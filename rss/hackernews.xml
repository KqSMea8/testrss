<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=hnrss.org%2Fnewest%3Fpoints%3D200&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://hnrss.org/newest?points=200" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dhnrss.org%252Fnewest%253Fpoints%253D200%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dhnrss.org%252Fnewest%253Fpoints%253D200%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>Hacker News: Newest</title>
<link>https://news.ycombinator.com/newest</link>
<description>Hacker News RSS</description>
<item>
<title>Worst Computer Bugs in History: Therac-25 (2017)</title>
<link>https://blog.bugsnag.com/bug-day-race-condition-therac-25/</link>
<guid isPermaLink="true" >https://blog.bugsnag.com/bug-day-race-condition-therac-25/</guid>
<description>&lt;blockquote readability=&quot;9.8878504672897&quot;&gt;
&lt;p&gt;The Worst Computer Bugs in History is a mini series to commemorate &lt;a href=&quot;https://blog.bugsnag.com/bug-day-2017/&quot;&gt;the discovery of the first computer bug&lt;/a&gt; seventy years ago. Although these stories are more extreme than most software bugs engineers will encounter during their careers, they are worth studying for the insights they can offer into software development and deployment. These computer bugs left a significant impact on the people who experienced them, and we hope they’ll offer valuable lessons we can all apply to our own work and projects. Read about other computer bugs in the series: &lt;a href=&quot;https://blog.bugsnag.com/bug-day-ariane-5-disaster/&quot;&gt;The Ariane 5 Disaster&lt;/a&gt;, the &lt;a href=&quot;https://blog.bugsnag.com/bug-day-mars-climate-orbiter/&quot;&gt;Mars Climate Orbiter&lt;/a&gt;, and &lt;a href=&quot;https://blog.bugsnag.com/bug-day-460m-loss/&quot;&gt;losing $460 million in 45 minutes&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The Therac-25 was a radiation therapy machine manufactured by AECL in the 80s, which offered a revolutionary dual treatment mode. It was also designed from the outset to use software based safety systems rather than hardware controls.&lt;/p&gt;
&lt;p&gt;The removal of these hardware safety measures had tragic consequences, as race conditions in the codebase led to the death of three patients, and caused debilitating injuries to at least three other patients. The manufacturer ultimately became the target of several lawsuits from families of the victims, and became subject to a Class I recall from the FDA, a situation which only happens if the agency believes there is significant risk of death or serious injury through continued use of a medical device.&lt;/p&gt;
&lt;h3 id=&quot;what-is-radiation&quot;&gt;What is radiation?&lt;/h3&gt;
&lt;p&gt;Radiation is toxic to living cells, and in large enough quantities will cause them to die. For example, cancerous cells can be killed by a dose of radiation which specifically targets the affected area. However, care must be taken to ensure that the dose is not too large, as this would kill healthy surrounding tissue, and could lead to serious injury or death for the patient.&lt;/p&gt;
&lt;p&gt;The Therac-25 was a linear accelerator with two modes of operation. Firstly, it could fire a beam of low-energy electrons, which do not penetrate far into the body, and are therefore well-suited at killing shallow tissues, such as in skin cancer. The second mode of operation delivers radiation via a beam of higher-energy X-Ray photons. These particles travel further and are best suited to treating deeper tissues, such as cancer of the lungs.&lt;/p&gt;
&lt;h3 id=&quot;revolutionary-design&quot;&gt;Revolutionary Design&lt;/h3&gt;
&lt;p&gt;Dual-mode operation was truly revolutionary at the time. Hospitals would not need to maintain two separate machines, reducing their maintenance costs, and logistics could be simplified, as patients would not need to be moved from one room to the next.&lt;/p&gt;
&lt;p&gt;The low-power mode used scanning magnets to spread the electron beam, whereas the high-power mode was activated by rotating four components into the beam. This process took around 8 seconds to complete, and afterwards, it would spread and direct a beam of the appropriate strength towards its target.&lt;/p&gt;
&lt;h3 id=&quot;software-not-hardware-for-safety-controls&quot;&gt;Software, not hardware, for safety controls&lt;/h3&gt;
&lt;p&gt;Therac-25 relied on software controls to switch between modes, rather than physical hardware. Preceding models used separate circuits to monitor radiation intensity, and hardware interlocks to ensure that spreading magnets were correctly positioned. Using software instead would in theory reduce complexity, and reduce manufacturing costs.&lt;/p&gt;
&lt;h3 id=&quot;malfunction-54-error-message&quot;&gt;Malfunction 54 error message&lt;/h3&gt;
&lt;p&gt;Over the course of several weeks, one radiology technician had become very quick at typing commands into the Therac-25 machine. One fateful day, she accidentally entered ‘x’ for X-Ray rather than ‘e’ for Electron, so pressed the up key to choose the correct mode. Upon starting the program, the machine shut down, displaying the error “Malfunction 54.” Due to the frequency at which other malfunctions occurred, and that “treatment pause” typically indicated a low-priority issue, the technician resumed treatment.&lt;/p&gt;
&lt;p&gt;The patient was receiving his 9th treatment, and immediately knew something had gone terribly wrong. He reported hearing a buzzing sound, which was later determined to be the machine delivering radiation at maximum capacity, and feeling as though someone had poured hot coffee over his bath.&lt;/p&gt;
&lt;p&gt;After a few days, the patient suffered paralysis due to radiation overexposure, and ultimately died of further complications. The manufacturer believed the root cause was due to an electrical shock, and the machine was put back into service despite an electric company verifying this was not the issue, and that similar incidents had been reported to AECL before.&lt;/p&gt;
&lt;h3 id=&quot;reproducing-the-error&quot;&gt;Reproducing the error&lt;/h3&gt;
&lt;p&gt;The bug was finally reproduced when the same technician operated the machine on another patient, who also died from radiation overexposure. The hospital physicist was convinced that there was an issue with the machine spreading magnets, and after a lot of trial and error, managed to reproduce the issue by performing data entry incredibly quickly.&lt;/p&gt;
&lt;p&gt;The dose of delivered radiation was so great that the physicist had to adjust the sensitivity of his detection equipment. The dose was in the range of 10-20,000 rads, which was over 100x the expected dose, and more than enough to kill a grown adult.&lt;/p&gt;
&lt;h3 id=&quot;race-conditions&quot;&gt;Race conditions&lt;/h3&gt;
&lt;p&gt;The operator’s intention was to use the low-power beam, whereas in reality the high-power beam had been used without the spreading magnets in place, delivering a much higher dose than expected. This was due to a race condition within the codebase, which had actually been present in the preceding model, Therac-20, but had been prevented by hardware safety controls.&lt;/p&gt;
&lt;p&gt;The software consisted of several routines running concurrently. Both the Data Entry and Keyboard Handler routines shared a single variable, which recorded whether the technician had completed entering commands.&lt;/p&gt;
&lt;p&gt;Once the data entry phase was marked complete, the magnet setting phase began. However, if a specific sequence of edits was applied in the Data Entry phase during the 8 second magnet setting phase, the setting was not applied to the machine hardware, due to the value of the completion variable. The UI would then display the wrong mode to the user, who would confirm the potentially lethal treatment.&lt;/p&gt;
&lt;p&gt;This bug had actually always been present in the Therac-20 codebase, a fact which was only discovered 2 months after the FDA recall. Hardware safety features on that model meant the error condition had never been detected, and the code was copied across to the Therac-25 with the cultural assumption that it had been battle-tested.&lt;/p&gt;
&lt;h3 id=&quot;byte-overflow&quot;&gt;Byte overflow&lt;/h3&gt;
&lt;p&gt;An additional concurrency bug caused the last known incident, which was due to overflow in a one-byte shared variable.&lt;/p&gt;
&lt;p&gt;Before firing an electron beam, an operator needs to position the machine precisely to target the treatment area. The parameters are then verified by the operator via keystrokes, and “set” pressed, to move the hardware to the correct position.&lt;/p&gt;
&lt;p&gt;During verification, the Class3 variable determines whether the hardware is configured correctly. A non-zero value indicates failure, whereas a zero value indicates that everything is setup correctly, and that treatment can proceed.&lt;/p&gt;
&lt;p&gt;Because the setup code ran hundreds of times and a byte can only hold 255 possible values, on the 256th attempt of setup, the shared variable would be set to 0.&lt;/p&gt;
&lt;p&gt;If at this exact time, the operator was unfortunate enough to hit the “set” button, the program would continue down a codepath which would fire a concentrated X-Ray beam, as the Class3 variable would indicate that the hardware was setup correctly. This did happen, and delivered a lethal dose of radiation to the patient.&lt;/p&gt;
&lt;h3 id=&quot;aftermath&quot;&gt;Aftermath&lt;/h3&gt;
&lt;p&gt;Worse still, an internal FDA memo stated that AECL had no formal software specifications or test plan for their device.&lt;/p&gt;
&lt;p&gt;Additionally, the software was not evaluated by independent testers, which may have helped combat cultural biases within the organization. A hardware simulator was also used for the majority of development, due to the difficulties of safely testing the actual hardware.&lt;/p&gt;
&lt;h3 id=&quot;takeaways&quot;&gt;Takeaways&lt;/h3&gt;
&lt;p&gt;There are several takeaway messages from the whole affair.&lt;/p&gt;
&lt;p&gt;Firstly, users will ignore cryptic error messages, particularly if they occur often. “Malfunction 54” does not convey the severity of the machine state, and the average user certainly won’t consult the accompanying physical manual to find out what it means.&lt;/p&gt;
&lt;p&gt;Secondly, usability can sometimes get in the way of safety. In this case it would have been preferable, although admittedly annoying, to have forced the user to re-enter commands in the case that they made an error, and to review the commands before executing.&lt;/p&gt;
&lt;p&gt;A final note is that in safety-critical systems, code should be subject to formal analysis from independent parties from those who developed it. Some level of automated testing at the unit level is also needed, rather than only testing the system as a whole.&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Therac-25 is an extreme example of what can go wrong with software systems, and the devastating consequences that bugs can have on regular people.&lt;/p&gt;
&lt;p&gt;Although most of us won’t work on safety-critical systems, software errors can still have a significant impact on our users. Most of us will have experienced a software failure during an important slideshow presentation, an app on our phones crashing in the middle of an activity, or a data breach that leaks our credentials to the entire internet.&lt;/p&gt;
&lt;p&gt;What’s the worst thing that could go wrong in your application?&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Our series on the Worst Software Bugs in History is in honor of &lt;a href=&quot;https://blog.bugsnag.com/bug-day-2017/&quot;&gt;Bug Day 2017&lt;/a&gt;. Seventy years ago, Grace Hopper discovered the first computer bug — a moth was stuck between relays in the Harvard Mark II computer she was working on. The notion of bugs was described in other fields previously, but the moth discovery was the first use of the term “debugging” in the field of computers.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Sources:&lt;br/&gt;http://courses.cs.vt.edu/cs3604/lib/Therac_25/Therac_1.html &lt;a href=&quot;https://en.wikipedia.org/wiki/Therac-25&quot;&gt;https://en.wikipedia.org/wiki/Therac-25&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 11 Aug 2018 16:24:39 +0000</pubDate>
<dc:creator>dangom</dc:creator>
<og:title>The Worst Computer Bugs in History: Race conditions in Therac-25</og:title>
<og:url>https://blog.bugsnag.com/bug-day-race-condition-therac-25/</og:url>
<og:type> article</og:type>
<og:image>https://blog.bugsnag.com/img/feature/therac-25.jpg</og:image>
<dc:format>text/html</dc:format>
<dc:identifier>https://blog.bugsnag.com/bug-day-race-condition-therac-25/</dc:identifier>
</item>
<item>
<title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
<link>https://tools.ietf.org/html/rfc8446</link>
<guid isPermaLink="true" >https://tools.ietf.org/html/rfc8446</guid>
<description>&lt;span class=&quot;pre noprint docinfo top&quot;&gt;[&lt;a href=&quot;https://tools.ietf.org/html/&quot; title=&quot;Document search and retrieval page&quot;&gt;Docs&lt;/a&gt;] [&lt;a href=&quot;https://tools.ietf.org/rfc/rfc8446.txt&quot; title=&quot;Plaintext version of this document&quot;&gt;txt&lt;/a&gt;|&lt;a href=&quot;https://tools.ietf.org/pdf/rfc8446&quot; title=&quot;PDF version of this document&quot;&gt;pdf&lt;/a&gt;] [&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-tls-tls13&quot; title=&quot;draft-ietf-tls-tls13&quot;&gt;draft-ietf-tls-...&lt;/a&gt;] [&lt;a href=&quot;https://datatracker.ietf.org/doc/rfc8446&quot; title=&quot;IESG Datatracker information for this document&quot;&gt;Tracker&lt;/a&gt;] [&lt;a href=&quot;https://datatracker.ietf.org/ipr/search/?rfc=8446&amp;amp;submit=rfc&quot; title=&quot;IPR disclosures related to this document&quot;&gt;IPR&lt;/a&gt;]&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;pre noprint docinfo&quot;&gt;PROPOSED STANDARD&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;
Internet Engineering Task Force (IETF)                       E. Rescorla
Request for Comments: 8446                                       Mozilla
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc5077&quot;&gt;5077&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;5246&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6961&quot;&gt;6961&lt;/a&gt;                                  August 2018
Updates: &lt;a href=&quot;https://tools.ietf.org/html/rfc5705&quot;&gt;5705&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot;&gt;6066&lt;/a&gt;
Category: Standards Track
ISSN: 2070-1721


        &lt;span class=&quot;h1&quot;&gt;The Transport Layer Security (TLS) Protocol Version 1.3&lt;/span&gt;

Abstract

   This document specifies version 1.3 of the Transport Layer Security
   (TLS) protocol.  TLS allows client/server applications to communicate
   over the Internet in a way that is designed to prevent eavesdropping,
   tampering, and message forgery.

   This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077,
   5246, and 6961.  This document also specifies new requirements for
   TLS 1.2 implementations.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc7841#section-2&quot;&gt;Section 2 of RFC 7841&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;https://www.rfc-editor.org/info/rfc8446&quot;&gt;https://www.rfc-editor.org/info/rfc8446&lt;/a&gt;.

















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                    [Page 1]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;https://trustee.ietf.org/license-info&quot;&gt;https://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

























&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                    [Page 2]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


Table of Contents

   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-1&quot;&gt;1&lt;/a&gt;. Introduction ....................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-6&quot;&gt;6&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-1.1&quot;&gt;1.1&lt;/a&gt;. Conventions and Terminology ................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-7&quot;&gt;7&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-1.2&quot;&gt;1.2&lt;/a&gt;. Major Differences from TLS 1.2 .............................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-8&quot;&gt;8&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-1.3&quot;&gt;1.3&lt;/a&gt;. Updates Affecting TLS 1.2 ..................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-9&quot;&gt;9&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-2&quot;&gt;2&lt;/a&gt;. Protocol Overview ..............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-10&quot;&gt;10&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-2.1&quot;&gt;2.1&lt;/a&gt;. Incorrect DHE Share .......................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-14&quot;&gt;14&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-2.2&quot;&gt;2.2&lt;/a&gt;. Resumption and Pre-Shared Key (PSK) .......................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-15&quot;&gt;15&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-2.3&quot;&gt;2.3&lt;/a&gt;. 0-RTT Data ................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-17&quot;&gt;17&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-3&quot;&gt;3&lt;/a&gt;. Presentation Language ..........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-19&quot;&gt;19&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-3.1&quot;&gt;3.1&lt;/a&gt;. Basic Block Size ..........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-19&quot;&gt;19&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-3.2&quot;&gt;3.2&lt;/a&gt;. Miscellaneous .............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-20&quot;&gt;20&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-3.3&quot;&gt;3.3&lt;/a&gt;. Numbers ...................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-20&quot;&gt;20&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-3.4&quot;&gt;3.4&lt;/a&gt;. Vectors ...................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-20&quot;&gt;20&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-3.5&quot;&gt;3.5&lt;/a&gt;. Enumerateds ...............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-21&quot;&gt;21&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-3.6&quot;&gt;3.6&lt;/a&gt;. Constructed Types .........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-22&quot;&gt;22&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-3.7&quot;&gt;3.7&lt;/a&gt;. Constants .................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-23&quot;&gt;23&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-3.8&quot;&gt;3.8&lt;/a&gt;. Variants ..................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-23&quot;&gt;23&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4&quot;&gt;4&lt;/a&gt;. Handshake Protocol .............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-24&quot;&gt;24&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1&quot;&gt;4.1&lt;/a&gt;. Key Exchange Messages .....................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-25&quot;&gt;25&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.1&quot;&gt;4.1.1&lt;/a&gt;. Cryptographic Negotiation ..........................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-26&quot;&gt;26&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.2&quot;&gt;4.1.2&lt;/a&gt;. Client Hello .......................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-27&quot;&gt;27&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.3&quot;&gt;4.1.3&lt;/a&gt;. Server Hello .......................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-31&quot;&gt;31&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.4&quot;&gt;4.1.4&lt;/a&gt;. Hello Retry Request ................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-33&quot;&gt;33&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2&quot;&gt;4.2&lt;/a&gt;. Extensions ................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-35&quot;&gt;35&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.1&quot;&gt;4.2.1&lt;/a&gt;. Supported Versions .................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-39&quot;&gt;39&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.2&quot;&gt;4.2.2&lt;/a&gt;. Cookie .............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-40&quot;&gt;40&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.3&quot;&gt;4.2.3&lt;/a&gt;. Signature Algorithms ...............................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-41&quot;&gt;41&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.4&quot;&gt;4.2.4&lt;/a&gt;. Certificate Authorities ............................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-45&quot;&gt;45&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.5&quot;&gt;4.2.5&lt;/a&gt;. OID Filters ........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-45&quot;&gt;45&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.6&quot;&gt;4.2.6&lt;/a&gt;. Post-Handshake Client Authentication ...............&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-47&quot;&gt;47&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.7&quot;&gt;4.2.7&lt;/a&gt;. Supported Groups ...................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-47&quot;&gt;47&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.8&quot;&gt;4.2.8&lt;/a&gt;. Key Share ..........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-48&quot;&gt;48&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.9&quot;&gt;4.2.9&lt;/a&gt;. Pre-Shared Key Exchange Modes ......................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-51&quot;&gt;51&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.10&quot;&gt;4.2.10&lt;/a&gt;. Early Data Indication .............................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-52&quot;&gt;52&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.11&quot;&gt;4.2.11&lt;/a&gt;. Pre-Shared Key Extension ..........................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-55&quot;&gt;55&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.3&quot;&gt;4.3&lt;/a&gt;. Server Parameters .........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-59&quot;&gt;59&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;. Encrypted Extensions ...............................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-60&quot;&gt;60&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.3.2&quot;&gt;4.3.2&lt;/a&gt;. Certificate Request ................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-60&quot;&gt;60&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4&quot;&gt;4.4&lt;/a&gt;. Authentication Messages ...................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-61&quot;&gt;61&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.1&quot;&gt;4.4.1&lt;/a&gt;. The Transcript Hash ................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-63&quot;&gt;63&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.2&quot;&gt;4.4.2&lt;/a&gt;. Certificate ........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-64&quot;&gt;64&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.3&quot;&gt;4.4.3&lt;/a&gt;. Certificate Verify .................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-69&quot;&gt;69&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.4&quot;&gt;4.4.4&lt;/a&gt;. Finished ...........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-71&quot;&gt;71&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.5&quot;&gt;4.5&lt;/a&gt;. End of Early Data .........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-72&quot;&gt;72&lt;/a&gt;





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                    [Page 3]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6&quot;&gt;4.6&lt;/a&gt;. Post-Handshake Messages ...................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-73&quot;&gt;73&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.1&quot;&gt;4.6.1&lt;/a&gt;. New Session Ticket Message .........................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-73&quot;&gt;73&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.2&quot;&gt;4.6.2&lt;/a&gt;. Post-Handshake Authentication ......................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-75&quot;&gt;75&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.3&quot;&gt;4.6.3&lt;/a&gt;. Key and Initialization Vector Update ...............&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-76&quot;&gt;76&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5&quot;&gt;5&lt;/a&gt;. Record Protocol ................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-77&quot;&gt;77&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5.1&quot;&gt;5.1&lt;/a&gt;. Record Layer ..............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-78&quot;&gt;78&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5.2&quot;&gt;5.2&lt;/a&gt;. Record Payload Protection .................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-80&quot;&gt;80&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5.3&quot;&gt;5.3&lt;/a&gt;. Per-Record Nonce ..........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-82&quot;&gt;82&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5.4&quot;&gt;5.4&lt;/a&gt;. Record Padding ............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-83&quot;&gt;83&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5.5&quot;&gt;5.5&lt;/a&gt;. Limits on Key Usage .......................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-84&quot;&gt;84&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-6&quot;&gt;6&lt;/a&gt;. Alert Protocol .................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-85&quot;&gt;85&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-6.1&quot;&gt;6.1&lt;/a&gt;. Closure Alerts ............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-87&quot;&gt;87&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-6.2&quot;&gt;6.2&lt;/a&gt;. Error Alerts ..............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-88&quot;&gt;88&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7&quot;&gt;7&lt;/a&gt;. Cryptographic Computations .....................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-90&quot;&gt;90&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.1&quot;&gt;7.1&lt;/a&gt;. Key Schedule ..............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-91&quot;&gt;91&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.2&quot;&gt;7.2&lt;/a&gt;. Updating Traffic Secrets ..................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-94&quot;&gt;94&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.3&quot;&gt;7.3&lt;/a&gt;. Traffic Key Calculation ...................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-95&quot;&gt;95&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.4&quot;&gt;7.4&lt;/a&gt;. (EC)DHE Shared Secret Calculation .........................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-95&quot;&gt;95&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.4.1&quot;&gt;7.4.1&lt;/a&gt;. Finite Field Diffie-Hellman ........................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-95&quot;&gt;95&lt;/a&gt;
           &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.4.2&quot;&gt;7.4.2&lt;/a&gt;. Elliptic Curve Diffie-Hellman ......................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-96&quot;&gt;96&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.5&quot;&gt;7.5&lt;/a&gt;. Exporters .................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-97&quot;&gt;97&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-8&quot;&gt;8&lt;/a&gt;. 0-RTT and Anti-Replay ..........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-98&quot;&gt;98&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-8.1&quot;&gt;8.1&lt;/a&gt;. Single-Use Tickets ........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-99&quot;&gt;99&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-8.2&quot;&gt;8.2&lt;/a&gt;. Client Hello Recording ....................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-99&quot;&gt;99&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-8.3&quot;&gt;8.3&lt;/a&gt;. Freshness Checks .........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-101&quot;&gt;101&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-9&quot;&gt;9&lt;/a&gt;. Compliance Requirements .......................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-102&quot;&gt;102&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-9.1&quot;&gt;9.1&lt;/a&gt;. Mandatory-to-Implement Cipher Suites .....................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-102&quot;&gt;102&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-9.2&quot;&gt;9.2&lt;/a&gt;. Mandatory-to-Implement Extensions ........................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-103&quot;&gt;103&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-9.3&quot;&gt;9.3&lt;/a&gt;. Protocol Invariants ......................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-104&quot;&gt;104&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-10&quot;&gt;10&lt;/a&gt;. Security Considerations ......................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-106&quot;&gt;106&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-11&quot;&gt;11&lt;/a&gt;. IANA Considerations ..........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-106&quot;&gt;106&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-12&quot;&gt;12&lt;/a&gt;. References ...................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-109&quot;&gt;109&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-12.1&quot;&gt;12.1&lt;/a&gt;. Normative References ....................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-109&quot;&gt;109&lt;/a&gt;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-12.2&quot;&gt;12.2&lt;/a&gt;. Informative References ..................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-112&quot;&gt;112&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. State Machine ........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-120&quot;&gt;120&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-A.1&quot;&gt;A.1&lt;/a&gt;. Client ....................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-120&quot;&gt;120&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-A.2&quot;&gt;A.2&lt;/a&gt;. Server ....................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-121&quot;&gt;121&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Protocol Data Structures and Constant Values .........&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-122&quot;&gt;122&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.1&quot;&gt;B.1&lt;/a&gt;. Record Layer ..............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-122&quot;&gt;122&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.2&quot;&gt;B.2&lt;/a&gt;. Alert Messages ............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-123&quot;&gt;123&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3&quot;&gt;B.3&lt;/a&gt;. Handshake Protocol ........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-124&quot;&gt;124&lt;/a&gt;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.1&quot;&gt;B.3.1&lt;/a&gt;. Key Exchange Messages .................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-125&quot;&gt;125&lt;/a&gt;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.2&quot;&gt;B.3.2&lt;/a&gt;. Server Parameters Messages ............................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-131&quot;&gt;131&lt;/a&gt;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.3&quot;&gt;B.3.3&lt;/a&gt;. Authentication Messages ...............................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-132&quot;&gt;132&lt;/a&gt;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.4&quot;&gt;B.3.4&lt;/a&gt;. Ticket Establishment ..................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-132&quot;&gt;132&lt;/a&gt;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.5&quot;&gt;B.3.5&lt;/a&gt;. Updating Keys .........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-133&quot;&gt;133&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.4&quot;&gt;B.4&lt;/a&gt;. Cipher Suites .............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-133&quot;&gt;133&lt;/a&gt;




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                    [Page 4]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. Implementation Notes .................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-134&quot;&gt;134&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C.1&quot;&gt;C.1&lt;/a&gt;. Random Number Generation and Seeding ......................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-134&quot;&gt;134&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C.2&quot;&gt;C.2&lt;/a&gt;. Certificates and Authentication ...........................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-135&quot;&gt;135&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C.3&quot;&gt;C.3&lt;/a&gt;. Implementation Pitfalls ...................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-135&quot;&gt;135&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C.4&quot;&gt;C.4&lt;/a&gt;. Client Tracking Prevention ................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-137&quot;&gt;137&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C.5&quot;&gt;C.5&lt;/a&gt;. Unauthenticated Operation .................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-137&quot;&gt;137&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D&quot;&gt;Appendix D&lt;/a&gt;. Backward Compatibility ...............................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-138&quot;&gt;138&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.1&quot;&gt;D.1&lt;/a&gt;. Negotiating with an Older Server ..........................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-139&quot;&gt;139&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.2&quot;&gt;D.2&lt;/a&gt;. Negotiating with an Older Client ..........................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-139&quot;&gt;139&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.3&quot;&gt;D.3&lt;/a&gt;. 0-RTT Backward Compatibility ..............................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-140&quot;&gt;140&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.4&quot;&gt;D.4&lt;/a&gt;. Middlebox Compatibility Mode ..............................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-140&quot;&gt;140&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.5&quot;&gt;D.5&lt;/a&gt;. Security Restrictions Related to Backward Compatibility ...&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-141&quot;&gt;141&lt;/a&gt;
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E&quot;&gt;Appendix E&lt;/a&gt;. Overview of Security Properties ......................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-142&quot;&gt;142&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1&quot;&gt;E.1&lt;/a&gt;. Handshake .................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-142&quot;&gt;142&lt;/a&gt;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1.1&quot;&gt;E.1.1&lt;/a&gt;. Key Derivation and HKDF ...............................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-145&quot;&gt;145&lt;/a&gt;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1.2&quot;&gt;E.1.2&lt;/a&gt;. Client Authentication .................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-146&quot;&gt;146&lt;/a&gt;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1.3&quot;&gt;E.1.3&lt;/a&gt;. 0-RTT .................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-146&quot;&gt;146&lt;/a&gt;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1.4&quot;&gt;E.1.4&lt;/a&gt;. Exporter Independence .................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-146&quot;&gt;146&lt;/a&gt;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1.5&quot;&gt;E.1.5&lt;/a&gt;. Post-Compromise Security ..............................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-146&quot;&gt;146&lt;/a&gt;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1.6&quot;&gt;E.1.6&lt;/a&gt;. External References ...................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-147&quot;&gt;147&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.2&quot;&gt;E.2&lt;/a&gt;. Record Layer ..............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-147&quot;&gt;147&lt;/a&gt;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.2.1&quot;&gt;E.2.1&lt;/a&gt;. External References ...................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-148&quot;&gt;148&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.3&quot;&gt;E.3&lt;/a&gt;. Traffic Analysis ..........................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-148&quot;&gt;148&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.4&quot;&gt;E.4&lt;/a&gt;. Side-Channel Attacks ......................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-149&quot;&gt;149&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.5&quot;&gt;E.5&lt;/a&gt;. Replay Attacks on 0-RTT ...................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-150&quot;&gt;150&lt;/a&gt;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.5.1&quot;&gt;E.5.1&lt;/a&gt;. Replay and Exporters ..................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-151&quot;&gt;151&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.6&quot;&gt;E.6&lt;/a&gt;. PSK Identity Exposure .....................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-152&quot;&gt;152&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.7&quot;&gt;E.7&lt;/a&gt;. Sharing PSKs ..............................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-152&quot;&gt;152&lt;/a&gt;
     &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.8&quot;&gt;E.8&lt;/a&gt;. Attacks on Static RSA .....................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-152&quot;&gt;152&lt;/a&gt;
   Contributors .....................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-153&quot;&gt;153&lt;/a&gt;
   Author's Address .................................................&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#page-160&quot;&gt;160&lt;/a&gt;




















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                    [Page 5]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-1&quot; id=&quot;section-1&quot;&gt;1&lt;/a&gt;.  Introduction&lt;/span&gt;

   The primary goal of TLS is to provide a secure channel between two
   communicating peers; the only requirement from the underlying
   transport is a reliable, in-order data stream.  Specifically, the
   secure channel should provide the following properties:

   -  Authentication: The server side of the channel is always
      authenticated; the client side is optionally authenticated.
      Authentication can happen via asymmetric cryptography (e.g., RSA
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-RSA&quot; title=&quot;&amp;quot;A Method for Obtaining Digital Signatures and Public-Key Cryptosystems&amp;quot;&quot;&gt;RSA&lt;/a&gt;], the Elliptic Curve Digital Signature Algorithm (ECDSA)
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-ECDSA&quot; title=&quot;&amp;quot;Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)&amp;quot;&quot;&gt;ECDSA&lt;/a&gt;], or the Edwards-Curve Digital Signature Algorithm (EdDSA)
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc8032&quot; title=&quot;&amp;quot;Edwards-Curve Digital Signature Algorithm (EdDSA)&amp;quot;&quot;&gt;RFC8032&lt;/a&gt;]) or a symmetric pre-shared key (PSK).

   -  Confidentiality: Data sent over the channel after establishment is
      only visible to the endpoints.  TLS does not hide the length of
      the data it transmits, though endpoints are able to pad TLS
      records in order to obscure lengths and improve protection against
      traffic analysis techniques.

   -  Integrity: Data sent over the channel after establishment cannot
      be modified by attackers without detection.

   These properties should be true even in the face of an attacker who
   has complete control of the network, as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3552&quot; title=&quot;&amp;quot;Guidelines for Writing RFC Text on Security Considerations&amp;quot;&quot;&gt;RFC3552&lt;/a&gt;].  See
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E&quot;&gt;Appendix E&lt;/a&gt; for a more complete statement of the relevant security
   properties.

   TLS consists of two primary components:

   -  A handshake protocol (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4&quot;&gt;Section 4&lt;/a&gt;) that authenticates the
      communicating parties, negotiates cryptographic modes and
      parameters, and establishes shared keying material.  The handshake
      protocol is designed to resist tampering; an active attacker
      should not be able to force the peers to negotiate different
      parameters than they would if the connection were not under
      attack.

   -  A record protocol (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5&quot;&gt;Section 5&lt;/a&gt;) that uses the parameters established
      by the handshake protocol to protect traffic between the
      communicating peers.  The record protocol divides traffic up into
      a series of records, each of which is independently protected
      using the traffic keys.








&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                    [Page 6]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   TLS is application protocol independent; higher-level protocols can
   layer on top of TLS transparently.  The TLS standard, however, does
   not specify how protocols add security with TLS; how to initiate TLS
   handshaking and how to interpret the authentication certificates
   exchanged are left to the judgment of the designers and implementors
   of protocols that run on top of TLS.

   This document defines TLS version 1.3.  While TLS 1.3 is not directly
   compatible with previous versions, all versions of TLS incorporate a
   versioning mechanism which allows clients and servers to
   interoperably negotiate a common version if one is supported by both
   peers.

   This document supersedes and obsoletes previous versions of TLS,
   including version 1.2 [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot; title=&quot;&amp;quot;The Transport Layer Security (TLS) Protocol Version 1.2&amp;quot;&quot;&gt;RFC5246&lt;/a&gt;].  It also obsoletes the TLS ticket
   mechanism defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5077&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Session Resumption without Server-Side State&amp;quot;&quot;&gt;RFC5077&lt;/a&gt;] and replaces it with the mechanism
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;.  Because TLS 1.3 changes the way keys are
   derived, it updates [&lt;a href=&quot;https://tools.ietf.org/html/rfc5705&quot; title=&quot;&amp;quot;Keying Material Exporters for Transport Layer Security (TLS)&amp;quot;&quot;&gt;RFC5705&lt;/a&gt;] as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.5&quot;&gt;Section 7.5&lt;/a&gt;.  It also
   changes how Online Certificate Status Protocol (OCSP) messages are
   carried and therefore updates [&lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Extensions: Extension Definitions&amp;quot;&quot;&gt;RFC6066&lt;/a&gt;] and obsoletes [&lt;a href=&quot;https://tools.ietf.org/html/rfc6961&quot; title=&quot;&amp;quot;The Transport Layer Security (TLS) Multiple Certificate Status Request Extension&amp;quot;&quot;&gt;RFC6961&lt;/a&gt;] as
   described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.2.1&quot;&gt;Section 4.4.2.1&lt;/a&gt;.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-1.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-1.1&quot; id=&quot;section-1.1&quot;&gt;1.1&lt;/a&gt;.  Conventions and Terminology&lt;/span&gt;

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
   &quot;OPTIONAL&quot; in this document are to be interpreted as described in
   &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot; title=&quot;&amp;quot;Key words for use in RFCs to Indicate Requirement Levels&amp;quot;&quot;&gt;RFC2119&lt;/a&gt;] [&lt;a href=&quot;https://tools.ietf.org/html/rfc8174&quot; title=&quot;&amp;quot;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&amp;quot;&quot;&gt;RFC8174&lt;/a&gt;] when, and only when, they appear in all
   capitals, as shown here.

   The following terms are used:

   client:  The endpoint initiating the TLS connection.

   connection:  A transport-layer connection between two endpoints.

   endpoint:  Either the client or server of the connection.

   handshake:  An initial negotiation between client and server that
      establishes the parameters of their subsequent interactions
      within TLS.

   peer:  An endpoint.  When discussing a particular endpoint, &quot;peer&quot;
      refers to the endpoint that is not the primary subject of
      discussion.






&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                    [Page 7]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   receiver:  An endpoint that is receiving records.

   sender:  An endpoint that is transmitting records.

   server:  The endpoint that did not initiate the TLS connection.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-1.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-1.2&quot; id=&quot;section-1.2&quot;&gt;1.2&lt;/a&gt;.  Major Differences from TLS 1.2&lt;/span&gt;

   The following is a list of the major functional differences between
   TLS 1.2 and TLS 1.3.  It is not intended to be exhaustive, and there
   are many minor differences.

   -  The list of supported symmetric encryption algorithms has been
      pruned of all algorithms that are considered legacy.  Those that
      remain are all Authenticated Encryption with Associated Data
      (AEAD) algorithms.  The cipher suite concept has been changed to
      separate the authentication and key exchange mechanisms from the
      record protection algorithm (including secret key length) and a
      hash to be used with both the key derivation function and
      handshake message authentication code (MAC).

   -  A zero round-trip time (0-RTT) mode was added, saving a round trip
      at connection setup for some application data, at the cost of
      certain security properties.

   -  Static RSA and Diffie-Hellman cipher suites have been removed; all
      public-key based key exchange mechanisms now provide forward
      secrecy.

   -  All handshake messages after the ServerHello are now encrypted.
      The newly introduced EncryptedExtensions message allows various
      extensions previously sent in the clear in the ServerHello to also
      enjoy confidentiality protection.

   -  The key derivation functions have been redesigned.  The new design
      allows easier analysis by cryptographers due to their improved key
      separation properties.  The HMAC-based Extract-and-Expand Key
      Derivation Function (HKDF) is used as an underlying primitive.

   -  The handshake state machine has been significantly restructured to
      be more consistent and to remove superfluous messages such as
      ChangeCipherSpec (except when needed for middlebox compatibility).

   -  Elliptic curve algorithms are now in the base spec, and new
      signature algorithms, such as EdDSA, are included.  TLS 1.3
      removed point format negotiation in favor of a single point format
      for each curve.




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                    [Page 8]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   -  Other cryptographic improvements were made, including changing the
      RSA padding to use the RSA Probabilistic Signature Scheme
      (RSASSA-PSS), and the removal of compression, the Digital
      Signature Algorithm (DSA), and custom Ephemeral Diffie-Hellman
      (DHE) groups.

   -  The TLS 1.2 version negotiation mechanism has been deprecated in
      favor of a version list in an extension.  This increases
      compatibility with existing servers that incorrectly implemented
      version negotiation.

   -  Session resumption with and without server-side state as well as
      the PSK-based cipher suites of earlier TLS versions have been
      replaced by a single new PSK exchange.

   -  References have been updated to point to the updated versions of
      RFCs, as appropriate (e.g., &lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot;&gt;RFC 5280&lt;/a&gt; rather than &lt;a href=&quot;https://tools.ietf.org/html/rfc3280&quot;&gt;RFC 3280&lt;/a&gt;).

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-1.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-1.3&quot; id=&quot;section-1.3&quot;&gt;1.3&lt;/a&gt;.  Updates Affecting TLS 1.2&lt;/span&gt;

   This document defines several changes that optionally affect
   implementations of TLS 1.2, including those which do not also support
   TLS 1.3:

   -  A version downgrade protection mechanism is described in
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.3&quot;&gt;Section 4.1.3&lt;/a&gt;.

   -  RSASSA-PSS signature schemes are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;.

   -  The &quot;supported_versions&quot; ClientHello extension can be used to
      negotiate the version of TLS to use, in preference to the
      legacy_version field of the ClientHello.

   -  The &quot;signature_algorithms_cert&quot; extension allows a client to
      indicate which signature algorithms it can validate in X.509
      certificates.

   Additionally, this document clarifies some compliance requirements
   for earlier versions of TLS; see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-9.3&quot;&gt;Section 9.3&lt;/a&gt;.












&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                    [Page 9]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-2&quot; id=&quot;section-2&quot;&gt;2&lt;/a&gt;.  Protocol Overview&lt;/span&gt;

   The cryptographic parameters used by the secure channel are produced
   by the TLS handshake protocol.  This sub-protocol of TLS is used by
   the client and server when first communicating with each other.  The
   handshake protocol allows peers to negotiate a protocol version,
   select cryptographic algorithms, optionally authenticate each other,
   and establish shared secret keying material.  Once the handshake is
   complete, the peers use the established keys to protect the
   application-layer traffic.

   A failure of the handshake or other protocol error triggers the
   termination of the connection, optionally preceded by an alert
   message (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-6&quot;&gt;Section 6&lt;/a&gt;).

   TLS supports three basic key exchange modes:

   -  (EC)DHE (Diffie-Hellman over either finite fields or elliptic
      curves)

   -  PSK-only

   -  PSK with (EC)DHE




























&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 10]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Figure 1 below shows the basic full TLS handshake:

       Client                                           Server

Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     v + pre_shared_key*       --------&amp;gt;
                                                  ServerHello  ^ Key
                                                 + key_share*  | Exch
                                            + pre_shared_key*  v
                                        {EncryptedExtensions}  ^  Server
                                        {CertificateRequest*}  v  Params
                                               {Certificate*}  ^
                                         {CertificateVerify*}  | Auth
                                                   {Finished}  v
                               &amp;lt;--------  [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}              --------&amp;gt;
       [Application Data]      &amp;lt;-------&amp;gt;  [Application Data]

              +  Indicates noteworthy extensions sent in the
                 previously noted message.

              *  Indicates optional or situation-dependent
                 messages/extensions that are not always sent.

              {} Indicates messages protected using keys
                 derived from a [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-sender&quot;&gt;sender&lt;/a&gt;]_handshake_traffic_secret.

              [] Indicates messages protected using keys
                 derived from [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-sender&quot;&gt;sender&lt;/a&gt;]_application_traffic_secret_N.

               Figure 1: Message Flow for Full TLS Handshake

   The handshake can be thought of as having three phases (indicated in
   the diagram above):

   -  Key Exchange: Establish shared keying material and select the
      cryptographic parameters.  Everything after this phase is
      encrypted.

   -  Server Parameters: Establish other handshake parameters
      (whether the client is authenticated, application-layer protocol
      support, etc.).




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 11]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   -  Authentication: Authenticate the server (and, optionally, the
      client) and provide key confirmation and handshake integrity.

   In the Key Exchange phase, the client sends the ClientHello
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt;) message, which contains a random nonce
   (ClientHello.random); its offered protocol versions; a list of
   symmetric cipher/HKDF hash pairs; either a set of Diffie-Hellman key
   shares (in the &quot;key_share&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.8&quot;&gt;Section 4.2.8&lt;/a&gt;) extension), a set of
   pre-shared key labels (in the &quot;pre_shared_key&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.11&quot;&gt;Section 4.2.11&lt;/a&gt;)
   extension), or both; and potentially additional extensions.
   Additional fields and/or messages may also be present for middlebox
   compatibility.

   The server processes the ClientHello and determines the appropriate
   cryptographic parameters for the connection.  It then responds with
   its own ServerHello (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.3&quot;&gt;Section 4.1.3&lt;/a&gt;), which indicates the negotiated
   connection parameters.  The combination of the ClientHello and the
   ServerHello determines the shared keys.  If (EC)DHE key establishment
   is in use, then the ServerHello contains a &quot;key_share&quot; extension with
   the server's ephemeral Diffie-Hellman share; the server's share MUST
   be in the same group as one of the client's shares.  If PSK key
   establishment is in use, then the ServerHello contains a
   &quot;pre_shared_key&quot; extension indicating which of the client's offered
   PSKs was selected.  Note that implementations can use (EC)DHE and PSK
   together, in which case both extensions will be supplied.

   The server then sends two messages to establish the Server
   Parameters:

   EncryptedExtensions:  responses to ClientHello extensions that are
      not required to determine the cryptographic parameters, other than
      those that are specific to individual certificates.
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;]

   CertificateRequest:  if certificate-based client authentication is
      desired, the desired parameters for that certificate.  This
      message is omitted if client authentication is not desired.
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt;]













&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 12]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Finally, the client and server exchange Authentication messages.  TLS
   uses the same set of messages every time that certificate-based
   authentication is needed.  (PSK-based authentication happens as a
   side effect of key exchange.)  Specifically:

   Certificate:  The certificate of the endpoint and any per-certificate
      extensions.  This message is omitted by the server if not
      authenticating with a certificate and by the client if the server
      did not send CertificateRequest (thus indicating that the client
      should not authenticate with a certificate).  Note that if raw
      public keys [&lt;a href=&quot;https://tools.ietf.org/html/rfc7250&quot; title=&quot;&amp;quot;Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)&amp;quot;&quot;&gt;RFC7250&lt;/a&gt;] or the cached information extension
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc7924&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Cached Information Extension&amp;quot;&quot;&gt;RFC7924&lt;/a&gt;] are in use, then this message will not contain a
      certificate but rather some other value corresponding to the
      server's long-term key.  [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.2&quot;&gt;Section 4.4.2&lt;/a&gt;]

   CertificateVerify:  A signature over the entire handshake using the
      private key corresponding to the public key in the Certificate
      message.  This message is omitted if the endpoint is not
      authenticating via a certificate.  [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.3&quot;&gt;Section 4.4.3&lt;/a&gt;]

   Finished:  A MAC (Message Authentication Code) over the entire
      handshake.  This message provides key confirmation, binds the
      endpoint's identity to the exchanged keys, and in PSK mode also
      authenticates the handshake.  [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.4&quot;&gt;Section 4.4.4&lt;/a&gt;]

   Upon receiving the server's messages, the client responds with its
   Authentication messages, namely Certificate and CertificateVerify (if
   requested), and Finished.

   At this point, the handshake is complete, and the client and server
   derive the keying material required by the record layer to exchange
   application-layer data protected through authenticated encryption.
   Application Data MUST NOT be sent prior to sending the Finished
   message, except as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;.  Note that while the
   server may send Application Data prior to receiving the client's
   Authentication messages, any data sent at that point is, of course,
   being sent to an unauthenticated peer.














&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 13]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-2.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-2.1&quot; id=&quot;section-2.1&quot;&gt;2.1&lt;/a&gt;.  Incorrect DHE Share&lt;/span&gt;

   If the client has not provided a sufficient &quot;key_share&quot; extension
   (e.g., it includes only DHE or ECDHE groups unacceptable to or
   unsupported by the server), the server corrects the mismatch with a
   HelloRetryRequest and the client needs to restart the handshake with
   an appropriate &quot;key_share&quot; extension, as shown in Figure 2.  If no
   common cryptographic parameters can be negotiated, the server MUST
   abort the handshake with an appropriate alert.

        Client                                               Server

        ClientHello
        + key_share             --------&amp;gt;
                                                  HelloRetryRequest
                                &amp;lt;--------               + key_share
        ClientHello
        + key_share             --------&amp;gt;
                                                        ServerHello
                                                        + key_share
                                              {EncryptedExtensions}
                                              {CertificateRequest*}
                                                     {Certificate*}
                                               {CertificateVerify*}
                                                         {Finished}
                                &amp;lt;--------       [Application Data*]
        {Certificate*}
        {CertificateVerify*}
        {Finished}              --------&amp;gt;
        [Application Data]      &amp;lt;-------&amp;gt;        [Application Data]

             Figure 2: Message Flow for a Full Handshake with
                           Mismatched Parameters

   Note: The handshake transcript incorporates the initial
   ClientHello/HelloRetryRequest exchange; it is not reset with the
   new ClientHello.

   TLS also allows several optimized variants of the basic handshake, as
   described in the following sections.











&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 14]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-2.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-2.2&quot; id=&quot;section-2.2&quot;&gt;2.2&lt;/a&gt;.  Resumption and Pre-Shared Key (PSK)&lt;/span&gt;

   Although TLS PSKs can be established out of band, PSKs can also be
   established in a previous connection and then used to establish a new
   connection (&quot;session resumption&quot; or &quot;resuming&quot; with a PSK).  Once a
   handshake has completed, the server can send the client a PSK
   identity that corresponds to a unique key derived from the initial
   handshake (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.1&quot;&gt;Section 4.6.1&lt;/a&gt;).  The client can then use that PSK
   identity in future handshakes to negotiate the use of the associated
   PSK.  If the server accepts the PSK, then the security context of the
   new connection is cryptographically tied to the original connection
   and the key derived from the initial handshake is used to bootstrap
   the cryptographic state instead of a full handshake.  In TLS 1.2 and
   below, this functionality was provided by &quot;session IDs&quot; and &quot;session
   tickets&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc5077&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Session Resumption without Server-Side State&amp;quot;&quot;&gt;RFC5077&lt;/a&gt;].  Both mechanisms are obsoleted in TLS 1.3.

   PSKs can be used with (EC)DHE key exchange in order to provide
   forward secrecy in combination with shared keys, or can be used
   alone, at the cost of losing forward secrecy for the application
   data.































&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 15]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Figure 3 shows a pair of handshakes in which the first handshake
   establishes a PSK and the second handshake uses it:

          Client                                               Server

   Initial Handshake:
          ClientHello
          + key_share               --------&amp;gt;
                                                          ServerHello
                                                          + key_share
                                                {EncryptedExtensions}
                                                {CertificateRequest*}
                                                       {Certificate*}
                                                 {CertificateVerify*}
                                                           {Finished}
                                    &amp;lt;--------     [Application Data*]
          {Certificate*}
          {CertificateVerify*}
          {Finished}                --------&amp;gt;
                                    &amp;lt;--------      [NewSessionTicket]
          [Application Data]        &amp;lt;-------&amp;gt;      [Application Data]


   Subsequent Handshake:
          ClientHello
          + key_share*
          + pre_shared_key          --------&amp;gt;
                                                          ServerHello
                                                     + pre_shared_key
                                                         + key_share*
                                                {EncryptedExtensions}
                                                           {Finished}
                                    &amp;lt;--------     [Application Data*]
          {Finished}                --------&amp;gt;
          [Application Data]        &amp;lt;-------&amp;gt;      [Application Data]

               Figure 3: Message Flow for Resumption and PSK

   As the server is authenticating via a PSK, it does not send a
   Certificate or a CertificateVerify message.  When a client offers
   resumption via a PSK, it SHOULD also supply a &quot;key_share&quot; extension
   to the server to allow the server to decline resumption and fall back
   to a full handshake, if needed.  The server responds with a
   &quot;pre_shared_key&quot; extension to negotiate the use of PSK key
   establishment and can (as shown here) respond with a &quot;key_share&quot;
   extension to do (EC)DHE key establishment, thus providing forward
   secrecy.




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 16]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   When PSKs are provisioned out of band, the PSK identity and the KDF
   hash algorithm to be used with the PSK MUST also be provisioned.

   Note:  When using an out-of-band provisioned pre-shared secret, a
      critical consideration is using sufficient entropy during the key
      generation, as discussed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4086&quot; title=&quot;&amp;quot;Randomness Requirements for Security&amp;quot;&quot;&gt;RFC4086&lt;/a&gt;].  Deriving a shared secret
      from a password or other low-entropy sources is not secure.  A
      low-entropy secret, or password, is subject to dictionary attacks
      based on the PSK binder.  The specified PSK authentication is not
      a strong password-based authenticated key exchange even when used
      with Diffie-Hellman key establishment.  Specifically, it does not
      prevent an attacker that can observe the handshake from performing
      a brute-force attack on the password/pre-shared key.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-2.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-2.3&quot; id=&quot;section-2.3&quot;&gt;2.3&lt;/a&gt;.  0-RTT Data&lt;/span&gt;

   When clients and servers share a PSK (either obtained externally or
   via a previous handshake), TLS 1.3 allows clients to send data on the
   first flight (&quot;early data&quot;).  The client uses the PSK to authenticate
   the server and to encrypt the early data.

   As shown in Figure 4, the 0-RTT data is just added to the 1-RTT
   handshake in the first flight.  The rest of the handshake uses the
   same messages as for a 1-RTT handshake with PSK resumption.



























&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 17]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


         Client                                               Server

         ClientHello
         + early_data
         + key_share*
         + psk_key_exchange_modes
         + pre_shared_key
         (Application Data*)     --------&amp;gt;
                                                         ServerHello
                                                    + pre_shared_key
                                                        + key_share*
                                               {EncryptedExtensions}
                                                       + early_data*
                                                          {Finished}
                                 &amp;lt;--------       [Application Data*]
         (EndOfEarlyData)
         {Finished}              --------&amp;gt;
         [Application Data]      &amp;lt;-------&amp;gt;        [Application Data]

               +  Indicates noteworthy extensions sent in the
                  previously noted message.

               *  Indicates optional or situation-dependent
                  messages/extensions that are not always sent.

               () Indicates messages protected using keys
                  derived from a client_early_traffic_secret.

               {} Indicates messages protected using keys
                  derived from a [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-sender&quot;&gt;sender&lt;/a&gt;]_handshake_traffic_secret.

               [] Indicates messages protected using keys
                  derived from [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-sender&quot;&gt;sender&lt;/a&gt;]_application_traffic_secret_N.

               Figure 4: Message Flow for a 0-RTT Handshake
















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 18]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   IMPORTANT NOTE: The security properties for 0-RTT data are weaker
   than those for other kinds of TLS data.  Specifically:

   1.  This data is not forward secret, as it is encrypted solely under
       keys derived using the offered PSK.

   2.  There are no guarantees of non-replay between connections.
       Protection against replay for ordinary TLS 1.3 1-RTT data is
       provided via the server's Random value, but 0-RTT data does not
       depend on the ServerHello and therefore has weaker guarantees.
       This is especially relevant if the data is authenticated either
       with TLS client authentication or inside the application
       protocol.  The same warnings apply to any use of the
       early_exporter_master_secret.

   0-RTT data cannot be duplicated within a connection (i.e., the server
   will not process the same data twice for the same connection), and an
   attacker will not be able to make 0-RTT data appear to be 1-RTT data
   (because it is protected with different keys).  &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.5&quot;&gt;Appendix E.5&lt;/a&gt; contains
   a description of potential attacks, and &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-8&quot;&gt;Section 8&lt;/a&gt; describes
   mechanisms which the server can use to limit the impact of replay.

&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-3&quot; id=&quot;section-3&quot;&gt;3&lt;/a&gt;.  Presentation Language&lt;/span&gt;

   This document deals with the formatting of data in an external
   representation.  The following very basic and somewhat casually
   defined presentation syntax will be used.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-3.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-3.1&quot; id=&quot;section-3.1&quot;&gt;3.1&lt;/a&gt;.  Basic Block Size&lt;/span&gt;

   The representation of all data items is explicitly specified.  The
   basic data block size is one byte (i.e., 8 bits).  Multiple-byte data
   items are concatenations of bytes, from left to right, from top to
   bottom.  From the byte stream, a multi-byte item (a numeric in the
   following example) is formed (using C notation) by:

      value = (byte[0] &amp;lt;&amp;lt; 8*(n-1)) | (byte[1] &amp;lt;&amp;lt; 8*(n-2)) |
              ... | byte[n-1];

   This byte ordering for multi-byte values is the commonplace network
   byte order or big-endian format.










&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 19]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-3.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-3.2&quot; id=&quot;section-3.2&quot;&gt;3.2&lt;/a&gt;.  Miscellaneous&lt;/span&gt;

   Comments begin with &quot;/*&quot; and end with &quot;*/&quot;.

   Optional components are denoted by enclosing them in &quot;[[ ]]&quot; (double
   brackets).

   Single-byte entities containing uninterpreted data are of
   type opaque.

   A type alias T' for an existing type T is defined by:

      T T';

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-3.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-3.3&quot; id=&quot;section-3.3&quot;&gt;3.3&lt;/a&gt;.  Numbers&lt;/span&gt;

   The basic numeric data type is an unsigned byte (uint8).  All larger
   numeric data types are constructed from a fixed-length series of
   bytes concatenated as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; and are also unsigned.
   The following numeric types are predefined.

      uint8 uint16[2];
      uint8 uint24[3];
      uint8 uint32[4];
      uint8 uint64[8];

   All values, here and elsewhere in the specification, are transmitted
   in network byte (big-endian) order; the uint32 represented by the hex
   bytes 01 02 03 04 is equivalent to the decimal value 16909060.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-3.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-3.4&quot; id=&quot;section-3.4&quot;&gt;3.4&lt;/a&gt;.  Vectors&lt;/span&gt;

   A vector (single-dimensioned array) is a stream of homogeneous data
   elements.  The size of the vector may be specified at documentation
   time or left unspecified until runtime.  In either case, the length
   declares the number of bytes, not the number of elements, in the
   vector.  The syntax for specifying a new type, T', that is a fixed-
   length vector of type T is

      T T'[n];

   Here, T' occupies n bytes in the data stream, where n is a multiple
   of the size of T.  The length of the vector is not included in the
   encoded stream.







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 20]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   In the following example, Datum is defined to be three consecutive
   bytes that the protocol does not interpret, while Data is three
   consecutive Datum, consuming a total of nine bytes.

      opaque Datum[3];      /* three uninterpreted bytes */
      Datum Data[9];        /* three consecutive 3-byte vectors */

   Variable-length vectors are defined by specifying a subrange of legal
   lengths, inclusively, using the notation &amp;lt;floor..ceiling&amp;gt;.  When
   these are encoded, the actual length precedes the vector's contents
   in the byte stream.  The length will be in the form of a number
   consuming as many bytes as required to hold the vector's specified
   maximum (ceiling) length.  A variable-length vector with an actual
   length field of zero is referred to as an empty vector.

      T T'&amp;lt;floor..ceiling&amp;gt;;

   In the following example, &quot;mandatory&quot; is a vector that must contain
   between 300 and 400 bytes of type opaque.  It can never be empty.
   The actual length field consumes two bytes, a uint16, which is
   sufficient to represent the value 400 (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;).  Similarly,
   &quot;longer&quot; can represent up to 800 bytes of data, or 400 uint16
   elements, and it may be empty.  Its encoding will include a two-byte
   actual length field prepended to the vector.  The length of an
   encoded vector must be an exact multiple of the length of a single
   element (e.g., a 17-byte vector of uint16 would be illegal).

      opaque mandatory&amp;lt;300..400&amp;gt;;
            /* length field is two bytes, cannot be empty */
      uint16 longer&amp;lt;0..800&amp;gt;;
            /* zero to 400 16-bit unsigned integers */

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-3.5&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-3.5&quot; id=&quot;section-3.5&quot;&gt;3.5&lt;/a&gt;.  Enumerateds&lt;/span&gt;

   An additional sparse data type, called &quot;enum&quot; or &quot;enumerated&quot;, is
   available.  Each definition is a different type.  Only enumerateds of
   the same type may be assigned or compared.  Every element of an
   enumerated must be assigned a value, as demonstrated in the following
   example.  Since the elements of the enumerated are not ordered, they
   can be assigned any unique value, in any order.

      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;

   Future extensions or additions to the protocol may define new values.
   Implementations need to be able to parse and ignore unknown values
   unless the definition of the field states otherwise.





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 21]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   An enumerated occupies as much space in the byte stream as would its
   maximal defined ordinal value.  The following definition would cause
   one byte to be used to carry fields of type Color.

      enum { red(3), blue(5), white(7) } Color;

   One may optionally specify a value without its associated tag to
   force the width definition without defining a superfluous element.

   In the following example, Taste will consume two bytes in the data
   stream but can only assume the values 1, 2, or 4 in the current
   version of the protocol.

      enum { sweet(1), sour(2), bitter(4), (32000) } Taste;

   The names of the elements of an enumeration are scoped within the
   defined type.  In the first example, a fully qualified reference to
   the second element of the enumeration would be Color.blue.  Such
   qualification is not required if the target of the assignment is well
   specified.

      Color color = Color.blue;     /* overspecified, legal */
      Color color = blue;           /* correct, type implicit */

   The names assigned to enumerateds do not need to be unique.  The
   numerical value can describe a range over which the same name
   applies.  The value includes the minimum and maximum inclusive values
   in that range, separated by two period characters.  This is
   principally useful for reserving regions of the space.

      enum { sad(0), meh(1..254), happy(255) } Mood;

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-3.6&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-3.6&quot; id=&quot;section-3.6&quot;&gt;3.6&lt;/a&gt;.  Constructed Types&lt;/span&gt;

   Structure types may be constructed from primitive types for
   convenience.  Each specification declares a new, unique type.  The
   syntax used for definitions is much like that of C.

      struct {
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } T;

   Fixed- and variable-length vector fields are allowed using the
   standard vector syntax.  Structures V1 and V2 in the variants example
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-3.8&quot;&gt;Section 3.8&lt;/a&gt;) demonstrate this.



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 22]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   The fields within a structure may be qualified using the type's name,
   with a syntax much like that available for enumerateds.  For example,
   T.f2 refers to the second field of the previous declaration.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-3.7&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-3.7&quot; id=&quot;section-3.7&quot;&gt;3.7&lt;/a&gt;.  Constants&lt;/span&gt;

   Fields and variables may be assigned a fixed value using &quot;=&quot;, as in:

      struct {
          T1 f1 = 8;  /* T.f1 must always be 8 */
          T2 f2;
      } T;

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-3.8&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-3.8&quot; id=&quot;section-3.8&quot;&gt;3.8&lt;/a&gt;.  Variants&lt;/span&gt;

   Defined structures may have variants based on some knowledge that is
   available within the environment.  The selector must be an enumerated
   type that defines the possible variants the structure defines.  Each
   arm of the select (below) specifies the type of that variant's field
   and an optional field label.  The mechanism by which the variant is
   selected at runtime is not prescribed by the presentation language.

      struct {
          T1 f1;
          T2 f2;
          ....
          Tn fn;
          select (E) {
              case e1: Te1 [[fe1]];
              case e2: Te2 [[fe2]];
              ....
              case en: Ten [[fen]];
          };
      } Tv;

















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 23]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   For example:

      enum { apple(0), orange(1) } VariantTag;

      struct {
          uint16 number;
          opaque string&amp;lt;0..10&amp;gt;; /* variable length */
      } V1;

      struct {
          uint32 number;
          opaque string[10];    /* fixed length */
      } V2;

      struct {
          VariantTag type;
          select (VariantRecord.type) {
              case apple:  V1;
              case orange: V2;
          };
      } VariantRecord;

&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4&quot; id=&quot;section-4&quot;&gt;4&lt;/a&gt;.  Handshake Protocol&lt;/span&gt;

   The handshake protocol is used to negotiate the security parameters
   of a connection.  Handshake messages are supplied to the TLS record
   layer, where they are encapsulated within one or more TLSPlaintext or
   TLSCiphertext structures which are processed and transmitted as
   specified by the current active connection state.






















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 24]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


      enum {
          client_hello(1),
          server_hello(2),
          new_session_ticket(4),
          end_of_early_data(5),
          encrypted_extensions(8),
          certificate(11),
          certificate_request(13),
          certificate_verify(15),
          finished(20),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;

      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* remaining bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;

   Protocol messages MUST be sent in the order defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.1&quot;&gt;Section 4.4.1&lt;/a&gt;
   and shown in the diagrams in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-2&quot;&gt;Section 2&lt;/a&gt;.  A peer which receives a
   handshake message in an unexpected order MUST abort the handshake
   with an &quot;unexpected_message&quot; alert.

   New handshake message types are assigned by IANA as described in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-11&quot;&gt;Section 11&lt;/a&gt;.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1&quot; id=&quot;section-4.1&quot;&gt;4.1&lt;/a&gt;.  Key Exchange Messages&lt;/span&gt;

   The key exchange messages are used to determine the security
   capabilities of the client and the server and to establish shared
   secrets, including the traffic keys used to protect the rest of the
   handshake and the data.





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 25]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.1.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.1&quot; id=&quot;section-4.1.1&quot;&gt;4.1.1&lt;/a&gt;.  Cryptographic Negotiation&lt;/span&gt;

   In TLS, the cryptographic negotiation proceeds by the client offering
   the following four sets of options in its ClientHello:

   -  A list of cipher suites which indicates the AEAD algorithm/HKDF
      hash pairs which the client supports.

   -  A &quot;supported_groups&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.7&quot;&gt;Section 4.2.7&lt;/a&gt;) extension which indicates the
      (EC)DHE groups which the client supports and a &quot;key_share&quot;
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.8&quot;&gt;Section 4.2.8&lt;/a&gt;) extension which contains (EC)DHE shares for some
      or all of these groups.

   -  A &quot;signature_algorithms&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;) extension which indicates
      the signature algorithms which the client can accept.  A
      &quot;signature_algorithms_cert&quot; extension (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;) may also be
      added to indicate certificate-specific signature algorithms.

   -  A &quot;pre_shared_key&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.11&quot;&gt;Section 4.2.11&lt;/a&gt;) extension which contains a
      list of symmetric key identities known to the client and a
      &quot;psk_key_exchange_modes&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.9&quot;&gt;Section 4.2.9&lt;/a&gt;) extension which indicates
      the key exchange modes that may be used with PSKs.

   If the server does not select a PSK, then the first three of these
   options are entirely orthogonal: the server independently selects a
   cipher suite, an (EC)DHE group and key share for key establishment,
   and a signature algorithm/certificate pair to authenticate itself to
   the client.  If there is no overlap between the received
   &quot;supported_groups&quot; and the groups supported by the server, then the
   server MUST abort the handshake with a &quot;handshake_failure&quot; or an
   &quot;insufficient_security&quot; alert.

   If the server selects a PSK, then it MUST also select a key
   establishment mode from the set indicated by the client's
   &quot;psk_key_exchange_modes&quot; extension (at present, PSK alone or with
   (EC)DHE).  Note that if the PSK can be used without (EC)DHE, then
   non-overlap in the &quot;supported_groups&quot; parameters need not be fatal,
   as it is in the non-PSK case discussed in the previous paragraph.

   If the server selects an (EC)DHE group and the client did not offer a
   compatible &quot;key_share&quot; extension in the initial ClientHello, the
   server MUST respond with a HelloRetryRequest (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.4&quot;&gt;Section 4.1.4&lt;/a&gt;) message.









&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 26]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   If the server successfully selects parameters and does not require a
   HelloRetryRequest, it indicates the selected parameters in the
   ServerHello as follows:

   -  If PSK is being used, then the server will send a &quot;pre_shared_key&quot;
      extension indicating the selected key.

   -  When (EC)DHE is in use, the server will also provide a &quot;key_share&quot;
      extension.  If PSK is not being used, then (EC)DHE and
      certificate-based authentication are always used.

   -  When authenticating via a certificate, the server will send the
      Certificate (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.2&quot;&gt;Section 4.4.2&lt;/a&gt;) and CertificateVerify (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.3&quot;&gt;Section 4.4.3&lt;/a&gt;)
      messages.  In TLS 1.3 as defined by this document, either a PSK or
      a certificate is always used, but not both.  Future documents may
      define how to use them together.

   If the server is unable to negotiate a supported set of parameters
   (i.e., there is no overlap between the client and server parameters),
   it MUST abort the handshake with either a &quot;handshake_failure&quot; or
   &quot;insufficient_security&quot; fatal alert (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-6&quot;&gt;Section 6&lt;/a&gt;).

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.1.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.2&quot; id=&quot;section-4.1.2&quot;&gt;4.1.2&lt;/a&gt;.  Client Hello&lt;/span&gt;

   When a client first connects to a server, it is REQUIRED to send the
   ClientHello as its first TLS message.  The client will also send a
   ClientHello when the server has responded to its ClientHello with a
   HelloRetryRequest.  In that case, the client MUST send the same
   ClientHello without modification, except as follows:

   -  If a &quot;key_share&quot; extension was supplied in the HelloRetryRequest,
      replacing the list of shares with a list containing a single
      KeyShareEntry from the indicated group.

   -  Removing the &quot;early_data&quot; extension (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.10&quot;&gt;Section 4.2.10&lt;/a&gt;) if one was
      present.  Early data is not permitted after a HelloRetryRequest.

   -  Including a &quot;cookie&quot; extension if one was provided in the
      HelloRetryRequest.












&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 27]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   -  Updating the &quot;pre_shared_key&quot; extension if present by recomputing
      the &quot;obfuscated_ticket_age&quot; and binder values and (optionally)
      removing any PSKs which are incompatible with the server's
      indicated cipher suite.

   -  Optionally adding, removing, or changing the length of the
      &quot;padding&quot; extension [&lt;a href=&quot;https://tools.ietf.org/html/rfc7685&quot; title=&quot;&amp;quot;A Transport Layer Security (TLS) ClientHello Padding Extension&amp;quot;&quot;&gt;RFC7685&lt;/a&gt;].

   -  Other modifications that may be allowed by an extension defined in
      the future and present in the HelloRetryRequest.

   Because TLS 1.3 forbids renegotiation, if a server has negotiated
   TLS 1.3 and receives a ClientHello at any other time, it MUST
   terminate the connection with an &quot;unexpected_message&quot; alert.

   If a server established a TLS connection with a previous version of
   TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST
   retain the previous protocol version.  In particular, it MUST NOT
   negotiate TLS 1.3.

   Structure of this message:

      uint16 ProtocolVersion;
      opaque Random[32];

      uint8 CipherSuite[2];    /* Cryptographic suite selector */

      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id&amp;lt;0..32&amp;gt;;
          CipherSuite cipher_suites&amp;lt;2..2^16-2&amp;gt;;
          opaque legacy_compression_methods&amp;lt;1..2^8-1&amp;gt;;
          Extension extensions&amp;lt;8..2^16-1&amp;gt;;
      } ClientHello;
















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 28]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   legacy_version:  In previous versions of TLS, this field was used for
      version negotiation and represented the highest version number
      supported by the client.  Experience has shown that many servers
      do not properly implement version negotiation, leading to &quot;version
      intolerance&quot; in which the server rejects an otherwise acceptable
      ClientHello with a version number higher than it supports.  In
      TLS 1.3, the client indicates its version preferences in the
      &quot;supported_versions&quot; extension (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;) and the
      legacy_version field MUST be set to 0x0303, which is the version
      number for TLS 1.2.  TLS 1.3 ClientHellos are identified as having
      a legacy_version of 0x0303 and a supported_versions extension
      present with 0x0304 as the highest version indicated therein.
      (See &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D&quot;&gt;Appendix D&lt;/a&gt; for details about backward compatibility.)

   random:  32 bytes generated by a secure random number generator.  See
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C&quot;&gt;Appendix C&lt;/a&gt; for additional information.

   legacy_session_id:  Versions of TLS before TLS 1.3 supported a
      &quot;session resumption&quot; feature which has been merged with pre-shared
      keys in this version (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;).  A client which has a
      cached session ID set by a pre-TLS 1.3 server SHOULD set this
      field to that value.  In compatibility mode (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.4&quot;&gt;Appendix D.4&lt;/a&gt;),
      this field MUST be non-empty, so a client not offering a
      pre-TLS 1.3 session MUST generate a new 32-byte value.  This value
      need not be random but SHOULD be unpredictable to avoid
      implementations fixating on a specific value (also known as
      ossification).  Otherwise, it MUST be set as a zero-length vector
      (i.e., a zero-valued single byte length field).

   cipher_suites:  A list of the symmetric cipher options supported by
      the client, specifically the record protection algorithm
      (including secret key length) and a hash to be used with HKDF, in
      descending order of client preference.  Values are defined in
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.4&quot;&gt;Appendix B.4&lt;/a&gt;.  If the list contains cipher suites that the server
      does not recognize, support, or wish to use, the server MUST
      ignore those cipher suites and process the remaining ones as
      usual.  If the client is attempting a PSK key establishment, it
      SHOULD advertise at least one cipher suite indicating a Hash
      associated with the PSK.












&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 29]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   legacy_compression_methods:  Versions of TLS before 1.3 supported
      compression with the list of supported compression methods being
      sent in this field.  For every TLS 1.3 ClientHello, this vector
      MUST contain exactly one byte, set to zero, which corresponds to
      the &quot;null&quot; compression method in prior versions of TLS.  If a
      TLS 1.3 ClientHello is received with any other value in this
      field, the server MUST abort the handshake with an
      &quot;illegal_parameter&quot; alert.  Note that TLS 1.3 servers might
      receive TLS 1.2 or prior ClientHellos which contain other
      compression methods and (if negotiating such a prior version) MUST
      follow the procedures for the appropriate prior version of TLS.

   extensions:  Clients request extended functionality from servers by
      sending data in the extensions field.  The actual &quot;Extension&quot;
      format is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;.  In TLS 1.3, the use of certain
      extensions is mandatory, as functionality has moved into
      extensions to preserve ClientHello compatibility with previous
      versions of TLS.  Servers MUST ignore unrecognized extensions.

   All versions of TLS allow an extensions field to optionally follow
   the compression_methods field.  TLS 1.3 ClientHello messages always
   contain extensions (minimally &quot;supported_versions&quot;, otherwise, they
   will be interpreted as TLS 1.2 ClientHello messages).  However,
   TLS 1.3 servers might receive ClientHello messages without an
   extensions field from prior versions of TLS.  The presence of
   extensions can be detected by determining whether there are bytes
   following the compression_methods field at the end of the
   ClientHello.  Note that this method of detecting optional data
   differs from the normal TLS method of having a variable-length field,
   but it is used for compatibility with TLS before extensions were
   defined.  TLS 1.3 servers will need to perform this check first and
   only attempt to negotiate TLS 1.3 if the &quot;supported_versions&quot;
   extension is present.  If negotiating a version of TLS prior to 1.3,
   a server MUST check that the message either contains no data after
   legacy_compression_methods or that it contains a valid extensions
   block with no data following.  If not, then it MUST abort the
   handshake with a &quot;decode_error&quot; alert.

   In the event that a client requests additional functionality using
   extensions and this functionality is not supplied by the server, the
   client MAY abort the handshake.

   After sending the ClientHello message, the client waits for a
   ServerHello or HelloRetryRequest message.  If early data is in use,
   the client may transmit early Application Data (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;) while
   waiting for the next handshake message.





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 30]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.1.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.3&quot; id=&quot;section-4.1.3&quot;&gt;4.1.3&lt;/a&gt;.  Server Hello&lt;/span&gt;

   The server will send this message in response to a ClientHello
   message to proceed with the handshake if it is able to negotiate an
   acceptable set of handshake parameters based on the ClientHello.

   Structure of this message:

      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id_echo&amp;lt;0..32&amp;gt;;
          CipherSuite cipher_suite;
          uint8 legacy_compression_method = 0;
          Extension extensions&amp;lt;6..2^16-1&amp;gt;;
      } ServerHello;

   legacy_version:  In previous versions of TLS, this field was used for
      version negotiation and represented the selected version number
      for the connection.  Unfortunately, some middleboxes fail when
      presented with new values.  In TLS 1.3, the TLS server indicates
      its version using the &quot;supported_versions&quot; extension
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;), and the legacy_version field MUST be set to
      0x0303, which is the version number for TLS 1.2.  (See &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D&quot;&gt;Appendix D&lt;/a&gt;
      for details about backward compatibility.)

   random:  32 bytes generated by a secure random number generator.  See
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C&quot;&gt;Appendix C&lt;/a&gt; for additional information.  The last 8 bytes MUST be
      overwritten as described below if negotiating TLS 1.2 or TLS 1.1,
      but the remaining bytes MUST be random.  This structure is
      generated by the server and MUST be generated independently of the
      ClientHello.random.

   legacy_session_id_echo:  The contents of the client's
      legacy_session_id field.  Note that this field is echoed even if
      the client's value corresponded to a cached pre-TLS 1.3 session
      which the server has chosen not to resume.  A client which
      receives a legacy_session_id_echo field that does not match what
      it sent in the ClientHello MUST abort the handshake with an
      &quot;illegal_parameter&quot; alert.

   cipher_suite:  The single cipher suite selected by the server from
      the list in ClientHello.cipher_suites.  A client which receives a
      cipher suite that was not offered MUST abort the handshake with an
      &quot;illegal_parameter&quot; alert.

   legacy_compression_method:  A single byte which MUST have the
      value 0.



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 31]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   extensions:  A list of extensions.  The ServerHello MUST only include
      extensions which are required to establish the cryptographic
      context and negotiate the protocol version.  All TLS 1.3
      ServerHello messages MUST contain the &quot;supported_versions&quot;
      extension.  Current ServerHello messages additionally contain
      either the &quot;pre_shared_key&quot; extension or the &quot;key_share&quot;
      extension, or both (when using a PSK with (EC)DHE key
      establishment).  Other extensions (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;) are sent
      separately in the EncryptedExtensions message.

   For reasons of backward compatibility with middleboxes (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.4&quot;&gt;Appendix D.4&lt;/a&gt;), the HelloRetryRequest message uses the same structure
   as the ServerHello, but with Random set to the special value of the
   SHA-256 of &quot;HelloRetryRequest&quot;:

     CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91
     C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C

   Upon receiving a message with type server_hello, implementations MUST
   first examine the Random value and, if it matches this value, process
   it as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.4&quot;&gt;Section 4.1.4&lt;/a&gt;).

   TLS 1.3 has a downgrade protection mechanism embedded in the server's
   random value.  TLS 1.3 servers which negotiate TLS 1.2 or below in
   response to a ClientHello MUST set the last 8 bytes of their Random
   value specially in their ServerHello.

   If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of
   their Random value to the bytes:

     44 4F 57 4E 47 52 44 01

   If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2
   servers SHOULD, set the last 8 bytes of their ServerHello.Random
   value to the bytes:

     44 4F 57 4E 47 52 44 00

   TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below
   MUST check that the last 8 bytes are not equal to either of these
   values.  TLS 1.2 clients SHOULD also check that the last 8 bytes are
   not equal to the second value if the ServerHello indicates TLS 1.1 or
   below.  If a match is found, the client MUST abort the handshake with
   an &quot;illegal_parameter&quot; alert.  This mechanism provides limited
   protection against downgrade attacks over and above what is provided
   by the Finished exchange: because the ServerKeyExchange, a message
   present in TLS 1.2 and below, includes a signature over both random
   values, it is not possible for an active attacker to modify the



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 32]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   random values without detection as long as ephemeral ciphers are
   used.  It does not provide downgrade protection when static RSA
   is used.

   Note: This is a change from [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot; title=&quot;&amp;quot;The Transport Layer Security (TLS) Protocol Version 1.2&amp;quot;&quot;&gt;RFC5246&lt;/a&gt;], so in practice many TLS 1.2
   clients and servers will not behave as specified above.

   A legacy TLS client performing renegotiation with TLS 1.2 or prior
   and which receives a TLS 1.3 ServerHello during renegotiation MUST
   abort the handshake with a &quot;protocol_version&quot; alert.  Note that
   renegotiation is not possible when TLS 1.3 has been negotiated.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.1.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.4&quot; id=&quot;section-4.1.4&quot;&gt;4.1.4&lt;/a&gt;.  Hello Retry Request&lt;/span&gt;

   The server will send this message in response to a ClientHello
   message if it is able to find an acceptable set of parameters but the
   ClientHello does not contain sufficient information to proceed with
   the handshake.  As discussed in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.3&quot;&gt;Section 4.1.3&lt;/a&gt;, the HelloRetryRequest
   has the same format as a ServerHello message, and the legacy_version,
   legacy_session_id_echo, cipher_suite, and legacy_compression_method
   fields have the same meaning.  However, for convenience we discuss
   &quot;HelloRetryRequest&quot; throughout this document as if it were a distinct
   message.

   The server's extensions MUST contain &quot;supported_versions&quot;.
   Additionally, it SHOULD contain the minimal set of extensions
   necessary for the client to generate a correct ClientHello pair.  As
   with the ServerHello, a HelloRetryRequest MUST NOT contain any
   extensions that were not first offered by the client in its
   ClientHello, with the exception of optionally the &quot;cookie&quot; (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;) extension.

   Upon receipt of a HelloRetryRequest, the client MUST check the
   legacy_version, legacy_session_id_echo, cipher_suite, and
   legacy_compression_method as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.3&quot;&gt;Section 4.1.3&lt;/a&gt; and then
   process the extensions, starting with determining the version using
   &quot;supported_versions&quot;.  Clients MUST abort the handshake with an
   &quot;illegal_parameter&quot; alert if the HelloRetryRequest would not result
   in any change in the ClientHello.  If a client receives a second
   HelloRetryRequest in the same connection (i.e., where the ClientHello
   was itself in response to a HelloRetryRequest), it MUST abort the
   handshake with an &quot;unexpected_message&quot; alert.









&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 33]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Otherwise, the client MUST process all extensions in the
   HelloRetryRequest and send a second updated ClientHello.  The
   HelloRetryRequest extensions defined in this specification are:

   -  supported_versions (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;)

   -  cookie (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   -  key_share (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.8&quot;&gt;Section 4.2.8&lt;/a&gt;)

   A client which receives a cipher suite that was not offered MUST
   abort the handshake.  Servers MUST ensure that they negotiate the
   same cipher suite when receiving a conformant updated ClientHello (if
   the server selects the cipher suite as the first step in the
   negotiation, then this will happen automatically).  Upon receiving
   the ServerHello, clients MUST check that the cipher suite supplied in
   the ServerHello is the same as that in the HelloRetryRequest and
   otherwise abort the handshake with an &quot;illegal_parameter&quot; alert.

   In addition, in its updated ClientHello, the client SHOULD NOT offer
   any pre-shared keys associated with a hash other than that of the
   selected cipher suite.  This allows the client to avoid having to
   compute partial hash transcripts for multiple hashes in the second
   ClientHello.

   The value of selected_version in the HelloRetryRequest
   &quot;supported_versions&quot; extension MUST be retained in the ServerHello,
   and a client MUST abort the handshake with an &quot;illegal_parameter&quot;
   alert if the value changes.






















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 34]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2&quot; id=&quot;section-4.2&quot;&gt;4.2&lt;/a&gt;.  Extensions&lt;/span&gt;

   A number of TLS messages contain tag-length-value encoded extensions
   structures.

    struct {
        ExtensionType extension_type;
        opaque extension_data&amp;lt;0..2^16-1&amp;gt;;
    } Extension;

    enum {
        server_name(0),                             /* &lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot;&gt;RFC 6066&lt;/a&gt; */
        max_fragment_length(1),                     /* &lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot;&gt;RFC 6066&lt;/a&gt; */
        status_request(5),                          /* &lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot;&gt;RFC 6066&lt;/a&gt; */
        supported_groups(10),                       /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8422&quot;&gt;RFC 8422&lt;/a&gt;, 7919 */
        signature_algorithms(13),                   /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        use_srtp(14),                               /* &lt;a href=&quot;https://tools.ietf.org/html/rfc5764&quot;&gt;RFC 5764&lt;/a&gt; */
        heartbeat(15),                              /* &lt;a href=&quot;https://tools.ietf.org/html/rfc6520&quot;&gt;RFC 6520&lt;/a&gt; */
        application_layer_protocol_negotiation(16), /* &lt;a href=&quot;https://tools.ietf.org/html/rfc7301&quot;&gt;RFC 7301&lt;/a&gt; */
        signed_certificate_timestamp(18),           /* &lt;a href=&quot;https://tools.ietf.org/html/rfc6962&quot;&gt;RFC 6962&lt;/a&gt; */
        client_certificate_type(19),                /* &lt;a href=&quot;https://tools.ietf.org/html/rfc7250&quot;&gt;RFC 7250&lt;/a&gt; */
        server_certificate_type(20),                /* &lt;a href=&quot;https://tools.ietf.org/html/rfc7250&quot;&gt;RFC 7250&lt;/a&gt; */
        padding(21),                                /* &lt;a href=&quot;https://tools.ietf.org/html/rfc7685&quot;&gt;RFC 7685&lt;/a&gt; */
        pre_shared_key(41),                         /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        early_data(42),                             /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        supported_versions(43),                     /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        cookie(44),                                 /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        psk_key_exchange_modes(45),                 /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        certificate_authorities(47),                /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        oid_filters(48),                            /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        post_handshake_auth(49),                    /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        signature_algorithms_cert(50),              /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        key_share(51),                              /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        (65535)
    } ExtensionType;
















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 35]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Here:

   -  &quot;extension_type&quot; identifies the particular extension type.

   -  &quot;extension_data&quot; contains information specific to the particular
      extension type.

   The list of extension types is maintained by IANA as described in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-11&quot;&gt;Section 11&lt;/a&gt;.

   Extensions are generally structured in a request/response fashion,
   though some extensions are just indications with no corresponding
   response.  The client sends its extension requests in the ClientHello
   message, and the server sends its extension responses in the
   ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate
   messages.  The server sends extension requests in the
   CertificateRequest message which a client MAY respond to with a
   Certificate message.  The server MAY also send unsolicited extensions
   in the NewSessionTicket, though the client does not respond directly
   to these.

   Implementations MUST NOT send extension responses if the remote
   endpoint did not send the corresponding extension requests, with the
   exception of the &quot;cookie&quot; extension in the HelloRetryRequest.  Upon
   receiving such an extension, an endpoint MUST abort the handshake
   with an &quot;unsupported_extension&quot; alert.

   The table below indicates the messages where a given extension may
   appear, using the following notation: CH (ClientHello),
   SH (ServerHello), EE (EncryptedExtensions), CT (Certificate),
   CR (CertificateRequest), NST (NewSessionTicket), and
   HRR (HelloRetryRequest).  If an implementation receives an extension
   which it recognizes and which is not specified for the message in
   which it appears, it MUST abort the handshake with an
   &quot;illegal_parameter&quot; alert.
















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 36]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   +--------------------------------------------------+-------------+
   | Extension                                        |     TLS 1.3 |
   +--------------------------------------------------+-------------+
   | server_name [&lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Extensions: Extension Definitions&amp;quot;&quot;&gt;RFC6066&lt;/a&gt;]                            |      CH, EE |
   |                                                  |             |
   | max_fragment_length [&lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Extensions: Extension Definitions&amp;quot;&quot;&gt;RFC6066&lt;/a&gt;]                    |      CH, EE |
   |                                                  |             |
   | status_request [&lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Extensions: Extension Definitions&amp;quot;&quot;&gt;RFC6066&lt;/a&gt;]                         |  CH, CR, CT |
   |                                                  |             |
   | supported_groups [&lt;a href=&quot;https://tools.ietf.org/html/rfc7919&quot; title=&quot;&amp;quot;Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)&amp;quot;&quot;&gt;RFC7919&lt;/a&gt;]                       |      CH, EE |
   |                                                  |             |
   | signature_algorithms (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;)                  |      CH, CR |
   |                                                  |             |
   | use_srtp [&lt;a href=&quot;https://tools.ietf.org/html/rfc5764&quot; title=&quot;&amp;quot;Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)&amp;quot;&quot;&gt;RFC5764&lt;/a&gt;]                               |      CH, EE |
   |                                                  |             |
   | heartbeat [&lt;a href=&quot;https://tools.ietf.org/html/rfc6520&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension&amp;quot;&quot;&gt;RFC6520&lt;/a&gt;]                              |      CH, EE |
   |                                                  |             |
   | application_layer_protocol_negotiation [&lt;a href=&quot;https://tools.ietf.org/html/rfc7301&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension&amp;quot;&quot;&gt;RFC7301&lt;/a&gt;] |      CH, EE |
   |                                                  |             |
   | signed_certificate_timestamp [&lt;a href=&quot;https://tools.ietf.org/html/rfc6962&quot; title=&quot;&amp;quot;Certificate Transparency&amp;quot;&quot;&gt;RFC6962&lt;/a&gt;]           |  CH, CR, CT |
   |                                                  |             |
   | client_certificate_type [&lt;a href=&quot;https://tools.ietf.org/html/rfc7250&quot; title=&quot;&amp;quot;Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)&amp;quot;&quot;&gt;RFC7250&lt;/a&gt;]                |      CH, EE |
   |                                                  |             |
   | server_certificate_type [&lt;a href=&quot;https://tools.ietf.org/html/rfc7250&quot; title=&quot;&amp;quot;Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)&amp;quot;&quot;&gt;RFC7250&lt;/a&gt;]                |      CH, EE |
   |                                                  |             |
   | padding [&lt;a href=&quot;https://tools.ietf.org/html/rfc7685&quot; title=&quot;&amp;quot;A Transport Layer Security (TLS) ClientHello Padding Extension&amp;quot;&quot;&gt;RFC7685&lt;/a&gt;]                                |          CH |
   |                                                  |             |
   | key_share (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;)                             | CH, SH, HRR |
   |                                                  |             |
   | pre_shared_key (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;)                        |      CH, SH |
   |                                                  |             |
   | psk_key_exchange_modes (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;)                |          CH |
   |                                                  |             |
   | early_data (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;)                            | CH, EE, NST |
   |                                                  |             |
   | cookie (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;)                                |     CH, HRR |
   |                                                  |             |
   | supported_versions (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;)                    | CH, SH, HRR |
   |                                                  |             |
   | certificate_authorities (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;)               |      CH, CR |
   |                                                  |             |
   | oid_filters (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;)                           |          CR |
   |                                                  |             |
   | post_handshake_auth (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;)                   |          CH |
   |                                                  |             |
   | signature_algorithms_cert (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;)             |      CH, CR |
   +--------------------------------------------------+-------------+




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 37]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   When multiple extensions of different types are present, the
   extensions MAY appear in any order, with the exception of
   &quot;pre_shared_key&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.11&quot;&gt;Section 4.2.11&lt;/a&gt;) which MUST be the last extension in
   the ClientHello (but can appear anywhere in the ServerHello
   extensions block).  There MUST NOT be more than one extension of the
   same type in a given extension block.

   In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each
   handshake even when in resumption-PSK mode.  However, 0-RTT
   parameters are those negotiated in the previous handshake; mismatches
   may require rejecting 0-RTT (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.10&quot;&gt;Section 4.2.10&lt;/a&gt;).

   There are subtle (and not so subtle) interactions that may occur in
   this protocol between new features and existing features which may
   result in a significant reduction in overall security.  The following
   considerations should be taken into account when designing new
   extensions:

   -  Some cases where a server does not agree to an extension are error
      conditions (e.g., the handshake cannot continue), and some are
      simply refusals to support particular features.  In general, error
      alerts should be used for the former and a field in the server
      extension response for the latter.

   -  Extensions should, as far as possible, be designed to prevent any
      attack that forces use (or non-use) of a particular feature by
      manipulation of handshake messages.  This principle should be
      followed regardless of whether the feature is believed to cause a
      security problem.  Often the fact that the extension fields are
      included in the inputs to the Finished message hashes will be
      sufficient, but extreme care is needed when the extension changes
      the meaning of messages sent in the handshake phase.  Designers
      and implementors should be aware of the fact that until the
      handshake has been authenticated, active attackers can modify
      messages and insert, remove, or replace extensions.
















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 38]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.1&quot; id=&quot;section-4.2.1&quot;&gt;4.2.1&lt;/a&gt;.  Supported Versions&lt;/span&gt;

      struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions&amp;lt;2..254&amp;gt;;

              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;

   The &quot;supported_versions&quot; extension is used by the client to indicate
   which versions of TLS it supports and by the server to indicate which
   version it is using.  The extension contains a list of supported
   versions in preference order, with the most preferred version first.
   Implementations of this specification MUST send this extension in the
   ClientHello containing all versions of TLS which they are prepared to
   negotiate (for this specification, that means minimally 0x0304, but
   if previous versions of TLS are allowed to be negotiated, they MUST
   be present as well).

   If this extension is not present, servers which are compliant with
   this specification and which also support TLS 1.2 MUST negotiate
   TLS 1.2 or prior as specified in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot; title=&quot;&amp;quot;The Transport Layer Security (TLS) Protocol Version 1.2&amp;quot;&quot;&gt;RFC5246&lt;/a&gt;], even if
   ClientHello.legacy_version is 0x0304 or later.  Servers MAY abort the
   handshake upon receiving a ClientHello with legacy_version 0x0304 or
   later.

   If this extension is present in the ClientHello, servers MUST NOT use
   the ClientHello.legacy_version value for version negotiation and MUST
   use only the &quot;supported_versions&quot; extension to determine client
   preferences.  Servers MUST only select a version of TLS present in
   that extension and MUST ignore any unknown versions that are present
   in that extension.  Note that this mechanism makes it possible to
   negotiate a version prior to TLS 1.2 if one side supports a sparse
   range.  Implementations of TLS 1.3 which choose to support prior
   versions of TLS SHOULD support TLS 1.2.  Servers MUST be prepared to
   receive ClientHellos that include this extension but do not include
   0x0304 in the list of versions.

   A server which negotiates a version of TLS prior to TLS 1.3 MUST set
   ServerHello.version and MUST NOT send the &quot;supported_versions&quot;
   extension.  A server which negotiates TLS 1.3 MUST respond by sending
   a &quot;supported_versions&quot; extension containing the selected version
   value (0x0304).  It MUST set the ServerHello.legacy_version field to
   0x0303 (TLS 1.2).  Clients MUST check for this extension prior to
   processing the rest of the ServerHello (although they will have to



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 39]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   parse the ServerHello in order to read the extension).  If this
   extension is present, clients MUST ignore the
   ServerHello.legacy_version value and MUST use only the
   &quot;supported_versions&quot; extension to determine the selected version.  If
   the &quot;supported_versions&quot; extension in the ServerHello contains a
   version not offered by the client or contains a version prior to
   TLS 1.3, the client MUST abort the handshake with an
   &quot;illegal_parameter&quot; alert.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.2&quot; id=&quot;section-4.2.2&quot;&gt;4.2.2&lt;/a&gt;.  Cookie&lt;/span&gt;

      struct {
          opaque cookie&amp;lt;1..2^16-1&amp;gt;;
      } Cookie;

   Cookies serve two primary purposes:

   -  Allowing the server to force the client to demonstrate
      reachability at their apparent network address (thus providing a
      measure of DoS protection).  This is primarily useful for
      non-connection-oriented transports (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc6347&quot; title=&quot;&amp;quot;Datagram Transport Layer Security Version 1.2&amp;quot;&quot;&gt;RFC6347&lt;/a&gt;] for an example
      of this).

   -  Allowing the server to offload state to the client, thus allowing
      it to send a HelloRetryRequest without storing any state.  The
      server can do this by storing the hash of the ClientHello in the
      HelloRetryRequest cookie (protected with some suitable integrity
      protection algorithm).

   When sending a HelloRetryRequest, the server MAY provide a &quot;cookie&quot;
   extension to the client (this is an exception to the usual rule that
   the only extensions that may be sent are those that appear in the
   ClientHello).  When sending the new ClientHello, the client MUST copy
   the contents of the extension received in the HelloRetryRequest into
   a &quot;cookie&quot; extension in the new ClientHello.  Clients MUST NOT use
   cookies in their initial ClientHello in subsequent connections.

   When a server is operating statelessly, it may receive an unprotected
   record of type change_cipher_spec between the first and second
   ClientHello (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5&quot;&gt;Section 5&lt;/a&gt;).  Since the server is not storing any
   state, this will appear as if it were the first message to be
   received.  Servers operating statelessly MUST ignore these records.









&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 40]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.3&quot; id=&quot;section-4.2.3&quot;&gt;4.2.3&lt;/a&gt;.  Signature Algorithms&lt;/span&gt;

   TLS 1.3 provides two extensions for indicating which signature
   algorithms may be used in digital signatures.  The
   &quot;signature_algorithms_cert&quot; extension applies to signatures in
   certificates, and the &quot;signature_algorithms&quot; extension, which
   originally appeared in TLS 1.2, applies to signatures in
   CertificateVerify messages.  The keys found in certificates MUST also
   be of appropriate type for the signature algorithms they are used
   with.  This is a particular issue for RSA keys and PSS signatures, as
   described below.  If no &quot;signature_algorithms_cert&quot; extension is
   present, then the &quot;signature_algorithms&quot; extension also applies to
   signatures appearing in certificates.  Clients which desire the
   server to authenticate itself via a certificate MUST send the
   &quot;signature_algorithms&quot; extension.  If a server is authenticating via
   a certificate and the client has not sent a &quot;signature_algorithms&quot;
   extension, then the server MUST abort the handshake with a
   &quot;missing_extension&quot; alert (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;).

   The &quot;signature_algorithms_cert&quot; extension was added to allow
   implementations which supported different sets of algorithms for
   certificates and in TLS itself to clearly signal their capabilities.
   TLS 1.2 implementations SHOULD also process this extension.
   Implementations which have the same policy in both cases MAY omit the
   &quot;signature_algorithms_cert&quot; extension.


























&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 41]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   The &quot;extension_data&quot; field of these extensions contains a
   SignatureSchemeList value:

      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),

          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),

          /* RSASSA-PSS algorithms with public key OID rsaEncryption */
          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),

          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),

          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),

          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),

          /* Reserved Code Points */
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;

      struct {
          SignatureScheme supported_signature_algorithms&amp;lt;2..2^16-2&amp;gt;;
      } SignatureSchemeList;

   Note: This enum is named &quot;SignatureScheme&quot; because there is already a
   &quot;SignatureAlgorithm&quot; type in TLS 1.2, which this replaces.  We use
   the term &quot;signature algorithm&quot; throughout the text.







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 42]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Each SignatureScheme value lists a single signature algorithm that
   the client is willing to verify.  The values are indicated in
   descending order of preference.  Note that a signature algorithm
   takes as input an arbitrary-length message, rather than a digest.
   Algorithms which traditionally act on a digest should be defined in
   TLS to first hash the input with a specified hash algorithm and then
   proceed as usual.  The code point groups listed above have the
   following meanings:

   RSASSA-PKCS1-v1_5 algorithms:  Indicates a signature algorithm using
      RSASSA-PKCS1-v1_5 [&lt;a href=&quot;https://tools.ietf.org/html/rfc8017&quot; title=&quot;&amp;quot;PKCS #1: RSA Cryptography Specifications Version 2.2&amp;quot;&quot;&gt;RFC8017&lt;/a&gt;] with the corresponding hash algorithm
      as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-SHS&quot; title=&quot;&amp;quot;Secure Hash Standard (SHS)&amp;quot;&quot;&gt;SHS&lt;/a&gt;].  These values refer solely to signatures
      which appear in certificates (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.2.2&quot;&gt;Section 4.4.2.2&lt;/a&gt;) and are not
      defined for use in signed TLS handshake messages, although they
      MAY appear in &quot;signature_algorithms&quot; and
      &quot;signature_algorithms_cert&quot; for backward compatibility with
      TLS 1.2.

   ECDSA algorithms:  Indicates a signature algorithm using ECDSA
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-ECDSA&quot; title=&quot;&amp;quot;Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)&amp;quot;&quot;&gt;ECDSA&lt;/a&gt;], the corresponding curve as defined in ANSI X9.62 [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-ECDSA&quot; title=&quot;&amp;quot;Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)&amp;quot;&quot;&gt;ECDSA&lt;/a&gt;]
      and FIPS 186-4 [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-DSS&quot; title=&quot;&amp;quot;Digital Signature Standard (DSS)&amp;quot;&quot;&gt;DSS&lt;/a&gt;], and the corresponding hash algorithm as
      defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-SHS&quot; title=&quot;&amp;quot;Secure Hash Standard (SHS)&amp;quot;&quot;&gt;SHS&lt;/a&gt;].  The signature is represented as a DER-encoded
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-X690&quot; title=&quot;&amp;quot;Information technology -- ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)&amp;quot;&quot;&gt;X690&lt;/a&gt;] ECDSA-Sig-Value structure.

   RSASSA-PSS RSAE algorithms:  Indicates a signature algorithm using
      RSASSA-PSS [&lt;a href=&quot;https://tools.ietf.org/html/rfc8017&quot; title=&quot;&amp;quot;PKCS #1: RSA Cryptography Specifications Version 2.2&amp;quot;&quot;&gt;RFC8017&lt;/a&gt;] with mask generation function 1.  The digest
      used in the mask generation function and the digest being signed
      are both the corresponding hash algorithm as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-SHS&quot; title=&quot;&amp;quot;Secure Hash Standard (SHS)&amp;quot;&quot;&gt;SHS&lt;/a&gt;].
      The length of the Salt MUST be equal to the length of the output
      of the digest algorithm.  If the public key is carried in an X.509
      certificate, it MUST use the rsaEncryption OID [&lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot; title=&quot;&amp;quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&amp;quot;&quot;&gt;RFC5280&lt;/a&gt;].

   EdDSA algorithms:  Indicates a signature algorithm using EdDSA as
      defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc8032&quot; title=&quot;&amp;quot;Edwards-Curve Digital Signature Algorithm (EdDSA)&amp;quot;&quot;&gt;RFC8032&lt;/a&gt;] or its successors.  Note that these
      correspond to the &quot;PureEdDSA&quot; algorithms and not the &quot;prehash&quot;
      variants.

   RSASSA-PSS PSS algorithms:  Indicates a signature algorithm using
      RSASSA-PSS [&lt;a href=&quot;https://tools.ietf.org/html/rfc8017&quot; title=&quot;&amp;quot;PKCS #1: RSA Cryptography Specifications Version 2.2&amp;quot;&quot;&gt;RFC8017&lt;/a&gt;] with mask generation function 1.  The digest
      used in the mask generation function and the digest being signed
      are both the corresponding hash algorithm as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-SHS&quot; title=&quot;&amp;quot;Secure Hash Standard (SHS)&amp;quot;&quot;&gt;SHS&lt;/a&gt;].
      The length of the Salt MUST be equal to the length of the digest
      algorithm.  If the public key is carried in an X.509 certificate,
      it MUST use the RSASSA-PSS OID [&lt;a href=&quot;https://tools.ietf.org/html/rfc5756&quot; title=&quot;&amp;quot;Updates for RSAES-OAEP and RSASSA-PSS Algorithm Parameters&amp;quot;&quot;&gt;RFC5756&lt;/a&gt;].  When used in
      certificate signatures, the algorithm parameters MUST be DER
      encoded.  If the corresponding public key's parameters are
      present, then the parameters in the signature MUST be identical to
      those in the public key.



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 43]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Legacy algorithms:  Indicates algorithms which are being deprecated
      because they use algorithms with known weaknesses, specifically
      SHA-1 which is used in this context with either (1) RSA using
      RSASSA-PKCS1-v1_5 or (2) ECDSA.  These values refer solely to
      signatures which appear in certificates (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.2.2&quot;&gt;Section 4.4.2.2&lt;/a&gt;) and
      are not defined for use in signed TLS handshake messages, although
      they MAY appear in &quot;signature_algorithms&quot; and
      &quot;signature_algorithms_cert&quot; for backward compatibility with
      TLS 1.2.  Endpoints SHOULD NOT negotiate these algorithms but are
      permitted to do so solely for backward compatibility.  Clients
      offering these values MUST list them as the lowest priority
      (listed after all other algorithms in SignatureSchemeList).
      TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless
      no valid certificate chain can be produced without it (see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.2.2&quot;&gt;Section 4.4.2.2&lt;/a&gt;).

   The signatures on certificates that are self-signed or certificates
   that are trust anchors are not validated, since they begin a
   certification path (see &lt;a href=&quot;https://tools.ietf.org/html/rfc5280#section-3.2&quot;&gt;[RFC5280], Section 3.2&lt;/a&gt;).  A certificate that
   begins a certification path MAY use a signature algorithm that is not
   advertised as being supported in the &quot;signature_algorithms&quot;
   extension.

   Note that TLS 1.2 defines this extension differently.  TLS 1.3
   implementations willing to negotiate TLS 1.2 MUST behave in
   accordance with the requirements of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot; title=&quot;&amp;quot;The Transport Layer Security (TLS) Protocol Version 1.2&amp;quot;&quot;&gt;RFC5246&lt;/a&gt;] when negotiating that
   version.  In particular:

   -  TLS 1.2 ClientHellos MAY omit this extension.

   -  In TLS 1.2, the extension contained hash/signature pairs.  The
      pairs are encoded in two octets, so SignatureScheme values have
      been allocated to align with TLS 1.2's encoding.  Some legacy
      pairs are left unallocated.  These algorithms are deprecated as of
      TLS 1.3.  They MUST NOT be offered or negotiated by any
      implementation.  In particular, MD5 [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-SLOTH&quot; title=&quot;&amp;quot;Transcript Collision Attacks: Breaking Authentication in TLS, IKE, and SSH&amp;quot;&quot;&gt;SLOTH&lt;/a&gt;], SHA-224, and DSA
      MUST NOT be used.

   -  ECDSA signature schemes align with TLS 1.2's ECDSA hash/signature
      pairs.  However, the old semantics did not constrain the signing
      curve.  If TLS 1.2 is negotiated, implementations MUST be prepared
      to accept a signature that uses any curve that they advertised in
      the &quot;supported_groups&quot; extension.

   -  Implementations that advertise support for RSASSA-PSS (which is
      mandatory in TLS 1.3) MUST be prepared to accept a signature using
      that scheme even when TLS 1.2 is negotiated.  In TLS 1.2,
      RSASSA-PSS is used with RSA cipher suites.



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 44]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.4&quot; id=&quot;section-4.2.4&quot;&gt;4.2.4&lt;/a&gt;.  Certificate Authorities&lt;/span&gt;

   The &quot;certificate_authorities&quot; extension is used to indicate the
   certificate authorities (CAs) which an endpoint supports and which
   SHOULD be used by the receiving endpoint to guide certificate
   selection.

   The body of the &quot;certificate_authorities&quot; extension consists of a
   CertificateAuthoritiesExtension structure.

      opaque DistinguishedName&amp;lt;1..2^16-1&amp;gt;;

      struct {
          DistinguishedName authorities&amp;lt;3..2^16-1&amp;gt;;
      } CertificateAuthoritiesExtension;

   authorities:  A list of the distinguished names [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-X501&quot; title=&quot;&amp;quot;Information Technology - Open Systems Interconnection - The Directory: Models&amp;quot;&quot;&gt;X501&lt;/a&gt;] of acceptable
      certificate authorities, represented in DER-encoded [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-X690&quot; title=&quot;&amp;quot;Information technology -- ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)&amp;quot;&quot;&gt;X690&lt;/a&gt;] format.
      These distinguished names specify a desired distinguished name for
      a trust anchor or subordinate CA; thus, this message can be used
      to describe known trust anchors as well as a desired authorization
      space.

   The client MAY send the &quot;certificate_authorities&quot; extension in the
   ClientHello message.  The server MAY send it in the
   CertificateRequest message.

   The &quot;trusted_ca_keys&quot; extension [&lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Extensions: Extension Definitions&amp;quot;&quot;&gt;RFC6066&lt;/a&gt;], which serves a similar
   purpose but is more complicated, is not used in TLS 1.3 (although it
   may appear in ClientHello messages from clients which are offering
   prior versions of TLS).

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.5&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.5&quot; id=&quot;section-4.2.5&quot;&gt;4.2.5&lt;/a&gt;.  OID Filters&lt;/span&gt;

   The &quot;oid_filters&quot; extension allows servers to provide a set of
   OID/value pairs which it would like the client's certificate to
   match.  This extension, if provided by the server, MUST only be sent
   in the CertificateRequest message.

      struct {
          opaque certificate_extension_oid&amp;lt;1..2^8-1&amp;gt;;
          opaque certificate_extension_values&amp;lt;0..2^16-1&amp;gt;;
      } OIDFilter;

      struct {
          OIDFilter filters&amp;lt;0..2^16-1&amp;gt;;
      } OIDFilterExtension;




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 45]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   filters:  A list of certificate extension OIDs [&lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot; title=&quot;&amp;quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&amp;quot;&quot;&gt;RFC5280&lt;/a&gt;] with their
      allowed value(s) and represented in DER-encoded [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-X690&quot; title=&quot;&amp;quot;Information technology -- ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)&amp;quot;&quot;&gt;X690&lt;/a&gt;] format.
      Some certificate extension OIDs allow multiple values (e.g.,
      Extended Key Usage).  If the server has included a non-empty
      filters list, the client certificate included in the response MUST
      contain all of the specified extension OIDs that the client
      recognizes.  For each extension OID recognized by the client, all
      of the specified values MUST be present in the client certificate
      (but the certificate MAY have other values as well).  However, the
      client MUST ignore and skip any unrecognized certificate extension
      OIDs.  If the client ignored some of the required certificate
      extension OIDs and supplied a certificate that does not satisfy
      the request, the server MAY at its discretion either continue the
      connection without client authentication or abort the handshake
      with an &quot;unsupported_certificate&quot; alert.  Any given OID MUST NOT
      appear more than once in the filters list.

   PKIX RFCs define a variety of certificate extension OIDs and their
   corresponding value types.  Depending on the type, matching
   certificate extension values are not necessarily bitwise-equal.  It
   is expected that TLS implementations will rely on their PKI libraries
   to perform certificate selection using certificate extension OIDs.

   This document defines matching rules for two standard certificate
   extensions defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot; title=&quot;&amp;quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&amp;quot;&quot;&gt;RFC5280&lt;/a&gt;]:

   -  The Key Usage extension in a certificate matches the request when
      all key usage bits asserted in the request are also asserted in
      the Key Usage certificate extension.

   -  The Extended Key Usage extension in a certificate matches the
      request when all key purpose OIDs present in the request are also
      found in the Extended Key Usage certificate extension.  The
      special anyExtendedKeyUsage OID MUST NOT be used in the request.

   Separate specifications may define matching rules for other
   certificate extensions.














&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 46]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.6&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.6&quot; id=&quot;section-4.2.6&quot;&gt;4.2.6&lt;/a&gt;.  Post-Handshake Client Authentication&lt;/span&gt;

   The &quot;post_handshake_auth&quot; extension is used to indicate that a client
   is willing to perform post-handshake authentication (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.2&quot;&gt;Section 4.6.2&lt;/a&gt;).
   Servers MUST NOT send a post-handshake CertificateRequest to clients
   which do not offer this extension.  Servers MUST NOT send this
   extension.

      struct {} PostHandshakeAuth;

   The &quot;extension_data&quot; field of the &quot;post_handshake_auth&quot; extension is
   zero length.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.7&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.7&quot; id=&quot;section-4.2.7&quot;&gt;4.2.7&lt;/a&gt;.  Supported Groups&lt;/span&gt;

   When sent by the client, the &quot;supported_groups&quot; extension indicates
   the named groups which the client supports for key exchange, ordered
   from most preferred to least preferred.

   Note: In versions of TLS prior to TLS 1.3, this extension was named
   &quot;elliptic_curves&quot; and only contained elliptic curve groups.  See
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc8422&quot; title=&quot;&amp;quot;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier&amp;quot;&quot;&gt;RFC8422&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc7919&quot; title=&quot;&amp;quot;Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)&amp;quot;&quot;&gt;RFC7919&lt;/a&gt;].  This extension was also used to negotiate
   ECDSA curves.  Signature algorithms are now negotiated independently
   (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;).

   The &quot;extension_data&quot; field of this extension contains a
   &quot;NamedGroupList&quot; value:

      enum {

          /* Elliptic Curve Groups (ECDHE) */
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
          x25519(0x001D), x448(0x001E),

          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
          ffdhe6144(0x0103), ffdhe8192(0x0104),

          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          (0xFFFF)
      } NamedGroup;

      struct {
          NamedGroup named_group_list&amp;lt;2..2^16-1&amp;gt;;
      } NamedGroupList;




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 47]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Elliptic Curve Groups (ECDHE):  Indicates support for the
      corresponding named curve, defined in either FIPS 186-4 [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-DSS&quot; title=&quot;&amp;quot;Digital Signature Standard (DSS)&amp;quot;&quot;&gt;DSS&lt;/a&gt;] or
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc7748&quot; title=&quot;&amp;quot;Elliptic Curves for Security&amp;quot;&quot;&gt;RFC7748&lt;/a&gt;].  Values 0xFE00 through 0xFEFF are reserved for
      Private Use [&lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot; title=&quot;&amp;quot;Guidelines for Writing an IANA Considerations Section in RFCs&amp;quot;&quot;&gt;RFC8126&lt;/a&gt;].

   Finite Field Groups (DHE):  Indicates support for the corresponding
      finite field group, defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7919&quot; title=&quot;&amp;quot;Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)&amp;quot;&quot;&gt;RFC7919&lt;/a&gt;].  Values 0x01FC through
      0x01FF are reserved for Private Use.

   Items in named_group_list are ordered according to the sender's
   preferences (most preferred choice first).

   As of TLS 1.3, servers are permitted to send the &quot;supported_groups&quot;
   extension to the client.  Clients MUST NOT act upon any information
   found in &quot;supported_groups&quot; prior to successful completion of the
   handshake but MAY use the information learned from a successfully
   completed handshake to change what groups they use in their
   &quot;key_share&quot; extension in subsequent connections.  If the server has a
   group it prefers to the ones in the &quot;key_share&quot; extension but is
   still willing to accept the ClientHello, it SHOULD send
   &quot;supported_groups&quot; to update the client's view of its preferences;
   this extension SHOULD contain all groups the server supports,
   regardless of whether they are currently supported by the client.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.8&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.8&quot; id=&quot;section-4.2.8&quot;&gt;4.2.8&lt;/a&gt;.  Key Share&lt;/span&gt;

   The &quot;key_share&quot; extension contains the endpoint's cryptographic
   parameters.

   Clients MAY send an empty client_shares vector in order to request
   group selection from the server, at the cost of an additional round
   trip (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.4&quot;&gt;Section 4.1.4&lt;/a&gt;).

      struct {
          NamedGroup group;
          opaque key_exchange&amp;lt;1..2^16-1&amp;gt;;
      } KeyShareEntry;

   group:  The named group for the key being exchanged.

   key_exchange:  Key exchange information.  The contents of this field
      are determined by the specified group and its corresponding
      definition.  Finite Field Diffie-Hellman [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-DH76&quot; title=&quot;&amp;quot;New directions in cryptography&amp;quot;&quot;&gt;DH76&lt;/a&gt;] parameters are
      described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.8.1&quot;&gt;Section 4.2.8.1&lt;/a&gt;; Elliptic Curve Diffie-Hellman
      parameters are described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.8.2&quot;&gt;Section 4.2.8.2&lt;/a&gt;.






&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 48]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   In the ClientHello message, the &quot;extension_data&quot; field of this
   extension contains a &quot;KeyShareClientHello&quot; value:

      struct {
          KeyShareEntry client_shares&amp;lt;0..2^16-1&amp;gt;;
      } KeyShareClientHello;

   client_shares:  A list of offered KeyShareEntry values in descending
      order of client preference.

   This vector MAY be empty if the client is requesting a
   HelloRetryRequest.  Each KeyShareEntry value MUST correspond to a
   group offered in the &quot;supported_groups&quot; extension and MUST appear in
   the same order.  However, the values MAY be a non-contiguous subset
   of the &quot;supported_groups&quot; extension and MAY omit the most preferred
   groups.  Such a situation could arise if the most preferred groups
   are new and unlikely to be supported in enough places to make
   pregenerating key shares for them efficient.

   Clients can offer as many KeyShareEntry values as the number of
   supported groups it is offering, each representing a single set of
   key exchange parameters.  For instance, a client might offer shares
   for several elliptic curves or multiple FFDHE groups.  The
   key_exchange values for each KeyShareEntry MUST be generated
   independently.  Clients MUST NOT offer multiple KeyShareEntry values
   for the same group.  Clients MUST NOT offer any KeyShareEntry values
   for groups not listed in the client's &quot;supported_groups&quot; extension.
   Servers MAY check for violations of these rules and abort the
   handshake with an &quot;illegal_parameter&quot; alert if one is violated.

   In a HelloRetryRequest message, the &quot;extension_data&quot; field of this
   extension contains a KeyShareHelloRetryRequest value:

      struct {
          NamedGroup selected_group;
      } KeyShareHelloRetryRequest;

   selected_group:  The mutually supported group the server intends to
      negotiate and is requesting a retried ClientHello/KeyShare for.

   Upon receipt of this extension in a HelloRetryRequest, the client
   MUST verify that (1) the selected_group field corresponds to a group
   which was provided in the &quot;supported_groups&quot; extension in the
   original ClientHello and (2) the selected_group field does not
   correspond to a group which was provided in the &quot;key_share&quot; extension
   in the original ClientHello.  If either of these checks fails, then
   the client MUST abort the handshake with an &quot;illegal_parameter&quot;
   alert.  Otherwise, when sending the new ClientHello, the client MUST



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 49]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   replace the original &quot;key_share&quot; extension with one containing only a
   new KeyShareEntry for the group indicated in the selected_group field
   of the triggering HelloRetryRequest.

   In a ServerHello message, the &quot;extension_data&quot; field of this
   extension contains a KeyShareServerHello value:

      struct {
          KeyShareEntry server_share;
      } KeyShareServerHello;

   server_share:  A single KeyShareEntry value that is in the same group
      as one of the client's shares.

   If using (EC)DHE key establishment, servers offer exactly one
   KeyShareEntry in the ServerHello.  This value MUST be in the same
   group as the KeyShareEntry value offered by the client that the
   server has selected for the negotiated key exchange.  Servers
   MUST NOT send a KeyShareEntry for any group not indicated in the
   client's &quot;supported_groups&quot; extension and MUST NOT send a
   KeyShareEntry when using the &quot;psk_ke&quot; PskKeyExchangeMode.  If using
   (EC)DHE key establishment and a HelloRetryRequest containing a
   &quot;key_share&quot; extension was received by the client, the client MUST
   verify that the selected NamedGroup in the ServerHello is the same as
   that in the HelloRetryRequest.  If this check fails, the client MUST
   abort the handshake with an &quot;illegal_parameter&quot; alert.

&lt;span class=&quot;h5&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.8.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.8.1&quot; id=&quot;section-4.2.8.1&quot;&gt;4.2.8.1&lt;/a&gt;.  Diffie-Hellman Parameters&lt;/span&gt;

   Diffie-Hellman [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-DH76&quot; title=&quot;&amp;quot;New directions in cryptography&amp;quot;&quot;&gt;DH76&lt;/a&gt;] parameters for both clients and servers are
   encoded in the opaque key_exchange field of a KeyShareEntry in a
   KeyShare structure.  The opaque value contains the Diffie-Hellman
   public value (Y = g^X mod p) for the specified group (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc7919&quot; title=&quot;&amp;quot;Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)&amp;quot;&quot;&gt;RFC7919&lt;/a&gt;]
   for group definitions) encoded as a big-endian integer and padded to
   the left with zeros to the size of p in bytes.

   Note: For a given Diffie-Hellman group, the padding results in all
   public keys having the same length.

   Peers MUST validate each other's public key Y by ensuring that 1 &amp;lt; Y
   &amp;lt; p-1.  This check ensures that the remote peer is properly behaved
   and isn't forcing the local system into a small subgroup.









&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 50]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h5&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.8.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.8.2&quot; id=&quot;section-4.2.8.2&quot;&gt;4.2.8.2&lt;/a&gt;.  ECDHE Parameters&lt;/span&gt;

   ECDHE parameters for both clients and servers are encoded in the
   opaque key_exchange field of a KeyShareEntry in a KeyShare structure.

   For secp256r1, secp384r1, and secp521r1, the contents are the
   serialized value of the following struct:

      struct {
          uint8 legacy_form = 4;
          opaque X[coordinate_length];
          opaque Y[coordinate_length];
      } UncompressedPointRepresentation;

   X and Y, respectively, are the binary representations of the x and y
   values in network byte order.  There are no internal length markers,
   so each number representation occupies as many octets as implied by
   the curve parameters.  For P-256, this means that each of X and Y use
   32 octets, padded on the left by zeros if necessary.  For P-384, they
   take 48 octets each.  For P-521, they take 66 octets each.

   For the curves secp256r1, secp384r1, and secp521r1, peers MUST
   validate each other's public value Q by ensuring that the point is a
   valid point on the elliptic curve.  The appropriate validation
   procedures are defined in Section 4.3.7 of [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-ECDSA&quot; title=&quot;&amp;quot;Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)&amp;quot;&quot;&gt;ECDSA&lt;/a&gt;] and alternatively
   in Section 5.6.2.3 of [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-KEYAGREEMENT&quot; title=&quot;&amp;quot;Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography&amp;quot;&quot;&gt;KEYAGREEMENT&lt;/a&gt;].  This process consists of three
   steps: (1) verify that Q is not the point at infinity (O), (2) verify
   that for Q = (x, y) both integers x and y are in the correct
   interval, and (3) ensure that (x, y) is a correct solution to the
   elliptic curve equation.  For these curves, implementors do not need
   to verify membership in the correct subgroup.

   For X25519 and X448, the contents of the public value are the byte
   string inputs and outputs of the corresponding functions defined in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7748&quot; title=&quot;&amp;quot;Elliptic Curves for Security&amp;quot;&quot;&gt;RFC7748&lt;/a&gt;]: 32 bytes for X25519 and 56 bytes for X448.

   Note: Versions of TLS prior to 1.3 permitted point format
   negotiation; TLS 1.3 removes this feature in favor of a single point
   format for each curve.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.9&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.9&quot; id=&quot;section-4.2.9&quot;&gt;4.2.9&lt;/a&gt;.  Pre-Shared Key Exchange Modes&lt;/span&gt;

   In order to use PSKs, clients MUST also send a
   &quot;psk_key_exchange_modes&quot; extension.  The semantics of this extension
   are that the client only supports the use of PSKs with these modes,
   which restricts both the use of PSKs offered in this ClientHello and
   those which the server might supply via NewSessionTicket.




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 51]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   A client MUST provide a &quot;psk_key_exchange_modes&quot; extension if it
   offers a &quot;pre_shared_key&quot; extension.  If clients offer
   &quot;pre_shared_key&quot; without a &quot;psk_key_exchange_modes&quot; extension,
   servers MUST abort the handshake.  Servers MUST NOT select a key
   exchange mode that is not listed by the client.  This extension also
   restricts the modes for use with PSK resumption.  Servers SHOULD NOT
   send NewSessionTicket with tickets that are not compatible with the
   advertised modes; however, if a server does so, the impact will just
   be that the client's attempts at resumption fail.

   The server MUST NOT send a &quot;psk_key_exchange_modes&quot; extension.

      enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;

      struct {
          PskKeyExchangeMode ke_modes&amp;lt;1..255&amp;gt;;
      } PskKeyExchangeModes;

   psk_ke:  PSK-only key establishment.  In this mode, the server
      MUST NOT supply a &quot;key_share&quot; value.

   psk_dhe_ke:  PSK with (EC)DHE key establishment.  In this mode, the
      client and server MUST supply &quot;key_share&quot; values as described in
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.8&quot;&gt;Section 4.2.8&lt;/a&gt;.

   Any future values that are allocated must ensure that the transmitted
   protocol messages unambiguously identify which mode was selected by
   the server; at present, this is indicated by the presence of the
   &quot;key_share&quot; in the ServerHello.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.10&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.10&quot; id=&quot;section-4.2.10&quot;&gt;4.2.10&lt;/a&gt;.  Early Data Indication&lt;/span&gt;

   When a PSK is used and early data is allowed for that PSK, the client
   can send Application Data in its first flight of messages.  If the
   client opts to do so, it MUST supply both the &quot;pre_shared_key&quot; and
   &quot;early_data&quot; extensions.

   The &quot;extension_data&quot; field of this extension contains an
   &quot;EarlyDataIndication&quot; value.












&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 52]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


      struct {} Empty;

      struct {
          select (Handshake.msg_type) {
              case new_session_ticket:   uint32 max_early_data_size;
              case client_hello:         Empty;
              case encrypted_extensions: Empty;
          };
      } EarlyDataIndication;

   See &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.1&quot;&gt;Section 4.6.1&lt;/a&gt; for details regarding the use of the
   max_early_data_size field.

   The parameters for the 0-RTT data (version, symmetric cipher suite,
   Application-Layer Protocol Negotiation (ALPN) [&lt;a href=&quot;https://tools.ietf.org/html/rfc7301&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension&amp;quot;&quot;&gt;RFC7301&lt;/a&gt;] protocol,
   etc.) are those associated with the PSK in use.  For externally
   provisioned PSKs, the associated values are those provisioned along
   with the key.  For PSKs established via a NewSessionTicket message,
   the associated values are those which were negotiated in the
   connection which established the PSK.  The PSK used to encrypt the
   early data MUST be the first PSK listed in the client's
   &quot;pre_shared_key&quot; extension.

   For PSKs provisioned via NewSessionTicket, a server MUST validate
   that the ticket age for the selected PSK identity (computed by
   subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age
   modulo 2^32) is within a small tolerance of the time since the ticket
   was issued (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-8&quot;&gt;Section 8&lt;/a&gt;).  If it is not, the server SHOULD proceed
   with the handshake but reject 0-RTT, and SHOULD NOT take any other
   action that assumes that this ClientHello is fresh.

   0-RTT messages sent in the first flight have the same (encrypted)
   content types as messages of the same type sent in other flights
   (handshake and application_data) but are protected under different
   keys.  After receiving the server's Finished message, if the server
   has accepted early data, an EndOfEarlyData message will be sent to
   indicate the key change.  This message will be encrypted with the
   0-RTT traffic keys.













&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 53]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   A server which receives an &quot;early_data&quot; extension MUST behave in one
   of three ways:

   -  Ignore the extension and return a regular 1-RTT response.  The
      server then skips past early data by attempting to deprotect
      received records using the handshake traffic key, discarding
      records which fail deprotection (up to the configured
      max_early_data_size).  Once a record is deprotected successfully,
      it is treated as the start of the client's second flight and the
      server proceeds as with an ordinary 1-RTT handshake.

   -  Request that the client send another ClientHello by responding
      with a HelloRetryRequest.  A client MUST NOT include the
      &quot;early_data&quot; extension in its followup ClientHello.  The server
      then ignores early data by skipping all records with an external
      content type of &quot;application_data&quot; (indicating that they are
      encrypted), up to the configured max_early_data_size.

   -  Return its own &quot;early_data&quot; extension in EncryptedExtensions,
      indicating that it intends to process the early data.  It is not
      possible for the server to accept only a subset of the early data
      messages.  Even though the server sends a message accepting early
      data, the actual early data itself may already be in flight by the
      time the server generates this message.

   In order to accept early data, the server MUST have accepted a PSK
   cipher suite and selected the first key offered in the client's
   &quot;pre_shared_key&quot; extension.  In addition, it MUST verify that the
   following values are the same as those associated with the
   selected PSK:

   -  The TLS version number

   -  The selected cipher suite

   -  The selected ALPN [&lt;a href=&quot;https://tools.ietf.org/html/rfc7301&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension&amp;quot;&quot;&gt;RFC7301&lt;/a&gt;] protocol, if any

   These requirements are a superset of those needed to perform a 1-RTT
   handshake using the PSK in question.  For externally established
   PSKs, the associated values are those provisioned along with the key.
   For PSKs established via a NewSessionTicket message, the associated
   values are those negotiated in the connection during which the ticket
   was established.

   Future extensions MUST define their interaction with 0-RTT.






&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 54]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   If any of these checks fail, the server MUST NOT respond with the
   extension and must discard all the first-flight data using one of the
   first two mechanisms listed above (thus falling back to 1-RTT or
   2-RTT).  If the client attempts a 0-RTT handshake but the server
   rejects it, the server will generally not have the 0-RTT record
   protection keys and must instead use trial decryption (either with
   the 1-RTT handshake keys or by looking for a cleartext ClientHello in
   the case of a HelloRetryRequest) to find the first non-0-RTT message.

   If the server chooses to accept the &quot;early_data&quot; extension, then it
   MUST comply with the same error-handling requirements specified for
   all records when processing early data records.  Specifically, if the
   server fails to decrypt a 0-RTT record following an accepted
   &quot;early_data&quot; extension, it MUST terminate the connection with a
   &quot;bad_record_mac&quot; alert as per &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;.

   If the server rejects the &quot;early_data&quot; extension, the client
   application MAY opt to retransmit the Application Data previously
   sent in early data once the handshake has been completed.  Note that
   automatic retransmission of early data could result in incorrect
   assumptions regarding the status of the connection.  For instance,
   when the negotiated connection selects a different ALPN protocol from
   what was used for the early data, an application might need to
   construct different messages.  Similarly, if early data assumes
   anything about the connection state, it might be sent in error after
   the handshake completes.

   A TLS implementation SHOULD NOT automatically resend early data;
   applications are in a better position to decide when retransmission
   is appropriate.  A TLS implementation MUST NOT automatically resend
   early data unless the negotiated connection selects the same ALPN
   protocol.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.11&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.11&quot; id=&quot;section-4.2.11&quot;&gt;4.2.11&lt;/a&gt;.  Pre-Shared Key Extension&lt;/span&gt;

   The &quot;pre_shared_key&quot; extension is used to negotiate the identity of
   the pre-shared key to be used with a given handshake in association
   with PSK key establishment.













&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 55]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   The &quot;extension_data&quot; field of this extension contains a
   &quot;PreSharedKeyExtension&quot; value:

      struct {
          opaque identity&amp;lt;1..2^16-1&amp;gt;;
          uint32 obfuscated_ticket_age;
      } PskIdentity;

      opaque PskBinderEntry&amp;lt;32..255&amp;gt;;

      struct {
          PskIdentity identities&amp;lt;7..2^16-1&amp;gt;;
          PskBinderEntry binders&amp;lt;33..2^16-1&amp;gt;;
      } OfferedPsks;

      struct {
          select (Handshake.msg_type) {
              case client_hello: OfferedPsks;
              case server_hello: uint16 selected_identity;
          };
      } PreSharedKeyExtension;

   identity:  A label for a key.  For instance, a ticket (as defined in
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.4&quot;&gt;Appendix B.3.4&lt;/a&gt;) or a label for a pre-shared key established
      externally.

   obfuscated_ticket_age:  An obfuscated version of the age of the key.
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.11.1&quot;&gt;Section 4.2.11.1&lt;/a&gt; describes how to form this value for identities
      established via the NewSessionTicket message.  For identities
      established externally, an obfuscated_ticket_age of 0 SHOULD be
      used, and servers MUST ignore the value.

   identities:  A list of the identities that the client is willing to
      negotiate with the server.  If sent alongside the &quot;early_data&quot;
      extension (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.10&quot;&gt;Section 4.2.10&lt;/a&gt;), the first identity is the one used
      for 0-RTT data.

   binders:  A series of HMAC values, one for each value in the
      identities list and in the same order, computed as described
      below.

   selected_identity:  The server's chosen identity expressed as a
      (0-based) index into the identities in the client's list.

   Each PSK is associated with a single Hash algorithm.  For PSKs
   established via the ticket mechanism (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.1&quot;&gt;Section 4.6.1&lt;/a&gt;), this is the KDF
   Hash algorithm on the connection where the ticket was established.
   For externally established PSKs, the Hash algorithm MUST be set when



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 56]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   the PSK is established or default to SHA-256 if no such algorithm is
   defined.  The server MUST ensure that it selects a compatible PSK
   (if any) and cipher suite.

   In TLS versions prior to TLS 1.3, the Server Name Identification
   (SNI) value was intended to be associated with the session (&lt;a href=&quot;https://tools.ietf.org/html/rfc6066#section-3&quot;&gt;Section 3
   of [RFC6066]&lt;/a&gt;), with the server being required to enforce that the SNI
   value associated with the session matches the one specified in the
   resumption handshake.  However, in reality the implementations were
   not consistent on which of two supplied SNI values they would use,
   leading to the consistency requirement being de facto enforced by the
   clients.  In TLS 1.3, the SNI value is always explicitly specified in
   the resumption handshake, and there is no need for the server to
   associate an SNI value with the ticket.  Clients, however, SHOULD
   store the SNI with the PSK to fulfill the requirements of
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.1&quot;&gt;Section 4.6.1&lt;/a&gt;.

   Implementor's note: When session resumption is the primary use case
   of PSKs, the most straightforward way to implement the PSK/cipher
   suite matching requirements is to negotiate the cipher suite first
   and then exclude any incompatible PSKs.  Any unknown PSKs (e.g., ones
   not in the PSK database or encrypted with an unknown key) SHOULD
   simply be ignored.  If no acceptable PSKs are found, the server
   SHOULD perform a non-PSK handshake if possible.  If backward
   compatibility is important, client-provided, externally established
   PSKs SHOULD influence cipher suite selection.

   Prior to accepting PSK key establishment, the server MUST validate
   the corresponding binder value (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.11.2&quot;&gt;Section 4.2.11.2&lt;/a&gt; below).  If this
   value is not present or does not validate, the server MUST abort the
   handshake.  Servers SHOULD NOT attempt to validate multiple binders;
   rather, they SHOULD select a single PSK and validate solely the
   binder that corresponds to that PSK.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-8.2&quot;&gt;Section 8.2&lt;/a&gt; and
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.6&quot;&gt;Appendix E.6&lt;/a&gt; for the security rationale for this requirement.  In
   order to accept PSK key establishment, the server sends a
   &quot;pre_shared_key&quot; extension indicating the selected identity.

   Clients MUST verify that the server's selected_identity is within the
   range supplied by the client, that the server selected a cipher suite
   indicating a Hash associated with the PSK, and that a server
   &quot;key_share&quot; extension is present if required by the ClientHello
   &quot;psk_key_exchange_modes&quot; extension.  If these values are not
   consistent, the client MUST abort the handshake with an
   &quot;illegal_parameter&quot; alert.







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 57]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   If the server supplies an &quot;early_data&quot; extension, the client MUST
   verify that the server's selected_identity is 0.  If any other value
   is returned, the client MUST abort the handshake with an
   &quot;illegal_parameter&quot; alert.

   The &quot;pre_shared_key&quot; extension MUST be the last extension in the
   ClientHello (this facilitates implementation as described below).
   Servers MUST check that it is the last extension and otherwise fail
   the handshake with an &quot;illegal_parameter&quot; alert.

&lt;span class=&quot;h5&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.11.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.11.1&quot; id=&quot;section-4.2.11.1&quot;&gt;4.2.11.1&lt;/a&gt;.  Ticket Age&lt;/span&gt;

   The client's view of the age of a ticket is the time since the
   receipt of the NewSessionTicket message.  Clients MUST NOT attempt to
   use tickets which have ages greater than the &quot;ticket_lifetime&quot; value
   which was provided with the ticket.  The &quot;obfuscated_ticket_age&quot;
   field of each PskIdentity contains an obfuscated version of the
   ticket age formed by taking the age in milliseconds and adding the
   &quot;ticket_age_add&quot; value that was included with the ticket (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.1&quot;&gt;Section 4.6.1&lt;/a&gt;), modulo 2^32.  This addition prevents passive
   observers from correlating connections unless tickets are reused.
   Note that the &quot;ticket_lifetime&quot; field in the NewSessionTicket message
   is in seconds but the &quot;obfuscated_ticket_age&quot; is in milliseconds.
   Because ticket lifetimes are restricted to a week, 32 bits is enough
   to represent any plausible age, even in milliseconds.

&lt;span class=&quot;h5&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.11.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.11.2&quot; id=&quot;section-4.2.11.2&quot;&gt;4.2.11.2&lt;/a&gt;.  PSK Binder&lt;/span&gt;

   The PSK binder value forms a binding between a PSK and the current
   handshake, as well as a binding between the handshake in which the
   PSK was generated (if via a NewSessionTicket message) and the current
   handshake.  Each entry in the binders list is computed as an HMAC
   over a transcript hash (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.1&quot;&gt;Section 4.4.1&lt;/a&gt;) containing a partial
   ClientHello up to and including the PreSharedKeyExtension.identities
   field.  That is, it includes all of the ClientHello but not the
   binders list itself.  The length fields for the message (including
   the overall length, the length of the extensions block, and the
   length of the &quot;pre_shared_key&quot; extension) are all set as if binders
   of the correct lengths were present.

   The PskBinderEntry is computed in the same way as the Finished
   message (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.4&quot;&gt;Section 4.4.4&lt;/a&gt;) but with the BaseKey being the binder_key
   derived via the key schedule from the corresponding PSK which is
   being offered (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.1&quot;&gt;Section 7.1&lt;/a&gt;).







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 58]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   If the handshake includes a HelloRetryRequest, the initial
   ClientHello and HelloRetryRequest are included in the transcript
   along with the new ClientHello.  For instance, if the client sends
   ClientHello1, its binder will be computed over:

      Transcript-Hash(Truncate(ClientHello1))

   Where Truncate() removes the binders list from the ClientHello.

   If the server responds with a HelloRetryRequest and the client then
   sends ClientHello2, its binder will be computed over:

      Transcript-Hash(ClientHello1,
                      HelloRetryRequest,
                      Truncate(ClientHello2))

   The full ClientHello1/ClientHello2 is included in all other handshake
   hash computations.  Note that in the first flight,
   Truncate(ClientHello1) is hashed directly, but in the second flight,
   ClientHello1 is hashed and then reinjected as a &quot;message_hash&quot;
   message, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.1&quot;&gt;Section 4.4.1&lt;/a&gt;.

&lt;span class=&quot;h5&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.2.11.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.11.3&quot; id=&quot;section-4.2.11.3&quot;&gt;4.2.11.3&lt;/a&gt;.  Processing Order&lt;/span&gt;

   Clients are permitted to &quot;stream&quot; 0-RTT data until they receive the
   server's Finished, only then sending the EndOfEarlyData message,
   followed by the rest of the handshake.  In order to avoid deadlocks,
   when accepting &quot;early_data&quot;, servers MUST process the client's
   ClientHello and then immediately send their flight of messages,
   rather than waiting for the client's EndOfEarlyData message before
   sending its ServerHello.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.3&quot; id=&quot;section-4.3&quot;&gt;4.3&lt;/a&gt;.  Server Parameters&lt;/span&gt;

   The next two messages from the server, EncryptedExtensions and
   CertificateRequest, contain information from the server that
   determines the rest of the handshake.  These messages are encrypted
   with keys derived from the server_handshake_traffic_secret.













&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 59]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.3.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.3.1&quot; id=&quot;section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;.  Encrypted Extensions&lt;/span&gt;

   In all handshakes, the server MUST send the EncryptedExtensions
   message immediately after the ServerHello message.  This is the first
   message that is encrypted under keys derived from the
   server_handshake_traffic_secret.

   The EncryptedExtensions message contains extensions that can be
   protected, i.e., any which are not needed to establish the
   cryptographic context but which are not associated with individual
   certificates.  The client MUST check EncryptedExtensions for the
   presence of any forbidden extensions and if any are found MUST abort
   the handshake with an &quot;illegal_parameter&quot; alert.

   Structure of this message:

      struct {
          Extension extensions&amp;lt;0..2^16-1&amp;gt;;
      } EncryptedExtensions;

   extensions:  A list of extensions.  For more information, see the
      table in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.3.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.3.2&quot; id=&quot;section-4.3.2&quot;&gt;4.3.2&lt;/a&gt;.  Certificate Request&lt;/span&gt;

   A server which is authenticating with a certificate MAY optionally
   request a certificate from the client.  This message, if sent, MUST
   follow EncryptedExtensions.

   Structure of this message:

      struct {
          opaque certificate_request_context&amp;lt;0..2^8-1&amp;gt;;
          Extension extensions&amp;lt;2..2^16-1&amp;gt;;
      } CertificateRequest;
















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 60]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   certificate_request_context:  An opaque string which identifies the
      certificate request and which will be echoed in the client's
      Certificate message.  The certificate_request_context MUST be
      unique within the scope of this connection (thus preventing replay
      of client CertificateVerify messages).  This field SHALL be zero
      length unless used for the post-handshake authentication exchanges
      described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.2&quot;&gt;Section 4.6.2&lt;/a&gt;.  When requesting post-handshake
      authentication, the server SHOULD make the context unpredictable
      to the client (e.g., by randomly generating it) in order to
      prevent an attacker who has temporary access to the client's
      private key from pre-computing valid CertificateVerify messages.

   extensions:  A set of extensions describing the parameters of the
      certificate being requested.  The &quot;signature_algorithms&quot; extension
      MUST be specified, and other extensions may optionally be included
      if defined for this message.  Clients MUST ignore unrecognized
      extensions.

   In prior versions of TLS, the CertificateRequest message carried a
   list of signature algorithms and certificate authorities which the
   server would accept.  In TLS 1.3, the former is expressed by sending
   the &quot;signature_algorithms&quot; and optionally &quot;signature_algorithms_cert&quot;
   extensions.  The latter is expressed by sending the
   &quot;certificate_authorities&quot; extension (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;).

   Servers which are authenticating with a PSK MUST NOT send the
   CertificateRequest message in the main handshake, though they MAY
   send it in post-handshake authentication (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.2&quot;&gt;Section 4.6.2&lt;/a&gt;) provided
   that the client has sent the &quot;post_handshake_auth&quot; extension (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.6&quot;&gt;Section 4.2.6&lt;/a&gt;).

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4&quot; id=&quot;section-4.4&quot;&gt;4.4&lt;/a&gt;.  Authentication Messages&lt;/span&gt;

   As discussed in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-2&quot;&gt;Section 2&lt;/a&gt;, TLS generally uses a common set of
   messages for authentication, key confirmation, and handshake
   integrity: Certificate, CertificateVerify, and Finished.  (The PSK
   binders also perform key confirmation, in a similar fashion.)  These
   three messages are always sent as the last messages in their
   handshake flight.  The Certificate and CertificateVerify messages are
   only sent under certain circumstances, as defined below.  The
   Finished message is always sent as part of the Authentication Block.
   These messages are encrypted under keys derived from the
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-sender&quot;&gt;sender&lt;/a&gt;]_handshake_traffic_secret.








&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 61]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   The computations for the Authentication messages all uniformly take
   the following inputs:

   -  The certificate and signing key to be used.

   -  A Handshake Context consisting of the set of messages to be
      included in the transcript hash.

   -  A Base Key to be used to compute a MAC key.

   Based on these inputs, the messages then contain:

   Certificate:  The certificate to be used for authentication, and any
      supporting certificates in the chain.  Note that certificate-based
      client authentication is not available in PSK handshake flows
      (including 0-RTT).

   CertificateVerify:  A signature over the value
      Transcript-Hash(Handshake Context, Certificate).

   Finished:  A MAC over the value Transcript-Hash(Handshake Context,
      Certificate, CertificateVerify) using a MAC key derived from the
      Base Key.

   The following table defines the Handshake Context and MAC Base Key
   for each scenario:

   +-----------+-------------------------+-----------------------------+
   | Mode      | Handshake Context       | Base Key                    |
   +-----------+-------------------------+-----------------------------+
   | Server    | ClientHello ... later   | server_handshake_traffic_   |
   |           | of EncryptedExtensions/ | secret                      |
   |           | CertificateRequest      |                             |
   |           |                         |                             |
   | Client    | ClientHello ... later   | client_handshake_traffic_   |
   |           | of server               | secret                      |
   |           | Finished/EndOfEarlyData |                             |
   |           |                         |                             |
   | Post-     | ClientHello ... client  | client_application_traffic_ |
   | Handshake | Finished +              | secret_N                    |
   |           | CertificateRequest      |                             |
   +-----------+-------------------------+-----------------------------+









&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 62]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.4.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.1&quot; id=&quot;section-4.4.1&quot;&gt;4.4.1&lt;/a&gt;.  The Transcript Hash&lt;/span&gt;

   Many of the cryptographic computations in TLS make use of a
   transcript hash.  This value is computed by hashing the concatenation
   of each included handshake message, including the handshake message
   header carrying the handshake message type and length fields, but not
   including record layer headers.  I.e.,

    Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)

   As an exception to this general rule, when the server responds to a
   ClientHello with a HelloRetryRequest, the value of ClientHello1 is
   replaced with a special synthetic handshake message of handshake type
   &quot;message_hash&quot; containing Hash(ClientHello1).  I.e.,

  Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =
      Hash(message_hash ||        /* Handshake type */
           00 00 Hash.length  ||  /* Handshake message length (bytes) */
           Hash(ClientHello1) ||  /* Hash of ClientHello1 */
           HelloRetryRequest  || ... || Mn)

   The reason for this construction is to allow the server to do a
   stateless HelloRetryRequest by storing just the hash of ClientHello1
   in the cookie, rather than requiring it to export the entire
   intermediate hash state (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;).

   For concreteness, the transcript hash is always taken from the
   following sequence of handshake messages, starting at the first
   ClientHello and including only those messages that were sent:
   ClientHello, HelloRetryRequest, ClientHello, ServerHello,
   EncryptedExtensions, server CertificateRequest, server Certificate,
   server CertificateVerify, server Finished, EndOfEarlyData, client
   Certificate, client CertificateVerify, client Finished.

   In general, implementations can implement the transcript by keeping a
   running transcript hash value based on the negotiated hash.  Note,
   however, that subsequent post-handshake authentications do not
   include each other, just the messages through the end of the main
   handshake.












&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 63]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.4.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.2&quot; id=&quot;section-4.4.2&quot;&gt;4.4.2&lt;/a&gt;.  Certificate&lt;/span&gt;

   This message conveys the endpoint's certificate chain to the peer.

   The server MUST send a Certificate message whenever the agreed-upon
   key exchange method uses certificates for authentication (this
   includes all key exchange methods defined in this document
   except PSK).

   The client MUST send a Certificate message if and only if the server
   has requested client authentication via a CertificateRequest message
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt;).  If the server requests client authentication but no
   suitable certificate is available, the client MUST send a Certificate
   message containing no certificates (i.e., with the &quot;certificate_list&quot;
   field having length 0).  A Finished message MUST be sent regardless
   of whether the Certificate message is empty.

   Structure of this message:

      enum {
          X509(0),
          RawPublicKey(2),
          (255)
      } CertificateType;

      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From &lt;a href=&quot;https://tools.ietf.org/html/rfc7250&quot;&gt;RFC 7250&lt;/a&gt; ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo&amp;lt;1..2^24-1&amp;gt;;

              case X509:
                opaque cert_data&amp;lt;1..2^24-1&amp;gt;;
          };
          Extension extensions&amp;lt;0..2^16-1&amp;gt;;
      } CertificateEntry;

      struct {
          opaque certificate_request_context&amp;lt;0..2^8-1&amp;gt;;
          CertificateEntry certificate_list&amp;lt;0..2^24-1&amp;gt;;
      } Certificate;










&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 64]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   certificate_request_context:  If this message is in response to a
      CertificateRequest, the value of certificate_request_context in
      that message.  Otherwise (in the case of server authentication),
      this field SHALL be zero length.

   certificate_list:  A sequence (chain) of CertificateEntry structures,
      each containing a single certificate and set of extensions.

   extensions:  A set of extension values for the CertificateEntry.  The
      &quot;Extension&quot; format is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;.  Valid extensions
      for server certificates at present include the OCSP Status
      extension [&lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Extensions: Extension Definitions&amp;quot;&quot;&gt;RFC6066&lt;/a&gt;] and the SignedCertificateTimestamp extension
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc6962&quot; title=&quot;&amp;quot;Certificate Transparency&amp;quot;&quot;&gt;RFC6962&lt;/a&gt;]; future extensions may be defined for this message as
      well.  Extensions in the Certificate message from the server MUST
      correspond to ones from the ClientHello message.  Extensions in
      the Certificate message from the client MUST correspond to
      extensions in the CertificateRequest message from the server.  If
      an extension applies to the entire chain, it SHOULD be included in
      the first CertificateEntry.

   If the corresponding certificate type extension
   (&quot;server_certificate_type&quot; or &quot;client_certificate_type&quot;) was not
   negotiated in EncryptedExtensions, or the X.509 certificate type was
   negotiated, then each CertificateEntry contains a DER-encoded X.509
   certificate.  The sender's certificate MUST come in the first
   CertificateEntry in the list.  Each following certificate SHOULD
   directly certify the one immediately preceding it.  Because
   certificate validation requires that trust anchors be distributed
   independently, a certificate that specifies a trust anchor MAY be
   omitted from the chain, provided that supported peers are known to
   possess any omitted certificates.

   Note: Prior to TLS 1.3, &quot;certificate_list&quot; ordering required each
   certificate to certify the one immediately preceding it; however,
   some implementations allowed some flexibility.  Servers sometimes
   send both a current and deprecated intermediate for transitional
   purposes, and others are simply configured incorrectly, but these
   cases can nonetheless be validated properly.  For maximum
   compatibility, all implementations SHOULD be prepared to handle
   potentially extraneous certificates and arbitrary orderings from any
   TLS version, with the exception of the end-entity certificate which
   MUST be first.

   If the RawPublicKey certificate type was negotiated, then the
   certificate_list MUST contain no more than one CertificateEntry,
   which contains an ASN1_subjectPublicKeyInfo value as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7250#section-3&quot;&gt;[RFC7250], Section 3&lt;/a&gt;.




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 65]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   The OpenPGP certificate type [&lt;a href=&quot;https://tools.ietf.org/html/rfc6091&quot; title=&quot;&amp;quot;Using OpenPGP Keys for Transport Layer Security (TLS) Authentication&amp;quot;&quot;&gt;RFC6091&lt;/a&gt;] MUST NOT be used with TLS 1.3.

   The server's certificate_list MUST always be non-empty.  A client
   will send an empty certificate_list if it does not have an
   appropriate certificate to send in response to the server's
   authentication request.

&lt;span class=&quot;h5&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.4.2.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.2.1&quot; id=&quot;section-4.4.2.1&quot;&gt;4.4.2.1&lt;/a&gt;.  OCSP Status and SCT Extensions&lt;/span&gt;

   [&lt;a name=&quot;ref-RFC6066&quot; id=&quot;ref-RFC6066&quot;&gt;RFC6066&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc6961&quot; title=&quot;&amp;quot;The Transport Layer Security (TLS) Multiple Certificate Status Request Extension&amp;quot;&quot;&gt;RFC6961&lt;/a&gt;] provide extensions to negotiate the server
   sending OCSP responses to the client.  In TLS 1.2 and below, the
   server replies with an empty extension to indicate negotiation of
   this extension and the OCSP information is carried in a
   CertificateStatus message.  In TLS 1.3, the server's OCSP information
   is carried in an extension in the CertificateEntry containing the
   associated certificate.  Specifically, the body of the
   &quot;status_request&quot; extension from the server MUST be a
   CertificateStatus structure as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Extensions: Extension Definitions&amp;quot;&quot;&gt;RFC6066&lt;/a&gt;], which is
   interpreted as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc6960&quot; title=&quot;&amp;quot;X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP&amp;quot;&quot;&gt;RFC6960&lt;/a&gt;].

   Note: The status_request_v2 extension [&lt;a href=&quot;https://tools.ietf.org/html/rfc6961&quot; title=&quot;&amp;quot;The Transport Layer Security (TLS) Multiple Certificate Status Request Extension&amp;quot;&quot;&gt;RFC6961&lt;/a&gt;] is deprecated.
   TLS 1.3 servers MUST NOT act upon its presence or information in it
   when processing ClientHello messages; in particular, they MUST NOT
   send the status_request_v2 extension in the EncryptedExtensions,
   CertificateRequest, or Certificate messages.  TLS 1.3 servers MUST be
   able to process ClientHello messages that include it, as it MAY be
   sent by clients that wish to use it in earlier protocol versions.

   A server MAY request that a client present an OCSP response with its
   certificate by sending an empty &quot;status_request&quot; extension in its
   CertificateRequest message.  If the client opts to send an OCSP
   response, the body of its &quot;status_request&quot; extension MUST be a
   CertificateStatus structure as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Extensions: Extension Definitions&amp;quot;&quot;&gt;RFC6066&lt;/a&gt;].

   Similarly, [&lt;a href=&quot;https://tools.ietf.org/html/rfc6962&quot; title=&quot;&amp;quot;Certificate Transparency&amp;quot;&quot;&gt;RFC6962&lt;/a&gt;] provides a mechanism for a server to send a
   Signed Certificate Timestamp (SCT) as an extension in the ServerHello
   in TLS 1.2 and below.  In TLS 1.3, the server's SCT information is
   carried in an extension in the CertificateEntry.













&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 66]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h5&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.4.2.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.2.2&quot; id=&quot;section-4.4.2.2&quot;&gt;4.4.2.2&lt;/a&gt;.  Server Certificate Selection&lt;/span&gt;

   The following rules apply to the certificates sent by the server:

   -  The certificate type MUST be X.509v3 [&lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot; title=&quot;&amp;quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&amp;quot;&quot;&gt;RFC5280&lt;/a&gt;], unless explicitly
      negotiated otherwise (e.g., [&lt;a href=&quot;https://tools.ietf.org/html/rfc7250&quot; title=&quot;&amp;quot;Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)&amp;quot;&quot;&gt;RFC7250&lt;/a&gt;]).

   -  The server's end-entity certificate's public key (and associated
      restrictions) MUST be compatible with the selected authentication
      algorithm from the client's &quot;signature_algorithms&quot; extension
      (currently RSA, ECDSA, or EdDSA).

   -  The certificate MUST allow the key to be used for signing (i.e.,
      the digitalSignature bit MUST be set if the Key Usage extension is
      present) with a signature scheme indicated in the client's
      &quot;signature_algorithms&quot;/&quot;signature_algorithms_cert&quot; extensions (see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;).

   -  The &quot;server_name&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Extensions: Extension Definitions&amp;quot;&quot;&gt;RFC6066&lt;/a&gt;] and &quot;certificate_authorities&quot;
      extensions are used to guide certificate selection.  As servers
      MAY require the presence of the &quot;server_name&quot; extension, clients
      SHOULD send this extension, when applicable.

   All certificates provided by the server MUST be signed by a signature
   algorithm advertised by the client if it is able to provide such a
   chain (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;).  Certificates that are self-signed or
   certificates that are expected to be trust anchors are not validated
   as part of the chain and therefore MAY be signed with any algorithm.

   If the server cannot produce a certificate chain that is signed only
   via the indicated supported algorithms, then it SHOULD continue the
   handshake by sending the client a certificate chain of its choice
   that may include algorithms that are not known to be supported by the
   client.  This fallback chain SHOULD NOT use the deprecated SHA-1 hash
   algorithm in general, but MAY do so if the client's advertisement
   permits it, and MUST NOT do so otherwise.

   If the client cannot construct an acceptable chain using the provided
   certificates and decides to abort the handshake, then it MUST abort
   the handshake with an appropriate certificate-related alert (by
   default, &quot;unsupported_certificate&quot;; see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-6.2&quot;&gt;Section 6.2&lt;/a&gt; for more
   information).

   If the server has multiple certificates, it chooses one of them based
   on the above-mentioned criteria (in addition to other criteria, such
   as transport-layer endpoint, local configuration, and preferences).





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 67]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h5&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.4.2.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.2.3&quot; id=&quot;section-4.4.2.3&quot;&gt;4.4.2.3&lt;/a&gt;.  Client Certificate Selection&lt;/span&gt;

   The following rules apply to certificates sent by the client:

   -  The certificate type MUST be X.509v3 [&lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot; title=&quot;&amp;quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&amp;quot;&quot;&gt;RFC5280&lt;/a&gt;], unless explicitly
      negotiated otherwise (e.g., [&lt;a href=&quot;https://tools.ietf.org/html/rfc7250&quot; title=&quot;&amp;quot;Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)&amp;quot;&quot;&gt;RFC7250&lt;/a&gt;]).

   -  If the &quot;certificate_authorities&quot; extension in the
      CertificateRequest message was present, at least one of the
      certificates in the certificate chain SHOULD be issued by one of
      the listed CAs.

   -  The certificates MUST be signed using an acceptable signature
      algorithm, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt;.  Note that this relaxes
      the constraints on certificate-signing algorithms found in prior
      versions of TLS.

   -  If the CertificateRequest message contained a non-empty
      &quot;oid_filters&quot; extension, the end-entity certificate MUST match the
      extension OIDs that are recognized by the client, as described in
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.5&quot;&gt;Section 4.2.5&lt;/a&gt;.

&lt;span class=&quot;h5&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.4.2.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.2.4&quot; id=&quot;section-4.4.2.4&quot;&gt;4.4.2.4&lt;/a&gt;.  Receiving a Certificate Message&lt;/span&gt;

   In general, detailed certificate validation procedures are out of
   scope for TLS (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot; title=&quot;&amp;quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&amp;quot;&quot;&gt;RFC5280&lt;/a&gt;]).  This section provides TLS-specific
   requirements.

   If the server supplies an empty Certificate message, the client MUST
   abort the handshake with a &quot;decode_error&quot; alert.

   If the client does not send any certificates (i.e., it sends an empty
   Certificate message), the server MAY at its discretion either
   continue the handshake without client authentication or abort the
   handshake with a &quot;certificate_required&quot; alert.  Also, if some aspect
   of the certificate chain was unacceptable (e.g., it was not signed by
   a known, trusted CA), the server MAY at its discretion either
   continue the handshake (considering the client unauthenticated) or
   abort the handshake.

   Any endpoint receiving any certificate which it would need to
   validate using any signature algorithm using an MD5 hash MUST abort
   the handshake with a &quot;bad_certificate&quot; alert.  SHA-1 is deprecated,
   and it is RECOMMENDED that any endpoint receiving any certificate
   which it would need to validate using any signature algorithm using a
   SHA-1 hash abort the handshake with a &quot;bad_certificate&quot; alert.  For
   clarity, this means that endpoints can accept these algorithms for
   certificates that are self-signed or are trust anchors.



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 68]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   All endpoints are RECOMMENDED to transition to SHA-256 or better as
   soon as possible to maintain interoperability with implementations
   currently in the process of phasing out SHA-1 support.

   Note that a certificate containing a key for one signature algorithm
   MAY be signed using a different signature algorithm (for instance, an
   RSA key signed with an ECDSA key).

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.4.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.3&quot; id=&quot;section-4.4.3&quot;&gt;4.4.3&lt;/a&gt;.  Certificate Verify&lt;/span&gt;

   This message is used to provide explicit proof that an endpoint
   possesses the private key corresponding to its certificate.  The
   CertificateVerify message also provides integrity for the handshake
   up to this point.  Servers MUST send this message when authenticating
   via a certificate.  Clients MUST send this message whenever
   authenticating via a certificate (i.e., when the Certificate message
   is non-empty).  When sent, this message MUST appear immediately after
   the Certificate message and immediately prior to the Finished
   message.

   Structure of this message:

      struct {
          SignatureScheme algorithm;
          opaque signature&amp;lt;0..2^16-1&amp;gt;;
      } CertificateVerify;

   The algorithm field specifies the signature algorithm used (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; for the definition of this type).  The signature is a
   digital signature using that algorithm.  The content that is covered
   under the signature is the hash output as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.1&quot;&gt;Section 4.4.1&lt;/a&gt;,
   namely:

      Transcript-Hash(Handshake Context, Certificate)

   The digital signature is then computed over the concatenation of:

   -  A string that consists of octet 32 (0x20) repeated 64 times

   -  The context string

   -  A single 0 byte which serves as the separator

   -  The content to be signed







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 69]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   This structure is intended to prevent an attack on previous versions
   of TLS in which the ServerKeyExchange format meant that attackers
   could obtain a signature of a message with a chosen 32-byte prefix
   (ClientHello.random).  The initial 64-byte pad clears that prefix
   along with the server-controlled ServerHello.random.

   The context string for a server signature is
   &quot;TLS 1.3, server CertificateVerify&quot;.  The context string for a
   client signature is &quot;TLS 1.3, client CertificateVerify&quot;.  It is
   used to provide separation between signatures made in different
   contexts, helping against potential cross-protocol attacks.

   For example, if the transcript hash was 32 bytes of 01 (this length
   would make sense for SHA-256), the content covered by the digital
   signature for a server CertificateVerify would be:

      2020202020202020202020202020202020202020202020202020202020202020
      2020202020202020202020202020202020202020202020202020202020202020
      544c5320312e332c207365727665722043657274696669636174655665726966
      79
      00
      0101010101010101010101010101010101010101010101010101010101010101

   On the sender side, the process for computing the signature field of
   the CertificateVerify message takes as input:

   -  The content covered by the digital signature

   -  The private signing key corresponding to the certificate sent in
      the previous message

   If the CertificateVerify message is sent by a server, the signature
   algorithm MUST be one offered in the client's &quot;signature_algorithms&quot;
   extension unless no valid certificate chain can be produced without
   unsupported algorithms (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;).

   If sent by a client, the signature algorithm used in the signature
   MUST be one of those present in the supported_signature_algorithms
   field of the &quot;signature_algorithms&quot; extension in the
   CertificateRequest message.

   In addition, the signature algorithm MUST be compatible with the key
   in the sender's end-entity certificate.  RSA signatures MUST use an
   RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5
   algorithms appear in &quot;signature_algorithms&quot;.  The SHA-1 algorithm
   MUST NOT be used in any signatures of CertificateVerify messages.





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 70]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   All SHA-1 signature algorithms in this specification are defined
   solely for use in legacy certificates and are not valid for
   CertificateVerify signatures.

   The receiver of a CertificateVerify message MUST verify the signature
   field.  The verification process takes as input:

   -  The content covered by the digital signature

   -  The public key contained in the end-entity certificate found in
      the associated Certificate message

   -  The digital signature received in the signature field of the
      CertificateVerify message

   If the verification fails, the receiver MUST terminate the handshake
   with a &quot;decrypt_error&quot; alert.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.4.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.4&quot; id=&quot;section-4.4.4&quot;&gt;4.4.4&lt;/a&gt;.  Finished&lt;/span&gt;

   The Finished message is the final message in the Authentication
   Block.  It is essential for providing authentication of the handshake
   and of the computed keys.

   Recipients of Finished messages MUST verify that the contents are
   correct and if incorrect MUST terminate the connection with a
   &quot;decrypt_error&quot; alert.

   Once a side has sent its Finished message and has received and
   validated the Finished message from its peer, it may begin to send
   and receive Application Data over the connection.  There are two
   settings in which it is permitted to send data prior to receiving the
   peer's Finished:

   1.  Clients sending 0-RTT data as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.10&quot;&gt;Section 4.2.10&lt;/a&gt;.

   2.  Servers MAY send data after sending their first flight, but
       because the handshake is not yet complete, they have no assurance
       of either the peer's identity or its liveness (i.e., the
       ClientHello might have been replayed).











&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 71]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   The key used to compute the Finished message is computed from the
   Base Key defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; using HKDF (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.1&quot;&gt;Section 7.1&lt;/a&gt;).
   Specifically:

   finished_key =
       HKDF-Expand-Label(BaseKey, &quot;finished&quot;, &quot;&quot;, Hash.length)

   Structure of this message:

      struct {
          opaque verify_data[Hash.length];
      } Finished;

   The verify_data value is computed as follows:

      verify_data =
          HMAC(finished_key,
               Transcript-Hash(Handshake Context,
                               Certificate*, CertificateVerify*))

      * Only included if present.

   HMAC [&lt;a href=&quot;https://tools.ietf.org/html/rfc2104&quot; title=&quot;&amp;quot;HMAC: Keyed- Hashing for Message Authentication&amp;quot;&quot;&gt;RFC2104&lt;/a&gt;] uses the Hash algorithm for the handshake.  As noted
   above, the HMAC input can generally be implemented by a running hash,
   i.e., just the handshake hash at this point.

   In previous versions of TLS, the verify_data was always 12 octets
   long.  In TLS 1.3, it is the size of the HMAC output for the Hash
   used for the handshake.

   Note: Alerts and any other non-handshake record types are not
   handshake messages and are not included in the hash computations.

   Any records following a Finished message MUST be encrypted under the
   appropriate application traffic key as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;.  In
   particular, this includes any alerts sent by the server in response
   to client Certificate and CertificateVerify messages.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.5&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.5&quot; id=&quot;section-4.5&quot;&gt;4.5&lt;/a&gt;.  End of Early Data&lt;/span&gt;

      struct {} EndOfEarlyData;

   If the server sent an &quot;early_data&quot; extension in EncryptedExtensions,
   the client MUST send an EndOfEarlyData message after receiving the
   server Finished.  If the server does not send an &quot;early_data&quot;
   extension in EncryptedExtensions, then the client MUST NOT send an
   EndOfEarlyData message.  This message indicates that all 0-RTT
   application_data messages, if any, have been transmitted and that the



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 72]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   following records are protected under handshake traffic keys.
   Servers MUST NOT send this message, and clients receiving it MUST
   terminate the connection with an &quot;unexpected_message&quot; alert.  This
   message is encrypted under keys derived from the
   client_early_traffic_secret.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.6&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6&quot; id=&quot;section-4.6&quot;&gt;4.6&lt;/a&gt;.  Post-Handshake Messages&lt;/span&gt;

   TLS also allows other messages to be sent after the main handshake.
   These messages use a handshake content type and are encrypted under
   the appropriate application traffic key.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.6.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.1&quot; id=&quot;section-4.6.1&quot;&gt;4.6.1&lt;/a&gt;.  New Session Ticket Message&lt;/span&gt;

   At any time after the server has received the client Finished
   message, it MAY send a NewSessionTicket message.  This message
   creates a unique association between the ticket value and a secret
   PSK derived from the resumption master secret (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7&quot;&gt;Section 7&lt;/a&gt;).

   The client MAY use this PSK for future handshakes by including the
   ticket value in the &quot;pre_shared_key&quot; extension in its ClientHello
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.11&quot;&gt;Section 4.2.11&lt;/a&gt;).  Servers MAY send multiple tickets on a single
   connection, either immediately after each other or after specific
   events (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C.4&quot;&gt;Appendix C.4&lt;/a&gt;).  For instance, the server might send a new
   ticket after post-handshake authentication in order to encapsulate
   the additional client authentication state.  Multiple tickets are
   useful for clients for a variety of purposes, including:

   -  Opening multiple parallel HTTP connections.

   -  Performing connection racing across interfaces and address
      families via (for example) Happy Eyeballs [&lt;a href=&quot;https://tools.ietf.org/html/rfc8305&quot; title=&quot;&amp;quot;Happy Eyeballs Version 2: Better Connectivity Using Concurrency&amp;quot;&quot;&gt;RFC8305&lt;/a&gt;] or related
      techniques.

   Any ticket MUST only be resumed with a cipher suite that has the same
   KDF hash algorithm as that used to establish the original connection.

   Clients MUST only resume if the new SNI value is valid for the server
   certificate presented in the original session and SHOULD only resume
   if the SNI value matches the one used in the original session.  The
   latter is a performance optimization: normally, there is no reason to
   expect that different servers covered by a single certificate would
   be able to accept each other's tickets; hence, attempting resumption
   in that case would waste a single-use ticket.  If such an indication
   is provided (externally or by any other means), clients MAY resume
   with a different SNI value.





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 73]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   On resumption, if reporting an SNI value to the calling application,
   implementations MUST use the value sent in the resumption ClientHello
   rather than the value sent in the previous session.  Note that if a
   server implementation declines all PSK identities with different SNI
   values, these two values are always the same.

   Note: Although the resumption master secret depends on the client's
   second flight, a server which does not request client authentication
   MAY compute the remainder of the transcript independently and then
   send a NewSessionTicket immediately upon sending its Finished rather
   than waiting for the client Finished.  This might be appropriate in
   cases where the client is expected to open multiple TLS connections
   in parallel and would benefit from the reduced overhead of a
   resumption handshake, for example.

      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce&amp;lt;0..255&amp;gt;;
          opaque ticket&amp;lt;1..2^16-1&amp;gt;;
          Extension extensions&amp;lt;0..2^16-2&amp;gt;;
      } NewSessionTicket;

   ticket_lifetime:  Indicates the lifetime in seconds as a 32-bit
      unsigned integer in network byte order from the time of ticket
      issuance.  Servers MUST NOT use any value greater than
      604800 seconds (7 days).  The value of zero indicates that the
      ticket should be discarded immediately.  Clients MUST NOT cache
      tickets for longer than 7 days, regardless of the ticket_lifetime,
      and MAY delete tickets earlier based on local policy.  A server
      MAY treat a ticket as valid for a shorter period of time than what
      is stated in the ticket_lifetime.

   ticket_age_add:  A securely generated, random 32-bit value that is
      used to obscure the age of the ticket that the client includes in
      the &quot;pre_shared_key&quot; extension.  The client-side ticket age is
      added to this value modulo 2^32 to obtain the value that is
      transmitted by the client.  The server MUST generate a fresh value
      for each ticket it sends.

   ticket_nonce:  A per-ticket value that is unique across all tickets
      issued on this connection.









&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 74]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   ticket:  The value of the ticket to be used as the PSK identity.  The
      ticket itself is an opaque label.  It MAY be either a database
      lookup key or a self-encrypted and self-authenticated value.

   extensions:  A set of extension values for the ticket.  The
      &quot;Extension&quot; format is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;.  Clients MUST ignore
      unrecognized extensions.

   The sole extension currently defined for NewSessionTicket is
   &quot;early_data&quot;, indicating that the ticket may be used to send 0-RTT
   data (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.10&quot;&gt;Section 4.2.10&lt;/a&gt;).  It contains the following value:

   max_early_data_size:  The maximum amount of 0-RTT data that the
      client is allowed to send when using this ticket, in bytes.  Only
      Application Data payload (i.e., plaintext but not padding or the
      inner content type byte) is counted.  A server receiving more than
      max_early_data_size bytes of 0-RTT data SHOULD terminate the
      connection with an &quot;unexpected_message&quot; alert.  Note that servers
      that reject early data due to lack of cryptographic material will
      be unable to differentiate padding from content, so clients
      SHOULD NOT depend on being able to send large quantities of
      padding in early data records.

   The PSK associated with the ticket is computed as:

       HKDF-Expand-Label(resumption_master_secret,
                        &quot;resumption&quot;, ticket_nonce, Hash.length)

   Because the ticket_nonce value is distinct for each NewSessionTicket
   message, a different PSK will be derived for each ticket.

   Note that in principle it is possible to continue issuing new tickets
   which indefinitely extend the lifetime of the keying material
   originally derived from an initial non-PSK handshake (which was most
   likely tied to the peer's certificate).  It is RECOMMENDED that
   implementations place limits on the total lifetime of such keying
   material; these limits should take into account the lifetime of the
   peer's certificate, the likelihood of intervening revocation, and the
   time since the peer's online CertificateVerify signature.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.6.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.2&quot; id=&quot;section-4.6.2&quot;&gt;4.6.2&lt;/a&gt;.  Post-Handshake Authentication&lt;/span&gt;

   When the client has sent the &quot;post_handshake_auth&quot; extension (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.6&quot;&gt;Section 4.2.6&lt;/a&gt;), a server MAY request client authentication at any
   time after the handshake has completed by sending a
   CertificateRequest message.  The client MUST respond with the
   appropriate Authentication messages (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;).  If the client
   chooses to authenticate, it MUST send Certificate, CertificateVerify,



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 75]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   and Finished.  If it declines, it MUST send a Certificate message
   containing no certificates followed by Finished.  All of the client's
   messages for a given response MUST appear consecutively on the wire
   with no intervening messages of other types.

   A client that receives a CertificateRequest message without having
   sent the &quot;post_handshake_auth&quot; extension MUST send an
   &quot;unexpected_message&quot; fatal alert.

   Note: Because client authentication could involve prompting the user,
   servers MUST be prepared for some delay, including receiving an
   arbitrary number of other messages between sending the
   CertificateRequest and receiving a response.  In addition, clients
   which receive multiple CertificateRequests in close succession MAY
   respond to them in a different order than they were received (the
   certificate_request_context value allows the server to disambiguate
   the responses).

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-4.6.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.3&quot; id=&quot;section-4.6.3&quot;&gt;4.6.3&lt;/a&gt;.  Key and Initialization Vector Update&lt;/span&gt;

   The KeyUpdate handshake message is used to indicate that the sender
   is updating its sending cryptographic keys.  This message can be sent
   by either peer after it has sent a Finished message.  Implementations
   that receive a KeyUpdate message prior to receiving a Finished
   message MUST terminate the connection with an &quot;unexpected_message&quot;
   alert.  After sending a KeyUpdate message, the sender SHALL send all
   its traffic using the next generation of keys, computed as described
   in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;.  Upon receiving a KeyUpdate, the receiver MUST update
   its receiving keys.

      enum {
          update_not_requested(0), update_requested(1), (255)
      } KeyUpdateRequest;

      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;

   request_update:  Indicates whether the recipient of the KeyUpdate
      should respond with its own KeyUpdate.  If an implementation
      receives any other value, it MUST terminate the connection with an
      &quot;illegal_parameter&quot; alert.

   If the request_update field is set to &quot;update_requested&quot;, then the
   receiver MUST send a KeyUpdate of its own with request_update set to
   &quot;update_not_requested&quot; prior to sending its next Application Data
   record.  This mechanism allows either side to force an update to the
   entire connection, but causes an implementation which receives



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 76]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   multiple KeyUpdates while it is silent to respond with a single
   update.  Note that implementations may receive an arbitrary number of
   messages between sending a KeyUpdate with request_update set to
   &quot;update_requested&quot; and receiving the peer's KeyUpdate, because those
   messages may already be in flight.  However, because send and receive
   keys are derived from independent traffic secrets, retaining the
   receive traffic secret does not threaten the forward secrecy of data
   sent before the sender changed keys.

   If implementations independently send their own KeyUpdates with
   request_update set to &quot;update_requested&quot; and they cross in flight,
   then each side will also send a response, with the result that each
   side increments by two generations.

   Both sender and receiver MUST encrypt their KeyUpdate messages with
   the old keys.  Additionally, both sides MUST enforce that a KeyUpdate
   with the old key is received before accepting any messages encrypted
   with the new key.  Failure to do so may allow message truncation
   attacks.

&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-5&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-5&quot; id=&quot;section-5&quot;&gt;5&lt;/a&gt;.  Record Protocol&lt;/span&gt;

   The TLS record protocol takes messages to be transmitted, fragments
   the data into manageable blocks, protects the records, and transmits
   the result.  Received data is verified, decrypted, reassembled, and
   then delivered to higher-level clients.

   TLS records are typed, which allows multiple higher-level protocols
   to be multiplexed over the same record layer.  This document
   specifies four content types: handshake, application_data, alert, and
   change_cipher_spec.  The change_cipher_spec record is used only for
   compatibility purposes (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.4&quot;&gt;Appendix D.4&lt;/a&gt;).

   An implementation may receive an unencrypted record of type
   change_cipher_spec consisting of the single byte value 0x01 at any
   time after the first ClientHello message has been sent or received
   and before the peer's Finished message has been received and MUST
   simply drop it without further processing.  Note that this record may
   appear at a point at the handshake where the implementation is
   expecting protected records, and so it is necessary to detect this
   condition prior to attempting to deprotect the record.  An
   implementation which receives any other change_cipher_spec value or
   which receives a protected change_cipher_spec record MUST abort the
   handshake with an &quot;unexpected_message&quot; alert.  If an implementation
   detects a change_cipher_spec record received before the first
   ClientHello message or after the peer's Finished message, it MUST be
   treated as an unexpected record type (though stateless servers may
   not be able to distinguish these cases from allowed cases).



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 77]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Implementations MUST NOT send record types not defined in this
   document unless negotiated by some extension.  If a TLS
   implementation receives an unexpected record type, it MUST terminate
   the connection with an &quot;unexpected_message&quot; alert.  New record
   content type values are assigned by IANA in the TLS ContentType
   registry as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-11&quot;&gt;Section 11&lt;/a&gt;.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-5.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-5.1&quot; id=&quot;section-5.1&quot;&gt;5.1&lt;/a&gt;.  Record Layer&lt;/span&gt;

   The record layer fragments information blocks into TLSPlaintext
   records carrying data in chunks of 2^14 bytes or less.  Message
   boundaries are handled differently depending on the underlying
   ContentType.  Any future content types MUST specify appropriate
   rules.  Note that these rules are stricter than what was enforced in
   TLS 1.2.

   Handshake messages MAY be coalesced into a single TLSPlaintext record
   or fragmented across several records, provided that:

   -  Handshake messages MUST NOT be interleaved with other record
      types.  That is, if a handshake message is split over two or more
      records, there MUST NOT be any other records between them.

   -  Handshake messages MUST NOT span key changes.  Implementations
      MUST verify that all messages immediately preceding a key change
      align with a record boundary; if not, then they MUST terminate the
      connection with an &quot;unexpected_message&quot; alert.  Because the
      ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate
      messages can immediately precede a key change, implementations
      MUST send these messages in alignment with a record boundary.

   Implementations MUST NOT send zero-length fragments of Handshake
   types, even if those fragments contain padding.

   Alert messages (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-6&quot;&gt;Section 6&lt;/a&gt;) MUST NOT be fragmented across records, and
   multiple alert messages MUST NOT be coalesced into a single
   TLSPlaintext record.  In other words, a record with an Alert type
   MUST contain exactly one message.

   Application Data messages contain data that is opaque to TLS.
   Application Data messages are always protected.  Zero-length
   fragments of Application Data MAY be sent, as they are potentially
   useful as a traffic analysis countermeasure.  Application Data
   fragments MAY be split across multiple records or coalesced into a
   single record.






&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 78]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


      enum {
          invalid(0),
          change_cipher_spec(20),
          alert(21),
          handshake(22),
          application_data(23),
          (255)
      } ContentType;

      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;

   type:  The higher-level protocol used to process the enclosed
      fragment.

   legacy_record_version:  MUST be set to 0x0303 for all records
      generated by a TLS 1.3 implementation other than an initial
      ClientHello (i.e., one not generated after a HelloRetryRequest),
      where it MAY also be 0x0301 for compatibility purposes.  This
      field is deprecated and MUST be ignored for all purposes.
      Previous versions of TLS would use other values in this field
      under some circumstances.

   length:  The length (in bytes) of the following
      TLSPlaintext.fragment.  The length MUST NOT exceed 2^14 bytes.  An
      endpoint that receives a record that exceeds this length MUST
      terminate the connection with a &quot;record_overflow&quot; alert.

   fragment:  The data being transmitted.  This value is transparent and
      is treated as an independent block to be dealt with by the higher-
      level protocol specified by the type field.

   This document describes TLS 1.3, which uses the version 0x0304.  This
   version value is historical, deriving from the use of 0x0301 for
   TLS 1.0 and 0x0300 for SSL 3.0.  In order to maximize backward
   compatibility, a record containing an initial ClientHello SHOULD have
   version 0x0301 (reflecting TLS 1.0) and a record containing a second
   ClientHello or a ServerHello MUST have version 0x0303 (reflecting
   TLS 1.2).  When negotiating prior versions of TLS, endpoints follow
   the procedure and requirements provided in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D&quot;&gt;Appendix D&lt;/a&gt;.







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 79]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   When record protection has not yet been engaged, TLSPlaintext
   structures are written directly onto the wire.  Once record
   protection has started, TLSPlaintext records are protected and sent
   as described in the following section.  Note that Application Data
   records MUST NOT be written to the wire unprotected (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-2&quot;&gt;Section 2&lt;/a&gt;
   for details).

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-5.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-5.2&quot; id=&quot;section-5.2&quot;&gt;5.2&lt;/a&gt;.  Record Payload Protection&lt;/span&gt;

   The record protection functions translate a TLSPlaintext structure
   into a TLSCiphertext structure.  The deprotection functions reverse
   the process.  In TLS 1.3, as opposed to previous versions of TLS, all
   ciphers are modeled as &quot;Authenticated Encryption with Associated
   Data&quot; (AEAD) [&lt;a href=&quot;https://tools.ietf.org/html/rfc5116&quot; title=&quot;&amp;quot;An Interface and Algorithms for Authenticated Encryption&amp;quot;&quot;&gt;RFC5116&lt;/a&gt;].  AEAD functions provide a unified encryption
   and authentication operation which turns plaintext into authenticated
   ciphertext and back again.  Each encrypted record consists of a
   plaintext header followed by an encrypted body, which itself contains
   a type and optional padding.

      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;

      struct {
          ContentType opaque_type = application_data; /* 23 */
          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];
      } TLSCiphertext;

   content:  The TLSPlaintext.fragment value, containing the byte
      encoding of a handshake or an alert message, or the raw bytes of
      the application's data to send.

   type:  The TLSPlaintext.type value containing the content type of the
      record.

   zeros:  An arbitrary-length run of zero-valued bytes may appear in
      the cleartext after the type field.  This provides an opportunity
      for senders to pad any TLS record by a chosen amount as long as
      the total stays within record size limits.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5.4&quot;&gt;Section 5.4&lt;/a&gt; for
      more details.







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 80]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   opaque_type:  The outer opaque_type field of a TLSCiphertext record
      is always set to the value 23 (application_data) for outward
      compatibility with middleboxes accustomed to parsing previous
      versions of TLS.  The actual content type of the record is found
      in TLSInnerPlaintext.type after decryption.

   legacy_record_version:  The legacy_record_version field is always
      0x0303.  TLS 1.3 TLSCiphertexts are not generated until after
      TLS 1.3 has been negotiated, so there are no historical
      compatibility concerns where other values might be received.  Note
      that the handshake protocol, including the ClientHello and
      ServerHello messages, authenticates the protocol version, so this
      value is redundant.

   length:  The length (in bytes) of the following
      TLSCiphertext.encrypted_record, which is the sum of the lengths of
      the content and the padding, plus one for the inner content type,
      plus any expansion added by the AEAD algorithm.  The length
      MUST NOT exceed 2^14 + 256 bytes.  An endpoint that receives a
      record that exceeds this length MUST terminate the connection with
      a &quot;record_overflow&quot; alert.

   encrypted_record:  The AEAD-encrypted form of the serialized
      TLSInnerPlaintext structure.

   AEAD algorithms take as input a single key, a nonce, a plaintext, and
   &quot;additional data&quot; to be included in the authentication check, as
   described in &lt;a href=&quot;https://tools.ietf.org/html/rfc5116#section-2.1&quot;&gt;Section 2.1 of [RFC5116]&lt;/a&gt;.  The key is either the
   client_write_key or the server_write_key, the nonce is derived from
   the sequence number and the client_write_iv or server_write_iv (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;), and the additional data input is the record header.

   I.e.,

      additional_data = TLSCiphertext.opaque_type ||
                        TLSCiphertext.legacy_record_version ||
                        TLSCiphertext.length

   The plaintext input to the AEAD algorithm is the encoded
   TLSInnerPlaintext structure.  Derivation of traffic keys is defined
   in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.3&quot;&gt;Section 7.3&lt;/a&gt;.

   The AEAD output consists of the ciphertext output from the AEAD
   encryption operation.  The length of the plaintext is greater than
   the corresponding TLSPlaintext.length due to the inclusion of
   TLSInnerPlaintext.type and any padding supplied by the sender.  The
   length of the AEAD output will generally be larger than the
   plaintext, but by an amount that varies with the AEAD algorithm.



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 81]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Since the ciphers might incorporate padding, the amount of overhead
   could vary with different lengths of plaintext.  Symbolically,

      AEADEncrypted =
          AEAD-Encrypt(write_key, nonce, additional_data, plaintext)

   The encrypted_record field of TLSCiphertext is set to AEADEncrypted.

   In order to decrypt and verify, the cipher takes as input the key,
   nonce, additional data, and the AEADEncrypted value.  The output is
   either the plaintext or an error indicating that the decryption
   failed.  There is no separate integrity check.  Symbolically,

      plaintext of encrypted_record =
          AEAD-Decrypt(peer_write_key, nonce,
                       additional_data, AEADEncrypted)

   If the decryption fails, the receiver MUST terminate the connection
   with a &quot;bad_record_mac&quot; alert.

   An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion
   greater than 255 octets.  An endpoint that receives a record from its
   peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST
   terminate the connection with a &quot;record_overflow&quot; alert.  This limit
   is derived from the maximum TLSInnerPlaintext length of 2^14 octets +
   1 octet for ContentType + the maximum AEAD expansion of 255 octets.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-5.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-5.3&quot; id=&quot;section-5.3&quot;&gt;5.3&lt;/a&gt;.  Per-Record Nonce&lt;/span&gt;

   A 64-bit sequence number is maintained separately for reading and
   writing records.  The appropriate sequence number is incremented by
   one after reading or writing each record.  Each sequence number is
   set to zero at the beginning of a connection and whenever the key is
   changed; the first record transmitted under a particular traffic key
   MUST use sequence number 0.

   Because the size of sequence numbers is 64-bit, they should not wrap.
   If a TLS implementation would need to wrap a sequence number, it MUST
   either rekey (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.3&quot;&gt;Section 4.6.3&lt;/a&gt;) or terminate the connection.












&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 82]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Each AEAD algorithm will specify a range of possible lengths for the
   per-record nonce, from N_MIN bytes to N_MAX bytes of input [&lt;a href=&quot;https://tools.ietf.org/html/rfc5116&quot; title=&quot;&amp;quot;An Interface and Algorithms for Authenticated Encryption&amp;quot;&quot;&gt;RFC5116&lt;/a&gt;].
   The length of the TLS per-record nonce (iv_length) is set to the
   larger of 8 bytes and N_MIN for the AEAD algorithm (see &lt;a href=&quot;https://tools.ietf.org/html/rfc5116#section-4&quot;&gt;[RFC5116],
   Section 4&lt;/a&gt;).  An AEAD algorithm where N_MAX is less than 8 bytes
   MUST NOT be used with TLS.  The per-record nonce for the AEAD
   construction is formed as follows:

   1.  The 64-bit record sequence number is encoded in network byte
       order and padded to the left with zeros to iv_length.

   2.  The padded sequence number is XORed with either the static
       client_write_iv or server_write_iv (depending on the role).

   The resulting quantity (of length iv_length) is used as the
   per-record nonce.

   Note: This is a different construction from that in TLS 1.2, which
   specified a partially explicit nonce.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-5.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-5.4&quot; id=&quot;section-5.4&quot;&gt;5.4&lt;/a&gt;.  Record Padding&lt;/span&gt;

   All encrypted TLS records can be padded to inflate the size of the
   TLSCiphertext.  This allows the sender to hide the size of the
   traffic from an observer.

   When generating a TLSCiphertext record, implementations MAY choose to
   pad.  An unpadded record is just a record with a padding length of
   zero.  Padding is a string of zero-valued bytes appended to the
   ContentType field before encryption.  Implementations MUST set the
   padding octets to all zeros before encrypting.

   Application Data records may contain a zero-length
   TLSInnerPlaintext.content if the sender desires.  This permits
   generation of plausibly sized cover traffic in contexts where the
   presence or absence of activity may be sensitive.  Implementations
   MUST NOT send Handshake and Alert records that have a zero-length
   TLSInnerPlaintext.content; if such a message is received, the
   receiving implementation MUST terminate the connection with an
   &quot;unexpected_message&quot; alert.











&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 83]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   The padding sent is automatically verified by the record protection
   mechanism; upon successful decryption of a
   TLSCiphertext.encrypted_record, the receiving implementation scans
   the field from the end toward the beginning until it finds a non-zero
   octet.  This non-zero octet is the content type of the message.  This
   padding scheme was selected because it allows padding of any
   encrypted TLS record by an arbitrary size (from zero up to TLS record
   size limits) without introducing new content types.  The design also
   enforces all-zero padding octets, which allows for quick detection of
   padding errors.

   Implementations MUST limit their scanning to the cleartext returned
   from the AEAD decryption.  If a receiving implementation does not
   find a non-zero octet in the cleartext, it MUST terminate the
   connection with an &quot;unexpected_message&quot; alert.

   The presence of padding does not change the overall record size
   limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14
   + 1 octets.  If the maximum fragment length is reduced -- as, for
   example, by the record_size_limit extension from [&lt;a href=&quot;https://tools.ietf.org/html/rfc8449&quot; title=&quot;&amp;quot;Record Size Limit Extension for TLS&amp;quot;&quot;&gt;RFC8449&lt;/a&gt;] -- then
   the reduced limit applies to the full plaintext, including the
   content type and padding.

   Selecting a padding policy that suggests when and how much to pad is
   a complex topic and is beyond the scope of this specification.  If
   the application-layer protocol on top of TLS has its own padding, it
   may be preferable to pad Application Data TLS records within the
   application layer.  Padding for encrypted Handshake or Alert records
   must still be handled at the TLS layer, though.  Later documents may
   define padding selection algorithms or define a padding policy
   request mechanism through TLS extensions or some other means.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-5.5&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-5.5&quot; id=&quot;section-5.5&quot;&gt;5.5&lt;/a&gt;.  Limits on Key Usage&lt;/span&gt;

   There are cryptographic limits on the amount of plaintext which can
   be safely encrypted under a given set of keys.  [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-AEAD-LIMITS&quot; title=&quot;&amp;quot;Limits on Authenticated Encryption Use in TLS&amp;quot;&quot;&gt;AEAD-LIMITS&lt;/a&gt;]
   provides an analysis of these limits under the assumption that the
   underlying primitive (AES or ChaCha20) has no weaknesses.
   Implementations SHOULD do a key update as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.3&quot;&gt;Section 4.6.3&lt;/a&gt;
   prior to reaching these limits.

   For AES-GCM, up to 2^24.5 full-size records (about 24 million) may be
   encrypted on a given connection while keeping a safety margin of
   approximately 2^-57 for Authenticated Encryption (AE) security.  For
   ChaCha20/Poly1305, the record sequence number would wrap before the
   safety limit is reached.





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 84]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-6&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-6&quot; id=&quot;section-6&quot;&gt;6&lt;/a&gt;.  Alert Protocol&lt;/span&gt;

   TLS provides an Alert content type to indicate closure information
   and errors.  Like other messages, alert messages are encrypted as
   specified by the current connection state.

   Alert messages convey a description of the alert and a legacy field
   that conveyed the severity level of the message in previous versions
   of TLS.  Alerts are divided into two classes: closure alerts and
   error alerts.  In TLS 1.3, the severity is implicit in the type of
   alert being sent, and the &quot;level&quot; field can safely be ignored.  The
   &quot;close_notify&quot; alert is used to indicate orderly closure of one
   direction of the connection.  Upon receiving such an alert, the TLS
   implementation SHOULD indicate end-of-data to the application.

   Error alerts indicate abortive closure of the connection (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-6.2&quot;&gt;Section 6.2&lt;/a&gt;).  Upon receiving an error alert, the TLS implementation
   SHOULD indicate an error to the application and MUST NOT allow any
   further data to be sent or received on the connection.  Servers and
   clients MUST forget the secret values and keys established in failed
   connections, with the exception of the PSKs associated with session
   tickets, which SHOULD be discarded if possible.

   All the alerts listed in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-6.2&quot;&gt;Section 6.2&lt;/a&gt; MUST be sent with
   AlertLevel=fatal and MUST be treated as error alerts when received
   regardless of the AlertLevel in the message.  Unknown Alert types
   MUST be treated as error alerts.

   Note: TLS defines two generic alerts (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-6&quot;&gt;Section 6&lt;/a&gt;) to use upon
   failure to parse a message.  Peers which receive a message which
   cannot be parsed according to the syntax (e.g., have a length
   extending beyond the message boundary or contain an out-of-range
   length) MUST terminate the connection with a &quot;decode_error&quot; alert.
   Peers which receive a message which is syntactically correct but
   semantically invalid (e.g., a DHE share of p - 1, or an invalid enum)
   MUST terminate the connection with an &quot;illegal_parameter&quot; alert.















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 85]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


      enum { warning(1), fatal(2), (255) } AlertLevel;

      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          record_overflow(22),
          handshake_failure(40),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          inappropriate_fallback(86),
          user_canceled(90),
          missing_extension(109),
          unsupported_extension(110),
          unrecognized_name(112),
          bad_certificate_status_response(113),
          unknown_psk_identity(115),
          certificate_required(116),
          no_application_protocol(120),
          (255)
      } AlertDescription;

      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;














&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 86]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-6.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-6.1&quot; id=&quot;section-6.1&quot;&gt;6.1&lt;/a&gt;.  Closure Alerts&lt;/span&gt;

   The client and the server must share knowledge that the connection is
   ending in order to avoid a truncation attack.

   close_notify:  This alert notifies the recipient that the sender will
      not send any more messages on this connection.  Any data received
      after a closure alert has been received MUST be ignored.

   user_canceled:  This alert notifies the recipient that the sender is
      canceling the handshake for some reason unrelated to a protocol
      failure.  If a user cancels an operation after the handshake is
      complete, just closing the connection by sending a &quot;close_notify&quot;
      is more appropriate.  This alert SHOULD be followed by a
      &quot;close_notify&quot;.  This alert generally has AlertLevel=warning.

   Either party MAY initiate a close of its write side of the connection
   by sending a &quot;close_notify&quot; alert.  Any data received after a closure
   alert has been received MUST be ignored.  If a transport-level close
   is received prior to a &quot;close_notify&quot;, the receiver cannot know that
   all the data that was sent has been received.

   Each party MUST send a &quot;close_notify&quot; alert before closing its write
   side of the connection, unless it has already sent some error alert.
   This does not have any effect on its read side of the connection.
   Note that this is a change from versions of TLS prior to TLS 1.3 in
   which implementations were required to react to a &quot;close_notify&quot; by
   discarding pending writes and sending an immediate &quot;close_notify&quot;
   alert of their own.  That previous requirement could cause truncation
   in the read side.  Both parties need not wait to receive a
   &quot;close_notify&quot; alert before closing their read side of the
   connection, though doing so would introduce the possibility of
   truncation.

   If the application protocol using TLS provides that any data may be
   carried over the underlying transport after the TLS connection is
   closed, the TLS implementation MUST receive a &quot;close_notify&quot; alert
   before indicating end-of-data to the application layer.  No part of
   this standard should be taken to dictate the manner in which a usage
   profile for TLS manages its data transport, including when
   connections are opened or closed.

   Note: It is assumed that closing the write side of a connection
   reliably delivers pending data before destroying the transport.







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 87]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-6.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-6.2&quot; id=&quot;section-6.2&quot;&gt;6.2&lt;/a&gt;.  Error Alerts&lt;/span&gt;

   Error handling in TLS is very simple.  When an error is detected, the
   detecting party sends a message to its peer.  Upon transmission or
   receipt of a fatal alert message, both parties MUST immediately close
   the connection.

   Whenever an implementation encounters a fatal error condition, it
   SHOULD send an appropriate fatal alert and MUST close the connection
   without sending or receiving any additional data.  In the rest of
   this specification, when the phrases &quot;terminate the connection&quot; and
   &quot;abort the handshake&quot; are used without a specific alert it means that
   the implementation SHOULD send the alert indicated by the
   descriptions below.  The phrases &quot;terminate the connection with an X
   alert&quot; and &quot;abort the handshake with an X alert&quot; mean that the
   implementation MUST send alert X if it sends any alert.  All alerts
   defined below in this section, as well as all unknown alerts, are
   universally considered fatal as of TLS 1.3 (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-6&quot;&gt;Section 6&lt;/a&gt;).  The
   implementation SHOULD provide a way to facilitate logging the sending
   and receiving of alerts.

   The following error alerts are defined:

   unexpected_message:  An inappropriate message (e.g., the wrong
      handshake message, premature Application Data, etc.) was received.
      This alert should never be observed in communication between
      proper implementations.

   bad_record_mac:  This alert is returned if a record is received which
      cannot be deprotected.  Because AEAD algorithms combine decryption
      and verification, and also to avoid side-channel attacks, this
      alert is used for all deprotection failures.  This alert should
      never be observed in communication between proper implementations,
      except when messages were corrupted in the network.

   record_overflow:  A TLSCiphertext record was received that had a
      length more than 2^14 + 256 bytes, or a record decrypted to a
      TLSPlaintext record with more than 2^14 bytes (or some other
      negotiated limit).  This alert should never be observed in
      communication between proper implementations, except when messages
      were corrupted in the network.

   handshake_failure:  Receipt of a &quot;handshake_failure&quot; alert message
      indicates that the sender was unable to negotiate an acceptable
      set of security parameters given the options available.

   bad_certificate:  A certificate was corrupt, contained signatures
      that did not verify correctly, etc.



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 88]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   unsupported_certificate:  A certificate was of an unsupported type.

   certificate_revoked:  A certificate was revoked by its signer.

   certificate_expired:  A certificate has expired or is not currently
      valid.

   certificate_unknown:  Some other (unspecified) issue arose in
      processing the certificate, rendering it unacceptable.

   illegal_parameter:  A field in the handshake was incorrect or
      inconsistent with other fields.  This alert is used for errors
      which conform to the formal protocol syntax but are otherwise
      incorrect.

   unknown_ca:  A valid certificate chain or partial chain was received,
      but the certificate was not accepted because the CA certificate
      could not be located or could not be matched with a known trust
      anchor.

   access_denied:  A valid certificate or PSK was received, but when
      access control was applied, the sender decided not to proceed with
      negotiation.

   decode_error:  A message could not be decoded because some field was
      out of the specified range or the length of the message was
      incorrect.  This alert is used for errors where the message does
      not conform to the formal protocol syntax.  This alert should
      never be observed in communication between proper implementations,
      except when messages were corrupted in the network.

   decrypt_error:  A handshake (not record layer) cryptographic
      operation failed, including being unable to correctly verify a
      signature or validate a Finished message or a PSK binder.

   protocol_version:  The protocol version the peer has attempted to
      negotiate is recognized but not supported (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D&quot;&gt;Appendix D&lt;/a&gt;).

   insufficient_security:  Returned instead of &quot;handshake_failure&quot; when
      a negotiation has failed specifically because the server requires
      parameters more secure than those supported by the client.

   internal_error:  An internal error unrelated to the peer or the
      correctness of the protocol (such as a memory allocation failure)
      makes it impossible to continue.

   inappropriate_fallback:  Sent by a server in response to an invalid
      connection retry attempt from a client (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc7507&quot; title=&quot;&amp;quot;TLS Fallback Signaling Cipher Suite Value (SCSV) for Preventing Protocol Downgrade Attacks&amp;quot;&quot;&gt;RFC7507&lt;/a&gt;]).



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 89]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   missing_extension:  Sent by endpoints that receive a handshake
      message not containing an extension that is mandatory to send for
      the offered TLS version or other negotiated parameters.

   unsupported_extension:  Sent by endpoints receiving any handshake
      message containing an extension known to be prohibited for
      inclusion in the given handshake message, or including any
      extensions in a ServerHello or Certificate not first offered in
      the corresponding ClientHello or CertificateRequest.

   unrecognized_name:  Sent by servers when no server exists identified
      by the name provided by the client via the &quot;server_name&quot; extension
      (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Extensions: Extension Definitions&amp;quot;&quot;&gt;RFC6066&lt;/a&gt;]).

   bad_certificate_status_response:  Sent by clients when an invalid or
      unacceptable OCSP response is provided by the server via the
      &quot;status_request&quot; extension (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Extensions: Extension Definitions&amp;quot;&quot;&gt;RFC6066&lt;/a&gt;]).

   unknown_psk_identity:  Sent by servers when PSK key establishment is
      desired but no acceptable PSK identity is provided by the client.
      Sending this alert is OPTIONAL; servers MAY instead choose to send
      a &quot;decrypt_error&quot; alert to merely indicate an invalid PSK
      identity.

   certificate_required:  Sent by servers when a client certificate is
      desired but none was provided by the client.

   no_application_protocol:  Sent by servers when a client
      &quot;application_layer_protocol_negotiation&quot; extension advertises only
      protocols that the server does not support (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc7301&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension&amp;quot;&quot;&gt;RFC7301&lt;/a&gt;]).

   New Alert values are assigned by IANA as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-11&quot;&gt;Section 11&lt;/a&gt;.

&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-7&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-7&quot; id=&quot;section-7&quot;&gt;7&lt;/a&gt;.  Cryptographic Computations&lt;/span&gt;

   The TLS handshake establishes one or more input secrets which are
   combined to create the actual working keying material, as detailed
   below.  The key derivation process incorporates both the input
   secrets and the handshake transcript.  Note that because the
   handshake transcript includes the random values from the Hello
   messages, any given handshake will have different traffic secrets,
   even if the same input secrets are used, as is the case when the same
   PSK is used for multiple connections.








&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 90]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-7.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-7.1&quot; id=&quot;section-7.1&quot;&gt;7.1&lt;/a&gt;.  Key Schedule&lt;/span&gt;

   The key derivation process makes use of the HKDF-Extract and
   HKDF-Expand functions as defined for HKDF [&lt;a href=&quot;https://tools.ietf.org/html/rfc5869&quot; title=&quot;&amp;quot;HMAC-based Extract-and-Expand Key Derivation Function (HKDF)&amp;quot;&quot;&gt;RFC5869&lt;/a&gt;], as well as the
   functions defined below:

       HKDF-Expand-Label(Secret, Label, Context, Length) =
            HKDF-Expand(Secret, HkdfLabel, Length)

       Where HkdfLabel is specified as:

       struct {
           uint16 length = Length;
           opaque label&amp;lt;7..255&amp;gt; = &quot;tls13 &quot; + Label;
           opaque context&amp;lt;0..255&amp;gt; = Context;
       } HkdfLabel;

       Derive-Secret(Secret, Label, Messages) =
            HKDF-Expand-Label(Secret, Label,
                              Transcript-Hash(Messages), Hash.length)

   The Hash function used by Transcript-Hash and HKDF is the cipher
   suite hash algorithm.  Hash.length is its output length in bytes.
   Messages is the concatenation of the indicated handshake messages,
   including the handshake message type and length fields, but not
   including record layer headers.  Note that in some cases a zero-
   length Context (indicated by &quot;&quot;) is passed to HKDF-Expand-Label.  The
   labels specified in this document are all ASCII strings and do not
   include a trailing NUL byte.

   Note: With common hash functions, any label longer than 12 characters
   requires an additional iteration of the hash function to compute.
   The labels in this specification have all been chosen to fit within
   this limit.

















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 91]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Keys are derived from two input secrets using the HKDF-Extract and
   Derive-Secret functions.  The general pattern for adding a new secret
   is to use HKDF-Extract with the Salt being the current secret state
   and the Input Keying Material (IKM) being the new secret to be added.
   In this version of TLS 1.3, the two input secrets are:

   -  PSK (a pre-shared key established externally or derived from the
      resumption_master_secret value from a previous connection)

   -  (EC)DHE shared secret (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.4&quot;&gt;Section 7.4&lt;/a&gt;)

   This produces a full key derivation schedule shown in the diagram
   below.  In this diagram, the following formatting conventions apply:

   -  HKDF-Extract is drawn as taking the Salt argument from the top and
      the IKM argument from the left, with its output to the bottom and
      the name of the output on the right.

   -  Derive-Secret's Secret argument is indicated by the incoming
      arrow.  For instance, the Early Secret is the Secret for
      generating the client_early_traffic_secret.

   -  &quot;0&quot; indicates a string of Hash.length bytes set to zero.




























&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 92]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


             0
             |
             v
   PSK -&amp;gt;  HKDF-Extract = Early Secret
             |
             +-----&amp;gt; Derive-Secret(., &quot;ext binder&quot; | &quot;res binder&quot;, &quot;&quot;)
             |                     = binder_key
             |
             +-----&amp;gt; Derive-Secret(., &quot;c e traffic&quot;, ClientHello)
             |                     = client_early_traffic_secret
             |
             +-----&amp;gt; Derive-Secret(., &quot;e exp master&quot;, ClientHello)
             |                     = early_exporter_master_secret
             v
       Derive-Secret(., &quot;derived&quot;, &quot;&quot;)
             |
             v
   (EC)DHE -&amp;gt; HKDF-Extract = Handshake Secret
             |
             +-----&amp;gt; Derive-Secret(., &quot;c hs traffic&quot;,
             |                     ClientHello...ServerHello)
             |                     = client_handshake_traffic_secret
             |
             +-----&amp;gt; Derive-Secret(., &quot;s hs traffic&quot;,
             |                     ClientHello...ServerHello)
             |                     = server_handshake_traffic_secret
             v
       Derive-Secret(., &quot;derived&quot;, &quot;&quot;)
             |
             v
   0 -&amp;gt; HKDF-Extract = Master Secret
             |
             +-----&amp;gt; Derive-Secret(., &quot;c ap traffic&quot;,
             |                     ClientHello...server Finished)
             |                     = client_application_traffic_secret_0
             |
             +-----&amp;gt; Derive-Secret(., &quot;s ap traffic&quot;,
             |                     ClientHello...server Finished)
             |                     = server_application_traffic_secret_0
             |
             +-----&amp;gt; Derive-Secret(., &quot;exp master&quot;,
             |                     ClientHello...server Finished)
             |                     = exporter_master_secret
             |
             +-----&amp;gt; Derive-Secret(., &quot;res master&quot;,
                                   ClientHello...client Finished)
                                   = resumption_master_secret




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 93]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   The general pattern here is that the secrets shown down the left side
   of the diagram are just raw entropy without context, whereas the
   secrets down the right side include Handshake Context and therefore
   can be used to derive working keys without additional context.  Note
   that the different calls to Derive-Secret may take different Messages
   arguments, even with the same secret.  In a 0-RTT exchange,
   Derive-Secret is called with four distinct transcripts; in a
   1-RTT-only exchange, it is called with three distinct transcripts.

   If a given secret is not available, then the 0-value consisting of a
   string of Hash.length bytes set to zeros is used.  Note that this
   does not mean skipping rounds, so if PSK is not in use, Early Secret
   will still be HKDF-Extract(0, 0).  For the computation of the
   binder_key, the label is &quot;ext binder&quot; for external PSKs (those
   provisioned outside of TLS) and &quot;res binder&quot; for resumption PSKs
   (those provisioned as the resumption master secret of a previous
   handshake).  The different labels prevent the substitution of one
   type of PSK for the other.

   There are multiple potential Early Secret values, depending on which
   PSK the server ultimately selects.  The client will need to compute
   one for each potential PSK; if no PSK is selected, it will then need
   to compute the Early Secret corresponding to the zero PSK.

   Once all the values which are to be derived from a given secret have
   been computed, that secret SHOULD be erased.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-7.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-7.2&quot; id=&quot;section-7.2&quot;&gt;7.2&lt;/a&gt;.  Updating Traffic Secrets&lt;/span&gt;

   Once the handshake is complete, it is possible for either side to
   update its sending traffic keys using the KeyUpdate handshake message
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.3&quot;&gt;Section 4.6.3&lt;/a&gt;.  The next generation of traffic keys is
   computed by generating client_/server_application_traffic_secret_N+1
   from client_/server_application_traffic_secret_N as described in this
   section and then re-deriving the traffic keys as described in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.3&quot;&gt;Section 7.3&lt;/a&gt;.

   The next-generation application_traffic_secret is computed as:

       application_traffic_secret_N+1 =
           HKDF-Expand-Label(application_traffic_secret_N,
                             &quot;traffic upd&quot;, &quot;&quot;, Hash.length)

   Once client_/server_application_traffic_secret_N+1 and its associated
   traffic keys have been computed, implementations SHOULD delete
   client_/server_application_traffic_secret_N and its associated
   traffic keys.




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 94]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-7.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-7.3&quot; id=&quot;section-7.3&quot;&gt;7.3&lt;/a&gt;.  Traffic Key Calculation&lt;/span&gt;

   The traffic keying material is generated from the following input
   values:

   -  A secret value

   -  A purpose value indicating the specific value being generated

   -  The length of the key being generated

   The traffic keying material is generated from an input traffic secret
   value using:

   [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-sender&quot;&gt;sender&lt;/a&gt;]_write_key = HKDF-Expand-Label(Secret, &quot;key&quot;, &quot;&quot;, key_length)
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-sender&quot;&gt;sender&lt;/a&gt;]_write_iv  = HKDF-Expand-Label(Secret, &quot;iv&quot;, &quot;&quot;, iv_length)

   [&lt;a name=&quot;ref-sender&quot; id=&quot;ref-sender&quot;&gt;sender&lt;/a&gt;] denotes the sending side.  The value of Secret for each
   record type is shown in the table below.

       +-------------------+---------------------------------------+
       | Record Type       | Secret                                |
       +-------------------+---------------------------------------+
       | 0-RTT Application | client_early_traffic_secret           |
       |                   |                                       |
       | Handshake         | [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-sender&quot;&gt;sender&lt;/a&gt;]_handshake_traffic_secret     |
       |                   |                                       |
       | Application Data  | [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-sender&quot;&gt;sender&lt;/a&gt;]_application_traffic_secret_N |
       +-------------------+---------------------------------------+

   All the traffic keying material is recomputed whenever the underlying
   Secret changes (e.g., when changing from the handshake to Application
   Data keys or upon a key update).

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-7.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-7.4&quot; id=&quot;section-7.4&quot;&gt;7.4&lt;/a&gt;.  (EC)DHE Shared Secret Calculation&lt;/span&gt;

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-7.4.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-7.4.1&quot; id=&quot;section-7.4.1&quot;&gt;7.4.1&lt;/a&gt;.  Finite Field Diffie-Hellman&lt;/span&gt;

   For finite field groups, a conventional Diffie-Hellman [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-DH76&quot; title=&quot;&amp;quot;New directions in cryptography&amp;quot;&quot;&gt;DH76&lt;/a&gt;]
   computation is performed.  The negotiated key (Z) is converted to a
   byte string by encoding in big-endian form and left-padded with zeros
   up to the size of the prime.  This byte string is used as the shared
   secret in the key schedule as specified above.

   Note that this construction differs from previous versions of TLS
   which removed leading zeros.





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 95]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-7.4.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-7.4.2&quot; id=&quot;section-7.4.2&quot;&gt;7.4.2&lt;/a&gt;.  Elliptic Curve Diffie-Hellman&lt;/span&gt;

   For secp256r1, secp384r1, and secp521r1, ECDH calculations (including
   parameter and key generation as well as the shared secret
   calculation) are performed according to [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-IEEE1363&quot; title=&quot;&amp;quot;IEEE Standard Specifications for Public Key Cryptography&amp;quot;&quot;&gt;IEEE1363&lt;/a&gt;] using the
   ECKAS-DH1 scheme with the identity map as the key derivation function
   (KDF), so that the shared secret is the x-coordinate of the ECDH
   shared secret elliptic curve point represented as an octet string.
   Note that this octet string (&quot;Z&quot; in IEEE 1363 terminology) as output
   by FE2OSP (the Field Element to Octet String Conversion Primitive)
   has constant length for any given field; leading zeros found in this
   octet string MUST NOT be truncated.

   (Note that this use of the identity KDF is a technicality.  The
   complete picture is that ECDH is employed with a non-trivial KDF
   because TLS does not directly use this secret for anything other than
   for computing other secrets.)

   For X25519 and X448, the ECDH calculations are as follows:

   -  The public key to put into the KeyShareEntry.key_exchange
      structure is the result of applying the ECDH scalar multiplication
      function to the secret key of appropriate length (into scalar
      input) and the standard public basepoint (into u-coordinate point
      input).

   -  The ECDH shared secret is the result of applying the ECDH scalar
      multiplication function to the secret key (into scalar input) and
      the peer's public key (into u-coordinate point input).  The output
      is used raw, with no processing.

   For these curves, implementations SHOULD use the approach specified
   in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7748&quot; title=&quot;&amp;quot;Elliptic Curves for Security&amp;quot;&quot;&gt;RFC7748&lt;/a&gt;] to calculate the Diffie-Hellman shared secret.
   Implementations MUST check whether the computed Diffie-Hellman shared
   secret is the all-zero value and abort if so, as described in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7748#section-6&quot;&gt;Section 6 of [RFC7748]&lt;/a&gt;.  If implementors use an alternative
   implementation of these elliptic curves, they SHOULD perform the
   additional checks specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7748#section-7&quot;&gt;Section 7 of [RFC7748]&lt;/a&gt;.













&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 96]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-7.5&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-7.5&quot; id=&quot;section-7.5&quot;&gt;7.5&lt;/a&gt;.  Exporters&lt;/span&gt;

   [&lt;a name=&quot;ref-RFC5705&quot; id=&quot;ref-RFC5705&quot;&gt;RFC5705&lt;/a&gt;] defines keying material exporters for TLS in terms of the
   TLS pseudorandom function (PRF).  This document replaces the PRF with
   HKDF, thus requiring a new construction.  The exporter interface
   remains the same.

   The exporter value is computed as:

   TLS-Exporter(label, context_value, key_length) =
       HKDF-Expand-Label(Derive-Secret(Secret, label, &quot;&quot;),
                         &quot;exporter&quot;, Hash(context_value), key_length)

   Where Secret is either the early_exporter_master_secret or the
   exporter_master_secret.  Implementations MUST use the
   exporter_master_secret unless explicitly specified by the
   application.  The early_exporter_master_secret is defined for use in
   settings where an exporter is needed for 0-RTT data.  A separate
   interface for the early exporter is RECOMMENDED; this avoids the
   exporter user accidentally using an early exporter when a regular one
   is desired or vice versa.

   If no context is provided, the context_value is zero length.
   Consequently, providing no context computes the same value as
   providing an empty context.  This is a change from previous versions
   of TLS where an empty context produced a different output than an
   absent context.  As of this document's publication, no allocated
   exporter label is used both with and without a context.  Future
   specifications MUST NOT define a use of exporters that permit both an
   empty context and no context with the same label.  New uses of
   exporters SHOULD provide a context in all exporter computations,
   though the value could be empty.

   Requirements for the format of exporter labels are defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5705#section-4&quot;&gt;Section 4 of [RFC5705]&lt;/a&gt;.
















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 97]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-8&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-8&quot; id=&quot;section-8&quot;&gt;8&lt;/a&gt;.  0-RTT and Anti-Replay&lt;/span&gt;

   As noted in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.5&quot;&gt;Appendix E.5&lt;/a&gt;, TLS does not provide
   inherent replay protections for 0-RTT data.  There are two potential
   threats to be concerned with:

   -  Network attackers who mount a replay attack by simply duplicating
      a flight of 0-RTT data.

   -  Network attackers who take advantage of client retry behavior to
      arrange for the server to receive multiple copies of an
      application message.  This threat already exists to some extent
      because clients that value robustness respond to network errors by
      attempting to retry requests.  However, 0-RTT adds an additional
      dimension for any server system which does not maintain globally
      consistent server state.  Specifically, if a server system has
      multiple zones where tickets from zone A will not be accepted in
      zone B, then an attacker can duplicate a ClientHello and early
      data intended for A to both A and B.  At A, the data will be
      accepted in 0-RTT, but at B the server will reject 0-RTT data and
      instead force a full handshake.  If the attacker blocks the
      ServerHello from A, then the client will complete the handshake
      with B and probably retry the request, leading to duplication on
      the server system as a whole.

   The first class of attack can be prevented by sharing state to
   guarantee that the 0-RTT data is accepted at most once.  Servers
   SHOULD provide that level of replay safety by implementing one of the
   methods described in this section or by equivalent means.  It is
   understood, however, that due to operational concerns not all
   deployments will maintain state at that level.  Therefore, in normal
   operation, clients will not know which, if any, of these mechanisms
   servers actually implement and hence MUST only send early data which
   they deem safe to be replayed.

   In addition to the direct effects of replays, there is a class of
   attacks where even operations normally considered idempotent could be
   exploited by a large number of replays (timing attacks, resource
   limit exhaustion and others, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.5&quot;&gt;Appendix E.5&lt;/a&gt;).  Those
   can be mitigated by ensuring that every 0-RTT payload can be replayed
   only a limited number of times.  The server MUST ensure that any
   instance of it (be it a machine, a thread, or any other entity within
   the relevant serving infrastructure) would accept 0-RTT for the same
   0-RTT handshake at most once; this limits the number of replays to
   the number of server instances in the deployment.  Such a guarantee
   can be accomplished by locally recording data from recently received
   ClientHellos and rejecting repeats, or by any other method that




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 98]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   provides the same or a stronger guarantee.  The &quot;at most once per
   server instance&quot; guarantee is a minimum requirement; servers SHOULD
   limit 0-RTT replays further when feasible.

   The second class of attack cannot be prevented at the TLS layer and
   MUST be dealt with by any application.  Note that any application
   whose clients implement any kind of retry behavior already needs to
   implement some sort of anti-replay defense.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-8.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-8.1&quot; id=&quot;section-8.1&quot;&gt;8.1&lt;/a&gt;.  Single-Use Tickets&lt;/span&gt;

   The simplest form of anti-replay defense is for the server to only
   allow each session ticket to be used once.  For instance, the server
   can maintain a database of all outstanding valid tickets, deleting
   each ticket from the database as it is used.  If an unknown ticket is
   provided, the server would then fall back to a full handshake.

   If the tickets are not self-contained but rather are database keys,
   and the corresponding PSKs are deleted upon use, then connections
   established using PSKs enjoy forward secrecy.  This improves security
   for all 0-RTT data and PSK usage when PSK is used without (EC)DHE.

   Because this mechanism requires sharing the session database between
   server nodes in environments with multiple distributed servers, it
   may be hard to achieve high rates of successful PSK 0-RTT connections
   when compared to self-encrypted tickets.  Unlike session databases,
   session tickets can successfully do PSK-based session establishment
   even without consistent storage, though when 0-RTT is allowed they
   still require consistent storage for anti-replay of 0-RTT data, as
   detailed in the following section.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-8.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-8.2&quot; id=&quot;section-8.2&quot;&gt;8.2&lt;/a&gt;.  Client Hello Recording&lt;/span&gt;

   An alternative form of anti-replay is to record a unique value
   derived from the ClientHello (generally either the random value or
   the PSK binder) and reject duplicates.  Recording all ClientHellos
   causes state to grow without bound, but a server can instead record
   ClientHellos within a given time window and use the
   &quot;obfuscated_ticket_age&quot; to ensure that tickets aren't reused outside
   that window.

   In order to implement this, when a ClientHello is received, the
   server first verifies the PSK binder as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.11&quot;&gt;Section 4.2.11&lt;/a&gt;.
   It then computes the expected_arrival_time as described in the next
   section and rejects 0-RTT if it is outside the recording window,
   falling back to the 1-RTT handshake.





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                   [Page 99]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   If the expected_arrival_time is in the window, then the server checks
   to see if it has recorded a matching ClientHello.  If one is found,
   it either aborts the handshake with an &quot;illegal_parameter&quot; alert or
   accepts the PSK but rejects 0-RTT.  If no matching ClientHello is
   found, then it accepts 0-RTT and then stores the ClientHello for as
   long as the expected_arrival_time is inside the window.  Servers MAY
   also implement data stores with false positives, such as Bloom
   filters, in which case they MUST respond to apparent replay by
   rejecting 0-RTT but MUST NOT abort the handshake.

   The server MUST derive the storage key only from validated sections
   of the ClientHello.  If the ClientHello contains multiple PSK
   identities, then an attacker can create multiple ClientHellos with
   different binder values for the less-preferred identity on the
   assumption that the server will not verify it (as recommended by
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.11&quot;&gt;Section 4.2.11&lt;/a&gt;).  I.e., if the client sends PSKs A and B but the
   server prefers A, then the attacker can change the binder for B
   without affecting the binder for A.  If the binder for B is part of
   the storage key, then this ClientHello will not appear as a
   duplicate, which will cause the ClientHello to be accepted, and may
   cause side effects such as replay cache pollution, although any 0-RTT
   data will not be decryptable because it will use different keys.  If
   the validated binder or the ClientHello.random is used as the storage
   key, then this attack is not possible.

   Because this mechanism does not require storing all outstanding
   tickets, it may be easier to implement in distributed systems with
   high rates of resumption and 0-RTT, at the cost of potentially weaker
   anti-replay defense because of the difficulty of reliably storing and
   retrieving the received ClientHello messages.  In many such systems,
   it is impractical to have globally consistent storage of all the
   received ClientHellos.  In this case, the best anti-replay protection
   is provided by having a single storage zone be authoritative for a
   given ticket and refusing 0-RTT for that ticket in any other zone.
   This approach prevents simple replay by the attacker because only one
   zone will accept 0-RTT data.  A weaker design is to implement
   separate storage for each zone but allow 0-RTT in any zone.  This
   approach limits the number of replays to once per zone.  Application
   message duplication of course remains possible with either design.

   When implementations are freshly started, they SHOULD reject 0-RTT as
   long as any portion of their recording window overlaps the startup
   time.  Otherwise, they run the risk of accepting replays which were
   originally sent during that period.







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 100]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Note: If the client's clock is running much faster than the server's,
   then a ClientHello may be received that is outside the window in the
   future, in which case it might be accepted for 1-RTT, causing a
   client retry, and then acceptable later for 0-RTT.  This is another
   variant of the second form of attack described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-8&quot;&gt;Section 8&lt;/a&gt;.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-8.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-8.3&quot; id=&quot;section-8.3&quot;&gt;8.3&lt;/a&gt;.  Freshness Checks&lt;/span&gt;

   Because the ClientHello indicates the time at which the client sent
   it, it is possible to efficiently determine whether a ClientHello was
   likely sent reasonably recently and only accept 0-RTT for such a
   ClientHello, otherwise falling back to a 1-RTT handshake.  This is
   necessary for the ClientHello storage mechanism described in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-8.2&quot;&gt;Section 8.2&lt;/a&gt; because otherwise the server needs to store an unlimited
   number of ClientHellos, and is a useful optimization for self-
   contained single-use tickets because it allows efficient rejection of
   ClientHellos which cannot be used for 0-RTT.

   In order to implement this mechanism, a server needs to store the
   time that the server generated the session ticket, offset by an
   estimate of the round-trip time between client and server.  I.e.,

       adjusted_creation_time = creation_time + estimated_RTT

   This value can be encoded in the ticket, thus avoiding the need to
   keep state for each outstanding ticket.  The server can determine the
   client's view of the age of the ticket by subtracting the ticket's
   &quot;ticket_age_add&quot; value from the &quot;obfuscated_ticket_age&quot; parameter in
   the client's &quot;pre_shared_key&quot; extension.  The server can determine
   the expected_arrival_time of the ClientHello as:

     expected_arrival_time = adjusted_creation_time + clients_ticket_age

   When a new ClientHello is received, the expected_arrival_time is then
   compared against the current server wall clock time and if they
   differ by more than a certain amount, 0-RTT is rejected, though the
   1-RTT handshake can be allowed to complete.














&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 101]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   There are several potential sources of error that might cause
   mismatches between the expected_arrival_time and the measured time.
   Variations in client and server clock rates are likely to be minimal,
   though potentially the absolute times may be off by large values.
   Network propagation delays are the most likely causes of a mismatch
   in legitimate values for elapsed time.  Both the NewSessionTicket and
   ClientHello messages might be retransmitted and therefore delayed,
   which might be hidden by TCP.  For clients on the Internet, this
   implies windows on the order of ten seconds to account for errors in
   clocks and variations in measurements; other deployment scenarios may
   have different needs.  Clock skew distributions are not symmetric, so
   the optimal tradeoff may involve an asymmetric range of permissible
   mismatch values.

   Note that freshness checking alone is not sufficient to prevent
   replays because it does not detect them during the error window,
   which -- depending on bandwidth and system capacity -- could include
   billions of replays in real-world settings.  In addition, this
   freshness checking is only done at the time the ClientHello is
   received and not when subsequent early Application Data records are
   received.  After early data is accepted, records may continue to be
   streamed to the server over a longer time period.

&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-9&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-9&quot; id=&quot;section-9&quot;&gt;9&lt;/a&gt;.  Compliance Requirements&lt;/span&gt;

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-9.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-9.1&quot; id=&quot;section-9.1&quot;&gt;9.1&lt;/a&gt;.  Mandatory-to-Implement Cipher Suites&lt;/span&gt;

   In the absence of an application profile standard specifying
   otherwise:

   A TLS-compliant application MUST implement the TLS_AES_128_GCM_SHA256
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-GCM&quot; title=&quot;&amp;quot;Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC&amp;quot;&quot;&gt;GCM&lt;/a&gt;] cipher suite and SHOULD implement the TLS_AES_256_GCM_SHA384
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-GCM&quot; title=&quot;&amp;quot;Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC&amp;quot;&quot;&gt;GCM&lt;/a&gt;] and TLS_CHACHA20_POLY1305_SHA256 [&lt;a href=&quot;https://tools.ietf.org/html/rfc8439&quot; title=&quot;&amp;quot;ChaCha20 and Poly1305 for IETF Protocols&amp;quot;&quot;&gt;RFC8439&lt;/a&gt;] cipher suites (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.4&quot;&gt;Appendix B.4&lt;/a&gt;).

   A TLS-compliant application MUST support digital signatures with
   rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for
   CertificateVerify and certificates), and ecdsa_secp256r1_sha256.  A
   TLS-compliant application MUST support key exchange with secp256r1
   (NIST P-256) and SHOULD support key exchange with X25519 [&lt;a href=&quot;https://tools.ietf.org/html/rfc7748&quot; title=&quot;&amp;quot;Elliptic Curves for Security&amp;quot;&quot;&gt;RFC7748&lt;/a&gt;].











&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 102]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-9.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-9.2&quot; id=&quot;section-9.2&quot;&gt;9.2&lt;/a&gt;.  Mandatory-to-Implement Extensions&lt;/span&gt;

   In the absence of an application profile standard specifying
   otherwise, a TLS-compliant application MUST implement the following
   TLS extensions:

   -  Supported Versions (&quot;supported_versions&quot;; &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;)

   -  Cookie (&quot;cookie&quot;; &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   -  Signature Algorithms (&quot;signature_algorithms&quot;; &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;)

   -  Signature Algorithms Certificate (&quot;signature_algorithms_cert&quot;;
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;)

   -  Negotiated Groups (&quot;supported_groups&quot;; &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.7&quot;&gt;Section 4.2.7&lt;/a&gt;)

   -  Key Share (&quot;key_share&quot;; &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.8&quot;&gt;Section 4.2.8&lt;/a&gt;)

   -  Server Name Indication (&quot;server_name&quot;; &lt;a href=&quot;https://tools.ietf.org/html/rfc6066#section-3&quot;&gt;Section 3 of [RFC6066]&lt;/a&gt;)

   All implementations MUST send and use these extensions when offering
   applicable features:

   -  &quot;supported_versions&quot; is REQUIRED for all ClientHello, ServerHello,
      and HelloRetryRequest messages.

   -  &quot;signature_algorithms&quot; is REQUIRED for certificate authentication.

   -  &quot;supported_groups&quot; is REQUIRED for ClientHello messages using DHE
      or ECDHE key exchange.

   -  &quot;key_share&quot; is REQUIRED for DHE or ECDHE key exchange.

   -  &quot;pre_shared_key&quot; is REQUIRED for PSK key agreement.

   -  &quot;psk_key_exchange_modes&quot; is REQUIRED for PSK key agreement.














&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 103]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   A client is considered to be attempting to negotiate using this
   specification if the ClientHello contains a &quot;supported_versions&quot;
   extension with 0x0304 contained in its body.  Such a ClientHello
   message MUST meet the following requirements:

   -  If not containing a &quot;pre_shared_key&quot; extension, it MUST contain
      both a &quot;signature_algorithms&quot; extension and a &quot;supported_groups&quot;
      extension.

   -  If containing a &quot;supported_groups&quot; extension, it MUST also contain
      a &quot;key_share&quot; extension, and vice versa.  An empty
      KeyShare.client_shares vector is permitted.

   Servers receiving a ClientHello which does not conform to these
   requirements MUST abort the handshake with a &quot;missing_extension&quot;
   alert.

   Additionally, all implementations MUST support the use of the
   &quot;server_name&quot; extension with applications capable of using it.
   Servers MAY require clients to send a valid &quot;server_name&quot; extension.
   Servers requiring this extension SHOULD respond to a ClientHello
   lacking a &quot;server_name&quot; extension by terminating the connection with
   a &quot;missing_extension&quot; alert.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-9.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-9.3&quot; id=&quot;section-9.3&quot;&gt;9.3&lt;/a&gt;.  Protocol Invariants&lt;/span&gt;

   This section describes invariants that TLS endpoints and middleboxes
   MUST follow.  It also applies to earlier versions of TLS.

   TLS is designed to be securely and compatibly extensible.  Newer
   clients or servers, when communicating with newer peers, should
   negotiate the most preferred common parameters.  The TLS handshake
   provides downgrade protection: Middleboxes passing traffic between a
   newer client and newer server without terminating TLS should be
   unable to influence the handshake (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1&quot;&gt;Appendix E.1&lt;/a&gt;).  At the same
   time, deployments update at different rates, so a newer client or
   server MAY continue to support older parameters, which would allow it
   to interoperate with older endpoints.













&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 104]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   For this to work, implementations MUST correctly handle extensible
   fields:

   -  A client sending a ClientHello MUST support all parameters
      advertised in it.  Otherwise, the server may fail to interoperate
      by selecting one of those parameters.

   -  A server receiving a ClientHello MUST correctly ignore all
      unrecognized cipher suites, extensions, and other parameters.
      Otherwise, it may fail to interoperate with newer clients.  In
      TLS 1.3, a client receiving a CertificateRequest or
      NewSessionTicket MUST also ignore all unrecognized extensions.

   -  A middlebox which terminates a TLS connection MUST behave as a
      compliant TLS server (to the original client), including having a
      certificate which the client is willing to accept, and also as a
      compliant TLS client (to the original server), including verifying
      the original server's certificate.  In particular, it MUST
      generate its own ClientHello containing only parameters it
      understands, and it MUST generate a fresh ServerHello random
      value, rather than forwarding the endpoint's value.

      Note that TLS's protocol requirements and security analysis only
      apply to the two connections separately.  Safely deploying a TLS
      terminator requires additional security considerations which are
      beyond the scope of this document.

   -  A middlebox which forwards ClientHello parameters it does not
      understand MUST NOT process any messages beyond that ClientHello.
      It MUST forward all subsequent traffic unmodified.  Otherwise, it
      may fail to interoperate with newer clients and servers.

      Forwarded ClientHellos may contain advertisements for features not
      supported by the middlebox, so the response may include future TLS
      additions the middlebox does not recognize.  These additions MAY
      change any message beyond the ClientHello arbitrarily.  In
      particular, the values sent in the ServerHello might change, the
      ServerHello format might change, and the TLSCiphertext format
      might change.

   The design of TLS 1.3 was constrained by widely deployed
   non-compliant TLS middleboxes (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.4&quot;&gt;Appendix D.4&lt;/a&gt;); however, it does
   not relax the invariants.  Those middleboxes continue to be
   non-compliant.







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 105]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-10&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-10&quot; id=&quot;section-10&quot;&gt;10&lt;/a&gt;.  Security Considerations&lt;/span&gt;

   Security issues are discussed throughout this memo, especially in
   Appendices C, D, and E.

&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-11&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-11&quot; id=&quot;section-11&quot;&gt;11&lt;/a&gt;.  IANA Considerations&lt;/span&gt;

   This document uses several registries that were originally created in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot; title=&quot;&amp;quot;The Transport Layer Security (TLS) Protocol Version 1.1&amp;quot;&quot;&gt;RFC4346&lt;/a&gt;] and updated in [&lt;a href=&quot;https://tools.ietf.org/html/rfc8447&quot; title=&quot;&amp;quot;IANA Registry Updates for TLS and DTLS&amp;quot;&quot;&gt;RFC8447&lt;/a&gt;].  IANA has updated these to
   reference this document.  The registries and their allocation
   policies are below:

   -  TLS Cipher Suites registry: values with the first byte in the
      range 0-254 (decimal) are assigned via Specification Required
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot; title=&quot;&amp;quot;Guidelines for Writing an IANA Considerations Section in RFCs&amp;quot;&quot;&gt;RFC8126&lt;/a&gt;].  Values with the first byte 255 (decimal) are reserved
      for Private Use [&lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot; title=&quot;&amp;quot;Guidelines for Writing an IANA Considerations Section in RFCs&amp;quot;&quot;&gt;RFC8126&lt;/a&gt;].

      IANA has added the cipher suites listed in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.4&quot;&gt;Appendix B.4&lt;/a&gt; to the
      registry.  The &quot;Value&quot; and &quot;Description&quot; columns are taken from
      the table.  The &quot;DTLS-OK&quot; and &quot;Recommended&quot; columns are both
      marked as &quot;Y&quot; for each new cipher suite.

   -  TLS ContentType registry: Future values are allocated via
      Standards Action [&lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot; title=&quot;&amp;quot;Guidelines for Writing an IANA Considerations Section in RFCs&amp;quot;&quot;&gt;RFC8126&lt;/a&gt;].

   -  TLS Alerts registry: Future values are allocated via Standards
      Action [&lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot; title=&quot;&amp;quot;Guidelines for Writing an IANA Considerations Section in RFCs&amp;quot;&quot;&gt;RFC8126&lt;/a&gt;].  IANA has populated this registry with the
      values from &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.2&quot;&gt;Appendix B.2&lt;/a&gt;.  The &quot;DTLS-OK&quot; column is marked as &quot;Y&quot;
      for all such values.  Values marked as &quot;_RESERVED&quot; have comments
      describing their previous usage.

   -  TLS HandshakeType registry: Future values are allocated via
      Standards Action [&lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot; title=&quot;&amp;quot;Guidelines for Writing an IANA Considerations Section in RFCs&amp;quot;&quot;&gt;RFC8126&lt;/a&gt;].  IANA has updated this registry to
      rename item 4 from &quot;NewSessionTicket&quot; to &quot;new_session_ticket&quot; and
      populated this registry with the values from &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3&quot;&gt;Appendix B.3&lt;/a&gt;.  The
      &quot;DTLS-OK&quot; column is marked as &quot;Y&quot; for all such values.  Values
      marked &quot;_RESERVED&quot; have comments describing their previous or
      temporary usage.













&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 106]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   This document also uses the TLS ExtensionType Values registry
   originally created in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4366&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Extensions&amp;quot;&quot;&gt;RFC4366&lt;/a&gt;].  IANA has updated it to reference
   this document.  Changes to the registry follow:

   -  IANA has updated the registration policy as follows:

      Values with the first byte in the range 0-254 (decimal) are
      assigned via Specification Required [&lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot; title=&quot;&amp;quot;Guidelines for Writing an IANA Considerations Section in RFCs&amp;quot;&quot;&gt;RFC8126&lt;/a&gt;].  Values with the
      first byte 255 (decimal) are reserved for Private Use [&lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot; title=&quot;&amp;quot;Guidelines for Writing an IANA Considerations Section in RFCs&amp;quot;&quot;&gt;RFC8126&lt;/a&gt;].

   -  IANA has updated this registry to include the &quot;key_share&quot;,
      &quot;pre_shared_key&quot;, &quot;psk_key_exchange_modes&quot;, &quot;early_data&quot;,
      &quot;cookie&quot;, &quot;supported_versions&quot;, &quot;certificate_authorities&quot;,
      &quot;oid_filters&quot;, &quot;post_handshake_auth&quot;, and
      &quot;signature_algorithms_cert&quot; extensions with the values defined in
      this document and the &quot;Recommended&quot; value of &quot;Y&quot;.

   -  IANA has updated this registry to include a &quot;TLS 1.3&quot; column which
      lists the messages in which the extension may appear.  This column
      has been initially populated from the table in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;, with
      any extension not listed there marked as &quot;-&quot; to indicate that it
      is not used by TLS 1.3.

   This document updates an entry in the TLS Certificate Types registry
   originally created in [&lt;a href=&quot;https://tools.ietf.org/html/rfc6091&quot; title=&quot;&amp;quot;Using OpenPGP Keys for Transport Layer Security (TLS) Authentication&amp;quot;&quot;&gt;RFC6091&lt;/a&gt;] and updated in [&lt;a href=&quot;https://tools.ietf.org/html/rfc8447&quot; title=&quot;&amp;quot;IANA Registry Updates for TLS and DTLS&amp;quot;&quot;&gt;RFC8447&lt;/a&gt;].  IANA has
   updated the entry for value 1 to have the name &quot;OpenPGP_RESERVED&quot;,
   &quot;Recommended&quot; value &quot;N&quot;, and comment &quot;Used in TLS versions prior
   to 1.3.&quot;

   This document updates an entry in the TLS Certificate Status Types
   registry originally created in [&lt;a href=&quot;https://tools.ietf.org/html/rfc6961&quot; title=&quot;&amp;quot;The Transport Layer Security (TLS) Multiple Certificate Status Request Extension&amp;quot;&quot;&gt;RFC6961&lt;/a&gt;].  IANA has updated the entry
   for value 2 to have the name &quot;ocsp_multi_RESERVED&quot; and comment &quot;Used
   in TLS versions prior to 1.3&quot;.

   This document updates two entries in the TLS Supported Groups
   registry (created under a different name by [&lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot; title=&quot;&amp;quot;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)&amp;quot;&quot;&gt;RFC4492&lt;/a&gt;]; now maintained
   by [&lt;a href=&quot;https://tools.ietf.org/html/rfc8422&quot; title=&quot;&amp;quot;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier&amp;quot;&quot;&gt;RFC8422&lt;/a&gt;]) and updated by [&lt;a href=&quot;https://tools.ietf.org/html/rfc7919&quot; title=&quot;&amp;quot;Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)&amp;quot;&quot;&gt;RFC7919&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc8447&quot; title=&quot;&amp;quot;IANA Registry Updates for TLS and DTLS&amp;quot;&quot;&gt;RFC8447&lt;/a&gt;].  The entries
   for values 29 and 30 (x25519 and x448) have been updated to also
   refer to this document.












&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 107]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   In addition, this document defines two new registries that are
   maintained by IANA:

   -  TLS SignatureScheme registry: Values with the first byte in the
      range 0-253 (decimal) are assigned via Specification Required
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot; title=&quot;&amp;quot;Guidelines for Writing an IANA Considerations Section in RFCs&amp;quot;&quot;&gt;RFC8126&lt;/a&gt;].  Values with the first byte 254 or 255 (decimal) are
      reserved for Private Use [&lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot; title=&quot;&amp;quot;Guidelines for Writing an IANA Considerations Section in RFCs&amp;quot;&quot;&gt;RFC8126&lt;/a&gt;].  Values with the first byte in
      the range 0-6 or with the second byte in the range 0-3 that are
      not currently allocated are reserved for backward compatibility.
      This registry has a &quot;Recommended&quot; column.  The registry has been
      initially populated with the values described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;.
      The following values are marked as &quot;Recommended&quot;:
      ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384,
      rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512,
      rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, and
      ed25519.  The &quot;Recommended&quot; column is assigned a value of &quot;N&quot;
      unless explicitly requested, and adding a value with a
      &quot;Recommended&quot; value of &quot;Y&quot; requires Standards Action [&lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot; title=&quot;&amp;quot;Guidelines for Writing an IANA Considerations Section in RFCs&amp;quot;&quot;&gt;RFC8126&lt;/a&gt;].
      IESG Approval is REQUIRED for a Y-&amp;gt;N transition.

   -  TLS PskKeyExchangeMode registry: Values in the range 0-253
      (decimal) are assigned via Specification Required [&lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot; title=&quot;&amp;quot;Guidelines for Writing an IANA Considerations Section in RFCs&amp;quot;&quot;&gt;RFC8126&lt;/a&gt;].
      The values 254 and 255 (decimal) are reserved for Private Use
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot; title=&quot;&amp;quot;Guidelines for Writing an IANA Considerations Section in RFCs&amp;quot;&quot;&gt;RFC8126&lt;/a&gt;].  This registry has a &quot;Recommended&quot; column.  The
      registry has been initially populated with psk_ke (0) and
      psk_dhe_ke (1).  Both are marked as &quot;Recommended&quot;.  The
      &quot;Recommended&quot; column is assigned a value of &quot;N&quot; unless explicitly
      requested, and adding a value with a &quot;Recommended&quot; value of &quot;Y&quot;
      requires Standards Action [&lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot; title=&quot;&amp;quot;Guidelines for Writing an IANA Considerations Section in RFCs&amp;quot;&quot;&gt;RFC8126&lt;/a&gt;].  IESG Approval is REQUIRED
      for a Y-&amp;gt;N transition.





















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 108]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-12&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-12&quot; id=&quot;section-12&quot;&gt;12&lt;/a&gt;.  References&lt;/span&gt;

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-12.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-12.1&quot; id=&quot;section-12.1&quot;&gt;12.1&lt;/a&gt;.  Normative References&lt;/span&gt;

   [&lt;a name=&quot;ref-DH76&quot; id=&quot;ref-DH76&quot;&gt;DH76&lt;/a&gt;]     Diffie, W. and M. Hellman, &quot;New directions in
              cryptography&quot;, IEEE Transactions on Information
              Theory, Vol. 22 No. 6, pp. 644-654,
              DOI 10.1109/TIT.1976.1055638, November 1976.

   [&lt;a name=&quot;ref-ECDSA&quot; id=&quot;ref-ECDSA&quot;&gt;ECDSA&lt;/a&gt;]    American National Standards Institute, &quot;Public Key
              Cryptography for the Financial Services Industry: The
              Elliptic Curve Digital Signature Algorithm (ECDSA)&quot;,
              ANSI ANS X9.62-2005, November 2005.

   [&lt;a name=&quot;ref-GCM&quot; id=&quot;ref-GCM&quot;&gt;GCM&lt;/a&gt;]      Dworkin, M., &quot;Recommendation for Block Cipher Modes of
              Operation: Galois/Counter Mode (GCM) and GMAC&quot;,
              NIST Special Publication 800-38D,
              DOI 10.6028/NIST.SP.800-38D, November 2007.

   [&lt;a name=&quot;ref-RFC2104&quot; id=&quot;ref-RFC2104&quot;&gt;RFC2104&lt;/a&gt;]  Krawczyk, H., Bellare, M., and R. Canetti, &quot;HMAC: Keyed-
              Hashing for Message Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2104&quot;&gt;RFC 2104&lt;/a&gt;,
              DOI 10.17487/RFC2104, February 1997,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc2104&quot;&gt;https://www.rfc-editor.org/info/rfc2104&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC2119&quot; id=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;,
              DOI 10.17487/RFC2119, March 1997,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc2119&quot;&gt;https://www.rfc-editor.org/info/rfc2119&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC5116&quot; id=&quot;ref-RFC5116&quot;&gt;RFC5116&lt;/a&gt;]  McGrew, D., &quot;An Interface and Algorithms for Authenticated
              Encryption&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5116&quot;&gt;RFC 5116&lt;/a&gt;, DOI 10.17487/RFC5116, January 2008,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc5116&quot;&gt;https://www.rfc-editor.org/info/rfc5116&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC5280&quot; id=&quot;ref-RFC5280&quot;&gt;RFC5280&lt;/a&gt;]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, &quot;Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot;&gt;RFC 5280&lt;/a&gt;, DOI 10.17487/RFC5280, May 2008,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc5280&quot;&gt;https://www.rfc-editor.org/info/rfc5280&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC5705&quot; id=&quot;ref-RFC5705&quot;&gt;RFC5705&lt;/a&gt;]  Rescorla, E., &quot;Keying Material Exporters for Transport
              Layer Security (TLS)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5705&quot;&gt;RFC 5705&lt;/a&gt;, DOI 10.17487/RFC5705,
              March 2010, &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc5705&quot;&gt;https://www.rfc-editor.org/info/rfc5705&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC5756&quot; id=&quot;ref-RFC5756&quot;&gt;RFC5756&lt;/a&gt;]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,
              &quot;Updates for RSAES-OAEP and RSASSA-PSS Algorithm
              Parameters&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5756&quot;&gt;RFC 5756&lt;/a&gt;, DOI 10.17487/RFC5756, January 2010,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc5756&quot;&gt;https://www.rfc-editor.org/info/rfc5756&lt;/a&gt;&amp;gt;.




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 109]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   [&lt;a name=&quot;ref-RFC5869&quot; id=&quot;ref-RFC5869&quot;&gt;RFC5869&lt;/a&gt;]  Krawczyk, H. and P. Eronen, &quot;HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5869&quot;&gt;RFC 5869&lt;/a&gt;,
              DOI 10.17487/RFC5869, May 2010,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc5869&quot;&gt;https://www.rfc-editor.org/info/rfc5869&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC6066&quot; id=&quot;ref-RFC6066&quot;&gt;RFC6066&lt;/a&gt;]  Eastlake 3rd, D., &quot;Transport Layer Security (TLS)
              Extensions: Extension Definitions&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot;&gt;RFC 6066&lt;/a&gt;,
              DOI 10.17487/RFC6066, January 2011,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc6066&quot;&gt;https://www.rfc-editor.org/info/rfc6066&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC6655&quot; id=&quot;ref-RFC6655&quot;&gt;RFC6655&lt;/a&gt;]  McGrew, D. and D. Bailey, &quot;AES-CCM Cipher Suites for
              Transport Layer Security (TLS)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6655&quot;&gt;RFC 6655&lt;/a&gt;,
              DOI 10.17487/RFC6655, July 2012,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc6655&quot;&gt;https://www.rfc-editor.org/info/rfc6655&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC6960&quot; id=&quot;ref-RFC6960&quot;&gt;RFC6960&lt;/a&gt;]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,
              Galperin, S., and C. Adams, &quot;X.509 Internet Public Key
              Infrastructure Online Certificate Status Protocol - OCSP&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc6960&quot;&gt;RFC 6960&lt;/a&gt;, DOI 10.17487/RFC6960, June 2013,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc6960&quot;&gt;https://www.rfc-editor.org/info/rfc6960&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC6961&quot; id=&quot;ref-RFC6961&quot;&gt;RFC6961&lt;/a&gt;]  Pettersen, Y., &quot;The Transport Layer Security (TLS)
              Multiple Certificate Status Request Extension&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6961&quot;&gt;RFC 6961&lt;/a&gt;,
              DOI 10.17487/RFC6961, June 2013,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc6961&quot;&gt;https://www.rfc-editor.org/info/rfc6961&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC6962&quot; id=&quot;ref-RFC6962&quot;&gt;RFC6962&lt;/a&gt;]  Laurie, B., Langley, A., and E. Kasper, &quot;Certificate
              Transparency&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6962&quot;&gt;RFC 6962&lt;/a&gt;, DOI 10.17487/RFC6962, June 2013,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc6962&quot;&gt;https://www.rfc-editor.org/info/rfc6962&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC6979&quot; id=&quot;ref-RFC6979&quot;&gt;RFC6979&lt;/a&gt;]  Pornin, T., &quot;Deterministic Usage of the Digital Signature
              Algorithm (DSA) and Elliptic Curve Digital Signature
              Algorithm (ECDSA)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6979&quot;&gt;RFC 6979&lt;/a&gt;, DOI 10.17487/RFC6979,
              August 2013, &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc6979&quot;&gt;https://www.rfc-editor.org/info/rfc6979&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC7301&quot; id=&quot;ref-RFC7301&quot;&gt;RFC7301&lt;/a&gt;]  Friedl, S., Popov, A., Langley, A., and E. Stephan,
              &quot;Transport Layer Security (TLS) Application-Layer Protocol
              Negotiation Extension&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7301&quot;&gt;RFC 7301&lt;/a&gt;, DOI 10.17487/RFC7301,
              July 2014, &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc7301&quot;&gt;https://www.rfc-editor.org/info/rfc7301&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC7507&quot; id=&quot;ref-RFC7507&quot;&gt;RFC7507&lt;/a&gt;]  Moeller, B. and A. Langley, &quot;TLS Fallback Signaling Cipher
              Suite Value (SCSV) for Preventing Protocol Downgrade
              Attacks&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7507&quot;&gt;RFC 7507&lt;/a&gt;, DOI 10.17487/RFC7507, April 2015,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc7507&quot;&gt;https://www.rfc-editor.org/info/rfc7507&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC7748&quot; id=&quot;ref-RFC7748&quot;&gt;RFC7748&lt;/a&gt;]  Langley, A., Hamburg, M., and S. Turner, &quot;Elliptic Curves
              for Security&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7748&quot;&gt;RFC 7748&lt;/a&gt;, DOI 10.17487/RFC7748,
              January 2016, &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc7748&quot;&gt;https://www.rfc-editor.org/info/rfc7748&lt;/a&gt;&amp;gt;.



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 110]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   [&lt;a name=&quot;ref-RFC7919&quot; id=&quot;ref-RFC7919&quot;&gt;RFC7919&lt;/a&gt;]  Gillmor, D., &quot;Negotiated Finite Field Diffie-Hellman
              Ephemeral Parameters for Transport Layer Security (TLS)&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7919&quot;&gt;RFC 7919&lt;/a&gt;, DOI 10.17487/RFC7919, August 2016,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc7919&quot;&gt;https://www.rfc-editor.org/info/rfc7919&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC8017&quot; id=&quot;ref-RFC8017&quot;&gt;RFC8017&lt;/a&gt;]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              &quot;PKCS #1: RSA Cryptography Specifications Version 2.2&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc8017&quot;&gt;RFC 8017&lt;/a&gt;, DOI 10.17487/RFC8017, November 2016,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc8017&quot;&gt;https://www.rfc-editor.org/info/rfc8017&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC8032&quot; id=&quot;ref-RFC8032&quot;&gt;RFC8032&lt;/a&gt;]  Josefsson, S. and I. Liusvaara, &quot;Edwards-Curve Digital
              Signature Algorithm (EdDSA)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc8032&quot;&gt;RFC 8032&lt;/a&gt;,
              DOI 10.17487/RFC8032, January 2017,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc8032&quot;&gt;https://www.rfc-editor.org/info/rfc8032&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC8126&quot; id=&quot;ref-RFC8126&quot;&gt;RFC8126&lt;/a&gt;]  Cotton, M., Leiba, B., and T. Narten, &quot;Guidelines for
              Writing an IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc8126&quot;&gt;RFC 8126&lt;/a&gt;, DOI 10.17487/RFC8126, June 2017,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc8126&quot;&gt;https://www.rfc-editor.org/info/rfc8126&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC8174&quot; id=&quot;ref-RFC8174&quot;&gt;RFC8174&lt;/a&gt;]  Leiba, B., &quot;Ambiguity of Uppercase vs Lowercase in
              &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; Key Words&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc8174&quot;&gt;RFC 8174&lt;/a&gt;,
              DOI 10.17487/RFC8174, May 2017,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc8174&quot;&gt;https://www.rfc-editor.org/info/rfc8174&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC8439&quot; id=&quot;ref-RFC8439&quot;&gt;RFC8439&lt;/a&gt;]  Nir, Y. and A. Langley, &quot;ChaCha20 and Poly1305 for IETF
              Protocols&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc8439&quot;&gt;RFC 8439&lt;/a&gt;, DOI 10.17487/RFC8439, June 2018,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc8439&quot;&gt;https://www.rfc-editor.org/info/rfc8439&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-SHS&quot; id=&quot;ref-SHS&quot;&gt;SHS&lt;/a&gt;]      Dang, Q., &quot;Secure Hash Standard (SHS)&quot;, National Institute
              of Standards and Technology report,
              DOI 10.6028/NIST.FIPS.180-4, August 2015.

   [&lt;a name=&quot;ref-X690&quot; id=&quot;ref-X690&quot;&gt;X690&lt;/a&gt;]     ITU-T, &quot;Information technology -- ASN.1 encoding rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER)&quot;, ISO/IEC 8825-1:2015, November 2015.














&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 111]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;section-12.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#section-12.2&quot; id=&quot;section-12.2&quot;&gt;12.2&lt;/a&gt;.  Informative References&lt;/span&gt;

   [&lt;a name=&quot;ref-AEAD-LIMITS&quot; id=&quot;ref-AEAD-LIMITS&quot;&gt;AEAD-LIMITS&lt;/a&gt;]
              Luykx, A. and K. Paterson, &quot;Limits on Authenticated
              Encryption Use in TLS&quot;, August 2017,
              &amp;lt;&lt;a href=&quot;http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf&quot;&gt;http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-BBFGKZ16&quot; id=&quot;ref-BBFGKZ16&quot;&gt;BBFGKZ16&lt;/a&gt;]
              Bhargavan, K., Brzuska, C., Fournet, C., Green, M.,
              Kohlweiss, M., and S. Zanella-Beguelin, &quot;Downgrade
              Resilience in Key-Exchange Protocols&quot;, Proceedings of IEEE
              Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.37, May 2016.

   [&lt;a name=&quot;ref-BBK17&quot; id=&quot;ref-BBK17&quot;&gt;BBK17&lt;/a&gt;]    Bhargavan, K., Blanchet, B., and N. Kobeissi, &quot;Verified
              Models and Reference Implementations for the TLS 1.3
              Standard Candidate&quot;, Proceedings of IEEE Symposium on
              Security and Privacy (San Jose), DOI 10.1109/SP.2017.26,
              May 2017.

   [&lt;a name=&quot;ref-BDFKPPRSZZ16&quot; id=&quot;ref-BDFKPPRSZZ16&quot;&gt;BDFKPPRSZZ16&lt;/a&gt;]
              Bhargavan, K., Delignat-Lavaud, A., Fournet, C.,
              Kohlweiss, M., Pan, J., Protzenko, J., Rastogi, A., Swamy,
              N., Zanella-Beguelin, S., and J. Zinzindohoue,
              &quot;Implementing and Proving the TLS 1.3 Record Layer&quot;,
              Proceedings of IEEE Symposium on Security and Privacy (San
              Jose), May 2017, &amp;lt;&lt;a href=&quot;https://eprint.iacr.org/2016/1178&quot;&gt;https://eprint.iacr.org/2016/1178&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-Ben17a&quot; id=&quot;ref-Ben17a&quot;&gt;Ben17a&lt;/a&gt;]   Benjamin, D., &quot;Presentation before the TLS WG at
              IETF 100&quot;, November 2017,
              &amp;lt;&lt;a href=&quot;https://datatracker.ietf.org/meeting/100/materials/slides-100-tls-sessa-tls13/&quot;&gt;https://datatracker.ietf.org/meeting/100/materials/&lt;/a&gt;
              &lt;a href=&quot;https://datatracker.ietf.org/meeting/100/materials/slides-100-tls-sessa-tls13/&quot;&gt;slides-100-tls-sessa-tls13/&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-Ben17b&quot; id=&quot;ref-Ben17b&quot;&gt;Ben17b&lt;/a&gt;]   Benjamin, D., &quot;Additional TLS 1.3 results from Chrome&quot;,
              message to the TLS mailing list, 18 December 2017,
              &amp;lt;&lt;a href=&quot;https://www.ietf.org/mail-archive/web/tls/current/msg25168.html&quot;&gt;https://www.ietf.org/mail-archive/web/tls/current/&lt;/a&gt;
              &lt;a href=&quot;https://www.ietf.org/mail-archive/web/tls/current/msg25168.html&quot;&gt;msg25168.html&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-Blei98&quot; id=&quot;ref-Blei98&quot;&gt;Blei98&lt;/a&gt;]   Bleichenbacher, D., &quot;Chosen Ciphertext Attacks against
              Protocols Based on RSA Encryption Standard PKCS #1&quot;,
              Proceedings of CRYPTO '98, 1998.

   [&lt;a name=&quot;ref-BMMRT15&quot; id=&quot;ref-BMMRT15&quot;&gt;BMMRT15&lt;/a&gt;]  Badertscher, C., Matt, C., Maurer, U., Rogaway, P., and B.
              Tackmann, &quot;Augmented Secure Channels and the Goal of the
              TLS 1.3 Record Layer&quot;, ProvSec 2015, September 2015,
              &amp;lt;&lt;a href=&quot;https://eprint.iacr.org/2015/394&quot;&gt;https://eprint.iacr.org/2015/394&lt;/a&gt;&amp;gt;.





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 112]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   [&lt;a name=&quot;ref-BT16&quot; id=&quot;ref-BT16&quot;&gt;BT16&lt;/a&gt;]     Bellare, M. and B. Tackmann, &quot;The Multi-User Security of
              Authenticated Encryption: AES-GCM in TLS 1.3&quot;, Proceedings
              of CRYPTO 2016, July 2016,
              &amp;lt;&lt;a href=&quot;https://eprint.iacr.org/2016/564&quot;&gt;https://eprint.iacr.org/2016/564&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-CCG16&quot; id=&quot;ref-CCG16&quot;&gt;CCG16&lt;/a&gt;]    Cohn-Gordon, K., Cremers, C., and L. Garratt, &quot;On
              Post-compromise Security&quot;, IEEE Computer Security
              Foundations Symposium, DOI 10.1109/CSF.2016.19, July 2015.

   [&lt;a name=&quot;ref-CHECKOWAY&quot; id=&quot;ref-CHECKOWAY&quot;&gt;CHECKOWAY&lt;/a&gt;]
              Checkoway, S., Maskiewicz, J., Garman, C., Fried, J.,
              Cohney, S., Green, M., Heninger, N., Weinmann, R.,
              Rescorla, E., and H. Shacham, &quot;A Systematic Analysis of
              the Juniper Dual EC Incident&quot;, Proceedings of the 2016 ACM
              SIGSAC Conference on Computer and Communications Security
              - CCS '16, DOI 10.1145/2976749.2978395, October 2016.

   [&lt;a name=&quot;ref-CHHSV17&quot; id=&quot;ref-CHHSV17&quot;&gt;CHHSV17&lt;/a&gt;]  Cremers, C., Horvat, M., Hoyland, J., Scott, S., and T.
              van der Merwe, &quot;Awkward Handshake: Possible mismatch of
              client/server view on client authentication in
              post-handshake mode in Revision 18&quot;, message to the TLS
              mailing list, 10 February 2017, &amp;lt;&lt;a href=&quot;https://www.ietf.org/mail-archive/web/tls/current/msg22382.html&quot;&gt;https://www.ietf.org/&lt;/a&gt;
              &lt;a href=&quot;https://www.ietf.org/mail-archive/web/tls/current/msg22382.html&quot;&gt;mail-archive/web/tls/current/msg22382.html&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-CHSV16&quot; id=&quot;ref-CHSV16&quot;&gt;CHSV16&lt;/a&gt;]   Cremers, C., Horvat, M., Scott, S., and T. van der Merwe,
              &quot;Automated Analysis and Verification of TLS 1.3: 0-RTT,
              Resumption and Delayed Authentication&quot;, Proceedings of
              IEEE Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.35, May 2016,
              &amp;lt;&lt;a href=&quot;https://ieeexplore.ieee.org/document/7546518/&quot;&gt;https://ieeexplore.ieee.org/document/7546518/&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-CK01&quot; id=&quot;ref-CK01&quot;&gt;CK01&lt;/a&gt;]     Canetti, R. and H. Krawczyk, &quot;Analysis of Key-Exchange
              Protocols and Their Use for Building Secure Channels&quot;,
              Proceedings of Eurocrypt 2001,
              DOI 10.1007/3-540-44987-6_28, April 2001.

   [&lt;a name=&quot;ref-CLINIC&quot; id=&quot;ref-CLINIC&quot;&gt;CLINIC&lt;/a&gt;]   Miller, B., Huang, L., Joseph, A., and J. Tygar, &quot;I Know
              Why You Went to the Clinic: Risks and Realization of HTTPS
              Traffic Analysis&quot;, Privacy Enhancing Technologies, pp.
              143-163, DOI 10.1007/978-3-319-08506-7_8, 2014.

   [&lt;a name=&quot;ref-DFGS15&quot; id=&quot;ref-DFGS15&quot;&gt;DFGS15&lt;/a&gt;]   Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,
              &quot;A Cryptographic Analysis of the TLS 1.3 Handshake
              Protocol Candidates&quot;, Proceedings of ACM CCS 2015,
              October 2015, &amp;lt;&lt;a href=&quot;https://eprint.iacr.org/2015/914&quot;&gt;https://eprint.iacr.org/2015/914&lt;/a&gt;&amp;gt;.






&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 113]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   [&lt;a name=&quot;ref-DFGS16&quot; id=&quot;ref-DFGS16&quot;&gt;DFGS16&lt;/a&gt;]   Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,
              &quot;A Cryptographic Analysis of the TLS 1.3 Full and
              Pre-shared Key Handshake Protocol&quot;, TRON 2016,
              February 2016, &amp;lt;&lt;a href=&quot;https://eprint.iacr.org/2016/081&quot;&gt;https://eprint.iacr.org/2016/081&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-DOW92&quot; id=&quot;ref-DOW92&quot;&gt;DOW92&lt;/a&gt;]    Diffie, W., van Oorschot, P., and M. Wiener,
              &quot;Authentication and authenticated key exchanges&quot;, Designs,
              Codes and Cryptography, DOI 10.1007/BF00124891, June 1992.

   [&lt;a name=&quot;ref-DSS&quot; id=&quot;ref-DSS&quot;&gt;DSS&lt;/a&gt;]      National Institute of Standards and Technology, U.S.
              Department of Commerce, &quot;Digital Signature Standard
              (DSS)&quot;, NIST FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4,
              July 2013.

   [&lt;a name=&quot;ref-FG17&quot; id=&quot;ref-FG17&quot;&gt;FG17&lt;/a&gt;]     Fischlin, M. and F. Guenther, &quot;Replay Attacks on Zero
              Round-Trip Time: The Case of the TLS 1.3 Handshake
              Candidates&quot;, Proceedings of EuroS&amp;amp;P 2017, April 2017,
              &amp;lt;&lt;a href=&quot;https://eprint.iacr.org/2017/082&quot;&gt;https://eprint.iacr.org/2017/082&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-FGSW16&quot; id=&quot;ref-FGSW16&quot;&gt;FGSW16&lt;/a&gt;]   Fischlin, M., Guenther, F., Schmidt, B., and B. Warinschi,
              &quot;Key Confirmation in Key Exchange: A Formal Treatment and
              Implications for TLS 1.3&quot;, Proceedings of IEEE Symposium
              on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.34, May 2016,
              &amp;lt;&lt;a href=&quot;https://ieeexplore.ieee.org/document/7546517/&quot;&gt;https://ieeexplore.ieee.org/document/7546517/&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-FW15&quot; id=&quot;ref-FW15&quot;&gt;FW15&lt;/a&gt;]     Weimer, F., &quot;Factoring RSA Keys With TLS Perfect Forward
              Secrecy&quot;, September 2015.

   [&lt;a name=&quot;ref-HCJC16&quot; id=&quot;ref-HCJC16&quot;&gt;HCJC16&lt;/a&gt;]   Husak, M., Cermak, M., Jirsik, T., and P. Celeda, &quot;HTTPS
              traffic analysis and client identification using passive
              SSL/TLS fingerprinting&quot;, EURASIP Journal on Information
              Security, Vol. 2016, DOI 10.1186/s13635-016-0030-7,
              February 2016.

   [&lt;a name=&quot;ref-HGFS15&quot; id=&quot;ref-HGFS15&quot;&gt;HGFS15&lt;/a&gt;]   Hlauschek, C., Gruber, M., Fankhauser, F., and C. Schanes,
              &quot;Prying Open Pandora's Box: KCI Attacks against TLS&quot;,
              Proceedings of USENIX Workshop on Offensive Technologies,
              August 2015.

   [&lt;a name=&quot;ref-IEEE1363&quot; id=&quot;ref-IEEE1363&quot;&gt;IEEE1363&lt;/a&gt;]
              IEEE, &quot;IEEE Standard Specifications for Public Key
              Cryptography&quot;, IEEE Std. 1363-2000,
              DOI 10.1109/IEEESTD.2000.92292.







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 114]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   [&lt;a name=&quot;ref-JSS15&quot; id=&quot;ref-JSS15&quot;&gt;JSS15&lt;/a&gt;]    Jager, T., Schwenk, J., and J. Somorovsky, &quot;On the
              Security of TLS 1.3 and QUIC Against Weaknesses in PKCS#1
              v1.5 Encryption&quot;, Proceedings of ACM CCS 2015,
              DOI 10.1145/2810103.2813657, October 2015,
              &amp;lt;&lt;a href=&quot;https://www.nds.rub.de/media/nds/veroeffentlichungen/2015/08/21/Tls13QuicAttacks.pdf&quot;&gt;https://www.nds.rub.de/media/nds/&lt;/a&gt;
              &lt;a href=&quot;https://www.nds.rub.de/media/nds/veroeffentlichungen/2015/08/21/Tls13QuicAttacks.pdf&quot;&gt;veroeffentlichungen/2015/08/21/Tls13QuicAttacks.pdf&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-KEYAGREEMENT&quot; id=&quot;ref-KEYAGREEMENT&quot;&gt;KEYAGREEMENT&lt;/a&gt;]
              Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R.
              Davis, &quot;Recommendation for Pair-Wise Key Establishment
              Schemes Using Discrete Logarithm Cryptography&quot;, National
              Institute of Standards and Technology,
              DOI 10.6028/NIST.SP.800-56Ar3, April 2018.

   [&lt;a name=&quot;ref-Kraw10&quot; id=&quot;ref-Kraw10&quot;&gt;Kraw10&lt;/a&gt;]   Krawczyk, H., &quot;Cryptographic Extraction and Key
              Derivation: The HKDF Scheme&quot;, Proceedings of CRYPTO 2010,
              August 2010, &amp;lt;&lt;a href=&quot;https://eprint.iacr.org/2010/264&quot;&gt;https://eprint.iacr.org/2010/264&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-Kraw16&quot; id=&quot;ref-Kraw16&quot;&gt;Kraw16&lt;/a&gt;]   Krawczyk, H., &quot;A Unilateral-to-Mutual Authentication
              Compiler for Key Exchange (with Applications to Client
              Authentication in TLS 1.3&quot;, Proceedings of ACM CCS 2016,
              October 2016, &amp;lt;&lt;a href=&quot;https://eprint.iacr.org/2016/711&quot;&gt;https://eprint.iacr.org/2016/711&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-KW16&quot; id=&quot;ref-KW16&quot;&gt;KW16&lt;/a&gt;]     Krawczyk, H. and H. Wee, &quot;The OPTLS Protocol and TLS 1.3&quot;,
              Proceedings of EuroS&amp;amp;P 2016, March 2016,
              &amp;lt;&lt;a href=&quot;https://eprint.iacr.org/2015/978&quot;&gt;https://eprint.iacr.org/2015/978&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-LXZFH16&quot; id=&quot;ref-LXZFH16&quot;&gt;LXZFH16&lt;/a&gt;]  Li, X., Xu, J., Zhang, Z., Feng, D., and H. Hu, &quot;Multiple
              Handshakes Security of TLS 1.3 Candidates&quot;, Proceedings of
              IEEE Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.36, May 2016,
              &amp;lt;&lt;a href=&quot;https://ieeexplore.ieee.org/document/7546519/&quot;&gt;https://ieeexplore.ieee.org/document/7546519/&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-Mac17&quot; id=&quot;ref-Mac17&quot;&gt;Mac17&lt;/a&gt;]    MacCarthaigh, C., &quot;Security Review of TLS1.3 0-RTT&quot;,
              March 2017, &amp;lt;&lt;a href=&quot;https://github.com/tlswg/tls13-spec/issues/1001&quot;&gt;https://github.com/tlswg/tls13-spec/&lt;/a&gt;
              &lt;a href=&quot;https://github.com/tlswg/tls13-spec/issues/1001&quot;&gt;issues/1001&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-PS18&quot; id=&quot;ref-PS18&quot;&gt;PS18&lt;/a&gt;]     Patton, C. and T. Shrimpton, &quot;Partially specified
              channels: The TLS 1.3 record layer without elision&quot;, 2018,
              &amp;lt;&lt;a href=&quot;https://eprint.iacr.org/2018/634&quot;&gt;https://eprint.iacr.org/2018/634&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-PSK-FINISHED&quot; id=&quot;ref-PSK-FINISHED&quot;&gt;PSK-FINISHED&lt;/a&gt;]
              Scott, S., Cremers, C., Horvat, M., and T. van der Merwe,
              &quot;Revision 10: possible attack if client authentication is
              allowed during PSK&quot;, message to the TLS mailing list,
              31 October 2015, &amp;lt;&lt;a href=&quot;https://www.ietf.org/mail-archive/web/tls/current/msg18215.html&quot;&gt;https://www.ietf.org/&lt;/a&gt;
              &lt;a href=&quot;https://www.ietf.org/mail-archive/web/tls/current/msg18215.html&quot;&gt;mail-archive/web/tls/current/msg18215.html&lt;/a&gt;&amp;gt;.




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 115]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   [&lt;a name=&quot;ref-REKEY&quot; id=&quot;ref-REKEY&quot;&gt;REKEY&lt;/a&gt;]    Abdalla, M. and M. Bellare, &quot;Increasing the Lifetime of a
              Key: A Comparative Analysis of the Security of Re-keying
              Techniques&quot;, ASIACRYPT 2000, DOI 10.1007/3-540-44448-3_42,
              October 2000.

   [&lt;a name=&quot;ref-Res17a&quot; id=&quot;ref-Res17a&quot;&gt;Res17a&lt;/a&gt;]   Rescorla, E., &quot;Preliminary data on Firefox TLS 1.3
              Middlebox experiment&quot;, message to the TLS mailing list,
              5 December 2017, &amp;lt;&lt;a href=&quot;https://www.ietf.org/mail-archive/web/tls/current/msg25091.html&quot;&gt;https://www.ietf.org/&lt;/a&gt;
              &lt;a href=&quot;https://www.ietf.org/mail-archive/web/tls/current/msg25091.html&quot;&gt;mail-archive/web/tls/current/msg25091.html&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-Res17b&quot; id=&quot;ref-Res17b&quot;&gt;Res17b&lt;/a&gt;]   Rescorla, E., &quot;More compatibility measurement results&quot;,
              message to the TLS mailing list, 22 December 2017,
              &amp;lt;&lt;a href=&quot;https://www.ietf.org/mail-archive/web/tls/current/msg25179.html&quot;&gt;https://www.ietf.org/mail-archive/web/tls/current/&lt;/a&gt;
              &lt;a href=&quot;https://www.ietf.org/mail-archive/web/tls/current/msg25179.html&quot;&gt;msg25179.html&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC3552&quot; id=&quot;ref-RFC3552&quot;&gt;RFC3552&lt;/a&gt;]  Rescorla, E. and B. Korver, &quot;Guidelines for Writing RFC
              Text on Security Considerations&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp72&quot;&gt;BCP 72&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3552&quot;&gt;RFC 3552&lt;/a&gt;,
              DOI 10.17487/RFC3552, July 2003,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc3552&quot;&gt;https://www.rfc-editor.org/info/rfc3552&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC4086&quot; id=&quot;ref-RFC4086&quot;&gt;RFC4086&lt;/a&gt;]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              &quot;Randomness Requirements for Security&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp106&quot;&gt;BCP 106&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4086&quot;&gt;RFC 4086&lt;/a&gt;,
              DOI 10.17487/RFC4086, June 2005,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc4086&quot;&gt;https://www.rfc-editor.org/info/rfc4086&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC4346&quot; id=&quot;ref-RFC4346&quot;&gt;RFC4346&lt;/a&gt;]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC 4346&lt;/a&gt;,
              DOI 10.17487/RFC4346, April 2006,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc4346&quot;&gt;https://www.rfc-editor.org/info/rfc4346&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC4366&quot; id=&quot;ref-RFC4366&quot;&gt;RFC4366&lt;/a&gt;]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,
              and T. Wright, &quot;Transport Layer Security (TLS)
              Extensions&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4366&quot;&gt;RFC 4366&lt;/a&gt;, DOI 10.17487/RFC4366, April 2006,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc4366&quot;&gt;https://www.rfc-editor.org/info/rfc4366&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC4492&quot; id=&quot;ref-RFC4492&quot;&gt;RFC4492&lt;/a&gt;]  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.
              Moeller, &quot;Elliptic Curve Cryptography (ECC) Cipher Suites
              for Transport Layer Security (TLS)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot;&gt;RFC 4492&lt;/a&gt;,
              DOI 10.17487/RFC4492, May 2006,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc4492&quot;&gt;https://www.rfc-editor.org/info/rfc4492&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC5077&quot; id=&quot;ref-RFC5077&quot;&gt;RFC5077&lt;/a&gt;]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,
              &quot;Transport Layer Security (TLS) Session Resumption without
              Server-Side State&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5077&quot;&gt;RFC 5077&lt;/a&gt;, DOI 10.17487/RFC5077,
              January 2008, &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc5077&quot;&gt;https://www.rfc-editor.org/info/rfc5077&lt;/a&gt;&amp;gt;.






&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 116]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   [&lt;a name=&quot;ref-RFC5246&quot; id=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt;]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt;,
              DOI 10.17487/RFC5246, August 2008,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc5246&quot;&gt;https://www.rfc-editor.org/info/rfc5246&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC5764&quot; id=&quot;ref-RFC5764&quot;&gt;RFC5764&lt;/a&gt;]  McGrew, D. and E. Rescorla, &quot;Datagram Transport Layer
              Security (DTLS) Extension to Establish Keys for the Secure
              Real-time Transport Protocol (SRTP)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5764&quot;&gt;RFC 5764&lt;/a&gt;,
              DOI 10.17487/RFC5764, May 2010,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc5764&quot;&gt;https://www.rfc-editor.org/info/rfc5764&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC5929&quot; id=&quot;ref-RFC5929&quot;&gt;RFC5929&lt;/a&gt;]  Altman, J., Williams, N., and L. Zhu, &quot;Channel Bindings
              for TLS&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5929&quot;&gt;RFC 5929&lt;/a&gt;, DOI 10.17487/RFC5929, July 2010,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc5929&quot;&gt;https://www.rfc-editor.org/info/rfc5929&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC6091&quot; id=&quot;ref-RFC6091&quot;&gt;RFC6091&lt;/a&gt;]  Mavrogiannopoulos, N. and D. Gillmor, &quot;Using OpenPGP Keys
              for Transport Layer Security (TLS) Authentication&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc6091&quot;&gt;RFC 6091&lt;/a&gt;, DOI 10.17487/RFC6091, February 2011,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc6091&quot;&gt;https://www.rfc-editor.org/info/rfc6091&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC6101&quot; id=&quot;ref-RFC6101&quot;&gt;RFC6101&lt;/a&gt;]  Freier, A., Karlton, P., and P. Kocher, &quot;The Secure
              Sockets Layer (SSL) Protocol Version 3.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6101&quot;&gt;RFC 6101&lt;/a&gt;,
              DOI 10.17487/RFC6101, August 2011,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc6101&quot;&gt;https://www.rfc-editor.org/info/rfc6101&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC6176&quot; id=&quot;ref-RFC6176&quot;&gt;RFC6176&lt;/a&gt;]  Turner, S. and T. Polk, &quot;Prohibiting Secure Sockets Layer
              (SSL) Version 2.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6176&quot;&gt;RFC 6176&lt;/a&gt;, DOI 10.17487/RFC6176,
              March 2011, &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc6176&quot;&gt;https://www.rfc-editor.org/info/rfc6176&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC6347&quot; id=&quot;ref-RFC6347&quot;&gt;RFC6347&lt;/a&gt;]  Rescorla, E. and N. Modadugu, &quot;Datagram Transport Layer
              Security Version 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6347&quot;&gt;RFC 6347&lt;/a&gt;, DOI 10.17487/RFC6347,
              January 2012, &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc6347&quot;&gt;https://www.rfc-editor.org/info/rfc6347&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC6520&quot; id=&quot;ref-RFC6520&quot;&gt;RFC6520&lt;/a&gt;]  Seggelmann, R., Tuexen, M., and M. Williams, &quot;Transport
              Layer Security (TLS) and Datagram Transport Layer Security
              (DTLS) Heartbeat Extension&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6520&quot;&gt;RFC 6520&lt;/a&gt;,
              DOI 10.17487/RFC6520, February 2012,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc6520&quot;&gt;https://www.rfc-editor.org/info/rfc6520&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC7230&quot; id=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, DOI 10.17487/RFC7230, June 2014,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc7230&quot;&gt;https://www.rfc-editor.org/info/rfc7230&lt;/a&gt;&amp;gt;.








&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 117]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   [&lt;a name=&quot;ref-RFC7250&quot; id=&quot;ref-RFC7250&quot;&gt;RFC7250&lt;/a&gt;]  Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J.,
              Weiler, S., and T. Kivinen, &quot;Using Raw Public Keys in
              Transport Layer Security (TLS) and Datagram Transport
              Layer Security (DTLS)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7250&quot;&gt;RFC 7250&lt;/a&gt;, DOI 10.17487/RFC7250,
              June 2014, &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc7250&quot;&gt;https://www.rfc-editor.org/info/rfc7250&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC7465&quot; id=&quot;ref-RFC7465&quot;&gt;RFC7465&lt;/a&gt;]  Popov, A., &quot;Prohibiting RC4 Cipher Suites&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7465&quot;&gt;RFC 7465&lt;/a&gt;,
              DOI 10.17487/RFC7465, February 2015,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc7465&quot;&gt;https://www.rfc-editor.org/info/rfc7465&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC7568&quot; id=&quot;ref-RFC7568&quot;&gt;RFC7568&lt;/a&gt;]  Barnes, R., Thomson, M., Pironti, A., and A. Langley,
              &quot;Deprecating Secure Sockets Layer Version 3.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7568&quot;&gt;RFC 7568&lt;/a&gt;,
              DOI 10.17487/RFC7568, June 2015,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc7568&quot;&gt;https://www.rfc-editor.org/info/rfc7568&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC7627&quot; id=&quot;ref-RFC7627&quot;&gt;RFC7627&lt;/a&gt;]  Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A.,
              Langley, A., and M. Ray, &quot;Transport Layer Security (TLS)
              Session Hash and Extended Master Secret Extension&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7627&quot;&gt;RFC 7627&lt;/a&gt;, DOI 10.17487/RFC7627, September 2015,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc7627&quot;&gt;https://www.rfc-editor.org/info/rfc7627&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC7685&quot; id=&quot;ref-RFC7685&quot;&gt;RFC7685&lt;/a&gt;]  Langley, A., &quot;A Transport Layer Security (TLS) ClientHello
              Padding Extension&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7685&quot;&gt;RFC 7685&lt;/a&gt;, DOI 10.17487/RFC7685,
              October 2015, &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc7685&quot;&gt;https://www.rfc-editor.org/info/rfc7685&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC7924&quot; id=&quot;ref-RFC7924&quot;&gt;RFC7924&lt;/a&gt;]  Santesson, S. and H. Tschofenig, &quot;Transport Layer Security
              (TLS) Cached Information Extension&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7924&quot;&gt;RFC 7924&lt;/a&gt;,
              DOI 10.17487/RFC7924, July 2016,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc7924&quot;&gt;https://www.rfc-editor.org/info/rfc7924&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC8305&quot; id=&quot;ref-RFC8305&quot;&gt;RFC8305&lt;/a&gt;]  Schinazi, D. and T. Pauly, &quot;Happy Eyeballs Version 2:
              Better Connectivity Using Concurrency&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc8305&quot;&gt;RFC 8305&lt;/a&gt;,
              DOI 10.17487/RFC8305, December 2017,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc8305&quot;&gt;https://www.rfc-editor.org/info/rfc8305&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC8422&quot; id=&quot;ref-RFC8422&quot;&gt;RFC8422&lt;/a&gt;]  Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, &quot;Elliptic
              Curve Cryptography (ECC) Cipher Suites for Transport Layer
              Security (TLS) Versions 1.2 and Earlier&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc8422&quot;&gt;RFC 8422&lt;/a&gt;,
              DOI 10.17487/RFC8422, August 2018,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc8422&quot;&gt;https://www.rfc-editor.org/info/rfc8422&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC8447&quot; id=&quot;ref-RFC8447&quot;&gt;RFC8447&lt;/a&gt;]  Salowey, J. and S. Turner, &quot;IANA Registry Updates for TLS
              and DTLS&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc8447&quot;&gt;RFC 8447&lt;/a&gt;, DOI 10.17487/RFC8447, August 2018,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc8447&quot;&gt;https://www.rfc-editor.org/info/rfc8447&lt;/a&gt;&amp;gt;.

   [&lt;a name=&quot;ref-RFC8449&quot; id=&quot;ref-RFC8449&quot;&gt;RFC8449&lt;/a&gt;]  Thomson, M., &quot;Record Size Limit Extension for TLS&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc8449&quot;&gt;RFC 8449&lt;/a&gt;, DOI 10.17487/RFC8449, August 2018,
              &amp;lt;&lt;a href=&quot;https://www.rfc-editor.org/info/rfc8449&quot;&gt;https://www.rfc-editor.org/info/rfc8449&lt;/a&gt;&amp;gt;.



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 118]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   [&lt;a name=&quot;ref-RSA&quot; id=&quot;ref-RSA&quot;&gt;RSA&lt;/a&gt;]      Rivest, R., Shamir, A., and L. Adleman, &quot;A Method for
              Obtaining Digital Signatures and Public-Key
              Cryptosystems&quot;, Communications of the ACM, Vol. 21 No. 2,
              pp. 120-126, DOI 10.1145/359340.359342, February 1978.

   [&lt;a name=&quot;ref-SIGMA&quot; id=&quot;ref-SIGMA&quot;&gt;SIGMA&lt;/a&gt;]    Krawczyk, H., &quot;SIGMA: The 'SIGn-and-MAc' Approach to
              Authenticated Diffie-Hellman and its Use in the IKE
              Protocols&quot;, Proceedings of CRYPTO 2003,
              DOI 10.1007/978-3-540-45146-4_24, August 2003.

   [&lt;a name=&quot;ref-SLOTH&quot; id=&quot;ref-SLOTH&quot;&gt;SLOTH&lt;/a&gt;]    Bhargavan, K. and G. Leurent, &quot;Transcript Collision
              Attacks: Breaking Authentication in TLS, IKE, and SSH&quot;,
              Network and Distributed System Security
              Symposium (NDSS 2016), DOI 10.14722/ndss.2016.23418,
              February 2016.

   [&lt;a name=&quot;ref-SSL2&quot; id=&quot;ref-SSL2&quot;&gt;SSL2&lt;/a&gt;]     Hickman, K., &quot;The SSL Protocol&quot;, February 1995.

   [&lt;a name=&quot;ref-TIMING&quot; id=&quot;ref-TIMING&quot;&gt;TIMING&lt;/a&gt;]   Boneh, D. and D. Brumley, &quot;Remote Timing Attacks Are
              Practical&quot;, USENIX Security Symposium, August 2003.

   [&lt;a name=&quot;ref-TLS13-TRACES&quot; id=&quot;ref-TLS13-TRACES&quot;&gt;TLS13-TRACES&lt;/a&gt;]
              Thomson, M., &lt;a href=&quot;https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;amp;q=inurl:draft-+%22Example+Handshake+Traces+for+TLS+1.3%22&quot;&gt;&quot;Example Handshake Traces for TLS 1.3&quot;&lt;/a&gt;, Work
              in Progress, &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-tls-tls13-vectors-06&quot;&gt;draft-ietf-tls-tls13-vectors-06&lt;/a&gt;, July 2018.

   [&lt;a name=&quot;ref-X501&quot; id=&quot;ref-X501&quot;&gt;X501&lt;/a&gt;]     ITU-T, &quot;Information Technology - Open Systems
              Interconnection - The Directory: Models&quot;, ITU-T X.501,
              October 2016, &amp;lt;&lt;a href=&quot;https://www.itu.int/rec/T-REC-X.501/en&quot;&gt;https://www.itu.int/rec/T-REC-X.501/en&lt;/a&gt;&amp;gt;.























&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 119]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-A&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-A&quot; id=&quot;appendix-A&quot;&gt;Appendix A&lt;/a&gt;.  State Machine&lt;/span&gt;

   This appendix provides a summary of the legal state transitions for
   the client and server handshakes.  State names (in all capitals,
   e.g., START) have no formal meaning but are provided for ease of
   comprehension.  Actions which are taken only in certain circumstances
   are indicated in [].  The notation &quot;K_{send,recv} = foo&quot; means &quot;set
   the send/recv key to the given key&quot;.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-A.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-A.1&quot; id=&quot;appendix-A.1&quot;&gt;A.1&lt;/a&gt;.  Client&lt;/span&gt;

                              START &amp;lt;----+
               Send ClientHello |        | Recv HelloRetryRequest
          [K_send = early data] |        |
                                v        |
           /                 WAIT_SH ----+
           |                    | Recv ServerHello
           |                    | K_recv = handshake
       Can |                    V
      send |                 WAIT_EE
     early |                    | Recv EncryptedExtensions
      data |           +--------+--------+
           |     Using |                 | Using certificate
           |       PSK |                 v
           |           |            WAIT_CERT_CR
           |           |        Recv |       | Recv CertificateRequest
           |           | Certificate |       v
           |           |             |    WAIT_CERT
           |           |             |       | Recv Certificate
           |           |             v       v
           |           |              WAIT_CV
           |           |                 | Recv CertificateVerify
           |           +&amp;gt; WAIT_FINISHED &amp;lt;+
           |                  | Recv Finished
           \                  | [Send EndOfEarlyData]
                              | K_send = handshake
                              | [Send Certificate [+ CertificateVerify]]
    Can send                  | Send Finished
    app data   --&amp;gt;            | K_send = K_recv = application
    after here                v
                          CONNECTED

   Note that with the transitions as shown above, clients may send
   alerts that derive from post-ServerHello messages in the clear or
   with the early data keys.  If clients need to send such alerts, they
   SHOULD first rekey to the handshake keys if possible.





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 120]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-A.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-A.2&quot; id=&quot;appendix-A.2&quot;&gt;A.2&lt;/a&gt;.  Server&lt;/span&gt;

                              START &amp;lt;-----+
               Recv ClientHello |         | Send HelloRetryRequest
                                v         |
                             RECVD_CH ----+
                                | Select parameters
                                v
                             NEGOTIATED
                                | Send ServerHello
                                | K_send = handshake
                                | Send EncryptedExtensions
                                | [Send CertificateRequest]
 Can send                       | [Send Certificate + CertificateVerify]
 app data                       | Send Finished
 after   --&amp;gt;                    | K_send = application
 here                  +--------+--------+
              No 0-RTT |                 | 0-RTT
                       |                 |
   K_recv = handshake  |                 | K_recv = early data
 [Skip decrypt errors] |    +------&amp;gt; WAIT_EOED -+
                       |    |       Recv |      | Recv EndOfEarlyData
                       |    | early data |      | K_recv = handshake
                       |    +------------+      |
                       |                        |
                       +&amp;gt; WAIT_FLIGHT2 &amp;lt;--------+
                                |
                       +--------+--------+
               No auth |                 | Client auth
                       |                 |
                       |                 v
                       |             WAIT_CERT
                       |        Recv |       | Recv Certificate
                       |       empty |       v
                       | Certificate |    WAIT_CV
                       |             |       | Recv
                       |             v       | CertificateVerify
                       +-&amp;gt; WAIT_FINISHED &amp;lt;---+
                                | Recv Finished
                                | K_recv = application
                                v
                            CONNECTED









&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 121]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-B&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B&quot; id=&quot;appendix-B&quot;&gt;Appendix B&lt;/a&gt;.  Protocol Data Structures and Constant Values&lt;/span&gt;

   This appendix provides the normative protocol types and the
   definitions for constants.  Values listed as &quot;_RESERVED&quot; were used in
   previous versions of TLS and are listed here for completeness.
   TLS 1.3 implementations MUST NOT send them but might receive them
   from older TLS implementations.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-B.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.1&quot; id=&quot;appendix-B.1&quot;&gt;B.1&lt;/a&gt;.  Record Layer&lt;/span&gt;

      enum {
          invalid(0),
          change_cipher_spec(20),
          alert(21),
          handshake(22),
          application_data(23),
          heartbeat(24),  /* &lt;a href=&quot;https://tools.ietf.org/html/rfc6520&quot;&gt;RFC 6520&lt;/a&gt; */
          (255)
      } ContentType;

      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;

      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;

      struct {
          ContentType opaque_type = application_data; /* 23 */
          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];
      } TLSCiphertext;












&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 122]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-B.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.2&quot; id=&quot;appendix-B.2&quot;&gt;B.2&lt;/a&gt;.  Alert Messages&lt;/span&gt;

      enum { warning(1), fatal(2), (255) } AlertLevel;

      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          decryption_failed_RESERVED(21),
          record_overflow(22),
          decompression_failure_RESERVED(30),
          handshake_failure(40),
          no_certificate_RESERVED(41),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          export_restriction_RESERVED(60),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          inappropriate_fallback(86),
          user_canceled(90),
          no_renegotiation_RESERVED(100),
          missing_extension(109),
          unsupported_extension(110),
          certificate_unobtainable_RESERVED(111),
          unrecognized_name(112),
          bad_certificate_status_response(113),
          bad_certificate_hash_value_RESERVED(114),
          unknown_psk_identity(115),
          certificate_required(116),
          no_application_protocol(120),
          (255)
      } AlertDescription;

      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 123]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-B.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3&quot; id=&quot;appendix-B.3&quot;&gt;B.3&lt;/a&gt;.  Handshake Protocol&lt;/span&gt;

      enum {
          hello_request_RESERVED(0),
          client_hello(1),
          server_hello(2),
          hello_verify_request_RESERVED(3),
          new_session_ticket(4),
          end_of_early_data(5),
          hello_retry_request_RESERVED(6),
          encrypted_extensions(8),
          certificate(11),
          server_key_exchange_RESERVED(12),
          certificate_request(13),
          server_hello_done_RESERVED(14),
          certificate_verify(15),
          client_key_exchange_RESERVED(16),
          finished(20),
          certificate_url_RESERVED(21),
          certificate_status_RESERVED(22),
          supplemental_data_RESERVED(23),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;

      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;









&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 124]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-B.3.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.1&quot; id=&quot;appendix-B.3.1&quot;&gt;B.3.1&lt;/a&gt;.  Key Exchange Messages&lt;/span&gt;

    uint16 ProtocolVersion;
    opaque Random[32];

    uint8 CipherSuite[2];    /* Cryptographic suite selector */

    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
        Random random;
        opaque legacy_session_id&amp;lt;0..32&amp;gt;;
        CipherSuite cipher_suites&amp;lt;2..2^16-2&amp;gt;;
        opaque legacy_compression_methods&amp;lt;1..2^8-1&amp;gt;;
        Extension extensions&amp;lt;8..2^16-1&amp;gt;;
    } ClientHello;

    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
        Random random;
        opaque legacy_session_id_echo&amp;lt;0..32&amp;gt;;
        CipherSuite cipher_suite;
        uint8 legacy_compression_method = 0;
        Extension extensions&amp;lt;6..2^16-1&amp;gt;;
    } ServerHello;



























&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 125]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


    struct {
        ExtensionType extension_type;
        opaque extension_data&amp;lt;0..2^16-1&amp;gt;;
    } Extension;

    enum {
        server_name(0),                             /* &lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot;&gt;RFC 6066&lt;/a&gt; */
        max_fragment_length(1),                     /* &lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot;&gt;RFC 6066&lt;/a&gt; */
        status_request(5),                          /* &lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot;&gt;RFC 6066&lt;/a&gt; */
        supported_groups(10),                       /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8422&quot;&gt;RFC 8422&lt;/a&gt;, 7919 */
        signature_algorithms(13),                   /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        use_srtp(14),                               /* &lt;a href=&quot;https://tools.ietf.org/html/rfc5764&quot;&gt;RFC 5764&lt;/a&gt; */
        heartbeat(15),                              /* &lt;a href=&quot;https://tools.ietf.org/html/rfc6520&quot;&gt;RFC 6520&lt;/a&gt; */
        application_layer_protocol_negotiation(16), /* &lt;a href=&quot;https://tools.ietf.org/html/rfc7301&quot;&gt;RFC 7301&lt;/a&gt; */
        signed_certificate_timestamp(18),           /* &lt;a href=&quot;https://tools.ietf.org/html/rfc6962&quot;&gt;RFC 6962&lt;/a&gt; */
        client_certificate_type(19),                /* &lt;a href=&quot;https://tools.ietf.org/html/rfc7250&quot;&gt;RFC 7250&lt;/a&gt; */
        server_certificate_type(20),                /* &lt;a href=&quot;https://tools.ietf.org/html/rfc7250&quot;&gt;RFC 7250&lt;/a&gt; */
        padding(21),                                /* &lt;a href=&quot;https://tools.ietf.org/html/rfc7685&quot;&gt;RFC 7685&lt;/a&gt; */
        RESERVED(40),                               /* Used but never
                                                       assigned */
        pre_shared_key(41),                         /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        early_data(42),                             /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        supported_versions(43),                     /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        cookie(44),                                 /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        psk_key_exchange_modes(45),                 /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        RESERVED(46),                               /* Used but never
                                                       assigned */
        certificate_authorities(47),                /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        oid_filters(48),                            /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        post_handshake_auth(49),                    /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        signature_algorithms_cert(50),              /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        key_share(51),                              /* &lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt; */
        (65535)
    } ExtensionType;

    struct {
        NamedGroup group;
        opaque key_exchange&amp;lt;1..2^16-1&amp;gt;;
    } KeyShareEntry;

    struct {
        KeyShareEntry client_shares&amp;lt;0..2^16-1&amp;gt;;
    } KeyShareClientHello;

    struct {
        NamedGroup selected_group;
    } KeyShareHelloRetryRequest;




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 126]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


    struct {
        KeyShareEntry server_share;
    } KeyShareServerHello;

    struct {
        uint8 legacy_form = 4;
        opaque X[coordinate_length];
        opaque Y[coordinate_length];
    } UncompressedPointRepresentation;

    enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;

    struct {
        PskKeyExchangeMode ke_modes&amp;lt;1..255&amp;gt;;
    } PskKeyExchangeModes;

    struct {} Empty;

    struct {
        select (Handshake.msg_type) {
            case new_session_ticket:   uint32 max_early_data_size;
            case client_hello:         Empty;
            case encrypted_extensions: Empty;
        };
    } EarlyDataIndication;

    struct {
        opaque identity&amp;lt;1..2^16-1&amp;gt;;
        uint32 obfuscated_ticket_age;
    } PskIdentity;

    opaque PskBinderEntry&amp;lt;32..255&amp;gt;;

    struct {
        PskIdentity identities&amp;lt;7..2^16-1&amp;gt;;
        PskBinderEntry binders&amp;lt;33..2^16-1&amp;gt;;
    } OfferedPsks;

    struct {
        select (Handshake.msg_type) {
            case client_hello: OfferedPsks;
            case server_hello: uint16 selected_identity;
        };
    } PreSharedKeyExtension;







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 127]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h5&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-B.3.1.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.1.1&quot; id=&quot;appendix-B.3.1.1&quot;&gt;B.3.1.1&lt;/a&gt;.  Version Extension&lt;/span&gt;

      struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions&amp;lt;2..254&amp;gt;;

              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;

&lt;span class=&quot;h5&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-B.3.1.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.1.2&quot; id=&quot;appendix-B.3.1.2&quot;&gt;B.3.1.2&lt;/a&gt;.  Cookie Extension&lt;/span&gt;

      struct {
          opaque cookie&amp;lt;1..2^16-1&amp;gt;;
      } Cookie;


































&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 128]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h5&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-B.3.1.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.1.3&quot; id=&quot;appendix-B.3.1.3&quot;&gt;B.3.1.3&lt;/a&gt;.  Signature Algorithm Extension&lt;/span&gt;

      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),

          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),

          /* RSASSA-PSS algorithms with public key OID rsaEncryption */
          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),

          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),

          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),

          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),

          /* Reserved Code Points */
          obsolete_RESERVED(0x0000..0x0200),
          dsa_sha1_RESERVED(0x0202),
          obsolete_RESERVED(0x0204..0x0400),
          dsa_sha256_RESERVED(0x0402),
          obsolete_RESERVED(0x0404..0x0500),
          dsa_sha384_RESERVED(0x0502),
          obsolete_RESERVED(0x0504..0x0600),
          dsa_sha512_RESERVED(0x0602),
          obsolete_RESERVED(0x0604..0x06FF),
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;

      struct {
          SignatureScheme supported_signature_algorithms&amp;lt;2..2^16-2&amp;gt;;
      } SignatureSchemeList;



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 129]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h5&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-B.3.1.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.1.4&quot; id=&quot;appendix-B.3.1.4&quot;&gt;B.3.1.4&lt;/a&gt;.  Supported Groups Extension&lt;/span&gt;

      enum {
          unallocated_RESERVED(0x0000),

          /* Elliptic Curve Groups (ECDHE) */
          obsolete_RESERVED(0x0001..0x0016),
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
          obsolete_RESERVED(0x001A..0x001C),
          x25519(0x001D), x448(0x001E),

          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
          ffdhe6144(0x0103), ffdhe8192(0x0104),

          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          obsolete_RESERVED(0xFF01..0xFF02),
          (0xFFFF)
      } NamedGroup;

      struct {
          NamedGroup named_group_list&amp;lt;2..2^16-1&amp;gt;;
      } NamedGroupList;

   Values within &quot;obsolete_RESERVED&quot; ranges are used in previous
   versions of TLS and MUST NOT be offered or negotiated by TLS 1.3
   implementations.  The obsolete curves have various known/theoretical
   weaknesses or have had very little usage, in some cases only due to
   unintentional server configuration issues.  They are no longer
   considered appropriate for general use and should be assumed to be
   potentially unsafe.  The set of curves specified here is sufficient
   for interoperability with all currently deployed and properly
   configured TLS implementations.
















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 130]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-B.3.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.2&quot; id=&quot;appendix-B.3.2&quot;&gt;B.3.2&lt;/a&gt;.  Server Parameters Messages&lt;/span&gt;

      opaque DistinguishedName&amp;lt;1..2^16-1&amp;gt;;

      struct {
          DistinguishedName authorities&amp;lt;3..2^16-1&amp;gt;;
      } CertificateAuthoritiesExtension;

      struct {
          opaque certificate_extension_oid&amp;lt;1..2^8-1&amp;gt;;
          opaque certificate_extension_values&amp;lt;0..2^16-1&amp;gt;;
      } OIDFilter;

      struct {
          OIDFilter filters&amp;lt;0..2^16-1&amp;gt;;
      } OIDFilterExtension;

      struct {} PostHandshakeAuth;

      struct {
          Extension extensions&amp;lt;0..2^16-1&amp;gt;;
      } EncryptedExtensions;

      struct {
          opaque certificate_request_context&amp;lt;0..2^8-1&amp;gt;;
          Extension extensions&amp;lt;2..2^16-1&amp;gt;;
      } CertificateRequest;
























&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 131]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-B.3.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.3&quot; id=&quot;appendix-B.3.3&quot;&gt;B.3.3&lt;/a&gt;.  Authentication Messages&lt;/span&gt;

      enum {
          X509(0),
          OpenPGP_RESERVED(1),
          RawPublicKey(2),
          (255)
      } CertificateType;

      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From &lt;a href=&quot;https://tools.ietf.org/html/rfc7250&quot;&gt;RFC 7250&lt;/a&gt; ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo&amp;lt;1..2^24-1&amp;gt;;

              case X509:
                opaque cert_data&amp;lt;1..2^24-1&amp;gt;;
          };
          Extension extensions&amp;lt;0..2^16-1&amp;gt;;
      } CertificateEntry;

      struct {
          opaque certificate_request_context&amp;lt;0..2^8-1&amp;gt;;
          CertificateEntry certificate_list&amp;lt;0..2^24-1&amp;gt;;
      } Certificate;

      struct {
          SignatureScheme algorithm;
          opaque signature&amp;lt;0..2^16-1&amp;gt;;
      } CertificateVerify;

      struct {
          opaque verify_data[Hash.length];
      } Finished;

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-B.3.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.4&quot; id=&quot;appendix-B.3.4&quot;&gt;B.3.4&lt;/a&gt;.  Ticket Establishment&lt;/span&gt;

      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce&amp;lt;0..255&amp;gt;;
          opaque ticket&amp;lt;1..2^16-1&amp;gt;;
          Extension extensions&amp;lt;0..2^16-2&amp;gt;;
      } NewSessionTicket;







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 132]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-B.3.5&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.3.5&quot; id=&quot;appendix-B.3.5&quot;&gt;B.3.5&lt;/a&gt;.  Updating Keys&lt;/span&gt;

      struct {} EndOfEarlyData;

      enum {
          update_not_requested(0), update_requested(1), (255)
      } KeyUpdateRequest;

      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-B.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-B.4&quot; id=&quot;appendix-B.4&quot;&gt;B.4&lt;/a&gt;.  Cipher Suites&lt;/span&gt;

   A symmetric cipher suite defines the pair of the AEAD algorithm and
   hash algorithm to be used with HKDF.  Cipher suite names follow the
   naming convention:

      CipherSuite TLS_AEAD_HASH = VALUE;

      +-----------+------------------------------------------------+
      | Component | Contents                                       |
      +-----------+------------------------------------------------+
      | TLS       | The string &quot;TLS&quot;                               |
      |           |                                                |
      | AEAD      | The AEAD algorithm used for record protection  |
      |           |                                                |
      | HASH      | The hash algorithm used with HKDF              |
      |           |                                                |
      | VALUE     | The two-byte ID assigned for this cipher suite |
      +-----------+------------------------------------------------+

   This specification defines the following cipher suites for use with
   TLS 1.3.

              +------------------------------+-------------+
              | Description                  | Value       |
              +------------------------------+-------------+
              | TLS_AES_128_GCM_SHA256       | {0x13,0x01} |
              |                              |             |
              | TLS_AES_256_GCM_SHA384       | {0x13,0x02} |
              |                              |             |
              | TLS_CHACHA20_POLY1305_SHA256 | {0x13,0x03} |
              |                              |             |
              | TLS_AES_128_CCM_SHA256       | {0x13,0x04} |
              |                              |             |
              | TLS_AES_128_CCM_8_SHA256     | {0x13,0x05} |
              +------------------------------+-------------+



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 133]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   The corresponding AEAD algorithms AEAD_AES_128_GCM, AEAD_AES_256_GCM,
   and AEAD_AES_128_CCM are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5116&quot; title=&quot;&amp;quot;An Interface and Algorithms for Authenticated Encryption&amp;quot;&quot;&gt;RFC5116&lt;/a&gt;].
   AEAD_CHACHA20_POLY1305 is defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc8439&quot; title=&quot;&amp;quot;ChaCha20 and Poly1305 for IETF Protocols&amp;quot;&quot;&gt;RFC8439&lt;/a&gt;].  AEAD_AES_128_CCM_8
   is defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc6655&quot; title=&quot;&amp;quot;AES-CCM Cipher Suites for Transport Layer Security (TLS)&amp;quot;&quot;&gt;RFC6655&lt;/a&gt;].  The corresponding hash algorithms are
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-SHS&quot; title=&quot;&amp;quot;Secure Hash Standard (SHS)&amp;quot;&quot;&gt;SHS&lt;/a&gt;].

   Although TLS 1.3 uses the same cipher suite space as previous
   versions of TLS, TLS 1.3 cipher suites are defined differently, only
   specifying the symmetric ciphers, and cannot be used for TLS 1.2.
   Similarly, cipher suites for TLS 1.2 and lower cannot be used with
   TLS 1.3.

   New cipher suite values are assigned by IANA as described in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-11&quot;&gt;Section 11&lt;/a&gt;.

&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-C&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C&quot; id=&quot;appendix-C&quot;&gt;Appendix C&lt;/a&gt;.  Implementation Notes&lt;/span&gt;

   The TLS protocol cannot prevent many common security mistakes.  This
   appendix provides several recommendations to assist implementors.
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-TLS13-TRACES&quot; title=&quot;&amp;quot;Example Handshake Traces for TLS 1.3&amp;quot;&quot;&gt;TLS13-TRACES&lt;/a&gt;] provides test vectors for TLS 1.3 handshakes.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-C.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C.1&quot; id=&quot;appendix-C.1&quot;&gt;C.1&lt;/a&gt;.  Random Number Generation and Seeding&lt;/span&gt;

   TLS requires a cryptographically secure pseudorandom number generator
   (CSPRNG).  In most cases, the operating system provides an
   appropriate facility such as /dev/urandom, which should be used
   absent other (e.g., performance) concerns.  It is RECOMMENDED to use
   an existing CSPRNG implementation in preference to crafting a new
   one.  Many adequate cryptographic libraries are already available
   under favorable license terms.  Should those prove unsatisfactory,
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc4086&quot; title=&quot;&amp;quot;Randomness Requirements for Security&amp;quot;&quot;&gt;RFC4086&lt;/a&gt;] provides guidance on the generation of random values.

   TLS uses random values (1) in public protocol fields such as the
   public Random values in the ClientHello and ServerHello and (2) to
   generate keying material.  With a properly functioning CSPRNG, this
   does not present a security problem, as it is not feasible to
   determine the CSPRNG state from its output.  However, with a broken
   CSPRNG, it may be possible for an attacker to use the public output
   to determine the CSPRNG internal state and thereby predict the keying
   material, as documented in [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-CHECKOWAY&quot; title=&quot;&amp;quot;A Systematic Analysis of the Juniper Dual EC Incident&amp;quot;&quot;&gt;CHECKOWAY&lt;/a&gt;].  Implementations can provide
   extra security against this form of attack by using separate CSPRNGs
   to generate public and private values.









&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 134]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-C.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C.2&quot; id=&quot;appendix-C.2&quot;&gt;C.2&lt;/a&gt;.  Certificates and Authentication&lt;/span&gt;

   Implementations are responsible for verifying the integrity of
   certificates and should generally support certificate revocation
   messages.  Absent a specific indication from an application profile,
   certificates should always be verified to ensure proper signing by a
   trusted certificate authority (CA).  The selection and addition of
   trust anchors should be done very carefully.  Users should be able to
   view information about the certificate and trust anchor.
   Applications SHOULD also enforce minimum and maximum key sizes.  For
   example, certification paths containing keys or signatures weaker
   than 2048-bit RSA or 224-bit ECDSA are not appropriate for secure
   applications.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-C.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C.3&quot; id=&quot;appendix-C.3&quot;&gt;C.3&lt;/a&gt;.  Implementation Pitfalls&lt;/span&gt;

   Implementation experience has shown that certain parts of earlier TLS
   specifications are not easy to understand and have been a source of
   interoperability and security problems.  Many of these areas have
   been clarified in this document, but this appendix contains a short
   list of the most important things that require special attention from
   implementors.

   TLS protocol issues:

   -  Do you correctly handle handshake messages that are fragmented to
      multiple TLS records (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;)?  Do you correctly handle
      corner cases like a ClientHello that is split into several small
      fragments?  Do you fragment handshake messages that exceed the
      maximum fragment size?  In particular, the Certificate and
      CertificateRequest handshake messages can be large enough to
      require fragmentation.

   -  Do you ignore the TLS record layer version number in all
      unencrypted TLS records (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D&quot;&gt;Appendix D&lt;/a&gt;)?

   -  Have you ensured that all support for SSL, RC4, EXPORT ciphers,
      and MD5 (via the &quot;signature_algorithms&quot; extension) is completely
      removed from all possible configurations that support TLS 1.3 or
      later, and that attempts to use these obsolete capabilities fail
      correctly (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D&quot;&gt;Appendix D&lt;/a&gt;)?

   -  Do you handle TLS extensions in ClientHellos correctly, including
      unknown extensions?







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 135]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   -  When the server has requested a client certificate but no suitable
      certificate is available, do you correctly send an empty
      Certificate message, instead of omitting the whole message (see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.2&quot;&gt;Section 4.4.2&lt;/a&gt;)?

   -  When processing the plaintext fragment produced by AEAD-Decrypt
      and scanning from the end for the ContentType, do you avoid
      scanning past the start of the cleartext in the event that the
      peer has sent a malformed plaintext of all zeros?

   -  Do you properly ignore unrecognized cipher suites (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt;),
      hello extensions (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;), named groups (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.7&quot;&gt;Section 4.2.7&lt;/a&gt;), key
      shares (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.8&quot;&gt;Section 4.2.8&lt;/a&gt;), supported versions (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;), and
      signature algorithms (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;) in the ClientHello?

   -  As a server, do you send a HelloRetryRequest to clients which
      support a compatible (EC)DHE group but do not predict it in the
      &quot;key_share&quot; extension?  As a client, do you correctly handle a
      HelloRetryRequest from the server?

   Cryptographic details:

   -  What countermeasures do you use to prevent timing attacks
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-TIMING&quot; title=&quot;&amp;quot;Remote Timing Attacks Are Practical&amp;quot;&quot;&gt;TIMING&lt;/a&gt;]?

   -  When using Diffie-Hellman key exchange, do you correctly preserve
      leading zero bytes in the negotiated key (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;)?

   -  Does your TLS client check that the Diffie-Hellman parameters sent
      by the server are acceptable (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.8.1&quot;&gt;Section 4.2.8.1&lt;/a&gt;)?

   -  Do you use a strong and, most importantly, properly seeded random
      number generator (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C.1&quot;&gt;Appendix C.1&lt;/a&gt;) when generating Diffie-Hellman
      private values, the ECDSA &quot;k&quot; parameter, and other security-
      critical values?  It is RECOMMENDED that implementations implement
      &quot;deterministic ECDSA&quot; as specified in [&lt;a href=&quot;https://tools.ietf.org/html/rfc6979&quot; title=&quot;&amp;quot;Deterministic Usage of the Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA)&amp;quot;&quot;&gt;RFC6979&lt;/a&gt;].

   -  Do you zero-pad Diffie-Hellman public key values and shared
      secrets to the group size (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.8.1&quot;&gt;Section 4.2.8.1&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;)?

   -  Do you verify signatures after making them, to protect against
      RSA-CRT key leaks [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-FW15&quot; title=&quot;&amp;quot;Factoring RSA Keys With TLS Perfect Forward Secrecy&amp;quot;&quot;&gt;FW15&lt;/a&gt;]?









&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 136]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-C.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C.4&quot; id=&quot;appendix-C.4&quot;&gt;C.4&lt;/a&gt;.  Client Tracking Prevention&lt;/span&gt;

   Clients SHOULD NOT reuse a ticket for multiple connections.  Reuse of
   a ticket allows passive observers to correlate different connections.
   Servers that issue tickets SHOULD offer at least as many tickets as
   the number of connections that a client might use; for example, a web
   browser using HTTP/1.1 [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot; title=&quot;&amp;quot;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&amp;quot;&quot;&gt;RFC7230&lt;/a&gt;] might open six connections to a
   server.  Servers SHOULD issue new tickets with every connection.
   This ensures that clients are always able to use a new ticket when
   creating a new connection.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-C.5&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-C.5&quot; id=&quot;appendix-C.5&quot;&gt;C.5&lt;/a&gt;.  Unauthenticated Operation&lt;/span&gt;

   Previous versions of TLS offered explicitly unauthenticated cipher
   suites based on anonymous Diffie-Hellman.  These modes have been
   deprecated in TLS 1.3.  However, it is still possible to negotiate
   parameters that do not provide verifiable server authentication by
   several methods, including:

   -  Raw public keys [&lt;a href=&quot;https://tools.ietf.org/html/rfc7250&quot; title=&quot;&amp;quot;Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)&amp;quot;&quot;&gt;RFC7250&lt;/a&gt;].

   -  Using a public key contained in a certificate but without
      validation of the certificate chain or any of its contents.

   Either technique used alone is vulnerable to man-in-the-middle
   attacks and therefore unsafe for general use.  However, it is also
   possible to bind such connections to an external authentication
   mechanism via out-of-band validation of the server's public key,
   trust on first use, or a mechanism such as channel bindings (though
   the channel bindings described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5929&quot; title=&quot;&amp;quot;Channel Bindings for TLS&amp;quot;&quot;&gt;RFC5929&lt;/a&gt;] are not defined for
   TLS 1.3).  If no such mechanism is used, then the connection has no
   protection against active man-in-the-middle attack; applications
   MUST NOT use TLS in such a way absent explicit configuration or a
   specific application profile.

















&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 137]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-D&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D&quot; id=&quot;appendix-D&quot;&gt;Appendix D&lt;/a&gt;.  Backward Compatibility&lt;/span&gt;

   The TLS protocol provides a built-in mechanism for version
   negotiation between endpoints potentially supporting different
   versions of TLS.

   TLS 1.x and SSL 3.0 use compatible ClientHello messages.  Servers can
   also handle clients trying to use future versions of TLS as long as
   the ClientHello format remains compatible and there is at least one
   protocol version supported by both the client and the server.

   Prior versions of TLS used the record layer version number
   (TLSPlaintext.legacy_record_version and
   TLSCiphertext.legacy_record_version) for various purposes.  As of
   TLS 1.3, this field is deprecated.  The value of
   TLSPlaintext.legacy_record_version MUST be ignored by all
   implementations.  The value of TLSCiphertext.legacy_record_version is
   included in the additional data for deprotection but MAY otherwise be
   ignored or MAY be validated to match the fixed constant value.
   Version negotiation is performed using only the handshake versions
   (ClientHello.legacy_version and ServerHello.legacy_version, as well
   as the ClientHello, HelloRetryRequest, and ServerHello
   &quot;supported_versions&quot; extensions).  In order to maximize
   interoperability with older endpoints, implementations that negotiate
   the use of TLS 1.0-1.2 SHOULD set the record layer version number to
   the negotiated version for the ServerHello and all records
   thereafter.

   For maximum compatibility with previously non-standard behavior and
   misconfigured deployments, all implementations SHOULD support
   validation of certification paths based on the expectations in this
   document, even when handling prior TLS versions' handshakes (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.4.2.2&quot;&gt;Section 4.4.2.2&lt;/a&gt;).

   TLS 1.2 and prior supported an &quot;Extended Master Secret&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7627&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension&amp;quot;&quot;&gt;RFC7627&lt;/a&gt;]
   extension which digested large parts of the handshake transcript into
   the master secret.  Because TLS 1.3 always hashes in the transcript
   up to the server Finished, implementations which support both TLS 1.3
   and earlier versions SHOULD indicate the use of the Extended Master
   Secret extension in their APIs whenever TLS 1.3 is used.











&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 138]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-D.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.1&quot; id=&quot;appendix-D.1&quot;&gt;D.1&lt;/a&gt;.  Negotiating with an Older Server&lt;/span&gt;

   A TLS 1.3 client who wishes to negotiate with servers that do not
   support TLS 1.3 will send a normal TLS 1.3 ClientHello containing
   0x0303 (TLS 1.2) in ClientHello.legacy_version but with the correct
   version(s) in the &quot;supported_versions&quot; extension.  If the server does
   not support TLS 1.3, it will respond with a ServerHello containing an
   older version number.  If the client agrees to use this version, the
   negotiation will proceed as appropriate for the negotiated protocol.
   A client using a ticket for resumption SHOULD initiate the connection
   using the version that was previously negotiated.

   Note that 0-RTT data is not compatible with older servers and
   SHOULD NOT be sent absent knowledge that the server supports TLS 1.3.
   See &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.3&quot;&gt;Appendix D.3&lt;/a&gt;.

   If the version chosen by the server is not supported by the client
   (or is not acceptable), the client MUST abort the handshake with a
   &quot;protocol_version&quot; alert.

   Some legacy server implementations are known to not implement the TLS
   specification properly and might abort connections upon encountering
   TLS extensions or versions which they are not aware of.
   Interoperability with buggy servers is a complex topic beyond the
   scope of this document.  Multiple connection attempts may be required
   in order to negotiate a backward-compatible connection; however, this
   practice is vulnerable to downgrade attacks and is NOT RECOMMENDED.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-D.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.2&quot; id=&quot;appendix-D.2&quot;&gt;D.2&lt;/a&gt;.  Negotiating with an Older Client&lt;/span&gt;

   A TLS server can also receive a ClientHello indicating a version
   number smaller than its highest supported version.  If the
   &quot;supported_versions&quot; extension is present, the server MUST negotiate
   using that extension as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;.  If the
   &quot;supported_versions&quot; extension is not present, the server MUST
   negotiate the minimum of ClientHello.legacy_version and TLS 1.2.  For
   example, if the server supports TLS 1.0, 1.1, and 1.2, and
   legacy_version is TLS 1.0, the server will proceed with a TLS 1.0
   ServerHello.  If the &quot;supported_versions&quot; extension is absent and the
   server only supports versions greater than
   ClientHello.legacy_version, the server MUST abort the handshake with
   a &quot;protocol_version&quot; alert.

   Note that earlier versions of TLS did not clearly specify the record
   layer version number value in all cases
   (TLSPlaintext.legacy_record_version).  Servers will receive various
   TLS 1.x versions in this field, but its value MUST always be ignored.




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 139]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-D.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.3&quot; id=&quot;appendix-D.3&quot;&gt;D.3&lt;/a&gt;.  0-RTT Backward Compatibility&lt;/span&gt;

   0-RTT data is not compatible with older servers.  An older server
   will respond to the ClientHello with an older ServerHello, but it
   will not correctly skip the 0-RTT data and will fail to complete the
   handshake.  This can cause issues when a client attempts to use
   0-RTT, particularly against multi-server deployments.  For example, a
   deployment could deploy TLS 1.3 gradually with some servers
   implementing TLS 1.3 and some implementing TLS 1.2, or a TLS 1.3
   deployment could be downgraded to TLS 1.2.

   A client that attempts to send 0-RTT data MUST fail a connection if
   it receives a ServerHello with TLS 1.2 or older.  It can then retry
   the connection with 0-RTT disabled.  To avoid a downgrade attack, the
   client SHOULD NOT disable TLS 1.3, only 0-RTT.

   To avoid this error condition, multi-server deployments SHOULD ensure
   a uniform and stable deployment of TLS 1.3 without 0-RTT prior to
   enabling 0-RTT.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-D.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.4&quot; id=&quot;appendix-D.4&quot;&gt;D.4&lt;/a&gt;.  Middlebox Compatibility Mode&lt;/span&gt;

   Field measurements [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-Ben17a&quot; title=&quot;&amp;quot;Presentation before the TLS WG at IETF 100&amp;quot;&quot;&gt;Ben17a&lt;/a&gt;] [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-Ben17b&quot; title=&quot;&amp;quot;Additional TLS 1.3 results from Chrome&amp;quot;&quot;&gt;Ben17b&lt;/a&gt;] [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-Res17a&quot; title=&quot;&amp;quot;Preliminary data on Firefox TLS 1.3 Middlebox experiment&amp;quot;&quot;&gt;Res17a&lt;/a&gt;] [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-Res17b&quot; title=&quot;&amp;quot;More compatibility measurement results&amp;quot;&quot;&gt;Res17b&lt;/a&gt;] have found
   that a significant number of middleboxes misbehave when a TLS
   client/server pair negotiates TLS 1.3.  Implementations can increase
   the chance of making connections through those middleboxes by making
   the TLS 1.3 handshake look more like a TLS 1.2 handshake:

   -  The client always provides a non-empty session ID in the
      ClientHello, as described in the legacy_session_id section of
      &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt;.

   -  If not offering early data, the client sends a dummy
      change_cipher_spec record (see the third paragraph of &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5&quot;&gt;Section 5&lt;/a&gt;)
      immediately before its second flight.  This may either be before
      its second ClientHello or before its encrypted handshake flight.
      If offering early data, the record is placed immediately after the
      first ClientHello.

   -  The server sends a dummy change_cipher_spec record immediately
      after its first handshake message.  This may either be after a
      ServerHello or a HelloRetryRequest.

   When put together, these changes make the TLS 1.3 handshake resemble
   TLS 1.2 session resumption, which improves the chance of successfully
   connecting through middleboxes.  This &quot;compatibility mode&quot; is
   partially negotiated: the client can opt to provide a session ID or
   not, and the server has to echo it.  Either side can send



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 140]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   change_cipher_spec at any time during the handshake, as they must be
   ignored by the peer, but if the client sends a non-empty session ID,
   the server MUST send the change_cipher_spec as described in this
   appendix.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-D.5&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-D.5&quot; id=&quot;appendix-D.5&quot;&gt;D.5&lt;/a&gt;.  Security Restrictions Related to Backward Compatibility&lt;/span&gt;

   Implementations negotiating the use of older versions of TLS SHOULD
   prefer forward secret and AEAD cipher suites, when available.

   The security of RC4 cipher suites is considered insufficient for the
   reasons cited in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7465&quot; title=&quot;&amp;quot;Prohibiting RC4 Cipher Suites&amp;quot;&quot;&gt;RFC7465&lt;/a&gt;].  Implementations MUST NOT offer or
   negotiate RC4 cipher suites for any version of TLS for any reason.

   Old versions of TLS permitted the use of very low strength ciphers.
   Ciphers with a strength less than 112 bits MUST NOT be offered or
   negotiated for any version of TLS for any reason.

   The security of SSL 3.0 [&lt;a href=&quot;https://tools.ietf.org/html/rfc6101&quot; title=&quot;&amp;quot;The Secure Sockets Layer (SSL) Protocol Version 3.0&amp;quot;&quot;&gt;RFC6101&lt;/a&gt;] is considered insufficient for the
   reasons enumerated in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7568&quot; title=&quot;&amp;quot;Deprecating Secure Sockets Layer Version 3.0&amp;quot;&quot;&gt;RFC7568&lt;/a&gt;], and it MUST NOT be negotiated for
   any reason.

   The security of SSL 2.0 [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-SSL2&quot; title=&quot;&amp;quot;The SSL Protocol&amp;quot;&quot;&gt;SSL2&lt;/a&gt;] is considered insufficient for the
   reasons enumerated in [&lt;a href=&quot;https://tools.ietf.org/html/rfc6176&quot; title=&quot;&amp;quot;Prohibiting Secure Sockets Layer (SSL) Version 2.0&amp;quot;&quot;&gt;RFC6176&lt;/a&gt;], and it MUST NOT be negotiated for
   any reason.

   Implementations MUST NOT send an SSL version 2.0 compatible
   CLIENT-HELLO.  Implementations MUST NOT negotiate TLS 1.3 or later
   using an SSL version 2.0 compatible CLIENT-HELLO.  Implementations
   are NOT RECOMMENDED to accept an SSL version 2.0 compatible
   CLIENT-HELLO in order to negotiate older versions of TLS.

   Implementations MUST NOT send a ClientHello.legacy_version or
   ServerHello.legacy_version set to 0x0300 or less.  Any endpoint
   receiving a Hello message with ClientHello.legacy_version or
   ServerHello.legacy_version set to 0x0300 MUST abort the handshake
   with a &quot;protocol_version&quot; alert.

   Implementations MUST NOT send any records with a version less than
   0x0300.  Implementations SHOULD NOT accept any records with a version
   less than 0x0300 (but may inadvertently do so if the record version
   number is ignored completely).

   Implementations MUST NOT use the Truncated HMAC extension, defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc6066#section-7&quot;&gt;Section 7 of [RFC6066]&lt;/a&gt;, as it is not applicable to AEAD algorithms
   and has been shown to be insecure in some scenarios.





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 141]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h2&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E&quot; id=&quot;appendix-E&quot;&gt;Appendix E&lt;/a&gt;.  Overview of Security Properties&lt;/span&gt;

   A complete security analysis of TLS is outside the scope of this
   document.  In this appendix, we provide an informal description of
   the desired properties as well as references to more detailed work in
   the research literature which provides more formal definitions.

   We cover properties of the handshake separately from those of the
   record layer.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1&quot; id=&quot;appendix-E.1&quot;&gt;E.1&lt;/a&gt;.  Handshake&lt;/span&gt;

   The TLS handshake is an Authenticated Key Exchange (AKE) protocol
   which is intended to provide both one-way authenticated (server-only)
   and mutually authenticated (client and server) functionality.  At the
   completion of the handshake, each side outputs its view of the
   following values:

   -  A set of &quot;session keys&quot; (the various secrets derived from the
      master secret) from which can be derived a set of working keys.

   -  A set of cryptographic parameters (algorithms, etc.).

   -  The identities of the communicating parties.

   We assume the attacker to be an active network attacker, which means
   it has complete control over the network used to communicate between
   the parties [&lt;a href=&quot;https://tools.ietf.org/html/rfc3552&quot; title=&quot;&amp;quot;Guidelines for Writing RFC Text on Security Considerations&amp;quot;&quot;&gt;RFC3552&lt;/a&gt;].  Even under these conditions, the handshake
   should provide the properties listed below.  Note that these
   properties are not necessarily independent, but reflect the protocol
   consumers' needs.

   Establishing the same session keys:  The handshake needs to output
      the same set of session keys on both sides of the handshake,
      provided that it completes successfully on each endpoint (see
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-CK01&quot; title=&quot;&amp;quot;Analysis of Key-Exchange Protocols and Their Use for Building Secure Channels&amp;quot;&quot;&gt;CK01&lt;/a&gt;], Definition 1, part 1).

   Secrecy of the session keys:  The shared session keys should be known
      only to the communicating parties and not to the attacker (see
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-CK01&quot; title=&quot;&amp;quot;Analysis of Key-Exchange Protocols and Their Use for Building Secure Channels&amp;quot;&quot;&gt;CK01&lt;/a&gt;], Definition 1, part 2).  Note that in a unilaterally
      authenticated connection, the attacker can establish its own
      session keys with the server, but those session keys are distinct
      from those established by the client.

   Peer authentication:  The client's view of the peer identity should
      reflect the server's identity.  If the client is authenticated,
      the server's view of the peer identity should match the client's
      identity.



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 142]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Uniqueness of the session keys:  Any two distinct handshakes should
      produce distinct, unrelated session keys.  Individual session keys
      produced by a handshake should also be distinct and independent.

   Downgrade protection:  The cryptographic parameters should be the
      same on both sides and should be the same as if the peers had been
      communicating in the absence of an attack (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-BBFGKZ16&quot; title=&quot;&amp;quot;Downgrade Resilience in Key-Exchange Protocols&amp;quot;&quot;&gt;BBFGKZ16&lt;/a&gt;],
      Definitions 8 and 9).

   Forward secret with respect to long-term keys:  If the long-term
      keying material (in this case the signature keys in certificate-
      based authentication modes or the external/resumption PSK in PSK
      with (EC)DHE modes) is compromised after the handshake is
      complete, this does not compromise the security of the session key
      (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-DOW92&quot; title=&quot;&amp;quot;Authentication and authenticated key exchanges&amp;quot;&quot;&gt;DOW92&lt;/a&gt;]), as long as the session key itself has been erased.
      The forward secrecy property is not satisfied when PSK is used in
      the &quot;psk_ke&quot; PskKeyExchangeMode.

   Key Compromise Impersonation (KCI) resistance:  In a mutually
      authenticated connection with certificates, compromising the
      long-term secret of one actor should not break that actor's
      authentication of their peer in the given connection (see
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-HGFS15&quot; title=&quot;&amp;quot;Prying Open Pandora's Box: KCI Attacks against TLS&amp;quot;&quot;&gt;HGFS15&lt;/a&gt;]).  For example, if a client's signature key is
      compromised, it should not be possible to impersonate arbitrary
      servers to that client in subsequent handshakes.

   Protection of endpoint identities:  The server's identity
      (certificate) should be protected against passive attackers.  The
      client's identity should be protected against both passive and
      active attackers.

   Informally, the signature-based modes of TLS 1.3 provide for the
   establishment of a unique, secret, shared key established by an
   (EC)DHE key exchange and authenticated by the server's signature over
   the handshake transcript, as well as tied to the server's identity by
   a MAC.  If the client is authenticated by a certificate, it also
   signs over the handshake transcript and provides a MAC tied to both
   identities.  [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-SIGMA&quot; title=&quot;&amp;quot;SIGMA: The 'SIGn-and-MAc' Approach to Authenticated Diffie-Hellman and its Use in the IKE Protocols&amp;quot;&quot;&gt;SIGMA&lt;/a&gt;] describes the design and analysis of this type
   of key exchange protocol.  If fresh (EC)DHE keys are used for each
   connection, then the output keys are forward secret.

   The external PSK and resumption PSK bootstrap from a long-term shared
   secret into a unique per-connection set of short-term session keys.
   This secret may have been established in a previous handshake.  If
   PSK with (EC)DHE key establishment is used, these session keys will
   also be forward secret.  The resumption PSK has been designed so that
   the resumption master secret computed by connection N and needed to
   form connection N+1 is separate from the traffic keys used by



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 143]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   connection N, thus providing forward secrecy between the connections.
   In addition, if multiple tickets are established on the same
   connection, they are associated with different keys, so compromise of
   the PSK associated with one ticket does not lead to the compromise of
   connections established with PSKs associated with other tickets.
   This property is most interesting if tickets are stored in a database
   (and so can be deleted) rather than if they are self-encrypted.

   The PSK binder value forms a binding between a PSK and the current
   handshake, as well as between the session where the PSK was
   established and the current session.  This binding transitively
   includes the original handshake transcript, because that transcript
   is digested into the values which produce the resumption master
   secret.  This requires that both the KDF used to produce the
   resumption master secret and the MAC used to compute the binder be
   collision resistant.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1.1&quot;&gt;Appendix E.1.1&lt;/a&gt; for more on this.  Note: The
   binder does not cover the binder values from other PSKs, though they
   are included in the Finished MAC.

   TLS does not currently permit the server to send a
   certificate_request message in non-certificate-based handshakes
   (e.g., PSK).  If this restriction were to be relaxed in future, the
   client's signature would not cover the server's certificate directly.
   However, if the PSK was established through a NewSessionTicket, the
   client's signature would transitively cover the server's certificate
   through the PSK binder.  [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-PSK-FINISHED&quot; title=&quot;&amp;quot;Revision 10: possible attack if client authentication is allowed during PSK&amp;quot;&quot;&gt;PSK-FINISHED&lt;/a&gt;] describes a concrete attack
   on constructions that do not bind to the server's certificate (see
   also [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-Kraw16&quot; title=&quot;&amp;quot;A Unilateral-to-Mutual Authentication Compiler for Key Exchange (with Applications to Client Authentication in TLS 1.3&amp;quot;&quot;&gt;Kraw16&lt;/a&gt;]).  It is unsafe to use certificate-based client
   authentication when the client might potentially share the same
   PSK/key-id pair with two different endpoints.  Implementations
   MUST NOT combine external PSKs with certificate-based authentication
   of either the client or the server unless negotiated by some
   extension.

   If an exporter is used, then it produces values which are unique and
   secret (because they are generated from a unique session key).
   Exporters computed with different labels and contexts are
   computationally independent, so it is not feasible to compute one
   from another or the session secret from the exported value.
   Note: Exporters can produce arbitrary-length values; if exporters are
   to be used as channel bindings, the exported value MUST be large
   enough to provide collision resistance.  The exporters provided in
   TLS 1.3 are derived from the same Handshake Contexts as the early
   traffic keys and the application traffic keys, respectively, and thus
   have similar security properties.  Note that they do not include the
   client's certificate; future applications which wish to bind to the
   client's certificate may need to define a new exporter that includes
   the full handshake transcript.



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 144]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   For all handshake modes, the Finished MAC (and, where present, the
   signature) prevents downgrade attacks.  In addition, the use of
   certain bytes in the random nonces as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.1.3&quot;&gt;Section 4.1.3&lt;/a&gt;
   allows the detection of downgrade to previous TLS versions.  See
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-BBFGKZ16&quot; title=&quot;&amp;quot;Downgrade Resilience in Key-Exchange Protocols&amp;quot;&quot;&gt;BBFGKZ16&lt;/a&gt;] for more details on TLS 1.3 and downgrade.

   As soon as the client and the server have exchanged enough
   information to establish shared keys, the remainder of the handshake
   is encrypted, thus providing protection against passive attackers,
   even if the computed shared key is not authenticated.  Because the
   server authenticates before the client, the client can ensure that if
   it authenticates to the server, it only reveals its identity to an
   authenticated server.  Note that implementations must use the
   provided record-padding mechanism during the handshake to avoid
   leaking information about the identities due to length.  The client's
   proposed PSK identities are not encrypted, nor is the one that the
   server selects.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.1.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1.1&quot; id=&quot;appendix-E.1.1&quot;&gt;E.1.1&lt;/a&gt;.  Key Derivation and HKDF&lt;/span&gt;

   Key derivation in TLS 1.3 uses HKDF as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5869&quot; title=&quot;&amp;quot;HMAC-based Extract-and-Expand Key Derivation Function (HKDF)&amp;quot;&quot;&gt;RFC5869&lt;/a&gt;] and its
   two components, HKDF-Extract and HKDF-Expand.  The full rationale for
   the HKDF construction can be found in [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-Kraw10&quot; title=&quot;&amp;quot;Cryptographic Extraction and Key Derivation: The HKDF Scheme&amp;quot;&quot;&gt;Kraw10&lt;/a&gt;] and the rationale for
   the way it is used in TLS 1.3 in [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-KW16&quot; title=&quot;&amp;quot;The OPTLS Protocol and TLS 1.3&amp;quot;&quot;&gt;KW16&lt;/a&gt;].  Throughout this document,
   each application of HKDF-Extract is followed by one or more
   invocations of HKDF-Expand.  This ordering should always be followed
   (including in future revisions of this document); in particular, one
   SHOULD NOT use an output of HKDF-Extract as an input to another
   application of HKDF-Extract without an HKDF-Expand in between.
   Multiple applications of HKDF-Expand to some of the same inputs are
   allowed as long as these are differentiated via the key and/or the
   labels.

   Note that HKDF-Expand implements a pseudorandom function (PRF) with
   both inputs and outputs of variable length.  In some of the uses of
   HKDF in this document (e.g., for generating exporters and the
   resumption_master_secret), it is necessary that the application of
   HKDF-Expand be collision resistant; namely, it should be infeasible
   to find two different inputs to HKDF-Expand that output the same
   value.  This requires the underlying hash function to be collision
   resistant and the output length from HKDF-Expand to be of size at
   least 256 bits (or as much as needed for the hash function to prevent
   finding collisions).








&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 145]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.1.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1.2&quot; id=&quot;appendix-E.1.2&quot;&gt;E.1.2&lt;/a&gt;.  Client Authentication&lt;/span&gt;

   A client that has sent authentication data to a server, either during
   the handshake or in post-handshake authentication, cannot be sure
   whether the server afterwards considers the client to be
   authenticated or not.  If the client needs to determine if the server
   considers the connection to be unilaterally or mutually
   authenticated, this has to be provisioned by the application layer.
   See [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-CHHSV17&quot; title=&quot;&amp;quot;Awkward Handshake: Possible mismatch of client/server view on client authentication in post-handshake mode in Revision 18&amp;quot;&quot;&gt;CHHSV17&lt;/a&gt;] for details.  In addition, the analysis of
   post-handshake authentication from [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-Kraw16&quot; title=&quot;&amp;quot;A Unilateral-to-Mutual Authentication Compiler for Key Exchange (with Applications to Client Authentication in TLS 1.3&amp;quot;&quot;&gt;Kraw16&lt;/a&gt;] shows that the client
   identified by the certificate sent in the post-handshake phase
   possesses the traffic key.  This party is therefore the client that
   participated in the original handshake or one to whom the original
   client delegated the traffic key (assuming that the traffic key has
   not been compromised).

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.1.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1.3&quot; id=&quot;appendix-E.1.3&quot;&gt;E.1.3&lt;/a&gt;.  0-RTT&lt;/span&gt;

   The 0-RTT mode of operation generally provides security properties
   similar to those of 1-RTT data, with the two exceptions that the
   0-RTT encryption keys do not provide full forward secrecy and that
   the server is not able to guarantee uniqueness of the handshake
   (non-replayability) without keeping potentially undue amounts of
   state.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-8&quot;&gt;Section 8&lt;/a&gt; for mechanisms to limit the exposure to replay.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.1.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1.4&quot; id=&quot;appendix-E.1.4&quot;&gt;E.1.4&lt;/a&gt;.  Exporter Independence&lt;/span&gt;

   The exporter_master_secret and early_exporter_master_secret are
   derived to be independent of the traffic keys and therefore do not
   represent a threat to the security of traffic encrypted with those
   keys.  However, because these secrets can be used to compute any
   exporter value, they SHOULD be erased as soon as possible.  If the
   total set of exporter labels is known, then implementations SHOULD
   pre-compute the inner Derive-Secret stage of the exporter computation
   for all those labels, then erase the [early_]exporter_master_secret,
   followed by each inner value as soon as it is known that it will not
   be needed again.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.1.5&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1.5&quot; id=&quot;appendix-E.1.5&quot;&gt;E.1.5&lt;/a&gt;.  Post-Compromise Security&lt;/span&gt;

   TLS does not provide security for handshakes which take place after
   the peer's long-term secret (signature key or external PSK) is
   compromised.  It therefore does not provide post-compromise security
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-CCG16&quot; title=&quot;&amp;quot;On Post-compromise Security&amp;quot;&quot;&gt;CCG16&lt;/a&gt;], sometimes also referred to as backward or future secrecy.
   This is in contrast to KCI resistance, which describes the security
   guarantees that a party has after its own long-term secret has been
   compromised.




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 146]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.1.6&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.1.6&quot; id=&quot;appendix-E.1.6&quot;&gt;E.1.6&lt;/a&gt;.  External References&lt;/span&gt;

   The reader should refer to the following references for analysis of
   the TLS handshake: [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-DFGS15&quot; title=&quot;&amp;quot;A Cryptographic Analysis of the TLS 1.3 Handshake Protocol Candidates&amp;quot;&quot;&gt;DFGS15&lt;/a&gt;], [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-CHSV16&quot; title=&quot;&amp;quot;Automated Analysis and Verification of TLS 1.3: 0-RTT, Resumption and Delayed Authentication&amp;quot;&quot;&gt;CHSV16&lt;/a&gt;], [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-DFGS16&quot; title=&quot;&amp;quot;A Cryptographic Analysis of the TLS 1.3 Full and Pre-shared Key Handshake Protocol&amp;quot;&quot;&gt;DFGS16&lt;/a&gt;], [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-KW16&quot; title=&quot;&amp;quot;The OPTLS Protocol and TLS 1.3&amp;quot;&quot;&gt;KW16&lt;/a&gt;], [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-Kraw16&quot; title=&quot;&amp;quot;A Unilateral-to-Mutual Authentication Compiler for Key Exchange (with Applications to Client Authentication in TLS 1.3&amp;quot;&quot;&gt;Kraw16&lt;/a&gt;],
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-FGSW16&quot; title=&quot;&amp;quot;Key Confirmation in Key Exchange: A Formal Treatment and Implications for TLS 1.3&amp;quot;&quot;&gt;FGSW16&lt;/a&gt;], [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-LXZFH16&quot; title=&quot;&amp;quot;Multiple Handshakes Security of TLS 1.3 Candidates&amp;quot;&quot;&gt;LXZFH16&lt;/a&gt;], [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-FG17&quot; title=&quot;&amp;quot;Replay Attacks on Zero Round-Trip Time: The Case of the TLS 1.3 Handshake Candidates&amp;quot;&quot;&gt;FG17&lt;/a&gt;], and [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-BBK17&quot; title=&quot;&amp;quot;Verified Models and Reference Implementations for the TLS 1.3 Standard Candidate&amp;quot;&quot;&gt;BBK17&lt;/a&gt;].

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.2&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.2&quot; id=&quot;appendix-E.2&quot;&gt;E.2&lt;/a&gt;.  Record Layer&lt;/span&gt;

   The record layer depends on the handshake producing strong traffic
   secrets which can be used to derive bidirectional encryption keys and
   nonces.  Assuming that is true, and the keys are used for no more
   data than indicated in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;, then the record layer should
   provide the following guarantees:

   Confidentiality:  An attacker should not be able to determine the
      plaintext contents of a given record.

   Integrity:  An attacker should not be able to craft a new record
      which is different from an existing record which will be accepted
      by the receiver.

   Order protection/non-replayability:  An attacker should not be able
      to cause the receiver to accept a record which it has already
      accepted or cause the receiver to accept record N+1 without having
      first processed record N.

   Length concealment:  Given a record with a given external length, the
      attacker should not be able to determine the amount of the record
      that is content versus padding.

   Forward secrecy after key change:  If the traffic key update
      mechanism described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-4.6.3&quot;&gt;Section 4.6.3&lt;/a&gt; has been used and the
      previous generation key is deleted, an attacker who compromises
      the endpoint should not be able to decrypt traffic encrypted with
      the old key.

   Informally, TLS 1.3 provides these properties by AEAD-protecting the
   plaintext with a strong key.  AEAD encryption [&lt;a href=&quot;https://tools.ietf.org/html/rfc5116&quot; title=&quot;&amp;quot;An Interface and Algorithms for Authenticated Encryption&amp;quot;&quot;&gt;RFC5116&lt;/a&gt;] provides
   confidentiality and integrity for the data.  Non-replayability is
   provided by using a separate nonce for each record, with the nonce
   being derived from the record sequence number (&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;), with the
   sequence number being maintained independently at both sides; thus,
   records which are delivered out of order result in AEAD deprotection
   failures.  In order to prevent mass cryptanalysis when the same
   plaintext is repeatedly encrypted by different users under the same
   key (as is commonly the case for HTTP), the nonce is formed by mixing





&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 147]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   the sequence number with a secret per-connection initialization
   vector derived along with the traffic keys.  See [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-BT16&quot; title=&quot;&amp;quot;The Multi-User Security of Authenticated Encryption: AES-GCM in TLS 1.3&amp;quot;&quot;&gt;BT16&lt;/a&gt;] for analysis
   of this construction.

   The rekeying technique in TLS 1.3 (see &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;) follows the
   construction of the serial generator as discussed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-REKEY&quot; title=&quot;&amp;quot;Increasing the Lifetime of a Key: A Comparative Analysis of the Security of Re-keying Techniques&amp;quot;&quot;&gt;REKEY&lt;/a&gt;], which
   shows that rekeying can allow keys to be used for a larger number of
   encryptions than without rekeying.  This relies on the security of
   the HKDF-Expand-Label function as a pseudorandom function (PRF).  In
   addition, as long as this function is truly one way, it is not
   possible to compute traffic keys from prior to a key change (forward
   secrecy).

   TLS does not provide security for data which is communicated on a
   connection after a traffic secret of that connection is compromised.
   That is, TLS does not provide post-compromise security/future
   secrecy/backward secrecy with respect to the traffic secret.  Indeed,
   an attacker who learns a traffic secret can compute all future
   traffic secrets on that connection.  Systems which want such
   guarantees need to do a fresh handshake and establish a new
   connection with an (EC)DHE exchange.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.2.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.2.1&quot; id=&quot;appendix-E.2.1&quot;&gt;E.2.1&lt;/a&gt;.  External References&lt;/span&gt;

   The reader should refer to the following references for analysis of
   the TLS record layer: [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-BMMRT15&quot; title=&quot;&amp;quot;Augmented Secure Channels and the Goal of the TLS 1.3 Record Layer&amp;quot;&quot;&gt;BMMRT15&lt;/a&gt;], [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-BT16&quot; title=&quot;&amp;quot;The Multi-User Security of Authenticated Encryption: AES-GCM in TLS 1.3&amp;quot;&quot;&gt;BT16&lt;/a&gt;], [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-BDFKPPRSZZ16&quot; title=&quot;&amp;quot;Implementing and Proving the TLS 1.3 Record Layer&amp;quot;&quot;&gt;BDFKPPRSZZ16&lt;/a&gt;], [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-BBK17&quot; title=&quot;&amp;quot;Verified Models and Reference Implementations for the TLS 1.3 Standard Candidate&amp;quot;&quot;&gt;BBK17&lt;/a&gt;], and
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-PS18&quot; title=&quot;&amp;quot;Partially specified channels: The TLS 1.3 record layer without elision&amp;quot;&quot;&gt;PS18&lt;/a&gt;].

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.3&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.3&quot; id=&quot;appendix-E.3&quot;&gt;E.3&lt;/a&gt;.  Traffic Analysis&lt;/span&gt;

   TLS is susceptible to a variety of traffic analysis attacks based on
   observing the length and timing of encrypted packets [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-CLINIC&quot; title=&quot;&amp;quot;I Know Why You Went to the Clinic: Risks and Realization of HTTPS Traffic Analysis&amp;quot;&quot;&gt;CLINIC&lt;/a&gt;]
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-HCJC16&quot; title=&quot;&amp;quot;HTTPS traffic analysis and client identification using passive SSL/TLS fingerprinting&amp;quot;&quot;&gt;HCJC16&lt;/a&gt;].  This is particularly easy when there is a small set of
   possible messages to be distinguished, such as for a video server
   hosting a fixed corpus of content, but still provides usable
   information even in more complicated scenarios.

   TLS does not provide any specific defenses against this form of
   attack but does include a padding mechanism for use by applications:
   The plaintext protected by the AEAD function consists of content plus
   variable-length padding, which allows the application to produce
   arbitrary-length encrypted records as well as padding-only cover
   traffic to conceal the difference between periods of transmission and
   periods of silence.  Because the padding is encrypted alongside the
   actual content, an attacker cannot directly determine the length of
   the padding but may be able to measure it indirectly by the use of
   timing channels exposed during record processing (i.e., seeing how
   long it takes to process a record or trickling in records to see



&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 148]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   which ones elicit a response from the server).  In general, it is not
   known how to remove all of these channels because even a
   constant-time padding removal function will likely feed the content
   into data-dependent functions.  At minimum, a fully constant-time
   server or client would require close cooperation with the
   application-layer protocol implementation, including making that
   higher-level protocol constant time.

   Note: Robust traffic analysis defenses will likely lead to inferior
   performance due to delays in transmitting packets and increased
   traffic volume.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.4&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.4&quot; id=&quot;appendix-E.4&quot;&gt;E.4&lt;/a&gt;.  Side-Channel Attacks&lt;/span&gt;

   In general, TLS does not have specific defenses against side-channel
   attacks (i.e., those which attack the communications via secondary
   channels such as timing), leaving those to the implementation of the
   relevant cryptographic primitives.  However, certain features of TLS
   are designed to make it easier to write side-channel resistant code:

   -  Unlike previous versions of TLS which used a composite MAC-then-
      encrypt structure, TLS 1.3 only uses AEAD algorithms, allowing
      implementations to use self-contained constant-time
      implementations of those primitives.

   -  TLS uses a uniform &quot;bad_record_mac&quot; alert for all decryption
      errors, which is intended to prevent an attacker from gaining
      piecewise insight into portions of the message.  Additional
      resistance is provided by terminating the connection on such
      errors; a new connection will have different cryptographic
      material, preventing attacks against the cryptographic primitives
      that require multiple trials.

   Information leakage through side channels can occur at layers above
   TLS, in application protocols and the applications that use them.
   Resistance to side-channel attacks depends on applications and
   application protocols separately ensuring that confidential
   information is not inadvertently leaked.













&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 149]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.5&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.5&quot; id=&quot;appendix-E.5&quot;&gt;E.5&lt;/a&gt;.  Replay Attacks on 0-RTT&lt;/span&gt;

   Replayable 0-RTT data presents a number of security threats to TLS-
   using applications, unless those applications are specifically
   engineered to be safe under replay (minimally, this means idempotent,
   but in many cases may also require other stronger conditions, such as
   constant-time response).  Potential attacks include:

   -  Duplication of actions which cause side effects (e.g., purchasing
      an item or transferring money) to be duplicated, thus harming the
      site or the user.

   -  Attackers can store and replay 0-RTT messages in order to reorder
      them with respect to other messages (e.g., moving a delete to
      after a create).

   -  Exploiting cache timing behavior to discover the content of 0-RTT
      messages by replaying a 0-RTT message to a different cache node
      and then using a separate connection to measure request latency,
      to see if the two requests address the same resource.

   If data can be replayed a large number of times, additional attacks
   become possible, such as making repeated measurements of the speed of
   cryptographic operations.  In addition, they may be able to overload
   rate-limiting systems.  For a further description of these attacks,
   see [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-Mac17&quot; title=&quot;&amp;quot;Security Review of TLS1.3 0-RTT&amp;quot;&quot;&gt;Mac17&lt;/a&gt;].

   Ultimately, servers have the responsibility to protect themselves
   against attacks employing 0-RTT data replication.  The mechanisms
   described in &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-8&quot;&gt;Section 8&lt;/a&gt; are intended to prevent replay at the TLS
   layer but do not provide complete protection against receiving
   multiple copies of client data.  TLS 1.3 falls back to the 1-RTT
   handshake when the server does not have any information about the
   client, e.g., because it is in a different cluster which does not
   share state or because the ticket has been deleted as described in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.  If the application-layer protocol retransmits data in
   this setting, then it is possible for an attacker to induce message
   duplication by sending the ClientHello to both the original cluster
   (which processes the data immediately) and another cluster which will
   fall back to 1-RTT and process the data upon application-layer
   replay.  The scale of this attack is limited by the client's
   willingness to retry transactions and therefore only allows a limited
   amount of duplication, with each copy appearing as a new connection
   at the server.







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 150]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   If implemented correctly, the mechanisms described in Sections &lt;a href=&quot;https://tools.ietf.org/html/rfc8446#section-8.1&quot;&gt;8.1&lt;/a&gt;
   and 8.2 prevent a replayed ClientHello and its associated 0-RTT data
   from being accepted multiple times by any cluster with consistent
   state; for servers which limit the use of 0-RTT to one cluster for a
   single ticket, then a given ClientHello and its associated 0-RTT data
   will only be accepted once.  However, if state is not completely
   consistent, then an attacker might be able to have multiple copies of
   the data be accepted during the replication window.  Because clients
   do not know the exact details of server behavior, they MUST NOT send
   messages in early data which are not safe to have replayed and which
   they would not be willing to retry across multiple 1-RTT connections.

   Application protocols MUST NOT use 0-RTT data without a profile that
   defines its use.  That profile needs to identify which messages or
   interactions are safe to use with 0-RTT and how to handle the
   situation when the server rejects 0-RTT and falls back to 1-RTT.

   In addition, to avoid accidental misuse, TLS implementations MUST NOT
   enable 0-RTT (either sending or accepting) unless specifically
   requested by the application and MUST NOT automatically resend 0-RTT
   data if it is rejected by the server unless instructed by the
   application.  Server-side applications may wish to implement special
   processing for 0-RTT data for some kinds of application traffic
   (e.g., abort the connection, request that data be resent at the
   application layer, or delay processing until the handshake
   completes).  In order to allow applications to implement this kind of
   processing, TLS implementations MUST provide a way for the
   application to determine if the handshake has completed.

&lt;span class=&quot;h4&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.5.1&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.5.1&quot; id=&quot;appendix-E.5.1&quot;&gt;E.5.1&lt;/a&gt;.  Replay and Exporters&lt;/span&gt;

   Replays of the ClientHello produce the same early exporter, thus
   requiring additional care by applications which use these exporters.
   In particular, if these exporters are used as an authentication
   channel binding (e.g., by signing the output of the exporter), an
   attacker who compromises the PSK can transplant authenticators
   between connections without compromising the authentication key.

   In addition, the early exporter SHOULD NOT be used to generate
   server-to-client encryption keys because that would entail the reuse
   of those keys.  This parallels the use of the early application
   traffic keys only in the client-to-server direction.









&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 151]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.6&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.6&quot; id=&quot;appendix-E.6&quot;&gt;E.6&lt;/a&gt;.  PSK Identity Exposure&lt;/span&gt;

   Because implementations respond to an invalid PSK binder by aborting
   the handshake, it may be possible for an attacker to verify whether a
   given PSK identity is valid.  Specifically, if a server accepts both
   external-PSK handshakes and certificate-based handshakes, a valid PSK
   identity will result in a failed handshake, whereas an invalid
   identity will just be skipped and result in a successful certificate
   handshake.  Servers which solely support PSK handshakes may be able
   to resist this form of attack by treating the cases where there is no
   valid PSK identity and where there is an identity but it has an
   invalid binder identically.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.7&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.7&quot; id=&quot;appendix-E.7&quot;&gt;E.7&lt;/a&gt;.  Sharing PSKs&lt;/span&gt;

   TLS 1.3 takes a conservative approach to PSKs by binding them to a
   specific KDF.  By contrast, TLS 1.2 allows PSKs to be used with any
   hash function and the TLS 1.2 PRF.  Thus, any PSK which is used with
   both TLS 1.2 and TLS 1.3 must be used with only one hash in TLS 1.3,
   which is less than optimal if users want to provision a single PSK.
   The constructions in TLS 1.2 and TLS 1.3 are different, although they
   are both based on HMAC.  While there is no known way in which the
   same PSK might produce related output in both versions, only limited
   analysis has been done.  Implementations can ensure safety from
   cross-protocol related output by not reusing PSKs between TLS 1.3 and
   TLS 1.2.

&lt;span class=&quot;h3&quot;&gt;&lt;a class=&quot;selflink&quot; name=&quot;appendix-E.8&quot; href=&quot;https://tools.ietf.org/html/rfc8446#appendix-E.8&quot; id=&quot;appendix-E.8&quot;&gt;E.8&lt;/a&gt;.  Attacks on Static RSA&lt;/span&gt;

   Although TLS 1.3 does not use RSA key transport and so is not
   directly susceptible to Bleichenbacher-type attacks [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-Blei98&quot; title=&quot;&amp;quot;Chosen Ciphertext Attacks against Protocols Based on RSA Encryption Standard PKCS #1&amp;quot;&quot;&gt;Blei98&lt;/a&gt;], if TLS
   1.3 servers also support static RSA in the context of previous
   versions of TLS, then it may be possible to impersonate the server
   for TLS 1.3 connections [&lt;a href=&quot;https://tools.ietf.org/html/rfc8446#ref-JSS15&quot; title=&quot;&amp;quot;On the Security of TLS 1.3 and QUIC Against Weaknesses in PKCS#1 v1.5 Encryption&amp;quot;&quot;&gt;JSS15&lt;/a&gt;].  TLS 1.3 implementations can prevent
   this attack by disabling support for static RSA across all versions
   of TLS.  In principle, implementations might also be able to separate
   certificates with different keyUsage bits for static RSA decryption
   and RSA signature, but this technique relies on clients refusing to
   accept signatures using keys in certificates that do not have the
   digitalSignature bit set, and many clients do not enforce this
   restriction.










&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 152]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


Contributors

   Martin Abadi
   University of California, Santa Cruz
   abadi@cs.ucsc.edu

   Christopher Allen
   (co-editor of TLS 1.0)
   Alacrity Ventures
   ChristopherA@AlacrityManagement.com

   Richard Barnes
   Cisco
   rlb@ipv.sx

   Steven M. Bellovin
   Columbia University
   smb@cs.columbia.edu

   David Benjamin
   Google
   davidben@google.com

   Benjamin Beurdouche
   INRIA &amp;amp; Microsoft Research
   benjamin.beurdouche@ens.fr

   Karthikeyan Bhargavan
   (editor of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7627&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension&amp;quot;&quot;&gt;RFC7627&lt;/a&gt;])
   INRIA
   karthikeyan.bhargavan@inria.fr

   Simon Blake-Wilson
   (co-author of [&lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot; title=&quot;&amp;quot;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)&amp;quot;&quot;&gt;RFC4492&lt;/a&gt;])
   BCI
   sblakewilson@bcisse.com

   Nelson Bolyard
   (co-author of [&lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot; title=&quot;&amp;quot;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)&amp;quot;&quot;&gt;RFC4492&lt;/a&gt;])
   Sun Microsystems, Inc.
   nelson@bolyard.com

   Ran Canetti
   IBM
   canetti@watson.ibm.com






&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 153]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Matt Caswell
   OpenSSL
   matt@openssl.org

   Stephen Checkoway
   University of Illinois at Chicago
   sfc@uic.edu

   Pete Chown
   Skygate Technology Ltd
   pc@skygate.co.uk

   Katriel Cohn-Gordon
   University of Oxford
   me@katriel.co.uk

   Cas Cremers
   University of Oxford
   cas.cremers@cs.ox.ac.uk

   Antoine Delignat-Lavaud
   (co-author of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7627&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension&amp;quot;&quot;&gt;RFC7627&lt;/a&gt;])
   INRIA
   antdl@microsoft.com

   Tim Dierks
   (co-author of TLS 1.0, co-editor of TLS 1.1 and 1.2)
   Independent
   tim@dierks.org

   Roelof DuToit
   Symantec Corporation
   roelof_dutoit@symantec.com

   Taher Elgamal
   Securify
   taher@securify.com

   Pasi Eronen
   Nokia
   pasi.eronen@nokia.com

   Cedric Fournet
   Microsoft
   fournet@microsoft.com






&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 154]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Anil Gangolli
   anil@busybuddha.org

   David M. Garrett
   dave@nulldereference.com

   Illya Gerasymchuk
   Independent
   illya@iluxonchik.me

   Alessandro Ghedini
   Cloudflare Inc.
   alessandro@cloudflare.com

   Daniel Kahn Gillmor
   ACLU
   dkg@fifthhorseman.net

   Matthew Green
   Johns Hopkins University
   mgreen@cs.jhu.edu

   Jens Guballa
   ETAS
   jens.guballa@etas.com

   Felix Guenther
   TU Darmstadt
   mail@felixguenther.info

   Vipul Gupta
   (co-author of [&lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot; title=&quot;&amp;quot;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)&amp;quot;&quot;&gt;RFC4492&lt;/a&gt;])
   Sun Microsystems Laboratories
   vipul.gupta@sun.com

   Chris Hawk
   (co-author of [&lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot; title=&quot;&amp;quot;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)&amp;quot;&quot;&gt;RFC4492&lt;/a&gt;])
   Corriente Networks LLC
   chris@corriente.net

   Kipp Hickman

   Alfred Hoenes

   David Hopwood
   Independent Consultant
   david.hopwood@blueyonder.co.uk




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 155]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Marko Horvat
   MPI-SWS
   mhorvat@mpi-sws.org

   Jonathan Hoyland
   Royal Holloway, University of London
   jonathan.hoyland@gmail.com

   Subodh Iyengar
   Facebook
   subodh@fb.com

   Benjamin Kaduk
   Akamai Technologies
   kaduk@mit.edu

   Hubert Kario
   Red Hat Inc.
   hkario@redhat.com

   Phil Karlton
   (co-author of SSL 3.0)

   Leon Klingele
   Independent
   mail@leonklingele.de

   Paul Kocher
   (co-author of SSL 3.0)
   Cryptography Research
   paul@cryptography.com

   Hugo Krawczyk
   IBM
   hugokraw@us.ibm.com

   Adam Langley
   (co-author of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7627&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension&amp;quot;&quot;&gt;RFC7627&lt;/a&gt;])
   Google
   agl@google.com

   Olivier Levillain
   ANSSI
   olivier.levillain@ssi.gouv.fr







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 156]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Xiaoyin Liu
   University of North Carolina at Chapel Hill
   xiaoyin.l@outlook.com

   Ilari Liusvaara
   Independent
   ilariliusvaara@welho.com

   Atul Luykx
   K.U. Leuven
   atul.luykx@kuleuven.be

   Colm MacCarthaigh
   Amazon Web Services
   colm@allcosts.net

   Carl Mehner
   USAA
   carl.mehner@usaa.com

   Jan Mikkelsen
   Transactionware
   janm@transactionware.com

   Bodo Moeller
   (co-author of [&lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot; title=&quot;&amp;quot;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)&amp;quot;&quot;&gt;RFC4492&lt;/a&gt;])
   Google
   bodo@acm.org

   Kyle Nekritz
   Facebook
   knekritz@fb.com

   Erik Nygren
   Akamai Technologies
   erik+ietf@nygren.org

   Magnus Nystrom
   Microsoft
   mnystrom@microsoft.com

   Kazuho Oku
   DeNA Co., Ltd.
   kazuhooku@gmail.com







&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 157]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Kenny Paterson
   Royal Holloway, University of London
   kenny.paterson@rhul.ac.uk

   Christopher Patton
   University of Florida
   cjpatton@ufl.edu

   Alfredo Pironti
   (co-author of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7627&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension&amp;quot;&quot;&gt;RFC7627&lt;/a&gt;])
   INRIA
   alfredo.pironti@inria.fr

   Andrei Popov
   Microsoft
   andrei.popov@microsoft.com

   Marsh Ray
   (co-author of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7627&quot; title=&quot;&amp;quot;Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension&amp;quot;&quot;&gt;RFC7627&lt;/a&gt;])
   Microsoft
   maray@microsoft.com

   Robert Relyea
   Netscape Communications
   relyea@netscape.com

   Kyle Rose
   Akamai Technologies
   krose@krose.org

   Jim Roskind
   Amazon
   jroskind@amazon.com

   Michael Sabin

   Joe Salowey
   Tableau Software
   joe@salowey.net

   Rich Salz
   Akamai
   rsalz@akamai.com

   David Schinazi
   Apple Inc.
   dschinazi@apple.com




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 158]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Sam Scott
   Royal Holloway, University of London
   me@samjs.co.uk

   Thomas Shrimpton
   University of Florida
   teshrim@ufl.edu

   Dan Simon
   Microsoft, Inc.
   dansimon@microsoft.com

   Brian Smith
   Independent
   brian@briansmith.org

   Brian Sniffen
   Akamai Technologies
   ietf@bts.evenmere.org

   Nick Sullivan
   Cloudflare Inc.
   nick@cloudflare.com

   Bjoern Tackmann
   University of California, San Diego
   btackmann@eng.ucsd.edu

   Tim Taubert
   Mozilla
   ttaubert@mozilla.com

   Martin Thomson
   Mozilla
   mt@mozilla.com

   Hannes Tschofenig
   Arm Limited
   Hannes.Tschofenig@arm.com

   Sean Turner
   sn3rd
   sean@sn3rd.com

   Steven Valdez
   Google
   svaldez@google.com




&lt;span class=&quot;grey&quot;&gt;Rescorla                     Standards Track                  [Page 159]&lt;/span&gt;
&lt;/pre&gt;
&lt;hr class=&quot;noprint&quot; align=&quot;left&quot; /&gt;&lt;pre class=&quot;newpage&quot;&gt;

&lt;span class=&quot;grey&quot;&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8446&quot;&gt;RFC 8446&lt;/a&gt;                           TLS                       August 2018&lt;/span&gt;


   Filippo Valsorda
   Cloudflare Inc.
   filippo@cloudflare.com

   Thyla van der Merwe
   Royal Holloway, University of London
   tjvdmerwe@gmail.com

   Victor Vasiliev
   Google
   vasilvv@google.com

   Hoeteck Wee
   Ecole Normale Superieure, Paris
   hoeteck@alum.mit.edu

   Tom Weinstein

   David Wong
   NCC Group
   david.wong@nccgroup.trust

   Christopher A. Wood
   Apple Inc.
   cawood@apple.com

   Tim Wright
   Vodafone
   timothy.wright@vodafone.com

   Peter Wu
   Independent
   peter@lekensteyn.nl

   Kazu Yamamoto
   Internet Initiative Japan Inc.
   kazu@iij.ad.jp

Author's Address

   Eric Rescorla
   Mozilla

   Email: ekr@rtfm.com







Rescorla                     Standards Track                  [Page 160]

&lt;/pre&gt;
&lt;br /&gt;&lt;span class=&quot;noprint&quot;&gt;&lt;small&gt;&lt;small&gt;Html markup produced by rfcmarkup 1.127, available from &lt;a href=&quot;https://tools.ietf.org/tools/rfcmarkup/&quot;&gt;https://tools.ietf.org/tools/rfcmarkup/&lt;/a&gt;&lt;/small&gt;&lt;/small&gt;&lt;/span&gt;</description>
<pubDate>Sat, 11 Aug 2018 11:57:44 +0000</pubDate>
<dc:creator>dochtman</dc:creator>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://tools.ietf.org/html/rfc8446</dc:identifier>
</item>
<item>
<title>China is detaining a million Uighur muslims in a secret camp</title>
<link>https://www.bbc.com/news/world-asia-china-45147972</link>
<guid isPermaLink="true" >https://www.bbc.com/news/world-asia-china-45147972</guid>
<description>&lt;figure class=&quot;media-landscape has-caption full-width lead&quot;&gt;&lt;span class=&quot;image-and-copyright-container&quot;&gt;
                
                &lt;img class=&quot;js-image-replace&quot; alt=&quot;An Uighur woman holds the IDs of her relatives who are currently detained, as she and others protest on a street in July, 2009&quot; src=&quot;https://ichef.bbci.co.uk/news/320/cpsprodpb/C474/production/_102929205_uighurwomen.jpg&quot; width=&quot;976&quot; height=&quot;649&quot;/&gt;&lt;span class=&quot;off-screen&quot;&gt;Image copyright&lt;/span&gt;
                 &lt;span class=&quot;story-image-copyright&quot;&gt;Getty Images&lt;/span&gt;
                
            &lt;/span&gt;
            
            &lt;figcaption class=&quot;media-caption&quot;&gt;&lt;span class=&quot;off-screen&quot;&gt;Image caption&lt;/span&gt;
                &lt;span class=&quot;media-caption__text&quot;&gt;
                    Uighur protesters pictured in 2009 wield the ID cards of detained relatives
                &lt;/span&gt;
            &lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;story-body__introduction&quot;&gt;A UN human rights committee has heard there are credible reports that China is holding a million Uighurs in &quot;counter-extremism centres&quot;.&lt;/p&gt;&lt;p&gt;Gay McDougall, a member of the UN Committee on the Elimination of Racial Discrimination, raised the claims at a two-day UN meeting on China.&lt;/p&gt;&lt;p&gt;She said she was concerned by reports that Beijing had &quot;turned the Uighur autonomous region into something that resembles a massive internment camp&quot;.&lt;/p&gt;&lt;p&gt;China did not immediately respond.&lt;/p&gt;&lt;p&gt;Its 50-strong delegation said it would address questions on Monday, when the session in Geneva continues.&lt;/p&gt;&lt;ul class=&quot;story-body__unordered-list&quot;&gt;&lt;li class=&quot;story-body__list-item&quot;&gt;&lt;a href=&quot;https://www.bbc.com/news/world-asia-china-22278037&quot; class=&quot;story-body__link&quot;&gt;In depth: Tensions between Beijing and the Uighurs&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;story-body__list-item&quot;&gt;&lt;a href=&quot;https://www.bbc.com/news/world-asia-42049550&quot; class=&quot;story-body__link&quot;&gt;Uighurs dig their way out of Thai jail&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Beijing has previously denied the existence of such camps. &lt;/p&gt;&lt;h2 class=&quot;story-body__crosshead&quot;&gt;Who are the Uighurs? &lt;/h2&gt;&lt;p&gt;The Uighurs are a Muslim ethnic minority mostly based in China's Xinjiang province. They make up around 45% of the population there.&lt;/p&gt;&lt;p&gt;Xinjiang is officially designated as an autonomous region within China, like Tibet to its south.&lt;/p&gt;&lt;figure class=&quot;media-with-caption&quot; readability=&quot;-24&quot;&gt;&lt;div class=&quot;player-with-placeholder&quot; readability=&quot;7&quot;&gt;
            &lt;img class=&quot;media-placeholder player-with-placeholder__image narrative-video-placeholder&quot; src=&quot;https://ichef.bbci.co.uk/images/ic/720x405/p05wv9gj.jpg&quot;/&gt;&lt;p&gt;Media playback is unsupported on your device&lt;/p&gt;
      
    &lt;/div&gt;    &lt;figcaption class=&quot;media-with-caption__caption&quot;&gt;&lt;span class=&quot;off-screen&quot;&gt;Media caption&lt;/span&gt;John Sudworth reports from Xinjiang, where all filming and reporting by foreign media is tightly controlled&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Reports that more and more Uighurs and other Muslim minorities are being detained in Xinjiang have been circulating for some months.&lt;/p&gt;&lt;h2 class=&quot;story-body__crosshead&quot;&gt;What is Beijing accused of?&lt;/h2&gt;&lt;p&gt;Human rights groups including Amnesty International and Human Rights Watch have submitted reports to the UN committee documenting claims of mass imprisonment, in camps where inmates are forced to swear loyalty to China's President Xi Jinping. &lt;/p&gt;&lt;p&gt;The World Uyghur Congress said in its report that detainees are held indefinitely without charge, and forced to shout Communist Party slogans.  &lt;/p&gt;&lt;p&gt;It said they are poorly fed, and reports of torture are widespread. &lt;/p&gt;&lt;p&gt;Most inmates have never been charged with a crime, it is claimed, and do not receive legal representation.&lt;/p&gt;&lt;p&gt;China is said to carry out the detentions under the guise of combating religious extremism.&lt;/p&gt;&lt;h2 class=&quot;story-body__crosshead&quot;&gt;What does China say?&lt;/h2&gt;&lt;p&gt;The Chinese government denies the existence of these camps. &lt;/p&gt;&lt;p&gt;In April, Laura Stone, a senior diplomat in the US State Department, said tens of thousands of people had been detained in &quot;re-education centres&quot; amid a government crackdown.&lt;/p&gt;&lt;p&gt;In response, Chinese Foreign Ministry spokeswoman Hua Chunying stated that, &quot;everyone can see that people of all ethnicities in Xinjiang live and work in peace and contentment and enjoy peaceful and progressing lives&quot;.&lt;/p&gt;&lt;ul class=&quot;story-body__unordered-list&quot;&gt;&lt;li class=&quot;story-body__list-item&quot;&gt;&lt;a href=&quot;https://www.bbc.com/news/world-asia-china-39460538&quot; class=&quot;story-body__link&quot;&gt;China bans beards and veils in Xinjiang&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;story-body__list-item&quot;&gt;&lt;a href=&quot;https://www.bbc.com/news/world-asia-pacific-16860974&quot; class=&quot;story-body__link&quot;&gt;Profile: What is Xinjiang like?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;figure class=&quot;media-landscape has-caption full-width&quot;&gt;&lt;span class=&quot;image-and-copyright-container&quot;&gt;
                
                
                
                
                
                 &lt;span class=&quot;off-screen&quot;&gt;Image copyright&lt;/span&gt;
                 &lt;span class=&quot;story-image-copyright&quot;&gt;Getty Images&lt;/span&gt;
                
            &lt;/span&gt;
            
            &lt;figcaption class=&quot;media-caption&quot;&gt;&lt;span class=&quot;off-screen&quot;&gt;Image caption&lt;/span&gt;
                &lt;span class=&quot;media-caption__text&quot;&gt;
                    China denies the existence of mass detention camps where Uighurs are held without trial (Pictured: Uighur men at a bazaar in 2013)
                &lt;/span&gt;
            &lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;The claims come on a day of worsening religious tensions elsewhere in China. &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.bbc.co.uk/news/world-asia-china-45140551&quot; class=&quot;story-body__link&quot;&gt;In the north-western Ningxia region, hundreds of Muslims engaged in a standoff with authorities&lt;/a&gt; on Friday to prevent their mosque from being demolished.&lt;/p&gt;&lt;p&gt;Officials said the newly-built Weizhou Grand Mosque had not been given proper building permits. However, human rights groups say there is increasing official hostility towards Muslims in China, where religious activities remain tightly controlled by the government.&lt;/p&gt;
            </description>
<pubDate>Sat, 11 Aug 2018 02:28:25 +0000</pubDate>
<dc:creator>crunchlibrarian</dc:creator>
<og:title>China detains one million Uighurs, UN told</og:title>
<og:type>article</og:type>
<og:description>A million ethnic Uighurs may be being held in &quot;re-education centres&quot;, a UN rights panel has heard.</og:description>
<og:url>https://www.bbc.co.uk/news/world-asia-china-45147972</og:url>
<og:image>https://ichef.bbci.co.uk/news/1024/branded_news/C474/production/_102929205_uighurwomen.jpg</og:image>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.bbc.com/news/world-asia-china-45147972</dc:identifier>
</item>
<item>
<title>1/0 = 0</title>
<link>https://www.hillelwayne.com/post/divide-by-zero/</link>
<guid isPermaLink="true" >https://www.hillelwayne.com/post/divide-by-zero/</guid>
<description>&lt;p&gt;Have a tweet:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hillelwayne.com/post/divide-by-zero/tweet.png&quot; alt=&quot;Picture of original tweet, name blacked out&quot;/&gt;&lt;/p&gt;
&lt;p&gt;I have no idea if Pony is making the right choice here, I don’t know Pony, and I don’t have any interest in learning Pony. But this tweet raised my hackles for two reasons:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;It’s pretty smug. I have very strong opinions about programming, but one rule I try to follow is &lt;em&gt;do not mock other programmers&lt;/em&gt;. Programming is too big and I’m too small to understand everything. Disagreeing is fine, laying out why people are wrong is fine, making fun of them is not fine.&lt;/li&gt;
&lt;li&gt;It’s saying that Pony is &lt;em&gt;mathematically&lt;/em&gt; wrong. This is objectively false.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;I tweeted a thing about why &lt;code&gt;1/0 = 0&lt;/code&gt; is mathematically sound. Some people agreed, some people agreed with caveats, and some people called it bunk. A few people said it’s clear I don’t know real mathematics, because a real mathematician would never make such a mistake.&lt;/p&gt;
&lt;p&gt;So in this post I’d like to clearly, formally lay out why it’s consistent to say that &lt;code&gt;1/0 = 0&lt;/code&gt;, why some of the common objections don’t apply, and what the real mathematicians say. Fair warning, this post is going to be a little more mathematically dense than my usual stuff. I’ve tried to make it clear but, well, math.&lt;/p&gt;
&lt;h2 id=&quot;consistency&quot;&gt;Consistency&lt;/h2&gt;
&lt;p&gt;First we need to explain what we mean by “consistency”. In a given formalism, a mathematical statement is true if you can’t use it to prove something that’s false, like &lt;code&gt;1 = 0&lt;/code&gt;. The formalism is consistent, or &lt;strong&gt;sound&lt;/strong&gt;, if you can only use it to prove true statements. To say &lt;code&gt;1/0 = 0&lt;/code&gt; is unsound is to either say that we can prove &lt;code&gt;1/0 ≠ 0&lt;/code&gt; or that, given &lt;code&gt;1/0 = 0&lt;/code&gt;, we can prove something that’s false. These are actually equivalent statements but it’ll be useful to treat them as distinct for teaching purposes.&lt;/p&gt;
&lt;p&gt;Next we need to explain what we mean by “division”. But to do that, I need to introduce &lt;strong&gt;fields&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&quot;fields&quot;&gt;Fields&lt;/h2&gt;
&lt;p&gt;A field is a set of elements (S) along with an &lt;strong&gt;addition operator&lt;/strong&gt; (&lt;code&gt;+&lt;/code&gt;) and a &lt;strong&gt;multiplication operator&lt;/strong&gt; (&lt;code&gt;*&lt;/code&gt;) that follow some properties:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;The set is &lt;strong&gt;closed&lt;/strong&gt; under both operations. If &lt;code&gt;x&lt;/code&gt; is an element of S and &lt;code&gt;y&lt;/code&gt; is an element of S, then both &lt;code&gt;x + y&lt;/code&gt; and &lt;code&gt;x * y&lt;/code&gt; are elements of S.&lt;/li&gt;
&lt;li&gt;Both operations are &lt;strong&gt;commutative&lt;/strong&gt;. &lt;code&gt;a + b = b + a&lt;/code&gt;, and &lt;code&gt;a * b = b * a&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Both operations are &lt;strong&gt;associative&lt;/strong&gt;. &lt;code&gt;a + (b + c) = (a + b) + c&lt;/code&gt;, and &lt;code&gt;a * (b * c) = (a * b) * c&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Multiplication is distributive. &lt;code&gt;a * (b + c) = a * b + a * c&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;There is an element that is the &lt;strong&gt;additive identity&lt;/strong&gt;, or &lt;code&gt;0&lt;/code&gt;, such that &lt;code&gt;a + 0 = a&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;There is an element that is the &lt;strong&gt;multiplicative identity&lt;/strong&gt;, or &lt;code&gt;1&lt;/code&gt;, such that &lt;code&gt;a * 1 = a&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The two identities are different elements. &lt;code&gt;1 ≠ 0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Every element has an &lt;strong&gt;additive inverse&lt;/strong&gt;, &lt;code&gt;-a&lt;/code&gt;, such that &lt;code&gt;a + (-a) = 0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Every element EXCEPT 0 has a &lt;strong&gt;multiplicative inverse&lt;/strong&gt;, &lt;code&gt;a⁻&lt;/code&gt;, such that &lt;code&gt;a*a⁻ = 1&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;These are all of the rules of a field. We can define S, +, and * any way we want, as long as all of the rules are followed. The real numbers, along with our conventional notion of addition and multiplication, form a field. This gives us the building blocks to discover properties of our system. In order to prove a &lt;strong&gt;theorem&lt;/strong&gt;, we need to be able to derive it solely through the definitions of &lt;code&gt;S/+/*&lt;/code&gt;, the definition of a field, and any axioms we have. For example, we can prove that for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a * 0 = 0&lt;/code&gt;:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;By the additive identity, &lt;code&gt;0 + 0 = 0&lt;/code&gt;, so &lt;code&gt;a * 0 = a * (0 + 0)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;By the distributive property, &lt;code&gt;a * (0 + 0) = a * 0 + a * 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;By the additive inverse property, there is some &lt;code&gt;- (a * 0)&lt;/code&gt; such that &lt;code&gt;- (a * 0) + (a * 0) = 0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Combining (1) and (2), we get &lt;code&gt;a * 0 = a * 0 + a * 0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Combining (3) and (4), we get &lt;code&gt;- (a * 0) + (a * 0) = - (a * 0) + a * 0 + a * 0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Evaluating (5) gives us &lt;code&gt;0 = a * 0&lt;/code&gt;. QED.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Now that we have this as a theorem, we can use it to prove other theorems. Given this property, we can immediately show that there is no multiplicative inverse of 0:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;If 0 had a multiplicative inverse &lt;code&gt;0⁻&lt;/code&gt;, then &lt;code&gt;0 * 0⁻ = 1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;For all real numbers, &lt;code&gt;a * 0 = 0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Since &lt;code&gt;1 ≠ 0&lt;/code&gt;, there is no multiplicative inverse of &lt;code&gt;0⁻&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Okay, now we can talk about division in the reals.&lt;/p&gt;
&lt;h2 id=&quot;division&quot;&gt;Division&lt;/h2&gt;
&lt;p&gt;The field definition does &lt;em&gt;not&lt;/em&gt; include division, nor do our definitions of addition or multiplication. This means we are free to define division however we want. We want to define it in a way that &lt;em&gt;mostly&lt;/em&gt; follows our intuition and is sound. I say &lt;em&gt;mostly&lt;/em&gt; because our intuition doesn’t generalize. As an example, we intuitively think of &lt;code&gt;a * b&lt;/code&gt; as “&lt;code&gt;a&lt;/code&gt; summed up &lt;code&gt;b&lt;/code&gt; times”. So what’s &lt;code&gt;-1 * π&lt;/code&gt;? How do you sum up something π times? While it would be nice if division didn’t have any “oddness” to it, we can’t guarantee that without kneecapping mathematics.&lt;/p&gt;
&lt;p&gt;The intuitive definition of division is multiplying by the inverse. &lt;code&gt;a/2 = a * 2⁻&lt;/code&gt;. Under this definition, we can get all of the properties of division we’re used to by proving that they hold. For example,&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Theorem: &lt;code&gt;a/a = 1&lt;/code&gt;. Proof: &lt;code&gt;a/a = a * a⁻ = 1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Theorem: &lt;code&gt;a * (b/c) = b * (a/c)&lt;/code&gt;. Proof: &lt;code&gt;a * (b/c) = a * (b * c⁻)&lt;/code&gt;. Since multiplication is commutative and associative, we can rearrange this to get &lt;code&gt;b * (a * c⁻) = b * (a/c)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;This is all great, except for one problem: &lt;strong&gt;0 does not have a multiplicative inverse&lt;/strong&gt;. Both of those proofs are invalid: if I write &lt;code&gt;0/0&lt;/code&gt;, I get &lt;code&gt;0 * 0⁻&lt;/code&gt;, which is an invalid equation. So we &lt;em&gt;cannot&lt;/em&gt; prove that &lt;code&gt;a/a = 1&lt;/code&gt;. We &lt;em&gt;can&lt;/em&gt;, however, prove something weaker:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Theorem: IF &lt;code&gt;a ≠ 0&lt;/code&gt;, THEN &lt;code&gt;a/a = 1&lt;/code&gt;. Proof: same.&lt;/li&gt;
&lt;li&gt;Theorem: IF &lt;code&gt;c ≠ 0&lt;/code&gt;, THEN &lt;code&gt;a * (b/c) = b * (a/c)&lt;/code&gt;. Proof: same.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Note this does &lt;em&gt;not&lt;/em&gt; go both ways: it does &lt;em&gt;not&lt;/em&gt; follow that &lt;code&gt;0/0 ≠ 1&lt;/code&gt;. All we know is we cannot use &lt;em&gt;this&lt;/em&gt; theorem to prove that &lt;code&gt;0/0 = 1&lt;/code&gt;. So we do not have that &lt;code&gt;0/0 ≠ 1&lt;/code&gt;. For any given number, we &lt;em&gt;cannot&lt;/em&gt; prove that &lt;code&gt;0/0&lt;/code&gt; is not that number! Since we’ve defined division as multiplying by the inverse, and zero does not have an inverse, our definition of division does not cover dividing by zero. It does not say anything about it, leaving it “undefined” if you will.&lt;/p&gt;
&lt;p&gt;Since this form of division is not defined for 0, it is a &lt;strong&gt;partial function&lt;/strong&gt; over the reals: there is some value in its domain that we have not specified. Practically, this is &lt;em&gt;fine&lt;/em&gt;: we’re used to thinking of &lt;code&gt;1/0&lt;/code&gt; as an impossible operation. But division is no longer an operation over the real numbers. We need to either capture that in the definition, or find some way of extending division to cover dividing by zero. So there’s three things we can do:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;We can say that division’s domain is all the real numbers &lt;em&gt;except&lt;/em&gt; zero. This is what we do in our day-to-day lives, and the way that Agda and Idris handle division.&lt;/li&gt;
&lt;li&gt;We can choose some value that isn’t a real number, such as “undefined” or infinity, and say &lt;code&gt;x/0 = &amp;lt;whatever&amp;gt;&lt;/code&gt;. This is what some mathematicians do with the Riemann sphere.&lt;/li&gt;
&lt;li&gt;We could choose some real number, like 19, and say that &lt;code&gt;x/0 = 19&lt;/code&gt;. This is what Isabelle, Lean and Coq do.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;All of these have tradeoffs. With a restricted domain, you don’t have a total function, which can cause headaches. With an “undefined” value, division is no longer closed on the reals. In the last case, you explode everybody’s intuitive notion of division. But &lt;em&gt;all of these are sound.&lt;/em&gt; Since our original notion of division does not say anything about dividing by zero, it does not &lt;em&gt;rule out&lt;/em&gt; anything. None of these extensions lead to a contradiction.&lt;/p&gt;
&lt;p&gt;The controversy is over the last case, so let’s focus on that. We’ll define division as follows: &lt;code&gt;IF b = 0 THEN a/b = 1 ELSE a/b = a * b⁻&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Something I need to emphasize here: &lt;strong&gt;this does not give us an inverse of 0.&lt;/strong&gt; &lt;code&gt;1/0&lt;/code&gt; is not &lt;code&gt;0⁻&lt;/code&gt;. This means that while &lt;code&gt;0/0 = 1&lt;/code&gt;, &lt;code&gt;0 * 1/0 = 0&lt;/code&gt;. Division is only “multiply by the inverse” when the denominator isn’t 0. All we’ve done is special case dividing by zero and nothing else. And doing so is mathematically consistent, because &lt;em&gt;under this definition of division&lt;/em&gt; you can’t take &lt;code&gt;1/0 = 1&lt;/code&gt; and prove something false.&lt;/p&gt;
&lt;h2 id=&quot;objections&quot;&gt;Objections&lt;/h2&gt;
&lt;p&gt;Here’s where a lot of people objected. They would take the fact &lt;code&gt;1/0 = 1&lt;/code&gt; and prove something false, usually &lt;code&gt;1 = 0&lt;/code&gt;. None of these proofs, however, are sound. To see why, let’s dig into a couple example proofs and show where they break down.&lt;/p&gt;
&lt;p&gt;Here’s a common argument:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;1/0 = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1/0 * 0 = 1 * 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 * 0/0 = 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 = 0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;The problem is in step (3): our division theorem is only valid for &lt;code&gt;c ≠ 0&lt;/code&gt;, so you can’t go from &lt;code&gt;1/0 * 0&lt;/code&gt; to &lt;code&gt;1 * 0/0&lt;/code&gt;. The “denominator is nonzero” clause prevents us from taking our definition and reaching this contradiction.&lt;/p&gt;
&lt;p&gt;Here’s where people got tripped up. They assume we needed the nonzero clause on our division theorems because &lt;code&gt;x/0&lt;/code&gt; is undefined. “If &lt;code&gt;x/0&lt;/code&gt; is a value, then the theorem should extend to &lt;code&gt;c=0&lt;/code&gt;, too.” &lt;strong&gt;This is wrong.&lt;/strong&gt; The problem is &lt;em&gt;not&lt;/em&gt; that &lt;code&gt;1/0&lt;/code&gt; was undefined. The problem was that our proof uses the multiplicative inverse, and there is no multiplicative inverse of 0. Under our modified definition of division, we &lt;em&gt;still&lt;/em&gt; don’t have &lt;code&gt;0⁻&lt;/code&gt;, which means our proof &lt;em&gt;still&lt;/em&gt; does not work for dividing by zero. We still need the condition. So it is &lt;em&gt;not&lt;/em&gt; a theorem that &lt;code&gt;a * (b / 0) = b * (a / 0)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To be clear, this does &lt;em&gt;not&lt;/em&gt; mean they must be different! All we know is that we cannot use &lt;em&gt;this&lt;/em&gt; theorem to argue they &lt;em&gt;are&lt;/em&gt; equal. Since the “proof” that &lt;code&gt;1 = 0&lt;/code&gt; used that theorem, the proof is unsound.&lt;/p&gt;
&lt;p&gt;Pretty much every counterargument makes this exact same mistake: it assumes that because &lt;code&gt;1/0&lt;/code&gt; is now defined, there is now some &lt;code&gt;0⁻&lt;/code&gt; that generalizes our theorems. But there’s not.&lt;/p&gt;
&lt;p&gt;Another common objection is that if &lt;code&gt;1/0 = 1&lt;/code&gt;, then multiplicative inverses are no longer unique: &lt;code&gt;2/2 = 1&lt;/code&gt;, but also &lt;code&gt;2/0 = 1&lt;/code&gt;, so now 2 has two inverses. This, again, confuses cause and effect. &lt;code&gt;1/2&lt;/code&gt; is the inverse of 2 &lt;strong&gt;not&lt;/strong&gt; because of how we define inverses, but how we defined division. &lt;code&gt;2/2 = 1&lt;/code&gt; because &lt;code&gt;2/2 = 2 * 2⁻&lt;/code&gt;. But, again, zero does not have an inverse, and &lt;code&gt;2/0&lt;/code&gt; is not &lt;code&gt;2 * 0⁻&lt;/code&gt;. Since &lt;code&gt;0⁻&lt;/code&gt; does not exist, it is not an inverse of 2, and every nonzero number still has a unique inverse.&lt;/p&gt;
&lt;p&gt;If you want to prove that &lt;code&gt;1/0 = 1&lt;/code&gt; leads to a contradiction, you must explicitly list every step you take and show that none of them assume that &lt;code&gt;0⁻&lt;/code&gt; exists.&lt;/p&gt;
&lt;h2 id=&quot;1-0-0&quot;&gt;&lt;code&gt;1/0 = 0&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;We’ve now established that if we choose some constant &lt;code&gt;C&lt;/code&gt;, then defining division such that &lt;code&gt;x/0 = C&lt;/code&gt; does not lead to any inconsistencies. It turns out that for certain choices of C, specifically 0, we can make some theorems &lt;em&gt;stronger&lt;/em&gt;. We can do this by removing the conditions on (some of) our division theorems, and then add a special case to the proof itself. For example:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Theorem: &lt;code&gt;a * (b/c) = b * (a/c)&lt;/code&gt;. Proof: we already proved this for &lt;code&gt;c ≠ 0&lt;/code&gt;. Now let &lt;code&gt;c = 0&lt;/code&gt;. Then &lt;code&gt;a * (b/0) = a * 0 = 0&lt;/code&gt;, and &lt;code&gt;b * (a/0) = b * 0 = 0&lt;/code&gt;, and &lt;code&gt;0 = 0&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Under this definition of division step (3) in the counterargument above is now valid: we &lt;em&gt;can&lt;/em&gt; say that &lt;code&gt;1/0 * 0 = 1 * 0/0&lt;/code&gt;. However, in step (4) we say that &lt;code&gt;0/0 = 1&lt;/code&gt;. This theorem does not get stronger:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“Theorem”: &lt;code&gt;a/a = 1&lt;/code&gt;. Proof: we already proved this for &lt;code&gt;a ≠ 0&lt;/code&gt;. Now let &lt;code&gt;a = 0&lt;/code&gt;. Then &lt;code&gt;a/a = 0/0 = 0&lt;/code&gt;, so &lt;code&gt;1 = 0&lt;/code&gt; and wait shit nevermind&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;This is why Lean and Isabelle define &lt;code&gt;1/0&lt;/code&gt; this way. Coq does it too, but as far as I can tell they don’t use it as an optimization.&lt;/p&gt;
&lt;h2 id=&quot;the-real-mathematicians&quot;&gt;The Real Mathematicians&lt;/h2&gt;
&lt;p&gt;A final objection is that I’m a CS person, not a mathmatician, so I don’t understand the math here. But what do the PhDs say?&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2018-February/msg00128.html&quot;&gt;Lawrence Paulson&lt;/a&gt;, professor of computational logic and inventor of Isabelle:&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;A bit of history: the first logic supported within Isabelle was Martin-Löf’s constructive type theory, and it is still there (CTT). And while developing arithmetic within that formalisation, I came up with a definition (necessarily primitive recursive and executable) of division. It delivered n/0 = 0. Since then a number of people have noticed that defining x/0 = 0 is convenient. This identity holds in quite a few different proof assistants now.&lt;/p&gt;
&lt;p&gt;These things are conventions, exactly the same as announcing that x^-n = 1/x^n and that x^0 = 0.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://lamport.azurewebsites.net/pubs/lamport-types.pdf&quot;&gt;Leslie Lamport&lt;/a&gt;, Math PhD and winner of the 2013 Turing Award:&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;[In ZF set theory] Since 0 is not in the domain of &lt;em&gt;recip&lt;/em&gt;, we know nothing about the value of &lt;code&gt;1 / 0&lt;/code&gt;; it might equal &lt;code&gt;√2&lt;/code&gt;, it might equal R, or it might equal anything else.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://storm-country.com/blog/&quot;&gt;Matt Noonan&lt;/a&gt;, Math PhD and introducer of &lt;a href=&quot;http://kataskeue.com/gdp.pdf&quot;&gt;Ghost Proofs&lt;/a&gt; to Haskell:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;looks all fine to me!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Arthur Azevedo de Amorim, an author of the &lt;a href=&quot;https://softwarefoundations.cis.upenn.edu/&quot;&gt;introductory Coq textbook&lt;/a&gt;, reconstructs the same argument I did &lt;a href=&quot;https://stackoverflow.com/questions/29282819/coq-qarith-division-by-zero-is-zero-why/29286440#29286440&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I also chatted with a few math graduate student friends and emailed a couple of postdocs I know. So far people nobody’s said that letting &lt;code&gt;1/0 = 0&lt;/code&gt; is unsound. If any end up getting back to me with that I will include their refutation of this post.&lt;/p&gt;
&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;This was originally motivated by how Pony does division. So, is Pony doing the right thing here? No clue. Pony is a programming language, not a formal mathematical system. Consistency is less important than safety, convenience, and context. As a programmer, I don’t like it.&lt;/p&gt;
&lt;p&gt;But is Pony doing something unsound? Absolutely not. It is &lt;em&gt;totally fine&lt;/em&gt; to define &lt;code&gt;1/0 = 0&lt;/code&gt;. Nothing breaks and you can’t prove something false. Everybody who was making fun of Pony programmers for being ‘bad at math’ doesn’t actually understand the math behind it.&lt;/p&gt;
&lt;p&gt;Don’t make fun of other people. The world is big and we are small.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Thanks to Watson Ladd, &lt;a href=&quot;http://storm-country.com/blog/&quot;&gt;Matt Noonan&lt;/a&gt; , &lt;a href=&quot;https://pron.github.io/&quot;&gt;Ron Pressler&lt;/a&gt; , Josh Lieber, and Edwin Brady for feedback.&lt;/em&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 10 Aug 2018 19:19:24 +0000</pubDate>
<dc:creator>ingve</dc:creator>
<og:title>1/0 = 0 • Hillel Wayne</og:title>
<og:description>Have a tweet: I have no idea if Pony is making the right choice here, I don’t know Pony, and I don’t have any interest in learning Pony. But this tweet raised my hackles for two reasons: It’s pretty smug. I have very strong opinions about programming, but one rule I try to follow is do not mock other programmers.1 Programming is too big and I’m too small to understand everything.</og:description>
<og:url>https://www.hillelwayne.com/post/divide-by-zero/</og:url>
<og:type>article</og:type>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.hillelwayne.com/post/divide-by-zero/</dc:identifier>
</item>
<item>
<title>Introduction to OCaml</title>
<link>https://blog.baturin.org/introduction-to-ocaml.html</link>
<guid isPermaLink="true" >https://blog.baturin.org/introduction-to-ocaml.html</guid>
<description>&lt;footer class=&quot;post-info&quot; readability=&quot;14.294117647059&quot;&gt;&lt;abbr class=&quot;published&quot; title=&quot;2018-08-06T00:00:00+00:00&quot;&gt;Published: Mon 06 August 2018&lt;/abbr&gt;
&lt;address class=&quot;vcard author&quot;&gt;By &lt;a class=&quot;url fn&quot; href=&quot;https://blog.baturin.org/author/daniil-baturin.html&quot;&gt;Daniil Baturin&lt;/a&gt;&lt;/address&gt;
&lt;p&gt;In &lt;a href=&quot;https://blog.baturin.org/category/programming-languages.html&quot;&gt;Programming languages&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;tags: &lt;a href=&quot;https://blog.baturin.org/tag/ocaml.html&quot;&gt;ocaml&lt;/a&gt;&lt;/p&gt;
&lt;/footer&gt;
&lt;p&gt;This post series started as a response to requests from some friends curious about OCaml. There are quite a few nice books already, but I realized that if I just recommend them any one of those books, it still will leave me with quite a few things to explain in depth, or force me to recommend another just to learn about that part. So I thought I may as well write something that hopefully will allow a person who already knows how to program in some other language get started with writing OCaml programs and continue learning on their own and find their own sources.&lt;/p&gt;
&lt;p&gt;I decided to follow these principles:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Do not make it REPL-centric. Real life programs are not developed in the REPL. Include examples of complete programs.&lt;/li&gt;
&lt;li&gt;Do not introduce any concept before enough background is given to explain it without unjustified simplifications. Incomplete truth is better than a lie.&lt;/li&gt;
&lt;li&gt;Provide motivating examples and explain pathological cases.&lt;/li&gt;
&lt;li&gt;Do not mention foxes or chunky bacon.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Is OCaml hard to learn? Yes and no. It's easy to learn because it's not a “puzzle language” — its rules are generally hard and fast, and its syntax and semantics are predictable. However, it's also harder to learn than most popular languages because it uses ideas that are only starting to gain wide acceptance. It is not unlike the difference between the assembly languages and first structured programming languages.&lt;/p&gt;
&lt;p&gt;Why would one want to use it? Here are some points:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Very fast compiler. The reference implementation of OCaml can bootstrap itself within minutes.&lt;/li&gt;
&lt;li&gt;Static typing without a need to write any type annotations by hand.&lt;/li&gt;
&lt;li&gt;The type system is expressive enough to find some classes of logic errors, not just misplaced variables.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Its traditional domain is compiler writing and automated theorem proving systems. For example, &lt;a href=&quot;http://coq.inria.fr/&quot;&gt;Coq&lt;/a&gt; proof assistant, that was used to create the &lt;a href=&quot;http://compcert.inria.fr/&quot;&gt;first C compiler&lt;/a&gt; where all optimizations are mathematically proven correct, is written in it. The Rust compiler was written in OCaml until it was able to compile itself.&lt;/p&gt;
&lt;p&gt;More recently, it also started to be used by financial companies such as Jane Street and Lexifi for their automated trading software, and tools for cross-compiling it to JavaScript allowed using it for web applications. For example, the web version of Facebook Messenger was largely rewritten in OCaml with alternative syntax.&lt;/p&gt;

&lt;p&gt;OCaml itself is not new. It was first released as a distinct language in 1996, and even has one direct descendant — F#, that even includes syntax compatibility mode. However, the history of the ML language family is even longer and goes back to the 70's, and the theory that made those languages possible is even older yet, dating back to the 30's — it is called the lambda calculus.&lt;/p&gt;
&lt;p&gt;Here is a brief and simplified story.&lt;/p&gt;
&lt;p&gt;In the 30's, mathematicians took intense interest in the concept of computability. They could be called computer scientists even though general purpose computers didn't exist yet, and they were creating the foundations for their development. The main questions of the computability theory are what problems can be solved by algorithms, and how to reason about algorithms, for example, how and when can we find out if an algorithm always terminates. It required computation models, and multiple models were developed independently.&lt;/p&gt;
&lt;p&gt;Alan Turing developed the well known abstract machine that is now called Turing machine — an infinite length tape and a head that can read and write symbols to the tape cells. Independently, Alonzo Church and Haskell Curry found that it is possible to model arbitrary computations using nothing but functions — that was the lambda calculus. Then it was discovered that the two models are equally powerful.&lt;/p&gt;
&lt;p&gt;In the 40's, the lambda calculus was extended with a concept of types. Types were invented even before the lambda calculus, and long before computers, as an alternative to the set theory that would be free of its paradoxes (Bertrand Russel, who discovered a famous paradox, worked on type theory extensively). However, it took a while longer for the typed lambda calculi to take root in computers languages, and the first languages based on it were untyped.&lt;/p&gt;
&lt;p&gt;The Turing machine is roughly the model behind imperative languages such as C and Fortran. The first language closely related to the lambda calculus was Lisp developed by John McCarthy in 1958. For a while, all functional languages were untyped (or dynamically typed).&lt;/p&gt;
&lt;p&gt;However, in the 1970's, J. Roger Hindley and Robin Milner independently discovered a type system that allowed to unambiguously infer types of all expressions in a language without any type annotations. Then Milner et al. developed an algorithm for doing it efficiently, and created a programming language called ML (Meta Language) that was statically typed but made type annotations entirely optional, since it could infer all types and detect type errors on its own.&lt;/p&gt;
&lt;p&gt;Initially, ML was an embedded language of a theorem proving system, but later took a life of its own, and people (I need to research who did it first) discovered a way to extend it with mutable references and exception handling in a type safe manner at cost of a small restriction. Now it was suitable for general purpose programming.&lt;/p&gt;
&lt;p&gt;ML had multiple descendants, most of them research languages not intended for production use. Its type system was also incorporated into the family of programming languages that led to creation of Haskell, though whether Haskell belongs to the ML family or not is debatable.&lt;/p&gt;
&lt;p&gt;The original ML went through a process of standardization in the 1990's and its entire specification was mathematically proven to be consistent by Robert Harper et al., which is a truly outstanding result. However, its speficiation was not extended since 1997, and it's rarely used now, even though it remains fairly popular for teaching and a few theorem proving systems still use it. One notable modern project that uses it is &lt;a href=&quot;http://impredicative.com/ur/&quot;&gt;Ur/Web&lt;/a&gt;, a specialized programming language for web development.&lt;/p&gt;
&lt;p&gt;Another ML descendant called CAML remained under active development, and eventually evolved into OCaml we know today. Along with F#, it remains the most common ML in production use now.&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://blog.baturin.org/images/fp_genealogy.png&quot; width=&quot;650px&quot;/&gt;&lt;/div&gt;

&lt;p&gt;OCaml is probably unique in that its reference implementation includes all of native code compiler for multiple platforms, a bytecode compiler, and an interactive interpreter. Standalone program normally use the native code compiler, while the bytecode is only used on platforms not supported by it, With third-party tools, it can also be cross-compiled to JavaScript, and the tools are powerful enough to allow running OCaml itself in the web browser, you can find a real example of it at &lt;a href=&quot;https://try.ocamlpro.com/&quot;&gt;try.ocamlpro.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The implementation is licensed under GNU LGPL and is available from &lt;a href=&quot;https://ocaml.org&quot;&gt;ocaml.org&lt;/a&gt;. On UNIX-like systems, however, the fastest and most convenient way to install it is to use &lt;a href=&quot;https://opam.ocaml.org/doc/Install.html&quot;&gt;OPAM&lt;/a&gt;, the OCaml package manager. Unlike most similar tools such as Python's pip or Haskell's cabal, OPAM allows installing the compiler itself, keeping multiple compiler versions on the same machine, and switching between them, in addition to installing OCaml libraries.&lt;/p&gt;
&lt;p&gt;OPAM for Windows, however, is still under development, so I will not cover it yet.&lt;/p&gt;
&lt;p&gt;When you have OPAM installed, use the &lt;code&gt;opam switch&lt;/code&gt; command to install the compiler. At the time of writing, the latest version is 4.07, so the command will be: &lt;code&gt;opam switch 4.07&lt;/code&gt;. When it completes, you may want to run this command to setup the environment varibles without restarting your shell: &lt;code&gt;eval $(opam config env)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Once you are set, you can verify the installation by executing the three main programs: &lt;code&gt;ocamlc&lt;/code&gt; (the bytecode compiler), &lt;code&gt;ocamlopt&lt;/code&gt; (the native code compiler), and &lt;code&gt;ocaml&lt;/code&gt; (the interactive interpreter). The first two should exit without any output, the third one starts the interactive top level where you can enter expressions and have them evaluated — more on that later.&lt;/p&gt;

&lt;p&gt;The interactive interpreter allows you to enter expressions and have them evaluated. One thing you should note is that it uses double semicolon as an end of input mark, so you should terminate all expression with &lt;code&gt;;;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The default REPL is quite minimalist and doesn't even support command history. You can either alleviate the issue with rlwrap, or, better, install &lt;code&gt;utop&lt;/code&gt; from OPAM (&lt;code&gt;opam install utop&lt;/code&gt;). It is an alternative REPL that supports history, completion, and more.&lt;/p&gt;
&lt;p&gt;While the examples here tend to be compiler-centric, you should not neglect the REPL. First, it's the quickest way to find out the type of any function without even opening the documentation: just type something like &lt;code&gt;print_endline ;;&lt;/code&gt; and you'll see the type. Second, any valid OCaml program can pasted into the REPL or its file can be loaded into it with &lt;code&gt;#use &quot;somefile.ml&quot;;;&lt;/code&gt; directive. It is even possible to run OCaml programs in the same fashion as Python or Ruby scripts with &lt;code&gt;ocaml file.ml&lt;/code&gt;. It is also possible to load compiled libraries into the REPL, but we'll not discuss that part now.&lt;/p&gt;

&lt;h2&gt;The structure of OCaml programs&lt;/h2&gt;
&lt;p&gt;An OCaml program, loosely speaking, is a sequence of expressions evaluated from top to bottom. There is no designated main function. There are also no statements in OCaml, everything is an expression, all expressions have values, and all values have types.&lt;/p&gt;
&lt;p&gt;This is an absolutely useless but valid OCaml program:&lt;/p&gt;

&lt;p&gt;You can save it to file, for example &lt;code&gt;one.ml&lt;/code&gt; and compile it with &lt;code&gt;ocamlopt -o one ./one.ml&lt;/code&gt;. The executable it produces will exit immediately. What happens there? It's a program with a single expression, &lt;code&gt;1&lt;/code&gt;, which is a constant of type &lt;code&gt;int&lt;/code&gt;. Constants evaluate to themselves, so this program evaluates &lt;code&gt;1&lt;/code&gt;, which produces no effects, and exits, since it has nothing else to do.&lt;/p&gt;
&lt;p&gt;A constant is an example of a &lt;em&gt;pure&lt;/em&gt; expression. It produces no &lt;em&gt;side effects&lt;/em&gt; such as input/output, and it stays the same no matter how many times it's evaluated. An expression can also be &lt;em&gt;impure&lt;/em&gt;, if they produce side effects, or evaluate to a different value if you evaluate it more than once (like a function for getting current system time, for example).&lt;/p&gt;
&lt;h2&gt;Constants and types&lt;/h2&gt;
&lt;p&gt;So, integer literal &lt;code&gt;1&lt;/code&gt; is a constant of type &lt;code&gt;int&lt;/code&gt;. Let's look at some other kinds of constants we can use:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;4.0&lt;/code&gt;, &lt;code&gt;3.5&lt;/code&gt;, &lt;code&gt;1.&lt;/code&gt; — floating point literals have type &lt;code&gt;float&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'c'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt; — character literals have type &lt;code&gt;char&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;foo&quot;&lt;/code&gt;, &lt;code&gt;&quot;bar\n&quot;&lt;/code&gt; — string literals have type &lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; — boolean literals have type &lt;code&gt;bool&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;This list is not complete, but it's enough for the start.&lt;/p&gt;
&lt;h2&gt;Function application and Hello World&lt;/h2&gt;
&lt;p&gt;Now let's write a slightly less useless program, the traditional “hello world”. For this we'll need to use a function. The standard library function that prints a string with a newline at the end is &lt;code&gt;print_endline&lt;/code&gt;, there's also &lt;code&gt;print_string&lt;/code&gt; function that doesn't add a line break.&lt;/p&gt;
&lt;p&gt;The syntax for function application is very simple: function name followed by its arguments. You need no parentheses or any other special syntax.&lt;/p&gt;
&lt;p&gt;This is the Hello World program:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
print_endline &quot;hello world&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now compile it and try it out:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ ocamlopt -o hello ./hello.ml 

$ ./hello
hello world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the sake of experiment, you can try applying the &lt;code&gt;print_endline&lt;/code&gt; function to a non-string constant and get your first type error:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
$ cat hello.ml 
print_endline &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;

$ ocamlopt -o hello ./hello.ml 
File &lt;span class=&quot;s2&quot;&gt;&quot;./test.ml&quot;&lt;/span&gt;, line &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;, characters &lt;span class=&quot;m&quot;&gt;14&lt;/span&gt;-15:
Error: This expression has &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt; int but an expression was expected of &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;
         string
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is type inference in action: the compiler inferred the type of &lt;code&gt;1&lt;/code&gt; as &lt;code&gt;int&lt;/code&gt;, checked the type of the &lt;code&gt;print_endline&lt;/code&gt; function, and found that it expects a string. How it knows that &lt;code&gt;int&lt;/code&gt; is a wrong type to use with &lt;code&gt;print_endline&lt;/code&gt; though? By checking it against the type of that function.&lt;/p&gt;
&lt;h2&gt;The type of functions and the unit type&lt;/h2&gt;
&lt;p&gt;In OCaml, like in any functional language, functions themselves are values. If functions are values, they must also have types. By typing &lt;code&gt;print_endline;;&lt;/code&gt; in the REPL you can see that its type is &lt;code&gt;string -&amp;gt; unit&lt;/code&gt;. The arrow signifies that it's a function from a type named &lt;code&gt;string&lt;/code&gt; to another type named &lt;code&gt;unit&lt;/code&gt;. When the compiler encountered the &lt;code&gt;print_endline 1&lt;/code&gt; expression, it knew that the type of &lt;code&gt;1&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt; rather than &lt;code&gt;string&lt;/code&gt;, and from the type of &lt;code&gt;print_endline&lt;/code&gt; it knew that its argument must be &lt;code&gt;string&lt;/code&gt;, so it was able to detect the type error.&lt;/p&gt;
&lt;p&gt;Now let's examine the “return type” of that function on the right hand side of the arrow. We are already familiar with &lt;code&gt;string&lt;/code&gt;, but the &lt;code&gt;unit&lt;/code&gt; is new. What is it and why it's needed?&lt;/p&gt;
&lt;p&gt;As you remember, all expressions have types, so when &lt;code&gt;print_endline &quot;hello world&quot;&lt;/code&gt; is evaluated, the result of evaluation must have some type. A function in OCaml cannot “return nothing”. Since many functions are used just for their side effects and cannot produce any useful values, some type must have been invented just to have them comply with the “all values have types” rules.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;unit&lt;/code&gt; type is a type that has only one value, and it was invented specially for this purpose. Its only possible value is a constant written &lt;code&gt;()&lt;/code&gt;. Whether it was made to look this way to mimic calling functions without arguments in other languages is debatable, you should just remember that the constant &lt;code&gt;()&lt;/code&gt; has type &lt;code&gt;unit&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The unit type is also used for functions that take no useful arguments, but have to take something because in OCaml a function cannot have no arguments either. The “arrow type” must always have both left and right hand sides.&lt;/p&gt;
&lt;p&gt;An example of a function with &lt;code&gt;unit -&amp;gt; unit&lt;/code&gt; type is &lt;code&gt;print_newline&lt;/code&gt; that just prints a line break. A program that prints a line break thus can be written as:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre&gt;
print_newline ()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Programs with multiple expressions and variables&lt;/h2&gt;
&lt;p&gt;So far we have only written programs that consist of a single expression. Let's see how to introduce variables and how to use multiple expressions — in OCaml these concepts are related.&lt;/p&gt;
&lt;p&gt;To create a variable, you &lt;em&gt;bind&lt;/em&gt; a value to a name. They are variables in mathematical sense, their value generally cannot change, even though the same name can be bound to a different value in a different scope. Variables are also called &lt;em&gt;bindings&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Bindings are created with the &lt;code&gt;let&lt;/code&gt; keyword. There are two ways to use &lt;code&gt;let&lt;/code&gt;-bindings: one allows you to make a binding accessible only to one expression that follows it (&lt;code&gt;let &amp;lt;name&amp;gt; = &amp;lt;value&amp;gt; in &amp;lt;expr&amp;gt;&lt;/code&gt;), while the other (&lt;code&gt;let &amp;lt;name&amp;gt; = &amp;lt;value&amp;gt;&lt;/code&gt;) makes a binding accessible to all expressions below it. This is not a standard OCaml terminology, but for convenience let's call them &lt;em&gt;local&lt;/em&gt; and &lt;em&gt;global&lt;/em&gt; bindings respectively.&lt;/p&gt;
&lt;p&gt;Let's rewrite the Hello World program with a local binding:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
$ cat ./test.ml 
&lt;span class=&quot;nb&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hello world&quot;&lt;/span&gt; in print_endline hello

$ ocamlopt -o &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; ./test.ml 

$ ./test 
hello world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We could also use two bindings instead of one to demonstrate that &lt;code&gt;let ... in&lt;/code&gt; constructs can be nested:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
let hello = &quot;hello &quot; in
let world = &quot;world&quot; in
print_endline (hello ^ world)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;^&lt;/code&gt; operator here is string concatenation. What happens here? Earlier I said that in the &lt;code&gt;let ... in&lt;/code&gt; form, the binding will only be available to the expression that follows the &lt;code&gt;in&lt;/code&gt; keyword, but remember that &lt;code&gt;let&lt;/code&gt;-bindings are themselves expressions, and they can be chained. Every &lt;code&gt;let&lt;/code&gt;-binding opens a new scope. Here we first create a scope where the name &lt;code&gt;hello&lt;/code&gt; is bound to a string constant &lt;code&gt;&quot;hello &quot;&lt;/code&gt;, then inside it we create a scope where the name &lt;code&gt;world&lt;/code&gt; is bound to a string constant &lt;code&gt;&quot;world&quot;&lt;/code&gt;, and in that scope, evaluate the &lt;code&gt;print_endline (hello ^ world)&lt;/code&gt; expression.&lt;/p&gt;
&lt;p&gt;Now let's try global bindings. Before we can try them, we need to learn how to use multiple expressions in our programs. You might have already noticed that we have not used a semicolon or another statement terminator. Simply writing:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
print_endline hello
print_endline world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;will not work because it will be parsed by the compiler as an attempt to apply the &lt;code&gt;print_endline&lt;/code&gt; function to three arguments, of which the first is a string, the second if a function, and the third is string again; and this will fail because the type of &lt;code&gt;print_endline&lt;/code&gt; is &lt;code&gt;string -&amp;gt; unit&lt;/code&gt;. In the example above we avoided the issue by applying &lt;code&gt;print_endline&lt;/code&gt; to another expression in parentheses, but this isn't always feasible.&lt;/p&gt;
&lt;p&gt;How do we make a program with multiple independent expressions parse correctly then? It's time to learn a secret of &lt;code&gt;let&lt;/code&gt;: its left hand side is not just a name, but a &lt;em&gt;pattern&lt;/em&gt;. Patterns have multiple uses and forms, which we will explore later. For now, you need to know that a name is a pattern. Another possible pattern is the &lt;em&gt;wildcard pattern&lt;/em&gt; written &lt;code&gt;_&lt;/code&gt;, which comes in handy when you need to have an expression evaluated, but don't want to bind its value to any name.&lt;/p&gt;
&lt;p&gt;To create independent expressions you can make “fake” bindings with wildcard patterns:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
let hello = &quot;hello &quot;
let world = &quot;world&quot;

let _ = print_string hello
let _ = print_endline world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A constant is also a valid pattern. As you remember, the type of &lt;code&gt;print_endline&lt;/code&gt; is &lt;code&gt;string -&amp;gt; unit&lt;/code&gt;, so it always evaluates to the &lt;code&gt;()&lt;/code&gt; constant. Thus you can also write:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
let () = print_string hello
let () = print_endline world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this case you need to watch that the constant pattern on the left hand side and the expression on the right hand side have the same type, but when you start using more complex expressions, this can also serve as a useful safeguard against accidentally using an expression of a non-unit type on the right hand side. While the wildcard pattern accepts values of any types in the &lt;code&gt;let&lt;/code&gt;-binding context, a constant pattern, such as &lt;code&gt;()&lt;/code&gt;, will force type checking. The choice whether to use this or not is up to the programmer.&lt;/p&gt;
&lt;p&gt;Finally, if you have multiple expressions of the &lt;code&gt;unit&lt;/code&gt; type, you can chain them using semicolons. In OCaml, the semicolon is an &lt;em&gt;expression separator&lt;/em&gt; rather than a statement terminator, so you will need at least one wildcard binding to use it though:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
let helloworld = &quot;hello world&quot;

let _ = print_string helloworld; print_newline ()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you try this with expressions of types other than &lt;code&gt;unit&lt;/code&gt;, the compiler will produce a warning. To supress the warning, you can apply the &lt;code&gt;ignore&lt;/code&gt; function to your expression, as in:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
let _ = ignore 1; print_endline &quot;hello world&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, you can also use &lt;code&gt;;;&lt;/code&gt; like in the REPL, but it's a very bad style and should be avoided whenever possible.&lt;/p&gt;
&lt;h3&gt;Shadowing&lt;/h3&gt;
&lt;p&gt;As you remember, every new binding opens a new scope. We can illustrate it like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;c&quot;&gt;(* Scope 0 *)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hello &quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;(* Opens scope 1 *)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;(* Scope 1 *)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;world&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;world&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;(* Opens scope 2 *)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;(* Scope 2, (hello = &quot;hello &quot;, world = &quot;world&quot;) *)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print_endline&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;world&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let's stop and think what happens if we make two bindings with the same name.&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;c&quot;&gt;(* Scope 0 *)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;(* Scope 1 *)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hi&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;(* Scope 2 *)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print_endline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you compile this program and run it, you'll see that it prints &lt;code&gt;hi&lt;/code&gt;. This is because the second binding redefined the value of &lt;code&gt;hello&lt;/code&gt; in the scope 2. This is called &lt;em&gt;shadowing&lt;/em&gt;. It is distinct from variable assignment. The original value of &lt;code&gt;hello&lt;/code&gt; did not change, it just becomes inaccessible from the new scope where it was redefined. Is the original value of &lt;code&gt;hello&lt;/code&gt; lost forever? In the example above, yes, it will be completely inaccessible. In general case, the question is more interesting, but we will lean about it later when we get to functions and closures.&lt;/p&gt;
&lt;p&gt;The case when difference from variable assignment is especially visible is the &lt;code&gt;let ... in&lt;/code&gt; bindings. It is perfectly safe to redefine a binding locally and it will have no effect on the rest of the program.&lt;/p&gt;
&lt;p&gt;Consider this program:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;c&quot;&gt;(* Scope 0 *)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hello &quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;world&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* Local scope 1 *)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_endline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;(* Back to scope 0 *)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print_endline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It will print &lt;code&gt;hello world&lt;/code&gt;, and then print &lt;code&gt;hello&lt;/code&gt;, because our &lt;code&gt;let ... in&lt;/code&gt; binding only redefined the &lt;code&gt;hello&lt;/code&gt; variable for the &lt;code&gt;print_endline hello&lt;/code&gt; expression.&lt;/p&gt;
&lt;h2&gt;Arithmetics&lt;/h2&gt;
&lt;p&gt;Now that we know how to use expressions and bindings and have basic idea of how function types work, we can look at the arithmetics.&lt;/p&gt;
&lt;p&gt;As we've seen earlier, integer and floating point numbers are distinct types in OCaml. The character type is not a numeric type and cannot be used in arithmetic expressions.&lt;/p&gt;
&lt;p&gt;An unusual feature of OCaml is that it also uses different sets of arithmetic functions for integers and floating point numbers. The reason for it is that otherwise the language would require either support for ad hoc polymorphism, which would ruin the decidable type inference without any type annotations; or magical overloading specially for arithmetics. The language designers sacrificed some convenience for consistency.&lt;/p&gt;
&lt;p&gt;The integer operators look as usual: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;. The floating point operators have a dot at the end: &lt;code&gt;+.&lt;/code&gt;, &lt;code&gt;-.&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/.&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
let a = 4 + 2 (* good *)
let b = 4.0 *. 3.5 (* good *)

let c = (float 4) +. 2. (* good, integer is converted to float *)

let d = 4.0 + 2.0 (* bad, using an integer addition with floats *)
let e = 4 +. 2 (* bad using a floating point addition with integers *)
let f = 4.0 + 2 (* bad, mixing floats with integers *)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let's write a program that takes temperature in Celsius from the standard input and converts it to Kelvin.&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
let celsius = read_float ()

let kelvin = celsius +. 273.15

let _ = print_float kelvin; print_newline ()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's verify that it works:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ ocamlopt -o kelvin ./kelvin.ml 

$ ./kelvin
&lt;span class=&quot;m&quot;&gt;20&lt;/span&gt;
&lt;span class=&quot;m&quot;&gt;293&lt;/span&gt;.15
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Write a program that takes an integer from the standard input and prints its square. Use &lt;code&gt;read_int&lt;/code&gt; function for reading and &lt;code&gt;print_int&lt;/code&gt; for writing.&lt;/p&gt;
&lt;p&gt;Write a program that takes a floating point number representing temperature in Celsius from the standard input and converts it to Fahrenheit.&lt;/p&gt;
&lt;p&gt;Continue to the &lt;a href=&quot;https://blog.baturin.org/introduction-to-ocaml-part-2.html&quot;&gt;part 2&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>Fri, 10 Aug 2018 18:09:55 +0000</pubDate>
<dc:creator>jxub</dc:creator>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://blog.baturin.org/introduction-to-ocaml.html</dc:identifier>
</item>
<item>
<title>You Cannot Serve Two Masters: The Harms of Dual Affiliation</title>
<link>http://www.argmin.net/2018/08/09/co-employment/</link>
<guid isPermaLink="true" >http://www.argmin.net/2018/08/09/co-employment/</guid>
<description>&lt;p&gt;Facebook would like to have computer science faculty in AI committed to work 80% of their time in industrial jobs and 20% of their time at their university. They call this scheme “&lt;a href=&quot;https://newsroom.fb.com/news/2018/07/facebook-ai-research-expands/&quot;&gt;co-employment&lt;/a&gt;” or “&lt;a href=&quot;https://www.facebook.com/schrep/posts/10156638732909443&quot;&gt;dual&lt;/a&gt; &lt;a href=&quot;https://www.businessinsider.com/facebook-yann-lecun-dual-affiliation-model-ai-experts-2018-8&quot;&gt;affiliation&lt;/a&gt;.” This model assumes people can slice their time and attention like a computer, but people can’t do this. Universities and companies are communities, each with their particular missions and values. The values of these communities are often at odds, and researchers must choose where their main commitment lies. By committing researchers to a particular company’s interests, this new model of employment will harm our colleagues, our discipline, and everyone’s future. Like many harms, it comes with benefits for some. But the harm in this proposal outweighs the benefits. If industry wants to support and grow academic computer science, there are much better ways to achieve this.&lt;/p&gt;&lt;p&gt;The proposal will harm our discipline, because it will distract established talent from the special roles of academics: curiosity driven research. Academic scholarship has an excellent record of pursuing ideas into places that are exciting and productive, even if they don’t result in immediate, tangible benefits and especially if they ruffle the feathers of established, powerful institutions. You can’t do that if 80% of your time is spent not annoying a big company. Though big companies belabor promises of complete intellectual freedom to faculty, that can’t and won’t happen because the purpose of companies is to make money for shareholders.&lt;/p&gt;
&lt;p&gt;The proposal harms our students directly. Our faculty at their best secure everyone’s future by teaching talented students how to understand the challenges facing the broader world. Such mentorship is enriched by the courage, independence, security, and trained judgement of senior scholars to guide students’ perspectives on what is worth doing, what is likely irrelevant, and what is wrong. Engaging with a student body requires an all-in commitment, both in teaching and advising roles. Faculty primarily working elsewhere means cancelled classes. Faculty wedded to a company means advice that’s colored by the interest of the company.&lt;/p&gt;
&lt;p&gt;The proposal harms our future because it will stifle innovation. University researchers have a great historical record of disruptive entrepreneurism — for example, Google dates back to a paper from the Stanford digital library project. Smooth transitions from academic research to industrial practice are widely encouraged: most universities allow faculty to consult at 20% time, do year-long sabbaticals in industry, or take leave to start companies in order to promote such transitions. But there’s a big difference between an industrial leave and a long-term commitment. You can’t do disruptive entrepreneurism if 80% of what you do is owned by a big company. Part of the point of being a big company is to control your environment by crushing, containing, or co-opting inconvenient innovations. Faculty who sign on are subject to a huge gravitational force and are &lt;a href=&quot;https://newsroom.fb.com/news/2017/12/hard-questions-is-spending-time-on-social-media-bad-for-us/&quot;&gt;hard pressed not to annoy the big company they work for&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Like many really dangerous bargains, the harms are diffuse, and the benefits are focused. One kind of benefit is for faculty who sign on: in addition to the higher industrial salaries, working at a big company provides a chance to lead a team of research engineers to execute large-scale projects that may be used by millions. But another, more alarming, benefit is for big companies: all those potentially disruptive or potentially annoying ideas are now owned or controlled by the big company. Perhaps that’s &lt;del&gt;the point of&lt;/del&gt; why management supports the proposal.&lt;/p&gt;
&lt;p&gt;If industry really wants to help scale and advance computer science research, it’s easy to do. Do what many companies are already doing, but do much more of it. Give fellowships to graduate students and scholarships to undergraduate students. Employ students as interns. Pay for named chairs and new buildings. Give lots of faculty small amounts of research money. Make and publish open datasets. Give us easy access to industrial scale computing resources. But don’t raid our faculty and tell us it’s good for us.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;We have made a small edit to clear up a misunderstanding raised by a colleague. We have noted this change with strikethrough. Though comments are closed, you can follow the discussion on &lt;a href=&quot;https://twitter.com/beenwrekt/status/1027915117076336640&quot;&gt;Twitter&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/MachineLearning/comments/963pek/r_you_cannot_serve_two_masters_the_harms_of_dual/&quot;&gt;Reddit&lt;/a&gt; and &lt;a href=&quot;https://news.ycombinator.com/item?id=17734877&quot;&gt;Hacker News&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 Aug 2018 16:45:44 +0000</pubDate>
<dc:creator>stochastician</dc:creator>
<og:type>article</og:type>
<og:title>You Cannot Serve Two Masters: The Harms of Dual Affiliation</og:title>
<og:description>Musings on systems, information, learning, and optimization.</og:description>
<og:url>http://benjamin-recht.github.io/2018/08/09/co-employment/</og:url>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.argmin.net/2018/08/09/co-employment/</dc:identifier>
</item>
<item>
<title>Show HN: Ultralight – Lightweight, Pure-GPU HTML UI Renderer for C++</title>
<link>https://ultralig.ht</link>
<guid isPermaLink="true" >https://ultralig.ht</guid>
<description>&lt;div readability=&quot;34&quot;&gt;
&lt;h3 class=&quot;bold primary-color launchaco-builder-hoverable&quot;&gt;Ultra-light&lt;/h3&gt;
&lt;p class=&quot;paragraph secondary-color launchaco-builder-hoverable&quot;&gt;Only 8MB compressed, low memory usage, we've stripped WebKit to the bare essentials.&lt;/p&gt;
&lt;/div&gt;&lt;div readability=&quot;35&quot;&gt;&lt;em class=&quot;icon mobile-center-icon secondary-bg launchaco-builder-hoverable&quot;/&gt;
&lt;h3 class=&quot;bold primary-color launchaco-builder-hoverable&quot;&gt;Ultra-fast&lt;/h3&gt;
&lt;p class=&quot;paragraph secondary-color launchaco-builder-hoverable&quot;&gt;GPU-Accelerated, drivers for Direct3D, Metal, and OpenGL. Optimized for games.&lt;/p&gt;
&lt;/div&gt;&lt;div readability=&quot;35&quot;&gt;&lt;em class=&quot;icon mobile-center-icon secondary-bg launchaco-builder-hoverable&quot;/&gt;
&lt;h3 class=&quot;bold primary-color launchaco-builder-hoverable&quot;&gt;Cross-platform&lt;/h3&gt;
&lt;p class=&quot;paragraph secondary-color launchaco-builder-hoverable&quot;&gt;Write once, deploy to multiple platforms. Windows, macOS, and coming soon to Linux.&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 10 Aug 2018 14:28:20 +0000</pubDate>
<dc:creator>adamjs</dc:creator>
<og:image></og:image>
<dc:format>text/html</dc:format>
<dc:identifier>https://ultralig.ht/</dc:identifier>
</item>
<item>
<title>Google Boots Open-Source Anti-Censorship Tool &quot;Ahoy&quot; from Chrome Store</title>
<link>https://torrentfreak.com/google-boots-open-source-anti-censorship-tool-from-chrome-store-180810/</link>
<guid isPermaLink="true" >https://torrentfreak.com/google-boots-open-source-anti-censorship-tool-from-chrome-store-180810/</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://torrentfreak.com/images/censored.jpg&quot;&gt;&lt;img src=&quot;https://torrentfreak.com/images/censored.jpg&quot; alt=&quot;&quot; width=&quot;199&quot; height=&quot;173&quot; class=&quot;alignright size-full wp-image-35000&quot;/&gt;&lt;/a&gt;Last December, TF reported on &lt;a href=&quot;https://sitesbloqueados.pt/&quot;&gt;SitesBloqueados&lt;/a&gt; (Blocked Sites) a web portal run by Revolução dos Bytes (Bytes’ Revolution), a group of anti-censorship activists in Portugal.&lt;/p&gt;
&lt;p&gt;Internet censorship is common in the country, with more than 1,700 sites banned from regular Internet access for reasons ranging from copyright to gambling. The process does not require intervention from the courts so Revolução dos Bytes decided to keep an eye on things with its Ahoy! Chrome and Firefox extension.&lt;/p&gt;
&lt;p&gt;“Ahoy! basically bypasses any traffic to a blocked site through our own proxies, allowing the users to navigate in a free, uncensored internet,” team member Henrique Mouta &lt;a href=&quot;https://torrentfreak.com/massive-site-blocking-measures-countered-by-100k-browser-addon-users-171231/&quot;&gt;previously told TF&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Not only is Ahoy! able to unblock sites, it can also detect newly blocked domains and feed information back, so that its unblocking abilities are always up to date.&lt;/p&gt;
&lt;p&gt;Things had been going well. After servicing 100,000 users last December, Ahoy! grew to almost 185,000 users this year. However, progress and indeed the project itself is now under threat after arbitrary action by Google.&lt;/p&gt;
&lt;p&gt;“Google decided to remove us from Chrome’s Web Store without any justification”, Henrique informs TF.&lt;/p&gt;
&lt;p&gt;“We always make sure our code is high quality, secure and 100% free (as in beer and as in freedom). All the source code is open source. And we’re pretty sure we never broke any of the Google’s marketplace rules.”&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;Users being to plumment after Google takedown&lt;/strong&gt;&lt;/center&gt;
&lt;center&gt;&lt;a href=&quot;https://torrentfreak.com/images/u0uiqvk4-e1533885511495.bmp&quot;&gt;&lt;img src=&quot;https://torrentfreak.com/images/u0uiqvk4-e1533885511495.bmp&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;135&quot; class=&quot;aligncenter size-full wp-image-159711&quot;/&gt;&lt;/a&gt;&lt;/center&gt;
&lt;p&gt;Henrique says he’s tried to reach out to Google but finding someone to help has proven impossible. Even re-submitting Ahoy! to Google from scratch hasn’t helped the situation.&lt;/p&gt;
&lt;p&gt;“I tried and resubmitted the plugin but it was refused after a few hours and without any justification,” Henrique says.&lt;/p&gt;
&lt;p&gt;“Google never reached us or notified us about the removal from Chrome Web Store. We never got a single email justifying what happened, why have we been removed from the store, or/and what are we breaching and how can we fix it.”&lt;/p&gt;
&lt;p&gt;TorrentFreak reached out to Google asking why this anti-censorship tool has been removed from its Chrome store. Despite multiple requests, the search giant failed to respond to us or the Ahoy! team.&lt;/p&gt;
&lt;p&gt;The negative effect on the project following removal by Google has been swift. Before the takedown, Ahoy! had around 185,000 users with around 500 installations per day. That progress has now been reversed.&lt;/p&gt;
&lt;p&gt;“Right now, we have 174k active users on Chrome, quickly dropping (around 500 each day). We are being contacted every day by our users asking where they can now download the Chrome version, and asking what happened. I can tell you that we’ve noticed a web traffic drop on our API of about ~25%,” Henrique says.&lt;/p&gt;
&lt;p&gt;Whatever problem Google has with the Chrome version of Ahoy!, the same cannot be said of its Firefox variant. The extension is &lt;a href=&quot;https://addons.mozilla.org/pt-PT/firefox/addon/ahoy/?src=recommended&quot;&gt;living happily&lt;/a&gt; on that platform and no ToS breach has been advised.&lt;/p&gt;
&lt;p&gt;That seems to suggest the team has done little wrong but with Google refusing to provide an explanation, they have no chance of fixing an issue, if one exists.&lt;/p&gt;
&lt;p&gt;“The source code is 100% &lt;a href=&quot;https://github.com/revolucaodosbytes/ahoy-chrome&quot;&gt;open source&lt;/a&gt;, so it’s easy to see that we’re not doing anything sketchy, we really care about our users’ privacy and security. If we’re doing something wrong, we don’t know what,” Henrique complains.&lt;/p&gt;
&lt;p&gt;The issue is critical, not least since 98% of Ahoy! users access it via Chrome. So, until Google provides some kind of explanation, Chrome users will have to install the extension manually via a &lt;a href=&quot;https://download.ahoy.pro/&quot;&gt;new site&lt;/a&gt; set up for the purpose.&lt;/p&gt;
&lt;p&gt;“We have many users asking what happened and how can they download this extension [from the Chrome Store] and I have no answers for them. We’re losing our user base every day, and if we don’t find a solution our project will probably die,” Henrique concludes.&lt;/p&gt;
</description>
<pubDate>Fri, 10 Aug 2018 14:09:49 +0000</pubDate>
<dc:creator>davidgerard</dc:creator>
<og:type>article</og:type>
<og:title>Google Boots Open Source Anti-Censorship Tool From Chrome Store - TorrentFreak</og:title>
<og:description>A browser extension that acted as an anti-censorship tool for 185,000 people has been kicked out of the Chrome store by Google. The open source Ahoy! tool facilitated access to more than 1,700 blocked sites but is now under threat. Despite several requests, Google has provided no reason for its decision.</og:description>
<og:url>https://torrentfreak.com/google-boots-open-source-anti-censorship-tool-from-chrome-store-180810/</og:url>
<og:image>https://torrentfreak.com/images/censorship3.jpg</og:image>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://torrentfreak.com/google-boots-open-source-anti-censorship-tool-from-chrome-store-180810/</dc:identifier>
</item>
<item>
<title>Ending support for Dropbox syncing to drives with certain uncommon file systems</title>
<link>https://www.dropboxforum.com/t5/Syncing-and-uploads/Linux-Dropbox-client-warn-me-that-it-ll-stop-syncing-in-Nov-why/m-p/290065/highlight/true#M42255</link>
<guid isPermaLink="true" >https://www.dropboxforum.com/t5/Syncing-and-uploads/Linux-Dropbox-client-warn-me-that-it-ll-stop-syncing-in-Nov-why/m-p/290065/highlight/true#M42255</guid>
<description>&lt;div class=&quot;lia-message-body-content&quot; readability=&quot;66.761194029851&quot;&gt;
&lt;p&gt;I'm sorry, but this is NOT acceptable! Is Dropbox trying to get rid of the users from Linux community completely? There have been many bad decisions in the past, and this just top of the iceberg...&lt;/p&gt;&lt;p&gt;Why the f*ck only EXT4 is suddenly supported on Linux? Just because of extended attributes? That's a lot of horse BS:&lt;br/&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_file_attributes#Linux&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Extended_file_attributes#Linux&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&quot;In &lt;a title=&quot;Linux&quot; href=&quot;https://en.wikipedia.org/wiki/Linux&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Linux&lt;/a&gt;, the &lt;a title=&quot;Ext2&quot; href=&quot;https://en.wikipedia.org/wiki/Ext2&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;ext2&lt;/a&gt;, &lt;a title=&quot;Ext3&quot; href=&quot;https://en.wikipedia.org/wiki/Ext3&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;ext3&lt;/a&gt;, &lt;a title=&quot;Ext4&quot; href=&quot;https://en.wikipedia.org/wiki/Ext4&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;ext4&lt;/a&gt;, &lt;a title=&quot;JFS (file system)&quot; href=&quot;https://en.wikipedia.org/wiki/JFS_(file_system)&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;JFS&lt;/a&gt;, &lt;a title=&quot;Squashfs&quot; href=&quot;https://en.wikipedia.org/wiki/Squashfs&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Squashfs&lt;/a&gt;, &lt;a title=&quot;YAFFS&quot; href=&quot;https://en.wikipedia.org/wiki/YAFFS&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Yaffs2&lt;/a&gt;, &lt;a title=&quot;ReiserFS&quot; href=&quot;https://en.wikipedia.org/wiki/ReiserFS&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;ReiserFS&lt;/a&gt;, &lt;a title=&quot;Reiser4&quot; href=&quot;https://en.wikipedia.org/wiki/Reiser4&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Reiser4&lt;/a&gt;, &lt;a title=&quot;XFS&quot; href=&quot;https://en.wikipedia.org/wiki/XFS&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;XFS&lt;/a&gt;, &lt;a title=&quot;Btrfs&quot; href=&quot;https://en.wikipedia.org/wiki/Btrfs&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Btrfs&lt;/a&gt;, &lt;a title=&quot;OrangeFS&quot; href=&quot;https://en.wikipedia.org/wiki/OrangeFS&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;OrangeFS&lt;/a&gt;, &lt;a title=&quot;Lustre (file system)&quot; href=&quot;https://en.wikipedia.org/wiki/Lustre_(file_system)&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Lustre&lt;/a&gt;, &lt;a title=&quot;OCFS2&quot; href=&quot;https://en.wikipedia.org/wiki/OCFS2&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;OCFS2 1.6&lt;/a&gt; and &lt;a title=&quot;F2FS&quot; href=&quot;https://en.wikipedia.org/wiki/F2FS&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;F2FS&lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_file_attributes#cite_note-8&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;[8]&lt;/a&gt; filesystems support extended attributes (abbreviated &lt;em&gt;xattr&lt;/em&gt;) when enabled in the kernel configuration&quot;&lt;/p&gt;
&lt;p&gt;Yes, I'm running LUKS encryption on top of my BTRFS partition, where I have my Dropbox folder. And I still don't see a valid and a proper reason why this configuration shouldn't work.&lt;/p&gt;&lt;p&gt;I'm definitely not gonna re-format my whole Linux just because of Dropbox - there are reasons why I'm on BTRFS. I'd like to hear some proper engineering explanation why suddenly xattr is required now and why only ext4 is supported. Because I really don't think there's any. This just seems like a lot of product/marketing  crap. There are reasons why VFS exists in Linux...&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_file_system&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Virtual_file_system&lt;/a&gt;&lt;/p&gt;&lt;p&gt;From the xattr(7) man page:&lt;/p&gt;

&lt;pre&gt;
       In the Btrfs, XFS, and Reiserfs filesystem implementations, there is
       no practical limit on the number of extended attributes associated
       with a file, and the algorithms used to store extended attribute
       information on disk are scalable. 
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 10 Aug 2018 13:14:09 +0000</pubDate>
<dc:creator>ronjouch</dc:creator>
<og:image>https://mxpez29397.i.lithium.com/t5/image/serverpage/image-id/3899iC0B9B989DD9BB378</og:image>
<og:type>article</og:type>
<og:url>https://www.dropboxforum.com/t5/Syncing-and-uploads/Dropbox-client-warns-me-that-it-ll-stop-syncing-in-Nov-why/m-p/290065#M42255</og:url>
<og:description>Hi everyone, on Nov. 7, 2018, we’re ending support for Dropbox syncing to drives with certain uncommon file systems. The supported file systems are NTFS for Windows, HFS+ or APFS for Mac, and Ext4 for Linux.   We’ve updated our desktop requirements accordingly here.   A supported file system is requ...</og:description>
<og:title>Re: Desktop app notification: Move dropbox location dropbox stops synchronizing in November</og:title>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.dropboxforum.com/t5/Syncing-and-uploads/Dropbox-client-warns-me-that-it-ll-stop-syncing-in-Nov-why/m-p/290065/highlight/true</dc:identifier>
</item>
<item>
<title>Show HN: Curl for GraphQL with autocomplete, subscriptions and GraphiQL</title>
<link>https://github.com/hasura/graphqurl</link>
<guid isPermaLink="true" >https://github.com/hasura/graphqurl</guid>
<description>&lt;div class=&quot;Box-body p-6&quot;&gt;
&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;text&quot;&gt;
&lt;p&gt;Made by the team at &lt;a href=&quot;https://hasura.io&quot; rel=&quot;nofollow&quot;&gt;hasura.io&lt;/a&gt;, &lt;code&gt;graphqurl&lt;/code&gt; is a curl like CLI for GraphQL:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CLI for making GraphQL queries with autocomplete&lt;/li&gt;
&lt;li&gt;Run GraphiQL locally against any endpoint&lt;/li&gt;
&lt;li&gt;Use as a library with nodejs or from the browser&lt;/li&gt;
&lt;li&gt;Supports subscriptions&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://oclif.io&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/fd9484ad8bb70e8f1c0f1d9d47bec2aaf934c81f/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636c692d6f636c69662d627269676874677265656e2e737667&quot; alt=&quot;oclif&quot; data-canonical-src=&quot;https://img.shields.io/badge/cli-oclif-brightgreen.svg&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://npmjs.org/package/graphqurl&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/6657edbeab261009d0676c25d757265872cfd0da/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f67726170687175726c2e737667&quot; alt=&quot;Version&quot; data-canonical-src=&quot;https://img.shields.io/npm/v/graphqurl.svg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://circleci.com/gh/hasura/graphqurl/tree/master&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/b98a853d3a283074f10b11de6d3f6804715f38ee/68747470733a2f2f636972636c6563692e636f6d2f67682f6861737572612f67726170687175726c2f747265652f6d61737465722e7376673f7374796c653d736869656c64&quot; alt=&quot;CircleCI&quot; data-canonical-src=&quot;https://circleci.com/gh/hasura/graphqurl/tree/master.svg?style=shield&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://ci.appveyor.com/project/hasura-bot/graphqurl/branch/master&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/05332ada3c1a5b9f6b2a0824fddded8222fa2b8e/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f6861737572612f67726170687175726c3f6272616e63683d6d6173746572267376673d74727565&quot; alt=&quot;Appveyor CI&quot; data-canonical-src=&quot;https://ci.appveyor.com/api/projects/status/github/hasura/graphqurl?branch=master&amp;amp;svg=true&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://npmjs.org/package/graphqurl&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/ae21617bbbde56eebe6ff497a4b020366370c51e/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f64772f67726170687175726c2e737667&quot; alt=&quot;Downloads/week&quot; data-canonical-src=&quot;https://img.shields.io/npm/dw/graphqurl.svg&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://github.com/hasura/graphqurl/blob/master/LICENSE.md&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/5db8baf139bd90ff1619e5afce2c2912888b244f/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f6c2f67726170687175726c2e737667&quot; alt=&quot;License&quot; data-canonical-src=&quot;https://img.shields.io/npm/l/graphqurl.svg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/hasura/graphqurl/blob/master/assets/subscription.gif&quot;&gt;&lt;img src=&quot;https://github.com/hasura/graphqurl/raw/master/assets/subscription.gif&quot; alt=&quot;Graphqurl Demo&quot;/&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/hasura/graphqurl/blob/master/assets/graphiql.gif&quot;&gt;&lt;img src=&quot;https://github.com/hasura/graphqurl/raw/master/assets/graphiql.gif&quot; alt=&quot;GraphiQL Demo&quot;/&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/hasura/graphqurl/blob/master/assets/bash_trigger.gif&quot;&gt;&lt;img src=&quot;https://github.com/hasura/graphqurl/raw/master/assets/bash_trigger.gif&quot; alt=&quot;Subscriptions triggering bash&quot;/&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h2&gt;Installation&lt;/h2&gt;
&lt;h3&gt;CLI&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
npm install -g graphqurl
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Node Library&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
npm install --save graphqurl
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;h3&gt;CLI&lt;/h3&gt;
&lt;h4&gt;Query&lt;/h4&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
gq https://my-graphql-endpoint/graphql \
     -H &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Authorization: token &amp;lt;token&amp;gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; \
     -q &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;query { table { column } }&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Auto-complete&lt;/h4&gt;
&lt;p&gt;GraphQURL can auto-complete queries using schema introspection. Execute the command without providing a query string:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ gq &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;endpoint&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; [-H &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;header:value&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;]
Enter the query, use TAB to auto-complete, Ctrl+Q to execute, Ctrl+C to cancel
gql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can use &lt;code&gt;TAB&lt;/code&gt; to trigger auto-complete. &lt;code&gt;Ctrl+C&lt;/code&gt; to cancel the input and &lt;code&gt;Ctrl+Q&lt;/code&gt;/&lt;code&gt;Enter&lt;/code&gt; to execute the query.&lt;/p&gt;
&lt;h4&gt;GraphiQL&lt;/h4&gt;
&lt;p&gt;Open GraphiQL with a given endpoint:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
gq &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;endpoint&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; -i
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a custom GraphiQL where you can specify request headers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Mutation&lt;/h4&gt;
&lt;p&gt;Mutations with variables can be executed by providing the variables with &lt;code&gt;-v&lt;/code&gt; flag.&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
gq &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;endpoint&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; \
   -v &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;name=hasura&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; \
   -q &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;mutation ($name: String) { table (objects: [{ name: $name }]) }&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Subscription&lt;/h4&gt;
&lt;p&gt;Subscriptions can be executed and the response is streamed on to stdout.&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
gq &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;endpoint&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; \
   -q &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;subscription { table { column } }&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Command&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ gq ENDPOINT [-q QUERY]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Args&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ENDPOINT&lt;/code&gt;: graphql endpoint (can be also set as &lt;code&gt;GRAPHQURL_ENDPOINT&lt;/code&gt; env var)&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;Options&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-q, --query=query&lt;/code&gt;: graphql query to exxecute&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-H, --header=&quot;key:value&quot;&lt;/code&gt;: request header&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v, --variable=&quot;key=value&quot;&lt;/code&gt;: variables used in the query&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n, --name=name&lt;/code&gt;: name of the graphql definition to execute, use only if there are multiple definitions&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--queryFile=/path/to/queryfile&lt;/code&gt;: file to read the query from&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--variablesFile=/path/to/variablefile&lt;/code&gt;: file to read the query variables from&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i, --graphiql&lt;/code&gt;: open graphiql with the given endpoint, headers, query and variables&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p, --graphiqlPort=graphiqlPort&lt;/code&gt;: [default: 4500] port to use for graphiql&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-a, --graphiqlAddress=graphiqlAddress&lt;/code&gt;: [default: localhost] address to use for graphiql&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l, --singleLine&lt;/code&gt;: show output in a single line, do not prettify&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--version&lt;/code&gt;: show CLI version&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-h, --help&lt;/code&gt;: show CLI help&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Node Library&lt;/h3&gt;
&lt;h4&gt;Using callbacks:&lt;/h4&gt;
&lt;div class=&quot;highlight highlight-source-js&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;pl-c1&quot;&gt;query&lt;/span&gt; } &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;graphqurl&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;successCallback&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;response&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;queryType&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;parsedQuery&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (queryType &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;subscription&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;) {
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; handle subscription response&lt;/span&gt;
  } &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; handle query/mutation response&lt;/span&gt;
  }
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;errorCallback&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;queryType&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;parsedQuery&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;error&lt;/span&gt;(error);
}

&lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(
  {
    query&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;query { table { column } }&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    endpoint&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;https://my-graphql-endpoint/graphql&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    headers&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
      &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;x-access-key&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;mysecretxxx&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    }
  },
  successCalllback,
  errorCallback
);
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Using Promises:&lt;/h4&gt;
&lt;p&gt;For queries and mutations,&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;pl-c1&quot;&gt;query&lt;/span&gt; } &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;graphqurl&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(
  {
    query&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;query { table { column } }&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    endpoint&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;https://my-graphql-endpoint/graphql&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    headers&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
      &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;x-access-key&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;mysecretxxx&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    }
  }
).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;((&lt;span class=&quot;pl-smi&quot;&gt;response&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(response))
 .&lt;span class=&quot;pl-c1&quot;&gt;catch&lt;/span&gt;((&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;error&lt;/span&gt;(error));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For subscriptions,&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;pl-c1&quot;&gt;query&lt;/span&gt; } &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;graphqurl&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(
  {
    query&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;subscription { table { column } }&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    endpoint&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;https://my-graphql-endpoint/graphql&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    headers&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
      &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;x-access-key&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;mysecretxxx&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    }
  }
).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;((&lt;span class=&quot;pl-smi&quot;&gt;observable&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-smi&quot;&gt;observable&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;subscribe&lt;/span&gt;(
    (&lt;span class=&quot;pl-c1&quot;&gt;event&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Event received: &lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;event&lt;/span&gt;);
      &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; handle event&lt;/span&gt;
    },
    (&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Error: &lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, error);
      &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; handle error&lt;/span&gt;
    }
  )
})
 .&lt;span class=&quot;pl-c1&quot;&gt;catch&lt;/span&gt;((&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;error&lt;/span&gt;(error));
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Subscriptions are not supported in browsers yet.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;API&lt;/h3&gt;
&lt;h4&gt;query(options, successCallback, errorCallback)&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;options&lt;/strong&gt;: [Object, &lt;em&gt;required&lt;/em&gt;] GraphQL query options with the following properties:
&lt;ul&gt;&lt;li&gt;endpoint: [String, &lt;em&gt;required&lt;/em&gt;] GraphQL endpoint&lt;/li&gt;
&lt;li&gt;query: [String, &lt;em&gt;required&lt;/em&gt;] GraphQL query string&lt;/li&gt;
&lt;li&gt;headers: [Object] Request headers, defaults to &lt;code&gt;{}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;variables: [Object] GraphQL query variables, defaults to '{}'&lt;/li&gt;
&lt;li&gt;name: [String] Operation name. Used only if the &lt;code&gt;query&lt;/code&gt; string contains multiple operations.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;successCallback&lt;/strong&gt;: [Function] Success callback which is called after a successful response. It is called with the following parameters:
&lt;ul&gt;&lt;li&gt;response: The response of your query&lt;/li&gt;
&lt;li&gt;queryType: The type of query you made i.e. one [&lt;code&gt;query&lt;/code&gt;, &lt;code&gt;mutation&lt;/code&gt;, &lt;code&gt;subcription&lt;/code&gt;]&lt;/li&gt;
&lt;li&gt;parsedQuery: The query parsed into a GraphQL document&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;errorCallback&lt;/strong&gt;: [Function] Error callback which is called after a the occurance of an error. It is called with the following parameters:
&lt;ul&gt;&lt;li&gt;error: The occured error&lt;/li&gt;
&lt;li&gt;queryType: [String] The type of query you made i.e. one [&lt;code&gt;query&lt;/code&gt;, &lt;code&gt;mutation&lt;/code&gt;, &lt;code&gt;subcription&lt;/code&gt;]&lt;/li&gt;
&lt;li&gt;parsedQuery: [Object] The query parsed into a GraphQL document&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Returns&lt;/strong&gt;: [Promise (response) ]If &lt;code&gt;successCallback&lt;/code&gt; and &lt;code&gt;errorCallback&lt;/code&gt; are not provided, this function returns the response wrapped in a promise.
&lt;ul&gt;&lt;li&gt;response: response is a GraphQL compliant JSON object in case of &lt;code&gt;queries&lt;/code&gt; and &lt;code&gt;mutations&lt;/code&gt;. However, if you make a subscription, it returns an observable that you can later subscribe to. Check &lt;a href=&quot;https://github.com/hasura/graphqurl#subscriptions&quot;&gt;this example&lt;/a&gt; to see how to subscribe to observables.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;More Examples&lt;/h2&gt;
&lt;h3&gt;Node Library&lt;/h3&gt;
&lt;h4&gt;Queries&lt;/h4&gt;
&lt;p&gt;Query example with variables&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;pl-c1&quot;&gt;query&lt;/span&gt; } &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;graphqurl&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(
  {
    query&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;      query ($name: String) {&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;        table(where: { column: $name }) {&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;          id&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;          column&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;        }&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;      }&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;    &lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;,
    endpoint&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;https://my-graphql-endpoint/graphql&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    headers&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
      &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;x-access-key&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;mysecretxxx&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    },
    variables&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
      name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Alice&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
    }
  }
).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;((&lt;span class=&quot;pl-smi&quot;&gt;response&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(response))
 .&lt;span class=&quot;pl-c1&quot;&gt;catch&lt;/span&gt;((&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;error&lt;/span&gt;(error));
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Mutations&lt;/h4&gt;
&lt;div class=&quot;highlight highlight-source-js&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;pl-c1&quot;&gt;query&lt;/span&gt; } &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;graphqurl&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(
  {
    query&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;      mutation ($id_insert_input: String!, $column_insert_input: String!) {&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;        insert_to_table (&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;          id: $id_insert_input,&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;          column: $column_insert_input&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;        ) {&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;          affected_rows&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;        }&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;      }&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;    &lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;,
    endpoint&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;https://my-graphql-endpoint/graphql&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    headers&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
      &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;x-access-key&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;mysecretxxx&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    },
    variables&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
      id_insert_input&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;id_ak23sdfkjk2&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
      column_insert_input&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Bob&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
    }
  }
).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;((&lt;span class=&quot;pl-smi&quot;&gt;response&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(response))
 .&lt;span class=&quot;pl-c1&quot;&gt;catch&lt;/span&gt;((&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;error&lt;/span&gt;(error));
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Subscriptions&lt;/h4&gt;
&lt;p&gt;Using promises,&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;pl-c1&quot;&gt;query&lt;/span&gt; } &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;graphqurl&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;eventCallback&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;pl-c1&quot;&gt;event&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Event received:&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;event&lt;/span&gt;);
  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; handle event&lt;/span&gt;
};

&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;errorCallback&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Error:&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, error)
};

&lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(
  {
    query&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;subscription { table { column } }&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    endpoint&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;https://my-graphql-endpoint/graphql&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    headers&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
      &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Authorization&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Bearer Andkw23kj=Kjsdk2902ksdjfkd&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
    }
  },
).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;((&lt;span class=&quot;pl-smi&quot;&gt;observable&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-smi&quot;&gt;observable&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;subscribe&lt;/span&gt;(
    (&lt;span class=&quot;pl-c1&quot;&gt;event&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Event received&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;event&lt;/span&gt;);
      &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; handle event&lt;/span&gt;
    },
    (&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Error&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, error);
      &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; handle error&lt;/span&gt;
    }
  )
}).&lt;span class=&quot;pl-c1&quot;&gt;catch&lt;/span&gt;(errorCallback);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Lets do the above subscription using callbacks,&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;pl-c1&quot;&gt;query&lt;/span&gt; } &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;graphqurl&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;eventCallback&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;event&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Event received:&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;event&lt;/span&gt;);
  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; handle event&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;errorCallback&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Error:&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, error)
}

&lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(
  {
    query&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;subscription { table { column } }&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    endpoint&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;https://my-graphql-endpoint/graphql&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    headers&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
      &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Authorization&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Bearer Andkw23kj=Kjsdk2902ksdjfkd&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
    }
  },
  eventCallback,
  errorCallback
);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;CLI&lt;/h3&gt;
&lt;p&gt;Generic example:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
gq \
     https://my-graphql-endpoint/graphql \
     -H &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Authorization: token &amp;lt;token&amp;gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; \
     -H &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;X-Another-Header: another-header-value&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; \
     -v &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;variable1=value1&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; \
     -v &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;variable2=value2&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; \
     -q &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;query { table { column } }&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Reading the query and variables from a file:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
gq \
     https://my-graphql-endpoint/graphql \
     -H &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Authorization: token &amp;lt;token&amp;gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; \
     -H &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;X-Another-Header: another-header-value&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; \
     --variableFile=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;./queryVariables.json&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; \
     --queryFile=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;./query.gql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Executing only a particular named query from a file that contains many queries:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
gq &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;endpoint&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; --queryFile ./queries.gql --name getItems
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;Maintained with ♡ by &lt;a href=&quot;https://hasura.io&quot; rel=&quot;nofollow&quot;&gt;Hasura&lt;/a&gt;&lt;/p&gt;
&lt;/article&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 10 Aug 2018 09:39:35 +0000</pubDate>
<dc:creator>wawhal</dc:creator>
<og:image>https://avatars3.githubusercontent.com/u/13966722?s=400&amp;v=4</og:image>
<og:type>object</og:type>
<og:title>hasura/graphqurl</og:title>
<og:url>https://github.com/hasura/graphqurl</og:url>
<og:description>graphqurl - curl for GraphQL with autocomplete, subscriptions and GraphiQL. Also a JS library</og:description>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://github.com/hasura/graphqurl</dc:identifier>
</item>
</channel>
</rss>