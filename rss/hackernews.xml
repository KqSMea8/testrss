<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=hnrss.org%2Fnewest%3Fpoints%3D200&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://hnrss.org/newest?points=200" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dhnrss.org%252Fnewest%253Fpoints%253D200%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dhnrss.org%252Fnewest%253Fpoints%253D200%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>Hacker News: Newest</title>
<link>https://news.ycombinator.com/newest</link>
<description>Hacker News RSS</description>
<item>
<title>What’s Inside Every iPhone, from Retina Displays to Cameras</title>
<link>https://www.bloomberg.com/features/apple-iphone-guts/</link>
<guid isPermaLink="true" >https://www.bloomberg.com/features/apple-iphone-guts/</guid>
<description>&lt;p&gt;&lt;span class=&quot;dib px0-5&quot;&gt;&lt;span class=&quot;chiclet chiclet-square chiclet-big bgc-white fc-black&quot;&gt;1&lt;/span&gt; Published: October 12, 2017, 5:00 a.m. EDT&lt;/span&gt;&lt;/p&gt;&lt;div sm=&quot;fs3 ls-big&quot; md=&quot;p4 fs4-2&quot; xl=&quot;fs4-8&quot; readability=&quot;34.588235294118&quot;&gt;
&lt;p&gt;Apple Inc. has sold more than 1.2 billion iPhones since January 2007, when founder Steve Jobs triumphantly claimed, “Today, Apple is going to reinvent the phone.” That figure, based on quarterly results that include the 15 distinct models that came out before iPhones 8 and X, means that in terms of units sold, the iPhone is probably more successful than any consumer product ever created. The device has seeded entire industries—apps, most notably—and sent the stock prices of suppliers soaring. On the other hand, suppliers that have been spurned by Apple have struggled and, in at least one case, subsequently gone bankrupt.&lt;/p&gt;
&lt;p&gt;The story of the device’s evolution is readily available to anyone willing to crack an old phone open and look at what’s inside. To understand this, we partnered with &lt;a href=&quot;https://www.ifixit.com/&quot; target=&quot;_blank&quot;&gt;iFixit&lt;/a&gt;, the website known for publishing detailed “teardowns” of each phone, and &lt;a href=&quot;https://ihsmarkit.com/&quot; target=&quot;_blank&quot;&gt;IHS Markit&lt;/a&gt;, which produces estimates of the cost of electronics components. Then, with an EBay account and a little help from Sunny Lin, the founder of Simple Mac, an iPhone repair shop in New York, we got our hands on each iPhone model and opened them up. Here are the results. We will update this graphic to include additional models—such as the S models and the oft-forgotten iPhone 5C—and to include new phones as they’re released.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;—Max Chafkin &amp;amp; Ian King&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 13 Oct 2017 02:36:24 +0000</pubDate>
<dc:creator>shawndumas</dc:creator>
<og:type>article</og:type>
<og:title>Here’s a Detailed Look at What's Inside an iPhone</og:title>
<og:image>https://www.bloomberg.com/features/apple-iphone-guts/img/social.jpg</og:image>
<og:description>The story of the device’s evolution since 2007.</og:description>
<og:url>https://www.bloomberg.com/features/apple-iphone-guts/</og:url>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.bloomberg.com/features/apple-iphone-guts/</dc:identifier>
</item>
<item>
<title>Rejecting a candidate for over-qualification results in age bias</title>
<link>https://www.facebook.com/notes/kent-beck/over-qualification-wut/1671791376187053/</link>
<guid isPermaLink="true" >https://www.facebook.com/notes/kent-beck/over-qualification-wut/1671791376187053/</guid>
<description>&lt;p&gt;My father was laid off from SRI at 55. He spent the next two years bouncing around the Valley fruitlessly looking for work, lowering his expectations all the while. Eventually he gave up, tucked his tail between his legs, and retired to southern Oregon.&lt;/p&gt;
&lt;p&gt;My father wasn’t rejected for his lack of skills. He could make a 6502 bark, roll over, and shake hands. His code worked. He knew when to clean up, so he was able to add features indefinitely. He hit his deadlines. He could code, he just couldn’t find a job.&lt;/p&gt;
&lt;p&gt;I still carry some of the pain of his situation with me. I’m afraid of “aging out” of technology. I’ve worked to keep myself employable. I’m already seeing responses most easily explained by age-related bias, though, so my time is coming.&lt;/p&gt;
&lt;h3 class=&quot;_2cuy _50a1 _2vxa&quot;&gt;“Over-Qualified”&lt;/h3&gt;

&lt;blockquote class=&quot;_2cuy _509u _2vxa&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;“You are over-qualified for the position and we don’t think you’d be satisfied” is de facto age discrimination&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The subsequent conversation was diverse and intense enough that I want to follow up on the many interesting comments. I will make three points:&lt;/p&gt;
&lt;ul class=&quot;_5a_q _5yj1&quot; dir=&quot;ltr&quot;&gt;&lt;li class=&quot;_2cuy _509q _2vxa&quot;&gt;Mechanism, not equivalence&lt;/li&gt;
&lt;li class=&quot;_2cuy _509q _2vxa&quot;&gt;Effect, not motivation&lt;/li&gt;
&lt;li class=&quot;_2cuy _509q _2vxa&quot;&gt;Thoughts, not words&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;_2cuy _50a1 _2vxa&quot;&gt;Mechanism, Not Equivalence&lt;/h3&gt;
&lt;p&gt;One set of responses to the tweet related how non-old people can also hear this response. To be clear, I didn’t say that citing over-qualification &lt;span class=&quot;_4yxp&quot;&gt;is&lt;/span&gt; age discrimination. There are legitimate reasons to cite over-qualification. I’m saying that citing over-qualification is also used as the &lt;span class=&quot;_4yxp&quot;&gt;mechanism&lt;/span&gt; for enforcing age-related bias, just as “lack of culture fit” is used as a mechanism for enforcing gender and cultural bias.&lt;/p&gt;
&lt;h3 class=&quot;_2cuy _50a1 _2vxa&quot;&gt;Effect, Not Motivation&lt;/h3&gt;
&lt;p&gt;Another set of responses speculated on the motivation of those citing over-qualification: fear of managing someone better, fear of being called out on bullshit, fear of salary pressure. You know what? I just don’t care. While there are certainly explanations for this kind of behavior there are no excuses. Look at the effects of your behavior.&lt;/p&gt;
&lt;h3 class=&quot;_2cuy _50a1 _2vxa&quot;&gt;Thoughts, Not Words&lt;/h3&gt;
&lt;p&gt;Compared to when I was a wee little engineer, the list of forbidden questions and phrases is much longer. I’m not interested in adding “over-qualified and likely dissatisfied” to that list. I am interested in addressing the thoughts that lead to that phrase.&lt;/p&gt;
&lt;p&gt;Have you used the phrase? Reflect on your thoughts just before you used it. Reflect on the beliefs that must underlie such thoughts. Hint: this is going to be uncomfortable work, at least if you’re honest.&lt;/p&gt;
&lt;h3 class=&quot;_2cuy _50a1 _2vxa&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;My father spent from 57 to 83 on his five acres on a hilltop. He puttered in his ham shack. He ran for county planning commissioner and lost. He cared for my aging mother. He never wrote another line of code.&lt;/p&gt;
&lt;p&gt;Part of that is on him (about which more later), but part is on the system you and I are still part of. The beliefs that prevent experienced programmers from contributing at their full capacity are still out there. It’s up to us to call them out.&lt;/p&gt;
</description>
<pubDate>Thu, 12 Oct 2017 21:23:47 +0000</pubDate>
<dc:creator>KentBeck</dc:creator>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.facebook.com/notes/kent-beck/over-qualification-wut/1671791376187053/?_fb_noscript=1</dc:identifier>
</item>
<item>
<title>TerrariaClone – An incomprehensible hellscape of spaghetti code</title>
<link>https://github.com/raxod502/TerrariaClone</link>
<guid isPermaLink="true" >https://github.com/raxod502/TerrariaClone</guid>
<description>&lt;h3&gt;README.md&lt;/h3&gt;
&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;text&quot;&gt;
&lt;p&gt;Back when I was first learning to program in Java, I decided to try to make a clone of the excellent PC game &lt;a href=&quot;https://terraria.org/&quot;&gt;Terraria&lt;/a&gt;. Of course, I was convinced that my version would have many more features than the official one.&lt;/p&gt;
&lt;p&gt;But before I realized how silly that idea was, I produced 11,000 lines of, to date, the most atrocious code I have ever seen in my life. I make it available here mostly as a cautionary tale of what can happen if you don't pay attention to the quality of your code. (Lesson learned, in my case!) Here are some of the highlights:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;Blocks and items, among many other things, are represented by magic numbers instead of enums. There are 417 lines of block comments at the top of &lt;code&gt;TerrariaClone.java&lt;/code&gt; that serve as manual translation tables.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There are no access modifiers. Everything is package-private.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;So as to avoid needing to declare local variables and loop indices, all of the variables for everything are declared globally at the class level. Here is one of the several hundred lines of declarations in &lt;code&gt;TerrariaClone.java&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int x, y, i, j, k, t, wx, wy, lx, ly, tx, ty, twx, twy, tlx, tly, ux, uy, ux2, uy2, uwx, uwy, uwx2, ulx, uly, ulx2, uly2, ucx, ucy, uclx, ucly, pwx, pwy, icx, icy, n, m, dx, dy, dx2, dy2, mx, my, lsx, lsy, lsn, ax, ay, axl, ayl, nl, vc, xpos, ypos, xpos2, ypos2, x2, y2, rnum, mining, immune, width, height, xmin, xmax, ymin, ymax, intpercent, ground;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Although there are a few other classes, the bulk of the code is in the God Class &lt;code&gt;TerrariaClone&lt;/code&gt;, which spans over 6,500 lines of code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;TerrariaClone.init()&lt;/code&gt; method, which is over 1,300 lines long, actually grew so large that the Java compiler started &lt;em&gt;running out of memory&lt;/em&gt; trying to compile it! The solution? Copy half of the &lt;code&gt;init()&lt;/code&gt; code into a new method, called &lt;code&gt;codeTooLarge()&lt;/code&gt;, and call that from &lt;code&gt;init()&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Frankly horrifying inline data tables:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static boolean[] solid = {false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, false, false, false, true, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false};
static boolean[] ltrans = {false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, true, true, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false};
static boolean[] wirec = {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true};
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Over 1,000 lines of filling globally declared HashMaps and ArrayLists with magic numbers and strings one by one.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The control flow is so labyrinthine that some of the code is actually indented by 23 tabs. Forget the 80-column rule -- these lines don't even &lt;em&gt;start&lt;/em&gt; until column 92! Even if we discard the inline data tables, then the longest line in the codebase is still a whopping &lt;em&gt;387 characters&lt;/em&gt; long (you'll have to scroll to the right to read it):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;                                                                                                 blocks[l][y2][x2] &amp;gt;= 137 &amp;amp;&amp;amp; blocks[l][y2][x2] &amp;lt;= 168 &amp;amp;&amp;amp; y &amp;gt; y2 &amp;amp;&amp;amp; blocks[l][y2][x2] != 140 &amp;amp;&amp;amp; blocks[l][y2][x2] != 144 &amp;amp;&amp;amp; blocks[l][y2][x2] != 148 &amp;amp;&amp;amp; blocks[l][y2][x2] != 152 &amp;amp;&amp;amp; blocks[l][y2][x2] != 156 &amp;amp;&amp;amp; blocks[l][y2][x2] != 160 &amp;amp;&amp;amp; blocks[l][y2][x2] != 164 &amp;amp;&amp;amp; blocks[l][y2][x2] != 168) &amp;amp;&amp;amp;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Did I mention that &lt;em&gt;everything is global&lt;/em&gt;, including &lt;em&gt;loop indexing variables&lt;/em&gt;?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There are random print statements scattered throughout the codebase, with helpful messages like &lt;code&gt;[DEBUG2R]&lt;/code&gt; and &lt;code&gt;[DEBUG2A]&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Why use a pre-existing GUI framework for your text boxes when you can easily roll your own?&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;char c = 0;
if (key.getKeyCode() == key.VK_Q) c = 'q';
...
if (queue[5]) {
    if (c == 'q') c = 'Q';
    ...
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Now, when importing this project into version control (you thought I was using version control when I wrote this??), I did fix a few of the most blatantly horrible style violations -- for instance, I normalized the whitespace, although other improvements (for example, removing the over 500 cases of unnecessary boxing) have been reverted by popular demand in the name of historical integrity. I also tried to get the main game actually working, which meant fixing a few resource path issues. Unfortunately, it's only working in the academic sense, since it's so slow that you only get about 0.03 FPS and it crashes when you click the mouse button. But, somewhere in there is a working game. You know, sort of.&lt;/p&gt;
&lt;h4&gt;TerraFrame?&lt;/h4&gt;
&lt;p&gt;This project was originally called TerraFrame (back when I created it in 2011). I believe the reasoning was that it was a &lt;em&gt;Terra&lt;/em&gt;ria clone, and it was in a J&lt;em&gt;Frame&lt;/em&gt;. Yes, it's stupid, much like every other part of this project. Meanwhile, there is a completely unrelated company called TerraFrame. This led to an unfortunate misunderstanding wherein somebody thought that this garbage heap of a codebase was associated in some way with TerraFrame, the company. After receiving a very polite email pointing out the issue, I've changed the name to something that makes more sense (TerrariaClone).&lt;/p&gt;
&lt;/article&gt;</description>
<pubDate>Thu, 12 Oct 2017 19:59:53 +0000</pubDate>
<dc:creator>warent</dc:creator>
<og:image>https://avatars2.githubusercontent.com/u/6559064?s=400&amp;v=4</og:image>
<og:type>object</og:type>
<og:title>raxod502/TerrariaClone</og:title>
<og:url>https://github.com/raxod502/TerrariaClone</og:url>
<og:description>TerrariaClone - 🔥 An incomprehensible hellscape of spaghetti code.</og:description>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://github.com/raxod502/TerrariaClone</dc:identifier>
</item>
<item>
<title>Exploiting the Wi-Fi Stack on Apple Devices</title>
<link>https://googleprojectzero.blogspot.com/2017/10/over-air-vol-2-pt-3-exploiting-wi-fi.html</link>
<guid isPermaLink="true" >https://googleprojectzero.blogspot.com/2017/10/over-air-vol-2-pt-3-exploiting-wi-fi.html</guid>
<description>&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Posted by Gal Beniamini, Project Zero&lt;/span&gt;&lt;/div&gt;
&lt;strong id=&quot;docs-internal-guid-67da8c65-0c43-0473-29e2-0c8ea30e011e&quot;&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;In this blog post we’ll complete our goal of achieving remote kernel code execution on the iPhone 7, by means of Wi-Fi communication alone.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;After developing a Wi-Fi firmware exploit in the&lt;/span&gt; &lt;a href=&quot;https://googleprojectzero.blogspot.com/2017/10/over-air-vol-2-pt-2-exploiting-wi-fi.html&quot;&gt;&lt;span&gt;previous blog post&lt;/span&gt;&lt;/a&gt;&lt;span&gt;, we are left with the task of using our newly acquired access to gain control over the XNU kernel. To this end, we’ll begin by investigating the isolation mechanisms present on the iPhone. Next, we’ll explore the ways in which the host interacts with the Wi-Fi chip, identify several attack surfaces, and assess their corresponding security properties. Finally, we’ll discover multiple vulnerabilities and proceed to develop a fully-functional reliable exploit for one of them, allowing us to gain control over the host’s kernel.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;160&quot; src=&quot;https://lh4.googleusercontent.com/GW9k8F51JnL3fMCXtoCLuP5LEiP-zheS6E9dL11BHGzILTCSzKK-4mzZ2j9X_I1BUacLZc1eU1JN0g73x2ETi46ys43DjXgvWevAWub6hJJCluADPGpNlOHHIxqh-5wONZhsuw4I&quot; width=&quot;449&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;All the vulnerabilities presented in this blog post (&lt;/span&gt;&lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1302&quot;&gt;&lt;span&gt;#1&lt;/span&gt;&lt;/a&gt;&lt;span&gt;,&lt;/span&gt; &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1305&quot;&gt;&lt;span&gt;#2&lt;/span&gt;&lt;/a&gt;&lt;span&gt;,&lt;/span&gt; &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1312&quot;&gt;&lt;span&gt;#3&lt;/span&gt;&lt;/a&gt;&lt;span&gt;,&lt;/span&gt; &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1313&quot;&gt;&lt;span&gt;#4&lt;/span&gt;&lt;/a&gt;&lt;span&gt;,&lt;/span&gt; &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1314&quot;&gt;&lt;span&gt;#5&lt;/span&gt;&lt;/a&gt;&lt;span&gt;,&lt;/span&gt; &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1317&quot;&gt;&lt;span&gt;#6&lt;/span&gt;&lt;/a&gt;&lt;span&gt;,&lt;/span&gt; &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1318&quot;&gt;&lt;span&gt;#7&lt;/span&gt;&lt;/a&gt;&lt;span&gt;) were reported to Apple and subsequently fixed in iOS 11. For an analysis of other affected devices in the Apple ecosystem, see the corresponding&lt;/span&gt; &lt;a href=&quot;https://support.apple.com/en-gb/HT208113&quot;&gt;&lt;span&gt;security&lt;/span&gt;&lt;/a&gt; &lt;a href=&quot;https://support.apple.com/en-gb/HT208115&quot;&gt;&lt;span&gt;bulletins&lt;/span&gt;&lt;/a&gt;&lt;span&gt;.&lt;/span&gt;&lt;/div&gt;
&lt;h3 dir=&quot;ltr&quot;&gt;&lt;span&gt;Hardware Isolation&lt;/span&gt;&lt;/h3&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;PCIe DMA&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Broadcom’s Wi-Fi chips are present in a wide range of platforms; including mobile phones, IOT devices and Wi-Fi routers. To accommodate for this variance, each chip must be sufficiently configurable, supporting several different interfaces for vendors wishing to integrate the chip into their platform. Indeed, Cypress’s&lt;/span&gt; &lt;a href=&quot;http://www.cypress.com/file/298016/download&quot;&gt;&lt;span&gt;data sheets&lt;/span&gt;&lt;/a&gt; &lt;span&gt;include a wide range of supported interfaces, including&lt;/span&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;&lt;span&gt;PCIe&lt;/span&gt;&lt;/a&gt;&lt;span&gt;,&lt;/span&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Digital#SDIO_cards&quot;&gt;&lt;span&gt;SDIO&lt;/span&gt;&lt;/a&gt; &lt;span&gt;and&lt;/span&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/USB&quot;&gt;&lt;span&gt;USB&lt;/span&gt;&lt;/a&gt;&lt;span&gt;.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;98&quot; src=&quot;https://lh3.googleusercontent.com/XVQi2_Q3iWKLPCRvwbyk2JmSVlowIcYR7cTpjMkU282rliuL1XHXKp9vysPcCn0ldd6wzeDTviQSAPAF9Wt0ZLpkS8c2bjXUw9qJhhLU-SLF-QJhmvgZr5aFfhP0_AKMzF8rx4OX&quot; width=&quot;361&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;While choosing the interface with which to integrate the chip may seem inconsequential, it could have far ranging&lt;/span&gt; &lt;span&gt;security&lt;/span&gt; &lt;span&gt;implications. Each interface comes with different security guarantees, affecting the degree to which the peripheral may be “&lt;/span&gt;&lt;span&gt;isolated&lt;/span&gt;&lt;span&gt;” from the host. As we’ve&lt;/span&gt; &lt;a href=&quot;https://googleprojectzero.blogspot.com/2017/10/over-air-vol-2-pt-2-exploiting-wi-fi.html&quot;&gt;&lt;span&gt;already demonstrated&lt;/span&gt;&lt;/a&gt; &lt;span&gt;how the Wi-Fi chip’s security can be subverted by remote attackers, it’s clear that providing isolation is crucial in sufficiently safeguarding the host.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;From a security perspective, both SDIO and USB (up to 3.1) inherently offer some degree of isolation. SDIO solely enables the serial transfer of information between the host and the target device. Similarly, USB allows the transfer of “packets” between peripherals and the host. Broadly speaking, both interfaces can be thought of as facilitating an&lt;/span&gt; &lt;span&gt;explicit&lt;/span&gt; &lt;span&gt;communication channel between the host and the peripheral. All the data transported through these interfaces must be&lt;/span&gt; &lt;span&gt;explicitly&lt;/span&gt; &lt;span&gt;handled by either peer, by inspecting incoming requests and responding accordingly.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;PCIe operates using a different paradigm. Instead of communicating with the host using a communication protocol, PCIe allows peripherals to gain&lt;/span&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;&lt;span&gt;Direct Memory Access&lt;/span&gt;&lt;/a&gt; &lt;span&gt;(DMA) to the host’s memory. Using DMA, peripherals may autonomously prepare data structures within the host’s memory, only signalling the host (via a&lt;/span&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Message_Signaled_Interrupts&quot;&gt;&lt;span&gt;Message Signalled Interrupt&lt;/span&gt;&lt;/a&gt;&lt;span&gt;) once there’s processing to be done. Operating in this manner allows the host to conserve computing resources, as opposed to protocols that require processing to transfer data between endpoints or to handle each individual request.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Efficient as this approach may be, it also raises some challenges with regards to isolation. First and foremost, how can we be guaranteed that malicious peripherals won’t abuse this access in order to attack the host? After all, in the presence of full control over the host’s memory, subverting any program running on the host is trivial (for example, peripherals may freely modify a program’s stack, alter function pointers, overwrite code -- all unbeknownst to the host itself).&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Luckily, this issue has not gone unaddressed. Sufficient isolation for DMA-capable components can be achieved by partitioning the visible memory space available to the peripheral using a dedicated hardware component - an&lt;/span&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Input%E2%80%93output_memory_management_unit&quot;&gt;&lt;span&gt;I/O Memory Management Unit&lt;/span&gt;&lt;/a&gt; &lt;span&gt;(IOMMU).&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;231&quot; src=&quot;https://lh4.googleusercontent.com/arU3a0AClOlNAPmFSCmTzOaQCqqds8joMcCUprMHU-H8LZ_2sbg5aDRzOWECne6Z16BdF4fSLM03kQitDz0eqbJE0OH4CJqQeaAShXZnBDN-QZHQTlp9tQ-TC8crmXvT4broIWH6&quot; width=&quot;546&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;IOMMUs facilitate a memory translation service for peripherals, converting their addressable memory ranges (referred to as “IO-Space”) into ranges within the host’s Physical Address Space (PAS). Configuring the IOMMU’s translation tables allows the host to selectively control which portions of its memory are exposed to each peripheral, while safeguarding other ranges against potentially malicious access. Consequently, the bulk of the responsibility for providing sufficient isolation lays with the host.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Returning to the issue at hand, as we are focusing on the Wi-Fi stack present within Apple’s ecosystem, an immediate question springs to mind -- which interfaces does Apple leverage to connect the Wi-Fi chip to the host? Inspecting the Wi-Fi firmware images present in several generations of Apple devices reveals that since the iPhone 6 (included), Apple has opted for PCIe to connect the Wi-Fi chip to the host. Older models, such as the iPhone 5c and 5s, relied on a USB interface instead.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;274&quot; src=&quot;https://lh6.googleusercontent.com/mto_24L_rPgIsqfuewxjf8H-8WdUghWgdb3V0otsCbw5ZtKKh_NS-3517p8DCofXeGWKZ6BkXShEIrHHPm_exP-QsioURSUBV01sb-6uE_DXrre8X_pp6sQDs0TbsLF7FoT7W51n&quot; width=&quot;651&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Due to the risks highlighted above, it is crucial that recent iPhones utilise an IOMMU to isolate themselves from potentially malicious PCIe-connected Wi-Fi chips. Indeed, during our&lt;/span&gt; &lt;a href=&quot;https://googleprojectzero.blogspot.co.uk/2017/04/over-air-exploiting-broadcoms-wi-fi_11.html&quot;&gt;&lt;span&gt;previous research&lt;/span&gt;&lt;/a&gt; &lt;span&gt;into the isolation mechanisms on Android devices, we discovered that&lt;/span&gt; &lt;span&gt;no isolation&lt;/span&gt; &lt;span&gt;was enforced in two of the most prominent SoCs; Qualcomm’s Snapdragon 810 and Samsung’s Exynos 8890, thereby allowing the Wi-Fi chip to freely access the host’s memory (leading to complete compromise of the device).&lt;/span&gt;&lt;/div&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;Inspecting the DMA Engine&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;To gain some visibility into the isolation capabilities present on the iPhone 7, we’ll begin by exploring the Wi-Fi firmware itself. If a form of isolation is present, the memory ranges used by the Wi-Fi SoC to perform DMA operations and those utilised by the host would be disparate. Conversely, if we happen to find the same ranges of physical addresses, that would hint that no         isolation is taking place.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Luckily, much of the complexity involved in reverse-engineering the firmware’s DMA functionality can be forgone, as Broadcom’s SoftMAC drivers (&lt;/span&gt;&lt;a href=&quot;https://github.com/spotify/linux/blob/6eb782fc88d11b9f40f3d1d714531f22c57b39f9/drivers/staging/brcm80211/util/hnddma.c#L146&quot;&gt;&lt;span&gt;brcm80211&lt;/span&gt;&lt;/a&gt;&lt;span&gt;) contain the majority of the code used to interface with the SoC’s DMA engine.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Each DMA engine facilitates transfers in a single direction between two endpoints; one representing the Wi-Fi firmware, and another denoting either an internal core within the Wi-Fi SoC (such as when interacting with the RX or TX&lt;/span&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)&quot;&gt;&lt;span&gt;FIFO&lt;/span&gt;&lt;/a&gt;&lt;span&gt;s) or the host itself. As we are interested in inspecting the memory ranges used for transfers originating in the Wi-Fi chip and terminating at the host, we must locate the DMA engine responsible for “dongle-to-host” memory transfers.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;As it happens, this task is rather straightforward. Each “&lt;/span&gt;&lt;a href=&quot;https://github.com/spotify/linux/blob/6eb782fc88d11b9f40f3d1d714531f22c57b39f9/drivers/staging/brcm80211/util/hnddma.c#L72&quot;&gt;&lt;span&gt;dma_info&lt;/span&gt;&lt;/a&gt;&lt;span&gt;” structure in the firmware (representing a DMA engine) is prefixed by a pointer to a block of DMA-related function pointers stored in the firmware’s RAM. Since the block is placed at a fixed address, we can locate all instances of the structure by searching for the pointer within the firmware’s RAM. For each instance we come across, inspecting the “name” field encoded in the structure should allow us to deduce the identity of the DMA engine in question.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;167&quot; src=&quot;https://lh3.googleusercontent.com/TIgidYZmZDVEt61hWmaTsdfuQ97jPQBVePQ1myCl5FmP_8GXG8WiGMtsRPCYA1iFmPvs6I7oeOlnBpCN93U7PqC29B2QXhmz0PvrOBzjg1D8MFMkUNNvC9lhF1Gw_XPyiWjCTqDR&quot; width=&quot;316&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Combining these two tidbits, we can quickly locate each DMA engine in the firmware’s RAM:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;104&quot; src=&quot;https://lh4.googleusercontent.com/TpoSNqp9Yjzl1wx1kXmFGmpQ_yJXtju6asqV881suerXgLn6FAUGbbFbJ8A_khk7YnVgcTDtE_B8QiWs7bpV39OgAsbKn-0WA7h1nBWsZaXFMo74mv7HHiAtDACIkzmh5a_slHsb&quot; width=&quot;435&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;The first few instances clearly relate to internal DMA engines. The last instance, labeled “H2D”, indicates “host-to-dongle” memory transfers. Therefore, by elimination, the single entry left must correspond to transfers from the dongle to the host (sneakily left unnamed!).&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Having located the engine, all that remains is to dump the RX descriptor ring and extract the addresses to which DMA transfers are performed. Unfortunately, descriptors are rapidly consumed after being inserted into the corresponding rings, replacing their contents with generic placeholder values. Therefore, observing the value of a non-consumed descriptor from a single memory snapshot is tricky. Instead, to extract “fresh” descriptors, we’ll&lt;/span&gt; &lt;a href=&quot;https://github.com/google/Legilimency/blob/master/BCMClient.py#L385&quot;&gt;&lt;span&gt;insert a hook&lt;/span&gt;&lt;/a&gt; &lt;span&gt;on the DMA transfer function, allowing us to dump descriptor addresses before they are inserted into the corresponding rings.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;After inserting the hook, we are presented with the following output:&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;65&quot; src=&quot;https://lh6.googleusercontent.com/O85KqhUcOHd7XYFrq1grEEn_VR8yD-hg7KaxSnjiXM3Waq_P_zR5UvQ-kEd9n3zWZdjB9He_Q6cCUKX2RMsgT01BL2BkD8whqZyZ-Zrs8IUqAcwJsZm-fCQpcCZtcqug66ARGdmd&quot; width=&quot;240&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;All of the descriptor addresses appear to be 32-bits wide...&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;How do the above addresses relate to our knowledge of the physical address space on the iPhone 7? The DRAM’s base address in the host’s physical address space is denoted by the “&lt;/span&gt;&lt;a href=&quot;https://github.com/apple/darwin-xnu/blob/0a798f6738bc1db01281fc08ae024145e84df927/osfmk/arm64/arm_vm_init.c#L86&quot;&gt;&lt;span&gt;gPhysBase&lt;/span&gt;&lt;/a&gt;&lt;span&gt;” variable (stored in the kernel’s BSS). Reading this value from our research platform will allow us to determine whether the DMA descriptor addresses correspond to host-side physical ranges:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;59&quot; src=&quot;https://lh4.googleusercontent.com/UESKJIxGFUP3WHA_2GwkmvInxyDRopxO7ADqrY-Q-9crZn0EcfEnJOWdaCEyzLBt8VWq3WNzyB11L0GLyQpsY167I3q_YWydYjdlQopS3n4K3lRJ0msHDu0Sug8qqR0AtOCasfms&quot; width=&quot;332&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Ah-ha! The iPhone 7’s DRAM is based at&lt;/span&gt; &lt;span&gt;0x800000000&lt;/span&gt; &lt;span&gt;-- an address&lt;/span&gt; &lt;span&gt;beyond&lt;/span&gt; &lt;span&gt;a 32-bit range.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Therefore, some form of conversion is taking place between the ranges visible to the Wi-Fi chip (IO-Space) and those corresponding to the host’s physical address space. To locate the root cause of this conversion, let’s shift our attention back towards the host.&lt;/span&gt;&lt;/div&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;DART&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;The host and the Wi-Fi chip communicate with one another using a protocol designed by Broadcom, dubbed “MSGBUF”. Using the protocol, both endpoints are able to transmit and receive control messages, as well as traffic, through a set of “message rings”. Each ring is stored within the host’s memory, but is also made accessible to the firmware through DMA.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Since the rings must be accessible through DMA to the Wi-FI chip, locating the code responsible for their initialisation might shed some light on the process through which their physical addresses are converted to the DMA-accessible addresses we encountered in the firmware’s DMA descriptors.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Reverse-engineering&lt;/span&gt; &lt;span&gt;AppleBCMWLANBusInterfacePCIe&lt;/span&gt;&lt;span&gt;, we quickly arrive at the function responsible for initialising the IPC structures utilised by the Wi-Fi chip and the host, including the aforementioned rings:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;1.  void*&lt;/span&gt; &lt;span&gt;init_ring&lt;/span&gt;&lt;span&gt;(void* this, uint64_t&lt;/span&gt; &lt;span&gt;alignment&lt;/span&gt;&lt;span&gt;, IOMapper*&lt;/span&gt; &lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;, ...) {&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;2.      ...&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;3.      IOOptionBits&lt;/span&gt; &lt;span&gt;options&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;kIOMemoryTypeVirtual&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;kIODirectionOutIn&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;4.      IOBufferMemoryDescriptor* desc =&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;6.                                                      &lt;/span&gt;&lt;span&gt;options&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;7.                                                      &lt;/span&gt;&lt;span&gt;capacity&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;8.                                                      &lt;/span&gt;&lt;span&gt;alignment&lt;/span&gt;&lt;span&gt;);                                    &lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;9.      ...&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;11.         &lt;/span&gt;&lt;span&gt;IODMACommand::OutputLittle64&lt;/span&gt;&lt;span&gt;,  &lt;/span&gt;&lt;span&gt;//outSegFunc&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;11.         0,                             &lt;/span&gt;&lt;span&gt;//numAddressBits&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;12.         0,                             &lt;/span&gt;&lt;span&gt;//maxSegmentSize&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;13.         0,                             &lt;/span&gt;&lt;span&gt;//mappingOptions&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;14.         0,                             &lt;/span&gt;&lt;span&gt;//maxTransferSize&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;15.         1,                             &lt;/span&gt;&lt;span&gt;//alignment&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;16.         &lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;,                        &lt;/span&gt;&lt;span&gt;//mapper&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;17.         0);                            &lt;/span&gt;&lt;span&gt;//refCon&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;18      ...&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;20.     ...&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;function 0xFFFFFFF006D1C074&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;As we can see above, the function utilises&lt;/span&gt; &lt;a href=&quot;https://developer.apple.com/library/content/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/Features/Features.html&quot;&gt;&lt;span&gt;I/O Kit&lt;/span&gt;&lt;/a&gt; &lt;span&gt;APIs to manage and map DMA-capable descriptors.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Upon closer inspection, we can see that&lt;/span&gt; &lt;a href=&quot;https://github.com/apple/darwin-xnu/blob/master/iokit/Kernel/IODMACommand.cpp&quot;&gt;&lt;span&gt;IODMACommand&lt;/span&gt;&lt;/a&gt; &lt;span&gt;defers the actual mapping operations to the provided IOMapper instance (“mapper” in the snippet above). However, as luck would have it, the same “mapper” object is stored within the “PCIe object” we identified in the&lt;/span&gt; &lt;a href=&quot;https://googleprojectzero.blogspot.com/2017/09/over-air-vol-2-pt-1-exploiting-wi-fi.html&quot;&gt;&lt;span&gt;first part&lt;/span&gt;&lt;/a&gt; &lt;span&gt;of our research. Therefore, we can proceed to&lt;/span&gt; &lt;a href=&quot;https://github.com/google/Legilimency/blob/master/BCMClient.py#L333&quot;&gt;&lt;span&gt;extract the IOMapper instance&lt;/span&gt;&lt;/a&gt; &lt;span&gt;and begin tracing through its associated code paths.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;While the&lt;/span&gt; &lt;a href=&quot;https://github.com/apple/darwin-xnu/blob/master/iokit/Kernel/IOMapper.cpp&quot;&gt;&lt;span&gt;source code for IOMapper&lt;/span&gt;&lt;/a&gt; &lt;span&gt;is available in the open-sourced portions of XNU, it does not perform any actual mapping operations, but rather delegates them to the “System Mapper” - a globally registered IOMapper instance. Since no concrete subclasses of IOMapper are present in the open-sourced portions of XNU, we can assume that a specialised subclass, performing the actual mapping implementation, exists in one of the proprietary KEXTs.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Indeed, following the extracted IOMapper’s virtual table, we arrive at the&lt;/span&gt; &lt;span&gt;IODARTMapper&lt;/span&gt; &lt;span&gt;class, under&lt;/span&gt; &lt;span&gt;com.apple.driver.IODARTFamily&lt;/span&gt; &lt;span&gt;-- it seems a specialised IOMapper is used after all!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Before we continue down the rabbit hole, let’s take a step back and assess the situation. According to Apple’s&lt;/span&gt; &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Darwin/Conceptual/KernelProgramming/vm/vm.html&quot;&gt;&lt;span&gt;documentation&lt;/span&gt;&lt;/a&gt;&lt;span&gt;, DART stands for “Device Address Resolution Table” -- a hardware component integrated into the memory controller, whose purpose it is to provide a separate address space mapping for 32-bit PCI peripherals. DART allows the system to map physical addresses beyond the 32-bit range to peripherals, and to provide fine-grained control over exposed memory ranges to each device. In short, this is non other than a proprietary IOMMU designed by Apple!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Digging deeper into&lt;/span&gt; &lt;span&gt;IODARTMapper&lt;/span&gt;&lt;span&gt;, we find&lt;/span&gt; &lt;a href=&quot;https://developer.apple.com/documentation/kernel/iomapper/1532983-iovminsert?language=objc&quot;&gt;&lt;span&gt;iovmInsert&lt;/span&gt;&lt;/a&gt;&lt;span&gt;; the entry point for inserting new IO-Space translations through a mapper. Passing through several more layers of indirection, we finally arrive at an instance of&lt;/span&gt; &lt;span&gt;AppleS5L8960XDART&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;128&quot; src=&quot;https://lh4.googleusercontent.com/pSxxjeXRvtVgSY0gW81fcQJGvDIufD9TPlWhWQ-6TOMp2URKuthsn1xcuIc8vzJirMFuZkoWXYmsJep0QdPA99xpulyE55rO8jF7R9FPoU6amFnsd4EyfyLYr8sMlBgBtOZyRIDs&quot; width=&quot;597&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;The latter object originates in a different driver;&lt;/span&gt; &lt;span&gt;com.apple.driver.AppleS5L8960XDART&lt;/span&gt;&lt;span&gt;. It appears we’re getting closer to the bare-metal DART implementation for the SoC! Oddly, the driver references “S5L8960X”; the product code for the Apple A7 SoC (used in older iPhones, such as the 5s). Perhaps this artefact suggests that the same DART implementation has been used in prior SoC revisions.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Taking a closer look at&lt;/span&gt; &lt;span&gt;AppleS5L8960XDART&lt;/span&gt;&lt;span&gt;, we quickly come across a function of particular interest. This function performs many bit shifts and masks, much like we’d expect from translation-table management code. After spending some time familiarising ourselves with the code, we come to the realisation that the function is responsible for populating DART’s translation tables! Here is a high-level representation of the relevant code:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;1.  void*&lt;/span&gt; &lt;span&gt;create_descriptors&lt;/span&gt;&lt;span&gt;(void* this, uint64_t&lt;/span&gt; &lt;span&gt;table_index&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;2.                           uint32_t&lt;/span&gt; &lt;span&gt;start_pfn&lt;/span&gt;&lt;span&gt;, uint32_t&lt;/span&gt; &lt;span&gt;map_size&lt;/span&gt;&lt;span&gt;, ...) {&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;4.      ...&lt;/span&gt; &lt;span&gt;//Validate input arguments, acquire mutex&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;5.      void**&lt;/span&gt; &lt;span&gt;dart_table&lt;/span&gt; &lt;span&gt;= ((void***)(this + 312))[&lt;/span&gt;&lt;span&gt;table_index&lt;/span&gt;&lt;span&gt;];&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;6.      uint32_t&lt;/span&gt; &lt;span&gt;end_pfn&lt;/span&gt; &lt;span&gt; =&lt;/span&gt; &lt;span&gt;start_pfn&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;map_size&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;8.      &lt;/span&gt;&lt;span&gt;//Populating each L0 descriptor in the range&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;9.      uint32_t l0_start_idx = (&lt;/span&gt;&lt;span&gt;start_pfn&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt; 18) &amp;amp; 0x3;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;10.     uint32_t l0_end_idx   = (&lt;/span&gt;&lt;span&gt;end_pfn&lt;/span&gt; &lt;span&gt;  &amp;gt;&amp;gt; 18) &amp;amp; 0x3;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;11.      &lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;12.     for (uint32_t&lt;/span&gt; &lt;span&gt;l0_idx&lt;/span&gt; &lt;span&gt;= l0_start_idx;&lt;/span&gt; &lt;span&gt;l0_idx&lt;/span&gt; &lt;span&gt;&amp;lt;= l0_end_idx;&lt;/span&gt; &lt;span&gt;l0_idx&lt;/span&gt;&lt;span&gt;++) {&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;13.      &lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;14.         &lt;/span&gt;&lt;span&gt;//Creating the L1 table if it doesn’t already exist&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;15.         struct l1_table_t*&lt;/span&gt; &lt;span&gt;l1_table&lt;/span&gt; &lt;span&gt;= (struct l1_table_t*)(&lt;/span&gt;&lt;span&gt;dart_table&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;l0_idx&lt;/span&gt;&lt;span&gt;]);&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;16.         if (!&lt;/span&gt;&lt;span&gt;l1_table&lt;/span&gt;&lt;span&gt;) {&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;17.             &lt;/span&gt;&lt;span&gt;l1_table&lt;/span&gt; &lt;span&gt;= allocate_l1_table(this);&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;18.             &lt;/span&gt;&lt;span&gt;dart_table&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;l0_idx&lt;/span&gt;&lt;span&gt;] =&lt;/span&gt; &lt;span&gt;l1_table&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;19.             uint64_t table_phys =&lt;/span&gt; &lt;span&gt;l1_table&lt;/span&gt;&lt;span&gt;-&amp;gt;desc-&amp;gt;&lt;/span&gt;&lt;a href=&quot;https://developer.apple.com/documentation/kernel/iomemorydescriptor/1812807-getphysicalsegment?language=objc&quot;&gt;&lt;span&gt;getPhysicalSegment&lt;/span&gt;&lt;/a&gt;&lt;span&gt;(...);&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;20.             uint64_t&lt;/span&gt; &lt;span&gt;l0_desc&lt;/span&gt; &lt;span&gt;= ((table_phys &amp;gt;&amp;gt; 12) &amp;amp; 0xFFFFFF) | 0x80000000;&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;22.             set_l0_desc(this,&lt;/span&gt; &lt;span&gt;table_index&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;l0_idx&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;l0_desc&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;23.         }&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;25.         &lt;/span&gt;&lt;span&gt;//Calculating the range of L1 descriptors to populate&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;26.         uint32_t l1_start_idx = (&lt;/span&gt;&lt;span&gt;l0_idx&lt;/span&gt; &lt;span&gt;== l0_start_idx) ?&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;27.                                      (&lt;/span&gt;&lt;span&gt;start_pfn&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt; 9) &amp;amp; 0x1FF : 0;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;28.         uint32_t l1_end_idx   = (&lt;/span&gt;&lt;span&gt;l0_idx&lt;/span&gt; &lt;span&gt;== l0_end_idx) ?&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;29.                                      (&lt;/span&gt;&lt;span&gt;end_pfn&lt;/span&gt; &lt;span&gt;  &amp;gt;&amp;gt; 9) &amp;amp; 0x1FF : 511;&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;31.         &lt;/span&gt;&lt;span&gt;//Populating each L1 descriptor in the range&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;32.         for (uint32_t&lt;/span&gt; &lt;span&gt;l1_idx&lt;/span&gt; &lt;span&gt;= l1_start_idx;&lt;/span&gt; &lt;span&gt;l1_idx&lt;/span&gt; &lt;span&gt;&amp;lt;= l1_end_idx;&lt;/span&gt; &lt;span&gt;l1_idx&lt;/span&gt;&lt;span&gt;++) {&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;34.             &lt;/span&gt;&lt;span&gt;//Creating the L2 table if it doesn’t already exist&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;35.             struct l2_table_t*&lt;/span&gt; &lt;span&gt;l2_table;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;36.             &lt;/span&gt;&lt;span&gt;l2_table&lt;/span&gt; &lt;span&gt;= (struct l2_table_t*)&lt;/span&gt;&lt;span&gt;l1_table&lt;/span&gt;&lt;span&gt;-&amp;gt;l2_tables[&lt;/span&gt;&lt;span&gt;l1_idx&lt;/span&gt;&lt;span&gt;];&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;37.             if (!&lt;/span&gt;&lt;span&gt;l2_table&lt;/span&gt;&lt;span&gt;) {&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;38.                 &lt;/span&gt;&lt;span&gt;l2_table&lt;/span&gt; &lt;span&gt;= allocate_l1_desc(this);&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;39.                 &lt;/span&gt;&lt;span&gt;l1_table&lt;/span&gt;&lt;span&gt;-&amp;gt;l2_tables[&lt;/span&gt;&lt;span&gt;l1_idx&lt;/span&gt;&lt;span&gt;] =&lt;/span&gt; &lt;span&gt;l2_table&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;40.                 uint64_t table_phys =&lt;/span&gt; &lt;span&gt;l2_table&lt;/span&gt;&lt;span&gt;-&amp;gt;desc-&amp;gt;&lt;/span&gt;&lt;a href=&quot;https://developer.apple.com/documentation/kernel/iomemorydescriptor/1812807-getphysicalsegment?language=objc&quot;&gt;&lt;span&gt;getPhysicalSegment&lt;/span&gt;&lt;/a&gt;&lt;span&gt;(...);&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;41.                 &lt;/span&gt;&lt;span&gt;l1_table&lt;/span&gt;&lt;span&gt;-&amp;gt;descriptors[&lt;/span&gt;&lt;span&gt;l1_idx&lt;/span&gt;&lt;span&gt;] = (table_phys &amp;amp; 0xFFFFFF000) | 3;&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;43.                 ...&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;44.             }&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;45.         }&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;46.     }&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;47.     ...&lt;/span&gt; &lt;span&gt;//Release mutex&lt;/span&gt;&lt;/div&gt;


&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;50. struct l1_table_t {&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;51.    IOBufferMemoryDescriptor* desc;      &lt;/span&gt;&lt;span&gt;//Descriptor holding L1 table&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;52.    uint64_t* descriptors;               &lt;/span&gt;&lt;span&gt;//Kernel VA ptr to L1 descs&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;53.    struct l2_table_t* l2_tables[512];   &lt;/span&gt;&lt;span&gt;//L2 descriptors within this table&lt;/span&gt;&lt;/div&gt;


&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;56. struct l2_table_t {&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;57.     IOBufferMemoryDescriptor* desc;     &lt;/span&gt;&lt;span&gt;//Descriptor holding L2 table&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;58.     uint64_t* descriptors;              &lt;/span&gt;&lt;span&gt;//Kernel VA ptr to L2 descs&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;59.     uint64_t unknown;&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;function 0xFFFFFFF0065978F0&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Alright! Let’s take a moment to unpack the above function.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;For starters, it appears that DART utilises a 3-level translation regime. The first level is capable of holding up to four descriptors, while each subsequent level holds 512 descriptors. Since DART uses a 4KB translation granule, we can deduce that, in ascending order, L2 table maps 0x200000 bytes into IO-Space, while L1 tables map up to 0x40000000 bytes.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;In addition to the 3-level regime specified above, DART holds four “base descriptors”. Unlike regular descriptors, these are&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;indexed by bits in the IO-Space address, but are instead referenced explicitly using a parameter provided by the caller.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Drawing on our knowledge of PCIe, we can speculate on the nature of these “base descriptors”. Perhaps each DART can facilitate mappings for several different PCI peripherals on the same bus, where each “base descriptor” corresponds to one such device (based on the “Requester-ID” encoded in the incoming&lt;/span&gt; &lt;a href=&quot;http://xillybus.com/tutorials/pci-express-tlp-pcie-primer-tutorial-guide-1&quot;&gt;&lt;span&gt;TLP&lt;/span&gt;&lt;/a&gt;&lt;span&gt;)? Whether or not this is the case, dumping the “base descriptors” in the DART instance corresponding to the Wi-Fi chip reveals that only the first descriptor is populated in our case.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;In order to access the DART mappings, two distinct sets of data structures are utilised in tandem; a set of “convenience” structures which map the translation hierarchy into high-level objects within the kernel’s virtual address space, and another set holding the descriptors themselves, which are linked together based on physical addresses. The former set is used by the kernel to conveniently locate and modify DART’s mappings, while the latter is used by DART’s hardware to perform the actual IO-Space translations.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;414&quot; src=&quot;https://lh6.googleusercontent.com/8kuuhLw3zfJh6mJwPA89joCmUf4LVFW0dH8oHJw-sWpM7hfElTFAM3mEEONeH2ka0yDNQ8B2MerXHQ76i4UfuThybgX9ci1QT3arpZpVDCag1PXEn_a6JfvbMcBBg8cGkuSfUvXb&quot; width=&quot;703&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Looking more closely at the descriptors, it appears that the translation format utilised by DART is proprietary, and does not match the formats present in the ARM VMSA (including those utilised by&lt;/span&gt; &lt;a href=&quot;https://developer.arm.com/products/system-ip/system-controllers/system-memory-management-unit&quot;&gt;&lt;span&gt;SMMUs&lt;/span&gt;&lt;/a&gt;&lt;span&gt;). Nonetheless, we can deduce the descriptors’ composition by inspecting the code above, which constructs and populates descriptors across the translation hierarchy.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;L0 descriptors encode the physical frame number (using a 4KB translation granule) corresponding to the next level table in the lower bits, and set the 31st bit to indicate a valid entry. L1 and L2 descriptors, on the other hand, use the bottom two bits to indicate validity (setting both bits denotes a valid entry, other combinations result in translation faults), while the top bits store the physical address of either the next translation table or of the 4KB region mapped into IO-Space.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;278&quot; src=&quot;https://lh3.googleusercontent.com/4ei4bJ2Z7Boq2T1X3d-Wl-_k_ldzlaAaGLfy3X2NXt4yJj8Gr2NUZ19QtJLslAA3k1zzbwy8qWnIeWo3DDqpjdzQ4Q5xtOH_57_biFoDa1HSXi9NzbITePGB6eN3nraj01gInmzc&quot; width=&quot;421&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Lastly, we must deduce IO-Space’s base address to complete our analysis of DART’s translation format. Drawing on our previous encounter with IO-Space addresses stored in the DMA descriptors within the Wi-Fi firmware, all the addresses appeared to be based at address 0x80000000. As such, it seems like a fair assumption that IO-Space mappings for the Wi-Fi chip begin at the aforementioned address.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Combining all of the information above, let’s&lt;/span&gt; &lt;a href=&quot;https://github.com/google/Legilimency/blob/master/DART.py&quot;&gt;&lt;span&gt;build a module&lt;/span&gt;&lt;/a&gt; &lt;span&gt;in our research platform to interact with the DART instance. The module will&lt;/span&gt; &lt;a href=&quot;https://github.com/google/Legilimency/blob/master/DART.py#L59&quot;&gt;&lt;span&gt;analyse DART’s translation tables&lt;/span&gt;&lt;/a&gt;&lt;span&gt;, following the hierarchy described above. By analysing the translation tables, we can subsequently hold a mapping between IO-Space addresses and their corresponding physical ranges within the host’s PAS. Furthermore, we can&lt;/span&gt; &lt;span&gt;invert&lt;/span&gt; &lt;span&gt;the tables in order to produce a PAS to IO-Space mapping. Using these two mappings we can subsequently convert&lt;/span&gt; &lt;a href=&quot;https://github.com/google/Legilimency/blob/master/DART.py#L114&quot;&gt;&lt;span&gt;IO-Space addresses to physical addresses&lt;/span&gt;&lt;/a&gt;&lt;span&gt;, and&lt;/span&gt; &lt;a href=&quot;https://github.com/google/Legilimency/blob/master/DART.py#L125&quot;&gt;&lt;span&gt;vice versa&lt;/span&gt;&lt;/a&gt;&lt;span&gt;.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Finally, in addition to inspecting IO-Space, our DART module also allows us to&lt;/span&gt; &lt;span&gt;manipulate&lt;/span&gt; &lt;span&gt;IO-Space, by&lt;/span&gt; &lt;a href=&quot;https://github.com/google/Legilimency/blob/master/DART.py#L136&quot;&gt;&lt;span&gt;introducing new mappings into IO-Space&lt;/span&gt;&lt;/a&gt; &lt;span&gt;containing whichever physical address we desire.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;At long last, we can test whether our deductions regarding DART’s structure are indeed valid. First, let’s&lt;/span&gt; &lt;a href=&quot;https://github.com/google/Legilimency/blob/master/BCMClient.py#L327&quot;&gt;&lt;span&gt;extract the DART instance corresponding to the Wi-Fi chip&lt;/span&gt;&lt;/a&gt;&lt;span&gt;. Then, using this object, we can proceed to dump the entire mapping between IO-Space addresses and their corresponding physical ranges by following DART’s translation hierarchy:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;161&quot; src=&quot;https://lh3.googleusercontent.com/KtWMrcLFyaY0IUvP6evCXbDDL4tSAGXoEQCTxpm5uFJp9vTVYS2H1Yu1DyHWwJHLn5eFJh84A5vQjTjppPyAUO7pyMrbhqPhX03qgtE_gfRjwxiblT9C89tn_eEdGvGz8TVJjIi8&quot; width=&quot;238&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Great! The first few mappings appear sane -- each IO-Space address is translated into a corresponding physical range well within the host’s PAS. Moreover, we can see that our assumption regarding DART’s translation granule holds, as some mapped physical addresses are within a 4KB range from one another.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;To be absolutely certain that our assessment is valid, let’s perform another short experiment. We’ll map-in an unused IO-Space address, pointing it at a physical address corresponding to “spare” data within the kernel’s BSS. Next, using the DMA hook we inserted previously, we’ll direct unconsumed DMA descriptors at the newly mapped IO-Space address. By doing so, subsequent DMA transfers should arrive at our chosen BSS address.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;After inserting the hook and monitoring the mapped BSS range (by reading it through the kernel’s VAS), we are presented with the following result:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;78&quot; src=&quot;https://lh3.googleusercontent.com/k1GJnwEZgcQ2yxdeb7uRNodeKHLzYftfSkFINDArX8KNae7O5IJifm4cemxY46qV8bT7bKpg9PPeoa8t-tEYw_EP4LFB1rkD4bRUwjCrzFAYqAa2gDTbciHvhECmkG0r5RXXR79l&quot; width=&quot;519&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Awesome! We managed to DMA into an arbitrary physical address within the kernel’s BSS, thus confirming that our understanding of DART is correct.&lt;/span&gt;&lt;/div&gt;
&lt;h3 dir=&quot;ltr&quot;&gt;&lt;span&gt;Exploring DART&lt;/span&gt;&lt;/h3&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Using our newly acquired control over IO-Space, we can proceed to conduct a few experiments.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;For starters, it would be interesting to see whether the kernel integrity mechanisms present on the iPhone 7 (“&lt;/span&gt;&lt;a href=&quot;https://github.com/apple/darwin-xnu/blob/0a798f6738bc1db01281fc08ae024145e84df927/pexpert/pexpert/arm64/hurricane.h#L10&quot;&gt;&lt;span&gt;KTRR&lt;/span&gt;&lt;/a&gt;&lt;span&gt;”, previously referred to as “AMCC”), still hold in the presence of malicious DMA attempts from the Wi-Fi chip. To find out, we’ll map each of the protected physical ranges (the kernel’s code segments, read-only segments, etc.) into IO-Space, insert the DMA hook, and observe their contents to see whether they were successfully modified.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Unsurprisingly, each attempt to DMA into a protected region results in a fault being raised, subsequently triggering a kernel panic and crashing the device. Attempting to DMA into the KTRR’s hardware registers&lt;/span&gt; &lt;a href=&quot;https://github.com/apple/darwin-xnu/blob/master/pexpert/pexpert/arm64/AMCC.h#L15&quot;&gt;&lt;span&gt;storing protected region ranges&lt;/span&gt;&lt;/a&gt; &lt;span&gt;similarly fails -- once the lockdown occurs, no modification of the registers is permitted.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;71&quot; src=&quot;https://lh5.googleusercontent.com/p_6XIeMn0_YrYjIrNk6HJnJDa8-WJl5Ulai-gRvUPVWoxOcKwEQcLirvx1m4maSVs8ZEs2ulFlyQmoznqbZbJNNbTQYt7XVkf_AlheApwy6wOq0AWX-4J3wdGUWvqX6PEpEBC3dM&quot; width=&quot;597&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Continuing our analysis of DART, let’s consider another edge-case scenario: assume two subsequent IO-Space mappings correspond to non-contiguous ranges of physical memory. In such a case, should DMA operations&lt;/span&gt; &lt;span&gt;crossing the boundary&lt;/span&gt; &lt;span&gt;between the two IO-Space ranges be permitted? If so, should the data be split across the corresponding physical ranges? Or should the transfer instead only utilise the first physical range?&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;To find out, we’ll conduct another experiment. First, we’ll create two IO-Space mappings pointing at disparate regions in the Kernel’s BSS. Then, using the DMA engine, we’ll initiate a transfer crossing the boundary between the two IO-Space addresses.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;190&quot; src=&quot;https://lh4.googleusercontent.com/qGl05_CKkQxhn4WKiAnKS-15hMMwEV-1A0fSH9AF8nF2d7eIYbmeKE7_g3iU1vIEhCotbyGY9N9VRKdvSwCh9n4noyMQySZx5TfoQb42mSbWmrgJCTaT9rdOOUeo_1G7AyXNliUE&quot; width=&quot;463&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Running the above experiment and monitoring the resulting addresses through the kernel’s VAS, we are presented with a positive result -- DART correctly splits the transaction into the two corresponding physical ranges, thus never exceeding any of the mapped-in regions’ bounds.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;So far, so good.&lt;/span&gt;&lt;/div&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;PCIe Configuration Space&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Continuing our investigation of DART, we arrive at another query -- how does DART perform context determination? Namely, how does DART differentiate between the components issuing the memory access requests?&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Depending on DART’s architecture, several solutions to this question exist. If each DART is assigned to a single component or a single PCIe bus, no identification is needed, as it can simply funnel all operations from that origin through its translation mechanism. Alternately, if several PCIe components exist on the bus to which DART is assigned, it&lt;/span&gt; &lt;span&gt;could&lt;/span&gt; &lt;span&gt;utilise the “Requester ID” (RID) field in the PCIe&lt;/span&gt; &lt;a href=&quot;http://xillybus.com/tutorials/pci-express-tlp-pcie-primer-tutorial-guide-1&quot;&gt;&lt;span&gt;TLP&lt;/span&gt;&lt;/a&gt; &lt;span&gt;to identify the originating component.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Using the RID for context determination is not risk-free, as malicious PCIe components may attempt to&lt;/span&gt; &lt;a href=&quot;https://github.com/Cr4sh/s6_pcie_microblaze&quot;&gt;&lt;span&gt;“spoof” the contents of their TLPs&lt;/span&gt;&lt;/a&gt;&lt;span&gt;. To deal with such scenarios, PCIe introduced&lt;/span&gt; &lt;a href=&quot;https://pcisig.com/sites/default/files/specification_documents/ECN__Integrated_Endpoints_and_IOV_updates__19%20Nov%202015_Final.pdf&quot;&gt;&lt;span&gt;Access Control Services&lt;/span&gt;&lt;/a&gt; &lt;span&gt;(ACS), allowing PCIe switches to perform routing decisions, including disallowing transfer of certain TLPs based on their encompassed IDs. As we are not aware of the PCIe topology on the iPhone, it remains unknown whether such a configuration is needed (or used).&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;With regards to control over the PCIe TLPs, Broadcom’s Wi-Fi chips expose much of the PCIe Core’s functionality to the Wi-Fi firmware by mapping the core’s registers through a fixed backplane address. Previous Broadcom SoC revisions, which incorporated PCIe Gen 1 cores, allowed access to several “diagnostic” registers (via&lt;/span&gt; &lt;a href=&quot;https://github.com/spotify/linux/blob/master/drivers/staging/brcm80211/include/pcie_core.h#L73&quot;&gt;&lt;span&gt;pcieindaddr&lt;/span&gt;&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;https://github.com/spotify/linux/blob/master/drivers/staging/brcm80211/include/pcie_core.h#L74&quot;&gt;&lt;span&gt;pcieinddata&lt;/span&gt;&lt;/a&gt;&lt;span&gt;), which govern over the physical (PLP), data link (DLLP) and transport (TLP) layers of PCIe. Regardless, it is unknown whether the this mechanism allows modification of the RID, or indeed whether this form of access is still present in current-gen Broadcom hardware.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Nevertheless, standardised PCIe mechanisms exist which may also affect the RID’s composition. For instance, PCIe 3.0 introduced&lt;/span&gt; &lt;a href=&quot;https://pcisig.com/sites/default/files/specification_documents/ECN-alt-rid-interpretation-070604.pdf&quot;&gt;&lt;span&gt;Alternate Routing-ID Interpretation&lt;/span&gt;&lt;/a&gt; &lt;span&gt;(ARI), which modifies the encoding of the RID, eliminating the “device” field while expanding the “function” field to 8 bits.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;95&quot; src=&quot;https://lh4.googleusercontent.com/UUS4y65wR3CB_jzQAJZy6Vgqc3ZluciYlWKlBTNwDIzr8KWVbj2NG1zPdpMGBBGqeSnroZl_c2uUFXw0YY_ZW5e2GyrUAjkjEF8RuR48XCRF5MxTvd61Ri1IggFBdexsBSDtpyXx&quot; width=&quot;587&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;While normally the PCIe Configuration Space is accessed through the host, Broadcom’s Wi-Fi SoC exposes the configuration space&lt;/span&gt; &lt;span&gt;within the Wi-Fi SoC&lt;/span&gt;&lt;span&gt;, through a pair of backplane registers corresponding to the PCIe Core (&lt;/span&gt;&lt;a href=&quot;https://github.com/spotify/linux/blob/master/drivers/staging/brcm80211/include/pcie_core.h#L65&quot;&gt;&lt;span&gt;configaddr&lt;/span&gt;&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;https://github.com/spotify/linux/blob/master/drivers/staging/brcm80211/include/pcie_core.h#L66&quot;&gt;&lt;span&gt;configdata&lt;/span&gt;&lt;/a&gt;&lt;span&gt;). Using these registers, the Wi-Fi firmware can not only read the PCIe Configuration Space, but also modify values within it. Like many advanced PCIe features, ARI is exposed in the configuration space through an “extended capability” blob; therefore, if ARI is supported by the PCIe core, we could utilise our access to the configuration space to enable the feature from the Wi-Fi firmware.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;To determine whether such capabilities are present in the PCIe core, we’ll produce a dump of the configuration space (using the aforementioned register pair). After doing so, we can simply reorganise the contents in a format legible to&lt;/span&gt; &lt;a href=&quot;https://linux.die.net/man/8/lspci&quot;&gt;&lt;span&gt;lspci&lt;/span&gt;&lt;/a&gt;&lt;span&gt;, and instruct it to parse the given data, producing a human-readable representation of the features supported by the PCIe core:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;665&quot; src=&quot;https://lh5.googleusercontent.com/B0CzIKzrpEgfyi0rOgxXFjEqxbfuNa5CNLXN5BrH5innXq-SYQGR34YJZUx6BqEZD-jQTff4rkUlmUc1ebPLJOZehZLs1Bi_MOAWaJR5GoTzmYIUT9vK18kMPM6hzkoxl7BRHQoU&quot; width=&quot;566&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Scanning through the above capabilities, it appears that none of the “advanced” PCIe features (such as ARI) are supported by the PCIe core.&lt;/span&gt;&lt;/div&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;Exploring IO-Space&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;While we’ve already determined how DART facilitates the IO-Space mapping for the Wi-Fi chip, we have yet to investigate the contents of the memory exposed through this mechanism. In order to investigate IO-Space’s contents, we’ll use a two-stage translation process; first, we’ll use our&lt;/span&gt; &lt;a href=&quot;https://github.com/google/Legilimency/blob/master/DART.py&quot;&gt;&lt;span&gt;DART module&lt;/span&gt;&lt;/a&gt; &lt;span&gt;to produce a mapping between the IO-Space addresses and their corresponding physical ranges. Once we obtain the mapped physical ranges, all that remains is to map these ranges into the kernel’s VAS, allowing us to subsequently dump their contents using our research platform.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;As we know, the mapping from virtual to physical addresses is governed by the&lt;/span&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_management_unit&quot;&gt;&lt;span&gt;MMU&lt;/span&gt;&lt;/a&gt;&lt;span&gt;’s translation tables. On ARMv8-A platforms (such as the iPhone 7), the ARM Virtual Memory System Architecture (VMSA) specifies the format of the translation tables utilised by the ARM MMU. Like any XNU task, the kernel’s translation tables are accessible through its&lt;/span&gt; &lt;a href=&quot;https://github.com/apple/darwin-xnu/blob/master/osfmk/kern/task.h#L147&quot;&gt;&lt;span&gt;task_t&lt;/span&gt;&lt;/a&gt; &lt;span&gt;structure (exported through its data segment). Following the entries in the task structure, we arrive at its&lt;/span&gt; &lt;a href=&quot;https://github.com/apple/darwin-xnu/blob/master/osfmk/arm/pmap.h#L239&quot;&gt;&lt;span&gt;pmap&lt;/span&gt;&lt;/a&gt;&lt;span&gt;, holding the translation tables.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;

&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Using our new module, we can now perform translations between the virtual addresses in the kernel’s VAS and physical ones. Furthermore, we can&lt;/span&gt; &lt;span&gt;invert&lt;/span&gt; &lt;span&gt;the translation table, producing a (one-to-many) mapping from physical to virtual addresses. In tandem with our DART module, this allows us to take each IO-Space address, convert it to a physical address, and then use our inverted translation table to convert it back to a virtual address in the kernel’s VAS.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Consequently, we can now iterate over the entire IO-Space exposed to the Wi-Fi chip, extracting the contents of every mapped region:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;188&quot; src=&quot;https://lh5.googleusercontent.com/yyxvzwWthY65RhWx5bq6MKuRkUDjUNbkrchS2b37ybaq1t2HSkssaUUFcB_XAsLwTx8vcYLl-2wjo0YDHCNK8SogKR0i5PpIp2j5ylLHePnW1cggsHkuSW9GMg6qQmGm32cKlv-p&quot; width=&quot;612&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;After producing a copy of the entire contents of IO-Space, we can now comb through it, searching for any “accidental” mappings that might be beneficial for a would-be attacker present on the Wi-Fi chip.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;For starters, recall that the kernel protects itself against remote attackers by utilising KASLR. This mitigation introduces a randomised “slide” value, which is added to the kernel’s base loading address (both virtual and physical). Since many exploits rely on the ability to pre-calculate addresses within the kernel’s VAS, such a mitigation may slow down attackers, or hinder the reliability of exploits targeting the kernel.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;However, as the same “slide” value is applied globally, it is often the case that a single “leaked” kernel VAS address results in a KASLR bypass (allowing attackers to deduce the slide’s value). Therefore, if any kernel virtual address is accidentally leaked in an IO-Space mapped page, the Wi-Fi chip may be able to similarly subvert KASLR.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Apart from the potential implications regarding KASLR, the presence of any kernel VAS pointer in IO-Space would be worrisome, as the pointer might be utilised by kernel code. Allowing a malicious Wi-Fi chip to corrupt its value may subsequently affect the kernel’s behaviour (perhaps even resulting in code execution).&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;To find out whether any kernel pointers are exposed through IO-Space, let’s scan through the extracted IO-Space pages, searching for 64-bit words corresponding to addresses within the kernel’s VAS. After going through every single page, we are greeted with a negative result; we can find no kernel VAS pointers in any IO-Space mapped page!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;With a cursory investigation of IO-Space out of the way, we can now dig deeper, attempting to gain a better understanding of the IO-mapped contents. To this end, we’ll combine several approaches:&lt;/span&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li dir=&quot;ltr&quot;&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Inspect each page’s contents to look for hints regarding its role&lt;/span&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li dir=&quot;ltr&quot;&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Locate the kernel code responsible for interacting with the same IO-Space range&lt;/span&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li dir=&quot;ltr&quot;&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Check the IO-Space address against posted addresses in the Wi-Fi firmware&lt;/span&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li dir=&quot;ltr&quot;&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Use the Android driver as reference for any “strange” unidentified constructs&lt;/span&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;After performing the above steps, we are finally able to piece together a complete mapping of IO-Space (thus also concluding that no “accidental” mappings are present). It is important to note that since IO-Space is not subject to randomisation, the IO addresses are&lt;/span&gt; &lt;span&gt;constant&lt;/span&gt;&lt;span&gt;, and are not affected by the KASLR slide.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;370&quot; src=&quot;https://lh6.googleusercontent.com/T32UIpLsBbHWdR_0g8jkssv8FSGBYXdcgVIcUUPR731VxBxy9lnQzx3ggQfIJBdf6PtOaMZZrXXR7QN2Ros2X7p23RFXg2_uGlcAfQVapmkOit781UO3lAeYOHHmeQljxVer6Leb&quot; width=&quot;797&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3 dir=&quot;ltr&quot;&gt;&lt;span&gt;Searching For Vulnerabilities&lt;/span&gt;&lt;/h3&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Having explored the aspects relating to DART, IO-Space mappings, and low-level components, let’s proceed to inspect the more traditional attack surfaces exposed by the host.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Recall that the Wi-Fi chip and the host communicate with one another through a series of “rings”, mapped into IO-Space. Each ring facilitates the transfer of information in a single direction; either from the device to the host (D2H), or vice versa (H2D).&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Among the messages transferred through message rings, “Control Messages” represent a rather abundant attack surface. These message are used to instruct the firmware to perform complex state-changing operations, such as creating additional message rings, deleting them, and even transporting high-level requests (&lt;/span&gt;&lt;span&gt;ioctls&lt;/span&gt;&lt;span&gt;) to be processed by the firmware.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Due to their complexity, control messages rely on a bidirectional communication channel; the “Control Submit” ring (H2D) allows the host to submit the requests to the device, while the “Control Complete” ring (D2H) is used by the device to return the results back to the host.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;After committing messages to the D2H rings, the Wi-Fi firmware signals the host by writing to a “MailBox” register and triggering an MSI interrupt. This interrupt is subsequently handled by the host, which inspects the MailBox register, and notifies the corresponding (D2H) rings that data may be available for processing.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;318&quot; src=&quot;https://lh5.googleusercontent.com/MbCmegmMfvcG5Tg11VRiYOUAVAzBYEzBKkbZz6juApN9KddRt7IWz7XN5B3Mjp5MUXS0wF6SmsLCrKhnJANtsxDyoMJUMc-Fmwbb3lgHJ7REH9qslv6FzQX8iOnJEOLjo42D2obu&quot; width=&quot;582&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Tracing through the above flow, we reach the handler function for processing incoming control messages within the host. To assist in reverse-engineering these messages, we’ll utilise Broadcom’s Android driver (&lt;/span&gt;&lt;a href=&quot;https://android.googlesource.com/kernel/common.git/+/bcmdhd-3.10&quot;&gt;&lt;span&gt;bcmdhd&lt;/span&gt;&lt;/a&gt;&lt;span&gt;), which contains the definitions for the control structures, as well as the message codes corresponding to each request.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;249&quot; src=&quot;https://lh4.googleusercontent.com/8hhA3UnUSduP2nF46-DKtz0NWJ31eA9xBQfAZsiXApDIpXOJmhJlxjeDpkGL8ixS6O2bmdXryT29GVuheCxvJ2j3vDGoqnmDNJFRF5i0DvRUDHpgaYneY3WigInc8PLJs0Ow93kf&quot; width=&quot;463&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;AppleBCMWLANBusPCIeInterface::drainControlCompleteRing&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;The encapsulating handler simply reads the “message type” field, and proceeds to delegate the message’s processing to a dedicated handler -- one per message type. Going over each of the handlers, we stumble across a&lt;/span&gt; &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1302&quot;&gt;&lt;span&gt;memory corruption bug&lt;/span&gt;&lt;/a&gt; &lt;span&gt;triggerable by the firmware. Incidentally, the bug was present in a handler for a message type which isn’t available in the Android driver.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Moving on, let’s set our sights on slightly higher targets in the protocol stack. Recall that control rings are also used to carry high-level control requests from the host to the firmware, dubbed “ioctls”. Each&lt;/span&gt; &lt;span&gt;ioctl&lt;/span&gt; &lt;span&gt;allows the host to either set a firmware-specific configuration value, or to retrieve its current value. As this channel is quite versatile, much of the high-level interaction between the host and the firmware is enacted through this channel, including retrieving the current channel, setting network configurations, and more.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;However, like any other signal originating from the device, it is important to remember that “ioctls” can be co-opted by malicious Wi-Fi firmware. After all, an attacker controlling the Wi-Fi firmware can simply hook the “ioctl” handling function, thereby allowing full control over the contents transmitted back to the host.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Reverse-engineering the high-level driver,&lt;/span&gt; &lt;span&gt;AppleBCMWLANCore&lt;/span&gt;&lt;span&gt;, we quickly identify the entry point responsible for issuing&lt;/span&gt; &lt;span&gt;ioctl&lt;/span&gt; &lt;span&gt;requests from the host to the Wi-Fi firmware. Cross referencing the function, we find nearly 500 call sites, several of which act as wrappers for common functionality, thus revealing even more originating call sites. After going over each of the aforementioned sites, we discover&lt;/span&gt; &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1305&quot;&gt;&lt;span&gt;several&lt;/span&gt;&lt;/a&gt; &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1312&quot;&gt;&lt;span&gt;memory&lt;/span&gt;&lt;/a&gt; &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1313&quot;&gt;&lt;span&gt;corruptions&lt;/span&gt;&lt;/a&gt; &lt;span&gt;in their corresponding handlers.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Lastly, there’s one more communication channel to consider -- Broadcom allows the in-band transmission of “event packets” from the Wi-Fi firmware to the host. These frames, denoted by a unique&lt;/span&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/EtherType&quot;&gt;&lt;span&gt;EtherType&lt;/span&gt;&lt;/a&gt; &lt;span&gt;(0x886C), carry unsolicited events from the firmware, requiring special handling by the host. Tracing through the host’s RX path brings us to the entry point for handling such frames:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;263&quot; src=&quot;https://lh3.googleusercontent.com/mub84C4XhV6S1d4LHodaHW8DPR9yRNEeCbuWD-V1k0hqJ_lPZEVZ6ac-RZtjH-yNBpawNPdg2x9NTMIe6Lp8esYly1fdRO5G6jq7gUx36J-XrBkhCEteQIds0BRWy0AVj0QM3tM0&quot; width=&quot;478&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;AppleBCMWLANCore::handleEventPacket&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Once again, going over each handler in the above function (while using the Android driver to assist our understanding of the corresponding event codes and data structures), we discover&lt;/span&gt; &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1318&quot;&gt;&lt;span&gt;two&lt;/span&gt;&lt;/a&gt; &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1314&quot;&gt;&lt;span&gt;more&lt;/span&gt;&lt;/a&gt; &lt;span&gt;vulnerabilities.&lt;/span&gt;&lt;/div&gt;
&lt;h3 dir=&quot;ltr&quot;&gt;&lt;span&gt;Better Vulnerabilities&lt;/span&gt;&lt;/h3&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;Data Races?&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;While the vulnerabilities we just discovered allow us to trigger several forms of memory corruptions in the host (OOB writes, heap overflows), and even to leak constrained data from the host to the firmware, reliably exploiting any of them remains rather challenging.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;For starters, the Wi-Fi chip has no visibility into the host’s memory (apart from the IO-Space mapped regions), and relatively little control over objects allocated within the kernel. Therefore, grooming the kernel’s memory in order to successfully launch a heap memory corruption attack would require significant effort. What’s more, this challenge is compounded by the presence of KASLR, preventing us from accurately locating the kernel’s data structures (barring any information disclosure).&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Nonetheless, perhaps we can identify better primitives by digging deeper!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;So far, we’ve only considered the&lt;/span&gt; &lt;span&gt;contents&lt;/span&gt; &lt;span&gt;of the data transferred between the host and the firmware. Effectively, we were thinking of the firmware and the host as two distinct entities, communicating with one another through an isolated communication channel. In fact, nothing can be further from the truth -- the two endpoints share a PCIe interface, allowing the firmware to perform DMA accesses at will to any IO-Space address.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;One of the major risks when using a shared memory interface is the matter of&lt;/span&gt; &lt;span&gt;timing&lt;/span&gt;&lt;span&gt;. While the host and firmware normally synchronise their operations to ensure that no data races occur, attackers controlling the Wi-Fi firmware are bound by no such agreement. Using our control over the Wi-Fi chip, we can&lt;/span&gt; &lt;span&gt;intentionally&lt;/span&gt; &lt;span&gt;modify data structures within IO-Space&lt;/span&gt; &lt;span&gt;as they are being accessed by the host&lt;/span&gt;&lt;span&gt;. Doing so might allow us to introduce race conditions, such as&lt;/span&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use&quot;&gt;&lt;span&gt;TOCTTOU&lt;/span&gt;&lt;/a&gt;&lt;span&gt;s, creating vulnerable conditions in otherwise safe code (under normal assumptions).&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;The first target for such modification are the control messages we inspected earlier on. Inspecting the control ring handler in the host, it appears that the messages are read&lt;/span&gt; &lt;span&gt;directly&lt;/span&gt; &lt;span&gt;from the IO-Space mapped buffer, raising the possibility for data races in their processing. Nonetheless, going over the relevant code paths, we find no security-relevant races.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;What about the second control channel we reviewed -- event packets? Perhaps we could modify a packet’s contents while it is being processed, thereby affecting the kernel’s behaviour? Once again, the answer is negative; each transferred packet is first copied from its IO-Space mapped buffer to a kernel-resident&lt;/span&gt; &lt;a href=&quot;https://github.com/apple/darwin-xnu/blob/master/bsd/sys/mbuf.h&quot;&gt;&lt;span&gt;mbuf&lt;/span&gt;&lt;/a&gt; &lt;span&gt;before subsequently passing it on for processing, thus eliminating the possibility of firmware-induced races.&lt;/span&gt;&lt;/div&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;Message Rings, Revisited&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;So far, we’ve inspected the high-level functionality provided by message rings, namely, the control messages transported therein. However, we’ve neglected several aspects of their operation. One implementation detail of particular note is the method through which rings allow the endpoints to&lt;/span&gt; &lt;span&gt;synchronise&lt;/span&gt; &lt;span&gt;their accesses to the ring.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;To allow concurrent accesses by both the ring’s consumer and its corresponding producer, each ring is assigned a pair of indices: a&lt;/span&gt; &lt;span&gt;read index&lt;/span&gt; &lt;span&gt;specifying the location up to which the consumer has read the messages, and a&lt;/span&gt; &lt;span&gt;write index&lt;/span&gt; &lt;span&gt;specifying the location at which the next message will be submitted by the producer. As their name implies, each ring forms a circular buffer -- upon arriving at the last ring index, the indices simply wrap around, returning back to the ring’s base.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;108&quot; src=&quot;https://lh3.googleusercontent.com/0jkBkzL2_01OsrZ32u3KRZGVH0lT-LaNxOAZpQVOAyi3ZJr9U2h0YFyDqdyhJzG9sJFULxlBA042snZfrEK3E0GQfPV-KQq08q_89IEiS8Zkbkd5RTuIpf0fh8K35BDzl8nB7hsT&quot; width=&quot;298&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Since both endpoints must be aware of the ring indices to successfully coordinate their access, a mechanism must exist through which the indices may be shared between the two. In Apple’s case, this is achieved by mapping all the indices into IO-Space mapped buffers.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;74&quot; src=&quot;https://lh6.googleusercontent.com/Zn5fRQuLT9WeKUbqbvV9gWkLS-Kg0zmyzlTvE71ua0IZYQItHmZNbPBk-CVY9kQA-gBvZRTJiyx4aOcmID1cQLKaYnQP49uX1oMafscX0OkVzwRsNumoiM_HgxB7f4OxQdJ3AvCk&quot; width=&quot;558&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;While mapping the indices into IO-Space is a convenient way to share their values, it is not risk-free. For starters, if all the above indices are mapped into IO-Space, a malicious Wi-Fi chip may not only utilise DMA access to&lt;/span&gt; &lt;span&gt;read&lt;/span&gt; &lt;span&gt;them, but may also be able to&lt;/span&gt; &lt;span&gt;modify&lt;/span&gt; &lt;span&gt;them.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;This form of access is excessive -- after all, the device need only update the read indices for H2D rings, and the write indices for D2H rings. The remaining indices should, at most, be read by the device. However, as DART’s implementation is proprietary, it is unknown whether it can facilitate read-only mappings. Consequently, all of the above indices are mapped into IO-Space as&lt;/span&gt; &lt;span&gt;both readable and writable&lt;/span&gt;&lt;span&gt;, thus allowing a malicious Wi-Fi chip to freely alter their values.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;This IO-Space-based index sharing mechanism raises an important question; what if a Wi-Fi chip were to maliciously modify a ring’s indices while the ring is being processed by the host? Would doing so introduce a race condition? To find out, let’s take a look at the function through which the host submits messages into H2D rings:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;1.  void*&lt;/span&gt; &lt;span&gt;AppleBCMWLANPCIeSubmissionRing::workloopSubmitTx&lt;/span&gt;&lt;span&gt;(uint32_t* p_&lt;/span&gt;&lt;span&gt;read_index,&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;2.                                                         uint32_t* p_write_index) {&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;4.      &lt;/span&gt;&lt;span&gt;//Getting the write index from the IO-Space mapped buffer (!)&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;5.      &lt;/span&gt;&lt;span&gt;uint32_t&lt;/span&gt; &lt;span&gt;write_index&lt;/span&gt; &lt;span&gt;= *(this-&amp;gt;&lt;/span&gt;&lt;span&gt;write_index_ptr&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;6.      &lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;7.      &lt;/span&gt;&lt;span&gt;//Iterating until there are no more events to process&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;8.      while (this-&amp;gt;&lt;/span&gt;&lt;span&gt;getRemainingEvents&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;p_&lt;/span&gt;&lt;span&gt;read_index, p_write_index)) {&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;10.         &lt;/span&gt;&lt;span&gt;//Calculate the next insertion address based on the write index&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;11.         void*&lt;/span&gt; &lt;span&gt;ring_addr&lt;/span&gt; &lt;span&gt;= this-&amp;gt;&lt;/span&gt;&lt;span&gt;ring_base&lt;/span&gt; &lt;span&gt;+ this-&amp;gt;&lt;/span&gt;&lt;span&gt;item_size&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;write_index&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;12.         uint32_t&lt;/span&gt; &lt;span&gt;max_events&lt;/span&gt; &lt;span&gt;= this-&amp;gt;&lt;/span&gt;&lt;span&gt;calculateRemainingWriteSpace&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;14          &lt;/span&gt;&lt;span&gt;//Writing the current events to the ring&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;15.         uint32_t&lt;/span&gt; &lt;span&gt;num_written&lt;/span&gt; &lt;span&gt;= this-&amp;gt;&lt;/span&gt;&lt;span&gt;submit_func&lt;/span&gt;&lt;span&gt;(...,&lt;/span&gt; &lt;span&gt;ring_addr&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;max_events&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;16.         if (!&lt;/span&gt;&lt;span&gt;num_written&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;17.             break;&lt;/span&gt; &lt;span&gt;//No more events to process&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;19.         &lt;/span&gt;&lt;span&gt;//Update the write index&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;20.         &lt;/span&gt;&lt;span&gt;write_index&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;num_written&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;21.         if (&lt;/span&gt;&lt;span&gt;write_index&lt;/span&gt; &lt;span&gt;&amp;gt;= this-&amp;gt;&lt;/span&gt;&lt;span&gt;max_index&lt;/span&gt;&lt;span&gt;) {&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;22.             &lt;/span&gt;&lt;span&gt;write_index&lt;/span&gt; &lt;span&gt;= 0;&lt;/span&gt; &lt;span&gt;//Wrap around&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;24.         &lt;/span&gt;&lt;span&gt;//Commit the new index to the IO-Space mapped buffer (!)&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;25.         *(this-&amp;gt;&lt;/span&gt;&lt;span&gt;write_index_ptr&lt;/span&gt;&lt;span&gt;) =&lt;/span&gt; &lt;span&gt;write_index&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;26.     }&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;27.     ...&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;30. class AppleBCMWLANPCIeSubmissionRing {&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;31.     ...&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;32.     uint32    max_index;          &lt;/span&gt;&lt;span&gt;//The maximal ring index               (off 88)&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;33.     uint32    item_size;          &lt;/span&gt;&lt;span&gt;//The size of each item                (off 92)&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;33.     uint32_t* read_index_ptr;     &lt;/span&gt;&lt;span&gt;//IO-Space mapped read index pointer   (off 174)&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;34.     uint32_t* write_index_ptr;    &lt;/span&gt;&lt;span&gt;//IO-Space mapped write index pointer  (off 184)&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;35.     void*     ring_base;          &lt;/span&gt;&lt;span&gt;//IO-Space mapped ring base address    (off 248)&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;function 0xFFFFFFF006D36D04&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Alright! Looking at the above function immediately raises some red flags…&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;The function appears to read values from IO-Space mapped buffers in several different locations, seemingly making no effort to coordinate the read values. This kind of pattern opens the door to the possibility of race conditions induced by the firmware.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Let’s focus on the “write index” utilised by the function. At first, the index is fetched by reading its value directly from the IO-Space mapped buffer (line 5). This same value is then used to derive the location to which the next ring item will be written (line 11). Crucially, however, the value is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;used in any shape or form by the surrounding verifications utilised by the function to decide whether the current ring indices are valid (lines 8, 12).&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Therefore, the verification methods must re-fetch the indices’ values, introducing a possible discrepancy between the value used during verification, and the one used to place the next item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;To exploit the above issue, an attacker controlling the Wi-Fi chip can DMA into the ring indices in order to introduce one value for the ring address calculation (line 5), while quickly switching the index to a different, valid value, for the remaining validations (lines 8, 12). If the above race is executed successfully, the following H2D item will be submitted by the host at an arbitrary attacker-controller offset from the ring’s base, triggering an out-of-bounds write!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;139&quot; src=&quot;https://lh6.googleusercontent.com/TQTpawlaT-h8MRAlfOO5vjJNHd6m6_yFll4NbxLNVyyyNfhlV0vWiEzPV6yeLv-Couxv2YZeYqsmj1MiSh2LfzlTcT7ontNMkDEqtSJZJIFZeGjYOxIcM6yVqHXz0qkO51x0RT-_&quot; width=&quot;519&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;Removing The Race Condition&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;While the above primitive is no doubt useful, it has one inherent downside -- performing a data race from an external vantage point may be a difficult feat, especially considering the platform we’re executing on (an ARM Cortex R) is significantly slower than the targeted one (a full-blown application processor).&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Perhaps by gaining a better understanding of the primitive, we can deal with these limitations. To this end, let’s take a closer look at the validation performed by the submission function:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;1.  uint32_t&lt;/span&gt; &lt;span&gt;AppleBCMWLANPCIeSubmissionRing::calculateRemainingWriteSpace&lt;/span&gt;&lt;span&gt;() {&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;3.      uint32_t&lt;/span&gt; &lt;span&gt;read_index&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;write_index&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;4.      this-&amp;gt;&lt;/span&gt;&lt;span&gt;getIndices&lt;/span&gt;&lt;span&gt;(&amp;amp;&lt;/span&gt;&lt;span&gt;read_index&lt;/span&gt;&lt;span&gt;, &amp;amp;&lt;/span&gt;&lt;span&gt;write_index&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;6.      &lt;/span&gt;&lt;span&gt;//Did the ring wrap around?&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;7.      if (&lt;/span&gt;&lt;span&gt;read_index&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;write_index&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;8.          return&lt;/span&gt; &lt;span&gt;read_index&lt;/span&gt; &lt;span&gt;- (&lt;/span&gt;&lt;span&gt;write_index&lt;/span&gt; &lt;span&gt;+ 1);&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;9.      else&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;10.         return this-&amp;gt;&lt;/span&gt;&lt;span&gt;max_index&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;write_index&lt;/span&gt; &lt;span&gt;+ (&lt;/span&gt;&lt;span&gt;read_index&lt;/span&gt; &lt;span&gt;? 0 : -1);&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;11. }&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;13. void&lt;/span&gt; &lt;span&gt;AppleBCMWLANPCIeSubmissionRing::getIndices&lt;/span&gt;&lt;span&gt;(uint32_t*&lt;/span&gt; &lt;span&gt;rindex&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;14.                                                 uint32_t*&lt;/span&gt; &lt;span&gt;windex&lt;/span&gt;&lt;span&gt;) {&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;15.     uint32_t&lt;/span&gt; &lt;span&gt;read_index&lt;/span&gt; &lt;span&gt;= *(this-&amp;gt;&lt;/span&gt;&lt;span&gt;read_index_ptr&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;16.     uint32_t&lt;/span&gt; &lt;span&gt;write_index&lt;/span&gt; &lt;span&gt;= *(this-&amp;gt;&lt;/span&gt;&lt;span&gt;write_index_ptr&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;17.     if (&lt;/span&gt;&lt;span&gt;read_index&lt;/span&gt; &lt;span&gt;&amp;gt;= 0x10000 ||&lt;/span&gt; &lt;span&gt;write_index&lt;/span&gt; &lt;span&gt;&amp;gt;= 0x10000)&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;18.         panic(...);&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;19.     *&lt;/span&gt;&lt;span&gt;rindex&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;read_index&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;20.     *&lt;/span&gt;&lt;span&gt;windex&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;write_index&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;21. }&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Ah-ha! Looking at the code above, we can identify yet another fault.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;When fetching the ring indices, the&lt;/span&gt; &lt;span&gt;getIndices&lt;/span&gt; &lt;span&gt;function attempts to validate their values to ensure that they do not exceed the allowed ranges. This is undoubtedly a good idea, as it prevents corrupted values from being utilised (which may result in memory corruption).&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;However, instead of comparing the indices against the current ring’s capacity, they are compared against a&lt;/span&gt; &lt;span&gt;fixed&lt;/span&gt; &lt;span&gt;maximal value:&lt;/span&gt; &lt;span&gt;0x10000&lt;/span&gt;&lt;span&gt;. While this value is certainly an upper bound on the rings’ capacities, it is far from a tight bound (in fact, most rings only hold several hundred items at-most).&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Therefore, observing the code above we reach two immediate conclusions. First, if we were to attempt a race condition whereby the ring index is modified to a value larger than the fixed bound (&lt;/span&gt;&lt;span&gt;0x10000)&lt;/span&gt;&lt;span&gt;, we run the risk of triggering a kernel panic should the race attempt fail (line 18). More importantly, however, modifying the write index to any value&lt;/span&gt; &lt;span&gt;below the fixed bound&lt;/span&gt; &lt;span&gt;(but still above the actual ring’s bounds), will allow us to pass the validations above, resulting in an out-of-bounds write with no race-condition required.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Using the above primitive, we can target any H2D ring, causing the next element to be reliably inserted at an out-of-bounds address within the kernel’s VAS! While the affected range is limited to the ring’s item size multiplied by the aforementioned fixed bound, as we’ll see later on, that’s more than enough.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;Triggering the Primitive&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Before pressing on, it’s important that we prove that the scenario above is indeed feasible. After all, many components within the kernel might utilise the modified ring indices, which, in turn, may enforce their own validations.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;To do so, we’ll perform a short experiment using our research platform. First, we’ll select an H2D ring, and&lt;/span&gt; &lt;a href=&quot;https://github.com/google/Legilimency/blob/master/BCMHostDongleInterface.py#L218&quot;&gt;&lt;span&gt;fetch&lt;/span&gt;&lt;/a&gt; &lt;span&gt;its&lt;/span&gt; &lt;a href=&quot;https://github.com/google/Legilimency/blob/master/AppleBCMWLANPCIeSubmissionRing.py&quot;&gt;&lt;span&gt;corresponding object within the kernel&lt;/span&gt;&lt;/a&gt;&lt;span&gt;. Using the aforementioned object, we can then locate the ring’s base address, allowing us to inspect its contents. Now, we’ll modify the ring indices by utilising the firmware’s DMA engine, while concurrently monitoring the kernel virtual address at the targeted offset for modification. If the primitive is triggered successfully, we should expect an item to be inserted at the target offset from the ring’s base address.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;However, running the above experiment results in a resounding failure! Every attempt to trigger the out-of-bounds write results in a kernel panic, thereby crashing the device. Inspecting the panic logs reveals the source of this crash:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;62&quot; src=&quot;https://lh3.googleusercontent.com/MBlxxnt4cUfDy-S8jMJYJkiTYVdzqaG0r8AuIrNWLQepSOx9pf8UOSJVL82wE1_v-A1y_RCJzWH5JexcKiial038QoIGDSxkBX0iuas9B_3Bb8t1hizri6Yeo5UD_iqblehhE9DJ&quot; width=&quot;525&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;It appears that when executing our attack, the firmware attempts to perform a DMA&lt;/span&gt; &lt;span&gt;read&lt;/span&gt; &lt;span&gt;operation from an address beyond its IO-Space mapped ranges! Taking a moment to reflect on this, the source of the error is immediately apparent: since both the firmware and the host share the ring indices through IO-Space, modifying the aforementioned values affects not only the host, but also the firmware’s implementation of the MSGBUF protocol.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Namely, the firmware attempts to read the ring’s contents using the corrupted indices, resulting in an out-of-bounds access to IO-Space, triggering the above panic.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;As we have control over the firmware, we could simply try to intercept the corresponding code paths in its MSGBUF implementation, thus preventing it from issuing the malformed DMA request. Unfortunately, this approach is easier said than done - the firmware’s implementation of MSGBUF is woven into many code-paths in both the ROM and RAM; attempting to patch-out each part results in either breakage of a different component, or in undesired side-effects.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Instead of addressing the&lt;/span&gt; &lt;span&gt;sources&lt;/span&gt; &lt;span&gt;of the DMA transfers, we’ll go straight to the&lt;/span&gt; &lt;span&gt;target&lt;/span&gt; &lt;span&gt;-- the engine itself. Recall that each DMA engine on the firmware is accessible through an instance of a single structure (&lt;/span&gt;&lt;a href=&quot;https://github.com/spotify/linux/blob/6eb782fc88d11b9f40f3d1d714531f22c57b39f9/drivers/staging/brcm80211/util/hnddma.c#L72&quot;&gt;&lt;span&gt;dma_info&lt;/span&gt;&lt;/a&gt;&lt;span&gt;). Changing the DMA engine’s backplane register pointers within the dma_info structure would mean that while the calling code-paths are able to continue issuing malformed DMA requests, the requests themselves are never actually received by the DMA engine, thus preventing us from triggering a fault.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;165&quot; src=&quot;https://lh6.googleusercontent.com/nCTiZQlvvs2yvjPqzV3HKjRQ5bnWlWJSDwnWYKCjfXLf-NWJRfl2bJhW47vzid42WGWB2O3ecn6XeSt_qfufwmzuvtIR0_vUUyxu1cLzmoclJRC4WUYJdkqomdfLfcgRdsrZseMi&quot; width=&quot;540&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Indeed, incorporating the above patch into our vulnerability trigger, we can now freely modify the ring indices without inducing a crash. Furthermore, inspecting the corresponding kernel virtual at the targeted index, we can see that our overwrite is finally successful!&lt;/span&gt;&lt;/div&gt;
&lt;h3 dir=&quot;ltr&quot;&gt;&lt;span&gt;Devising An Exploit Plan&lt;/span&gt;&lt;/h3&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Having concluded that the primitive is usable, we can now proceed to the next stage -- devising an exploit plan. Namely, we must decide on a data structure to target using the exploit primitive, which may allow us to either modify the kernel’s behaviour, or otherwise gain a useful primitive bringing us closer to that goal.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;So which data structure should we target? As we do not have any visibility into the kernel’s address space, reliably locating structures within the kernel presents quite a challenge. What’s more, our primitive only allows limited control over the written content (namely, the data written by the host is an H2D ring item). On top of that, each OOB element can only be written at offsets which are multiples of the ring’s item size, thus introducing alignment constraints.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;The above limitations make reliable exploitation rather difficult. Alas, if only there were a data structure whose internal composition were relatively flexible, and to which a single modification would grant us complete control over the host…&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;...But of course, we’ve already come across the perfect target -- DART’s translation tables!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Recall that DART’s translation tables govern over the mapping between IO-Space and the host’s physical address space. If we were able to use our primitive in order to modify the tables, we might be able to introduce new mappings into IO-Space, pointing at arbitrary physical ranges within the host’s PAS. Mapping in arbitrary physical memory into the Wi-Fi chip is a nearly ideal primitive, as it would allow the chip to modify any data structure used by the kernel, leading to trivial code execution.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;In order to successfully carry out such an attack, we must first figure out whether DART’s translation tables indeed constitute valid targets for the vulnerability primitive. Namely, we must figure out whether they reside within the primitive’s scope of influence.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;However, scanning through the memory ranges within the primitive’s scope, we quickly come to the realisation that the placement of objects following the message rings is highly variable. Indeed, each device reboot yield an entirely different layout, thus preventing us from relying on any particular object being placed at any given offset from a message ring.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Perhaps we’re out of luck…?&lt;/span&gt;&lt;/div&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;Shaping IO-Space&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;...Instead of relying of lucky placement of nearby objects, let’s take matters into our own hands.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;In order to place a DART translation table within the primitive’s scope, we’d need to either move a translation table into the primitive’s scope, or to move one of the message rings, thus shifting the primitive’s scope across different regions of the kernel’s memory.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;The former approach seems infeasible; DART’s translation tables are only allocated when the IO-Space mappings are first populated (namely, when the Wi-Fi chip is first initialised). Once the mapping is complete, all of DART’s translation tables remain in their fixed positions within the kernel’s VAS.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;But what about moving the rings? While control rings are immovable, a second set of ring exists -- “flow rings”. Flow rings are H2D rings used to facilitate the transfer of outgoing (TX) traffic. They do not carry the traffic itself, but rather notify the device of the transmitted frame’s metadata (including the IO-Space address at which its actual content is stored).&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Unlike control rings, flow rings are far more “flexible”. Individual flows are dynamically added and removed as the need arises, by sending a corresponding control message from the host to the device. Each flow is identified by its endpoints (source and destination MAC), their encompassed protocol (i.e., EtherType), and their “priority”.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Perhaps we can use this dynamic nature of flow rings to our advantage. For example, if we were to delete a flow ring, it might subsequently get re-allocated at a different location in the kernel’s memory, thus shifting the scope of our OOB primitive to a possibly more “interesting” patch of objects.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Normally, deleting a flow ring is a two way process; the host sends a deletion request, which is subsequently met by a corresponding message from the device, signalling a successful deletion. However, inspecting the host’s implementation of the above messages, it appears we can just as well skip the first half of the exchange, and send an unsolicited deletion response from the device:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;1.  uint32_t&lt;/span&gt; &lt;span&gt;AppleBCMWLANBusPCIeInterface&lt;/span&gt;&lt;span&gt;::completeFlowRingDeleteResponseMsg&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;4.      &lt;/span&gt;&lt;span&gt;//Is the ring ID within bounds?&lt;/span&gt;&lt;span&gt;&lt;br class=&quot;kix-line-break&quot;/&gt;&lt;/span&gt;&lt;span&gt;5.      if (&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt;flow_ring_id&lt;/span&gt; &lt;span&gt;&amp;lt; this-&amp;gt;&lt;/span&gt;&lt;span&gt;min_flow&lt;/span&gt; &lt;span&gt;||&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;6.&lt;/span&gt; &lt;span&gt;         msg&lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt;flow_ring_id&lt;/span&gt; &lt;span&gt;&amp;gt;= this-&amp;gt;&lt;/span&gt;&lt;span&gt;max_flow&lt;/span&gt;&lt;span&gt;) {&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;7.          ...&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;8.      }&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;9.      &lt;/span&gt;&lt;span&gt;//Does a flow ring exist at the given index?&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;10.     else if (this-&amp;gt;&lt;/span&gt;&lt;span&gt;flow_rings&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt;flow_ring_id&lt;/span&gt;&lt;span&gt;]) {&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;11.         this-&amp;gt;&lt;/span&gt;&lt;span&gt;deleteFlowCallback&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt;status&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;msg&lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt;flow_ring_id&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;12.         ...&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;13.         return 0;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;14.     }&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;15.     else {&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;16.         ...&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;17.         return 0xE00002BC;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;18.     }&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;function 0xFFFFFFF006D2FD44&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Doing so causes an interesting side-effect to occur: instead of completely deleting the ring, the host decrements a single reference count on the ring object, which is insufficient to bring down the total count to zero (the missing release was meant to be performed by the code responsible for sending the deletion request in the first place).&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Consequently, the flow ring is left mapped into IO-Space, but is unusable by the host. As such, newly allocated flow rings cannot inhabit the same IO-Space range (as it remains occupied by the unusable ring), and must instead be carved from higher IO-Space addresses.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;This primitive has several interesting side-effects.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;For starters, it allows us to re-allocate flow rings, thus moving around their base addresses within the kernel’s VAS, recasting the net over potentially interesting objects within the kernel.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;More importantly, however, this primitive allows us to force the allocation of a brand new DART L2 translation table. Since each L2 translation table can only map a fixed range into IO-Space, by continuously leaking flow rings we are able to exhaust the available space in the L2 table, thereby forcing DART to allocate a new table from which the next IO-Space addresses are carved.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Lastly, as luck would have it, since both the rings themselves and DART’s translation tables are carved using the same allocator (&lt;/span&gt;&lt;a href=&quot;https://developer.apple.com/documentation/kernel/1575326-iomalloc&quot;&gt;&lt;span&gt;IOMalloc&lt;/span&gt;&lt;/a&gt;&lt;span&gt;), and have similar sizes, they are both carved from the same “zone” of memory. Therefore, by continuously leaking IO-Space addresses and creating new flow rings until a new DART L2 translation table is formed, we can&lt;/span&gt; &lt;span&gt;guarantee&lt;/span&gt; &lt;span&gt;that the new table will be placed in close proximity to the following flow ring, thereby placing the L2 translation table within our primitive’s scope!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;203&quot; src=&quot;https://lh6.googleusercontent.com/dVkVsBMhJSVbnfyak9p0Kp0puSzbEcyro3AMpJsc-dj5XfV2MQsuDPfihwjolIURqSQfANV-TVd3aQW6Me8KZyMp6D8Y5LTytgtSS0qe4DI8Z9YgqsSncF-vJ-jefCIxKVtdhzSk&quot; width=&quot;565&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Putting it all together, we can finally reach a reliable placement of DART translation tables in close proximity to a flow ring, thereby allowing us to overwrite entries in the translation tables with flow ring items.&lt;/span&gt;&lt;/div&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;Flow Ring Items vs. DART Descriptors&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;To understand whether flow ring items make good candidates to overwrite DART descriptors, let’s take a moment to inspect their structure. As these items are present in the&lt;/span&gt; &lt;a href=&quot;https://android.googlesource.com/kernel/common/+/bcmdhd-3.10/drivers/net/wireless/bcmdhd/include/bcmmsgbuf.h#482&quot;&gt;&lt;span&gt;same form&lt;/span&gt;&lt;/a&gt; &lt;span&gt;in the Android driver, we are spared the need to reverse-engineer them:&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;263&quot; src=&quot;https://lh4.googleusercontent.com/Jol9bBLJETDjK8c66CoiUPjVWUsEhch-vUi3S8lxwXQ1XoxHF3aQxlvvK2XEhB31CkOfxhRPLLMzhcLsQtGZm3fL35-GAx-PVNP-v7t3RSLwbcsPt527HVSG2zT-AEi3vEeTiGGN&quot; width=&quot;624&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;So how does the above structure relate to a DART descriptor?&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;As the above structure has a 64-bit aligned size, and ring items are always placed in increments of the same size, we can deduce that each quadword in the above structure will reside in a 64-bit aligned address. Similarly, DART descriptors are 64-bits wide, and are placed in 64-bit aligned addresses. Therefore, each aligned&lt;/span&gt; &lt;a href=&quot;https://en.wiktionary.org/wiki/quadword&quot;&gt;&lt;span&gt;quadword&lt;/span&gt;&lt;/a&gt; &lt;span&gt;in the above structure serves as a potential candidate for replacing a DART descriptor.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;However, going over the above quadwords, it is quickly apparent that no fully-controlled word exists within the structure. Indeed, the first and last word are composed of mostly constant values, whereas the third and fourth contain IO-Space addresses (whose forms are incompatible with DART descriptors). Nonetheless, taking a closer look, it appears that the second word is at least&lt;/span&gt; &lt;span&gt;somewhat&lt;/span&gt; &lt;span&gt;malleable. Its lower six bytes are governed by the destination MAC address to which the frame is being transmitted, while the two upper bytes contain the beginning of our source MAC.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Assuming we could cause the host to send frames to a MAC address of our choosing, that would grant us control over the lower six bytes. However, the remaining two bytes are populated using our device’s MAC address, a much harder target for modification...&lt;/span&gt;&lt;/div&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;Spoofing The Source MAC?&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;To understand whether we can indeed modify the device’s MAC address, let’s take a closer look at the mechanisms through which the MAC address may be programmable on the Wi-Fi chip.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Like many production devices, Broadcom’s Wi-Fi chips allow the storage of chip-specific configuration using one of two mechanisms; either by using a block of Serial Programmable ROM (SPROM) or by utilising a set of One Time Programmable (OTP) fuses. The Wi-Fi chip present on the iPhone 7 uses the latter mechanism.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;As for the host, it stores the Wi-Fi chip’s MAC address in the “device tree” (among many other device-specific properties). The “device tree” is a simple hierarchical representation of hardware components utilised by the platform (much like its Linux counterpart, bearing the same name), allowing consumers within the kernel to easily access (and populate) its nodes.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;During the Wi-Fi chip’s initialisation, the&lt;/span&gt; &lt;span&gt;AppleBCMWLANCore&lt;/span&gt; &lt;span&gt;driver retrieves the contents of the chip’s OTP fuses (using the PCIe BARs), and proceeds to parse them according to the PCMCIA&lt;/span&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/PC_Card#Card_information_structure&quot;&gt;&lt;span&gt;Card Information Structure&lt;/span&gt;&lt;/a&gt; &lt;span&gt;(CIS) format. Reverse-engineering the parsing functions in the kernel, it is quickly apparent that one tag in particular bears significance with regards to our pursuits.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;If a “Function Extension” tag is encountered in the CIS data embedded in the OTP, the kernel will extract the MAC address encapsulated within it, and insert it into the “local-mac-address” node in the device tree, representing the Wi-Fi MAC address!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;61&quot; src=&quot;https://lh5.googleusercontent.com/kDlbIf4M1TJiTHuVxNuyqcIA6l54qMR_d8YOgu7g7XlhqGBXqvGcq4PFHj81bt_Bqs2OYbtOjx8ILk8fa2XwXZlK8hAW7Pw9weIzo96IxIt-NSwyKgDDv27nXPxJsD1-URALyVVv&quot; width=&quot;441&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Extracting the stored OTP contents from the kernel, we can see that no such element is present in the OTP contents to begin with, thus allowing us to insert our own tag without fear of causing a collision:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;249&quot; src=&quot;https://lh3.googleusercontent.com/gP3NzYDtPUB1VhTRlDmSFvTVFD9FYzrN_ICp2dwZUc_ZnEHllDdTcWs5Cc5YxZuLvLpSg7bh5gvVAE9d3yef1t5pNqMvIkqNooKtZ5GkqgNGBIkCeII_S9JjhIxyrXQD1cnty_aW&quot; width=&quot;537&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Wi-Fi Chip OTP&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Therefore, to change the MAC address, all we’d need to do is fuse the corresponding bits into the OTP, thus inserting the new CIS tag. However, this is easier said than done. For starters, writing to the OTP is a risky operation, and may result in permanent damage to the chip if done incorrectly. Moreover, as it’s name implies, writing to the OTP is a&lt;/span&gt; &lt;span&gt;one-time&lt;/span&gt; &lt;span&gt;operation, leaving no room for error. Perhaps we could avoid changing the MAC after all?&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;After discussing the above situation, my colleague Ian Beer suggested an alternative!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Why not, instead, check if the high-order bits in the DART descriptor are actually being used for the translation process? To test this suggestion, we’ll use the research platform to insert a&lt;/span&gt; &lt;span&gt;valid&lt;/span&gt; &lt;span&gt;L2 descriptor into DART, with one small caveat -- we’ll change the two upper bytes in the 64-bit descriptor to “corrupted” values. After inserting the mapping, we can simply insert a DMA hook into the firmware, performing a DMA access to the aforementioned address.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;127&quot; src=&quot;https://lh5.googleusercontent.com/IJHzQXiBSRd7SLe4nS8BBe9wMnuJSwrsOyNW2y0ufALcGxxeeMcB7H9kj_jZJ0_tp__yerjn1tXRjIJ0yClWJxWVfV9_dIn1Qg5GSUUICddiu0h0qKklTLqB9ZiKx-neCp58EQ-m&quot; width=&quot;521&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Running the experiment above we are greeted with a positive result! Indeed, the upper bytes of the DART descriptor are&lt;/span&gt; &lt;span&gt;ignored&lt;/span&gt; &lt;span&gt;by the translation process, thus sparing us the need to modify the MAC.&lt;/span&gt;&lt;/div&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;Spoofing The Destination MAC&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Having confirmed that modifying the source MAC is no longer a barrier, all that remains is to cause the host to send a frame to a crafted MAC address, thus allowing us to control the six&lt;/span&gt; &lt;span&gt;significant&lt;/span&gt; &lt;span&gt;bytes within our 64-bit word.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Naturally, one way to solicit a response from the host is to transmit an&lt;/span&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol&quot;&gt;&lt;span&gt;ICMP&lt;/span&gt;&lt;/a&gt; &lt;span&gt;Echo Request (&lt;/span&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Ping_(networking_utility)&quot;&gt;&lt;span&gt;ping&lt;/span&gt;&lt;/a&gt;&lt;span&gt;) to it, subsequently triggering a corresponding ICMP Echo Response to be sent in response. While this approach can easily trigger the transmission of frames from the host, it only allows frames to be transmitted to known destinations, but does not offer control over the destination MAC.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;To trigger communications to our target MAC, we’ll first launch an&lt;/span&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/ARP_spoofing&quot;&gt;&lt;span&gt;ARP Spoofing&lt;/span&gt;&lt;/a&gt; &lt;span&gt;attack; sending a crafted ping from an arbitrary (unused) IP address, thereby causing the host to send an “ARP Request” querying the MAC address of the crafted IP, to which we’ll respond a response encoding our own MAC address, thus associating the IP address with a crafted MAC value.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;However, several problems arise when using this method. First, recall that the MAC address is meant to masquerade as a valid DART L2 Descriptor. As we’ve seen in our analysis of the descriptor formats, every valid L2 descriptor must have the two least-significant bits set. This poses somewhat of a problem for MAC addresses, as their bottom bits bear special significance&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;147&quot; src=&quot;https://lh5.googleusercontent.com/I95na2V0jMJvrmemDZWPvhAUSV8UKElVv7DAfBYSrtqTMX1LSwlp2MfianeKdYQoYL4lYq7pBzpWR_2WWDG0tXZy8V8kfciF7D5Z-SJrlPH-6j4krzzin7Bi5Z-TuKwFXq_TxgQJ&quot; width=&quot;202&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Setting the bottom two bits in the MAC address would indicate that it is a&lt;/span&gt; &lt;span&gt;broadcast / multicast&lt;/span&gt; &lt;span&gt;address. As we are sending unicast traffic (and are expecting a unicast response), it might be difficult to solicit such responses from the host. Furthermore, any network-resident security devices might inspect the traffic and flag it as suspicious (especially as we are executing a classical ARP spoofing attack). What’s more, the router or access point may refuse to route unicast traffic to a broadcast MAC.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;To get around the above limitations, we’ll simply inject the traffic&lt;/span&gt; &lt;span&gt;directly from the firmware&lt;/span&gt;&lt;span&gt;, without transmitting it over the air. To achieve this goal, we’ve written a small assembly stub that, when executed on the firmware,&lt;/span&gt; &lt;a href=&quot;https://github.com/google/Legilimency/blob/master/code_chunks/send_frame/chunk.S&quot;&gt;&lt;span&gt;injects the encapsulated frames&lt;/span&gt;&lt;/a&gt; &lt;span&gt;directly into the host, as if it were transmitted over the network.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;137&quot; src=&quot;https://lh4.googleusercontent.com/88XvCq1P0KMd0kkxSvCr1OCFr1VHl4aDzZipmaLQZktEogXWrLOgrNs3GmKpeZv4vheShOiN3yUjBOC7laC5jTKeNmKJGLdP1jEhNRj0dGKzaPdXzp9-EJsy81fdYz-IC5nK5qDq&quot; width=&quot;487&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;This allows us to inject even potentially malformed traffic that would not have been routable (like unicast traffic from a broadcast MAC). Indeed, after running the ARP spoofing vector with the above mechanism, we are able to solicit responses from the host to our crafted (broadcast) MAC address (XNU does not object to sending unicast traffic to broadcast MACs). Great!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;148&quot; src=&quot;https://lh6.googleusercontent.com/GGgtL6TMWsFaAkTCgzpWZCSVkx-0eC6SP2lUxblC45HHaqCtRGQ_VMnJt8K9IIdVibIP6WAgqP-nxCQSWsHTkp4_sxet7jRcDF9fBeBYL97_iqBa000fjw0QZXcl21L-YOWsCUSN&quot; width=&quot;507&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;Inception&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Finally, all the ducks are lined up in a row -- we can solicit traffic to MAC addresses of our choosing (even broadcast MACs), without having to modify the source MAC. Furthermore, we can shape IO-Space in order to force a new DART translation table to be allocated following a flow ring within the kernel’s VAS. Therefore, we can overwrite DART descriptors with our own crafted values, thus introducing new mappings into IO-Space. However, a single question remains -- which physical address should we map into IO-Space?&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;After all, we&lt;/span&gt; &lt;span&gt;still&lt;/span&gt; &lt;span&gt;haven’t dealt with the issue of KASLR. As the kernel’s loading addresses, both physical and virtual, are “slid” using a randomised value, we cannot locate physical addresses within the kernel until we uncover the slide’s value. If we cannot reliably locate the kernel’s base address, which physical addresses&lt;/span&gt; &lt;span&gt;can&lt;/span&gt; &lt;span&gt;we find?&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;To get around this limitation, we’ll use one more trick! While the host’s physical address space houses the DRAM, in which the kernel and application memory are stored, additional regions of physically addressable content can also be found in the PAS. For instance,&lt;/span&gt; &lt;span&gt;hardware registers&lt;/span&gt; &lt;span&gt;are mapped into fixed physical addresses, allowing the host to interact with peripherals on the SoC. Among these peripherals is DART itself!&lt;/span&gt;&lt;/div&gt;

&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;82&quot; src=&quot;https://lh3.googleusercontent.com/Q3FnQZo59NeP8GeOZgJ8gO7qZU1uSfHwxHyC53H2TnektedvbzD_6Qx7kIkdAyC3gS21ngTEh_5heb6n7itTgeQ5ACWHCOcQTRF7mZXqNUNsQoExF21gyM95iidNJvi4WDG1To9d&quot; width=&quot;588&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;As we’ve previously seen, DART’s translation process is initiated using four “L0 descriptors”. These descriptors are fed into DART’s hardware registers, denoting the base addresses of the translation tables from which the IO-Space translation process begins. If we were to map in DART’s hardware registers into IO-Space, we could either read the descriptors, thus allowing us to locate DART’s translation tables within the physical address space!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;It should be noted that although DART’s hardware registers are addressable within the host’s physical address space, it remains unknown&lt;/span&gt; &lt;span&gt;why&lt;/span&gt; &lt;span&gt;IO-Space mappings should even be allowed to include ranges beyond the DRAM’s bounds. Indeed, it stands to reason that such mappings would be prohibited by the hardware. However, as it happens, no such restriction is enforced - DART freely allows any physical range to be inserted into IO-Space.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Therefore, if we wish to map-in DART’s own hardware registers into IO-Space, all that remains is to locate the physical ranges corresponding to DART’s hardware registers! To do so, we’ll use a combined approach.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;First, we’ll use our research platform to extract the DART instance, from which we can subsequently retrieve the kernel VAS pointer corresponding to DART’s hardware registers. Then, using our translation table module, we can proceed to convert the kernel virtual address to its matching physical range. After doing so, we are presented with the following result:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;38&quot; src=&quot;https://lh5.googleusercontent.com/pWBWmNDNdOZkGzPQLZFX-DVDgSUSQOgDpZSuJoKsuYc0556DBv0B2S7q0IWRiQVIv2HnknoxAGvNIiFuMD-VxPeCk7HZ7OGL5LZ5G7yH9gCBm_HWWh8QzfjH9uaUt2qZsz9xFPgZ&quot; width=&quot;267&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Great! The address is clearly not within the DRAM’s range, hinting that we’re on the right track.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;To verify whether this is indeed the correct address, we’ll use a second approach. As we already noted, the device hierarchy is stored within a structure called the “device tree”. Different properties relating to each peripheral, include the addresses of their corresponding hardware registers, are stored as nodes within this tree.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;The device tree itself is present in a binary format within the firmware image (encapsulated in an&lt;/span&gt; &lt;a href=&quot;https://www.theiphonewiki.com/wiki/IMG4_File_Format&quot;&gt;&lt;span&gt;IMG4&lt;/span&gt;&lt;/a&gt; &lt;span&gt;container). After&lt;/span&gt; &lt;a href=&quot;https://github.com/xerub/img4tool/blob/master/img4.c&quot;&gt;&lt;span&gt;extracting the device tree&lt;/span&gt;&lt;/a&gt;&lt;span&gt;, we are presented with a blob storing the device hierarchy. Although the tree’s format is undocumented, inspecting the binary reveals an extremely simple structure; a fixed header denoting the number of children and entries contained in each node, followed by a fixed-length name, and a variable-length value. I later discovered that Jonathan Levin has similarly reversed this structure, and has written a tool to parse out its contents (albeit for an IMG3 container) -- you can check out his script&lt;/span&gt; &lt;a href=&quot;http://www.newosxbook.com/src.jl?tree=listings&amp;amp;file=6-bonus.c&quot;&gt;&lt;span&gt;here&lt;/span&gt;&lt;/a&gt;&lt;span&gt;.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Regardless, after writing&lt;/span&gt; &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1317#c4&quot;&gt;&lt;span&gt;our own python script&lt;/span&gt;&lt;/a&gt; &lt;span&gt;to parse the device tree, we are presented with the following result:&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;192&quot; src=&quot;https://lh6.googleusercontent.com/zUW9V5GW8J_Mww7xl7KwrcMU6mmUasS2xLKV_kMx-aDg3QTwXO6JGW8-uLnVwQ5npdBIYqzlCVkwOvRL7ySgg-fwGEfjzIBMINbr87gMXtBxWsXERGcuA4w1Anx58t_sNAvkejuf&quot; width=&quot;521&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Ah-ha! We once again find the same physical address, thus concluding that our analysis of DART’s hardware registers is correct.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Putting it all together, we can now utilise our exploit primitive to map the physical address containing DART’s registers into IO-Space. Once mapped, we can proceed to read the hardware registers’ values, including the L0 descriptors. It should be noted that attempting to access the hardware registers from the host requires strict 32-bit load and store operations -- attempting a 64-bit load from the hardware registers results in a garbled value being returned. Curiously, however, DMA-ing to and from the hardware registers from the Wi-Fi chip goes unhindered!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;292&quot; src=&quot;https://lh3.googleusercontent.com/sIwHdK5IaUHY3ncp-CjpZ3FOL8M5TfQtYRrGYkt3NBtufvox2Fei_Kmdk3rEp43TG8o2mQODPwXcml1hb5NFzl3rVVHgAHyhcvagSR8h8BY3DGnQU9i4kzwOhXwOQR8xax8SJdj1&quot; width=&quot;358&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Using the L0 descriptor, we can now extract the physical address of the next translation table in DART’s hierarchy. Then, by repeating the exploit primitive and mapping-in the newly discovered physical address into IO-Space, we can repeat the process, descending down DART’s translation hierarchy until we reach a DART L2 translation table. Thus, using one flow ring, we can bring them all, and in IO-Space bind them.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Once an L2 translation table is located within the physical address space, we can proceed to map it into IO-Space using our exploit primitive one last time, thus inserting DART’s own translation table into IO-Space!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;By mapping DART’s translation table into its own IO-Space ranges, we can now utilise DMA access from the Wi-Fi chip in order to freely introduce new mappings into IO-Space (removing the need for the exploit primitive). Thus, gaining full control over the host’s physical memory!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;168&quot; src=&quot;https://lh4.googleusercontent.com/TMR_tF834DWWgu62kjpk4lwkEXTC1m3dE6uBEZ7VLYuMNVJCnUn32Gzu45xf8t_TwbESiMtmkW0rB7lZeOKmpdbg01hw_3T_UVK6F1NrrNg2hf-NAhB7hDvrGtg5bi0VKWJVF1Wf&quot; width=&quot;555&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Furthermore, as DART’s translation entries are never cleared, we are guaranteed that once the malicious IO-Space entries are inserted, they remain accessible to the Wi-Fi chip, until the device itself reboots. As such, the exploit process need only occur once in order to introduce a backdoor allowing the Wi-Fi chip to freely access the host’s physical memory.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;One curiosity of note is that DART’s has a rather large TLB. Therefore, changes in IO-Space may not immediately be reflected until the entries are evicted from the cache. Nonetheless, this is easily dealt with by mapping in IO-Space addresses in a circular pattern, thus allowing stale entries to get cleared.&lt;/span&gt;&lt;/div&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;&lt;span&gt;Finding The KASLR Slide&lt;/span&gt;&lt;/h4&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;At long last, we have complete control over the entire physical address space, directly from the Wi-Fi chip. Consequently, we can proceed to map and and modify any physical address we desire, even those corresponding to the kernel’s data structures.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;While this form of access is sufficient in order to subvert the kernel, there’s one tiny snag we have yet to deal with: KASLR. Since the kernel’s physical base address is randomised using the KASLR slide, and we have yet to deduce its value, we might have to resort to scanning the DRAM’s physical address ranges until we locate the kernel itself.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;This approach is rather inefficient. Instead, we can opt for a more elegant path. Recall that, as we’ve just seen, hardware registers may be freely mapped into IO-Space. As hardware registers are not affected by the KASLR slide (indeed they are mapped at fixed physical addresses), they can be trivially located regardless of the current “slide” value.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Perhaps one of the hardware registers can be used as an oracle to deduce the KASLR slide?&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Recall that newer devices, such as the iPhone 7, enforce the integrity of the kernel using a hardware mechanism dubbed “KTRR”. Simply put, this mechanism allows the device to provide “lockdown” regions, to which subsequent modifications are prohibited. These regions are programmed using a&lt;/span&gt; &lt;a href=&quot;https://github.com/apple/darwin-xnu/blob/master/pexpert/pexpert/arm64/AMCC.h#L15&quot;&gt;&lt;span&gt;special set of hardware registers&lt;/span&gt;&lt;/a&gt;&lt;span&gt;.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;167&quot; src=&quot;https://lh3.googleusercontent.com/DF625ZU0w7fEoqq9uQGAv7NrkOsWHWtet72osPWxb5rDsRIE1_xvfeUJkym7zEiNA0lUyReVwjHMGfIGnWN23wguu6H4G94VlCIFTuLO67eT2FkawFT9HnuclQHvKPEZIOpPDGKn&quot; width=&quot;404&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Amusingly, this very same mechanism can be used to deduce the KASLR slide!&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;By mapping in physical addresses corresponding to the aforementioned hardware registers, we can proceed to read their contents directly from IO-Space. This, in turn, reveals the physical ranges encoded in the “lockdown registers”, which store non other than the kernel’s base address.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;48&quot; src=&quot;https://lh3.googleusercontent.com/LU3xkeChZ_7MDddkCTOnkg46lzFA4_pg66M7VsqFjdsIG5ReBjWpuFM5Ioh-leCHlvtKQZusgfRteMg6rjHrEMVy2YJrXLzbuwWav2djvwYnWJUdnlFDqLD1Cx4diBXXaDDngD5h&quot; width=&quot;260&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3 dir=&quot;ltr&quot;&gt;&lt;span&gt;The Exploit&lt;/span&gt;&lt;/h3&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Summing up all of the above, we’ve finally written an exploit, allowing full control over the device’s physical memory over-the-air, using Wi-Fi communication alone. You can find the exploit&lt;/span&gt; &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1317#c3&quot;&gt;&lt;span&gt;here&lt;/span&gt;&lt;/a&gt;&lt;span&gt;.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;It should be noted that several smaller details have been omitted from the blog post, in the interest of (some) brevity. For instance, locating the offset between the newly allocated DART translation table and the flow ring requires a process of probing various IO-Space addresses, while also guaranteeing that alignment constraints enforced by the granularity of ring item sizes are met. We encourage researchers to read the exploit’s code in order to discover any such omitted parts.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;The exploit has been tested against the iPhone 7 running iOS 10.2 (14C92). The vulnerabilities are present in versions of iOS up to (and including) iOS 10.3.3. Researchers wishing to utilise the exploit on different iDevices or different versions, would be required to adjust the symbols used by the exploit.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;img height=&quot;452&quot; src=&quot;https://lh6.googleusercontent.com/1b3-3UNijHyJrJaKCF7lWbtCV-wTYmIJbUFqPl-kVJjgj3Q_1d2OvCtoUscKA8yI5tasDHAzgZflERIa8m6oBgTkNlt8xSENF8JoC7aSE5cdKy9KoY6-n0YMe6Znu5FESXET8ojk&quot; width=&quot;428&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Upon successful execution, the exploit exposes APIs to read and write the host’s physical memory directly over-the-air, by mapping in any requested address to the controlled DART L2 translation table, and issuing DMA accesses to the corresponding mapped IO-Space addresses.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;For convenience sake, the exploit also locates the kernel’s physical base address using the method we described above (using the KTRR read-only region registers), thus allowing researchers to easily explore the kernel’s physical memory ranges.&lt;/span&gt;&lt;/div&gt;
&lt;h3 dir=&quot;ltr&quot;&gt;&lt;span&gt;Afterword&lt;/span&gt;&lt;/h3&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Over the course of this series of blog posts, we’ve explored the security of the Wi-Fi stack on Apple devices. Consequently, we constructed a complete exploit chain, allowing attackers to reliably gain control over the iOS kernel on an iPhone 7 using Wi-Fi communication alone.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;During our research, we explored several components, including Broadcom’s Wi-Fi firmware, the DART IOMMU, and Apple’s Wi-Fi drivers. Each of the aforementioned components is proprietary, thus requiring substantial effort to gain visibility into their operations. We hope that by providing the&lt;/span&gt; &lt;a href=&quot;https://github.com/google/Legilimency&quot;&gt;&lt;span&gt;tools&lt;/span&gt;&lt;/a&gt; &lt;span&gt;used to conduct our research, additional exploration of these surfaces will be performed in the future, allowing for their corresponding security postures to be enhanced.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;We’ve also seen how the iPhone utilises hardware security mechanisms, such as DART, in order to provide isolation between the host and potentially malicious components. These mechanisms significantly raise the bar for launching successful attacks targeting the host. Nonetheless, additional research into DART is needed in order to explore all facets of its implementation. For instance, while we’ve explored the enacted IO-Space through the prism of the Wi-Fi chip, additional PCIe components exist on the SoC, which are similarly guarded by DARTs. These components remain, as of yet, unexplored.&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Apart from fixing individual vulnerabilities in the security boundaries between the host and the Wi-Fi chip, several structural enhancements can be applied to make future exploitation harder. This includes introducing read-only mappings to DART (if they are not already present), clearing unused descriptors from DART’s translation tables upon rebooting the associated component, and preventing IO-Space mappings from exposing physical ranges beyond the DRAM.&lt;/span&gt;&lt;/div&gt;
&lt;br/&gt;&lt;div dir=&quot;ltr&quot;&gt;&lt;span&gt;Lastly, while memory isolation goes a long way towards defending the host against a rogue Wi-Fi chip, the host must still consider all communications originating from the Wi-Fi chip as potentially malicious. To this end, the numerous communication channels between the two endpoints (including event packets, “ioctls”, and control commands), must be designed to withstand malformed data transmitted by the chip.&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 12 Oct 2017 19:51:17 +0000</pubDate>
<dc:creator>archimag0</dc:creator>
<og:url>https://googleprojectzero.blogspot.com/2017/10/over-air-vol-2-pt-3-exploiting-wi-fi.html</og:url>
<og:title>Over The Air - Vol. 2, Pt. 3: Exploiting The Wi-Fi Stack on Apple Devices</og:title>
<og:description>Posted by Gal Beniamini, Project Zero In this blog post we’ll complete our goal of achieving remote kernel code execution on the iPhone ...</og:description>
<og:image>https://lh4.googleusercontent.com/GW9k8F51JnL3fMCXtoCLuP5LEiP-zheS6E9dL11BHGzILTCSzKK-4mzZ2j9X_I1BUacLZc1eU1JN0g73x2ETi46ys43DjXgvWevAWub6hJJCluADPGpNlOHHIxqh-5wONZhsuw4I=w1200-h630-p-k-no-nu</og:image>
<dc:format>text/html</dc:format>
<dc:identifier>https://googleprojectzero.blogspot.com/2017/10/over-air-vol-2-pt-3-exploiting-wi-fi.html</dc:identifier>
</item>
<item>
<title>Google commits $1B in grants to train U.S. workers for high-tech jobs</title>
<link>https://techcrunch.com/2017/10/12/google-commits-1-billion-in-grants-to-train-u-s-workers-for-high-tech-jobs/</link>
<guid isPermaLink="true" >https://techcrunch.com/2017/10/12/google-commits-1-billion-in-grants-to-train-u-s-workers-for-high-tech-jobs/</guid>
<description>&lt;img src=&quot;https://tctechcrunch2011.files.wordpress.com/2015/08/464948948.jpg?w=738&quot; class=&quot;&quot;/&gt;&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;The nature of work is changing on a global level at a rapid pace. Sure, it’s not the first time work has been dramatically impacted by technology, but the growth of automation, robotics, AI and the like have the potential to displace jobs at an unprecedented rate. And Google will almost certainly be one of the driving forces behind that transformation.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;The search giant has regularly expressed a desire to help stem some of that negative impact, and now it’s putting its money where its mouth is to the tune of $1 billion. CEO Sundar Pichai announced &lt;a target=&quot;_blank&quot; href=&quot;https://blog.google/topics/causes-community/opportunity-for-everyone/&quot; rel=&quot;noopener&quot;&gt;Grow with Google&lt;/a&gt; at an event earlier today in Pittsburgh, PA. Over the next five years, the initiative will commit $1 billion to nonprofits aimed at training American workers and helping build business.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;The location of the event will not be lost on anyone who has followed Pittsburgh’s growth over the last few decades. The Steel City has long served as an ideal example of an economy that’s rebounded from the brink of disaster. In Pittsburgh’s case, technology was a primary driver, thanks to Carnegie Mellon, which has helped transform it from post-Rust Belt depression to one of the country’s leading tech hubs. These days, the walls of Pittsburgh’s former factories house cutting-edge innovations in fields like robotics and autonomous driving.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Pichai noted in his address that the city also holds special meaning for him. “It was the first city I saw in America when I came here 24 years ago,” he explained. “I was here before the internet really took off, but the city was already changing. &lt;span class=&quot;s2&quot;&gt;The number of high-tech jobs had doubled&lt;/span&gt;.”&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;The company is committing $10 million to Goodwill as part of the initiative — the largest G&lt;span class=&quot;s3&quot;&gt;oogle.org&lt;/span&gt; has committed to one organization. That money will be used to help launch the Goodwill Digital Career Accelerator, aimed at preparing the American workforce for high-tech jobs. Grow with Google also will take the form of a national tour hosted by libraries and community organizations aimed at bringing training and career advice directly to local towns and cities. That’s part of the company’s goal of committing one million hours to employee volunteering over the next five years.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;“At Google, our mission is to make sure that information serves everyone, not just a few,” Pichai explained in the address. “A child in a school here in Pittsburgh can access the same information on Google as a professor at Carnegie Mellon. In the end, the internet is a powerful equalizer, capable of propelling new ideas and people forward.”&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Additional online training can be found at the &lt;a target=&quot;_blank&quot; href=&quot;https://grow.google/&quot; rel=&quot;noopener&quot;&gt;Grow with Google hub&lt;/a&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;small&gt;Featured Image: LLUIS GENE/AFP/Getty Images&lt;/small&gt;</description>
<pubDate>Thu, 12 Oct 2017 18:55:52 +0000</pubDate>
<dc:creator>thesanerguy</dc:creator>
<og:title>Google commits $1 billion in grants to train U.S. workers for high-tech jobs</og:title>
<og:description>The nature of work is changing on a global level at a rapid pace. Sure, it’s not the first time work has been dramatically impacted by technology, but the..</og:description>
<og:image>https://tctechcrunch2011.files.wordpress.com/2015/08/464948948.jpg</og:image>
<og:url>http://social.techcrunch.com/2017/10/12/google-commits-1-billion-in-grants-to-train-u-s-workers-for-high-tech-jobs/</og:url>
<og:type>article</og:type>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://techcrunch.com/2017/10/12/google-commits-1-billion-in-grants-to-train-u-s-workers-for-high-tech-jobs/</dc:identifier>
</item>
<item>
<title>John Carmack&amp;#039;s Keynote at Oculus 4 Live Stream [video]</title>
<link>https://www.facebook.com/oculusvr/videos/vb.270208243080697/1189602884474557/?type=3&amp;theater</link>
<guid isPermaLink="true" >https://www.facebook.com/oculusvr/videos/vb.270208243080697/1189602884474557/?type=3&amp;theater</guid>
<description>[unable to retrieve full-text content]&lt;p&gt;Article URL: &lt;a href=&quot;https://www.facebook.com/oculusvr/videos/vb.270208243080697/1189602884474557/?type=3&amp;theater&quot;&gt;https://www.facebook.com/oculusvr/videos/vb.270208243080697/1189602884474557/?type=3&amp;theater&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Comments URL: &lt;a href=&quot;https://news.ycombinator.com/item?id=15459506&quot;&gt;https://news.ycombinator.com/item?id=15459506&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Points: 325&lt;/p&gt;&lt;p&gt;# Comments: 106&lt;/p&gt;
&lt;hr&gt;&lt;p&gt;hnrss is a labor of love, but if the project has made your job
or hobby project easier and you want to show some gratitude, &lt;a
href=&quot;https://donate.hnrss.org/&quot;&gt;donations are very much
appreciated&lt;/a&gt;. PayPal and Bitcoin both accepted. Thanks!&lt;/p&gt;
        </description>
<pubDate>Thu, 12 Oct 2017 17:11:32 +0000</pubDate>
<dc:creator>staunch</dc:creator>
<og:title>Log In or Sign Up to View</og:title>
<og:description>See posts, photos and more on Facebook.</og:description>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.facebook.com/oculusvr/videos/vb.270208243080697/1189602884474557/?type=3&amp;theater&amp;_fb_noscript=1</dc:identifier>
</item>
<item>
<title>Equifax takes down web page after reports of new hack</title>
<link>http://www.reuters.com/article/us-equifax-breach/equifax-takes-down-web-page-after-reports-of-new-hack-idUSKBN1CH2F3</link>
<guid isPermaLink="true" >http://www.reuters.com/article/us-equifax-breach/equifax-takes-down-web-page-after-reports-of-new-hack-idUSKBN1CH2F3</guid>
<description>&lt;p data-reactid=&quot;38&quot;&gt;NEW YORK (Reuters) - Equifax Inc said on Thursday that one of its third-party vendors had been running malicious code on one its web pages, but that the credit reporting agency was not the subject of another cyber attack and its systems were not compromised.&lt;/p&gt;
&lt;p data-reactid=&quot;39&quot;&gt;Equifax had said earlier it took the affected web page offline “out of an abundance of caution” following a report by the technology news website Ars Technica that the company’s website may have been hacked.&lt;/p&gt;
&lt;p data-reactid=&quot;40&quot;&gt;Atlanta-based Equifax disclosed a little over a month ago that cyber criminals had breached its systems between mid-May and late July and stolen the sensitive information of 145.5 million people.&lt;/p&gt;
&lt;p data-reactid=&quot;41&quot;&gt;“Equifax can confirm that its systems were not compromised and that the reported issue did not affect our consumer online dispute portal,” spokeswoman Francesca De Girolami said in a statement on Thursday.&lt;/p&gt;
&lt;p data-reactid=&quot;42&quot;&gt;“The issue involves a third-party vendor that Equifax uses to collect website performance data, and that vendor’s code running on an Equifax website was serving malicious content.”&lt;/p&gt;
&lt;p data-reactid=&quot;43&quot;&gt;The company said it has removed the vendor’s code from the web page, which was taken offline so the company can conduct further analysis.&lt;/p&gt;
&lt;div class=&quot;Image_container_1tVQo&quot; data-reactid=&quot;44&quot;&gt;

&lt;span class=&quot;Image_caption_KoNH1&quot; data-reactid=&quot;49&quot;&gt;FILE PHOTO: The logo and trading information for Credit reporting company Equifax Inc. are displayed on a screen on the floor of the New York Stock Exchange (NYSE) in New York, U.S., September 26, 2017. REUTERS/Lucas Jackson&lt;/span&gt;&lt;/div&gt;
&lt;p data-reactid=&quot;50&quot;&gt;Randy Abrams, an independent security analyst, said he noticed the issue late on Wednesday when he was attempting to check some information in his credit report and a bogus pop-up ad appeared on Equifax’s website.&lt;/p&gt;
&lt;p data-reactid=&quot;51&quot;&gt;The pop-ups could trick visitors into installing fraudulent Adobe Flash updates and infect computers with malware, he said in an interview with Reuters on Thursday.&lt;/p&gt;
&lt;p data-reactid=&quot;52&quot;&gt;&quot;You've got to be kidding me,&quot; he recalled thinking when he first saw the ads. Then he successfully replicated the problem at least five times, making a video that he posted to YouTube. (&lt;a href=&quot;http://bit.ly/2z3GTLc&quot;&gt;bit.ly/2z3GTLc&lt;/a&gt;)&lt;/p&gt;
&lt;p data-reactid=&quot;53&quot;&gt;Equifax’s security protocols have been under scrutiny since Sept. 7 when the company disclosed its systems had been breached. As a credit reporting agency, Equifax keeps vast amounts of consumer data for banks and other creditors to use to determine the chances of their customers’ defaulting.&lt;/p&gt;
&lt;p data-reactid=&quot;54&quot;&gt;The breach has prompted investigations by multiple federal and state agencies, including a criminal probe by the U.S. Department of Justice, and it has led to the departure of the company’s chief executive officer, chief information officer and chief security officer.&lt;/p&gt;
&lt;p data-reactid=&quot;55&quot;&gt;Equifax shares ended down 1.5 percent at $108.81.&lt;/p&gt;
&lt;div class=&quot;Attribution_attribution_o4ojT&quot; data-reactid=&quot;56&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;Attribution_content_27_rw&quot; data-reactid=&quot;57&quot;&gt;Reporting by John McCrank; Editing by Bill Rigby&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Thu, 12 Oct 2017 16:42:47 +0000</pubDate>
<dc:creator>SirLJ</dc:creator>
<og:title>Equifax says systems not compromised in latest cyber scare</og:title>
<og:url>https://www.reuters.com/article/us-equifax-breach/equifax-takes-web-page-offline-after-reports-of-new-cyber-attack-idUSKBN1CH2F3</og:url>
<og:type>article</og:type>
<og:description>Equifax Inc said on Thursday that one of its third-party vendors had been running malicious code on one its web pages, but that the credit reporting agency was not the subject of another cyber attack and its systems were not compromised.</og:description>
<og:image>https://s1.reutersmedia.net/resources/r/?m=02&amp;d=20171012&amp;t=2&amp;i=1205237336&amp;w=&amp;fh=545px&amp;fw=&amp;ll=&amp;pl=&amp;sq=&amp;r=LYNXMPED9B1J0</og:image>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.reuters.com/article/us-equifax-breach/equifax-takes-down-web-page-after-reports-of-new-hack-idUSKBN1CH2F3</dc:identifier>
</item>
<item>
<title>Rust 1.21</title>
<link>https://blog.rust-lang.org/2017/10/12/Rust-1.21.html</link>
<guid isPermaLink="true" >https://blog.rust-lang.org/2017/10/12/Rust-1.21.html</guid>
<description>&lt;p&gt;The Rust team is happy to announce the latest version of Rust, 1.21.0. Rust is a systems programming language focused on safety, speed, and concurrency.&lt;/p&gt;&lt;p&gt;If you have a previous version of Rust installed, getting Rust 1.21 is as easy as:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;rustup update stable
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you don’t have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code class=&quot;highlighter-rouge&quot;&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1210-2017-10-12&quot;&gt;detailed release notes for 1.21.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h3 id=&quot;whats-in-1210-stable&quot;&gt;What’s in 1.21.0 stable&lt;/h3&gt;
&lt;p&gt;This release contains some very minor, but nice-to-have features, as well as some new documentation.&lt;/p&gt;
&lt;p&gt;First up, a small change to literals. Consider code like this:&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Rust, this code is synonymous with:&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That is, the &lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt; here will be stored on the stack, or possibly in registers. &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; will be a reference to it.&lt;/p&gt;
&lt;p&gt;However, given that it’s a literal integer, there’s no reason that it &lt;em&gt;has&lt;/em&gt; to be local like this. Imagine we had a function that took a &lt;code class=&quot;highlighter-rouge&quot;&gt;'static&lt;/code&gt; argument, like &lt;code class=&quot;highlighter-rouge&quot;&gt;std::thread::spawn&lt;/code&gt;. You might use &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; like this:&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;nn&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;spawn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;move&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt; 
    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In previous versions of Rust, this would fail to compile:&lt;/p&gt;
&lt;div class=&quot;language-text highlighter-rouge&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;error[E0597]: borrowed value does not live long enough
  --&amp;gt; src/main.rs:4:14
   |
4  |     let x = &amp;amp;5;
   |              ^ does not live long enough
...
10 | }
   | - temporary value only lives until here
   |
   = note: borrowed value must be valid for the static lifetime...
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because the &lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt; is local, so is its borrow, which doesn’t satisfy the requirements for &lt;code class=&quot;highlighter-rouge&quot;&gt;spawn&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, if you compile this on Rust 1.21, it will work. Why? Well, if the thing being referred to is okay to put into a &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;, we could instead de-sugar &lt;code class=&quot;highlighter-rouge&quot;&gt;let x = &amp;amp;5;&lt;/code&gt; like this:&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FIVE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FIVE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, since the &lt;code class=&quot;highlighter-rouge&quot;&gt;FIVE&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; is a &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;'static i32&lt;/code&gt;. And so this is what Rust will now do in this kind of case. For full details, see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1414-rvalue_static_promotion.md&quot;&gt;RFC 1414&lt;/a&gt;, which was accepted in January, but started in December of 2015!&lt;/p&gt;
&lt;p&gt;We &lt;a href=&quot;https://github.com/rust-lang/rust/pull/43506&quot;&gt;now run LLVM in parallel while generating code&lt;/a&gt;, which should reduce peak memory usage.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/rust-lang-nursery/rls/&quot;&gt;RLS&lt;/a&gt; can now be installed &lt;a href=&quot;https://github.com/rust-lang/rust/pull/44204&quot;&gt;through rustup&lt;/a&gt; by invoking &lt;code class=&quot;highlighter-rouge&quot;&gt;rustup component add rls-preview&lt;/code&gt;. In general, many useful Rust developer tools such as the RLS, Clippy, and &lt;code class=&quot;highlighter-rouge&quot;&gt;rustfmt&lt;/code&gt; need nightly Rust; this is the first steps toward having them work on stable Rust. Please check out the preview, and you’ll hear more about these plans in the future.&lt;/p&gt;
&lt;p&gt;Finally, a few documentation improvements. First up, if you visit &lt;a href=&quot;https://doc.rust-lang.org/stable/std/os/&quot;&gt;the docs for &lt;code class=&quot;highlighter-rouge&quot;&gt;std::os&lt;/code&gt;&lt;/a&gt;, which contains operating system specific functionality, you’ll now see more than just &lt;code class=&quot;highlighter-rouge&quot;&gt;linux&lt;/code&gt;, the platform we build the documentation on. We’ve long regretted that the hosted version of the documentation has been Linux-specific; this is a first step towards rectifying that. This is &lt;a href=&quot;https://github.com/rust-lang/rust/pull/43348&quot;&gt;specific to the standard library&lt;/a&gt; and not for general use; we hope to improve this further in the future.&lt;/p&gt;
&lt;p&gt;Next, &lt;a href=&quot;https://github.com/rust-lang/rust/pull/43916&quot;&gt;Cargo’s docs are moving!&lt;/a&gt; Historically, Cargo’s docs were hosted on doc.crates.io, which doesn’t follow the release train model, even though Cargo itself does. This led to situations where a feature would land in Cargo nightly, the docs would be updated, and then for up to twelve weeks, users would &lt;em&gt;think&lt;/em&gt; that it should work, but it wouldn’t yet. &lt;a href=&quot;https://doc.rust-lang.org/cargo&quot;&gt;https://doc.rust-lang.org/cargo&lt;/a&gt; will be the new home of Cargo’s docs, though for now, that URL is a redirect to doc.crates.io. Future releases will move Cargo’s docs over, and at that point, doc.crates.io will redirect to doc.rust-lang.org/cargo. Cargo’s docs have long needed a refreshing, so expect to hear more news about Cargo’s docs generally in the future!&lt;/p&gt;
&lt;p&gt;Finally, until now, &lt;code class=&quot;highlighter-rouge&quot;&gt;rustdoc&lt;/code&gt; did not have any documentation. This is now &lt;a href=&quot;https://github.com/rust-lang/rust/pull/43863&quot;&gt;fixed&lt;/a&gt;, with a new “&lt;code class=&quot;highlighter-rouge&quot;&gt;rustdoc&lt;/code&gt; Book,” located at &lt;a href=&quot;https://doc.rust-lang.org/rustdoc&quot;&gt;https://doc.rust-lang.org/rustdoc&lt;/a&gt;. These docs are fairly bare-bones at the moment, but we’ll be improving them over time.&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1210-2017-10-12&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h4 id=&quot;library-stabilizations&quot;&gt;Library stabilizations&lt;/h4&gt;
&lt;p&gt;Not too many stabilizations this release, but there’s one really great quality of life change: due to the lack of type-level integers, arrays only supported various traits up to size 32. This &lt;a href=&quot;https://github.com/rust-lang/rust/pull/43690&quot;&gt;has now been fixed for the &lt;code class=&quot;highlighter-rouge&quot;&gt;Clone&lt;/code&gt; trait&lt;/a&gt;, which also caused a lot of ICEs at times, when a type would be &lt;code class=&quot;highlighter-rouge&quot;&gt;Copy&lt;/code&gt; but not &lt;code class=&quot;highlighter-rouge&quot;&gt;Clone&lt;/code&gt;. For other traits, &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md&quot;&gt;an RFC for type-level integers was accepted recently&lt;/a&gt;, which may help with this situation. That change has yet to be implemented, however, though pre-requisite work is ongoing at the moment.&lt;/p&gt;
&lt;p&gt;Next, &lt;a href=&quot;https://github.com/rust-lang/rust/pull/44567&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator::for_each&lt;/code&gt;&lt;/a&gt; has been stabilized, letting you consume an iterator for side effects without needing a &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop:&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// old&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// new&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.for_each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The correct one to use depends on your situation; in the sample above, the &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop is pretty straightforward. But when you’re chaining a number of iterators together, the &lt;code class=&quot;highlighter-rouge&quot;&gt;for_each&lt;/code&gt; version is sometimes clearer. Consider this:&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// old&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// new&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;.filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;.for_each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/42565&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; now implement &lt;code class=&quot;highlighter-rouge&quot;&gt;From&amp;lt;&amp;amp;[T]&amp;gt; where T: Clone&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;From&amp;lt;str&amp;gt;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;From&amp;lt;String&amp;gt;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;From&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt; where T: ?Sized&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;From&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/rust-lang/rust/pull/44593&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;max&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt; functions on the &lt;code class=&quot;highlighter-rouge&quot;&gt;Ord&lt;/code&gt; trait&lt;/a&gt; are now stable.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/rust-lang/rust/pull/44639&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;needs_drop&lt;/code&gt; intrinsic&lt;/a&gt; is now stable.&lt;/p&gt;
&lt;p&gt;Finally, &lt;a href=&quot;https://doc.rust-lang.org/std/mem/fn.discriminant.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::mem::discriminant&lt;/code&gt; has been stabilized&lt;/a&gt;, allowing you to see what variant an &lt;code class=&quot;highlighter-rouge&quot;&gt;enum&lt;/code&gt; instance is without a &lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt; statement.&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1210-2017-10-12&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h4 id=&quot;cargo-features&quot;&gt;Cargo features&lt;/h4&gt;
&lt;p&gt;Beyond the documentation features listed above, Cargo is gaining one major feature in this release: &lt;a href=&quot;https://github.com/rust-lang/cargo/pull/4123&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[patch]&lt;/code&gt;&lt;/a&gt;. Designed in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1969-cargo-prepublish.md&quot;&gt;RFC 1969&lt;/a&gt;, the &lt;code class=&quot;highlighter-rouge&quot;&gt;[patch]&lt;/code&gt; section of your &lt;code class=&quot;highlighter-rouge&quot;&gt;Cargo.toml&lt;/code&gt; can be used when you want to override certain parts of your dependency graph. We also have a feature, &lt;code class=&quot;highlighter-rouge&quot;&gt;[replace]&lt;/code&gt; that has similar functionality. In many ways, &lt;code class=&quot;highlighter-rouge&quot;&gt;[patch]&lt;/code&gt; is the new &lt;code class=&quot;highlighter-rouge&quot;&gt;[replace]&lt;/code&gt;, and while we have no plans to deprecate or remove &lt;code class=&quot;highlighter-rouge&quot;&gt;[replace]&lt;/code&gt;, at this point, you should use &lt;code class=&quot;highlighter-rouge&quot;&gt;[patch]&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;[replace]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So what’s it look like? Let’s say we have a &lt;code class=&quot;highlighter-rouge&quot;&gt;Cargo.toml&lt;/code&gt; that looks like this:&lt;/p&gt;
&lt;div class=&quot;language-toml highlighter-rouge&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;nn&quot;&gt;[dependencies]&lt;/span&gt;
&lt;span class=&quot;py&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1.2.3&quot;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In addition, our &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; crate depends on a &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt; crate, and we find a bug in &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;. To test this out, we’d download the source code for &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;, and then update our &lt;code class=&quot;highlighter-rouge&quot;&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;language-toml highlighter-rouge&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;nn&quot;&gt;[dependencies]&lt;/span&gt;
&lt;span class=&quot;py&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1.2.3&quot;&lt;/span&gt;

&lt;span class=&quot;nn&quot;&gt;[patch.crates-io]&lt;/span&gt;
&lt;span class=&quot;py&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'/path/to/bar'&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, when you &lt;code class=&quot;highlighter-rouge&quot;&gt;cargo build&lt;/code&gt;, it will use the local version of &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;, rather than the one from &lt;code class=&quot;highlighter-rouge&quot;&gt;crates.io&lt;/code&gt; that &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; depends on.&lt;/p&gt;
&lt;p&gt;For more details, see the &lt;a href=&quot;http://doc.crates.io/manifest.html#the-patch-section&quot;&gt;documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Additionally:&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1210-2017-10-12&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h3 id=&quot;contributors-to-1210&quot;&gt;Contributors to 1.21.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.21. We couldn’t have done it without all of you. &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.21.0&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Oct 2017 15:59:10 +0000</pubDate>
<dc:creator>steveklabnik</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://blog.rust-lang.org/2017/10/12/Rust-1.21.html</dc:identifier>
</item>
<item>
<title>Digging for treasure in Aladdin’s source code</title>
<link>https://gamehistory.org/aladdin-source-code/</link>
<guid isPermaLink="true" >https://gamehistory.org/aladdin-source-code/</guid>
<description>&lt;p&gt;When it was released back in 1993, &lt;a class=&quot;link primary-color&quot; href=&quot;http://en.wikipedia.org/wiki/Disney%27s_Aladdin_(Virgin_Games_video_game)&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Disney’s Aladdin&lt;/a&gt; for the Sega Genesis (or Mega Drive, depending on which side of the pond you lived on through the early 90’s) was really a visually striking game.&lt;/p&gt;
&lt;p&gt;Powered by what eventually became known as “Digicel” technology, along with a solid selection of middleware and some impressive talent, Aladdin managed to set itself apart from other Genesis titles of the era. Aladdin’s beautifully hand-crafted, surprisingly well-quantized artwork set new expectations for many in the realm of what could be accomplished on Genesis hardware. It did so not by leveraging any particularly fancy raster effects or obscure hardware techniques, but rather by pairing effective artwork and design with just the right technology.&lt;/p&gt;
&lt;p&gt;This unique blend of artwork and technology is a large part of what gives Aladdin a special place in video game history. It’s also a large part of what made it such a joy to discover an archive featuring the complete source code for the game in the &lt;a class=&quot;link primary-color&quot; href=&quot;http://gamehistory.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Video Game History Foundation&lt;/a&gt; collection! In addition to being a treasure trove of data, this archive represented a great opportunity for me to begin establishing standards for source code archival, curating practices, tool dependency tracking, and a lot of other process-oriented things at the VGHF.&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/wp-content/uploads/2017/10/genietiles.png&quot; rel=&quot;attachment wp-att-881&quot;&gt;&lt;img class=&quot;alignnone wp-image-1044 size-full&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/10/genietiles.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;Almost all of the development tools and materials were still intact in this archive. I quickly started piecing processes together, and began working on getting the source code (which is written entirely in &lt;a class=&quot;link primary-color&quot; href=&quot;http://en.wikipedia.org/wiki/Motorola_68000_series&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;M68K&lt;/a&gt; assembly) built into a working binary. I’m going to walk you through the journey and reveal my discoveries at each step of the way. That includes finding a plethora of unreleased material, and even re-implementing entire objects and enemies that had been removed by the time Aladdin saw its commercial release!&lt;/p&gt;
&lt;p&gt;Hopefully you like technical talk, because I’m not holding anything back. If not, well, there are pictures! (and you can skip straight to the &lt;a class=&quot;link primary-color&quot; href=&quot;https://gamehistory.org/aladdin-source-code/#sect_30&quot;&gt;cool section&lt;/a&gt;) You might also want a copy of &lt;a class=&quot;link primary-color&quot; href=&quot;http://www.richwhitehouse.com/index.php?content=inc_projects.php&amp;amp;showproject=91&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Noesis&lt;/a&gt; on hand to explore along with me. In case you aren’t familiar, in short summary, it’s a tool built on a framework to assist in reverse engineering and exploring all manner of data. It includes a script, &lt;em&gt;fmt_virginmd_chopper.py&lt;/em&gt;, which will allow you to dig all of the Chopper tile data out of any known (commercial or otherwise) Aladdin ROM image. The resulting data can then be viewed directly by Noesis. While it won’t give you access to the materials that didn’t actually make it to retail, it will allow you to flip through frames and observe tile usage in the finished product.&lt;/p&gt;
&lt;p&gt;It’s also worth noting that Noesis can dig the Chopper data back up out of the Aladdin &lt;a class=&quot;link primary-color&quot; href=&quot;http://hiddenpalace.org/Aladdin_(Chicago_C.E.S_demo)&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;CES demo build&lt;/a&gt;. This reveals a few interesting things exclusive to that build, including some additional sketch material that does not appear to be accessible in the build through normal gameplay.&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/wp-content/uploads/2017/10/cesrun-1.gif&quot; rel=&quot;attachment wp-att-887&quot;&gt;&lt;img class=&quot;alignnone wp-image-1037 size-full&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/10/cesrun-1.gif&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;The CES demo build is labeled as a Chicago CES demo, but as noted in the build’s &lt;a class=&quot;link primary-color&quot; href=&quot;https://tcrf.net/Proto:Disney%27s_Aladdin_(Genesis)&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;TCRF article&lt;/a&gt;, the SNASM-generated timestamp reflects June 27th, 1993. This indicates that the build was produced several weeks after the show had taken place.&lt;/p&gt;
&lt;p&gt;Referencing our source archive, we can see that some source art was modified as late as mid June, and is already removed from ROM in the CES demo build. This is far from conclusive (we have no way of knowing if source art continued to be modified after being removed from the Chopper database), but supports the idea that the CES demo build may have been produced from an active development branch on June 27th, 1993, rather than being further developed on a branch of an earlier development snapshot. For simplicity’s sake, though, I’ll continue to refer to this build as the CES demo build when the material I’m discussing relates to the build in some way.&lt;/p&gt;
&lt;h3 class=&quot;pt3&quot;&gt;Contents&lt;/h3&gt;

&lt;h3 class=&quot;pt3&quot;&gt;1. Overview&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;41&quot;&gt;
&lt;p&gt;The archive containing Aladdin is laid out such that it looks to have been someone’s working copy of the game’s source code and data, as opposed to being a shared repository of any sort. A few of the data dependencies were missing in the archive, which was a little surprising, with the game having been built out of this very workspace at some point. However, I was able to reproduce the missing data without much trouble to get a usable binary building again.&lt;/p&gt;
&lt;p&gt;Although content otherwise seems to match the retail distributions of Aladdin, modified dates for some of the source files in this archive are as late as September 30, 1993. That’s 10 days later than the build date of the Japanese distribution, which is September 20, 1993. There are no apparent data changes, but a thorough byte to byte comparison is somewhat problematic due to the drastically different build circumstances.&lt;/p&gt;
&lt;p&gt;The really fun part here is that this archive includes a big chunk of source art material! That’s where the stuff that never made it into the game is hiding. That material is generally built into a more ideal/compact form by some other tool(s) before finally being included in the ROM itself. We’ll be taking a look at all of those tools and processes in this article.&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/?attachment_id=906&quot; rel=&quot;attachment wp-att-906&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-906&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/al_ching.jpg&quot; alt=&quot;&quot; width=&quot;80%&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;span class=&quot;f6&quot;&gt;An example of animation sequence source data.&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;The other big discovery in this Aladdin archive is that there are large swaths of commented out code for prototyped and/or removed features. These days, if a programmer were to comment out hundreds of lines of newly-unused code instead of removing them outright, they’d probably get chewed out in their code review. But thanks to that wonderful practice, we get to enjoy true-to-intent features, enemies, and more, 24 years into the future! Take that, coding standards!&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;2. Tools&lt;/h3&gt;
&lt;p&gt;From building the code to creating and preparing the data for use, Aladdin leverages a pretty sizable toolset, all within the friendly confines of MS-DOS. This archive gives us an effective view into the actual content creation processes that were used at Virgin to bring this game to life. In this section, I’ll discuss what each tool is/does, and chronicle my experience in discovering and using it.&lt;/p&gt;
&lt;h3 class=&quot;pt3&quot;&gt;2.1. SNASM68K&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;76.596330275229&quot;&gt;
&lt;p&gt;An old log in the archive appeared to implicate version 1.29 (or 1.30, at odds with some code comments) of &lt;a class=&quot;link primary-color&quot; href=&quot;http://segaretro.org/SNASM68K&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;SNASM68K&lt;/a&gt; as the original assembler of choice for Aladdin. I was already somewhat familiar with SNASM, after a brief foray into Sega CD development many years ago, but I only had access to newer versions of the tool. That meant I had to make a few changes to get the source built again. The most unpleasant change there was due to the fact that SNASM decided to switch between “!” and “|” for the OR operator at some point, which led to some sweeping macro changes. A few branch relays were also required here and there, despite the fact that memory layout remains relatively faithful to the commercial binary.&lt;/p&gt;
&lt;p&gt;Assessing the code itself, it was readily apparent that a file called FOLDER.68K was intended to be the entrypoint for the assembler. This file defines a number of “build configuration”-esque variables, many of which conditionally include/exclude bits of code elsewhere, or determine whether PAL or NTSC data get pulled into ROM. After getting familiar with things and dealing with the assorted SNASM version-related issues, I tried booting up the resulting binary, and was delighted to see:&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/aladdin-source-code/boottext/&quot; rel=&quot;attachment wp-att-914&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-914&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/boottext.jpg&quot; alt=&quot;&quot; width=&quot;80%&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;This is actually from the cheat screen that appears still enabled at retail, and it appears on startup by default in this archive’s code drop, with an updated SNASM-supplied timestamp. Its appearance at startup is contingent upon one of those “build configuration” variables as well.&lt;/p&gt;
&lt;p&gt;I happily proceeded further into the game, and was greeted with a hang when loading into the first level. Time to bust out the debugger! Oh wait, I don’t have a debugger. After a couple rounds of troubleshooting by way of inserting jump-to-selfs to narrow down the hang window, I decided to stop being a terrible person and go see if there were any Genesis emulators out there with built-in debuggers that didn’t require me to download 50 separate libraries in order to produce a custom debugger-enabled build. I came across a debugger-enabled build of &lt;a class=&quot;link primary-color&quot; href=&quot;http://segaretro.org/Regen&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Regen&lt;/a&gt; at this point, and away I went!&lt;/p&gt;
&lt;p&gt;Breaking in-place from an already-hung state in Regen, the program counter was off in no man’s land, the register states were generally hosed, and the stack was trashed, such that I could not determine what the last sane place of code execution was, even when attempting to employ Aladdin’s built-in exception handler. This is when you know you’re in for fun times.&lt;/p&gt;
&lt;p&gt;After producing an address map with SNASM to see what was actually going where, I got the address for a point in the code that looked about right for where things get kicked off for a level load. Set a PC breakpoint on that address and ran. Breakpoint hit, so I stepped through a bit, and determined it was diverging into oblivion somewhere within the &lt;a class=&quot;link primary-color&quot; href=&quot;https://gamehistory.org/aladdin-source-code/#sect_25&quot;&gt;ProPack&lt;/a&gt; decompress-to-RAM routine. Namely, when decompressing the level’s “FLOOR” data. This is what it sounds like, it’s a look-up table that defines the level’s floor tiles.&lt;/p&gt;
&lt;p&gt;I stepped through the decompression loop quite a bit, observing no problems, until I finally noticed the destination address. It was decompressing floor data all over the user stack. That didn’t seem right! I looked over to the labels that defined the location of the active floor in RAM, and it was indeed right above the user stack.&lt;/p&gt;
&lt;p&gt;As it turned out, there was some macro magic in there to get the maximum size of all the uncompressed floor files, and use that to determine the size of the floor region in RAM. Said macro magic was managing to wind up calculating a nice value of “0” in my version of SNASM. Fixed that, vetted for any other locations in the code using similar macro magic, and it was smooth sailing from there. No more apparent issues from a cursory run-through of the game.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;2.2. Chopper&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;89.534711964549&quot;&gt;
&lt;p&gt;Chopper is probably the unsung hero behind what Virgin referred to as “Digicel” technology. Unfortunately, I don’t really have any visibility over the process that was used to take hand-drawn art and digitize it, other than that it seems to, at some point, end up with the art being imported into &lt;a class=&quot;link primary-color&quot; href=&quot;http://en.wikipedia.org/wiki/Deluxe_Paint_Animation&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;DeluxePaint Animation&lt;/a&gt;. I don’t know whether it was largely driven by generic hardware/software solutions, or if Virgin introduced something proprietary into the mix. What I do know is that once something had made its way down to DeluxePaint Animation, Chopper took it from there.&lt;/p&gt;
&lt;p&gt;Chopper is a wholly-proprietary interface-driven tool, which works off of its own sprite database format. It was principally developed by Andy Astor, but looks to have been touched by quite a few hands. This includes David Perry, who specified the Genesis output format. Unfortunately, Chopper’s source code is not included in the archive, so our visibility into its development is limited to accompanying documentation.&lt;/p&gt;
&lt;p&gt;Chopper’s primary role is to chop imported animations up into tiles, varying in sizes from 1×1 to 4×4. (inclusive of rectangular dimensions, and where each tile is 8×8 pixels) It has a variety of chopping options, as well as options for how to default each animation frame’s collision box, and whether to consider frame, sequence, or whole database when deciding how to chop. The interface itself looks like this:&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/aladdin-source-code/chopper_cut_s/&quot; rel=&quot;attachment wp-att-918&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-918&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/chopper_cut_s.jpg&quot; alt=&quot;&quot; width=&quot;80%&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;Above, I’ve imported the Prisoner, who was removed from the retail version of the game. We can see the distinct boundaries where the current frame has been chopped into groups of tiles. The yellow rectangle represents the collision box for the frame, and each number represents the number of times that tile group is reused.&lt;/p&gt;
&lt;p&gt;Although Chopper operates on its own proprietary database format, it’s capable of exporting tile data to a variety of ideal platform target formats, aimed primarily at the Genesis and SNES. In the case of Aladdin/Genesis, Chopper writes out a number of .SEG (Sega, rather than segment as the programmer or Doom mapper in you might initially suspect) files, which represents the whole of raw tile data for each 1×1 – 4×4 size. Chopper also generates a number of .68K files, which are meant to be assembled as code, and define additional properties for each frame. (part count, collision, and per-part properties like tile size, offset, and index) These files also define the intended order of data inclusion, reflecting the data’s final placement in ROM, and dictating any necessary alignment restrictions for the tile data itself.&lt;/p&gt;
&lt;p&gt;The Noesis script mentioned earlier in this article, &lt;em&gt;fmt_virginmd_chopper.py&lt;/em&gt;, will attempt to locate frame data in the expected Genesis form, and convert it back up into a series of .SEG files with a plain-text .68K file that references back into the .SEG files using the same naming conventions as native Chopper Sega data. You’re free to play around with the plain text file in order to observe how changing the properties affects use of the tiles, just as it would on hardware.&lt;/p&gt;
&lt;p&gt;Another interesting aspect of Chopper is that it’s set up to explicitly look for a single-pixel rectangle to define the desired bounds of an animation sequence. I’ve also coded up a parameter option to mimic this for the DeluxePaint Animation importer in Noesis. A lot of the animation sources therefore look something like this:&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/aladdin-source-code/al_run1_nochop/&quot; rel=&quot;attachment wp-att-921&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-921&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/AL_RUN1_nochop.gif&quot; alt=&quot;&quot; width=&quot;80%&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;Many sources contain active image data outside of the desired rectangle, which was probably commonly used as a scratch pad and for reference. After Chopper imports the sequence with its default handling, it ends up looking like this:&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/wp-content/uploads/2017/10/AL_RUN1_chop-1.gif&quot; rel=&quot;attachment wp-att-922&quot;&gt;&lt;img class=&quot;alignnone wp-image-1036 size-full&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/10/AL_RUN1_chop-1.gif&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;Another tool was also written as part of Aladdin’s Chopper import process, which trivially digests Chopper’s native .68K output to spit out some additional per-frame tables/lists. This includes a linear list of pointers to each frame, probably born of a desire to be able to increment frames by jumping between pointers instead of dealing with the variable size (due to a variable number of parts) of each frame.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;2.3. tUME&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;44.893742621015&quot;&gt;
&lt;p&gt;Aladdin makes use of &lt;a class=&quot;link primary-color&quot; href=&quot;http://games.greggman.com/game/tume___the_universal_map_editor/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;tUME&lt;/a&gt;, which is a generic tile-based map editor. Like every other game of the era that used tUME, Aladdin has its very own custom tUME packer. The packer is a standalone tool, which exports data in a collection of formats ideally suited to the platform and to the particular title.&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/aladdin-source-code/tume_cut/&quot; rel=&quot;attachment wp-att-925&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-925&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/tume_cut.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;In the case of Aladdin, the tUME packer is named “tPJungle”, presumably named after its intended use in The Jungle Book. tPJungle spits out a variety of files, including block/character data, contour data (which is typically shared between levels), floor look-up/tile data, a variety of room data types (depending on whether the level is a traditional room, or a picture room like the Genie bonus screen and other cameo screens seen in the game), palettes, and parallax files which allow multiple room layers to reference into the character/tile data.&lt;/p&gt;
&lt;p&gt;The output of the tUME packer tends to then be compressed as part of a separate batch process, and the compressed (or in some cases still not compressed) data is manually referenced within a .68K file.&lt;/p&gt;
&lt;p&gt;Enemies and objects are placed according to their tile number. This means that the following tile table bitmap corresponds directly to a table in code which triggers the appropriate object spawner/generator based on the tile index:&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/aladdin-source-code/object/&quot; rel=&quot;attachment wp-att-924&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-924&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/OBJECT.jpg&quot; alt=&quot;&quot; width=&quot;80%&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;There are a good many unused slots, as well as slots that were previously referencing now-removed objects (like the Prisoner or Sword Swallower) which now direct to stub functions. Unfortunately, the removed enemies don’t look to be placed in any of the tUME sources, so outside of hints from the design document, we don’t get any free indicators of how/where these enemies were meant to be placed.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;2.4. GEMS&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;18.164294954722&quot;&gt;
&lt;p&gt;Aladdin uses the &lt;a class=&quot;link primary-color&quot; href=&quot;http://segaretro.org/GEMS&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;GEMS&lt;/a&gt; driver for sound, leveraging FM and PSG patches a good bit in its music playback. A separately generated data set is also provided for the PAL distribution. Our archive does not contain the GEMS intermediate sources, and the GEMS-generated code/data is accompanied by a batch file that shows it being copied locally from a network location. This means that anything we can divine from this archive, we can also divine from the retail game by digging the GEMS sequence/sample/patch/etc. data back up from the binary.&lt;/p&gt;
&lt;p&gt;What is present in this archive, however, is the actual Cakewalk MIDI source (used to feed the sequencer which fed GEMS) and linear PCM samples provided directly by &lt;a class=&quot;link primary-color&quot; href=&quot;https://en.wikipedia.org/wiki/Tommy_Tallarico&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Tommy Tallarico&lt;/a&gt;! You can read more about that over in &lt;a class=&quot;link primary-color&quot; href=&quot;https://gamehistory.org/aladdin-source-code/#sect_35&quot;&gt;Sound and Music&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;2.5. ProPack&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;27.732970027248&quot;&gt;
&lt;p&gt;Rob Northen’s &lt;a class=&quot;link primary-color&quot; href=&quot;http://segaretro.org/Rob_Northen_compression&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;ProPack&lt;/a&gt; is used pretty extensively in Aladdin on a variety of data types, including floor look-up tables and character (but not animated/chopped) tile data. Aladdin uses method 1, as outlined in the Sega Retro article I just linked, exclusively. Having plenty of decoder references (in 8086, M68K, and 6502 assembly to name a few) available, I also wrote an implementation of the decoder for Noesis.&lt;/p&gt;
&lt;p&gt;Numerous batch files are present in the Aladdin archive, which appear to have been manually maintained to convert and compress all of the relevant level data for direct inclusion in ROM. Presumably, the level design workflow here was something like “Modify in tUME, save, exit tUME, run batch, assemble, run game”.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;3.0. Buried Treasure&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;38.491580662683&quot;&gt;
&lt;p&gt;The most exciting thing about digging into this archive was unearthing the wealth of material present that hadn’t managed to make its way into the retail game. I was very surprised to find so much stuff still intact, and even more surprised to find out how much relevant code still existed (albeit not assembled into the retail ROM image) in the codebase.&lt;/p&gt;
&lt;p&gt;After getting familiar with Chopper and the rest of the tools, I set about re-importing some of the removed assets and re-adding various bits of code for things like old object generators, animations, and alien (more commonly known these days as actors, or entities if you’ve got Quake in your blood) logic. I bumped the ROM size up to 4MB (32Mbit), so that I’d have plenty of room to pile all of that glorious film back in straight from the cutting room floor, and not have to do any picking and choosing over what I wanted to bring back. Some of the code was ready to roll right out of the box, but in other cases I had to do some fixing up and tweaking to get things fully operational again.&lt;/p&gt;
&lt;p&gt;Another amazing bonus found within these files was a copy of the game’s &lt;a class=&quot;link primary-color&quot; href=&quot;https://gamehistory.org/aladdin-source-code/#sect_36&quot;&gt;original design document&lt;/a&gt;, version 3.3, dated from April 27, 1993. I’ve used this document as a reference to help me determine original intent for the incomplete code and features I’ve come across in my travels.&lt;/p&gt;
&lt;p&gt;I’m not even covering the whole body of extra material here, but these are the big highlights thus far. I’ve also found game-ready animations for the skeleton from the CES demo build, with the addition of a walking sequence. It appears there may have been some intent to have him stumble toward the player before exploding. There’s no related code in place, and I haven’t gotten around to writing up brand new animation/state logic for him, so that’s something else to look forward to.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;3.1. Bonus Round&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;40&quot;&gt;
&lt;p&gt;One of the first things I came across was a bunch of old Genie bonus round code. It explicitly sets up an “arm” alien which represents the slot machine lever, and uses some additional movement and state code. I brought the old Genie slot code back wholesale, and re-imported all of the animation dependencies through Chopper. I also noticed there was a spinning Genie coin animation in the source art, which made sense with this slot machine theme, so I brought that back in too. Here’s the result:&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/?attachment_id=929&quot; rel=&quot;attachment wp-att-929&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-929&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/aladdin_oldslots.gif&quot; alt=&quot;&quot; width=&quot;80%&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;You’ll notice the background doesn’t quite match up with the slot arm. Fortunately, I managed to locate the tUME map source for the background that it does belong to, buried in a “TRASH” directory. I exported the old tUME map with tPJungle, and got it plugged back into the game:&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/aladdin-source-code/aladdin_oldslots_bg/&quot; rel=&quot;attachment wp-att-930&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-930&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/aladdin_oldslots_bg.jpg&quot; alt=&quot;&quot; width=&quot;80%&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;However, this background comes with its own issues. The foreground layer doesn’t appear to be set up quite correctly, and there’s no remaining logic in code that meshes with the idea of a 3-reel slot machine as the background itself would seem to indicate. It’s hard to say whether this background didn’t actually make its way into prototyping before being taken to the chopping block, or if the code related to it was completely removed. It’s also possible that this “TRASH” copy is not the final background that was used prior to the removal of this slot machine themed bonus round.&lt;/p&gt;
&lt;p&gt;We’d have to adjust quite a few things on our own to bring back this bonus game in a way that makes sense and meshes with the original slot machine theme. We do, however, still have all of the data we’d need to be able to faithfully reflect the original intent in a new implementation. The slot machine version of this bonus game is described in great detail in the game’s design document. A rock, paper, scissors bonus game is also described, but there is no trace of it in source code or art, so it seems that the idea never got off the ground.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;3.2. Enemies&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;104&quot;&gt;
&lt;p&gt;Numerous enemies were removed from the game prior to the retail distribution. The considerations for removal probably varied on a case-by-case basis, between design/appeal reasons, development time, and ROM space limitations. Given how tightly the retail game was butting up against the 2MB (16Mbit) ROM constraint, we can only speculate on the decision balance for each case. Some of these enemies were fully functional, while others required a bit of love and care to restore.&lt;/p&gt;
&lt;h4 class=&quot;nb2&quot;&gt;Sword Swallower&lt;/h4&gt;
&lt;p&gt;The Sword Swallower is a close design relative of the Knife Juggler, and was intended to be part of the marketplace enemy lineup. He sits in one location, and pulls an endless stream of swords out of his throat to toss across the screen. He needed his projectiles hooked back up as well, but was functional without additional modification, and appears to behave in keeping with his CES demo build implementation.&lt;/p&gt;
&lt;p&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/3VuXtbZaZW0?rel=0&amp;amp;showinfo=0&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;allowfullscreen&quot;&gt;[embedded content]&lt;/iframe&gt;&lt;/p&gt;
The Sword Swallower in action.
&lt;h4 class=&quot;nb2&quot;&gt;Prisoner&lt;/h4&gt;
&lt;p&gt;The Prisoner was intended to help populate the Sultan’s Dungeon, and comes complete with several separate animation sequences. He idly files away at the chain on his leg, and begins swinging the ball and chain around his leg when approached. He also has a pain/reaction sequence, which I had to implement from scratch, as no traces of related code remained. The Prisoner also appears in the CES demo build, but with an incorrect palette, and with no reaction sequence present in the ROM.&lt;/p&gt;
&lt;p&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/_dPIBDLlKJo?rel=0&amp;amp;showinfo=0&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;allowfullscreen&quot;&gt;[embedded content]&lt;/iframe&gt;&lt;/p&gt;
The cut Prisoner enemy, rebuilt and reborn!
&lt;h4 class=&quot;nb2&quot;&gt;Golden Monkey&lt;/h4&gt;
&lt;p&gt;Shown here in what’s certainly an inappropriate context (he’s intended for the Cave of Wonders), the Golden Monkey is a relatively simple enemy that just tosses an endless stream of jewels at the player. No other animations are provided for this guy, and no additional code was required to get him back up and running.&lt;/p&gt;
&lt;p&gt;The design document describes the Golden Monkey as behaving identically to the Shiva statue in the retail game. Likewise, the Shiva statue was intended to be a more involved encounter, triggered by Iago flying by and dropping a vial. It seems the decision was made, at some point, to simply drop the Golden Monkey and use the Shiva statue in its place.&lt;/p&gt;
&lt;p&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/G5LRtXflISs?rel=0&amp;amp;showinfo=0&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;allowfullscreen&quot;&gt;[embedded content]&lt;/iframe&gt;&lt;/p&gt;
The Golden Monkey, out of its element (it was meant to appear in the Cave of Wonders stage).
&lt;h4 class=&quot;nb2&quot;&gt;Flamingo Iago&lt;/h4&gt;
&lt;p&gt;In the Sultan’s Palace level, Iago was meant to make an appearance in a flamingo getup. He marches across the screen on stilts, and damages the player on contact.&lt;/p&gt;
&lt;p&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/glUora1hbY0?rel=0&amp;amp;showinfo=0&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;allowfullscreen&quot;&gt;[embedded content]&lt;/iframe&gt;&lt;/p&gt;
Flamingo Iago obviously would have walked on this level’s water sections, you’ll have to use your imagination a little bit here.
&lt;p&gt;Flamingo Iago’s animation sequence is also present in the CES demo build’s ROM, even though it does not appear to be used in the game.&lt;/p&gt;
&lt;h4 class=&quot;nb2&quot;&gt;Rolly Snake&lt;/h4&gt;
&lt;p&gt;While the snake did make his way into the retail version of the game, he was originally intended to roll. His internal name is, in fact, ROLLY_SNAKE. I came across some code that indicated he was meant to do a roll if he was close enough to the player after an attack. I hooked that code back up and was greeted by some curious behavior, where the direction of the roll was very random and occasionally would leave the snake stuck in “rolling” mode even after the animation had stopped. I had to do a bit of fixing up, but was able to get his roll attack back in a state that at least looked like it made some sense.&lt;/p&gt;
&lt;p&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/xQiXlkkNPa0?rel=0&amp;amp;showinfo=0&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;allowfullscreen&quot;&gt;[embedded content]&lt;/iframe&gt;&lt;/p&gt;
A simple implementation of the snake’s unused rolling animation.
&lt;p&gt;Interestingly, our copy of the design document outlines behavior quite different from what was indicated by the code:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;If the snake is hit by 2 throwable objects in a row, it will become a snake-wheel and roll to the right, over other enemies, killing them. The snake will roll fast enough so that Aladdin will not be able to catch up to it, and it will roll off the screen.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;There are no indications in the source code that this behavior ever made its way into the game. In speculation, this might be an indication that the present implementation of rolling was a test, compromising the feature while still attempting to utilize the animation work that had been done. The snake’s animations (including the roll sequence) are also present in the CES demo build’s ROM, even though the snake doesn’t make an appearance in the demo.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;3.3. Genie Parts&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;61.5&quot;&gt;
&lt;p&gt;Several environmental Genie objects were removed from the retail game, although none of them appear to have managed to get to the point of being fully polished. These objects were intended to be used on the “Inside the Lamp” level, and pertained to affecting player mobility throughout the map.&lt;/p&gt;
&lt;h4 class=&quot;nb2&quot;&gt;Genie Arm&lt;/h4&gt;
&lt;p&gt;The Genie Arm is a Genie hand connected to 6 orbs. It moves on a fixed path upon contact, carrying the player with it.&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/aladdin-source-code/aladdin_geniearm/&quot; rel=&quot;attachment wp-att-942&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-942&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/aladdin_geniearm.gif&quot; alt=&quot;&quot; width=&quot;80%&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;The Genie Arm was likely intended to supplement the existing hand platforms (which did make it into the retail game), as described in the design document:&lt;/p&gt;
&lt;div class=&quot;b--purple bl bw2 pl3&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;em&gt;These are the main ‘building blocks’ of the level and form the majority of the platforms that Aladdin moves on. Some of these platforms will shrink and grow back to their original size in regular patterns. Obviously the larger the hand, the easier it is to jump onto as it presents a larger target. The level design will use this timing mechanic to the full.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Other hand platforms will look slightly different and will be made out of tiles rather than sprites. This will enable us to avoid embarrassing sprite flicker.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Due to a quirk of the implementation, only one Genie Arm can exist at a time, because it’s effectively coded up as a singleton. When a new arm comes into the view, the previous arm becomes that arm, causing the previous arm to effectively disappear.&lt;/p&gt;
&lt;h4 class=&quot;nb2&quot;&gt;Genie Hands&lt;/h4&gt;
&lt;p&gt;The Genie Hands don’t seem to have a direct design correlation, and in what is left of the implementation, it’s just a pair of hands clapping. It can’t be interacted with.&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/aladdin-source-code/aladdin_geniehands/&quot; rel=&quot;attachment wp-att-946&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-946&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/aladdin_geniehands.gif&quot; alt=&quot;&quot; width=&quot;80%&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;It’s difficult to say whether this might’ve been some kind of hazard, or if it affected mobility in some other way. It’s possible that some vital/associated code was removed (rather than being left for reference) because it tied into other (player-related) logic.&lt;/p&gt;
&lt;h4 class=&quot;nb2&quot;&gt;Genie Ball&lt;/h4&gt;
&lt;p&gt;The Genie Ball pops into existence when the player approaches, then locks the player in place on top of it upon contact:&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/aladdin-source-code/aladdin_genieball/&quot; rel=&quot;attachment wp-att-947&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-947&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/aladdin_genieball.gif&quot; alt=&quot;&quot; width=&quot;80%&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;The Genie Ball’s intended design is called out in the design document:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;These are a double-edged sword. If Aladdin can get on top of a rolling Genie ball, he can use it as a kind of moving elevator to get around various sections of the lamp. The ball also offers the additional height sometimes required to make a jump up to a bonus or secret area, but Aladdin may have to balance on the ball for a while before the ball is in the correct place from which to make the jump.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The Genie Ball code integrates pretty significantly into player movement code, so it wouldn’t be too surprising if something is very broken in its newly-resurrected form. The object may also have additional setup requirements that aren’t being fulfilled here, as indicated by its working behavior in the CES demo build.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;3.4. Sketches&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;54&quot;&gt;
&lt;p&gt;Within the source art, there are a few digitized pieces in sketch form. As an example, here’s a sketching of each frame of Aladdin’s falling animation:&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/?attachment_id=949&quot; rel=&quot;attachment wp-att-949&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-949&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/al_fall1.jpg&quot; alt=&quot;&quot; width=&quot;80%&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;We have more details provided in the sketch for Aladdin’s second falling animation. The image itself calls out specific frames for loops and holds:&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/aladdin-source-code/al_fall2/&quot; rel=&quot;attachment wp-att-950&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-950&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/al_fall2.jpg&quot; alt=&quot;&quot; width=&quot;80%&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;This provides a tiny glimpse back upward into the actual art creation process. Of particular note is a game-ready Abu animation that I came across, which is still in sketch form:&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/wp-content/uploads/2017/10/AB_LKBAG-1.gif&quot; rel=&quot;attachment wp-att-951&quot;&gt;&lt;img class=&quot;alignnone wp-image-1038 size-full&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/10/AB_LKBAG-1.gif&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;This particular bit of art is for Abu looking into a bag, which doesn’t seem to be reflected by any particular game event or remaining prototype code. However, a related mechanic that would affect boss battles is called out in the design document:&lt;/p&gt;
&lt;div class=&quot;b--purple bl bw2 pl3&quot; readability=&quot;39&quot;&gt;
&lt;p&gt;&lt;em&gt;Aladdin arrives at the boss, the scroll stops and the music changes to the boss music we will use for every boss. As the music changes, Abu will dart into view from off screen and place a magic bag of gems, which he is prepared to reluctantly lend to Aladdin, somewhere on the screen (in more inaccessible places in the later levels and also in the hard difficulty setting), in order to help him defeat the boss.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Abu then darts off screen again as he certainly doesn’t want to stay around for the ensuing ‘fun’! All Aladdin has to do is move over the bag (as he would to collect any other object or throwable) and the bag will disappear (into Aladdin’s inventory).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Abu’s bag is magic because it contains a never-ending supply of gems so Aladdin will never run out.  Abu, though, as we know, is partial to the odd gem and takes the bag back off of Aladdin after the defeat of each boss (the bag will automatically be thrown to one side of Aladdin after a boss has been defeated), Abu will dart back into view, once again, to retrieve the bag before disappearing off screen again.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;When he retrieves his magic bag, Abu’s reaction/behavior will depend on the number of gems used by Aladdin in defeating the boss. The more gems used, the more angry he will be in his gesticulation. If Aladdin uses no gems, Abu will show his pleasure in some Abu like way. There will probably be three different Abu reactions in the cartridge version (ecstatic, nonchalant and angry) and five in the CD one.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;In a similar vein, this fish animation, also present in the CES demo build, still lives alongside its completed version in the source art:&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/wp-content/uploads/2017/10/FS_FISH-1.gif&quot; rel=&quot;attachment wp-att-952&quot;&gt;&lt;img class=&quot;alignnone wp-image-1039 size-full&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/10/FS_FISH-1.gif&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;It may be a bit telling that we have masked, game-ready artwork still in sketch form and ready to go, and that some of it was even employed in the game for the CES demo build. It’s unlikely that this would occur if the process of getting art to this point weren’t already incredibly streamlined, and reveals a rather interesting workflow!&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;3.5. Sound and Music&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;34&quot;&gt;
&lt;p&gt;Although we don’t have any intermediary source/project data relating to GEMS, we have something even better hidden within this archive, which is the raw Cakewalk MIDI files and sample data provided by Tommy Tallarico. All of the digital samples were delivered in the form of raw 8-bit linear PCM blobs, such that Tommy calls out the sample frequencies in his accompanying letter:&lt;/p&gt;
&lt;p&gt;You might want to check the tempos for all the songs in case some weird PAL-NTSC thing happens. I’m sure by now you know the deal! All of the samples are at 10.4 khz except the following:jl87.vmd 8.7honk.vmd 5.2xplode2.vmd 5.8camel2.vmd 8.7finger.vmd 7.3feet2.vmd 7.3feet3.vmd 8.7cash2.vmd 7.3feet5.vmd 8.7&lt;/p&gt;
&lt;p&gt;Tommy also calls out the timing difference between NTSC and PAL here, which is a special consideration when using GEMS, as timing is effectively baked into the final sequence data that the GEMS driver digests. Aladdin does indeed take special care to include separate PAL audio data.&lt;/p&gt;
&lt;p&gt;The tools and hardware that were used to feed the Cakewalk sequencer data to GEMS are unknown, but the raw blobs of linear PCM are in keeping with the way GEMS expects to directly digest sample data. Loading up the Cakewalk project files gives us a bit of a cleaner glimpse (than digging back up from the binary targeted at the GEMS driver) into the original tracks as well.&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/?attachment_id=956&quot; rel=&quot;attachment wp-att-956&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-956&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/cakewalk_s.jpg&quot; alt=&quot;&quot; width=&quot;80%&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;It might be interesting to dig in further to draw more comparisons between the MIDI sources and the GEMS data that was cooked into the retail game, but we’ll have to save that for another day.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;3.6. The Design Document&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;153.1638621564&quot;&gt;
&lt;p&gt;I was shocked when I saw this thing buried down in a zip file within a zip file. There’s a massive wealth of information, and more what-could-have-beens than you can shake an apple at in here. The design document is specified as version 3.3, and the file is dated April 27, 1993. It has contributions from many individuals, with the doc itself attributing David Bishop, Seth Mendelsohn, Mike Dietz, and Mark Yamada, with a sanity check by David Perry.&lt;/p&gt;
&lt;p&gt;There are a great many disparities between what went into this design doc, and what ended up in the game. I could write an entire article on that material alone, but I am going to highlight some of the more interesting disparities in this section.&lt;/p&gt;
&lt;p&gt;On the whole, this document gives us a lot of material with which to resurrect old ideas and features, especially those that already had some degree of art put in place. It also gives us more clues about small one-off bits of art that are never referenced in the game/code, like this one:&lt;/p&gt;
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/wp-content/uploads/2017/10/AL_SCOOP-1.gif&quot; rel=&quot;attachment wp-att-972&quot;&gt;&lt;img class=&quot;alignnone wp-image-1040 size-full&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/10/AL_SCOOP-1.gif&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;The original design intent was that bananas would be collected, and actually trigger Abu to appear at random points on the level. This animation appears to have been crafted so that Abu could be scooped up during a carpet ride (hinted at by the posture and the hair movement), but no traces of Abu-scooping otherwise remain. It’s also quite interesting to note that this animation exists inside the CES demo build’s ROM, even though it doesn’t appear to be used in gameplay!&lt;/p&gt;
&lt;p&gt;Whatever we end up doing with this source code and data, this design document will be an exceptionally valuable resource.&lt;/p&gt;
&lt;h4 class=&quot;nb2&quot;&gt;The Levels&lt;/h4&gt;
&lt;p&gt;We have a breakdown in the design doc of what was planned to be the original level layout:&lt;/p&gt;
&lt;div class=&quot;bg-black-10 pa3 f5 overflow-auto&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;ma0&quot;&gt;
Level                        Goal               Boss
------------------------------------------------------------
1.    Marketplace            Rescue Jasmine     Razoul
2.    Desert                 Find Scarab #1     None
3.    Marketplace rooftops   Find Scarab #2     Gazeem
4.    Prison                 Escape from prison None
5.    Cave of Wonders (gold) Reach lamp chamber Shiva monkey
6     Cave of Wonders (lamp) Get the lamp       None
7.    Fly out of cave        Escape from cave   None
8.    Inside the lamp        Find the Genie     None
9.    'Good' Palace          Capture Jafar      Iago
10.   Marketplace            Fight to palace    Razoul 2
11.   'Evil' Palace          Destroy Jafar      Jafar
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There were also plans for different levels and bosses for the Sega CD version of the game, which we’ll get to in the &lt;a class=&quot;link primary-color&quot; href=&quot;https://gamehistory.org/aladdin-source-code/#sect_37&quot;&gt;Sega CD section&lt;/a&gt;. The level structure survived mostly intact, with a few notable changes:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Both Gazeem and Razoul appear on the rooftops, with level 1 having no boss.&lt;/li&gt;
&lt;li&gt;The Cave of Wonders sequences seems to have been streamlined a bit, into an on-foot escape sequence leading into the carpet escape sequence.&lt;/li&gt;
&lt;li&gt;The marketplace fight toward the palace is gone, transitioning straight from the Sultan’s Palace to Jafar’s Palace. There was also a second encounter planned with Razoul for this stage.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;No traces of the missing marketplace level remain, so it’s possible that it was never started, likely either due to development timeline constraints or ROM space constraints.&lt;/p&gt;
&lt;h4 class=&quot;nb2&quot;&gt;Player Mechanics&lt;/h4&gt;
&lt;p&gt;There were quite a few changes to player mechanics, in between this design doc revision and the final game. Some of the more interesting highlights include:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Aladdin was not intended to be able to attack or throw objects while falling, and rather only when jumping, presumably during the upward arc. This certainly would have resulted in a very different game!&lt;/li&gt;
&lt;li&gt;The design doc specifically calls out that Aladdin’s sword slash will &lt;strong&gt;not&lt;/strong&gt; be used to block hand to hand and sword attacks from enemies, but this seems to generally be the opposite of behavior at retail, and is often a vital part of avoiding damage from guards.&lt;/li&gt;
&lt;li&gt;Holding different directions on the pad was originally intended to allow Aladdin to target thrown objects in the directions of up-left, up, and up-right.&lt;/li&gt;
&lt;li&gt;The delay to shift the view up/down when holding up/down on the pad was originally specified as 3 seconds each.&lt;/li&gt;
&lt;li&gt;Even in the non-CD version of the game, melons and rocks were intended to be throwable objects for some levels in addition to apples. Although not mentioned in the document, lemon projectiles were also in the game at some point. Speculatively, with rocks being intended to show up on levels like the desert, the idea of stoning people and animals to death may have been received poorly by Disney!
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/aladdin-source-code/ob_stone/&quot; rel=&quot;attachment wp-att-959&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-959&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/OB_STONE.gif&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;https://gamehistory.org/aladdin-source-code/ob_lemon/&quot; rel=&quot;attachment wp-att-967&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-967&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/09/OB_LEMON.gif&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;Aladdin was to be dropped into some levels by the Genie. I’ve located a pair of animations that look like they were meant for this sequence.
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/wp-content/uploads/2017/10/al_strt1mrg.gif&quot; rel=&quot;attachment wp-att-962&quot;&gt;&lt;img class=&quot;alignnone wp-image-1041 size-full&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/10/al_strt1mrg.gif&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;Additional idle animations were planned, even for the cartridge version of the game:
&lt;div class=&quot;b--purple bl bw2 pl3&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;em&gt;Thought bubble appears above Aladdin containing a graphic of the princess (only after he knows the girl in the market place was Jasmine) to re-enforce that he wants to see her again.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Thought bubble appears above Aladdin containing a graphic of the girl he rescued in the market place. (only after he rescues her but before he finds out she is the princess – this may change depending on how Razoul is re-introduced into the game at the expense of the Apple Merchant)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Carpet flies in and gestures to the player to get with the program. (only after cave level)&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;It was planned that when Aladdin’s health lowered to a certain point, on outdoor maps, several vultures would appear in the parallax layer and “circle in anticipation of failure”.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;On the whole, things seem to have worked out for the best in the retail game, although directional throwing and extra throwables, as well as the pure aesthetic additions, could have been fun!&lt;/p&gt;
&lt;h4 class=&quot;nb2&quot;&gt;Enemies&lt;/h4&gt;
&lt;p&gt;As indicated by the enemies that I &lt;a class=&quot;link primary-color&quot; href=&quot;https://gamehistory.org/aladdin-source-code/#sect_32&quot;&gt;found in the source art&lt;/a&gt;, there are quite a few differences between what was laid out in the design doc and what made it to retail. Rather than laying out a central list of enemies and specifying them by level, the document defines unique enemies within the scope of each level.&lt;/p&gt;
&lt;p&gt;The design effectively calls out completely different enemy characteristics and scenarios in a great many cases. Some of the highlights are:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The “short tubby round” guards were to intended to swing a stick as their attack, while the “tall thin lanky” guards were to throw knives. Attacks ended up being swapped between the two at retail.&lt;/li&gt;
&lt;li&gt;The larger guards, in addition to the taunts which survived to retail, were intended to mix up attacks between high and low. Aladdin was to be able to duck under or jump over these attacks.&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;Fat ladies were intended to make an appearance in the marketplace:
&lt;div class=&quot;b--purple bl bw2 pl3&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;em&gt;They run left/right being chased by a mouse, and will run over Aladdin if he doesn’t get out of the way (jump over). Fat ladies cannot be killed.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;The circumstances and pacing of the Razoul battle were originally quite different:
&lt;div class=&quot;b--purple bl bw2 pl3&quot; readability=&quot;47&quot;&gt;
&lt;p&gt;&lt;em&gt;Razoul will be standing on the roof of the prison building. The width of the building will take up about 1/2 of the screen, and Razoul will be seen behind a wall, so that only his upper torso will be visible, on either side of the roof will be a pile of barrels stacked in a pyramid.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Razoul will pace back and forth on top of the roof. Since the building will be in the center of the screen Aladdin will be able to climb up the sides by using a series of platforms on the sides of the building, and edges of the screen. The platforms will allow Aladdin to get below, and to the side of Razoul, or by jumping from the upper most platform, just above him. Aladdin will not be able to get on the roof.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;When Razoul gets to the edge of the roof, he will push a barrel off the edge. The barrel will roll downwards, from platform to platform, until it reaches the ground (like in Donkey Kong) and falls into a hole in the center. Razoul will push a barrel off every second or so. Razoul will continue to roll barrels until Aladdin runs to the opposite side of the roof, and then will run to the other side of the roof and start pushing barrels again.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Razoul can only be hit while he is running from side to side. When Aladdin is on the upper most platform, Razoul will throw knives at him. The knife throws will be between pushing off barrels, making sure Aladdin does not stay in one place for too long.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The barrels will damage Aladdin, and can not be destroyed expect for specially colored ones, which can be destroyed using a sword slash to revel bonus items (health, tries, etc..). In order for Aladdin to defeat Razoul, he will have to run from side to side, and up the platforms on both sides of the building. In the center of the ground will be a hole over which Aladdin will have jump or lose a try. Above the center of the ground will be a canopy that will prevent Aladdin from throwing any object directly up at Razoul.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;A “green with yellow hoops” variant of the snake was planned.&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;Periodic attacks from Iago’s cousins (differing from Iago in the color of their plumage) were planned:
&lt;div class=&quot;b--purple bl bw2 pl3&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;em&gt;Each of Iago’s cousins can carry one red vial in their claws. Red vials explode on impact with anything. They fly onto the screen, try to line themselves up above Aladdin and then drop their vial. They then fly off screen again (carry on in the direction they were heading when they dropped the vial).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The vials damage Aladdin if they land on him. Aladdin can also walk into the puff of smoke if a vial lands in front of him and he will still take damage, the puff of smoke will disappear after 0.5 seconds.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;Mirage enemies were planned for the desert level, which would shimmer in and out, taking the appearance of existing enemies. Mirages can both harm and be harmed by Aladdin.&lt;/li&gt;
&lt;li&gt;The Prisoner enemy that was unearthed from source art was originally intended to appear in robes with a black and white striped turban. He was also intended to be the size of Aladdin, rather than the very tall, lanky character we see now, and have an additional chain-swinging attack.&lt;/li&gt;
&lt;li&gt;Bats were originally outlined as having a special dive bomb attack.&lt;/li&gt;
&lt;li&gt;It was planned that one of Iago’s cousins would fly by and drop a vial on one of the skeletons in the Sultan’s Dungeon, as an initial encounter to help justify the fact that skeletons were coming back to life throughout the level.&lt;/li&gt;
&lt;li&gt;Golden Monkeys were originally planned for a different gold Cave of Wonders level, where the cave would be filled with golden coins, gems, and other treasures. The Golden Monkey was likely removed when it was decided to cut this level, with his behavior being appropriated over to the Shiva statue.&lt;/li&gt;
&lt;li&gt;Stone Monkeys were planned for the second Cave of Wonders level, which would have behavior identical to gold monkeys, but they would throw stones instead of coins/gold/jewels.&lt;/li&gt;
&lt;li readability=&quot;4.5&quot;&gt;The Shiva statue that appears in the Cave of Wonders with the Gold/Stone Monkey design was originally intended to appear in the palace, with the following design:
&lt;div class=&quot;b--purple bl bw2 pl3&quot; readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;em&gt;Action:&lt;/em&gt;&lt;br/&gt;&lt;em&gt;Will remain still as most statues do, until Iago flies by and drops a vial on it. It will then magically come to life and begin to attack Aladdin&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Attack:&lt;/em&gt;&lt;br/&gt;&lt;em&gt;She will use her many arms to pull jewels from her headdress and throw them at Aladdin. When jewels come into contact with the ground they will magically burst into flames and burn for 2-3 seconds. Each time she is hit by Aladdin she will lose one of her arms.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Appearance:&lt;/em&gt;&lt;br/&gt;&lt;em&gt;About the same size as Aladdin, but with 8 arms. Dressed in harem pants, a halter top, and a headdress with many jewels set in it. She will still have the color and texture of a marble statue even after she has come to life.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;Flamingos in the Sultan’s Palace originally had a slightly more hostile mechanic:
&lt;div class=&quot;b--purple bl bw2 pl3&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;em&gt;If the player stands too long on a flamingo, it will turn around and peck at him. One of the flamingos will be Iago in disguise, and will always move out of the way just as the player is about to land on him.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;The Iago boss battle originally had an emphasis on having to use Abu’s precious gems to attack Iago, with that being the only means of pushing Iago further toward the cogs.&lt;/li&gt;
&lt;li&gt;Jafar in human form was intended to occasionally throw down red vials, which would create a lasting cloud of damaging smoke.
&lt;div class=&quot;tc&quot;&gt;&lt;a href=&quot;https://gamehistory.org/wp-content/uploads/2017/10/JH_THROW-1.gif&quot; rel=&quot;attachment wp-att-989&quot;&gt;&lt;img class=&quot;alignnone wp-image-1042 size-full&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/10/JH_THROW-1.gif&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;Jafar in snake form was intended to have a tongue attack, and would smile when the attack succeeded, with quite a few other attack/behavioral variations.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;This doesn’t touch on everything, by any means, and there are still many other subtle differences between design and implementation throughout the game.&lt;/p&gt;
&lt;h4 class=&quot;nb2&quot;&gt;Rock, Paper, Scissors&lt;/h4&gt;
&lt;p&gt;Although no backing code or data appears to remain, we have an entire outline of a Rock, Paper, Scissors game. It’s worth repeating in whole here:&lt;/p&gt;
&lt;div class=&quot;b--purple bl bw2 pl3&quot; readability=&quot;77&quot;&gt;
&lt;p&gt;&lt;em&gt;Having entered this bonus screen, the player will see the carpet in the left center of the screen shaking its upper left tassel, Aladdin will be on the right center of the screen shaking his right hand. A Rock with the letter A below, a Paper with the letter B below, and a pair of Scissors with the letter C below will be displayed, centered along the top of the screen.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The rules are identical to the traditional game where each player picks Rock, Paper, or Scissors. Rock is represented by a fist, Paper by a flat hand, and Scissors by holding out the index and middle fingers in the shape of a V. The player will play Aladdin.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;While the carpet’s tassel and Aladdin’s hand are seen shaking back and forth (this will continue until the player makes a choice), the player must select one of the three buttons A, B, or C to chose which hand shape he wants to play. After selecting the desired shape, the carpet and Aladdin will both shake their tassel and fist two more times and then, on the third shake, display their choices. Whoever wins will celebrate, and the screen will display the winner.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;If Aladdin loses, then the game is over and he will be returned to the same spot he left on the map, and will be invincible for a few seconds (this sequences will also occur after the third play of the game regardless of who wins). If Aladdin wins, the screen will show in graphical (as seen if they were being picked up in the regular game) and/or text (if extra score) form, what he has won.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Then the player will be asked if they wish to play again for a chance to win more, or leave the game keeping the items they won. If the player plays again they may lose the game, and lose the item(s) previously won (i.e. if in the first game Aladdin wins a 1up, and wins 10 gems and another 2 1ups in the second game, then loses in the third game he will loose everything previously won: the 10 gems and the 2 1ups).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;A maximum of 3 games can be played during a single visit to this bonus game. Aladdin can only play the second game if he wins the first and can only play the third and final game if he wins both the first and second.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;In case of a tie the game will be played over until someone wins.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;u&gt;Rules&lt;/u&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;Rock beats Scissors&lt;/em&gt;&lt;br/&gt;&lt;em&gt;Paper beats Rock&lt;/em&gt;&lt;br/&gt;&lt;em&gt;Scissors beats Paper&lt;/em&gt;&lt;br/&gt;&lt;em&gt;If both positions are the same the game is a tie and is replayed.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;u&gt;Prizes&lt;/u&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;1st win: 1up&lt;/em&gt;&lt;br/&gt;&lt;em&gt;2nd win: 10 gems, and 2 1ups&lt;/em&gt;&lt;br/&gt;&lt;em&gt;3rd win: 1 Genie smart bomb, 15 gems, 3 1ups&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: we may alter what Aladdin wins according to the difficulty setting in which the game is being played (better winnings for the easier settings). This will be decided during tuning.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: prizes are cumulative, if Aladdin wins all 3 games, he will receive 6 1ups, 25 gems, and 1 Genie smart bomb&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;This seems to have been a very early idea, as we can see where some elements of the description no longer mesh with other design and item mechanics.&lt;/p&gt;
&lt;h4 class=&quot;nb2&quot;&gt;ROM Breakdown&lt;/h4&gt;
&lt;p&gt;Although it doesn’t necessarily end up having a full basis in reality, an attempt was made in the design doc to break down the memory requirements of all of the characters, levels, and features ahead of time. This provides a pretty cool retrospective on how closely designers and artists used to have to pay attention to and respect the technical constraints of their target medium.&lt;/p&gt;
&lt;div class=&quot;b--purple bl bw2 pl3&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;2048K&lt;/strong&gt; – Total Memory Available on Cartridge&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;u&gt;Proposed memory usage&lt;br/&gt;&lt;/u&gt;&lt;strong&gt;480K&lt;/strong&gt; – 8 Levels @ 60K per level (this covers tileset, triggers, contours…everything…)&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;132K&lt;/strong&gt; – 3 Levels with out tile sets @ 44K per level&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;175K&lt;/strong&gt; – Music and sound effects&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;64K&lt;/strong&gt; – Program,&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;64K&lt;/strong&gt; – Sprite tables&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;64K&lt;/strong&gt; – Control tables&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;120K&lt;/strong&gt; – Intro / interlude / outro / finale sequences (each interlude pic = 4K)&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;30K&lt;/strong&gt; – Sega, Disney, Aladdin and Virgin logos&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;491K&lt;/strong&gt; – Aladdin and all non level specific characters&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;369K&lt;/strong&gt; – Level specific sprites&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;241K&lt;/strong&gt; – Bosses&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;80K&lt;/strong&gt; – All bonus games&lt;/em&gt;&lt;br/&gt;&lt;em&gt;___________&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;2274K&lt;/strong&gt; Needed&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;2048K&lt;/strong&gt; -___________&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;226K&lt;/strong&gt; Over… Hmmmmm.&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;u&gt;&lt;strong&gt;&lt;br/&gt;60K&lt;/strong&gt; Per Level breakdown:&lt;br/&gt;&lt;/u&gt;&lt;strong&gt;11500&lt;/strong&gt; Bytes – Background Character Data (Compressed)&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;32768&lt;/strong&gt; Bytes – Background Block references and combinations&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;1200&lt;/strong&gt; Bytes – Floor and sprite trigger information (Compressed)&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;400&lt;/strong&gt; Bytes – Contour information&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;10699&lt;/strong&gt; Bytes – Map data (Compressed)&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;2171&lt;/strong&gt; Bytes – Parallax map data (Compressed)&lt;/em&gt;&lt;br/&gt;&lt;em&gt;___________&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;58738&lt;/strong&gt; Bytes Per Level roughly.[This figure will reduce if graphic style is more simplistic or if level sizes are smaller than the maximum size available]&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;This kind of careful coordination and planning is really a healthy exercise for many reasons, and it’s a far cry from the kind of disconnect we often seem to have between art, design, and programming in game development these days. I wish I could say I never had to yell at an artist for things like putting a giant 4096×4096 texture that is a single solid color into the game, or designers when they just assume everything will get fixed for them at some point when they find themselves creating 3 minute load times. I’ve used “your blank texture is larger than an entire game was 20 years ago” as my words of shame before.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;3.7. Sega CD&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;A Sega CD version of the game seems to have been planned from the very beginning. Unfortunately, although the design document has many Sega CD callouts, they generally don’t seem to have survived to the source art in our Aladdin archive here. These are all of the CD-specific features and elements that I managed to parse from the design doc:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Aladdin in Prince Ali form was planned to appear in numerous additional Sega CD levels. The design doc calls out that Aladdin would only appear as Prince Ali in one level of the cartridge version, and is intentionally omitted to save ROM space.&lt;/li&gt;
&lt;li&gt;Jafar was planned to have a third Genie boss form in the CD version of the game. No traces of art for this stage exist in our archive.&lt;/li&gt;
&lt;li&gt;Had the Abu magic bag feature survived to retail, two additional Abu reactions to Aladdin’s use of Abu’s precious gems were planned for the CD version.&lt;/li&gt;
&lt;li&gt;An Apple Merchant boss was planned to be the marketplace boss in place of Razoul in the CD version, and Razoul would move over to become the boss of the prison stage instead.&lt;/li&gt;
&lt;li&gt;The desert was planned to have a Sand Scorpion boss in the CD version. No additional design information is provided on this boss.&lt;/li&gt;
&lt;li&gt;In the second marketplace stage leading up to the Jafar’s Palace (which didn’t make it to retail), a Fire Eater boss was planned for the CD version instead of a second Razoul encounter.&lt;/li&gt;
&lt;li&gt;An additional snowball throwable item was planned for the CD version.&lt;/li&gt;
&lt;li&gt;Even more idle animations were planned specifically for the CD version:
&lt;ul&gt;&lt;li&gt;&lt;em&gt;Genie floats into view and says one of a number of things. (only after cave level…CD version only)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Carpet flies in and taps Aladdin on the shoulder and flies off again. (only after cave level…CD version only)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A man would sometimes appear laying on a bed of nails obstacle in the CD version, allowing Aladdin to jump off of him once without being harmed. After being jumped on once, gets up “in disgust” and can no longer be used as a stepping stone.&lt;/li&gt;
&lt;li readability=&quot;6.5&quot;&gt;Quick sand was planned for the desert level in the CD version:
&lt;div class=&quot;b--purple bl bw2 pl3&quot; readability=&quot;24&quot;&gt;
&lt;p&gt;&lt;em&gt;As Aladdin walks over certain sections of sand, he will start to sink. Jumping continually will extract Aladdin from the sand and will allow him to traverse these areas without sinking. If the player leaves it too long, Aladdin will sink beneath the sand and loose a try (or end the game if he was on his final try). Quick sand will look slightly different from regular sand so the observant player will be able to anticipate this hazard.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;One particular patch of quick sand leads down into a secret area. To get there, Aladdin must overcome his natural inclination to save himself from sinking into the desert and stay where he is. If Aladdin drops beneath the surface of this particular patch of quicksand, the Scarabs will slide in and out to reveal him in a new area of the desert, probably cavelike (if we have the tiles available), where Aladdin will find an extra life and a continue and various other goodies.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The visual and gameplay mechanics we will use to get Aladdin back up onto the desert surface need to be specified but will use another Scarab wipe to maintain consistency.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;Cacti were also potentially planned for the CD version:
&lt;div class=&quot;b--purple bl bw2 pl3&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;em&gt;These come in various shapes and sizes (probably two species). We will remove them from the game if we cannot make them feel like they ‘belong’ in Aladdin’s world. Contact with a cactus will damage Aladdin (1 point of damage per contact).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;One type of cactus can be destroyed if an object is thrown at it or if hit be a sword slash. The other, more substantial looking, genus of cactus isn’t going anywhere and can only be avoided, not ‘removed’.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Both types of cactus will be designed graphically so that many different looking cactus tree can be created without a huge graphical and therefore memory overhead.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;Swinging clotheslines (in addition to the rather static ropes that can be climbed across) were planned for the CD version of the marketplace.&lt;/li&gt;
&lt;li&gt;The carpet would have a special animation with flaming tassels after a close call with a fire jet.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CD-based plans also occasionally tie into elements/features that were planned (but didn’t survive) for the cartridge version of the game.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;3.8. The Code&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;68.416361416361&quot;&gt;
&lt;p&gt;There’s a lot to talk about regarding the actual source code. One of the more interesting aspects of the game code itself is that it’s all driven by what is effectively an incredibly lightweight state machine. Things like animation sequences are defined in assembly as seen in this tiny snippet:&lt;/p&gt;
&lt;div class=&quot;bg-black-10 pa3 f5 overflow-auto&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;ma0&quot;&gt;
; Slither along
AN_ROLLY_SNAKE:
        dc.w SN_SLTHR_FRAME1
        mface_man

R_S:    dc.w SN_SLTHR_FRAME1
        dc.w SN_SLTHR_FRAME1
        dc.w SN_SLTHR_FRAME1

        mif_within_X 85,AN_ROLLY_SNAKE_BITE

        dc.w SN_SLTHR_FRAME2
        dc.w SN_SLTHR_FRAME2
        dc.w SN_SLTHR_FRAME2

        dc.w SN_SLTHR_FRAME3
        dc.w SN_SLTHR_FRAME3
        dc.w SN_SLTHR_FRAME3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is emitting bytes/words for each “command”. Each animation frame is specified by emitting a word, and that word is a pointer into a list of frame pointers near-ish the beginning of ROM. We then have a variety of macros for things like the mif_within_X conditional logic that you see there, which emits an appropriate command byte, with the command bytes conveniently falling outside the value range of the known frame pointer values. The result of that command may then be that the state data pointer is set to something else for the next execution cycle.&lt;/p&gt;
&lt;p&gt;Aliens (objects/actors) are driven, for the most part, by having code churn through state data like this. Movement is also handled in a similar fashion, where movement logic is defined by emitting bytes, and each alien is allowed to provide a pointer to its movement state data. It’s also fairly common for animation state data to swap out the pointer to movement state data, so there’s a specific macro used to emit the appropriate bytes to do this.&lt;/p&gt;
&lt;p&gt;There’s a sizable amount of code dedicated to running through these tiny state blocks, and managing the actual calculations for things like physics/collisions and even basic movement hierarchy. The player is, of course, his own special case. He makes use of state data just like standard aliens, but he has his own boilerplate assembly logic to handle a great deal of the more complicated state logic, which also takes care to often set the state pointers directly.&lt;/p&gt;
&lt;p&gt;Doing things this way simplifies the work involved in adding new objects, and it helps keep memory costs down by minimizing the amount of new code needed for each object and by packing logic into reasonably efficient state commands. Combined with the fact that the actual state logic is kept very simple and there are special-case macros for all of the reasonably complex logic cases, this is a great system for a game of Aladdin’s scope.&lt;/p&gt;
&lt;p&gt;Beyond that, we have a lot of boilerplate code to handle system-level things like DMA transfers to VRAM, with a routine named “DMA_IT” being the heart of where all of those Chopper tiles we looked at earlier end up getting &lt;a href=&quot;https://segaretro.org/Blast_processing&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;blasted&lt;/a&gt; into VRAM. Chopper has been designed to minimize the cost of this pretty effectively, avoiding CPU decompression costs while still trying to cut down on the number of unique tiles per frame of animation. I haven’t actually profiled Aladdin to see how many cycles are typically spent where, but based on the end result, I’d say it’s doing its job well enough.&lt;/p&gt;
&lt;p&gt;We could deep-dive into countless systems here, but without going into too much detail, these are the more notable high-level goings-on in the Aladdin codebase.&lt;/p&gt;
&lt;p&gt;With all of that said, here are some other random points of interest that I took note of as I was exploring:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;There’s a MAKEDEMO assembly-time variable that can be set to on, to record demos. When recording, the game actually writes controller commands at each frame into VRAM. You can see the background tiles gradually corrupting as the demo records, which is fun. Once the designated VRAM buffer is full, the game copies the data back out of VRAM over to main RAM, then spins in place (because it’s just demolished main memory) forever so that you can attach a debugger and dump the demo data from a known address. I created a custom demo this way, just for fun.&lt;/li&gt;
&lt;li&gt;More demo fun facts: The demo data itself is just a raw stream of controller inputs for each frame, and both demo recording and playback force a random seed of “12345678” to ensure deterministic results.&lt;/li&gt;
&lt;li&gt;There’s also a MASTER assembly-time variable, which looks like it was actually set to OFF for the retail distribution. When set to ON, it disables parts of the cheat screen that survived at retail, but the code does not assemble without modifications when it’s enabled. One might therefore speculate that the cheat screen (still containing phone and fax numbers) wasn’t actually intended to be left on for the retail distribution.&lt;/li&gt;
&lt;li&gt;Cheat codes are listed out among a lot of other static data in a file called TABLES.68K, and are read one byte at a time with the cheat code logic incrementing a pointer to the appropriate cheat code table and resetting it back to the beginning when the wrong input is pressed. There are no additional (beyond what’s already known/documented) hidden/disabled-at-retail cheat codes residing in the source.&lt;/li&gt;
&lt;li&gt;When recording video for this article, I wanted to disable the high-frequency flicker that occurs when Aladdin gets hurt, to avoid having him disappear entirely for multiple frames when downsampling video to lower framerates. Locating the bit of code in question, I discovered an “IF TO_DEMO=OFF” assembler check around it. Apparently I wasn’t the first person to encounter this problem when recording promo footage! TO_DEMO appears to have been left off for the CES demo build, or this particular bit came as a later addition, based on the fact that the flicker still occurs in that build. (when invincibility is not enabled)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;I don’t know about you, but this stuff sure makes me miss the golden days of game development.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;pt3&quot;&gt;4.0. What’s Next?&lt;/h3&gt;
&lt;div class=&quot;pl4&quot; readability=&quot;24&quot;&gt;
&lt;p&gt;Every game has a story, and sometimes binary speaks louder than words. But source code usually speaks even louder! We’ve already lost a lot of fascinating video game history to cancelled prototypes, discarded demos, and hardware failures. Unless we start considering preservation and archival more seriously in the video game industry, especially when it comes to hardware-based DRM technologies, we stand to lose even more than we’ve already lost.&lt;/p&gt;
&lt;p&gt;I started this project with a mind toward wrapping up the Aladdin archive in question for proper preservation, taking the first steps toward standardizing source curating and archival at the VGHF. That meant documenting the source code from a high level, in order to establish its intended target(s) and any external dependencies on other tools and/or data so that we could also start tracking those dependencies in a standardized way. In doing this, it became quickly apparent that Aladdin had quite a story to tell. I expect it’s the first story of many, and I can’t wait to see what pops up next!&lt;/p&gt;
&lt;p&gt;Until next time…&lt;br/&gt;&lt;a href=&quot;https://gamehistory.org/wp-content/uploads/2017/10/GN_CHEER.gif&quot; rel=&quot;attachment wp-att-965&quot;&gt;&lt;img class=&quot;alignnone wp-image-1043 size-full&quot; src=&quot;https://gamehistory.org/wp-content/uploads/2017/10/GN_CHEER.gif&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 12 Oct 2017 14:30:58 +0000</pubDate>
<dc:creator>j_s</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://gamehistory.org/aladdin-source-code/</dc:identifier>
</item>
<item>
<title>Hyperloop One Becomes ‘Virgin Hyperloop One’</title>
<link>https://techcrunch.com/2017/10/12/hyperloop-one-becomes-virgin-hyperloop-one-with-virgin-group-investment/</link>
<guid isPermaLink="true" >https://techcrunch.com/2017/10/12/hyperloop-one-becomes-virgin-hyperloop-one-with-virgin-group-investment/</guid>
<description>&lt;img src=&quot;https://tctechcrunch2011.files.wordpress.com/2017/10/img_1105_cropped_0.jpg?w=738&quot; class=&quot;&quot;/&gt;&lt;p id=&quot;speakable-summary&quot;&gt;Hyperloop One has received a &lt;a target=&quot;_blank&quot; href=&quot;https://www.virgin.com/richard-branson/introducing-virgin-hyperloop-one-worlds-most-revolutionary-train-service&quot; rel=&quot;noopener&quot;&gt;significant investment in Hyperloop One&lt;/a&gt; — the official figure hasn’t been revealed, but it’s enough that the Hyperloop tech startup, which aims to create networks of high-speed transportation tunnels to various locales across the globe, has changed its name. Virgin Hyperloop One is the entity’s official moniker going forward, which is quite a mouthful.&lt;/p&gt;&lt;p&gt;Virgin Hyperloop One’s rebrand will mean it gains from association with Virgin Group founder Richard Branson, whose high-tech transportation exploits include Virgin Galactic and other space-based ventures. The goal of the company under the rebrand remains the same, and it’ll continue to explore the best places and partners for deploying its high-speed transportation tech, which will zoom pods at high speed down extremely low-pressure tubes to reduce trip times over land from hours to minutes.&lt;/p&gt;
&lt;p&gt;The money isn’t the only connection between Hyperloop One and Virgin; the Hyperloop company’s president of engineering, Josh Giegel, is a former Virgin employee. Branson noted in a blog post that he also visited Hyperloop One earlier this summer to view its technology first-hand, at the Hyperloop One DevLoop test track site in Nevada, outside Las Vegas.&lt;/p&gt;

&lt;p&gt;Recently, Hyperloop One (sorry, Virgin Hyperloop One — that’s going to take some getting used to) announced that it had selected a range of finalists for its global competition to identify potential routes, and it has announced a few public-private partnerships to undertake feasibility studies.&lt;/p&gt;
&lt;p&gt;Right now it appears that Hyperloop One’s business will remain on track with the rebrand, and it’s probably a good thing to have a close billionaire friend with a passion for future modes of transport when you’re trying to build a brand new type of high-speed ground transit.&lt;/p&gt;
</description>
<pubDate>Thu, 12 Oct 2017 13:29:02 +0000</pubDate>
<dc:creator>mpweiher</dc:creator>
<og:title>Hyperloop One becomes ‘Virgin Hyperloop One’ with Virgin Group investment</og:title>
<og:description>Hyperloop One has received a significant investment -- the official figure hasn't been revealed, but it's enough that the Hyperloop tech startup, which aims..</og:description>
<og:image>https://tctechcrunch2011.files.wordpress.com/2017/10/img_1105_cropped_0.jpg</og:image>
<og:url>http://social.techcrunch.com/2017/10/12/hyperloop-one-becomes-virgin-hyperloop-one-with-virgin-group-investment/</og:url>
<og:type>article</og:type>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://techcrunch.com/2017/10/12/hyperloop-one-becomes-virgin-hyperloop-one-with-virgin-group-investment/</dc:identifier>
</item>
</channel>
</rss>