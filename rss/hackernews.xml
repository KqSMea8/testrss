<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=hnrss.org%2Fnewest%3Fpoints%3D200&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://hnrss.org/newest?points=200" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dhnrss.org%252Fnewest%253Fpoints%253D200%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dhnrss.org%252Fnewest%253Fpoints%253D200%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>Hacker News: Newest</title>
<link>https://news.ycombinator.com/newest</link>
<description>Hacker News RSS</description>
<item>
<title>Next generation video: Introducing AV1</title>
<link>https://people.xiph.org/~xiphmont/demo/av1/demo1.shtml</link>
<guid isPermaLink="true" >https://people.xiph.org/~xiphmont/demo/av1/demo1.shtml</guid>
<description>&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;link rel=&quot;icon&quot; href=&quot;http://www.xiph.org/images/logos/xiph.ico&quot; type=&quot;image/x-icon&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; title=&quot;default demosheet&quot; media=&quot;screen&quot; href=&quot;demo.css&quot; type=&quot;text/css&quot; /&gt;&lt;title&gt;next generation video: Introducing AV1&lt;/title&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot; readability=&quot;366.69570442342&quot;&gt;
&lt;div id=&quot;xiphlogo&quot;&gt;&lt;a href=&quot;https://www.xiph.org/&quot;&gt;&lt;img src=&quot;https://www.xiph.org/images/logos/fish_xiph_org.png&quot; alt=&quot;Fish Logo and Xiph.org&quot; /&gt;&lt;/a&gt;


&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://people.xiph.org/~xiphmont/demo/av1/whiteboard-smaller.jpg&quot; /&gt;&lt;div readability=&quot;9&quot;&gt;
&lt;div readability=&quot;13&quot;&gt;&lt;img src=&quot;https://people.xiph.org/~xiphmont/demo/av1/av1-logo.png&quot; alt=&quot;AV1&quot; /&gt;&lt;p&gt;AV1 is a new general-purpose video codec developed by the Alliance for Open Media. The alliance began development of this new codec using Google's VPX codecs, Cisco's Thor codec, and Mozilla's/Xiph.Org's Daala codec as starting point. AV1 leapfrogs the performance of VP9 and HEVC, making it a next-next-generation codec. The AV1 format is and will always be royalty-free with a permissive FOSS license.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Those of you who &lt;a href=&quot;https://people.xiph.org/~xiphmont/demo/daala/demo1.shtml&quot;&gt;followed Daala development&lt;/a&gt; know that when the &lt;a href=&quot;https://aomedia.org/&quot;&gt;Alliance for Open Media&lt;/a&gt; formed, Xiph and Mozilla submitted our Daala codec as one of the inputs toward standardization. Along with Daala, Google submitted its VP9 codec, and Cisco submitted Thor. The idea was to build a new codec out of pieces of all three, along with any other useful research we found. I hadn't written any new demo pages about new tech in Daala or AV1 since then; for a long time we had little idea of what the final codec was going to look like.&lt;/p&gt;
&lt;p&gt;About two years ago, AOM voted to base the fundamental structure of the new codec on VP9, rather than Daala or Thor. AOM member companies wanted the shortest path to shipping a useful codec without royalty or licensing strings, and VP9 was decided to be the lowest-technical-risk choice. I agree with that choice; Daala was a contender, but I also think both the lapping approach and frequency-domain techniques required by Daala weren't (and still aren't) mature enough for deployment. There were still technical unknowns in Daala, and choosing VP9 as a starting point avoided most of them.&lt;/p&gt;
&lt;p&gt;As a result of starting with VP9, AV1 (the AOM Video Codec 1) is a mostly familiar codec built along traditional block-based transform coding lines. Of course, it also includes new exciting things, several of which are taken from Daala! Now that we're rapidly approaching the final spec freeze, it's time to write more of the long-delayed codec technology demos in the context of AV1.&lt;/p&gt;
&lt;h2&gt;An Updated look at Chroma from Luma Prediction (CfL)&lt;/h2&gt;
&lt;p&gt;Chroma from Luma prediction (CfL for short) is one of the new prediction techniques adopted by AV1. As the name implies, it predicts the colors in an image (chroma) based on brightness values (luma). Luma values are coded and decoded first, and then CfL makes an educated prediction of the colors. When the guess is good, this reduces the amount of color information to be coded, saving space.&lt;/p&gt;
&lt;p&gt;CfL is not actually &lt;em&gt;brand new&lt;/em&gt; in AV1. &lt;a href=&quot;http://dx.doi.org/10.1109/ICIP.2009.5413727&quot;&gt;The seminal CfL paper&lt;/a&gt; dates from 2009, and LG and Samsung jointly propsed an &lt;a href=&quot;https://people.xiph.org/~xiphmont/demo/av1/phenix.int-evry.fr/jct/doc_end_user/documents/5_Geneva/wg11/JCTVC-E266-v4.zip&quot;&gt;early implementation of CfL named LM Mode&lt;/a&gt; that was rejected during the design of HEVC. You'll remember I wrote about &lt;a href=&quot;https://people.xiph.org/~xiphmont/demo/daala/demo4.shtml&quot;&gt;the particularly advanced version of CfL used in the the Daala codec&lt;/a&gt;. Cisco's Thor codec also had a CfL technique similar to LM Mode, and HEVC eventually added an improved version called Cross-Channel Prediction (CCP) via the HEVC Range Extension.&lt;/p&gt;
&lt;table class=&quot;caption&quot;&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;
&lt;th&gt;LM Mode&lt;/th&gt;
&lt;th&gt;Thor CfL&lt;/th&gt;
&lt;th&gt;Daala CfL&lt;/th&gt;
&lt;th&gt;HEVC CCP&lt;/th&gt;
&lt;th&gt;AV1 CfL&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Prediction Domain&lt;/th&gt;
&lt;td&gt;spatial&lt;/td&gt;
&lt;td&gt;spatial&lt;/td&gt;
&lt;td&gt;frequency&lt;/td&gt;
&lt;td&gt;spatial&lt;/td&gt;
&lt;td class=&quot;highlight&quot;&gt;spatial&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Coding&lt;/th&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;sign bit&lt;/td&gt;
&lt;td&gt;index + signs&lt;/td&gt;
&lt;td class=&quot;highlight&quot;&gt;joint sign + index&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Activation Mechanism&lt;/th&gt;
&lt;td&gt;LM_MODE&lt;/td&gt;
&lt;td&gt;threshold&lt;/td&gt;
&lt;td&gt;signal&lt;/td&gt;
&lt;td&gt;binary flag&lt;/td&gt;
&lt;td class=&quot;highlight&quot;&gt;CFL_PRED&lt;br /&gt;(uv-only mode)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Requires PVQ&lt;/th&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td class=&quot;highlight&quot;&gt;no&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Decoder modeling?&lt;/th&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td class=&quot;highlight&quot;&gt;no&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;div class=&quot;caption&quot; readability=&quot;26&quot;&gt;
&lt;p&gt;Above: A summary of the characteristics of various Chroma from Luma (CfL)implementations.&lt;/p&gt;
&lt;p&gt;LG's LM Mode and Thor were similar in that the encoder and decoder both run an identical prediction model in parallel, and do not need to code any parameters. Unfortunately, this parallel/implicit model reduces fit accuracy and increases decoder complexity.&lt;/p&gt;
&lt;p&gt;Unlike the others, Daala's CfL worked in the frequency domain. It signaled only an activation and sign bit, with the other parameter information already implicitly encoded via PVQ.&lt;/p&gt;
&lt;p&gt;The final AV1 CfL implementation builds on the Daala implementation, borrowing model ideas from Thor and improving on both through additional new research. It avoids any complexity increase in the decoder, implements a model search that also reduces encoder complexity over its predecessors, and notably improves the encoded model fit and accuracy.&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;The need for better intra prediction&lt;/h3&gt;
&lt;p&gt;At a fundamental level, compression is the art of prediction. Until the last generation or so, video compression focused primarily on &lt;strong&gt;inter-frame&lt;/strong&gt; (or just &lt;strong&gt;inter&lt;/strong&gt;) prediction, that is, coding a frame as a set of changes from other frames. Frames that use inter-frame prediction are themselves collectively referred to as &lt;strong&gt;inter frames&lt;/strong&gt;. Inter-frame prediction has become fantastically powerful over the past few decades.&lt;/p&gt;
&lt;p&gt;Despite the power of inter-prediction, we still need occasional standalone &lt;strong&gt;keyframes&lt;/strong&gt;. Keyframes, by definition, do not rely on information from any other frames; as a result, they can only use &lt;strong&gt;intra-frame&lt;/strong&gt; (or just &lt;strong&gt;intra&lt;/strong&gt;) prediction that works entirely &lt;em&gt;within&lt;/em&gt; a frame. Because keyframes can only use intra-prediction, they are also often referred to as &lt;strong&gt;intra frames&lt;/strong&gt;. Intra/Keyframes make it possible to seek in a video, otherwise we'd always have to start playing at and only at the very beginning&lt;a href=&quot;https://people.xiph.org/~xiphmont/demo/av1/demo1.shtml#rolling-intra&quot;&gt;*&lt;/a&gt;. &lt;img class=&quot;caption&quot; src=&quot;https://people.xiph.org/~xiphmont/demo/av1/framebits.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Above: Bit usage histogram of the first sixty frames of a test video, beginning with a keyframe. In this clip, the keyframe is 20-30 times the size of the subsequent inter frames. In a low-motion or mostly static video, a keyframe can be hundreds of times as large as an inter frame.&lt;/p&gt;
&lt;p&gt;Compared to inter frames, keyframes are enormously large, so they tend to be used as seldom as possible and spaced widely apart. Despite this, as inter frames have gotten smaller and smaller, keyframes have taken up an increasingly large proportion of a bitstream. As a result, video codec research has looked for newer, more-powerful forms of intra-prediction to shrink keyframe size. And, despite their name, inter frames can also use intra-prediction techniques in those cases where it's beneficial.&lt;/p&gt;
&lt;p&gt;Improved intra-prediction is a double win!&lt;/p&gt;
&lt;p&gt;Chroma from Luma works entirely from luma blocks within a frame, and thus is an intra-prediction technique.&lt;/p&gt;
&lt;h3&gt;Energy is Power&lt;a href=&quot;https://people.xiph.org/~xiphmont/demo/av1/demo1.shtml#xtime&quot;&gt;†&lt;/a&gt;&lt;br /&gt;Correlated Energy is Information&lt;/h3&gt;
&lt;p&gt;What makes us think we can predict color based on brightness?&lt;/p&gt;
&lt;p&gt;Most video representations reduce channel correlation by using a YUV-like color space. Y is the luma channel, the grayscale version of the video signal made by adding together weighted versions of the original red, green and blue signals. The chroma channels, U and V, subtract the luma signal from blue, and the luma signal from red respectively. YUV is simple and substantially reduces coding redundancy across channels.&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;caption&quot; src=&quot;https://people.xiph.org/~xiphmont/demo/av1/persimmon-yuv.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Above: decomposition of an image (far left) into a YUV, or more correctly, bt.601 Y'CbCr colorspace. The middle left image displays the luma channel and the two right images show the chroma channels. There is less cross channel redundancy in YUV than in an RGB image, but features from the original image are still plainly visible in all three channels of the YUV decomposition; all three channels still have edges in the same places.&lt;/p&gt;
&lt;p&gt;And yet, it's obvious looking at YUV decompositions of frames that edges in the luma and chroma planes still happen in the same places. There's remaining correlation that we can exploit to reduce bitrate; let's try to reuse some more of that luma data to predict color.&lt;/p&gt;
&lt;h3&gt;Getting Out The Crayons&lt;/h3&gt;
&lt;p&gt;Chroma from Luma prediction is, at its heart, the process of colorizing a monochrome image based on educated guessing. It's not unlike taking an old black-and-white photo, some colored pencils, and getting to work coloring in the photo. Of course, CfL's color predictions must be accurate to be useful; they can't be &lt;em&gt;wild&lt;/em&gt; guesses.&lt;/p&gt;
&lt;p&gt;This work is made easier by the fact that modern video codecs break an image down into a hierarchy of smaller units, doing most of the encoding work on these units independently.&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;caption&quot; src=&quot;https://people.xiph.org/~xiphmont/demo/av1/demo1-split.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Above: The AV1 encoder splits this frame into individual prediction units to maximize encoding fidelity, but just as importantly, to break the frame into smaller chunks that are easier to analyze and allow the codec to adjust prediction as it proceeds through the image.&lt;/p&gt;
&lt;p&gt;A model that predicts color across the entire image at once would be unwieldy, complex, and error-prone, but we don't need to predict the entire image. Because the encoder is working with small chunks at a time, we only need to look at correlations over small areas, and over these small areas, we can predict color from brightness with a high degree of accuracy using a fairly simple model. Consider the small portion of the image below, highlighted in red:&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;caption&quot; src=&quot;https://people.xiph.org/~xiphmont/demo/av1/snowbird.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Above: A single block highlighted from a single frame of video, illustrating that localizing chroma prediction into small blocks can be an effective means of simplifying prediction needs.&lt;/p&gt;
&lt;p&gt;Over this small range for this example, the correct 'rule' for coloring the image is simple: Brighter areas are green, and color desaturates along with brightness down to black. Most blocks will have similarly simple coloration rules. We can get as fancy as we like, but simple also works very well, so let's start with simple and fit the data to a simple αx+β line:&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;caption&quot; src=&quot;https://people.xiph.org/~xiphmont/demo/av1/snowbird2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Above: Cb and Cr (U and V) values plotted versus luma (Y) for pixels in the highlighted block from the previous picture. A quantized and encoded straight-line model fit is superimposed over the scatterplot as a line. Note that a fit consists of two lines; in this example, the lines are superimposed.&lt;/p&gt;
&lt;p&gt;Well, OK, it's two lines-- one for the U channel (Blue difference, Cb) and one for the V channel (Red difference, Cr). In other words, where &lt;tt&gt;L&lt;span class=&quot;super&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;sub&quot;&gt;ij&lt;/span&gt;&lt;/tt&gt; &lt;span class=&quot;sub&quot;&gt;are the reconstructed luma values, we compute the chroma values as follows:&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;U&lt;span class=&quot;sub&quot;&gt;ij&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt&gt; = &lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;α&lt;span class=&quot;sub&quot;&gt;U&lt;/span&gt;L&lt;span class=&quot;super&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;sub&quot;&gt;ij&lt;/span&gt; + &lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;β&lt;span class=&quot;sub&quot;&gt;U&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt&gt;V&lt;span class=&quot;sub&quot;&gt;ij&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt&gt; = &lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;α&lt;span class=&quot;sub&quot;&gt;V&lt;/span&gt;L&lt;span class=&quot;super&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;sub&quot;&gt;ij&lt;/span&gt; + &lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt&gt;β&lt;span class=&quot;sub&quot;&gt;V&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;What do these parameters look like? The &lt;em&gt;α&lt;/em&gt;s select a specific hue (and anti-hue) from a 2D plane of choices that will be scaled/applied according to the luma:&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;caption&quot; src=&quot;https://people.xiph.org/~xiphmont/demo/av1/alphacbcr.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Above: CfL's &lt;em&gt;α&lt;/em&gt; parameters select a hue for block colorization from a 2D color plane.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;β&lt;/em&gt;s alter the zero-crossing point of the color scale, that is, they're the knobs that shift the minimum and maximum levels of colorization applied. Note that &lt;em&gt;β&lt;/em&gt; allows us to apply &lt;em&gt;negative&lt;/em&gt; color as well; that gives us the opposite of the hue selected by &lt;em&gt;α&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Our task now boils down to choosing the correct &lt;em&gt;α&lt;/em&gt;s and &lt;em&gt;β&lt;/em&gt;s, and then encoding them. Here's one straightforward implicit approach from &lt;a href=&quot;https://arxiv.org/abs/1711.03951&quot;&gt;Predicting Chroma from Luma in AV1&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;caption&quot; src=&quot;https://people.xiph.org/~xiphmont/demo/av1/alphabeta.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;That looks scarier that it is. In English: Perform a least squares fit of the chroma values versus the reconstructed luma values to find &lt;em&gt;α&lt;/em&gt;, then use &lt;em&gt;α&lt;/em&gt; to solve for the chroma offset &lt;em&gt;β&lt;/em&gt;. At least, this is one possible way to handle the fit, and it's often used in CfL implementations (such as LM Mode and Thor) that do not signal either &lt;em&gt;α&lt;/em&gt; or &lt;em&gt;β&lt;/em&gt;. In this case, the fit is made using already decoded chroma values of neighboring pixels that have already been fully decoded.&lt;/p&gt;
&lt;h3&gt;Chroma from Luma in Daala&lt;/h3&gt;
&lt;p&gt;Daala performs all prediction in the frequency domain, CfL included, providing a prediction vector as one of the inputs to &lt;a href=&quot;https://people.xiph.org/~jm/daala/pvq_demo/&quot;&gt;PVQ encoding&lt;/a&gt;. PVQ is a gain/shape encoding; the luma PVQ vector encodes the location of the shapes and edges in luma, and we simply re-use it as a predictor of the shapes and edges in chroma.&lt;/p&gt;
&lt;p&gt;Daala does not need to encode an &lt;em&gt;α&lt;/em&gt; value, as that's subsumed into the PVQ gain (except for the sign). Nor does Daala need to encode a &lt;em&gt;β&lt;/em&gt; value; because Daala applies CfL only to the AC chroma coefficients, &lt;em&gt;β&lt;/em&gt; is always zero. This reinforces an insight: &lt;em&gt;β&lt;/em&gt; is conceptually just the chroma values' DC-offset.&lt;/p&gt;
&lt;p&gt;In effect, because Daala uses PVQ to encode transform blocks, it gets CfL almost for free, both in terms of bit cost and computational cost in the encoder as well as the decoder.&lt;/p&gt;
&lt;h3&gt;Chroma from Luma in AV1&lt;/h3&gt;
&lt;p&gt;AV1 did not adopt PVQ, so the cost of CfL is approximately equal whether CfL is computed in the pixel or frequency domain; there's no longer a special bonus to working in frequency. In addition, &lt;a href=&quot;https://people.xiph.org/~xiphmont/demo/daala/demo3.shtml&quot;&gt;TF (Time-Frequency resolution switching)&lt;/a&gt;, which Daala uses to glue the smallest luma blocks together to make subsampled chroma blocks large enough, currently only works with the DCT and Walsh-Hadamard transforms. As AV1 also uses the discrete sine transform and a pixel domain identity transform, we can't easily perform AV1 CfL in the frequency domain, at least when we use subsampled chroma.&lt;/p&gt;
&lt;p&gt;But unlike Daala, AV1 doesn't &lt;em&gt;need&lt;/em&gt; to do CfL in the frequency domain. So, we move Daala's frequency-domain CfL back into the pixel domain for AV1. One of the neat things about CfL is that the basic equations work the same way in both domains.&lt;/p&gt;
&lt;p&gt;CfL in AV1 must keep reconstruction complexity to a minimum. For this reason, we explicitly code &lt;em&gt;α&lt;/em&gt; so that there is no expensive least-squares fitting in the decoder. The bit cost of explicitly coding &lt;em&gt;α&lt;/em&gt; is more than outweighed by the additional accuracy gained by computing it using the current block's chroma pixels as opposed to neighboring reconstructed chroma pixels.&lt;/p&gt;
&lt;p&gt;Next, we optimize the fitting complexity on the encoder-side. In Daala, which operates in the frequency domain, we perform CfL using only luma's AC coefficients. AV1 performs CfL fitting in the pixel domain, but we can subtract the average (that is, that already-computed DC value) from each pixel, rendering the pixel values zero-mean and equivalent to the AC coefficient contribution as in Daala. Zero-mean luma values cancel out a substantial portion of the least-squares equation, greatly reducing the computational overhead:&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;caption&quot; src=&quot;https://people.xiph.org/~xiphmont/demo/av1/alphabeta2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;There's more we can do. Remembering that &lt;em&gt;β&lt;/em&gt; is simply chroma's DC-offset, we realize that the encoder and decoder already perform DC-prediction for the chroma planes as it's needed for other prediction modes. Of course, a predicted DC value is not going to be as accurate as an explicitly coded DC/&lt;em&gt;β&lt;/em&gt; value, but testing shows that it's still quite good:&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;caption&quot; src=&quot;https://people.xiph.org/~xiphmont/demo/av1/DCbeta.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Above: Error analysis of using the default DC predictor value calculated using neighboring pixels, as opposed to coding an explicit &lt;em&gt;β&lt;/em&gt; value calculated from pixels in the current block.&lt;/p&gt;
&lt;p&gt;As a result, we simply use the pre-existing chroma DC prediction instead of &lt;em&gt;β&lt;/em&gt;. This not only means we don't need to explicitly code &lt;em&gt;β&lt;/em&gt;, it also means we do not need to explicitly compute &lt;em&gt;β&lt;/em&gt; from &lt;em&gt;α&lt;/em&gt; in either the decoder &lt;em&gt;or&lt;/em&gt; encoder. Thus, our final CfL prediction equation becomes:&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;caption&quot; src=&quot;https://people.xiph.org/~xiphmont/demo/av1/av1cfl.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In those cases where prediction alone isn't accurate enough, we encode a transform-domain residual. And, of course, when the prediction isn't good enough to save any bits at all, we simply don't have to use it.&lt;/p&gt;
&lt;h3&gt;Results&lt;/h3&gt;
&lt;p&gt;CfL gains are, like any other prediction technique, dependent on the test. AOM uses a number of &lt;a href=&quot;https://media.xiph.org/video/derf/&quot;&gt;stadardized test sets hosted at Xiph.Org&lt;/a&gt;, and made available through the automated &lt;a href=&quot;https://arewecompressedyet.com/&quot;&gt;'Are We Compressed Yet?'&lt;/a&gt; testing tool.&lt;/p&gt;
&lt;p&gt;CfL is an intra-prediction technique, and to best isolate its usefulness in intra-coding, we can look at its performance on keyframes using the 'subset-1' image test set:&lt;/p&gt;
&lt;table class=&quot;textable&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;
&lt;td colspan=&quot;7&quot; class=&quot;title&quot;&gt;BD-rate&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;
&lt;td&gt;PSNR&lt;/td&gt;
&lt;td&gt;PSNR-HVS&lt;/td&gt;
&lt;td&gt;SSIM&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;CIEDE2000&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;PSNR Cb&lt;/td&gt;
&lt;td&gt;PSNR Cr&lt;/td&gt;
&lt;td&gt;MS SSIM&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;result&quot;&gt;&lt;td&gt;Average&lt;/td&gt;
&lt;td&gt;-0.53&lt;/td&gt;
&lt;td&gt;-0.31&lt;/td&gt;
&lt;td&gt;-0.34&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-4.87&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-12.87&lt;/td&gt;
&lt;td&gt;-10.75&lt;/td&gt;
&lt;td&gt;-0.34&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Most of the metrics here are not color-sensitive, they're simply included because they're always included and it's nice to see CfL doesn't &lt;em&gt;damage&lt;/em&gt; them. Of course, it shouldn't; by making color coding more efficient, it is also freeing up bits that can be used to better represent luma as well.&lt;/p&gt;
&lt;p&gt;That said, CIE delta-E 2000 is the metric to pay attention to; it implements a perceptually-uniform color error metric. We see that CfL saves nearly 5% in bitrate when both luma and chroma are considered! That's a stunning number for a single prediction technique.&lt;/p&gt;
&lt;p&gt;CfL is available for intra-blocks within inter-frames as well. During AV1 development, the objective-1-fast set was the standard test set for metric evaluation of motion sequences:&lt;/p&gt;
&lt;table class=&quot;textable&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;
&lt;td colspan=&quot;7&quot; class=&quot;title&quot;&gt;BD-rate&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;
&lt;td&gt;PSNR&lt;/td&gt;
&lt;td&gt;PSNR-HVS&lt;/td&gt;
&lt;td&gt;SSIM&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;CIEDE2000&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;PSNR Cb&lt;/td&gt;
&lt;td&gt;PSNR Cr&lt;/td&gt;
&lt;td&gt;MS SSIM&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;result&quot;&gt;&lt;td&gt;Average&lt;/td&gt;
&lt;td&gt;-0.43&lt;/td&gt;
&lt;td&gt;-0.42&lt;/td&gt;
&lt;td&gt;-0.38&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-2.41&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-5.85&lt;/td&gt;
&lt;td&gt;-5.51&lt;/td&gt;
&lt;td&gt;-0.40&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1080p&lt;/td&gt;
&lt;td&gt;-0.32&lt;/td&gt;
&lt;td&gt;-0.37&lt;/td&gt;
&lt;td&gt;-0.28&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-2.52&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-6.80&lt;/td&gt;
&lt;td&gt;-5.31&lt;/td&gt;
&lt;td&gt;-0.31&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1080p-screen&lt;/td&gt;
&lt;td&gt;-1.82&lt;/td&gt;
&lt;td&gt;-1.72&lt;/td&gt;
&lt;td&gt;-1.71&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-8.22&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-17.76&lt;/td&gt;
&lt;td&gt;-12.00&lt;/td&gt;
&lt;td&gt;-1.75&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;720p&lt;/td&gt;
&lt;td&gt;-0.12&lt;/td&gt;
&lt;td&gt;-0.11&lt;/td&gt;
&lt;td&gt;-0.07&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-0.52&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-1.08&lt;/td&gt;
&lt;td&gt;-1.23&lt;/td&gt;
&lt;td&gt;-0.12&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;360p&lt;/td&gt;
&lt;td&gt;-0.15&lt;/td&gt;
&lt;td&gt;-0.05&lt;/td&gt;
&lt;td&gt;-0.10&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-0.80&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-2.17&lt;/td&gt;
&lt;td&gt;-6.45&lt;/td&gt;
&lt;td&gt;-0.04&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;As expected, we still see solid gains, though CfL's contribution is watered down somewhat by the preponderance of inter-prediction in use. Intra blocks are used primarily in keyframes, each of these test sequences coded only a single keyframe, and intra-coding is not used often in inter-frames.&lt;/p&gt;
&lt;p&gt;The big exception is '1080p-screen' content where we see a whopping 8% rate reduction. This makes sense; most screencasting content is fairly static, and where areas change they are almost always wholesale updates suited to intra coding rather than the smooth motion suited to inter. These screencasting clips code more intra blocks and so see more gain from CfL.&lt;/p&gt;
&lt;p&gt;This is true of synthetic and rendered content as well:&lt;/p&gt;
&lt;table class=&quot;textable&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;
&lt;td colspan=&quot;7&quot; class=&quot;title&quot;&gt;BD-rate&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;
&lt;td&gt;PSNR&lt;/td&gt;
&lt;td&gt;PSNR-HVS&lt;/td&gt;
&lt;td&gt;SSIM&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;CIEDE2000&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;PSNR Cb&lt;/td&gt;
&lt;td&gt;PSNR Cr&lt;/td&gt;
&lt;td&gt;MS SSIM&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;result&quot;&gt;&lt;td&gt;Twitch&lt;/td&gt;
&lt;td&gt;-1.01&lt;/td&gt;
&lt;td&gt;-0.93&lt;/td&gt;
&lt;td&gt;-0.90&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-5.74&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-15.58&lt;/td&gt;
&lt;td&gt;-9.96&lt;/td&gt;
&lt;td&gt;-0.81&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;The Twitch test set is entirely live-streamed video game content, and we see solid gains here as well.&lt;/p&gt;
&lt;p&gt;Chroma From Luma is not, of course, the only technique being adopted in a production codec for the first time in AV1. Next post we'll look at a technique that really is entirely brand new in AV1: The Constrained Directional Enhancement Filter.&lt;/p&gt;
&lt;address&gt;—Monty (&lt;a href=&quot;mailto:monty@xiph.org&quot;&gt;monty@xiph.org&lt;/a&gt;, &lt;a href=&quot;mailto:cmontgomery@mozilla.com&quot;&gt;cmontgomery@mozilla.com&lt;/a&gt;) April 9, 2018&lt;/address&gt;
&lt;p&gt;&lt;em&gt;&lt;a name=&quot;rolling-intra&quot; id=&quot;rolling-intra&quot;&gt;*&lt;/a&gt; It's also possible to spread a keyframe through other frames using a technique called &lt;strong&gt;rolling intra&lt;/strong&gt;. Rolling intra splits standalone keyframes into standalone blocks that are sprinkled through preceding inter frames. Rather than seeking to a keyframe and simply beginning playback at that point, a rolling intra codec seeks to an earlier point, reads forward collecting the standalone keyframe pieces that are spread out through other frames, then begins playback after it has enough information to construct a complete, up-to-date frame. Rolling intra does not improve compression; it merely spreads out bitrate spikes caused by large keyframes. It can also be used as a form of error resiliency.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a name=&quot;xtime&quot; id=&quot;xtime&quot;&gt;†&lt;/a&gt;Technically, Energy is Power x Time&lt;/em&gt;. When comparing apples and oranges, it is important to express both in watt-hours.&lt;/p&gt;
&lt;h2&gt;Additional Resources&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Alliance for Open Media Design Document: &lt;a href=&quot;https://docs.google.com/document/d/1T86spqQqt7o3LWj3FeaOPUJ2vZ_DSgImJ2r0on8wP-g/&quot;&gt;Chroma from Luma in AV1&lt;/a&gt;, Luc Trudeau, David Michael Barr&lt;/li&gt;
&lt;li&gt;The seminal paper on spatial domain Chroma from Luma prediction: &lt;a href=&quot;http://dx.doi.org/10.1109/ICIP.2009.5413727&quot;&gt;Intra Prediction Method Based on the Linear Relationship between the Channels for YUV 4:2:0 Intra Coding&lt;/a&gt;, Sang Heon Lee, 2009 16th IEEE International Conference on Image Processing (ICIP)&lt;/li&gt;
&lt;li&gt;LG proposal to include spatial Chroma from Luma in HEVC: &lt;a href=&quot;http://wftp3.itu.int/av-arch/jctvc-site/2010_07_B_Geneva/JCTVC-B021.doc&quot;&gt;New intra chroma prediction using inter-channel correlation&lt;/a&gt;, Kim et. al. 2010&lt;/li&gt;
&lt;li&gt;Samsung and LG joint LM Mode proposal to HEVC: &lt;a href=&quot;https://people.xiph.org/~xiphmont/demo/av1/phenix.int-evry.fr/jct/doc_end_user/documents/5_Geneva/wg11/JCTVC-E266-v4.zip&quot;&gt;Chroma intra prediction by reconstructed luma samples&lt;/a&gt;, Kim et. al. 2011&lt;/li&gt;
&lt;li&gt;CfL as implemented in Daala: &lt;a href=&quot;https://arxiv.org/abs/1603.03482&quot;&gt;Predicting Chroma from Luma with Frequency Domain Intra Prediction&lt;/a&gt;, Nathan E. Egge, Jean-Marc Valin, 10 March 2016&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1711.03951&quot;&gt;Predicting Chroma from Luma in AV1&lt;/a&gt;, Luc N. Trudeau, Nathan E. Egge, David Barr, 17 January 2018&lt;/li&gt;
&lt;li&gt;Daala technology &lt;a href=&quot;https://people.xiph.org/~xiphmont/demo/daala/demo3.shtml&quot;&gt;demo page for Time-Frequency resolution switching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Daala technology &lt;a href=&quot;https://people.xiph.org/~xiphmont/demo/daala/demo4.shtml&quot;&gt;demo page for Chroma-From-Luma&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Chroma From Luma VDD presentation: &lt;a href=&quot;https://docs.google.com/presentation/d/1LYQQ4EnsIIbTTdXlLpxbxK90ijkdNhz7Pt5a1CJoxsY/&quot;&gt;Chroma from Luma (CfL) in AV1&lt;/a&gt; , Luc Trudeau, David Michael Barr, September 2017&lt;/li&gt;
&lt;li&gt;Data Compression Conference presentation: &lt;a href=&quot;https://docs.google.com/presentation/d/13yUG1lyNmf_TtWARvOJRGa05EVknKya-VEDZ_8L22P8/&quot;&gt;Chroma from Luma Intra Prediction for AV1&lt;/a&gt;, Luc N. Trudeau, Nathan E. Egge, David Barr, March 2018&lt;/li&gt;
&lt;li&gt;Xiph.Org's &lt;a href=&quot;https://media.xiph.org/video/derf/&quot;&gt;standard 'derf' test sets&lt;/a&gt;, hosted at &lt;a href=&quot;https://media.xiph.org/&quot;&gt;media.xiph.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Automated testing harness and metrics used by Daala and AV1 development: &lt;a href=&quot;https://arewecompressedyet.com/&quot;&gt;Are We Compressed Yet?&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;&lt;div class=&quot;mr&quot;&gt;
&lt;div&gt;&lt;a href=&quot;http://mozilla.org/&quot;&gt;&lt;img src=&quot;https://people.xiph.org/~xiphmont/demo/moz-logo2.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;div class=&quot;mrcenter&quot; readability=&quot;5.9333333333333&quot;&gt;
&lt;div class=&quot;mrcontent&quot; readability=&quot;28.819047619048&quot;&gt;Monty's codec documentation work is sponsored by&lt;br /&gt;&lt;a href=&quot;http://www.mozilla.org/en-US/research/&quot;&gt;Mozilla Research&lt;/a&gt;.&lt;br /&gt;(C) Copyright 2018 Mozilla and Xiph.Org&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;mrright&quot;&gt;
&lt;div class=&quot;mrcontent&quot;&gt;&lt;a href=&quot;http://www.mozilla.org/en-US/research/&quot;&gt;&lt;img src=&quot;https://people.xiph.org/~xiphmont/demo/hack.jpg&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;</description>
<pubDate>Mon, 09 Apr 2018 19:26:08 +0000</pubDate>
<dc:creator>TD-Linux</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://people.xiph.org/~xiphmont/demo/av1/demo1.shtml</dc:identifier>
</item>
<item>
<title>Testimony of Mark Zuckerberg – Hearing Before US House of Representatives [pdf]</title>
<link>http://docs.house.gov/meetings/IF/IF00/20180411/108090/HHRG-115-IF00-Wstate-ZuckerbergM-20180411.pdf</link>
<guid isPermaLink="true" >http://docs.house.gov/meetings/IF/IF00/20180411/108090/HHRG-115-IF00-Wstate-ZuckerbergM-20180411.pdf</guid>
<description>&lt;a href=&quot;http://docs.house.gov/meetings/IF/IF00/20180411/108090/HHRG-115-IF00-Wstate-ZuckerbergM-20180411.pdf&quot;&gt;Download PDF&lt;/a&gt;</description>
<pubDate>Mon, 09 Apr 2018 15:52:11 +0000</pubDate>
<dc:creator>uptown</dc:creator>
<dc:format>application/pdf</dc:format>
<dc:identifier>http://docs.house.gov/meetings/IF/IF00/20180411/108090/HHRG-115-IF00-Wstate-ZuckerbergM-20180411.pdf</dc:identifier>
</item>
<item>
<title>Microplastics found in 93% of bottled water tested in global study</title>
<link>http://www.cbc.ca/news/technology/bottled-water-microplastics-1.4575045</link>
<guid isPermaLink="true" >http://www.cbc.ca/news/technology/bottled-water-microplastics-1.4575045</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;The bottled water industry is estimated to be worth&lt;/span&gt; &lt;a href=&quot;https://globenewswire.com/news-release/2017/05/26/998349/0/en/Global-Bottled-Water-Market-will-reach-USD-280-0-Billion-by-2020.html&quot;&gt;nearly $200 billion a year&lt;/a&gt;, surpassing sugary sodas as the most popular beverage in many countries. But its perceived image of cleanliness and purity is being challenged by a global investigation that found the water tested is often contaminated with tiny particles of plastic.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;Our love affair with making single-use disposable plastics out of a material that lasts for literally centuries — that's a disconnect, and I think we need to rethink our relationship with that,&quot; says Prof. Sherri Mason, a microplastics researcher who carried out the laboratory work at the State University of New York (SUNY).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The research was conducted on behalf of&lt;/span&gt; &lt;a href=&quot;https://orbmedia.org/&quot;&gt;Orb Media&lt;/a&gt;, a U.S-based non-profit journalism organization with which CBC News has partnered.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mason's team tested 259 bottles of water purchased in nine countries (none were bought in Canada). Though many brands are sold internationally, the water source, manufacturing and bottling process for the same brand can differ by country.&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11.036789297659&quot;&gt;

The 11 brands tested include the world's dominant players — Nestle Pure Life, Aquafina, Dasani, Evian, San Pellegrino and Gerolsteiner — as well as major national brands across Asia, Africa, Europe and the Americas.&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Researchers found &lt;a href=&quot;https://orbmedia.org/stories/plus-plastic&quot;&gt;93 per cent of all bottles tested&lt;/a&gt; contained some sort of microplastic, including polypropylene, polystyrene, nylon and polyethylene terephthalate (PET).&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;10.4 particles/litre on average&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Microplastics are the result of the breakdown of all the plastic waste that makes its way into&lt;/span&gt; landfills and oceans. They are also manufactured intentionally, as microbeads used in skin care products. Microbeads are now being phased out in Canada, after significant numbers began to appear in the Great Lakes and the tiny particles were found filling the stomachs of fish.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Anything smaller than five millimetres in size (5,000 microns) is considered microplastic.&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;placeholder&quot;&gt;&lt;span&gt;&lt;img alt=&quot;&quot; width=&quot;100&quot; height=&quot;75&quot; class=&quot;imageEl storyImage loaded lazyImage smallImage&quot; src=&quot;https://i.cbc.ca/1.4576269.1521053804!/fileImage/httpImage/image.png_gen/derivatives/original_1180/image2-png.png?imwidth=100&quot;/&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;span&gt;&lt;span class=&quot;leadimage-caption&quot;&gt;Using the Red Nile test, researchers identified tiny particles believed to be microplastics in many bottles of water.  (Orb Media)&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Orb found on average there were 10.4 particles of plastic per litre that were 100 microns (0.10 mm) or bigger. This is double the level of microplastics in the tap water tested from more than a dozen countries across five continents, examined in a 2017 study by Orb that looked at similar-sized plastics.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Other, smaller particles were also discovered — 314 of them per litre, on average — which&lt;/span&gt; some of the experts consulted about the Orb study believe are plastics but cannot definitively identify.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The amount of particles varied from bottle to bottle: while some contained one, others contained thousands.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The purpose of the study was to establish the presence of the plastics in bottled water.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;It's unclear what the effect of microplastics is on human health, and no previous work has established a maximum safe level of consumption. There are no rules or standards for allowable limits of microplastics in bottled water in Canada, the United States and Europe. Rules and standards for other countries from the study are not known.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Two brands — Nestle and Gerolsteiner — confirmed their own testing showed their water contained microplastics, albeit at much lower levels than what Orb Media is reporting.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Emerging science&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Plastics are present nearly everywhere and can take hundreds of years to degrade, if at all. Many types only continue to break down into smaller and smaller particles, until they are not visible to the naked eye.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Plastics have also been known to act like a sponge, and can absorb and release chemicals that could be harmful if consumed by mammals and fish.&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;5.1223021582734&quot;&gt;

&quot;It's not straightforward,&quot; said Prof. Max Liboiron of Memorial University in St John's.&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&quot;If you've ever had chili or spaghetti and you put it in Tupperware, and you can't scrub the orange colour out, that's a manifestation of how plastics absorb oily chemicals,&quot; says Liboiron, director of the&lt;/span&gt; Civic Laboratory for Environmental Action Research (CLEAR), which monitors plastic pollution.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The European Food Safety Authority&lt;/span&gt; &lt;a href=&quot;https://drive.google.com/file/d/1om9TTZjiQPhFE4TqbtL80Omg_uozrwYW/view&quot;&gt;suggests&lt;/a&gt; most microplastics will be excreted by the body. But the United Nations Food and Agriculture Organization &lt;a href=&quot;https://drive.google.com/file/d/1oHSOj9s48Rat-cn1FRDUwuFIDkYH2Sm0/view&quot;&gt;has raised concerns&lt;/a&gt; about the possibility some particles could be small enough to pass into the bloodstream and organs.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;It's not clear how the plastic is getting into the bottled water — whether it's the water source itself or the air or the manufacturing and bottling process.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;Even the simple act of opening the cap could cause plastic to be chipping off the cap,&quot; Mason said.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;The science behind the test&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;The water tested was purchased in the U.S., Kenya, China, Brazil, India, Indonesia, Lebanon, Mexico and Thailand, and represented a range of brands across several continents. It was shipped to the specialized lab at SUNY in Fredonia, N.Y.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Scientists used Nile Red fluorescent tagging, an emerging method for the rapid identification of microplastics, as the dye binds to plastic. Scientists put the dyed water through a filter and then viewed samples under a microscope.&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;placeholder&quot;&gt;&lt;span&gt;&lt;img alt=&quot;&quot; width=&quot;100&quot; height=&quot;72.9&quot; class=&quot;imageEl storyImage loaded lazyImage smallImage&quot; src=&quot;https://i.cbc.ca/1.4575049.1520980956!/fileImage/httpImage/image.JPG_gen/derivatives/original_1180/prof-sherri-mason.JPG?imwidth=100&quot;/&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;span&gt;&lt;span class=&quot;leadimage-caption&quot;&gt;Prof. Sherri Mason carried out the laboratory work at the State University of New York (SUNY), on behalf of Orb Media.  (Dave MacIntosh/CBC)&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Mason's team was able to identify specific plastics over 100 microns (0.10 mm) in size but not smaller particles. According to experts contacted by CBC News, there is a chance the Nile Red dye is adhering to another unknown substance other than plastic.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mason leaves open that possibility but leans strongly to the smaller particles being plastic.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The developer of the Nile Red method agrees.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Fluorescing particles that were too small to be analyzed should be called &quot;probable microplastic,&quot; said Andrew Mayes, senior lecturer in chemistry at the University of East Anglia in the U.K.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Orb consulted several toxicologists and microplastics experts throughout the entire process who also reviewed the findings.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;This is pretty substantial,&quot; Mayes said. &quot;I've looked in some detail at the finer points of the way the work was done, and I'm satisfied that it has been applied carefully and appropriately, in a way that I would have done it in my lab.&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CBC News also asked multiple experts to review Orb's study; while similar questions came up with the Nile Red dye, they were convinced there was some level of microplastics in the water and further research was warranted.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Big brands respond&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Nestle said in a response that it had tested six bottles of water from two of its brands — Nestle Pure Life and San Pellegrino — and found between two and 12 microplastics per litre, much lower than what Orb found in its study. The company suggested that Nile Red dye is known to &quot;generate false positives.&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Gerolsteiner also said its tests showed a &quot;significantly lower quantity of microplastics per litre&quot; in its products.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;We still cannot understand how the study reached the conclusions it did,&quot; the company said. &quot;The research results do not correspond to the internal analyses that we conduct on a regular basis,&quot; the company said in a response.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Danone, the company behind Evian and Indonesian brand Aqua, told Orb it is &quot;not in a position to comment as the testing methodology used is unclear. There is still limited data on the topic, and conclusions differ dramatically from one study to another.&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Brazilian brand Minalba told Orb that it abides by all quality and security standards required by Brazilian legislation.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The American Beverage Association, which represents many of the biggest brands across North America, including Nestle, Evian, Dasani and Aquafina, told Orb that &quot;the science on microplastics and microfibres is nascent and an emerging field…. We stand by the safety of our bottled water products and we are interested in contributing to serious scientific research that will ... help us all understand the scope, impact and appropriate next steps.&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Brands &lt;span&gt;Biserli and Wahaha did not respond to Orb's request for comment.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Plastics, plastics everywhere&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Within three decades, there will be more plastics in the oceans than fish. They are having a profound effect on the environment. In the oceans, vast quantities float on the surface, trapping sea life and blocking the sun's rays from entering the waters.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mason points out people can choose to not buy water in a plastic bottle, and to carry a refillable bottle instead. But for other products, there is no choice. The majority of products on grocery and retail store shelves are contained in plastic.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;It's portable, it's lightweight, it's convenient, it's cheap — that just makes it easy,&quot; Mason says. &quot;It's so difficult to get people to care about things they can't see.&quot;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Apr 2018 15:33:58 +0000</pubDate>
<dc:creator>nothrows</dc:creator>
<og:url>http://www.cbc.ca/news/technology/bottled-water-microplastics-1.4575045</og:url>
<og:title>93% of bottled water tested contained microplastics: Study | CBC News</og:title>
<og:image>https://i.cbc.ca/1.4575047.1520980876!/fileImage/httpImage/image.jpg_gen/derivatives/16x9_620/hkg10235388.jpg</og:image>
<og:description>The image of bottle water as clean and pure is being challenged by a global investigation that found the water tested is often contaminated with tiny particles of plastic.</og:description>
<og:type>article</og:type>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cbc.ca/news/technology/bottled-water-microplastics-1.4575045</dc:identifier>
</item>
<item>
<title>Android container in Chrome OS</title>
<link>https://chromium.googlesource.com/chromiumos/platform2/+/master/arc/container-bundle/</link>
<guid isPermaLink="true" >https://chromium.googlesource.com/chromiumos/platform2/+/master/arc/container-bundle/</guid>
<description>&lt;p&gt;This document outlines the process by which Android runs in a Linux container in Chrome OS.&lt;/p&gt;
&lt;p&gt;This document explains how the container for Android master works unless otherwise noted. The container for N may work in a slightly different way.&lt;/p&gt;
&lt;h2&gt;config.json&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;code&quot;&gt;config.json&lt;/code&gt; is used by &lt;a href=&quot;https://chromium.googlesource.com/chromiumos/platform2/+/master/run_oci/&quot;&gt;&lt;code class=&quot;code&quot;&gt;run_oci&lt;/code&gt;&lt;/a&gt;, to describe how the container is set up. This file describes the mount structure, namespaces, device nodes that are to be created, cgroups configuration, and capabilities that are inherited.&lt;/p&gt;
&lt;h2&gt;Namespaces&lt;/h2&gt;
&lt;p&gt;Android is running using all of the available Linux &lt;a href=&quot;http://man7.org/linux/man-pages/man7/namespaces.7.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;namespaces(7)&lt;/code&gt;&lt;/a&gt; to increase isolation from the rest of the system:&lt;/p&gt;
&lt;p&gt;Running all of Android's userspace in namespaces also increases compatibility since we can provide it with an environment that is closer to what it expects to find under normal circumstances.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;code&quot;&gt;run_oci&lt;/code&gt; starts in the init namespace (which is shared with most of Chrome OS), running as real root with all capabilities. The mount namespace associated with that is referred to as the &lt;strong&gt;init mount namespace&lt;/strong&gt;. Any mount performed in the init mount namespace will span user sessions and are performed before &lt;code class=&quot;code&quot;&gt;run_oci&lt;/code&gt; starts, so they do not figure in &lt;code class=&quot;code&quot;&gt;config.json&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;First, &lt;code class=&quot;code&quot;&gt;run_oci&lt;/code&gt; creates a mount namespace (while still being associated with init‘s user namespace) that is known as the &lt;strong&gt;intermediate mount namespace&lt;/strong&gt;. Due to the fact that when it is running in this namespace it still has all of root’s capabilities in the init namespace, it can perform privileged operations, such as performing remounts (e.g. calling &lt;code class=&quot;code&quot;&gt;mount(2)&lt;/code&gt; with &lt;code class=&quot;code&quot;&gt;MS_REMOUNT&lt;/code&gt; and without &lt;code class=&quot;code&quot;&gt;MS_BIND&lt;/code&gt;), and requesting to mount a &lt;a href=&quot;http://man7.org/linux/man-pages/man5/tmpfs.5.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;tmpfs(5)&lt;/code&gt;&lt;/a&gt; into Android‘s &lt;code class=&quot;code&quot;&gt;/dev&lt;/code&gt; with the &lt;code class=&quot;code&quot;&gt;dev&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;exec&lt;/code&gt; flags. This intermediate mount namespace is also used to avoid leaking mounts into the init mount namespace, and will be automatically cleaned up when the last process in the namespace exits. This process is typically Android’s init, but if the container fails to start, it can also be &lt;code class=&quot;code&quot;&gt;run_oci&lt;/code&gt; itself.&lt;/p&gt;
&lt;p&gt;Still within the intermediate mount namespace, the container process is created by calling the &lt;a href=&quot;http://man7.org/linux/man-pages/man2/clone.2.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;clone(2)&lt;/code&gt;&lt;/a&gt; system call with the &lt;code class=&quot;code&quot;&gt;CLONE_NEWPID&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;CLONE_NEWUSER&lt;/code&gt; flags. Given that mount namespaces have an owner user namespace, the only way that we can transition into both is to perform both simultaneously. Since Linux 3.9, &lt;code class=&quot;code&quot;&gt;CLONE_NEWUSER&lt;/code&gt; implies &lt;code class=&quot;code&quot;&gt;CLONE_FS&lt;/code&gt;, so this also has the side effect of making this new process no longer share its root directory (&lt;a href=&quot;http://man7.org/linux/man-pages/man2/chroot.2.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;chroot(2)&lt;/code&gt;&lt;/a&gt;) with any other process.&lt;/p&gt;
&lt;p&gt;Once in the container user namespace, the container process enters the rest of the namespaces using &lt;a href=&quot;http://man7.org/linux/man-pages/man2/unshare.2.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;unshare(2)&lt;/code&gt;&lt;/a&gt; system call with the appropriate flag for each namespace. After it performs this with the &lt;code class=&quot;code&quot;&gt;CLONE_NEWNS&lt;/code&gt; flag, it enters the a mount namespace which is referred to as the &lt;strong&gt;container mount namespace&lt;/strong&gt;. This is where the vast majority of the mounts happen. Since this is associated with the container user namespace and the processes here no longer run as root in the init user namespace, some operations are no longer allowed by the kernel, even though the capabilities might be set. Some examples are remounts that modify the &lt;code class=&quot;code&quot;&gt;exec&lt;/code&gt;, &lt;code class=&quot;code&quot;&gt;suid&lt;/code&gt;, &lt;code class=&quot;code&quot;&gt;dev&lt;/code&gt; flags.&lt;/p&gt;
&lt;p&gt;Once &lt;code class=&quot;code&quot;&gt;run_oci&lt;/code&gt; finishes setting up the container process and calls &lt;a href=&quot;http://man7.org/linux/man-pages/man2/exit.2.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;exit(2)&lt;/code&gt;&lt;/a&gt; to daemonize the container process tree, there are no longer any processes in the system that have a direct reference to the intermediate mount namespace, so it is no longer accessible from anywhere. This means that there is no way to obtain a file descriptor that can be passed to &lt;a href=&quot;http://man7.org/linux/man-pages/man2/setns.2.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;setns(2)&lt;/code&gt;&lt;/a&gt; in order to enter it. The namespace itself is still alive since it is the parent of the container mount namespace.&lt;/p&gt;
&lt;h3&gt;User namespace&lt;/h3&gt;
&lt;p&gt;The user namespace is assigned 2,000,000 uids distributed in the following way:&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;init namespace uid range&lt;/th&gt;
&lt;th&gt;container namespace uid range&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;655360 - 660359&lt;/td&gt;
&lt;td&gt;0 - 4999&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;600 - 649&lt;/td&gt;
&lt;td&gt;5000 - 5049&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;660410 - 2655360&lt;/td&gt;
&lt;td&gt;5050 - 2000000&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;The second range maps Chrome OS daemon uids (600-649), into one of Android's &lt;a href=&quot;https://source.android.com/devices/tech/config/filesystem#defining-an-oem-specific-aid&quot;&gt;OEM-specific AIDs&lt;/a&gt; ranges.&lt;/p&gt;
&lt;h3&gt;Network namespace&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2&gt;Mounts&lt;/h2&gt;
&lt;p&gt;There are several ways in which resources are mounted inside the container:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Loop mounts: used to mount filesystem images into the filesystem. Android uses two of these: one for &lt;code class=&quot;code&quot;&gt;system.raw.img&lt;/code&gt;, and another one for &lt;code class=&quot;code&quot;&gt;vendor.raw.img&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Bind mounts: these make a file or directory visible from another subdirectory and can span &lt;a href=&quot;http://man7.org/linux/man-pages/man2/chroot.2.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;chroot(2)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://man7.org/linux/man-pages/man2/pivot_root.2.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;pivot_root(2)&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Shared mounts: these mounts use the &lt;code class=&quot;code&quot;&gt;MS_SHARED&lt;/code&gt; flags for &lt;a href=&quot;http://man7.org/linux/man-pages/man2/mount.2.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;mount(2)&lt;/code&gt;&lt;/a&gt; in the init mount namespace and &lt;code class=&quot;code&quot;&gt;MS_SLAVE&lt;/code&gt; in the container mount namespace, which causes any mount changes under that mount point to propagate to other shared subtrees.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;All mounts are performed in the &lt;code class=&quot;code&quot;&gt;/opt/google/container/android/rootfs/root&lt;/code&gt; subtree. Given that &lt;code class=&quot;code&quot;&gt;run_oci&lt;/code&gt; does not modify the init mount namespace, any mounts that span user sessions (such as the &lt;code class=&quot;code&quot;&gt;system.raw.img&lt;/code&gt; loop mount) should have already been performed before &lt;code class=&quot;code&quot;&gt;run_oci&lt;/code&gt; starts. This is typically handled by &lt;a href=&quot;https://chromium.googlesource.com/chromiumos/platform2/+/master/arc/setup/&quot;&gt;&lt;code class=&quot;code&quot;&gt;arc-setup&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The flags to the &lt;code class=&quot;code&quot;&gt;mounts&lt;/code&gt; section are the ones understood by &lt;a href=&quot;http://man7.org/linux/man-pages/man8/mount.8.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;mount(8)&lt;/code&gt;&lt;/a&gt;. Note that one mount entry might become more than one call to &lt;code class=&quot;code&quot;&gt;mount(2)&lt;/code&gt;, since some flags combinations are ignored by the kernel (e.g. changes to mount propagation flags ignore all other flags).&lt;/p&gt;
&lt;h3&gt;List of mounts visible in the container mount namespace&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/&lt;/code&gt;: This is &lt;code class=&quot;code&quot;&gt;/opt/google/containers/android/system.raw.img&lt;/code&gt; loop-mounted by &lt;code class=&quot;code&quot;&gt;arc-setup&lt;/code&gt; (called from &lt;code class=&quot;code&quot;&gt;/etc/init/arc-system-mount.conf&lt;/code&gt;) in the init namespace. This spans container invocations since it is stateless. The &lt;code class=&quot;code&quot;&gt;exec&lt;/code&gt;/&lt;code class=&quot;code&quot;&gt;suid&lt;/code&gt; flags are added in the intermediate mount namespace, as well as recursively changing its propagation flags to be &lt;code class=&quot;code&quot;&gt;MS_SLAVE&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/dev&lt;/code&gt;: This is a &lt;code class=&quot;code&quot;&gt;tmpfs&lt;/code&gt; mounted in the intermediate mount namespace with &lt;code class=&quot;code&quot;&gt;android-root&lt;/code&gt; as owner. This is needed to get the &lt;code class=&quot;code&quot;&gt;dev&lt;/code&gt;/&lt;code class=&quot;code&quot;&gt;exec&lt;/code&gt; mount flags.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/dev/pts&lt;/code&gt;: Pseudo TTS devpts file system with namespace support so that it is in a different namespace than the parent namespace even though the device node ids look identical. Required for bionic CTS tests. The device is mounted with nosuid and noexec mount options for better security although stock Android does not use them.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/dev/ptmx&lt;/code&gt;: The &lt;a href=&quot;https://www.kernel.org/doc/Documentation/filesystems/devpts.txt&quot;&gt;kernel documentation&lt;/a&gt; for devpts indicates that there are two ways to support &lt;code class=&quot;code&quot;&gt;/dev/ptmx&lt;/code&gt;: creating a symlink that points to &lt;code class=&quot;code&quot;&gt;/dev/pts/ptmx&lt;/code&gt;, or bind-mounting &lt;code class=&quot;code&quot;&gt;/dev/pts/ptmx&lt;/code&gt;. The bind-mount was chosen to mark it &lt;code class=&quot;code&quot;&gt;u:object_r:ptmx_device:s0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/dev/kmsg&lt;/code&gt;: This is a bind-mount of the host‘s &lt;code class=&quot;code&quot;&gt;/run/arc/android.kmsg.fifo&lt;/code&gt;, which is just a FIFO file. Logs written to the fake device are read by a job called &lt;code class=&quot;code&quot;&gt;arc-kmsg-logger&lt;/code&gt; and stored in host’s /var/log/android.kmsg.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/dev/socket&lt;/code&gt;: This is a normal &lt;code class=&quot;code&quot;&gt;tmpfs&lt;/code&gt;, used by Android's &lt;code class=&quot;code&quot;&gt;init&lt;/code&gt; to store socket files.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/dev/usb-ffs/adb&lt;/code&gt;: This is a bind-mount of the hosts's &lt;code class=&quot;code&quot;&gt;/run/arc/adbd&lt;/code&gt; and is a slave mount, which contains a FIFO that acts as the ADB gadget configured through ConfigFS/FunctionFS. This file is only present in Developer Mode. Once the &lt;code class=&quot;code&quot;&gt;/dev/usb-ffs/adb/ep0&lt;/code&gt; file is written to, the bulk-in and bulk-out endpoints will be bind-mounted into this same directory.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/data&lt;/code&gt; and &lt;code class=&quot;code&quot;&gt;/data/cache&lt;/code&gt;: These two directories are bind-mounted from the Chrome OS user's cryptohome (from &lt;code class=&quot;code&quot;&gt;/home/root/${HASH}/android-data/{data,cache}&lt;/code&gt;), which is only available after a user has logged in.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/var/run/arc&lt;/code&gt;: A &lt;code class=&quot;code&quot;&gt;tmpfs&lt;/code&gt; that holds several mount points from other containers for Chrome &amp;lt;=&amp;gt; Android file system communication, such as &lt;code class=&quot;code&quot;&gt;dlfs&lt;/code&gt;, OBB, and external storage.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/var/run/arc/sdcard&lt;/code&gt;: A FUSE file system provided by &lt;code class=&quot;code&quot;&gt;sdcard&lt;/code&gt; daemon running outside the container.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/var/run/chrome&lt;/code&gt;: Holds the ARC bridge and Wayland UNIX domain sockets.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/var/run/cras&lt;/code&gt;: Holds the CRAS UNIX domain socket.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/var/run/inputbridge&lt;/code&gt;: Holds a FIFO for doing IPC within the container. surfaceflinger uses the FIFO to propage input events from host to the container.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/sys&lt;/code&gt;: A normal &lt;code class=&quot;code&quot;&gt;sysfs&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/sys/fs/selinux&lt;/code&gt;: This is bind-mounted from &lt;code class=&quot;code&quot;&gt;/sys/fs/selinux&lt;/code&gt; outside the container.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/sys/kernel/debug&lt;/code&gt;: Since this directory is owned by real root with very restrictive permissions (so the container would not be able to access any resource in that directory), a &lt;code class=&quot;code&quot;&gt;tmpfs&lt;/code&gt; is mounted in its place.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/sys/kernel/debug/sync&lt;/code&gt;: The permissions of this directory in the host are relaxed so that &lt;code class=&quot;code&quot;&gt;android-root&lt;/code&gt; can access it, and bind-mounted in the container.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/sys/kernel/debug/tracing&lt;/code&gt;: This is bind-mounted from the host's /run/arc/debugfs/tracing, only in dev mode. Note that the group id is mapped into the container to allow access from inside by DAC.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/proc&lt;/code&gt;: A normal &lt;code class=&quot;code&quot;&gt;proc&lt;/code&gt; fs. This is mounted in the container mount namespace, which is associated with the container user+pid namespaces to display the correct PID mappings.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/proc/cmdline&lt;/code&gt;: A regular file with the runtime-generated kernel commandline is bind-mounted instead of the Chrome OS kernel commandline.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/proc/sys/vm/mmap_rnd_compat_bits&lt;/code&gt;, &lt;code class=&quot;code&quot;&gt;/proc/sys/vm/mmap_rnd_bits&lt;/code&gt;: Two regular files are bind-mounted since the original files are owned by real root with very restrictive permissions. Android's &lt;code class=&quot;code&quot;&gt;init&lt;/code&gt; modified the contents of these files to increase the &lt;a href=&quot;http://man7.org/linux/man-pages/man2/mmap.2.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;mmap(2)&lt;/code&gt;&lt;/a&gt; entropy, and will crash if this operation is not allowed. Mounting these two files reduces the number of mods to &lt;code class=&quot;code&quot;&gt;init&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/proc/sys/kernel/kptr_restrict&lt;/code&gt;: Same as with &lt;code class=&quot;code&quot;&gt;/proc/sys/vm/mmap_rnd_bits&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/oem&lt;/code&gt;: Holds &lt;code class=&quot;code&quot;&gt;platform.xml&lt;/code&gt; file.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/var/run/arc/bugreport&lt;/code&gt;: This is bind-mounted from host‘s &lt;code class=&quot;code&quot;&gt;/run/arc/bugreport&lt;/code&gt;. The container creates a pipe file in the directory to allow host’s &lt;code class=&quot;code&quot;&gt;debugd&lt;/code&gt; to read it. When it is read, Android's &lt;code class=&quot;code&quot;&gt;bugreport&lt;/code&gt; output is sent to the host side.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/var/run/arc/apkcache&lt;/code&gt;: This is bind-mounted from host‘s `/mnt/stateful_partition/unencrypted/apkcache. The host directory is for storing APK files specified by the device’s policy and downloaded on the host side.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/var/run/arc/dalvik-cache&lt;/code&gt;: This is bind-mounted from host's &lt;code class=&quot;code&quot;&gt;/mnt/stateful_partition/unencrypted/art-data/dalvik-cache&lt;/code&gt;. The host directory is for storing boot*.art files compiled on the host side. This allows the container to load the files right away without building them.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/var/run/camera&lt;/code&gt;: Holds the arc-camera UNIX domain socket.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/var/run/arc/obb&lt;/code&gt;: This is bind-mounted from host's &lt;code class=&quot;code&quot;&gt;/run/arc/obb&lt;/code&gt;. A daemon running outside the container called &lt;code class=&quot;code&quot;&gt;/usr/bin/arc-obb-mounter&lt;/code&gt; mounts an OBB image file as a FUSE file system to the directory when requested.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/var/run/arc/media&lt;/code&gt;: This is bind-mounted from host's &lt;code class=&quot;code&quot;&gt;/run/arc/media&lt;/code&gt;. A daemon running outside the container called &lt;code class=&quot;code&quot;&gt;/usr/bin/mount-passthrough&lt;/code&gt; mounts an external storage as a FUSE file system to the directory when needed.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;/vendor&lt;/code&gt;: This is loop-mounted from host's &lt;code class=&quot;code&quot;&gt;/opt/google/containers/android/vendor.raw.img&lt;/code&gt;. The directory may have graphic drivers, Houdini, board-specific APKs, and so on.&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Capabilities&lt;/h2&gt;
&lt;p&gt;Android is running in a user namespace, and the &lt;code class=&quot;code&quot;&gt;root&lt;/code&gt; user in the namespace has all possible capabilities in that namespace. Nevertheless, there are some operations in the kernel where the capability check is performed against the user in the init namespace. All the capabilities where all the checks are done in this way (such as &lt;code class=&quot;code&quot;&gt;CAP_SYS_MODULE&lt;/code&gt;) are removed because no user within the container would be able to use it.&lt;/p&gt;
&lt;p&gt;Additionally, the following capabilities were removed (by dropping them from the list of permitted, inheritable, effective, and ambient capability sets) to signal the container that it cannot perform certain operations:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;code&quot;&gt;CAP_SYS_BOOT&lt;/code&gt;: This signals Android's &lt;code class=&quot;code&quot;&gt;init&lt;/code&gt; process that it should not use &lt;code class=&quot;code&quot;&gt;reboot(2)&lt;/code&gt;, but instead call &lt;code class=&quot;code&quot;&gt;exit(2)&lt;/code&gt;. It is also used to decide whether or not to block the &lt;code class=&quot;code&quot;&gt;SIGTERM&lt;/code&gt; signal, which can be used to request the container to terminate itself from the outside.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;code&quot;&gt;CAP_SYSLOG&lt;/code&gt;: This signals Android that it will not be able to access kernel pointers found in &lt;code class=&quot;code&quot;&gt;/proc/kallsyms&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Cgroups&lt;/h2&gt;
&lt;p&gt;By default, processes running inside the container are not allowed to access any device files. They can only access the ones that are explcitly allowed in the &lt;code class=&quot;code&quot;&gt;config.json&lt;/code&gt;'s &lt;code class=&quot;code&quot;&gt;linux&lt;/code&gt; &amp;gt; &lt;code class=&quot;code&quot;&gt;resources&lt;/code&gt; &amp;gt; &lt;code class=&quot;code&quot;&gt;devices&lt;/code&gt; section.&lt;/p&gt;
&lt;h2&gt;Boot process&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3&gt;Hooks&lt;/h3&gt;
&lt;p&gt;The hooks used by &lt;code class=&quot;code&quot;&gt;run_oci&lt;/code&gt; follow the &lt;a href=&quot;https://github.com/opencontainers/runtime-spec/blob/master/config.md#posix-platform-hooks&quot;&gt;Open Container Initiative spec for POSIX-platform Hooks&lt;/a&gt;, with a Chrome OS-specific extension that allows a hook to be installed after all the mounts have been processed, but prior to calling &lt;a href=&quot;http://man7.org/linux/man-pages/man2/chroot.2.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;chroot(2)&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All the hooks are run by calling &lt;a href=&quot;http://man7.org/linux/man-pages/man2/fork.2.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;fork(2)&lt;/code&gt;&lt;/a&gt;+ &lt;a href=&quot;http://man7.org/linux/man-pages/man2/execve.2.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;execve(2)&lt;/code&gt;&lt;/a&gt; from the &lt;code class=&quot;code&quot;&gt;run_oci&lt;/code&gt; process (which is the parent of the container process), and within the intermediate mount namespace.&lt;/p&gt;
&lt;p&gt;In order to avoid paying the price of creating several processes and switching back and forth between namespaces (which added several milliseconds to the boot time when done naïvely), we have consolidated all of the hook execution to a single pre-chroot hook that invokes &lt;a href=&quot;https://chromium.googlesource.com/chromiumos/platform2/+/master/arc/setup/&quot;&gt;&lt;code class=&quot;code&quot;&gt;arc-setup&lt;/code&gt;&lt;/a&gt; with the &lt;code class=&quot;code&quot;&gt;--pre-chroot&lt;/code&gt; flag. This performs several operations:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Set up &lt;a href=&quot;https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html&quot;&gt;&lt;code class=&quot;code&quot;&gt;binfmt_misc&lt;/code&gt;&lt;/a&gt; to perform ARM binary translation on Intel devices.&lt;/li&gt;
&lt;li&gt;Restores the SELinux context of several of the files and directories that are created by &lt;code class=&quot;code&quot;&gt;run_oci&lt;/code&gt;, since these are not handled by either the build system, or the first invocation of &lt;code class=&quot;code&quot;&gt;arc-setup&lt;/code&gt; that occurs before &lt;code class=&quot;code&quot;&gt;run_oci&lt;/code&gt; is invoked.&lt;/li&gt;
&lt;li&gt;Touches &lt;code class=&quot;code&quot;&gt;/dev/.coldboot_done&lt;/code&gt;, which is used by Android as a signal that it has reached a certain point during the boot sequence. This is normally done by Android's &lt;code class=&quot;code&quot;&gt;init&lt;/code&gt; during its first stage, but we do not use it and boot Android directly into &lt;code class=&quot;code&quot;&gt;init&lt;/code&gt;'s second stage.&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;References&lt;/h2&gt;
</description>
<pubDate>Mon, 09 Apr 2018 15:21:56 +0000</pubDate>
<dc:creator>navigaid</dc:creator>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://chromium.googlesource.com/chromiumos/platform2/+/master/arc/container-bundle/</dc:identifier>
</item>
<item>
<title>Facebook urged to make GDPR its “baseline standard” globally</title>
<link>https://techcrunch.com/2018/04/09/facebook-urged-to-make-gdpr-its-baseline-standard-globally/</link>
<guid isPermaLink="true" >https://techcrunch.com/2018/04/09/facebook-urged-to-make-gdpr-its-baseline-standard-globally/</guid>
<description>&lt;p&gt;&lt;a class=&quot;crunchbase-link&quot; href=&quot;https://www.crunchbase.com/organization/facebook/&quot; target=&quot;_blank&quot; data-type=&quot;organization&quot; data-entity=&quot;facebook&quot;&gt;Facebook&lt;/a&gt; is facing calls from consumer groups to make the European Union’s incoming &lt;a href=&quot;https://techcrunch.com/2018/01/20/wtf-is-gdpr/&quot;&gt;GDPR&lt;/a&gt; data protection framework the “baseline standard for all Facebook services”.&lt;/p&gt;
&lt;p&gt;The update to the bloc’s &lt;a class=&quot;crunchbase-link&quot; href=&quot;https://www.crunchbase.com/organization/data-protection/&quot; target=&quot;_blank&quot; data-type=&quot;organization&quot; data-entity=&quot;data-protection&quot;&gt;data protection&lt;/a&gt; framework is intended to strengthen consumers’ control over how their personal data is used by bolstering transparency and consent requirements, and beefing up penalties for data breaches and privacy violations.&lt;/p&gt;
&lt;p&gt;In an &lt;a href=&quot;http://tacd.org/wp-content/uploads/2018/04/TACD-letter-to-Mark-Zuckerberg_final.pdf&quot;&gt;open letter&lt;/a&gt; addressed to founder Mark Zuckerberg, a coalition of US and EU consumer and privacy rights groups urges the company to “confirm your company’s commitment to global compliance with the GDPR and provide specific details on how the company plans to implement these changes in your testimony before the US Congress this week”.&lt;/p&gt;
&lt;p&gt;The letter is written by the Trans Atlantic Consumer Dialogue, and co-signed by Jeffrey Chester, the executive director of the &lt;a href=&quot;https://www.democraticmedia.org&quot;&gt;Center for Digital Democracy&lt;/a&gt; in the US and Finn Lützow-Holm Myrstad, the head of the digital services section at the Norwegian Consumer Council.&lt;/p&gt;
&lt;p&gt;“The GDPR helps ensure that companies such as yours operate in an accountable and transparent manner, subject to the rule of law and the democratic process,” they write. “The GDPR provides a solid foundation for data protection, establishing clear responsibilities for companies that collect personal data and clear rights for users whose data is gathered. These are protections that all users should be entitled to no matter where they are located.&lt;/p&gt;
&lt;p&gt;“We favor the continued growth of the digital economy and we strongly support innovation. The unregulated collection and use of personal data threatens this future. Data breaches, identity theft, cyber-attack, and financial fraud are all on the rise. The vast collection of personal data has also diminished competition. And the targeting of internet users, based on detailed and secret profiling with opaque algorithms, threatens not only consumer &lt;a class=&quot;crunchbase-link&quot; href=&quot;https://www.crunchbase.com/organization/privacy/&quot; target=&quot;_blank&quot; data-type=&quot;organization&quot; data-entity=&quot;privacy&quot;&gt;privacy&lt;/a&gt; but also democratic institutions.”&lt;/p&gt;
&lt;p&gt;Zuckerberg caused confusion about Facebook’s intentions towards GDPR last week when he &lt;a href=&quot;https://techcrunch.com/2018/04/04/facebook-gdpr-wont-be-universal/&quot;&gt;refused to confirm&lt;/a&gt; whether the company would apply the same compliance measures for users in North America — suggesting domestic and Canadian Facebookers, whose data is processed in the US, rather than Ireland (where its international HQ is based), would be subject to lower privacy standards than all other users (whose data is processed within the EU) after May 25 when GDPR comes into force.&lt;/p&gt;
&lt;p&gt;In a subsequent &lt;a href=&quot;https://techcrunch.com/2018/04/04/zuckerberg-gdpr/&quot;&gt;conference call with reporters&lt;/a&gt;, Zuckerberg further fogged the issue by saying Facebook intends to “make all the same controls available everywhere, not just in Europe” — yet he went on to caveat that by adding: “Is it going to be exactly the same format? Probably not. We’ll need to figure out what makes sense in different markets with different laws in different places.”&lt;/p&gt;
&lt;p&gt;Privacy experts were quick to point out that “controls and settings” are just one component of the data protection regulation. If Facebook is truly going to apply GDPR universally it will need to give every Facebook user the same high privacy and data protection standards that GDPR mandates for EU citizens — such as by providing users with the right to view, amend and delete personal data it holds on them; and the right to obtain a copy of this personal data in a portable format.&lt;/p&gt;
&lt;p&gt;Facebook does currently provide some user data on request — but this is by no means comprehensive. For example it only provides an &lt;a href=&quot;https://techcrunch.com/2018/03/28/facebook-just-lost-another-user-new-zealands-privacy-commissioner/&quot;&gt;eight-week snapshot&lt;/a&gt; of information to users about which advertisers have told it they have a user’s consent to process their information.&lt;/p&gt;
&lt;p&gt;In denying a more fulsome fulfillment of what’s known in Europe as a ‘subject access request’, the company told one requester, Paul-Olivier Dehaye, the co-founder of PersonalData.IO, that it would involve “disproportionate effort” to fulfill his request — invoking an exception in Irish law in order to circumvent current EU privacy laws.&lt;/p&gt;
&lt;p&gt;“[Facebook] are really arguing ‘we are too big to comply with data protection law’,” Dehaye told a UK parliamentary committee &lt;a href=&quot;https://techcrunch.com/2018/03/28/facebook-just-lost-another-user-new-zealands-privacy-commissioner/&quot;&gt;last month&lt;/a&gt;, discussing how difficult it has been to get the company to divulge information it holds about him. “The costs would be too high for us. Which is mindboggling that they wouldn’t see the direction they’re going there. Do they really want to make that argument?”&lt;/p&gt;
&lt;p&gt;Whether that situation changes once GDPR is in force remains to be seen.&lt;/p&gt;
&lt;p&gt;The new framework at least introduces a regime of much larger penalties for privacy violations — beefing up enforcement with maximum fines of up to 4% of a company’s global annual turnover. So the legal risks of trying to circumvent EU data protection law will inflate substantially in just over a month.&lt;/p&gt;
&lt;p&gt;And Facebook has already made some changes ahead of GDPR coming into force (and likely to try to comply with the new standard) — &lt;a href=&quot;https://techcrunch.com/2018/03/28/facebook-will-cut-off-access-to-third-party-data-for-ad-targeting/&quot;&gt;announcing it’s shutting down a partnership&lt;/a&gt; with major offline and online data brokers, for example.&lt;/p&gt;
&lt;p&gt;“Consumer groups and privacy groups, human rights groups, civil rights groups will all probably be watching how GDPR is implemented,” Finn Lützow-Holm Myrstad tells TechCrunch. “And will be ready to probably go to court to establish that these are fundamental rights for European citizens at the moment. So we’re definitely going to pay attention.&lt;/p&gt;
&lt;p&gt;“But obviously we really want the industry to work with us and to take this seriously because if they don’t there will be a very negative spiral of court cases and a chilling effect for consumers because they will be afraid of using these services. And they will be caught in the middle because of the lack of options that they have when it comes to these services. And I don’t think that’s good for anyone. So we really hope that this is sign of change — real change — from Facebook.”&lt;/p&gt;
&lt;p&gt;The company remains under huge pressure following revelations about &lt;a href=&quot;https://techcrunch.com/2018/04/04/cambridge-analytica-87-million/&quot;&gt;how much Facebook user information&lt;/a&gt; was passed to a controversial political consultancy, Cambridge Analytica, by a developer using its platform to deploy a quiz app as a vehicle for harvesting personal data without most users’ knowledge or consent.&lt;/p&gt;
&lt;p&gt;Facebook has said as many as 87M users could have had their data passed to Cambridge Analytica as a result of them or their friends downloading the app in 2014.&lt;/p&gt;
&lt;p&gt;Zuckerberg is &lt;a href=&quot;https://techcrunch.com/2018/04/06/zuckerberg-will-also-testify-before-the-senate/&quot;&gt;due to give testimony&lt;/a&gt; on this and likely wider issues related to privacy and data protection on his platform to US politicians this week.&lt;/p&gt;
&lt;p&gt;One line of questioning might well focus on why Facebook has so studiously &lt;a href=&quot;https://techcrunch.com/2018/03/24/facebook-was-warned-about-app-permissions-in-2011/&quot;&gt;ignored years of warnings&lt;/a&gt; that it was not adequately locking down access to user data on its platform.&lt;/p&gt;
&lt;p&gt;The Norwegian Consumer Council actually filed a complaint about Facebook app permissions all the way back in &lt;a href=&quot;https://fil.forbrukerradet.no/wp-content/uploads/2011/08/20100510-ncc-complaint-facebook-zynga-.pdf&quot;&gt;2010&lt;/a&gt;, writing presciently then: “Third-party applications should only be given access to the information they need in order to function. Facebook should not be able to renounce responsibility for the way in which third parties collect, store or use personal data. As a facilitator and operator Facebook must take direct responsibility for the applications available on the platform.”&lt;/p&gt;
&lt;p&gt;Myrstad says Facebook’s historical response to these sort of privacy complaints has been “sadly very, very little”.&lt;/p&gt;
&lt;p&gt;On the contrary, he says the company has made it “&lt;a href=&quot;https://techcrunch.com/2018/03/28/it-was-not-consent-it-was-concealment/&quot;&gt;really, really difficult&lt;/a&gt; to opt out of their tracking, their profiling”. He also describes Facebook’s default settings as “a nightmare” for people to understand. In terms of GDPR compliance, he says he believes Facebook will need to make changes to their business model and alter default settings — at very least for users whose data gets processed via Facebook Ireland.&lt;/p&gt;
&lt;p&gt;“They will definitely need to have much better consent mechanisms than they do today. Much less take it or leave it,” says Myrstad. “I think there will be a discussion also in Europe, and I think it’s not yet written in stone yet how this will turn out, but we definitely also think that the amount of tracking that Facebook does by default on other websites will need an actual explicit consent — which there is not today. It’s not possible to opt out of the tracking.&lt;/p&gt;
&lt;p&gt;“You can opt out of behavioral advertising but that’s not the same as opting out from tracking. And I think the way they do that today is not in line with GDPR… I think they will actually struggle [to comply]. They’re already struggling under current law in Europe. So they will need to make some fundamental changes to their business model.”&lt;/p&gt;
&lt;p&gt;At the time of writing Facebook had not responded to a request for comment.&lt;/p&gt;
</description>
<pubDate>Mon, 09 Apr 2018 14:29:42 +0000</pubDate>
<dc:creator>wpasc</dc:creator>
<og:title>Facebook urged to make GDPR its “baseline standard” globally</og:title>
<og:description>Facebook is facing calls from consumer groups to make the European Union’s incoming GDPR data protection framework the “baseline standard for all Facebook services”. The update to the bloc’s data protection framework is intended to strengthen consumers’ control over ho…</og:description>
<og:image>https://techcrunch.com/wp-content/uploads/2015/08/368912557_2fc44d3709_b.jpg?w=596</og:image>
<og:url>http://social.techcrunch.com/2018/04/09/facebook-urged-to-make-gdpr-its-baseline-standard-globally/</og:url>
<og:type>article</og:type>
<dc:language>en-US</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://techcrunch.com/2018/04/09/facebook-urged-to-make-gdpr-its-baseline-standard-globally/</dc:identifier>
</item>
<item>
<title>Reverse Engineering WhatsApp Web</title>
<link>https://github.com/sigalor/whatsapp-web-reveng/blob/master/README.md</link>
<guid isPermaLink="true" >https://github.com/sigalor/whatsapp-web-reveng/blob/master/README.md</guid>
<description>
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;This project intends to provide a complete description and re-implementation of the WhatsApp Web API, which will eventually lead to a custom client. WhatsApp Web internally works using WebSockets; this project does as well.&lt;/p&gt;
&lt;h2&gt;Trying it out&lt;/h2&gt;
&lt;p&gt;Before you can run the application, make sure that you have the following software installed:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Node.js (at least version 8, as the &lt;code&gt;async&lt;/code&gt; &lt;code&gt;await&lt;/code&gt; syntax is used)&lt;/li&gt;
&lt;li&gt;the CSS preprocessor &lt;a href=&quot;http://sass-lang.com/&quot; rel=&quot;nofollow&quot;&gt;Sass&lt;/a&gt; (which you previously need Ruby for)&lt;/li&gt;
&lt;li&gt;Python 2.7 with the following &lt;code&gt;pip&lt;/code&gt; packages installed:
&lt;ul&gt;&lt;li&gt;&lt;code&gt;websocket-client&lt;/code&gt; and &lt;code&gt;git+https://github.com/dpallot/simple-websocket-server.git&lt;/code&gt; for acting as WebSocket server and client&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curve25519-donna&lt;/code&gt; and &lt;code&gt;pycrypto&lt;/code&gt; for the encryption stuff&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pyqrcode&lt;/code&gt; for QR code generation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Before starting the application for the first time, run &lt;code&gt;npm install&lt;/code&gt; to install all Node and &lt;code&gt;pip install -r requirements&lt;/code&gt; for all Python dependencies.&lt;/p&gt;
&lt;p&gt;Lastly, to finally launch it, just run &lt;code&gt;npm start&lt;/code&gt;. Using fancy &lt;code&gt;concurrently&lt;/code&gt; and &lt;code&gt;nodemon&lt;/code&gt; magic, all three local components will be started after each other and when you edit a file, the changed module will automatically restart to apply the changes.&lt;/p&gt;
&lt;h2&gt;Application architecture&lt;/h2&gt;
&lt;p&gt;The project is organized in the following way. Note the used ports and make sure that they are not in use elsewhere before starting the application. &lt;a target=&quot;_blank&quot; href=&quot;https://raw.githubusercontent.com/sigalor/whatsapp-web-reveng/master/doc/img/app-architecture1000.png&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sigalor/whatsapp-web-reveng/master/doc/img/app-architecture1000.png&quot; alt=&quot;whatsapp-web-reveng Application architecture&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Login and encryption details&lt;/h2&gt;
&lt;p&gt;WhatsApp Web encrypts the data using several different algorithms. These include &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot; rel=&quot;nofollow&quot;&gt;AES 256 ECB&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Curve25519&quot; rel=&quot;nofollow&quot;&gt;Curve25519&lt;/a&gt; as Diffie-Hellman key agreement scheme, &lt;a href=&quot;https://en.wikipedia.org/wiki/HKDF&quot; rel=&quot;nofollow&quot;&gt;HKDF&lt;/a&gt; for generating the extended shared secret and &lt;a href=&quot;https://en.wikipedia.org/wiki/Hash-based_message_authentication_code&quot; rel=&quot;nofollow&quot;&gt;HMAC&lt;/a&gt; with SHA256.&lt;/p&gt;
&lt;p&gt;Starting the WhatsApp Web session happens by just connecting to one of its websocket servers at &lt;code&gt;wss://w[1-8].web.whatsapp.com/ws&lt;/code&gt; (&lt;code&gt;wss://&lt;/code&gt; means that the websocket connection is secure; &lt;code&gt;w[1-8]&lt;/code&gt; means that any number between 1 and 8 can follow the &lt;code&gt;w&lt;/code&gt;). Also make sure that, when establishing the connection, the HTTP header &lt;code&gt;Origin: https://web.whatsapp.com&lt;/code&gt; is set, otherwise the connection will be rejected.&lt;/p&gt;
&lt;h3&gt;Messages&lt;/h3&gt;
&lt;p&gt;When you send messages to a WhatsApp Web websocket, they need to be in a specific format. It is quite simple and looks like &lt;code&gt;messageTag,JSON&lt;/code&gt;, e.g. &lt;code&gt;1515590796,[&quot;data&quot;,123]&lt;/code&gt;. Note that apparently the message tag can be anything. This application mostly uses the current timestamp as tag, just to be a bit unique. WhatsApp itself often uses message tags like &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;1234.--0&lt;/code&gt; or something like that. Obviously the message tag may not contain a comma. Additionally, JSON &lt;em&gt;objects&lt;/em&gt; are possible as well as payload.&lt;/p&gt;
&lt;h3&gt;Logging in&lt;/h3&gt;
&lt;p&gt;To log in at an open websocket, follow these steps:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Generate your own &lt;code&gt;clientId&lt;/code&gt;, which needs to be 16 base64-encoded bytes (i.e. 25 characters). This application just uses 16 random bytes, i.e. &lt;code&gt;base64.b64encode(os.urandom(16))&lt;/code&gt; in Python.&lt;/li&gt;
&lt;li&gt;Decide for a tag for your message, which is more or less arbitrary (see above). This application uses the current timestamp (in seconds) for that. Remember this tag for later.&lt;/li&gt;
&lt;li&gt;The message you send to the websocket looks like this: &lt;code&gt;messageTag,[&quot;admin&quot;,&quot;init&quot;,[0,2,7314],[&quot;Long browser description&quot;,&quot;ShortBrowserDesc&quot;],&quot;clientId&quot;,true]&lt;/code&gt;.
&lt;ul&gt;&lt;li&gt;Obviously, you need to replace &lt;code&gt;messageTag&lt;/code&gt; and &lt;code&gt;clientId&lt;/code&gt; by the values you chose before&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;[0,2,7314]&lt;/code&gt; part specifies the current WhatsApp Web version. The last value changes frequently. It should be quite backwards-compatible though.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;Long browser description&quot;&lt;/code&gt; is an arbitrary string that will be shown in the WhatsApp app in the list of registered WhatsApp Web clients after you scan the QR code.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;ShortBrowserDesc&quot;&lt;/code&gt; has not been observed anywhere yet but is arbitrary as well.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;After a few moments, your websocket will receive a message in the specified format with the message tag &lt;em&gt;you chose in step 2&lt;/em&gt;. The JSON object of this message has the following attributes:
&lt;ul&gt;&lt;li&gt;&lt;code&gt;status&lt;/code&gt;: should be 200&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ref&lt;/code&gt;: in the application, this is treated as the server ID; important for the QR generation, see below&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ttl&lt;/code&gt;: is 20000, maybe the time after the QR code becomes invalid&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update&lt;/code&gt;: a boolean flag&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curr&lt;/code&gt;: the current WhatsApp Web version, e.g. &lt;code&gt;0.2.7314&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time&lt;/code&gt;: the timestamp the server responded at, as floating-point milliseconds, e.g. &lt;code&gt;1515592039037.0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;QR code generation&lt;/h3&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;Generate your own private key with Curve25519, e.g. &lt;code&gt;curve25519.Private()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Get the public key from your private key, e.g. &lt;code&gt;privateKey.get_public()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Obtain the string later encoded by the QR code by concatenating the following values with a comma:
&lt;ul&gt;&lt;li&gt;the server ID, i.e. the &lt;code&gt;ref&lt;/code&gt; attribute from step 4&lt;/li&gt;
&lt;li&gt;the base64-encoded version of your public key, i.e. &lt;code&gt;base64.b64encode(publicKey.serialize())&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;your client ID&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Turn this string into an image (e.g. using &lt;code&gt;pyqrcode&lt;/code&gt;) and scan it using the WhatsApp app.&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;After scanning the QR code&lt;/h3&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;Immediately after you scan the QR code, the websocket receives several important JSON messages that build up the encryption details. These use the specified message format and have a JSON &lt;em&gt;array&lt;/em&gt; as payload. Their message tag has no special meaning. The first entry of the JSON array has one of the following values:
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Conn&lt;/code&gt;: array contains JSON object as second element with connection information containing the following attributes and many more:
&lt;ul&gt;&lt;li&gt;&lt;code&gt;battery&lt;/code&gt;: the current battery percentage of your phone&lt;/li&gt;
&lt;li&gt;&lt;code&gt;browserToken&lt;/code&gt; (could be important, but not used by the application yet)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clientToken&lt;/code&gt; (could be important, but not used by the application yet)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;phone&lt;/code&gt;: an object with detailed information about your phone, e.g. &lt;code&gt;device_manufacturer&lt;/code&gt;, &lt;code&gt;device_model&lt;/code&gt;, &lt;code&gt;os_build_number&lt;/code&gt;, &lt;code&gt;os_version&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;platform&lt;/code&gt;: your phone OS, e.g. &lt;code&gt;android&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pushname&lt;/code&gt;: the name of yours you provided WhatsApp&lt;/li&gt;
&lt;li&gt;&lt;code&gt;secret&lt;/code&gt; (remember this!)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;serverToken&lt;/code&gt; (could be important, but not used by the application yet)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wid&lt;/code&gt;: your phone number in the chat identification format (see below)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stream&lt;/code&gt;: array has four elements in total, so the entire payload is like &lt;code&gt;[&quot;Stream&quot;,&quot;update&quot;,false,&quot;0.2.7314&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Props&lt;/code&gt;: array contains JSON object as second element with several properties like &lt;code&gt;imageMaxKBytes&lt;/code&gt; (1024), &lt;code&gt;maxParticipants&lt;/code&gt; (257), &lt;code&gt;videoMaxEdge&lt;/code&gt; (960) and others&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;Key generation&lt;/h3&gt;
&lt;ol start=&quot;10&quot;&gt;&lt;li&gt;You are now ready for generating the final encryption keys. Start by decoding the &lt;code&gt;secret&lt;/code&gt; from &lt;code&gt;Conn&lt;/code&gt; as base64 and storing it as &lt;code&gt;secret&lt;/code&gt;. This decoded secret will be 144 bytes long.&lt;/li&gt;
&lt;li&gt;Take the &lt;em&gt;first 32 bytes&lt;/em&gt; of the decoded secret and use it as a public key. Together with your private key, generate a shared key out of it and call it &lt;code&gt;sharedSecret&lt;/code&gt;. The application does it using &lt;code&gt;privateKey.get_shared_key(curve25519.Public(secret[:32]), lambda a:a)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Use a key containing 32 null bytes to encode the shared secret using HMAC SHA256. Take this value and extend it to 80 bytes using HKDF. Call this value &lt;code&gt;sharedSecretExpanded&lt;/code&gt;. This is done with &lt;code&gt;HKDF(HmacSha256(&quot;\0&quot;*32, sharedSecret), 80)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;This step is optional, it validates the data provided by the server. The method is called &lt;em&gt;HMAC validation&lt;/em&gt;. Do it by first calculating &lt;code&gt;HmacSha256(sharedSecretExpanded[32:64], secret[:32] + secret[64:])&lt;/code&gt;. Compare this value to &lt;code&gt;secret[32:64]&lt;/code&gt;. If they are not equal, abort the login.&lt;/li&gt;
&lt;li&gt;You now have the encrypted keys: store &lt;code&gt;sharedSecretExpanded[64:] + secret[64:]&lt;/code&gt; as &lt;code&gt;keysEncrypted&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The encrypted keys now need to be decrypted using AES with &lt;code&gt;sharedSecretExpanded[:32]&lt;/code&gt; as key, i.e. store &lt;code&gt;AESDecrypt(sharedSecretExpanded[:32], keysEncrypted)&lt;/code&gt; as &lt;code&gt;keysDecrypted&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;keysDecrypted&lt;/code&gt; variable is 64 bytes long and contains two keys, each 32 bytes long. The &lt;code&gt;encKey&lt;/code&gt; is used for decrypting binary messages sent to you by the WhatsApp Web server or encrypting binary messages you send to the server. The &lt;code&gt;macKey&lt;/code&gt; is needed to validate the messages sent to you:
&lt;ul&gt;&lt;li&gt;&lt;code&gt;encKey&lt;/code&gt;: &lt;code&gt;keysDecrypted[:32]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;macKey&lt;/code&gt;: &lt;code&gt;keysDecrypted[32:64]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;Validating and decrypting messages&lt;/h3&gt;
&lt;p&gt;Now that you have the two keys, validating and decrypting messages the server sent to you is quite easy. Note that this is only needed for &lt;em&gt;binary&lt;/em&gt; messages, all JSON you receive stays plain. The binary messages always have 32 bytes at the beginning that specify the HMAC checksum.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Validate the message by hashing the actual message content with the &lt;code&gt;macKey&lt;/code&gt; (here &lt;code&gt;messageContent&lt;/code&gt; is the &lt;em&gt;entire&lt;/em&gt; binary message): &lt;code&gt;HmacSha256(macKey, messageContent[32:])&lt;/code&gt;. If this value is not equal to &lt;code&gt;messageContent[:32]&lt;/code&gt;, the message sent to you by the server is invalid and should be discarded.&lt;/li&gt;
&lt;li&gt;Decrypt the message content using AES and the &lt;code&gt;encKey&lt;/code&gt;: &lt;code&gt;AESDecrypt(encKey, messageContent[32:])&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;The data you get in the final step has a binary format which is described in the following. Even though it's binary, you can still see several strings in it, especially the content of messages you sent is quite obvious there.&lt;/p&gt;
&lt;h2&gt;Binary message format&lt;/h2&gt;
&lt;h3&gt;Binary decoding&lt;/h3&gt;
&lt;p&gt;The Python script &lt;code&gt;backend/decoder.py&lt;/code&gt; implements the &lt;code&gt;MessageParser&lt;/code&gt; class. It is able to create a JSON structure out of binary data in which the data is still organized in a rather messy way. The section about Node Handling below will discuss how the nodes are reorganized afterwards.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MessageParser&lt;/code&gt; initially just needs some data and then processes it byte by byte, i.e. as a stream. It has a couple of constants and a lot of methods which all build on each other.&lt;/p&gt;
&lt;h4&gt;Constants&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;Tags&lt;/em&gt; with their respective integer values
&lt;ul&gt;&lt;li&gt;&lt;em&gt;LIST_EMPTY&lt;/em&gt;: 0&lt;/li&gt;
&lt;li&gt;&lt;em&gt;STREAM_8&lt;/em&gt;: 2&lt;/li&gt;
&lt;li&gt;&lt;em&gt;DICTIONARY_0&lt;/em&gt;: 236&lt;/li&gt;
&lt;li&gt;&lt;em&gt;DICTIONARY_1&lt;/em&gt;: 237&lt;/li&gt;
&lt;li&gt;&lt;em&gt;DICTIONARY_2&lt;/em&gt;: 238&lt;/li&gt;
&lt;li&gt;&lt;em&gt;DICTIONARY_3&lt;/em&gt;: 239&lt;/li&gt;
&lt;li&gt;&lt;em&gt;LIST_8&lt;/em&gt;: 248&lt;/li&gt;
&lt;li&gt;&lt;em&gt;LIST_16&lt;/em&gt;: 249&lt;/li&gt;
&lt;li&gt;&lt;em&gt;JID_PAIR&lt;/em&gt;: 250&lt;/li&gt;
&lt;li&gt;&lt;em&gt;HEX_8&lt;/em&gt;: 251&lt;/li&gt;
&lt;li&gt;&lt;em&gt;BINARY_8&lt;/em&gt;: 252&lt;/li&gt;
&lt;li&gt;&lt;em&gt;BINARY_20&lt;/em&gt;: 253&lt;/li&gt;
&lt;li&gt;&lt;em&gt;BINARY_32&lt;/em&gt;: 254&lt;/li&gt;
&lt;li&gt;&lt;em&gt;NIBBLE_8&lt;/em&gt;: 255&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Tokens&lt;/em&gt; are a long list of 151 strings in which the indices matter:
&lt;ul&gt;&lt;li&gt;&lt;code&gt;[None,None,None,&quot;200&quot;,&quot;400&quot;,&quot;404&quot;,&quot;500&quot;,&quot;501&quot;,&quot;502&quot;,&quot;action&quot;,&quot;add&quot;, &quot;after&quot;,&quot;archive&quot;,&quot;author&quot;,&quot;available&quot;,&quot;battery&quot;,&quot;before&quot;,&quot;body&quot;, &quot;broadcast&quot;,&quot;chat&quot;,&quot;clear&quot;,&quot;code&quot;,&quot;composing&quot;,&quot;contacts&quot;,&quot;count&quot;, &quot;create&quot;,&quot;debug&quot;,&quot;delete&quot;,&quot;demote&quot;,&quot;duplicate&quot;,&quot;encoding&quot;,&quot;error&quot;, &quot;false&quot;,&quot;filehash&quot;,&quot;from&quot;,&quot;g.us&quot;,&quot;group&quot;,&quot;groups_v2&quot;,&quot;height&quot;,&quot;id&quot;, &quot;image&quot;,&quot;in&quot;,&quot;index&quot;,&quot;invis&quot;,&quot;item&quot;,&quot;jid&quot;,&quot;kind&quot;,&quot;last&quot;,&quot;leave&quot;, &quot;live&quot;,&quot;log&quot;,&quot;media&quot;,&quot;message&quot;,&quot;mimetype&quot;,&quot;missing&quot;,&quot;modify&quot;,&quot;name&quot;, &quot;notification&quot;,&quot;notify&quot;,&quot;out&quot;,&quot;owner&quot;,&quot;participant&quot;,&quot;paused&quot;, &quot;picture&quot;,&quot;played&quot;,&quot;presence&quot;,&quot;preview&quot;,&quot;promote&quot;,&quot;query&quot;,&quot;raw&quot;, &quot;read&quot;,&quot;receipt&quot;,&quot;received&quot;,&quot;recipient&quot;,&quot;recording&quot;,&quot;relay&quot;, &quot;remove&quot;,&quot;response&quot;,&quot;resume&quot;,&quot;retry&quot;,&quot;s.whatsapp.net&quot;,&quot;seconds&quot;, &quot;set&quot;,&quot;size&quot;,&quot;status&quot;,&quot;subject&quot;,&quot;subscribe&quot;,&quot;t&quot;,&quot;text&quot;,&quot;to&quot;,&quot;true&quot;, &quot;type&quot;,&quot;unarchive&quot;,&quot;unavailable&quot;,&quot;url&quot;,&quot;user&quot;,&quot;value&quot;,&quot;web&quot;,&quot;width&quot;, &quot;mute&quot;,&quot;read_only&quot;,&quot;admin&quot;,&quot;creator&quot;,&quot;short&quot;,&quot;update&quot;,&quot;powersave&quot;, &quot;checksum&quot;,&quot;epoch&quot;,&quot;block&quot;,&quot;previous&quot;,&quot;409&quot;,&quot;replaced&quot;,&quot;reason&quot;, &quot;spam&quot;,&quot;modify_tag&quot;,&quot;message_info&quot;,&quot;delivery&quot;,&quot;emoji&quot;,&quot;title&quot;, &quot;description&quot;,&quot;canonical-url&quot;,&quot;matched-text&quot;,&quot;star&quot;,&quot;unstar&quot;, &quot;media_key&quot;,&quot;filename&quot;,&quot;identity&quot;,&quot;unread&quot;,&quot;page&quot;,&quot;page_count&quot;, &quot;search&quot;,&quot;media_message&quot;,&quot;security&quot;,&quot;call_log&quot;,&quot;profile&quot;,&quot;ciphertext&quot;, &quot;invite&quot;,&quot;gif&quot;,&quot;vcard&quot;,&quot;frequent&quot;,&quot;privacy&quot;,&quot;blacklist&quot;,&quot;whitelist&quot;, &quot;verify&quot;,&quot;location&quot;,&quot;document&quot;,&quot;elapsed&quot;,&quot;revoke_invite&quot;,&quot;expiration&quot;, &quot;unsubscribe&quot;,&quot;disable&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;Number reformatting&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;Unpacking nibbles&lt;/em&gt;: Returns the ASCII representation for numbers between 0 and 9. Returns &lt;code&gt;-&lt;/code&gt; for 10, &lt;code&gt;.&lt;/code&gt; for 11 and &lt;code&gt;\0&lt;/code&gt; for 15.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Unpacking hex values&lt;/em&gt;: Returns the ASCII representation for numbers between 0 and 9 or letters between A and F (i.e. uppercase) for numbers between 10 and 15.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Unpacking bytes&lt;/em&gt;: Expects a tag as an additional parameter, namely &lt;em&gt;NIBBLE_8&lt;/em&gt; or &lt;em&gt;HEX_8&lt;/em&gt;. Unpacks a nibble or hex value accordingly.&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;Number formats&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;Byte&lt;/em&gt;: A plain ol' byte.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Integer with N bytes&lt;/em&gt;: Reads N bytes and builds a number out of them. Can be little or big endian; if not specified otherwise, big endian is used. Note that no negative values are possible.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Int16&lt;/em&gt;: An integer with two bytes, read using &lt;em&gt;Integer with N bytes&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Int20&lt;/em&gt;: Consumes three bytes and constructs an integer using the last four bits of the first byte and the entire second and third byte. Is therefore always big endian.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Int32&lt;/em&gt;: An integer with four bytes, read using &lt;em&gt;Integer with N bytes&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Int64&lt;/em&gt;: An integer with eight bytes, read using &lt;em&gt;Integer with N bytes&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Packed8&lt;/em&gt;: Expects a tag as an additional parameter, namely &lt;em&gt;NIBBLE_8&lt;/em&gt; or &lt;em&gt;HEX_8&lt;/em&gt;. Returns a string.
&lt;ul&gt;&lt;li&gt;First reads a byte &lt;code&gt;n&lt;/code&gt; and does the following &lt;code&gt;n&amp;amp;127&lt;/code&gt; many times: Reads a byte &lt;code&gt;l&lt;/code&gt; and for each nibble, adds the result of its &lt;em&gt;unpacked version&lt;/em&gt; to the return value (using &lt;em&gt;unpacking bytes&lt;/em&gt; with the given tag). Most significant nibble first.&lt;/li&gt;
&lt;li&gt;If the most significant bit of &lt;code&gt;n&lt;/code&gt; was set, removes the last character of the return value.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;Variable length integers&lt;/h4&gt;
&lt;p&gt;In contrast to the previous number formats, reading a &lt;em&gt;variable length integer&lt;/em&gt; (VLI) does &lt;em&gt;not&lt;/em&gt; change the current data pointer.&lt;/p&gt;
&lt;p&gt;First, the length &lt;code&gt;l&lt;/code&gt; of the VLI is read by reading bytes until a byte with the most significant bit set is encountered, but at most 10 bytes.&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Ranged variable length integers&lt;/em&gt; expect a minimum and a maximum value. If the read &lt;em&gt;variable length integer&lt;/em&gt; is less then the minimum or greater than or equal to the maximum, throw an error.&lt;/p&gt;
&lt;h4&gt;Helper methods&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;Read bytes&lt;/em&gt;: Reads and returns the specified number of bytes.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Check for list tag&lt;/em&gt;: Expects a tag as parameter and returns true if the tag is &lt;code&gt;LIST_EMPTY&lt;/code&gt;, &lt;code&gt;LIST_8&lt;/code&gt; or &lt;code&gt;LIST_16&lt;/code&gt; (i.e. 0, 248 or 249).&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Read list size&lt;/em&gt;: Expects a list tag as parameter. Returns 0 for &lt;code&gt;LIST_EMPTY&lt;/code&gt;, returns a read byte for &lt;code&gt;LIST_8&lt;/code&gt; or a read &lt;em&gt;Int16&lt;/em&gt; for &lt;code&gt;LIST_16&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Read a string from characters&lt;/em&gt;: Expects the string length as parameter, reads this many bytes and returns them as a string.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Get a token&lt;/em&gt;: Expects an index to the array of &lt;em&gt;Tokens&lt;/em&gt;, and returns the respective string.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Get a double token&lt;/em&gt;: Expects two integers &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and gets the token at index &lt;code&gt;a*256+b&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;Strings&lt;/h4&gt;
&lt;p&gt;Reading a string needs a &lt;em&gt;tag&lt;/em&gt; as parameter. Depending on this tag, different data is read.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;If the tag is between 3 and 235, the &lt;em&gt;token&lt;/em&gt; (i.e. a string) of this tag is got. If the token is &lt;code&gt;&quot;s.whatsapp.net&quot;&lt;/code&gt;, &lt;code&gt;&quot;c.us&quot;&lt;/code&gt; is returned instead, otherwise the token is returned as is.&lt;/li&gt;
&lt;li&gt;If the tag is between &lt;em&gt;DICTIONARY_0&lt;/em&gt; and &lt;em&gt;DICTIONARY_3&lt;/em&gt;, a &lt;em&gt;double token&lt;/em&gt; is returned, with &lt;code&gt;tag-DICTIONARY_0&lt;/code&gt; as first and a read byte as second parameter.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;LIST_EMPTY&lt;/em&gt;: Nothing is returned (e.g. &lt;code&gt;None&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;em&gt;BINARY_8&lt;/em&gt;: A byte is read which is then used to &lt;em&gt;read a string from characters&lt;/em&gt; with this length.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;BINARY_20&lt;/em&gt;: An &lt;em&gt;Int20&lt;/em&gt; is read which is then used to &lt;em&gt;read a string from characters&lt;/em&gt; with this length.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;BINARY_32&lt;/em&gt;: An &lt;em&gt;Int32&lt;/em&gt; is read which is then used to &lt;em&gt;read a string from characters&lt;/em&gt; with this length.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;JID_PAIR&lt;/em&gt;
&lt;ul&gt;&lt;li&gt;First, a byte is read which is then used to &lt;em&gt;read a string&lt;/em&gt; &lt;code&gt;i&lt;/code&gt; with this tag.&lt;/li&gt;
&lt;li&gt;Second, another byte is read which is then used to &lt;em&gt;read a string&lt;/em&gt; &lt;code&gt;j&lt;/code&gt; with this tag.&lt;/li&gt;
&lt;li&gt;Finally, &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; are joined together with an &lt;code&gt;@&lt;/code&gt; sign and the result is returned.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;NIBBLE_8&lt;/em&gt; or &lt;em&gt;HEX_8&lt;/em&gt;: A &lt;em&gt;Packed8&lt;/em&gt; with this tag is returned.&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;Attribute lists&lt;/h4&gt;
&lt;p&gt;Reading an attribute list needs the number of attributes to read as parameter. An attribute list is always a JSON object. For each attribute read, the following steps are executed for getting key-value pairs (exactly in this order!):&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;Key&lt;/em&gt;: A byte is read which is then used to &lt;em&gt;read a string&lt;/em&gt; with this tag.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Value&lt;/em&gt;: A byte is read which is then used to &lt;em&gt;read a string&lt;/em&gt; with this tag.&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;Nodes&lt;/h4&gt;
&lt;p&gt;A node always consists of a JSON array with exactly three entries: description, attributes and content. The following steps are needed to read a node:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;A &lt;em&gt;list size&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; is read by using a read byte as the tag. The list size 0 is invalid.&lt;/li&gt;
&lt;li&gt;The description tag is read as a byte. The value 2 is invalid for this tag. The description string &lt;code&gt;descr&lt;/code&gt; is then obtained by &lt;em&gt;reading a string&lt;/em&gt; with this tag.&lt;/li&gt;
&lt;li&gt;The attributes object &lt;code&gt;attrs&lt;/code&gt; is read by &lt;em&gt;reading an attributes object&lt;/em&gt; with length &lt;code&gt;(a-2 + a%2) &amp;gt;&amp;gt; 1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;a&lt;/code&gt; was odd, this node does not have any content, i.e. &lt;code&gt;[descr, attrs, None]&lt;/code&gt; is returned.&lt;/li&gt;
&lt;li&gt;For getting the node's content, first a byte, i.e. a tag is read. Depending on this tag, different types of content emerge:
&lt;ul&gt;&lt;li&gt;If the tag is a &lt;em&gt;list tag&lt;/em&gt;, a &lt;em&gt;list is read&lt;/em&gt; using this tag (see below for lists).&lt;/li&gt;
&lt;li&gt;&lt;em&gt;BINARY_8&lt;/em&gt;: A byte is read which is then used as length for &lt;em&gt;reading bytes&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;BINARY_20&lt;/em&gt;: An &lt;em&gt;Int20&lt;/em&gt; is read which is then used as length for &lt;em&gt;reading bytes&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;BINARY_32&lt;/em&gt;: An &lt;em&gt;Int32&lt;/em&gt; is read which is then used as length for &lt;em&gt;reading bytes&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;If the tag is something else, a &lt;em&gt;string is read&lt;/em&gt; using this tag.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Eventually, &lt;code&gt;[descr, attrs, content]&lt;/code&gt; is returned.&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;Lists&lt;/h4&gt;
&lt;p&gt;Reading a list requires a &lt;em&gt;list tag&lt;/em&gt; (i.e. &lt;em&gt;LIST_EMPTY&lt;/em&gt;, &lt;em&gt;LIST_8&lt;/em&gt; or &lt;em&gt;LIST_16&lt;/em&gt;). The length of the list is then obtained by &lt;em&gt;reading a list size&lt;/em&gt; using this tag. For each list entry, a &lt;em&gt;node is read&lt;/em&gt;.&lt;/p&gt;
&lt;h3&gt;Node Handling&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2&gt;WhatsApp Web API&lt;/h2&gt;
&lt;p&gt;WhatsApp Web itself has an interesting API as well. You can even try it out directly in your browser. Just log in at the normal &lt;a href=&quot;https://web.whatsapp.com/&quot; rel=&quot;nofollow&quot;&gt;https://web.whatsapp.com/&lt;/a&gt;, then open the browser development console. Now enter something like the following (see below for details on the chat identification):&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;window.Store.Wap.profilePicFind(&quot;49123456789@c.us&quot;).then(res =&amp;gt; console.log(res));&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;window.Store.Wap.lastseenFind(&quot;49123456789@c.us&quot;).then(res =&amp;gt; console.log(res));&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;window.Store.Wap.statusFind(&quot;49123456789@c.us&quot;).then(res =&amp;gt; console.log(res));&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Using the amazing Chrome developer console, you can see that &lt;code&gt;window.Store.Wap&lt;/code&gt; contains a lot of other very interesting functions. Many of them return JavaScript promises. When you click on the &lt;em&gt;Network&lt;/em&gt; tab and then on &lt;em&gt;WS&lt;/em&gt; (maybe you need to reload the site first), you can look at all the communication between WhatsApp Web and its servers.&lt;/p&gt;
&lt;h3&gt;Chat identification&lt;/h3&gt;
&lt;p&gt;The WhatsApp Web API uses the following formats to identify chats with individual users and groups of multiple users.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Chats&lt;/strong&gt;: &lt;code&gt;[country code][number]@c.us&lt;/code&gt;, e.g. &lt;strong&gt;&lt;code&gt;49123456789@c.us&lt;/code&gt;&lt;/strong&gt; when you are from Germany and your phone number is &lt;code&gt;0123 456789&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Groups&lt;/strong&gt;: &lt;code&gt;[phone number of group creator]-[timestamp of group creation]@g.us&lt;/code&gt;, e.g. &lt;strong&gt;&lt;code&gt;49123456789-1509911919@g.us&lt;/code&gt;&lt;/strong&gt; for the group that &lt;code&gt;49123456789@c.us&lt;/code&gt; created on November 5 2017.&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;WebSocket messages&lt;/h3&gt;
&lt;p&gt;There are two types of WebSocket messages that are exchanged between server and client. On the one hand, plain JSON that is rather unambiguous (especially for the API calls above), on the other hand encrypted binary messages.&lt;/p&gt;
&lt;p&gt;Unfortunately, these binary ones cannot be looked at using the Chrome developer tools. Additionally, the Python backend, that of course also receives these messages, needs to decrypt them, as they contain encrypted data. The section about encryption details discusses how it can be decrypted.&lt;/p&gt;
&lt;h2&gt;Tasks&lt;/h2&gt;
&lt;h3&gt;Backend&lt;/h3&gt;
&lt;h3&gt;Web frontend&lt;/h3&gt;
&lt;h3&gt;Documentation&lt;/h3&gt;
&lt;h2&gt;Terms and conditions&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;You will &lt;em&gt;not&lt;/em&gt; use this software for marketing purposes (spam, massive sending...). We will not give support to anyone with such intents.&lt;/li&gt;
&lt;li&gt;We reserve the right to block any user of this repository that does not meet these conditions.&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Legal&lt;/h3&gt;
&lt;p&gt;This code is in no way affiliated with, authorized, maintained, sponsored or endorsed by WhatsApp or any of its affiliates or subsidiaries. This is an independent and unofficial software. Use at your own risk.&lt;/p&gt;
&lt;h3&gt;Cryptography Notice&lt;/h3&gt;
&lt;p&gt;This distribution includes cryptographic software. The country in which you currently reside may have restrictions on the import, possession, use, and/or re-export to another country, of encryption software. BEFORE using any encryption software, please check your country's laws, regulations and policies concerning the import, possession, or use, and re-export of encryption software, to see if this is permitted. See &lt;a href=&quot;http://www.wassenaar.org/&quot; rel=&quot;nofollow&quot;&gt;http://www.wassenaar.org/&lt;/a&gt; for more information.&lt;/p&gt;
&lt;p&gt;The U.S. Government Department of Commerce, Bureau of Industry and Security (BIS), has classified this software as Export Commodity Control Number (ECCN) 5D002.C.1, which includes information security software using or performing cryptographic functions with asymmetric algorithms. The form and manner of this distribution makes it eligible for export under the License Exception ENC Technology Software Unrestricted (TSU) exception (see the BIS Export Administration Regulations, Section 740.13) for both object code and source code.&lt;/p&gt;
</description>
<pubDate>Mon, 09 Apr 2018 14:23:53 +0000</pubDate>
<dc:creator>wjh_</dc:creator>
<og:image>https://avatars0.githubusercontent.com/u/12279340?s=400&amp;v=4</og:image>
<og:type>object</og:type>
<og:title>sigalor/whatsapp-web-reveng</og:title>
<og:url>https://github.com/sigalor/whatsapp-web-reveng</og:url>
<og:description>whatsapp-web-reveng - Reverse engineering WhatsApp Web.</og:description>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://github.com/sigalor/whatsapp-web-reveng/blob/master/README.md</dc:identifier>
</item>
<item>
<title>Show HN: Wey – A fast, open-source Slack desktop app</title>
<link>https://github.com/yue/wey</link>
<guid isPermaLink="true" >https://github.com/yue/wey</guid>
<description>&lt;h3&gt;README.md&lt;/h3&gt;
&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;text&quot;&gt;
&lt;p&gt;Fast open source Slack desktop app, written in Node.js with native UI powered by &lt;a href=&quot;https://github.com/yue/yue&quot;&gt;the Yue library&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Do not use this for work, you might miss important messages due to bugs and missing features.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Screenshots&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;macOS&lt;/th&gt;
&lt;th&gt;Linux&lt;/th&gt;
&lt;th&gt;Windows&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://user-images.githubusercontent.com/639601/38463114-178afd9e-3b2e-11e8-9650-09b5d981523b.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/639601/38463114-178afd9e-3b2e-11e8-9650-09b5d981523b.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://user-images.githubusercontent.com/639601/38463115-17b8c7e2-3b2e-11e8-8f75-5a76f87686f3.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/639601/38463115-17b8c7e2-3b2e-11e8-8f75-5a76f87686f3.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://user-images.githubusercontent.com/639601/38463105-97644cc4-3b2d-11e8-97a1-6cdb451ae3a8.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/639601/38463105-97644cc4-3b2d-11e8-97a1-6cdb451ae3a8.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;Releases&lt;/h2&gt;
&lt;p&gt;To find latest releases for different platforms, go to the &lt;a href=&quot;https://github.com/yue/wey/releases&quot;&gt;Releases&lt;/a&gt; page on GitHub.&lt;/p&gt;
&lt;p&gt;For hackers, you can also &lt;code&gt;npm install -g wey&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Technical stack&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/yue/yue&quot;&gt;Yue&lt;/a&gt; - Cross-platform native UI library&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yue/yode&quot;&gt;Yode&lt;/a&gt; - Node.js fork with GUI message loop&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yue/yackage&quot;&gt;Yackage&lt;/a&gt; - Package Node.js project with Yode&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nodejs.org&quot; rel=&quot;nofollow&quot;&gt;Node.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Resources usage&lt;/h2&gt;
&lt;p&gt;Resouces used by Wey are based on following things:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The Node.js runtime.&lt;/li&gt;
&lt;li&gt;Native windows and widgets.&lt;/li&gt;
&lt;li&gt;HTML view used for rendering messages.&lt;/li&gt;
&lt;li&gt;JavaScript code for communicating with Slack.&lt;/li&gt;
&lt;li&gt;Cached Users and messages information in teams.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Normally for multiple teams with heavy traffics, Wey should not have any significant CPU usage, and RAM ussage is usually under 100MB. However if you have a team with more than 10k users in it, the memory usage may increase a lot.&lt;/p&gt;
&lt;h2&gt;Design principles&lt;/h2&gt;
&lt;p&gt;Wey is developed with following principles, the ultimate goal is to provide a fast and powerful chat app.&lt;/p&gt;
&lt;h3&gt;Use native UI for almost everything&lt;/h3&gt;
&lt;p&gt;Most parts of Wey should be created with native UI widgets from Yue library, when there is need for custom UI, draw it manually.&lt;/p&gt;
&lt;h3&gt;HTML is our friend&lt;/h3&gt;
&lt;p&gt;Webview is a great tool as long as we use it wisely. For rendering the rich messages of Slack, HTML is the best tool.&lt;/p&gt;
&lt;p&gt;The HTML pages showed in Wey should be static for best performance, the usage of JavaScript in the pages must be minimal. We should not use any external CSS or JavaScript library/framework, every style and animation must be hand written.&lt;/p&gt;
&lt;h3&gt;Minimal dependencies&lt;/h3&gt;
&lt;p&gt;Be careful when adding dependencies, only use third party modules that are small and without tons of dependencies.&lt;/p&gt;
&lt;h3&gt;Hide details of chat service providers&lt;/h3&gt;
&lt;p&gt;While Wey currently only supports Slack, it is on roadmap to add support for more services, and in future we will support plugins to add arbitrary services.&lt;/p&gt;
&lt;p&gt;To achieve this we must ensure the views and controllers must only operate on the public interfaces of models, all internal implementations must be hidden from outside.&lt;/p&gt;
&lt;h3&gt;Separated views&lt;/h3&gt;
&lt;p&gt;Wey supports multiple windows with different types for reading messages, so the views should act only as users of models, and should not manage the models.&lt;/p&gt;
&lt;p&gt;As benefit creating views in Wey is very fast, opening a new window is almost as fast as showing a hidden window. Users can close all windows and run Wey in background, while still be able to open a new window quicly.&lt;/p&gt;
&lt;h3&gt;Correctly unload things&lt;/h3&gt;
&lt;p&gt;While JavaScript has garbage collections, it is still very easy to cause memory leaks when careless referencing objects together. Views in Wey are reloaded frequently (for example switching accounts and closing windows), so it is important to ensure everything event subscription is detached when unloading a view.&lt;/p&gt;
&lt;h2&gt;Contributions&lt;/h2&gt;
&lt;p&gt;Please limit the size of pull requests under 300 lines, otherwise it would be rather hard to review the code. If you have a big feature to add, please consider splitting it into multiple pull requests.&lt;/p&gt;
&lt;p&gt;It is also encouraged to fork this project or even develop commercial apps based on this project, as long as you follow the GPLv3 license.&lt;/p&gt;
&lt;h2&gt;Performance bottleneck&lt;/h2&gt;
&lt;p&gt;In Wey most time are spent on networking, especially on startup when fetching channels information from Slack, and performance is usually limited by Slack's APIs.&lt;/p&gt;
&lt;h3&gt;Most operations are done via web API&lt;/h3&gt;
&lt;p&gt;In Slack while there is Real Time Messaging API, most common operations can only be done via web APIs, i.e. by sending HTTPS requests, and it is really slow.&lt;/p&gt;
&lt;h3&gt;Messages do not include user information&lt;/h3&gt;
&lt;p&gt;The messages history we pulled from Slack does not include full user information, it only has user IDs in it. So in order to render the messages we have to pull users list first.&lt;/p&gt;
&lt;p&gt;However certain Slack teams have more than 20k users, and it is impossible to download all users' information and cache them. Because of this rendering messages becomes asynchronous work, whenever an uncached user ID is encountered, we have to wait and pull user's information before rendering the message.&lt;/p&gt;
&lt;p&gt;And for large teams we usually end up with caching more than 10k users, which uses a huge JavaScript object, and takes lots of memory.&lt;/p&gt;
&lt;h3&gt;Some bots are not returned in &lt;code&gt;users.list&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;While the &lt;code&gt;users.list&lt;/code&gt; should also return bot users, it somehow does not return certain bot users. As a result even for small teams that we can cache all the users, we still have to spend time fetching user information when rendering channel messages involving bots.&lt;/p&gt;
&lt;h2&gt;Quirks&lt;/h2&gt;
&lt;p&gt;I have met some quirks when using Slack APIs, any help would be appreciated.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;To mark a channel as read we need to send last read timestamp, but it is really to determine which timestamp to send. Marking certain bot messages as read would make Slack server think the channel is unread.&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;License&lt;/h2&gt;
&lt;p&gt;The main source code under &lt;code&gt;lib/&lt;/code&gt; are published under GPLv3, other things are published under public domain.&lt;/p&gt;
&lt;/article&gt;</description>
<pubDate>Mon, 09 Apr 2018 13:07:54 +0000</pubDate>
<dc:creator>zcbenz</dc:creator>
<og:image>https://avatars1.githubusercontent.com/u/20884325?s=400&amp;v=4</og:image>
<og:type>object</og:type>
<og:title>yue/wey</og:title>
<og:url>https://github.com/yue/wey</og:url>
<og:description>wey - Fast open source Slack desktop app</og:description>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://github.com/yue/wey</dc:identifier>
</item>
<item>
<title>Go-internals: Chapter 2, “Interfaces” released</title>
<link>https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md</link>
<guid isPermaLink="true" >https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md</guid>
<description>&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go version
go version go1.10 linux/amd64
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This chapter covers the inner workings of Go's interfaces.&lt;/p&gt;
&lt;p&gt;Specifically, we'll look at:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;How functions &amp;amp; methods are called at run time.&lt;/li&gt;
&lt;li&gt;How interfaces are built and what they're made of.&lt;/li&gt;
&lt;li&gt;How, when and at what cost does dynamic dispatch work.&lt;/li&gt;
&lt;li&gt;How the empty interface &amp;amp; other special cases differ from their peers.&lt;/li&gt;
&lt;li&gt;How interface composition works.&lt;/li&gt;
&lt;li&gt;How and at what cost do type assertions work.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;As we dig deeper and deeper, we'll also poke at miscellaneous low-level concerns, such as some implementation details of modern CPUs as well as various optimizations techniques used by the Go compiler.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;em&gt;This chapter assumes you're familiar with Go's assembler (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter1_assembly_primer/README.md&quot;&gt;chapter I&lt;/a&gt;).&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;If and when running into architecture-specific matters, always assume &lt;code&gt;linux/amd64&lt;/code&gt;.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;We will always work with compiler optimizations &lt;strong&gt;enabled&lt;/strong&gt;.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Quoted text and/or comments always come from the official documentation (including Russ Cox &quot;Function Calls&quot; design document) and/or codebase, unless stated otherwise.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Function and method calls&lt;/h2&gt;
&lt;p&gt;As pointed out by Russ Cox in his design document about function calls (listed at the end of this chapter), Go has..:&lt;/p&gt;
&lt;p&gt;..4 different kinds of functions..:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;top-level func&lt;/li&gt;
&lt;li&gt;method with value receiver&lt;/li&gt;
&lt;li&gt;method with pointer receiver&lt;/li&gt;
&lt;li&gt;func literal&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;..and 5 different kinds of calls:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;direct call of top-level func (&lt;code&gt;func TopLevel(x int) {}&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;direct call of method with value receiver (&lt;code&gt;func (Value) M(int) {}&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;direct call of method with pointer receiver (&lt;code&gt;func (*Pointer) M(int) {}&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;indirect call of method on interface (&lt;code&gt;type Interface interface { M(int) }&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;indirect call of func value (&lt;code&gt;var literal = func(x int) {}&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;Mixed together, these make up for 10 possible combinations of function and call types:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;direct call of top-level func /&lt;/li&gt;
&lt;li&gt;direct call of method with value receiver /&lt;/li&gt;
&lt;li&gt;direct call of method with pointer receiver /&lt;/li&gt;
&lt;li&gt;indirect call of method on interface / containing value with value method&lt;/li&gt;
&lt;li&gt;indirect call of method on interface / containing pointer with value method&lt;/li&gt;
&lt;li&gt;indirect call of method on interface / containing pointer with pointer method&lt;/li&gt;
&lt;li&gt;indirect call of func value / set to top-level func&lt;/li&gt;
&lt;li&gt;indirect call of func value / set to value method&lt;/li&gt;
&lt;li&gt;indirect call of func value / set to pointer method&lt;/li&gt;
&lt;li&gt;indirect call of func value / set to func literal&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(A slash separates what is known at compile time from what is only found out at run time.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We'll first take a few minutes to review the three kinds of direct calls, then we'll shift our focus towards interfaces and indirect method calls for the rest of this chapter.&lt;br/&gt;We won't cover function literals in this chapter, as doing so would first require us to become familiar with the mechanics of closures.. which we'll inevitably do, in due time.&lt;/p&gt;
&lt;h3&gt;Overview of direct calls&lt;/h3&gt;
&lt;p&gt;Consider the following code (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/direct_calls.go&quot;&gt;direct_calls.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;go:noinline&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt;) &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt; { &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a + b }

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Adder&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt;{ id &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt; }
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;go:noinline&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;(&lt;span class=&quot;pl-v&quot;&gt;adder&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;Adder&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;AddPtr&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt;) &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt; { &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a + b }
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;go:noinline&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;(&lt;span class=&quot;pl-v&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Adder&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;AddVal&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt;) &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt; { &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a + b }

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;() {
    &lt;span class=&quot;pl-c1&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;) &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; direct call of top-level function&lt;/span&gt;

    &lt;span class=&quot;pl-smi&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; Adder{id: &lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;}
    adder.&lt;span class=&quot;pl-c1&quot;&gt;AddPtr&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;) &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; direct call of method with pointer receiver&lt;/span&gt;
    adder.&lt;span class=&quot;pl-c1&quot;&gt;AddVal&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;) &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; direct call of method with value receiver&lt;/span&gt;

    (&amp;amp;adder).&lt;span class=&quot;pl-c1&quot;&gt;AddVal&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;) &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; implicit dereferencing&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's have a quick look at the code generated for each of those 4 calls.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Direct call of a top-level function&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Looking at the assembly output for &lt;code&gt;Add(10, 32)&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0000&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; TEXT        &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.main(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;  ;; ...omitted everything but the actual function call...&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x0021&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;        &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;137438953482&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x002b&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x002f&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(SB)&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;  ;; ...omitted everything but the actual function call...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see that, as we already knew from chapter I, this translates into a direct jump to a global function symbol in the &lt;code&gt;.text&lt;/code&gt; section, with the arguments and return values stored on the caller's stack-frame.&lt;br/&gt;It's as straightforward as it gets.&lt;/p&gt;
&lt;p&gt;Russ Cox wraps it up as such in his document:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Direct call of top-level func: A direct call of a top-level func passes all arguments on the stack, expecting results to occupy the successive stack positions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Direct call of a method with pointer receiver&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;First things first, the receiver is initialized via &lt;code&gt;adder := Adder{id: 6754}&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0034&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.adder&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;(The extra-space on our stack-frame was pre-allocated as part of the frame-pointer preamble, which we haven't shown here for conciseness.)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Then comes the actual method call to &lt;code&gt;adder.AddPtr(10, 32)&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0057&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ        &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.adder&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;        ;; move &amp;amp;adder to..&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x005c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;         ;; ..the top of the stack (argument #1)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0060&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;     &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;137438953482&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;      ;; move (32,10) to..&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x006a&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;          ;; ..the top of the stack (arguments #3 &amp;amp; #2)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x006f&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.(&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;Adder).AddPtr(SB)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Looking at the assembly output, we can clearly see that a call to a method (whether it has a value or pointer receiver) is almost identical to a function call, the only difference being that the receiver is passed as first argument.&lt;br/&gt;In this case, we do so by loading the effective address (&lt;code&gt;LEAQ&lt;/code&gt;) of &lt;code&gt;&quot;&quot;.adder+28(SP)&lt;/code&gt; at the top of the frame, so that argument #1 becomes &lt;code&gt;&amp;amp;adder&lt;/code&gt; (if you're a bit confused regarding the semantics of &lt;code&gt;LEA&lt;/code&gt; vs. &lt;code&gt;MOV&lt;/code&gt;, you may want to have a look at the links at the end of this chapter for some pointers).&lt;/p&gt;
&lt;p&gt;Note how the compiler encodes the type of the receiver and whether it's a value or pointer directly into the name of the symbol: &lt;code&gt;&quot;&quot;.(*Adder).AddPtr&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Direct call of method: In order to use the same generated code for both an indirect call of a func value and for a direct call, the code generated for a method (both value and pointer receivers) is chosen to have the same calling convention as a top-level function with the receiver as a leading argument.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Direct call of a method with value receiver&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As we'd expect, using a value receiver yields very similar code as above.&lt;br/&gt;Consider &lt;code&gt;adder.AddVal(10, 32)&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x003c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;       &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;42949679714&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;       ;; move (10,6754) to..&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0046&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;         ;; ..the top of the stack (arguments #2 &amp;amp; #1)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x004a&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL&lt;/span&gt;       &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;            ;; move 32 to the top of the stack (argument #3)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0052&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Adder.AddVal(SB)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Looks like something a bit trickier is going on here, though: the generated assembly isn't even referencing &lt;code&gt;&quot;&quot;.adder+28(SP)&lt;/code&gt; anywhere, even though that is where our receiver currently resides.&lt;br/&gt;So what's really going on here? Well, since the receiver is a value, and since the compiler is able to statically infer that value, it doesn't bother with copying the existing value from its current location (&lt;code&gt;28(SP)&lt;/code&gt;): instead, it simply creates a new, identical &lt;code&gt;Adder&lt;/code&gt; value directly on the stack, and merges this operation with the creation of the second argument to save one more instruction in the process.&lt;/p&gt;
&lt;p&gt;Once again, notice how the symbol name of the method explicitly denotes that it expects a value receiver.&lt;/p&gt;
&lt;h3&gt;Implicit dereferencing&lt;/h3&gt;
&lt;p&gt;There's one final call that we haven't looked at yet: &lt;code&gt;(&amp;amp;adder).AddVal(10, 32)&lt;/code&gt;.&lt;br/&gt;In that case, we're using a pointer variable to call a method that instead expects a value receiver. Somehow, Go automagically dereferences our pointer and manages to make the call. How so?&lt;/p&gt;
&lt;p&gt;How the compiler handles this kind of situation depends on whether or not the receiver being pointed to has escaped to the heap or not.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Case A: The receiver is on the stack&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If the receiver is still on the stack and its size is sufficiently small that it can be copied in a few instructions, as is the case here, the compiler simply copies its value over to the top of the stack then does a straightforward method call to &lt;code&gt;&quot;&quot;.Adder.AddVal&lt;/code&gt; (i.e. the one with a value receiver).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(&amp;amp;adder).AddVal(10, 32)&lt;/code&gt; thus looks like this in this situation:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0074&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL        &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.adder&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;        ;; move (i.e. copy) adder (note the MOV instead of a LEA) to..&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0078&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL      &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;         ;; ..the top of the stack (argument #1)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x007b&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;     &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;137438953482&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;      ;; move (32,10) to..&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0085&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;          ;; ..the top of the stack (arguments #3 &amp;amp; #2)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x008a&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Adder.AddVal(SB)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Boring (although efficient). Let's move on to case B.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Case B: The receiver is on the heap&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If the receiver has escaped to the heap then the compiler has to take a cleverer route: it generates a new method (with a pointer receiver, this time) that wraps &lt;code&gt;&quot;&quot;.Adder.AddVal&lt;/code&gt;, and replaces the original call to &lt;code&gt;&quot;&quot;.Adder.AddVal&lt;/code&gt; (the wrappee) with a call to &lt;code&gt;&quot;&quot;.(*Adder).AddVal&lt;/code&gt; (the wrapper).&lt;br/&gt;The wrapper's sole mission, then, is to make sure that the receiver gets properly dereferenced before being passed to the wrappee, and that any arguments and return values involved are properly copied back and forth between the caller and the wrappee.&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;NOTE: In assembly outputs, these wrapper methods are marked as &lt;code&gt;&amp;lt;autogenerated&amp;gt;&lt;/code&gt;.&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;Here's an annotated listing of the generated wrapper that should hopefully clear things up a bit:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0000&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; TEXT        &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.(&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;Adder).AddVal(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; DUPOK|WRAPPER&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;24&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;  ;; ...omitted preambles...&lt;/span&gt;

&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x0026&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..this&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt; ;; check whether the receiver..&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x002b&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; TESTQ        &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                  ;; ..is nil&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x002e&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; JEQ  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;92&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;             ;; if it is, jump to 0x005c (panic)&lt;/span&gt;

&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x0030&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;            ;; dereference pointer receiver..&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x0032&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;            ;; ..and move (i.e. copy) the resulting value to argument #1&lt;/span&gt;

&lt;span class=&quot;pl-c&quot;&gt;  ;; forward (copy) arguments #2 &amp;amp; #3 then call the wrappee&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x0035&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.a&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;48&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x0039&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x003d&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.b&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;52&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x0041&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x0045&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Adder.AddVal(SB)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt; ;; call the wrapped method&lt;/span&gt;

&lt;span class=&quot;pl-c&quot;&gt;  ;; copy return value from wrapped method then return&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x004a&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x004e&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.~r2&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;56&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;  ;; ...omitted frame-pointer stuff...&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x005b&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;RET&lt;/span&gt;

&lt;span class=&quot;pl-c&quot;&gt;  ;; throw a panic with a detailed error&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0x005c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;    runtime.panicwrap(SB)&lt;/span&gt;

&lt;span class=&quot;pl-c&quot;&gt;  ;; ...omitted epilogues...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Obviously, this kind of wrapper can induce quite a bit of overhead considering all the copying that needs to be done in order to pass the arguments back and forth; especially if the wrappee is just a few instructions.&lt;br/&gt;Fortunately, in practice, the compiler would have inlined the wrappee directly into the wrapper to amortize these costs (when feasible, at least).&lt;/p&gt;
&lt;p&gt;Note the &lt;code&gt;WRAPPER&lt;/code&gt; directive in the definition of the symbol, which indicates that this method shouldn't appear in backtraces (so as not to confuse the end-user), nor should it be able to recover from panics that might be thrown by the wrappee.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WRAPPER: This is a wrapper function and should not count as disabling recover.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;code&gt;runtime.panicwrap&lt;/code&gt; function, which throws a panic if the wrapper's receiver is &lt;code&gt;nil&lt;/code&gt;, is pretty self-explanatory; here's its complete listing for reference (&lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/error.go#L132-L157&quot;&gt;src/runtime/error.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; panicwrap generates a panic for a call to a wrapped value method&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; with a nil pointer receiver.&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; It is called from the generated wrapper code.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;panicwrap&lt;/span&gt;() {
    &lt;span class=&quot;pl-smi&quot;&gt;pc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;getcallerpc&lt;/span&gt;()
    &lt;span class=&quot;pl-smi&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;funcname&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;findfunc&lt;/span&gt;(pc))
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; name is something like &quot;main.(*T).F&quot;.&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; We want to extract pkg (&quot;main&quot;), typ (&quot;T&quot;), and meth (&quot;F&quot;).&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Do it by finding the parens.&lt;/span&gt;
    &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;stringsIndexByte&lt;/span&gt;(name, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;(&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; i &amp;lt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; {
        &lt;span class=&quot;pl-c1&quot;&gt;throw&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;panicwrap: no ( in &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; + name)
    }
    &lt;span class=&quot;pl-smi&quot;&gt;pkg&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; name[:i-&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;]
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; i+&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt; &amp;gt;= &lt;span class=&quot;pl-c1&quot;&gt;len&lt;/span&gt;(name) || name[i-&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;:i+&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;] != &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;.(*&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;pl-c1&quot;&gt;throw&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;panicwrap: unexpected string after package name: &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; + name)
    }
    name = name[i+&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;:]
    i = &lt;span class=&quot;pl-c1&quot;&gt;stringsIndexByte&lt;/span&gt;(name, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;)&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; i &amp;lt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; {
        &lt;span class=&quot;pl-c1&quot;&gt;throw&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;panicwrap: no ) in &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; + name)
    }
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; i+&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt; &amp;gt;= &lt;span class=&quot;pl-c1&quot;&gt;len&lt;/span&gt;(name) || name[i:i+&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;] != &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;).&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; {
        &lt;span class=&quot;pl-c1&quot;&gt;throw&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;panicwrap: unexpected string after type name: &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; + name)
    }
    &lt;span class=&quot;pl-smi&quot;&gt;typ&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; name[:i]
    &lt;span class=&quot;pl-smi&quot;&gt;meth&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; name[i+&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;:]
    &lt;span class=&quot;pl-c1&quot;&gt;panic&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;plainError&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;value method &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; + pkg + &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;.&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; + typ + &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;.&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; + meth + &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; called using nil *&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; + typ + &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; pointer&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;))
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That's all for function and method calls, we'll now focus on the main course: interfaces.&lt;/p&gt;
&lt;h2&gt;Anatomy of an interface&lt;/h2&gt;
&lt;h3&gt;Overview of the datastructures&lt;/h3&gt;
&lt;p&gt;Before we can understand how they work, we first need to build a mental model of the datastructures that make up interfaces and how they're laid out in memory.&lt;br/&gt;To that end, we'll have a quick peek into the runtime package to see what an interface actually looks like from the standpoint of the Go implementation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The &lt;code&gt;iface&lt;/code&gt; structure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iface&lt;/code&gt; is the root type that represents an interface within the runtime (&lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/runtime2.go#L143-L146&quot;&gt;src/runtime/runtime2.go&lt;/a&gt;).&lt;br/&gt;Its definition goes like this:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; iface &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; { &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 16 bytes on a 64bit arch&lt;/span&gt;
    tab  *itab
    data unsafe.&lt;span class=&quot;pl-smi&quot;&gt;Pointer&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;An interface is thus a very simple structure that maintains 2 pointers:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;tab&lt;/code&gt; holds the address of an &lt;code&gt;itab&lt;/code&gt; object, which embeds the datastructures that describe both the type of the interface as well as the type of the data it points to.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; is a raw (i.e. &lt;code&gt;unsafe&lt;/code&gt;) pointer to the value held by the interface.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;While extremely simple, this definition already gives us some valuable information: since interfaces can only hold pointers, &lt;em&gt;any concrete value that we wrap into an interface will have to have its address taken&lt;/em&gt;.&lt;br/&gt;More often than not, this will result in a heap allocation as the compiler takes the conservative route and forces the receiver to escape.&lt;br/&gt;This holds true even for scalar types!&lt;/p&gt;
&lt;p&gt;We can prove that with a few lines of code (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/escape.go&quot;&gt;escape.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Addifier&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt;{ &lt;span class=&quot;pl-c1&quot;&gt;Add&lt;/span&gt;(a, b &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt; }

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Adder&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt;{ name &lt;span class=&quot;pl-k&quot;&gt;string&lt;/span&gt; }
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;go:noinline&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;(&lt;span class=&quot;pl-v&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Adder&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Add&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt;) &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt; { &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a + b }

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;() {
    &lt;span class=&quot;pl-smi&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; Adder{name: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;myAdder&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;}
    adder.&lt;span class=&quot;pl-c1&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;)        &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; doesn't escape&lt;/span&gt;
    &lt;span class=&quot;pl-c1&quot;&gt;Addifier&lt;/span&gt;(adder).&lt;span class=&quot;pl-c1&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;) &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; escapes&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ GOOS=linux GOARCH=amd64 go tool compile -m escape.go
escape.go:13:10: Addifier(adder) escapes to heap
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One could even visualize the resulting heap allocation using a simple benchmark (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/escape_test.go&quot;&gt;escape_test.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;BenchmarkDirect&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;testing&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;B&lt;/span&gt;) {
    &lt;span class=&quot;pl-smi&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; Adder{id: &lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;}
    &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
        adder.&lt;span class=&quot;pl-c1&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;)
    }
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;BenchmarkInterface&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;testing&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;B&lt;/span&gt;) {
    &lt;span class=&quot;pl-smi&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; Adder{id: &lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;}
    &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
        &lt;span class=&quot;pl-c1&quot;&gt;Addifier&lt;/span&gt;(adder).&lt;span class=&quot;pl-c1&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;)
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ GOOS=linux GOARCH=amd64 go tool compile -m escape_test.go 
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; ...&lt;/span&gt;
escape_test.go:22:11: Addifier(adder) escapes to heap
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ GOOS=linux GOARCH=amd64 go &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; -bench=. -benchmem ./escape_test.go
BenchmarkDirect-8       2000000000               1.60 ns/op            0 B/op          0 allocs/op
BenchmarkInterface-8    100000000                15.0 ns/op            4 B/op          1 allocs/op
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can clearly see how each time we create a new &lt;code&gt;Addifier&lt;/code&gt; interface and initialize it with our &lt;code&gt;adder&lt;/code&gt; variable, a heap allocation of &lt;code&gt;sizeof(Adder)&lt;/code&gt; actually takes place. Later in this chapter, we'll see how even simple scalar types can lead to heap allocations when used with interfaces.&lt;/p&gt;
&lt;p&gt;Let's turn our attention towards the next datastructure: &lt;code&gt;itab&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The &lt;code&gt;itab&lt;/code&gt; structure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;itab&lt;/code&gt; is defined thusly (&lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/runtime2.go#L648-L658&quot;&gt;src/runtime/runtime2.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; itab &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; { &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 40 bytes on a 64bit arch&lt;/span&gt;
    inter *interfacetype
    _type *_type
    hash  &lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; copy of _type.hash. Used for type switches.&lt;/span&gt;
    _     [&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;]&lt;span class=&quot;pl-k&quot;&gt;byte&lt;/span&gt;
    fun   [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; variable sized. fun[0]==0 means _type does not implement inter.&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;An &lt;code&gt;itab&lt;/code&gt; is the heart &amp;amp; brain of an interface.&lt;/p&gt;
&lt;p&gt;First, it embeds a &lt;code&gt;_type&lt;/code&gt;, which is the internal representation of any Go type within the runtime.&lt;br/&gt;A &lt;code&gt;_type&lt;/code&gt; describes every facets of a type: its name, its characteristics (e.g. size, alignment...), and to some extent, even how it behaves (e.g. comparison, hashing...)!&lt;br/&gt;In this instance, the &lt;code&gt;_type&lt;/code&gt; field describes the type of the value held by the interface, i.e. the value that the &lt;code&gt;data&lt;/code&gt; pointer points to.&lt;/p&gt;
&lt;p&gt;Second, we find a pointer to an &lt;code&gt;interfacetype&lt;/code&gt;, which is merely a wrapper around &lt;code&gt;_type&lt;/code&gt; with some extra information that are specific to interfaces.&lt;br/&gt;As you'd expect, the &lt;code&gt;inter&lt;/code&gt; field describes the type of the interface itself.&lt;/p&gt;
&lt;p&gt;Finally, the &lt;code&gt;fun&lt;/code&gt; array holds the function pointers that make up the virtual/dispatch table of the interface.&lt;br/&gt;Notice the comment that says &lt;code&gt;// variable sized&lt;/code&gt;, meaning that the size with which this array is declared is &lt;em&gt;irrelevant&lt;/em&gt;.&lt;br/&gt;We'll see later in this chapter that the compiler is responsible for allocating the memory that backs this array, and does so independently of the size indicated here. Likewise, the runtime always accesses this array using raw pointers, thus bounds-checking does not apply here.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The &lt;code&gt;_type&lt;/code&gt; structure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As we said above, the &lt;code&gt;_type&lt;/code&gt; structure gives a complete description of a Go type.&lt;br/&gt;It's defined as such (&lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/type.go#L25-L43&quot;&gt;src/runtime/type.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; _type &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; { &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 48 bytes on a 64bit arch&lt;/span&gt;
    size       &lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;
    ptrdata    &lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; size of memory prefix holding all pointers&lt;/span&gt;
    hash       &lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;
    tflag      tflag
    align      &lt;span class=&quot;pl-k&quot;&gt;uint8&lt;/span&gt;
    fieldalign &lt;span class=&quot;pl-k&quot;&gt;uint8&lt;/span&gt;
    kind       &lt;span class=&quot;pl-k&quot;&gt;uint8&lt;/span&gt;
    alg        *typeAlg
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; gcdata stores the GC type data for the garbage collector.&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; If the KindGCProg bit is set in kind, gcdata is a GC program.&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Otherwise it is a ptrmask bitmap. See mbitmap.go for details.&lt;/span&gt;
    gcdata    *&lt;span class=&quot;pl-k&quot;&gt;byte&lt;/span&gt;
    str       nameOff
    ptrToThis typeOff
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Thankfully, most of these fields are quite self-explanatory.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;nameOff&lt;/code&gt; &amp;amp; &lt;code&gt;typeOff&lt;/code&gt; types are &lt;code&gt;int32&lt;/code&gt; offsets into the metadata embedded into the final executable by the linker. This metadata is loaded into &lt;code&gt;runtime.moduledata&lt;/code&gt; structures at run time (&lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/symtab.go#L352-L393&quot;&gt;src/runtime/symtab.go&lt;/a&gt;), which should look fairly similar if you've ever had to look at the content of an ELF file.&lt;br/&gt;The runtime provide helpers that implement the necessary logic for following these offsets through the &lt;code&gt;moduledata&lt;/code&gt; structures, such as e.g. &lt;code&gt;resolveNameOff&lt;/code&gt; (&lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/type.go#L168-L196&quot;&gt;src/runtime/type.go&lt;/a&gt;) and &lt;code&gt;resolveTypeOff&lt;/code&gt; (&lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/type.go#L202-L236&quot;&gt;src/runtime/type.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;resolveNameOff&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;ptrInModule&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;Pointer&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;nameOff&lt;/span&gt;) &lt;span class=&quot;pl-v&quot;&gt;name&lt;/span&gt; {}
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;resolveTypeOff&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;ptrInModule&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;Pointer&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;typeOff&lt;/span&gt;) *&lt;span class=&quot;pl-v&quot;&gt;_type&lt;/span&gt; {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I.e., assuming &lt;code&gt;t&lt;/code&gt; is a &lt;code&gt;_type&lt;/code&gt;, calling &lt;code&gt;resolveTypeOff(t, t.ptrToThis)&lt;/code&gt; returns a copy of &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The &lt;code&gt;interfacetype&lt;/code&gt; structure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Finally, here's the &lt;code&gt;interfacetype&lt;/code&gt; structure (&lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/type.go#L342-L346&quot;&gt;src/runtime/type.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; interfacetype &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; { &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 80 bytes on a 64bit arch&lt;/span&gt;
    typ     _type
    pkgpath name
    mhdr    []imethod
}

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; imethod &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
    name nameOff
    ityp typeOff
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As mentionned, an &lt;code&gt;interfacetype&lt;/code&gt; is just a wrapper around a &lt;code&gt;_type&lt;/code&gt; with some extra interface-specific metadata added on top.&lt;br/&gt;In the current implementation, this metadata is mostly composed of a list of offsets that points to the respective names and types of the methods exposed by the interface (&lt;code&gt;[]imethod&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here's an overview of what an &lt;code&gt;iface&lt;/code&gt; looks like when represented with all of its sub-types inlined; this hopefully should help connect all the dots:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; iface &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; { &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; `iface`&lt;/span&gt;
    tab *&lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; { &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; `itab`&lt;/span&gt;
        inter *&lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; { &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; `interfacetype`&lt;/span&gt;
            typ &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; { &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; `_type`&lt;/span&gt;
                size       &lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;
                ptrdata    &lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;
                hash       &lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;
                tflag      tflag
                align      &lt;span class=&quot;pl-k&quot;&gt;uint8&lt;/span&gt;
                fieldalign &lt;span class=&quot;pl-k&quot;&gt;uint8&lt;/span&gt;
                kind       &lt;span class=&quot;pl-k&quot;&gt;uint8&lt;/span&gt;
                alg        *typeAlg
                gcdata     *&lt;span class=&quot;pl-k&quot;&gt;byte&lt;/span&gt;
                str        nameOff
                ptrToThis  typeOff
            }
            pkgpath name
            mhdr    []&lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; { &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; `imethod`&lt;/span&gt;
                name nameOff
                ityp typeOff
            }
        }
        _type *&lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; { &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; `_type`&lt;/span&gt;
            size       &lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;
            ptrdata    &lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;
            hash       &lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;
            tflag      tflag
            align      &lt;span class=&quot;pl-k&quot;&gt;uint8&lt;/span&gt;
            fieldalign &lt;span class=&quot;pl-k&quot;&gt;uint8&lt;/span&gt;
            kind       &lt;span class=&quot;pl-k&quot;&gt;uint8&lt;/span&gt;
            alg        *typeAlg
            gcdata     *&lt;span class=&quot;pl-k&quot;&gt;byte&lt;/span&gt;
            str        nameOff
            ptrToThis  typeOff
        }
        hash &lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;
        _    [&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;]&lt;span class=&quot;pl-k&quot;&gt;byte&lt;/span&gt;
        fun  [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;
    }
    data unsafe.&lt;span class=&quot;pl-smi&quot;&gt;Pointer&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This section glossed over the different data-types that make up an interface to help us to start building a mental model of the various cogs involved in the overall machinery, and how they all work with each other.&lt;br/&gt;In the next section, we'll learn how these datastructures actually get computed.&lt;/p&gt;
&lt;h3&gt;Creating an interface&lt;/h3&gt;
&lt;p&gt;Now that we've had a quick look at all the datastructures involved, we'll focus on how they actually get allocated and initiliazed.&lt;/p&gt;
&lt;p&gt;Consider the following program (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/iface.go&quot;&gt;iface.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Mather&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; {
    &lt;span class=&quot;pl-c1&quot;&gt;Add&lt;/span&gt;(a, b &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;
    &lt;span class=&quot;pl-c1&quot;&gt;Sub&lt;/span&gt;(a, b &lt;span class=&quot;pl-k&quot;&gt;int64&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;int64&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Adder&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt;{ id &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt; }
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;go:noinline&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;(&lt;span class=&quot;pl-v&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Adder&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Add&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt;) &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt; { &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a + b }
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;go:noinline&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;(&lt;span class=&quot;pl-v&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Adder&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Sub&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;int64&lt;/span&gt;) &lt;span class=&quot;pl-v&quot;&gt;int64&lt;/span&gt; { &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a - b }

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;() {
    &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Mather&lt;/span&gt;(Adder{id: &lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;})

    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; This call just makes sure that the interface is actually used.&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Without this call, the linker would see that the interface defined above&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; is in fact never used, and thus would optimize it out of the final&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; executable.&lt;/span&gt;
    m.&lt;span class=&quot;pl-c1&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;NOTE: For the remainder of this chapter, we will denote an interface &lt;code&gt;I&lt;/code&gt; that holds a type &lt;code&gt;T&lt;/code&gt; as &lt;code&gt;&amp;lt;I,T&amp;gt;&lt;/code&gt;. E.g. &lt;code&gt;Mather(Adder{id: 6754})&lt;/code&gt; instantiates an &lt;code&gt;iface&amp;lt;Mather, Adder&amp;gt;&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Let's zoom in on the instantiation of &lt;code&gt;iface&amp;lt;Mather, Adder&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Mather&lt;/span&gt;(Adder{id: &lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This single line of Go code actually sets off quite a bit of machinery, as the assembly listing generated by the compiler can attest:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; part 1: allocate the receiver&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x001d&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL&lt;/span&gt;       &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..autotmp_1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; part 2: set up the itab&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0025&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ      go.itab.&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Adder&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Mather(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x002c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; part 3: set up the data&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0030&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ      &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..autotmp_1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0035&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x003a&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; runtime.convT2I32(SB)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x003f&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0044&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, we've splitted the output into three logical parts.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Part 1: Allocate the receiver&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x001d&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..autotmp_1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A constant decimal value of &lt;code&gt;6754&lt;/code&gt;, corresponding to the ID of our &lt;code&gt;Adder&lt;/code&gt;, is stored at the beginning of the current stack-frame.&lt;br/&gt;It's stored there so that the compiler will later be able to reference it by its address; we'll see why in part 3.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Part 2: Set up the itab&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0025&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ        go.itab.&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Adder&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Mather(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x002c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It looks like the compiler has already created the necessary &lt;code&gt;itab&lt;/code&gt; for representing our &lt;code&gt;iface&amp;lt;Mather, Adder&amp;gt;&lt;/code&gt; interface, and made it available to us via a global symbol: &lt;code&gt;go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We're in the process of building an &lt;code&gt;iface&amp;lt;Mather, Adder&amp;gt;&lt;/code&gt; interface and, in order to do so, we're loading the effective address of this global &lt;code&gt;go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather&lt;/code&gt; symbol at the top of the current stack-frame.&lt;br/&gt;Once again, we'll see why in part 3.&lt;/p&gt;
&lt;p&gt;Semantically, this gives us something along the lines of the following pseudo-code:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;getSymAddr&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;go.itab.main.Adder,main.Mather&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;).(*itab)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That's half of our interface right there!&lt;/p&gt;
&lt;p&gt;Now, while we're at it, let's have a deeper look at that &lt;code&gt;go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather&lt;/code&gt; symbol.&lt;br/&gt;As usual, the &lt;code&gt;-S&lt;/code&gt; flag of the compiler can tell us a lot:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ GOOS=linux GOARCH=amd64 go tool compile -S iface.go | grep -A 7 '^go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather'
go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather SRODATA dupok size=40
    0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x0010 8a 3d 5f 61 00 00 00 00 00 00 00 00 00 00 00 00  .=_a............
    0x0020 00 00 00 00 00 00 00 00                          ........
    rel 0+8 t=1 type.&quot;&quot;.Mather+0
    rel 8+8 t=1 type.&quot;&quot;.Adder+0
    rel 24+8 t=1 &quot;&quot;.(*Adder).Add+0
    rel 32+8 t=1 &quot;&quot;.(*Adder).Sub+0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Neat. Let's analyze this piece by piece.&lt;/p&gt;
&lt;p&gt;The first piece declares the symbol and its attributes:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather SRODATA dupok size=40
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;As usual, since we're looking directly at the intermediate object file generated by the compiler (i.e. the linker hasn't run yet), symbol names are still missing package names. Nothing new on that front.&lt;br/&gt;Other than that, what we've got here is a 40-byte global object symbol that will be stored in the &lt;code&gt;.rodata&lt;/code&gt; section of our binary.&lt;/p&gt;
&lt;p&gt;Note the &lt;code&gt;dupok&lt;/code&gt; directive, which tells the linker that it is legal for this symbol to appear multiple times at link-time: the linker will have to arbitrarily choose one of them over the others.&lt;br/&gt;What makes the Go authors think that this symbol might end up duplicated, I'm not sure. Feel free to file an issue if you know more.&lt;/p&gt;
&lt;p&gt;The second piece is a hexdump of the 40 bytes of data associated with the symbol. I.e., it's a serialized representation of an &lt;code&gt;itab&lt;/code&gt; structure:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0010 8a 3d 5f 61 00 00 00 00 00 00 00 00 00 00 00 00  .=_a............
0x0020 00 00 00 00 00 00 00 00                          ........
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;As you can see, most of this data is just a bunch of zeros at this point. The linker will take care of filling them up, as we'll see in a minute.&lt;/p&gt;
&lt;p&gt;Notice how, among all these zeros, 4 bytes actually have been set though, at offset &lt;code&gt;0x10+4&lt;/code&gt;.&lt;br/&gt;If we take a look back at the declaration of the &lt;code&gt;itab&lt;/code&gt; structure and annotate the respective offsets of its fields:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; itab &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; { &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 40 bytes on a 64bit arch&lt;/span&gt;
    inter *interfacetype &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; offset 0x00 ($00)&lt;/span&gt;
    _type *_type         &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; offset 0x08 ($08)&lt;/span&gt;
    hash  &lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;       &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; offset 0x10 ($16)&lt;/span&gt;
    _     [&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;]&lt;span class=&quot;pl-k&quot;&gt;byte&lt;/span&gt;   &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; offset 0x14 ($20)&lt;/span&gt;
    fun   [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;        &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; offset 0x18 ($24)&lt;/span&gt;
                         &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; offset 0x20 ($32)&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see that offset &lt;code&gt;0x10+4&lt;/code&gt; matches the &lt;code&gt;hash uint32&lt;/code&gt; field: i.e., the hash value that corresponds to our &lt;code&gt;main.Adder&lt;/code&gt; type is already right there in our object file.&lt;/p&gt;
&lt;p&gt;The third and final piece lists a bunch of relocation directives for the linker:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rel 0+8 t=1 type.&quot;&quot;.Mather+0
rel 8+8 t=1 type.&quot;&quot;.Adder+0
rel 24+8 t=1 &quot;&quot;.(*Adder).Add+0
rel 32+8 t=1 &quot;&quot;.(*Adder).Sub+0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rel 0+8 t=1 type.&quot;&quot;.Mather+0&lt;/code&gt; tells the linker to fill up the first 8 bytes (&lt;code&gt;0+8&lt;/code&gt;) of the contents with the address of the global object symbol &lt;code&gt;type.&quot;&quot;.Mather&lt;/code&gt;.&lt;br/&gt;&lt;code&gt;rel 8+8 t=1 type.&quot;&quot;.Adder+0&lt;/code&gt; then fills the next 8 bytes with the address of &lt;code&gt;type.&quot;&quot;.Adder&lt;/code&gt;, and so on and so forth.&lt;/p&gt;
&lt;p&gt;Once the linker has done its job and followed all of these directives, our 40-byte serialized &lt;code&gt;itab&lt;/code&gt; will be complete.&lt;br/&gt;Overall, we're now looking at something akin to the following pseudo-code:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;getSymAddr&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;go.itab.main.Adder,main.Mather&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;).(*itab)

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; NOTE: The linker strips the `type.` prefix from these symbols when building&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; the executable, so the final symbol names in the .rodata section of the&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; binary will actually be `main.Mather` and `main.Adder` rather than&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; `type.main.Mather` and `type.main.Adder`.&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Don't get tripped up by this when toying around with objdump.&lt;/span&gt;
tab.&lt;span class=&quot;pl-smi&quot;&gt;inter&lt;/span&gt; = &lt;span class=&quot;pl-c1&quot;&gt;getSymAddr&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;type.main.Mather&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;).(*interfacetype)
tab.&lt;span class=&quot;pl-smi&quot;&gt;_type&lt;/span&gt; = &lt;span class=&quot;pl-c1&quot;&gt;getSymAddr&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;type.main.Adder&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;).(*_type)

tab.&lt;span class=&quot;pl-smi&quot;&gt;fun&lt;/span&gt;[&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;pl-c1&quot;&gt;getSymAddr&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;main.(*Adder).Add&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;).(&lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;)
tab.&lt;span class=&quot;pl-smi&quot;&gt;fun&lt;/span&gt;[&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;pl-c1&quot;&gt;getSymAddr&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;main.(*Adder).Sub&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;).(&lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We've got ourselves a ready-to-use &lt;code&gt;itab&lt;/code&gt;, now if we just had some data to along with it, that'd make for a nice, complete interface.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Part 3: Set up the data&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0030&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ        &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..autotmp_1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0035&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x003a&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; runtime.convT2I32(SB)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x003f&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0044&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember from part 1 that the top of the stack &lt;code&gt;(SP)&lt;/code&gt; currently holds the address of &lt;code&gt;go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather&lt;/code&gt; (argument #1).&lt;br/&gt;Also remember from part 2 that we had stored a &lt;code&gt;$6754&lt;/code&gt; decimal constant in &lt;code&gt;&quot;&quot;..autotmp_1+36(SP)&lt;/code&gt;: we now load the effective address of this constant just below the top of the stack-frame, at 8(SP) (argument #2).&lt;/p&gt;
&lt;p&gt;These two pointers are the two arguments that we pass into &lt;code&gt;runtime.convT2I32&lt;/code&gt;, which will apply the final touches of glue to create and return our complete interface.&lt;br/&gt;Let's have a closer look at it (&lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/iface.go#L433-L451&quot;&gt;src/runtime/iface.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;convT2I32&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;tab&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;itab&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;Pointer&lt;/span&gt;) (&lt;span class=&quot;pl-v&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;iface&lt;/span&gt;) {
    &lt;span class=&quot;pl-smi&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; tab.&lt;span class=&quot;pl-smi&quot;&gt;_type&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; ...omitted debug stuff... &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt; unsafe.&lt;span class=&quot;pl-smi&quot;&gt;Pointer&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; *(*&lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;)(elem) == &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; {
        x = unsafe.&lt;span class=&quot;pl-c1&quot;&gt;Pointer&lt;/span&gt;(&amp;amp;zeroVal[&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;])
    } &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; {
        x = &lt;span class=&quot;pl-c1&quot;&gt;mallocgc&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;, t, &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;)
        *(*&lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;)(x) = *(*&lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;)(elem)
    }
    i.&lt;span class=&quot;pl-smi&quot;&gt;tab&lt;/span&gt; = tab
    i.&lt;span class=&quot;pl-smi&quot;&gt;data&lt;/span&gt; = x
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;runtime.convT2I32&lt;/code&gt; does 4 things:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;It creates a new &lt;code&gt;iface&lt;/code&gt; structure &lt;code&gt;i&lt;/code&gt; (to be pedantic, its caller creates it.. same difference).&lt;/li&gt;
&lt;li&gt;It assigns the &lt;code&gt;itab&lt;/code&gt; pointer we just gave it to &lt;code&gt;i.tab&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;It &lt;strong&gt;allocates a new object of type &lt;code&gt;i.tab._type&lt;/code&gt; on the heap&lt;/strong&gt;, then copy the value pointed to by the second argument &lt;code&gt;elem&lt;/code&gt; into that new object.&lt;/li&gt;
&lt;li&gt;It returns the final interface.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;This process is quite straightforward overall, although the 3rd step does involve some tricky implementation details in this specific case, which are caused by the fact that our &lt;code&gt;Adder&lt;/code&gt; type is effectively a scalar type.&lt;br/&gt;We'll look at the interactions of scalar types and interfaces in more details in the section about &lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md#interface-holding-a-scalar-type&quot;&gt;the special cases of interfaces&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Conceptually, we've now accomplished the following (pseudo-code):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;getSymAddr&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;go.itab.main.Adder,main.Mather&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;).(*itab)
&lt;span class=&quot;pl-smi&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;getSymAddr&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&quot;&quot;..autotmp_1+36(SP)&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;).(*&lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;)

&lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; runtime.&lt;span class=&quot;pl-c1&quot;&gt;convTI32&lt;/span&gt;(tab, unsafe.&lt;span class=&quot;pl-c1&quot;&gt;Pointer&lt;/span&gt;(elem))

&lt;span class=&quot;pl-c1&quot;&gt;assert&lt;/span&gt;(i.&lt;span class=&quot;pl-smi&quot;&gt;tab&lt;/span&gt; == tab)
&lt;span class=&quot;pl-c1&quot;&gt;assert&lt;/span&gt;(*(*&lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;)(i.&lt;span class=&quot;pl-smi&quot;&gt;data&lt;/span&gt;) == &lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;) &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; same value..&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;assert&lt;/span&gt;((*&lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;)(i.&lt;span class=&quot;pl-smi&quot;&gt;data&lt;/span&gt;) != elem)  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ..but different (al)locations!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To summarize all that just went down, here's a complete, annotated version of the assembly code for all 3 parts:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x001d&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..autotmp_1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;         ;; create an addressable $6754 value at 36(SP)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0025&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ      go.itab.&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Adder&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Mather(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;  ;; set up go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather..&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x002c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                            ;; ..as first argument (tab *itab)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0030&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ      &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..autotmp_1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;            ;; set up &amp;amp;36(SP)..&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0035&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                           ;; ..as second argument (elem unsafe.Pointer)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x003a&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; runtime.convT2I32(SB)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;               ;; call convT2I32(go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather, &amp;amp;$6754)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x003f&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                          ;; AX now holds i.tab (go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0044&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                          ;; CX now holds i.data (&amp;amp;$6754, somewhere on the heap)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Keep in mind that all of this started with just one single line: &lt;code&gt;m := Mather(Adder{id: 6754})&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We finally got ourselves a complete, working interface.&lt;/p&gt;
&lt;h3&gt;Reconstructing an &lt;code&gt;itab&lt;/code&gt; from an executable&lt;/h3&gt;
&lt;p&gt;In the previous section, we dumped the contents of &lt;code&gt;go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather&lt;/code&gt; directly from the object files generated by the compiler and ended up looking at what was mostly a blob of zeros (except for the &lt;code&gt;hash&lt;/code&gt; value):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ GOOS=linux GOARCH=amd64 go tool compile -S iface.go | grep -A 3 '^go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather'
go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather SRODATA dupok size=40
    0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x0010 8a 3d 5f 61 00 00 00 00 00 00 00 00 00 00 00 00  .=_a............
    0x0020 00 00 00 00 00 00 00 00                          ........
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;To get a better picture of how the data is laid out into the final executable produced by the linker, we'll walk through the generated ELF file and manually reconstruct the bytes that make up the &lt;code&gt;itab&lt;/code&gt; of our &lt;code&gt;iface&amp;lt;Mather, Adder&amp;gt;&lt;/code&gt;.&lt;br/&gt;Hopefully, this'll enable us to observe what our &lt;code&gt;itab&lt;/code&gt; looks like once the linker has done its job.&lt;/p&gt;
&lt;p&gt;First things first, let's build the &lt;code&gt;iface&lt;/code&gt; binary: &lt;code&gt;GOOS=linux GOARCH=amd64 go build -o iface.bin iface.go&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1: Find &lt;code&gt;.rodata&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let's print the section headers in search of &lt;code&gt;.rodata&lt;/code&gt;, &lt;code&gt;readelf&lt;/code&gt; can help with that:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ readelf -St -W iface.bin
There are 22 section headers, starting at offset 0x190:

Section Headers:
  [Nr] Name
       Type            Address          Off    Size   ES   Lk Inf Al
       Flags
  [ 0] 
       NULL            0000000000000000 000000 000000 00   0   0  0
       [0000000000000000]: 
  [ 1] .text
       PROGBITS        0000000000401000 001000 04b3cf 00   0   0 16
       [0000000000000006]: ALLOC, EXEC
  [ 2] .rodata
       PROGBITS        000000000044d000 04d000 028ac4 00   0   0 32
       [0000000000000002]: ALLOC
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;# ...omitted rest of output...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What we really need here is the (decimal) offset of the section, so let's apply some pipe-foo:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ readelf -St -W iface.bin &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  grep -A 1 .rodata &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  tail -n +2 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  awk &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;{print &quot;ibase=16;&quot;toupper($3)}&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  bc
315392
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which means that &lt;code&gt;fseek&lt;/code&gt;-ing 315392 bytes into our binary should place us right at the start of the &lt;code&gt;.rodata&lt;/code&gt; section.&lt;br/&gt;Now what we need to do is map this file location to a virtual-memory address.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 2: Find the virtual-memory address (VMA) of &lt;code&gt;.rodata&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The VMA is the virtual address at which the section will be mapped once the binary has been loaded in memory by the OS. I.e., this is the address that we'll use to reference a symbol at runtime.&lt;/p&gt;
&lt;p&gt;The reason we care about the VMA in this case is that we cannot directly ask &lt;code&gt;readelf&lt;/code&gt; or &lt;code&gt;objdump&lt;/code&gt; for the offset of a specific symbol (AFAIK). What we can do, on the other hand, is ask for the VMA of a specific symbol.&lt;br/&gt;Coupled with some simple maths, we should be able to build a mapping between VMAs and offsets and finally find the offsets of the symbols that we're looking for.&lt;/p&gt;
&lt;p&gt;Finding the VMA of &lt;code&gt;.rodata&lt;/code&gt; is no different than finding its offset, it's just a different column is all:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ readelf -St -W iface.bin &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  grep -A 1 .rodata &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  tail -n +2 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  awk &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;{print &quot;ibase=16;&quot;toupper($2)}&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  bc
4509696
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So here's what we know so far: the &lt;code&gt;.rodata&lt;/code&gt; section is located at offset &lt;code&gt;$315392&lt;/code&gt; (= &lt;code&gt;0x04d000&lt;/code&gt;) into the ELF file, which will be mapped at virtual address &lt;code&gt;$4509696&lt;/code&gt; (= &lt;code&gt;0x44d000&lt;/code&gt;) at run time.&lt;/p&gt;
&lt;p&gt;Now we need the VMA as well as the size of the symbol we're looking for:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Its VMA will (indirectly) allow us to locate it within the executable.&lt;/li&gt;
&lt;li&gt;Its size will tell us how much data to extract once we've found the correct offset.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Step 3: Find the VMA &amp;amp; size of &lt;code&gt;go.itab.main.Adder,main.Mather&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objdump&lt;/code&gt; has those available for us.&lt;/p&gt;
&lt;p&gt;First, find the symbol:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ objdump -t -j .rodata iface.bin &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; grep &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;go.itab.main.Adder,main.Mather&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
0000000000475140 g     O .rodata        0000000000000028 go.itab.main.Adder,main.Mather
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then, get its VMA in decimal form:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ objdump -t -j .rodata iface.bin &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  grep &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;go.itab.main.Adder,main.Mather&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  awk &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;{print &quot;ibase=16;&quot;toupper($1)}&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  bc
4673856
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And finally, get its size in decimal form:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ objdump -t -j .rodata iface.bin &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  grep &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;go.itab.main.Adder,main.Mather&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  awk &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;{print &quot;ibase=16;&quot;toupper($5)}&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  bc
40
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;go.itab.main.Adder,main.Mather&lt;/code&gt; will be mapped at virtual address &lt;code&gt;$4673856&lt;/code&gt; (= &lt;code&gt;0x475140&lt;/code&gt;) at run time, and has a size of 40 bytes (which we already knew, as it's the size of an &lt;code&gt;itab&lt;/code&gt; structure).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 4: Find &amp;amp; extract &lt;code&gt;go.itab.main.Adder,main.Mather&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We now have all the elements we need in order to locate &lt;code&gt;go.itab.main.Adder,main.Mather&lt;/code&gt; within our binary.&lt;/p&gt;
&lt;p&gt;Here's a reminder of what we know so far:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.rodata offset: 0x04d000 == $315392
.rodata VMA: 0x44d000 == $4509696

go.itab.main.Adder,main.Mather VMA: 0x475140 == $4673856
go.itab.main.Adder,main.Mather size: 0x24 = $40
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;If &lt;code&gt;$315392&lt;/code&gt; (&lt;code&gt;.rodata&lt;/code&gt;'s offset) maps to $4509696 (&lt;code&gt;.rodata&lt;/code&gt;'s VMA) and &lt;code&gt;go.itab.main.Adder,main.Mather&lt;/code&gt;'s VMA is &lt;code&gt;$4673856&lt;/code&gt;, then &lt;code&gt;go.itab.main.Adder,main.Mather&lt;/code&gt;'s offset within the executable is:&lt;br/&gt;&lt;code&gt;sym.offset = sym.vma - section.vma + section.offset = $4673856 - $4509696 + $315392 = $479552&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now that we know both the offset and size of the data, we can take out good ol' &lt;code&gt;dd&lt;/code&gt; and extract the raw bytes straight out of the executable:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ dd if=iface.bin of=/dev/stdout bs=1 count=40 skip=479552 &lt;span class=&quot;pl-k&quot;&gt;2&amp;gt;&lt;/span&gt;/dev/null &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; hexdump
0000000 bd20 0045 0000 0000 ed40 0045 0000 0000
0000010 3d8a 615f 0000 0000 c2d0 0044 0000 0000
0000020 c350 0044 0000 0000                    
0000028
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This certainly does look like a clear-cut victory.. but is it, really? Maybe we've just dumped 40 totally random, unrelated bytes? Who knows?&lt;br/&gt;There's at least one way to be sure: let's compare the type hash found in our binary dump (at offset &lt;code&gt;0x10+4&lt;/code&gt; -&amp;gt; &lt;code&gt;0x615f3d8a&lt;/code&gt;) with the one loaded by the runtime (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/iface_type_hash.go&quot;&gt;iface_type_hash.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; simplified definitions of runtime's iface &amp;amp; itab types&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; iface &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
    tab  *itab
    data unsafe.&lt;span class=&quot;pl-smi&quot;&gt;Pointer&lt;/span&gt;
}
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; itab &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
    inter &lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;
    _type &lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;
    hash  &lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;
    _     [&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;]&lt;span class=&quot;pl-k&quot;&gt;byte&lt;/span&gt;
    fun   [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;() {
    &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Mather&lt;/span&gt;(Adder{id: &lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;})

    &lt;span class=&quot;pl-smi&quot;&gt;iface&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; (*iface)(unsafe.&lt;span class=&quot;pl-c1&quot;&gt;Pointer&lt;/span&gt;(&amp;amp;m))
    fmt.&lt;span class=&quot;pl-c1&quot;&gt;Printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;iface.tab.hash = &lt;span class=&quot;pl-c1&quot;&gt;%#x&lt;/span&gt;&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, iface.&lt;span class=&quot;pl-smi&quot;&gt;tab&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;hash&lt;/span&gt;) &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 0x615f3d8a&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's a match! &lt;code&gt;fmt.Printf(&quot;iface.tab.hash = %#x\n&quot;, iface.tab.hash)&lt;/code&gt; gives us &lt;code&gt;0x615f3d8a&lt;/code&gt;, which corresponds to the value that we've extracted from the contents of the ELF file.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We've reconstructed the complete &lt;code&gt;itab&lt;/code&gt; for our &lt;code&gt;iface&amp;lt;Mather, Adder&amp;gt;&lt;/code&gt; interface; it's all there in the executable, just waiting to be used, and already contains all the information that the runtime will need to make the interface behave as we expect.&lt;/p&gt;
&lt;p&gt;Of course, since an &lt;code&gt;itab&lt;/code&gt; is mostly composed of a bunch of pointers to other datastructures, we'd have to follow the virtual addresses present in the contents that we've extracted via &lt;code&gt;dd&lt;/code&gt; in order to reconstruct the complete picture.&lt;br/&gt;Speaking of pointers, we can now have a clear view of the virtual-table for &lt;code&gt;iface&amp;lt;Mather, Adder&amp;gt;&lt;/code&gt;; here's an annotated version of the contents of &lt;code&gt;go.itab.main.Adder,main.Mather&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ dd if=iface.bin of=/dev/stdout bs=1 count=40 skip=479552 &lt;span class=&quot;pl-k&quot;&gt;2&amp;gt;&lt;/span&gt;/dev/null &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; hexdump
0000000 bd20 0045 0000 0000 ed40 0045 0000 0000
0000010 3d8a 615f 0000 0000 c2d0 0044 0000 0000
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;                           ^^^^^^^^^^^^^^^^^^^&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;                       offset 0x18+8: itab.fun[0]&lt;/span&gt;
0000020 c350 0044 0000 0000                    
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;       ^^^^^^^^^^^^^^^^^^^&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; offset 0x20+8: itab.fun[1]&lt;/span&gt;
0000028
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ objdump -t -j .text iface.bin &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; grep 000000000044c2d0
000000000044c2d0 g     F .text  0000000000000079 main.(&lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt;Adder).Add
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ objdump -t -j .text iface.bin &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; grep 000000000044c350
000000000044c350 g     F .text  000000000000007f main.(&lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt;Adder).Sub
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Without surprise, the virtual table for &lt;code&gt;iface&amp;lt;Mather, Adder&amp;gt;&lt;/code&gt; holds two method pointers: &lt;code&gt;main.(*Adder).add&lt;/code&gt; and &lt;code&gt;main.(*Adder).sub&lt;/code&gt;.&lt;br/&gt;Well, actually, this &lt;em&gt;is&lt;/em&gt; a bit surprising: we've never defined these two methods to have pointer receivers.&lt;br/&gt;The compiler has generated these wrapper methods on our behalf (as we've described in the &lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md#implicit-dereferencing&quot;&gt;&quot;Implicit dereferencing&quot; section&lt;/a&gt;) because it knows that we're going to need them: since an interface can only hold pointers, and since our &lt;code&gt;Adder&lt;/code&gt; implementation of said interface only provides methods with value-receivers, we'll have to go through a wrapper at some point if we're going to call either of these methods via the virtual table of the interface.&lt;/p&gt;
&lt;p&gt;This should already give you a pretty good idea of how dynamic dispatch is handled at run time; which is what we will look at in the next section.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bonus&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I've hacked up a generic bash script that you can use to dump the contents of any symbol in any section of an ELF file (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/dump_sym.sh&quot;&gt;dump_sym.sh&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; ./dump_sym.sh bin_path section_name sym_name&lt;/span&gt;
$ ./dump_sym.sh iface.bin .rodata go.itab.main.Adder,main.Mather
.rodata file-offset: 315392
.rodata VMA: 4509696
go.itab.main.Adder,main.Mather VMA: 4673856
go.itab.main.Adder,main.Mather SIZE: 40

0000000 bd20 0045 0000 0000 ed40 0045 0000 0000
0000010 3d8a 615f 0000 0000 c2d0 0044 0000 0000
0000020 c350 0044 0000 0000                    
0000028
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I'd imagine there must exist an easier way to do what this script does, maybe some arcane flags or an obscure gem hidden inside the &lt;code&gt;binutils&lt;/code&gt; distribution.. who knows.&lt;br/&gt;If you've got some hints, don't hesitate to say so in the issues.&lt;/p&gt;
&lt;h2&gt;Dynamic dispatch&lt;/h2&gt;
&lt;p&gt;In this section we'll finally cover the main feature of interfaces: dynamic dispatch.&lt;br/&gt;Specifically, we'll look at how dynamic dispatch works under the hood, and how much we got to pay for it.&lt;/p&gt;
&lt;h3&gt;Indirect method call on interface&lt;/h3&gt;
&lt;p&gt;Let's have a look back at our code from earlier (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/iface.go&quot;&gt;iface.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Mather&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; {
    &lt;span class=&quot;pl-c1&quot;&gt;Add&lt;/span&gt;(a, b &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;
    &lt;span class=&quot;pl-c1&quot;&gt;Sub&lt;/span&gt;(a, b &lt;span class=&quot;pl-k&quot;&gt;int64&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;int64&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Adder&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt;{ id &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt; }
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;go:noinline&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;(&lt;span class=&quot;pl-v&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Adder&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Add&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt;) &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt; { &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a + b }
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;go:noinline&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;(&lt;span class=&quot;pl-v&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Adder&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Sub&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;int64&lt;/span&gt;) &lt;span class=&quot;pl-v&quot;&gt;int64&lt;/span&gt; { &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a - b }

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;() {
    &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Mather&lt;/span&gt;(Adder{id: &lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;})
    m.&lt;span class=&quot;pl-c1&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We've already had a deeper look into most of what happens in this piece of code: how the &lt;code&gt;iface&amp;lt;Mather, Adder&amp;gt;&lt;/code&gt; interface gets created, how it's laid out in the final exectutable, and how it ends up being loaded by the runtime.&lt;br/&gt;There's only one thing left for us to look at, and that is the actual indirect method call that follows: &lt;code&gt;m.Add(10, 32)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To refresh our memory, we'll zoom in on both the creation of the interface as well as on the method call itself:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Mather&lt;/span&gt;(Adder{id: &lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;})
m.&lt;span class=&quot;pl-c1&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Thankfully, we already have a fully annotated version of the assembly generated by the instantiation done on the first line (&lt;code&gt;m := Mather(Adder{id: 6754})&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; m := Mather(Adder{id: 6754})&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x001d&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL&lt;/span&gt;       &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..autotmp_1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;         ;; create an addressable $6754 value at 36(SP)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0025&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ      go.itab.&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Adder&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Mather(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;  ;; set up go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather..&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x002c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                            ;; ..as first argument (tab *itab)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0030&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ      &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..autotmp_1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;            ;; set up &amp;amp;36(SP)..&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0035&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                           ;; ..as second argument (elem unsafe.Pointer)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x003a&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; runtime.convT2I32(SB)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;               ;; runtime.convT2I32(go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather, &amp;amp;$6754)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x003f&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                          ;; AX now holds i.tab (go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0044&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                          ;; CX now holds i.data (&amp;amp;$6754, somewhere on the heap)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now, here's the assembly listing for the indirect method call that follows (&lt;code&gt;m.Add(10, 32)&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; m.Add(10, 32)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0049&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x004d&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;     &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;137438953482&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0057&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x005c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0060&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the knowdledge accumulated from the previous sections, these few instructions should be straightforward to understand.&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0049&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once &lt;code&gt;runtime.convT2I32&lt;/code&gt; has returned, &lt;code&gt;AX&lt;/code&gt; holds &lt;code&gt;i.tab&lt;/code&gt;, which as we know is a pointer to an &lt;code&gt;itab&lt;/code&gt;; and more specifically a pointer to &lt;code&gt;go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather&lt;/code&gt; in this case.&lt;br/&gt;By dereferencing &lt;code&gt;AX&lt;/code&gt; and offsetting 24 bytes forward, we reach &lt;code&gt;i.tab.fun&lt;/code&gt;, which corresponds to the first entry of the virtual table.&lt;br/&gt;Here's a reminder of what the offset table for &lt;code&gt;itab&lt;/code&gt; looks like:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; itab &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; { &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 32 bytes on a 64bit arch&lt;/span&gt;
    inter *interfacetype &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; offset 0x00 ($00)&lt;/span&gt;
    _type *_type         &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; offset 0x08 ($08)&lt;/span&gt;
    hash  &lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;       &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; offset 0x10 ($16)&lt;/span&gt;
    _     [&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;]&lt;span class=&quot;pl-k&quot;&gt;byte&lt;/span&gt;   &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; offset 0x14 ($20)&lt;/span&gt;
    fun   [&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;        &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; offset 0x18 ($24)&lt;/span&gt;
                         &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; offset 0x20 ($32)&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As we've seen in the previous section where we've reconstructed the final &lt;code&gt;itab&lt;/code&gt; directly from the executable, &lt;code&gt;iface.tab.fun[0]&lt;/code&gt; is a pointer to &lt;code&gt;main.(*Adder).add&lt;/code&gt;, which is the compiler-generated wrapper-method that wraps our original value-receiver &lt;code&gt;main.Adder.add&lt;/code&gt; method.&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x004d&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;       &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;137438953482&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0057&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We store &lt;code&gt;10&lt;/code&gt; and &lt;code&gt;32&lt;/code&gt; at the top of the stack, as arguments #2 &amp;amp; #3.&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x005c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0060&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once &lt;code&gt;runtime.convT2I32&lt;/code&gt; has returned, &lt;code&gt;CX&lt;/code&gt; holds &lt;code&gt;i.data&lt;/code&gt;, which is a pointer to our &lt;code&gt;Adder&lt;/code&gt; instance.&lt;br/&gt;We move this pointer to the top of stack, as argument #1, to satisfy the calling convention: the receiver for a method should always be passed as the first argument.&lt;/p&gt;
&lt;p&gt;Finally, with our stack all set up, we can do the actual call.&lt;/p&gt;
&lt;p&gt;We'll close this section with a complete annotated assembly listing of the entire process:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; m := Mather(Adder{id: 6754})&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x001d&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL&lt;/span&gt;       &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..autotmp_1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;         ;; create an addressable $6754 value at 36(SP)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0025&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ      go.itab.&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Adder&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Mather(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;  ;; set up go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather..&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x002c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                            ;; ..as first argument (tab *itab)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0030&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ      &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..autotmp_1&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;            ;; set up &amp;amp;36(SP)..&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0035&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                           ;; ..as second argument (elem unsafe.Pointer)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x003a&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; runtime.convT2I32(SB)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;               ;; runtime.convT2I32(go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather, &amp;amp;$6754)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x003f&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                          ;; AX now holds i.tab (go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0044&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                          ;; CX now holds i.data (&amp;amp;$6754, somewhere on the heap)&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; m.Add(10, 32)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0049&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                          ;; AX now holds (*iface.tab)+0x18, i.e. iface.tab.fun[0]&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x004d&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;     &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;137438953482&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                   ;; move (32,10) to..&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0057&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                           ;; ..the top of the stack (arguments #3 &amp;amp; #2)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x005c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                            ;; CX, which holds &amp;amp;$6754 (i.e., our receiver), gets moved to&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;                                                    ;; ..the top of stack (argument #1 -&amp;gt; receiver)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0060&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                                  ;; you know the drill&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We now have a clear picture of the entire machinery required for interfaces and virtual method calls to work.&lt;br/&gt;In the next section, we'll measure the actual cost of this machinery, in theory as well as in practice.&lt;/p&gt;
&lt;h3&gt;Overhead&lt;/h3&gt;
&lt;p&gt;As we've seen, the implementation of interfaces delegates most of the work on both the compiler and the linker. From a performance standpoint, this is obviously very good news: we effectively want to relieve the runtime from as much work as possible.&lt;br/&gt;There do exist some specific cases where instantiating an interface may also require the runtime to get to work (e.g. the &lt;code&gt;runtime.convT2*&lt;/code&gt; family of functions), though they are not so prevalent in practice.&lt;br/&gt;We'll learn more about these edge cases in the &lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md#special-cases--compiler-tricks&quot;&gt;section dedicated to the special cases of interfaces&lt;/a&gt;. In the meantime, we'll concentrate purely on the overhead of virtual method calls and ignore the one-time costs related to instantiation.&lt;/p&gt;
&lt;p&gt;Once an interface has been properly instantiated, calling methods on it is nothing more than going through one more layer of indirection compared to the usual statically dispatched call (i.e. dereferencing &lt;code&gt;itab.fun&lt;/code&gt; at the desired index).&lt;br/&gt;As such, one would imagine this process to be virtually free.. and one would be kind of right, but not quite: the theory is a bit tricky, and the reality even trickier still.&lt;/p&gt;
&lt;h4&gt;The theory: quick refresher on modern CPUs&lt;/h4&gt;
&lt;p&gt;The extra indirection inherent to virtual calls is, in and of itself, effectively free &lt;em&gt;for as long as it is somewhat predictable from the standpoint of the CPU&lt;/em&gt;.&lt;br/&gt;Modern CPUs are very aggressive beasts: they cache aggressively, they aggressively pre-fetch both instructions &amp;amp; data, they pre-execute code aggressively, they even reorder and parallelize it as they see fit.&lt;br/&gt;All of this extra work is done whether we want it or not, hence we should always strive not to get in the way of the CPU's efforts to be extra smart, so all of these precious cycles don't go needlessly wasted.&lt;/p&gt;
&lt;p&gt;This is where virtual method calls can quickly become a problem.&lt;/p&gt;
&lt;p&gt;In the case of a statically dispatched call, the CPU has foreknowledge of the upcoming branch in the program and pre-fetches the necessary instructions accordingly. This makes up for a smooth, transparent transition from one branch of the program to the other as far as performance is concerned.&lt;br/&gt;With dynamic dispatch, on the other hand, the CPU cannot know in advance where the program is heading: it all depends on computations whose results are, by definition, not known until run time. To counter-balance this, the CPU applies various algorithms and heuristics in order to guess where the program is going to branch next (i.e. &quot;branch prediction&quot;).&lt;/p&gt;
&lt;p&gt;If the processor guesses correctly, we can expect a dynamic branch to be almost as efficient as a static one, since the instructions of the landing site have already been pre-fetched into the processor's caches anyway.&lt;/p&gt;
&lt;p&gt;If it gets things wrong, though, things can get a bit rough: first, of course, we'll have to pay for the extra indirection plus the corresponding (slow) load from main memory (i.e. the CPU is effectively stalled) to load the right instructions into the L1i cache. Even worse, we'll have to pay for the price of the CPU backtracking in its own mistakes and flushing its instruction pipeline following the branch misprediction.&lt;br/&gt;Another important downside of dynamic dispatch is that it makes inlining impossible by definition: one simply cannot inline what they don't know is coming.&lt;/p&gt;
&lt;p&gt;All in all, it should, at least in theory, be very possible to end up with massive differences in performance between a direct call to an inlined function F, and a call to that same function that couldn't be inlined and had to go through some extra layers of indirection, and maybe even got hit by a branch misprediction on its way.&lt;/p&gt;
&lt;p&gt;That's mostly it for the theory.&lt;br/&gt;When it comes to modern hardware, though, one should always be wary of the theory.&lt;/p&gt;
&lt;p&gt;Let's measure this stuff.&lt;/p&gt;
&lt;h4&gt;The practice: benchmarks&lt;/h4&gt;
&lt;p&gt;First things first, some information about the CPU we're running on:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ lscpu &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; sed -nr &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;/Model name/ s/.*:\s*(.* @ .*)/\1/p&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We'll define the interface used for our benchmarks as such (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/iface_bench_test.go&quot;&gt;iface_bench_test.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; identifier &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; {
    &lt;span class=&quot;pl-c1&quot;&gt;idInline&lt;/span&gt;() &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;
    &lt;span class=&quot;pl-c1&quot;&gt;idNoInline&lt;/span&gt;() &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; id32 &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt;{ id &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt; }

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; NOTE: Use pointer receivers so we don't measure the extra overhead incurred by&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; autogenerated wrappers as part of our results.&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;(&lt;span class=&quot;pl-v&quot;&gt;id&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;id32&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;idInline&lt;/span&gt;&lt;/span&gt;() &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt; { &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; id.&lt;span class=&quot;pl-smi&quot;&gt;id&lt;/span&gt; }
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;go:noinline&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;(&lt;span class=&quot;pl-v&quot;&gt;id&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;id32&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;idNoInline&lt;/span&gt;&lt;/span&gt;() &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt; { &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; id.&lt;span class=&quot;pl-smi&quot;&gt;id&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Benchmark suite A: single instance, many calls, inlined &amp;amp; non-inlined&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For our first two benchmarks, we'll try calling a non-inlined method inside a busy-loop, on both an &lt;code&gt;*Adder&lt;/code&gt; value and a &lt;code&gt;iface&amp;lt;Mather, *Adder&amp;gt;&lt;/code&gt; interface:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;escapeMePlease&lt;/span&gt; *id32
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; escapeToHeap makes sure that `id` escapes to the heap.&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; In simple situations such as some of the benchmarks present in this file,&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; the compiler is able to statically infer the underlying type of the&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; interface (or rather the type of the data it points to, to be pedantic) and&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ends up replacing what should have been a dynamic method call by a&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; static call.&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; This anti-optimization prevents this extra cleverness.&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;go:noinline&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;escapeToHeap&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;id&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;id32&lt;/span&gt;) &lt;span class=&quot;pl-v&quot;&gt;identifier&lt;/span&gt; {
    escapeMePlease = id
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; escapeMePlease
}

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;myID&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;BenchmarkMethodCall_direct&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;testing&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;B&lt;/span&gt;) {
    b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;single/noinline&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
        &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;escapeToHeap&lt;/span&gt;(&amp;amp;id32{id: &lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;}).(*id32)
        &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; CALL &quot;&quot;.(*id32).idNoInline(SB)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVL 8(SP), AX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ &quot;&quot;.&amp;amp;myID+40(SP), CX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVL AX, (CX)&lt;/span&gt;
            myID = m.&lt;span class=&quot;pl-c1&quot;&gt;idNoInline&lt;/span&gt;()
        }
    })
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;BenchmarkMethodCall_interface&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;testing&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;B&lt;/span&gt;) {
    b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;single/noinline&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
        &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;escapeToHeap&lt;/span&gt;(&amp;amp;id32{id: &lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;})
        &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ 32(AX), CX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ &quot;&quot;.m.data+40(SP), DX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ DX, (SP)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; CALL CX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVL 8(SP), AX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ &quot;&quot;.&amp;amp;myID+48(SP), CX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVL AX, (CX)&lt;/span&gt;
            myID = m.&lt;span class=&quot;pl-c1&quot;&gt;idNoInline&lt;/span&gt;()
        }
    })
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We expect both benchmarks to run A) extremely fast and B) at almost the same speeds.&lt;/p&gt;
&lt;p&gt;Given the tightness of the loop, we can expect both benchmarks to have their data (receiver &amp;amp; vtable) and instructions (&lt;code&gt;&quot;&quot;.(*id32).idNoInline&lt;/code&gt;) already be present in the L1d/L1i caches of the CPU for each iteration of the loop. I.e., performance should be purely CPU-bound.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BenchmarkMethodCall_interface&lt;/code&gt; should run a bit slower (on the nanosecond scale) though, as it has to deal with the overhead of finding &amp;amp; copying the right pointer from the virtual table (which is already in the L1 cache, though).&lt;br/&gt;Since the &lt;code&gt;CALL CX&lt;/code&gt; instruction has a strong dependency on the output of these few extra instructions required to consult the vtable, the processor has no choice but to execute all of this extra logic as a sequential stream, leaving any chance of instruction-level parallelization on the table.&lt;br/&gt;This is ultimately the main reason why we would expect the &quot;interface&quot; version to run a bit slower.&lt;/p&gt;
&lt;p&gt;We end up with the following results for the &quot;direct&quot; version:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; -run=NONE -o iface_bench_test.bin iface_bench_test.go &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; \
  perf stat --cpu=1 \
  taskset 2 \
  ./iface_bench_test.bin -test.cpu=1 -test.benchtime=1s -test.count=3 \
      -test.bench=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;BenchmarkMethodCall_direct/single/noinline&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
BenchmarkMethodCall_direct/single/noinline              2000000000               1.81 ns/op
BenchmarkMethodCall_direct/single/noinline              2000000000               1.80 ns/op
BenchmarkMethodCall_direct/single/noinline              2000000000               1.80 ns/op

 Performance counter stats &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;CPU(s) 1&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;:

      11702.303843      cpu-clock (msec)          &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    1.000 CPUs utilized          &lt;/span&gt;
             2,481      context-switches          &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    0.212 K/sec                  &lt;/span&gt;
                 1      cpu-migrations            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    0.000 K/sec                  &lt;/span&gt;
             7,349      page-faults               &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    0.628 K/sec                  &lt;/span&gt;
    43,726,491,825      cycles                    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    3.737 GHz                    &lt;/span&gt;
   110,979,100,648      instructions              &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    2.54  insn per cycle         &lt;/span&gt;
    19,646,440,556      branches                  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 1678.852 M/sec                  &lt;/span&gt;
           566,424      branch-misses             &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    0.00% of all branches        &lt;/span&gt;

      11.702332281 seconds &lt;span class=&quot;pl-k&quot;&gt;time&lt;/span&gt; elapsed
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And here's for the &quot;interface&quot; version:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; -run=NONE -o iface_bench_test.bin iface_bench_test.go &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; \
  perf stat --cpu=1 \
  taskset 2 \
  ./iface_bench_test.bin -test.cpu=1 -test.benchtime=1s -test.count=3 \
      -test.bench=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;BenchmarkMethodCall_interface/single/noinline&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
BenchmarkMethodCall_interface/single/noinline           2000000000               1.95 ns/op
BenchmarkMethodCall_interface/single/noinline           2000000000               1.96 ns/op
BenchmarkMethodCall_interface/single/noinline           2000000000               1.96 ns/op

 Performance counter stats &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;CPU(s) 1&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;:

      12709.383862      cpu-clock (msec)          &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    1.000 CPUs utilized          &lt;/span&gt;
             3,003      context-switches          &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    0.236 K/sec                  &lt;/span&gt;
                 1      cpu-migrations            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    0.000 K/sec                  &lt;/span&gt;
            10,524      page-faults               &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    0.828 K/sec                  &lt;/span&gt;
    47,301,533,147      cycles                    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    3.722 GHz                    &lt;/span&gt;
   124,467,105,161      instructions              &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    2.63  insn per cycle         &lt;/span&gt;
    19,878,711,448      branches                  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 1564.097 M/sec                  &lt;/span&gt;
           761,899      branch-misses             &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    0.00% of all branches        &lt;/span&gt;

      12.709412950 seconds &lt;span class=&quot;pl-k&quot;&gt;time&lt;/span&gt; elapsed
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The results match our expectations: the &quot;interface&quot; version is indeed a bit slower, with approximately 0.15 extra nanoseconds per iteration, or a ~8% slowdown.&lt;br/&gt;8% might sound like a noticeable difference at first, but we have to keep in mind that A) these are nanosecond-scale measurements and B) the method being called does so little work that it magnifies even more the overhead of the call.&lt;/p&gt;
&lt;p&gt;Looking at the number of instructions per benchmark, we see that the interface-based version has had to execute for ~14 billion more instructions compared to the &quot;direct&quot; version (&lt;code&gt;110,979,100,648&lt;/code&gt; vs. &lt;code&gt;124,467,105,161&lt;/code&gt;), even though both benchmarks were run for &lt;code&gt;6,000,000,000&lt;/code&gt; (&lt;code&gt;2,000,000,000\*3&lt;/code&gt;) iterations.&lt;br/&gt;As we've mentionned before, the CPU cannot parallelize these extra instructions due to the &lt;code&gt;CALL&lt;/code&gt; depending on them, which gets reflected quite clearly in the instruction-per-cycle ratio: both benchmarks end up with a similar IPC ratio (&lt;code&gt;2.54&lt;/code&gt; vs. &lt;code&gt;2.63&lt;/code&gt;) even though the &quot;interface&quot; version has much more work to do overall.&lt;br/&gt;This lack of parallelism piles up to an extra ~3.5 billion CPU cycles for the &quot;interface&quot; version, which is where those extra 0.15ns that we've measured are actually spent.&lt;/p&gt;
&lt;p&gt;Now what happens when we let the compiler inline the method call?&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;myID&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;BenchmarkMethodCall_direct&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;testing&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;B&lt;/span&gt;) {
    b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;single/inline&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
        &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;escapeToHeap&lt;/span&gt;(&amp;amp;id32{id: &lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;}).(*id32)
        b.&lt;span class=&quot;pl-c1&quot;&gt;ResetTimer&lt;/span&gt;()
        &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVL (DX), SI&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVL SI, (CX)&lt;/span&gt;
            myID = m.&lt;span class=&quot;pl-c1&quot;&gt;idInline&lt;/span&gt;()
        }
    })
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;BenchmarkMethodCall_interface&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;testing&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;B&lt;/span&gt;) {
    b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;single/inline&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
        &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;escapeToHeap&lt;/span&gt;(&amp;amp;id32{id: &lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;})
        b.&lt;span class=&quot;pl-c1&quot;&gt;ResetTimer&lt;/span&gt;()
        &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ 32(AX), CX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ &quot;&quot;.m.data+40(SP), DX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ DX, (SP)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; CALL CX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVL 8(SP), AX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ &quot;&quot;.&amp;amp;myID+48(SP), CX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVL AX, (CX)&lt;/span&gt;
            myID = m.&lt;span class=&quot;pl-c1&quot;&gt;idNoInline&lt;/span&gt;()
        }
    })
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Two things jump out at us:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;BenchmarkMethodCall_direct&lt;/code&gt;: Thanks to inlining, the call has been reduced to a simple pair of memory moves.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BenchmarkMethodCall_interface&lt;/code&gt;: Due to dynamic dispatch, the compiler has been unable to inline the call, thus the generated assembly ends up being exactly the same as before.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;We won't even bother running &lt;code&gt;BenchmarkMethodCall_interface&lt;/code&gt; since the code hasn't changed a bit.&lt;br/&gt;Let's have a quick look at the &quot;direct&quot; version though:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; -run=NONE -o iface_bench_test.bin iface_bench_test.go &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; \
  perf stat --cpu=1 \
  taskset 2 \
  ./iface_bench_test.bin -test.cpu=1 -test.benchtime=1s -test.count=3 \
      -test.bench=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;BenchmarkMethodCall_direct/single/inline&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
BenchmarkMethodCall_direct/single/inline                2000000000               0.35 ns/op
BenchmarkMethodCall_direct/single/inline                2000000000               0.34 ns/op
BenchmarkMethodCall_direct/single/inline                2000000000               0.34 ns/op

 Performance counter stats &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;CPU(s) 1&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;:

       2464.353001      cpu-clock (msec)          &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    1.000 CPUs utilized          &lt;/span&gt;
               629      context-switches          &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    0.255 K/sec                  &lt;/span&gt;
                 1      cpu-migrations            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    0.000 K/sec                  &lt;/span&gt;
             7,322      page-faults               &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    0.003 M/sec                  &lt;/span&gt;
     9,026,867,915      cycles                    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    3.663 GHz                    &lt;/span&gt;
    41,580,825,875      instructions              &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    4.61  insn per cycle         &lt;/span&gt;
     7,027,066,264      branches                  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 2851.485 M/sec                  &lt;/span&gt;
         1,134,955      branch-misses             &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;    0.02% of all branches        &lt;/span&gt;

       2.464386341 seconds &lt;span class=&quot;pl-k&quot;&gt;time&lt;/span&gt; elapsed
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As expected, this runs ridiculously fast now that the overhead of the call is gone.&lt;br/&gt;With ~0.34ns per op for the &quot;direct&quot; inlined version, the &quot;interface&quot; version is now ~475% slower, quite a steep drop from the ~8% difference that we've measured earlier with inlining disabled.&lt;/p&gt;
&lt;p&gt;Notice how, with the branching inherent to the method call now gone, the CPU is able to parallelize and speculatively execute the remaining instructions much more efficiently, reaching an IPC ratio of 4.61.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Benchmark suite B: many instances, many non-inlined calls, small/big/pseudo-random iterations&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For this second benchmark suite, we'll look at a more real-world-like situation in which an iterator goes through a slice of objects that all expose a common method and calls it for each object.&lt;br/&gt;To better mimic reality, we'll disable inlining, as most methods called this way in a real program would most likely by sufficiently complex not to be inlined by the compiler (YMMV; a good counter-example of this is the &lt;code&gt;sort.Interface&lt;/code&gt; interface from the standard library).&lt;/p&gt;
&lt;p&gt;We'll define 3 similar benchmarks that just differ in the way they access this slice of objects; the goal being to simulate decreasing levels of cache friendliness:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;In the first case, the iterator walks the array in order, calls the method, then gets incremented by the size of one object for each iteration.&lt;/li&gt;
&lt;li&gt;In the second case, the iterator still walks the slice in order, but this time gets incremented by a value that's larger than the size of a single cache-line.&lt;/li&gt;
&lt;li&gt;Finally, in the third case, the iterator will pseudo-randomly steps through the slice.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;In all three cases, we'll make sure that the array is big enough not to fit entirely in any of the processor's caches in order to simulate (not-so-accurately) a very busy server that's putting a lot of pressure of both its CPU caches and main memory.&lt;/p&gt;
&lt;p&gt;Here's a quick recap of the processor's attributes, we'll design the benchmarks accordingly:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ lscpu &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; sed -nr &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;/Model name/ s/.*:\s*(.* @ .*)/\1/p&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz
$ lscpu &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; grep cache
L1d cache:           32K
L1i cache:           32K
L2 cache:            256K
L3 cache:            6144K
$ getconf LEVEL1_DCACHE_LINESIZE
64
$ getconf LEVEL1_ICACHE_LINESIZE
64
$ find /sys/devices/system/cpu/cpu0/cache/index{1,2,3} -name &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;shared_cpu_list&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; -exec cat {} &lt;span class=&quot;pl-cce&quot;&gt;\;&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; (annotations are mine)&lt;/span&gt;
0,4 &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; L1 (hyperthreading)&lt;/span&gt;
0,4 &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; L2 (hyperthreading)&lt;/span&gt;
0-7 &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; L3 (shared + hyperthreading)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here's what the benchmark suite looks like for the &quot;direct&quot; version (the benchmarks marked as &lt;code&gt;baseline&lt;/code&gt; compute the cost of retrieving the receiver in isolation, so that we can subtract that cost from the final measurements):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; _maxSize = &lt;span class=&quot;pl-c1&quot;&gt;2097152&lt;/span&gt;             &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 2^21&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; _maxSizeModMask = _maxSize - &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; avoids a mod (%) in the hot path&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;_randIndexes&lt;/span&gt; = [_maxSize]&lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt;{}
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;init&lt;/span&gt;() {
    rand.&lt;span class=&quot;pl-c1&quot;&gt;Seed&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;42&lt;/span&gt;)
    &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;range&lt;/span&gt; _randIndexes {
        _randIndexes[i] = rand.&lt;span class=&quot;pl-c1&quot;&gt;Intn&lt;/span&gt;(_maxSize)
    }
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;BenchmarkMethodCall_direct&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;testing&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;B&lt;/span&gt;) {
    &lt;span class=&quot;pl-smi&quot;&gt;adders&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;make&lt;/span&gt;([]*id32, _maxSize)
    &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;range&lt;/span&gt; adders {
        adders[i] = &amp;amp;id32{id: &lt;span class=&quot;pl-c1&quot;&gt;int32&lt;/span&gt;(i)}
    }
    runtime.&lt;span class=&quot;pl-c1&quot;&gt;GC&lt;/span&gt;()

    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;myID&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;

    b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;many/noinline/small_incr&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt; *id32
        b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;baseline&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
            &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
                m = adders[i&amp;amp;_maxSizeModMask]
            }
        })
        b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;call&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
            &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
                m = adders[i&amp;amp;_maxSizeModMask]
                myID = m.&lt;span class=&quot;pl-c1&quot;&gt;idNoInline&lt;/span&gt;()
            }
        })
    })
    b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;many/noinline/big_incr&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt; *id32
        b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;baseline&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
            &lt;span class=&quot;pl-smi&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;
            &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
                m = adders[j&amp;amp;_maxSizeModMask]
                j += &lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;
            }
        })
        b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;call&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
            &lt;span class=&quot;pl-smi&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;
            &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
                m = adders[j&amp;amp;_maxSizeModMask]
                myID = m.&lt;span class=&quot;pl-c1&quot;&gt;idNoInline&lt;/span&gt;()
                j += &lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;
            }
        })
    })
    b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;many/noinline/random_incr&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt; *id32
        b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;baseline&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
            &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
                m = adders[_randIndexes[i&amp;amp;_maxSizeModMask]]
            }
        })
        b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;call&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
            &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
                m = adders[_randIndexes[i&amp;amp;_maxSizeModMask]]
                myID = m.&lt;span class=&quot;pl-c1&quot;&gt;idNoInline&lt;/span&gt;()
            }
        })
    })
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The benchmark suite for the &quot;interface&quot; version is identical, except that the array is initialized with interface values instead of pointers to the concrete type, as one would expect:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;BenchmarkMethodCall_interface&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;testing&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;B&lt;/span&gt;) {
    &lt;span class=&quot;pl-smi&quot;&gt;adders&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;make&lt;/span&gt;([]identifier, _maxSize)
    &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;range&lt;/span&gt; adders {
        adders[i] = &lt;span class=&quot;pl-c1&quot;&gt;identifier&lt;/span&gt;(&amp;amp;id32{id: &lt;span class=&quot;pl-c1&quot;&gt;int32&lt;/span&gt;(i)})
    }
    runtime.&lt;span class=&quot;pl-c1&quot;&gt;GC&lt;/span&gt;()

    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; ... &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the &quot;direct&quot; suite, we get the following results:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; -run=NONE -o iface_bench_test.bin iface_bench_test.go &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; \
  benchstat &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&amp;lt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;    taskset 2 ./iface_bench_test.bin -test.cpu=1 -test.benchtime=1s -test.count=3 \&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;      -test.bench=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;BenchmarkMethodCall_direct/many/noinline&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;)&lt;/span&gt;&lt;/span&gt;
name                                                  time/op
MethodCall_direct/many/noinline/small_incr/baseline   0.99ns ± 3%
MethodCall_direct/many/noinline/small_incr/call       2.32ns ± 1% &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 2.32 - 0.99 = 1.33ns&lt;/span&gt;
MethodCall_direct/many/noinline/big_incr/baseline     5.86ns ± 0%
MethodCall_direct/many/noinline/big_incr/call         17.1ns ± 1% &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 17.1 - 5.86 = 11.24ns&lt;/span&gt;
MethodCall_direct/many/noinline/random_incr/baseline  8.80ns ± 0%
MethodCall_direct/many/noinline/random_incr/call      30.8ns ± 0% &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 30.8 - 8.8 = 22ns&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There really are no surprises here:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;small_incr&lt;/code&gt;: By being &lt;em&gt;extremely&lt;/em&gt; cache-friendly, we obtain results similar to the previous benchmark that looped over a single instance.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;big_incr&lt;/code&gt;: By forcing the CPU to fetch a new cache-line at every iteration, we do see a noticeable bump in latencies, which is completely unrelated to the cost of doing the call, though: ~6ns are attributable to the baseline while the rest is a combination of the cost of dereferencing the receiver in order to get to its &lt;code&gt;id&lt;/code&gt; field and copying around the return value.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;random_incr&lt;/code&gt;: Same remarks as with &lt;code&gt;big_incr&lt;/code&gt;, except that the bump in latencies is even more pronounced due to A) the pseudo-random accesses and B) the cost of retrieving the next index from the pre-computed array of indexes (which triggers cache misses in and of itself).&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;As logic would dictate, thrashing the CPU d-caches doesn't seem to influence the latency of the actual direct method call (inlined or not) by any mean, although it does make everything that surrounds it slower.&lt;/p&gt;
&lt;p&gt;What about dynamic dispatch?&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; -run=NONE -o iface_bench_test.bin iface_bench_test.go &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; \
  benchstat &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&amp;lt;(&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;    taskset 2 ./iface_bench_test.bin -test.cpu=1 -test.benchtime=1s -test.count=3 \&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;      -test.bench=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;BenchmarkMethodCall_interface/many/inline&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;)&lt;/span&gt;&lt;/span&gt;
name                                                     time/op
MethodCall_interface/many/noinline/small_incr/baseline   1.38ns ± 0%
MethodCall_interface/many/noinline/small_incr/call       3.48ns ± 0% &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 3.48 - 1.38 = 2.1ns&lt;/span&gt;
MethodCall_interface/many/noinline/big_incr/baseline     6.86ns ± 0%
MethodCall_interface/many/noinline/big_incr/call         19.6ns ± 1% &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 19.6 - 6.86 = 12.74ns&lt;/span&gt;
MethodCall_interface/many/noinline/random_incr/baseline  11.0ns ± 0%
MethodCall_interface/many/noinline/random_incr/call      34.7ns ± 0% &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 34.7 - 11.0 = 23.7ns&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The results are extremely similar, albeit a tiny bit slower overall simply due to the fact that we're copying two quad-words (i.e. both fields of an &lt;code&gt;identifier&lt;/code&gt; interface) out of the slice at each iteration instead of one (a pointer to &lt;code&gt;id32&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;The reason this runs almost as fast as its &quot;direct&quot; counterpart is that, since all the interfaces in the slice share a common &lt;code&gt;itab&lt;/code&gt; (i.e. they're all &lt;code&gt;iface&amp;lt;Mather, Adder&amp;gt;&lt;/code&gt; interfaces), their associated virtual table never leaves the L1d cache and so fetching the right method pointer at each iteration is virtually free.&lt;br/&gt;Likewise, the instructions that make up the body of the &lt;code&gt;main.(*id32).idNoInline&lt;/code&gt; method never leave the L1i cache.&lt;/p&gt;
&lt;p&gt;One might think that, in practice, a slice of interfaces would encompass many different underlying types (and thus vtables), which would result in thrashing of both the L1i and L1d caches due to the varying vtables pushing each other out.&lt;br/&gt;While that holds true in theory, these kinds of thoughts tend to be the result of years of experience using older OOP languages such as C++ that (used to, at least) encourage the use of deeply-nested hierarchies of inherited classes and virtual calls as their main tool of abstraction.&lt;br/&gt;With big enough hierarchies, the number of associated vtables could sometimes get large enough to thrash the CPU caches when iterating over a datastructure holding various implementations of a virtual class (think e.g. of a GUI framework where everything is a &lt;code&gt;Widget&lt;/code&gt; stored in a graph-like datastructure); especially so that, in C++ at least, virtual classes tend to specify quite complex behaviors, sometimes with dozen of methods, resulting in quite big vtables and even more pressure on the L1d cache.&lt;/p&gt;
&lt;p&gt;Go, on the other hand, has very different idioms: OOP has been completely thrown out of the window, the type system flattened, and interfaces are most often used to describe minimal, constrained behaviors (a few methods at most an average, helped by the fact that interfaces are implicitly satisfied) instead of being used as an abstraction on top of a more complex, layered type hierarchy.&lt;br/&gt;In practice, in Go, I've found it's very rare to have to iterate over a set of interfaces that carry many different underlying types. YMMV, of course.&lt;/p&gt;
&lt;p&gt;For the curious-minded, here's what the results of the &quot;direct&quot; version would have looked like with inlining enabled:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
name                                                time/op
MethodCall_direct/many/inline/small_incr            0.97ns ± 1% &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 0.97ns&lt;/span&gt;
MethodCall_direct/many/inline/big_incr/baseline     5.96ns ± 1%
MethodCall_direct/many/inline/big_incr/call         11.9ns ± 1% &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 11.9 - 5.96 = 5.94ns&lt;/span&gt;
MethodCall_direct/many/inline/random_incr/baseline  9.20ns ± 1%
MethodCall_direct/many/inline/random_incr/call      16.9ns ± 1% &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 16.9 - 9.2 = 7.7ns&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which would have made the &quot;direct&quot; version around 2 to 3 times faster than the &quot;interface&quot; version in cases where the compiler would have been able to inline the call.&lt;br/&gt;Then again, as we've mentionned earlier, the limited capabilities of the current compiler with regards to inlining mean that, in practice, these kind of wins would rarely be seen. And of course, there often are times when you really don't have a choice but to resort to virtual calls anyway.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Effectively measuring the latency of a virtual call turned out to be quite a complex endeavor, as most of it is the direct consequence of many intertwined side-effects that result from the very complex implementation details of modern hardware.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;In Go&lt;/em&gt;, thanks to the idioms encouraged by the design of the language, and taking into account the (current) limitations of the compiler with regards to inlining, one could effectively consider dynamic dispatch as virtually free.&lt;br/&gt;Still, when in doubt, one should always measure their hot paths and look at the relevant performance counters to assert with certainty whether dynamic dispatch ends up being an issue or not.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(NOTE: We will look at the inlining capabilities of the compiler in a later chapter of this book.&lt;/em&gt;)&lt;/p&gt;
&lt;h2&gt;Special cases &amp;amp; compiler tricks&lt;/h2&gt;
&lt;p&gt;This section will review some of the most common special cases that we encounter every day when dealing with interfaces.&lt;/p&gt;
&lt;p&gt;By now you should have a pretty clear idea of how interfaces work, so we'll try and aim for conciseness here.&lt;/p&gt;
&lt;h3&gt;The empty interface&lt;/h3&gt;
&lt;p&gt;The datastructure for the empty interface is what you'd intuitively think it would be: an &lt;code&gt;iface&lt;/code&gt; without an &lt;code&gt;itab&lt;/code&gt;.&lt;br/&gt;There are two reasons for that:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Since the empty interface has no methods, everything related to dynamic dispatch can safely be dropped from the datastructure.&lt;/li&gt;
&lt;li&gt;With the virtual table gone, the type of the empty interface itself, not to be confused with the type of the data it holds, is always the same (i.e. we talk about &lt;em&gt;the&lt;/em&gt; empty interface rather than &lt;em&gt;an&lt;/em&gt; empty interface).&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;em&gt;NOTE: Similar to the notation we used for &lt;code&gt;iface&lt;/code&gt;, we'll denote the empty interface holding a type T as &lt;code&gt;eface&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;eface&lt;/code&gt; is the root type that represents the empty interface within the runtime (&lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/runtime2.go#L148-L151&quot;&gt;src/runtime/runtime2.go&lt;/a&gt;).&lt;br/&gt;Its definition goes like this:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; eface &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; { &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 16 bytes on a 64bit arch&lt;/span&gt;
    _type *_type
    data  unsafe.&lt;span class=&quot;pl-smi&quot;&gt;Pointer&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where &lt;code&gt;_type&lt;/code&gt; holds the type information of the value pointed to by &lt;code&gt;data&lt;/code&gt;.&lt;br/&gt;As expected, the &lt;code&gt;itab&lt;/code&gt; has been dropped entirely.&lt;/p&gt;
&lt;p&gt;While the empty interface could just reuse the &lt;code&gt;iface&lt;/code&gt; datastructure (it is a superset of &lt;code&gt;eface&lt;/code&gt; after all), the runtime chooses to distinguish the two for two main reasons: space efficiency and code clarity.&lt;/p&gt;
&lt;h3&gt;Interface holding a scalar type&lt;/h3&gt;
&lt;p&gt;Earlier in this chapter (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md#overview-of-the-datastructures&quot;&gt;#Anatomy of an Interface&lt;/a&gt;), we've mentionned that even storing a simple scalar type such as an integer into an interface will result in a heap allocation.&lt;br/&gt;It's time we see why, and how.&lt;/p&gt;
&lt;p&gt;Consider these two benchmarks (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/eface_scalar_test.go&quot;&gt;eface_scalar_test.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;BenchmarkEfaceScalar&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;testing&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;B&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Uint&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;
    b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;uint32&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
            Uint = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(i)
        }
    })
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Eface&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt;{}
    b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;eface32&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
            Eface = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(i)
        }
    })
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; -benchmem -bench=. ./eface_scalar_test.go
BenchmarkEfaceScalar/uint32-8           2000000000         0.54 ns/op     0 B/op     0 allocs/op
BenchmarkEfaceScalar/eface32-8           100000000         12.3 ns/op     4 B/op     1 allocs/op
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;That's a 2-orders-of-magnitude difference in performance for a simple assignment operation, and&lt;/li&gt;
&lt;li&gt;we can see that the second benchmark has to allocate 4 extra bytes at each iteration.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Clearly, some hidden heavy machinery is being set off in the second case: we need to have a look at the generated assembly.&lt;/p&gt;
&lt;p&gt;For the first benchmark, the compiler generates exactly what you'd expect it to with regard to the assignment operation:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; Uint = uint32(i)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x000d&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL      &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the second benchmark, though, things get far more complex:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; Eface = uint32(i)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0050&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL      &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..autotmp_3&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0054&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ      type.uint32(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x005b&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x005f&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ      &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..autotmp_3&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0064&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0069&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; runtime.convT2E32(SB)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x006e&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0073&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0078&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.&amp;amp;Eface&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;48&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x007d&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0080&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL      runtime.writeBarrier(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0086&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ      &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DI&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x008a&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; TESTL     &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x008c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JNE&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;148&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x008e&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0092&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JMP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;46&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0094&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; runtime.gcWriteBarrier(SB)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0099&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JMP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;46&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is &lt;em&gt;just&lt;/em&gt; the assignment, not the complete benchmark!&lt;br/&gt;We'll have to study this code piece by piece.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1: Create the interface&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0050&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL        &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..autotmp_3&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0054&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ      type.uint32(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x005b&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x005f&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ      &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;..autotmp_3&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0064&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0069&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; runtime.convT2E32(SB)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x006e&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0073&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This first piece of the listing instantiates the empty interface &lt;code&gt;eface&amp;lt;uint32&amp;gt;&lt;/code&gt; that we will later assign to &lt;code&gt;Eface&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We've already studied similar code in the section about creating interfaces (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md#creating-an-interface&quot;&gt;#Creating an interface&lt;/a&gt;), except that this code was calling &lt;code&gt;runtime.convT2I32&lt;/code&gt; instead of &lt;code&gt;runtime.convT2E32&lt;/code&gt; here; nonetheless, this should look very familiar.&lt;/p&gt;
&lt;p&gt;It turns out that &lt;code&gt;runtime.convT2I32&lt;/code&gt; and &lt;code&gt;runtime.convT2E32&lt;/code&gt; are part of a larger family of functions whose job is to instanciate either a specific interface or the empty interface from a scalar value (or a string or slice, as special cases).&lt;br/&gt;This family is composed of 10 symbols, one for each combination of &lt;code&gt;(eface/iface, 16/32/64/string/slice)&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; empty interface from scalar value&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;convT2E16&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;t&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;_type&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;Pointer&lt;/span&gt;) (&lt;span class=&quot;pl-v&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;eface&lt;/span&gt;) {}
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;convT2E32&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;t&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;_type&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;Pointer&lt;/span&gt;) (&lt;span class=&quot;pl-v&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;eface&lt;/span&gt;) {}
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;convT2E64&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;t&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;_type&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;Pointer&lt;/span&gt;) (&lt;span class=&quot;pl-v&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;eface&lt;/span&gt;) {}
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;convT2Estring&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;t&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;_type&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;Pointer&lt;/span&gt;) (&lt;span class=&quot;pl-v&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;eface&lt;/span&gt;) {}
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;convT2Eslice&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;t&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;_type&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;Pointer&lt;/span&gt;) (&lt;span class=&quot;pl-v&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;eface&lt;/span&gt;) {}

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; interface from scalar value&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;convT2I16&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;tab&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;itab&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;Pointer&lt;/span&gt;) (&lt;span class=&quot;pl-v&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;iface&lt;/span&gt;) {}
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;convT2I32&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;tab&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;itab&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;Pointer&lt;/span&gt;) (&lt;span class=&quot;pl-v&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;iface&lt;/span&gt;) {}
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;convT2I64&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;tab&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;itab&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;Pointer&lt;/span&gt;) (&lt;span class=&quot;pl-v&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;iface&lt;/span&gt;) {}
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;convT2Istring&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;tab&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;itab&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;Pointer&lt;/span&gt;) (&lt;span class=&quot;pl-v&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;iface&lt;/span&gt;) {}
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;convT2Islice&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;tab&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;itab&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;Pointer&lt;/span&gt;) (&lt;span class=&quot;pl-v&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;iface&lt;/span&gt;) {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;em&gt;You'll notice that there is no &lt;code&gt;convT2E8&lt;/code&gt; nor &lt;code&gt;convT2I8&lt;/code&gt; function; this is due to a compiler optimization that we'll take a look at at the end of this section.&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;All of these functions do almost the exact same thing, they only differ in the type of their return value (&lt;code&gt;iface&lt;/code&gt; vs. &lt;code&gt;eface&lt;/code&gt;) and the size of the memory that they allocate on the heap.&lt;br/&gt;Let's take a look at e.g. &lt;code&gt;runtime.convT2E32&lt;/code&gt; more closely (&lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/iface.go#L308-L325&quot;&gt;src/runtime/iface.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;convT2E32&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;t&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;_type&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;Pointer&lt;/span&gt;) (&lt;span class=&quot;pl-v&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;eface&lt;/span&gt;) {
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; ...omitted debug stuff... &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt; unsafe.&lt;span class=&quot;pl-smi&quot;&gt;Pointer&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; *(*&lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;)(elem) == &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; {
        x = unsafe.&lt;span class=&quot;pl-c1&quot;&gt;Pointer&lt;/span&gt;(&amp;amp;zeroVal[&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;])
    } &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; {
        x = &lt;span class=&quot;pl-c1&quot;&gt;mallocgc&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;4&lt;/span&gt;, t, &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;)
        *(*&lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;)(x) = *(*&lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;)(elem)
    }
    e.&lt;span class=&quot;pl-smi&quot;&gt;_type&lt;/span&gt; = t
    e.&lt;span class=&quot;pl-smi&quot;&gt;data&lt;/span&gt; = x
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The function initializes the &lt;code&gt;_type&lt;/code&gt; field of the &lt;code&gt;eface&lt;/code&gt; structure &quot;passed&quot; in by the caller (remember: return values are allocated by the caller on its own stack-frame) with the &lt;code&gt;_type&lt;/code&gt; given as first parameter.&lt;br/&gt;For the &lt;code&gt;data&lt;/code&gt; field of the &lt;code&gt;eface&lt;/code&gt;, it all depends on the value of the second parameter &lt;code&gt;elem&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;If &lt;code&gt;elem&lt;/code&gt; is zero, &lt;code&gt;e.data&lt;/code&gt; is initialized to point to &lt;code&gt;runtime.zeroVal&lt;/code&gt;, which is a special global variable defined by the runtime that represents the zero value. We'll discuss a bit more about this special variable in the next section.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;elem&lt;/code&gt; is non-zero, the function allocates 4 bytes on the heap (&lt;code&gt;x = mallocgc(4, t, false)&lt;/code&gt;), initializes the contents of those 4 bytes with the value pointed to by &lt;code&gt;elem&lt;/code&gt; (&lt;code&gt;*(*uint32)(x) = *(*uint32)(elem)&lt;/code&gt;), then stick the resulting pointer into &lt;code&gt;e.data&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;In this case, &lt;code&gt;e._type&lt;/code&gt; holds the address of &lt;code&gt;type.uint32&lt;/code&gt; (&lt;code&gt;LEAQ type.uint32(SB), AX&lt;/code&gt;), which is implemented by the standard library and whose address will only be known when linking against said stdlib:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go tool nm eface_scalar_test.o &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; grep &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;type\.uint32&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
         U type.uint32
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;U&lt;/code&gt; denotes that the symbol is not defined in this object file, and will (hopefully) be provided by another object at link-time (i.e. the standard library in this case).)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 2: Assign the result (part 1)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0078&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.&amp;amp;Eface&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;48&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x007d&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;         ;; Eface._type = ret._type&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The result of &lt;code&gt;runtime.convT2E32&lt;/code&gt; gets assigned to our &lt;code&gt;Eface&lt;/code&gt; variable.. or does it?&lt;/p&gt;
&lt;p&gt;Actually, for now, only the &lt;code&gt;_type&lt;/code&gt; field of the returned value is being assigned to &lt;code&gt;Eface._type&lt;/code&gt;, the &lt;code&gt;data&lt;/code&gt; field cannot be copied over just yet.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 3: Assign the result (part 2) or ask the garbage collector to&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0080&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL        runtime.writeBarrier(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0086&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ      &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DI&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;  ;; Eface.data = ret.data (indirectly via runtime.gcWriteBarrier)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x008a&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; TESTL     &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x008c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JNE&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;148&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x008e&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;  ;; Eface.data = ret.data (direct)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0092&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JMP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;46&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0094&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; runtime.gcWriteBarrier(SB)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0099&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JMP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;46&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The apparent complexity of this last piece is a side-effect of assigning the &lt;code&gt;data&lt;/code&gt; pointer of the returned &lt;code&gt;eface&lt;/code&gt; to &lt;code&gt;Eface.data&lt;/code&gt;: since we're manipulating the memory graph of our program (i.e. which part of memory holds references to which part of memory), we may have to notify the garbage collector of this change, just in case a garbage collection were to be currently running in the background.&lt;/p&gt;
&lt;p&gt;This is known as a write barrier, and is a direct consequence of Go's &lt;em&gt;concurrent&lt;/em&gt; garbage collector.&lt;br/&gt;Don't worry if this sounds a bit vague for now; the next chapter of this book will offer a thorough review of garbage collection in Go.&lt;br/&gt;For now, it's enough to remember that when we see some assembly code calling into &lt;code&gt;runtime.gcWriteBarrier&lt;/code&gt;, it has to do with pointer manipulation and notifying the garbage collector.&lt;/p&gt;
&lt;p&gt;All in all, this final piece of code can do one of two things:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;If the write-barrier is currently inactive, it assigns &lt;code&gt;ret.data&lt;/code&gt; to &lt;code&gt;Eface.data&lt;/code&gt; (&lt;code&gt;MOVQ AX, 8(DX)&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;If the write-barrier is active, it politely asks the garbage-collector to do the assignment on our behalf&lt;br/&gt;(&lt;code&gt;LEAQ 8(DX), DI&lt;/code&gt; + &lt;code&gt;CALL runtime.gcWriteBarrier(SB)&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(&lt;em&gt;Once again, try not to worry too much about this for now.&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;Voila, we've got a complete interface holding a simple scalar type (&lt;code&gt;uint32&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;While sticking a scalar value into an interface is not something that happens that often in practice, it can be a costly operation for various reasons, and as such it's important to be aware of the machinery behind it.&lt;/p&gt;
&lt;p&gt;Speaking of cost, we've mentionned that the compiler implements various tricks to avoid allocating in some specific situations; we'll close this section with a quick look at 3 of those tricks.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interface trick 1: Byte-sized values&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Consider this benchmark that instanciates an &lt;code&gt;eface&amp;lt;uint8&amp;gt;&lt;/code&gt; (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/eface_scalar_test.go&quot;&gt;eface_scalar_test.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;BenchmarkEfaceScalar&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;testing&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;B&lt;/span&gt;) {
    b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;eface8&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; LEAQ    type.uint8(SB), BX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ    BX, (CX)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVBLZX AL, SI&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; LEAQ    runtime.staticbytes(SB), R8&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ADDQ    R8, SI&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVL    runtime.writeBarrier(SB), R9&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; LEAQ    8(CX), DI&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; TESTL   R9, R9&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; JNE     100&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ    SI, 8(CX)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; JMP     40&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ    AX, R9&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ    SI, AX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; CALL    runtime.gcWriteBarrier(SB)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ    R9, AX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; JMP     40&lt;/span&gt;
            Eface = &lt;span class=&quot;pl-c1&quot;&gt;uint8&lt;/span&gt;(i)
        }
    })
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; -benchmem -bench=BenchmarkEfaceScalar/eface8 ./eface_scalar_test.go
BenchmarkEfaceScalar/eface8-8           2000000000         0.88 ns/op     0 B/op     0 allocs/op
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We notice that in the case of a byte-sized value, the compiler avoids the call to &lt;code&gt;runtime.convT2E&lt;/code&gt;/&lt;code&gt;runtime.convT2I&lt;/code&gt; and the associated heap allocation, and instead re-uses the address of a global variable exposed by the runtime that already holds the 1-byte value we're looking for: &lt;code&gt;LEAQ runtime.staticbytes(SB), R8&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;runtime.staticbytes&lt;/code&gt; can be found in &lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/iface.go#L619-L653&quot;&gt;src/runtime/iface.go&lt;/a&gt; and looks like this:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; staticbytes is used to avoid convT2E for byte-sized values.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;staticbytes&lt;/span&gt; = [...]&lt;span class=&quot;pl-k&quot;&gt;byte&lt;/span&gt;{
    &lt;span class=&quot;pl-c1&quot;&gt;0x00&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x01&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x02&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x03&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x04&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x05&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x06&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x07&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x08&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x09&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x0a&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x0b&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x0c&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x0d&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x0e&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x0f&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0x10&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x11&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x12&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x13&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x14&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x15&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x16&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x17&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x18&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x19&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x1a&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x1b&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x1c&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x1d&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x1e&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x1f&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0x20&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x21&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x22&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x23&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x24&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x25&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x26&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x27&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x28&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x29&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x2a&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x2b&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x2c&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x2d&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x2e&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x2f&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0x30&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x31&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x32&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x33&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x34&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x35&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x36&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x37&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x38&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x39&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x3a&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x3b&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x3c&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x3d&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x3e&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x3f&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0x40&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x41&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x42&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x43&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x44&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x45&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x46&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x47&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x48&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x49&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x4a&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x4b&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x4c&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x4d&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x4e&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x4f&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0x50&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x51&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x52&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x53&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x54&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x55&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x56&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x57&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x58&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x59&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x5a&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x5b&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x5c&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x5d&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x5e&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x5f&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0x60&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x61&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x62&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x63&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x64&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x65&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x66&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x67&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x68&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x69&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x6a&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x6b&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x6c&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x6d&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x6e&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x6f&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0x70&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x71&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x72&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x73&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x74&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x75&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x76&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x77&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x78&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x79&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x7a&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x7b&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x7c&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x7d&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x7e&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x7f&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0x80&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x81&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x82&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x83&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x84&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x85&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x86&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x87&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x88&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x89&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x8a&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x8b&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x8c&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x8d&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x8e&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x8f&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0x90&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x91&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x92&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x93&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x94&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x95&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x96&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x97&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x98&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x99&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x9a&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x9b&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x9c&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x9d&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x9e&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0x9f&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0xa0&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xa1&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xa2&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xa3&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xa4&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xa5&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xa6&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xa7&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xa8&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xa9&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xaa&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xab&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xac&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xad&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xae&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xaf&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0xb0&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xb1&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xb2&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xb3&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xb4&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xb5&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xb6&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xb7&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xb8&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xb9&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xba&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xbb&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xbc&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xbd&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xbe&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xbf&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0xc0&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xc1&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xc2&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xc3&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xc4&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xc5&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xc6&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xc7&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xc8&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xc9&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xca&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xcb&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xcc&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xcd&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xce&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xcf&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0xd0&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xd1&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xd2&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xd3&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xd4&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xd5&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xd6&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xd7&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xd8&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xd9&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xda&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xdb&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xdc&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xdd&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xde&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xdf&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0xe0&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xe1&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xe2&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xe3&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xe4&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xe5&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xe6&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xe7&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xe8&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xe9&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xea&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xeb&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xec&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xed&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xee&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xef&lt;/span&gt;,
    &lt;span class=&quot;pl-c1&quot;&gt;0xf0&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xf1&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xf2&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xf3&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xf4&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xf5&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xf6&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xf7&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xf8&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xf9&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xfa&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xfb&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xfc&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xfd&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xfe&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;0xff&lt;/span&gt;,
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using the right offset into this array, the compiler can effectively avoid an extra heap allocation and still reference any value representable as a single byte.&lt;/p&gt;
&lt;p&gt;Something feels wrong here, though.. can you tell?&lt;br/&gt;The generated code still embeds all the machinery related to the write-barrier, even though the pointer we're manipulating holds the address of a global variable whose lifetime is the same as the entire program's anyway.&lt;br/&gt;I.e. &lt;code&gt;runtime.staticbytes&lt;/code&gt; can never be garbage collected, no matter which part of memory holds a reference to it or not, so we shouldn't have to pay for the overhead of a write-barrier in this case.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interface trick 2: Static inference&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Consider this benchmark that instanciates an &lt;code&gt;eface&amp;lt;uint64&amp;gt;&lt;/code&gt; from a value known at compile time (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/eface_scalar_test.go&quot;&gt;eface_scalar_test.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;BenchmarkEfaceScalar&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;testing&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;B&lt;/span&gt;) {
    b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;eface-static&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; LEAQ  type.uint64(SB), BX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ  BX, (CX)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVL  runtime.writeBarrier(SB), SI&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; LEAQ  8(CX), DI&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; TESTL SI, SI&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; JNE   92&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; LEAQ  &quot;&quot;.statictmp_0(SB), SI&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ  SI, 8(CX)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; JMP   40&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ  AX, SI&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; LEAQ  &quot;&quot;.statictmp_0(SB), AX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; CALL  runtime.gcWriteBarrier(SB)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ  SI, AX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; LEAQ  &quot;&quot;.statictmp_0(SB), SI&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; JMP   40&lt;/span&gt;
            Eface = &lt;span class=&quot;pl-c1&quot;&gt;uint64&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;42&lt;/span&gt;)
        }
    })
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; -benchmem -bench=BenchmarkEfaceScalar/eface-static ./eface_scalar_test.go
BenchmarkEfaceScalar/eface-static-8     2000000000         0.81 ns/op     0 B/op     0 allocs/op
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can see from the generated assembly that the compiler completely optimizes out the call to &lt;code&gt;runtime.convT2E64&lt;/code&gt;, and instead directly constructs the empty interface by loading the address of an autogenerated global variable that already holds the value we're looking for: &lt;code&gt;LEAQ &quot;&quot;.statictmp_0(SB), SI&lt;/code&gt; (note the &lt;code&gt;(SB)&lt;/code&gt; part, indicating a global variable).&lt;/p&gt;
&lt;p&gt;We can better visualize what's going on using the script that we've hacked up earlier: &lt;code&gt;dump_sym.sh&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ GOOS=linux GOARCH=amd64 go tool compile eface_scalar_test.go
$ GOOS=linux GOARCH=amd64 go tool link -o eface_scalar_test.bin eface_scalar_test.o
$ ./dump_sym.sh eface_scalar_test.bin .rodata main.statictmp_0
.rodata file-offset: 655360
.rodata VMA: 4849664
main.statictmp_0 VMA: 5145768
main.statictmp_0 SIZE: 8

0000000 002a 0000 0000 0000                    
0000008
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As expected, &lt;code&gt;main.statictmp_0&lt;/code&gt; is a 8-byte variable whose value is &lt;code&gt;0x000000000000002a&lt;/code&gt;, i.e. &lt;code&gt;$42&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interface trick 3: Zero-values&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For this final trick, consider the following benchmark that instanciates an &lt;code&gt;eface&amp;lt;uint32&amp;gt;&lt;/code&gt; from a zero-value (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/eface_scalar_test.go&quot;&gt;eface_scalar_test.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;BenchmarkEfaceScalar&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;testing&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;B&lt;/span&gt;) {
    b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;eface-zeroval&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVL  $0, &quot;&quot;..autotmp_3+36(SP)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; LEAQ  type.uint32(SB), AX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ  AX, (SP)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; LEAQ  &quot;&quot;..autotmp_3+36(SP), CX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ  CX, 8(SP)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; CALL  runtime.convT2E32(SB)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ  16(SP), AX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ  24(SP), CX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ  &quot;&quot;.&amp;amp;Eface+48(SP), DX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ  AX, (DX)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVL  runtime.writeBarrier(SB), AX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; LEAQ  8(DX), DI&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; TESTL AX, AX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; JNE   152&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ  CX, 8(DX)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; JMP   46&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; MOVQ  CX, AX&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; CALL  runtime.gcWriteBarrier(SB)&lt;/span&gt;
            &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; JMP   46&lt;/span&gt;
            Eface = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(i - i) &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; outsmart the compiler (avoid static inference)&lt;/span&gt;
        }
    })
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; -benchmem -bench=BenchmarkEfaceScalar/eface-zero ./eface_scalar_test.go
BenchmarkEfaceScalar/eface-zeroval-8     500000000         3.14 ns/op     0 B/op     0 allocs/op
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First, notice how we make use of &lt;code&gt;uint32(i - i)&lt;/code&gt; instead of &lt;code&gt;uint32(0)&lt;/code&gt; to prevent the compiler from falling back to optimization #2 (static inference).&lt;br/&gt;(&lt;em&gt;Sure, we could just have declared a global zero variable and the compiler would had been forced to take the conservative route too.. but then again, we're trying to have some fun here. Don't be that guy.&lt;/em&gt;)&lt;br/&gt;The generated code now looks exactly like the normal, allocating case.. and still, it doesn't allocate. What's going on?&lt;/p&gt;
&lt;p&gt;As we've mentionned earlier back when we were dissecting &lt;code&gt;runtime.convT2E32&lt;/code&gt;, the allocation here can be optimized out using a trick similar to #1 (byte-sized values): when some code needs to reference a variable that holds a zero-value, the compiler simply gives it the address of a global variable exposed by the runtime whose value is always zero.&lt;br/&gt;Similarly to &lt;code&gt;runtime.staticbytes&lt;/code&gt;, we can find this variable in the runtime code (&lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/hashmap.go#L1248-L1249&quot;&gt;src/runtime/hashmap.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; maxZero = &lt;span class=&quot;pl-c1&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; must match value in ../cmd/compile/internal/gc/walk.go&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;zeroVal&lt;/span&gt; [maxZero]&lt;span class=&quot;pl-k&quot;&gt;byte&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This ends our little tour of optimizations.&lt;br/&gt;We'll close this section with a summary of all the benchmarks that we've just looked at:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; -benchmem -bench=. ./eface_scalar_test.go
BenchmarkEfaceScalar/uint32-8           2000000000         0.54 ns/op     0 B/op     0 allocs/op
BenchmarkEfaceScalar/eface32-8           100000000         12.3 ns/op     4 B/op     1 allocs/op
BenchmarkEfaceScalar/eface8-8           2000000000         0.88 ns/op     0 B/op     0 allocs/op
BenchmarkEfaceScalar/eface-zeroval-8     500000000         3.14 ns/op     0 B/op     0 allocs/op
BenchmarkEfaceScalar/eface-static-8     2000000000         0.81 ns/op     0 B/op     0 allocs/op
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;A word about zero-values&lt;/h3&gt;
&lt;p&gt;As we've just seen, the &lt;code&gt;runtime.convT2*&lt;/code&gt; family of functions avoids a heap allocation when the data to be held by the resulting interface happens to reference a zero-value.&lt;br/&gt;This optimization is not specific to interfaces and is actually part of a broader effort by the Go runtime to make sure that, when in need of a pointer to a zero-value, unnecessary allocations are avoided by taking the address of a special, always-zero variable exposed by the runtime.&lt;/p&gt;
&lt;p&gt;We can confirm this with a simple program (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/zeroval.go&quot;&gt;zeroval.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;go:linkname zeroVal runtime.zeroVal&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;zeroVal&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; eface &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt;{ _type, data unsafe.&lt;span class=&quot;pl-smi&quot;&gt;Pointer&lt;/span&gt; }

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;() {
    &lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;42&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt;{} = x - x &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; outsmart the compiler (avoid static inference)&lt;/span&gt;

    fmt.&lt;span class=&quot;pl-c1&quot;&gt;Printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;zeroVal = &lt;span class=&quot;pl-c1&quot;&gt;%p&lt;/span&gt;&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &amp;amp;zeroVal)
    fmt.&lt;span class=&quot;pl-c1&quot;&gt;Printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;      i = &lt;span class=&quot;pl-c1&quot;&gt;%p&lt;/span&gt;&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, ((*eface)(unsafe.&lt;span class=&quot;pl-c1&quot;&gt;Pointer&lt;/span&gt;(&amp;amp;i))).&lt;span class=&quot;pl-smi&quot;&gt;data&lt;/span&gt;)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go run zeroval.go
zeroVal = 0x5458e0
      i = 0x5458e0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As expected.&lt;/p&gt;
&lt;p&gt;Note the &lt;code&gt;//go:linkname&lt;/code&gt; directive which allows us to reference an external symbol:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The //go:linkname directive instructs the compiler to use “importpath.name” as the object file symbol name for the variable or function declared as “localname” in the source code. Because this directive can subvert the type system and package modularity, it is only enabled in files that have imported &quot;unsafe&quot;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;A tangent about zero-size variables&lt;/h3&gt;
&lt;p&gt;In a similar vein as zero-values, a very common trick in Go programs is to rely on the fact that instanciating an object of size 0 (such as &lt;code&gt;struct{}{}&lt;/code&gt;) doesn't result in an allocation.&lt;br/&gt;The official Go specification (linked at the end of this chapter) ends on a note that explains this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &quot;may&quot; in &quot;may have the same address in memory&quot; implies that the compiler doesn't guarantee this fact to be true, although it has always been and continues to be the case in the current implementation of the official Go compiler (&lt;code&gt;gc&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;As usual, we can confirm this with a simple program (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/zerobase.go&quot;&gt;zerobase.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;() {
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt;{}
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;42&lt;/span&gt;]&lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt;{}

    fmt.&lt;span class=&quot;pl-c1&quot;&gt;Printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;s = &lt;span class=&quot;pl-c1&quot;&gt;% p&lt;/span&gt;&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &amp;amp;s)
    fmt.&lt;span class=&quot;pl-c1&quot;&gt;Printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;a = &lt;span class=&quot;pl-c1&quot;&gt;% p&lt;/span&gt;&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &amp;amp;a)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go run zerobase.go
s = 0x546fa8
a = 0x546fa8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we'd like to know what hides behind this address, we can simply have a peek inside the binary:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go build -o zerobase.bin zerobase.go &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; objdump -t zerobase.bin &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; grep 546fa8
0000000000546fa8 g     O .noptrbss      0000000000000008 runtime.zerobase
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then it's just a matter of finding this &lt;code&gt;runtime.zerobase&lt;/code&gt; variable within the runtime source code (&lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/malloc.go#L516-L517&quot;&gt;src/runtime/malloc.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; base address for all 0-byte allocations&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;zerobase&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And if we'd rather be really, really sure indeed:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;go:linkname zerobase runtime.zerobase&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;zerobase&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;() {
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt;{}
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;42&lt;/span&gt;]&lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt;{}

    fmt.&lt;span class=&quot;pl-c1&quot;&gt;Printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;zerobase = &lt;span class=&quot;pl-c1&quot;&gt;%p&lt;/span&gt;&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &amp;amp;zerobase)
    fmt.&lt;span class=&quot;pl-c1&quot;&gt;Printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;       s = &lt;span class=&quot;pl-c1&quot;&gt;%p&lt;/span&gt;&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &amp;amp;s)
    fmt.&lt;span class=&quot;pl-c1&quot;&gt;Printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;       a = &lt;span class=&quot;pl-c1&quot;&gt;%p&lt;/span&gt;&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &amp;amp;a)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ go run zerobase.go
zerobase = 0x546fa8
       s = 0x546fa8
       a = 0x546fa8
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Interface composition&lt;/h2&gt;
&lt;p&gt;There really is nothing special about interface composition, it merely is syntastic sugar exposed by the compiler.&lt;/p&gt;
&lt;p&gt;Consider the following program (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/compound_interface.go&quot;&gt;compound_interface.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Adder&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt;{ &lt;span class=&quot;pl-c1&quot;&gt;Add&lt;/span&gt;(a, b &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt; }
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Subber&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt;{ &lt;span class=&quot;pl-c1&quot;&gt;Sub&lt;/span&gt;(a, b &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt; }
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Mather&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; {
    &lt;span class=&quot;pl-v&quot;&gt;Adder&lt;/span&gt;
    &lt;span class=&quot;pl-v&quot;&gt;Subber&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Calculator&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt;{ id &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt; }
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;(&lt;span class=&quot;pl-v&quot;&gt;c&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;Calculator&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Add&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt;) &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt; { &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a + b }
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;(&lt;span class=&quot;pl-v&quot;&gt;c&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;Calculator&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Sub&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt;) &lt;span class=&quot;pl-v&quot;&gt;int32&lt;/span&gt; { &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; a - b }

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;() {
    &lt;span class=&quot;pl-smi&quot;&gt;calc&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; Calculator{id: &lt;span class=&quot;pl-c1&quot;&gt;6754&lt;/span&gt;}
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt; Mather = &amp;amp;calc
    m.&lt;span class=&quot;pl-c1&quot;&gt;Sub&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;32&lt;/span&gt;)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As usual, the compiler generates the corresponding &lt;code&gt;itab&lt;/code&gt; for &lt;code&gt;iface&amp;lt;Mather, *Calculator&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ GOOS=linux GOARCH=amd64 go tool compile -S compound_interface.go &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; \
  grep -A 7 &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;^go.itab.\*&quot;&quot;.Calculator,&quot;&quot;.Mather&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
go.itab.&lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;.Calculator,&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;.Mather SRODATA dupok size=40
    0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x0010 5e 33 ca c8 00 00 00 00 00 00 00 00 00 00 00 00  ^3..............
    0x0020 00 00 00 00 00 00 00 00                          ........
    rel 0+8 t=1 type.&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;.Mather+0
    rel 8+8 t=1 type.&lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;.Calculator+0
    rel 24+8 t=1 &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;.(&lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt;Calculator).Add+0
    rel 32+8 t=1 &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;.(&lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt;Calculator).Sub+0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can see from the relocation directives that the virtual table generated by the compiler holds both the methods of &lt;code&gt;Adder&lt;/code&gt; as well as those belonging to &lt;code&gt;Subber&lt;/code&gt;, as we'd expect:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rel 24+8 t=1 &quot;&quot;.(*Calculator).Add+0
rel 32+8 t=1 &quot;&quot;.(*Calculator).Sub+0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Like we said, there's no secret sauce when it comes to interface composition.&lt;/p&gt;
&lt;p&gt;On an unrelated note, this little program demonstrates something that we had not seen up until now: since the generated &lt;code&gt;itab&lt;/code&gt; is specifically tailored to &lt;em&gt;a pointer to&lt;/em&gt; a &lt;code&gt;Constructor&lt;/code&gt;, as opposed to a concrete value, this fact gets reflected both in its symbol-name (&lt;code&gt;go.itab.*&quot;&quot;.Calculator,&quot;&quot;.Mather&lt;/code&gt;) as well as in the &lt;code&gt;_type&lt;/code&gt; that it embeds (&lt;code&gt;type.*&quot;&quot;.Calculator&lt;/code&gt;).&lt;br/&gt;This is consistent with the semantics used for naming method symbols, like we've seen earlier at the beginning of this chapter.&lt;/p&gt;
&lt;h2&gt;Assertions&lt;/h2&gt;
&lt;p&gt;We'll close this chapter by looking at type assertions, both from an implementation and a cost standpoint.&lt;/p&gt;
&lt;h3&gt;Type assertions&lt;/h3&gt;
&lt;p&gt;Consider this short program (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/eface_to_type.go&quot;&gt;eface_to_type.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Eface&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt;{} &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; outsmart compiler (avoid static inference)&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;assertion&lt;/span&gt;() {
    &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;uint64&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;42&lt;/span&gt;)
    Eface = i
    j = Eface.(&lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here's the annotated assembly listing for &lt;code&gt;j = Eface.(uint32)&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0065&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00101&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;       &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Eface(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;         ;; AX = Eface._type&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x006c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00108&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Eface&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;              ;; CX = Eface.data&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0073&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00115&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ  type.uint32(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;           ;; DX = type.uint32&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x007a&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00122&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; CMPQ  &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                              ;; Eface._type == type.uint32 ?&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x007d&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00125&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JNE&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;162&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                                ;; no? panic our way outta here&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x007f&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00127&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL  (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                 ;; AX = *Eface.data&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0081&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00129&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL  &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.j(SB)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                     ;; j = AX = *Eface.data&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; exit&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0087&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00135&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;BP&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x008c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00140&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; ADDQ&lt;/span&gt;   &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;48&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0090&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00144&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;RET&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; panic: interface conversion: &amp;lt;iface&amp;gt; is &amp;lt;have&amp;gt;, not &amp;lt;want&amp;gt;&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00a2&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00162&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                 ;; have: Eface._type&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00a6&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00166&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                  ;; want: type.uint32&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00ab&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00171&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ  type.interface {}(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;     ;; AX = type.interface{} (eface)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00b2&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00178&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                 ;; iface: AX&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00b7&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00183&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;CALL&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;     runtime.panicdottypeE(SB)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;     ;; func panicdottypeE(have, want, iface *_type)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00bc&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00188&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; UNDEF&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00be&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00190&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;NOP&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nothing surprising in there: the code compares the address held by &lt;code&gt;Eface._type&lt;/code&gt; with the address of &lt;code&gt;type.uint32&lt;/code&gt;, which, as we've seen before, is the global symbol exposed by the standard library that holds the content of the &lt;code&gt;_type&lt;/code&gt; structure which describes an &lt;code&gt;uint32&lt;/code&gt;.&lt;br/&gt;If the &lt;code&gt;_type&lt;/code&gt; pointers match, then all is good and we're free to assign &lt;code&gt;*Eface.data&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt;; otherwise, we call &lt;code&gt;runtime.panicdottypeE&lt;/code&gt; to throw a panic message that precisely describes the mismatch.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;runtime.panicdottypeE&lt;/code&gt; is a &lt;em&gt;very&lt;/em&gt; simple function that does no more than you'd expect (&lt;a href=&quot;https://github.com/golang/go/blob/bf86aec25972f3a100c3aa58a6abcbcc35bdea49/src/runtime/iface.go#L235-L245&quot;&gt;src/runtime/iface.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; panicdottypeE is called when doing an e.(T) conversion and the conversion fails.&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; have = the dynamic type we have.&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; want = the static type we're trying to convert to.&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; iface = the static type we're converting from.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;panicdottypeE&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;have&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;want&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;iface&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;_type&lt;/span&gt;) {
    &lt;span class=&quot;pl-smi&quot;&gt;haveString&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; have != &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt; {
        haveString = have.&lt;span class=&quot;pl-k&quot;&gt;string&lt;/span&gt;()
    }
    &lt;span class=&quot;pl-c1&quot;&gt;panic&lt;/span&gt;(&amp;amp;TypeAssertionError{iface.&lt;span class=&quot;pl-k&quot;&gt;string&lt;/span&gt;(), haveString, want.&lt;span class=&quot;pl-k&quot;&gt;string&lt;/span&gt;(), &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;})
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;What about performance?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Well, let's see what we've got here: a bunch of &lt;code&gt;MOV&lt;/code&gt;s from main memory, a &lt;em&gt;very&lt;/em&gt; predictable branch and, last but not least, a pointer dereference (&lt;code&gt;j = *Eface.data&lt;/code&gt;) (which is only there because we've initialized our interface with a concrete value in the first place, otherwise we could just have copied the &lt;code&gt;Eface.data&lt;/code&gt; pointer directly).&lt;/p&gt;
&lt;p&gt;It's not even worth micro-benchmarking this, really.&lt;br/&gt;Similarly to the overhead of dynamic dispatch that we've measured earlier, this is in and of itself, in theory, almost free. How much it'll really cost you in practice will most likely be a matter of how your code-path is designed with regard to cache-friendliness &amp;amp; al.&lt;br/&gt;A simple micro-benchmark would probably be too skewed to tell us anything useful here, anyway.&lt;/p&gt;
&lt;p&gt;All in all, we end up with the same old advice as usual: measure for your specific use case, check your processor's performance counters, and assert whether or not this has a visible impact on your hot path.&lt;br/&gt;It might. It might not. It most likely doesn't.&lt;/p&gt;
&lt;h3&gt;Type-switches&lt;/h3&gt;
&lt;p&gt;Type-switches are a bit trickier, of course. Consider the following code (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/eface_to_type.go&quot;&gt;eface_to_type.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Eface&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt;{} &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; outsmart compiler (avoid static inference)&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;typeSwitch&lt;/span&gt;() {
    &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;42&lt;/span&gt;)
    Eface = i
    &lt;span class=&quot;pl-k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; Eface.(&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;uint16&lt;/span&gt;:
        j = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(v)
    &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;:
        j = v
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This quite simple type-switch statement translates into the following assembly (annotated):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-assembly&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; switch v := Eface.(type)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0065&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00101&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Eface(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt; ;; AX = Eface._type&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x006c&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00108&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.Eface&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;      ;; CX = Eface.data&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0073&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00115&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; TESTQ &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                      ;; Eface._type == nil ?&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0076&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00118&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; JEQ   &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;153&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                        ;; yes? exit the switch&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0078&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00120&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL  &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;         ;; DX = Eface.type._hash&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; case uint32&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x007b&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00123&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; CMPL  &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; $&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;800397251&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;         ;; Eface.type._hash == type.uint32.hash ?&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0081&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00129&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JNE&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;163&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                        ;; no? go to next case (uint16)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0083&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00131&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ  type.uint32(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;BX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;   ;; BX = type.uint32&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x008a&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00138&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; CMPQ  &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;BX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                      ;; type.uint32 == Eface._type ? (hash collision?)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x008d&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00141&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JNE&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;206&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                        ;; no? clear BX and go to next case (uint16)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x008f&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00143&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL  (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;BX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;         ;; BX = *Eface.data&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0091&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00145&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JNE&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;163&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                        ;; landsite for indirect jump starting at 0x00d3&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0093&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00147&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL  &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;BX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.j(SB)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;             ;; j = BX = *Eface.data&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; exit&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x0099&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00153&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;MOVQ&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;BP&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x009e&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00158&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; ADDQ&lt;/span&gt;   &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;48&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;SP&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00a2&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00162&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;RET&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; case uint16&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00a3&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00163&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; CMPL  &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; $&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;269349216&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;         ;; Eface.type._hash == type.uint16.hash ?&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00a9&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00169&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JNE&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;153&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                        ;; no? exit the switch&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00ab&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00171&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; LEAQ  type.uint16(SB)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;   ;; DX = type.uint16&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00b2&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00178&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; CMPQ  &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;DX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                      ;; type.uint16 == Eface._type ? (hash collision?)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00b5&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00181&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JNE&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;199&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                        ;; no? clear AX and exit the switch&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00b7&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00183&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVWLZX       (&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;CX&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;         ;; AX = uint16(*Eface.data)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00ba&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00186&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JNE&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;153&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                        ;; landsite for indirect jump starting at 0x00cc&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00bc&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00188&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVWLZX       &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                      ;; AX = uint16(AX) (redundant)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00bf&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00191&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL  &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;.j(SB)&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;             ;; j = AX = *Eface.data&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00c5&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00197&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JMP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;153&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                        ;; we're done, exit the switch&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;;; indirect jump table&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00c7&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00199&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL&lt;/span&gt;   &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;AX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                 ;; AX = $0&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00cc&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00204&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JMP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;186&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                        ;; indirect jump to 153 (exit)&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00ce&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00206&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; MOVL&lt;/span&gt;   &lt;span class=&quot;pl-c1&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;BX&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                 ;; BX = $0&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;0x00d3&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;00211&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;JMP&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;145&lt;/span&gt;&lt;span class=&quot;pl-c&quot;&gt;                        ;; indirect jump to 163 (case uint16)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once again, if you meticulously step through the generated code and carefully read the corresponding annotations, you'll find that there's no dark magic in there.&lt;br/&gt;The control flow might look a bit convoluted at first, as it jumps back and forth a lot, but other than it's a pretty faithful rendition of the original Go code.&lt;/p&gt;
&lt;p&gt;There are quite a few interesting things to note, though.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note 1: Layout&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;First, notice the high-level layout of the generated code, which matches pretty closely the original switch statement:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;We find an initial block of instructions that loads the &lt;code&gt;_type&lt;/code&gt; of the variable we're interested in, and checks for &lt;code&gt;nil&lt;/code&gt; pointers, just in case.&lt;/li&gt;
&lt;li&gt;Then, we get N logical blocks that each correspond to one of the cases described in the original switch statement.&lt;/li&gt;
&lt;li&gt;And finally, one last block defines a kind of indirect jump table that allows the control flow to jump from one case to the next while making sure to properly reset dirty registers on the way.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;While obvious in hindsight, that second point is pretty important, as it implies that the number of instructions generated by a type-switch statement is purely a factor of the number of cases that it describes.&lt;br/&gt;In practice, this could lead to surprising performance issues as, for example, a massive type-switch statement with plenty of cases could generate a ton of instructions and end up thrashing the L1i cache if used on the wrong path.&lt;/p&gt;
&lt;p&gt;Another interesting fact regarding the layout of our simple switch-statement above is the order in which the cases are set up in the generated code. In our original Go code, &lt;code&gt;case uint16&lt;/code&gt; came first, followed by &lt;code&gt;case uint32&lt;/code&gt;. In the assembly generated by the compiler, though, their orders have been reversed, with &lt;code&gt;case uint32&lt;/code&gt; now being first and &lt;code&gt;case uint16&lt;/code&gt; coming in second.&lt;br/&gt;That this reordering is a net win for us in this particular case is nothing but mere luck, AFAICT. In fact, if you take the time to experiment a bit with type-switches, especially ones with more than two cases, you'll find that the compiler always shuffles the cases using some kind of deterministic heuristics.&lt;br/&gt;What those heuristics are, I don't know (but as always, I'd love to if you do).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note 2: O(n)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Second, notice how the control flow blindly jumps from one case to the next, until it either lands on one that evaluates to true or finally reaches the end of the switch statement.&lt;/p&gt;
&lt;p&gt;Once again, while obvious when one actually stops to think about it (&quot;how else could it work?&quot;), this is easy to overlook when reasoning at a higher-level. In practice, this means that the cost of evaluating a type-switch statement grows linearly with its number of cases: it's &lt;code&gt;O(n)&lt;/code&gt;.&lt;br/&gt;Likewise, evaluating a type-switch statement with N cases effectively has the same time-complexity as evaluating N type-assertions. As we've said, there's no magic here.&lt;/p&gt;
&lt;p&gt;It's easy to confirm this with a bunch of benchmarks (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/eface_to_type_test.go&quot;&gt;eface_to_type_test.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;eface&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt;{} = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;42&lt;/span&gt;)

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;BenchmarkEfaceToType&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;b&lt;/span&gt; *&lt;span class=&quot;pl-v&quot;&gt;testing&lt;/span&gt;.&lt;span class=&quot;pl-v&quot;&gt;B&lt;/span&gt;) {
    b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;switch-small&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
            &lt;span class=&quot;pl-k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; eface.(&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt;) {
            &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;int8&lt;/span&gt;:
                j = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(v)
            &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;int16&lt;/span&gt;:
                j = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(v)
            &lt;span class=&quot;pl-k&quot;&gt;default&lt;/span&gt;:
                j = v.(&lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;)
            }
        }
    })
    b.&lt;span class=&quot;pl-c1&quot;&gt;Run&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;switch-big&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;func&lt;/span&gt;(b *testing.&lt;span class=&quot;pl-smi&quot;&gt;B&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i &amp;lt; b.&lt;span class=&quot;pl-smi&quot;&gt;N&lt;/span&gt;; i++ {
            &lt;span class=&quot;pl-k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:=&lt;/span&gt; eface.(&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt;) {
            &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;int8&lt;/span&gt;:
                j = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(v)
            &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;int16&lt;/span&gt;:
                j = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(v)
            &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;int32&lt;/span&gt;:
                j = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(v)
            &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;int64&lt;/span&gt;:
                j = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(v)
            &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;uint8&lt;/span&gt;:
                j = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(v)
            &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;uint16&lt;/span&gt;:
                j = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(v)
            &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;uint64&lt;/span&gt;:
                j = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(v)
            &lt;span class=&quot;pl-k&quot;&gt;default&lt;/span&gt;:
                j = v.(&lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;)
            }
        }
    })
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
benchstat &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&amp;lt;(&lt;/span&gt;go &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; -benchtime=1s -bench=. -count=3 ./eface_to_type_test.go&lt;span class=&quot;pl-pds&quot;&gt;)&lt;/span&gt;&lt;/span&gt;
name                        time/op
EfaceToType/switch-small-8  1.91ns ± 2%
EfaceToType/switch-big-8    3.52ns ± 1%
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With all its extra cases, the second type-switch does take almost twice as long per iteration indeed.&lt;/p&gt;
&lt;p&gt;As an interesting exercise for the reader, try adding a &lt;code&gt;case uint32&lt;/code&gt; in either one of the benchmarks above (anywhere), you'll see their performances improve drastically:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
benchstat &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&amp;lt;(&lt;/span&gt;go &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; -benchtime=1s -bench=. -count=3 ./eface_to_type_test.go&lt;span class=&quot;pl-pds&quot;&gt;)&lt;/span&gt;&lt;/span&gt;
name                        time/op
EfaceToType/switch-small-8  1.63ns ± 1%
EfaceToType/switch-big-8    2.17ns ± 1%
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using all the tools and knowledge that we've gathered during this chapter, you should be able to explain the rationale behind the numbers. Have fun!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note 3: Type hashes &amp;amp; pointer comparisons&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Finally, notice how the type comparisons in each cases are always done in two phases:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;The types' hashes (&lt;code&gt;_type.hash&lt;/code&gt;) are compared, and then&lt;/li&gt;
&lt;li&gt;if they match, the respective memory-addresses of each &lt;code&gt;_type&lt;/code&gt; pointers are compared directly.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Since each &lt;code&gt;_type&lt;/code&gt; structure is generated once by the compiler and stored in a global variable in the &lt;code&gt;.rodata&lt;/code&gt; section, we are guaranteed that each type gets assigned a unique address for the lifetime of the program.&lt;/p&gt;
&lt;p&gt;In that context, it makes sense to do this extra pointer comparison in order to make sure that the successful match wasn't simply the result of a hash collision.. but then this raises an obvious question: why not just compare the pointers directly in the first place, and drop the notion of type hashes altogether? Especially when simple type assertions, as we've seen earlier, don't use type hashes at all.&lt;br/&gt;The answer is I don't have the slightest clue, and certainly would love some enlightment on this. As always, feel free to open an issue if you know more.&lt;/p&gt;
&lt;p&gt;Speaking of type hashes, how is it that we know that &lt;code&gt;$-800397251&lt;/code&gt; corresponds to &lt;code&gt;type.uint32.hash&lt;/code&gt; and &lt;code&gt;$-269349216&lt;/code&gt; to &lt;code&gt;type.uint16.hash&lt;/code&gt;, you might wonder? The hard way, of course (&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/eface_type_hash.go&quot;&gt;eface_type_hash.go&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; simplified definitions of runtime's eface &amp;amp; _type types&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; eface &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
    _type *_type
    data  unsafe.&lt;span class=&quot;pl-smi&quot;&gt;Pointer&lt;/span&gt;
}
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; _type &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
    size    &lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;
    ptrdata &lt;span class=&quot;pl-k&quot;&gt;uintptr&lt;/span&gt;
    hash    &lt;span class=&quot;pl-k&quot;&gt;uint32&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; omitted lotta fields &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Eface&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt;{}
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;() {
    Eface = &lt;span class=&quot;pl-c1&quot;&gt;uint32&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;42&lt;/span&gt;)
    fmt.&lt;span class=&quot;pl-c1&quot;&gt;Printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;eface&amp;lt;uint32&amp;gt;._type.hash = &lt;span class=&quot;pl-c1&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
        &lt;span class=&quot;pl-c1&quot;&gt;int32&lt;/span&gt;((*eface)(unsafe.&lt;span class=&quot;pl-c1&quot;&gt;Pointer&lt;/span&gt;(&amp;amp;Eface)).&lt;span class=&quot;pl-smi&quot;&gt;_type&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;hash&lt;/span&gt;))

    Eface = &lt;span class=&quot;pl-c1&quot;&gt;uint16&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;42&lt;/span&gt;)
    fmt.&lt;span class=&quot;pl-c1&quot;&gt;Printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;eface&amp;lt;uint16&amp;gt;._type.hash = &lt;span class=&quot;pl-c1&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
        &lt;span class=&quot;pl-c1&quot;&gt;int32&lt;/span&gt;((*eface)(unsafe.&lt;span class=&quot;pl-c1&quot;&gt;Pointer&lt;/span&gt;(&amp;amp;Eface)).&lt;span class=&quot;pl-smi&quot;&gt;_type&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;hash&lt;/span&gt;))
}
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;$ go run eface_type_hash.go
eface&amp;lt;uint32&amp;gt;._type.hash = -800397251
eface&amp;lt;uint16&amp;gt;._type.hash = -269349216
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;That's it for interfaces.&lt;/p&gt;
&lt;p&gt;I hope this chapter has given you most of the answers you were looking for when it comes to interfaces and their innards. Most importantly, it should have provided you with all the necessary tools and skills required to dig further whenever you'd need to.&lt;/p&gt;
&lt;p&gt;If you have any questions or suggestions, don't hesitate to open an issue with the &lt;code&gt;chapter2:&lt;/code&gt; prefix!&lt;/p&gt;
&lt;h2&gt;Links&lt;/h2&gt;
</description>
<pubDate>Mon, 09 Apr 2018 06:38:01 +0000</pubDate>
<dc:creator>teh_cmc</dc:creator>
<og:image>https://avatars3.githubusercontent.com/u/2910679?s=400&amp;v=4</og:image>
<og:type>object</og:type>
<og:title>teh-cmc/go-internals</og:title>
<og:url>https://github.com/teh-cmc/go-internals</og:url>
<og:description>go-internals - A book about the internals of the Go programming language.</og:description>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md</dc:identifier>
</item>
<item>
<title>Original Windows File Manager with enhancements</title>
<link>https://github.com/Microsoft/winfile</link>
<guid isPermaLink="true" >https://github.com/Microsoft/winfile</guid>
<description>&lt;h3&gt;README.md&lt;/h3&gt;
&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;text&quot;&gt;
&lt;p&gt;The Windows File Manager lives again and runs as a native x86 and x64 desktop app on all currently supported version of Windows, including Windows 10. I welcome your thoughts, comments and suggestions. There are two primary versions of the source code in the master branch:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;original_plus tag: refers to the source for WinFile as of Windows NT4 with minimal changes so that it compiles with Visual Studio and runs on current Windows.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;current master: contains my personal changes / additions to WinFile.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;I will consider bugs fixes and suggestions for minor changes to the master branch. Feel free to create a pull request or post issues as you see fit.&lt;/p&gt;
&lt;p&gt;I will not be changing the original_plus sources nor creating other branches for other purposes. You are welcome do that on your own.&lt;/p&gt;
&lt;h2&gt;History&lt;/h2&gt;
&lt;p&gt;The Windows File manager was originally released with Windows 3.0 in the early 1990s. You can read more about the history at &lt;a href=&quot;https://en.wikipedia.org/wiki/File_Manager_(Windows)&quot; rel=&quot;nofollow&quot;&gt;https://en.wikipedia.org/wiki/File_Manager_(Windows)&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;What it looks like&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://camo.githubusercontent.com/9db980c656a644e153bddcfb720c177e4d6c0a7d/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f362f36372f57696e66696c652d7631302d302d66696c652d6d616e616765725f25323863726f707065642532392e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/9db980c656a644e153bddcfb720c177e4d6c0a7d/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f362f36372f57696e66696c652d7631302d302d66696c652d6d616e616765725f25323863726f707065642532392e706e67&quot; alt=&quot;(https://commons.wikimedia.org/wiki/File:Winfile-v10-0-file-manager_%28cropped%29.png)&quot; data-canonical-src=&quot;https://upload.wikimedia.org/wikipedia/commons/6/67/Winfile-v10-0-file-manager_%28cropped%29.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Thanks to &lt;a href=&quot;https://github.com/speps&quot;&gt;@Speps&lt;/a&gt; for the link; not sure who uploaded the image to Wikimedia.&lt;/p&gt;
&lt;h2&gt;Changes in original_plus&lt;/h2&gt;
&lt;p&gt;The source code provided here (in the src directory) was copied from the Windows NT 4 source tree in November 2007. The tag named original_plus contains a very limited set of modifications from the original sources to enable WinFile.exe to run on current Windows. The most significant changes are:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;converted to Visual Studio solution; works on VS 2015 and 2017&lt;/li&gt;
&lt;li&gt;compiles and runs on 64-bit Windows (e.g., GetWindowLong -&amp;gt; GetWindowLongPtr, LONG -&amp;gt; LPARAM)&lt;/li&gt;
&lt;li&gt;added a few header files which were stored elsewhere in the NT source tree (e.g., wfext.h)&lt;/li&gt;
&lt;li&gt;deleted some unused files (e.g., winfile.def)&lt;/li&gt;
&lt;li&gt;converted 64-bit arithmetic from internal libraries to C&lt;/li&gt;
&lt;li&gt;converted internal shell APIs to public APIs (the primary reason the old version would not run)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;The help directory contains both winfile.hlp and winfile.chm. Winfile.hlp was in the NT4 source tree, but does not work on Windows 10 any more. Winfile.chm was copied from a regular installation of Windows 98 and works on Windows 10. As is, WinFile.exe tries to launch winfile.hlp which fails.&lt;/p&gt;
&lt;p&gt;To create your own local branch referring to this release, run &quot;git checkout -b original_plus&quot;.&lt;/p&gt;
&lt;h2&gt;Changes in master v10.0 after original_plus&lt;/h2&gt;
&lt;p&gt;The master branch contains changes I have made since 2007. The changes have been solely determined by my needs and personal use. Some of the changes have limitations that fit the way I use the tool. For example, the path index which supports the new goto command only contains information for the c: drive.&lt;/p&gt;
&lt;p&gt;I have also not redesigned or restructured WinFile in any major way.&lt;/p&gt;
&lt;p&gt;Version v10.0 represents the entire set of changes from Nov. 2007 until this OSS project was created. For changes post v10.0, see the commit and release history.&lt;/p&gt;
&lt;p&gt;In summary v10.0 has the following changes/new features compared to original_plus:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;OLE drag/drop support&lt;/li&gt;
&lt;li&gt;control characters (e.g., ctrl+C) map to current short cut (e.g., ctrl+c -&amp;gt; copy) instead of changing drives&lt;/li&gt;
&lt;li&gt;cut (ctrl+X) followed by paste (ctrl+V) translates into a file move as one would expect&lt;/li&gt;
&lt;li&gt;left and right arrows in the tree view expand and collapse folders like in the Explorer&lt;/li&gt;
&lt;li&gt;added context menus in both panes&lt;/li&gt;
&lt;li&gt;improved the means by which icons are displayed for files&lt;/li&gt;
&lt;li&gt;F12 runs notepad or notepad++ on the selected file&lt;/li&gt;
&lt;li&gt;moved the ini file location to %AppData%\Roaming\Microsoft\WinFile&lt;/li&gt;
&lt;li&gt;File.Search can include a date which limits the files returned to those after the date provided; the output is also sorted by the date instead of by the name&lt;/li&gt;
&lt;li&gt;File.Search includes an option as to whether to include sub-directories&lt;/li&gt;
&lt;li&gt;ctrl+K starts a command shell (ConEmu if installed) in the current directory; shfit+ctrl+K starts an elevated command shell (cmd.exe only)&lt;/li&gt;
&lt;li&gt;File.Goto (ctrl+G) enables one to type a few words of a path and get a list of directories; selecting one changes to that directory. Only drive c: is indexed.&lt;/li&gt;
&lt;li&gt;UI shows reparse points (e.g., Junction points) as such&lt;/li&gt;
&lt;li&gt;added simple forward / back navigation (probably needs to be improved)&lt;/li&gt;
&lt;li&gt;View command has a new option to sort by date forward (oldest on top); normal date sorting is newest on top&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;You can read the code for more details.&lt;/p&gt;
&lt;h2&gt;Contributing&lt;/h2&gt;
&lt;p&gt;As mentioned above, this project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit &lt;a href=&quot;https://cla.microsoft.com&quot; rel=&quot;nofollow&quot;&gt;https://cla.microsoft.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.&lt;/p&gt;
&lt;p&gt;This project has adopted the &lt;a href=&quot;https://opensource.microsoft.com/codeofconduct/&quot; rel=&quot;nofollow&quot;&gt;Microsoft Open Source Code of Conduct&lt;/a&gt;. For more information see the &lt;a href=&quot;https://opensource.microsoft.com/codeofconduct/faq/&quot; rel=&quot;nofollow&quot;&gt;Code of Conduct FAQ&lt;/a&gt; or contact &lt;a href=&quot;mailto:opencode@microsoft.com&quot;&gt;opencode@microsoft.com&lt;/a&gt; with any additional questions or comments.&lt;/p&gt;
&lt;h2&gt;License&lt;/h2&gt;
&lt;p&gt;Copyright (c) Microsoft Corporation. All rights reserved.&lt;/p&gt;
&lt;p&gt;Licensed under the &lt;a href=&quot;https://github.com/Microsoft/winfile/blob/master/LICENSE&quot;&gt;MIT&lt;/a&gt; License.&lt;/p&gt;
&lt;/article&gt;</description>
<pubDate>Mon, 09 Apr 2018 03:30:42 +0000</pubDate>
<dc:creator>chungy</dc:creator>
<og:image>https://avatars2.githubusercontent.com/u/6154722?s=400&amp;v=4</og:image>
<og:type>object</og:type>
<og:title>Microsoft/winfile</og:title>
<og:url>https://github.com/Microsoft/winfile</og:url>
<og:description>Original Windows File Manager (winfile) with enhancements</og:description>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://github.com/Microsoft/winfile</dc:identifier>
</item>
<item>
<title>Post-Mortem and Security Advisory: Data Exposure After travis-ci.com Outage</title>
<link>https://blog.travis-ci.com/2018-04-03-incident-post-mortem</link>
<guid isPermaLink="true" >https://blog.travis-ci.com/2018-04-03-incident-post-mortem</guid>
<description>&lt;p&gt;On Tuesday, 13 March 2018, &lt;a href=&quot;https://www.traviscistatus.com/incidents/z2b3lz2kwcfp&quot;&gt;travis-ci.com was non-operational&lt;/a&gt; for around 5.5 hours starting at 12:14 UTC. There was a backlog of builds for another 3.5 hours after the system returned to an operational state.&lt;/p&gt;
&lt;p&gt;This post outlines what happened, and explains what exactly it means for you as a travis-ci.com customer.&lt;/p&gt;
&lt;h2 id=&quot;what-happened&quot;&gt;What happened&lt;/h2&gt;
&lt;p&gt;On Tuesday, 13 March 2018 at 12:04 UTC a database query was accidentally run against our production database which truncated all tables. The query was blocked for around 10 minutes and finally executed at 12:14 UTC.&lt;/p&gt;
&lt;p&gt;As we responded to alerts immediately following this, our API remained operational for roughly 30 minutes, connected to an almost empty database.&lt;/p&gt;
&lt;p&gt;Whenever anyone signed in to travis-ci.com during this time, they saw blank user profiles. Since their old user records had been wiped from the database, our system created new records for them, with primary keys generated from the existing sequence (PostgreSQL does not reset id sequences on truncate).&lt;/p&gt;
&lt;p&gt;We eventually took the step of taking all applications in our system offline, and the database was restored to its original state some hours later.&lt;/p&gt;
&lt;p&gt;When our system was finally back online, those who had logged in during the 30 minutes between database truncation and our applications going offline found themselves logged in as the wrong users. Their login credentials – in the form of a signed token in localStorage – corresponded to user records created after system restore.&lt;/p&gt;
&lt;p&gt;As brand new customers are not the only accounts to require new user records, because we sync users from GitHub on a regular basis, this meant that both new and existing users at travis-ci.com were affected by this issue.&lt;/p&gt;
&lt;p&gt;To address this situation, all affected tokens were revoked by 14:22 UTC on Wednesday, 14 March.&lt;/p&gt;
&lt;p&gt;We also became aware that once the database was restored, we didn’t restart our cron scheduler, causing errors with triggering scheduled cron jobs.&lt;/p&gt;
&lt;h2 id=&quot;regarding-security&quot;&gt;Regarding Security&lt;/h2&gt;
&lt;p&gt;Since the outage we have analysed our application logs for customer accounts that may have been impacted by the token mismatch. We have contacted all customers who were technically affected. A subset of these had no repositories which had run builds on travis-ci.com, and there was no evidence that any customer data was exposed. Another subset had build logs for repositories that were potentially exposed, but our access logs suggested no users accessed build logs during the period of exposure. Another subset were potentially exposed, with our access logs suggesting at least one user was logged in with access to data during the period of exposure.&lt;/p&gt;
&lt;p&gt;We have advised affected customers that if they already encrypt all secrets (passwords, API tokens, sensitive environment variables etc.) using our available encryption features, they are safe from exposure. We have also advised them it would be wise to rotate any credentials stored on travis-ci.com, even if encrypted, and check repositories on travis-ci.com to make sure build logs do not contain other forms of sensitive information, as a precautionary measure.&lt;/p&gt;
&lt;p&gt;Please check your emails for a Security Advisory from us - the subject line should start with “Travis CI Security Advisory:”. We have contacted GitHub repository admin users. If you haven’t received such an email, then your account has not been impacted. Please do contact &lt;a href=&quot;mailto:support@travis-ci.com?subject=Security%20Advisory%20Question&quot;&gt;support@travis-ci.com&lt;/a&gt; with any questions or concerns– we’ll be happy to assist with whatever questions you might have about this.&lt;/p&gt;
&lt;h2 id=&quot;what-we-learned&quot;&gt;What We Learned&lt;/h2&gt;
&lt;p&gt;We have held an internal incident retrospective to learn more about how the data failure occurred, what can be improved on our side to protect against such a failure, and how to better restore and protect data if a similar incident should ever occur.&lt;/p&gt;
&lt;ul readability=&quot;12.371712636305&quot;&gt;&lt;li readability=&quot;3.8954248366013&quot;&gt;
&lt;p&gt;It took us a day to uncover the root cause of the original database truncation. Using our API logs, and with information from our upstream provider about the IP address the query originated from, we were able to identify a truncate query run during tests using the &lt;a href=&quot;https://github.com/DatabaseCleaner/database_cleaner&quot;&gt;Database Cleaner&lt;/a&gt; gem. The shell the tests ran in unknowingly had a DATABASE_URL environment variable set as our production database. It was an old terminal window in a tmux session that had been used for inspecting production data many days before. The developer returned to this window and executed the test suite with the DATABASE_URL still set.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;This raised the question of &lt;em&gt;why&lt;/em&gt;, when needing to debug or inspect production data, we connected our development environment to a production database with write access. The answer to this was that our tooling and processes made it difficult to connect to the read-only follower, which is why connecting to the primary database was a common shortcut.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;We realised that while seeking to understand the problem, then quickly applying steps to rectify the situation, we inadvertantly left user-facing applications running. This was an error that resulted in the creation of replicated user ids.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;We omitted turning certain alerts back on - which meant that we were unaware the cron scheduler was not operational.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;We were reminded that our most experienced developers can make inadvertent errors resulting in significant outages.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;On a positive note, we were able to recover our entire travis-ci.com production database with only ~15 minutes of data loss.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Steps we have taken to avoid accidental database table truncation:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Revoked the truncate permission on our databases, effectively making it impossible for tables to be truncated.&lt;/li&gt;
&lt;li&gt;Patched our internal spec_helpers to check for the DATABASE_URL environment variable.&lt;/li&gt;
&lt;li&gt;Added a &lt;a href=&quot;https://github.com/travis-ci/prompt_warn_env&quot;&gt;shell prompt warning&lt;/a&gt; to our developer tooling to make the shell prompt warn when a DATABASE_URL is set.&lt;/li&gt;
&lt;li&gt;Submitted a &lt;a href=&quot;https://github.com/DatabaseCleaner/database_cleaner/pull/521&quot;&gt;Pull Request&lt;/a&gt; to the Database Cleaner gem to safeguard against accidentally using a remote DATABASE_URL.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Steps we have taken to avoid compounding issues:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Created an alias for the follower database, to make it easier to find and connect to when testing is required against production data.&lt;/li&gt;
&lt;li&gt;Automated database failover and maintenance to reduce the time and number of manual steps needed to recover from this type of situation.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;In addition to the measures mentioned above, we are planning a number of short and long term improvements that are aimed at making our system more resilient and preventing similar outages from happening.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Here at Travis CI we take security very seriously. The data failure we experienced was unprecedented in both scope and size. Unfortunately, when responding we missed some steps which would have reduced the problems that occurred.&lt;/p&gt;
&lt;p&gt;We are incredibly sorry for any inconvenience caused to your business and your developers. We truly value the trust our customers place in us, and look forward to putting the lessons learned to good use in continuing to improve our service.&lt;/p&gt;
&lt;p&gt;Please don’t hesitate to contact &lt;a href=&quot;mailto:support@travis-ci.com&quot;&gt;support@travis-ci.com&lt;/a&gt; with any further questions.&lt;/p&gt;
</description>
<pubDate>Mon, 09 Apr 2018 03:12:29 +0000</pubDate>
<dc:creator>xtreak29</dc:creator>
<dc:language>en</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://blog.travis-ci.com/2018-04-03-incident-post-mortem</dc:identifier>
</item>
</channel>
</rss>