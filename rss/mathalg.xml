<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed43.com%2Fmathalg-jtks.xml&amp;max=5&amp;links=preserve&amp;exc=1" />
<atom:link rel="alternate" title="Source URL" href="http://feed43.com/mathalg-jtks.xml" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed43.com%252Fmathalg-jtks.xml%26max%3D5%26links%3Dpreserve%26exc%3D1&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed43.com%252Fmathalg-jtks.xml%26max%3D5%26links%3Dpreserve%26exc%3D1" />
<title>算法与数学之美</title>
<link>http://www.jintiankansha.me/column/c9dZ5TM2aS</link>
<description>算法与数学之美 - 今天看啥</description>
<ttl>360</ttl>
<item>
<title>41岁英年早逝北大计算机系才子，给四岁幼子的临别赠言</title>
<link>http://www.jintiankansha.me/t/4JXoCF36Tf</link>
<guid isPermaLink="true" >http://www.jintiankansha.me/t/4JXoCF36Tf</guid>
<description>&lt;p&gt;&lt;span&gt;关公，曾经有一段时间和他的大哥刘备、三弟张飞在战争中被打散了，他曾一度被曹操收拢帐下，曹操用当年吕布的天下第一名马&quot;千里赤兔兽&quot;和&quot;美髯公&quot;的雅号收买关羽的心，但关羽从不为之所动，执意要去寻找失散的哥哥刘备。因了这个缘故，后人奉关羽为忠义千秋的武圣人。曹操百般无奈，只好遂了他的心愿，也算交下这个朋友，放他走了。于是就有了流传百世的&quot;过五关斩六将&quot;、&quot;千里走单骑&quot;的故事。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，爸爸问你一个问题，前次讲过&quot;三英战吕布&quot;的故事，刘关张三个人合起来都打不过吕布一个人，为什么曹操杀了吕布这个天下第一武将，却偏偏喜欢关公？关公和吕布他俩谁厉害？不到五岁的儿子当然答，吕布单打一个关公，肯定是吕布厉害。我说，不错，但是曹操为什么更喜欢关公一定要留住关公为自己效力呢？儿子摇摇头。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我问儿子，&quot;爸爸让你记住的人生做事第二要靠什么？&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;儿子很快就回答，&quot;靠朋友和助力&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;对，因为关公的忠诚和义气，他能得到很多信服他的人愿意帮助他，于是关公后来有了千千万万的将军和士兵帮他打仗，而且他懂谋略，懂得指挥千军万马运筹帷幄决胜千里。那么他和仅仅自己武功厉害却没有朋友不懂谋略的吕布相比，谁厉害？&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;关公！&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;对。所以，记住爸爸告诉你的'人生做事第二要靠朋友和助力'，和朋友要讲义气，你帮朋友，朋友帮你。那么，关羽的谋略又从哪里来呢？&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;……不知道&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;读书和实践，就是知行合一。&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;……&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;关公过五关斩六将千里走单骑这个故事中有这样一个小插曲，在有一关，守城将军想要害死关公，命手下人在黑夜用柴草烧死关羽。手下人放火前出于好奇，想看看守城将军要烧死的是个什么样的人物，于是隔窗偷偷一看，不得了，眼见关公威风凛凛端坐在油灯前，左手拿一本《春秋》，右手捋着胡须，这哪里是个凡人，简直就是天神下凡！于是这个人不忍加害关公，关公因此得以平安度过这一关。关公夜里读的那本书《春秋》讲的都是我们中国历史上文化思想和军事战略最鼎盛最活跃的周朝的历史故事，关公的谋略就是一半来自这些书里，一半来自他领兵打仗的实践中。那么，关公夜读《春秋》是恰恰这天他偶尔读了一次就被害他的人碰巧看见了吗？&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;……不知道&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;肯定不是。关公就读了一次书，就被别人看见了，天下没有那么巧的事。一定是关公读书习以为常才会被人看到。所以，读书学习不是一朝一夕一曝十寒的事，而是持之以恒、天天都要做的事。爸爸问你，爸爸说的‘人生做事第一要靠什么’？&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;人生做事第一要靠智力和毅力！&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;对，记住，关公坚持每天读书，持之以恒，这就叫作‘毅力’。&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;记住了。&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;你知道关公最终的结局是怎样的吗？&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;不知道。&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;关公后来成了三国当中蜀国最厉害的‘五虎上将’的第一名将，统率管理魏蜀吴三个国家必争的当中要地荆州。因为他的能力和眼界都超出了一般的常人，这时候的他镇守荆州大片土地就变得责任重大，他的每一个大大小小的决定都会影响到千千万万人的生命安全和生活幸福，所以他这时候做每个决定都要尽可能的避免犯错误。想想爸爸说的‘人生做事第三要靠什么’？&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;眼界和定力！&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;对，关公这时候能力非常大，能做的事非常多，那么很多坏事和诱惑也会随之而来，如果不谨慎就非常容易犯错。所以，禁得住诱惑、少犯错误就是定力。&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;记住了。&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;后来，关公因为自己的功绩越来越显赫，就变得傲慢了，于是就给敌人可乘之机，导致关公大意失荆州，而后败走麦城，在途中死在几个无名小辈的手中。这说明，人的定力不但要禁得起外部的诱惑和错误信息，还要禁得起来自自己内心的骄傲、迷惑和错误。&quot;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;  &lt;span&gt;THE NEXT BEST THING&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;某晚做了个梦，醒来后梦中场景清晰可见历历在目。我已头发半白，和儿子做在斯坦福的同一间教室里，我又重新开始了大学学习。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 19 Jun 2018 15:47:12 +0000</pubDate>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.jintiankansha.me/t/4JXoCF36Tf</dc:identifier>
</item>
<item>
<title>人类最早何时学会计数</title>
<link>http://www.jintiankansha.me/t/ZxxQPSPh3n</link>
<guid isPermaLink="true" >http://www.jintiankansha.me/t/ZxxQPSPh3n</guid>
<description>&lt;section class=&quot;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;p&gt;点击上方蓝字关注&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot; data-tools=&quot;135&amp;#x7F16;&amp;#x8F91;&amp;#x5668;&quot; data-id=&quot;92307&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.3125&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/Giaiaz5rZqia8HhH3FFhXZE1lUZgQ81pf3d3ogAE7MN3h8wPkgsibF9efjBiass1RrA7gXFcibXr03KInWdz79WoHryg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;112&quot; data-width=&quot;100%&quot; width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section readability=&quot;3.5&quot;&gt;&lt;section class=&quot;&quot; readability=&quot;7&quot;&gt;&lt;p&gt;&lt;span&gt;【美国《对话》杂志网站6月5日文章】题：人类最早是在何时学会计数的？（作者 美国米德尔伯里学院数学和自然哲学教授彼得·舒默）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然没有人知道数学的确切起源，但像我自己这样的现代数学家知道，人类口语的出现比书面语要早数千年。语言学方面的线索表明，世界各地的人们一定是先有了数学思维。&lt;/span&gt;&lt;/p&gt;

&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.3733333333333333&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/Giaiaz5rZqia8HhH3FFhXZE1lUZgQ81pf3d7kzMCkxDkDa2eiah5nmvCfq486WkT53IQfZmjaDyBc0UA8p4HVv04Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;75&quot; data-width=&quot;100%&quot; width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;&quot; data-tools=&quot;135&amp;#x7F16;&amp;#x8F91;&amp;#x5668;&quot; data-id=&quot;91555&quot;&gt;&lt;section data-role=&quot;paragraph&quot; class=&quot;&quot;&gt;&lt;section data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数学产生的早期线索&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;差异比类似更容易理解。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在英语中，有多个表达“2”这个概念的词，如“duo（两个）”、“pair（对）”、“couple（一双）”等，还有一些特别的词组，如“ team of horses（两匹马）”、“brace of partridge（对山鹑）”等等。这表明“2”的数学概念是在人类已经拥有了高度发达和丰富的语言之后才产生的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;书面语的出现比口语晚很很多。而且遗憾的是，大部分书面语都是书写在不能长期保存的介质上，它们很快就腐烂掉了。但从一些遗存下来的古代文物中的确可以看到复杂的数学。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;例如，在世界的许多地方都发现了史前的账目棍（刻有记号的动物骨头）等，它们虽然不能证明存在真正的记数，但至少表明确实存在某种数字记录。显然，人们是在就记号和一堆外部收集的物体进行一种一对对一的比较。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;计数的地域差异&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对现代“原始”文化的研究提供了研究人美数学发展历程的另一扇窗户。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在这些文化中，计数常常是通过默默地折手指或是指向身体的特定部位来进行的。新几内亚一个巴布亚部落的人可以通过折手指和指向自己的手肘、肩膀、嘴巴及子等身体部位从1数到22。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;大部分原始文化都会根据当时的环境来选择某种特定物体进行计数。例如，阿兹特克人会数1石头、2石头、3石头等。5条鱼即“5石头鱼”。而爪哇岛的一个部落在数数时会用“1谷”开始。南太平洋的尼西部落则用水果计数。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;英语中的数词可能也具有特定的物体含义，只是在时间的长河中逐渐散失。例如“five（5）”这个词就可能与“hand（手）”有某种关系。而“ eleven（11）”和“12”这两个词则可能类似于“超1”和“超2”，即10个手指都数完了还超过了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;美国人今天的数学使用十进制,这是从古希腊人那里继承来的。但其它文化则表现出了巨大的多样性。一些古代中国人，以及南非的一个部落使用二进制。三进制很少见，但在美国原住民部落中井非闻所未闻。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;古巴比伦人使用六十进制。这一体系的很多痕迹直到今天仍可以看到。这就是为什么一个小时有60分钟，一个圆有360度。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数字的书写&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;那么书写的数字又是怎样的呢？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;古代美索不达米亚人使用一种十分简单的计数体系。他们只使用两个记号：垂直楔（v）代表1，水平楔（＜）代表10。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;但美索不达米亚人没有零的概念。这就像是一个现代人不能识别5．03同53、503之间的区别一样。上下文和背景必不可少。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们今天使用的数字大多数起源于印度。乘法、除法、平方根等许多现代规则也是在印度诞生。这些理念通过伊斯兰学者进步发展并逐渐传入西方世界。这就是为什么我们现在把数字称为印度-阿拉伯数字体系。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从“1、2”数到许多，再到我们现代的数学世界，这期间经历了数千年，意识到这一点或许能对一个挣扎在数学之中的学生有所安慰。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;∑编辑 | Gemini&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.0437601296596435&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky7x6u1VxMVMia4MLibNzC2nrumY3zDflTsCeoM04M1BrkvPny8tsw6hYkIicUr42iarLmadL2x6JwV6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;617&quot; width=&quot;auto&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;算法数学之美微信公众号欢迎赐稿&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;稿件涉及数学、物理、算法、计算机、编程等相关领域，经采用我们将奉上稿酬。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;投稿邮箱：math_alg@163.com&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 19 Jun 2018 15:47:11 +0000</pubDate>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.jintiankansha.me/t/ZxxQPSPh3n</dc:identifier>
</item>
<item>
<title>JS家的排序算法</title>
<link>http://www.jintiankansha.me/t/OMWfV9pLCU</link>
<guid isPermaLink="true" >http://www.jintiankansha.me/t/OMWfV9pLCU</guid>
<description>&lt;h2&gt;&lt;strong&gt;引子&lt;/strong&gt;&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;span&gt;有句话怎么说来着：&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;雷锋推倒雷峰塔，Java implements JavaScript.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;当年，想凭借抱Java大腿火一把而不惜把自己名字给改了的JavaScript（原名LiveScript），如今早已光芒万丈。node JS的出现更是让JavaScript可以前后端通吃。虽然Java依然制霸企业级软件开发领域（C/C + +的大神们不要打我。。。），但在Web的江湖，JavaScript可谓风头无两，坐上了头把交椅。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然而，在传统的计算机算法和数据结构领域，大多数专业教材和书籍的默认语言都是Java或者C/C+ +。这给最近想恶补算法和数据结构知识的我造成了一定困扰，因为我想寻找一本以JavaScript为默认语言的算法书籍。当我了解到O’REILLY家的动物丛书系列里有一本叫做《数据结构与算法JavaScript描述》时，便兴奋的花了两天时间把这本书从头到尾读了一遍。它是一本很好的针对前端开发者们的入门算法书籍，可是，它有一个很大的缺陷，就是里面有很多明显的小错误，明显到就连我这种半路出家的程序猿都能一眼看出来。还有一个问题是，很多重要的算法和数据结构知识并没有在这本书里被提到。这些问题对于作为一个晚期强迫症患者的我来说简直不能忍。于是乎，一言不合我就决定自己找资料总结算法。那么，我就从算法领域里最基础的知识点——排序算法总结起好了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我相信以下的代码里一定会有某些bug或错误或语法不规范等问题是我自己无法发现的，所以敬请各位大神能够指出错误，因为只有在不断改错的道路上我才能取得长久的进步。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;十大经典算法排序总结对比&lt;/span&gt;&lt;/h2&gt;
&lt;hr /&gt;&lt;p&gt;&lt;span&gt;一张图概括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.6086956521739131&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabkwTLbzd7Jib8nlLIFrjpERVT0Tk6TPUfutk82kMsUDsbq7VbSHl4GOWoCAGNcKFeo1QspdJhDiahzzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主流排序算法概览&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;名词解释：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;n&lt;/strong&gt;: 数据规模&lt;br /&gt;&lt;strong&gt;k&lt;/strong&gt;:“桶”的个数&lt;br /&gt;&lt;strong&gt;In-place&lt;/strong&gt;: 占用常数内存，不占用额外内存&lt;br /&gt;&lt;strong&gt;Out-place&lt;/strong&gt;: 占用额外内存&lt;br /&gt;&lt;strong&gt;稳定性&lt;/strong&gt;：排序后2个相等键值的顺序和排序之前它们的顺序相同&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;冒泡排序（Bubble Sort）&lt;/span&gt;&lt;/h2&gt;
&lt;hr /&gt;&lt;h5&gt;&lt;span&gt;冒泡排序须知：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;作为最简单的排序算法之一，冒泡排序给我的感觉就像Abandon在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。。。冒泡排序还有一种优化算法，就是立一个flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。。。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;什么时候最快（Best Cases）：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊。。。。）&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;什么时候最慢（Worst Cases）：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;当输入的数据是反序时（写一个for循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗。。。）&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;冒泡排序动图演示：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.31113801452784506&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/951TjTgiabkwTLbzd7Jib8nlLIFrjpERVTfdGr5ZM0p9EeeTQCa5L0jVJAmOwPUwYDy0BwqEPNbl1Y3cpLXTiaYFg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;826&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5&gt;&lt;span&gt;冒泡排序JavaScript代码实现：&lt;/span&gt;&lt;/h5&gt;
&lt;pre class=&quot;hljs php&quot;&gt;
&lt;br /&gt;&lt;code class=&quot;php&quot;&gt;&lt;span&gt;function &lt;span class=&quot;hljs-title&quot;&gt;bubbleSort(arr) {    var len = arr.length;    for (var i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; len; i++) {        for (var j = &lt;span class=&quot;hljs-number&quot;&gt;0; j &amp;lt; len - 1 - i; j++) {            if (arr[j] &amp;gt; arr[j+&lt;span class=&quot;hljs-number&quot;&gt;1]) {        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;span&gt;选择排序（Selection Sort）&lt;/span&gt;&lt;/h2&gt;
&lt;hr /&gt;&lt;h5&gt;&lt;span&gt;选择排序须知：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;选择排序动图演示：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img class=&quot;imagebubble-image&quot; data-ratio=&quot;0.30579531442663377&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/951TjTgiabkwTLbzd7Jib8nlLIFrjpERVTkrac5V2ibWBzyWm5nJia3dNjASgiaicDVMUG31x5QC4zzpr4zcsSztyaxg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;811&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Selection Sort 动图演示 算法可视化来源：http://visualgo.net/&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;选择排序JavaScript代码实现：&lt;/span&gt;&lt;/h5&gt;
&lt;pre class=&quot;hljs php&quot;&gt;
&lt;code class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;selectionSort&lt;span class=&quot;hljs-params&quot;&gt;(arr) {    &lt;span class=&quot;hljs-keyword&quot;&gt;var len = arr.length;    &lt;span class=&quot;hljs-keyword&quot;&gt;var minIndex, temp;    &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;var i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; len - &lt;span class=&quot;hljs-number&quot;&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;&gt;&lt;/ins&gt;

    
1; i++) {
        minIndex = i;        &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;var j = i + &lt;span class=&quot;hljs-number&quot;&gt;1; j &amp;lt; len; j++) {            &lt;span class=&quot;hljs-keyword&quot;&gt;if (arr[j] &amp;lt; arr[minIndex]) {     &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;span&gt;插入排序（Insertion Sort）&lt;/span&gt;&lt;/h2&gt;
&lt;hr /&gt;&lt;h5&gt;&lt;span&gt;插入排序须知：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了。。。&lt;br /&gt;插入排序和冒泡排序一样，也有一种优化算法，叫做&lt;strong&gt;拆半插入&lt;/strong&gt;。对于这种算法，得了懒癌的我就套用教科书上的一句经典的话吧：感兴趣的同学可以在课后自行研究。。。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;插入排序动图演示：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img class=&quot;imagebubble-image&quot; data-ratio=&quot;0.6226880394574599&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/951TjTgiabkwTLbzd7Jib8nlLIFrjpERVTfIednKtLyVUoU7OqetLulJwIST3DfgSnzUaiaqF8yA8XSMTabWR18DA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;811&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Insertion Sort 动图演示 算法可视化来源：http://visualgo.net/&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;插入排序JavaScript代码实现：&lt;/span&gt;&lt;/h5&gt;
&lt;pre class=&quot;hljs php&quot;&gt;
&lt;code class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;insertionSort&lt;span class=&quot;hljs-params&quot;&gt;(arr) {    &lt;span class=&quot;hljs-keyword&quot;&gt;var len = arr.length;    &lt;span class=&quot;hljs-keyword&quot;&gt;var preIndex, current;    &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;var i = &lt;span class=&quot;hljs-number&quot;&gt;1; i &amp;lt; len; i++) {
        preIndex = i - &lt;span class=&quot;hljs-number&quot;&gt;1;
        current = arr[i];        &lt;span class=&quot;hljs-keyword&quot;&gt;while(preIndex &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;0 &amp;amp;&amp;amp; arr[preIndex] &amp;gt; current) {
            arr[preIndex+&lt;span class=&quot;hljs-number&quot;&gt;1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex+&lt;span class=&quot;hljs-number&quot;&gt;1] = current;
    }    &lt;span class=&quot;hljs-keyword&quot;&gt;return arr;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;span&gt;希尔排序（Shell Sort）&lt;/span&gt;&lt;/h2&gt;
&lt;hr /&gt;&lt;h5&gt;&lt;span&gt;希尔排序须知：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;希尔排序是插入排序的一种更高效率的实现。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。在这里，我就使用了这种方法。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;希尔排序JavaScript代码实现：&lt;/span&gt;&lt;/h5&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;shellSort&lt;span class=&quot;hljs-params&quot;&gt;(arr) {
    var len = arr.length,
        temp,
        gap = &lt;span class=&quot;hljs-number&quot;&gt;1;    &lt;span class=&quot;hljs-keyword&quot;&gt;while(gap &amp;lt; len/&lt;span class=&quot;hljs-number&quot;&gt;3) {          &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;span&gt;归并排序（Merge Sort）&lt;/span&gt;&lt;/h2&gt;
&lt;hr /&gt;&lt;h5&gt;&lt;span&gt;归并排序须知：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第2种方法）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;自下而上的迭代&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;在《数据结构与算法JavaScript描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;However, it is not possible to do so in JavaScript, as the recursion goes too deep&lt;br /&gt;for the language to handle.&lt;br /&gt;然而,在 JavaScript 中这种方式不太可行,因为这个算法的递归深度对它来讲太深了。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;说实话，我不太理解这句话。意思是JavaScript编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。&lt;br /&gt;和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;归并排序动图演示：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.6226880394574599&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/951TjTgiabkwTLbzd7Jib8nlLIFrjpERVTicLiaUGAiaaZ5ln011NxWpgKaMPgKSEKiaEWrGyCQYN0aUVuRfQj1SxR3A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;811&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Merge Sort 动图演示 算法可视化来源：http://visualgo.net/&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;归并排序JavaScript代码实现：&lt;/span&gt;&lt;/h5&gt;
&lt;pre class=&quot;hljs swift&quot;&gt;
&lt;code class=&quot;swift&quot;&gt;function mergeSort(arr) {  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;span&gt;快速排序（Quick Sort）&lt;/span&gt;&lt;/h2&gt;
&lt;hr /&gt;&lt;h5&gt;&lt;span&gt;快速排序须知：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。&lt;br /&gt;快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。虽然Worst Case的时间复杂度达到了O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为O(n log n) 的排序算法表现要更好，可是这是为什么呢，我也不知道。。。好在我的强迫症又犯了，查了N多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;快速排序的最坏运行情况是O(n²)，比如说顺序数列的快排。但它的平摊期望时间是O(n log n) ，且O(n log n)记号中隐含的常数因子很小，比复杂度稳定等于O(n log n)的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;&lt;span&gt;快速排序动图演示：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.31072749691738594&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/951TjTgiabkwTLbzd7Jib8nlLIFrjpERVTSlz0212qjUpibhMbxJs2eeR24AKXOjB9jQKX8soicicsIo8BuibcYzZ1fA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;811&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Quick Sort 动图演示 算法可视化来源：http://visualgo.net/&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;快速排序JavaScript代码实现：&lt;/span&gt;&lt;/h5&gt;
&lt;pre class=&quot;hljs swift&quot;&gt;
&lt;code class=&quot;swift&quot;&gt;function &lt;span class=&quot;hljs-built_in&quot;&gt;var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;span&gt;堆排序（Heap Sort）&lt;/span&gt;&lt;/h2&gt;
&lt;hr /&gt;&lt;h5&gt;&lt;span&gt;堆排序须知：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h5&gt;&lt;span&gt;堆排序动图演示：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.6654478976234004&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/951TjTgiabkwTLbzd7Jib8nlLIFrjpERVTOEhmNTsF9M03SDV7jI0QOHRB5MYg4VvhxuuZ8FyYHTzvrWibsxyEp7A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;547&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Heap Sort 动图演示 算法可视化来源：&lt;/span&gt;&lt;span&gt;http://www.ee.ryerson.ca/~courses/coe428/sorting/heapsort.html&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;堆排序JavaScript代码实现：&lt;/span&gt;&lt;/h5&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return arr;
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;span&gt;计数排序（Counting Sort）&lt;/span&gt;&lt;/h2&gt;
&lt;hr /&gt;&lt;h5&gt;&lt;span&gt;计数排序须知：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。&lt;br /&gt;作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;计数排序动图演示：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.5503952569169961&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/951TjTgiabkwTLbzd7Jib8nlLIFrjpERVTb1CGWh6U6ULalaHyhow1Yk65gg2UvbDkeFQyks52GLCqAotV7lFDDQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1012&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Counting Sort 动图演示 算法可视化来源：http://visualgo.net/&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;计数排序JavaScript代码实现：&lt;/span&gt;&lt;/h5&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;countingSort&lt;span class=&quot;hljs-params&quot;&gt;(arr, maxValue) {
    var bucket = &lt;span class=&quot;hljs-keyword&quot;&gt;new Array(maxValue+&lt;span class=&quot;hljs-number&quot;&gt;1),
        sortedIndex = &lt;span class=&quot;hljs-number&quot;&gt;0;
        arrLen = arr.length,
        bucketLen = maxValue + &lt;span class=&quot;hljs-number&quot;&gt;1;    &lt;span class=&quot;hljs-keyword&quot;&gt;for (var i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; arrLen; i++) {        &lt;span class=&quot;hljs-keyword&quot;&gt;if (!bucket[arr[i]]) {
            bucket[arr[i]] = &lt;span class=&quot;hljs-number&quot;&gt;0;
        }
        bucket[arr[i]]++;
    }    &lt;span class=&quot;hljs-keyword&quot;&gt;for (var j = &lt;span class=&quot;hljs-number&quot;&gt;0; j &amp;lt; bucketLen; j++) {        &lt;span class=&quot;hljs-keyword&quot;&gt;while(bucket[j] &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }    &lt;span class=&quot;hljs-keyword&quot;&gt;return arr;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;span&gt;桶排序（Bucket Sort）&lt;/span&gt;&lt;/h2&gt;
&lt;hr /&gt;&lt;h5&gt;&lt;span&gt;桶排序须知：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。&lt;br /&gt;为了使桶排序更加高效，我们需要做到这两点：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;在额外空间充足的情况下，尽量增大桶的数量&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;使用的映射函数能够将输入的N个数据均匀的分配到K个桶中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。&lt;/span&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;&gt;&lt;/ins&gt; &lt;h5&gt;&lt;span&gt;什么时候最快（Best Cases）：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;当输入的数据可以均匀的分配到每一个桶中&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;什么时候最慢（Worst Cases）：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;当输入的数据被分配到了同一个桶中&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;桶排序JavaScript代码实现：&lt;/span&gt;&lt;/h5&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;return arr;
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;span&gt;基数排序（Radix Sort）&lt;/span&gt;&lt;/h2&gt;
&lt;hr /&gt;&lt;h5&gt;&lt;span&gt;基数排序须知：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;基数排序有两种方法：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;MSD 从高位开始进行排序&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;LSD 从低位开始进行排序&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h5&gt;&lt;span&gt;基数排序 vs 计数排序 vs 桶排序&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：&lt;br /&gt;基数排序：根据键值的每位数字来分配桶&lt;br /&gt;计数排序：每个桶只存储单一键值&lt;br /&gt;桶排序：每个桶存储一定范围的数值&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;LSD基数排序动图演示：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.567193675889328&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/951TjTgiabkwTLbzd7Jib8nlLIFrjpERVTobarEBn550hgI5tSFkSakOdVKibWlaxBhRiayosoJVmDib5I262ic1EEmg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1012&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Radix Sort 动图演示 算法可视化来源：http://visualgo.net/&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;基数排序JavaScript代码实现：&lt;/span&gt;&lt;/h5&gt;
&lt;pre class=&quot;hljs cs&quot;&gt;
&lt;code class=&quot;cs&quot;&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;∑编辑 | Gemini&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;来源 | 简书&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.0437601296596435&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky7x6u1VxMVMia4MLibNzC2nrumY3zDflTsCeoM04M1BrkvPny8tsw6hYkIicUr42iarLmadL2x6JwV6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;617&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;算法数学之美微信公众号欢迎赐稿&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;稿件涉及数学、物理、算法、计算机、编程等相关领域，经采用我们将奉上稿酬。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;投稿邮箱：math_alg@163.com&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 18 Jun 2018 14:41:08 +0000</pubDate>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.jintiankansha.me/t/OMWfV9pLCU</dc:identifier>
</item>
</channel>
</rss>