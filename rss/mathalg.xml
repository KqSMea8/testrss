<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed43.com%2Fmathalg-jtks.xml&amp;max=5&amp;links=preserve&amp;exc=1" />
<atom:link rel="alternate" title="Source URL" href="http://feed43.com/mathalg-jtks.xml" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed43.com%252Fmathalg-jtks.xml%26max%3D5%26links%3Dpreserve%26exc%3D1&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed43.com%252Fmathalg-jtks.xml%26max%3D5%26links%3Dpreserve%26exc%3D1" />
<title>算法与数学之美</title>
<link>http://www.jintiankansha.me/column/c9dZ5TM2aS</link>
<description>算法与数学之美 - 今天看啥</description>
<ttl>360</ttl>
<item>
<title>人工智能的算法黑箱与数据正义</title>
<link>http://www.jintiankansha.me/t/YxxJYiU050</link>
<guid isPermaLink="true" >http://www.jintiankansha.me/t/YxxJYiU050</guid>
<description>&lt;div id=&quot;&quot;&gt;&lt;p&gt;&lt;img class=&quot;&quot; data-backh=&quot;314&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/f84kJBXzrBUZZ8xYKuc9TUu3wlMskfgHVXxG6cjyHBbvnoKfwPVUx2Q1V1mXic4ldGqXMfkicCMrJAS5glrXS5icQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; width=&quot;100%&quot;/&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; data-tools=&quot;135&amp;#x7F16;&amp;#x8F91;&amp;#x5668;&quot; data-id=&quot;86456&quot;&gt;&lt;section class=&quot;&quot; readability=&quot;2.5&quot;&gt;&lt;section data-bgless=&quot;lighten&quot; data-bglessp=&quot;15%&quot; readability=&quot;5&quot;&gt;&lt;p&gt;&lt;span&gt;一个月前，《终极算法》作者、人工智能著名学者、华盛顿大学教授 Pedro Domingos 在社交网络中写道：“自 5 月 25 日起，欧盟将会要求所有算法解释其输出原理，这意味着深度学习成为非法的方式。”一石激起千层浪。人们不禁要问：欧盟为何出台这个法规？以深度学习为核心的人工智能真的会遭遇重大挫折？中国应当借鉴并仿效吗？&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7920997920997921&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/f84kJBXzrBUZZ8xYKuc9TUu3wlMskfgHspmV2PRcnwWcS7VZCafvn66COnCWbFJg4Yb4cplBAP4OlicfpibLtL1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;481&quot;/&gt;&lt;/p&gt;


&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;&quot;&gt;&lt;section readability=&quot;1&quot;&gt;&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;用人工智能的自动化决定&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;尽管真正拥有知觉和自我意识的“强人工智能”仍属幻想，但专注于特定功能的“弱人工智能”早如雨后春笋般涌现。在万物互联的背景下，以云计算为用，以个人数据为体，以机器学习为魂的智能应用已经“润物细无声”。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从今日头条的个性化推送到蚂蚁金服的芝麻信用评分，从京东的“奶爸当家指数”到某旅游网站用大数据“杀熟”，个人信息自动化分析深嵌入到我们日常生活之中。在法律上，我们称之为“基于个人信息的自动化决定”。简单来说，就是通过自动化的数据处理，评估、分析及预测个人的工作表现、经济状况、位置、健康状况、个人偏好、可信赖度或者行为表现，进而利用这种“数据画像”（profiling），在不同的业务场景中作出有关数据主体的各项决定。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.5683836589698046&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/f84kJBXzrBUZZ8xYKuc9TUu3wlMskfgHoq2APPIVkK3vPbbuklLnryesZ19LueYDXWZInqQb1ZFECoeFPIvxXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;563&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;人工智能的自动化决定一方面可以给我们带来便利，比如智能投顾或智能医疗，但另一方面，它绝非完美无缺，它可能出错，甚至还可能存在“恶意”。美国马萨诸塞州的居民John Gass便深受其害。联邦调查局的反恐识别系统将他误认为是另一位司机，并吊销了他的驾驶执照，于是，他不得不费时费力，让当局相信他不是那名司机。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其实，John Cass已经非常幸运。在美国，每周超过1000人被机场使用的算法错误地标记为恐怖分子。一名美国航空公司的飞行员在一年中被拘留了80次，因为他的名字与爱尔兰共和军领导人的名字相似。这还不算是最糟糕的。人工智能的算法依赖于大数据，而大数据并非中立。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;它们从真实社会中抽取，必然带有社会固有的不平等、排斥性和歧视的痕迹。例如，为了在Twitter上与千禧一代进行对话，微软开发了Tay聊天机器人，它旨在学习如何通过复制网民的语音来模仿他人。可仅仅在试用24小时后，它就被引入歧途，成为支持种族灭绝的反女权主义纳粹分子，以至于发出了“希特勒无罪”的消息。更有甚者，美国法院用以评估犯罪风险的算法COMPAS，亦被证明对黑人造成了系统性歧视。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7343173431734318&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/f84kJBXzrBUZZ8xYKuc9TUu3wlMskfgHH2aicetPtkgKvdkk7bYTYHnJUS1yFBIzrvHVVFrNA7nhA9rQu6Rlsdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;542&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;无论是程序错误，还是算法歧视，在人工智能的前沿领域——深度学习中，都变得难以识别。华盛顿特区的Sarah Wysocki是一位被普遍认可的老师，但当2009年政府用一个自动化决定程序来评价教师表现时，她和其他205人因得分不佳被解雇。据称，该决定以少数学生的成绩为依据，可学校始终无法解释为何优秀教师会落得如此下场。华盛顿学校的难题有着深层次原因。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;与传统机器学习不同，深度学习并不遵循数据输入、特征提取、特征选择、逻辑推理、预测的过程，而是由计算机直接从事物原始特征出发，自动学习和生成高级的认知结果。在人工智能输入的数据和其输出的答案之间，存在着我们无法洞悉的“隐层”，它被称为“黑箱”（black box）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;这里的“黑箱”并不只意味着不能观察，还意味着即使计算机试图向我们解释，我们也无法理解。哥伦比亚大学的机器人学家 Hod Lipson把这一困境形象地描述为“这就像是向一条狗解释莎士比亚是谁。”&lt;/span&gt;&lt;/p&gt;


&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;&quot;&gt;&lt;section readability=&quot;1&quot;&gt;&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;《统一数据保护条例》的应对&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;正是因为人工智能的自动化决定对个人权利的重大影响，将于2018年5月25日生效的欧盟《统一数据保护条例》（GDRR）在1995年《数据保护指令》（Directive 95/46/EC）的基础上，进一步强化了对自然人数据的保护。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首先，尊重个人的选择权。当自动化决定将对个人产生法律上的后果或类似效果时，除非当事人明确同意，或者对于当事人间合同的达成和履行来说必不可少，否则，个人均有权不受相关决定的限制。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.5380228136882129&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/f84kJBXzrBUZZ8xYKuc9TUu3wlMskfgHKgHmwFuibt4ybbl5r2c7cb1LKerqe1lak9yKRbIsEUx0m7icq3o8S4Bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;526&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其次，将个人敏感数据排除在人工智能的自动化决定之外。根据《统一数据保护条例》第9（1）条，“敏感数据”即有关种族、政治倾向、宗教信仰、健康、性生活、性取向的数据，或者可唯一性识别自然人的基因数据、生物数据。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;由于这些数据一旦遭到泄露、修改或不当利用，就会对个人造成不良影响，因此，欧盟一律禁止自动化处理，即使当事人同意亦是如是，只有在明确的法律规定时才存在例外。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.6419965576592083&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/f84kJBXzrBUZZ8xYKuc9TUu3wlMskfgHZ30DmKf8MQKdia664Nice0Aqwge8MvwoBoczcqDFLQLia2DibUkFKVbl5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;再次，增加数据使用者在个人数据收集时的透明度。根据《统一数据保护条例》第13条（f）和第14条（g），如果个人数据将用于自动化决定，那么至少应当向个人提供相关决定的重要性、对个人预期的影响以及有关运算逻辑的“有用信息”。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;比如，在银行收集个人数据时，应当告知其可能使用人工智能对贷款人资质进行审核，而审核的最坏结果（如不批贷）也应一并披露。此外，由于我们都不是技术专家，因此，这里的“有用信息”不但应浅显易懂，为每个人理解，而且要有助于每个人主张自己在《统一数据保护条例》或其他法律下的权利。还是以贷款审核为例，当我们觉得被不公正对待时，银行提供的信息就应当成为法院审理的重要依据。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.46798029556650245&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/f84kJBXzrBUZZ8xYKuc9TUu3wlMskfgHwlEoCIWuaBiaUficZEEHRbvFBd8EQWFbw52H3dwO0iaxuiaUBpL4GNNmLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最后，如果个人对自动化决定不满，则有权主张人工介入，以表达自己的观点并提出质疑。这一规定和上述透明度要求相结合，产生了针对人工智能的所谓“解释权”，而这正是Pedro Domingos的担忧所在。考虑到算法黑箱，深度学习的合法化似乎是个无解的问题。但事实上，这可能是个误解。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一方面，“有用信息”的提供是在收集数据之时，而非作出自动化决定之后，其意味着个人仅仅概括地了解系统的一般原则即可，并不需要彻底把握某项具体决定的逻辑。另一方面，法律所看重的是“可理解”（explainable），而不是“可阐释（interpretable）。换言之，它不关注人工智能内部究竟如何运作，而只关心输入数据和输出结果的关联关系。在加州大学伯克利分校发布的《人工智能的系统挑战：一个伯克利的观点》（A Berkeley View of Systems Challenges for AI）中，这种关联性被称“反事实问题”测试。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在个人被拒绝贷款的例子中，人工智能系统必须能否回答如果诸如“我不是女性，是不是就能批贷？”“如果我不是小企业主，是不是就能批贷”这样的问题。因而数据使用者有义务建构出一套具有交互诊断分析能力的系统，通过检视输入数据和重现执行过程，来化解人们的质疑。这才是“人工介入”的真实含义。&lt;/span&gt;&lt;/p&gt;


&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;&quot;&gt;&lt;section readability=&quot;1&quot;&gt;&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;将数据正义引入中国&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;数据是数字经济的关键生产要素，人工智能是数字经济的关键产业支柱。如何在发掘数据的经济价值、发展人工智能的同时，保障个人的权利和自由，依然是数字社会的未解难题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当前，我国尚无《个人信息保护法》，在不久前出台的《个人信息安全规范》中，第7.10条“约束信息系统自动决策”也只是赋予了个人提出申请的程序性权利，并不涉及实质约束。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;无独有偶，中国电子技术标准化研究院发布的《人工智能标准化白皮书》虽然已关注到人工智能的伦理和隐私问题，但着墨不多，因过于原则而难以实施。就此而言，《统一数据保护条例》可成为我国可资借鉴的他山之石。它不仅仅提供了一系列具象的法律规则，更重要的是它在“数据效率”之外，传递出“数据正义”（data justice）的理念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.5117540687160941&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/f84kJBXzrBUZZ8xYKuc9TUu3wlMskfgHl1n1HKPhlNibXXeDOiccqorW4AIy7UUC6ySchiag42jelhrgT4ZVx996w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;553&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;尽管作为一个发展中的理念，数据正义的含义远未定型，但“反数据歧视”和“数据透明”必然是题中之意。在数字化生存的今天，不管是“社会人”还是“经济人”，都首先是“数字人”。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现实空间的我们被数据所记载、所表达、所模拟、所处理、所预测，现实空间的歧视也是如此。从求职歧视到消费歧视和司法歧视，数据歧视前所未有地制度化和系统化。基于此，法律首先要做的就是规定更加小心和负责地收集、使用、共享可能导致歧视的任何敏感数据。可这显然不够。从大数据的相关性原理出发，只是将敏感数据简单排除并不能保证它们不被考虑。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;例如，若特定区域的人有着大量的低收入群体或少数族裔，那么区域的地理数据就可以代替收入或种族数据，用作歧视工具。所以，要识别和挑战数据应用中的歧视和偏见，“数据透明”就不可或缺。换言之，它要求在数据生产和处理日趋复杂的形势下，增强个人的知情权，从而修复信息的对称性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;关于这一点，凯文·凯利所讲的老婆婆故事是一个绝佳的例子。在故事里，你住在一个小城镇，你的邻居老婆婆知道你的一切动向和行踪，但你可能不会觉得被冒犯，因为你不在家的时候，老婆婆会帮你看家；更重要的是，你了解关于老婆婆的一切。从信息窥视的角度，数字时代的政府和企业就像邻居老婆婆，不过，他们只是部分地做到了第一点，就第二点而言，我们却还有很长的路要走。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;作者：许可，法学博士、中国人民大学金融科技与互联网安全研究中心副主任&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p&gt;&lt;span&gt;稿件涉及数学、物理、算法、计算机、编程等相关领域&lt;br/&gt;稿件一经采用，我们将奉上稿酬。&lt;/span&gt;&lt;/p&gt;</description>
<pubDate>Mon, 19 Mar 2018 18:33:53 +0000</pubDate>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.jintiankansha.me/t/YxxJYiU050</dc:identifier>
</item>
<item>
<title>图论的各种基本算法</title>
<link>http://www.jintiankansha.me/t/XCcHMN506E</link>
<guid isPermaLink="true" >http://www.jintiankansha.me/t/XCcHMN506E</guid>
<description>&lt;section class=&quot;&quot; data-tools=&quot;135&amp;#x7F16;&amp;#x8F91;&amp;#x5668;&quot; data-id=&quot;86456&quot;&gt;&lt;section class=&quot;&quot; readability=&quot;1.5&quot;&gt;&lt;section data-bgless=&quot;lighten&quot; data-bglessp=&quot;15%&quot; readability=&quot;3&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;本篇主要涉及到图论的基本算法&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，不包含有关最大流的内容。图论的大部分算法都是由性质或推论得出来的，想朴素想出来确实不容易。&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二分图(Is-Bipartite)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一个图的所有顶点可以划分成两个子集，使所有的边的入度和出度顶点分别在这两个子集中。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个问题可以转换为上篇提到过的图的着色问题，只要看图是否能着2个颜色就行了。当然，可以回溯解决这个问题，不过对于着2个颜色可以BFS解决。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;同样，一维数组colors表示节点已着的颜色。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IS-BIPARTITE(g,colors)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let queue be new Queue&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  colors[0] = 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  queue.push(0)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  while queue.empty() == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    let v = queue.top()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    queue.pop()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for i equal to every vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      if colors[i] == 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        colors[i] = 3 - colors[v]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        queue.push(i)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      else if colors[i] == colors[v]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        return false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  return true&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:Θ(V+E)，V表示顶点的个数，E表示边的个数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;DFS改良(DFS-Improve)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上篇文章提到过，搜索解空间是树形的，也就是在说BFS和DFS。那么在对图进行BFS和DFS有什么区别呢，这个问题要从解空间角度去理解。对图进行BFS的解空间是一颗树，可叫广度优先树。而DFS是多棵树构成的森林，可叫深度优先森林。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里要对DFS进行小小的改良，它的性质会对解多个问题会很有帮助。原版DFS搜索的时候，会先遍历本顶点，再递归遍历临接的顶点。DFS改良希望能先递归遍历临接的顶点，再遍历本顶点，并且按遍历顺序逆序存储起来。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DFS-IMPROVE(v,visited,stack)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  visited[v] = true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for i equal to every vertex adjacent to v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if visited[i] == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      DFS-IMPROVE(i,visited,stack)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  stack.push(v)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;这个改良版DFS有个很有用的性质就是，对于两个顶点A、B，存在A到B的路径，而不存在B到A的路径，则从记录的顺序中取出的时候，一定会先取出顶点A，再取出顶点B。以下为这个性质的证明。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;假设：有两个顶点A和B，存在路径从A到B，不存在路径从B到A。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;证明：分为两种情况，情况一，先搜索到A顶点，情况二，先搜索到B顶点。对于情况一，由命题可得，A一定存储在B之后，那么取出时先取出的是顶点A。对于情况二，先搜索到B顶点，由于B顶点搜索不到A顶点，则A一定存储在B之后，那么取出时仍先取出的是顶点A，命题得证。&lt;/span&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; 
&lt;p&gt;&lt;span&gt;DFS改良性质：对于两个顶点A、B，存在A到B的路径，而不存在B到A的路径，则从记录的顺序中取出的时候，一定会先取出顶点A，再取出顶点B。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;欧拉回路(Eulerian-Path-And-Circuit)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在无向图中，欧拉路径定义为，一条路径经过所有的边，每个边只经过一次。欧拉回路定义为，存在一条欧拉路径且路径的起点和终点为同一个顶点。可以看到只有连通图才能有欧拉回路和欧拉路径。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个算法很巧。如果一条路径要经过一个顶点，本质是从一条边到达一个顶点，然后从这个顶点通过另一条边出去。欧拉回路就是要求路径要经过所有的点，起点和终点还都是同一个顶点。那么就等价于要求所有顶点连接的边是2个。实际上，路径还可以经过顶点多次，那么就等价于要求所有顶点连接的边是偶数个。欧拉路径的要求就等价于所有顶点连接的边是偶数个，除了起点和终点两个顶点可以是奇数个。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;先判断图是否是连通图。返回0代表没有欧拉回路或者欧拉路径，返回1代表有欧拉路径，返回2代表有欧拉回路。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;EULERIAN-PATH-AND-CIRCUIT(g)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  if isConnected(g) == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    return 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let odd = 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for v equal to every vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if v has not even edge &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      odd = odd + 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  if odd &amp;gt; 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    returon 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  if odd == 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    return 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  if odd == 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    return 2&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; 
&lt;p&gt;&lt;span&gt;时间复杂度:Θ(V+E)，V表示顶点的个数，E表示边的个数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;拓扑排序(Topological-Sorting)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;将一张有向无环图的顶点排序，排序规则是所有边的入度顶点要在出度顶点之前。可以看到，无向和有环图都不存在拓扑排序，并且拓扑排序可能存在多种解。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;拓扑排序有两种解法，一种是从搜索角度。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果我能保障先递归遍历临接的顶点，再遍历本顶点的话，那么遍历的顺序的逆序就是一个拓扑排序。那么就可以直接用DFS改良求解出拓扑排序。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TOPOLOGICAL-SORTING-DFS(g)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let visited be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let result be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let stack be new Stack&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for v equal to every vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if visited[v] == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      DFS-IMPROVE(v,visited,stack)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  while stack.empty() == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      result.append(stack.top())&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      stack.pop()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  return result&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:Θ(V+E)，V表示顶点的个数，E表示边的个数&lt;/span&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; 
&lt;p&gt;&lt;span&gt;另一种是贪心选择。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;直觉上，既然要所有边的出度顶点在入度顶点之前，可以从入度和出度角度来解决问题。可以让入度最小的排序在前，也可以让出度最大的排序在后，排序后，这个顶点的边都不会再影响问题了，可以去掉。去掉后再重新加入新的顶点，直到加入所有顶点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个问题还有个隐含条件，挑选出、入度最小的顶点就等价于挑选出、入度为0的顶点。这是因为图必须是无环图，所以肯定存在出、入度为0的顶点，那么出、入度最小的顶点就是出、入度为0的顶点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;直觉上这是一个可行的策略，细想一下，按出度最大排序和按入度为零排序是否等价。实际上是不等价的，按入度为零排序，如果出现了多个入度为零的顶点，这多个顶点排序的顺序是无关的，可以任意排序。而按出度最大排序，出现了多个入度最大的顶点，这多个顶点排序是有关的，不能任意排序。所以，只能按入度为零排序。实际上，这个想法就是贪心选择。下面以挑选入度为零的边作为贪心选择解决问题，同样地，还是先证明这个贪心选择的正确性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;命题：入度为零的顶点v排序在前。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;假设：S为图的一个拓扑排序，l为此排序的首个顶点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;证明：如果l=v，则命题得证。如果l不等于v，将l顶点从S中去除，然后加入顶点v得到新的排序S‘。因为S去除l以后l以后的排序没有变，仍为拓扑排序，v入度为零，v前面可以没有顶点，所以S’也为图的一个拓扑排序，命题得证。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;29&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TOPOLOGICAL-SORTING-GREEDY(g)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let inDegree be every verties inDegree Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let stack be new Stack&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let result be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for v equal to every vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if inDegree[v] == 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      stack.push(v)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  while stack.empty() == false&lt;/span&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;    vertex v = stack.top()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    stack.pop()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    result.append(v)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for i equal to every vertex adjacent to v &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      inDegree[i] = inDegree[i] - 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      if inDegree[i] == 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        stack.push(i)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  return result.reverse()&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:Θ(V+E)，V表示顶点的个数，E表示边的个数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;强连通分量(Strongly-Connected-Components)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;图中的一个顶点与另一个顶点互相都有路径可以抵达，就说这两个顶点强连通。图中有多个顶点两两之间都强连通，则这多个顶点构成图的强连通分量。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;朴素的想法是，假如从一个顶点A可以搜索到另一个顶点B，如果从B顶点再能搜索回A顶点的话，A、B就在一个强连通分量中。不过，这样每两个顶点要进行两次DFS，复杂度肯定会很高。这里可以引入转置图(将有向边的方向翻转)的性质。这样问题就转换成了，从A顶点搜索到B顶点，将图转置后，如果再A顶点还能搜索到B顶点，A、B顶点就在一个强连通分量中。用算法表述出来就是先从A顶点DFS，然后将图转置，再从A顶点DFS，两次DFS都能搜索到B顶点的话，B顶点就与A顶点在同一个强连通分量中。然而朴素想法只能想到这里了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;有多个算法被研究出来解决这个问题，下面先介绍Kosaraju算法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Kosaraju&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Kosaraju算法使用了DFS改良的性质去解决问题，想法很有趣。Kosaraju算法现将图进行DFS改良，然后将图转置，再进行DFS。第二次DFS每个顶点能够搜索到的点就是一个强连通分量。算法正确性和说明如下。&lt;/span&gt;&lt;/p&gt;

&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;通过DFS改良性质可以得出定理，一个强连通分量C如果有到达另一个强连通分量C’的路径，则C’比C先被搜索完，这个定理很明显，如果C中有路径到C’，那么根据DFS改良性质一定会先搜索到C，再搜索完C’，再搜索完C。将这个定理做定理1。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;定理1：一个强连通分量C如果有到达另一个强连通分量C’的路径，则C’比C先被搜索完。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;定理1还可以再进行推论，如果一个强连通分量C有到达另一个强连通分量C’的路径，则将图转置后，C比C’先被搜索完，这个推论也很明显，将图转置后，不存在C到C’的路径，存在C’到C的路径，而仍是先搜索C再搜索C‘，所以C比C‘先被搜索完，这个推论作为推论1。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;推论1：如果一个强连通分量C有到达另一个强连通分量C’的路径，则将图转置后，C比C’先被搜索完。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.5971685971685972&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwEicibLanv6K9HOz2fIuhrCWfqpWZ95n8myxx2wgIuDYzEanWPL4ykKESxLehbA8TLAxhgC6Lh6QWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;777&quot; width=&quot;670px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;以下为用结构归纳法对算法正确性进行证明。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;命题：第二次DFS每个顶点能够搜索到的点就是一个强连通分量。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;假设：n代表图中有多少个强连通分量。 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;证明：如果n=1，则第二次DFS就是搜索一遍所有顶点，命题得证。现在假设n=k时，命题成立。现证明n=k+1时，是否成立。假设搜索到第k+1个强连通分量的第一个顶点为u，u肯定能搜索到所有k+1个强连通分量的顶点。并且根据推论1，此时被转置后的图，所有从第k+1个强连通分量能到达的其他强连通分量都已经被搜索过了。所以u只能搜索到所有第k+1个强连通分量的顶点，即第二次DFS每个顶点只能够搜索到包含此顶点的强连通分量中的顶点，命题得证。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;37&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;KOSARAJU-STRONGLY-CONNECTED-COMPONENTS(g)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let visited be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;  let stack be new Stack&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for v equal to every vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if visited[v] == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      DFS-IMPROVE(v,visited,stack)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let gt = transpose of g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for v equal to every vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    visited[v] = false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  while stack.empty() == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    vertex v = stack.top()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    stack.pop()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if visited[v] == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      DFS(v,visited)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      print ' Found a Strongly Connected Components '&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DFS(v,visited)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  visited[v] = true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  print v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for i equal to every vertex adjacent to v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if visited[i] == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      DFS(i,visited,stack)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:Θ(V+E)，V表示顶点的个数，E表示边的个数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Kosaraju算法需要进行两次DFS，那么可不可以只进行一次DFS，边遍历边找强连通分量？Tarjan就是这样的算法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Tarjan&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;同样，还是要基于DFS搜索性质来思考问题。DFS创建出的深度优先搜索树会先被访问根节点再被访问子孙节点。什么时候会出现强连通分量？只有子孙节点有连通祖先节点的边的时候。如果从某个节点，其子孙节点都只有指向自己子孙节点的边的时候，这是明显没有构成强连通分量的。那么，出现了子孙节点指向其祖先节点的时候，从被指向的祖先节点一直搜索到指向的子孙节点所经过所有顶点就构成了一个强连通分量。如果出现了多个子孙节点都指向了祖先节点怎么办？最早被指向、访问的祖先节点到最晚指向、访问的子孙节点构成了“最大“的强连通分量，这才是想要找的强连通分量。如果遇到了一个指向祖先节点的子孙节点，就算构成一个强连通分量，会导致找到多个互相嵌套的强连通分量。那么，要记录访问顺序就要为每个节点设置一个被访问顺序的编号，让属于同一个强连通分量的顶点编号一致。上面讨论的是构成了一个强连通分量怎么处理，如果没有多个节点构成的强连通分量怎么处理？在搜索节点之前，为这个节点默认设置上被访问的顺序编号，这样如果没有搜索到多个节点构成的强连通分量，每个节点就是自己的强连通分量。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.510662177328844&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwEicibLanv6K9HOz2fIuhrCW956tKch091JUqDsI3QkxykAxBFmQvQWeevY3fIEdDKJEqOSGaW8AJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;891&quot; width=&quot;670px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;算法表述为，从某个节点开始搜索，默认设置自己为一个强连通分量。只要节点有子孙节点，就要等待子孙节点都搜索完，再更新自己强连通分量信息。只要节点有指向祖先节点，也要更新自己的强连通分量。判断子孙节点构成的强连通分量”大“还是自己构成的强连通分量”大“，自己属于最”大“的强连通分量。也就是说，算法找出了所有顶点的所属的最“大”强连通分量。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;数组disc表示顶点被访问顺序的编号，数组low表示顶点所在的强连通分量编号。最后当顶点在disc和low中编号一致时，代表顶点是所在强连通分量中第一个被搜索到的顶点。此时，输出所在的强连通分量所包括的顶点。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;55&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TARJAN-STRONGLY-CONNECTED-COMPONENTS(g)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let disc be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let low be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let stack be new Stack&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let isInStack be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for i from 1 to the number of vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    disc [i] = -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    low [i] = -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for u from 1 to the number of vertex in g &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if disc[i] != -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      TARJAN-STRONGLY-CONNECTED-COMPONENTS-UTIL(u,disc,low,stack,isInStack)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TARJAN-STRONGLY-CONNECTED-COMPONENTS-UTIL(u,disc,low,stack,isInStack)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let time be static&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;  time = time + 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  disc[u] = low[u] = time&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  stack.push(u)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  isInStack[u] = true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for v equal to every vertex adjacent to u&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if disc[v] == -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      TARJAN-STRONGLY-CONNECTED-COMPONENTS-UTIL(v,disc,low,stack,isInStack)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      low[u] = min(low[u],low[v])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    else if isInStack[v] == true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      low[u] = min(low[u],disc[v])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let w = 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if low[u] == disc[u]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      while stack.top() != u&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        w = stack.top()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        isInStack[w] = false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        stack.pop()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        print w&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      w = stack.top()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      isInStack[w] = false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      stack.pop()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      print w&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      print ' Found a Strongly Connected Components '&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:Θ(V+E)，V表示顶点的个数，E表示边的个数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;图的割点(Articulation Points)、桥(Bridge)、双连通分量(Biconnected Components)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;图的割点(Articulation-Points)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; 
&lt;p&gt;&lt;span&gt;图的割点也叫图的关节点，定义为无向图中分割两个连通分量的点，或者说去掉这个点，图中的连通分量数增加了。可以看到如果求出了连通分量，那么不同连通分量中间的顶点就是割点。什么时候某个顶点不是这样的割点？如果这个顶点的子孙顶点有连接这个顶点祖先顶点的边，那么去掉这个顶点，这个顶点的子孙顶点和祖先顶点仍然连通。那么，寻找割点的过程就等价于寻找子孙顶点没有连接祖先顶点的顶点。这个问题的求解过程类似于Tarjan强连通分量的求解过程。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;不过，这个问题有个例外就是根顶点，对一般顶点的处理方式处理根顶点行得通吗？根顶点肯定没有子孙顶点指向祖先顶点，但是根顶点可以是割点。所以，根顶点需要特殊处理。根顶点什么时候是割点？当根顶点有多颗子树，且之间无法互相到达的时候。那么，存不存在根顶点有多颗子树，且之间可以互相到达？不存在，如果互相之间可以到达，那在根顶点搜索第一颗子树的时候，就会搜索到可到达的子树，就不会存在多颗子树了。所以，根顶点有多颗子树，那么这多颗子树之间一定无法互相到达。根顶点有多颗子树，且之间无法互相到达的时候就等价于根顶点有多颗子树。所以，只要根顶点有多颗子树，那么根顶点就是割点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;同样地，数组disc表示顶点被访问顺序的编号，数组low表示顶点所在的强连通分量编号。数组parent找出根顶点。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;68&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ARTICULATION-POINTS(g)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let disc be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let low be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let result be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let parent be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let visited be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for i from 1 to the number of vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    result [i] = false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    visited [i] = false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    parent [i] = -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for u from 1 to the number of vertex in g &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if visited[i] == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      ARTICULATION-POINTS-UTIL(u,disc,low,result,parent,visited)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for i from 1 to the number if vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if result[i] == true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      print ' Found a Articulation Points i '&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ARTICULATION-POINTS-UTIL(u,disc,low,result,parent,visited)&lt;/span&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;  let time be static&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  time = time + 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let children = 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  disc[u] = low[u] = time&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  visited[u] = true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for v equal to every vertex adjacent to u&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if visited[v] == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      children = children + 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      parent[v] = u&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      ARTICULATION-POINTS-UTIL(u,disc,low,result,parent,visited)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      low[u] = min(low[u],low[v])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      if parnet[u] == -1 and children &amp;gt; 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        result[u] = true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      if parent[u] != -1 and low[v] &amp;gt;= disc[u]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        result[u] = true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    else if v != parent[u]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      low[u] = min(low[u],disc[v])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:Θ(V+E)，V表示顶点的个数，E表示边的个数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;桥(Bridge)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;桥定义为一条边，且去掉这个边，图中的连通分量数增加了。类似于寻找割点，寻找桥就是寻找这样一条，一端的顶点的子孙顶点没有连接这个顶点和其祖先顶点的边。求解过程和求割点基本一致。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;51&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BRIDGE(g)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let disc be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;    let low be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let parent be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let visited be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for i from 1 to the number of vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    visited [i] = false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    parent [i] = -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for u from 1 to the number of vertex in g &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if visited[i] == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      BRIDGE-UTIL(u,disc,low,parent,visited)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BRIDGE-UTIL(u,disc,low,parent,visited)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let time be static&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  time = time + 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  disc[u] = low[u] = time&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for v equal to every vertex adjacent to u&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if visited[v] == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      parent[v] = u&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      BRIDGE-UTIL(u,disc,low,parent,visited)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      low[u] = min(low[u],low[v])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      if low[v] &amp;gt; disc[u]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        print ' Found a Bridge u-&amp;gt;v '&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    else if v != parent[u]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      low[u] = min(low[u],disc[v])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:Θ(V+E)，V表示顶点的个数，E表示边的个数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;双连通分量(Biconnected-Components)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;双连通图定义为没有割点的图。双连通图的极大子图就为双连通分量。双连通分量就是在割点分割成多个连通分量处，共享割点。也就是说双连通分量是去掉割点后构成的连通分量，加上割点和到达割点的边。可以看出，双连通分量可分为不含有割点、一个割点、两个割点三种情况。对于不含有割点，说明图为双连通图。对于含有一个割点，可能为初始搜索的顶点到第一个割点之间的边构成的双连通分量，可能为遇到一个割点后到不再遇到割点之间的边构成双连通分量。对于含有两个割点，两个割点之间的边构成了一个双连通分量。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;求解此问题，只要在求割点的算法上做更改就可以了。按照求割点的算法求解割点，找到一个割点，输出找到的边，然后删除找到的边的记录，再去搜索下一个割点。每搜索完图某个顶点的可达顶点，输出找到的边。这样就涵盖了所有的情况。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;67&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BICONNECTED-COMPONENTS(g)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let disc be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let low be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let stack be new Stack&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let parent be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for i from 1 to the number of vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    disc [i] = -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    low [i] = -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    parent [i] = -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for u from 1 to the number of vertex in g &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if disc[i] == -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      BICONNECTED-COMPONENTS-UTIL(u,disc,low,stack,parent)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    let flag = flase&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    while stack.empty() == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      flag = true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      print stack.top().src -&amp;gt; stack.top().des&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      stack.pop()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if flag == true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      print ' Found a Bioconnected-Components '&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BICONNECTED-COMPONENTS-UTIL(u,disc,low,stack,parent)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let time be static&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  time = time + 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;  let children = 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  disc[u] = low[u] = time&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for v equal to every vertex adjacent to u&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if disc[v] == -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      children = children + 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      parent[v] = u&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      stack.push(u-&amp;gt;v)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      BICONNECTED-COMPONENTS-UTIL(u,disc,low,stack,parent)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      low[u] = min(low[u],low[v])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      if (parnet[u] == -1 and children &amp;gt; 1) or (parent[u] != -1 and low[v] &amp;gt;= disc[u])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        while stack.top().src != u or stack.top().des != v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          print stack.top().src -&amp;gt; stack.top().des&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          stack.pop()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        print stack.top().src -&amp;gt; stack.top().des&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        stack.pop()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        print ' Found a Bioconnected-Components '&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    else if v != parent[u] and disc[v] &amp;lt; low[u]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      low[u] = min(low[u],disc[v])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      stack.push(u-&amp;gt;v)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:Θ(V+E)，V表示顶点的个数，E表示边的个数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;最小生成树(Minimum-Spanning-Tree)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;生成树是指，在一个连通、无向、有权的图中，所有顶点构成的一颗树。图中可以有多颗生成树，而生成树的代价就是树中所有边的权重的和。最小生成树就是生成树中代价最小的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;朴素的想法就是从图中选择最小权重的边，直到生成一颗树。看通用的算法之前，同样要讨论一下最小生成树的性质。&lt;/span&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; 
&lt;p&gt;&lt;span&gt;对于一个连通、无向、有权图中，一定有最小生成树。如果图不包含最小生成树的任意一条边，那么图就是不连通的了，这与已知连通图不符，所以图必包含最小生成树。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;假设，A为某个最小生成树的子集(任意一个顶点都是最小生成树的子集)。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;那么，为A一直添加对的边，A最后就会成为一颗最小生成树。那么最小生成树问题就转换成为了，一直找到对的边，直到成为一颗最小生成树。这个对的边可以叫做安全边。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;安全边如何寻找显然就成了解决这个问题的关键点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;再假设，图中所有顶点为V，将所有顶点切割成两个部分S和V减去S。所有连接这两个部分的边，很形象的叫做横跨切割，这些边横跨了两个部分，成为这两个部分的桥梁。这里还有个问题，如何切割？使A不包含横跨切割。这样的切割有多种切法，切割后，横跨切割的最小代价边就为A的安全边。将这个作为定理1。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.4915254237288136&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwEicibLanv6K9HOz2fIuhrCWibmWiapaicdy4YiaFNNZVQFlXSsAquo6pmt62wk4T0Tw8rRI6cDVs6HoqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;944&quot; width=&quot;670px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;定理1：存在这样一个将所有顶点分成两个部分的切割，且使某个最小生成树子集A不包含横跨切割。则横跨此切割的最小代价边，就是A的安全边。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;以下为此定理的证明，这个定理的基础实际上是连通性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;命题：横跨切割的最小代价边为A的安全边。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;假设：横跨切割后的最小代价边为x，有最小生成树T包含A，但是不包含x。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;证明：既然T不包含x，那么T必须包含另一条连接x两端顶点的路径，这条路径上又必须有条边横跨切割。假设这条边为y。T将y减去后，x两端的顶点就无法互相到达。这时如果再加上x，那么x两端的顶点又可以互相到达，并且构造了另一颗生成树T’。可以看到，x的代价小于或等于y的代价，那么T‘的代价也小于或等于T的代价，那么T’也就是一颗最小生成树。那么x既不在A中，x又在一颗包含A的最小生成树中。命题得证。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可以看到这个证明过程使用的就是经常拿来证明贪心选择的技巧，也就是说最小生成树问题符合贪心算法的特征，也就解释了为什么下面将要提到的两个算法都是贪心算法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;定理1还可以进行推论，既然切割有多种方法，那可不可以对A和其余的顶点进行切割，设B为包括A和所有顶点构成的一个森林，C是其中的一个连通分量，那么C连接其他的连通分量的最小代价边是A的安全边。这个推论很好证明，因为A是B中的一个或者多个连通分量，如果按照C去切割图分成C和B减去C，不可能切割A，即A中必定不包含横跨切割。那么，横跨这个切割的最小代价边就是安全边，即C连接其他连通分量的最小代价边，推论成立。将这个推论作为推论1。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;推论1:某个最小生成树子集A和其他顶点构成的森林中，任意一个连通分量连接其他连通分量的最小代价边都为A的安全边。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果从所有不在A中的边选择最小代价的边，这个边一定连接着某个连通分量，这个推论也就将选安全边的范围拓展到任意一条不在A中的边。这个推论正好可以证明朴素想法的正确性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接下来看一下最小生成树的三个通用的算法Kruskal、Prime、Boruvka。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Kruskal&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;朴素想法和Kruskal已经很接近了。Kruskal算法做的就是一直选择代价最小的边，不过，如果选择这个边后，无生成最小生成树，而生成图了怎么办？Kruskal比朴素想法巧的地方就是不选择会成环的边。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Kruskal常用的检查是否成环的数据结构是UnionFind(并查集)，UnionFind有个操作，一个是Find检查元素所在集合的编号，Union将两个元素合并成一个集合。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;span&gt;KRUSKAL(g)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let edges be all the edges of g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sort(edges)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let uf be new UnionFind&lt;/span&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;  let e = 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let i = 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let result be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  while e &amp;lt; edges.length()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    let edge = edges[i]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    i = i + 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if uf.find(edge.src) != uf.find(edge.des)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      result.append(edge)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      e = e + 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      uf.union(edge.src,edge.des)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  return result&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;V表示顶点的个数，E表示边的个数，排序E个边加上E次UnionFind操作&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:O(Elog2E+Elog2V)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Prim&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;有了推论1，Prim算法的正确性理解起来就很简单了，一直只对最小生成树子集进行切割，然后选择出最小生成树子集与其他连通分量的最小代价边就OK了。Prim算法就是一直选择最小生成树子集与其他顶点连接的最小代价边。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Prim算法维持这样一个最小堆，存储最小生成树子集以外的顶点，与最小生成树子集临接的顶点的权重是其临接边的值，其余的最小堆中的顶点权重都是无穷。Prim算法初始将起始顶点在最小堆中的权重置为0，其余的顶点置为无穷。然后从最小堆中一直取权重最小的顶点，即选择最小代价边加入最小生成树，如果取出的顶点的临接顶点不在最小生成树中，且这个临接顶点在最小堆中的权重比边大，则更新临接顶点在最小堆的权重，直到从最小堆中取出所有的顶点，就得到了一颗最小生成树。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;28&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PRIM(g,s)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let heap be new MinHeap&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;  let result be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for i from 1 to the number of vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    let vertex be new Vertex(i)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    vertex.weight = INT_MAX&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    heap.insert(vertex)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  heap.decrease(s,0)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  while heap.empty() == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    vertex v = heap.top()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for u equal to every vertex adjacent to v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      if heap.isNotInHeap(u) and v-&amp;gt;u &amp;lt; heap.getWeightOfNode(u)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        result[u] = v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        heap.decrease(u,v-&amp;gt;u)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  return result&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;V表示顶点的个数，E表示边的个数，对V个顶点和E条边进行decrease操作&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:O(Elog2V+Vlog2V)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Boruvka&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Kruskal是根据所有边中最小代价边的一端的连通分量分割，Prim根据最小生成子树的子集分割，Boruvka根据所有的连通分量分割，实际上都是基于推论1。Boruvka算法将所有连通分量与其他连通分量的最小代价边选择出来，然后将这些边中未加入最小生成树子集的加进去，一直到生成最小生成树。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Boruvka算法同样使用了UnionFind去记录连通分量，用cheapest数组记录连通分量与其他连通分量连接的最小代价边的编号。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;46&quot;&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Boruvka(g)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let uf be new UnionFind&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let cheapest be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let edges be all the edge of g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let numTree = the number of vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let result be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for i from 1 to number of vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    cheapest[i] = -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  while numTree &amp;gt; 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for i from 1 to the number of edge in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      let set1 = uf.find(edges[i].src)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      let set2 = uf.find(edges[i].des)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      if set1 == set2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        continue&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      if cheapest[se1] == -1 or edges[cheapest[set1]].weight &amp;gt; edges[i].weight&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        cheapest[set1] = i&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      if cheapest[set2] == -1 or edges[cheapest[set2]].weight &amp;gt; edges[i].weight&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        cheapest[set2] = i&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for i from 1 to the number of vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      if cheapest[i] != -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        let set1 = uf.find(edges[cheapest[i]].src)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        let set2 = uf.find(edges[cheapest[i]].des)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        if set1 == set2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          continue&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        result[edges[cheapest[i]].src] = edges[cheapest[i]].des &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        uf.union(set1,set2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        numTree = numTree - 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  return result&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;时间复杂度:O(Elog2V)，V表示顶点的个数，E表示边的个数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;单源最短路径(Single-Source-Shortest-Paths)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;给出一张连通、有向图，找出一个顶点s到其他所有顶点的最短路径。可以看到，如果图中存在负环，不存在最短路径。因为存在负环就可以无限循环负环得到更短的路径。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;看通用的算法之前，同样要讨论一下问题的性质。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;假设，存在一条顶点s到顶点v的最短路径，i、j为路径上的两个顶点。那么在这条s到v最短路径上，i到j的路径是否是i到j的最短路径？是的，如果存在i到j的更短路径，就等价于存在一条s到v的更短路径，这与假设不符。也就是说，如果存在一条从s到v的最短路径，这条路径上任意两个顶点的路径都是这两个顶点的最短路径。那么，这个问题就具有动态规划的状态转移特征。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;解决此问题的朴素想法就是求出所有顶点s到顶点v的路径，然后取最小值。那么要是实现这个步骤，就要为v点存储一个估计值d，并设起始为无穷，如果有到达v的路径小于这个估计值，更新这个估计值，并且记录v的现阶段最小路径。这步操作叫做松弛操作(relax)。假设u为小于估计值路径上的上个顶点。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;RELAX(u,v,result)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  if v.d &amp;gt; u.d + u-&amp;gt;v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    v.d = u.d + u-&amp;gt;v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    result[v] = u&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.5134529147982063&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwEicibLanv6K9HOz2fIuhrCW4z0VmJGVW6rwhd35jw9b6UkOgYJeTAApqQicCnHoqAXa2fQn2q8YaZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot; width=&quot;670px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;那么，算法要做的就是一直松弛到达v顶点的路径，从无穷直到最小路径。可以看到，所有的求最短路径的算法都要基于这个操作去求解，不同的算法只能就是执行这个操作顺序不同或者次数不同。那么松弛操作会不会出问题，会不会松弛操作做过头了，将v的估计值松弛的比最短路径还小？不会，在算法运行期间，对于所有顶点，一直对顶点进行松弛操作，顶点的预估值不会低于最短路径。以下用结构证明法证明。&lt;/span&gt;&lt;/p&gt;

&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;假设：u代表任意一个连接v的顶点，s-&amp;gt;v代表s到v的边，s~&amp;gt;v代表s到v的最短路径。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;命题：对到达v的所有路径松弛操作有v.d &amp;gt;= s~&amp;gt;v&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;证明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于v=s的情况，v.d=0 s~v即s~s也为0，命题得证&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设对于顶点u，u.d &amp;gt;= s~&amp;gt;u成立。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有s~&amp;gt;v &amp;lt;= s~&amp;gt;u + u-&amp;gt;v，因为s~&amp;gt;v是一条最短路径，对于任意一条经过u到达v的路径，必小于最短路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;s~&amp;gt;v &amp;lt;= u.d + u-&amp;gt;v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为经过松弛操作v.d = u.d + u-&amp;gt;v，所以v.d &amp;gt;= s~&amp;gt;v，命题得证。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;松弛操作只能同时对一条边起作用。所以，最短路径长为n的路径，只能从最短路径长为n-1的路径，转移过来。这里就得到了这个问题最重要的性质，单源最短路径问题是个最短路径每次递增一的动态规划问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;单源最短路径性质：此问题是个最短路径每次长度递增一的动态规划问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在介绍通用算法之前，先介绍一种专对于有向无环图很巧的算法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;有向无环图单源最短路径(DAG-Shortest-Paths)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于有向无环图，可以先对图进行拓扑排序，然后按拓扑排序的顺序对每个顶点作为出度的边进行松弛操作，就得到了问题的一个解。以下证明算法的正确性。&lt;/span&gt;&lt;/p&gt;

&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;假设v为对图拓扑排序后的某个顶点。当对v作为出度的边进行松弛操作前，所有能到达v的路径都已经做过了松弛操作，此时已经找到了到达v的最短路径。那么，当对所有顶点作为出度的边进行松弛操作后，所有顶点的最短路径就已经被找到。算法的正确性得到证明。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DAG-SHORTEST-PATHS(g)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let sorted = TOPOLOGICAL-SORTING-GREEDY(g)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let result be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for u equal to every vertex in sorted&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for v equal to every vertex adjacent to u &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      if v.d &amp;gt; u.d + u-&amp;gt;v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        RELAX(u,v,result)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  return result&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:Θ(V+E)，V表示顶点的个数，E表示边的个数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接下来介绍两种通用的算法Bellman-Ford和Dijkstra。Bellman-Ford和Dijkstra有什么联系呢？Bellman-Ford可以解决有负权重图的单源最短路径问题，并且可以侦测出图中是否存在负环。Dijkstra只能解决没有负权重边的图的单源最短路径问题。Bellman-Ford是进行必须的最少次数的松弛操作。而Dijkstra发现，只要没有负权重边，还能进行更少的松弛操作解决问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Bellman-Ford&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Bellman-Ford是最通用的解决单源最短路径算法，初始将所有顶点估计值设为无穷，将源点设为零。然后，对所有边进行松弛操作，这个步骤作为内部循环。再将这个步骤做图的顶点个数减一次。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Bellman-Ford的正确性不难证明，可以看到随着Bellman-Ford算法内部的循环，Bellman-Ford找到的最短路径的长度也在增加。首先证明内部循环在循环到第n次时，找到了所有最短路径长为n的路径。我们用结构证明法。在以下证明中，可以看出Bellman-Ford虽然不是经典的动态规划算法，但是其原理是基于这个问题的动态规划性质的。&lt;/span&gt;&lt;/p&gt;

&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;证明：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于n=0时，最短路径为0，命题得证。 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;假设所有最短路径为n-1的路径已经被找到。因为根据单源最短路径的动态规划性质，最短路径长为n的路径，可以从最短路径长为n-1的路径，转移过来的。因为Bellman-Ford算法会对所有的边进行松弛操作。所以，所有长为n的最短路径会从相应的长为n-1的最短路径找到。命题得证。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;只要最短路径上不存在负环，那么所有最短路径就必小于V-1。所以，Bellman-Ford内部循环执行V-1次，能找到最长的最短路径，也就是能找到所有的最短路径。Bellman-Ford正确性证毕。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Bellman-Ford实现也很简单，这里添加一个flag位，提前省去不必要的循环。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BELLMAN-FORD(g,s)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let edges be all the edge of g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let result be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for i from 1 to the number of vertex of g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    result[i] = INT_MAX&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  result[s] = 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for i from 1 to the number of vertex of g minus 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    let flag = false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for j from 1 to the numnber of edge of g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      let edge = edges[j]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      if result[edge.src] != INT_MAX and edge.src &amp;gt; edge.des + edge.weight&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        RELAX(u,v,result)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        flag = true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if flag == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      break&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  return result&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:O(V⋅E)，V表示顶点的个数，E表示边的个数 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;为什么Bellman-Ford算法可以侦测出有负环？算法完成后再对图的所有边进行一次松弛操作，如果最短路径求得的值改变了，就是出现了负环。这个证明看一下松弛操作的定义就行了。根据松弛操作的性质，顶点的估计在等于最短路径后不会再改变了，如果改变了就是出现了负环，从而没有得到最短路径。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Dijkstra&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Dijkstra是个贪心算法，朴素的想一下，用贪心算法怎么解决问题。既然没有负权边，选出当前阶段最短的路径，这个路径就应该是到达这个路径终点的最短路径。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Dijkstra就是这样一个贪心算法，初始将所有顶点估计值设为无穷，将源点设为零。维护一个集合S代表已经找到的最短路径顶点，然后从集合S外所有顶点，选择有最小的估计值的顶点加入到集合中，然后再对这个顶点在S中的临接顶点做松弛操作，一直到所有顶点都在集合S中。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Dijkstra的贪心选择使用简单的反证法就可以证出。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;假设，现阶段要选从s到某个顶点u的路径作为最短路径加入到集合S中，并且这个选择是错误的。有另一条最短路径从s到达u，那么这条路径和原选择的路径肯定不一致，经过不同的顶点，假设这条最短路径上到达u的前一个顶点为k，既然这是一条从s到达u的最短路径，那么从s到k肯定比从s到v小，那么算法会先选择从s到k，然后选择最短路径，不会选择假设的路径，这与假设矛盾，假设不成立，贪心选择正确性得证。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;以下是算法导论上的证明，尝试从实际发生了什么去证明正确性，我认为有点clumsy(笨重)，核心的想法其实和上面简单的反证法一致。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;命题：选择有最小估计值的顶点加入集合S，那么这个估计值必定是这个顶点的最小路径。 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;同样使用反证法来证，并且关注已经选择了最小预估值的顶点但还没加入顶点S时的情形。&lt;/span&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; 
&lt;p&gt;&lt;span&gt;假如选择了顶点u，这时，将从s到u作为最小条路径加入到S中，分为两种情况。情况一，选择的从s到u的路径就是最短路径，那么命题已经得证。情况二，选择的从s到u的路径不是最短路径，存在u.d&amp;gt;s~&amp;gt;u。这种情况下，可以找到一个顶点x，使得x在集合S中，并在对x进行松弛操作后，找到另一个顶点y，使得y不在集合中且y的估计值就等于s到y的最短路径即s~&amp;gt;y。x可以与s重合，y可以与u重合。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;那么有y.d = s~&amp;gt;y&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为从s到y是从s到u的子路径，有s~&amp;gt;u &amp;gt;= s~&amp;gt;y&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;得出s~&amp;gt;u &amp;gt;= y.d&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为选择了顶点u，有u.d &amp;lt;= y.d&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;得出s~&amp;gt;u &amp;gt;= u.d&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这与假设矛盾，所以假设不成立，命题得证。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;实现和时间复杂度与Prim算法类似，集合S用最小堆实现。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;28&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DIJKSTRA(g,s)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let heap be new MinHeap&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let result be new Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for i from 1 to the number of vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    let vertex be new Vertex(i)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    vertex.d = INT_MAX&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    heap.insert(vertex)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  heap.decrease(s,0)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  while heap.empty() == false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    vertex u = heap.top()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for v equal to every vertex adjacent to u&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      if heap.isNotInHeap(v) and u.d v.d &amp;gt; u.d + u-&amp;gt;v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        RELAX(u,v,result)&lt;/span&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;        heap.decrease(v,v.d)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  return result&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;V表示顶点的个数，E表示边的个数，对V个顶点和E条边进行decrease操作&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:O(Elog2V+Vlog2V)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可以看到，如果运气好，Bellman-Ford不需要V次循环就可以找到所有最短路径，但是运气不好，Bellman-Ford要经过最少V次循环，这就是上文说到的，Bellman-Ford是进行必须的最少次数的松弛操作。而如果不存在负权重边，Dijkstra可以进行更少次的松弛操作，至多对每个顶点连接的边进行一次松弛操作就可以了，Bellman-Ford与Dijkstra的联系实际上就是动态规划与贪心算法的联系。Bellman-Ford和Dijkstra算法本质都是单源最短路径性质。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;全对最短路径(All-Pair-Shortest-Paths)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;全对最短路径就是将图中任意两点之间的最短路径求出来，输出一个矩阵，每个元素代表横坐标作为标号的顶点到纵坐标作为标号的顶点的最短路径。当然，可以对所有顶点运行一次Bellman-Ford算法得出结果，不过这样的复杂度就太高了。尝试去找到更好的算法解决这个问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;既然单源最短路径是个最短路径递增一的动态规划问题，尝试对全对最短路径使用这种性质，然后看看能不能降低复杂度。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;假设有n个顶点，dpij代表从顶点i到顶点j的最短路径，假设这条最短路径长为m，且k为任意顶点。那么，根据这个问题的动态规划状态转移特征，dpij是由长度为m−1的dpik加上k-&amp;gt;j转移过来的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.14925373134328357&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwEicibLanv6K9HOz2fIuhrCWUNg4s6ic7E5g5yF4Qely1NIRSRcEOCNpAFWO77G28pa7T6ITpgaK15A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot; width=&quot;670px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;看来即使在单源最短路径动态规划的性质上进行求解，复杂度仍然很高。&lt;/span&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; 
&lt;p&gt;&lt;span&gt;尝试不从最短路径长度角度考虑动态规划，从顶点角度去考虑动态规划，引出一个通用的算法Floyd-Warshall。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Floyd-Warshall&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;好，从顶点的角度去思考动态规划。从顶点i到顶点j要经过其他顶点，假设经过的顶点为k。然后根据解动态规划的经验，猜想dpij与dpik和dpkj怎么能沾到边？假设从i到j只需要经过[1,k]集合中的顶点。如果从i到j经过k，那么dpik就代表从i到k的最短路径，dpkj就代表从k到j的最短路径，dpij就等于从dpik和dpkj转移过去，而dpik和dpkj都不经过k，都只需要经过[1,k-1]集合中的顶点。如果从i到j不经过k，dpij就等于从i到j只需要经过[i,k-1]集合中的顶点时的dpij。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.4994535519125683&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwEicibLanv6K9HOz2fIuhrCWpbU2KMK4ibKasxnowp4toYknbdZicgTUXk5s6v0EUBhu4IPxMxEZZogw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;915&quot; width=&quot;670px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.11464968152866242&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwEicibLanv6K9HOz2fIuhrCWgjjToWD6Wrq6e876k3erUqLAiaicDm0D9NNFrsnYUR7qJ16aPMr1h6Ng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;942&quot; width=&quot;670px&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FLYOD-WARSHALL(g)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let dp be new Table&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for i from 1 to the number of vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for j from 1 to the number of vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      dp[i][j] = g[i][j]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  for k from 1 to the number of vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for i from 1 to the number of vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      for j from 1 to the number of vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        if dp[i][k] + dp[k][j] &amp;lt; dp[i][j]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;          dp[i][j] = dp[i][k] + dp[k][j]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  return dp&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:Θ(V3)，$V$表示顶点的个数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Johnson&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于稀疏图的话，还有办法降低算法复杂度。直观上看，对于稀疏图，对每个顶点运行Dijkstra算法是快过Floyd-Warshall算法的，但是这样要求图中不能有负权边。那么，可不可以将有负权边的图转化为没有负权边的图。Johnson就是这样一个算法，将所有的边进行重新赋权重(reweight)，然后再对所有顶点运行Dijkstra算法。那怎么进行重新赋权重呢？朴素想法是找出所有的边中最小的值，然后所有边增加这个值。很可惜，这样不行。考虑这样一个情况，顶点a到b的最短路径有3条边，最短路径为4。有a到b另一条路径只经过一条边，路径权重为5。如果对所有边增加1权重，那么顶点a到顶点b的最短路径就改变了。重新赋权重改变了最短路径是明显有问题的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可以看出重新赋权重有两点要求：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.对起点和终点相同的路径改变同样的权重，保持原来的最短路径结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.所有边重新赋权以后不存在负权边。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Johnson算法先对顶点重新赋值，然后将边的重新赋值由两端顶点的重新赋的值得出。假设u和v为相邻的两个顶点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.1014957264957265&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwEicibLanv6K9HOz2fIuhrCWHBMuCPyOxqf9jVj6JSbjoibGEVg1WpkJSPLvjtjmKsB7iarwOCzePhxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot; width=&quot;auto&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这样定义w’()函数以后，对路径重新赋的值影响的只有起点和终点两个顶点，中间顶点重赋的值都被消掉了。等价于保持原来的最短路径结果。那么，怎么保证第二点？Johnson算法会为图增加一个顶点s，然后对图运行一次Bellman-Ford算法。得出新增的顶点s与所有原顶点的最短路径，这个最短路径就是h()数的值。&lt;/span&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; 
&lt;p&gt;&lt;span&gt;而且在运行Bellman-Ford算法的时候，正好可以侦测出图中是否有负环。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;27&quot;&gt;
&lt;p&gt;&lt;span&gt;伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JOHNSON(g)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  let s be new Vertex&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  g.insert(s)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  if BELLMAN-FORD(g,s) == flase&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    there is a negative cycle in graph&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  else&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for v equal to every vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      h(v) = min(v~&amp;gt;s)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for (u,v) equal to every edge in graph&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      w’(u,v) = w(u,v) + h(u) - h(v)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    let result be new Table&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for u equal to every vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      DIJSKTRA(g,u)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      for v equal to every vertex in g&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        result[u][v] = min(u~&amp;gt;v) + h(v) - h(u)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  return result&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;时间复杂度:O(V⋅Elog2V+V2log2V+V⋅E)，V表示顶点的个数，E表示边的个数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;证明了这么多的算法正确性，可以看到，证明是有技巧的，常用的只有三个方法，反证法、结构归纳法、Cut-And-Paste法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;  经过图论的探讨，便可以理解算法与数学之间紧密的联系。解决问题要对问题本身的特征、属性进行总结或者提炼。有时要对问题进行相应的转化。然后根据问题的特征、性质推导出定理。再将定理拓展，提出推论。最后，算法就在灯火阑珊处了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这感觉就像，不是你找到了合适的算法。而是合适的算法找到了你。&lt;/span&gt;&lt;/p&gt;
&lt;section data-style=&quot;white-space: normal; text-align: left;font-size: 14px;line-height: 1.5em; color: rgb(12, 12, 12);&quot; readability=&quot;2&quot;&gt;&lt;p&gt;&lt;span&gt;∑编辑 | Gemini&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;来源 | &lt;span&gt;Mr.Riddler's Puzzle&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section data-style=&quot;white-space: normal; text-align: left;font-size: 14px;line-height: 1.5em; color: rgb(12, 12, 12);&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.9366666666666666&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/951TjTgiabkwJ4BpvBcQhGAbtWZZvV69s7GickZGibsKgYkTQkiaZfLYOmGS9iaaoibadibGJhT18OVZkfeJmCSUSD0zw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot; width=&quot;auto&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;p&gt;&lt;span&gt;算法数学之美微信公众号欢迎赐稿&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;稿件涉及数学、物理、算法、计算机、编程等相关领域&lt;br/&gt;稿件一经采用，我们将奉上稿酬。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;投稿邮箱：math_alg@163.com&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 18 Mar 2018 17:49:22 +0000</pubDate>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.jintiankansha.me/t/XCcHMN506E</dc:identifier>
</item>
</channel>
</rss>