<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed43.com%2Fmathalg-jtks.xml&amp;max=5&amp;links=preserve&amp;exc=1" />
<atom:link rel="alternate" title="Source URL" href="http://feed43.com/mathalg-jtks.xml" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed43.com%252Fmathalg-jtks.xml%26max%3D5%26links%3Dpreserve%26exc%3D1&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed43.com%252Fmathalg-jtks.xml%26max%3D5%26links%3Dpreserve%26exc%3D1" />
<title>算法与数学之美</title>
<link>http://www.jintiankansha.me/column/c9dZ5TM2aS</link>
<description>算法与数学之美 - 今天看啥</description>
<ttl>360</ttl>
<item>
<title>从七桥问题开始：全面介绍图论及其应用</title>
<link>http://www.jintiankansha.me/t/KDuln9hnNA</link>
<guid isPermaLink="true" >http://www.jintiankansha.me/t/KDuln9hnNA</guid>
<description>&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-color=&quot;rgb(117, 117, 118)&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-color=&quot;rgb(117, 117, 118)&quot;&gt;&lt;section&gt;&lt;section class=&quot;&quot; data-tools=&quot;135&amp;#x7F16;&amp;#x8F91;&amp;#x5668;&quot; data-id=&quot;89091&quot;&gt;&lt;section class=&quot;&quot; readability=&quot;2.5&quot;&gt;&lt;section class=&quot;&quot; https:=&quot;&quot; fill=&quot;&quot; break-word=&quot;&quot; readability=&quot;5&quot;&gt;&lt;p&gt;&lt;span&gt;图论是计算机科学中最重要、最有趣的领域之一，同时也是最容易被误解的。本长文从图论最基础的七桥问题开始，进而结合推特与 Facebook 实例解释无向图与有向图。此外，本文还是用大量的实例解释表征图、搜索树、哈希表等关键概念。最后本文描述了基于深度的搜索和基于广度的搜索等十分流行的图算法。&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;理解和使用图帮助我们成为更好的程序员。用图思考帮助我们成为最好的，至少我们应该那么思考。图是很多节点 V 和边 E 的集合，即可以表示为有序对 G=(V, E)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽管尝试研究过图论，也实现了一些算法，但是我还是非常困惑，因为它实在太无聊了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上，理解一件事物的最佳方式是理解其应用。我们将展示图论的多个应用，最重要的是，有很多插图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.5591531755915318&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOlv0SaU8QgfWL2Hlo19dzFqUiab0mqGRz4icx0kiaicfOKusHGaNHIKPHrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;803&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七桥问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们首先从《图论的起源》中的「柯尼斯堡（Königsberg）的七座桥」开始。在加里宁格勒（Kaliningrad）有七座桥，连接着由普雷戈里亚（Pregolya）河分割而成的两个岛屿和两大陆地。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 18 世纪，这里被称为柯尼斯堡，隶属普鲁士，这一区域有很多桥。当时，有一个与柯尼斯堡的桥相关的脑筋急转弯：如何只穿过桥一次而穿过整个城市。下图为柯尼斯堡七座桥的简化图。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.8480325644504749&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOibmeJaiaibicITicprkM7tI8UOYhwQJu7pvSkSq6FRbaL5bkHVY08mrmYbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可以尝试一下，在穿过每座桥仅一次的情况下穿过这个城市。每座桥，意味着所有桥都被穿过；只穿过一次，意味着每座桥不能被穿越两次及以上。如果你对这一问题有所了解，就知道这不可能。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.3035714285714286&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOkAA8BLiauSUQaLjgLxSMJLa0U5NWP0tnxcupia2iavicKzicONIa5bc0JQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;504&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Leonhard Euler &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有时候，放弃这一问题是合理的。这就是 Leonhard Euler 的解决方法，他没有试图解决这一问题，而是证明其不可解决。让我们试着去理解 Euler 的内在想法，做到像 Euler 一样思考。首先我们从下图开始。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.8518518518518519&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOSutjc4fYvcQP0vJlSiatNia4Y7Qx7vRD2VOP5j61xcpicQhUa4eeSVicicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;837&quot;/&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;图中有四块彼此分隔的区域，两个岛屿和两块陆地，以及七座桥。探讨每一区域的桥数是否有一定模式很有趣。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.8085808580858086&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOfviagSCzaOWk6oD36fULDzYjI1ibbBNCnE96veRicGfspAfdUT8UMS2DA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;606&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;每块区域的桥数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如图所示，每块区域的桥数皆为奇数。如果你只能穿过桥一次，区域有两座桥，那么你就可以进入并离开该区域。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.31624863685932386&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOOf616AibuxAwoiac16KD1R6MUqjpChLG00hXZmXLc6KpWUc0WZ2ZjWzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;917&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;有两座桥的区域的示例&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过图示很容易发现，如果你通过一座桥进入一个区域，那么你也要通过第二座桥离开它。但是当第三座桥出现，则无法只穿过桥一次而离开。所以对于一块区域，当桥数为偶时，则可以每座桥只穿过一次而离开；当桥数为奇时，则不能。请牢记。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们再添加一座新桥，如下图所示，看看其是否能解决问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.8177257525083612&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQO9C3q2wYo0rF3a8xLapRx9DuKTbPqlVE4XbUvnmU0Pot1ic8E45tutEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;598&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注意添加的新桥&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在我们有两个偶数和两个奇数。让我们在添加新桥的图上画一条新路线。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.8135313531353136&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOxwtIxWgPmIjNmKSD2VxDfqZIicAI9ysBDWhc9foLAiazQ4ClSSobKJ0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;606&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们已经看到了桥的奇偶数是重要的。这里有个问题：桥的数量解决问题了吗？难道这个数不应该一直是偶数吗？后来发现不是的。这就是 Euler 做的，他发现了一个显示桥数量很重要的办法。更有意思的事，有奇数个连接点的「陆地」也很重要。这时候 Euler 开始把陆地和桥转化成我们看得懂的图。下面是一幅表示了哥尼斯堡七桥（Königsberg bridges）的图（注意：我们「临时」加的桥不在这里）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.4658385093167702&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOCWdHtp90SCb6UV0DiajKQ9lyVVFH1sd1oeDoLK76wtnkicKialMXkibxoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;644&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;抽象化七桥问题&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题的泛化和提取是需要注意的。当你解决一个特定问题时，最重要的是为类似的问题概括答案。在这个实际问题里，Euler 的任务是泛化过桥问题从而在将来可以解决类似的问题。比如：对于世界上所有的桥。可视化也可以帮助我们从另一个角度看问题，如下面的图也全是七桥问题的抽象：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.8396694214876033&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOtaRT1tlK8SEpMoyZsH26fEEw11aaBNHUK9FX2KfEkg4Sdq3ok5LVag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;605&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，可视化图是解决该问题的好选择，因此我们需要去找出哥尼斯堡七桥问题是怎样被这张图解决的。注意从圈里面向外出来的线。因此我们命名圈为节点（或节点），连接他们的线为边。你也许看到了字母表达法，V 是节点（vertex），E 是边（edge）。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;img class=&quot;&quot; data-ratio=&quot;0.8333333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOUHGLIXBfg90XicjP7kdxIR3O8IqPLIjcHc91pVic4IFk4GTpicBCwZLIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一个重要的事是所谓节点自由度（Degree），即连接到节点的边数量。在我们上面的例子里，连接陆地和桥的边的数量可以被表达成节点的自由度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7598116169544741&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOamPic1QCiaTbU8nUzouDo0BIw4ia5F64e5MFZq3bPp0HaicswvxseA4NibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 Euler 的努力下，他证明了在图上（城市里）每次只走过一条边（桥）并且走过每一条边是严格取决于节点自由度。由这样的边组成的路径被叫做 Euler 路径（Euler path），Euler 路径的长度就是边的数量。&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;有限无向图 G(V,E) 的 Euler 路径是指 G 的每一个边都只出现一次的路径。如果 G 有一条 Euler 路径，它就被称之 Euler 图。[注释 1]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;定理：有且仅有两个确定的节点存在奇数自由度，其它的节点都有偶数自由度，那么该有限无向图为 Euler 图。【1】&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.3362676056338028&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOIkOxz4M7ogc5hFjL70hofqbnDTfs1XTKb1vKW22Rlds3Vcfcg2tBgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1136&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;左图：有两个节点有奇数自由度的图像。右图：所有节点都有奇数自由度。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，让我们分清楚上面定理和理论中的新名词。&lt;/span&gt;&lt;span&gt;有限图（Finite graph）是指有限数量的边和节点的图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图可以为有向的或无向的，这也是图非常有趣的性质。你肯定看到过将 Facebook 和 Twitter 的作为有向图和无向图的例子。Facebook 朋友关系也许可以很简单地表示为一个无向图，因为如果 Alice 是 Bob 的朋友的话，Bob 也必须是 Alice 的朋友。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.8203017832647462&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOkcVH1LL6bg25KPtYT0ZZzBZq3uBmkcIMb0q1VASZy8HjuRKIl7vz5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;729&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且也要注意「Patrick」节点，因为它没有连接一条边（edges）。虽然它还是图的一部分，但在这个案例中我们可以说该图没有连接上，这是个失联图（disconnected graph）（「John」、「Ashot」和「Beth」也是同样的，因为它们是和别的节点都是分离的）。在一个连接的图里没有到达不了的节点，这里必须在每一对节点之间有一条路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与 Facebook 的例子相反的是，如果 Alice 在 Twitter 上关注了 Bob，Bob 并不需要关注 Alice。所以「关注」关系必须是有向的连接，其表示节点（用户）有一条有向边（关注）连接到其它的节点（用户）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.8858773181169758&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOQvd4dkzictIYzZVEnNhEu6D03yzsLYkfL7iaVxibmwfRLibp3TnXmIX53A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;701&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，我们了解了什么是有限无向图，让我们再一次思考 Euler 图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7940026075619296&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOjnHiaBDW7qsvsSc92tkCVkEluicQqHTGu9JbMSEpvricaBVI2R5XLgDZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;767&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以为什么我们最开始就讨论了哥尼斯堡七桥问题和 Euler 图呢？在接触答案之前接触一下问题背后的因素（节点、边、有向、无向）也能避免枯燥的理论方法。我们现在应该更关注于用电脑表示图，因为这是我们最大的兴趣。用电脑程序表示图将使我们设计出一个算法来跟踪图路径（graph path），这样就能发现它是不是 Euler 路径了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图表征：前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是一个很沉闷的任务，要有耐心。记得数组和链表之间的战争吗？用如果你需要快速访问元素就用数组，如果你需要快速插入/删除元素就用链表等。我很难相信你会在像「怎样表示列表」这样的问题上纠结。当然，在图论中真正的表达是非常无聊的，因为首先你应该决定你将怎样确切地表达图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在我们以一个树来开始。你肯定已经至少一次见到了二叉树（下面的不是二叉搜索树）。&lt;/span&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; 
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.1519507186858315&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOGcGANWzSDZxqK2oQc4ebUiaIUbeoN1iaOVxsumwn3XDknuDgf5u0qgxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;487&quot; width=&quot;302px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为它是由节点和边构成的，所以它就是图。你也要想到一般最常见的二叉树是怎样表示的（至少在教科书上）。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;struct BinTreeNode&lt;br/&gt;{&lt;br/&gt;T value; // don&lt;span class=&quot;&quot;&gt;'t bother with template&amp;lt;&amp;gt;&lt;br/&gt;TreeNode* left;&lt;br/&gt;TreeNode* right;&lt;br/&gt;};&lt;br/&gt;class BinTree&lt;br/&gt;{&lt;br/&gt;public:&lt;br/&gt;// insert, remove, find, bla bla&lt;br/&gt;private:&lt;br/&gt;BinTreeNode* root_;&lt;br/&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;这个对于已经非常熟悉树的人来说太详细了，但是我必须确保我们在同一阶段。（注意我们还是在用伪代码）。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;6&quot;&gt;BinTreeNode* root = new BinTreeNode(&lt;span class=&quot;&quot;&gt;&quot;Green&quot;&lt;/span&gt;);&lt;p&gt;root-&amp;gt;left = new BinTreeNode(&lt;span class=&quot;&quot;&gt;&quot;Yellow&quot;&lt;/span&gt;);&lt;br/&gt;root-&amp;gt;right = new BinTreeNode(&lt;span class=&quot;&quot;&gt;&quot;Yellow 2&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;BinTreeNode* yellow_2 = root-&amp;gt;right;&lt;/p&gt;&lt;p&gt;yellow_2-&amp;gt;left = new BinTreeNode(&lt;span class=&quot;&quot;&gt;&quot;Almost red&quot;&lt;/span&gt;);&lt;br/&gt;yellow_2-&amp;gt;right = new BinTreeNode(&lt;span class=&quot;&quot;&gt;&quot;Red&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;如果你不是新手，仔细的读上面的伪代码然后阅读以下图解：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;img class=&quot;&quot; data-ratio=&quot;0.5650969529085873&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQO5iag6n9NTBbe4MXR09wOf5ZkEna1DJ8k1zc7p4Zbvhjqicb0SuibCibiaicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1083&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个二叉树是简单的节点「集合」，每一个父节点有左子节点和右子节点的节点。二叉树在应用简单规则的时候是非常有意义的，例如允许快速的关键字查找。二叉搜索树（BST）按序储存他们的关键字。我们可以根据任何规则实现二叉树（即使它会根据不同的规则而有不同的名字，比如，min—heap 或者 max——heap），最常见的 BST 规则是它符合二项搜索性质（也是名字的由来），即「任意节点的键值必须比它左边子树的键值要大，比右边子树上的键值要小。「更大」是 BST 重要的本质，当你把它改成「比更大或一样」时，你的 BST 可以在插入新节点时解决复制键值得问题，除此之外它将只保留唯一键值的节点。你可以在网上找到很好的二项树的文章，我们不会提供一个二元搜索树的全面实现，但我们将展示一个简单的二元搜索树。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.9159663865546218&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOiclOYX9eXOveQthiak7UJt28KMBlatVO02ESX8mpVQkstPBcDMziatia1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;595&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Airbnb&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;树是非常有用的数据结构，你也许还没有实现过树型结构，但你也许无意间用过它们。像你注意到的，二叉搜索树（Binary Search Tree）中有「搜索」，简单来说，所有需要快速查找的事，应该被放到二叉搜索树中。「应该」不意味着一定，在编程中最重要的事情是用合适的工具去解决问题。这里有很多案例可以看到简单链表（O(N) 复杂度）搜索相比 BST（O(logN) 复杂度）搜索更受欢迎。一般来说我们可以用一个库来实现一个 BST，但是在这个教程中我们可以重新发明我们自己的轮子（BST 是基本在所有多用途编程语言库都有实现）。接近了「一个真实世界例子」，这里是我们试着去处理的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Airbnb 房源搜索一瞥：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7807276302851525&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOzpW5gQ9CYTxOnR7Yqy1uWXKcwicd07JnSjIiaplnOkC69bWZUngk2W3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1017&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;怎样用滤波器基于词条尽可能快的搜索房源，这是一项很难的任务。如果我们考虑到 Airbnb 储存了几百万条表格的情况下，这个任务更难了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.691437802907916&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOj0aKiaAKQbmF3NAZ8c9T9KPpdI1uIUS9gL8GWwH3M2pBNFv46OS8Fjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;619&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以当用户搜索房源时，他们也许就会「接触」到四百万条数据库中的记录。的确，在网站主页上能够展现的「top listings」有限，而用户对浏览百万条列表也并不感兴趣。我没有任何 Airbnb 的分析记录, 但我们可以用编程语言中叫做「假设」的强大工具，所以我们假设单个用户查看最多 1 千个房源就会发现中意的房源。并且最重要的因子是即时用户的数量，因为它会影响数据结构、数据库和项目构架的选择。就像这看起来的那么明显，如果这里总共有 100 个用户，我们就不用去操心。相反，如果即时用户数量超过了百万级，我们必须去思考每一个决定到底对不对。每个决策都被正确的使用，这是为什么巨头们雇佣最好的人才，为提供卓越的服务而努力的原因（Google、Facebook、Airbnb、Netflix、Amazon、Twitter 和许多其他公司都在处理大量的数据；招聘正确的工程师来做正确的选择，为数百万实时用户每秒处理百万级字节的数据。这就是为什么我们码农纠结于可能遇见的数据结构，算法和问题处理，因为需要的是工程师有能力快速、有效地解决这样大的问题）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以在 Airbnb 的案例里，用户浏览了他们的房源主页，Airbnb 试着去过滤房源来找出最适合的。我们怎样处理这个问题呢？（注意这个问题是后端的，所以我们不需要管前端或者网络流量或者 https over http 或者 Amazon EC2 over home cluster 等。首先，因为我们已经熟悉了程序员仓库中最强大的工具（在说假设而不是抽象），我们假设处理的是完全适配 RAM 的数据。然后你也可以假设我们的 RAM 是足够大的。足够大去支持，但这是多大呢？这是另一个非常好的问题。需要多大的内存来存储真正的数据呢？如果我们处理的是四百万单元的数据（还是假设），如果我们大概知道每一个单元的大小，之后我们可以简单地驱动需要的内存，就是 4M*sizeof(one_unit)。考虑下「房源」及其性质（properties），事实上，至少考虑一下处理这一问题必要的性质（一个「房源」是我们的单元）。我们需要用 C++结构伪代码来表示一些问题，你可以简单地将他们转化为一个 MongoDB 略图目标或者任何你想要的形式, 我们只讨论性质的名字和类别。（试着去想象这是在空间经济里用字位段或者位集合）&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;// feel free to reorganize this struct to avoid redundant space&lt;br/&gt;// usage because of aligning factor&lt;br/&gt;// Remark &lt;span class=&quot;&quot;&gt;1&lt;/span&gt;: some of the properties could be expressed &lt;span class=&quot;&quot;&gt;as&lt;/span&gt; enums,&lt;br/&gt;// bitset &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; chosen &lt;span class=&quot;&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;&quot;&gt;as&lt;/span&gt; multi-value enum holder.&lt;br/&gt;// Remark &lt;span class=&quot;&quot;&gt;2&lt;/span&gt;&lt;/code&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;

    
: &lt;span class=&quot;&quot;&gt;for&lt;/span&gt; most of the count values the maximum &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;&quot;&gt;16&lt;/span&gt;&lt;br/&gt;// Remark &lt;span class=&quot;&quot;&gt;3&lt;/span&gt;: price value considered &lt;span class=&quot;&quot;&gt;as&lt;/span&gt; integer,&lt;br/&gt;// int considered &lt;span class=&quot;&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;&quot;&gt;4&lt;/span&gt; byte.&lt;br/&gt;// Remark &lt;span class=&quot;&quot;&gt;4&lt;/span&gt;: neighborhoods property omitted &lt;br/&gt;// Remark &lt;span class=&quot;&quot;&gt;5&lt;/span&gt;: to avoid spatial queries, we&lt;span class=&quot;&quot;&gt;'re &lt;br/&gt;// using only country code and city name, at this point won'&lt;/span&gt;t consider &lt;br/&gt;// the actual coordinates (latitude &lt;span class=&quot;&quot;&gt;and&lt;/span&gt; longitude)&lt;br/&gt;struct AirbnbHome&lt;br/&gt;{&lt;br/&gt;wstring name; // wide string&lt;br/&gt;uint price;&lt;br/&gt;uchar rating;&lt;br/&gt;uint rating_count;&lt;br/&gt;vector photos; // list of photo URLs&lt;br/&gt;string host_id;&lt;br/&gt;uchar adults_number;&lt;br/&gt;uchar children_number; // max &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;&quot;&gt;5&lt;/span&gt;&lt;br/&gt;uchar infants_number; // max &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;&quot;&gt;5&lt;/span&gt;&lt;br/&gt;bitset&amp;lt;&amp;lt;span class=&quot;&quot; style=&quot;max-width: 100%;box-sizing: border-box;font-size: inherit;color: rgb(174, 135, 250);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;&quot;&amp;gt;3&amp;gt; home_type;&lt;br/&gt;uchar beds_number;&lt;br/&gt;uchar bedrooms_number;&lt;br/&gt;uchar bathrooms_number;&lt;br/&gt;bitset&amp;lt;&amp;lt;span class=&quot;&quot; style=&quot;max-width: 100%;box-sizing: border-box;font-size: inherit;color: rgb(174, 135, 250);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;&quot;&amp;gt;21&amp;gt; accessibility;&lt;br/&gt;bool superhost;&lt;br/&gt;bitset&amp;lt;&amp;lt;span class=&quot;&quot; style=&quot;max-width: 100%;box-sizing: border-box;font-size: inherit;color: rgb(174, 135, 250);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;&quot;&amp;gt;20&amp;gt; amenities;&lt;br/&gt;bitset&amp;lt;&amp;lt;span class=&quot;&quot; style=&quot;max-width: 100%;box-sizing: border-box;font-size: inherit;color: rgb(174, 135, 250);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;&quot;&amp;gt;6&amp;gt; facilities;&lt;br/&gt;bitset&amp;lt;&amp;lt;span class=&quot;&quot; style=&quot;max-width: 100%;box-sizing: border-box;font-size: inherit;color: rgb(174, 135, 250);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;&quot;&amp;gt;34&amp;gt; property_types;&lt;br/&gt;bitset&amp;lt;&amp;lt;span class=&quot;&quot; style=&quot;max-width: 100%;box-sizing: border-box;font-size: inherit;color: rgb(174, 135, 250);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;&quot;&amp;gt;32&amp;gt; host_languages;&lt;br/&gt;bitset&amp;lt;&amp;lt;span class=&quot;&quot; style=&quot;max-width: 100%;box-sizing: border-box;font-size: inherit;color: rgb(174, 135, 250);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;&quot;&amp;gt;3

&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;

    
 house_rules;&lt;br/&gt;ushort country_code;&lt;br/&gt;string city;&lt;br/&gt;};&lt;br/&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;假设。上面的结构不是完美的（很显然），而且这里有很多假设或者不完整的地方，去再读一下免责声明。我只是看了下 Airbnb 的过滤器和应该存在的符合搜索查询的设计性产权表。这只是个例子。现在我们应该能计算每一个 AirbnbHome 对象会在内存中占用多少空间。name 是一个 wstring 来支持多语言的名字/头衔的，这个意味着每一个字符占了 2 字节（我们不想担心字符大小如果我们需要用其他的语言，但在 C++中，char 是 1 字节然后 wchar 是 2 字节）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;快速的看一下 Airbnb 的表可以让我们估计房源的名字可以占到最多 100 个字符（虽然最多的是 50 个左右，而不是 100 个），我们会认为 100 个字符是最多的量，这占了差不多 200 字节的内存。uint 是 4 字节，uchar 是 1 字节,ushort 是 2 字节（还是假设）。假设图片是在储存服务旁边，像 Amazon S3（目前据我所知，这个假设对于 Airbnb 来说是最可能实现的，当然这也是假设）而且我们有这些照片的 URL，而且考虑这里没有 URL 的标准尺寸的限制，但这事实上有一个众所周知的上线-2083 字符，我们将要用这个当成任何 URL 的最大尺寸。所以考虑到这个，平均每个房源有 5 张照片，这可以占到 10Kb 内存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们重新想一下，一般储存用同样的基础 URL 服务，像 http(s)://s3.amazonaws.com//&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样的「手段」可以用 host_id 来做，就是说，房主的用户 ID，占了 20 字节的内存（实际上我们可以就让用户用数字 ID，但考虑到一些 DB 系统像 MongoDB 有非常详细的 ID 生成器，我们假设 20 字节的字符 ID 是「中位」长度，已经可以用很小的改动就能适用于大部分 DB 系统了。Mongo 的 ID 长度是 24 字节）。最后，我们将用一个最多 4 字节 32 位大小对象的位集合和一个比 32 位大的 64 位小的位集合一起作为一个 8 字节的独享。注意这是个假设。我们在这个例子里为了所有的表达了枚举的性质用了位集合，但位集合可以取不止一个值，换种说法这是一种多种选择的多选框。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.48148148148148145&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOAEd4YY70R2NLy4NxFdyllYORYeCfmVs6hC1tGyuu5BserRO7vNhBBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举例，每一个 Airbnb 房源都有一些便利工具列表，比如：「熨斗」、「洗衣机」、「电视」、「wifi」、「挂衣架」、「烟雾探测器」甚至「适用于笔记本电脑的书桌」等。这里也许有超过 20 种便利工具，我们用 20 这个数字是因为 Airbnb 网站上可以用 20 个选项过滤。如果一个房源有所有的上述便利措施（在截图中看），我们在对应的位集合的位置上标注 1 就好。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.5214180206794683&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQO6Jp9icV59VGgO1B3c3ySoZzvhE0Rttia9MqNA1yo7ibyjNKqpvVWpXfaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;677&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;位集合（Bitset）允许储存 20 个不同数据而只用 20 个字节。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举例，检查一个房源有没有「洗衣机」：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;bool HasWasher(AirbnbHome* h)&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; h-&amp;gt;amenities[&lt;span class=&quot;&quot;&gt;2&lt;/span&gt;];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;或者更专业一点：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;7&quot;&gt;const int KITCHEN = &lt;span class=&quot;&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;

    
const int HEATING = &lt;span class=&quot;&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;const int WASHER = &lt;span class=&quot;&quot;&gt;2&lt;/span&gt;;&lt;br/&gt;//...&lt;br/&gt;bool HasWasher(AirbnbHome* h)&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; (h != nullptr) &amp;amp;&amp;amp; h-&amp;gt;amenities[WASHER];&lt;br/&gt;}&lt;p&gt;bool HasWasherAndKitchen(AirbnbHome* h)&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; (h != nullptr) &amp;amp;&amp;amp; h-&amp;gt;amenities[WASHER] &amp;amp;&amp;amp; h-&amp;gt;amenities[KITCHEN];&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;bool HasAllAmenities(AirbnbHome* h, const std::vector&amp;amp; amenities)&lt;br/&gt;{&lt;br/&gt;bool has = (h != nullptr);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;for&lt;/span&gt; (const auto a : amenities) {&lt;br/&gt;has &amp;amp;= h-&amp;gt;amenities[a];&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; has;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;你可以修正代码或修复编译错误，我们只想强调该问题背后用向量表征特征的观念。同样的观念可以用在「入住守则」、「房间类型」和其它特征上。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最后，对于国家编码和城市名。像上面代码注释中提到的一样（看标注），我们不会储存经纬度来避免地理-空间问题，我们储存国家代码和城市名字来缩小用地名搜索的范围（为了简介省略街名，原谅我）。国家代码可以被用两个字符，3 个字符或者 3 个数字来表示，我们会用 ushort 储存数字表达。不幸的是，城市比国家多了太多，所以我们不能使用「城市编码」，我们只会储存真实的城市名，保留平均 0 为 50 字节的城市名字和特别的名字。我们最好用一个附加的布尔变量来表示这是不是一个特别长的名字，所以我们将会加上附加的 32 字节来保证最终的结构大小。我们也假设在 64 位系统上工作，即使我们为 int 何 short 选择了非常紧凑的值。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;// Note the comments&lt;br/&gt;struct AirbnbHome&lt;br/&gt;{&lt;br/&gt;wstring name; // &lt;span class=&quot;&quot;&gt;200&lt;/span&gt; bytes&lt;br/&gt;uint price; // &lt;span class=&quot;&quot;&gt;4&lt;/span&gt; bytes&lt;br/&gt;uchar rating; // &lt;span class=&quot;&quot;&gt;1&lt;/span&gt; byte&lt;br/&gt;uint rating_count; // &lt;span class=&quot;&quot;&gt;4&lt;/span&gt; bytes&lt;br/&gt;vector photos; // &lt;span class=&quot;&quot;&gt;100&lt;/span&gt; bytes&lt;br/&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;

    
  string host_id; // &lt;span class=&quot;&quot;&gt;20&lt;/span&gt; bytes&lt;br/&gt;uchar adults_number; // &lt;span class=&quot;&quot;&gt;1&lt;/span&gt; byte&lt;br/&gt;uchar children_number; // &lt;span class=&quot;&quot;&gt;1&lt;/span&gt; byte&lt;br/&gt;uchar infants_number; // &lt;span class=&quot;&quot;&gt;1&lt;/span&gt; byte&lt;br/&gt;bitset&amp;lt;&amp;lt;span class=&quot;&quot; style=&quot;max-width: 100%;box-sizing: border-box;font-size: inherit;color: rgb(174, 135, 250);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;&quot;&amp;gt;3&lt;/code&gt;&amp;gt; home_type; // &lt;span class=&quot;&quot;&gt;4&lt;/span&gt; bytes&lt;br/&gt;uchar beds_number; // &lt;span class=&quot;&quot;&gt;1&lt;/span&gt; byte&lt;br/&gt;uchar bedrooms_number; // &lt;span class=&quot;&quot;&gt;1&lt;/span&gt; byte&lt;br/&gt;uchar bathrooms_number; // &lt;span class=&quot;&quot;&gt;1&lt;/span&gt; byte&lt;br/&gt;bitset&amp;lt;&amp;lt;span class=&quot;&quot; style=&quot;max-width: 100%;box-sizing: border-box;font-size: inherit;color: rgb(174, 135, 250);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;&quot;&amp;gt;21&amp;gt; accessibility; // &lt;span class=&quot;&quot;&gt;4&lt;/span&gt; bytes&lt;br/&gt;bool superhost; // &lt;span class=&quot;&quot;&gt;1&lt;/span&gt; byte&lt;br/&gt;bitset&amp;lt;&amp;lt;span class=&quot;&quot; style=&quot;max-width: 100%;box-sizing: border-box;font-size: inherit;color: rgb(174, 135, 250);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;&quot;&amp;gt;20&amp;gt; amenities; // &lt;span class=&quot;&quot;&gt;4&lt;/span&gt; bytes&lt;br/&gt;bitset&amp;lt;&amp;lt;span class=&quot;&quot; style=&quot;max-width: 100%;box-sizing: border-box;font-size: inherit;color: rgb(174, 135, 250);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;&quot;&amp;gt;6&amp;gt; facilities; // &lt;span class=&quot;&quot;&gt;4&lt;/span&gt; bytes&lt;br/&gt;bitset&amp;lt;&amp;lt;span class=&quot;&quot; style=&quot;max-width: 100%;box-sizing: border-box;font-size: inherit;color: rgb(174, 135, 250);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;&quot;&amp;gt;34&amp;gt; property_types; // &lt;span class=&quot;&quot;&gt;8&lt;/span&gt; bytes&lt;br/&gt;bitset&amp;lt;&amp;lt;span class=&quot;&quot; style=&quot;max-width: 100%;box-sizing: border-box;font-size: inherit;color: rgb(174, 135, 250);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;&quot;&amp;gt;32&amp;gt; host_languages; // &lt;span class=&quot;&quot;&gt;4&lt;/span&gt; bytes, correct me &lt;span class=&quot;&quot;&gt;if&lt;/span&gt; I&lt;span class=&quot;&quot;&gt;'m wrong&lt;br/&gt;bitset&amp;lt;3&amp;gt; house_rules; // 4 bytes&lt;br/&gt;ushort country_code; // 2 bytes&lt;br/&gt;string city; // 50 bytes&lt;br/&gt;};&lt;br/&gt;&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;所以，420 字节加上 32 个多出的字节，若我们四舍五入到 500 字节。所以每一个对象「home」最多占 500 字节，并且对于所有房源列表，500 字节*4 百万=1.86Gb ~2Gb。我们在搭建结构时做了很多假设，让储存在内存中更便宜。无论我们对这数据做什么，我们需要至少 2Gb 内存。如果你无聊，忍着，我们刚开始。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在是任务最难的地方了，为这个问题选择合适的数据结构（来尽可能有效的过滤表）不是最难的任务。最难的是（对我而言）按照一系列滤波器搜索列表。如果只有一个搜索键（key）（即只有一个滤波器），我们可以很轻易地解决这个问题。假设用户只关心价格，我们需要的只是在给定的范围以价格下降的顺序找到 Airbnbhome 对象（合适的家）。如果我们要用二元搜索树来解决这个问题，则可按下图形式执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7823691460055097&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOSBhgZ7IcicjbUQ0S0ibBFToG99JfOXeLLeB8hmIeOD8QPibFAd2R7r5hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;如果需要遍历所有的 4 百万个对象，这搜索树会长得很大很大。另外，需要占用的内存也会越来越多。这只是因为我们用了二元搜索数来存储对象，每一个树节点给它的左右子树两个额外的指针，加起来是每个子指针有 8 个额外的比特（假设是 64 位系统）。对于 400 百万节点它加起来就是 62Mb，对于 2Gb 对象的数据来说是很小的，但还是不能轻易地「忽略」。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前为止，上面展示的树表明了任何物品都可以很轻易地在 O（logN）复杂度内被找到。如果你对这些概念不熟悉，我们会在接下来解释清楚，或者跳过复杂度讨论的副章节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;算法复杂度：我们在这里快速地简要介绍，在之后的文章「Algorithmic Complexity and Software Performance: the missing manual」我会进行详细的解释。在大部分情况里，找到一个算法的「大 O」复杂度是简单的。首先要注意到，我们总是考虑最差的情况，即：一个算法要最多算多少次才能产生一个合适的结果（用来解决问题）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设一个有 100 个元素的未排序数列，要做多少次的比较才能让它找到任意的元素，这里也要考虑到需要的元素可能缺失的情况？它最多需要与匹配的数字比较 100 次才能发现，尽管有时候第一个在数列中的元素就是要找的数字（意味着单次比较就找到答案了），但我们只考虑最差的可能情况（元素可能丢失了或者在最后的位置）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7841328413284133&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOyIO5a9uDOHXAmia78ngjpAaExvCn5myQWG7PvUFzsSO3nvdV0VVCPEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;542&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算算法复杂度的重点是找到运算次数与输入规模之间的依赖关系，举例来说，上面的数列有 100 个元素，运算的次数也是 100，如果数列的数量（输入）增长到 1423，运算次数也会增长到 1423（最差的情况）。所以，输入和运算次数之间的关系在这里是非常清晰的，它也被叫做线性关系，运算次数和数列的增长一样快。增长是复杂度的关键，我们说在一个未排序的数列中搜索需要 O（N）次运算，来强调寻找它需要最多用 N 次运算，（甚至最多到 N 的常数倍数运算，比如 3N 次）。另一方面，访问数列上的任意元素只需要常数时间，比如 O（1）。这是因为数列的结构是一个连续结构，并且包含相同类型的元素，所以访问特定的元素只需要计算它与数列第一个元素的相对位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7759103641456583&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQO9NG9S04TJbkLMuFnwiaPTsOSNOmeMYhmTWrYVAmoD1Wp9AFQiaJibC4Kg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;714&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有一点非常明确，二元搜索树按排序顺序保存其节点。那么在二元搜索树中搜索元素的算法复杂度是多少呢？我们应该在最坏的情况下计算查找元素所需的操作次数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;见上图，当我们开始在根部搜索时，第一次匹配可能会导致三种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）目标节点被发现；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）如果要找的值小于节点的值，则匹配将继续到节点的左子树；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）如果要找的值大于节点的值，则匹配将继续到节点的右子树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在每一步中我们都把节点的数量减半。在二元搜索树中查找元素所需的操作数等于树的高度。树的高度是最长路径上节点的数量。在这一案例中，高度是 4。所以高度等于 logN+1（底数为 2），搜索复杂度是 O（logN+1）=O（logN）。这意味着在 4 百万个节点里搜索元素需要 log1000000=~22 次比较（最差的情况）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回到树搜索的问题，二元搜索树中的元素搜索时间为 O（logN）。为什么不使用哈希表？哈希表有常数的访问时间，这使得在几乎任何地方使用哈希表都是合理的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在该问题中，我们必须考虑一个重要的需求，即执行范围搜索，如搜索价格区间在$80 到 $162 之间的房源。在二元搜索树的情况下，获取区间中所有节点很简单，只需对树执行顺序遍历，保存计数即可。而哈希表的计算稍微昂贵，在这种情况下使用坚持二元搜索树更好一些。尽管还存在另一个因素，使我们需要重新考虑哈希表：密度。价格不会「一直」上涨，大部分房源处于固定的价格区间内。截图中的柱状图显示了价格的真实分布，数百万房源处于同一区间（$18—$212），它们具备同样的平均价格。简单的数组可能起到很好的效果。假设数组的索引是价格，则我们能够在（几乎）常数时间内获取任意价格区间。如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.075642965204236&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOo3hgvPpSPqgCtgtkV6HOLaRnQicMzc6B1ygYFoV9PlnzSRZc8xS3y0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就像一个哈希表，我们通过房源的价格来匹配每一套房子。所有具有相同价格的房源都归入单独的二元搜索树。如果我们存储房源的 ID 而不是上面定义的完整对象（AirbnbHome 结构），也可以节省一些空间。最可能的情况是将所有房源的完整对象保存在哈希表，并将房源 ID 映射到房源的完整对象中，以及保存另一个哈希表（或更好的，一个数组），该哈希表将价格与房源 ID 进行映射。因此，当用户请求价格范围时，我们从价格表中获取房源 ID，将结果裁剪成固定大小（即分页，通常在一页上显示 10-30 个项目），然后使用每个房源 ID 获取完整的房源对象。请记得，要注意平衡。平衡对二元搜索树至关重要，因为它是在 O（logN）内完成树操作的唯一保证。当你按排序顺序插入元素时，二元搜索树不平衡的问题就会很明显，最终，树将变成连接列表，这显然会导致线性时间复杂度。现在假设我们所有的搜索树都是完美平衡的。再看看上面的图。每个数组元素代表一棵大树。如果我们改变这个树，变成图呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.9217391304347826&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOGNH4KGP3cHRicnejkK51p6lAR2a2xzlCSHshwPb9tBUJzzATHeYtd3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;575&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是一个「更接近真实」的图。这个图展示了最隐蔽的数据结构和图，带领我们到了（下文）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图表征：进阶&lt;/strong&gt;&lt;/p&gt;

&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;图论的缺点是缺乏单独定义，这就是为什么你无法在库中找到 std::graph。我们已经尝试过表示「特别的」图 BST。重点在于，树是图，但图未必是树。最后一张示例图表明在一个抽象图下面有很多树，「价格 vs 房源」和一些节点的类型不同，价格只有价格值的图节点，表示满足特定价格的房源 ID（房源节点）的树。这很像混合数据结构，不同于我们在教科书示例中见到的简单图形。图表示的重点：不存在固定、「权威」的图表示结构（这与 BST 不同，后者用左／右子指针代表基于节点的特定表示，尽管你可以用一个数组表示 BST）。你可以用最便捷的方式表示一个图，重点在于你把它「看作」是图。「看图」的意思是使用适用于图的算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;N-ary 树更像是模拟一个图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7905027932960894&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOpCZ2Nh4PxOeO2RL5ys9DjraMOLBjhpiaGAX0EIEYSkUNKTdCZZG0Hqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;716&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，将 N-ary 树节点表示为：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;struct NTreeNode&lt;br/&gt;{&lt;br/&gt;T value;&lt;br/&gt;vector children;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;该结构仅表示树的一个节点，完整的树如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;// almost pseudocode&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;&quot;&gt;NTree&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;void Insert(const T&amp;amp;);&lt;br/&gt;void Remove(const T&amp;amp;);&lt;br/&gt;// lines of omitted code&lt;br/&gt;private:&lt;br/&gt;NTreeNode* root_;&lt;br/&gt;};&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;该类别是围绕单个树节点 root_ 的抽象。我们可以用它构建任意大小的树。这是树的起点。如果要添加新的树节点，我们就要为其分配内存，将该节点添加至树的根节点处。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图与 N-ary 树很像，只有细微的不同。我们来看一下。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7856135401974612&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOSzNQWtYrkbH9LETZicibNftscTPL1IHVAibTAywE8GwABRrPNwVLuMWJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;709&quot;/&gt;&lt;span&gt;这是图吗？我认为，是的。但这幅图与前面的 N-ary 相同，只不过稍微旋转了一下。只要你看到一棵树，无论它是苹果树、柠檬树，还是二叉搜索树，你都可以确定它也是一张图。因此，通过设计图节点（图节点）结构，我们能够提出同样的结构：&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;struct GraphNode&lt;br/&gt;{&lt;br/&gt;T value;&lt;br/&gt;vector adjacent_nodes;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;这样可以创建图吗？还不够。看下面两幅图，找不同：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.4082901554404145&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOJBf2wjib06Ax6gmPxyia4ckumCOiaBQwaaVICyaYCZMykIuc4vd2H04UQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;965&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;二者都是图&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;左侧的图没有可以「进入」的点（与其说是树，它更像森林），相反，右侧的图没有不可达的节点，听起来很熟悉。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;如果图中任意两点都是连通的，那么该图被称作连通图。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;虽然图中不明显，但是我们假设价格不能互相连接，那么在「价格 vs 房源」图中并不是每对节点之间都有路径相连，这说明我们无法使用单个 GraphNode 结构构建图的例子，但是在很多案例中我们必须这样处理非连通图。看下面这个类别：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;&quot;&gt;ConnectedGraph&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;// API&lt;p&gt;private:&lt;br/&gt;GraphNode* root_;&lt;br/&gt;};&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;类似围绕单个节点（根节点）构建的 N-ary 树，连通图也可以围绕根节点构建。树有「根」，即它们有起始点。连通图可以用带有根节点的树来表示（当然还有其他属性），不过要注意，实际的表示可能会随着算法或具体问题发生变化。但是，考虑基于节点的图本质，非连通图可以按照下面的方式来表示：&lt;/span&gt;&lt;/p&gt;

&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;&quot;&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;
&lt;span class=&quot;&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;&quot;&gt;DisconnectedGraphOrJustAGraph&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;// API&lt;p&gt;private:&lt;br/&gt;std::vector all_roots_;&lt;br/&gt;};&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;树状图可以清晰自然地表示 DFS/BFS 这样的图遍历。但是，高效路径追踪等需要不同的表示方法。还记得欧拉图吗？为了追踪图的「eulerness」（真实性），我们应该追踪图中的欧拉路径。这意味着遍历每个边一次就要访问所有节点；如果追踪结束后我们仍有未遍历的边，则该图没有欧拉路径，因此它不是欧拉图。更快的方法是：检查节点的度（假设每条边都保存了度），如定义所述，如果图的节点度是奇数，则它不是欧拉图。该检查的复杂度是 O(|V|)，其中 |V| 是图节点的数量。我们可以在插入新的边缘的同时追踪节点的奇数／偶数度，同时插入新的边以增加奇数／偶数度检查的复杂度到 O(1)。下面介绍图表示和返回路径的 Trace() 函数。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;32&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;8&quot;&gt;// A representation of a graph &lt;span class=&quot;&quot;&gt;with&lt;/span&gt; both vertex &lt;span class=&quot;&quot;&gt;and&lt;/span&gt; edge tables&lt;br/&gt;// Vertex table &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; a hashtable of edges (mapped by label)&lt;br/&gt;// Edge table &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; a structure &lt;span class=&quot;&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;&quot;&gt;4&lt;/span&gt; fields&lt;br/&gt;// VELO = Vertex Edge Label Only (e.g. no vertex payloads)&lt;p&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;&quot;&gt;ConnectedVELOGraph&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;struct Edge {&lt;br/&gt;Edge(const std::string&amp;amp; f, const std::string&amp;amp; t)&lt;br/&gt;: &lt;span class=&quot;&quot;&gt;from&lt;/span&gt;(f)&lt;br/&gt;, to(t)&lt;br/&gt;, used(false)&lt;br/&gt;, next(nullptr)&lt;br/&gt;{}&lt;br/&gt;std::string ToString() {&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;&quot;&gt;from&lt;/span&gt; + &lt;span class=&quot;&quot;&gt;&quot; - &quot;&lt;/span&gt; + to + &lt;span class=&quot;&quot;&gt;&quot; [used:&quot;&lt;/span&gt; + (used ? &lt;span class=&quot;&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;

    
 : &lt;span class=&quot;&quot;&gt;&quot;false&quot;&lt;/span&gt;) + &lt;span class=&quot;&quot;&gt;&quot;]&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;p&gt;std::string &lt;span class=&quot;&quot;&gt;from&lt;/span&gt;;&lt;br/&gt;std::string to;&lt;br/&gt;bool used;&lt;br/&gt;Edge* next;&lt;br/&gt;};&lt;/p&gt;&lt;p&gt;ConnectedVELOGraph() {}&lt;br/&gt;~ConnectedVELOGraph() {&lt;br/&gt;vertices_.clear();&lt;br/&gt;&lt;span class=&quot;&quot;&gt;for&lt;/span&gt; (std::size_t ix = &lt;span class=&quot;&quot;&gt;0&lt;/span&gt;; ix &amp;lt; edges_.size(); ++ix) {&lt;br/&gt;delete edges_[ix];&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public:&lt;br/&gt;void InsertEdge(const std::string&amp;amp; &lt;span class=&quot;&quot;&gt;from&lt;/span&gt;, const std::string&amp;amp; to) {&lt;br/&gt;Edge* e = new Edge(&lt;span class=&quot;&quot;&gt;from&lt;/span&gt;, to);&lt;br/&gt;InsertVertexEdge_(&lt;span class=&quot;&quot;&gt;from&lt;/span&gt;, e);&lt;br/&gt;InsertVertexEdge_(to, e);&lt;br/&gt;edges_.push_back(e);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public:&lt;br/&gt;void Print() {&lt;br/&gt;&lt;span class=&quot;&quot;&gt;for&lt;/span&gt; (auto elem : edges_) {&lt;br/&gt;std::cout &amp;lt;&amp;lt; elem-&amp;gt;ToString() &amp;lt;&amp;lt; std::endl;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;std::vector&amp;lt;:string&amp;gt; Trace(const std::string&amp;amp; v) {&lt;br/&gt;std::vector&amp;lt;:string&amp;gt; path;&lt;br/&gt;Edge* e = vertices_[v];&lt;br/&gt;&lt;span class=&quot;&quot;&gt;while&lt;/span&gt; (e != nullptr) {&lt;br/&gt;&lt;span class=&quot;&quot;&gt;if&lt;/span&gt; (e-&amp;gt;used) {&lt;br/&gt;e = e-&amp;gt;next;&lt;br/&gt;} &lt;span class=&quot;&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;e-&amp;gt;used = true;&lt;br/&gt;path.push_back(e-

&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;
&lt;span class=&quot;&quot;&gt;from&lt;/span&gt; + &lt;span class=&quot;&quot;&gt;&quot;:-:&quot;&lt;/span&gt; + e-&amp;gt;to);&lt;br/&gt;e = vertices_[e-&amp;gt;to];&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; path;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;private:&lt;br/&gt;void InsertVertexEdge_(const std::string&amp;amp; label, Edge* e) {&lt;br/&gt;&lt;span class=&quot;&quot;&gt;if&lt;/span&gt; (vertices_.count(label) == &lt;span class=&quot;&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;vertices_[label] = e;&lt;br/&gt;} &lt;span class=&quot;&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;vertices_[label]-&amp;gt;next = e;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;private:&lt;br/&gt;std::unordered_map&amp;lt;:string edge&amp;gt; vertices_;&lt;br/&gt;std::vector edges_;&lt;br/&gt;};&lt;br/&gt;&amp;lt;/:string&amp;gt;&amp;lt;/:string&amp;gt;&amp;lt;/:string&amp;gt;
&lt;/p&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;注意 bug，bug 到处都是。该代码包含大量假设，比如标签，我们可以通过节点理解字符串标签，确保你可以将其更新成任意事物。接下来，是命名。如注释中所述，VELOGraph 仅适用于 Vertex Edge Label Only Graph。重点在于，该图表示包括一个将节点标签映射至节点关联边的表、一个包含与边相连的两个节点的边列表，和一个仅用于 Trace() 函数的 flag。查看 Trace() 函数实现，它使用边的 flag 来标记已经遍历过的边（在任意 Trace() 调用之后应该重置 flag）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;示例：Twitter&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一种表示叫做相邻矩阵，它在有向图中有用，就像我们在 Twitter 关注图中所使用的那样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.8299845440494591&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOXhM81ANzhP02jGUs9hkn0jBT1ic4mlYXCgia8BiaMYojrwKTFfoJ6MByA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;647&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;有向图&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;推特案例中有 8 个节点，所以我们需要使用|V|x|V|的二维矩阵表征这个图（其中 |V|分别代表行数和列数）。如果从 v 到 u 有一条有向边，那么我们称矩阵的元素 [v][u] 为真，否则为假。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.777602523659306&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOiciatDHglBdVpM8oud5MGqkhcxia2csDicIpNZ8GktU4r33dEYpHaNl68w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如你所见，这是一个十分稀疏的矩阵，其中的值代表是否有单向连接路径。如果我们需要了解 Patrick 是否关注了 Bob 的推特，那么我们只需要查看矩阵中 [&quot;Patrick&quot;][&quot;Sponge Bob&quot;] 的值是不是等于 1。而要查看 Ann 推特的关注者，我需要获得「Ann」的整个列；同样查看 Sponge Bob 正在关注的人只需要查看「Sponge Bob」的行就行。此外，邻接矩阵（Adjacency matrix）可以用来描述无向图，它不会在 v 到 u 的边选择值「0 或 1」来表示是否有连接，它会同时设置两个方向的值都为 1，即 adj_matrix[v][u] = 1 和 adj_matrix[u][v] = 1。因此，无向图的邻接矩阵为对称矩阵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，在通常情况下我们在邻接矩阵中并不会只储存 0 和 1，我们可以储存一些更具信息的值，例如边权重等。最好的案例可能是带有距离信息的地图。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.406570841889117&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOfibdbibwB6BADMa7jtia5ficibGFuQ0d6WePYkQazvuPictud3gDkRj2JKgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图表示了 Patrick 和 Sponge Bob 等人之间的距离（也称为加权图）。如果节点间没有没有直接路径，那么我们就把它设为无穷大，它既不意味着根本没有路径，也不意味着一定有路径。它可以在应用算法搜索两个节点间路径时定义。当然，我们还有更好的方法来储存节点和边之间的关系，如关联矩阵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽管邻接矩阵对推特关注关系有很好的表征，但将 3 亿用户（每月活跃用户）储存在矩阵中需要 300*300*1（百万字节/布尔值）的储存空间。也就是约有 82000Tb（Terabyte）或需要 1024 * 82000 Gb 的储存空间。BitBoard 可以帮助我们减少一些空间需求，大约可以降低到 10000Tb，但还是太大。如上所述，邻接矩阵稀疏要求我们提供比实际需求更多的空间，这也就是为什么边的列表映射到节点可能会很有用。重点是，邻接矩阵允许保持关注和不关注的信息，而我们需要的仅仅是知道如下内容：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.39476678043230945&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQO6V0yrZu3R0cPv2qCo4A3j1CnHDL68mw3b0KwU4lthBVeUqJYIw4eOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;879&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;邻接矩阵与邻接列表&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;右图表示邻接列表（adjacency list），每个列表描述了图中的一组邻近节点。在图表中，我们突出了哈希表的用法，因为任何节点的访问复杂度都是 O（1）。而且对于邻近节点列表，我们并没有提到任何具体的数据结构，也不会从列表转化为向量。重点是，如果要确定 Patrick 是否关注 Liz，我们应该遍历哈希表中每一个元素（常数时间），而邻近矩阵需要查看每一个与 Liz 相关的元素（线性时间）。线性时间在这一点上并不是那么糟，因为我们经需要循环与 Patrick 相关的固定数目的节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们用空间复杂度表示推特，这需要 3 亿个哈希表记录，每个记录指向一个向量（选择向量以避免链表的左/右指针所产生的内存开销）。此外，虽然没有统计数据，但平均推特关注的人数是 707 个。所以如果我们考虑每个哈希表记录指向一个有 707 个用户 ID 的数组，且每个 ID 有 8 个字节，那么现在我们可以计算出储存空间约为 12TB。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在少很多了，但我们仍然不确定 12TB 是否是一个合理的数字。如果在 32Gb RAM 的专用服务器上一个月需要 30 美元，那么 12TB 加上一些控制服务器和备用服务器等（约需要额外两倍数量）核算下来需要 1500 台服务器，每月的成本达到了 45K 美元。这对于我们来说当然是难以接受的价格，但对于推特来说就非常便宜了。但推特需要提高响应的速度，即用户发的推文需要第一时间发送给关注的人。但理想的时间是多少？我们并不能作出任何假设和抽象，因此我们可以探讨一下现实世界产品系统的响应。以下是我们在推文时经常遇到情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7898338220918866&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQO4Nh4JV8W5Rl6z2rbKlDoXSXbstaxztfSMcpsuhNdA151ks5Hpw6PGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1023&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样我们并不知道一条推文需要多少时间才能发送到所有的关注者，但公开的数据表明每天约有 500 亿条推文。所以经验看来一般推文的时间在 5 秒内，同时我们还要注意哪些拥有超百万粉丝的名人，推特可能会分配更多的资源来推送名人「超级有用」的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了解决推文的分发问题，我们并不需要以下的图，我们需要关注者的列表。前面的哈希表和一些列表允许我们高效地搜索特定关注者关注的所有用户，但它并不允许高效地搜索关注特定用户所有关注者，因此我们必须扫描所有的哈希表键值。这也就是为什么我们应该构建另一个图，它与以下我们展示的图对称相反。这个新的图由包含 3 亿个节点的哈希表组成，每个节点指向相邻节点的猎鸟（结构相同），但是这次相邻节点的列表将表示关注者。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7905844155844156&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOLRDOfV73LExFVwBxGCYx1nln8HT3lYOrhDSdWGCNONLB3ax2XwVFkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此基于该示例，无论何时 Liz 发推特，Spone Bob 和 Ann 都必须在他们的时间线上找到特定的推文。一项普遍使用的解决该问题的技术是为每个用户的时间线保持独立的结构。假设推特有 3 亿的用户，我们可以假定至少存在 3 亿个时间线（每人一个）。简单的说，无论何时发推，我们应该找到他的关注者并且更新他们的时间轴，时间线可以被表征成连结串列或平衡树（以推文的日期作为节点关键字）。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;14&quot;&gt;
&lt;code class=&quot;&quot;&gt;// &lt;span class=&quot;&quot;&gt;'author'&lt;/span&gt; represents the User object, at this point we are interested only &lt;span class=&quot;&quot;&gt;in&lt;/span&gt; author.id&lt;br/&gt;//&lt;br/&gt;// &lt;span class=&quot;&quot;&gt;'tw'&lt;/span&gt; &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; a Tweet object, at this point we are interested only &lt;span class=&quot;&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;&quot;&gt;'tw.id'&lt;/span&gt;&lt;/code&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;
&lt;p&gt;void DeliverATweet(User* author, Tweet* tw)&lt;br/&gt;{&lt;br/&gt;// we assume that &lt;span class=&quot;&quot;&gt;'tw'&lt;/span&gt; object &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; already stored &lt;span class=&quot;&quot;&gt;in&lt;/span&gt; a database&lt;/p&gt;&lt;p&gt;// &lt;span class=&quot;&quot;&gt;1.&lt;/span&gt; Get the list of use&lt;span class=&quot;&quot;&gt;r's followers (author of the tweet)&lt;br/&gt;vector user_followers = GetUserFollowers(author-&amp;gt;id);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;// 2. insert tweet into each timeline&lt;br/&gt;for (auto follower : user_followers) {&lt;br/&gt;InsertTweetIntoUserTimeline(follower-&amp;gt;id, tw-&amp;gt;id);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;这仅仅是基本思想，从真实的时间线表征抽象得到。当然如果使用多线程，我们可以将实际的传送过程变得更快。这对于大规模案例非常关键，因为对于百万级别的关注者，接近列表终点的用户在处理上通常慢于接近列表前面的用户。以下的伪代码将尝试解释该多线程传送思想。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;12&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;18&quot;&gt;// Warning: a bunch of pseudocode ahead&lt;p&gt;void RangeInsertIntoTimelines(vector user_ids, long tweet_id)&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;for&lt;/span&gt; (auto id : user_ids) {&lt;br/&gt;InsertIntoUserTimeline(id, tweet_id);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;void DeliverATweet(User* author, Tweet* tw)&lt;br/&gt;{&lt;br/&gt;// we assume that &lt;span class=&quot;&quot;&gt;'tw'&lt;/span&gt; object &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; already stored &lt;span class=&quot;&quot;&gt;in&lt;/span&gt; a database&lt;/p&gt;&lt;p&gt;// &lt;span class=&quot;&quot;&gt;1.&lt;/span&gt; Get the list of use&lt;span class=&quot;&quot;&gt;r's (tweet author'&lt;/span&gt;s) followers&lt;span class=&quot;&quot;&gt;'s ids&lt;br/&gt;vector user_followers = GetUserFollowers(author-&amp;gt;id);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;// 2. Insert tweet into each timeline in parallel&lt;br/&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;

    
  const int CHUNK_SIZE = 4000; // saw this somewhere&lt;br/&gt;for (each CHUNK_SIZE elements in user_followers) {&lt;br/&gt;Thread t = ThreadPool.GetAvailableThread(); // somehow&lt;br/&gt;t.Run(RangeInsertIntoTimelines, current_chunk, tw-&amp;gt;id);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;因此无论关注者在什么时候刷新推特，他们都能收到新的推文。当然，我们仅仅讨论了 Airbnb 或推特面临问题的冰山一角，还有很多问题需要各位读者共同探讨。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7765640516385303&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQO7icX64mjQrYaHoTkEeO9mH0E1fbiaWSib8xRzmSA7hCxc5HfUM7YMcbOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1007&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;推特的推文分发问题关键在于对图的利用，即使我们不使用任何的图算法，仅用图表示。而真正的图算法是相当复杂的。在使用图表示之前，我们讨论了 Airbnb 房源和高效过滤的问题，主要困难在于当过滤器关键字超过一个的时候，就无法高效地过滤家园。那么使用图算法能带来什么好处吗？值得一试。我们可以将每个过滤器表示成一个独立的节点，每个过滤器可以代表特定的属性（价格、城市名、国家、生活设施等）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7718518518518519&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOt4dvmhm91F1f3OXVmtibF0BR1RC0l3xLkFIzcSlMY3LR66wbrQpNcfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;675&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Airbnb 过滤器节选&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们还可以通过添加高层的节点，例如「生活设施」节点来连接所有生活设施类的节点（WiFi、电视等），使该集合更容易理解。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7355021216407355&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOxzX9iak4H9fHclhNM7r3EteSJBZ0mmwzLSUZhLCkUe9sxtr0OLbceIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;拥有高级类型的 Airbnb 过滤器&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，我们可以将 Airbnb 房源（home）表示成节点，然后将这些节点和对应的属性节点连接起来。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7633053221288515&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOmiajJHTEicSC0ibphnkqKyg7kOmfpwCRiaGV4mEjROtXwGD7uL9C9EU3lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;714&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个插图的微妙变化使它更像一种特殊类型的图形，称为偶图（bipartite graph）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.8094512195121951&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQO2Il9iaPcIYXKCMJXmL9G1Vb0P5Yh0HdFxZT8UpAoZyLVicY4O5l2orew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;节点的数量比看起来的更多&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;偶图的节点可以分为两个不相交和独立的集合，这样每个边就将一个集合的节点连接到另一个集合的节点。在我们的例子中，其中一个表征过滤器（我们用 F 表示），另一个表征房源集合（H）。例如，如果有价值 62 美元的 10 万个房源，则标记为「$ 62」的价格节点将具有 10 万条边入射到每个房源的节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们测量空间复杂度的最坏情况，即每个家庭具有满足所有过滤器的所有属性，则要存储的边总量将为 7 万×400 万。如果我们将每个边表示为一个 ID 对：{filter_id; home_id}，如果我们重新考虑 ID，并使用 4 个字节（int）数字 ID 为过滤器 ID，8 个字节（long）ID 为房源使用的 ID，那么每个边缘至少需要 12 个字节。&lt;/span&gt;&lt;span&gt;因此，存储 7 万* 400 万个 12 字节值需要大约 3TB 的内存。我们在计算中犯了一个小错误，由于在 Airbnb 中有 65,000 个活跃城市，因此过滤器的数量约为 7 万个（统计数据）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;好消息是，同一个家庭不能位于不同的城市。也就是说，我们实际与城市边配对的数量是 400 万（每个家庭位于一个城市），因此我们将计算 70k-65k = 5000 个过滤器，这意味着我们需要 5000 * 400 万* 12 个字节的内存，小于 0.3Tb。听起来不错。但是什么给了我们这个偶图？最常见的网站/移动请求将由多个过滤器组成，例如：&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;house_type: &lt;span class=&quot;&quot;&gt;&quot;entire_place&quot;&lt;/span&gt;,&lt;br/&gt;adults_number: &lt;span class=&quot;&quot;&gt;2&lt;/span&gt;,&lt;br/&gt;price_range_start: &lt;span class=&quot;&quot;&gt;56&lt;/span&gt;,&lt;br/&gt;price_range_end: &lt;span class=&quot;&quot;&gt;80&lt;/span&gt;,&lt;br/&gt;beds_number: &lt;span class=&quot;&quot;&gt;2&lt;/span&gt;,&lt;br/&gt;amenities: [&lt;span class=&quot;&quot;&gt;&quot;tv&quot;&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;&quot;wifi&quot;&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;&quot;laptop friendly workspace&quot;&lt;/span&gt;],&lt;br/&gt;facilities: [&lt;span class=&quot;&quot;&gt;&quot;gym&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;因此我们只需要找到上述所有「过滤器」的节点，并处理与其邻近所有「房源」的节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图算法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或许，任何用图执行的计算过程都可以分类为「图算法」，你可以实现一个输出图的所由节点的函数，然后将其命名为「的节点输出算法」。但真正可怕的是教科书中列出的图算法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们尝试使用偶图匹配算法，例如 Hopcroft–Karp 算法到 Airbnb 房源过滤问题：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;给定一个 Airbnb 房源（H）的偶图和过滤器（F），其中 H 的每个节点可以多于 F 的一个相邻节点（共享一个公共边）。寻找 H 的由节点构成的子集，该子集和 F 的子集的节点相邻。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;问题的定义很难理解，并且目前我们还不确定 Hopcroft-Karp 算法可以解决该问题，但我们可以在求解的过程中学到很多图算法的关键思想。这个过程不会很短，需要你有耐心。Hopcroft-Karp 算法以二分图为输入，并生成最大基数匹配的输出，该输出是一个包含尽可能多的边的集合，其中没有任何两条边共享同一个端点。熟悉该算法的读者已经注意到，这并不能解决我们的问题，因为匹配过程的条件是没有任何两条边共享同一个节点。我们来看一个示例展示，其中只有 4 个过滤器和 8 个房源（为简单起见）。这些房源用字母 A 到 H 标记，过滤器是随机选择的。从 A 到 H 的所有房源都是 50 美元每晚的价格和一张床，但很少有供应 WiFi 和/或电视的。因此以下的示例过程将尝试找到满足四个条件的房源（拥有 4 个过滤器）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;img class=&quot;&quot; data-ratio=&quot;0.8059855521155831&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOicNOHD0AAB4k3IOOId3hs5lapD1Cicl9AG2n8uibpqGjicqkqQ0DVpnWeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;969&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对该问题的求解需要找到和特定的房源连接的所有边，该房源节点和相同的过滤器子集关联。而 Hopcroft-Karp 算法将移除公共端点的边，并生成和两个子集都关联的边。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看上图，我们需要寻找的是房源 D 和 G，它们满足了所有四个过滤器值。我们真正需要的是找到共享端点的所有匹配边。我们可以为该方法设计一个算法，但其处理时间可以说和用户需求并不相关（用户需求=快速）。也许创建一个平衡的多分类关键字的二值搜索树会更快，差不过类似于数据库索引文件，其将主关键字和外键映射到满足条件的记录集合。我们将在另一篇文章中独立讨论平衡二值搜索树和数据库索引，到时会再次返回到 Airbnb 房源问题上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Hopcroft-Karp 算法（以及很多其它算法）都基于 DFS（深度优先搜索）和 BFS（广度优先搜索）的图遍历算法。说实话，这里介绍 Hopcroft-Karp 算法的真正原因是逐渐转换到图遍历算法的讨论，相比从二值树开始讨论会更好。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二值树遍历非常漂亮，这大多是因为它们的递归本质。有三种基本的遍历方式称为中序（in-order）、后序（post-order）和前序（pre-order）。如果你曾经遍历过连结串列，这些概念是很好懂的。在连结串列中，你只需要输出当前节点的值（在下方的代码中称为 item），并继续到达下一个节点。&lt;/span&gt;&lt;/p&gt;

&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;7&quot;&gt;// struct ListNode {&lt;br/&gt;//   ListNode* next;&lt;br/&gt;//   T item;&lt;br/&gt;// }; &lt;p&gt;void TraverseRecursive(ListNode* node) // starting node, most commonly the list &lt;span class=&quot;&quot;&gt;'head'&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;if&lt;/span&gt; (!node) &lt;span class=&quot;&quot;&gt;return&lt;/span&gt;; // stop&lt;br/&gt;std::cout &amp;lt;&amp;lt; node-&amp;gt;item;&lt;br/&gt;TraverseRecursive(node-&amp;gt;next); // recursive call&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;void TraverseIterative(ListNode* node)&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;while&lt;/span&gt; (node) {&lt;br/&gt;std::cout &amp;lt;&amp;lt; node-&amp;gt;item;&lt;br/&gt;node = node-&amp;gt;next;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;这和二值树几乎相同，输出节点的值，然后到达下一个节点，但在这里，「下一个」指的是两个节点，左节点和右节点。因此你需要分别到达左节点和右节点。不过你有三个不同的选择：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;输出节点值，然后到达左节点，再到达右节点。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;到达左节点，然后输出节点值，再到达右节点。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;到达左节点，然后到达右节点，再输出节点值。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre readability=&quot;10.5&quot;&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;
&lt;code class=&quot;&quot; readability=&quot;15&quot;&gt;// struct TreeNode {&lt;br/&gt;//   T item;&lt;br/&gt;//   TreeNode* left;&lt;br/&gt;//   TreeNode* right;&lt;br/&gt;// }&lt;p&gt;// you cann &lt;span class=&quot;&quot;&gt;pass&lt;/span&gt; a callback function to do whatever you want to do &lt;span class=&quot;&quot;&gt;with&lt;/span&gt; the node&lt;span class=&quot;&quot;&gt;'s value&lt;br/&gt;// in this particular example we are just printing its value.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;// node is the &quot;starting point&quot;, basically the first call is done with the &quot;root&quot; node&lt;br/&gt;void PreOrderTraverse(TreeNode* node)&lt;br/&gt;{&lt;br/&gt;if (!node) return; // stop&lt;br/&gt;std::cout &amp;lt;&amp;lt; node-&amp;gt;item;&lt;br/&gt;PreOrderTraverse(node-&amp;gt;left); // do the same for the left sub-tree&lt;br/&gt;PreOrderTraverse(node-&amp;gt;right); // do the same for the right sub-tree&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;void InOrderTraverse(TreeNode* node)&lt;br/&gt;{&lt;br/&gt;if (!node) return; // stop&lt;br/&gt;InOrderTraverse(node-&amp;gt;left);&lt;br/&gt;std::cout &amp;lt;&amp;lt; node-&amp;gt;item;&lt;br/&gt;InOrderTraverse(node-&amp;gt;right);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;void PostOrderTraverse(TreeNode* node)&lt;br/&gt;{&lt;br/&gt;if (!node) return; // stop&lt;br/&gt;PostOrderTraverse(node-&amp;gt;left);&lt;br/&gt;PostOrderTraverse(node-&amp;gt;right);&lt;br/&gt;std::cout &amp;lt;&amp;lt; node-&amp;gt;item;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7684630738522954&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOicBkFk4TAlBSJeg1tdnCoH1AcYPwJ0CStyyCexSME8f56iaJrcZvhVfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;前序遍历的细节追踪&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.6005747126436781&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOP0ibeBWf5fg6t3dyEicniaxMgDeVia1icE3zQicnOcC7mfdgKR7pDH2iaYV4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;/p&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;很明显递归函数的形式很优雅，虽然其计算成本很高。每次我们递归地调用一个函数，也就意味着我们调用了一个完全的新函数（如上图所示）。其中「新」的意思是函数变量和局域变量需要分配其它的堆栈内存空间。这正是为什么递归调用的成本如此高（额外的堆栈空间分配和多函数调用）和危险（堆栈溢出），很明显地使用迭代实现会更好。在关键任务（航空、NASA 探测车等）的系统编程中，递归调用是完全禁止的。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;实例：Netflix&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;假设我们要将所有 Netflix 电影存储在二进制搜索树中，并将电影标题作为排序键。所以无论何时用户输入类似「Inter」的内容，我们都会返回一个以「Inter」开头的电影列表，举例，[「Interstellar」,「Interceptor」,「Interrogation of Walter White」]。如果我们将返回标题中包含「Inter」的所有电影（不仅仅是以「Inter」开头的电影）那就太好了，并且该列表将根据电影的评分或与该特定用户相关的内容进行排序（喜欢惊悚片比戏剧更多）。这个例子的重点在于对 BST 进行有效的范围查询，但像往常一样，我们不会深入探讨其余部分。基本上，我们需要通过搜索关键字进行快速查找，然后获得按关键字排序的结果列表，这很可能应该是电影评级和/或基于用户个性化数据的内部排名。我们会尽可能地坚持 KISK 原则（Keep It Simple，Karl）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;「KISK」或「让我们保持它的简单」或「为了简单起见」，这是教程编写者从真实问题中抽象出来的超级借口，并通过在伪代码中引入「abc」简单示例及其解决方案来做出大量假设，并且这些答案在很老的笔记本电脑上也能工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个问题可以很容易地应用到亚马逊的产品搜索上，因为我们通常通过输入描述我们兴趣的文本（如「图算法」）来搜索亚马逊的东西，并根据产品的评分获得结果（我没有在亚马逊的个性化结果中体验过搜索结果，但我很确定亚马逊也是这样做的）。所以，为了公平将这个子标题改为...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Netflix 和亚马逊。Netflix 提供电影服务，亚马逊提供产品，我们会将它们命名为「物品」，所以每当你阅读「物品」时，都会想到 Netflix 中的电影或亚马逊的任何 [合格] 产品。这些物品最常用的是解析其标题和描述（我们只处理标题），所以如果一个操作员（通常是一个人通过管理仪表板将项目的数据插入 Netflix / Amazon 数据库）插入新项目到数据库中，它的标题正在被一些「ItemTitleProcessor」处理以产生关键字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7556818181818182&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOGumqZTmfBG7gJychoBd8scvX2KicgA0RyCghgIXckZvXQiaEybulZDTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;704&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我知道这并不是最好的图例（而且有一个书写错误）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每一个物品都有专属 ID，这个 ID 也链接到了标题之中的关键字。这也是搜索引擎在爬全世界的网站时做的。他们分析每个文档的内容，对其进行标记（将其分解为更小的实体和单词）并添加到表中，该表将每个标记（词）映射到标记已被「看到」的文档标识（网站）。因此，无论何时搜索「hello」，搜索引擎都会获取映射到关键字「hello」的所有文档（实际情况非常复杂，因为最重要的是搜索相关性，这就是为什么谷歌搜索非常棒）。所以 Netflix /亚马逊的类似表格可能看起来像这样（再次，在阅读物品时想一想电影或产品）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7411598302687411&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOibJ0nbHoyNssrC4W6NpE3coERCF0EnVVY9MEpb1VAP9CQw6oxBDVKjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;倒排索引&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哈希表，再提一次。是的，我们将为此倒排索引（索引结构存储来自内容的映射）保留哈希表。哈希表会将关键字映射到物品的 BST。为什么选择 BST？因为我们希望保持它们的排序并同时提供连续排序的部分（响应前端请求），例如一次请求（分页）中的 100 个物品。这并不能说明 BST 的强大功能，但假设我们还需要在搜索结果中进行快速查找，例如，你需要关键字为「机器」的所有 3 星电影。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7955465587044535&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQO9zAaI19UGZqBxTBvnQjOn2AFn0icHicNWsrUgPicHOJLTU8X3oeoMibcow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;988&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请注意，可以在不同的树中复制物品，因为通常可以使用多个关键字找到物品。我们将使用如下面定义的物品进行操作：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;// Cached representation of an Item&lt;br/&gt;// Full Item object (&lt;span class=&quot;&quot;&gt;with&lt;/span&gt; title, description, comments etc.) &lt;br/&gt;// could be fetched &lt;span class=&quot;&quot;&gt;from&lt;/span&gt; the database&lt;br/&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;

    
struct Item&lt;br/&gt;{&lt;br/&gt;// ID_TYPE &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; the type of Item&lt;span class=&quot;&quot;&gt;'s unique id, might be an integer, or a string&lt;br/&gt;ID_TYPE id;&lt;br/&gt;int rating;&lt;br/&gt;};&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;每次将新物品插入数据库时，其标题都将被处理并添加到大型索引表中，该表将关键字映射到物品。可能有许多物品共享相同的关键字，因此我们将这些物品保存在按照评分排序的 BST 中。当用户搜索某个关键字时，他们会得到按其评分排序的物品列表。我们如何从排序的树中获取列表？通过按顺序遍历。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;8&quot;&gt;// this &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; a pseudocode, that&lt;span class=&quot;&quot;&gt;'s why I didn'&lt;/span&gt;t bother &lt;span class=&quot;&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&quot;const&amp;amp;&quot;&lt;/span&gt;&lt;span class=&quot;&quot;&gt;'s and &quot;std::&quot;'&lt;/span&gt;s&lt;br/&gt;// though it could have look better, forgive me C++ fellows&lt;p&gt;vector GetItemsByKeywordInSortedOrder(string keyword)&lt;br/&gt;{&lt;br/&gt;// assuming IndexTable &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; a big hashtable mapping keywords to Item BSTs&lt;br/&gt;BST items = IndexTable[keyword]; &lt;/p&gt;&lt;p&gt;// suppose BST has a function InOrderProduceVector(), which creates a vector &lt;span class=&quot;&quot;&gt;and&lt;/span&gt; &lt;br/&gt;// inserts into it items fetched via &lt;span class=&quot;&quot;&gt;in&lt;/span&gt;-order traversing the tree&lt;br/&gt;vector sorted_result = items.InOrderProduceVector();&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; sorted_result;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;这里是一种 InOrderProduceVector() 实现：&lt;/span&gt;&lt;/p&gt;

&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;9&quot;&gt;template &lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;

    
BST&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;// other code ...&lt;br/&gt;vector InOrderProduceVector()&lt;br/&gt;{&lt;br/&gt;vector result;&lt;br/&gt;result.reserve(&lt;span class=&quot;&quot;&gt;1000&lt;/span&gt;); // magic number, reserving a space to avoid reallocation on inserts&lt;br/&gt;InOrderProduceVectorHelper_(root_, result); // passing vector by reference&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;p&gt;protected:&lt;br/&gt;// takes a reference to vector&lt;br/&gt;void InOrderProduceVectorHelper_(BSTNode* node, vector&amp;amp; destination)&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;if&lt;/span&gt; (!node) &lt;span class=&quot;&quot;&gt;return&lt;/span&gt;;&lt;br/&gt;InOrderProduceVectorHelper_(node-&amp;gt;left, destination);&lt;br/&gt;destination.push_back(node-&amp;gt;item);&lt;br/&gt;InOrderProduceVectorHelper_(node-&amp;gt;right, destination);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;private:&lt;br/&gt;BSTNode* root_;&lt;br/&gt;};&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;但是呢，我们首先需要最高评价的物品，来替换掉按顺序遍历生成最低评级的物品。这是因为它的性质，是从低到高的顺序遍历物品，「自下而上」。为了得到我们想要的东西，即列表按降序而不是升序排列，我们应该仔细查看顺序遍历实现。我们所做的是通过左节点，然后打印当前节点的值和通过右边的节点。当我们第一次通过左节点时，这就是为什么我们首先获得了「最左」节点（最左节点），这是具有最小值的节点。因此，简单地将实现更改为首先通过正确的节点将导致我们按照列表的降序排列。我们会像其他人一样将其命名，这是一种逆序的遍历。让我们更新上面的代码（引入单个列表、警告、错误）：&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;pre readability=&quot;49&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;2&quot;&gt;// Reminder: this &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; pseudocode, no bother &lt;span class=&quot;&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&quot;const&amp;amp;&quot;&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;&quot;std::&quot;&lt;/span&gt; &lt;span class=&quot;&quot;&gt;or&lt;/span&gt; others&lt;br/&gt;// forgive me C++ fellows&lt;p&gt;template &lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;class&lt;/span&gt;&lt;/span&gt;
&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;
&lt;span class=&quot;&quot;&gt;BST&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt;:&lt;/p&gt;&lt;/code&gt;&lt;br/&gt;// other code ...&lt;p&gt;vector ReverseInOrderProduceVector(int offset, int limit)&lt;br/&gt;{&lt;br/&gt;vector result;&lt;br/&gt;result.reserve(limit);&lt;br/&gt;// passing result vector by reference&lt;br/&gt;// &lt;span class=&quot;&quot;&gt;and&lt;/span&gt; passing offset &lt;span class=&quot;&quot;&gt;and&lt;/span&gt; limit&lt;br/&gt;ReverseInOrderProduceVectorHelper_(root_, result, offset, limit);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;protected:&lt;br/&gt;// takes a reference to vector&lt;br/&gt;// skips &lt;span class=&quot;&quot;&gt;'offset'&lt;/span&gt; nodes &lt;span class=&quot;&quot;&gt;and&lt;/span&gt; inserts up to &lt;span class=&quot;&quot;&gt;'limit'&lt;/span&gt; nodes&lt;br/&gt;void ReverseInOrderProduceVectorHelper_(BSTNode* node, vector&amp;amp; destination, int offset, int limit)&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;if&lt;/span&gt; (!node) &lt;span class=&quot;&quot;&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;if&lt;/span&gt; (limit == &lt;span class=&quot;&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;&quot;&gt;return&lt;/span&gt;;&lt;br/&gt;--offset; // skipping current element&lt;br/&gt;ReverseInOrderProduceVectorHelper_(node-&amp;gt;right, destination, offset, limit);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;if&lt;/span&gt; (offset &amp;lt;= &lt;span class=&quot;&quot;&gt;0&lt;/span&gt;) { // &lt;span class=&quot;&quot;&gt;if&lt;/span&gt; skipped enough, insert&lt;br/&gt;destination.push_back(node-&amp;gt;value);&lt;br/&gt;--limit; // keep the count of insertions&lt;br/&gt;}&lt;br/&gt;ReverseInOrderProduceVectorHelper_(node-&amp;gt;left, destination, offset, limit);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;private:&lt;br/&gt;BSTNode* root_;&lt;br/&gt;};&lt;/p&gt;&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;

    
// ... other possibly useful code&lt;/p&gt;&lt;p&gt;// this &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; a pseudocode, that&lt;span class=&quot;&quot;&gt;'s why I didn'&lt;/span&gt;t bother &lt;span class=&quot;&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&quot;const&amp;amp;&quot;&lt;/span&gt;&lt;span class=&quot;&quot;&gt;'s and &quot;std::&quot;'&lt;/span&gt;s&lt;br/&gt;// though it could have look better, forgive me C++ fellows&lt;/p&gt;&lt;p&gt;vector GetItemsByKeywordInSortedOrder(string keyword, offset, limit) // pagination using offset &lt;span class=&quot;&quot;&gt;and&lt;/span&gt; limit&lt;br/&gt;{&lt;br/&gt;// assuming IndexTable &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; a big hashtable mapping keywords to Item BSTs&lt;br/&gt;BST items = IndexTable[keyword]; &lt;/p&gt;&lt;p&gt;// suppose BST has a function InOrderProduceVector(), which creates a vector &lt;span class=&quot;&quot;&gt;and&lt;/span&gt; &lt;br/&gt;// inserts into it items fetched via reverse &lt;span class=&quot;&quot;&gt;in&lt;/span&gt;-order traversing the tree&lt;br/&gt;// to get items &lt;span class=&quot;&quot;&gt;in&lt;/span&gt; descending order (starting &lt;span class=&quot;&quot;&gt;from&lt;/span&gt; the highest rated item)&lt;br/&gt;vector sorted_result = items.ReverseInOrderProduceVector(offset, limit);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; sorted_result;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过排序关键词查找电影或产品&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就对了，我们可以非常快速地提供物品搜索结果。如上所示，反转索引在搜索引擎中最常用，例如谷歌搜索。虽然谷歌搜索引擎非常复杂，它确实利用了某些简单的思想，来将搜索查询匹配到文档上，并尽可能快速地提供结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们使用了树遍历来以分类排序提供结果。在这里，前序/顺序/后序遍历可能太多了，但有时候我们也需要应用其它类型的遍历。让我们来解决这个著名的编程面试问题：「如何按等级输出一个二值树等级？」&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7601683029453016&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOCUM2dlECuUf3G3SWsgudIAnI9ibicX8qO0IRGEnEgJkBH4YIiadibFg4sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;DFS vs. BFS&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你对这个问题不熟悉，想想你在遍历树的时候可用于存储节点的数据结构。如果对比分层遍历树和上文介绍的其他方式（前序/顺序/后序遍历），就会发现两种主要的图遍历方法：深度优先搜索（DFS）和广度优先搜索（BFS）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.8291347207009858&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOuJwvjo6oia7CkDGMwq07HqmasXDqhgZ9sU3yLqMf9e0QuicplsK7Qfnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;913&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;深度优先搜索寻找最远的节点，广度优先搜索先寻找最近的节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7735085945399394&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOAZNqTX9qGrvLEjwpPibzGib2Vxd5MuZhYTDp5L2DicRZ3M7TgyRLVLlOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;989&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DFS 很像前序/顺序/后序遍历，而 BFS 用于分层输出树节点。我们需要一个队列（数据结构）来存储图的「层级」，同时输出（访问）其「父级」。在之前的插图中，节点是队列中浅蓝色的点。每一层的节点被从队列中取走，同时在访问每个被取走的节点时，我们还应该将其子节点插入队列（为下一层做准备）。下列代码很简单，可以帮助大家了解 BFS。代码假设图是连通的，尽管我们可以修改代码，使其应用于非连通图。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;6&quot;&gt;// Assuming graph &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; connected &lt;br/&gt;// &lt;span class=&quot;&quot;&gt;and&lt;/span&gt; a graph node &lt;span class=&quot;&quot;&gt;is&lt;/span&gt; defined by this structure&lt;br/&gt;// struct GraphNode {&lt;br/&gt;//   T item;&lt;br/&gt;//   vector children;&lt;br/&gt;// }&lt;p&gt;// WARNING: untested code&lt;br/&gt;void BreadthFirstSearch(GraphNode* node) // start node&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;if&lt;/span&gt; (!node) &lt;span class=&quot;&quot;&gt;return&lt;/span&gt;;&lt;br/&gt;queue q;&lt;br/&gt;q.push(node);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;while&lt;/span&gt; (!q.empty()) {&lt;br/&gt;GraphNode* cur = q.front(); // doesn&lt;span class=&quot;&quot;&gt;'t pop&lt;br/&gt;q.pop();&lt;br/&gt;for (auto child : cur-&amp;gt;children) {&lt;br/&gt;q.push(child);&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;// do what you want with current node&lt;br/&gt;cout &amp;lt;&amp;lt; cur-&amp;gt;item;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;在基于节点的连通图表示上可以轻松地了解基本思想。记住图遍历的实现因图表示而异。BFS 和 DFS 在解决图搜索问题中是重要的工具（但是存在大量图搜索算法）。尽管 DFS 具备优雅的递归实现，但进行迭代实现更合理。我们使用队列进行 BFS 的迭代实现，而 DFS 则需要堆栈。图领域中一个最流行的问题，同时也可能是你阅读本文的原因之一是寻找图节点之间的最短路径。这需要我们进行最后一个实验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;示例：Uber&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;  Uber 有 5000 万用户、700 万司机，对于 Uber 来说，最重要的事情之一就是高效匹配司机和乘客。该问题首先是定位的问题。后端要处理数百万份用户请求，将每份请求发送至一或多（通常是多）位附近的司机。尽管将用户请求发送至所有附近司机更加简单，有时也更加智能，但是预处理通常会有所帮助。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.782051282051282&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOekGZWPhYlz05JLteIhCmOiblbqkQfNCIN4PGzzOPQ7oaibicz8XjpRbug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了处理请求、基于用户坐标确定定位、寻找最近坐标的司机以外，我们还需要寻找最适合这趟行程的司机。为了避免地理空间请求处理（对比司机当前坐标和用户坐标，来获取附近车辆），我们假设已经分割了用户和多辆附近车辆的地图，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7818696883852692&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQO38WJh667h3ylJruUeMS7YY5cicLnKp94lRCCJWmf3bzGHmicsr1e3ccA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;706&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;黄色路线是车辆到用户处的可能路径。问题在于计算车辆到达用户的最小距离，即寻找最短路径。尽管这更多地涉及谷歌地图而不是 Uber，我们仍然尝试解决这一特定和简化案例，其原因主要在于通常存在多辆车，Uber 可能需要计算离用户最近的车。就这张插图而言，这意味着计算全部三辆车的最短路径并确定哪辆车最适合该行程。为了使问题简洁，我们将讨论只有一辆车的情况。下图显示了一些到达用户的可能路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.18618618618618618&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQO9Ncg1MaHFe4oS42RLqRib9eaPcDNJIFC5nicNFaR1szw0GU11qtPUticg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;车辆到达用户的可能路径&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将该地图分割表示为一个图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.88379705400982&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOI7Yv96ZnLRCJntsXHOaWXbBU2j6ZOial7Bb45h4F92IwmRmzibFUbpEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;611&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是一个无定向的加权图（更具体地说是，边加权）。为了找到从 B（车）到 A（用户）的最短途径，我们应该找到他们之间的一条边权重最小的路。你可以自由的设计你自己版本的解决方案，我们还是使用 Dijkstra 的版本。下面的步骤是从维基百科上找到的 Dijkstra 的算法的步骤。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们把起始的节点叫做初始节点。节点距离 Y 表示初始节点到 Y 的距离。Dijkstra 的算法将分配一些初始距离值，并尝试一步步地改善它们。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 标记所有未访问节点。创建所有未访问节点的集合「unvisited set」。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 为每个节点分配一个实验距离值：初始节点的距离值设置为 0，其他节点设置为无穷大。将初始节点设置为当前节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 对于当前节点，考虑其所有未访问近邻，通过当前节点计算它们的实验距离。对比新计算的实验距离和当前分配的值，分配较小的值。例如，如果当前节点 A 的距离是 6，连接 A 与近邻 B 的边长度为 2，则经过 A 到 B 的距离是 6 + 2 = 8。如果 B 之前标记的距离大于 8，则将其更改为 8。反之，保留当前值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 当我们考虑完当前节点的所有近邻之后，将当前节点标记为已访问，并从 unvisited set 中移除。已访问节点无需再检查。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 如果目标节点已经标记为已访问（当规划两个特定节点之间路线的时候），或 unvisited set 中节点之间的最小实验距离是无穷大（当规划完整遍历时，初始节点和其余未访问节点之间没有连接时），则停止，算法结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6. 反之，选择标记有最小实验距离的未访问节点，将其设置为新的「当前节点」，并返回第 3 步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在我们的示例中，我们首先将节点 B（车辆）设置为初始节点。前两步：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.5968436154949784&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOAhLZQHmA0HpXSQ9puYTXbaN9V27SYUegofhpesRlqRksZickWjUjYgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;/p&gt;

&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;我们的 unvisited set 包含了所有的节点，同时也要注意图左边里显示的表格。所有的节点都包括了到 B 和到之前节点的最短距离。例如，从 B 到 F 的最短距离是 20，之前节点是 B。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.6014388489208633&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOVricgIwah5wiaAMqI3o6C9bNtq2BPrFSVopiauR3fByaHaMJ7QrAuumGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;695&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们把 B 标注为访问过的然后移动到它的近邻 F。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.6017191977077364&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOyQJ9vqwljtxwmuWo8nlibiaYibiaG8Oj5gu8eI3OsrPhYEWMtMSeUrRFGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;698&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，我们把 F 标注已访问过的，然后在最小实验距离下选下一个没被访问过的节点，就是 G。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.6166902404526167&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQODnZJhL4wd563f7U7OXCEh6lMKxldtOP0egVXtzNzbze8vP1sY3bopw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就像算法里说的，如果目标节点已经被标注为访问过的（当规划两个特定的节点间的路线时）那么我们可以停止。所以我们下一步用下面的值去停止算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我们已经有了从 B 到 A 并且经过 F 与 G 的两条最短距离。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这真的是 Uber 里最简单的问题的例子，和冰山类比相比较，我们在冰山的山尖上。然而，这对于我们探索图论应用的真实场景是个好的开始。我没有完成我一开始计划的文章，但在不久的将来这个文章最有可能继续下去（也包括数据库内部索引）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于图论有很多内容需要去学习，这篇文章只是冰山一角，非常感谢各位读者有耐心能阅读完 ~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原文：https://medium.freecodecamp.org/i-dont-understand-graph-theory-1c96572a1401&lt;/span&gt;&lt;/p&gt;
&lt;section data-style=&quot;white-space: normal; text-align: left;font-size: 14px;line-height: 1.5em; color: rgb(12, 12, 12);&quot;&gt;&lt;p&gt;&lt;span&gt;选自&lt;span&gt; | &lt;/span&gt;Medium&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;来源 | 机器之心&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section data-style=&quot;white-space: normal; text-align: left;font-size: 14px;line-height: 1.5em; color: rgb(12, 12, 12);&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.9366666666666666&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/951TjTgiabkwJ4BpvBcQhGAbtWZZvV69s7GickZGibsKgYkTQkiaZfLYOmGS9iaaoibadibGJhT18OVZkfeJmCSUSD0zw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot; width=&quot;auto&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;p&gt;&lt;span&gt;算法数学之美微信公众号欢迎赐稿&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;稿件涉及数学、物理、算法、计算机、编程等相关领域&lt;br/&gt;稿件一经采用，我们将奉上稿酬。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;投稿邮箱：math_alg@163.com&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Mar 2018 19:24:39 +0000</pubDate>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.jintiankansha.me/t/KDuln9hnNA</dc:identifier>
</item>
<item>
<title>计算机起源的数学思想</title>
<link>http://www.jintiankansha.me/t/U7GnYqw6Uj</link>
<guid isPermaLink="true" >http://www.jintiankansha.me/t/U7GnYqw6Uj</guid>
<description>&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.6538461538461539&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQATdfZ715KZPwShJ0OdM5LCwLg40qsg7icLYGcmWW5pSThApBFbn19WCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;650&quot;/&gt;&lt;br/&gt;&lt;/p&gt;


&lt;section class=&quot;&quot; data-tools=&quot;135&amp;#x7F16;&amp;#x8F91;&amp;#x5668;&quot; data-id=&quot;86456&quot;&gt;&lt;section class=&quot;&quot; readability=&quot;2.5&quot;&gt;&lt;section data-bgless=&quot;lighten&quot; data-bglessp=&quot;15%&quot; readability=&quot;5&quot;&gt;&lt;p&gt;&lt;span&gt;人类的历史可以看做一部关于解放的历史。也有这样的说法，懒惰是人类进步的动力。为了偷懒，人类不断的做着各种努力，发明了各种机器工具，将自己从繁重的劳动解放出来，另一方面，每一次大的进步，都需要解放思想，同时也带来了全人类思想的大解放。在这样的历程中，计算机的出现无疑将人类从很多繁重的作业中解放了出来。与此同时，有些人开始思考能否制造出可以像人类一样进行思考的机器，以将人类从创造性的劳动和逻辑思考中解放出来，交给机器去完成。&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.6073059360730594&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAguPDmsdp4ibahVicSHbbQAumhGxVegMqMAns9G8dloUhiaEnG6vJxqPuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;虽然计算机的出现，不到百年，然而为了它的出现，所进行的探索和研究，早已经历经数百年的历史。当然准确的说，这些探索和研究在当时实际并不是为了计算机产生而进行的，绝大多数只是做了一个无意的铺垫。或许我们并不熟悉这样的一个过程，老实说现代的大学教育中也很少提及计算机出现之前的那些历史。实际上，了解这样的一个过程，更有助于我们理解一个事物是如何产生出来，它背后的科学原理又是如何，让我们可以透过复杂的电路外表，接触到最本质的东西。可以让我们除了对科学家们的工作表示赞叹之外，也可以深入他们当初的思想过程，近距离地进行跨越时间和空间的沟通。这对于我们自己应该如何思考问题，创造性地提出自己的想法也是有所帮助的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.690625&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/ksmtY9BFJOBx32afrgBbPu5LoLLAzDSPvT1XPGgdWIk9xicEjKh4bwowj5tiaJibuEmSXicJFMRsu5licQTcNgRTnqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们已经了解到这样的一些人物，乔治.布尔,康托，哥德尔，图灵，冯诺依曼。而我们的离散数学的教学中，本身太注重于知识本身的学习，而忽略了知识是如何被发现产生出来，以及不同的知识之间曾经的渊源和启发关系。而对于启迪思想来说，后者显然更为有力。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.47131782945736433&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAEdK9a4DhwbT17E4BawZ1akwJiaJ6pwXzV2lK82Rict0Tn9QZFW8CiazYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;645&quot;/&gt;&lt;/p&gt;

&lt;section&gt;&lt;section class=&quot;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;p&gt;&lt;strong&gt;莱布尼茨之梦&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;早在17世纪的莱布尼茨就有一个伟大的构想，他希望可以将人类的思维像代数运算那样符号化，规则化，从而让笨的人通过掌握这样的规则变得聪明，更进一步的制造出可以进行思维运算的机器，将人类从思考中解放。从莱布尼茨为微积分所确定的依然在今天被沿用的符号中，我们可以看出他对符号具有良好的感觉，通过选择良好的符号，可以大大的简化运算的复杂性，甚至将这样的运算变成一种天然的过程。除了构想之外，莱布尼茨本身为了发展一种逻辑演算也进行了很多尝试，他得到的一些结果已经具有后来布尔的逻辑代数的雏形。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.7305555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/ksmtY9BFJOBx32afrgBbPu5LoLLAzDSPYicSsZW8hhZ3ibficZmfR5icKy2y0QiaJCf8PKyjHibuBNxpwaVXQLn4msMg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;

&lt;section&gt;&lt;section class=&quot;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;布尔的逻辑代数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;19世纪的布尔，将逻辑代数化，发展出了逻辑代数成为后来计算机内部运算的逻辑基础。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在早期的研究中，布尔就已经认识到符号的力量，代数的力量正源于代表着量和运算的符号在几条基本规则的支配下体现出来的。后来，他开始思考能否将逻辑推理也像代数那样用符号和几条基本规则就可以完全表达。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.5922077922077922&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAkP5orCbZOVkBDH4L5BA2ABwrUiaIrsyVmaR2mCKNZiblTEOMCHc2Pkng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;770&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;他开始思考我们通常所说的某物具有某种性质，可以用一个类来表示，比如白的是x，绵羊是y，那么白绵羊就可以用xy来表示，这样日常生活中的概念开始具有代数的形式，用现代的术语来说上面的xy表示的正是交集。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;他又继续思考，xx表示什么呢，他发现xx与我们普通的代数运算不同xx依然表示的是x。xx=x实际上成为布尔的逻辑代数的一个基本规则。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;继续考虑下去，如果xx=x在普通的代数中意味着什么呢？xx=x，意味着x=1或者0.可以看到如果xx=x作为逻辑代数的基本规则，放在普通代数中意味着x=0或者1，那么逻辑代数是否意味着是01的普通代数呢。于是布尔得到一个基本原理，如果仅仅限于01，逻辑代数就变成了普通代数。关于这一点的思考，对于二进制运算的在逻辑代数中的主导作用具有很大的启发意义。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果限于01，那么01在我们的逻辑代数中代表的意思又是什么呢。我们之前看到可以用x表示某个类，对应地那么0可以解释成没有任何东西属于它的类，1可以解释成包含所有对象的全体。同时布尔又开始考虑普通代数中的+-在逻辑代数中的意义，x+y可以表示具有x和y两种属性的对象集合，x-y表示具有x属性同时不具有y属性的对象集合。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;考虑了这样的一些意义之后，接下来再看xx=x=&amp;gt; x-xx = 0 =&amp;gt; x(1-x) = 0&lt;br/&gt;现在我们以逻辑代数的观点看这个式子，它体现了这样一个含义：没有任何东西可以同时属于又不属于某个类。这点让布尔十分振奋，因为这刚好体现了亚里士多德的排中律，这就使他确信自己找对了路子。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt;  继续下去，布尔发现三段论也可以用他的逻辑代数来表达。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.4971014492753623&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAvZzYdsZghXpOSPKnJFQaZPdcB55IiamW1uYlKWYbibeDiapdARN5SSeZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所有x都是y x=xy(x中的任何东西也属于y，就等于说没有任何东西是属于x而不属于y的，也就是说x(1-y)=0)&lt;br/&gt;所有y都是z y=yz&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;------------ ?&lt;br/&gt;所有x都是z x=xz&lt;br/&gt;x=xy&lt;br/&gt;y=yz =&amp;gt; x = xy = x(yz) = (xy)z = xz&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;最后，&quot;如果x，那么y。&quot;可以用x(1-y)=0来表示,可以这样理解这个式子意味着如果x=1，那么y=1。在这里一方面我们可以把&quot;如果x，那么&quot;理解为等同于前面的这样一句话&quot;所有的x都是y&quot;,当然这两者有一个区别，现在的x，y表示的是命题，而原来的x，y表示的则是类概念。以今天的观点来看，前者是命题演算，后者是谓词演算。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是如果从另一个方面，重新考虑这句话，比如x=1表示命题x为真，x=0表示命题x为假，xy=1表示x且y，只有x，y均为1，xy=1，如果x=0或y=0，xy=0，这点又与普通代数相一致。从这个方向思考下去，就可以看到今天的布尔代数的基本面貌了，上面的这个定义正是与运算。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;布尔的逻辑体系，不仅包含了亚里士多德的逻辑体系，而且还超越了它，但是仍有无法表达的情形：所有失败的学生或者是糊涂的或者是懒惰的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.4274193548387097&quot; data-s=&quot;300,640&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/ksmtY9BFJOBx32afrgBbPu5LoLLAzDSP0ibj1KicGVvqG89Jpeibc5ics3PcaNEdqWDXNrXuyFhOcaGicmAl4Js9ULw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;620&quot;/&gt;&lt;/p&gt;

&lt;section&gt;&lt;section class=&quot;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;今天的布尔代数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;回到今天，我们再看布尔再把逻辑转变成代数的过程中，所产生的逻辑代数在今天的计算机中扮演着什么样的作用。布尔代数只有1和0两个元素，not and or三种运算，用几张真值表就可以表达清楚。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;AND | 1 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-----------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 | 1 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;0 | 0 0&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;这张表说明如果 AND 运算的两个元素有一个是 0，则运算结果总是 0。如果两个元素都是 1，运算结果是 1。例如，“太阳从西边升起”这个判断是假的(0),“水可以流动”这个判断是真的（1），那么，“太阳从西边升起并且水可以流动”就是假的（0）。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;OR | 1 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-----------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 | 1 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;0 | 1 0&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;这张表说明如果OR运算的两个元素有一个是 1，则运算结果总是 1。如果两个元素都是 0，运算结果是 0。比如说，“张三是比赛第一名”这个结论是假的（0），“李四是比赛第一名”是真的（1），那么“张三或者李四是第一名”就是真的（1）。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;NOT |&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 | 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;0 | 1&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;这张表说明 NOT 运算把 1 变成 0，把 0 变成 1。比如，如果“象牙是白的”是真的（1），那么“象牙不是白的”必定是假的（0）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如此简单的运算，实际上当时的布尔也不会想到它会被运用到计算机中，直到1938 年香农在他的硕士论文中指出用布尔代数来实现开关电路，使得布尔代数成为数字电路的基础。所有的数学和逻辑运算，加、减、乘、除、乘方、开方等等，全部能转换成二值的布尔运算。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;用计算的力量改变世界是每一个程序员的梦想，YaK团队抱着对教育的敬仰和热忱，开发了有趣的YaK编程工具以及配套的系统化教学课程。让孩子可以用编程去学习和理解上帝的语言：数学。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前言：人类的历史可以看做一部关于解放的历史。也有这样的说法，懒惰是人类进步的动力。为了偷懒，人类不断的做着各种努力，发明了各种机器工具，将自己从繁重的劳动解放出来，另一方面，每一次大的进步，都需要解放思想，同时也带来了全人类思想的大解放。在这样的历程中，计算机的出现无疑将人类从很多繁重的作业中解放了出来。与此同时，有些人开始思考能否制造出可以像人类一样进行思考的机器，以将人类从创造性的劳动和逻辑思考中解放出来，交给机器去完成。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前面我们看到计算起源的数学思想有莱布尼茨，布尔代数。接下来我们看到其他的数学思想在计算中的运用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.5366795366795367&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAicUNaxMITy8sWNNyxQC8Rk5ezDAoW45WhNFnhkpdkUa4FmzVQI75j4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;259&quot;/&gt;&lt;/p&gt;

&lt;section&gt;&lt;section class=&quot;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;&quot; readability=&quot;1&quot;&gt;&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;弗雷格的突破与绝望&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;弗雷格的一生主要发表了这样三本著作：《概念演算--一种模仿算术语言构造的纯思维的符号语言》（1879）、《算术的基础--对数概念的逻辑数学研究》（1884）《算术的基本规律》（l卷 1893，2卷1903）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其中概念演算，将普通数学中的一切演绎推理都包含在内，成为第一个完备的逻辑体系。布尔以普通代数为基础，用代数符号来表示逻辑关系。与此相反，弗雷格想以他的逻辑为基础而把代数构造出来。实际上这成为日后一个重要的学派&quot;逻辑主义&quot;,在他们看来逻辑与数学的关系就像一门学科的基本部分和高等部分之间的关系。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;弗雷格的逻辑体系，表现在今天就是我们数理逻辑中的命题演算和谓词演算(用数学的方法研究关于推理、证明等问题的学科就叫做数理逻辑。也叫做符号逻辑)。弗雷格第一次用精确的句法构造出形式化的人工语言，使得逻辑推理表示为机械演算即所谓的推理规则成为可能。从这个观点看，概念文字是我们今天使用的计算机程序设计语言的前身。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;弗雷格希望可以自然数提出一种纯粹逻辑的理论，从而证明算术，微积分乃至一切数学都可以看成逻辑的一个分支。于是弗雷格便希望可以用纯逻辑的术语来定义自然数，然后再用他的逻辑导出它们的性质。例如3这个数将被解释为逻辑的一部分。弗雷格的思想是把3定义为所有元素数为3的集合的集合。实际上这就是《算术的基础--对数概念的逻辑数学研究》这部著作的主要内容。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然而正是这样的一些工作，1902年，年轻的伯特兰.罗素据此提出那个著名的罗素悖论。弗雷格的算术使用了集合的集合这样一种概念。罗素指出，用集合的集合进行推理很容易导致矛盾。罗素的悖论可以这样描述：如果一个集合是它自身的一个成员，那么就把集合成为异常的，否则它就是正常的。那么由所有正常集合组成的集合是正常还是异常的呢？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果是正常的，那么它应该包含自身，这样它就应该是异常的。如果是异常的，那么它就不会包含自身，这样它就应该是正常的。无论哪个结果都导致了矛盾。实际上罗素构造这个悖论的方法，与之后哥德尔，图灵构造不可判定命题却有着神似的地方。然而这一矛盾却表明弗雷格构造的算术体系所基于的那些前提是靠不住的，并给弗雷格带来了巨大的打击。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;虽然弗雷格的逻辑已经很完备，但仍然具有一些局限性。他的规则并没有提供判定某个结论能否从给定的前提中推导出来的计算步骤。另外能否找到一种计算方法，它能够说明在弗雷格的逻辑中某一推理是正确的呢？其结果是这样一则证明：没有这样的一般方法存在。然而正是在证明这样一条否定性的结论过程中，阿兰图灵发现原则上可以设计出一种通用机，它可以执行任何可能的计算。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;弗雷格的研究开启语言哲学的大门，后来人们在寻找证明逻辑推理正确性的过程中，图灵发现了通用机，也就是今天计算机的数学模型。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.2037422037422036&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQABiadGicTaBOQ0sHUmPQ0h16xnrJpbPOa7sqyvIicJ8WObgAnexjIV3TxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;481&quot;/&gt;&lt;/p&gt;

&lt;section&gt;&lt;section class=&quot;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;&quot; readability=&quot;1&quot;&gt;&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;康托尔，对无限的探索&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;康托尔进入无限的世界，开始无限的数目的研究。他发现自然数与实数具有不同的基数，以及由此提出的连续统假设，即实数和自然数之间不存在具有其他基数的集合。这也是1900年，希尔伯特提出的23个问题中的第一问题。这个问题直到今天并未完全解决，1938年哥德尔和1963年保罗科恩的重大发现表明，如果连续统假设问题可以被解决，就必须超越普通数学的方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于我们普通人来说，最有用的大概是康托尔在证明实数与自然数基数不同的过程中所采用的对角线方法，这种方法是1891年，康托尔在一篇4页的论文中发表的。而对角线方法，在以后的故事中仍然会被用到，它将会被哥德尔用来解决一致性问题时构造系统内不可证命题，然后阿兰.图灵又再次使用了哥德尔的方法构造出了不可判定命题。而关于连续统假设的研究也引发了关于图灵机的构想。现在我们可以看到康托尔的工作与计算机的起源在这里产生了联系。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;关于对角线方法，我们从自然数集来看，我们可以发现自然数与自然数的子集组成的集合之间具有不同的基数，假设我们把自然数与不同的自然数子集建立一个对应关系，1: M1 2: M2....，采用对角线方法，我们总是可以构造出一个新的自然数集，它没有任何自然数与之对应，我们这样产生这个新的自然数集：如果i属于Mi,那么排除i，否则包含i，容易看到这样产生的一个集合不同于任何的Mi。可见由一切自然数集组成的集合的基数要大于自然数的基数。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;实际上康托尔并不是第一个关注到无限的数目特殊性的人，早在17世纪，莱布尼茨就发现偶数和自然数是一一对应的，正如他所说：对于任何一个数，都存在一个与之对应的偶数，那就是它的二倍。因此所有数的数目并不比偶数的数目更多，也就是说整体没有部分大。但是他得出了这样一个结论：所有自然数的数目这一概念是不一致的，讨论一个无限集中元素的数目是没有意义的。但是康托了选择了另一条路，他承认某些无限集将与它的一个子集具有相同的元素数目。正是基于这样一个大胆的选择，他才创立了关于无限的新理论。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当康托尔提出这些观点之后，立刻引来了各方面的责难。与弗雷格类似，人们发现用康托尔的超限数进行不加限制的推理会导致荒谬的结果。比如如果存在一个由所有基数组成的集合，那么它的基数该是多少呢？它必须比所有基数都大，但一个基数又怎么可能比所有基数都大呢？后来罗素又指出这样的一个问题：是否存在一个所有集合的集合？如果存在，那么倘若把对角线方法应用于它，会出现什么结果？这样我们会得到一个不同于所有那些已经拥有标签的集合的集合。正是在考虑这种情况时，罗素发现他那个关于由一切不是自身的集合组成的集合的著名悖论，也就是他向弗雷格传达的那个悖论。这里我们看到，弗雷格和康托尔之间被罗素悖论联系起来。而关于这个悖论的讨论和思考，则引发了数学史上的第三次危机。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.830703012912482&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQASVK7GJr4NUHstX9AxSnETTua05R55epgeslsnxk650T0tQiajE0xMJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;/p&gt;

&lt;section&gt;&lt;section class=&quot;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;大卫希尔伯特&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;希尔伯特是20世纪的数学领袖，1900年他在数学家大会上指出的23个问题，其中第二个便是关于算术一致性的问题。即關於一個公理系統相容性的問題，也就是判定一個公理系統內的所命題是彼此相容無矛盾的，希爾伯特希望能以嚴謹的方式來證明任意公理系統內命題的相容性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;希尔伯特纲领所提出的主要问题就是算术一致性问题。为了解决这个问题，希尔伯特发展出了元数学，一致性证明将在元数学内部完成。1928年，希尔伯特和他的学生阿克曼出版了一本逻辑课本，书中提出了关于弗雷格&amp;lt;&amp;gt;的基本逻辑(后来被称为一阶逻辑)两个主要问题，一个就是，证明一阶逻辑的完备性，即任何一个从外部看来有效的公式都可以只用课本里提出规则从系统内部导出。第二个问题以希尔伯特的判定问题而闻名，即对于一个一阶逻辑的公式，如果找到一种方法，可以在定义明确有限步骤内判定这个公式是有效的。这两个问题分别为哥德尔和图灵解决，而在解决第二个问题的过程中，图灵提出了图灵机的概念。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;后来在1928年的国际数学家大会上，希尔伯特又提出一个关于形式系统的问题，这个系统建立在把一阶逻辑应用于现在被称为皮亚诺算术或者PA的自然数公理系统的基础之上。希尔伯特希望可以证明PA是完备的，也就是说任何一个可以在PA中表出的命题或者可以在PA中被证明为真，或者可以被证明为假。两年后，这个问题被一个叫哥德尔的年轻人解决了，但答案却完全不像希尔伯特料想的那样。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.510928961748634&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQALkySKlZWC8wymiaS9rCjbbnA56tN5a2FFTvuWHVug6bE3EN4gxV7peA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;366&quot;/&gt;&lt;/p&gt;

&lt;section&gt;&lt;section class=&quot;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;哥德尔完备性定理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;希尔伯特在20世纪20年代介绍了他的元数学纲领：一致性有待证明的公理将被包含在一个形式逻辑系统之内，而证明仅仅是有限数目的符号的一种排列而已。当希尔伯特开始思考希尔伯特纲领时，希尔伯特的学生阿克曼和冯诺依曼似乎正在朝着用有限性方法证明PA的一致性的方向大步迈进。他们二人都已经为PA的一个有限的子系统找到了这样的证明，成功似乎指日可待。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这样哥德尔开始试图将算术一致性还原为PA的一致性，然而就是在这样的努力中失败了。哥德尔开始思考这些问题时，他重新思考了从外部而不是从内部考察一个系统的意思。从外部看，这些系统包含着符号串之间的关系。从内部看，这些系统能够表达关于不同数学对象的命题。哥德尔通过给符号串用自然数编码，将外部带到了内部。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;哥德尔发现存在这样的命题，它们从系统外部看是真命题，但无法在系统内部得到证明。于是他得出了一个非凡结论：一种有意义的数学真理的观念不仅是存在的，而且其范围还超出了任何给定的形式系统的证明能力。在1931年，他发表的论文&amp;lt;及有关系统的形式不可判定命题&amp;gt;&amp;gt;中，他选择对形式系统PM给出了他的结果，从而说明即使强逻辑系统也不可能把全部数学真理包含在内。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在哥德尔的证明中，关键的一步在于他证明了：一个自然数作为PM中可证命题的一个代码，这一性质本身可以在PM中表示出来。根据这一事实，哥德尔可以在PM中构造出一些命题，这些命题可以被看做表达了这样一个断言，即某些命题在PM中是不可证的。也就是说他可以构造出一个命题A，该命题经译码后可以断言某一命题B在PM中是不可证的。现在，在没有获知密码的人看来，命题A不过是一串符号而已，但是通过代码，神秘性就消失了：A表示这样一个命题，即某个符号串B表示在PM中一个不可证的命题。A和B通常是不同的命题，哥德尔问，它们是否有可能是相同的呢？事实上它们可以是相同的，哥德尔可以利用对角线方法证明这个结论。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;运用这些技巧，我们可以使被断言为不可证的命题和做出这一断言的命题是同一个命题。换句话说哥德尔发现了如果获得这样一个非凡的命题，我们将它称之外U，具有如下性质：&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;U说某个特殊命题在PM中不可证。&lt;br/&gt;那个特殊的命题就是U本身。&lt;br/&gt;因此，U说&quot;U在PM中不可证&quot;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;如果我们承认PM中证明的任何命题都是真的，那么我们发现U是真的，但它在PM中不可证。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;U是真的。假定它是假的，那么它表述的内容就是假的，因此它就是不是不可证的，而一定是可证的，从而是真的，这与开始假定U是假的矛盾，所以它一定是真的。因为它是真的，所以它表述的内容为真，所以它在PM中不可证。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们把U称为不可判定命题，当然这种不可判断性只与系统内部的可证性，从我们外部的观点来看U是真的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;另一方面，在PM内部，我们可以证明：如果PM是一致的，那么U。因此正是PM是一致的这一个假定，才使U在PM内部得不到证明。既然我们知道U在PM内部是不可证的，我们就必须得出结论说，PM的一致性在PM中不可证。而希尔伯特的主要目的就在于：用于被认为构成PM的一个非常有限的子集的有限性方法来证明像PM这样的系统的一致性。然而哥德尔证明了，即使就PM的全部能力而言，它也不足以证明自身的一致性。于是希尔伯特纲领走到了尽头。&lt;/span&gt;&lt;/p&gt;

&lt;section&gt;&lt;section class=&quot;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;图灵和图灵机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在哥德尓1930年的博士论文中证明了弗雷格的规则是完备的，这样就回答了希尔伯特1928年提出的第一个问题。而第二个问题即判定问题，在哥德尔的工作发表之后，人们很难想象存在这样的判定算法，于是阿兰图灵开始思考如果证明这样的算法是不存在的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;图灵采取了这样的一条道路，他首先分析了人的计算过程。通过丢掉非本质的细节，将这些计算活动局限在少数几种极为简单的基本操作上。然后图灵说明人可以被一个能够执行这些基本操作的机器所替代。然后只要证明仅仅执行那些基本操作的机器不可能判定一个给定的结论是否可以用弗雷格的规则从给定的前提中导出，这样他就能够下结论说，判定问题的算法是不存在的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;作为副产品，他对计算过程的分析，产生了通用计算机的一个数学模型。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;他观察到：在计算的每一个阶段，只有少数符号受到了注意。每一个阶段所采取的行动仅仅取决于受到注意的那些符号以及当前的心灵状态。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后他做出了如下抽象：计算通过在一条被划分成方格的纸带上写下符号来进行。执行计算的人在每一步都只注意其中一个方格的符号。她的下一步将仅仅取决于这个符号和她的心灵状态。她的下一步是这样的：她在当前注意的方格里写下一个符号，然后将注意力转向它左边或者右边的相邻符号。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在可以很容易看出，做这项工作的人可以用一个机器替代，纸带在机器上来回移动。关键之处在于图灵对于计算概念的分析，通过某种算法程序可计算的任何东西都可以通过一台图灵机来计算。因此如果我们可以证明某些任务无法用图灵机完成，那么我们就可以说没有任何算法可以完成这项任务。这就是图灵证明判定问题不存在算法的方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;实际上一台图灵机可以用这样的一个五元组来表示：当机器处于状态R，注视纸带上的符号a时，它将用b来代替a，向右移动一个方格，然后转到状态S。而一个具体的算法便可以由这些五元组表示的状态转换的集合组成的图灵机来表示出来。R a:b -&amp;gt; S 或者R a:b&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;图灵将对角线方法应用于这种情况，得到了图灵机不能解决的问题，由此推出了判定问题的不可解性。与哥德尓类似，图灵采用了对角线方法也对图灵机通过自然数进行了编码。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;图灵机本身可以是自然数编码表示，这样它也作为自身的输入。实际上有些输入会使图灵机停止下来，另一些则不会。这样一台图灵机就具有一些停机集合。如果我们考虑把一台图灵机的停机集合组成了一个包裹，并且认为那台机器的码数就是这个包裹的标签。对角线方法允许我们构造出一个与图灵机的任何停机集合都不同的自然数集合，我们称之为D。方法是这样的，我们考虑把图灵机的编码作为自身的输入，如果它的编码数不属于自身的停机集合，那么我们就把它加入D。而集合D则不是任何图灵机的停机集合。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后考虑这样一个问题：&lt;br/&gt;找到一种算法，判定一个给定的自然数是否属于集合D。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这就是一个不可解问题的例子。首先如果存在这样的一个算法，我们就能找到这样的一个图灵机，但是我可以改造一下这个图灵机，把以下两个五元组加入到这个图灵机：F 0:口-&amp;gt; F 和 F 口:口-&amp;gt; F。对于这个新的改进的图灵机来说，如果输入的数属于D那么那么机器就会像以前一样运转，并输出1而告终，如果输入的数不属于D，那这台机器将永远向右移动。这样我们就找到了一台图灵机它的停机集合刚好就是D。于是与我们的对角线方法矛盾。所以并不存在这样的一个算法。由此可知判断问题在算法上是不可解的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;为了验证自己工作的有效性，图灵又提出了通用机模型，通用机包含了图灵机代码以及待处理的数据。而这刚好对应着我们今天的机器，程序与数据的概念。也为存储程序计算机提供了一个模型。正是图灵在证明判定问题的不可解性是，对计算概念的分析以及对通用机的发现促使了计算机的产生。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1945年图灵又发表了他那篇著名的ACE(自动计算机)报告。这是对计算机的一次完整的描述，一直到逻辑电路图。也就是在这时冯诺依曼提出了他著名的&quot;关于EDVAC的报告草案&quot;，它实际上主张将要建造的EDVAC作为图灵通用机的一个物理模型实现出来。在这个报告里，提出了存储程序的概念，也就是沿用至今的冯诺依曼结构，实际上它的革命性不在于存储程序而是通用性，存储程序只是达到这一目的的一种手段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1950年，图灵又发表了他的经典论文，计算机与智能，提出了著名的图灵测试来测试计算机是否具有智能。1954年6月7日，图灵咬了一个浸过氰化物的苹果，结束了自己的生命。而他的通用机思想却延续到今天。&lt;/span&gt;&lt;/p&gt;
&lt;section data-style=&quot;white-space: normal; text-align: left;font-size: 14px;line-height: 1.5em; color: rgb(12, 12, 12);&quot;&gt;&lt;p&gt;&lt;span&gt;∑编辑 | Gemini&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;来源 | YK芽课&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section data-style=&quot;white-space: normal; text-align: left;font-size: 14px;line-height: 1.5em; color: rgb(12, 12, 12);&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.9366666666666666&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/951TjTgiabkwJ4BpvBcQhGAbtWZZvV69s7GickZGibsKgYkTQkiaZfLYOmGS9iaaoibadibGJhT18OVZkfeJmCSUSD0zw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot; width=&quot;auto&quot;/&gt;&lt;/p&gt;
&lt;/section&gt;&lt;p&gt;&lt;span&gt;算法数学之美微信公众号欢迎赐稿&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;稿件涉及数学、物理、算法、计算机、编程等相关领域&lt;br/&gt;稿件一经采用，我们将奉上稿酬。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;投稿邮箱：math_alg@163.com&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Mar 2018 18:49:41 +0000</pubDate>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.jintiankansha.me/t/U7GnYqw6Uj</dc:identifier>
</item>
<item>
<title>开学啦！你还焦躁吗？</title>
<link>http://www.jintiankansha.me/t/jAb7BcoYjT</link>
<guid isPermaLink="true" >http://www.jintiankansha.me/t/jAb7BcoYjT</guid>
<description>&lt;p line=&quot;YrKa&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;给你讲个鬼故事：开学啦！👻👻👻&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;gallery-image&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;310&quot; data-height=&quot;500&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/951TjTgiabky9IKf4rFYzrT2dGUFsBjQA5H69pqrib72D6pTicYkDXx3aRgqWH8Y2y6X91ROZaRnDVA0Mg907jVyA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot; data-width=&quot;900&quot; height=&quot;249&quot; width=&quot;458&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p line=&quot;Ar5Q&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;“开学”不单单是学生党的噩梦，越来越多的教育培训机构也因为开学季叫苦不迭，经过小编的深度调查，他们的烦恼主要分为以下两种：&lt;/span&gt;&lt;/p&gt;
&lt;p line=&quot;Qj2z&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;什么都别说～&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;gallery-image&quot; data-height=&quot;213.993px&quot; data-ratio=&quot;0.7133333333333334&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAhelJAtpYFW6ngTocdSiaviavNaUSecBObQDyAu3XkRNjhBthxGQ6AIVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot; data-width=&quot;300px&quot; height=&quot;213.993px&quot; width=&quot;300px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p line=&quot;3KAR&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;拯救教育培训机构不开心，今天为大家分享纯纯的干货！&lt;/span&gt;&lt;/p&gt;
&lt;p line=&quot;Qhmg&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;&lt;strong class=&quot;ql-size-12&quot;&gt;小编调研了新东方，学而思，巨人等国内知名教育机构，他们的招生宣传、报名和教学管理的高效秘诀，打包奉上！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;section class=&quot;RankEditor&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.2280701754385965&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAHxFfxoJnVH1OQuCyTjhMahhqUrdSibmqjJcEp0u13uy6sUgIJWOfgfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;57&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p class=&quot;title active&quot;&gt;&lt;strong&gt;招生获客&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.2280701754385965&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAGQicTy2aD7Wu4fnGT0xJNTpib2A5R3QZQ486dicgEiaNSkia2iccWH9KCgrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;57&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;p line=&quot;hVV2&quot; class=&quot;ql-long-6874420 ql-align-center&quot;&gt;&lt;span&gt;你以为大机构的招生获客方式是街头发传单“游泳健身了解一下”？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img class=&quot;gallery-image&quot; data-height=&quot;auto&quot; data-ratio=&quot;0.4230769230769231&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAoDOkkJwd9PtDSbLFIURappZJEm0hFwuhNIrU2HbpsVwbDpZUPCn7DQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;988&quot; data-width=&quot;auto&quot; height=&quot;auto&quot; width=&quot;auto&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p line=&quot;GBv6&quot; class=&quot;ql-long-6874420 ql-align-justify&quot;&gt;&lt;span&gt;或单纯斥资千万地铁大面积投广告？&lt;/span&gt;&lt;/p&gt;
&lt;p line=&quot;vPpZ&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;&lt;strong class=&quot;ql-size-12&quot;&gt;Naive！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p line=&quot;ytVz&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;其实，让学员、家长们挤破头的秘密只有一个：&lt;strong class=&quot;ql-size-12&quot;&gt;超出预期的奖励！&lt;/strong&gt;如&lt;strong class=&quot;ql-size-12&quot;&gt;免费听课&lt;/strong&gt;，&lt;strong class=&quot;ql-size-12&quot;&gt;免费送资料包&lt;/strong&gt;等。&lt;/span&gt;&lt;/p&gt;
&lt;p line=&quot;hxyH&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;这方面，罗老师用过的套路一级棒棒！&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img class=&quot;gallery-image&quot; data-height=&quot;233.976px&quot; data-ratio=&quot;0.5&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAl4rODAIC54nFIDgrmYmh6J0e7UwKyNoE37iamvP8SKE8qibsRTvzqHUw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;468&quot; data-width=&quot;467.986px&quot; height=&quot;233.976px&quot; width=&quot;467.986px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p line=&quot;czT0&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;当年老罗英语培训&lt;strong class=&quot;ql-size-12&quot;&gt;「1块钱听8节课」&lt;/strong&gt;的现象级招生案例，到现在大家还啧啧称道！&lt;/span&gt;&lt;/p&gt;
&lt;p line=&quot;S34R&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;不过，若&lt;strong class=&quot;ql-size-12&quot;&gt;用表单实现微信裂变，招生效果或成倍放大！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p line=&quot;Oka4&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;    ……&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img class=&quot;gallery-image&quot; data-height=&quot;317px&quot; data-ratio=&quot;0.6703703703703704&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAXWFfBC5DtdYYKhtKFmKnbTuBg8zVbuDrHWy6bl8XytR6c5O1szIXGg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-width=&quot;474px&quot; height=&quot;278&quot; width=&quot;462&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p line=&quot;n1Yi&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;不用大街小巷发传单，也不用投户外广告，一张在微信中&lt;strong class=&quot;ql-size-12&quot;&gt;指数级传播&lt;/strong&gt;的&lt;strong class=&quot;ql-size-12&quot;&gt;在线表单&lt;/strong&gt;，就能全部搞定。&lt;/span&gt;&lt;/p&gt;


&lt;section class=&quot;RankEditor&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.2280701754385965&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAHxFfxoJnVH1OQuCyTjhMahhqUrdSibmqjJcEp0u13uy6sUgIJWOfgfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;57&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p class=&quot;title active&quot;&gt;&lt;strong&gt;免费试听&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.2280701754385965&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAGQicTy2aD7Wu4fnGT0xJNTpib2A5R3QZQ486dicgEiaNSkia2iccWH9KCgrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;57&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p line=&quot;TAKV&quot; class=&quot;ql-long-6874420 ql-align-center&quot;&gt;&lt;span&gt;只需要花3分钟做一张名师课程试听报名表。物以稀为贵，你可以用&lt;/span&gt;&lt;strong&gt;&lt;span&gt;「选项名额」&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;来营造一课难求的火爆！&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img class=&quot;gallery-image&quot; data-height=&quot;auto&quot; data-ratio=&quot;0.8194444444444444&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAw0Fu2nvs3Mlt9yasbJxc22aAVxdaHg8CibAfBbfCmSFxUOGWyvqoHOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-width=&quot;auto&quot; height=&quot;auto&quot; width=&quot;auto&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p line=&quot;m2ZK&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;当然，插入学校介绍、微信二维码、课程链接，甚至是插入一段课程介绍视频，生动地展示课程信息，引导学生浏览官方课程详情网页，关注学校微信公众号。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;&lt;img class=&quot;gallery-image&quot; data-height=&quot;auto&quot; data-ratio=&quot;0.692588092345079&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAUoeSFuT7iaFljeBPf6lUPymDfQ4geT8bWicvw6345cpqzvq0BeaSiahEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;823&quot; data-width=&quot;auto&quot; height=&quot;297&quot; width=&quot;462&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p line=&quot;laMd&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;教材领取表也可以复制上面的套路。&lt;/span&gt;&lt;/p&gt;


&lt;section class=&quot;RankEditor&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.2280701754385965&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAHxFfxoJnVH1OQuCyTjhMahhqUrdSibmqjJcEp0u13uy6sUgIJWOfgfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;57&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p class=&quot;title active&quot;&gt;优惠码&lt;/p&gt;
&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.2280701754385965&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAGQicTy2aD7Wu4fnGT0xJNTpib2A5R3QZQ486dicgEiaNSkia2iccWH9KCgrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;57&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;毕竟熟人的安利最可信嘛～「推荐学员可享受*元课程优惠」可以说是招生利器！&lt;br/&gt;&lt;/p&gt;
&lt;p line=&quot;XPgm&quot; class=&quot;ql-long-6874420&quot; linespacing=&quot;150&quot;&gt;&lt;span&gt;制作代表一定面额的「优惠码」，对于推荐了新学员的老学员发放优惠码，即可在报名表单通过输入优惠码享受到课程优惠。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;gallery-image&quot; data-height=&quot;810&quot; data-ratio=&quot;0.5720338983050848&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAeqD1awfx4KNGbuwviaiaDaDFy9NJW9lg3bfcv5DX2JXQHnaibDicyhFKVQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1416&quot; data-width=&quot;1416&quot; height=&quot;250&quot; width=&quot;462&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p line=&quot;oAgz&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;别说我没提醒你，收集到的数据可都是财富，上面的各种表单获取潜在客户的真实信息，并进行后续的客户追踪，那些没报名的用户才是最有潜力的。&lt;/span&gt;&lt;/p&gt;
&lt;p line=&quot;FlZg&quot; class=&quot;ql-long-6874420 ql-align-center&quot;&gt;&lt;span&gt;&lt;strong class=&quot;ql-size-14&quot;&gt;教学管理系统&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p line=&quot;LBvY&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;“学员即客户”，服务好你的客户，让他们拥有非凡学习体验，才能产生从成绩到口碑再到收入一系列正面影响。&lt;/span&gt;&lt;/p&gt;
&lt;p line=&quot;aRAg&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;想要知道学员的到课率；想对学员进行在线考试测试，以及试题解析、成绩查询；将学员成绩发短信通知家长；教师授课反馈表......&lt;/span&gt;&lt;/p&gt;
&lt;p line=&quot;ibJW&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;这些“家教式”的教学管理系统，就是你和大机构的差距。&lt;/span&gt;&lt;/p&gt;

&lt;section class=&quot;RankEditor&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.2280701754385965&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAHxFfxoJnVH1OQuCyTjhMahhqUrdSibmqjJcEp0u13uy6sUgIJWOfgfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;57&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p class=&quot;title active&quot;&gt;线上签到&lt;/p&gt;
&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.2280701754385965&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAGQicTy2aD7Wu4fnGT0xJNTpib2A5R3QZQ486dicgEiaNSkia2iccWH9KCgrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;57&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p line=&quot;jSnk&quot; class=&quot;ql-long-6874420 ql-align-center&quot;&gt;&lt;span&gt;想知道同学们的到课率，你需要这样一个简单的「签到」系统，将报名学员数据当做花名册一样来签到。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p line=&quot;5nwS&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;现场扫码就能完成一秒签到&lt;/span&gt;&lt;span&gt;，后台还能看到实时更新的数据。简直是老师的福音，学生的噩梦～&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img class=&quot;gallery-image&quot; data-height=&quot;737&quot; data-ratio=&quot;0.6824074074074075&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/951TjTgiabky9IKf4rFYzrT2dGUFsBjQALbiaJGMrdWHBfSUpQ2HIHQkXxM5SgyynFYenlnzDKysurFwjH4iaVaDA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-width=&quot;1080&quot; height=&quot;287&quot; width=&quot;406&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;RankEditor&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.2280701754385965&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAHxFfxoJnVH1OQuCyTjhMahhqUrdSibmqjJcEp0u13uy6sUgIJWOfgfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;57&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p class=&quot;title active&quot;&gt;在线考试&lt;/p&gt;
&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.2280701754385965&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAGQicTy2aD7Wu4fnGT0xJNTpib2A5R3QZQ486dicgEiaNSkia2iccWH9KCgrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;57&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 class=&quot;ql-long-6874420&quot;/&gt;
&lt;p&gt;只需在表单中导入题目，再配合「在线考试」应用，一个考试系统就搭建好啦！&lt;/p&gt;
&lt;p line=&quot;I1SA&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;支持&lt;strong class=&quot;ql-size-12&quot;&gt;答题计时、自动判分、查看答案解析、提交之后显示评语&lt;/strong&gt;等功能，办一场线上考试就是这么简单！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;gallery-image&quot; data-height=&quot;321.406px&quot; data-ratio=&quot;0.5259259259259259&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/951TjTgiabky9IKf4rFYzrT2dGUFsBjQACBia8a1d0e0icqo23VrmHNhqSml1nQMwXaDU3KPFtibjSpnXIhsEfP83g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-width=&quot;611px&quot; height=&quot;272&quot; width=&quot;461&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;section class=&quot;RankEditor&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.2280701754385965&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAHxFfxoJnVH1OQuCyTjhMahhqUrdSibmqjJcEp0u13uy6sUgIJWOfgfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;57&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p class=&quot;title active&quot;&gt;成绩查询&lt;/p&gt;
&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.2280701754385965&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAGQicTy2aD7Wu4fnGT0xJNTpib2A5R3QZQ486dicgEiaNSkia2iccWH9KCgrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;57&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p line=&quot;dguU&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;你还可以在考试结束后，对表单数据设置可「查询」，学员只需要输入姓名或者其他身份信息就可以查询考试成绩了！高考、四六级成绩查询也就这个级别了吧～&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img class=&quot;gallery-image&quot; data-height=&quot;319.5px&quot; data-ratio=&quot;0.5231481481481481&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/951TjTgiabky9IKf4rFYzrT2dGUFsBjQACIhwL9FcU70ApGuicmGSwluykxuYW46VcGbIRIeKicbM8aExk2TLricibA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-width=&quot;611px&quot; height=&quot;265&quot; width=&quot;447&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p line=&quot;iPcm&quot; linespacing=&quot;150&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;span&gt;以上这些功能，不需要几千万的广告投入，也不需要专属的开发团队，更不需要大量的人力成本，一个小小的表单工具，就能满足这么多教育培训行业的需求。&lt;/span&gt;&lt;/p&gt;

&lt;p line=&quot;OJb3&quot; class=&quot;ql-long-6874420&quot;&gt;&lt;ins class=&quot;adsbygoogle&quot; data-ad-layout=&quot;in-article&quot; data-ad-format=&quot;fluid&quot; data-ad-client=&quot;ca-pub-1837452791782084&quot; data-ad-slot=&quot;7041996284&quot;/&gt; &lt;span&gt;&lt;strong&gt;金数据有网页版，app，小程序等多种路径，长按扫码快速体验金数据小程序。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.32130903681666045&quot; data-src=&quot;http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/951TjTgiabky9IKf4rFYzrT2dGUFsBjQAOeUnBAOuVd7vPOxLt9eIcUS6TicJhKibraUk1lwHoWYLia8NzwicacDwww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2689&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;偷偷告诉你，小编调研的这几家知名机构都在用呢，再不学起来生源都被他们抢走啦！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 15 Mar 2018 18:49:40 +0000</pubDate>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.jintiankansha.me/t/jAb7BcoYjT</dc:identifier>
</item>
</channel>
</rss>