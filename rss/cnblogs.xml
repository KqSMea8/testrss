<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【Webpack的使用指南 01】Webpack入门 - 韩子卢</title>
<link>http://www.cnblogs.com/vvjiang/p/8567909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vvjiang/p/8567909.html</guid>
<description>[unable to retrieve full-text content]使用Webpack有一段时间了，但是感觉之前学的用的都比较零散，所以在这里整理一下Webpack的使用知识，从入门到进阶。 创建项目 首先创建最简单的一个项目 npm init 得到以下项目结构： 安装Webpack 先来个全局的 npm i webpack g 再安装项目中的 npm i webp</description>
<pubDate>Wed, 14 Mar 2018 07:28:00 +0000</pubDate>
<dc:creator>韩子卢</dc:creator>
<dc:identifier>http://www.cnblogs.com/vvjiang/p/8567909.html</dc:identifier>
</item>
<item>
<title>整合了一个命令行程序的框架 - 陈宏博</title>
<link>http://www.cnblogs.com/huaface/p/8567904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huaface/p/8567904.html</guid>
<description>[unable to retrieve full-text content]背景 最近工作中写了N多个命令行程序跑数据.每新建一个项目就要引用各种包,各种配置.所以有了这个整合包.其实不能算是框架吧,没写什么代码,几乎就是引用一些包. 代码 GitHub: https://github.com/lun3322/Luna.Service NuGet1: Install Pac</description>
<pubDate>Wed, 14 Mar 2018 07:27:00 +0000</pubDate>
<dc:creator>陈宏博</dc:creator>
<dc:identifier>http://www.cnblogs.com/huaface/p/8567904.html</dc:identifier>
</item>
<item>
<title>ubuntu 14.04 下实现浏览器接收UDP视频流 - 考拉小无</title>
<link>http://www.cnblogs.com/wpqwpq/p/8567847.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wpqwpq/p/8567847.html</guid>
<description>[unable to retrieve full-text content]前言 由于近期项目需求，需实现在浏览器上实时预览接收UDP视频流信息。此功能若在VLC上可轻松播放，奈何由于Chrome、Firefox版本的升级，渐渐浏览器不支持外部插件，因而使用VLC web插件也成为泡影。在前辈指导下，采用 FFmpeg + SRS + ckplayer 的方式实现了该功能。</description>
<pubDate>Wed, 14 Mar 2018 07:21:00 +0000</pubDate>
<dc:creator>考拉小无</dc:creator>
<dc:identifier>http://www.cnblogs.com/wpqwpq/p/8567847.html</dc:identifier>
</item>
<item>
<title>Redis进阶实践之十七 Redis协议的规范 - PatrickLiu</title>
<link>http://www.cnblogs.com/PatrickLiu/p/8567453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/8567453.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;            Redis客户端使用称为RESP（Redis的序列化协议）的协议与Redis服务器进行通信。 虽然协议是专门为Redis设计的，但它可以用于其他客户端 - 服务器软件项目。&lt;/p&gt;&lt;p&gt;            RESP是对以下几点事情的折中：&lt;/p&gt;&lt;p&gt;                1、实现简单&lt;/p&gt;&lt;p&gt;                2、解析快速&lt;/p&gt;&lt;p&gt;                3、人类可读&lt;/p&gt;&lt;p&gt;            RESP可以序列化不同的数据类型，如整数，字符串，数组。还有一个特定类型的错误。请求将作为表示要执行的命令的参数的字符串数组从客户端发送到Redis服务器。Redis以命令特有的数据类型作为回复。&lt;/p&gt;&lt;p&gt;            RESP是二进制安全的，不需要处理从一个进程传输到另一个进程的批量数据，因为它使用前缀长度来传输批量数据。&lt;/p&gt;&lt;p&gt;            注意：此处概述的协议仅用于客户端 - 服务器通信。 Redis集群使用不同的二进制协议来交换节点之间的消息。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、Redis协议的详解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;          要想更好的使用Redis，如果没有对Redis的协议格式不了解，要想使用精通恐怕很难，现在我们就来看看Redis的协议是何许人也。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;          1、网络层（Networking layer）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                         客户端连接到Redis服务器，创建到端口6379的TCP连接。&lt;/p&gt;&lt;p&gt;                         尽管RESP在技术上是非TCP专用的，但在Redis的环境中，该协议仅用于TCP连接（或类似于Unix套接字的面向流的连接）。&lt;/p&gt;&lt;p&gt;            &lt;span&gt;&lt;strong&gt;2、请求-响应模型（Request-Response model）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                       Redis接受由不同参数组成的命令。 一旦接收到命令，它就会被处理并且发送响应回客户端。&lt;/p&gt;&lt;p&gt;                       这是最简单的模式，但有两个例外：&lt;/p&gt;&lt;p&gt;                             1、Redis支持管道操作（稍后会在本文档中介绍）。所以客户可以一次发送多个命令，稍后等待回复。&lt;/p&gt;&lt;p&gt;                             2、当Redis客户端订阅 Pub/Sub模式的通道时，协议会改变语义变成推送协议，也就是说，客户端不再需要发送命令，因为服务器一旦收到消息就会自动向客户端发送该新消息（对于订阅了通道的客户端）。&lt;/p&gt;&lt;p&gt;                        除了上述两个例外，Redis协议就是一个简单的 请求-响应 协议。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;             3、RESP协议描述（RESP protocol description）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                        RESP协议在Redis 1.2版本中引入，但它已成为在Redis 2.0版本中与Redis服务器沟通的标准方式。这是您应该在Redis客户端中实现的协议。&lt;/p&gt;&lt;p&gt;                        RESP实际上是一个支持以下数据类型的序列化协议：简单字符串，错误，整数，批量字符串和数组。&lt;/p&gt;&lt;p&gt;                        在Redis中,RESP用作 请求-响应 协议的方式如下：&lt;/p&gt;&lt;p&gt;                            1、客户端将命令作为批量字符串的RESP数组发送到Redis服务器。&lt;/p&gt;&lt;p&gt;                            2、服务器回复一个根据命令实现RESP类型。&lt;/p&gt;&lt;p&gt;                        在RESP中，某些数据的类型取决于第一个字节：&lt;/p&gt;&lt;p&gt;                            1、对于简单字符串，回复的第一个字节是“+”&lt;/p&gt;&lt;p&gt;                            2、对于错误，回复的第一个字节是“ - ”&lt;/p&gt;&lt;p&gt;                            3、对于整数，回复的第一个字节是“：”&lt;/p&gt;&lt;p&gt;                            4、对于批量字符串，回复的第一个字节是“$”&lt;/p&gt;&lt;p&gt;                            5、对于数组，回复的第一个字节是“*”&lt;/p&gt;&lt;p&gt;                    此外，RESP能够使用后面指定的 Bulk Strings 或Array 的特殊变体来表示空值。&lt;/p&gt;&lt;p&gt;                    在RESP中，协议的不同部分始终以“\r\n”（CRLF）结尾。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;      4、RESP简单字符串（RESP Simple Strings）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                   简单字符串按以下方式编码：以+（加号字符）开始，后跟一个不能包含CR或LF字符的字符串（不允许换行符），以CRLF（即“\r\n”）结尾。&lt;/p&gt;&lt;p&gt;                   简单字符串用于以最小开销传输非二进制安全的字符串。例如，许多Redis命令在成功时回复“OK”，因为RESP Simple String使用以下5个字节进行编码：&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;                  为了发送二进制安全的字符串，需要使用RESP Bulk Strings。&lt;/p&gt;&lt;p&gt;                  当Redis以简单字符串回复时，客户端库应该返回给调用者一个由'+'后的第一个字符组成的字符串，直到字符串结尾，不包括最终的CRLF字节。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;      5、RESP错误（RESP Errors）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                  RESP协议针对错误具有特定数据类型表示。实际上，错误与RESP Simple Strings完全相同，但第一个字符是减号' - '而不是加号。简单字符串和RESP错误之间的真正区别在于错误被客户端视为异常，而组成错误类型的字符串本身就是错误信息。&lt;/p&gt;&lt;p&gt;                  基本格式是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
              &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-Error message\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                  错误回复仅在发生错误时发送，例如，如果您尝试针对错误的数据类型执行操作，或者命令不存在等等。 当收到错误应答时，客户端就应该抛出一个异常。&lt;/p&gt;&lt;p&gt;                  以下是错误回复的示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
             -ERR unknown command &lt;span&gt;'&lt;/span&gt;&lt;span&gt;foobar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
             -WRONGTYPE Operation against a key holding the wrong kind of value
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                  “ - ”之后的第一个单词，直到第一个空格或换行符，表示返回的错误种类。这只是Redis使用的一种约定，并不是RESP错误格式的一部分。&lt;/p&gt;&lt;p&gt;                  例如，ERR是通用错误，而WRONGTYPE是一个更具体的错误，意味着客户端试图针对错误的数据类型执行操作。 这被称为错误前缀，并且是一种允许客户端了解服务器返回的错误类型而不依赖于给定的确切消息的方式，该消息可能随时间而改变。&lt;/p&gt;&lt;p&gt;                  客户端实现可能会针对不同的错误返回不同类型的异常，或者可能会提供一种通用方法来通过直接将错误名称作为字符串提供给调用者来捕获错误。&lt;/p&gt;&lt;p&gt;                  然而，这样的功能不应该被认为是至关重要的，因为它很少有用，而针对客户端有限的实现来说可能仅仅返回一个通用错误条件，例如 false 。&lt;br/&gt;           &lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;      6、RESP整数（RESP Integers）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                 这种以“：”字节为前缀，并且只是以一个CRLF终止字符串的类型就表示是整数。 例如“：0\r\n”或“：1000\r\n”是整数回复。&lt;/p&gt;&lt;p&gt;                 许多Redis命令返回RESP整数，如 INCR，LLEN 和 LASTSAVE。&lt;/p&gt;&lt;p&gt;                 返回的整数没有特殊含义，它只是INCR的增量数，LASTSAVE的UNIX时间等等。但是，返回的整数保证位于有符号的64位整数范围内。&lt;/p&gt;&lt;p&gt;                 整数回复也广泛用于返回true或false。例如像 EXISTS 或 SISMEMBER 这样的命令将返回1为真，0为假。&lt;/p&gt;&lt;p&gt;                 其他命令如 SADD，SREM 和 SETNX 将在实际执行操作时返回1，否则返回0。&lt;/p&gt;&lt;p&gt;                 以下命令将回复一个整数回复：SETNX，DEL，EXISTS，INCR，INCRBY，DECR，DECRBY，DBSIZE，LASTSAVE，REINENX，MOVE，LLEN，SADD，SREM，SISMEMBER，SCARD。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;      7、RESP大容量字符串（RESP Bulk Strings）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                  大容量字符串用于表示长达512 MB的单个二进制安全字符串。&lt;/p&gt;&lt;p&gt;                  &lt;strong&gt;大容量字符串按以下方式编码：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                       1、一个以“$”字节开始，后面是组成字符串的字节数（前缀长度），由CRLF终止。&lt;/p&gt;&lt;p&gt;                        2、实际的字符串数据。&lt;/p&gt;&lt;p&gt;                       3、最终的CRLF。&lt;/p&gt;&lt;p&gt;                    所以字符串“foobar”被编码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$6\r\nfoobar\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                   当一个空字符串只是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$0\r\n\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                 还可以使用RESP Bulk Strings 的特殊格式来表示空值。在这种特殊的格式中，长度是-1，并且没有数据，所以空值表示为：&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;                 这被称为Null Bulk String（空的大字符串）。&lt;/p&gt;&lt;p&gt;                 当服务器使用空字符串进行回复时，客户端库API不应该返回空字符串，而是返回一个nil对象。例如，Ruby库应该返回'nil'，而C库应该返回NULL值（或者在应答对象中设置一个特殊的标志），等等。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;      8、RESP数组（RESP Arrays）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                 Redis客户端使用RESP数组发送命令到Redis服务器。同样，某些Redis命令使用 RESP数组 作为回复类型 将元素集合返回给客户端。一个例子是返回列表元素的LRANGE命令。&lt;/p&gt;&lt;p&gt;                 RESP数组使用以下格式发送：&lt;/p&gt;&lt;p&gt;                        1、一个 * 字符作为第一个字节，后面跟着一个十进制的数字，该数字是数组中元素的个数，然后是CRLF。&lt;/p&gt;&lt;p&gt;                        2、Array的每个元素都有一个额外的RESP类型。&lt;/p&gt;&lt;p&gt;                  所以一个空的Array只是以下内容：&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;                   虽然两个RESP批量字符串“foo”和“bar”的数组编码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                   正如您看到的那样， * &amp;lt;count&amp;gt; CRLF 部分作为数组的前缀，组成数组的其他数据类型只是依次连接在一起。例如，一个三个整数的数组编码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*3\r\n:1\r\n:2\r\n:3\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                   数组可以包含混合类型，元素之间不必是同一类型的。例如，一个四个整数和一个字符串块的列表可以编码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               *&lt;span&gt;5&lt;/span&gt;&lt;span&gt;\r\n
               :&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\r\n
               :&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;\r\n
               :&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;\r\n
               :&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;\r\n
               $&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;\r\n
               foobar\r\n&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                   （为了清楚起见，应答内容分为多行）。&lt;/p&gt;&lt;p&gt;                    服务器发送的第一行是 *5\r\n，以指定接下来的五个回复。然后，构成多批量回复的项目的每个回复都被传送。&lt;/p&gt;&lt;p&gt;                    Null数组的概念也存在，并且是指定Null值的替代方法（通常使用Null Bulk String，但由于历史原因，我们有两种格式）。&lt;/p&gt;&lt;p&gt;                    例如，当BLPOP命令超时时，它会返回一个空数组，其计数为-1，如下例所示：&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;                   当Redis使用空数组响应时，客户端库API应返回空对象而不是空数组。这是区分空列表和不同条件（例如BLPOP命令的超时条件）所必需的。&lt;/p&gt;&lt;p&gt;                   在RESP协议中也有可能存在数组的数组。例如，两个数组的数组编码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
                *&lt;span&gt;2&lt;/span&gt;&lt;span&gt;\r\n

                &lt;/span&gt;*&lt;span&gt;3&lt;/span&gt;&lt;span&gt;\r\n
                :&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\r\n
                :&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;\r\n
                :&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;\r\n

                &lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;\r\n
                &lt;/span&gt;+&lt;span&gt;Foo\r\n
                &lt;/span&gt;-Bar\r\n
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;                   （回复内容被分成多行，并加了空行，只是为了阅读方便）。&lt;/p&gt;&lt;p&gt;                    上述RESP数据类型的编码表示了一个包含两个数组元素的数组，一个是包含三个整数1,2,3的一个数组，另一个是包含一个简单字符串和一个错误组成的两个元素的数组。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;      9、数组中的空元素（Null elements in Arrays）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                  数组中的单个元素可能为空。这用于Redis回复中，以表示这些元素缺失并且不是空的字符串。当SORT命令使用GET模式选项时，如果缺少指定的键，可能会发生这种情况。 包含Null元素的Array回复的示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
                *&lt;span&gt;3&lt;/span&gt;&lt;span&gt;\r\n
                $&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;\r\n
                foo\r\n
                $&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\r\n
                $&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;\r\n
                bar\r\n&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                 第二个元素是空值。 客户端库应该返回如下所示的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
                [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,nil,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                   请注意，这不是前面章节中所述的异常情况，而只是进一步指定协议的一个示例。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;        10、将命令发送到Redis服务器（Sending commands to a Redis Server）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                    现在您已经熟悉RESP序列化格式，编写Redis客户端库的实现将很容易。我们可以进一步指定客户端和服务器之间的交互如何工作：&lt;/p&gt;&lt;p&gt;                          1、客户端向Redis服务器发送仅包含Bulk Strings的RESP数组。&lt;/p&gt;&lt;p&gt;                          2、Redis服务器回复发送任何有效的RESP数据类型作为客户端的回复。&lt;/p&gt;&lt;p&gt;                    例如，一个典型的交互可能是如下这样。&lt;/p&gt;&lt;p&gt;                    客户端发送命令 LLEN mylist以获取存储在键名为mylist中的列表的长度，并且服务器以如下例子回复一个整数应答（C：是客户端，S：服务器）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
                C: *&lt;span&gt;2&lt;/span&gt;&lt;span&gt;\r\n
                C: $&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;\r\n
                C: LLEN\r\n
                C: $&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;\r\n
                C: mylist\r\n

                S: :&lt;/span&gt;&lt;span&gt;48293&lt;/span&gt;\r\n
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                     通常我们将协议的不同部分用换行符分开，但实际的交互是客户端作为一个整体发送 *2\r\n$4\r\nLLEN\r\n$6\r\nmylist\r\n。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;         11、多个命令和管道（Multiple commands and pipelining）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                     客户端可以使用相同的连接来发出多个命令。支持管道操作，因此客户端可以使用单个写入操作发送多个命令，而无需在发出下一条命令之前读取先前命令的服务器回复。所有的答复都可以在最后阅读。&lt;/p&gt;&lt;p&gt;                      欲了解更多信息，请查看我们关于&lt;a href=&quot;https://redis.io/topics/pipelining&quot; target=&quot;_blank&quot;&gt;管道的页面&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;         12、内联命令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                   有时在你的手中只有telnet工具，并且你需要发送一个命令到Redis服务器。虽然Redis协议易于实现，但在交互式会话中使用并不理想，而redis-cli可能并不总是可用。出于这个原因，Redis也以一种专门为人类设计的方式接受命令，并被称为内联命令格式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;                C: PING
                S: &lt;/span&gt;+PONG
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                   以下是返回整数的内联命令的另一个示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               C: EXISTS somekey
               S: :&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                      基本上你只需在telnet会话中编写空格分隔的参数。由于没有以统一请求协议中使用的 * 开始的命令，Redis 能够检测到这种情况并解析您的命令。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;         13、Redis协议的高性能分析器（High performance parser for the Redis protocol）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                     尽管Redis协议非常易于人工阅读并且易于实现，但它也可以通过类似二进制协议的性能来实现。&lt;/p&gt;&lt;p&gt;                     RESP使用前缀长度来传输批量数据，因此永远不需要扫描特殊字符有效负载，例如使用JSON发生的情况，也不需要承担发送到服务器的有效负载。&lt;/p&gt;&lt;p&gt;                     批量和多批量的长度可以使用代码进行计算，每个字符执行一次计算操作，同时扫描CR字符检查，像下面的C代码一样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
                  #include &amp;lt;stdio.h&amp;gt;

                  &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
                      unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *p = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$123\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                  
                      p&lt;/span&gt;++&lt;span&gt;;
                      &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(*p != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
                          len &lt;/span&gt;= (len*&lt;span&gt;10&lt;/span&gt;)+(*p - &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                          p&lt;/span&gt;++&lt;span&gt;;
                     }

                      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Now p points at '\r', and the len is in bulk_len. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                      printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, len);
                      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                    在识别出第一个CR之后，可以在不进行任何处理的情况下将其与以下LF一起跳过。然后可以使用单个读取操作读取批量数据，该操作不会以任何方式检查有效负载。最后，剩余的 CR 和 LF 字符将被丢弃而不进行任何处理。&lt;/p&gt;&lt;p&gt;                    虽然在性能上与二进制协议相当，但Redis协议在大多数高级语言中实现起来要简单得多，可减少在实现客户端的软件中的错误数量。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、结束&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;      &lt;br/&gt;            好了，今天就到这里了。该文章也翻译的差不多了，由于英文水平有限，翻译的过程中可能会出现一些语义不通的地方，希望大家指出，我可以修改错误，做的更好。好了，就说这么多吧，如果大家想查看原文，&lt;a href=&quot;https://redis.io/topics/protocol&quot; target=&quot;_blank&quot;&gt;请点击这里&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Wed, 14 Mar 2018 06:41:00 +0000</pubDate>
<dc:creator>PatrickLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/8567453.html</dc:identifier>
</item>
<item>
<title>网络防火墙和NAT地址转换 - 大天使彦</title>
<link>http://www.cnblogs.com/1477717815fuming/p/8567420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1477717815fuming/p/8567420.html</guid>
<description>&lt;p&gt;iptables/netfilter网络防火墙：&lt;/p&gt;
&lt;p&gt;(1) 充当网关&lt;/p&gt;
&lt;p&gt;(2) 使用filter表的FORWARD链&lt;/p&gt;
&lt;p&gt;注意的问题：&lt;/p&gt;
&lt;p&gt;(1) 请求-响应报文均会经由FORWARD链，要注意规则的方向性&lt;/p&gt;
&lt;p&gt;(2) 如果要启用conntrack机制，建议将双方向的状态为ESTABLISHED的报文直接放行&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实验：禁止互联网上的主机访问内网主机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143714259-252763369.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实验环境：3台机器&lt;/p&gt;
&lt;p&gt;假设：172.17.252.162 互联网上的主机（只有桥接，断掉仅主机）&lt;/p&gt;
&lt;p&gt; 两个网卡192.168.10.200和172.17.253.132 防火墙主机&lt;/p&gt;
&lt;p&gt; 192.168.10.187 内部网络主机（只有仅主机，断掉桥接）&lt;/p&gt;
&lt;p&gt;实验目的：允许内网主机访问互联网上主机，不允许互联网上主机访问内网主机&lt;/p&gt;
&lt;p&gt;（1）添加网关，让172.17.252.0/16网段的主机和192.168.10.0/24网段的主机能够互相ping通&lt;/p&gt;
&lt;p&gt;1.在172.17.252.162主机上&lt;/p&gt;
&lt;p&gt;route add default gw 172.17.253.132&lt;/p&gt;
&lt;p&gt;2.在192.168.10.187主机上&lt;/p&gt;
&lt;p&gt;route add default gw 192.168.10.200&lt;/p&gt;
&lt;p&gt;3.在防火墙上主机上开启转发功能&lt;/p&gt;
&lt;p&gt;vim /etc/sysctl.conf&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143714537-1365051810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;sysctl -p 使添加的内核参数生效&lt;/p&gt;
&lt;p&gt;4.查看连个网段的主机能否互相ping通&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143714911-1320741135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143715386-140837566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）在防火墙主机上添加策略，使内网的主机能访问互联网上的主机，而互联网上的主机不能访问内网的主机&lt;/p&gt;
&lt;p&gt;iptables -A FORWARD -s 192.168.10.0/24 -d 172.17.252.0/16 -m state --state NEW -j ACCEPT 在FORWARD链上允许源地址为192.168.10.0/24网段目标地址为172.17.252.0/16网段&lt;/p&gt;
&lt;p&gt;iptables -I FORWARD -m state --state ESTABLISHED -j ACCEPT&lt;/p&gt;
&lt;p&gt;iptables -A FORWARD -j REJECT 拒绝其他转发&lt;/p&gt;
&lt;p&gt;（3）测试&lt;/p&gt;
&lt;p&gt;在互联网主机上访问内部网络主机 不能ping通&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143715904-2088494092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在内网主机上ping互联网主机 能ping通&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143716387-1768955235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.SNAT 源网络地址转换&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上一个实验可以实现内网主机访问互联网主机，不允许互联网主机访问内网主机，但是有一个巨大的问题，就是内网主机地址必须是公有地址，成本太高，还不安全&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143716697-1750702891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实验环境：&lt;/p&gt;
&lt;p&gt;假设：192.168.6.52 互联网上的主机 ，只有一块网卡，桥接（公网ip）&lt;/p&gt;
&lt;p&gt; 192.168.66.128（仅主机）和192.168.6.143（桥接，公网ip） 防火墙主机，两块网卡，一块桥接，一块仅主机&lt;/p&gt;
&lt;p&gt; 192.168.66.177 内网的主机 ，一块网卡，仅主机（内网ip）&lt;/p&gt;
&lt;p&gt;实验目的：现在要通过防火墙做源地址转换，将192.168.66.177转换为192.168.6.143，从而实现访问互联网上的主机&lt;/p&gt;
&lt;p&gt;（1）在内网主机（192.168.66.177）上，将网关指向192.168.66.128&lt;/p&gt;
&lt;p&gt;route add default gw 192.168.66.177&lt;/p&gt;
&lt;p&gt;（2）在防火墙主机上做源地址转换,将内网的整个网段都替换成公网地址&lt;/p&gt;
&lt;p&gt;iptables -t nat -A POSTROUTING -s 192.168.66.0/24 -j SNAT --to-source 192.168.6.143&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;（3）测试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在192.168.6.52互联网上的主机上开一个web服务，然后用内网的主机192.168.66.177去访问，如果能访问到，说明实验成功&lt;/p&gt;
&lt;p&gt;1.在192.168.6.52主机上&lt;/p&gt;
&lt;p&gt;systemctl start httpd 开启httpd服务&lt;/p&gt;
&lt;p&gt;2.在192.168.66.177主机上用curl命令去访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143716990-866231345.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;用ping也能通&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143717257-884262065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）在互联网上的主机看看是谁访问的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143717668-624373226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;都是192.168.6.143访问的，说明试验成功&lt;/p&gt;

&lt;h3&gt;2.DNAT目标网络地址转换&lt;/h3&gt;
&lt;p&gt;假如说公司内部有一个人出差了，在互联网上想访问公司内部一个服务器，这要怎么做呢？如图：&lt;/p&gt;
&lt;p&gt;当互联网上的主机访问192.168.6.143的80端口时，就给他转到192.168.66.177的80端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143718104-1140133659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实验环境：&lt;/p&gt;
&lt;p&gt;假设：192.168.6.52 互联网上的主机，一块网卡，桥接&lt;/p&gt;
&lt;p&gt; 192.168.6.143和192.168.66.128 防火墙主机，两块网卡，一块桥接，一块仅主机&lt;/p&gt;
&lt;p&gt; 192.168.66.177 内网的主机 ，一块网卡，仅主机&lt;/p&gt;
&lt;p&gt;实验目的:实现互联网上的主机能够访问内网主机开启的httpd服务&lt;/p&gt;
&lt;p&gt;（1）在内网主机（192.168.66.177）上，将网关指向192.168.66.128&lt;/p&gt;
&lt;p&gt;route add default gw 192.168.66.177&lt;/p&gt;
&lt;p&gt;（2）在防火墙主机上做目标地址转换，将目标地址192.168.6.143转换为192.168.66.177&lt;/p&gt;
&lt;p&gt;iptables -t nat -A PREROUTING -d 192.168.6.143 -p tcp --dport 80 -j DNAT --to-destination 192.168.66.177:80&lt;/p&gt;
&lt;p&gt;（3）在内网主机（192.168.66.177）开启httpd服务&lt;/p&gt;
&lt;p&gt;systemctl start httpd&lt;/p&gt;
&lt;p&gt;echo hello world &amp;gt; /var/www/html/index.html&lt;/p&gt;
&lt;p&gt;（4）测试&lt;/p&gt;
&lt;p&gt;在互联网上的主机上用curl命令访问192.168.10.143&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143718325-856047547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（5）我们在内网主机上看日志，确实是互联网上的主机访问的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143718603-1971745653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;3.转发&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;实现其他人访问我本机的一个端口（如：80），给他转发到本机的另一个端口（如：8080）上&lt;/p&gt;
&lt;p&gt;我们基于上一个实验来做本实验&lt;/p&gt;
&lt;p&gt;（1）将内网主机上httpd服务端口改成8080&lt;/p&gt;
&lt;p&gt;vim /etc/httpd/conf/httpd.conf&lt;/p&gt;
&lt;p&gt;Listen 8080&lt;/p&gt;
&lt;p&gt;重启服务 systemctl restart httpd&lt;/p&gt;
&lt;p&gt;ss -ntl 查看端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143719093-1132859360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在只有8080端口，没有80端口&lt;/p&gt;
&lt;p&gt;（2）在内网主机（192.168.66.177）上设置转发策略，如果访问本机的80端口就给转发到本机的8080端口&lt;/p&gt;
&lt;p&gt;iptables -t nat -A PREROUTING -d 192.168.66.177 -p tcp --dport 80 -j REDIRECT --to-ports 8080&lt;/p&gt;
&lt;p&gt;（3）测试&lt;/p&gt;
&lt;p&gt;在互联网主机（192.168.6.52）上用curl来访问防火墙主机192.168.6.143&lt;/p&gt;
&lt;p&gt;curl 192.168.6.143&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235933/201803/1235933-20180314143719507-983055063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 14 Mar 2018 06:37:00 +0000</pubDate>
<dc:creator>大天使彦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1477717815fuming/p/8567420.html</dc:identifier>
</item>
<item>
<title>Python可视化库-Matplotlib使用总结 - 骑猪去流浪</title>
<link>http://www.cnblogs.com/flowyourheart/p/Python-ke-shi-hua-kuMatplotlib-shi-yong-zong-jie.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flowyourheart/p/Python-ke-shi-hua-kuMatplotlib-shi-yong-zong-jie.html</guid>
<description>[unable to retrieve full-text content]&gt; 在做完数据分析后,有时候需要将分析结果一目了然地展示出来,此时便离不开Python可视化工具,Matplotlib是Python中的一个2D绘图工具,是另外一个绘图工具seaborn的基础包#### 先总结下绘制子图的步骤:1.确定绘制的图形形状(如折线图/条状图/柱状图/饼图/散点图等)2.填...</description>
<pubDate>Wed, 14 Mar 2018 06:09:00 +0000</pubDate>
<dc:creator>骑猪去流浪</dc:creator>
<dc:identifier>http://www.cnblogs.com/flowyourheart/p/Python-ke-shi-hua-kuMatplotlib-shi-yong-zong-jie.html</dc:identifier>
</item>
<item>
<title>分布式学习最佳实践：从分布式系统的特征开始（附思维导图） - xybaby</title>
<link>http://www.cnblogs.com/xybaby/p/8544715.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xybaby/p/8544715.html</guid>
<description>

&lt;p&gt;　　&lt;span&gt;这一部分，与分布式不大相关，记录的是我是如何在分布式学习这条道路上摸索的，不感兴趣的读者请直接跳到下一章&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　过去的一年，我在分布式学习这条道路上苦苦徘徊，始终没有找到一个好的学习方法，一个能激励我持续学习的方法。&lt;/p&gt;
&lt;p&gt;　　当然，我也在不停的反思，最先发现的问题是学习不系统，东看看，西看看，看过就忘。于是写了一篇文章《&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/6930977.html&quot; target=&quot;_blank&quot;&gt;带着问题学习分布式系统&lt;/a&gt;》提出了一些问题，然后写了两篇文章来回带自己提出的问题。回过头看，其实这两篇文章都是基于分布式存储的。&lt;/p&gt;
&lt;p&gt;　　然后接下来，又是一段时间的迷茫，不知道要学习啥（也是在学习Paxos的时候遇到了阻碍），偶然看到了关于SMART的一些文章，发现原来自己的学习一点都不SAMRT，所以坚持不下去。于是又写了一篇文章《&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/7295555.html&quot; target=&quot;_blank&quot;&gt;带着SMART原则重新出发&lt;/a&gt;》，希望给自己设定SMART的目标，结果被博友打脸“一点都不smart”，而且也被结果打脸了，确实没有让我“重新出发”。&lt;/p&gt;
&lt;p&gt;　　我也曾经在网上搜索，“如何学习分布式系统“，但并没有找到理想的、或者说适合我的学习方法。网上的答案，都是说，看这些论文，看这些系统的实现。。。或者很多大学的课程，都是罗列出一堆术语：概念、协议、组件。而我觉得，逐个去了解这些术语似乎很无聊，因为不知道为什么要这个协议，或者说这些协议、组件是如何组合起来的。&lt;/p&gt;
&lt;p&gt;　　在没有得到适合自己的方案之后，我自己思考，希望更系统、全面的掌握，于是写了这篇文章《&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/7787034.html&quot; target=&quot;_blank&quot;&gt;什么是分布式系统，如何学习分布式系统&lt;/a&gt;》。主要内容是，从一个实际的大型网络出发，思考会遇到哪些问题，需要哪些分布式协议与组件。写完这篇文章，我的想法就是，逐个去学习这些组件。&lt;/p&gt;
&lt;p&gt;　　春节的时候，看完了《&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/8464430.html&quot; target=&quot;_blank&quot;&gt;小强升职记&lt;/a&gt;》，里面写到要用六个高度与大树分解法来设定自己的目标，制定自己的执行计划。于是，我尝试用这两个方法来指导我对分布式的学习。遗憾的是，在大数据分解法 树干（月计划）这一层，我就无法计划下去了，不知道每个月要学啥。具体原因，我想，还是没有一个对分布式系统的整理的认识。怎么整体把握呢，我想起了之前看到过的思维导图，于是就想画一张分布式系统的思维导图，然后逐个击破。当然，最开始也是瞎画，当时划出了5个树干，是这样子的：&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://images2018.cnblogs.com/blog/1089769/201803/1089769-20180313193345140-1957920100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在延伸feature（分布式系统需要考虑的特性）的时候，我逐渐明白，这是因为要满足这些feature，才设计了很多协议与算法，也提出了一些理论。比如说，这是因为要解决去中心化副本的一致性问题，才引入了Paxos（raft）协议。而每一个分布式系统，如分布式存储、分布式计算、分布式消息队列、分布式RPC框架，根据业务的不同，会使用不同的方法来满足这些feature，对这些feature的支持也可能会有权衡，比如一致性与可用性的权衡。&lt;/p&gt;
&lt;p&gt;　　所有，我觉得从分布式的特性出发，来一步步学习分布式是一种可行的方式。&lt;/p&gt;

&lt;p&gt;　　分布式的世界中涉及到大量的协议（raft、2pc、lease、quorum等）、大量的理论（FLP， CAP等）、大量的系统（GFS、MongoDB、MapReduce、Spark、RabbitMQ等）。这些大量的知识总是让我们无从下手，任何一个东西都需要花费大量的时间，特别是在没有项目、任务驱动的时候，没有一个明确的目标，真的很难坚持下去。&lt;/p&gt;
&lt;p&gt;　　所以，我一直在思考，能有什么办法能把这些东西串起来？当我掌握了知识点A的时候，能够自然地想到接下来要学习B知识，A和B的关系，也许是递进的，也许是并列的。我也这样尝试了，那就是《&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/7787034.html&quot; target=&quot;_blank&quot;&gt;什么是分布式系统，如何学习分布式系统&lt;/a&gt;》一文中我提到的，思考一个大型网站的架构，然后把这些协议、理论串起来。按照这个想法，我的计划就是去逐个学习这些组件。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;但是，其实在这里有一个误区，我认为一个大型网站就是一个分布式系统，包含诸多组件，这些组件是分布式系统的组成部分；而我现在认为，一个大型网站包含诸多组件，每一个组件都是一个分布式系统，比如分布式存储就是一个分布式系统，消息队列就是一个分布式系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;为什么说从思考分布式的特征出发，是一个可行的、系统的、循序渐进的学习方式呢&lt;/strong&gt;&lt;/span&gt;，因为：&lt;/p&gt;
&lt;p&gt;　　（1）先有问题，才会去思考解决问题的办法&lt;/p&gt;
&lt;p&gt;　　由于我们要提高可用性，所以我们才需要冗余；由于需要扩展性，所以我们才需要分片&lt;/p&gt;
&lt;p&gt;　　（2）解决一个问题，常常会引入新的问题&lt;/p&gt;
&lt;p&gt;　　比如，为了提高可用性，引入了冗余；而冗余又带来了副本之间的一致性问题，所以引入了中心化副本协议（primary/secondary)；那么接下来就要考虑primary（节点）故障时候的选举问题。。。&lt;/p&gt;
&lt;p&gt;　　（3）这是一个金字塔结构，或者说，也是一个深度优先遍历的过程。&lt;/p&gt;
&lt;p&gt;　　在这个过程中，我们始终知道自己已经掌握了哪些知识；还有哪些是已经知道，但未了解的知识；也能知道，哪些是空白，即我们知道这里可能有很多问题，但是具体是什么，还不知道。&lt;/p&gt;

&lt;p&gt;　　那么，各个分布式系统如何与这些特征相关联呢？不难发现，每个分布式系统都会或多或少的体现出这些特征，只是使用的方法、算法可能不大一样。所以，我们应该思考，某一个问题，在某个特定系统中是如何解决的。比如元数据管理的强一致性，在MongoDB中是如何实现的，在HDFS中是如何实现的。这也指导了我们如何去学习一个具体的分布式系统：带着问题，只关注关心的部分，而不是从头到尾看一遍。&lt;/p&gt;
&lt;p&gt;　　下面是，到目前为止，我对分布式特征的思维导图&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1089769/201803/1089769-20180314132152524-362531288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于上图，需要声明的是，第一：不一定完全正确，第二：不完整。这是因为，我自己也在学习中，可以看到，很多分支很短（比如去中心化副本协议），不是因为这一块没有内容，而是我压根儿还没去了解，还没去学习。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;我会持续跟新这幅脑图的&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;　　下一章，介绍一下分布式系统的各个特征。&lt;/p&gt;

&lt;p&gt; 　　任何介绍分布式系统的文章或者书籍都会提到分布式系统的几个特性：&lt;strong&gt;可扩展性、高性能、高可用、一致性&lt;/strong&gt;。这几个特性也是分布式系统的衡量指标，正是为了在不同的程度上满足这些特性（或者说达到这些指标），才会设计出各种各样的算法、协议，然后根据业务的需求在这些特性间平衡。&lt;/p&gt;
&lt;p&gt;　　那么本章节简单说明，为什么要满足这些特性，要满足这些特性需要解决什么问题，有什么好的解决方案。&lt;/p&gt;
&lt;h2&gt;可扩展性&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1089769/201803/1089769-20180313191316416-380948012.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Scalability is the capability of a system, network, or process to handle a growing amount of work, or its potential to be enlarged to accommodate that growth.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　可扩展性是指当系统的任务（work）增加的时候，通过增加资源来应对任务增长的能力。可扩展性是任何分布式系统必备的特性，这是由分布式系统的概念决定的：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　分布式系统的出现是为了解决单个计算机无法完成的计算、存储任务。那么当任务规模增加的时候，必然就需要添加更多的节点，这就是可扩展性。&lt;/p&gt;
&lt;p&gt;　　扩展性的目标是使得系统中的节点都在一个较为稳定的负载下工作，这就是负载均衡，当然，在动态增加节点的时候，需要进行任务（可能是计算，可能是数据存储）的迁移，以达到动态均衡。&lt;/p&gt;
&lt;p&gt;　　那么首先要考虑的问题就是，如何对任务进行拆分，将任务的子集分配到每一个节点，我们称这个过程问题Partition（Sharding）。关于Partition，其实我在《&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/7076731.html&quot; target=&quot;_blank&quot;&gt;带着问题学习分布式系统之数据分片&lt;/a&gt; 》一文中有详细介绍，这里进行归纳总结。&lt;/p&gt;
&lt;h3&gt;第一：分片分式，即按照什么算法对任务进行拆分&lt;/h3&gt;
&lt;p&gt;　　常见的算法包括：哈希（hash），一致性哈希（consistency hash），基于数据范围（range based）。每一种算法有各自的优缺点，也就有各自的适用场景。&lt;/p&gt;
&lt;h3&gt;第二：分片的键，partition key&lt;/h3&gt;
&lt;p&gt;　　partition key是数据的特征值，上面提到的任何分片方式都依赖于这个partition key，那么该如何选择呢&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt; based on what you think the primary access pattern will be&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　partition key会影响到任务在分片之间的均衡，而且一些系统中（mongodb）几乎是不能重新选择partition key的，因此在设计的时候就得想清楚&lt;/p&gt;
&lt;h3&gt;第三：分片的额外好处&lt;/h3&gt;
&lt;p&gt;　　提升性能和并发：不同的请求分发到不同的分片&lt;/p&gt;
&lt;p&gt;　　提高可用性：一个分片挂了不影响其他的分片&lt;/p&gt;
&lt;h3&gt;第四：分片带来的问题&lt;/h3&gt;
&lt;p&gt;　　如果一个操作需要跨越多个分片，那么效率就会很低下，比如数据中的join操作&lt;/p&gt;
&lt;h3&gt;第五：元数据管理&lt;/h3&gt;
&lt;p&gt;　　元数据记录了分片与节点的映射关系、节点状态等核心信息，分布式系统中，有专门的节点（节点集群）来管理元数据，我们称之为元数据服务器。元数据服务器有以下特点：&lt;/p&gt;
&lt;p&gt;　　高性能：cache&lt;/p&gt;
&lt;p&gt;　　高可用：冗余 加 快速failover&lt;/p&gt;
&lt;p&gt;　　强一致性（同时只有一个节点对外提供服务）&lt;/p&gt;
&lt;h3&gt;第六：任务的动态均衡&lt;/h3&gt;
&lt;p&gt;　　为了达到动态均衡，需要进行数据的迁移，如何保证在迁移的过程中保持对外提供服务，这也是一个需要精心设计的复杂问题。&lt;/p&gt;
&lt;h2&gt;可用性&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1089769/201803/1089769-20180313191345102-571618794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可用性（Availability）是系统不间断对外提供服务的能力，可用性是一个度的问题，最高目标就是7 * 24，即永远在线。但事实上做不到的，一般是用几个9来衡量系统的可用性，如下如所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1089769/201803/1089769-20180313191719808-796683217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　也就是如果要达到4个9的可用度（99.99%），那么一年之中只能有52.6分钟不可用，这是个巨大的挑战&lt;/p&gt;

&lt;p&gt;　　为什么分布式系统中必须要考虑可用性呢，这是因为分布式系统中故障的概率很高。分布式系统由大量异构的节点和网络组成，节点可能会crash、断电、磁盘损坏，网络可能丢包、延迟、网络分割。系统的规模放大了出故障的概率，因此分布式系统中，故障是常态。那么分布式系统的其中一个设计目标就是容错，在部分故障的情况下仍然对外提供服务，这就是可用性。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;冗余是提高可用性、可靠性的法宝&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　冗余就是说多个节点负责相同的任务，在需要状态维护的场景，比如分布式存储中使用非常广泛。在分布式计算，如MapReduce中，当一个worker运行异常缓慢时，master会将这个worker上的任务重新调度到其它worker，以提高系统的吞吐，这也算一种冗余。但存储的冗余相比计算而言要复杂许多，因此主要考虑存储的冗余。&lt;/p&gt;
&lt;p&gt;　　维护同一份数据的多个节点称之为多个副本。我们考虑一个问题，当向这个副本集写入数据的时候，怎么保证并发情况下数据的一致性，是否有一个节点有决定更新的顺序，这就是中心化、去中心话副本协议的区别。&lt;/p&gt;
&lt;h3&gt;中心化与去中心化&lt;/h3&gt;
&lt;p&gt;　　中心化就是有一个主节点（primary master）负责调度数据的更新，其优点是协议简单，将并发操作转变为顺序操作，缺点事primar可能y成为瓶颈，且在primary故障的时候重新选举会有一段时间的不可用。&lt;/p&gt;
&lt;p&gt;　　去中心化就是所有节点地位平等，都能够发起数据的更新，优点是高可用，缺点是协议复杂，要保证一致性很难。&lt;/p&gt;
&lt;p&gt;　　提到去中心化，比较有名的是dynamo，cassandra，使用了quorum、vector clock等算法来尽量保证去中心化环境下的一致性。对于去中心化这一块，目前还没怎么学习，所以下面主要讨论中心化副本集。对于中心化副本协议，我在《&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/7153755.html&quot; target=&quot;_blank&quot;&gt;带着问题学习分布式之中心化复制集&lt;/a&gt;》一文中也有详细介绍，这里简单归纳总结。&lt;/p&gt;
&lt;h3&gt;节点更新策略&lt;/h3&gt;
&lt;p&gt;　　primary节点到secondary节点的数据时同步还是异步，即客户端是否需要等待数据落地到副本集中的所有节点。&lt;/p&gt;
&lt;p&gt;　　同步的优点在于强一致性，但是可用性和性能（响应延迟）比较差；异步则相反。&lt;/p&gt;
&lt;h3&gt;数据流向&lt;/h3&gt;
&lt;p&gt;　　即数据是如何从Primary节点到secondary节点的，有链式和主从模式。&lt;/p&gt;
&lt;p&gt;　　链式的优点时充分利用网络带宽，减轻primary压力，但缺点是写入延迟会大一些。GFS，MongoDB（默认情况下）都是链式。&lt;/p&gt;
&lt;h3&gt;部分节点写入异常&lt;/h3&gt;
&lt;p&gt;　　理论上，副本集中的多个节点的数据应该保持一致，因此多个数据的写入理论上应该是一个事务：要么都发生，要么都不发生。但是分布式事务（如2pc）是一个复杂的、低效的过程，因此副本集的更新一般都是best effort 1pc，如果失败，则重试，或者告诉应用自行处理。&lt;/p&gt;
&lt;h3&gt;primary的选举&lt;/h3&gt;
&lt;p&gt;　　在中心化副本协议中，primary节点是如何选举出来的，当primary节点挂掉之后，又是如何选择出新的primary节点呢，有两种方式：自治系统，依赖其他组件的系统。（ps，这两个名字是我杜撰的 。。。）&lt;/p&gt;
&lt;p&gt;　　所谓的自治系统，就是节点内部自行投票选择，比如mongodb，tfs，zookeeper&lt;/p&gt;
&lt;p&gt;　　依赖其他组件的系统，是指primary由副本集之后的组件来任命，比如GFS中的primary由master（GFS的元数据服务器）任命，hdfs的元数据namenode由zookeeper心跳选出。&lt;/p&gt;
&lt;h3&gt;secondary是否对外提供服务（读服务）&lt;/h3&gt;
&lt;p&gt; 　　中心化复制集中，secondary是否对外提供读服务，取决于系统对一致性的要求。&lt;/p&gt;
&lt;p&gt;　　比如前面介绍到节点更新策略时，可能是异步的，那么secondary上的数据相比primary会有一定延迟，从secondary上读数据的话无法满足强一致性要求。&lt;/p&gt;
&lt;p&gt;　　比如元数据，需要强一致性保证，所以一般都只会从primary读数据。而且，一般称主节点为active（master），从节点为standby（slave）。在这种情况下，是通过冗余 加上 快速的failover来保证可用性。&lt;/p&gt;
&lt;h2&gt;一致性&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1089769/201803/1089769-20180314103757972-554610630.png&quot; alt=&quot;&quot; width=&quot;453&quot; height=&quot;391&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从上面可以看到，为了高可用性，引入了冗余（副本）机制，而副本机制就带来了一致性问题。当然，如果没有冗余机制，或者不是数据（状态）的冗余，那么不会出现一致性问题，比如MapReduce。&lt;/p&gt;
&lt;p&gt;　　一致性与可用性在分布式系统中的关系，已经有足够的研究，形成了CAP理论。CAP理论就是说分布式数据存储，最多只能同时满足一致性（C，Consistency）、可用性（A， Availability）、分区容错性（P，Partition Tolerance）中的两者。但一致性和可用性都是一个度的问题，是0到1，而不是只有0和1两个极端。详细可以参考之前的文章《&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/6871764.html&quot; target=&quot;_blank&quot;&gt;CAP理论与MongoDB一致性、可用性的一些思考&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;　　一致性从系统的角度和用户的角度有不同的等级。&lt;/p&gt;
&lt;h3&gt;系统角度的一致性&lt;/h3&gt;
&lt;p&gt; 　　强一致性、若一致性、最终一致性&lt;/p&gt;
&lt;h3&gt;用户角度的一致性&lt;/h3&gt;
&lt;p&gt; 　　单调读一致性，单调写一致性，读后写一致性，写后读一致性&lt;/p&gt;
&lt;h2&gt;高性能&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1089769/201803/1089769-20180314112850965-2064581952.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　正式因为单个节点的scale up不能完成任务，因此我们才需要scale out，用大量的节点来完成任务，分布式系统的理想目标是任务与节点按一定的比例线性增长。&lt;/p&gt;
&lt;h3&gt;衡量指标&lt;/h3&gt;
&lt;p&gt;　　高并发&lt;/p&gt;
&lt;p&gt;　　高吞吐&lt;/p&gt;
&lt;p&gt;　　低延迟&lt;/p&gt;
&lt;p&gt;　　不同的系统关注的核心指标不一样，比如MapReduce，本身就是离线计算，无需低延迟&lt;/p&gt;
&lt;h3&gt;可行的办法&lt;/h3&gt;
&lt;p&gt;　　单个节点的scaleup&lt;/p&gt;
&lt;p&gt;　　分片（partition）&lt;/p&gt;
&lt;p&gt;　　缓存：比如元数据&lt;/p&gt;
&lt;p&gt; 　   短事务&lt;/p&gt;

&lt;p&gt; &lt;a href=&quot;http://book.mixu.net/distsys/&quot; target=&quot;_blank&quot;&gt;Distributed systems for fun and profit  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刘杰:《&lt;a href=&quot;http://blog.sciencenet.cn/home.php?mod=attachment&amp;amp;id=31413&quot; target=&quot;_blank&quot;&gt;分布式系统原理介绍&lt;/a&gt;》&lt;/p&gt;

</description>
<pubDate>Wed, 14 Mar 2018 04:55:00 +0000</pubDate>
<dc:creator>xybaby</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xybaby/p/8544715.html</dc:identifier>
</item>
<item>
<title>云计算之路-阿里云上：3个manager节点异常造成 docker swarm 集群宕机 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/8566696.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/8566696.html</guid>
<description>[unable to retrieve full-text content]今天 11:29 - 11:39 左右，docker swarm 集群 3 个 manager 节点同时出现异常，造成整个集群宕机，由此给您带来很大的麻烦，请您谅解。最近我们刚刚确认我们所有遇到的 docker swarm 不稳定问题都与部分节点的异常状况有关，即使是一直让我们非常头疼的 docke...</description>
<pubDate>Wed, 14 Mar 2018 04:21:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<dc:identifier>http://www.cnblogs.com/cmt/p/8566696.html</dc:identifier>
</item>
<item>
<title>Spring【依赖注入】就是这么简单 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8566706.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8566706.html</guid>
<description>[unable to retrieve full-text content]前言 在Spring的第二篇中主要讲解了Spring Core模块的使用IOC容器创建对象的问题，Spring Core模块主要是解决对象的创建和对象之间的依赖关系，因此本博文主要讲解如何 使用IOC容器来解决对象之间的依赖关系 ！ 回顾以前对象依赖 我们来看一下我们以前关于对象依赖，是怎么的历程 </description>
<pubDate>Wed, 14 Mar 2018 04:11:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8566706.html</dc:identifier>
</item>
<item>
<title>Django Middleware简介 - MyStitch</title>
<link>http://www.cnblogs.com/StitchSun/p/8552651.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/StitchSun/p/8552651.html</guid>
<description>[unable to retrieve full-text content]1 前言 Django使用非常熟练了，各种API接口不在话下，全都搞定。为方便定位问题在每个API接口的的开始和返回的地方都加上了log打印，记录入参和返回值。 但是这样有一个问题，需要每个API接口都要写一遍，非常的不Pythonic，有没有更好的方法呢？ 如果大家对装饰器熟悉的话，会想到这个方法</description>
<pubDate>Wed, 14 Mar 2018 03:56:00 +0000</pubDate>
<dc:creator>MyStitch</dc:creator>
<dc:identifier>http://www.cnblogs.com/StitchSun/p/8552651.html</dc:identifier>
</item>
</channel>
</rss>