<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET Core 2.0 : 七.一张图看透启动背后的秘密 - FlyLolo</title>
<link>http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_7.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_7.html</guid>
<description>&lt;p&gt;　　为什么我们可以在Startup这个 “孤零零的” 类中配置依赖注入和管道？&lt;/p&gt;
&lt;p&gt;　　它是什么时候被实例化并且调用的？&lt;/p&gt;
&lt;p&gt;　　参数中的IServiceCollection services是怎么来的?&lt;/p&gt;
&lt;p&gt;　　处理管道是怎么构建起来的？&lt;/p&gt;
&lt;p&gt;　　启动过程中，系统“默默的”做了哪些准备工作？&lt;/p&gt;
&lt;p&gt;　　上一篇文章讲了ASP.NET Core中的依赖注入（&lt;a href=&quot;http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_0.html&quot; target=&quot;_blank&quot;&gt;系列目录&lt;/a&gt;）， 而它的配置是在Startup这个文件中的 &lt;span class=&quot;cnblogs_code&quot;&gt;ConfigureServices(IServiceCollection services)&lt;/span&gt; 方法，而且Startup这个类也没有继承任何类或者接口。 深入的想一想，可能会冒出类似上面列出的好多问题，下面用一幅图来看透它。&lt;/p&gt;

&lt;p&gt;先上图， 觉得看不清可以点击看大图或者下载后放大查看。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/548134/201803/548134-20180321160719074-1992689731.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/548134/201803/548134-20180321160719074-1992689731.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图一  （&lt;a href=&quot;https://images2018.cnblogs.com/blog/548134/201803/548134-20180321160719074-1992689731.png&quot; target=&quot;_blank&quot;&gt;点击放大&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;　　应用程序在Main方法之后通过调用Create­DefaultBuilder方法创建并配置WebHostBuilder， &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebHostBuilder : IWebHostBuilder
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; List&amp;lt;Action&amp;lt;WebHostBuilderContext, IServiceCollection&amp;gt;&amp;gt;&lt;span&gt; _configureServicesDelegates;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; IConfiguration _config;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IWebHostBuilder UseSetting(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             _config[key] =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IWebHostBuilder ConfigureServices(Action&amp;lt;WebHostBuilderContext, IServiceCollection&amp;gt;&lt;span&gt; configureServices)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (configureServices == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(configureServices));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            _configureServicesDelegates.Add(configureServices);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WebHostBuilder存在一个重要的集合&lt;span&gt;①&lt;/span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; List&amp;lt;Action&amp;lt;WebHostBuilderContext, IServiceCollection&amp;gt;&amp;gt; _configureServicesDelegates;&lt;/span&gt; ， 通过 &lt;span class=&quot;cnblogs_code&quot;&gt;ConfigureServices&lt;/span&gt; 方法将需要的Action加入进来。&lt;/p&gt;
&lt;p&gt;UseSetting是一个用于设置Key-Value的方法， 一些常用的配置均会通过此方法写入_config中。&lt;/p&gt;

&lt;p&gt;　　Create­DefaultBuilder之后调用UseStartup&amp;lt;Startup&amp;gt;()，指定Startup为启动类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder UseStartup(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IWebHostBuilder hostBuilder, Type startupType)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; startupAssemblyName =&lt;span&gt; startupType.GetTypeInfo().Assembly.GetName().Name;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hostBuilder
                .UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName)
                .ConfigureServices(services &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IStartup).GetTypeInfo().IsAssignableFrom(startupType.GetTypeInfo()))
                    {
                        services.AddSingleton(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IStartup), startupType);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        services.AddSingleton(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IStartup), sp =&amp;gt;&lt;span&gt;
                        {
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hostingEnvironment = sp.GetRequiredService&amp;lt;IHostingEnvironment&amp;gt;&lt;span&gt;();
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConventionBasedStartup(StartupLoader.LoadMethods(sp, startupType, hostingEnvironment.EnvironmentName));
                        });
                    }
                });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先获取Startup类对应的AssemblyName， 调用UseSetting方法将其设置为WebHostDefaults.ApplicationKey（“applicationName”）的值。&lt;/p&gt;
&lt;p&gt;然后调用WebHostBuilder的&lt;span&gt;②&lt;/span&gt;&lt;span&gt;ConfigureServices&lt;/span&gt;方法，将一个Action写入WebHostBuilder 的 configureServicesDelegates中。&lt;/p&gt;
&lt;p&gt;这个Action的意思就是说，如果这个被指定的类startupType是一个实现了IStartup的类， 那么将其通过AddSingleton注册到services 这个ServiceCollection中， 如果不是， 那么将其“转换”成 ConventionBasedStartup 这个实现了 IStartup的类后再进行注册。这里涉及到一个StartupLoader的LoadMethods()方法，会通过字符串的方式查找“ConfigureServices”、“Configure{ &lt;span&gt;environmentName&lt;/span&gt;}Services”这样的方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：这里只是将一个Action写入了configureServicesDelegates， 而不是已经执行了对IStartup的注册， 因为这个Action尚未执行，services也还不存在。&lt;span&gt;就像菩萨对八戒说： 八戒（Startup）你先在高老庄等着吧， 将来有个和尚带领一个取经小分队（ServiceCollection &lt;span data-mce-=&quot;&quot;&gt;services&lt;/span&gt; ）过来的时候你加入他们。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;其实在Create­DefaultBuilder方法中的几个UseXXX的方法也是这样通过ConfigureServices将对应的Action写入了configureServicesDelegates， 等待唐僧的到来。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;创建并配置好的WebHostBuilder开始通过Build方法创建WebHost了， 首先是BuildCommonServices， &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; IServiceCollection BuildCommonServices(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; AggregateException hostingStartupErrors)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...省略...&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; services = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            services.AddSingleton(_hostingEnvironment);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            services.AddSingleton(_context);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;....各种Add....&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; configureServices &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _configureServicesDelegates)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                configureServices(_context, services);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; services;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         }                
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;　　在这个方法里创建了ServiceCollection &lt;span data-mce-=&quot;&quot;&gt;services（以唐僧为首的取经小分队）， 然后通过各种Add方法注册了好多内容进去（收了悟空），然后&lt;span&gt;③&lt;span data-mce-=&quot;&quot;&gt;foreach&lt;/span&gt;&lt;/span&gt; 之前暂存在configureServicesDelegates中的各个Action，传入services逐一执行， 将之前需要注册的内容注册到services中， 这里就包括Startup（八戒），注意这里仅是进行了注册，而未执行Startup的方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　处理好的这个services被BuildCommonServices返回后赋值给 &lt;span&gt;hostingServices,然后&lt;span&gt;&lt;span&gt; hostingServices经过Clone()生成 &lt;span&gt;applicationServices,再由这个 &lt;span&gt;applicationServices进行 &lt;span&gt;GetProviderFromFactory(hostingServices)生成一个 &lt;span&gt;IServiceProvider&lt;/span&gt; &lt;span&gt;hostingServiceProvider.经过一系列的处理后,可以创建WebHost了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; host = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebHost(
    applicationServices,
    hostingServiceProvider,
    _options,
    _config,
    hostingStartupErrors);

host.Initialize();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 将生成的applicationServices 和 hostingServiceProvider作为参数传递给新生成的WebHost。接下来就是这个WebHost的 Initialize()。&lt;/p&gt;

&lt;p&gt;WebHost的 Initialize()的主要工作就是BuildApplication()。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EnsureApplicationServices()：&lt;/strong&gt; 用来处理WebHost的 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;private&lt;/span&gt; IServiceProvider _applicationServices&lt;/span&gt; ，&lt;span&gt;④Startup的ConfigureServices方法在这里被调用&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
_startup = _hostingServiceProvider.GetRequiredService&amp;lt;IStartup&amp;gt;&lt;span&gt;();
_applicationServices &lt;/span&gt;= _startup.ConfigureServices(_applicationServiceCollection);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 &lt;span class=&quot;cnblogs_code&quot;&gt;GetRequiredService&amp;lt;IStartup&amp;gt;()&lt;/span&gt; 获取到我们的_startup， 然后调用这个_startup的 &lt;span&gt;⑤ConfigureServices&lt;/span&gt; 方法，这就是我们用于依赖注入的startup类的ConfigureServices方法了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，&lt;/span&gt;_applicationServices是根据_applicationServiceCollection 加上我们在_startup中注册的内容之后重新生成的 &lt;span&gt;IServiceProvider。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EnsureServer()&lt;span&gt;⑥&lt;/span&gt;：&lt;/strong&gt;通过 &lt;span&gt;GetRequiredService&amp;lt;IServer&amp;gt;()获取Server并配置监听地址。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; builderFactory = _applicationServices.GetRequiredService&amp;lt;IApplicationBuilderFactory&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; builder =&lt;span&gt; builderFactory.CreateBuilder(Server.Features);
builder.ApplicationServices &lt;/span&gt;= _applicationServices;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取到 IApplicationBuilderFactory并通过它&lt;span&gt;⑦&lt;/span&gt;创建 &lt;span&gt;IApplicationBuilder,并将上面创建的&lt;/span&gt;_applicationServices赋值给它的ApplicationServices，它还有个重要的集合_components&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IList&amp;lt;Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;&amp;gt; _components = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 从_components的类型可以看出它其实是中间件的集合，是该调用我们的_startup的Configure方法的时候了。&lt;/p&gt;
&lt;p&gt;先获取定义的IStartupFilter， &lt;span&gt;⑧&lt;/span&gt;foreach这些IStartupFilter并与_startup的Configure方法一起将配置的中间件写入_components，然后通过 Build()创建RequestDelegate _application，&lt;/p&gt;
&lt;p&gt;在Build()中对_components进行处理生成请求处理管道，&lt;span&gt;关于IStartupFilter和生成管道这部分将在下篇文章进行详细说明。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　WebHost创建完毕， 最后一步就是Run起来了，WebHost的Run()会调用它的方法StartAsync()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task StartAsync(CancellationToken cancellationToken = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken))
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;......&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hostingApp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HostingApplication(_application, _logger, diagnosticSource, httpContextFactory);
    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Server.StartAsync(hostingApp, cancellationToken).ConfigureAwait(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    _hostedServiceExecutor.StartAsync(cancellationToken).ConfigureAwait(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;    //&lt;/span&gt;&lt;span&gt;.....&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在之前的文章中我们知道，请求是经过 Server监听=&amp;gt;处理成httpContext=&amp;gt;Application处理，所以这里首先传入上面创建的_application和一个httpContextFactory来&lt;span&gt;⑨生成一个HostingApplication&lt;/span&gt;，并将这个HostingApplication传入Server的StartAsync(), 当Server监听到请求之后， 后面的工作由HostingApplication来完成。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;⑩hostedServiceExecutor.StartAsync()&lt;/span&gt;方法用来开启一个后台运行的服务，一些需要后台运行的操作比如定期刷新缓存等可以放到这里来。&lt;/p&gt;
</description>
<pubDate>Wed, 21 Mar 2018 23:13:00 +0000</pubDate>
<dc:creator>FlyLolo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_7.html</dc:identifier>
</item>
<item>
<title>TensorFlow-谷歌深度学习库 体验一二三 - 火山岩上的小红花</title>
<link>http://www.cnblogs.com/duwenlu/p/8621223.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duwenlu/p/8621223.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一个TensorFlow的运算可以看作是一个数据流图。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个&lt;strong&gt;图&lt;/strong&gt;呢则由一组操作和数据集组成。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;操作（operation）代表运算单元&lt;/li&gt;
&lt;li&gt;数据（tensor） 代表在各运算单元流动的数据单元&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;要想使用一个数据流图，必须把它注册为默认的图。&lt;/p&gt;
&lt;p&gt;注意：图这个class并不是线程安全的，它所有的方法也不是。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将一个图设为默认的图&lt;/strong&gt;的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
g =&lt;span&gt; tf.Graph()
with g.as_default(): # 将图设为默认
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; define operations and tensors in g&lt;/span&gt;
    c = tf.constant(30.0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;as_default(self)&lt;/p&gt;
&lt;p&gt;返回一个将Graph设为默认的context manager。如果你想要在一个进程中创建多个图考虑使用。如果你不显示调用，一个全局默认图将被提供。&lt;/p&gt;
&lt;p&gt;默认图所属当前线程，如果你创建了一个新的线程，你必须在那个线程中显示调用as_default方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建常量tensor&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
constant(value, dtype=None, shape=None, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Const&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, verify_shape=False)&lt;/pre&gt;
&lt;p&gt;'''&lt;/p&gt;
&lt;p&gt;Args:&lt;br/&gt;value: A constant value (or list) of output type `dtype`.&lt;/p&gt;&lt;p&gt;dtype: The type of the elements of the resulting tensor.&lt;/p&gt;&lt;p&gt;shape: Optional dimensions of resulting tensor.&lt;/p&gt;&lt;p&gt;name: Optional name for the tensor.&lt;/p&gt;&lt;p&gt;verify_shape: Boolean that enables verification of a shape of values.&lt;/p&gt;&lt;p&gt;Returns:&lt;br/&gt;A Constant Tensor.&lt;/p&gt;&lt;p&gt;Raises:&lt;br/&gt;TypeError: if shape is incorrectly specified or unsupported.&lt;/p&gt;
&lt;p&gt;'''&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;传入value创建常量tensor。value可以是一个常量值或常量列表。 参数shape是可选的，如果不提供默认为传入value的shape。&lt;/p&gt;
&lt;p&gt;同理，dtype也是可选的，不提供则默认为传入value的dtype。&lt;/p&gt;
&lt;p&gt;```python&lt;br/&gt;# Constant 1-D Tensor populated with value list.&lt;br/&gt;tensor = tf.constant([1, 2, 3, 4, 5, 6, 7]) =&amp;gt; [1 2 3 4 5 6 7]&lt;/p&gt;&lt;p&gt;# Constant 2-D tensor populated with scalar value -1.&lt;br/&gt;tensor = tf.constant(-1.0, shape=[2, 3]) =&amp;gt; [[-1. -1. -1.]&lt;br/&gt;[-1. -1. -1.]]&lt;br/&gt;```&lt;br/&gt;&lt;strong&gt;创建变量tensor&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  w = tf.Variable(&amp;lt;initial-value&amp;gt;, name=&amp;lt;optional-name&amp;gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个变量维持图的状态。 变量在定义的时候要声明它的类型和shape， 在创建之后虽然值是可以改变的， 但类型和shape是固定的。&lt;/p&gt;
&lt;p&gt;和其他tensor一样，被创建的变量可以被图中的操作当作输入使用。&lt;/p&gt;
&lt;p&gt;当你启用已经定义好的图时，所有变量必须显示的&lt;span&gt;被初始化&lt;/span&gt;，之后你才可以运行操作使用他们的值。你也可以从文件中读取完成初始化步骤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建placeholder&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
placeholder(dtype, shape=None, name=None)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;给一个tensor插入placeholder，并且会在之后补充进去。&lt;/p&gt;
&lt;p&gt;通过`Session.run()`的备选参数`feed_dict` 将之前的placeholder的值补进去, 如果你没有喂进任何数据就运行会话对象将报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 
    ```python
    x &lt;/span&gt;= tf.placeholder(tf.float32, shape=(1024, 1024&lt;span&gt;))
    y &lt;/span&gt;=&lt;span&gt; tf.matmul(x, x)
    
    with tf.Session() as sess:
      &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(sess.run(y))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ERROR: will fail because x was not fed.&lt;/span&gt;
&lt;span&gt;    
      rand_array &lt;/span&gt;= np.random.rand(1024, 1024&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(sess.run(y, feed_dict={x: rand_array}))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Will succeed.&lt;/span&gt;
    ```
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;计算logits tensor&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
logits = tf.matmul(tf_train_dataset, weights) + biases
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;计算softmax cross entropy，loss tensor&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
loss =&lt;span&gt; tf.reduce_mean(
     tf.nn.softmax_cross_entropy_with_logits(labels&lt;/span&gt;=tf_train_labels, logits=logits))
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
softmax_cross_entropy_with_logits_v2(_sentinel=None, labels=None, logits=None, dim=-1, name=None)
&lt;/pre&gt;
&lt;p&gt;Args:&lt;br/&gt;_sentinel: Used to prevent positional parameters. Internal, do not use.&lt;br/&gt;labels: Each row `labels[i]` must be a valid probability distribution.&lt;br/&gt;logits: Unscaled log probabilities.&lt;br/&gt;dim: The class dimension. Defaulted to -1 which is the last dimension.&lt;br/&gt;name: A name for the operation (optional).&lt;/p&gt;&lt;p&gt;Returns:&lt;br/&gt;A 1-D `Tensor` of length `batch_size` of the same type as `logits` with the&lt;br/&gt;softmax cross entropy loss.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;计算probability errors。 对于每一个想要预测的内容， 它必须有且只有一个标签。&lt;/p&gt;
&lt;p&gt;参数为logits和labels，这个函数内部会自动处理soft max。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201803/1336707-20180321235838290-1282792957.png&quot; alt=&quot;&quot; width=&quot;298&quot; height=&quot;138&quot;/&gt;&lt;/p&gt;
&lt;p&gt;softmax: 将score转化成probability&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; softmax(x):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Compute softmax values for each sets of scores in x.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; np.exp(x) / np.sum(np.exp(x), axis = 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;one-hot-encoding: 正确的label标为1，其他均为0. 比如有a，b，c三个label，a为正确的label标为1，b和c标为0&lt;/p&gt;
&lt;p&gt;cross-entropy（用来衡量performance）:　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201803/1336707-20180322001251713-1825272313.png&quot; alt=&quot;&quot; width=&quot;311&quot; height=&quot;171&quot;/&gt;&lt;/p&gt;
&lt;p&gt;计算所有样本的综合loss：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201803/1336707-20180322001850428-1239224512.png&quot; alt=&quot;&quot; width=&quot;221&quot; height=&quot;91&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化处理Optimizer: Gradient Descent Optimizer， 定义operation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用梯度下降法找到最小的loss。 这个operation会更新涉及到的tensor的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GradientDescentOptimizer(tensorflow.python.training.optimizer.Optimizer)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt; __init__(self, learning_rate, use_locking=False, name='GradientDescent'&lt;span&gt;)
 Construct a new gradient descent optimizer. 
 Args:
 learning_rate: A Tensor or&lt;span&gt; a floating point value.  The learning rate to use.&lt;br/&gt;minimize(self, loss, global_step=None, var_list=None, gate_gradients=1&lt;span&gt;, 
 aggregation_method=None, colocate_gradients_with_ops=False, name=&lt;span&gt;None, 
 grad_loss=&lt;span&gt;None)
 Add operations to minimize `loss` by updating `var_list`.
 This method simply combines calls `compute_gradients()` and &lt;span&gt;`apply_gradients()`. &lt;br/&gt;If you want to process the gradient before applying them call `compute_gradients()` and&lt;span&gt; `apply_gradients()` explicitly instead of using this function.
       
 Args:
 loss: A `Tensor` containing the value to minimize.
 global_step: Optional `Variable` to increment by one after the variables have been updated.
 
 Returns:
 An Operation that updates the variables in&lt;span&gt; `var_list`.  If `global_step` was not&lt;span&gt; `None`, that operation also increments `global_step`.
       
 Raises:
 ValueError: If some of the variables are not `Variable` objects.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;什么是梯度下降？&lt;/p&gt;
&lt;p&gt;误差方程 (Cost Function). 用来计算&lt;span&gt;预测出来的和我们实际中的值有多大差别&lt;/span&gt;. 在预测数值的问题中. W是我们神经网络中的参数, 假设我们初始化的 W 在一个位置. 而这个位置的斜率也就是梯度下降中的梯度. loss误差最小的时候正是这条曲线最低的地方, 不过 W 却不知道这件事情, 他目前所知道的就是梯度线为自己在这个位置指出的一个&lt;span&gt;下降方向&lt;/span&gt;, 我们就要朝着这个梯度的方向下降一点点. 在做一条切线, 发现我还能下降, 那我就朝着梯度的方向继续下降, 这时, 再展示出现在的梯度, 因为梯度线已经躺平了, 我们已经指不出哪边是下降的方向了, 所以这时我们就找到了 W 参数的最理想值. 简而言之, 就是找到&lt;span&gt;梯度线躺平的点&lt;/span&gt;. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201803/1336707-20180322021530801-354812200.png&quot; alt=&quot;&quot; width=&quot;309&quot; height=&quot;202&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Session(会话)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用来&lt;span&gt;运行tensorflow operation的类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;会话对象封装了一个供ops类执行并且可以评估tensor的环境。&lt;/p&gt;
&lt;p&gt;会话类会拥有自己的资源，为确保在使用后这些资源被释放，可以使用context manager&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Using the context manager.&lt;/span&gt;
&lt;span&gt; with tf.Session() as sess:
     sess.run(...)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在初始化创建一个会话对象的时候，如果没有指明图那么一个默认的图会被启用。如果你拥有多个图，那么你需要为每一个图初始化一个会话对象。&lt;/p&gt;

&lt;p&gt;在会话类中，首先要初始化所有变量。使用global_variables_initializer()返回一个op并运行来初始化。&lt;/p&gt;
&lt;p&gt;global_variables_initializer()&lt;br/&gt;Returns an Op that initializes global variables.&lt;br/&gt;Returns:&lt;br/&gt;An Op that initializes global variables in the graph.&lt;/p&gt;

</description>
<pubDate>Wed, 21 Mar 2018 20:11:00 +0000</pubDate>
<dc:creator>火山岩上的小红花</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/duwenlu/p/8621223.html</dc:identifier>
</item>
<item>
<title>多线程_基本操作 - J.FengS</title>
<link>http://www.cnblogs.com/fjfsu/p/J_Feng.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fjfsu/p/J_Feng.html</guid>
<description>&lt;h2&gt;什么是多线程：&lt;/h2&gt;
&lt;p&gt;　　进程：正在运行的程序，QQ 360 ......&lt;/p&gt;
&lt;p&gt;       线程：就是进程中一条执行程序的执行路径，一个程序至少有一条执行路径。（360中的杀毒 电脑体检 电脑清理 同时运行的话就需要开启多条路径）&lt;/p&gt;
&lt;p&gt;　　每个线程都有自己需要运行的内容，而这些内容可以称为线程要执行的任务。&lt;/p&gt;
&lt;p&gt;　　开启多线程是为了同时运行多部分代码。&lt;/p&gt;
&lt;p&gt;　　好处：解决了多部分需要同时运行的问题&lt;/p&gt;
&lt;p&gt;　　弊端：如果线程过多，会导致效率很低（因为程序的执行都是CPU做着随机 快速切换来完成的）&lt;/p&gt;
&lt;p&gt;　　JVM在启动时，就有着多个线程启动&lt;/p&gt;
&lt;p&gt;　　在多线程运行过程中，如有线程抛出了异常，那么该线程会停止运行（出栈），但是并不影响其他线程的正常运行。&lt;/p&gt;
&lt;h2&gt;线程的四种状态：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1344326/201803/1344326-20180322013500637-1595486352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;创建线程：&lt;/h2&gt;
&lt;p&gt;　　方法一：继承Thread类&lt;/p&gt;
&lt;p&gt;　　方法二：实现Runnable接口&lt;/p&gt;
&lt;p&gt;　　分析：创建线程的目的是为了开辟一条执行路径，让线程去运行指定的代码（执行路径的任务），实现和其他线程同时执行任务。&lt;/p&gt;
&lt;p&gt;　　　　　JVM创建的主线程任务都定义在了mian方法中；自定义的线程任务将要封装在Thread类的run方法中。&lt;/p&gt;

&lt;p&gt;　　方法一的步骤：1：继承Thread类   2：重写run方法（封装任务）  3：实例化Thread类的子类对象   4：调用start方法开启线程（这个方法会调用run方法来执行任务）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Text{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         aThread Dome=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; aThread();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        Dome.start();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        System.out.println(Thread.currentThread().getName());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; aThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        System.out.println(Thread.currentThread().getName());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;currentThread()是一个静态方法，它返回的是当前正在运行线程的这个对象，然后调用getName方法返回这个线程的名字；&lt;/p&gt;
&lt;p&gt;名字是Thread-编号（从0开始），主函数的名字就是main。&lt;/p&gt;
&lt;p&gt;Thread类中有个接收String类型参数的构造方法，我们传入的数据可以自定义线程的名字。如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; aThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    aThread(String a){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(a);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         System.out.println(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getName());
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　如果一个子类已经有了父类，但是它需要开启多线程来执行任务，那么就要用到Runnable这个接口来扩展该子类的功能（避免了java的单继承局限性）&lt;/p&gt;
&lt;p&gt;　　Runnable这个接口只有一个run一个抽象方法，所以Runnable接口的出现仅仅是为了用run封装任务而存在的；而且Thread类也实现了Runnable接口&lt;/p&gt;

&lt;p&gt;　　方法二的步骤：1：实现Runnable接口　2：重写run方法（封装任务）　3：创建Thread线程a  创建Runnable子类对象t　　&lt;/p&gt;
&lt;p&gt;　　　　　　　　　4：将t作为参数传递给a（Thread有个构造方法是用来接收Runnable类型参数的；因为任务都封装在了Runnbale子类的run方法中，&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　在开启线程的时候就要明确线程的任务，否则Thread会调用自己的run方法，Runnbale子类中的任务将永远不会被执行到）&lt;/p&gt;
&lt;p&gt;　　　　　　　　　5：开启线程（start）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Text{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         aThread t=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; aThread();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Thread a=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(t);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        a.start();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        System.out.println(Thread.currentThread().getName());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; aThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        System.out.println(Thread.currentThread().getName());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　实现Runnable接口的好处：1.将任务从Thread子类中分离出来，进行单独的封装；按照面向对象的思想将任务封装成了对象&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　 2.避免了JAVA单继承的局限性&lt;/p&gt;

&lt;h2&gt;多线程安全问题：&lt;/h2&gt;
&lt;p&gt;　　原因： 1.多个线程操作共享数据&lt;/p&gt;
&lt;p&gt;　　           2.操作共享数据的代码有多条&lt;/p&gt;
&lt;p&gt;                  当一个线程在执行共享数据的多条代码时，有其他的线程参与进来，就会导致线程安全问题的产生。&lt;/p&gt;
&lt;p&gt;　　例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Text{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         aThread t=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; aThread();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Thread a=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(t);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Thread a1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(t);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Thread a2=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(t);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Thread a3=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(t);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        a.start();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        a1.start();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        a2.start();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        a3.start();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; aThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mun=100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(mun&amp;gt;0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;{Thread.sleep(5);}&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;为了能够看得清楚，让线程冻结，sleep会抛出异常由于Runnable接口并没有抛出异常
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            ，所以其子类也不能抛，只能try catch去捕捉异常。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             System.out.println(Thread.currentThread().getName()+&quot;.....&quot;+mun--&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         }&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;运行的结果中会出项这样的情况Thread-3.....42  Thread-0.....42
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                （如果是卖票的话我们可以理解为这两个线程都卖了42号这个票，这是不允许的）&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;解决问题：&lt;/h2&gt;
&lt;p&gt;　　思路：当有线程操作共享数据的代码块时，不允许其他线程参与进来，即同步（简单说就是给共享数据的代码块安个锁，线程进来的时候都要判断一下是不是有别的线程正在操作共享数据代码块）&lt;/p&gt;
&lt;p&gt;　　同步的好处：解决了安全问题&lt;/p&gt;
&lt;p&gt;　　同步的弊端：相对而言效率降低了（因为每次都需要判断锁）&lt;/p&gt;
&lt;p&gt;　　注意：这几个线程一定要使用同一个锁&lt;/p&gt;
&lt;p&gt;　　方法一：同步代码块&lt;/p&gt;
&lt;p&gt;　　方法二：同步函数&lt;/p&gt;
&lt;p&gt;　　关键字：synchronized&lt;/p&gt;

&lt;p&gt;　　实现方法一（同步代码块）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Text{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         aThread t=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; aThread();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Thread a=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(t);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Thread a1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(t);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Thread a2=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(t);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Thread a3=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(t);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        a.start();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        a1.start();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        a2.start();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        a3.start();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; aThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mun=100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Object obj=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(mun&amp;gt;0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(obj){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(mun&amp;lt;=0)&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;{Thread.sleep(5);}&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             System.out.println(Thread.currentThread().getName()+&quot;.....&quot;+mun--&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }    
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同步代码块的锁是可以自定义的，这里的锁我自定义的是Obiect类的对象obj&lt;/p&gt;

&lt;p&gt;　　实现方法二（同步函数）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Text{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         aThread t=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; aThread();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Thread a=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(t);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Thread a1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(t);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Thread a2=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(t);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Thread a3=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(t);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        a.start();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        a1.start();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        a2.start();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        a3.start();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; aThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mun=100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(mun&amp;gt;0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        show();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show(){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(mun&amp;lt;=0)&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;{Thread.sleep(5);}&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             System.out.println(Thread.currentThread().getName()+&quot;.....&quot;+mun--&lt;span&gt;);    
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同步函数的锁是固定的this&lt;/p&gt;
&lt;p&gt;静态同步函数的锁，是这个函数所属的字节码对象（class文件）&lt;/p&gt;

&lt;p&gt;　　建议使用同步代码块&lt;/p&gt;
&lt;h2&gt;死锁：&lt;/h2&gt;
&lt;p&gt;　　同步的嵌套，有两把锁，都拿着对方的锁，导致代码无法继续进行下去。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Text{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         aThread a=&lt;span&gt;new&lt;/span&gt; aThread(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         aThread a1=&lt;span&gt;new&lt;/span&gt; aThread(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Thread t=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(a);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Thread t1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(a1);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        t.start();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        t1.start();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; aThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; flag;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     aThread(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; flag){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.flag=&lt;span&gt;flag;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(flag){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(suo.suo1){
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 System.out.println(&quot;我是if锁1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(suo.suo2){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     System.out.println(&quot;我是if锁2&quot;&lt;span&gt;);    
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(suo.suo2){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 System.out.println(&quot;我是elsef锁2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(suo.suo1){
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     System.out.println(&quot;我是else锁1&quot;&lt;span&gt;);    
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }    
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; suo{
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object suo1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object suo2=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;懒汉式在多线程中的应用：&lt;/h2&gt;
&lt;p&gt;　　因为懒汉式并没有直接实例化对象，在线程0判断了if语句后进入临时阻塞状态，线程1也进入了进来，这就导致了实例化不唯一&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1344326/201803/1344326-20180322031847096-845796813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例化不唯一问题的示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Text1 {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Ab a=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ab();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Ab b=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ab();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        a.start();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        b.start();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;{Thread.sleep(10);}&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.print(a.get()==&lt;span&gt;b.get());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Single{
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Single a=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Single(){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Single  getSingle(){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(a==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;{Thread.sleep(10);}&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             a=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Single();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;  a;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Ab &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Single a;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         a=&lt;span&gt;Single.getSingle();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    Single get(){
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多试几次输出的结果就会出现false&lt;/p&gt;

&lt;p&gt;　　解决问题（同步）（饿汉式代码应该如下修改）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Single{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Single a=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Single(){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Single  getSingle(){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(a==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;synchronized&lt;/span&gt; (Single.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(a==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     a=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Single();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;               }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;  a;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：在原有的饿汉式代码中多加了一个if判断,是为了提高效率，不然的还线程总是会去判断锁，效率下降，这也是不时用同步函数的原因。&lt;/p&gt;
&lt;p&gt;　　　加了同步，是为了解决安全问题。&lt;/p&gt;
&lt;p&gt;所以在开发的时候还是使用饿汉式好&lt;/p&gt;









</description>
<pubDate>Wed, 21 Mar 2018 20:11:00 +0000</pubDate>
<dc:creator>J.FengS</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fjfsu/p/J_Feng.html</dc:identifier>
</item>
<item>
<title>【前端单元测试入门05】react的单元测试之jest - 韩子卢</title>
<link>http://www.cnblogs.com/vvjiang/p/8620847.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vvjiang/p/8620847.html</guid>
<description>&lt;h2 id=&quot;jest&quot;&gt;jest&lt;/h2&gt;
&lt;p&gt;jest是facebook推出的一款测试框架，集成了前面所讲的Mocha和chai，jsdom,sinon等功能。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;npm install --save-dev jest
npm install -g jest&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基本用法&quot;&gt;基本用法&lt;/h2&gt;
&lt;p&gt;和之前介绍的mocha和chai的功能很像，甚至可以兼容mocha和chai的语法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;test('两数相加结果为两个数字的和', () =&amp;gt; {
    expect(addNum(1, 2)).toBe(3);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行命令jest后会自动运行&lt;em&gt;.test.js和&lt;/em&gt;.spec.js这种格式的文件。&lt;br/&gt;涉及到运用ES或react的，要与babel相结合，加上.babelrc文件即可，老玩法了。&lt;/p&gt;
&lt;h2 id=&quot;mock文件和css-module的问题&quot;&gt;mock文件和css module的问题&lt;/h2&gt;
&lt;p&gt;如果js文件中引用了css或者本地其他文件，那么就可能测试失败。&lt;br/&gt;为了解决这个问题，同时也为了提高测试效率，需要在package.json中配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;jest&quot;: {
    &quot;moduleNameMapper&quot;: {
     &quot;\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$&quot;: &quot;&amp;lt;rootDir&amp;gt;/test/config/fileMock.js&quot;,
     &quot;\\.(css|less)$&quot;: &quot;identity-obj-proxy&quot;
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而fileMock.js文件内容为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = 'test-file-stub';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后安装identity-obj-proxy即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install --save-dev identity-obj-proxy&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;生成测试覆盖率报告&quot;&gt;生成测试覆盖率报告&lt;/h2&gt;
&lt;p&gt;只需要在jest命令后加入 --coverage即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jest --coverage&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7197332-516b5e4288adf9b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;单元测试覆盖率报告&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Mar 2018 16:26:00 +0000</pubDate>
<dc:creator>韩子卢</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vvjiang/p/8620847.html</dc:identifier>
</item>
<item>
<title>设计模式之漫谈 - Wang_Charle</title>
<link>http://www.cnblogs.com/wang-charle/p/8620475.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-charle/p/8620475.html</guid>
<description>&lt;p&gt;从今天（2018-03-21）开始，我将浅谈下设计模式，这个话题肯定很多人谈过。由于我知识广度和深度均有不足，如有不合理的地方请多多包涵。在此只希望能帮助更多同行的小白，借此本人感觉很慰藉。当谈完设计模式后，我将开源一个完全自己写的DAL层，包括orm,连接池，线程，事务，MSIL，设计思路等。闲话少说，先说设计模式。&lt;/p&gt;
&lt;p&gt;第一谈：简单工厂模式&lt;/p&gt;
&lt;p&gt;1.创建一个对象的方法&lt;/p&gt;
&lt;p&gt;对象就是占空间的东西，从哲学的角度考虑，在空间上存在的东西就是对象。&lt;/p&gt;
&lt;p&gt;把空间比成内存。孤零零的对象没有研究价值，在托管代码中，孤魂野鬼的对象早晚被GC回收。像行尸走肉的人，孤魂野鬼的人，活着其实已经死了。所以对象需要被引用，正如人需要信仰。&lt;/p&gt;
&lt;p&gt;创建一个对象，可以直接new(通过构造函数直接“构造”)，也可以有一个专一东西的专门创建。&lt;/p&gt;
&lt;p&gt;比如我需要一个笔记本，一种办法，我先买笔记本的各个零件，然后自己组装。另一种办法，我向一个工厂订一台笔记本，有工厂代生产。&lt;/p&gt;
&lt;p&gt;1.机械师笔记本 M411=new 机械师笔记本(零件1，零件2，。。。)；&lt;/p&gt;
&lt;p&gt;2. public class 笔记本 &lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;public CPU&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;get;set;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;public RAM&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;get;set;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;public virtual void 组装()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;public class 联想笔记本：笔记本&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;public override void 组装()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;public class 机械师笔记本：笔记本&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;public override void 组装()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;public class XXX工厂&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;

&lt;p&gt; public static 笔记本 获取笔记本（string name）&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;private 笔记本 本本=null;&lt;/p&gt;
&lt;p&gt;switch(name)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;case &quot;联想笔记本&quot;:&lt;/p&gt;
&lt;p&gt;本本=new 联想笔记本();&lt;/p&gt;
&lt;p&gt;本本.组装();&lt;/p&gt;
&lt;p&gt;return 本本;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;p&gt; //想要联想笔记本&lt;/p&gt;
&lt;p&gt;笔记本 本本=XXX工厂.获取笔记本（&quot;联想笔记本&quot;）;&lt;/p&gt;
&lt;p&gt;这样创建一个对象，可以通过工厂集中来管理。&lt;/p&gt;
&lt;p&gt;过了12点了，不能再熬夜了，写的有些粗糙，纯手写，望大家多多包涵，设计模式就是一种解决一类问题的思想，重在理解思想。&lt;/p&gt;
&lt;p&gt;晚安&lt;/p&gt;
</description>
<pubDate>Wed, 21 Mar 2018 16:23:00 +0000</pubDate>
<dc:creator>Wang_Charle</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wang-charle/p/8620475.html</dc:identifier>
</item>
<item>
<title>gulp菜鸟级零基础详细教程 - WEICHAO</title>
<link>http://www.cnblogs.com/weichao1996/p/8620652.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weichao1996/p/8620652.html</guid>
<description>&lt;h4&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/h4&gt;
&lt;h4&gt;相信大家一定听说过gulp或者webpack，grunt等前端构建工具。gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 它能自动化地完成javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。&lt;/h4&gt;
&lt;p&gt;言归正传这篇是gulp菜鸟级别的教程。大佬们觉得太简单了请不要喷我，毕竟我也是一个菜鸟。写下这篇笔记，不是为了证明什么，就是方便我以后忘了时候回顾看一下。好，废话不多说 下面开始了&lt;br/&gt;&lt;strong&gt;1、node环境搭建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想要使用gulp，首先你得在你得电脑里面安装node.js，因为gulp是基于Nodejs的自动任务运行器。这个我就不详细介绍怎么安装了吧，网上教程一搜一大把。相信正在使用gulp的朋友，也知道怎么安装node.js&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2、使用命令行工具&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;开发的环境安装好了以后，接下来就是通过命令行来下载相应开发的模块包。什么是&lt;strong&gt;命令行&lt;/strong&gt;？命令行在OSX是终端（Terminal），在windows是命令提示符（Command Prompt）windows系统下　　WIN+R打开命令行工具，在里面输入cmd,回车。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149203/201803/1149203-20180321223608362-1685474386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3、选装cnpm（淘宝镜像）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常.&lt;span class=&quot;iconfont&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;strong&gt;3.1、&lt;/strong&gt;官方网址：&lt;a href=&quot;http://npm.taobao.org/&quot; target=&quot;_blank&quot;&gt;http://npm.taobao.org&lt;/a&gt;；&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;strong&gt;3.2、&lt;/strong&gt;安装：命令提示符执行&lt;span class=&quot;cmd&quot;&gt;&lt;code&gt;npm install cnpm -g --registry=https://registry.npm.taobao.org&lt;/code&gt;；  注意：安装完后最好查看其版本号&lt;span class=&quot;cmd&quot;&gt;cnpm -v或关闭命令提示符重写打开，安装完直接使用有可能会出现错误；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm）。&lt;/p&gt;
&lt;h3 class=&quot;ti15&quot;&gt;&lt;strong&gt;4、全局安装gulp&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;strong&gt;4.1&lt;/strong&gt;、说明：全局安装gulp目的是为了通过她执行gulp任务；&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;strong&gt;4.2&lt;/strong&gt;、安装：命令提示符执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
cnpm install gulp -g
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;strong&gt;4.3&lt;/strong&gt;、查看是否正确安装：命令提示符执行&lt;span class=&quot;cmd&quot;&gt;gulp -v，出现版本号即为正确安装。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;span class=&quot;cmd&quot;&gt;&lt;strong&gt;4.4&lt;/strong&gt;、依赖安装： npm install gulp --save-dev，这个可以在你的当前的项目目录下，打开命令行工具进行依赖安装。下面我们会在介绍packge.json文件当中介绍为什么需要依赖安装&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ti15&quot;&gt;&lt;strong&gt;&lt;span class=&quot;cmd&quot;&gt;5、&lt;/span&gt;新建package.json文件&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;strong&gt;5.1&lt;/strong&gt;、package.json文件是基于node.js项目必不可少的配置文件，它是存放在项目根目录的普通json文件，里面有你各个依赖安装模块插件的版本信息，以至于你能清楚看到你安装了那些模块。如下图我安装很多模块以后的json文件。&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149203/201803/1149203-20180321224904539-1582141182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.2、配置packge.json文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
npm init    //初始化packge.json文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ti15&quot;&gt; 注意：初始化packge.json文件必须在你项目的根目录下打开命令行工具，执行初始化代码。（怎么在当前目录下打开命令行工具？shift+右键。当然，win10系统的命令行工具被微软改版了，叫Powershell，作用还是一样）&lt;/p&gt;
&lt;h3 class=&quot;ti15&quot;&gt;&lt;strong&gt;6、新建gulpfile.js文件&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;ti15&quot;&gt;既然我们要使用gulp,我们就需要建立一个gulpfile.js文件，gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件。gulp的开发代码都写在这个里面的&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;strong&gt;js代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;67&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const  gulp=require('gulp');    &lt;span&gt;//引用gulp&lt;/span&gt;
const  del=require('del');      &lt;span&gt;//引用gulp删除插件&lt;/span&gt;
const  uglify=require('gulp-uglify');　　&lt;span&gt;//引用压缩Js插件&lt;/span&gt;
const  css=require('gulp-clean-css');　　&lt;span&gt;//gulp压缩css文件&lt;/span&gt;
const  rename = require(&quot;gulp-rename&quot;);　　&lt;span&gt;//引用重命名插件&lt;/span&gt;

gulp.task('hello',function () {     &lt;span&gt;//定义一个hello任务&lt;/span&gt;
    console.log('hello')
});

&lt;span&gt;//task()：定义任务
//src():源文件
// pipe():管道流，接通源头文件与目标文件的输出
// dest():输出文件的目的地
// watch():监视文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//事例：&lt;/span&gt;
&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 1、复制单个文件&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('copyHtml',function () {
    return gulp.src('./src/public/login.html').pipe(gulp.dest(&quot;dist/public&quot;))
});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 2、复制多个文件&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('copyAllHtml',function () {
    return gulp.src(&quot;./src/public/*.html&quot;).pipe(gulp.dest('dist/public'));
});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 3、复制指定文件&lt;/span&gt;
&lt;span&gt;// [指定的文件已，指定的文件2]&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('copy2Js',function () {
    return gulp.src([&quot;./src/public/js/ajax.js&quot;,'dist/public/js/classPage.js'])
    .pipe(gulp.dest(&quot;dist/public/js&quot;))
});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 4、某个文件
// ！排队的文件&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task(&quot;copyNoJs&quot;,function () {
    return gulp.src(['./src/public/js/*.js','!./src/public/js/Classroom.js'])
        .pipe(gulp.dest('dist/public/js'))
});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 5、复制多个后缀名的图片
// {选项一，选项二}&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task(&quot;copyImage&quot;,function () {
    return gulp.src('./src/public/img/*.{png,jpg,bmp,jpeg,gif}')
        .pipe(gulp.dest('dist/public/img'))
});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 6、执行多个任务
// gulp.task('任务名称',[任务依赖的模块],回调函数)
// 依赖任务之间没有顺序之分，异步执行
// 依赖任务之间完成后，在执行当前的回调函数&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('build',['copyAllHtml','copyNoJs','copyImage'],function () {
    console.log('编译成功')
});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 7、Watch:监视文件的变化&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('myWatch',function () {
    gulp.watch('./src/public/login.html',['build'])
});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 8、删除文件&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task(&quot;del&quot;,function () {
    // del('./dist/public/img/*.{jpg,png,jepg,gif}')
    // *：所有文件
    // **：所有文件夹
    del(['./dist/public/js/*']);
    del(['./dist/**/*']);
});

gulp.task('default',function () {
    gulp.start('serve')

});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 9、压缩js文件&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('ysjs',function(){
    return gulp.src('./src/public/js/*.js')
    .pipe(uglify())
    .pipe(gulp.dest('./src/public/js'));


});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;//10、 添加监听&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('watch_js',function(){
    return gulp.watch('./src/public/js/*.js',['ysjs'])

});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;//11、压缩css文件&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('css',function () {
    return gulp.src('./src/public/sass/*.css')
        .pipe(css())
        .pipe(gulp.dest('./src/public/sass'))
});
&lt;em&gt;&lt;strong&gt;&lt;span&gt;//添加监听&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('jtCss',function () {
    return gulp.watch('./src/public/sass/*.css',['css'])
});
&lt;em&gt;&lt;strong&gt;&lt;span&gt;//12、重命名css文件&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('reName',function () {
    return gulp.src('./src/public/sass/*.css')
        .pipe(rename({suffix: '.css'}))
        .pipe(css())
        .pipe(gulp.dest('./src/public/sass'))
});　　
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;lesson9&quot;&gt;7、运行gulp&lt;/h3&gt;
&lt;p class=&quot;ti15&quot;&gt;7.1、说明：命令提示符执行&lt;span class=&quot;cmd&quot;&gt;gulp 任务名称；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;7.2、编译less：命令提示符执行&lt;span class=&quot;cmd&quot;&gt;gulp testLess；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;7.3、当执行&lt;span class=&quot;cmd&quot;&gt;gulp default或&lt;span class=&quot;cmd&quot;&gt;gulp将会调用default任务里的所有任务&lt;strong&gt;&lt;span&gt;[‘testLess’,’elseTask’]&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;lesson10&quot;&gt;8、使用webstorm运行gulp任务&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149203/201803/1149203-20180321232448546-653084594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;9、使用vscode运行gulp任务&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;vcode是微软出的一款轻量级代码编辑器，免费而且功能强大，对JavaScript和NodeJS的支持非常好，自带很多功能，例如代码格式化，代码智能提示补全、Emmet插件等。&lt;/p&gt;
&lt;p&gt;在vscode上我们想要简单的运行gulp任务，我们可以下载一款名为“Gulp Tasks ”的插件。安装好插件以后，我们将项目文件添加到工作区当中，然后打开gulpfile.js文件。&lt;/p&gt;
&lt;p&gt;在左下角我们可以启动任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149203/201803/1149203-20180321233509707-2067950526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;10、总结：&lt;/h3&gt;
&lt;p class=&quot;ti15&quot;&gt;10.1、安装nodejs；&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;10.2、新建package.json文件；&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;10.3、全局和本地依赖安装gulp；&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;10.4、安装gulp插件；&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;10.5、新建gulpfile.js文件；&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;10.6、通过命令提示符或者开发工具运行gulp任务。&lt;/p&gt;

&lt;p class=&quot;ti15&quot;&gt;&lt;span class=&quot;cmd&quot;&gt;&lt;span class=&quot;cmd&quot;&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Wed, 21 Mar 2018 15:37:00 +0000</pubDate>
<dc:creator>WEICHAO</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weichao1996/p/8620652.html</dc:identifier>
</item>
<item>
<title>Beego 框架学习(一) - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/8620635.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/8620635.html</guid>
<description>&lt;p&gt; Beego官网本身已经整理的非常详细了，但是作为一个学习者，我还是决定自己好好整理一下，这样在后面使用的时候自己对每部分才能非常熟悉，即使忘记了，也可以迅速定位自己要用的知识在哪里。当然也是对官网的一个精简整理，同时结合一些例子，更好的理解和学习Beego&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;Beego官网地址：&lt;a href=&quot;https://beego.me&quot;&gt;https://beego.me&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这次整理也是一个初步的整理，正好在这个之后把之前通过net/http实现的短url项目通过beego框架实现一遍&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;Beego的安装&lt;/h2&gt;
&lt;p&gt;go get github.com/astaxie/beego&lt;/p&gt;
&lt;p&gt;bee 工具是一个为了协助快速开发 beego 项目而创建的项目，通过 bee 您可以很容易的进行 beego 项目的创建、热编译、开发、测试、和部署。&lt;/p&gt;
&lt;p&gt;go get github.com/beego/bee&lt;/p&gt;
&lt;p&gt;当我们安装好bee之后，bee命令默认是放在&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-1-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;G&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;O&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;P&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;A&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;T&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;H&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;/&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;i&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;n&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x91CC;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x9762;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#xFF0C;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x6240;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x4EE5;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x9700;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x8981;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x628A;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-2&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-3&quot; class=&quot;mi&quot;&gt;G&lt;span id=&quot;MathJax-Span-4&quot; class=&quot;mi&quot;&gt;O&lt;span id=&quot;MathJax-Span-5&quot; class=&quot;mi&quot;&gt;P&lt;span id=&quot;MathJax-Span-6&quot; class=&quot;mi&quot;&gt;A&lt;span id=&quot;MathJax-Span-7&quot; class=&quot;mi&quot;&gt;T&lt;span id=&quot;MathJax-Span-8&quot; class=&quot;mi&quot;&gt;H&lt;span id=&quot;MathJax-Span-9&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-10&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-11&quot; class=&quot;mo&quot;&gt;/&lt;span id=&quot;MathJax-Span-12&quot; class=&quot;mi&quot;&gt;b&lt;span id=&quot;MathJax-Span-13&quot; class=&quot;mi&quot;&gt;i&lt;span id=&quot;MathJax-Span-14&quot; class=&quot;mi&quot;&gt;n&lt;span id=&quot;MathJax-Span-15&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-16&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-17&quot; class=&quot;mo&quot;&gt;里&lt;span id=&quot;MathJax-Span-18&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-19&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-20&quot; class=&quot;mo&quot;&gt;面&lt;span id=&quot;MathJax-Span-21&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-22&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-23&quot; class=&quot;mo&quot;&gt;，&lt;span id=&quot;MathJax-Span-24&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-25&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-26&quot; class=&quot;mo&quot;&gt;所&lt;span id=&quot;MathJax-Span-27&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-28&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-29&quot; class=&quot;mo&quot;&gt;以&lt;span id=&quot;MathJax-Span-30&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-31&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-32&quot; class=&quot;mo&quot;&gt;需&lt;span id=&quot;MathJax-Span-33&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-34&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-35&quot; class=&quot;mo&quot;&gt;要&lt;span id=&quot;MathJax-Span-36&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-37&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-38&quot; class=&quot;mo&quot;&gt;把&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;GOPATH/bin里面，所以需要把GOPATH/bin 添加到您的环境变量中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;bee常用的命令&lt;/p&gt;
&lt;p&gt;bee new &amp;lt;项目名&amp;gt; ：创建一个项目,这样的项目一般是web项目&lt;br/&gt;需要注意的是这个命令须在 $GOPATH/src 下执行，最后生成的目录结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;├── conf
│   └── app.conf
├── controllers
│   └── default.go
├── main.go
├── models
├── routers
│   └── router.go
├── static
│   ├── css
│   ├── img
│   └── js
│       └── reload.min.js
├── tests
│   └── default_test.go
└── views
    └── index.tpl&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bee api myapi : 创建一个api项目，生成的目录结构为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;├── conf
│   └── app.conf
├── controllers
│   ├── object.go
│   └── user.go
├── main.go
├── models
│   ├── object.go
│   └── user.go
├── routers
│   └── router.go
└── tests
    └── default_test.go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bee run 命令是监控 beego 的项目，通过 fsnotify监控文件系统。但是注意该命令必须在 $GOPATH/src/appname 下执行。这样当我们在开发过程中，beego可以实时监测我们的代码文件发生变化，这样我们就不用重新编译运行，非常方便我们调试，我们可以将上面的myweb2项目通过bee run运行起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;localhost:myweb2 zhaofan$ go run
go run: no go files listed
localhost:myweb2 zhaofan$ bee run
______
&lt;/span&gt;|&lt;span&gt; ___ \
&lt;/span&gt;| |_/ /&lt;span&gt;  ___   ___
&lt;/span&gt;| ___ \ / _ \ /&lt;span&gt; _ \
&lt;/span&gt;| |_/ /|  __/|  __/&lt;span&gt;
\____&lt;/span&gt;/  \___| \___| v1.9.1
2018/03/19 23:59:20 INFO     ▶ 0001 Using 'myweb2' as 'appname'
2018/03/19 23:59:20 INFO     ▶ 0002&lt;span&gt; Initializing watcher...
myweb2&lt;/span&gt;/&lt;span&gt;controllers
myweb2&lt;/span&gt;/&lt;span&gt;routers
myweb2
&lt;/span&gt;2018/03/19 23:59:22 SUCCESS  ▶ 0003 Built Successfully!
2018/03/19 23:59:22 INFO     ▶ 0004 Restarting 'myweb2'&lt;span&gt;...
&lt;/span&gt;2018/03/19 23:59:22 SUCCESS  ▶ 0005 './myweb2'&lt;span&gt; is running...
&lt;/span&gt;2018/03/19 23:59:22.572 [I] [asm_amd64.s:2337] http server Running on http://:8080
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们通过打开浏览器访问：http://127.0.0.1:8080,可以看到如图：&lt;a href=&quot;http://127.0.0.1:8080,%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%A6%82%E5%9B%BE%EF%BC%9A&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180321232942204-1402119529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;Beego 架构了解&lt;/h2&gt;
&lt;p&gt;Beego架构图如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180321233004672-238888081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是Beegode 八大独立的模块&lt;/p&gt;
&lt;p&gt;Beego的执行逻辑，beego 是一个典型的 MVC 架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180321233021296-480972597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们从上面myweb2的目录接口也可以看出来：&lt;br/&gt;M（models 目录）、V（views 目录）和 C（controllers 目录）的结构&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;Beego路由设置&lt;/h2&gt;
&lt;p&gt;我们看一下Beego的入口函数：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    _ &lt;/span&gt;&quot;myweb2/routers&quot;
    &quot;github.com/astaxie/beego&quot;&lt;span&gt;
)

func main() {
    beego.Run()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引入了一个包 _ &quot;myweb2/routers 我们看一下这个包的内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package routers

import (
    &lt;/span&gt;&quot;myweb2/controllers&quot;
    &quot;github.com/astaxie/beego&quot;&lt;span&gt;
)

func init() {
    beego.Router(&lt;/span&gt;&quot;/&quot;, &amp;amp;&lt;span&gt;controllers.MainController{})
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里仅仅做了一个初始化，路由包里面我们看到执行了路由注册 beego.Router, 这个函数的功能是映射 URL 到 controller，第一个参数是 URL (用户请求的地址)，这里我们注册的是 /，也就是我们访问的不带任何参数的 URL，第二个参数是对应的 Controller，也就是我们即将把请求分发到那个控制器来执行相应的逻辑。这里对路由设置的一个小结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Router方法设置url和处理url的controller&lt;/li&gt;
&lt;li&gt;程序启动时，路由配置加载好，保存在map中&lt;/li&gt;
&lt;li&gt;请求处理时，通过请求的url进行查找对应的controller,把处理路由到controller进行执行&lt;/li&gt;
&lt;li&gt;我们就只需要编写自己的controller就好啦&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们看一下controller的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package controllers

import (
    &lt;/span&gt;&quot;github.com/astaxie/beego&quot;&lt;span&gt;
)

type MainController struct {
    beego.Controller  &lt;/span&gt;//&lt;span&gt; 这里可以看做是其他语言中的继承
}

func (c &lt;/span&gt;*&lt;span&gt;MainController) Get() {
    c.Data[&lt;/span&gt;&quot;Website&quot;] = &quot;beego.me&quot;&lt;span&gt;
    c.Data[&lt;/span&gt;&quot;Email&quot;] = &quot;astaxie@gmail.com&quot;&lt;span&gt;
    c.TplName &lt;/span&gt;= &quot;index.tpl&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对上述代码进行简单分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户的controller嵌套bee.Controller， 继承bee.Controller所有属性和&lt;/li&gt;
&lt;li&gt;方法&lt;/li&gt;
&lt;li&gt;Controller默认使用restful的风格，Get请求对应Get方法&lt;/li&gt;
&lt;li&gt;请求处理时，通过请求的url进行查找对应的controller，把处理路由到 controller进行执行&lt;/li&gt;
&lt;li&gt;通过业务逻辑处理之后，把数据赋值给Controller.Data这个map即可&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述代码中：c.TplName = &quot;index.tpl&quot;默认回去views下面去找模板文件&lt;br/&gt;除了上面的C.Data这种方法之外，还有很多方法，如常用的c.ServerJson()这样就会去c.Data中寻找key为json的值&lt;/p&gt;
&lt;p&gt;用户设置了模板之后系统会自动的调用 Render 函数（这个函数是在 beego.Controller 中实现的），所以无需用户自己来调用渲染。&lt;/p&gt;
&lt;p&gt;当然也可以不使用模版，直接用 this.Ctx.WriteString 输出字符串，如：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
func (c *&lt;span&gt;MainController) Get() {
        c.Ctx.WriteString(&lt;/span&gt;&quot;hello&quot;&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正则路由&lt;br/&gt;beego.Router(“/api/?:id”, &amp;amp;controllers.RController{}) 默认匹配 //匹配 /api/123 :id = 123 可以匹配 /api/ 这个URL&lt;/p&gt;
&lt;p&gt;beego.Router(“/api/:id”, &amp;amp;controllers.RController{}) 默认匹配 //匹配 /api/123 :id = 123 不可以匹配 /api/ 这个URL&lt;/p&gt;
&lt;p&gt;beego.Router(“/api/:id([0-9]+)“, &amp;amp;controllers.RController{}) 自定义正则匹配 //匹配 /api/123 :id = 123&lt;/p&gt;
&lt;p&gt;beego.Router(“/user/:username([\w]+)“, &amp;amp;controllers.RController{}) 正则字符串匹配 //匹配 /user/astaxie :username = astaxie&lt;/p&gt;
&lt;p&gt;beego.Router(“/download/*.*”, &amp;amp;controllers.RController{}) *匹配方式 //匹配 /download/file/api.xml :path= file/api :ext=xml&lt;/p&gt;
&lt;p&gt;beego.Router(“/download/ceshi/*“, &amp;amp;controllers.RController{}) *全匹配方式 //匹配 /download/ceshi/file/api.json :splat=file/api.json&lt;/p&gt;
&lt;p&gt;beego.Router(“/:id:int”, &amp;amp;controllers.RController{}) int 类型设置方式，匹配 :id为int 类型，框架帮你实现了正则 ([0-9]+)&lt;/p&gt;
&lt;p&gt;beego.Router(“/:hi:string”, &amp;amp;controllers.RController{}) string 类型设置方式，匹配 :hi 为 string 类型。框架帮你实现了正则 ([\w]+)&lt;/p&gt;
&lt;p&gt;beego.Router(“/cms_:id([0-9]+).html”, &amp;amp;controllers.CmsController{}) 带有前缀的自定义正则 //匹配 :id 为正则类型。匹配 cms_123.html 这样的 url :id = 123&lt;/p&gt;
&lt;p&gt;可以在 Controller 中通过如下方式获取上面的变量：&lt;br/&gt;this.Ctx.Input.Param(&quot;:id&quot;)&lt;br/&gt;this.Ctx.Input.Param(&quot;:username&quot;)&lt;br/&gt;this.Ctx.Input.Param(&quot;:splat&quot;)&lt;br/&gt;this.Ctx.Input.Param(&quot;:path&quot;)&lt;br/&gt;this.Ctx.Input.Param(&quot;:ext&quot;)&lt;/p&gt;
&lt;p&gt;自定义方法及 RESTful 规则:&lt;br/&gt;beego.Router(&quot;/&quot;,&amp;amp;IndexController{},&quot;*:Index&quot;)&lt;br/&gt;使用第三个参数，第三个参数就是用来设置对应 method 到函数名，定义如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;*表示任意的 method 都执行该函数&lt;/li&gt;
&lt;li&gt;使用 httpmethod:funcname 格式来展示&lt;/li&gt;
&lt;li&gt;多个不同的格式使用 ; 分割&lt;/li&gt;
&lt;li&gt;多个 method 对应同一个 funcname，method 之间通过 , 来分割&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;beego.Router(&quot;/api&quot;,&amp;amp;RestController{},&quot;get,post:ApiFunc&quot;)&lt;/p&gt;
&lt;p&gt;可用的 HTTP Method：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;*: 包含以下所有的函数&lt;/li&gt;
&lt;li&gt;get: GET 请求&lt;/li&gt;
&lt;li&gt;post: POST 请求&lt;/li&gt;
&lt;li&gt;put: PUT 请求&lt;/li&gt;
&lt;li&gt;delete: DELETE 请求&lt;/li&gt;
&lt;li&gt;patch: PATCH 请求&lt;/li&gt;
&lt;li&gt;options: OPTIONS 请求&lt;/li&gt;
&lt;li&gt;head: HEAD 请求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果同时存在 * 和对应的 HTTP Method，那么优先执行 HTTP Method 的方法&lt;/p&gt;
&lt;h2 id=&quot;toc_4&quot;&gt;Beego的model&lt;/h2&gt;
&lt;p&gt;我们知道 Web 应用中我们用的最多的就是数据库操作，而 model 层一般用来做这些操作，我们的 bee new 例子不存在 Model 的演示，但是 bee api 应用中存在 model 的应用。说的简单一点，如果您的应用足够简单，那么 Controller 可以处理一切的逻辑，如果您的逻辑里面存在着可以复用的东西，那么就抽取出来变成一个模块。因此 Model 就是逐步抽象的过程，&lt;/p&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;Beego的views层&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Beego模板默认支持:.tpl和.html两种后缀&lt;/li&gt;
&lt;li&gt;beego.AddTemplateExt增加新的模板后缀&lt;/li&gt;
&lt;li&gt;Beego模板用的就是Go官网自带的模板&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;toc_6&quot;&gt;静态文件&lt;/h2&gt;
&lt;p&gt;beego 默认注册了 static 目录为静态处理的目录，注册样式：URL 前缀和映射的目录（在/main.go文件中beego.Run()之前加入）：StaticDir[&quot;/static&quot;] = &quot;static&quot;&lt;/p&gt;
&lt;p&gt;Beego默认使用static目录作为静态文件目录&lt;br/&gt;beego.SetStaticPath增加新的静态文件目录&lt;/p&gt;
&lt;h2 id=&quot;toc_7&quot;&gt;配置文件读取&lt;/h2&gt;
&lt;p&gt;默认的配置文件内容：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
appname =&lt;span&gt; myweb2
httpport &lt;/span&gt;= 8080&lt;span&gt;
runmode &lt;/span&gt;= dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然前提是你已经在自己配置文件中添加了下面这些字段：&lt;br/&gt;beego.AppConfig.String(&quot;mysql_user&quot;)&lt;br/&gt;beego.AppConfig.String(&quot;mysql_pwd&quot;)&lt;/p&gt;
&lt;p&gt;如果我们将配置文件更改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
appname =&lt;span&gt; myweb2
httpport &lt;/span&gt;= 8080&lt;span&gt;
runmode &lt;/span&gt;=&lt;span&gt; dev

[dbconfig]
mysqlhost &lt;/span&gt;= 127.0.0.1&lt;span&gt;
mysqlport &lt;/span&gt;= 3308&lt;span&gt;
username &lt;/span&gt;=&lt;span&gt; root
passwd &lt;/span&gt;= 123
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以通过[命名]的方式将配置文件进行分组&lt;br/&gt;这样当我们获取变量的时候，可以通过下面方式获取：&lt;/p&gt;
&lt;p&gt;beego.AppConfig.String(&quot;dbconfig::mysql_user&quot;)&lt;br/&gt;beego.AppConfig.String(&quot;dbconfig::mysql_port&quot;)&lt;/p&gt;
&lt;p&gt;AppConfig 的方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Set(key, val string) error
String(key string) string
Strings(key string) []string
Int(key string) (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;, error)
Int64(key string) (int64, error)
Bool(key string) (bool, error)
Float(key string) (float64, error)
DefaultString(key string, defaultVal string) string
DefaultStrings(key string, defaultVal []string)
DefaultInt(key string, defaultVal &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;) &lt;span&gt;int&lt;/span&gt;&lt;span&gt;
DefaultInt64(key string, defaultVal int64) int64
DefaultBool(key string, defaultVal bool) bool
DefaultFloat(key string, defaultVal float64) float64
DIY(key string) (interface{}, error)
GetSection(section string) (map[string]string, error)
SaveConfigFile(filename string) error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_8&quot;&gt;获取用户提交的参数&lt;/h2&gt;
&lt;p&gt;Controller中的方法获取&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GetString(key string) string&lt;/li&gt;
&lt;li&gt;GetStrings(key string) []string&lt;/li&gt;
&lt;li&gt;GetInt(key string) (int64, error)&lt;/li&gt;
&lt;li&gt;GetBool(key string) (bool, error)&lt;/li&gt;
&lt;li&gt;GetFloat(key string) (float64, error)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不管是post还是get的其他方式提交的数据都可以通过上面的方式获取&lt;/p&gt;
&lt;p&gt;如果在平常开发中肯定设计到和其他语言的对接数据，这个时候对方发过来的数据可能就是一个json格式的数据，如果想要获取可以通过下面方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接通过Ctx.Input.RequestBody获取原始的数据&lt;/li&gt;
&lt;li&gt;配置文件里设置 copyrequestbody = true&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样就可以通过c.Ctx.Input.RequestBody 获取&lt;/p&gt;

</description>
<pubDate>Wed, 21 Mar 2018 15:35:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/8620635.html</dc:identifier>
</item>
<item>
<title>NEO从入门到开窗(2) - 智能合约的面相 - Dexter Di</title>
<link>http://www.cnblogs.com/DexterDi/p/8620589.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DexterDi/p/8620589.html</guid>
<description>&lt;p&gt;一、啰嗦两句&lt;/p&gt;
&lt;p&gt;昨天讲了智能合约的一生，那丫长啥样啊？今儿我就跟各位唠叨唠叨。&lt;/p&gt;

&lt;p&gt;二、一个简单的智能合约&lt;/p&gt;
&lt;p&gt;下面这段就是NEO实例源码里的一个，干撒用的？聪明的你一眼儿就看出来了吧，就是一个所谓域名合约的增删改查。有几点我唠叨两句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Neo.SmartContract.Framework.Services.Neo;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Neo.SmartContract
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Domain : Framework.SmartContract
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt; operation, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (operation)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Query((&lt;span&gt;string&lt;/span&gt;)args[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;register&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Register((&lt;span&gt;string&lt;/span&gt;)args[&lt;span&gt;0&lt;/span&gt;], (&lt;span&gt;byte&lt;/span&gt;[])args[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;transfer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Transfer((&lt;span&gt;string&lt;/span&gt;)args[&lt;span&gt;0&lt;/span&gt;], (&lt;span&gt;byte&lt;/span&gt;[])args[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Delete((&lt;span&gt;string&lt;/span&gt;)args[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] Query(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; domain)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Storage.Get(Storage.CurrentContext, domain);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Register(&lt;span&gt;string&lt;/span&gt; domain, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] owner)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Runtime.CheckWitness(owner)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] value =&lt;span&gt; Storage.Get(Storage.CurrentContext, domain);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            Storage.Put(Storage.CurrentContext, domain, owner);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Transfer(&lt;span&gt;string&lt;/span&gt; domain, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] to)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Runtime.CheckWitness(to)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] &lt;span&gt;from&lt;/span&gt; =&lt;span&gt; Storage.Get(Storage.CurrentContext, domain);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;from&lt;/span&gt; == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Runtime.CheckWitness(&lt;span&gt;from&lt;/span&gt;)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            Storage.Put(Storage.CurrentContext, domain, to);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Delete(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; domain)
        {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] owner =&lt;span&gt; Storage.Get(Storage.CurrentContext, domain);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (owner == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Runtime.CheckWitness(owner)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            Storage.Delete(Storage.CurrentContext, domain);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1. 上一节讲了，一个智能合约就是继承自SmartContract的类，Main函数啊，方法啊，全得是静态的，因为NEO的编译器就认静态的。&lt;/p&gt;
&lt;p&gt;2. Main就是智能合约的入口，调用的时候会穿些参数，第一个就是opeartion，根据这个来判断是啥操作，这点和Fabric很像，就一个init一个invoke，Etherenum不是这样的。&lt;/p&gt;
&lt;p&gt;3. 逻辑都能看明白，这个Storage是个啥玩意，看上去像个存储，在哪存储？这不就是serverless吗？ok，咱就以此为突破，重点关注一下这个Storage。&lt;/p&gt;
&lt;p&gt;源码说话。这个Storage是NEO工具包（SmartContract那个类一个项目下的）里的一个类，我们看下源码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Numerics;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Neo.SmartContract.Framework.Services.Neo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Storage
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt;&lt;span&gt; StorageContext CurrentContext
        {
            [Syscall(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Neo.Storage.GetContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;;
        }

        [Syscall(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Neo.Storage.Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] Get(StorageContext context, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] key);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我把其他方法都删了，留一个Get方法，示意一下。看到这，是不是有点懵逼，SysCall什么鬼，这种写法是不是似曾相识？是不是和dllimport差不多？其实我琢磨着作者写的时候也有这么个意图，就说啊，这是一系统调用啊，调用咱系统的东西。那到底这玩意儿咋个原理，咱们就得看NEO的编译器源码了。上一节咱提了，NEO的编译器就是根据规则把对应的代码翻译成指令码，编译器这部分咱后面也要说，找源码的过程比较琐碎，不贴代码了，这里先理解成编译器把他编译成OpCode.SYSCALL Neo.Storage.Get，就是系统调用Neo.Storage.Get。下面的问题就是NEO的虚拟机该怎么解释这个指令了，我们再去NEO.VM项目里找结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span readability=&quot;2&quot;&gt;private readonly InteropService service;&lt;p&gt;　　　　　　　　　　　　case&lt;/p&gt;&lt;/span&gt;&lt;span&gt; OpCode.SYSCALL:
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!service.Invoke(Encoding.ASCII.GetString(context.OpReader.ReadVarBytes(&lt;span&gt;252&lt;/span&gt;)), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;))
                            State &lt;/span&gt;|=&lt;span&gt; VMState.FAULT;
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看看Interopservice里Invoke都干了些啥，也是删除了部分代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Neo.VM
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InteropService
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, Func&amp;lt;ExecutionEngine, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; dictionary = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, Func&amp;lt;ExecutionEngine, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InteropService()
        {
            Register(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.ExecutionEngine.GetScriptContainer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetScriptContainer);
            Register(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.ExecutionEngine.GetExecutingScriptHash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetExecutingScriptHash);
            Register(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.ExecutionEngine.GetCallingScriptHash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetCallingScriptHash);
            Register(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.ExecutionEngine.GetEntryScriptHash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetEntryScriptHash);
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Register(&lt;span&gt;string&lt;/span&gt; method, Func&amp;lt;ExecutionEngine, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; handler)
        {
            dictionary[method] &lt;/span&gt;=&lt;span&gt; handler;
        }

        &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Invoke(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; method, ExecutionEngine engine)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!dictionary.ContainsKey(method)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dictionary[method](engine);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来InteropService里保留了一个字段，根据不同的方法名，注册不同的执行方法，我们要找的Neo.Storage.Get这个方法key是在那里注册的呢？搜。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Neo.SmartContract
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StateReader : InteropService
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; EventHandler&amp;lt;NotifyEventArgs&amp;gt;&lt;span&gt; Notify;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; EventHandler&amp;lt;LogEventArgs&amp;gt;&lt;span&gt; Log;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; StateReader Default = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StateReader();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StateReader()
        {
            Register(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Neo.Storage.Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Storage_Get);
        }

       &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Storage_Get(ExecutionEngine engine)
        {
            StorageContext context &lt;/span&gt;= engine.EvaluationStack.Pop().GetInterface&amp;lt;StorageContext&amp;gt;&lt;span&gt;();
            ContractState contract &lt;/span&gt;=&lt;span&gt; Blockchain.Default.GetContract(context.ScriptHash);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (contract == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!contract.HasStorage) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] key =&lt;span&gt; engine.EvaluationStack.Pop().GetByteArray();
            StorageItem item &lt;/span&gt;= Blockchain.Default.GetStorageItem(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StorageKey
            {
                ScriptHash &lt;/span&gt;=&lt;span&gt; context.ScriptHash,
                Key &lt;/span&gt;=&lt;span&gt; key
            });
            engine.EvaluationStack.Push(item&lt;/span&gt;?.Value ?? &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到Blockchain.Default.GetstorageItem()这个方法了吧，虚拟机执行器把链上的数据取出来了，这个Blockchain的实现是leveldb这个咱也后面再讲。&lt;/p&gt;
&lt;p&gt;好啦，到现在这一圈可以理解智能合约的执行过程了吧。聪明的你也一定发现了，你看的懂的那些逻辑，也会被NEO的编译器编译成指令码，这部分就复杂咯，后面咱们讲编译器的时候详细的说，编译器这块还是挺复杂的，面向代码作者拜一拜。。。&lt;/p&gt;

&lt;p&gt;三、小结&lt;/p&gt;
&lt;p&gt;智能合约好写，很容易理解，但是从头撸到底才能透彻的知道了解它的运行原理，撸的过程略过了很多东西，聪明的你一定很好奇吧，别着急，咱们下回书，再说。&lt;/p&gt;

</description>
<pubDate>Wed, 21 Mar 2018 15:28:00 +0000</pubDate>
<dc:creator>Dexter Di</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DexterDi/p/8620589.html</dc:identifier>
</item>
<item>
<title>线程池ThreadPoolExecutor源码解读研究（JDK1.8） - 我心自在</title>
<link>http://www.cnblogs.com/10158wsj/p/8620200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/10158wsj/p/8620200.html</guid>
<description>&lt;h2&gt;一、什么是线程池&lt;/h2&gt;
&lt;p&gt;       为什么要使用线程池？在多线程并发开发中，线程的数量较多，且每个线程执行一定的时间后就结束了，下一个线程任务到来还需要重新创建线程，这样线程数量特别庞大的时候，频繁的创建线程和销毁线程需要一定时间而且增加系统的额外开销。基于这样的场景，线程池就出现了，线程池可以做到一个线程的任务处理完可以接受下一个任务，并不需要频繁的创建销毁，这样大大节省了时间和系统的开销。&lt;/p&gt;
&lt;p&gt;         线程池，顾名思义，就是一个池子，任务提交的到线程池后，线程池会在池子里边找有没有空闲的线程，如果没有，就会进入等待状态，有就会分配一个空闲的线程来接受这个任务，当服务执行完，从新放回到线程池，不需要销毁。在这种模式下，系统大大减少了创建线程个销毁线程的资源开销，而且一个线程可以用来执行多个任务，我们可以根据系统的配置灵活调整线程池的大小，从而更高效的执行任务。&lt;/p&gt;
&lt;h2&gt;二、线程池类之间关系&lt;/h2&gt;
&lt;p&gt;       线程池主要包含：Executors，Executor，ExecutorService，AbstractExecutorService，ThreadPoolExecutor这些类。Executors用来创建线程池，返回ExecutorService的对象，该对象就可以调用execute方法或者submit方法执行线程。当然，我们也可以自己new一个。&lt;/p&gt;
&lt;p&gt;Executor，ExecutorService，AbstractExecutorService，ThreadPoolExecutor的继承关系的继承关系为：Executor是一个接口，里面只有execute方法声明，接口ExecutorService继承Executor接口，里面包含shutdown()，shutdownNow()，isTerminated()，submit等方法; AbstractExecutorService是ExecutorService的实现类，实现了该类中的方法，ThreadPoolExecutor继承AbstractExecutorService。&lt;/p&gt;
&lt;h2&gt;三、线程池状态说明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;RUNNING&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;可以接受新任务，也可以处理阻塞队列里面的任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SHUTDOWN&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;不接受新任务，但是可以处理阻塞队列里的任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STOP&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;不在接收新任务，也不再处理阻塞队列里的任务，并中断正在处理的任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIDYING&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;中间状态：线程池中没有有效的线程，调用terminate进入TERMINATE状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TERMINATE：&lt;/strong&gt;终止状态&lt;/p&gt;
&lt;h2&gt;四、线程池源码分析&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ExecutorService  executor = Executors.newFixedThreadPool(100);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过API我们可以看到创建线程池的过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService newFixedThreadPool(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nThreads) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(nThreads, nThreads,
                                      &lt;/span&gt;0L&lt;span&gt;, TimeUnit.MILLISECONDS,
                                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Executors这个类中基本都是静态方法，代理了线程池的创建，大大简化了我么创建线程池工作量，通过方法名我们就可以创建我们想要的线程池，他的内部其实都是统一的方法实现的，通过构造方法重载实现不同的功能，但是不看源码，是很难知道他们的具体作用的。我们可以看到，这里面有好几种创建线程池的方法，他们有什么区别呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. newFixedThreadPool(int)&lt;/strong&gt;方法,内部实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建指定大小的线程池，如果超出大小，放入block队列，即LinkedBlockingQueue队列，默认的线程工厂为defaultThreadFactory。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. newWorkStealingPool(int)，&lt;/strong&gt;内部实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService newWorkStealingPool(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; parallelism) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ForkJoinPool
            (parallelism,
             ForkJoinPool.defaultForkJoinWorkerThreadFactory,
             &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JDK1.8新增，返回ForkJoin，个人感觉有一点mapReduce的思想。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.newSingleThreadPool&lt;/strong&gt;，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService newSingleThreadExecutor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FinalizableDelegatedExecutorService
            (&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 1&lt;span&gt;,
                                    &lt;/span&gt;0L&lt;span&gt;, TimeUnit.MILLISECONDS,
                                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建单个线程的线程池。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. newCachedThreadPool&lt;/strong&gt;，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService newCachedThreadPool() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(0&lt;span&gt;, Integer.MAX_VALUE,
                                      &lt;/span&gt;60L&lt;span&gt;, TimeUnit.SECONDS,
                                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;线程池长度超过处理需要，灵活回收空闲线程，若无可回收，则创建新线程。&lt;/p&gt;
&lt;p&gt;        Executors里面还有好多方法，我们仔细查看API就可以了解的个大概，它是一个工具类，提供了一些静态方法。从源码中我们可以看到创建线程池返回的是return new ThreadPoolExecutor方法，它的源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_994d3cd4-f80f-45cf-9d38-b04d517f506e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_994d3cd4-f80f-45cf-9d38-b04d517f506e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_994d3cd4-f80f-45cf-9d38-b04d517f506e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize,
                              &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
                              &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;/span&gt;&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (corePoolSize &amp;lt; 0 ||&lt;span&gt;
            maximumPoolSize &lt;/span&gt;&amp;lt;= 0 ||&lt;span&gt;
            maximumPoolSize &lt;/span&gt;&amp;lt; corePoolSize ||&lt;span&gt;
            keepAliveTime &lt;/span&gt;&amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (workQueue == &lt;span&gt;null&lt;/span&gt; || threadFactory == &lt;span&gt;null&lt;/span&gt; || handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.corePoolSize =&lt;span&gt; corePoolSize;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.maximumPoolSize =&lt;span&gt; maximumPoolSize;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.workQueue =&lt;span&gt; workQueue;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.keepAliveTime =&lt;span&gt; unit.toNanos(keepAliveTime);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.threadFactory =&lt;span&gt; threadFactory;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handler =&lt;span&gt; handler;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;        刚看源码的时候的确很痛苦，我们得熟悉作者的思想，他为什么要这么写，知道了作者的思想以后就好办多了，我是结合英文说明来揣摩的，下面我们看每个参数的意思。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;corePoolSize&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;核心线程大小，线程数一旦超过这个值，多余的就会被放入等待队列&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;maximumPoolSize&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;线程池中的最大线程数量，这个一般用不到，源码中可以看到corePoolSize和maximumPoolSize是一样的，不同的是大于这个值会由丢弃处理机制来处理，不会被放入等待队列。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;keepAliveTime&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;保持时间，当线程没有任务处理后，保持多久结束，默认是0&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;workQueue&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;等待队列，默认为LinkedBlockingQueue，这就是前面提到的等待队列，里面是一个HashSet，内部包装了一层。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;threadFactory&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;构造Thread方法，我们可以自己包装和传递，实现newThread方法&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;handler&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;这就是前面提到的丢弃处理机制方法，实现接口RejectExecutionHandler中的方法即可。&lt;/p&gt;
&lt;p&gt;在做项目的时候发现线程池有两个执行方法可供调用，分别是execute和submit，那么这两个方法有什么区别呢？在看submit源码的时候可以看到submit最终还是会调用execute方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1153367/201803/1153367-20180321222544158-494558207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;不同的是submit方法提供了一个Future来托管返回值的处理，当调用这个方法需要有返回值的时候，可以用这个方法，execute只能接受Runnable作为参数，而submit除了Runnable还可以接收Callable。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下面来分析最重要的execute方法源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_f068fca8-a503-4a08-9268-598523556c57&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f068fca8-a503-4a08-9268-598523556c57&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f068fca8-a503-4a08-9268-598523556c57&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(Runnable command) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (command == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;         * Proceed in 3 steps:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;         * 1. If fewer than corePoolSize threads are running, try to
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;         * start a new thread with the given command as its first
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;         * task.  The call to addWorker atomically checks runState and
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;         * workerCount, and so prevents false alarms that would add
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;         * threads when it shouldn't, by returning false.
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;         * 2. If a task can be successfully queued, then we still need
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;         * to double-check whether we should have added a thread
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;         * (because existing ones died since last checking) or that
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;         * the pool shut down since entry into this method. So we
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;         * recheck state and if necessary roll back the enqueuing if
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;         * stopped, or start a new thread if there are none.
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;         * 3. If we cannot queue task, then we try to add a new
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;         * thread.  If it fails, we know we are shut down or saturated
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;         * and so reject the task.
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (workerCountOf(c) &amp;lt;&lt;span&gt; corePoolSize) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (addWorker(command, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             c =&lt;span&gt; ctl.get();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (isRunning(c) &amp;amp;&amp;amp;&lt;span&gt; workQueue.offer(command)) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; recheck =&lt;span&gt; ctl.get();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (! isRunning(recheck) &amp;amp;&amp;amp;&lt;span&gt; remove(command))
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                reject(command);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (workerCountOf(recheck) == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 addWorker(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!addWorker(command, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            reject(command);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;代码解释：如果任务为空，返回空异常；接下来int c = ctl.get();获取线程池的状态位，进入if中计算线程池的数量，如果小于线程池的核心线程数，就封装成一个工作（work），失败了继续获取线程池状态位；if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command))判断线程池是否正常运行，正常的话就把当前线程添加到工作队列并且再次获取线程池状态位，if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))如果没有运行的线程了，就把刚才添加的线程移除，移除成功后，使用拒绝策略reject(command); else if (workerCountOf(recheck) == 0)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                addWorker(null, false);如果线程池的线程数为0，那么就要添加一个空任务继续运行，以此来保证可以继续接收新任务而继续运行。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;else if (!addWorker(command, false))&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            reject(command);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果核心线程满了，工作队列也饱和了，开启非核心线程也失败了就会拒绝，此时已经达到最大线程数了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;从英文解释中，我们可以看到：基本分三步：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;a)       开启线程执行任务，直到达到最大核心线程数&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;b)      达到核心线程数时，将接受的新任务放入工作队列&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;c)       当工作队列也放满后，就会开启线程（非核心）执行任务，直到到达最大线程数&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;d)      以上条件都不满足时，就执行默认的拒绝策略&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;addWork源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_e39d2654-3fd2-4d34-84df-30a5d5be309a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e39d2654-3fd2-4d34-84df-30a5d5be309a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e39d2654-3fd2-4d34-84df-30a5d5be309a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addWorker(Runnable firstTask, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; core) {
        retry: &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环标志&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) { 死循环
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c = ctl.get();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取状态位&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; rs = runStateOf(c);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算线程池的状态

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if queue empty only if necessary.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
                ! (rs == SHUTDOWN &amp;amp;&amp;amp;&lt;span&gt;
                   firstTask &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;
                   !&lt;span&gt; workQueue.isEmpty()))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一段说的是线程池不能正常运行的情况：线程池状态关闭、任务为空、队列为空返回错误&lt;/span&gt;

            &lt;span&gt;for&lt;/span&gt; (;;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;死循环&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; wc = workerCountOf(c);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算线程数&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (wc &amp;gt;= CAPACITY ||&lt;span&gt;
                    wc &lt;/span&gt;&amp;gt;= (core ?&lt;span&gt; corePoolSize : maximumPoolSize))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果线程数超出核心线程数，返回错误&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (compareAndIncrementWorkerCount(c))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加worker的数量&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt; retry;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回到进入该方法的循环状态&lt;/span&gt;
                c = ctl.get();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Re-read ctl&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (runStateOf(c) !=&lt;span&gt; rs)
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt; retry;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果状态发生改变，就回退
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else CAS failed due to workerCount change; retry inner loop&lt;/span&gt;
&lt;span&gt;            }
        }

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; workerStarted = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程是否开始运行&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; workerAdded = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;worker是否添加成功&lt;/span&gt;
        Worker w = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            w &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Worker(firstTask);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装成worker&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; Thread t =&lt;span&gt; w.thread;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;.mainLock;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加锁&lt;/span&gt;
&lt;span&gt;                mainLock.lock();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Recheck while holding lock.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Back out on ThreadFactory failure or if
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; shut down before lock acquired.&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(ctl.get());计算线程池状态

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rs &amp;lt; SHUTDOWN ||&lt;span&gt;
                        (rs &lt;/span&gt;== SHUTDOWN &amp;amp;&amp;amp; firstTask == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.isAlive()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; precheck that t is startable&lt;/span&gt;
                            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalThreadStateException();
                        workers.add(w);
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; workers.size();
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; largestPoolSize)
                            largestPoolSize &lt;/span&gt;=&lt;span&gt; s;
                        workerAdded &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;worker添加成功&lt;/span&gt;
&lt;span&gt;                    }
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    mainLock.unlock();
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (workerAdded) {
                    t.start();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动刚刚添加的任务&lt;/span&gt;
                    workerStarted = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt; workerStarted)
                addWorkerFailed(w);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;失败后执行的操作&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; workerStarted;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;从对源码的翻译中我们可以知道这个方法是有什么作用，简单说就是：创建任务，封装任务。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;五、线程测试&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;进行一个简单的测试模拟线程池的工作原理：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;模拟多线程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_4ad98431-c598-40ed-a21f-52cdd4005d62&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4ad98431-c598-40ed-a21f-52cdd4005d62&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4ad98431-c598-40ed-a21f-52cdd4005d62&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestThreadPool &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_e0018a4d-9e0f-4f9c-8c32-447bbf98b0ae&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e0018a4d-9e0f-4f9c-8c32-447bbf98b0ae&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e0018a4d-9e0f-4f9c-8c32-447bbf98b0ae&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定3个长度的工作队列&lt;/span&gt;
        LinkedBlockingDeque&amp;lt;Runnable&amp;gt; workQueue=&lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque&amp;lt;&amp;gt;(3&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定线程池参数：核心线程数，线程池最大线程数量，活跃时间，工作队列&lt;/span&gt;
        ThreadPoolExecutor threadPoolExecutor=&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(4, 7, 90&lt;span&gt;, 
                TimeUnit.SECONDS, workQueue);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 15; i++&lt;span&gt;) {
            threadPoolExecutor.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestThreadPool(), 
                    &lt;/span&gt;&quot;线程:&quot;.concat(i+&quot;&quot;&lt;span&gt;)));
            System.out.println(&lt;/span&gt;&quot;线程池中活跃线程数&quot;+&lt;span&gt;threadPoolExecutor.getActiveCount());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(workQueue.size()&amp;gt;0&lt;span&gt;){
                System.out.println(&lt;/span&gt;&quot;被阻塞的线程数为：&quot;+&lt;span&gt;workQueue.size());
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;指定线程池核心数为4，最大线程数量7，工作队列最大放入3个线程，模拟15个线程并发。运行结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_4b39003e-10f1-4105-99bc-060bf7364cdf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4b39003e-10f1-4105-99bc-060bf7364cdf&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4b39003e-10f1-4105-99bc-060bf7364cdf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;线程池中活跃线程数1
线程池中活跃线程数2
线程池中活跃线程数3
线程池中活跃线程数4
线程池中活跃线程数4
被阻塞的线程数为：&lt;/span&gt;1&lt;span&gt;
线程池中活跃线程数4
被阻塞的线程数为：&lt;/span&gt;2&lt;span&gt;
线程池中活跃线程数4
被阻塞的线程数为：&lt;/span&gt;3&lt;span&gt;
线程池中活跃线程数5
被阻塞的线程数为：&lt;/span&gt;3&lt;span&gt;
线程池中活跃线程数6
被阻塞的线程数为：&lt;/span&gt;3&lt;span&gt;
线程池中活跃线程数7
被阻塞的线程数为：&lt;/span&gt;3&lt;span&gt;
Exception in thread &lt;/span&gt;&quot;main&quot; java.util.concurrent.RejectedExecutionException: Task Thread[线程:10,5,main] rejected from java.util.concurrent.ThreadPoolExecutor@42a57993[Running, pool size = 7, active threads = 7, queued tasks = 3, completed tasks = 0&lt;span&gt;]
    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:&lt;/span&gt;2047&lt;span&gt;)
    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:&lt;/span&gt;823&lt;span&gt;)
    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:&lt;/span&gt;1369&lt;span&gt;)
    at main.Main.main(Main.java:&lt;/span&gt;19)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;        可以看到，创建了4个核心线程和3个非核心线程，当线程数超出了线程池可容纳的的最大数量，执行了拒绝策略Reject，说明队列和线程池都满了，线程池处于饱和状态，另外一个原因是完成的线程没有及时释放，而是进入了休眠。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        线程池工作原理：任务开始后，开始创建新的线程，当达到核心线程数后，新的任务进来不在创建新的线程，这时候把任务加入工作队列，当达到工作队列的长度后，新任务开始创建新的普通线程，直到数量达到线程池的最大核心数量，后面再有新任务则执行饱和策略或拒绝，抛出异常。&lt;/p&gt;
</description>
<pubDate>Wed, 21 Mar 2018 14:37:00 +0000</pubDate>
<dc:creator>我心自在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/10158wsj/p/8620200.html</dc:identifier>
</item>
<item>
<title>阅读好书依然是提升自己的高效方法：兼以作者的身份告诉大家如何选择书，以及高效学习的方法 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/8620225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/8620225.html</guid>
<description>&lt;p&gt;    国内技术网站多如牛毛，质量高的网站也不少，博客园也算一个，各类文章数以百万计，我随便输入一个关键字，比如Spring Cloud，都能看到大量的技术文章和教学视频，我无意贬低技术文章和教学视频的作用，否则博客园第一个就封杀我的文章了，我只是想说，如果大家想让自己成为大牛，系统性地阅读书籍不失为一条捷径。&lt;/p&gt;
&lt;p&gt;      我给出如下的论据：&lt;/p&gt;
&lt;p&gt;      论据一：我见过不少大牛，他们办公桌上的图书都是堆积如山。我可以这样说，看了很多书还未必成大牛，但不读书一定成不了大牛。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201803/1226172-20180321212724538-2075407706.png&quot; alt=&quot;&quot; width=&quot;373&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    论据二：正是因为网上文章太多，这导致了纸质书的幅度衰退。正因如此，各出版社才会严格把关，一些不好的书很少有机会出版，因为出版了一定亏，这话反过来说，目前能经过出版社审核出版的书，大多质量不会差。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201803/1226172-20180321213155409-1052965156.png&quot; alt=&quot;&quot; width=&quot;270&quot; height=&quot;208&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    论据三，目前大家公认的大神，总会以教学视频或图书等方式向大家展示自己，不看书，那怎么知道写技术书的条条框框？也就是说，从看书，到写书再到成为大牛，很多著名大牛就这样过来的。&lt;/p&gt;
&lt;p&gt;    总结性观点：网上知识虽然很多，说是海量也不为过，但太杂，有些甚至相互矛盾，假设某书有12个章节，可能其中的内容网上都有，但我得用很长的时间才能收集全，即使收集全了，我还无法有效甄别哪些该学，以及学习的方法（如果我都知道了我干嘛还要学？），但如果我买了一本经过出版社检验过的书，我就省去了收集和鉴别的精力，而且还能沿着作者给出的途径快速地上手某个知识点。&lt;/p&gt;

&lt;p&gt;    好了，如下给些干货，我毕竟也出了不少书，最近一本书是&lt;a href=&quot;http://www.broadview.com.cn/book/4843&quot;&gt;java web轻量级开发面试教程&lt;/a&gt;，我就以作者的身份告诉大家该如何甄别好书。&lt;/p&gt;
&lt;p&gt;     第一，出现如下情况的图书慎买。声明下，我只是列出一些鉴定方法，无意针对任何一本书。&lt;/p&gt;
&lt;p&gt;     1 出版社不知名，从目录上看，内容叙述一般，这有可能是自费出的书，出书的目的：世艰不拆。&lt;/p&gt;
&lt;p&gt;     2 随便翻下书，一般来说，技术图书总是会结合代码结合图表来说，如果出现大段大段纯文字的，这本书慎重买。因为缺少代码等必要说明手段，这本书未必能把你教会。&lt;/p&gt;
&lt;p&gt;     3 看下一本书的前言和内容介绍，以及每个章节的起头文字和每章小结，看下这些文字作者是否是在敷衍，不排除正文内容好但这些文字有些敷衍的好书，但毕竟少。&lt;/p&gt;
&lt;p&gt;     4 看下书里作者有没有骗篇幅的嫌疑，比如安装某个组件，作者把所有的步骤都贴上图，或者大段引入现成的API说明， 一处不要紧，但如果很多地方都这样，而且文字看上很随意，明显看得出敷衍的痕迹，那么这本书慎重，都骗篇幅了，那可能连读者一块骗。&lt;/p&gt;
&lt;p&gt;     5 看最后几章的文字质量是否还是一丝不苟，因为写书是个长期的活，我的书350页，写了半年，如果到最后工作忙 ，或者写书热情过了，可能虎头蛇尾了，甚至烂尾了，这样的话，书的精华部分就要大打折扣了。&lt;/p&gt;
&lt;p&gt;     6 有些书讲的知识点非常吸引人，但是实用性不强，说白了学好了也没处用，这种书大家可以自行选择。&lt;/p&gt;
&lt;p&gt;     7 再如一些案例书，案例虽然多，但大多中规中矩，明显看不出这些案例是从项目中抽取了，也无法从这些案例中看出实践中总结出来的精华点，那这类书中的案例可能是从别人那山寨出来的，不会有版权问题，但也别想得到太多的收获，说白了这些书可能就是 简单能跑通的代码加看图说话。&lt;/p&gt;

&lt;p&gt;    第二，如何选择对自己有帮助的书。&lt;/p&gt;
&lt;p&gt;    1 看目录，从目录中看这本书是否系统性地给出了知识点，比如 Spring Cloud的书，看下目录，看这本书的选材是否是过于偏重理论而忽略实现，再看下这本书的内容是否涵盖了当前的热点。&lt;/p&gt;
&lt;p&gt;    2 看前言和内容介绍。一般比较上心的作者，可能文字功底参差不齐，但总是会尽最大努力写好书，那么这些书的前言和内容介绍，一般就不会落俗套。&lt;/p&gt;
&lt;p&gt;    3 看下代码以及相关的说明，一般好书里的代码不会少，而且在讲述代码时不会过于简单，也不会看图说话，而是会针对性地给出自己的见解，或者讲下项目中的实践经验。&lt;/p&gt;
&lt;p&gt;     4 看书的附带资料。一般的好书除了附带代码外，还会附带视频教学，这样书就物超所值了。&lt;/p&gt;
&lt;p&gt;     5 看下叙述性文字，是简单的照本宣科，还是看上去有种亲和力，或者到处可见项目中凝结出的经验。&lt;/p&gt;

&lt;p&gt;    第三，从书中学内容的局限性。&lt;/p&gt;
&lt;p&gt;     1 能把资深架构级别知识点讲清楚的书不多，比如有100万个程序员，最终可能也就60万能升级到高级程序员，也就20万成升级到架构师，估计最后成为资深架构级别的大牛也就5万人。达到高级别的人很少，而且这些人未必会写书。&lt;/p&gt;
&lt;p&gt;    .所以，目前的情况是，对于架构师而言，能适合阅读的书不多，而且即使有适合的，可能也就其中的2个章节有帮助，所以对这些大牛而言，只能是多读书，从多本书里抽取知识点。&lt;/p&gt;
&lt;p&gt;    2 有些经验，或者技巧，或者心得，根本无法从书里得到，这些只能靠自己总结，或者偶尔能从网上得到些秘籍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201803/1226172-20180321222035288-303538590.png&quot; alt=&quot;&quot; width=&quot;141&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    不过话说回来，大牛们一定是读了很多书积累了扎实的功底后，才能自己领悟出各种武林秘籍。&lt;/p&gt;

&lt;p&gt;    最后，书山有路勤为径.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201803/1226172-20180321222620660-843203978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    比如升级，总是要靠时间积累，哪怕我不看书，是从其他渠道获得知识，总不能三天打鱼两天晒网。&lt;/p&gt;
&lt;p&gt;    最后自夸下，就看在我将近11点还在写博，而且我在博客园更新博客的频率不算低，希望各位大神保佑我早日成为资深架构师。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201803/1226172-20180321222809841-597545079.png&quot; alt=&quot;&quot; width=&quot;180&quot; height=&quot;165&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   我也相信，不管用什么方法，只要大家勤奋刻苦了，总能总结出针对自己的进阶方法，总能达到自己的预期目标。&lt;/p&gt;




</description>
<pubDate>Wed, 21 Mar 2018 14:31:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/8620225.html</dc:identifier>
</item>
</channel>
</rss>