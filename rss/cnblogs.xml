<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>自己用C语言写RL78 serial bootloader - GeekyGeek</title>
<link>http://www.cnblogs.com/geekygeek/p/hyperbootloader_rl78.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geekygeek/p/hyperbootloader_rl78.html</guid>
<description>&lt;p&gt;　　　　　　&lt;span&gt;&lt;strong&gt;了解更多关于bootloader 的C语言实现，请加我QQ: 1273623966 （验证信息请填 bootloader）,欢迎咨询或定制bootloader（在线升级程序）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　&lt;span&gt;　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;之前用C实现过多款PIC单片机的bootloader, 包括8-bit的PIC16，PIC18；16-bit的PIC24, dsPIC30, dsPIC33; 和32-bit的PIC32MX，PIC32MZ，我为这些类型PIC都写过C bootloader。今天要介绍的serial bootloader 是为我的RL78单片机学习板而写。RL78是Renesas的16-bit单片机。这是我第一次为Renesas的单片机写C 语言bootloader，遇到不少问题，通过不懈努力，总算成功的完成了我的第一个Renesas RL78 serial bootloader。我将这个RL78 serial bootloader命名为hyperboot_rl78, 因为hyperboot_rl78用到的上位机是hyperterm (超级终端）。写这篇博文的目的是来总结这次hyperboot_rl78的实现过程，总结内容包括bootloader的设计, bootloader的逻辑，bootloader的使用，实现环境，实现过程中遇到的问题，以及如何解决的。以上都会一一在这篇博文中介绍到。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       首先介绍实现环境，IDE是CS+， C编译器是CC-RL， 硬件板是我的学习板,  详细如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;IDE ：        CS+  for CC V7.00.00 [13 Jun 2018]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Compiler:    CC-RL V1.07.00&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;MCU:          RL78 F14 R5F10PPJ&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Hardware:   QB-R5F10PPJ-TB(e)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      我的bootloader和application的memory map设计如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;bootloader code range: 0x0000~0x33FF&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;application code range: 0x3400~0x3FFFF&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;application reset vector remap：0x4000&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;interrupt vector remap: 0x4006~0x40CA&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;bootloader 不使用interrupt，interrupt vector 区间0x4~0x7C remap到application的code区间0x4006~0x40CA。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;bootloader code range设置, bootloader interrupt remap 都需要通过修改CS+ bootloader工程的Linker Option来实现。具体可以查阅CS+的帮助。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;application code range设置, application reset vector remap 也需要修改CS+ application工程的Linker Option来实现。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;另外，interrupt vector remap 到application code区间0x4006~0x40CA, application使用中断的话，需要在代码中建Juamp Table, 并将interrupt service routine的地址映射到Jump Table中。 我的做法是在application CS+ 工程的Linker Option中新增 .app_vector section,  .app_vector section的地址范围0x4000~0x40CA(包括reset vector 和 interrupt vector).&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Jump Table指定到.app_vetor section, 在Jump Table 添加跳转指令和_start 地址(cstartup for reset vector)或interrupt service routine的地址(for interrupt vector)到相对应的位置中。Jump Table我是用CC-RL的汇编指令实现的，为此我查阅了RL78的Software Manual。Jump Table 中的汇编代码例子如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
      .DB                     _BR_                            ;BR
        .DB2                    _r_uart0_interrupt_send         ;0x16, Interrupt Service Routine
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       上面的bootloader 和application的Linker Option设置及Jump Table的实现费时最长，主要是对CS+项目的设置不熟， 对CC-RL的使用也不熟，查帮助，一步一步试错尝试，当所有的设置都OK了，Jump Table也实现了，我才长舒一口气，感觉本bootloader的实现即将完成。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        虽然一切bootloader 和 application的设置都OK了，也感觉bootloader的实现即将完成。但实际上并没有那么顺利，原因是bootloader 需要用到FSL， FSL是操作flash的library. 需要添加FSL的头文件和library到bootloader的代码工程中。仔细的查阅了FSL 的介绍文档（r01us0050ej0103_rl78.pdf），发现FSL需要我们根据需求配置FCD, RCD, BCD等section 到bootloader的ROM 空间或RAM空间。 由于我只使用到FSL的基本功能，并且采用status check internal mode. 所以我将FCD，RCD， BCD配置到bootloader 的ROM 空间， 当然也是通过修改bootloader的Linker Option来完成这项配置。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      bootloader 的配置完善了，接着就是bootloader功能和逻辑的实现了。 bootloader 的上位机是串口终端hyperterm(超级终端)。 hyperterm的配置（串口配置）如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;baud rate:   19200&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;data bytes:   8&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;parity:           none&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;stop bits:       1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;flow control : none&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;line delay:     150ms&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;     上电后， bootloader 初始化uart （baudrate-data bytes-parity-stop bits-flow control 要和hyperterm的配置一致，19200-8-none-1-none, 否则通信不了）。bootloader 然后每隔1S左右打印一个 '.' , 打印完6个'.' （6S）就跳转到application. 如果要更新程序，就在6S内在hyperterm 串口中敲一回车。bootloader 收到回车（代表握手成功）就开始擦除application code range. 打印 “Erasing *********&quot;  每擦除一个block (1024 bytes) 就增加打印一个 ”*“直到所有application blocks都擦除完毕，并打印”Done“（代表擦除成功）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      hyperterm 窗口显示了bootloader 完成Erase后打印的”Done“，就操作hyperterm采用发用文本的方式发送application 的hex文件，一行接一行的发送，每发送一行就暂停150ms （配置hyperterm参数line delay = 150ms).&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      bootloader 每接收一行，原样打印，并解读里面的数据类型，地址，长度，数据，和Checksum, 如果数据类型为S1或S2，就将接收到的数据烧写到对应的地址。直到最后一行也处理完毕。整个烧写过程都没问题就打印”Program Rewritten Complete“ “（代表更新成功）。并跳转到application。 如果烧写过程有问题就打印”Program Rewritten Complete with Error“。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      以上就是bootloader的更新程序的整个逻辑。代码框架如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void M_Bootloader_MainFunc(void)
{
       switch (bootState)
    {
        case BOOT_HANDSHAKE:
            M_Bootloader_Handshake();
            break;
        case BOOT_ERASE:
            M_Bootloader_Erase();
            break;
        case BOOT_RECEIVE:
            M_Bootloader_Receive();
            break;
        case BOOT_PROGRAM:
            M_Bootloader_Write();
            break;
        case BOOT_VERIFY:
            M_Bootloader_IVerify();
            break;
        case BOOT_PREJUMP:
            Prejump_To_Application();
            break;
        case BOOT_JUMPTO_APP:
            Jump_To_Application();
            break;
        default:
            break;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       整个过程， hyperterm中打印出来的内容就是更新流程log. 下面是一个完整的更新流程的log.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
....BOOT Mode             
Erasing*************************************************************************                                                                                
***********************************************Done                                                   
S00E0000726C3738463134706D6F7439                                
S1130000D040FFFF064009400C400F40124015400D                                          
S113001018401B401E402140244027402A402D40C8                                          
S113002030403340364039403C403F4042404540F8                                          
S113003048404B404E405140544057405A405D4028                                          
S113004060406340664069407C407F408240854018                                          
S113005088408B408E409140944097409A409D4008                                          
S1130060A040A340A640A940AC40AF40B240B54038                                          
S1130070B840BB40BE40C140C440C740CA400                                   
S10700C077FFE0855D                  
S10D00C4000000000000000000002E                              
S10D00CEFFFFFFFFFFFFFFFFFFFF2E                              
S113340048656C6C6F20776F726C640D0A000D0A4E                                          
S109341064000D0A6C00CB                      
S1134000EDD040ED4C42ED4C42ED4C42ED4C42EDD6                                          
S11340104C42ED4C42ED4C42ED4C42ED4C42ED4CE9                                          
S113402042EDA841ED2341ED4C42ED4C42EDC64139                                          
S1134030ED4C42ED4C42ED4C42ED4C42ED4C42ED28                                          
S11340404C42ED4C42ED4C42ED4C42ED4C42ED4CB9                                          
S113405042ED4C42ED4C42ED4C42ED4C42ED4C42B3                                          
S1134060ED4C42ED4C42ED4C42ED4C42ED4C42EDF8                                          
S11340704C42ED4C42ED4C42ED4C42ED4C42ED4C89                                          
S113408042ED4C42ED4C42ED4C42                          
S1134090ED4C42ED4C42ED4C42ED4C42ED4C42EDC8                                          
S11340A04C42ED4C42ED4C42ED4C42ED4C42ED4C59                                          
S11040B042ED4C42ED4C42ED4C42ED4C42D1                                    
S11340D0CBF820FEFC4B43003600B43025B4EF048B                                          
S11340E0CC0000A747DFF93620FE3020FEEF04CCD9                                          
S11340F00000A747DFF94100320000EF08B311497F                                          
S113410062454800B4F643DFF44100320000EF0892                                          
S1134110B3114962454820FEF643DFF4FC954200A2                                          
S1134120F6EFFEC1C3C5C78EFD708EFCC1C7AF02DA                                          
S113413001605C0798008800318EBF06018800D1B9                                          
S113414061E888008D129801AF16B44214B461D3AB                                          
S113415045EB12B4880199A212B4A214B4AF16B4F8                                          
S11341604214B4DF338F24B40CBCDD1B0CF8DD081F                                          
S11341700CE8DD134C08DF205A067F3203003012AE                                          
S113418034FCEB4400EF116A0680320300300E3435                                          
S1134190FCEB4400EF028801712BE1C6C09EFC6079                                          
S11341A09EFDC6C4C2C061FCC1C5AF10B46168DD68                                          
S11341B00EEB0EB4899D10A515BF0EB4B210B471E8                                          
S11341C01BE1C4C061FCC1C3C5C78EFD708EFCC1B8                                          
S11341D0E6140218B412F61661D8A1021AB4BF1A72                                          
S11341E0B413BF18B415021CB4121761D8A1021E6F                                          
S11341F0B4BF1EB413BF1CB4AF18B4DB1AB436007A                                          
S113420000340A00CEFB0B001705DF0661C8FC1B57                                          
S11342104500AF1CB4DB1EB436000034F401CEFB01                                          
S11342200B001705DF0561C87A0640AF22B4AF2042                                          
S1134230B460310308E73024B4FCD34400715BE17B                                          
S1134240C09EFC609EFDC6C4C2C061FC00EFFD615F                                          
S1044250FC6D            
S113425116C80300AEF82761D339315E12F643DD87                                          
S113426127BBBC02BC04BC06BC08BC0ABC0CBC0E0B                                          
S1134271BC10BC12BC14BC16BC18BC1ABC1CBC1EA1                                          
S11342813704200037B3EFD6AEF847DD06F6BBA7F7                                          
S1134291A7EFF5D7FE0200EFFE2004FC8F4400FCDB                                          
S11342A1464500717AFA5A06BFF6B802B800A80268                                          
S11342B1440000A80061F8446400DE1300A802145D                                          
S11342C1A800040100121561D8A1B80213EFDD3270                                          
S11342D10E00300034FCEB44001004D7                               
S11342E104CA0000CA0100CA0200CA0300CA0400C9                                          
S11342F1CA0500CA0600CA0700CA0800FC504300E8                                          
S1134301FC7B4300FC0A4400FC114400FC144500FE                                          
S1134311FC1F450034780015CA000004180016F685                                          
S11343217182B802B800A802440000A80061F844F0                                          
S11343310A00DE1300A80214A8000401001215618A                                          
S1134341D8A1B80213EFDD1004D7717BFAEF8D36D3                                          
S1134351C40234C402718215A116CEA000717AA1DF                                          
S1134361714BA4CA030071A336C402716AA1716BB3                                          
S1134371A4710BA1CA04C271A3D7CF0AB418F50B57                                          
S1134381B4D7BF02B413BF04B415BF06B4CF08B485                                          
S1134391043002B4FC7D45009F00B44CFFDF0800EB                                          
S11343A100FCDE4500EFF1D716400CB4015110DFDB                                          
S11343B11617BF02B413BF04B415BF06B4F508B48D                                          
S11343C13002B4FC7D45009F00B4D7400CB401DF3A                                          
S11343D11EBF02B4CF08B4033002B4FC7D45009F74                                          
S11343E100B44CFFDF080000FCDE4500EFF1D7CF3D                                          
S11343F100B4105110D7300AB4FC624500E50CB486                                          
S1134401D7FCE44500F50CB4D7CD06C0CE263FD782                                          
S113441136F00030330071A200000000BC26EF002A                                          
S1134421347000AAA4086C0308BAA4711AE5711BBC                                          
S1134431E1712AE5712BE1711AED711AE9712AED25                                          
S1134441712AE9302280BA98309780BA9CC9100049                                          
S11344519A89718A99300700BA96302201BA9A3042                                          
S11344619740BA9EC912009AAAA8086C0108BAA872                                          
S1134471AAB0BAB0AAAA086C0108BAAA51406F211D                                          
S1134481FF9E216A012051DF5F21FF9E21D7341253                                          
S113449101AA06086C0108BA06AA08086C0108BA40                                          
S11344A108A9086C0308B9711BE1712BE1711BE5C3                                          
S11344B1712BE5D7341401711AE5712AE5A9086C49                                          
S11344C10308B9AA06085CFE08BA06711BE1712B40                                          
S11344D1E1D714136168DF04308100D7F6BF14B447                                          
S11344E113BF16B415BF12B4F6D714136168DF04F1                                          
S11344F1308100D736E5FF15BF0EB413BF10B47178                                          
S113450192EB0EB4899D10A515BF0EB4B210B4710F                                          
S113451193F6D7710AE4710BE0D7CEABACD7304038                                          
S1134521021404800016718289718B99715AE571A4                                          
S11345315BE1715AED715AE9CA0200CA010030BF48                                          
S11345415DBFF006D7344002715BE1715BE58971AF                                          
S11345518A99D734400289718B99715AE5715BE16B                                          
S1044561D77E            
S11345627100900016BF04088C019F0108E503083E                                          
S1134572F2FCF8FF0E62CF800804D716E503088C1C                                          
S113458202088C03BF0408340010CF02080F8C0603                                          
S11345929F81084C03DD2415080E00081E01BF008C                                          
S11345A208148C04088C05BF06081251004E06DD5F                                          
S11345B21BF98108FCF8FF0E62EF20300004BF06ED                                          
S11345C2088C003129F005BF0008EFE5FB04080060                                      
S11345D2899BA7A5B3F643DFF75100D7FC04F00E7D
S11145E262D7FC08F00E71089000F58008D72F
S21403FF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9
S21403FF10FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE9
S21403FF20FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD9
S21403FF30FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC9
S21403FF40FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB9
S21403FF50FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA9
S21403FF60FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF99
S21403FF70FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF89
S21403FF80FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF79
S21403FF90FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF69
S21403FFA0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF59
S21403FFB0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF49
S21403FFC0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF39
S21403FFD0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF29
S21403FFE0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF19
S21403FFF0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF09
S9030000FC
Program Rewritten Complete
Hello world

l
d
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  hyperboot_rl78 有以下两个缺点：&lt;/p&gt;
&lt;p&gt;1。效率低， 每行delay 150ms&lt;/p&gt;
&lt;p&gt;2。和上位机hyperterm(超级终端)之间交互没有通信协定。&lt;/p&gt;

&lt;p&gt;       接下来计划完成一个全新RL78 bootloader，一个上位机，之间通信采用自定义协议， 或Xmodem协议，开发平台为CS+ 或 IAR。&lt;/p&gt;
</description>
<pubDate>Wed, 31 Oct 2018 16:42:00 +0000</pubDate>
<dc:creator>GeekyGeek</dc:creator>
<og:description>Renesas 16-bit MCU RL78 Serial bootloader</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geekygeek/p/hyperbootloader_rl78.html</dc:identifier>
</item>
<item>
<title>Linux 桌面玩家指南：09. X Window 的奥秘 - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/LinuxDesktop009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/LinuxDesktop009.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用&lt;code&gt;$&lt;/code&gt;标记数学公式的开始和结束。如果某条评论中出现了两个&lt;code&gt;$&lt;/code&gt;，MathJax 会将两个&lt;code&gt;$&lt;/code&gt;之间的内容按照数学公式进行排版，从而导致评论区格式混乱。如果大家的评论中用到了&lt;code&gt;$&lt;/code&gt;，但是又不是为了使用数学公式，就请使用&lt;code&gt;\$&lt;/code&gt;转义一下，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想从头阅读该系列吗？下面是传送门：&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;大名鼎鼎的 X Window 大家肯定不陌生。都知道它是 Unix/Linux 下面的窗口系统，也都知道它基于 Server/Clinet 架构。在网上随便搜一搜，也可以找到不少 X Window 的介绍。有不少文章为了给用户留一个直观的印象，往往先让系统进入纯文本界面，然后使用 startx 来启动图形界面，或者直接使用 X 来启动 X Server，再然后运行一个 xterm 来做示范。我觉得以上这些文章对 X Window 的理解有限，不够深入。所以，我这里写一篇《X Window 的奥秘》，以最新的 Ubuntu-18.10 Desktop 为例，展示如何学习 X Window。&lt;/p&gt;
&lt;p&gt;10 月是一个比较开心的月份。在这个月中，陆续发布了最新的 Ubuntu 18.10 和 Fedora 29，还有人在我的博客中问关于 CentOS 7 的问题。CentOS 7 固然是一个优秀的发行版，但并不是作为桌面系统的首选，Gnome 的版本太旧，官方仓库中的软件包也不够丰富，美化起来比较困难。在这一篇中，我要展示远程连接 X Server 的操作，需要两个外观差距稍微大一点的 Linux 桌面系统，所以选择了 CentOS 7 和 Ubuntu 18.10。&lt;/p&gt;
&lt;p&gt;Ubuntu 18.10 这次外观大变样，使用了 Yaru 主题，下面的截图展示了其中 Terminal 和 GVim 的外观：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181031150630510-1566358116.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而 CentOS 7 默认的外观太丑了，所以我给他换上了最流行的 adapta-gtk-theme 和 paper-icon-theme，下面的截图展示了其中 Terminal 和 GVim 的外观：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181031150743167-253533407.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两种风格应该是比较好区分的，在后文中，很容易通过外观来判断一个 GUI 程序究竟来自于哪一个系统。&lt;/p&gt;
&lt;h2 id=&quot;了解自己机器上的-x-window&quot;&gt;了解自己机器上的 X Window&lt;/h2&gt;
&lt;p&gt;X Window 其实是一种规范，它有很多不同的实现，在 Linux 系统下最流行的是实现 Xorg 和 XFree86，微软 Windows 系统下也有 X Window 的实现，苹果的Mac 也是 X Window 的一种。要了解自己机器上运行的 X Window 究竟是哪一个，可以使用查看进程的ps命令，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181031151318912-642586678.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，Ubuntu 18.10 使用的 X Window 是 Xorg。如果使用 ps -ef 命令，还可以看到 Xorg 运行时的命令行参数。&lt;/p&gt;
&lt;p&gt;想了解 X Window，下面这些文档需要看一遍先：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181031151836068-826947610.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面来说一下也许是众所周知的基础知识：X Window 是一个分层的架构，它分为 Serve 和 Client。X Server 负责图形界面的显示，（也负责用户的输入），而Client 程序需要连接到 X Server，然后请求 X Server 绘制图形界面，同时从 X Server 接受用户的输入。在桌面系统上，X Server 和 Client 程序往往安装在同一台机器上，日常使用基本感觉不到它是分层的。但是很显然，X Server 和 Client 也可以分别运行在不同的机器上，在一台机器上运行程序，而在另外一台机器上显示图形界面。&lt;/p&gt;
&lt;p&gt;X Window 中的 Server 和 Client 的概念和我们平时接触到的“Server/Client”概念刚好相反。很多熟悉 Internet 原理的人，第一次接触 X Window 的这两个概念都会搞错。比如，我在一台本地机器上运行 Ubuntu 18.10 桌面版，而在另外一台远程机器上运行 CentOS 7（纯字符界面），当我用 ssh 从 Ubuntu 连接到 CentOS 的时候，Ubuntu 是 Client，而 CentOS 是 Server。在 X Window 中，Server 偏偏是我面前的这台 Ubuntu，X Server 运行在 Ubuntu 上。我可以在 CentOS 中运行 GVim，但是窗口显示在 Ubuntu 中，这时，GVim 是一个 Client 程序，它在远程机器上运行，而它的窗口显示在本地。&lt;/p&gt;
&lt;h2 id=&quot;理解-display-和虚拟控制台&quot;&gt;理解 display 和虚拟控制台&lt;/h2&gt;
&lt;p&gt;前面提到网上很多介绍 X Window 的文章都是先让系统进入字符界面，然后手动启动一个 X Server。其实这完全没有必要，因为在同一台机器上完全可以运行多个 X Server，只需要让每个 X Server 的 display 不同即可。那么 display 究竟是什么？&lt;/p&gt;
&lt;p&gt;在 X Window 中，可以通过 hostname:display_number.screen_number 来指定一个屏幕。可以这样理解：一台计算机可以有多个 display，一个 display 可以有多个屏幕。所以，display 相当于是计算机配备的一套输入输出设备，一般情况下，一台电脑只配一套键盘鼠标和一个显示器，特殊情况下，可以配多个显示器。&lt;/p&gt;
&lt;p&gt;现在问题出来了，我的电脑只有一套键盘鼠标和一个显示器，也就是只有一个 display，那又怎么能运行多个 X Server 呢？那是因为在 Linux 中，还有虚拟控制台这样的高级特性。只需要同时按下 Ctrl+Alt+F1、Ctrl+Alt+F2、...、Ctrl+Alt+F7，就可以在不同的虚拟控制台中进行切换。在 Ubuntu 18.10 中，虚拟控制台 3 到 6 运行的是 agetty，也就是字符界面，虚拟控制台 2 运行的是 Xorg。（Fedora 中不一样，虚拟控制台 1 运行的是图形界面，其它的是字符界面。）如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181031153336308-133929108.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以直接运行 X Server 程序来启动 X Server。/usr/bin/X 和 Xorg 都是 X Server 程序。其实 /usr/bin/X 是 Xorg 的符号链接，用哪一个都是一样的。&lt;/p&gt;
&lt;p&gt;启动 X Server 的时候可以指定 display 参数，因为可以省略掉 hostname 和 screen_number，所以可以用 :0，:1 这样的格式来指定 display。在我的机器上，本来就有一个 X Server 在运行，display :0 已经被占用了，所以我使用 &lt;code&gt;sudo X vt8 :1 -auth /run/user/1000/gdm/Xauthority -retro&lt;/code&gt; 来在 display :1 上再运行一个 X Server，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181031165906337-115987151.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的 &lt;code&gt;-retro&lt;/code&gt; 参数是为了让 X Server 的背景显示为斜纹，否则背景为纯黑色，那就看不出来是否启动了 X Server。&lt;code&gt;vt8&lt;/code&gt; 参数指定将新启动的 X Server 放到第 8 个虚拟控制台。&lt;code&gt;:1&lt;/code&gt;参数指定新启动的 X Server 的 display number。启动 X Server 后的效果如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181031165337027-1818856858.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按 Ctrl+Alt+F2 回到 display :0，在新启动的 X Server 中运行一个 GVim 看看效果。运行 GVim 时，使用 -display :1 参数指定窗口显示在新启动的 X Server 上，使用 -geometry 参数指定窗口的大小和位置。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181031165602853-830241496.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再按 Ctrl+Alt+F8 切换到 display :1，看效果。如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181031165708595-2035219253.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不知道为什么，在 Ubuntu 18.10 中的虚拟控制台中切换两下，新启动的 X Server 就自动关闭了。而且切换到虚拟控制台 8 再切换回来，我的 Ubuntu 桌面的分辨率也变成了 800x600，非常不爽。当然，这里的展示只是为了证明能在一台机器上运行两个 X Server，能看到效果就行。&lt;/p&gt;
&lt;h2 id=&quot;远程连接-x-server&quot;&gt;远程连接 X Server&lt;/h2&gt;
&lt;p&gt;前面展示的在一个系统中运行两个 Xorg 并不是很吸引人，毕竟新启动的 X Server 太丑了，而且 Xorg 的参数一大堆，不是很容易搞。既然 X Client 和 X Server 可以分布在不同的机器上，那么，如果我们能够把别的系统中的 GUI 程序显示到本地机器中，那就比较过瘾了。理论上讲，如果在前面提到的 CentOS 7 中运行&lt;code&gt;gvim -display 192.168.40.135:0&lt;/code&gt;命令（这里的 192.168.40.135 是 Ubuntu 18.10 系统的内网 IP），就应该可以把界面显示到 Ubuntu 18.10 桌面上，反之，如果在 Ubuntu 18.10 中运行&lt;code&gt;gvim -display 192.168.40.130:0&lt;/code&gt;命令（这里的 192.168.40.130 是 CentOS 7 系统的内网 IP），就可以把界面显示到 CentOS 7 中。&lt;/p&gt;
&lt;p&gt;但是，这是行不通的。行不通的原因首先是 Xorg 复杂的认证机制。如果没有认证机制把关，随便就能让别的系统把图形界面甩过来，那桌面上岂不是垃圾窗口满天飞吗？其次，Xorg 在启动时往往会带上&lt;code&gt;-nolisten tcp&lt;/code&gt;参数，禁止接受从 TCP/IP 网络上传过来的连接请求。要禁用该选项，往往需要去更改 gdm 的配置文件。&lt;/p&gt;
&lt;p&gt;我这里就不折腾这些复杂的认证机制和命令行参数了，我这里来点简单的。最简单的把远程机器上的图形界面带回本地桌面的方式，是使用 SSH 的 X11 Forwarding 功能。该功能用起来非常简单，只需要在使用&lt;code&gt;ssh&lt;/code&gt;命令连接远程机器的时候，加上&lt;code&gt;-X&lt;/code&gt;或者&lt;code&gt;-Y&lt;/code&gt;参数就可以了。如下图，我在 Ubuntu 18.10 中使用&lt;code&gt;ssh -X 192.168.40.130&lt;/code&gt;远程连接到 CentOS 7 中，然后再运行&lt;code&gt;gvim&lt;/code&gt;命令，该 GVim 窗口就在 Ubuntu 桌面中显示出来了。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181031231134863-1850551184.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反之，如果在 CentOS 7 中使用&lt;code&gt;ssh -X 192.168.40.135&lt;/code&gt;远程连接到 Ubuntu 18.10 中，在运行&lt;code&gt;gvim&lt;/code&gt;命令，就可以把 Ubuntu 中的 GVim 显示到 CentOS 7 的桌面中，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181031235719661-1031243835.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SSH 的 X11 Forwarding 是一个非常强大的功能。我们甚至可以把 Linux 中的图形界面显示到 Windows 中，只需要在 Windows 中运行一个 X Server 就可以了。我选择的软件是 XMing，然后使用 PuTTY 连接到 Linux 系统。在 PuTTY 的设置中，开启 X11 Forwarding 功能，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181031235957621-749634410.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后可以把 Linux 桌面中的图形界面带入 Windows 桌面，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181101000035156-1573758396.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;理解-displaymanager-和-x-window-桌面环境的启动过程&quot;&gt;理解 DisplayManager 和 X Window 桌面环境的启动过程&lt;/h2&gt;
&lt;p&gt;X Server 的启动方式有两种，一种是通过显示管理器启动，另一种是手动启动。在前面的例子中，我通过直接运行&lt;code&gt;sudo X vt8 :1 -auth /run/user/1000/gdm/Xauthority -retro&lt;/code&gt;来启动了一个 X Server，这就是手动启动。手动启动 X Server 的方法还有运行 startx 或者 xinit。手动启动 X Server 的缺点就是启动的 X Server 不好看。而显示管理器启动的不仅有 X Server，还有一大堆的 Client 程序，构成了一个完整的桌面环境，界面当然就漂亮多了。&lt;/p&gt;
&lt;p&gt;显示管理器（Display Manager）是什么呢？前面我讲到 display 就是一个电脑配备的一套键盘鼠标和显示器，那么显示管理器就是这一套设备的管理器了。显示管理器可以直接管理这些设备，所以它可以控制 X Server 的运行，由它来启动 X Server 那是再合适不过了。系统启动过程是这样的：内核加载--&amp;gt;init程序运行--&amp;gt;显示管理器运行--&amp;gt; X Server 运行--&amp;gt;显示管理器连接到 X Server，显示登录界面--&amp;gt;用户登录后，登录界面关闭，加载桌面环境。从上面的流程可以看出，显示管理器是 X Server 的父进程，它负责启动 X Server，当 X Server 启动后，它又变成了 X Server 的一个 Client 程序，连接到 X Server 显示欢迎界面和登录界面，最后，显示管理器又是所有桌面环境的父进程，它负责启动桌面环境需要的其它 Client 程序。&lt;/p&gt;
&lt;p&gt;在 Ubuntu 的早期版本中，使用 lightdm 取代了传统的 xdm、gdm 等显示管理器。从 Ubuntu 17.10 开始，Ubuntu 放弃了 Unity 桌面而回归 Gnome 3，则显示管理器又变回 gdm 了。&lt;/p&gt;
&lt;p&gt;可以使用不同的方法对 X Server 进行配置，前面的例子是直接指定命令行参数。除了指定命令行参数，还可以使用环境变量和配置文件。X Server 的配置文件为一般是 /etc/X11/xorg.conf 或 /etc/X11/xorg.conf.d/ 目录下的 .conf 文件，当然，配置文件也可以放在其它的目录中，具体信息，请参看 man xorg.conf。&lt;/p&gt;
&lt;p&gt;如果没有配置文件，X Server 将在启动的时候自动检测硬件，然后生成一个内置的配置。Ubuntu 系统就没有配置文件。不过没关系，如果需要使用配置文件的时候，可以通过 X Server 的 -configure 参数生成一个配置文件，里面包含当前自动检测出的配置。如果需要任何个性化的配置，对该文件进行修改即可。&lt;/p&gt;
&lt;h2 id=&quot;运行嵌套的-x-server&quot;&gt;运行嵌套的 X Server&lt;/h2&gt;
&lt;p&gt;我们上面运行的 X Server 都是直接占用了计算机的整个显示器和键盘鼠标，事实上，在现有的图形界面中，还可以以窗口模式运行另外一个 X Server，称为 nested X Server。最常用的 nested X Server 是 Xephyr，在 Ubuntu 中可以通过如下命令安装它：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo aptitude install xserver-xephyr&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Xephyr 的使用非常简单，可以通过&lt;code&gt;man Xephyr&lt;/code&gt;命令查看它的使用手册。如果输入&lt;code&gt;Xephyr :1 -screen 1024x768&lt;/code&gt;命令，就可以在现有图形界面中打开一个窗口模式的 X Server，其中&lt;code&gt;-screen&lt;/code&gt;参数用来指定 X Server 显示区域的大小。以后再启动 GUI 程序，就可以通过程序的 &lt;code&gt;-display :1&lt;/code&gt; 选项让程序运行在这个嵌套的 X Server 中，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181101000928719-1452715133.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;怎么样，是不是很好玩呢？除了好玩，还很有用，比如调试窗口管理器啊、连接远程桌面啊什么的都用得着。当然，我这里只是简单展示一下原来 X Window 还可以这么玩。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;1.在一个 Linux 系统中存在多个虚拟控制台，所以可以启动多个 X Server；&lt;/p&gt;
&lt;p&gt;2.启动 X Server 的方式有两种，一种是使用 /usr/bin/X、startx、xinit 手动启动，一种是通过显示管理器启动；&lt;/p&gt;
&lt;p&gt;3.远程计算机连接本地的 X Server，需要 X Server 开放 TCP 端口，还要搞定安全认证；&lt;/p&gt;
&lt;p&gt;4.如果觉得搞定 X Server 的 TCP 端口和安全认证太麻烦，可以使用 SSH 的 X11 Forwarding 功能，远程连接 X Server 超级方便；&lt;/p&gt;
&lt;p&gt;5.X Server 的配置，可以通过命令行参数，可以通过环境变量，还可以通过配置文件；&lt;/p&gt;
&lt;p&gt;6.可以在现有的图形界面下以窗口模式运行嵌套的 X Server，常用的软件是 Xephyr；&lt;/p&gt;
&lt;p&gt;7.使用 XMing 和 PuTTY，把 Linux 图形界面带入 Windows 不是梦。&lt;/p&gt;
&lt;h2 id=&quot;求打赏&quot;&gt;求打赏&lt;/h2&gt;
&lt;p&gt;我对这次写的这个系列要求是非常高的：首先内容要有意义、够充实，信息量要足够丰富；其次是每一个知识点要讲透彻，不能模棱两可含糊不清；最后是包含丰富的截图，让那些不想装 Linux 系统的朋友们也可以领略到 Linux 桌面的风采。如果我的努力得到大家的认可，可以扫下面的二维码打赏一下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180831154735325-1276475036.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2018年11月01日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Wed, 31 Oct 2018 16:20:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>特别说明： 要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用 标记数学公式的开始和结束。如果某条评论中出现了两个 ，MathJax 会将两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop009.html</dc:identifier>
</item>
<item>
<title>一个磁盘I/O故障导致的AlwaysOn FailOver 过程梳理和分析 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9886686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9886686.html</guid>
<description>&lt;p&gt;下面是我们在使用AlwaysOn过程中遇到的一个切换案例。这个案例发生在2014年8月，虽然时间相对久远了，但是对我们学习理解AlwaysOn的FailOver原理和过程还是很有帮助的。本次FailOver的触发原因是系统I/O问题。大家需要理解，操作系统I/O出现了问题不一定立即触发SQL Server发生漂移，因为坏的槽点可能不在SQL Server实例所用到的位置，但是随着时间持续 和数据堆积，问题槽点可能扩大升级。我们可以看到在本例中，第一次出现I/O问题到SQL Server 漂移间隔了16分钟，所以大家不要奇怪。我们重点可以FailOver的过程和触发条件设置上，即文章的第二和第三部分。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;一 . 系统 I/O 异常 Log追踪 &lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.1  &lt;/strong&gt;&lt;span&gt;10:36:12&lt;/span&gt; &lt;strong&gt;发现I/O异常&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181031233108173-1833933547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2   &lt;span&gt;10:45:43   &lt;/span&gt; 显示个别读写花费时间较长&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181031233151268-934544440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.3  &lt;/strong&gt;&lt;span&gt;10:45:28&lt;/span&gt; &lt;strong&gt;看似I/O严重&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181031233337171-1907524134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.4   &lt;span&gt;10:52:20&lt;/span&gt; 出现个别连接Fail&lt;/strong&gt;&lt;strong&gt;现象&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;（查看表中的最后一笔数据显示为&lt;strong&gt;&lt;span&gt;10:53:17&lt;/span&gt;&lt;/strong&gt;）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181031233549730-1549731348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;strong&gt;二&lt;/strong&gt;&lt;strong&gt; . AlwaysOn FailOver&lt;/strong&gt; &lt;strong&gt;过程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;2.1&lt;/strong&gt; &lt;strong&gt;系统提示需要FailOver&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181031233722189-1003986653.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2&lt;/strong&gt; &lt;strong&gt;高可用性组的本地副本需要离线。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181031233826582-2041337265.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;Default&quot;&gt;（&lt;em&gt;&lt;strong&gt;相关知识：&lt;/strong&gt;&lt;/em&gt;Lease expired event from the cluster. Possible causes include loss of lease, possible network issues and sp_server_diagnostic query timeout. ）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3&lt;/strong&gt; &lt;strong&gt;错误提示信息显示，SQL Instance&lt;/strong&gt;&lt;strong&gt;和WSFC&lt;/strong&gt;&lt;strong&gt;连接异常。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181031234035768-599487092.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.4&lt;/strong&gt; &lt;strong&gt;可用性副本的角色发生变换。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181031234143457-2126959940.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.5 &lt;/strong&gt;&lt;strong&gt;角色为RESOLVING&lt;/strong&gt;&lt;strong&gt;无法访问DB&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181031234240961-2082084270.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（&lt;em&gt;&lt;strong&gt;相关知识：&lt;/strong&gt;&lt;/em&gt;When the role of an availability replica is indeterminate, such as during a failover, its databases are temporarily in a NOT SYNCHRONIZING state. Their role is set to RESOLVING until the role of the availability replica has resolved.）&lt;/p&gt;
&lt;p&gt;此时： 通过SSMS管理器，连接数据也是不可以访问的，显示状态为不同步了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181031234343938-860148562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;三 . 相关知识点&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;3.1  &lt;/strong&gt;&lt;strong&gt;什么是resourceDell&lt;/strong&gt;&lt;strong&gt;？resourceDell&lt;/strong&gt;&lt;strong&gt;的用途？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于AlwaysOn可用性组是建立在Windows故障转移群集之上的，Alwayson可用性组需要一个群集resourceDell来连接Windows群集和SQLServer实例。由于可用性组是一个群集资源，Windows群集需要透过AlwaysOn的resourceDell来控制资源的上线/离线，检查资源是否失败，更改资源的状态和属性，以及发生各种命令给可用性副本实例。（AlwaysOn可用性组的资源类型是“SQLServer Availability Group”）&lt;/p&gt;
&lt;p&gt;AlwaysOn通过sp_server_diagnostics来检查可用性组的健康状况，不断地获得诊断信息。sp_server_diagnostics的评估结果会被用来和AlwaysOn可用性组的FailureConditionLevel设置相比较，来约定是否符合发生故障转移的条件。一旦条件满足，则可用性组就被切换到新的可用性副本上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2  &lt;/strong&gt;&lt;strong&gt;HealthCheckTimeout&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;The HealthCheckTimeout setting is used to specify the length of time, in milliseconds, that the SQL Server resource DLL should wait for information returned by the sp_server_diagnostics stored procedure before reporting the AlwaysOn Failover Cluster Instance (FCI) as unresponsive. Changes that are made to the timeout settings are effective immediately and do not require a restart of the SQL Server resource.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;The resource DLL determines the responsiveness of the SQL instance using a health check timeout. The HealthCheckTimeout property defines how long the resource DLL should wait for the sp_server_diagnostics stored procedure before it reports the SQL instance as unresponsive to the WSFC service.&lt;/p&gt;
&lt;p&gt;The following items describe how this property affects timeout and repeat interval settings:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The resource DLL calls the sp_server_diagnostics stored procedure and sets the repeat interval to one-third of the HealthCheckTimeout setting.&lt;/li&gt;
&lt;li&gt;If the sp_server_diagnostics stored procedure is slow or is not returning information, the resource DLL will wait for the interval specified by HealthCheckTimeout before it reports to the WSFC service that the SQL instance is unresponsive.&lt;/li&gt;
&lt;li&gt;If the dedicated connection is lost, the resource DLL will retry the connection to the SQL instance for the interval specified by HealthCheckTimeout before it reports to the WSFC service that the SQL instance is unresponsive.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3.3  &lt;/strong&gt;&lt;strong&gt;FailureConditionLevel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The SQL Server Database Engine resource DLL determines whether the detected health status is a condition for failure using the FailureConditionLevel property. The FailureConditionLevel property defines which detected health statuses cause restarts or failovers.&lt;/p&gt;
&lt;p&gt;Review sp_server_diagnostics (Transact-SQL) as this system stored procedure plays in important role in the failure condition levels.&lt;/p&gt;
&lt;table border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;18.5&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;Level&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;Condition&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;No automatic failover or restart&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;ul&gt;&lt;li&gt;Indicates that no failover or restart will be triggered automatically on any failure conditions. This level is for system maintenance purposes only.&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Failover or restart on server down&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Indicates that a server restart or failover will be triggered if the following condition is raised:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;SQL Server service is down.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Failover or restart on server unresponsive&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Indicates that a server restart or failover will be triggered if any of the following conditions are raised:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;SQL Server service is down.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;SQL Server instance is not responsive (Resource DLL cannot receive data from sp_server_diagnostics within the HealthCheckTimeout settings).&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Failover or restart on critical server errors&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Indicates that a server restart or failover will be triggered if any of the following conditions are raised:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;SQL Server service is down.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;SQL Server instance is not responsive (Resource DLL cannot receive data from sp_server_diagnostics within the HealthCheckTimeout settings).&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;System stored procedure sp_server_diagnostics returns ‘system error’.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Failover or restart on moderate server errors&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;15&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Indicates that a server restart or failover will be triggered if any of the following conditions are raised:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;SQL Server service is down.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;SQL Server instance is not responsive (Resource DLL cannot receive data from sp_server_diagnostics within the HealthCheckTimeout settings).&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;System stored procedure sp_server_diagnostics returns ‘system error’.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;System stored procedure sp_server_diagnostics returns ‘resource error’.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Failover or restart on any qualified failure conditions&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;17&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Indicates that a server restart or failover will be triggered if any of the following conditions are raised:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;SQL Server service is down.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;SQL Server instance is not responsive (Resource DLL cannot receive data from sp_server_diagnostics within the HealthCheckTimeout settings).&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;System stored procedure sp_server_diagnostics returns ‘system error’.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;System stored procedure sp_server_diagnostics returns ‘resource error’.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;System stored procedure sp_server_diagnostics returns ‘query_processing error’.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.4  &lt;/strong&gt;&lt;strong&gt;通过&lt;/strong&gt;&lt;strong&gt;SQL&lt;/strong&gt;&lt;strong&gt;更改相关配置。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  The following example sets the HealthCheckTimeout option to 15,000 milliseconds (15 seconds).&lt;/p&gt;
&lt;pre&gt;
ALTER SERVER CONFIGURATION 
&lt;/pre&gt;
&lt;pre&gt;
SET FAILOVER CLUSTER PROPERTY HealthCheckTimeout = 15000;
&lt;/pre&gt;
&lt;p align=&quot;left&quot;&gt;  The following example sets the FailureConditionLevel property to 0, indicating that failover or restart will not be triggered automatically on any failure conditions.&lt;/p&gt;
&lt;pre&gt;
ALTER SERVER CONFIGURATION SET FAILOVER CLUSTER PROPERTY FailureConditionLevel = 0;&lt;/pre&gt;
&lt;h2&gt;&lt;strong&gt;四 . 结语&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;  可用性副本的FailOver不仅仅取决于Availability Mode 和FailOver Mode,还要受限于FailureConditionLevel。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;本文版权归作者所有，未经作者同意不得转载,谢谢配合！！！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 31 Oct 2018 15:59:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>下面是我们在使用AlwaysOn过程中遇到的一个切换案例。这个案例发生在2014年8月，虽然时间相对久远了，但是对我们学习理解AlwaysOn的FailOver原理和过程还是很有帮助的。本次FailO</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9886686.html</dc:identifier>
</item>
<item>
<title>Kali Linux ——在无网络情况下安装无线网卡驱动 - moonfair</title>
<link>http://www.cnblogs.com/moonfair/p/9886147.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonfair/p/9886147.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、背景：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　今日刚刚开始学习kali linux，众所周知，安装完成后，系统是没有无线网卡驱动的，这就对学生党造成相当的困扰：校园网要连接有线是需要认证客户端的，而认证客户端只有windows端，如此一来，无线网也连不上，有线网也连不上，这就......很尴尬。&lt;/p&gt;
&lt;p&gt;　　因此我走访各大博客，虽然没能直接解决问题，但也给了我一定的启发，最终摸索出一条不难实现的道路。&lt;/p&gt;
&lt;p&gt;　　在此我将分享自己解决问题的过程，希望能对有需要的读者有所帮助。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、操作环境：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;我的电脑是      联想ThinkPad E431&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　无线网卡是     Broadcom 802.11n &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　linux 版本是     Kali linux 2018.3a amd64&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　linux 内核版本是    4.15.0-kali2-amd64&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　有配置不同的同学也不要着急，本文提供的方法具备一般性，相信可以给你一定的启发。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、原理：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;废话说到这里，来谈一谈我的想法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　 这个方法是根据 “&lt;strong&gt;有线网环境下安装无线驱动&lt;/strong&gt;” 的情况改编的。我翻阅了大量博客后发现，安装无线网卡的&lt;span&gt;&lt;strong&gt;过程大多分为两步：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;                                                           &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;strong&gt; 1、安装核心头文件&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　　　　　　　　　　　　　2、安装无线网卡驱动 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、过程：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　原文是通过 apt-get 直接安装的，而我们没有网络环境，但是转念一想，通过apt-get 安装，本质上也是从 软件源 的网站下载，既然如此，我们为什么不&lt;span&gt;&lt;strong&gt;直接从源网站下载需要的文件&lt;/strong&gt;&lt;/span&gt;呢？&lt;/p&gt;
&lt;p&gt;　　于是我访问了中科大的 kali 镜像站：&lt;/p&gt;
&lt;p&gt;　　　　&lt;a href=&quot;http://mirrors.ustc.edu.cn/kali&quot; target=&quot;_blank&quot;&gt;http://mirrors.ustc.edu.cn/kali&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　发现是这样一个页面，&lt;strong&gt;其中的文件是可以直接下载的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467200/201810/1467200-20181031194418171-1708764464.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;但是我们同样面对两个问题：&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;1、该下载什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;2、要下载的文件在哪个目录下&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　下文将逐一解决这两个问题&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、下载什么文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1、内核头文件&lt;/strong&gt;&lt;/span&gt;　　&lt;/p&gt;
&lt;p&gt;　　　　　　  &lt;span&gt;&lt;strong&gt;&lt;span&gt;在终端执行命令：   uname -r&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　得到内核版本为 ：    4.15.0-kali2-amd64&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　记住这个版本号，这就是一会要下载的内核头文件版本&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　 　&lt;strong&gt;&lt;span&gt;2、网卡驱动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　　　&lt;span&gt;在终端执行命令： lspci | grep -i net&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　 &lt;span&gt;得到两行信息，第一行是你的有线网，第二行就是我们要的无线网&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　同样记住这个无线网卡的型号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;3、前置驱动dkms，kbuild和debhelper&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　这个则没有特别的要求，会在下一节讲解如何下载&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;6、在哪个目录下载文件：&lt;/span&gt;（为了方便大家阅读，需要下载的文件都将用&lt;span&gt;绿底粗体&lt;/span&gt;标注出来）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;关于这点我则是借鉴了 “从ISO镜像安装” 的思路，不过原文是ubuntu的系统，他们的ISO镜像里集成了大量的资源，但我们 kali 没有啊，只能去镜像站下了。尽管如此，原文中列出了linux镜像中存放文件的规律，而这一规律在镜像站也同样适用，因此我得以顺利从网站找到需要的文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　如上文所见，要找的文件有三种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;&lt;span&gt;1）内核头文件&lt;/span&gt;　（这里用 4.15.0-kali2-amd64 的内核版本来举例，在实际应用时，请替换成自己的版本号）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　&lt;strong&gt;&lt;span&gt;路径：　/pool/main/l/linux/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　&lt;strong&gt;&lt;span&gt;需要的文件：     linux-headers-4.15.0.kali2-amd64&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　可是啊，好事多磨，你多半会发现，&lt;span&gt;&lt;strong&gt;镜像站里的内核版本是4.18.0 的&lt;/strong&gt;&lt;/span&gt;，这和你的根本不一样啊，这怎么用呢。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　这里我没有贸然去尝试使用不同内核版本的头文件，而是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;&lt;strong&gt;选择升级kali的内核版本&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　当然这又是一个艰苦地翻博客的过程，其中辛酸就不足为外人道了，这里直接为大家献上解决方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　 在&lt;span&gt;&lt;strong&gt;同一个目录下&lt;/strong&gt;&lt;/span&gt;寻找以下文件并下载：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　&lt;strong&gt;&lt;span&gt;linux-kbuild-4.18_4.18.10-2kali1_amd64.deb&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　&lt;strong&gt;&lt;span&gt;linux-compiler-gcc-7-x86 4.18.10-2kali amd64.deb&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　&lt;span&gt;&lt;strong&gt;linux-headers-4.18.0-kali2-amd64_4.18.10-2kali_amd64.deb&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　&lt;strong&gt;&lt;span&gt;linux-headers-4.18.0-kali2-common_4.18.10-2kali1_all.deb&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　&lt;span&gt;&lt;strong&gt;linux-image-4.18.0-kali2-cloud-amd64_4.18.10-2kali1_amd64.deb&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　&lt;span&gt;&lt;strong&gt;linux-image-4.18.0-kali2-rt-amd64_4.18.10-2kali1_amd64.deb&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　&lt;span&gt;&lt;strong&gt;linux-image-4.18.0-kali2-amd64_4.18.10-2kali1_amd64.deb&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　　　　　　　这些文件基本包含了安装新内核及其头文件所需的所有文件，但根据具体情况，可能仍有缺漏，因此在读者安装时，&lt;span&gt;&lt;strong&gt;仍可能会缺失一些依赖&lt;/strong&gt;&lt;/span&gt;，                     若发生这种情况，推荐读者&lt;span&gt;&lt;strong&gt;仍在该目录下进行寻找&lt;/strong&gt;&lt;/span&gt;，或&lt;span&gt;&lt;strong&gt;联系博主以获取帮助&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　&lt;span&gt;&lt;strong&gt;2）网卡驱动&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　&lt;span&gt;&lt;strong&gt;路径：  /pool/non-free/b/broadcom-sta&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　&lt;span&gt;&lt;strong&gt;文件：  broadcom-sta-dkms_驱动版本号.deb&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　&lt;strong&gt;注意：此文件的位置取决于读者自己的网卡型号，抱歉不能为其他网卡型号的朋友提供帮助，大家可以尝试参考其他博客或从网卡的官网寻找相应的linux驱动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　&lt;span&gt;&lt;strong&gt;3）一些依赖文件&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　&lt;strong&gt;&lt;span&gt;路径： /pool/main/d/dkms&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　&lt;span&gt;&lt;strong&gt;文件：dkms_2.6.1-1_all.deb&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　&lt;span&gt;&lt;strong&gt;路径：/pool/main/d/debhelper&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　&lt;span&gt;&lt;strong&gt;文件：debhelper_11.4.1_all.deb&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;7、安装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　安装属于常规操作，不想看的大牛们可以跳过这一节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;strong&gt;1）&lt;/strong&gt;  用U盘将上一节中下载的文件拷贝到&lt;span&gt;&lt;strong&gt;文件管理器的一个目录下&lt;/strong&gt;&lt;/span&gt;，推荐选择  “下载”  这个目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 　&lt;strong&gt;2）&lt;/strong&gt; 在这一目录下右击鼠标，选择 &lt;span&gt;&lt;strong&gt;“在终端打开”&lt;/strong&gt;&lt;/span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;strong&gt;3）&lt;/strong&gt; 输入命令    &lt;span&gt;&lt;strong&gt; dpkg -i  文件名&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            （提示：&lt;strong&gt;可以只输入一部分文件名，然后按Tab键来补全，再按一次以选择下一个有同样前缀的文件&lt;/strong&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;strong&gt;4）重新启动&lt;/strong&gt;，如果一切顺利，你的无线驱动已经安装完成了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;8、可能出现的问题　&lt;/strong&gt;&lt;/span&gt;　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;span&gt;&lt;strong&gt;1）安装过程中出现依赖缺失&lt;/strong&gt;&lt;/span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;&lt;span&gt;请移步 &lt;a href=&quot;https://www.debian.org/distrib/packages#search_packages&quot; target=&quot;_blank&quot;&gt;&lt;span&gt; https://www.debian.org/distrib/packages#search_packages&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　在选择&lt;span&gt;&lt;strong&gt;“搜索软件包目录”&lt;/strong&gt;&lt;/span&gt;后，输入缺失包的名称，进入搜索&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 &lt;/span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467200/201810/1467200-20181031212945370-1825794436.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;然后进入该软件包的下载页面，即可在&lt;span&gt;高亮位置&lt;/span&gt;找到它所在的目录&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467200/201810/1467200-20181031213451277-1806137152.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;2）重新启动后没有使用新的内核版本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　    &lt;span&gt;&lt;strong&gt;若重新启动后使用   uname -r  发现内核版本并没有变化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　　　  则应该在&lt;span&gt;grub界面&lt;/span&gt;选择 &lt;span&gt;&quot;Advanced options for Kali GNU/Linux&quot;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　　　  然后&lt;span&gt;选择新安装的内核版本&lt;/span&gt;即可&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467200/201810/1467200-20181031214234437-548809728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;9、结语&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　本片教程就到这里了，博主也是刚开始学习kali，操作中可能有些疏漏和不妥当的地方，恳请各位看到的大牛们不吝指正，我一定会及时修改错误！&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;



</description>
<pubDate>Wed, 31 Oct 2018 15:48:00 +0000</pubDate>
<dc:creator>moonfair</dc:creator>
<og:description>本文主要介绍了如何在没有有线网的情况下安装Kali Linux 的无线网卡驱动，主要原理是通过从源网站直接下载缺失的软件包，希望能够帮到大家！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moonfair/p/9886147.html</dc:identifier>
</item>
<item>
<title>JVM总括三-字节码、字节码指令、JIT编译执行 - 程序员自我修养张振力</title>
<link>http://www.cnblogs.com/java-zzl/p/9862329.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java-zzl/p/9862329.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;JVM总括三-字节码、字节码指令、JIT编译执行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;　　java文件编译后的class文件，java跨平台的中间层，JVM通过对字节码的&lt;strong&gt;解释执行&lt;/strong&gt;（执行模式，还有&lt;strong&gt;JIT编译执行&lt;/strong&gt;，下面讲解），屏蔽对操作系统的依赖。&lt;strong&gt;一个字节&lt;/strong&gt;（8位）可以储存&lt;strong&gt;256中不同的指令&lt;/strong&gt;，这样的指令就是字节码，java所有指令有200个左右，这些指令组成了字节码文件（.class）。&lt;/p&gt;
&lt;h3&gt;一、字节码的主要指令：&lt;/h3&gt;
&lt;p&gt;　　.class文件里面的十六进制文件（如：图一），其中&lt;strong&gt;CAFE BABE&lt;/strong&gt;是标志这个文件为java的编译后的文件，00000034代表版本号，01670700一个字节（8位）就是一个字节指令，由于数值指令太难看懂，我们可以用&lt;strong&gt;javap&lt;/strong&gt;将指令翻译为助记指令（如：图二）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463936/201810/1463936-20181027165538463-312222058.png&quot; alt=&quot;&quot; width=&quot;359&quot; height=&quot;209&quot;/&gt;  图一&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463936/201810/1463936-20181027170246425-1473453970.png&quot; alt=&quot;&quot; width=&quot;474&quot; height=&quot;190&quot;/&gt;  图二&lt;/p&gt;
&lt;h4&gt;1、加载或储存指令&lt;/h4&gt;
&lt;p&gt;　　在栈帧中，通过指令操作数据在局部变量表与操作栈间传递。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ILOAD、ALOAD&lt;/strong&gt;：将int、对象引用类型从局部变量表压入操作栈顶；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ISTORE、ASTORE&lt;/strong&gt;：将int、对象引用类型从操作栈顶储存到局部变量表里；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ICONST、BIPUSH、SIPUSH、LDC&lt;/strong&gt;：将常亮加载到操作栈顶。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;2、运算指令&lt;/h4&gt;
&lt;p&gt;　　对操作栈上的值进行运算，并把结果写入操作栈顶，如&lt;strong&gt;IADD、IMUL&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;3、类型转换指令&lt;/h4&gt;
&lt;p&gt;　&lt;strong&gt;　I2L、D2F&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;4、对象创建与访问指令&lt;/h4&gt;
&lt;p&gt; 　　&lt;strong&gt;NEW&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;除了字节码指令外，还包括像LINENUMBER储存字节码与源码对应，方便调试定位；LOCALVARIABLE储存当前方法使用到的局部表量表。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;二、java源码文件转化为字节码（.class）文件的过程&lt;/h3&gt;
&lt;p&gt; 　　&lt;strong&gt;JAVA源文件&lt;/strong&gt;----------&amp;gt;&lt;strong&gt;词法解析&lt;/strong&gt;----------&amp;gt;&lt;strong&gt;语法解析&lt;/strong&gt;----------&amp;gt;&lt;strong&gt;语义分析&lt;/strong&gt;---------&amp;gt;&lt;strong&gt;生成字节码&lt;/strong&gt;---------&amp;gt;&lt;strong&gt;字节码文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;词法分析&lt;/strong&gt;：根据空格分割出单词、操作符等，形成token信息流；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;语法分析&lt;/strong&gt;：根据token流和java语法规范生成语法树；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;语义分析&lt;/strong&gt;：检查关键字、类型匹配是否正确；&lt;/p&gt;
&lt;h3&gt;三、执行模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、解释执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;JVM通过加载到的字节码进行执行；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、JIT编译执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;将热点代码（例如：高频方法体、循环体、公共模块）直接翻译成机器码，提高以后的执行效率；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、JIT编译执行与解释执行混合执行（主流JVM执行模式）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;每次方法调用的时候，方法调用计数器加1，如果计数达到阈值，请求编译成机器码，将机器码放在Code cache里面，下次执行查看是否已编译成机器码，已编译的直接执行机器码，没有编译的通过解释执行（也就是执行字节码）；&lt;/p&gt;

</description>
<pubDate>Wed, 31 Oct 2018 15:36:00 +0000</pubDate>
<dc:creator>程序员自我修养张振力</dc:creator>
<og:description>字节码、字节码指令、JIT编译执行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/java-zzl/p/9862329.html</dc:identifier>
</item>
<item>
<title>程序学习之路: 前端取经秘笈集结（持续更新） - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9886590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9886590.html</guid>
<description>&lt;p&gt;🎃捣蛋万圣节福利！&lt;/p&gt;
&lt;div class=&quot;oneLevelTitle&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031165327210-1683989743.png&quot;/&gt;&lt;h4&gt;一、Halloween Happy！&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt;今天万圣节, 是否已经按耐不住自己内心的小恶魔, 想早点下班狂欢！别着急, 咱们的上班摸鱼好朋友&lt;strong&gt;Google Doodles&lt;/strong&gt;今天又给我们推了几款'上班摸鱼'的万圣节游戏.玩起来, 时间简直不要过得飞快, 但是要注意身后的老板。&lt;/p&gt;
&lt;p&gt;google 纪念小游戏: &lt;a href=&quot;https://www.google.com/doodles/halloween-2018&quot; target=&quot;_blank&quot;&gt;《doodles》&lt;/a&gt; 或者google新建首页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031172437263-1011824901.png&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;oneLevelTitle&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031172551647-1121110137.png&quot;/&gt;&lt;h4&gt;二、前端资源汇总&lt;/h4&gt;
&lt;/div&gt;
&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;玩够了就该回来学习啦！下面整理一下所有可能接触到的前端的知识以及好的参考文献链接地址供大家参考。方便大家、也方便自己查找资料&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;前端IDE/编辑器&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://code.visualstudio.com/&quot; target=&quot;_blank&quot;&gt;VSCode&lt;/a&gt;： 个人觉得前端最好用的编辑器，而且免费。推荐使用&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://www.sublimetext.com/&quot; target=&quot;_blank&quot;&gt;sublime text 3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://notepad-plus-plus.org/download/v7.5.9.html&quot; target=&quot;_blank&quot;&gt;notepad++&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;个人比较不喜欢比较庞大的编辑器: HBuild、Webstorm.而且公司使用收费编辑器需要版权&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;CSS&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;http://www.w3school.com.cn/css/index.asp&quot; target=&quot;_blank&quot;&gt;.css&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://lesscss.cn/&quot; target=&quot;_blank&quot;&gt;.less&lt;/a&gt;：个人(公司)用得比较多, 和sass没多大区别.能加快css开发效率(谁用谁知道)&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://sass.bootcss.com/&quot; target=&quot;_blank&quot;&gt;.sass&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;JavaScript&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://study.163.com/course/introduction/224014.htm&quot; target=&quot;_blank&quot;&gt;👍《智能社:JavaScript教程-从入门到精通》&lt;/a&gt;：石川老师讲得非常好, 我当初入门就是看的这网课&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://www.w3school.com.cn/js/index.asp&quot; target=&quot;_blank&quot;&gt;《W3C JavaScript 教程》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000&quot; target=&quot;_blank&quot;&gt;《廖雪峰JavaScript教程》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://javascript.ruanyifeng.com/&quot; target=&quot;_blank&quot;&gt;《JavaScript 标准参考教程（alpha） -阮一峰》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://www.pansoso.com/zh/%E9%94%8B%E5%88%A9%E7%9A%84jquery&quot; target=&quot;_blank&quot;&gt;《锋利的JQuery》&lt;/a&gt;： jquery入门神器&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://blog.thankbabe.com/front/?hmsr=toutiao.io&amp;amp;source=toutiao&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&quot; target=&quot;_blank&quot;&gt;《JavaScript 秘密花园》&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;ES2015(ES6)&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/ruanyf/es6tutorial&quot; target=&quot;_blank&quot;&gt;👍《ECMAScript 6入门第三版》 -阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://scq000.github.io/2016/11/05/%E5%89%8D%E7%AB%AF%E7%9A%84%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BPromise%E5%92%8CAwait-Async/&quot; target=&quot;_blank&quot;&gt;《前端的异步解决方案之Promise和Await Async》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://segmentfault.com/a/1190000004365693&quot; target=&quot;_blank&quot;&gt;《30分钟掌握ES6/ES2015核心内容（上）》 -思否&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://segmentfault.com/a/1190000004368132&quot; target=&quot;_blank&quot;&gt;《30分钟掌握ES6/ES2015核心内容（下）》 -思否&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;前端基础面试&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers&quot; target=&quot;_blank&quot;&gt;赞《前端开发面试题》&lt;/a&gt;： 知识面非常广的前端面试题&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;NodeJs&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;http://nodeclass.com/&quot; target=&quot;_blank&quot;&gt;《Nodejs学习社区》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://www.npmjs.com/&quot; target=&quot;_blank&quot;&gt;《NPM官网》&lt;/a&gt;： 经常在上面找一些好的开源包&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://nqdeng.github.io/7-days-nodejs&quot; target=&quot;_blank&quot;&gt;《七天学会NodeJS -Nanqiao Deng》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://koa.bootcss.com/&quot; target=&quot;_blank&quot;&gt;《koa2 官网》&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;Webpack&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://www.jianshu.com/p/42e11515c10f&quot; target=&quot;_blank&quot;&gt;👍《入门Webpack，看这篇就够了》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://www.cnblogs.com/soyxiaobi/p/9489444.html&quot; target=&quot;_blank&quot;&gt;《soyChat》&lt;/a&gt;：个人React+Webpack+Express实战项目&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://zhaoda.gitbooks.io/webpack/content/&quot; target=&quot;_blank&quot;&gt;《Webpack 中文指南》&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;React&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://study.163.com/course/introduction/1003594007.htm&quot; target=&quot;_blank&quot;&gt;《智能社 React系列教学》&lt;/a&gt;： 入门基础&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://react.docschina.org/docs/hello-world.html&quot; target=&quot;_blank&quot;&gt;《React 中文文档》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://ant.design/&quot; target=&quot;_blank&quot;&gt;👍《Zent UI》&lt;/a&gt;： 公司的开源项目，当然要大力推荐啦！&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://ant.design/&quot; target=&quot;_blank&quot;&gt;《Ant-design》&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;微信小程序&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/&quot; target=&quot;_blank&quot;&gt;《微信小程序官方文档》&lt;/a&gt;： 你想要的这里都有&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://ant.design/&quot; target=&quot;_blank&quot;&gt;《wepy》&lt;/a&gt;： 微信官方框架&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/youzan/vant-weapp&quot; target=&quot;_blank&quot;&gt;👍《ZanUI-WeApp》&lt;/a&gt;： 公司的开源项目，当然要大力推荐啦！&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;其他&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/youzan/zan-proxy&quot; target=&quot;_blank&quot;&gt;👍《Zan-Proxy》&lt;/a&gt;： 公司的开源项目，当然要大力推荐啦！一款非常好用的调试线上代码的开源项目, 有了它再也不用担心发布线上了！&lt;/p&gt;
&lt;p&gt;-----未完待续------&lt;/p&gt;
</description>
<pubDate>Wed, 31 Oct 2018 15:27:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>🎃捣蛋万圣节福利！ 一、Halloween Happy！ 今天万圣节, 是否已经按耐不住自己内心的小恶魔, 想早点下班狂欢！别着急, 咱们的上班摸鱼好朋友Google Doodles今天又给我们推了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9886590.html</dc:identifier>
</item>
<item>
<title>#muduo学习笔记(二)Reactor关键结构 - 艾露米婭娜</title>
<link>http://www.cnblogs.com/ailumiyana/p/9886358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ailumiyana/p/9886358.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;reactor简述&quot;&gt;Reactor简述&lt;/h2&gt;
&lt;h3 id=&quot;什么是reactor&quot;&gt;什么是Reactor&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Reactor&lt;/code&gt;是一种基于事件驱动的设计模式，即通过回调机制,我们将事件的接口注册到Reactor上,当事件发生之后,就会回调注册的接口。&lt;br/&gt;&lt;code&gt;Reactor必要的几个组件&lt;/code&gt;：&lt;br/&gt;&lt;code&gt;Event Multiplexer事件分发器&lt;/code&gt;:即一些I/O复用机制select、poll、epoll等.程序将事件源注册到分发器上,等待事件的触发，做相应处理.&lt;br/&gt;&lt;code&gt;Handle事件源&lt;/code&gt;：用于标识一个事件，Linux上是文件描述符.&lt;br/&gt;&lt;code&gt;Reactor反应器&lt;/code&gt;：用于管理事件的调度及注册删除.当有激活的事件时,则调用回调函数处理，没有则继续事件循环.&lt;br/&gt;&lt;code&gt;event handler事件处理器&lt;/code&gt;：管理已注册事件和的调度，分成不同类型的事件(读/写,定时)当事件发生,调用对应的回调函数处理.&lt;/p&gt;
&lt;h3 id=&quot;reactor模型的优缺点&quot;&gt;Reactor模型的优缺点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;优点&lt;/code&gt;&lt;br/&gt;1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；&lt;br/&gt;2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；&lt;br/&gt;3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；&lt;br/&gt;4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;缺点&lt;/code&gt;&lt;br/&gt;Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，会影响这个Reactor中其他Channel的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的Thread-Per-Connection或许是一个更好的选择，或则此时使用Proactor模式。&lt;/p&gt;
&lt;h2 id=&quot;poll简述&quot;&gt;poll简述&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;poll的使用方法与select相似，轮询多个文件描述符，有读写时设置相应的状态位，poll相比select优在没有最大文件描述符数量的限制.&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;# include &amp;lt;poll.h&amp;gt;
int poll ( struct pollfd * fds, unsigned int nfds, int timeout);

struct pollfd {
int fd;         /* 文件描述符 */
short events;         /* 等待的事件 */
short revents;       /* 实际发生了的事件 */
} ; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　每一个pollfd结构体指定了一个被监视的文件描述符，可以传递多个结构体，指示poll()监视多个文件描述符。每个结构体的events域是监视该文件描述符的事件掩码，由用户来设置这个域。revents域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。events域中请求的任何事件都可能在revents域中返回。合法的事件如下：&lt;/p&gt;
&lt;p&gt;　　POLLIN 　　　　　　　　有数据可读。&lt;br/&gt;　　POLLRDNORM 　　　　 有普通数据可读。&lt;br/&gt;　　POLLRDBAND　　　　　 有优先数据可读。&lt;br/&gt;　　POLLPRI　　　　　　　　 有紧迫数据可读。&lt;br/&gt;　　POLLOUT　　　　　　 写数据不会导致阻塞。&lt;br/&gt;　　POLLWRNORM　　　　　 写普通数据不会导致阻塞。&lt;br/&gt;　　POLLWRBAND　　　　　 写优先数据不会导致阻塞。&lt;br/&gt;　　POLLMSGSIGPOLL 　　　　消息可用。&lt;/p&gt;
&lt;h3 id=&quot;poll使用样例&quot;&gt;poll使用样例&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;

#define MAX_BUFFER_SIZE 1024
#define IN_FILES 1
#define MAX(a,b) ((a&amp;gt;b)?(a):(b))

int main(int argc ,char **argv)
{
  struct pollfd fds[3];
  char buf[1024];
  int i,res,real_read, maxfd;

  if((fds[0].fd=open(&quot;/dev/stdin&quot;,O_RDONLY|O_NONBLOCK)) &amp;lt; 0)
  {
    fprintf(stderr,&quot;open data1 error:%s&quot;,strerror(errno));
    return 1;
  }

  for (i = 0; i &amp;lt; IN_FILES; i++)
  {
    fds[i].events = POLLIN | POLLPRI;
  }

  while(1) //|| fds[1].events || fds[2].events)
  {
    int ret = poll(fds, 1, 1000);
    if (ret &amp;lt; 0)
    {
      printf(&quot;Poll error : %s\n&quot;,strerror(errno));
      return 1;
    }

    if(ret == 0){
      printf(&quot;Poll timeout\n&quot;);
      continue;
    }

    for (i = 0; i&amp;lt; 1; i++)
    {
      if (fds[i].revents)
      {
        memset(buf, 0, MAX_BUFFER_SIZE);
        real_read = read(fds[i].fd, buf, MAX_BUFFER_SIZE);
        if (real_read &amp;lt; 0)
        {
          if (errno != EAGAIN)
          {
            printf(&quot;read eror : %s\n&quot;,strerror(errno));
            continue;
          }
        }
        else if (!real_read)
        {
          close(fds[i].fd);
          fds[i].events = 0;
        }
        else
        {
          if (i == 0)
          {
            buf[real_read] = '\0';
            printf(&quot;%s&quot;, buf);
            if ((buf[0] == 'q') || (buf[0] == 'Q'))
            {
              printf(&quot;quit\n&quot;);
              return 1;
            }
          }
          else
          {
            buf[real_read] = '\0';
            printf(&quot;%s&quot;, buf);
          }
        }
      }
    }
  }

  exit(0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;muduo-reactor关键结构&quot;&gt;muduo Reactor关键结构&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;muduo Reactor最核心的事件分发机制， 即将IO multiplexing拿到的IO事件分发给各个文件描述符（fd）的事件处理函数。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;channel&quot;&gt;Channel&lt;/h3&gt;
&lt;p&gt;Chanel目前我对它的理解是，它负责&lt;code&gt;管理一个文件描述符(file descript)IO事件.&lt;/code&gt;&lt;br/&gt;Channel会封装C的poll，把不同的IO事件分发到不同的回调：ReadCallBack、WriteCallBack等&lt;br/&gt;每个Channel对象自始至终只属于一个EventLoop，因此每个Channel对象都只属于某一个IO线程。 每个Channel对象自始至终只负责一个文件描述符（fd） 的IO事件分发&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1384555/201810/1384555-20181031223231533-483231737.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#ifndef NET_CHANNEL_H
#define NET_CHANNEL_H

#include &amp;lt;functional&amp;gt;

#include &quot;EventLoop.hh&quot;

class Channel {
public:
  typedef std::function&amp;lt;void()&amp;gt; EventCallBack;
  Channel(EventLoop* loop, int fd);
  ~Channel();

  void handleEvent();
  void setReadCallBack(const EventCallBack&amp;amp; cb) { m_readCallBack = cb; }
  void setWriteCallBack(const EventCallBack&amp;amp; cb) { m_writeCallBack = cb; }
  void setErrorCallBack(const EventCallBack&amp;amp; cb) { m_errorCallBack = cb; }

  int fd() const { return m_fd; }
  int events() const { return m_events; }
  void set_revents(int revt) { m_revents = revt; }
  bool isNoneEvent() const { return m_events == kNoneEvent; }

  void eableReading() { m_events |=  kReadEvent; update(); }

  int index() { return m_index; }
  void set_index(int idx) { m_index =idx; }

  EventLoop* ownerLoop() { return m_pLoop; }

private:
  Channel&amp;amp; operator=(const Channel&amp;amp;);
  Channel(const Channel&amp;amp;);

  void update();

  static const int kNoneEvent;
  static const int kReadEvent;
  static const int kWriteEvent;

  EventLoop* m_pLoop;
  const int m_fd;
  int m_events;    // 等待的事件
  int m_revents;   // 实际发生了的事件
  int m_index;

  EventCallBack m_readCallBack;
  EventCallBack m_writeCallBack;
  EventCallBack m_errorCallBack;
};

#endif

//Channel.cpp

#include &amp;lt;poll.h&amp;gt;
#include &quot;Channel.hh&quot;
#include &quot;Logger.hh&quot;

const int Channel::kNoneEvent = 0;
const int Channel::kReadEvent = POLLIN | POLLPRI;
const int Channel::kWriteEvent = POLLOUT;

Channel::Channel(EventLoop* loop, int fd)
  : m_pLoop(loop),
    m_fd(fd),
    m_events(0),
    m_revents(0),
    m_index(-1)
{

}

Channel::~Channel()
{

}

void Channel::update()
{
  m_pLoop-&amp;gt;updateChannel(this);
}


void Channel::handleEvent()
{
  if(m_revents &amp;amp; POLLNVAL)
  {
    LOG_WARN &amp;lt;&amp;lt; &quot;Channel::handleEvent() POLLNVAL&quot;;
  }

  if(m_revents &amp;amp; (POLLERR | POLLNVAL)){
    if(m_errorCallBack) m_errorCallBack();
  }

  if(m_revents &amp;amp; (POLLIN | POLLPRI | POLLRDHUP)){
    if(m_readCallBack) m_readCallBack();
  }

  if(m_revents &amp;amp; POLLOUT){
    if(m_writeCallBack) m_writeCallBack();
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;值得一提的就是 Channel::update()它会调用EventLoop::updateChannel()， 后者会转而调&lt;br/&gt;用Poller::updateChannel()。Poller对象下面会讲，通过Poller::updateChannel()注册IO事件(即file descript).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Channel::handleEvent()是Channel的核心， 它由EventLoop::loop()调&lt;br/&gt;用， 它的功能是根据revents发生事件的的值分别调用不同的用户回调。 这个函数以后还会扩充。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;poller&quot;&gt;Poller&lt;/h3&gt;
&lt;p&gt;Poller class是IO multiplexing的封装。 它现在是个具体类，而在muduo中是个抽象基类，因为muduo同时支持poll(2)和epoll(4)两种IOmultiplexing机制。&lt;br/&gt;Poller是EventLoop的间接成员，只供其自己在EventLoop的IO线程中调用，因此无须加锁。其生命期与EventLoop相等。&lt;br/&gt;Poller并不拥有管理文件描述符事件的Channel， Channel在析构之前必须自己&lt;br/&gt;unregister（EventLoop::removeChannel()） ， 避免空悬指针&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#ifndef _NET_POLLER_HH
#define _NET_POLLER_HH

#include &amp;lt;vector&amp;gt;
#include &amp;lt;map&amp;gt;

#include &quot;TimeStamp.hh&quot;
#include &quot;EventLoop.hh&quot;
#include &quot;Channel.hh&quot;

struct pollfd;

class Poller{
public:
  typedef std::vector&amp;lt;Channel*&amp;gt; ChannelList;

  Poller(EventLoop* loop);
  ~Poller();

  TimeStamp poll(int timeoutMs, ChannelList* activeChannels);

  void updateChannel(Channel* channel);

  void assertInLoopThread() { m_pOwerLoop-&amp;gt;assertInLoopThread(); }

private:
  Poller&amp;amp; operator=(const Poller&amp;amp;);
  Poller(const Poller&amp;amp;);

  void fillActiveChannels(int numEvents, ChannelList* activeChannels) const;

  typedef std::vector&amp;lt;struct pollfd&amp;gt; PollFdList;
  typedef std::map&amp;lt;int, Channel*&amp;gt; ChannelMap;

  EventLoop* m_pOwerLoop;
  PollFdList m_pollfds;
  ChannelMap m_channels;

};

#endif

//Poller.cpp
#include &quot;Poller.hh&quot;
#include &quot;Logger.hh&quot;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;

Poller::Poller(EventLoop* loop)
  : m_pOwerLoop(loop)
{

}

Poller::~Poller()
{

}

TimeStamp Poller::poll(int timeoutMs, ChannelList* activeChannels)
{
  LOG_TRACE &amp;lt;&amp;lt; &quot;Poller::poll()&quot;;
  int numEvents = ::poll(/*&amp;amp;*m_pollfds.begin()*/m_pollfds.data(), m_pollfds.size(), timeoutMs);
  TimeStamp now(TimeStamp::now());
  if(numEvents &amp;gt; 0){
    LOG_TRACE &amp;lt;&amp;lt; numEvents &amp;lt;&amp;lt; &quot; events happended&quot;;
    fillActiveChannels(numEvents, activeChannels);
  }
  else if(numEvents == 0){
    LOG_TRACE &amp;lt;&amp;lt; &quot; nothing happended&quot;;
  }
  else{
    LOG_SYSERR &amp;lt;&amp;lt; &quot;Poller::poll()&quot;;
  }

  return now;
}

/*
 *fillActiveChannels()遍历m_pollfds， 找出有活动事件的fd， 把它对应
 *的Channel填入activeChannels。
 */

void Poller::fillActiveChannels(int numEvents, ChannelList* activeChannels) const
{
  for(PollFdList::const_iterator pfd = m_pollfds.begin();
      pfd != m_pollfds.end() &amp;amp;&amp;amp; numEvents &amp;gt; 0; ++pfd)
  {
    if(pfd-&amp;gt;revents &amp;gt; 0)
    {
      --numEvents;
      ChannelMap::const_iterator ch = m_channels.find(pfd-&amp;gt;fd);
      assert(ch != m_channels.end());
      Channel* channel = ch-&amp;gt;second;
      assert(channel-&amp;gt;fd() == pfd-&amp;gt;fd);
      channel-&amp;gt;set_revents(pfd-&amp;gt;revents);
      activeChannels-&amp;gt;push_back(channel);
    }
  }
}

void Poller::updateChannel(Channel* channel)
{
  assertInLoopThread();
  LOG_TRACE &amp;lt;&amp;lt; &quot;fd= &quot; &amp;lt;&amp;lt; channel-&amp;gt;fd() &amp;lt;&amp;lt; &quot; events&quot; &amp;lt;&amp;lt; channel-&amp;gt;events();
  if(channel-&amp;gt;index() &amp;lt; 0){
    //a new one , add to pollfds
    assert(m_channels.find(channel-&amp;gt;fd()) == m_channels.end());
    struct pollfd pfd;
    pfd.fd = channel-&amp;gt;fd();
    pfd.events = static_cast&amp;lt;short&amp;gt;(channel-&amp;gt;events());
    pfd.revents = 0;
    m_pollfds.push_back(pfd);
    int idx = static_cast&amp;lt;int&amp;gt;(m_pollfds.size()) - 1;
    channel-&amp;gt;set_index(idx);
    m_channels[pfd.fd] = channel;

  }
  else{
    //update existing one
    assert(m_channels.find(channel-&amp;gt;fd()) != m_channels.end());
    assert(m_channels[channel-&amp;gt;fd()] == channel);
    int idx = channel-&amp;gt;index();
    assert(0 &amp;lt;= idx &amp;amp;&amp;amp; idx &amp;lt; static_cast&amp;lt;int&amp;gt;(m_pollfds.size()));
    struct pollfd&amp;amp; pfd = m_pollfds[idx];
    assert(pfd.fd == channel-&amp;gt;fd() || pfd.fd == -1);
    pfd.events = static_cast&amp;lt;short&amp;gt;(channel-&amp;gt;events());
    pfd.revents = 0;
    if(channel-&amp;gt;isNoneEvent()){
      //ignore this pollfd
      pfd.fd = -1;
    }
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;eventloop&quot;&gt;EventLoop&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;EventLopp在上一篇文章写过,这里给出改动.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;EventLoop 新增了quit()成员函数， 还加了几个数据成员，并在构造函数里初始化它们。注意EventLoop通过智能指针来间接持有poller.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+class Poller;
+class Channel;

class EventLoop
------------
    bool isInloopThread() const {return m_threadId == CurrentThread::tid(); }

    +void quit();
    +void updateChannel(Channel* channel);

    static EventLoop* getEventLoopOfCurrentThread();

private:
    EventLoop&amp;amp; operator=(const EventLoop&amp;amp;);
    EventLoop(const EventLoop&amp;amp;);

    void abortNotInLoopThread();

    +typedef std::vector&amp;lt;Channel*&amp;gt; ChannelList;

    bool m_looping;
    +bool m_quit;
    const pid_t m_threadId;
    +std::unique_ptr&amp;lt;Poller&amp;gt; m_poller;
    +ChannelList m_activeChannels;
};

//EventLoop.cpp
  m_threadId(CurrentThread::tid()),
 + m_poller(new Poller(this))
{
------
+void EventLoop::quit()
+{
+  m_quit = true;
+  //wakeup();
+}
+
+void EventLoop::updateChannel(Channel* channel)
+{
+  assert(channel-&amp;gt;ownerLoop() == this);
+  assertInLoopThread();
+  m_poller-&amp;gt;updateChannel(channel);
+}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上一篇文章的EventLoop-&amp;gt;loop()什么也没做,现在它有了实实在在的使命，&lt;code&gt;它调用Poller::poll()获得当前活动事件的Chanel列表， 然后依次调用每个Channel的handleEvent()函数&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void EventLoop::loop()
{
  assert(!m_looping);
  assertInLoopThread();
  m_looping = true;
  m_quit = false;

  LOG_TRACE &amp;lt;&amp;lt; &quot;EventLoop &quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &quot; start loopig&quot;;

  while(!m_quit)
  {
    m_activeChannels.clear();
    m_poller-&amp;gt;poll(1000, &amp;amp;m_activeChannels);
    for(ChannelList::iterator it = m_activeChannels.begin();
      it != m_activeChannels.end(); ++it)
    {
      (*it)-&amp;gt;handleEvent();
    }

  }

  LOG_TRACE &amp;lt;&amp;lt; &quot;EventLoop &quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &quot; stop loopig&quot;;
  m_looping = false;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;reactor时序图&quot;&gt;Reactor时序图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1384555/201810/1384555-20181031223138159-1743991001.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;测试程序-单次触发的定时器&quot;&gt;测试程序-单次触发的定时器&lt;/h3&gt;
&lt;p&gt;程序利用timerfd_create 把时间变成了一个文件描述符，该“文件”在定时器超时的那一刻变得可读，这样就能很方便地融入到 select/poll 框架中，用统一的方式来处理 IO 事件和超时事件，这也正是 Reactor 模式的长处。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;strings.h&amp;gt;

#include &quot;EventLoop.hh&quot;
#include &quot;Channel.hh&quot;
#include &quot;Poller.hh&quot;

//Reactor Test
//单次触发定时器
#include &amp;lt;sys/timerfd.h&amp;gt;

EventLoop* g_loop;

void timeout()
{
  printf(&quot;timeout!\n&quot;);
  g_loop-&amp;gt;quit();
}

int main()
{

  EventLoop loop;
  g_loop = &amp;amp;loop;

  int timerfd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK |TFD_CLOEXEC);

  Channel channel(&amp;amp;loop, timerfd);
  channel.setReadCallBack(timeout);
  channel.eableReading();

  struct itimerspec howlong;
  bzero(&amp;amp;howlong, sizeof howlong);
  howlong.it_value.tv_sec = 3;
  timerfd_settime(timerfd, 0, &amp;amp;howlong, NULL);

  loop.loop();

  close(timerfd);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt; ./test.out 
2018-10-31 22:25:54.532487 [TRACE] [EventLoop.cpp:16] [EventLoop] EventLoop Create 0x7FFEB9567CC0 in thread 3075
2018-10-31 22:25:54.533563 [TRACE] [Poller.cpp:64] [updateChannel] fd= 3 events3
2018-10-31 22:25:54.534000 [TRACE] [EventLoop.cpp:41] [loop] EventLoop 0x7FFEB9567CC0 start loopig
2018-10-31 22:25:54.534334 [TRACE] [Poller.cpp:20] [poll] Poller::poll()
2018-10-31 22:25:55.535827 [TRACE] [Poller.cpp:28] [poll]  nothing happended
2018-10-31 22:25:55.536287 [TRACE] [Poller.cpp:20] [poll] Poller::poll()
2018-10-31 22:25:56.538334 [TRACE] [Poller.cpp:28] [poll]  nothing happended
2018-10-31 22:25:56.538802 [TRACE] [Poller.cpp:20] [poll] Poller::poll()
2018-10-31 22:25:57.534175 [TRACE] [Poller.cpp:24] [poll] 1 events happended
timeout!
2018-10-31 22:25:57.534766 [TRACE] [EventLoop.cpp:55] [loop] EventLoop 0x7FFEB9567CC0 stop loopig
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 31 Oct 2018 14:33:00 +0000</pubDate>
<dc:creator>艾露米婭娜</dc:creator>
<og:description>muduo学习笔记(二)Reactor关键结构 [TOC] Reactor简述 什么是Reactor 是一种基于事件驱动的设计模式，即通过回调机制,我们将事件的接口注册到Reactor上,当事件发生之</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ailumiyana/p/9886358.html</dc:identifier>
</item>
<item>
<title>前端入门5-CSS弹性布局flex - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/9886038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/9886038.html</guid>
<description>&lt;p&gt;本系列文章内容全部梳理自以下四个来源：&lt;/p&gt;
&lt;p&gt;作为一个前端小白，入门跟着这四个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。&lt;/p&gt;

&lt;p&gt;弹性布局的作用有点儿类似 Android 中 LinearLayout 和 RelativeLayout 两者的合成版，即：支持横向布局，纵向布局，start，end，center 布局，宽高按比例瓜分等等，当然它还有很多其他功能，比如自动换行，按指定 order 排列等。总之有了 Android 基础，理解弹性布局 flex 蛮容易的。&lt;/p&gt;
&lt;p&gt;可以这么的理解，传统的网页布局方式是通过 display 和 position 以及 float 三者完成的，借助块级元素，行内元素特性，结合 position 指定的相对布局、绝对布局、固定布局方式来实现各种排版效果。如果需要浮动，则借助 float。&lt;/p&gt;
&lt;p&gt;但这种传统的方式，一来使用较复杂，二来某些排版效果不好实现，如列表、居中、响应式布局等效果。&lt;/p&gt;
&lt;p&gt;而 flex 则能够很好的完成传统的布局工作，而且，它还可以支持响应式布局。&lt;/p&gt;
&lt;h3 id=&quot;基础概念&quot;&gt;1.基础概念&lt;/h3&gt;
&lt;h4 id=&quot;两根轴线&quot;&gt;两根轴线&lt;/h4&gt;
&lt;p&gt;当使用 flex 布局时，首先想到的是两根轴线：主轴和交叉轴。主轴由 flex-direction 定义，另一根轴垂直于它。我们使用 flexbox 的所有属性都跟这两根轴线有关, 所以有必要在一开始首先理解它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-08cdf2e794ab15ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;flex&quot;/&gt;&lt;/p&gt;
&lt;p&gt;理解主轴和交叉轴的概念对于对齐 flexbox 里面的元素是很重要的；因为 flexbox 的特性是沿着主轴或者交叉轴对齐之中的元素。&lt;/p&gt;
&lt;h4 id=&quot;布局空白&quot;&gt;布局空白&lt;/h4&gt;
&lt;p&gt;布局空白：available space，大概来说，flex 容器大小扣掉 items 的 flex-basis 指定的占据的空间大小之外剩余的区域，flex-basis 通常是指 item 本身的大小，当然也可以手动设置。&lt;/p&gt;
&lt;p&gt;flex 的一些属性就是通过改变 flex 容器中的布局空白分配来达到对齐等效果的。&lt;/p&gt;
&lt;p&gt;比如 items 的 flex-grow 拉伸或者 flex 容器的 justify-content 主轴对齐等，其实就是将这些布局空白按照不同算法分配给各个 item，分给 item 时，是要直接填充进 item 的内容里达到拉伸效果，还是就简单的将空白围绕在 item 周围达到类似 margin 效果来实现 item 的居中、靠左、靠右、均分等对齐方式。&lt;/p&gt;
&lt;p&gt;具体属性不了解没关系，下面的章节会讲，知道概念即可。&lt;/p&gt;
&lt;h3 id=&quot;flex相关属性&quot;&gt;2.flex相关属性&lt;/h3&gt;
&lt;p&gt;对任意块级元素标签设置 display: flex 即可让这个元素作为 flex 容器存在，也就可以使用 flex 的相关属性了。&lt;/p&gt;
&lt;p&gt;flex 的属性并不多，目前只有 13 个，其中有 7 个是 flex 弹性盒子容器本身所使用的属性，6 个是 flex-item 弹性盒子的子项使用的属性。其中，有些属性只是将其他属性的集中简化使用，因此，真正具有布局用途的属性并不多，很好掌握。&lt;/p&gt;
&lt;p&gt;作用于 flex 弹性盒子容器身上的属性：&lt;/p&gt;
&lt;h4 id=&quot;flex-direction&quot;&gt;flex-direction&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-direction: row(default) | row-reverse | column | column-reverse&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于设置主轴的方向，flex 分主轴和交叉轴两个概念，items 布局时，默认延主轴方向进行，因此通过设置主轴是水平方向还是垂直方向就可以实现 items 的水平或垂直布局。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;row：默认值，设置主轴为水平方向&lt;/li&gt;
&lt;li&gt;column：设置主轴为垂直方向&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他属性就不介绍了，因为主轴方向就两个，要么水平，要么垂直，其他的区别仅在于水平时是从左到右，还是从右到左，所以这个属性的影响因素之一的 LTR 和 RTL，但没必要考虑这么多，这些场景应该不多，知道这个是用来设置主轴方向就够了，我觉得。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-fc89a44d228d398d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;flex-direction&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flex-wrap&quot;&gt;flex-wrap&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-wrap: nowrap(default) | wrap | wrap-reverse&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于设置是否允许换行，默认值 nowrap。&lt;/p&gt;
&lt;p&gt;当设置了 wrap 时，允许 items 在主轴方向溢出时自动进行换行布局，这点可以很好的用来实现响应式布局，比如当空间逐渐缩小时，原本水平排列的控件换成垂直方向排版。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-9a74643008a31410.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;flex-wrap&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flex-flow&quot;&gt;flex-flow&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-flow: &amp;lt;'flex-direction'&amp;gt; || &amp;lt;'flex-wrap'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个属性并没有另外的含义，它只是 flex-direction 和 flex-wrap 的简写用法而已。&lt;/p&gt;
&lt;p&gt;如果你不想单独使用上述两个属性，可以将它们一起在 flex-flow 使用，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-flow: row wrap
//等效于
flex-direction: row;
flex-wrap: wrap;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;justify-content&quot;&gt;justify-content&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;justify-content: normal(default) | &amp;lt;content-distribution&amp;gt; | &amp;lt;overflow-position&amp;gt;? [ &amp;lt;content-position&amp;gt; | left | right ]
where 
&amp;lt;content-distribution&amp;gt; = space-between | space-around | space-evenly | stretch
&amp;lt;overflow-position&amp;gt; = unsafe | safe
&amp;lt;content-position&amp;gt; = center | start | end | flex-start | flex-end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于设置 items 在主轴方向上的对齐方式，可以靠左，靠右，居中或者按比例均分等效果。&lt;/p&gt;
&lt;p&gt;需要先明确一点概念，对齐是指 items 在 flex 容器中的排版对齐方式，那么要想 flex 容器可以控制 items 的对齐方式，那主轴方向上自然就还需要有布局空白，如果都没有布局空白了，不就表明 items 已充满 flex 容器了，那谈何对齐。&lt;/p&gt;
&lt;p&gt;那么，如果存在至少一个 item，它的 flex-grow 属性不等于 0，justify-content 这个属性就失效了，因为 flex-grow 表示允许 item 按照比例瓜分布局空白，这样一来布局空白被瓜分完了，flex 容器在主轴方向上已被 items 充满， 也就没有对齐一说了。&lt;/p&gt;
&lt;p&gt;所以要能够正确的使用该属性来控制 items 在主轴方向的对齐方式，那么就需要注意 item 中会影响布局空白的属性，如 flex-grow，flex-basis 这些的使用。&lt;/p&gt;
&lt;p&gt;下面看看各属性值介绍（下面的介绍不考虑 RTL 的情况，默认都以 LTR 为主）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;start：主轴是水平方向的话，左对齐方式排版；主轴是垂直方向的话，上对齐方式排版；&lt;/li&gt;
&lt;li&gt;end：主轴是水平方向的话，右对齐方式排版；主轴是垂直方向的话，下对齐方式排版；&lt;/li&gt;
&lt;li&gt;center：居中方式排版；&lt;/li&gt;
&lt;li&gt;space-between：等比例瓜分布局空白，每行首元素对齐，末元素对齐，每行各元素间距一致；&lt;/li&gt;
&lt;li&gt;space-around：与上述的类似效果，区别仅在于，每行首元素并不是在 flex 容器内容区域左边就开始布局，它距离 flex 容器左边的距离等于各个元素之间间距的一半。说白点，就是行首元素和末尾元素的周边有类型 margin 值存在。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;剩余的属性值不介绍了，因为我也还没有搞懂它们的含义和应用场景。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-196cce807ce5f660.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;justify-content&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(ps：flex 容器设置了 padding，所以 start 和 end 才没有贴靠边界 )&lt;/p&gt;
&lt;h4 id=&quot;align-items&quot;&gt;align-items&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;align-items: normal | stretch | &amp;lt;baseline-position&amp;gt; | [ &amp;lt;overflow-position&amp;gt;? &amp;lt;self-position&amp;gt; ]
where 
&amp;lt;baseline-position&amp;gt; = [ first | last ]? baseline
&amp;lt;overflow-position&amp;gt; = unsafe | safe
&amp;lt;self-position&amp;gt; = center | start | end | self-start | self-end | flex-start | flex-end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于控制 items 在交叉轴方向上的排版布局方式，justify-content 是能控制主轴上的排版，而这个属性则是用于控制交叉轴，通常两个都会一起使用，相互结合，可以达到一些类似页面居中效果。&lt;/p&gt;
&lt;p&gt;看看属性值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;flex-start：交叉轴方向，从起点开始布局排版&lt;/li&gt;
&lt;li&gt;flex-end：交叉轴方向，从末尾开始布局排版&lt;/li&gt;
&lt;li&gt;center：交叉轴方向，从中间开始布局排版&lt;/li&gt;
&lt;li&gt;stretch：交叉轴方向，如果 items 在交叉轴方向没有设置大小，那么让 items 在交叉轴的方向充满 flex 容器的高度。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他属性不介绍了，不熟悉。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-6ce0c20a2721cd63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;align-items&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(ps：flex 容器设置了 padding，所以 start 和 end 才没有贴靠边界 )&lt;/p&gt;
&lt;p&gt;stretch 要能够生效，需要在 items 在交叉轴方向的不设置大小，如上图中主轴是水平方向，那么 items 需要不设置 height，此时 stretch 才能够让 items 拉伸占据交叉轴的高度。&lt;/p&gt;
&lt;p&gt;有一点需要注意，当 flex 容器的 items 在主轴方向上只有一行时，可以很明确的使用这个属性来控制在交叉轴的排版方式。但，如果 items 在主轴上超过一行，那么最终的效果可能就不是想要的了，比如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-bac610aee3b3dddc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;align-items2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果是想实现多行的 items 都作为一个整体居中，那么用 align-items 就无法实现了，针对这种有多行的情况，需要用另外一个属性来控制：align-content。&lt;/p&gt;
&lt;h4 id=&quot;align-content&quot;&gt;align-content&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;align-content: normal | &amp;lt;baseline-position&amp;gt; | &amp;lt;content-distribution&amp;gt; | &amp;lt;overflow-position&amp;gt;? &amp;lt;content-position&amp;gt;
where 
&amp;lt;baseline-position&amp;gt; = [ first | last ]? baseline
&amp;lt;content-distribution&amp;gt; = space-between | space-around | space-evenly | stretch
&amp;lt;overflow-position&amp;gt; = unsafe | safe
&amp;lt;content-position&amp;gt; = center | start | end | flex-start | flex-end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 flex 容器的 items 设置了溢出换行属性，且当前在交叉轴方向上存在多行 item 的情况下，该属性才会生效。&lt;/p&gt;
&lt;p&gt;网上有种翻译，说这个属性是用于轴对齐，我不是很理解，我自己粗俗的分两种情况理解：&lt;/p&gt;
&lt;p&gt;当需要进行 start, center, end 这些排版时，是将这些多行的 items 都看成一个整体，然后进行交叉轴方向上的排版控制。此时，将多行 item 看成一行之后，那么这个 align-content 之后的排版布局就跟 align-items 一样的效果了。&lt;/p&gt;
&lt;p&gt;其他的 space-around，space-between 究竟是如何计算排版的，不熟悉。&lt;/p&gt;
&lt;p&gt;属性值含义不看了，跟 align-items 一样的效果，直接看示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-a4b4b11bb9799c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;align-content&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(ps：flex 容器设置了 padding，所以 start 和 end 才没有贴靠边界 )&lt;/p&gt;
&lt;h4 id=&quot;place-content&quot;&gt;place-content&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;place-content: &amp;lt;'align-content'&amp;gt; &amp;lt;'justify-content'&amp;gt;?&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个属性并没有另外的含义，它只是 align-content 和 justify-content 的简写用法而已。&lt;/p&gt;
&lt;p&gt;如果你不想单独使用上述两个属性，可以将它们一起在 place-content 使用，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;place-content: center center
//等效于
align-content: center;
justify-content: center;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作用于 flex-item 弹性盒子的子项身上的属性：&lt;/p&gt;
&lt;h4 id=&quot;flex-basis&quot;&gt;flex-basis&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-basis: content | &amp;lt;'width'&amp;gt;

where 
&amp;lt;'width'&amp;gt; = [ &amp;lt;length&amp;gt; | &amp;lt;percentage&amp;gt; ] &amp;amp;&amp;amp; [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于设置 items 在主轴方向的大小，如果主轴是水平方向，相当于设置 width，此时，该属性值会覆盖掉 width 设置的大小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-abb7feeb207f305d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ps&quot;/&gt;&lt;/p&gt;
&lt;p&gt;尝试了下，在 chorme 浏览器上 content 属性不生效，不清楚，可能不同浏览器行为还不一样，既然这样，就先暂时不深入了解这个属性了，大概知道用于设置主轴方向上的 item 大小即可。&lt;/p&gt;
&lt;p&gt;就算要使用，先直接用指定数值大小的方式好了。&lt;/p&gt;
&lt;h4 id=&quot;flex-grow&quot;&gt;flex-grow&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-grow: &amp;lt;number&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于设置 item 在主轴方向上的拉伸因子，即如果 flex 容器还有剩余空间，会按照各 item 设置的拉伸因子比例关系分配。默认值为 0，即不拉伸。&lt;/p&gt;
&lt;p&gt;作用很像 Andorid 中的 LinearLayout 的 child 里设置了 layout_weight 用途一样。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-28701dfa2bfefc3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;flex-grow&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flex-shrink&quot;&gt;flex-shrink&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-shrink: &amp;lt;number&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于设置 item 在主轴方向上的收缩因子，跟 flex-grow 刚好反着来。当 flex 容器空间不够，item 要溢出时，设置次属性可控制 item 按比例进行相应收缩，以便不让 item 溢出，默认 1，值越大收缩倍数越大，最后 item 就越小，0 表示不收缩，负值无效。&lt;/p&gt;
&lt;p&gt;另外，如果设置了换行属性，那么这个就无效了。换行和收缩都是用于解决 item 在主轴方向上溢出的问题，既然是互斥，且换行优先级高，那么设置了换行，就不会再对 item 进行收缩了。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-456ce486db29b432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;flex-shrink&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flex&quot;&gt;flex&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex: none | auto | initial | [ &amp;lt;'flex-grow'&amp;gt; &amp;lt;'flex-shrink'&amp;gt;? || &amp;lt;'flex-basis'&amp;gt; ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这属性是 flex-grow，flex-shrink，flex-basis 三个属性的简化使用，有三种属性值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;none：元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应flex容器。相当于将属性设置为 &lt;code&gt;flex: 0 0 auto&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;auto：元素会根据自身的宽度与高度来确定尺寸，但是会自行伸长以吸收flex容器中额外的自由空间，也会缩短至自身最小尺寸以适应容器。这相当于将属性设置为 &lt;code&gt;flex: 1 1 auto&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;initial：属性默认值， 元素会根据自身宽高设置尺寸。它会缩短自身以适应容器，但不会伸长并吸收flex容器中的额外自由空间来适应容器 。相当于将属性设置为&quot;&lt;code&gt;flex: 0 1 auto&lt;/code&gt;&quot;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;flex 属性可以指定 1 个，2 个或 3 个值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单值语法&lt;/strong&gt;: 值必须为以下其中之一:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个无单位&lt;strong&gt;数(&amp;lt;number&amp;gt;)&lt;/strong&gt;: 它会被当作 &lt;code&gt;&amp;lt;flex-grow&amp;gt;的值。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个有效的&lt;strong&gt;宽度(width)&lt;/strong&gt;值: 它会被当作 &lt;code&gt;&amp;lt;flex-basis&amp;gt;的值。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关键字 &lt;code&gt;none, auto&lt;/code&gt;,或&lt;code&gt;initial&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;双值语法&lt;/strong&gt;: 第一个值必须为一个无单位数，并且它会被当作&lt;code&gt;&amp;lt;flex-grow&amp;gt;的值。第二个值必须为以下之一：&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个无单位数：它会被当作&lt;code&gt;&amp;lt;flex-shrink&amp;gt;的值。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个有效的宽度值: 它会被当作&lt;code&gt;&amp;lt;flex-basis&amp;gt;的值。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;三值语法:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个值必须为一个无单位数，并且它会被当作&lt;code&gt;&amp;lt;flex-grow&amp;gt;的值。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第二个值必须为一个无单位数，并且它会被当作 &lt;code&gt;&amp;lt;flex-shrink&amp;gt;的值。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第三个值必须为一个有效的宽度值， 并且它会被当作&lt;code&gt;&amp;lt;flex-basis&amp;gt;的值。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;align-self&quot;&gt;align-self&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;align-self: auto | normal | stretch | &amp;lt;baseline-position&amp;gt; | &amp;lt;overflow-position&amp;gt;? &amp;lt;self-position&amp;gt;
where 
&amp;lt;baseline-position&amp;gt; = [ first | last ]? baseline
&amp;lt;overflow-position&amp;gt; = unsafe | safe
&amp;lt;self-position&amp;gt; = center | start | end | self-start | self-end | flex-start | flex-end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于给单个 item 设置交叉轴方向上的排版布局方式，属性值和作用跟 align-items 一样，区别仅在于 align-items 是 flex 容器的属性，它会作用于所有的 items 上；而 align-self 允许对单个 item 设置，该值会覆盖 align-items 设置的属性值。&lt;/p&gt;
&lt;p&gt;这样就可以实现控制交叉轴上的每个 item 的不同布局方式，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-5ee64d58ee132497.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;align-items&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;order&quot;&gt;order&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;order: &amp;lt;integer&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于控制 items 的排版顺序，item 将按照 order 属性值的增序进行布局。拥有相同 order 属性值的元素按照它们在源代码中出现的顺序进行布局。默认值为 0，可设置负值，排序将在默认不设置的 item 前面。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-326dd86eb0d1ee85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;order&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;我觉得，这些属性大体记得每个属性的主要用途即可，至于每个属性值如何设置，如何相互结合使用可以达到什么样的效果，写代码的时候再调就是了。&lt;/p&gt;
&lt;h3 id=&quot;应用场景&quot;&gt;3.应用场景&lt;/h3&gt;
&lt;p&gt;以下场景中，如没有特别指明，flex 容器基本样式和 item 基本样式如下：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.flex
{
    width: 200px;
    height: 200px;
    border-radius: 20px;
    background-color: #FFFFFF;
}

.dot {
    width: 50px;
    font-size: 28px;
    line-height: 50px;
    text-align: center;
    color: #FFFFFF;
    height: 50px;
    border-radius: 25px;
    background-color: black;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;长这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-9f2db5850a9a9d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;基本样式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;白色区域是 flex 容器，黑色圆圈是 item。&lt;/p&gt;
&lt;h4 id=&quot;场景1&quot;&gt;场景1:&lt;/h4&gt;
&lt;p&gt;在页面中把一个元素居中：item 水平、垂直方向都居中&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.flex
{
    display: flex;/* 声明这个元素作为 flex 容器 */
    flex-direction: row;/*主轴为水平方向*/
    justify-content: center;/*水平居中*/
    align-items: center;/*垂直居中*/
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-a51d6aced1b8644f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;场景1&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;场景2&quot;&gt;场景2：&lt;/h4&gt;
&lt;p&gt;前后有固定大小 item，中间区域自动拉伸占据可用空间。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;style &amp;gt;
.flex
{
    display: flex;/* 声明这个元素作为 flex 容器 */
    flex-direction: row;/*主轴为水平方向*/
}
&amp;lt;/style&amp;gt;

&amp;lt;div class=&quot;flex&quot;&amp;gt;
    &amp;lt;div class=&quot;dot&quot; &amp;gt;1&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;dot&quot; style=&quot;flex-grow: 1&quot;&amp;gt;2&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;dot&quot; &amp;gt;3&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-bbf735fb6e50cfbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;场景2&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;场景3&quot;&gt;场景3：&lt;/h4&gt;
&lt;p&gt;响应式布局，在屏幕尺寸允许的情况下呈水平布局，但是在屏幕不允许的情况下可以水平折叠。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.flex
{
    display: flex;/* 声明这个元素作为 flex 容器 */
    flex-direction: row;/*主轴为水平方向*/
    flex-wrap: wrap;/*溢出时换行*/
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-2624d00b8b06428e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;场景3&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;场景4&quot;&gt;场景4：&lt;/h4&gt;
&lt;p&gt;水平排列的一组 item 中，前几个左对齐，后几个右对齐。&lt;/p&gt;
&lt;p&gt;这个需要结合块级元素的 margin 属性使用，当设置 margin: auto 时表示，将尽可能占据足够多的空间。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;style &amp;gt;
.flex
{
    display: flex;/* 声明这个元素作为 flex 容器 */
    flex-direction: row;/*主轴为水平方向*/
}
&amp;lt;/style&amp;gt;

&amp;lt;div class=&quot;flex&quot;&amp;gt;
    &amp;lt;div class=&quot;dot&quot; &amp;gt;1&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;dot&quot; &amp;gt;2&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;dot&quot; margin-left=&quot;auto&quot;&amp;gt;3&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-43f4d7ec238e1ad8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;场景4&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;大家好，我是 dasu，欢迎关注我的公众号（dasuAndroidTv），如果你觉得本篇内容有帮助到你，可以转载但记得要关注，要标明原文哦，谢谢支持~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dasuAndroidTv2.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 31 Oct 2018 13:28:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<og:description>声明 本系列文章内容全部梳理自以下四个来源： 《HTML5权威指南》 《JavaScript权威指南》</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/9886038.html</dc:identifier>
</item>
<item>
<title>Vue.js-03：第三章 - 事件修饰符的使用 - 墨墨墨墨小宇</title>
<link>http://www.cnblogs.com/danvic712/p/9846097.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danvic712/p/9846097.html</guid>
<description>&lt;h3&gt;&lt;strong&gt; 一、前言&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　熟悉了 Vue 的指令系统后，在实际开发中，不可避免的会使用到对于事件的操作，如何处理 DOM 事件流，成为我们必须要掌握的技能。不同于传统的前端开发，在 Vue 中给我们提供了事件修饰符这一利器，使我们可以便捷的处理 DOM 事件，本章，一起来学习如何使用事件修饰符来实现对于 DOM 事件流的操作。&lt;/p&gt;
&lt;p&gt;　　学习系列目录地址：&lt;a href=&quot;https://www.cnblogs.com/danvic712/p/9549100.html&quot; target=&quot;_black&quot;&gt;https://www.cnblogs.com/danvic712/p/9549100.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　仓储地址：&lt;a href=&quot;https://github.com/Lanesra712/VueTrial/tree/master/Chapter01-Rookie/directives&quot; target=&quot;_blcak&quot;&gt;https://github.com/Lanesra712/VueTrial/tree/master/Chapter01-Rookie/directives&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 二、干货合集&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;　　&lt;strong&gt;1、 DOM 事件流&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　有时，当我们需要完成页面中的某些功能时，我们要在需要实现功能的页面元素上使用 v-on 指令去监听 DOM 事件，在 html4 时代浏览器如何确定页面的哪一部分会拥有特定的事件时，IE 和 Netscape 的开发团队提出了两个截然相反的概念。这一差异，也使我们在写代码中需要考虑如何去处理 DOM 的事件细节。为了解决这一问题，vue 给我们提供了事件修饰符这一利器，它使我们的方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。&lt;/p&gt;
&lt;p&gt;　　一些涉及到概念：&lt;/p&gt;
&lt;p&gt;　　a）事件：用户设定或者是浏览器自身执行的某种动作。例如click(点击)、load(加载)、mouseover(鼠标悬停)、change(改变)等等&lt;/p&gt;
&lt;p&gt;　　b）事件处理程序：为了实现某个事件的功能而构建的函数方法，也可称为事件监听器&lt;/p&gt;
&lt;p&gt;　　c）DOM 事件流：描述的是从页面中接收事件的顺序,也可理解为事件在页面中传播的顺序&lt;/p&gt;
&lt;p&gt;　　在 DOM 事件流中存在着三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。&lt;/p&gt;
&lt;p&gt;　　a）事件捕获（event capture）:当鼠标点击或者触发 DOM 事件时，浏览器会从根节点开始&lt;strong&gt;由外到内&lt;/strong&gt;进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件&lt;/p&gt;
&lt;p&gt;　　b）事件冒泡（event bubbing）:当鼠标点击或者触发 DOM 事件时，浏览器会从根节点开始&lt;strong&gt;由内到外&lt;/strong&gt;进行事件传播，即点击了子元素，则先触发子元素绑定的事件，逐步扩散到父元素绑定的事件&lt;/p&gt;
&lt;p&gt;　　之前我们提到的 IE 和 Netscape 的开发团队提出了两个截然相反的事件流概念，IE 采取的是事件冒泡流，而标准的浏览器的事件流则是事件捕获流。所以，为了兼容 IE 我们需要改变某些的写法。&lt;/p&gt;
&lt;h4&gt;　　&lt;strong&gt;2、 事件修饰符&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　a）.stop：阻止事件冒泡&lt;br/&gt;　　在下面的示例中，我们分别创建了一个 button 的点击事件和外侧的 div 的点击事件，根据事件的冒泡机制我们可以得知，当我们点击了按钮之后，会扩散到父元素，从而触发父元素的点击事件，具体的结果也如下图所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;divDefault&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;divHandlerClick&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;点击&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;btnHandlerClick&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        data: {},
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        methods: {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            divHandlerClick() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是div的点击事件！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            },
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            btnHandlerClick() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是button的点击事件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这时候，如果我们不希望出现事件冒泡，则可以使用 Vue 内置的修饰符便捷的阻止事件冒泡的产生。因为我们是点击 button 后产生的事件冒泡，我们只需要在 button 的点击事件上加上 stop 修饰符即可，示例代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;点击&quot;&lt;/span&gt;&lt;span&gt; @click.stop&lt;/span&gt;&lt;span&gt;=&quot;btnHandlerClick&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201810/1310859-20181031205629743-566164568.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　b）.prevent：阻止默认事件&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　阻止默认事件这个也很好理解，有些标签本身会存在事件，例如，a 标签的跳转，form 表单中 submit 按钮的提交事件等等，在某些时候我们只想执行我们自己设置的事件，这时，就需要阻止标签的默认事件的执行，原生的 js 我们可以使用 preventDefault 方法来实现，而在 Vue 中，我们只需要使用 prevent 关键字就可以了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　在下面的示例中，我们为 a 标签添加了一个点击事件，由于 a 标签本身具有默认的跳转事件，此时，当我们点击后，最终还是会执行 a 标签的默认事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;aHandlerClick&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;链接跳转&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        data: {},
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        methods: {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            aHandlerClick() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是a标签的点击事件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201810/1310859-20181031205911818-1528152223.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在 Vue 中，当我们想要阻止元素的默认事件，只需要在绑定的事件后使用 prevent 修饰符即可，示例代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span&gt; @click.prevent&lt;/span&gt;&lt;span&gt;=&quot;aHandlerClick&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;链接跳转&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201810/1310859-20181031210003419-765210357.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　c）.capture：添加事件监听器时使用事件捕获模式&lt;br/&gt;　　在上面的学习中我们了解到，事件捕获模式与事件冒泡模式是一对相反的事件处理流程，当我们想要将页面元素的事件流改为事件捕获模式时，只需要在父级元素的事件上使用 capture 修饰符即可，还是上面的例子的代码，当我们在 div 绑定的点击事件上使用 capture 修饰符后，我们点击按钮首先触发的就是最外侧的 div 的事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;divDefault&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt; @click.capure&lt;/span&gt;&lt;span&gt;=&quot;divHandlerClick&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;点击&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;btnHandlerClick&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201810/1310859-20181031210137465-1953154662.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　d）.self：只当在 event.target 是当前元素自身时触发处理函数（比如不是子元素冒泡引起的事件触发）&lt;br/&gt;　　在上面的例子中，我们为 div 绑定了一个点击事件，而我们的本意可能是只有当我们点击 div 后触发这个事件，而实际情况是事件冒泡还是事件捕获都会触发这个事件，这与我们的本意是不符的。在 Vue 中，我们就可以使用 self 修饰符去修饰事件，让这个事件只在我们想要触发时触发。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;divDefault&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt; @click.self&lt;/span&gt;&lt;span&gt;=&quot;divHandlerClick&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;点击&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;btnHandlerClick&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201810/1310859-20181031210229720-594257869.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　e）.once：事件只触发一次&lt;br/&gt;　　当我们仅仅想对绑定的事件只在第一次的时候触发，这时我们就可以使用 once 修饰符去修饰绑定的事件。例如在下面的代码中，只有第一次点击时才会触发绑定的事件，之后点击都不会触发。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;点击&quot;&lt;/span&gt;&lt;span&gt; @click.once&lt;/span&gt;&lt;span&gt;=&quot;btnHandlerClick&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　f）.passive：滚动事件的默认行为 (即滚动行为) 将会立即触发&lt;br/&gt;　　在页面滚动的时候，浏览器会在整个事件处理完毕之后再触发滚动，因为浏览器并不知道这个事件是否在其处理函数中被调用了 event.preventDefault()，而 passive 修饰符用来进一步告诉浏览器这个事件的默认行为不会被取消，即 使用 passive 修饰符后表示绑定的事件永远不会调用 event.preventDefault()。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 三、总结&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;　　1、事件修饰符的使用顺序很重要&lt;/h4&gt;
&lt;p&gt;　　使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。&lt;/p&gt;
&lt;h4&gt;　　2、.passive 和 .prevent不能一起使用&lt;/h4&gt;
&lt;p&gt;　　不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 四、参考&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;a title=&quot;JavaScript事件流&quot; href=&quot;http://www.cnblogs.com/xianyulaodi/p/5544312.html&quot; target=&quot;_blank&quot;&gt;1、JavaScript事件流&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;JavaScript:深入理解事件流&quot; href=&quot;https://segmentfault.com/a/1190000003497939&quot; target=&quot;_blank&quot;&gt;2、JavaScript:深入理解事件流&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;理解DOM事件流的三个阶段&quot; href=&quot;https://segmentfault.com/a/1190000004463384&quot; target=&quot;_blank&quot;&gt;3、理解DOM事件流的三个阶段&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;JavaScript 详说事件机制之冒泡、捕获、传播、委托&quot; href=&quot;https://segmentfault.com/a/1190000004463384&quot; target=&quot;_blank&quot;&gt;4、JavaScript 详说事件机制之冒泡、捕获、传播、委托&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;vue从入门到进阶：指令与事件（二）&quot; href=&quot;https://segmentfault.com/a/1190000012819221#articleHeader29&quot; target=&quot;_blank&quot;&gt;5、vue从入门到进阶：指令与事件（二）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 31 Oct 2018 13:14:00 +0000</pubDate>
<dc:creator>墨墨墨墨小宇</dc:creator>
<og:description>一、前言 熟悉了 Vue 的指令系统后，在实际开发中，不可避免的会使用到对于事件的操作，如何处理 DOM 事件流，成为我们必须要掌握的技能。不同于传统的前端开发，在 Vue 中给我们提供了事件修饰符这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/danvic712/p/9846097.html</dc:identifier>
</item>
<item>
<title>人生的意义 - mindwind</title>
<link>http://www.cnblogs.com/mindwind/p/9885688.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mindwind/p/9885688.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/815275/201810/815275-20181031202404764-212460375.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近在 YouTube 看了个演讲分享，关于人生的意义，深有感触，所以简单翻译并分享记录在这里。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;让我们一劳永逸地找出生命的意义，在20分钟之内，好吗？&lt;/p&gt;
&lt;h2 id=&quot;life-is______&quot;&gt;LIFE IS______&lt;/h2&gt;
&lt;p&gt;你觉得这个空格里该是什么词？人生是什么？有什么想法吗？让我们先来看看哲学家和聪明人说过的一些不同选择。&lt;/p&gt;
&lt;h2 id=&quot;life-is-time人生是时间&quot;&gt;LIFE IS TIME（人生是时间）&lt;/h2&gt;
&lt;p&gt;有人说生命就是时间，生活就是时间，人生的定义是你从出生到死亡之间的时间。因此，人生的字面意义就是时间。如果人生就是时间，那么拥有美好生活的方法就是明智地利用时间。&lt;/p&gt;
&lt;p&gt;你如何能明智地利用时间呢？有下面五种方法：&lt;/p&gt;
&lt;h3 id=&quot;记住生命有限&quot;&gt;1. 记住，生命有限&lt;/h3&gt;
&lt;p&gt;如果今晚你发现只剩下一年的生命，你将会充分利用接下来这一年。如果人生是无限的，你就不会如此。&lt;/p&gt;
&lt;p&gt;要实现伟大的事情，需要两件事：一个计划，加上不充足的时间。给自己一个紧迫的截止日期，记住你随时都可能死，不要拖延。&lt;/p&gt;
&lt;p&gt;你该如何明智地利用时间呢？&lt;/p&gt;
&lt;h3 id=&quot;大部分时候活在未来&quot;&gt;2. 大部分时候，活在未来&lt;/h3&gt;
&lt;p&gt;让你当前的大部分行动为你的未来服务。学习，练习，锻炼，延迟满足，节省和投资，建设你的理想未来。这样做的人会更成功，甚至更快乐。&lt;/p&gt;
&lt;p&gt;但是，太过于关注未来，会让你成为一个进入第四次婚姻的成功人士，却没有真正的朋友。太过于关注未来，会让你忽略了当下的重要事情。&lt;/p&gt;
&lt;p&gt;你该如何明智地利用时间呢？&lt;/p&gt;
&lt;h3 id=&quot;有时活在当下&quot;&gt;3. 有时，活在当下&lt;/h3&gt;
&lt;p&gt;把你的头从未来中拉出来，把你的全部注意力放在当下，人际关系、沟通和两性情感都需要你这样做。&lt;/p&gt;
&lt;p&gt;但过于专注当下就成了享乐主义：仅仅为了当下的满足感，而尽可能兴奋和新奇地生活。&lt;/p&gt;
&lt;p&gt;过于专注当下，会导致你银行账户空空如也，无法控制（买买买）的冲动。过于专注当下会剥夺你更深层次的快乐，比如延迟的满足感、实现长期目标，以及开发有价值的专业知识和技能。&lt;/p&gt;
&lt;p&gt;你该如何明智地利用时间呢？&lt;/p&gt;
&lt;h3 id=&quot;有时活在过去&quot;&gt;4. 有时，活在过去&lt;/h3&gt;
&lt;p&gt;记住你的过往就相当于活过了两次。&lt;/p&gt;
&lt;p&gt;把你的生活放在过去的背景中，看看你已经走了多远。留出时间重新解释你经历过的事情，作为一个强有力的提醒，你也可以重新解读你的现在和未来。&lt;/p&gt;
&lt;p&gt;你该如何明智地利用时间呢？&lt;/p&gt;
&lt;h3 id=&quot;进入生活的状态&quot;&gt;5. 进入生活的状态&lt;/h3&gt;
&lt;p&gt;你知道心流的感觉 —— 在心流中，你专注于不太容易、也不太难的工作——工作本身就有明确的目标，也是工作自带的奖励。&lt;/p&gt;
&lt;p&gt;在生命的最后阶段，那些声称一生最幸福的人也是花了最多时间在心流状态中的人。为了更好地过好这一生，去追求那些让你处于这种状态的工作，避免那些把你从这种状态中拉出来的事情。&lt;/p&gt;
&lt;p&gt;那么，此时我们再说人生就是时间，你认为如何？似乎是个不错的观点？接下来我们再看看另外的视角。&lt;/p&gt;
&lt;h2 id=&quot;life-is-choice人生是选择&quot;&gt;LIFE IS CHOICE（人生是选择）&lt;/h2&gt;
&lt;p&gt;有人说生活就是选择，生活几乎都是关乎选择。你每天做一百个小小的选择，而一生会做一百个重大的选择，这些选择改变了你的一生。你的生活是由你的选择创造的，因此，人生即选择。&lt;/p&gt;
&lt;p&gt;所以，如果人生就是选择，那么拥有美好人生的方法就是做出正确的选择，你怎么能做出好的选择呢？有四种方法：&lt;/p&gt;
&lt;h3 id=&quot;依赖本能而非逻辑&quot;&gt;1. 依赖本能而非逻辑&lt;/h3&gt;
&lt;p&gt;你大脑的不同部分在进化的不同阶段开始发展。你大脑中最古老的部分，从我们还是鱼的时候就一直在进化，处理本能、恐惧和直觉。你大脑的最新部分，专属于人类的部分，处理逻辑、语言和预测。&lt;/p&gt;
&lt;p&gt;这个最新的部分还处在 Beta 测试中，一个 5 美元的计算器就能在数学上胜过它。但大脑最古老的部分是在 10 亿年前就启动了，从那以后一直处于运作和发展中。&lt;/p&gt;
&lt;p&gt;你观察和学习的每一件事都首先由你的逻辑大脑处理，但结果却被永久地储存为本能、恐惧和直觉。你的直觉和情感是你通过观察和学习一切达到的顶点。所以，如果你倾听自己的直觉，而不是过于依赖你 5 美元的计算器 Beta 测试版大脑，你会做出更好的选择。&lt;/p&gt;
&lt;p&gt;你该如何做出好的选择呢？&lt;/p&gt;
&lt;h3 id=&quot;在足够好的时候停止&quot;&gt;2. 在足够好的时候停止&lt;/h3&gt;
&lt;p&gt;现在相比以往任何时候，你都有更多的选项。你试着选择最好的选项，最好的职业，最好的学校，最好的男朋友/女朋友/伴侣/配偶。&lt;/p&gt;
&lt;p&gt;但是这样做会让你对自己所做的选择感到更糟，你比以往任何时候都更清楚地意识到那些你未选择的所有选项，以及每一个选项的好处。&lt;/p&gt;
&lt;p&gt;所以，不要追求绝对最好的选择。当你找到一个足够好的选项时，就停下来，你会做出同样好的选择，但更重要的是，你会感觉更好，更幸福。&lt;/p&gt;
&lt;p&gt;你该如何做出好的选择呢？&lt;/p&gt;
&lt;h3 id=&quot;设定限制&quot;&gt;3. 设定限制&lt;/h3&gt;
&lt;p&gt;每一个你不得不做出的选择都会造成一点痛苦，生活中有选择是好的，但有更多的选择并不总是更好。&lt;/p&gt;
&lt;p&gt;有时，当你让别人为你做一些选择时，你会更快乐。如果你病得很重，你希望你的医生选择最好的，而不是说：“这有几十个好的选择，你想要什么？” 这就是为什么宗教有吸引力，它给了你规则，它为你做了很多选择。&lt;/p&gt;
&lt;p&gt;所以，在生活中限制你的选择，砍掉一些选项，给自己制定规则。&lt;/p&gt;
&lt;p&gt;你该如何做出好的选择呢？&lt;/p&gt;
&lt;h3 id=&quot;选择重要而非紧急&quot;&gt;4. 选择重要，而非紧急&lt;/h3&gt;
&lt;p&gt;你知道什么是长期的重要与短期的紧急。&lt;/p&gt;
&lt;p&gt;紧急的是电子邮件、短信、推特、电话和新闻；重要的是花一千小时学习一项新的技能，这将对你的生活或工作有真正的帮助；重要的是把你的注意力完全集中在你生活中重要的人身上；重要的是花些时间去锻炼，或收集和分享你学到的东西。&lt;/p&gt;
&lt;p&gt;但这些事情都不会是紧急的，因而你必须忽略那些急迫诱人的哭喊声，刻意选择你知道的重要的东西。&lt;/p&gt;
&lt;p&gt;所以，人生是选择？你认为呢？似乎是不错的论断？我们再看看其他的。&lt;/p&gt;
&lt;h2 id=&quot;life-is-memory人生是记忆&quot;&gt;LIFE IS MEMORY（人生是记忆）&lt;/h2&gt;
&lt;p&gt;有人说人生就是记忆，未来并不存在，都是我们想象的。当下，一毫秒过去了，所以我们经历的一切都是一种记忆。你可以活得很长，但若没有太多的记忆，那你就只能算是经历了短暂的生命。如果你都不记得你的生活，它就像从来没有发生过一样。所以人生就是记忆。&lt;/p&gt;
&lt;p&gt;如果人生是记忆，那么拥有美好生活的方法就是创造更多的记忆。&lt;/p&gt;
&lt;p&gt;你怎么能创造记忆呢？&lt;/p&gt;
&lt;p&gt;改变常规，突破单调。搬家，只要有可能就做一些重大的改变，这些变化是你的编年史标记，这些变化将成为挂在你记忆力的钩子。&lt;/p&gt;
&lt;p&gt;记录它们，写成博客吧。不是记录在一家公司的 “围墙花园” 之中，而是一种格式，你可以存档并且 50 年后再查看，或者你的孙在可以在 100 年后再查看。为未来的你维护一个私人博客，讲述你去过的地方，你做了什么，以及你在路上遇到的奇奇怪怪的人们。如果你不把它记录下来，你将会惊讶于你忘记了多少。&lt;/p&gt;
&lt;p&gt;苏格拉底说：“未经检视的人生不值得活”。那被遗忘的人生呢？&lt;/p&gt;
&lt;p&gt;所以，人生是记忆？你认为呢？还想再试试其他的吗？&lt;/p&gt;
&lt;h2 id=&quot;life-is-learning人生是学习&quot;&gt;LIFE IS LEARNING（人生是学习）&lt;/h2&gt;
&lt;p&gt;我聪明的朋友和精神上的朋友都坚持生命的意义就是学习 —— 这就是你来到这个世界学习的原因。不仅仅是为了你自己，而且为了每个活着的人，为了子孙后代，你生命的意义就是学习。&lt;/p&gt;
&lt;p&gt;所以，如果人生就是学习，那么有美好生活的方法就是学到很多。&lt;/p&gt;
&lt;p&gt;你怎么能学到很多呢？&lt;/p&gt;
&lt;p&gt;与其谈论学习技巧，不如让我们谈谈正确的思维模式，这样你就能学到比你能意识到的更多东西。&lt;/p&gt;
&lt;p&gt;你可能听说过固定思维（Fixed mindset）和成长思维（Growth mindset）。&lt;/p&gt;
&lt;p&gt;固定思维说：“我很擅长这个” 或者 “我不擅长这个”。从童年开始，当你的父母说：“你很擅长数学！”你会想，“我很擅长数学！”但是，当你在一次测试中表现不佳时，你会想：“他们搞错了，我其实不太擅长数学”。大多数人都是这么想的，你能够经常听到类似的说法：“她是一位出色的歌手” 或者 “我只是不擅长跳舞”。&lt;/p&gt;
&lt;p&gt;成长思维说：“任何人都可以擅长任何事情，技能仅来自于实践。”&lt;/p&gt;
&lt;p&gt;曾经对数百名儿童进行了两次近乎不可能的艰难测试。第一次测试后，所有学生都受到了表扬，但有一半的学生私下里被告知：“你一定很擅长这个。” 另一半学生被告知：“你一定很努力”。&lt;/p&gt;
&lt;p&gt;当他们被给予第二次测试时，那些被告知 “你一定很擅长这个” 的学生在第二次测试中表现要差 20%。这些字眼鼓励一种固定的思维模式，让他们觉得没必要去努力尝试。你要么擅长，要么就不擅长。&lt;/p&gt;
&lt;p&gt;那些被告知 “你一定很努力” 的学生，在第二次考试中表现要好 30%。这些字眼鼓励一种成长思维模式，让他们觉得更努力会有所不同。&lt;/p&gt;
&lt;p&gt;因此，仅仅因为老师用了几个不同的字眼，学生的表现就产生了 +-50% 的差异。&lt;/p&gt;
&lt;p&gt;考虑你生活中的所有人，所有那些你收到反馈的日子，你告诉自己的所有事情，所有这一切累计起来的乘数效应，你就能看到这种简单的思维模式差异是如何决定或破坏我们这一生的学习的。&lt;/p&gt;
&lt;p&gt;家长们，请注意这一点。当你告诉孩子们擅长某些事情时，你可能会伤害他们。&lt;/p&gt;
&lt;p&gt;成功的人，要注意这一点。如果你相信别人对你的赞美，你可能会伤害你自己。人们告诉你很擅长你所做的事情，而不是说你必须很努力的工作。&lt;/p&gt;
&lt;p&gt;所以...人生是学习？你认为呢？&lt;/p&gt;
&lt;h2 id=&quot;life-is-suffering人生是痛苦&quot;&gt;LIFE IS SUFFERING（人生是痛苦）&lt;/h2&gt;
&lt;p&gt;我们应该看看佛教的观念，人生就是痛苦吗？不，这可没什么意思。&lt;/p&gt;
&lt;h2 id=&quot;life-is-love人生是爱&quot;&gt;LIFE IS LOVE（人生是爱）&lt;/h2&gt;
&lt;p&gt;这太模糊了。&lt;/p&gt;
&lt;h2 id=&quot;life-is-dna人生是基因&quot;&gt;LIFE IS DNA（人生是基因）&lt;/h2&gt;
&lt;p&gt;生命不过是在复制 DNA？这又太过精确了。&lt;/p&gt;
&lt;p&gt;那么人生到底是什么？让我们先换个话题。&lt;/p&gt;
&lt;h2 id=&quot;中文&quot;&gt;中文&lt;/h2&gt;
&lt;p&gt;几年前，我开始学中文，我对写作很着迷，我开始试着记住这些汉字。&lt;/p&gt;
&lt;p&gt;汉字看上去很复杂，但它们大多是由较小的、更简单的字组成的，而英语单词是由拉丁语的词根等组成的。所以你可以通过知道每个字符成分的含义来记住它的意义。例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/815275/201810/815275-20181031202432244-2065709306.png&quot;/&gt;&lt;br/&gt;语 language = words 讠+ five 五+ mouth 口&lt;/p&gt;
&lt;p&gt;所以，“语言” 就是至少五个人都会说的词吗？太棒了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/815275/201810/815275-20181031202457345-567511529.png&quot;/&gt;&lt;br/&gt;谢 thank you = words 讠+ body 身+ inch 寸&lt;/p&gt;
&lt;p&gt;嗯...这个不太明显。也许它想表达的是，当你说谢谢时，身体需要让出一英寸的尊重空间？这很有趣。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/815275/201810/815275-20181031202522833-564289543.png&quot;/&gt;&lt;br/&gt;名 name = evening 夕 + mouth 口&lt;/p&gt;
&lt;p&gt;所以，这是在夕阳下的傍晚有人呼喊你的名字？这是一种浪漫。&lt;/p&gt;
&lt;p&gt;我对每个字背后的历史或文化意义都很好奇。我对这些汉字的历史意义很好奇，直到我得到了一本汉语词源词典，它讲述了每一个汉字背后的全部历史。&lt;/p&gt;
&lt;p&gt;我查阅了这里给出的例子，发现这些字都是基于语音学的！那些组合字符根本不是因为它们的意义而被选择的，而是因为它们的发音。&lt;/p&gt;
&lt;p&gt;所以，看来我只是在把自己想象的意义加进去，它们根本没有任何意义！&lt;/p&gt;
&lt;p&gt;这让我大受震动。几个月来，我已经背了几百个字，把每一个字的组成部分的各种意义都强加了进去。&lt;/p&gt;
&lt;p&gt;从这里面恢复过来后，我想：生活中还有多少东西其实真的没有意义？还有一些其他什么东西是把我自己理解的意义放进去的？想想，这是真的吗？&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;没有什么东西是存在固有内在的意义的。所有的一切就是它们本来那样，就是这样。&lt;/p&gt;
&lt;p&gt;所以，让我们回到最初的问题，总结一下：人生的意义有什么？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间 Time?&lt;/li&gt;
&lt;li&gt;选择 Choice？&lt;/li&gt;
&lt;li&gt;记忆 Memory？&lt;/li&gt;
&lt;li&gt;学习 Learning？&lt;/li&gt;
&lt;li&gt;痛苦 Suffering？&lt;/li&gt;
&lt;li&gt;基因 DNA？&lt;/li&gt;
&lt;li&gt;爱 Love？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你可以从各种各样的答案中看出，它们只是投射出来的意义。&lt;/p&gt;
&lt;p&gt;你可以选择将这些意义中的一种投射到你的生活中，如果它让你感觉良好，或者能改善你当前的行为。&lt;/p&gt;
&lt;p&gt;但你知道，真正的答案现在是清晰而明显的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/815275/201810/815275-20181031202550455-2130266001.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;人生就（只是）人生，这并不意味着有什么。&lt;/p&gt;
&lt;p&gt;抹去你对过去事件赋予的任何意义；抹去任何阻碍你的意义；抹去那些人们说这有某种意味的时候；所有这些都不是真实的。&lt;/p&gt;
&lt;p&gt;人生没有内在的意义，没有什么有内在固有的意义。&lt;/p&gt;
&lt;p&gt;人生就是一片白板。&lt;/p&gt;
&lt;p&gt;你可以自由地投射任何为你服务的意义，伴随这份意义去自由地做任何你想做的事。&lt;/p&gt;
&lt;p&gt;谢谢。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;作者：Derek Sivers&lt;br/&gt;日期：2014-05-05&lt;br/&gt;原文：&lt;a href=&quot;https://sivers.org/ml&quot;&gt;The Meaning of Life&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;写点文字，画点画儿，记录成长瞬间。&lt;br/&gt;微信公众号「瞬息之间」，既然遇见，不如同行。&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/815275/201602/815275-20160216164606173-1251141402.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 31 Oct 2018 12:29:00 +0000</pubDate>
<dc:creator>mindwind</dc:creator>
<og:description>最近在 YouTube 看了个演讲分享，关于人生的意义，深有感触，所以简单翻译并分享记录在这里。 让我们一劳永逸地找出生命的意义，在20分钟之内，好吗？ LIFE IS______ 你觉得这个空格里该</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mindwind/p/9885688.html</dc:identifier>
</item>
</channel>
</rss>