<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>PyMySQL(一) ：什么是PyMySQL 、如何安装PyMSQL - 深圳-逸遥</title>
<link>http://www.cnblogs.com/snailrunning/p/9572353.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snailrunning/p/9572353.html</guid>
<description>&lt;h2 id=&quot;什么是pymysql&quot;&gt;1、什么是PyMySQL&lt;/h2&gt;
&lt;p&gt;为了使python连接上数据库，你需要一个驱动，这个驱动是用于与数据库交互的库。&lt;/p&gt;
&lt;p&gt;PyMySQL ： 这是一个使Python连接到MySQL的库，它是一个纯Python库。&lt;/p&gt;
&lt;p&gt;PyMySQL是一个开源项目 ：&lt;a href=&quot;https://github.com/PyMySQL/PyMySQL&quot; class=&quot;uri&quot;&gt;https://github.com/PyMySQL/PyMySQL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;环境要求：&lt;br/&gt;PyMySQL支持的python版本：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;python2&lt;/li&gt;
&lt;li&gt;python2.7&lt;/li&gt;
&lt;li&gt;python3&lt;/li&gt;
&lt;li&gt;python version &amp;gt;=3.4&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何安装pymysql&quot;&gt;2、如何安装PyMySQL&lt;/h2&gt;
&lt;h3 id=&quot;打开cmd窗口命令提示符运行以下其中一行语句&quot;&gt;2.1 打开CMD窗口（命令提示符），运行以下其中一行语句：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Python2.7 和 Python3 均可以使用&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;pip install PyMySQL&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;pip2.7 install PyMySQL&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;pip3 install PyMySQL&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;pip version == 18.0&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;python -m pip install PyMySQL&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;小编的Python版本是3.6.4&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1085954/201809/1085954-20180902012002604-1230638781.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;小贴士：如果想知道自己的电脑可以用哪个pip命令进行安装，同学们可以查看Python安装目录下Scripts目录&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;小编的/python36/Scripts 目录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1085954/201809/1085954-20180902012009148-538285008.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PyMySQL安装中 ——&amp;gt; 安装成功&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1085954/201809/1085954-20180902012015551-2037588668.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查看PyMySQL版本信息，运行以下语句：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;pip3 show PyMySQL&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1085954/201809/1085954-20180902014147504-1973150860.png&quot;/&gt;&lt;/p&gt;

&lt;h4 id=&quot;个人微信号欢迎交流&quot;&gt;&lt;strong&gt;个人微信号，欢迎交流。&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1085954/201809/1085954-20180902021135061-1501737659.png&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 01 Sep 2018 18:13:00 +0000</pubDate>
<dc:creator>深圳-逸遥</dc:creator>
<og:description>1、什么是PyMySQL 为了使python连接上数据库，你需要一个驱动，这个驱动是用于与数据库交互的库。 PyMySQL ： 这是一个使Python连接到MySQL的库，它是一个纯Python库。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snailrunning/p/9572353.html</dc:identifier>
</item>
<item>
<title>tensorflow源码解析之common_runtime-executor-下 - jicanghai</title>
<link>http://www.cnblogs.com/jicanghai/p/9572217.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jicanghai/p/9572217.html</guid>
<description>&lt;ol&gt;&lt;li&gt;核心概念&lt;/li&gt;
&lt;li&gt;executor.h
&lt;ol&gt;&lt;li&gt;Executor&lt;/li&gt;
&lt;li&gt;NewLocalExecutor&lt;/li&gt;
&lt;li&gt;ExecutorBarrier&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;executor.cc
&lt;ol&gt;&lt;li&gt;structs&lt;/li&gt;
&lt;li&gt;GraphView&lt;/li&gt;
&lt;li&gt;ExecutorImpl&lt;/li&gt;
&lt;li&gt;ExecutorState&lt;/li&gt;
&lt;li&gt;details&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;executorstate&quot;&gt;3.4 ExecutorState&lt;/h2&gt;
&lt;p&gt;在执行器的执行图计算的时候，需要一个结构来保存当前计算的即时信息，TF为此设计了类ExecutorState，它被用来保存每一个对ExecutorImpl::Run调用的状态信息。它会在一个节点已经准备好之后调度这个节点，并且保存每个节点尚未完成的输入信息。&lt;br/&gt;下面让我们先来看一下这个类的结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class ExecutorState {
  public:
    ExecutorState(const Executor::Args&amp;amp; args, ExecutorImpl* impl);
    void RunAsync(Executor::DoneCallback done);
  private:
    DeviceContextMap device_context_map_;
    
    typedef gtl::InlinedVector&amp;lt;TaggedNode, 8&amp;gt; TaggedNodeSeq;
    typedef gtl::InlinedVector&amp;lt;Entry, 4&amp;gt; EntryVector;
    
    const bool vlog_;
    const bool log_memory_;
    int64 step_id_;
    
    //未拥有
    Rendezvous* rendezvous;
    SessionState* session_state_;
    TensorStore* tensor_store_;
    //每个执行步级别的容器
    ScopedStepContainer* step_container_;
    StepStatesCollector* stats_collector_;
    
    checkpoint::TensorSliceReaderCacheWrapper* slice_reader_cache_;
    FunctionCallFrame* call_frame;
    const ExecutorImpl* impl_;
    CancellationManager* cancellation_manager_;
    Executor::Args::Runner runner_;
    bool sync_on_finish_;
    
    //拥有
    bool dumped_on_error_ = false;
    //当前执行步骤开始的帧
    FrameState* root_frame_;
    //执行器结束时需要调用的回调函数
    Executor::DoneCallback done_cb_;
    std::atomic_int_fast32_t num_outstanding_ops_;
    mutex mu_;
    Status status_ GUARDED_BY(mu_);
    
    //从帧名称到实际帧的映射。在当前帧的某个迭代周期内，可能会产生一个新的帧。新的子帧的唯一键值必须由父帧的名称、迭代编号、以及由nodedef推断出来的新帧的名称组合而成
    gtl::FlatMap&amp;lt;string, FrameState*&amp;gt; outstanding_frames_ GUARDED_BY(mu_);
    
    //一个帧的名称
    inline string MakeFrameName(FrameState* frame, int64 iter_id, const string&amp;amp; name);
    
    //找到一个现存的帧，或者创建一个新帧，在帧frame的iter迭代周期
    void FindOrCreateChildFrame(FrameState* frame, int64 iter, const Node* node, FrameState** child);
    
    //删除一个帧，当帧调用结束时使用
    void DeleteFrame(FrameState* frame, TaggedNodeSeq* ready);
    
    //清除那些起源于帧frame和迭代iter的帧，当一个子帧结束时调用
    void CleanupFramesIterations(FrameState* frame, int64 iter, TaggedNodeSeq* ready);
    
    //在当前的线程中处理一个已准备好的节点
    void Process(TaggedNode node, int64 scheduled_usec);
    
    //在调用item-&amp;gt;kernel之前，先填入其输入
    Status PrepareInputs(const NodeItem&amp;amp; item, Entry* first_input, TensorValueVec* inputs, DeviceContextVec* input_device_contexts, AllocatorAttributeVec* input_alloc_attrs, bool* is_input_dead);
    
    //在item-&amp;gt;kernel计算结束之后，处理输出
    Status ProcessOutputs(const NodeItem&amp;amp; item, OpKernelContext* ctx, EntryVector* outputs, NodeExecStats* stats);
    
    //在处理完输出之后，将输入传递给下一个输入
    void PropagateOutputs(const TaggedNode&amp;amp; tagged_node, const NodeItem* item, EntryVector* outputs, TaggedNodeSeq* ready);
    
    //节点计算结束后，接管stats，如果执行完成则返回true
    bool NodeDone(const Status&amp;amp; s, const Node* node, const TaggedNodeSeq&amp;amp; ready, NodeExecStats* stats, TaggedNodeReadyQueue* inline_ready);
    
    //调度ready中的所有复杂节点，然后将ready中的非复杂节点放入inline_ready
    void ScheduleReady(const TaggedNodeSeq&amp;amp; ready, TaggedNodeReadyQueue* inline_ready);
    
    //仅用作调试或记录
    inline void MaybeMarkCompleted(FrameState* frame, int64 iter, int64 id);
    
    //输出一个未完成或者活跃节点的信息
    void DumpPendingNodeState(const int node_id, const Entry* input_vector, bool show_nodes_with_no_ready_inputs);
    void DumpActiveNodeState(const FrameState* frame, IterationState* iteration);
    
    //提供执行器的状态信息
    void DumpState();
    const Tensor* GetTensorValueForDump(const Entry&amp;amp; input);
    
    //当执行器结束执行时，清理
    void Finish();
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从API上来看，ExecutorState几乎担当了执行器的职责，从后面的介绍也可以看出，实际上确实如此。执行器内部实际调用的就是ExecutorState内部的API。从类的结构中，我们还是看到了许多未曾相识的结构，下面我们先一一分析这些类的意义和结构。&lt;/p&gt;
&lt;p&gt;首先来看Entry，Entry要么是一个张量指针，要么是一个张量值，为计算图中的节点的输入或输出提供了一种统一的类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct Entry {
    Entry(const Entry&amp;amp; other);
    Entry&amp;amp; operator=(const Entry&amp;amp; other);
    
    void ClearVal();//清除val字段
    ManualConstructor&amp;lt;Tensor&amp;gt; val;//一个张量的值，如果val_filed_is_set是true的话
    Tensor* ref = nullptr;//一个张量引用
    mutext* ref_mu = nullptr;//为上述张量引用的互斥量
    bool has_value = false;//值是否存在，不论是val或者ref
    bool val_filed_is_set = false;//val字段是否被设置
    
    AllocatorAttributes alloc_attr;//为当前的张量分配内存的内存分配器的属性
    
    DeviceContext* device_context = nullptr;//包含了关于这个张量如何创建的设备相关的信息
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来看看IterationState，它代表了一轮迭代的状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct IterationState {
  public:
    //一轮迭代的状态，每个迭代轮次都由一个单独的拷贝。对于第k轮迭代，第i个节点的第j个输入在input_tensors[k][impl_-&amp;gt;nodes[i].input_start+j]。注意，没有必要对input_tensors做互斥锁，其中的内容只会被边的前一个节点写入，被边的后一个节点擦除，而每条边的前后两个节点是不可能同时运行的
    Entry* input_tensors;
    
    //每一轮迭代中未完成的op数量
    size_t outstanding_ops;
    
    //每一轮迭代中未完成的帧数量
    int outstanding_frame_count;
    int pending(PendingCounts::Handle h);
    int decrement_pending(PendingCounts::Handle int v);
    
    //标记一个merge节点为live
    void mark_live(PendingCounts::Handle h);
    //标记一个节点为处理开始
    void mark_started(PendingCounts::Handle h);
    //标记一个节点为处理结束
    void mark_completed(PendingCounts::Handle h);
    //获取节点状态
    PendingCounts::NodeState node_state(PendingCounts::Handle h);
    int dead_count(PendingCounts::Handle h);
    void increment_dead_count(PendingCounts::Handle h);
    void adjust_for_activation(PendingCounts::Handle h, bool increment_dead, int* pending_result, int* dead_result);
  
  private:
    PendingCounts counts_;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来是FrameState，代表了一个帧的状态。对于帧和迭代轮次，有以下几点需要说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于计算图中的循环来说，每个循环都需要创建一个新的帧。执行从第0个迭代开始。当第0个迭代的某个数值通过了一个NextIteration节点时，第1轮迭代就被创建并开始运行了。注意这时第0轮迭代可能仍在进行，所以多轮迭代可能会同时在运行。帧保持了多种数据结构来保存每轮迭代的状态。当第0轮迭代结束后，我们对其对应的状态进行垃圾回收。&lt;/li&gt;
&lt;li&gt;一个帧，当它的所有输入都已经被传入，所有的迭代都被计算完成时，这个帧就被认为是完成了，可以被进行垃圾回收了。&lt;/li&gt;
&lt;li&gt;一个帧保存了其中每一轮迭代的状态。如果以下三个条件都被满足，那么第i轮迭代就会被认为是已经完成了，第一，第i轮迭代已经没有未完成的节点了，第二，所有该轮的接收操作都已经完成了，第三，第i-1轮已完成。对于第0轮迭代，当帧的所有输入都已完成，我们就认为它已经结束了。&lt;/li&gt;
&lt;li&gt;帧和迭代轮次在结束后，都会进行垃圾回收。我们需要保存的状态量，跟调度器允许的并行度高度相关。我们希望调度器能够动态的控制未完成的并行帧和迭代的数量。为了减少内存消耗，调度器可能需要优先调度内层的帧和较低的迭代轮次。&lt;/li&gt;
&lt;li&gt;帧的状态一般总是在需要的时候才会被初始化，因此我们没有引入额外的损耗。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们来具体看下FrameState的结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct FrameState {
    const ExecutorImpl* executor = nullptr;//帧所在的执行器
    string frame_name;//当前帧的名称，是父帧，迭代轮次，和frame_name字段拼合起来得到的
    uint64 frame_id;//当前帧的唯一标识
    int64 parent_iter = -1;//父帧的迭代轮次，frame_name和parent_iter共同标识了当前的FrameState
    FrameState* parent_frame = nullptr;//父帧的FrameState
    const int 
    
    max_parallel_iterations;//最大允许的并行迭代数量
    int num_pending_inputs = 0;//当前帧仍然在等待的输入数量
    int64 iteration_count GUARDED_BY(mu) = 0;//当前帧中到达过的最大的迭代数量
    int num_outstanding_iterations GUARDED_BY(mu) = 1;//未完成的迭代数量
    
    gtl::InlinedVecotr&amp;lt;IterationState*,12&amp;gt; iterations;//当前帧活跃的迭代状态
    std::vector&amp;lt;std::pair&amp;lt;const Node*, Entry&amp;gt;&amp;gt; next_iter_roots GUARDED_BY(mu);
    std::vector&amp;lt;std::pair&amp;lt;const Node*, Entry&amp;gt;&amp;gt; inv_values GUARDED_BY(mu);
    std::vector&amp;lt;const Node*&amp;gt; dead_exits GUARDED_BY(mu);
    
    //属于当前帧的静态信息
    PendingCounts* pending_counts = nullptr;
    int total_input_tensors = 0;
    std::vector&amp;lt;const Node*&amp;gt;* nodes = nullptr;
    
    void InitializeFrameInfo(const string&amp;amp; enter_name);
    inline IterationState* GetInteration(int64 iter);
    inline void SetIteration(int64 iter, IterationState* state);
    
    //减少未完成的操作数量，清理帧中的迭代信息。如果帧执行结束则返回true
    inline bool DecrementOutputstandingOps(const GraphView* gview, int64 iter, TaggedNodeSeq* ready);
    inline bool DecrementOutstandingOpsLocked(const GraphView* gview, int64 iter, TaggedNodeSeq* ready);
    
    //如果帧中的计算都已经完成则返回true
    inline bool IsFrameDone();
    //如果迭代的计算已经结束则返回true
    bool IsIterationDone(int64 iter);
    //增加迭代的编号，如果是一个新迭代，就初始化它
    void IncrementIteration(const GraphView* gview, TaggedNodeSeq* ready);
    //激活一个新的迭代轮次中所有的NextIteration节点
    void ActivateNexts(const GraphView* gview, int64 iter, TaggedNodeSeq* ready);
    void ActivateLoopInvs(const GraphView* gview, int64 iter, TaggedNodeSeq* ready);
    void AddLoopInv(const NodeItem* item, const Entry&amp;amp; value, TaggedNodeSeq* ready);
    void ActivateNodes(const NodeItem* item, const bool is_dead, int64 iter, EntryVector* outputs, TaggedNodeSeq* ready);
    bool CleanupIterations(const GraphView* gview, int64 iter, TaggedNodeSeq* ready);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后让我们来看下最后的两个结构体，TaggedNode和TaggedNodeReadyQueue。其中TaggedNode非常简单，就是一个&amp;lt;frame&lt;em&gt;, iter, node&lt;/em&gt;&amp;gt;的结构体，而后者就是前者的一个Queue，用来表示已经准备好的节点的队列。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct TaggedNode {
    const Node* node = nullptr;
    FrameState* input_frame = nullptr;
    int64 input_iter = -1;
    bool is_dead = false;
    
    TaggedNode(const Node* t_node, FrameState* in_frame, int64 in_iter, bool dead);
};
class TaggedNodeReadyQueue {
  public:
    void push_back(TaggedNode node);
    void pop_front();
    bool empty();
    const TaggedNode* begin();
    const TaggedNode* end();
  private:
    gtl::InlinedVector&amp;lt;TaggedNode, 16&amp;gt; ready_;
    int front_index_;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于TaggedNodeReadyQueue，我们要说明一下，本来这里很自然的可以使用std::deque这个标准的双端列表来实现的，但因为在待运行序列中我们通常并没有太多的节点，所以为了效率我们只使用了一个vector来实现，并且省去了节点消耗后释放空间的麻烦。&lt;/p&gt;
&lt;h2 id=&quot;details&quot;&gt;3.5 details&lt;/h2&gt;
&lt;p&gt;终于快要接近终点了。在前文中我们讲了那么多结构，最终计算图的执行过程究竟是怎样的，我们仍然不得而知。因为具体的实现细节都隐藏在函数的实现中，而我们上文中全部都在探讨接口。现在我们就来看下，具体的实现方法。&lt;br/&gt;首先，执行器的入口是Run函数，先来看下ExecutorImpl中的Run函数是如何实现的吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void ExecutorImpl::RunAsync(const Args&amp;amp; args, DoneCallback done){
    (new ExecutorState(args,this))-&amp;gt;RunAsync(std::move(done));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这验证了我们上文中提到的，ExecutorImpl仍然只是一个接口，真正的执行是被推到ExecutorState类中完成的。在上述函数中，我们首先定义了一个ExecutorState对象，然后调用了它的RunAsync函数。在构造函数中，首先初始化了root_frame和iteration 0，我们具体看看RunAsync是如何实现的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void ExecutorState::RunAsync(Executor::DoneCallback done){
    const Graph* graph = impl_-&amp;gt;graph_;//获取计算图指针
    TaggedNodeSeq ready;//构建ready节点序列
    
    //让设备填充设备上下文映射
    Device* device = impl_-&amp;gt;params_.device;
    Status fill_status = device-&amp;gt;FillContextMap(graph, &amp;amp;device_context_map_);
    if(!fill_status.ok()){
        done(fill_status);
        return;
    }
    
    //初始化ready队列
    for(const Node* n : impl_-&amp;gt;root_nodes){
        DCHECK_EQ(n-&amp;gt;in_edges().size(),0);
        ready.push_back(TaggedNode{n,root_frame_,0,false});
    }
    if(ready.empty()){
        done(Status::OK());
    } else {
        num_outstanding_ops = ready.size();
        root_frame_-&amp;gt;iterations[0]-&amp;gt;outstanding_ops = ready.size();
        done_cb_ = std::move(done);
        ScheduleReady(ready,nullptr);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，主要做了两件事，第一是初始化了ready queue，第二是启动了ScheduleReady函数。&lt;br/&gt;下面我们再来看一下SheduleReady函数的运行机制：&lt;/p&gt;
</description>
<pubDate>Sat, 01 Sep 2018 16:15:00 +0000</pubDate>
<dc:creator>jicanghai</dc:creator>
<og:description>目录 1. 核心概念 2. executor.h 1. Executor 2. NewLocalExecutor 3. ExecutorBarrier 3. executor.cc 1. struct</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jicanghai/p/9572217.html</dc:identifier>
</item>
<item>
<title>AtCoder Regular Contest 101 D - Median of Medians - basasuya</title>
<link>http://www.cnblogs.com/Basasuya/p/9572200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Basasuya/p/9572200.html</guid>
<description>&lt;p&gt;二分答案&lt;/p&gt;
&lt;p&gt;然后前缀和+树状数组来判断这个答案是否大于等于数&lt;br/&gt;如果我们对于一个查询，如果小于这个数令为1，大于这个数领为-1&lt;br/&gt;将所有前缀和放在树状数组中，就可以查询所有sum_{l} &amp;lt; sum_{r}的组合&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;bitset&amp;gt;
#include &amp;lt;climits&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iomanip&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;list&amp;gt;
#include &amp;lt;map&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;set&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;
const int N = 1e5 + 5;
const int INF = 0x3f3f3f3f;
const int MOD = 1e9 + 7;
typedef long long ll;

int A[N];
int B[N];
int C[N];
ll tree[N * 2];
int n;
void Add(int pos, int num) {
    for (int i = pos; i &amp;lt;= 2 * n; i += i &amp;amp; -i) tree[i] += num;
}
ll Sum(int pos) {
    ll ans = 0;
    for (int i = pos; i &amp;gt; 0; i -= i &amp;amp; -i) ans += tree[i];
    return ans;
}

bool solve(int x) {
    memset(tree, 0, sizeof(tree));
    for (int i = 1; i &amp;lt;= n; ++i) {
        if (A[i] &amp;gt;= x)
            C[i] = 1;
        else
            C[i] = -1;
    }
    ll ans = 0;
    Add(n, 1);
    for (int i = 1; i &amp;lt;= n; ++i) {
        C[i] += C[i - 1];
        ans += Sum(C[i] + n);
        Add(C[i] + n, 1);
    }
    //    printf(&quot;%d\n&quot;, ans);
    return (ans &amp;gt;= (1ll * n * (n + 1) / 4));
}
int main() {
    while (~scanf(&quot;%d&quot;, &amp;amp;n)) {
        for (int i = 1; i &amp;lt;= n; ++i) {
            scanf(&quot;%d&quot;, &amp;amp;A[i]);
            B[i] = A[i];
        }
        sort(B + 1, B + n + 1);
        int tot = unique(B + 1, B + n + 1) - B - 1;
        int l = 1;
        int r = tot;

        while (l &amp;lt;= r) {
            int mid = (l + r) &amp;gt;&amp;gt; 1;
            if (solve(B[mid]))
                l = mid + 1;
            else
                r = mid - 1;
        }
        //    for(int i = 1; i &amp;lt;= tot; ++i) printf(&quot;%d &quot;, B[i]); printf(&quot;\n&quot;);
        printf(&quot;%d\n&quot;, B[r]);
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 01 Sep 2018 16:06:00 +0000</pubDate>
<dc:creator>basasuya</dc:creator>
<og:description>二分答案 然后前缀和+树状数组来判断这个答案是否大于等于数 如果我们对于一个查询，如果小于这个数令为1，大于这个数领为 1 将所有前缀和放在树状数组中，就可以查询所有sum_{l} include i</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Basasuya/p/9572200.html</dc:identifier>
</item>
<item>
<title>ACM 2018 南京网络赛H题Set解题报告 - zbh2047</title>
<link>http://www.cnblogs.com/zbh2047/p/9572187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zbh2047/p/9572187.html</guid>
<description>&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定\(n\)个数$a_i$，起初第\(i\)个数在第\(i\)个集合。有三种操作（共\(m\)次）：&lt;/p&gt;
&lt;p&gt;1 $u$ $v$ 将第$u$个数和第$v$个数所在集合合并&lt;/p&gt;
&lt;p&gt;2 $u$ 将第$u$个数所在集合所有数加1&lt;/p&gt;
&lt;p&gt;3 $u$ $k$ $x$ 问$u$所在集合有多少个数模$2^k$余$x$。&lt;/p&gt;
&lt;p&gt;数据范围：\(n,m \le 500000,a_i \le 10^9, 0 \le k \le 30\)。&lt;/p&gt;
&lt;h2&gt;简要题解&lt;/h2&gt;
&lt;p&gt;显然此题可以用set加启发式合并在\(O(n \log ^2 n)\)时间复杂度解决本题，但此题时限1.5s，必须使用一个log的做法。事实上，这是一道十分套路的Trie树题目。&lt;/p&gt;
&lt;p&gt;首先用并查集维护连通性。&lt;/p&gt;
&lt;p&gt;下面先考虑操作3，这相当于询问低$k$位二进制固定时集合中元素个数，可以用Trie树，维护一个子树中终结结点有多少个即可。&lt;/p&gt;
&lt;p&gt;对于加1操作，可以在Trie树上打标记，类似线段树进行pushDown标记下传。此题pushDown函数很新颖（之前没写过这样的pushDown），详见代码。&lt;/p&gt;
&lt;p&gt;对于合并操作，类似线段树合并。由于初始时\(n\)个数共需要\(O(n \log 10^9)\)个结点，而花费O(1)的时间会将总结点数减1，故Trie树合并的总时间复杂度也为\(O(n \log 10^9)\)。关于线段树合并，可以做这道入门题练手：&lt;a title=&quot;Codeforces Gym 101194G&quot; href=&quot;http://codeforces.com/gym/101194/attachments&quot; target=&quot;_blank&quot;&gt;Codeforces Gym 101194G&lt;/a&gt;（2016EC Final）&lt;/p&gt;
&lt;p&gt;总时间复杂度\(O((n+q) \log 10^9)\)。&lt;/p&gt;
&lt;h2&gt;注意事项&lt;/h2&gt;
&lt;p&gt;此题空间复杂度\(O(n \log 10^9)\)。如果Trie树合并使用新开的结点，每个结构体16B，将需要576MB，这会MLE。考虑Trie树合并时不新开结点，可以将空间降至288MB。&lt;/p&gt;
&lt;h2&gt;完整代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;cstdio&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;cstring&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include&amp;lt;vector&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; DEPTH 30
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Trie{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; next[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; tag;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }trie[&lt;span&gt;20000001&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; cnt;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; newTrie(){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     memset(&amp;amp;trie[++cnt], &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(Trie));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cnt;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; pushDown(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; &amp;amp;t =&lt;span&gt; trie[i].tag;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; &amp;amp;l = trie[i].next[&lt;span&gt;0&lt;/span&gt;], &amp;amp;r = trie[i].next[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (t){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t &amp;amp; &lt;span&gt;1&lt;/span&gt;){ swap(l, r); trie[l].tag++&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t &amp;gt;= &lt;span&gt;2&lt;/span&gt;){ trie[l].tag += t / &lt;span&gt;2&lt;/span&gt;; trie[r].tag += t / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         t = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; pushUp(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     trie[i].size = trie[trie[i].next[&lt;span&gt;0&lt;/span&gt;]].size + trie[trie[i].next[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]].size;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insert(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; depth, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!depth){ trie[i].size++; &lt;span&gt;return&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    pushDown(i);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; &amp;amp;pos = trie[i].next[x &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!pos)pos =&lt;span&gt; newTrie();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     insert(pos, depth - &lt;span&gt;1&lt;/span&gt;, x &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    pushUp(i);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; merge(&lt;span&gt;int&lt;/span&gt;&amp;amp; i, &lt;span&gt;int&lt;/span&gt; j, &lt;span&gt;int&lt;/span&gt; k, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; depth)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (j&amp;amp;&amp;amp;&lt;span&gt;k){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         i =&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;depth){
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             trie[i].size +=&lt;span&gt; trie[k].size;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        pushDown(j); pushDown(k);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;; c &amp;lt; &lt;span&gt;2&lt;/span&gt;; c++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             merge(trie[i].next[c], trie[j].next[c], trie[k].next[c], depth - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        pushUp(i);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; i = j ?&lt;span&gt; j : k;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; f[&lt;span&gt;600001&lt;/span&gt;], id[&lt;span&gt;600001&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getFather(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (f[i] == i)&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; f[i] =&lt;span&gt; getFather(f[i]);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, m, x, u, v, k;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;n, &amp;amp;&lt;span&gt;m);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;x);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         id[i] =&lt;span&gt; newTrie();
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         f[i] =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;        insert(id[i], DEPTH, x);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (m--&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;x, &amp;amp;&lt;span&gt;u);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         u =&lt;span&gt; getFather(u);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (x == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;v);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;             v =&lt;span&gt; getFather(v);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (u !=&lt;span&gt; v){
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;                 f[u] =&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;                merge(id[v], id[u], id[v], DEPTH);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (x == &lt;span&gt;2&lt;/span&gt;)trie[id[u]].tag++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;k, &amp;amp;&lt;span&gt;x);
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;&lt;span&gt; cur;
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (cur = id[u]; k; k--&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;                pushDown(cur);
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;                 cur = trie[cur].next[x &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!cur)&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;                 x &amp;gt;&amp;gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!cur)printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, trie[cur].size);
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 01 Sep 2018 15:58:00 +0000</pubDate>
<dc:creator>zbh2047</dc:creator>
<og:description>题目描述 给定\(n\)个数$a_i$，起初第\(i\)个数在第\(i\)个集合。有三种操作（共\(m\)次）： 1 $u$ $v$ 将第$u$个数和第$v$个数所在集合合并 2 $u$ 将第$u$个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zbh2047/p/9572187.html</dc:identifier>
</item>
<item>
<title>利用.NET Core类库System.Reflection.DispatchProxy实现简易Aop - Elder_James</title>
<link>http://www.cnblogs.com/ElderJames/p/implement-simple-Aop-using-a-dotnet-core-library-System-Reflection-DispatchProxy.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ElderJames/p/implement-simple-Aop-using-a-dotnet-core-library-System-Reflection-DispatchProxy.html</guid>
<description>&lt;p&gt;Aop即是面向切面编程，众多Aop框架里Castle是最为人所知的，另外还有Autofac、还有死去的Spring.NET，当然，.NET Core社区新秀AspectCore在性能与功能上都非常优秀，已经逐渐被社区推崇和有越来越多的人使用。感谢柠檬同学的礼物！&lt;/p&gt;
&lt;p&gt;如果大家出于自身需求或者学习，想实现一个Aop，是不是觉得一来就要使用Emit去做？最近我了解到了System.Reflection.DispatchProxy这个corefx类库，已经实现了动态代理功能。&lt;/p&gt;
&lt;p&gt;下面演示一下它的使用方法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        //创建代理类，并把SamepleProxy作为拦截器注入
        var samepleProxy = (targetInterface)SamepleProxy.Create&amp;lt;targetInterface, SamepleProxy&amp;gt;();
        //执行接口方法
        samepleProxy.Write(&quot;here is invoke by proxy&quot;);
    }
}

//需要被生成代理实例的接口
public interface targetInterface
{
    //这个方法会被代理类实现
    void Write(string writesomeshing);
}

public class SamepleProxy : DispatchProxy
{
    /// &amp;lt;summary&amp;gt;
    /// 拦截调用
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;method&quot;&amp;gt;所拦截的方法信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;所拦截方法被传入的参数指&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    protected override object Invoke(MethodInfo targetMethod, object[] args)
    {
        Console.WriteLine(args[0]);
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;System.Reflection.DispatchProxy&lt;/code&gt;只有一个Api，就是&lt;code&gt;objecct Create&amp;lt;T,TProxy&amp;gt;() where TProxy:DispatchProxy&lt;/code&gt;,约束了只能传入泛型参数，并不能从方法传入类型，这就会带来很多问题。而更可气的是，给官方提了issue之后，还是不给增加这个api……&lt;br/&gt;幸好，在那个issue下，issue作者提供了一个解决方案，就是用反射来构造这个泛型方法。我还在这基础上，封装了一下，加入了传入拦截器实例和传入拦截器构造方法参数的功能。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 拦截器接口
/// &amp;lt;/summary&amp;gt;
public interface IInterceptor
{
    /// &amp;lt;summary&amp;gt;
    /// 拦截器调用
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;target&quot;&amp;gt;代理实例&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;method&quot;&amp;gt;所拦截的方法&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;所拦截方法传入的参数值&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;返回值会传递给方法返回值&amp;lt;/returns&amp;gt;    
    object Intercept(object target, MethodInfo method, object[] parameters);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拦截器要实现这个接口，下面是对DispatchProxy的封装，实现更多创建代理实例的方法&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ProxyGenerator : DispatchProxy
{
    private IInterceptor interceptor { get; set; }
    private static object proxy { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 创建代理实例
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;targetType&quot;&amp;gt;所要代理的接口类型&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;interceptor&quot;&amp;gt;拦截器&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;代理实例&amp;lt;/returns&amp;gt;
    public static object Create(Type targetType, IInterceptor interceptor)
    {
        object proxy = GetProxy(targetType);
        MethodInfo method = typeof(ProxyGenerator).GetMethod(nameof(CreateInstance), BindingFlags.NonPublic | BindingFlags.Instance, Type.DefaultBinder, new[] { typeof(IInterceptor) }, null);
        method.Invoke(proxy, new object[] { interceptor });
        return proxy;
    }

    /// &amp;lt;summary&amp;gt;
    /// 创建代理实例
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;targetType&quot;&amp;gt;所要代理的接口类型&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;interceptorType&quot;&amp;gt;拦截器类型&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;拦截器构造函数参数值&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;代理实例&amp;lt;/returns&amp;gt;
    public static object Create(Type targetType, Type interceptorType, params object[] parameters)
    {
        object proxy = GetProxy(targetType);
        MethodInfo method = typeof(ProxyGenerator).GetMethod(nameof(CreateInstance), BindingFlags.NonPublic | BindingFlags.Instance, Type.DefaultBinder, new[] { typeof(Type), typeof(object[]) }, null);
        method.Invoke(proxy, new object[] { interceptorType, parameters });
        return proxy;
    }


    /// &amp;lt;summary&amp;gt;
    /// 创建代理实例 TTarget:所要代理的接口类型 TInterceptor:拦截器类型
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;拦截器构造函数参数值&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;代理实例&amp;lt;/returns&amp;gt;
    public static TTarget Create&amp;lt;TTarget, TInterceptor&amp;gt;(params object[] parameters) where TInterceptor : IInterceptor
    {
        object proxy = GetProxy(typeof(TTarget));
        MethodInfo method = typeof(ProxyGenerator).GetMethod(nameof(CreateInstance), BindingFlags.NonPublic | BindingFlags.Instance, Type.DefaultBinder, new[] { typeof(Type), typeof(object[]) }, null);
        method.Invoke(proxy, new object[] { typeof(TInterceptor), parameters });
        return (TTarget)proxy;
    }

    private static object GetProxy(Type targetType)
    {
        MethodInfo method = typeof(DispatchProxy).GetMethod(nameof(DispatchProxy.Create), new Type[] { });
        method = method.MakeGenericMethod(targetType, typeof(ProxyGenerator));
        proxy = method.Invoke(null, null);
        return proxy;
    }

    private void CreateInstance(Type interceptorType, object[] parameters)
    {
        this.interceptor = (IInterceptor)Activator.CreateInstance(interceptorType, parameters);
    }

    private void CreateInstance(IInterceptor interceptor)
    {
        this.interceptor = interceptor;
    }

    protected override object Invoke(MethodInfo method, object[] parameters)
    {
        return this.interceptor.Intercept(proxy, method, parameters);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        // var poxy = (targetInterface)ProxyGenerator.Create(typeof(targetInterface), new SamepleProxy());
        // 或
        //var poxy = (targetInterface)ProxyGenerator.Create(typeof(targetInterface), typeof(SamepleProxy));
        // 或
        var poxy = ProxyGenerator.Create&amp;lt;targetInterface, SamepleProxy&amp;gt;();
        poxy.Write(&quot;here is invoked by coreproxy&quot;);
    }
}


public class SamepleProxy : IInterceptor
{
    public object Intercept(object target, MethodInfo method, object[] parameters)
    {
        Console.WriteLine(parameters[0]);
        return null;
    }
}

public interface targetInterface
{
    void Write(string writesome);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结一下就是，微软爸爸给我们的这个轮子还是即轻便又很好用的。&lt;br/&gt;本文的实例代码可以在我的github上找到：&lt;a href=&quot;https://github.com/ElderJames/CoreProxy&quot; class=&quot;uri&quot;&gt;https://github.com/ElderJames/CoreProxy&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Sep 2018 15:46:00 +0000</pubDate>
<dc:creator>Elder_James</dc:creator>
<og:description>Aop即是面向切面编程，众多Aop框架里Castle是最为人所知的，另外还有Autofac、还有死去的Spring.NET，当然，.NET Core社区新秀AspectCore在性能与功能上都非常优秀</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ElderJames/p/implement-simple-Aop-using-a-dotnet-core-library-System-Reflection-DispatchProxy.html</dc:identifier>
</item>
<item>
<title>MySql数据库实现分布式的主从结构 - 小勇DW3</title>
<link>http://www.cnblogs.com/gxyandwmm/p/9572153.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gxyandwmm/p/9572153.html</guid>
<description>
&lt;p&gt;最近学习了关于使用MySql数据的实现主动结构的原理，在以前的并发访问低的场景一下，一般一台性能高的服务器作为一个MySql数据，就可以满足业务的增删改查场景，但是随着网络用户的增加&lt;/p&gt;
&lt;p&gt;当出现高并发，高QPS的情况下，一台MySql就很难支撑这种场景了，根据现在的分布式处理架构，处理在使用Redis这种高效的缓存数据库外，其实也可以针对数据库端进行分布式处理，也就是原来&lt;/p&gt;
&lt;p&gt;和Redis相同，使用分布式主从架构，通过Master 和 Slave 实现读写分析，数据采用主从复制的原理，这种采用读写分析，同时读的Slave机器可以多台配置的架构，极大了增加的后台的稳定性和满足&lt;/p&gt;
&lt;p&gt;高并发的情景；&lt;/p&gt;

&lt;h2&gt;下面进行原理分析：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901232037686-933970824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;配置的简要过程说明：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Mysql的配置文件【在Spring中进行设置】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901232235705-1807159569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据源的配置：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Master数据源：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901232523009-1863717659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Slave数据源：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901232620665-708967924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;源代码的可以采用基于自定义注解的方式实现：&lt;/p&gt;
&lt;p&gt;1、使用一个选择类，用来配置选择方式；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901232757945-1543957932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系统的配置需要采用一个路由配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901233002832-1496995675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在spring中注册数据源【通过master和slave关键字匹配对应的数据源】：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901233050703-1666715957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;采用注解的方式实现在Mapper接口上通过注解就可以实现自动匹配，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901233238211-1452180625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 自定义注解的实现：使用Aspectj的代理模式 AOP原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901233344194-1602873942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;把注解匹配到具体实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901233539628-1475357956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; Spring中配置注册:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901233957372-612112313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置完成！&lt;/p&gt;

</description>
<pubDate>Sat, 01 Sep 2018 15:42:00 +0000</pubDate>
<dc:creator>小勇DW3</dc:creator>
<og:description>最近学习了关于使用MySql数据的实现主动结构的原理，在以前的并发访问低的场景一下，一般一台性能高的服务器作为一个MySql数据，就可以满足业务的增删改查场景，但是随着网络用户的增加 当出现高并发，高</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gxyandwmm/p/9572153.html</dc:identifier>
</item>
<item>
<title>没做过大项目，但我会建大项目 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/build-complicate-program.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/build-complicate-program.html</guid>
<description>&lt;p&gt;刚出来实习的时候，参与的项目使用的还是SSH框架。&lt;/p&gt;
&lt;p&gt;那时候还在使用SVN进行版本管理，常常在合并代码的时候遇到各种莫名其妙的问题。&lt;/p&gt;
&lt;p&gt;那时候使用着曾经宇宙最好用的JAVA IDE Eclipse写代码，也没有觉得界面简陋影响编码。&lt;/p&gt;
&lt;p&gt;那时候还不知道啥时微服务，只知道有需求了就把代码往单体项目的代码里加，而且是前端和后台代码放一起的那种。什么Vue、React、Angular，不存在的，JQuery搞定一切。&lt;/p&gt;
&lt;p&gt;因为项目小，或者因为业务并不复杂，虽然项目代码都放一块，但是勉强还可以看，找相关的代码也算比较快。&lt;/p&gt;
&lt;p&gt;后来，慢慢接触到了一些大点的项目，而且微服务的设计理念也更加盛行和深入人心。所以，我们会发现在当今宇宙最好的JAVA IDE Intellij IDEA中多了越来越多的微服务项目，日益膨胀的业务，让我们在找相应的项目以及代码的时候力不从心。&lt;/p&gt;
&lt;p&gt;所以，这时候项目的编排就很重要，换句话说就是，大项目应该有大项目的样子。这篇就来看看我们如果在Intellij IDEA中搭建项目目录结构清新的大项目。&lt;/p&gt;
&lt;h3 id=&quot;项目结构对比&quot;&gt;项目结构对比&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;项目划分前&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233616835-1531223148.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候如果要添加代码，我们会在项目里面通过创建各个package用于区分业务代码，或者新建平级的module。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目划分后&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233624985-1678514422.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何创建有层次的大项目框架&quot;&gt;如何创建有层次的大项目框架&lt;/h3&gt;
&lt;h4 id=&quot;创建root项目&quot;&gt;1、创建root项目&lt;/h4&gt;
&lt;p&gt;点击File-&amp;gt;new-&amp;gt;Project，点击图中的左侧的maven，创建一个maven父级项目&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233633719-1893484142.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击next，进入下一步&lt;/p&gt;
&lt;h4 id=&quot;填写maven坐标项目&quot;&gt;2、填写maven坐标项目&lt;/h4&gt;
&lt;p&gt;因为创建的是maven项目，所以需要定义groupId和artifactId，自己填写即可&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233642152-335487651.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击next，进入下一步&lt;/p&gt;
&lt;h4 id=&quot;确认项目信息并完成父级项目创建&quot;&gt;3、确认项目信息并完成父级项目创建&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233649712-1729317451.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;父级项目概览&quot;&gt;4、父级项目概览&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233708353-192630572.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是一个再普通不过的maven项目，下面我们需要在这个项目中新建子module。&lt;/p&gt;
&lt;h4 id=&quot;创建聚合项目&quot;&gt;5、创建聚合项目&lt;/h4&gt;
&lt;p&gt;我们在微服务开发模式下经常需要开发一个接口服务，同时可能还需要一个用于同步数据的服务，如果我们把这两个服务散落在root项目目录下，有时候因为命名而隔得很远，找代码也不方便。&lt;/p&gt;
&lt;p&gt;这时候就需要一个聚合项目，该项目用于编排某个服务项目的原子项目（xxx），如服务的实现项目(&quot;xxx-service&quot;)，服务的接口项目(&quot;xxx-api&quot;)，服务的同步数据项目(&quot;xxx-sync&quot;)。&lt;/p&gt;
&lt;p&gt;这里我们就创建一个聚合项目spring&lt;/p&gt;
&lt;h5 id=&quot;创建spring项目&quot;&gt;5.1 创建“spring”项目&lt;/h5&gt;
&lt;p&gt;在root项目上右键选择new-&amp;gt;module&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233744404-911372159.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;创建一个maven的spring项目&quot;&gt;5.2 创建一个maven的“spring”项目&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233800040-1870113016.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击next，进入下一步&lt;/p&gt;
&lt;h5 id=&quot;填写maven的坐标信息&quot;&gt;5.3 填写maven的坐标信息&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233811636-1828637657.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意这里因为是在root下新建子module，所以这里有个“Parent”选项，即继承了root项目，填写下artifactId即可。&lt;/p&gt;
&lt;p&gt;点击next，进入下一步&lt;/p&gt;
&lt;h5 id=&quot;确认项目信息并完成聚合项目创建&quot;&gt;5.4 确认项目信息并完成聚合项目创建&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233841919-422003729.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;聚合项目概览&quot;&gt;5.5 聚合项目概览&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233851371-1182342528.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意这里聚合项目“spring”已经创建成功，点击root项目的pom文件，可以看到已经多了属性标签，如右图所示。&lt;/p&gt;
&lt;h4 id=&quot;创建聚合项目下的子项目&quot;&gt;6、创建聚合项目下的子项目&lt;/h4&gt;
&lt;p&gt;有了聚合项目，我们就可以在“spring”下创建子项目了，具体步骤如下&lt;/p&gt;
&lt;h5 id=&quot;创建聚合项目下的子项目-1&quot;&gt;6.1 创建聚合项目下的子项目&lt;/h5&gt;
&lt;p&gt;在“spring”项目上右键new-&amp;gt;module，这时候我们选择创建一个springboot的项目&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233921579-1051599046.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击next，进入下一步&lt;/p&gt;
&lt;h5 id=&quot;填写项目基本信息&quot;&gt;6.2 填写项目基本信息&lt;/h5&gt;
&lt;p&gt;填写好springboot项目的maven坐标信息&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233930779-1552771541.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击next，进入下一步，一直到确认信息页面&lt;/p&gt;
&lt;h5 id=&quot;确认项目信息&quot;&gt;6.3确认项目信息&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233939555-565578481.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意这里默认content root和module file location只到/Users/jackie/workspace/root/spring，但是我们要创建的是springboot项目，位于聚合项目下的子项目。所以需要将两个变量的信息改为如图所示，即加上新建项目的名称信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我在这里尝试过几次，都没有加上子项目的名称，导致新建的项目一直和聚合项目平级，无法起到聚合的目的，所以这里需要格外注意。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;聚合项目下的子项目概览&quot;&gt;6.4 聚合项目下的子项目概览&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233947203-1345503214.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里“spring”作为聚合项目，可以将该目录下的src目录删除，仅保留pom文件用于编排子项目。&lt;/p&gt;
&lt;p&gt;至此，我们完成了基本父级项目的创建，聚合项目的创建以及聚合项目下子项目的创建。&lt;/p&gt;
&lt;p&gt;看完这边，相信再复杂的目录结构层次也难不倒你了。&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Sep 2018 15:42:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>大项目实战可遇不可求，但是搭建大项目的技能我们志在必得。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/build-complicate-program.html</dc:identifier>
</item>
<item>
<title>python爬虫-淘宝商品密码（图文教程附源码） - BruceLong</title>
<link>http://www.cnblogs.com/yunlongaimeng/p/9572082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunlongaimeng/p/9572082.html</guid>
<description>&lt;p&gt;&lt;span&gt;今天闲着没事，不想像书上介绍的那样，我相信所有的数据都是有规律可以寻找的，然后去分析了一下淘宝的商品数据的规律和加密方式，用了最简单的知识去解析了需要的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个也让我学到了，解决问题的方法不止一个，我们要常常学会去思考，学会去学习，相信我们爬虫还是可以拿到我们想要的一切需要的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我也对数据感兴趣，就是感觉，世间万物都是有规律可寻的，就看我们能不能去发现其中的秘密。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们去解决一个问题的时候，那一种成就感是别人难以体会的。只有我们去亲身体验才会感到真正的幸福。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所用模块：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;re+requests+json&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所用环境：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;windows10 + pycharm&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;实战分析：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;第一步：根据url来在google chrome中分析数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302991/201809/1302991-20180901232642477-1681289849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302991/201809/1302991-20180901232751504-1944284487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析的结果是：数据就是通过json来存储的&lt;/p&gt;
&lt;p&gt;第二步：&lt;/p&gt;
&lt;p&gt;得到网页的源码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302991/201809/1302991-20180901232957569-1919365885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三步把得到的数据进行解析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302991/201809/1302991-20180901233051285-1926312380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 第四步：对数据进行解密&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302991/201809/1302991-20180901233123498-1512218709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第五步：就可以把json的数据拿到并分析得到相应的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302991/201809/1302991-20180901233208886-2082848913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 以下是源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在搜索框中输入美食得到的数据q=%E7%BE%8E%E9%A3%9F&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://s.taobao.com/search?q=%E7%BE%8E%E9%A3%9F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; response =&lt;span&gt; requests.get(url)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(response.text)&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用正则对html源码进行解析到一个json数据&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; pattern = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;g_page_config =(.*?});&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, re.S)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; result =&lt;span&gt; re.search(pattern, response.text)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(result.group(1))&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发现并不是那么简单而是加密的数据并是有规律可寻的，以下是加密的几个数据段&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     json_data = re.sub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(\\\\u003d)|(\\\\u0026)|(\\\\u003c)|(\\\\u003e)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, result.group(1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;数据解密成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(json_data)&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;数据解密失败，原因是：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,e)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; json_dumps = json.dumps(json_data)&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(json_dumps)&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; data_count = 1
&lt;span&gt;27&lt;/span&gt; data =&lt;span&gt; json.loads(json_data)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 分析json的数据并把需要的数据给读取出来&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; good &lt;span&gt;in&lt;/span&gt; data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mods&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;itemlist&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;auctions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;商店名：{},商品标题:{},\n商品图片：{},\n商品产地：{},商品价格：{},付款人数：{},\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(good[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nick&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], good[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], good[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pic_url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], good[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item_loc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], good[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;view_price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],good[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;view_sales&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     data_count += 1
&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(data_count)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 01 Sep 2018 15:17:00 +0000</pubDate>
<dc:creator>BruceLong</dc:creator>
<og:description>今天闲着没事，不想像书上介绍的那样，我相信所有的数据都是有规律可以寻找的，然后去分析了一下淘宝的商品数据的规律和加密方式，用了最简单的知识去解析了需要的数据。 这个也让我学到了，解决问题的方法不止一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunlongaimeng/p/9572082.html</dc:identifier>
</item>
<item>
<title>win32进程概念之句柄表,以及内核对象. - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/9571964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/9571964.html</guid>
<description>&lt;h2&gt;一丶什么是句柄表什么是内核对象.&lt;/h2&gt;
&lt;h3&gt;1.句柄表的生成&lt;/h3&gt;
&lt;p&gt;我们知道.我们使用CreateProcess 的时候会返回一个进程句柄.以及线程句柄. 其实在调用CreateProcess的时候.内核中会新建一个EPROCESS结构来存储我们的进程信息.&lt;/p&gt;
&lt;p&gt;例如如下图:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901213809885-626063259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是有一个问题.怎么给三环使用.难道直接返回EPROCESS?&lt;/p&gt;
&lt;p&gt;其实不是这样的. 第一EPROCESS在高两G. 三环程序是不可以访问的.所以返回的地址是高两G所以不能使用. 但是为了解决这一问题. &lt;/p&gt;
&lt;p&gt;windows创建了一个表格. 返回这个表格的索引. 而我们使用的就是这个索引.&lt;/p&gt;
&lt;h3&gt;2.什么是内核对象.&lt;/h3&gt;
&lt;p&gt;内核对象就是我们上面所说的EPROCESS. 有很多内核对象.具体可以看下CloseHandle. 这个API表示他可以关闭什么内核对象.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Access token&lt;/li&gt;
&lt;li&gt;Communications device&lt;/li&gt;
&lt;li&gt;Console input&lt;/li&gt;
&lt;li&gt;Console screen buffer&lt;/li&gt;
&lt;li&gt;Event&lt;/li&gt;
&lt;li&gt;File&lt;/li&gt;
&lt;li&gt;File mapping&lt;/li&gt;
&lt;li&gt;I/O completion port&lt;/li&gt;
&lt;li&gt;Job&lt;/li&gt;
&lt;li&gt;Mailslot&lt;/li&gt;
&lt;li&gt;Memory resource notification&lt;/li&gt;
&lt;li&gt;Mutex&lt;/li&gt;
&lt;li&gt;Named pipe&lt;/li&gt;
&lt;li&gt;Pipe&lt;/li&gt;
&lt;li&gt;Process&lt;/li&gt;
&lt;li&gt;Semaphore&lt;/li&gt;
&lt;li&gt;Thread&lt;/li&gt;
&lt;li&gt;Transaction&lt;/li&gt;
&lt;li&gt;Waitable timer&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以操作事件  文件 互斥体 线程. 等等....&lt;/p&gt;
&lt;h2&gt;二丶多进程共用内核对象&lt;/h2&gt;
&lt;h3&gt;1.第一种方法. 使用OpenProcess&lt;/h3&gt;
&lt;p&gt;在windows程序中.我们操作的都是内核对象. 我们可以通过OpenProcess API来打开一个已有进程的内核对象.&lt;/p&gt;
&lt;p&gt;如下图:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901214607042-1110188052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个进程里面的句柄表都是私有的. 例如第一张表. 句柄索引位1. 对应内核对象为A. 那么将索引传给B进程是没用用的.&lt;/p&gt;
&lt;p&gt;B进程只有使用API打开之后才能获得 A内核对象.&lt;/p&gt;

&lt;p&gt;其中中间的紫色表代表引用计数. 也就是说这个内核对象引用一次 这个值则会+1&lt;/p&gt;
&lt;p&gt;而CloseHandle作用就是 使内核对象的引用计数-1 如果都关闭了.那么此时内核对象没有人使用. 也没有执向了.所以就会销毁这个内核对象了.也就是说.当内核对象的引用计数位为0了.那么此时的内核对象&lt;/p&gt;
&lt;p&gt;才是真正的销毁.&lt;/p&gt;
&lt;p&gt;而线程是特例:  当线程的内核对象引用计数为0的时候也不会关闭.  此时必须先关闭线程.在使用CloseHandle 是引用计数 -1才可以.&lt;/p&gt;
&lt;h3&gt;2.使用继承句柄技术&lt;/h3&gt;
&lt;p&gt;在windows程序中. A创建 B .或者带有内核对象的 API在创建的时候. 都有一个SD属性.也就是安全属性.这个属性可以表示你创建的这个句柄是否可以继承.&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;p&gt; 　　CreateEvent()创建事件. 先不用管API的作用.我们看下API的参数吧.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HANDLE CreateEventA(
  LPSECURITY_ATTRIBUTES lpEventAttributes,     安全属性结构体 主要介绍他
  BOOL                  bManualReset,
  BOOL                  bInitialState,
  LPCSTR                lpName
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个就是安全属性结构体.如果我们不指定.默认就是父进程的.&lt;/p&gt;
&lt;p&gt;安全属性结构体.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _SECURITY_ATTRIBUTES {
  DWORD  nLength;                                         当前结构体大小.windows扩展使用的
  LPVOID lpSecurityDescriptor;                        表明这个句柄给谁用谁可以访问.谁可以关闭.不重要 具体可以看下API中的结构体的定义.不重要不列出来了.
  BOOL   bInheritHandle;                                重要.表明句柄是否可以被继承.
} SECURITY_ATTRIBUTES, &lt;/span&gt;*PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901220056740-1225123869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们的句柄可以被继承. 那么句柄表的第一项就填1.表示这个句柄可以被继承.如果不能继承.则为0&lt;/p&gt;
&lt;p&gt;此时我们的子进程就可以继承父进程的 所有可继承的句柄表了.  注意.是所有可继承.  可以是共享的了. 如下图所示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901220651916-527597919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A进程创建的 B D是可以继承的. 所以 子进程可以完全复制A进程 可继承句柄表. 不允许继承的为0 都赋值为0&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;二丶进程PID解析&lt;/h2&gt;
&lt;p&gt;在windows任务管理器中.有PID选项.我们可以选中查看. 而且在windows中也常常听到进程ID的概念.&lt;/p&gt;
&lt;p&gt;那么进程ID到底是个什么东西.&lt;/p&gt;
&lt;p&gt;其实进程ID是全局的句柄表的一个索引.  上面所讲的句柄表.都是自己私有的句柄表. PID是全局句柄表里面的.&lt;/p&gt;
&lt;p&gt;这个句柄表里面记录了所有的正在运行进程的句柄.而且是唯一的. 如果进程死亡那么这个pid可能会执向别的句柄.  但也是唯一的.如下图所示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901221724455-868725913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而这个全局句柄表才是真正有意义的.为什么这样说.&lt;/p&gt;
&lt;p&gt;我们可以做个测试.&lt;/p&gt;
&lt;p&gt;1.使用OpenProcess打开进程句柄.&lt;/p&gt;
&lt;p&gt;2.使用TerminlateProcess结束进程.&lt;/p&gt;
&lt;p&gt;OpenProcess(访问权限,句柄是否可以继承,进程PID)&lt;/p&gt;
&lt;p&gt;TerminlateProcess(进程句柄,自定义的退出码) 结束进程.&lt;/p&gt;
&lt;p&gt;使用上面的两个API可以测试一下我们已有的进程是否可以被关闭. 如果测试过后你会发现.&lt;/p&gt;
&lt;p&gt;只有PID获得句柄才是有用了.也就是说全局句柄表. 而上面所讲的都是子进程的句柄表.&lt;/p&gt;

&lt;h2&gt;三丶常用进程操作API&lt;/h2&gt;
&lt;p&gt;1. GetModuleFileName()  获取当前模块路径 例如:  c:\\1.exe&lt;/p&gt;
&lt;p&gt;2.GetCurretDirectory()     获取当前的工作目录 例如:  c:\text\abc&lt;/p&gt;
&lt;p&gt;3.OpenProcess()  根据进程PID打开进程.获取进程句柄.&lt;/p&gt;
&lt;p&gt;4.FindWindow()    根据类名以及文件名.返回窗口句柄.&lt;/p&gt;
&lt;p&gt;5.GetWindowsThreadProcessId()  根据窗口句柄.获取进程PID&lt;/p&gt;
&lt;p&gt;6.EnumProcesses 遍历所有进程.返回进程PID    具体参考MSDN 有提供的例子.&lt;/p&gt;
&lt;p&gt;7.GetCommandLine() 获取命令行参数&lt;/p&gt;
&lt;p&gt;8.CreateToolHelp32Snapshot() 创建进程快照. 如果懂逆向的就知道.FS寄存器中的TEB PEB结构中有存储当前模块的或者进程的链表.这个是保存当前这一时刻的快照.&lt;/p&gt;
&lt;p&gt;我们可以进行遍历. 具体参考MSDN或者本博客. &lt;/p&gt;

&lt;h2&gt;四丶编写windows程序遇到的问题.&lt;/h2&gt;
&lt;p&gt;我们在编写windows程序的时候.会包含windows.h 但是有的函数可能就没有. 比如上面我们说的第八个函数. 快照函数.&lt;/p&gt;
&lt;p&gt;此时我们要查询MSDN. 我们可以搜索一下网页的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901223937766-775455115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以在下边看到所需要的头文件 是 tlhelp32.h 此时我们包含一下即可.&lt;/p&gt;
&lt;p&gt;遇到的问题2.&lt;/p&gt;
&lt;p&gt;有的时候我们头文件也包含了也去使用了.但是调用API的时候出错了.为什么?&lt;/p&gt;
&lt;p&gt;原因是 有的API在高版本中才有.低版本中使用的时候是没有导出的.此时使用就会出错.提示没有这个API.&lt;/p&gt;
&lt;p&gt;解决方法: 如果学过win32的 说的这个方法你们就理解了.如果没学过也没关系.一般这个问题很少遇见. 博主也才预见过一次.&lt;/p&gt;
&lt;p&gt;可以使用 loadlibary加载所需要的dll. 然后使用 GetProcAddress获取函数地址. 使用函数指针来使用这个函数.&lt;/p&gt;

</description>
<pubDate>Sat, 01 Sep 2018 14:42:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<og:description>句柄表跟内核对象 一丶什么是句柄表什么是内核对象. 1.句柄表的生成 我们知道.我们使用CreateProcess 的时候会返回一个进程句柄.以及线程句柄. 其实在调用CreateProcess的时候</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/9571964.html</dc:identifier>
</item>
<item>
<title>Python制作回合制手游外挂简单教程（上） - Rest探路者</title>
<link>http://www.cnblogs.com/Java-Starter/p/9571919.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java-Starter/p/9571919.html</guid>
<description>&lt;h2 align=&quot;left&quot;&gt;&lt;strong&gt;引入：&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;每次玩回合制游戏的时候，反反复复的日常任务让人不胜其烦&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;玩问道的时候，我们希望能够自动刷道，玩梦幻希望能自动做师门、捉鬼等等&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;该外挂只能模拟鼠标键盘操作，并不能修改游戏数据&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我这里使用的python2.7&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;开发工具是PyCharm&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;strong&gt;前期知识准备：&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;首先下载autopy包，我这里PyCharm可以直接导入autopy包&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;或者用利用pip进行安装：pip install autopy&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;strong&gt;鼠标移动&lt;/strong&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;复制如下代码，运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;

import time

 

import autopy

#quick move

autopy.mouse.move(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

 

#smooth move

#autopy.mouse.smooth_move(&lt;/span&gt;&lt;span&gt;1370&lt;/span&gt;,&lt;span&gt;120&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;会发现鼠标瞬间移动到坐标(1,1)的位置，我的电脑是1920*1080的，最右下角的坐标就是(1920,1080)。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;将move换成smooth_move,会发现鼠标慢慢地移动到指定坐标&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;官方文档的解释：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;autopy.mouse.move(x: float, y: float)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    Moves the mouse to the given (x, y) coordinate.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    Exceptions:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            ValueError is thrown if the point is out of index.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;autopy.mouse.smooth_move(x: float, y: float)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    Smoothly moves the mouse to the given (x, y) coordinate in a straight line.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    Exceptions:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            ValueError is thrown if the point is out of index.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;坐标超过分辨率会报异常&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;strong&gt;鼠标点击&lt;/strong&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;运行代码，发现当前位置产生了点击操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;

import autopy

autopy.mouse.click() # 单击&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;strong&gt;键盘操作&lt;/strong&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;下面时一些常见的键值码和键的对应：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   字母和数字键　数字小键盘的键　　功能键　　　　其它键 &lt;br/&gt;      键   键码      键   键码          键   键码       键      键码 &lt;br/&gt;      A   65          0   96            F1   112       Backspace    8 &lt;br/&gt;      B   66          1   97            F2   113       Tab       9 &lt;br/&gt;      C   67          2   98            F3   114       Clear      12 &lt;br/&gt;      D   68          3   99            F4   115       Enter      13 &lt;br/&gt;      E   69          4   100           F5   116      Shift      16 &lt;br/&gt;      F   70          5   101           F6   117      Control     17 &lt;br/&gt;      G   71         6   102           F7   118      Alt       18 &lt;br/&gt;      H   72         7   103           F8   119      Caps Lock    20 &lt;br/&gt;      I    73          8   104          F9   120      Esc       27 &lt;br/&gt;      J    74          9   105          F10  121     Spacebar    32 &lt;br/&gt;      K   75         *   106           F11  122      Page Up     33 &lt;br/&gt;      L   76         +   107           F12  123      Page Down    34 &lt;br/&gt;      M   77        Enter 108                          End       35 &lt;br/&gt;      N   78         -   109                              Home      36 &lt;br/&gt;      O   79         .   110                              Left Arrow   37 &lt;br/&gt;      P   80         /   111                              Up Arrow    38 &lt;br/&gt;      Q   81                                                Right Arrow   39 &lt;br/&gt;      R   82                                                Down Arrow    40 &lt;br/&gt;      S   83                                                Insert      45 &lt;br/&gt;      T   84                                                Delete      46 &lt;br/&gt;      U   85                                                Help       47 &lt;br/&gt;      V   86                                                Num Lock     144   &lt;br/&gt;      W  87          &lt;br/&gt;      X   88      &lt;br/&gt;      Y   89      &lt;br/&gt;      Z   90      &lt;br/&gt;      0   48      &lt;br/&gt;      1   49      &lt;br/&gt;      2   50       &lt;br/&gt;      3   51       &lt;br/&gt;      4   52       &lt;br/&gt;      5   53       &lt;br/&gt;      6   54       &lt;br/&gt;      7   55       &lt;br/&gt;      8   56       &lt;br/&gt;      9   57&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;复制代码，运行，这里需要win32api包&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;调用win32api的keybd_event方法，用过要释放按键&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
#coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;

import time

import win32api

 

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #alt键位码是18

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #tab键位码是9

time.sleep(&lt;/span&gt;&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;)

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #enter键位码是13

 

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) #释放按键

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

time.sleep(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; 可以看到，完成了切换窗口的操作，相当于我们按alt+tab,然后回车进入&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;开始制作外挂：&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;这里以问道手游为例(回合制手游类似)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;需要夜神模拟器，并在模拟器上安装问道&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我试过蓝叠和MuMu模拟器，我用autopy移动鼠标到模拟器时鼠标就消失了，不能完成后续的自动操作，后来百度了&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;说有的模拟器不受win窗口的控制。不管那么多，我们先用夜神模拟器吧！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1201453/201809/1201453-20180901222349163-1818644615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;进入游戏，打开“活动”&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1201453/201809/1201453-20180901222357917-1861327743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;我们以“竞技场”活动举例说明&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1201453/201809/1201453-20180901222405574-162648938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; 这里我们要用到截图工具，我用的是&lt;a href=&quot;https://picpick.app/zh/&quot; target=&quot;_blank&quot;&gt;PicPick&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 个人用户免费，我主要用它来测量坐标&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1201453/201809/1201453-20180901222410955-1044140543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 记录下竞技场前往的坐标(1358,504)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1201453/201809/1201453-20180901222416237-1122311475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;记录下竞技场按钮的坐标(1332,650)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;制作回合制脚本首先得要熟悉任务流程&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;然后点击竞技场，走完这个任务流程，依次记录按钮的坐标&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;竞技场任务一天可以做五次，我们对步骤循环五次&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;战斗时间我们需要自己来计时，不同门派，土豪或者平民玩家时间都不一样&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我是平民玩家，大概耗时60s，点击过挑战让代码延迟60s再继续执行&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1201453/201809/1201453-20180901222448326-720592957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;复制代码，运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
#coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;

import autopy

import time

import win32api

import win32con

#竞技场

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #alt键位码是18

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #tab键位码是9

time.sleep(&lt;/span&gt;&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;)

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #enter键位码是13

 

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) #释放按键

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

time.sleep(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)

 

def mousemove_click(x,y):

    autopy.mouse.smooth_move(x, y)

    autopy.mouse.click()

 

mousemove_click(&lt;/span&gt;&lt;span&gt;771&lt;/span&gt;, &lt;span&gt;203&lt;/span&gt;&lt;span&gt;)  # 活动的坐标

 

mousemove_click(&lt;/span&gt;&lt;span&gt;1358&lt;/span&gt;,&lt;span&gt;504&lt;/span&gt;)  # 竞技场&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;前往&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;的坐标

 

time.sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;)#从天墉城城中心/&lt;span&gt;其他地图走到竞技使者花费20s

 

mousemove_click(&lt;/span&gt;&lt;span&gt;1334&lt;/span&gt;, &lt;span&gt;650&lt;/span&gt;&lt;span&gt;)  # 竞技使者对话框中的竞技场的坐标

 

 

#挑战完毕会出现对话窗口

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;):

    mousemove_click(&lt;/span&gt;&lt;span&gt;664&lt;/span&gt;,&lt;span&gt;706&lt;/span&gt;&lt;span&gt;) #挑战试炼童子

 

    mousemove_click(&lt;/span&gt;&lt;span&gt;1082&lt;/span&gt;,&lt;span&gt;578&lt;/span&gt;&lt;span&gt;) #确认

 

    mousemove_click(&lt;/span&gt;&lt;span&gt;1530&lt;/span&gt;, &lt;span&gt;794&lt;/span&gt;&lt;span&gt;)  # 战斗自动

 

    time.sleep(&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;)#挑战试炼童子预计60s
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 align=&quot;left&quot;&gt; 效果如下：&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1201453/201809/1201453-20180901222007369-1205355222.gif&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;349&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下一集将介绍如何实现队长模式刷道(自动组队，自动跑环接任务)&lt;/p&gt;

</description>
<pubDate>Sat, 01 Sep 2018 14:29:00 +0000</pubDate>
<dc:creator>Rest探路者</dc:creator>
<og:description>引入： 每次玩回合制游戏的时候，反反复复的日常任务让人不胜其烦 玩问道的时候，我们希望能够自动刷道，玩梦幻希望能自动做师门、捉鬼等等 说明： 该外挂只能模拟鼠标键盘操作，并不能修改游戏数据 我这里使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java-Starter/p/9571919.html</dc:identifier>
</item>
</channel>
</rss>