<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MySQL InnoDB 日志管理机制中的MTR和日志刷盘 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/10010529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/10010529.html</guid>
<description>&lt;h3&gt;1.MTR(mini-transaction) &lt;/h3&gt;
&lt;p&gt;在MySQL的 InnoDB日志管理机制中，有一个很重要的概念就是MTR。MTR是InnoDB存储擎中一个很重要的用来保证物理写的完整性和持久性的机制。&lt;/p&gt;
&lt;p&gt;先看下MTR在MysQL架构中的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181123235754657-1140734051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MTR是上面的逻辑层与下面物理层的交互窗口，同时也是用来保证下层物理数据正确性、完整性及持久性的机制。&lt;/p&gt;

&lt;h3&gt;2.日志刷盘的触发条件&lt;/h3&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;触发条件&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;线程默认每秒刷新一次。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;空间&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Log Buffer空间用完了&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;Check Point&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;&lt;span&gt;checkPoint的时机较多，既有空间触发也有时间触发。主要分为 &lt;/span&gt;
&lt;p&gt;&lt;span&gt;Sharp Checkpoint和Fuzzy Checkpoint&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;强一致事务要求&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;根据参数innodb_flush_log_at_trx_commit值不同，产生不同的行为。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;3. innodb_flush_log_at_trx_commit简单介绍&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181124010429280-1341356803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参数解释&lt;/p&gt;
&lt;p&gt;（部分内容个人理解，特别是我将log file 分为os cache 和 磁盘2种，更多内容还要求证。 ）&lt;/p&gt;
&lt;p&gt;0：每次事务提交时，根本不会去刷日志缓冲区。log buffer将每秒一次地写入到OS cache的log file中，并且log file的flush(刷到磁盘)上的Log Files操作同时进行。&lt;/p&gt;
&lt;p&gt;1：每次事务提交时MySQL都会把log buffer的数据写入到OS cache的log file，并且flush(刷到磁盘)Log Files中去，该模式为系统默认。&lt;/p&gt;
&lt;p&gt;2：每次事务提交时MySQL都会把log buffer的数据写入到OS cache的log file，但是flush(刷到磁盘)Log Files的操作并不会同时进行。该模式下，MySQL会每秒执行一次 flush(刷到磁盘)操作。&lt;/p&gt;
&lt;p&gt;注意事项&lt;/p&gt;
&lt;p&gt;当设置为0，该模式速度最快，但不太安全，这种设置是最危险的。如果此时运气不好，mysqld进程的崩溃，那么对数据库最新的更新都会丢失，即使事务已经提交了。但一般丢失的数据都是在一秒内产生的。&lt;/p&gt;
&lt;p&gt;当设置为1，该模式是最安全的，但也是最慢的一种方式。在mysqld 服务崩溃或者服务器主机crash的情况下，binary log 只有可能丢失最多一个语句或者一个事务。&lt;br/&gt;当设置为2，该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。&lt;/p&gt;
&lt;p&gt; 此参数可根据业务的可靠性要求进行调整，参数的选择对性能影响较大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;部分内容观点来自同行的分享，在此一并感谢！！！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 17:35:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>1.MTR(mini-transaction) 在MySQL的 InnoDB日志管理机制中，有一个很重要的概念就是MTR。MTR是InnoDB存储擎中一个很重要的用来保证物理写的完整性和持久性的机制。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/10010529.html</dc:identifier>
</item>
<item>
<title>sau交流学习社区--songEagle开发系列：Vue.js + Koa.js项目中使用JWT认证 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/10010303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/10010303.html</guid>
<description>&lt;h3&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;
&lt;h3&gt;JWT(JSON Web Token)，是为了在网络环境间传递声明而执行的一种基于JSON的开放标准（RFC 7519）。&lt;/h3&gt;
&lt;p&gt;JWT不是一个新鲜的东西，网上相关的介绍已经非常多了。不是很了解的可以在网上搜索一下相关信息。&lt;/p&gt;
&lt;p&gt;同步&lt;a href=&quot;https://www.mwcxs.top/page/454.html&quot; target=&quot;_blank&quot;&gt;sau交流学习社区：https://www.mwcxs.top/page/454.html&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;二、源码&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/saucxs/songEagle_backManage&quot; target=&quot;_blank&quot;&gt;Talk is cheap. Show me the code.&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;三、工作流程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;JWT本质来说是一个token。在前后端进行HTTP连接时来进行相应的验证。&lt;/p&gt;
&lt;p&gt;1. 博客的后台管理系统发起登录请求，后端服务器校验成功之后，生成JWT认证信息；&lt;/p&gt;
&lt;p&gt;2. 前端接收到JWT后进行存储；&lt;/p&gt;
&lt;p&gt;3. 前端在之后每次接口调用发起HTTP请求时，会将JWT放到HTTP的headers参数里的authorization中一起发送给后端；&lt;/p&gt;
&lt;p&gt;4. 后端接收到请求时会根据JWT中的信息来校验当前发起HTTP请求的用户是否是具有访问权限的，有访问权限时则交给服务器继续处理，没有时则直接返回401错误。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;四、实现过程&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;1. 登录成功生成JWT&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;说明：以下代码只保留了核心代码，详细代码可在对应文件中查看，下同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; /server/api/admin/admin.controller.js&lt;/span&gt;
const jwt = require('jsonwebtoken'&lt;span&gt;);
const config &lt;/span&gt;= require('../../config/config'&lt;span&gt;);

exports.login &lt;/span&gt;= async(ctx) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (hashedPassword ===&lt;span&gt; hashPassword) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户token&lt;/span&gt;
    const userToken =&lt;span&gt; {
      name: userName,
      id: results[&lt;/span&gt;0&lt;span&gt;].id
    };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 签发token&lt;/span&gt;
    const token = jwt.sign(userToken, config.tokenSecret, { expiresIn: '2h'&lt;span&gt; });
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2. 添加中间件校验JWT、&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; /server/middlreware/tokenError.js&lt;/span&gt;
const jwt = require('jsonwebtoken'&lt;span&gt;);
const config &lt;/span&gt;= require('../config/config'&lt;span&gt;);
const util &lt;/span&gt;= require('util'&lt;span&gt;);
const verify &lt;/span&gt;=&lt;span&gt; util.promisify(jwt.verify);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 判断token是否可用
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
module.exports &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ctx, next) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取jwt&lt;/span&gt;
      const token =&lt;span&gt; ctx.header.authorization; 
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (token) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解密payload，获取用户名和ID&lt;/span&gt;
          let payload = await verify(token.split(' ')[1&lt;span&gt;], config.tokenSecret);
          ctx.user &lt;/span&gt;=&lt;span&gt; {
            name: payload.name,
            id: payload.id
          };
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (err) {
          console.log(&lt;/span&gt;'token verify fail: '&lt;span&gt;, err)
        }
      }
      await next();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (err) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err.status === 401&lt;span&gt;) {
        ctx.status &lt;/span&gt;= 401&lt;span&gt;;
        ctx.body &lt;/span&gt;=&lt;span&gt; {
          success: &lt;/span&gt;0&lt;span&gt;,
          message: &lt;/span&gt;'认证失败'&lt;span&gt;
        };
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        err.status &lt;/span&gt;= 404&lt;span&gt;;
        ctx.body &lt;/span&gt;=&lt;span&gt; {
          success: &lt;/span&gt;0&lt;span&gt;,
          message: &lt;/span&gt;'404'&lt;span&gt;
        };
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3. Koa.js中添加JWT处理&lt;/h4&gt;
&lt;p&gt;此处在开发时需要过滤掉登录接口(login)，否则会导致JWT验证永远失败。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; /server/config/koa.js&lt;/span&gt;
const jwt = require('koa-jwt'&lt;span&gt;);
const tokenError &lt;/span&gt;= require('../middlreware/tokenError'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;
const app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Koa();

app.use(tokenError());
app.use(bodyParser());
app.use(koaJson());
app.use(resource(path.join(config.root, config.appPath)));

app.use(jwt({
  secret: config.tokenSecret
}).unless({
  path: [&lt;/span&gt;/^\/backapi\/admin\/login/, /^\/blogapi\//&lt;span&gt;]
}));

module.exports &lt;/span&gt;= app;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.前端处理&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;前端开发使用的是Vue.js，发送HTTP请求使用的是axios。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1. 登录成功之后将JWT存储到localStorage中（可根据个人需要存储，我个人是比较喜欢存储到localStorage中）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; methods: {
       login: async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
         let res = await api.login(&lt;span&gt;this&lt;/span&gt;.userName, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.password);
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res.success === 1&lt;span&gt;) {
           &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.errMsg = ''&lt;span&gt;;
           localStorage.setItem(&lt;/span&gt;'SONG_EAGLE_TOKEN'&lt;span&gt;, res.token);
           &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$router.push({ path: '/postlist'&lt;span&gt; });
         } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
           &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.errMsg =&lt;span&gt; res.message;
         }
       }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2. Vue.js的router（路由）跳转前校验JWT是否存在，不存在则跳转到登录页面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; /src/router/index.js&lt;/span&gt;
   router.beforeEach((to, from, next) =&amp;gt;&lt;span&gt; {
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (to.meta.requireAuth) {
       const token &lt;/span&gt;= localStorage.getItem('SONG_EAGLE_TOKEN'&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (token &amp;amp;&amp;amp; token !== 'null'&lt;span&gt;) {
         next();
       } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
         next(&lt;/span&gt;'/login'&lt;span&gt;);
       }
     } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
       next();
     }
   });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3. axios拦截器中给HTTP统一添加Authorization信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; /src/api/config.js&lt;/span&gt;
&lt;span&gt;   axios.interceptors.request.use(
     config &lt;/span&gt;=&amp;gt;&lt;span&gt; {
       const token &lt;/span&gt;= localStorage.getItem('SONG_EAGLE_TOKEN'&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (token) {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Bearer是JWT的认证头部信息&lt;/span&gt;
         config.headers.common['Authorization'] = 'Bearer ' +&lt;span&gt; token;
       }
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; config;
     },
     error &lt;/span&gt;=&amp;gt;&lt;span&gt; {
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Promise.reject(error);
     }
   );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4. axios拦截器在接收到HTTP返回时统一处理返回状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; /src/main.js&lt;/span&gt;
&lt;span&gt;   axios.interceptors.response.use(
     response &lt;/span&gt;=&amp;gt;&lt;span&gt; {
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response;
     },
     error &lt;/span&gt;=&amp;gt;&lt;span&gt; {
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (error.response.status === 401&lt;span&gt;) {
         Vue.prototype.$msgBox.showMsgBox({
           title: &lt;/span&gt;'错误提示'&lt;span&gt;,
           content: &lt;/span&gt;'您的登录信息已失效，请重新登录'&lt;span&gt;,
           isShowCancelBtn: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
         }).then((val) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
           router.push(&lt;/span&gt;'/login'&lt;span&gt;);
         }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(() =&amp;gt;&lt;span&gt; {
           console.log(&lt;/span&gt;'cancel'&lt;span&gt;);
         });
       } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
         Vue.prototype.$message.showMessage({
           type: &lt;/span&gt;'error'&lt;span&gt;,
           content: &lt;/span&gt;'系统出现错误'&lt;span&gt;
         });
       }
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Promise.reject(error);
     }
   );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这个基本上就是JWT的流程。当然单纯的JWT并不是说绝对安全的，不过对于一个个人博客系统的认证来说还是足够的。&lt;/p&gt;
&lt;p&gt;最后打个小广告。目前正在开发新版的个人博客中，包括两部分：&lt;/p&gt;
&lt;p&gt;【前端】(&lt;a href=&quot;https://github.com/saucxs/songEagle&quot; target=&quot;_blank&quot;&gt;https://github.com/saucxs/songEagle&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;【后端】(&lt;a href=&quot;https://github.com/saucxs/songEagle_backManage&quot; target=&quot;_blank&quot;&gt;https://github.com/saucxs/songEagle_backManage&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;都已在GitHub上开源，目前在逐步完善功能中。欢迎感兴趣的同学fork和star。&lt;/p&gt;

</description>
<pubDate>Fri, 23 Nov 2018 15:53:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>一、前言 JWT(JSON Web Token)，是为了在网络环境间传递声明而执行的一种基于JSON的开放标准（RFC 7519）。 JWT不是一个新鲜的东西，网上相关的介绍已经非常多了。不是很了解的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/10010303.html</dc:identifier>
</item>
<item>
<title>系统学习 Java IO (三)----FileInputStream/FileOutputStream &amp; RandomAccessFile - czwbig</title>
<link>http://www.cnblogs.com/czwbig/p/10010293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/czwbig/p/10010293.html</guid>
<description>&lt;p&gt;目录：&lt;a href=&quot;https://www.cnblogs.com/czwbig/p/10007201.html&quot;&gt;系统学习 Java IO---- 目录，概览&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;fileinputstream&quot;&gt;FileInputStream&lt;/h3&gt;
&lt;p&gt;这是一个简单的FileInputStream示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;InputStream input = new FileInputStream(&quot;D:\\input.txt&quot;);
int data = input.read();
while(data != -1) {
  //do something with data...
  doSomethingWithData(data);
  data = input.read();
}
input.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：为了代码清晰，这里并没有考虑处理异常的情况，IO 异常处理有专门的介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;fileinputstream-构造器&quot;&gt;FileInputStream 构造器&lt;/h5&gt;
&lt;p&gt;FileInputStream 类有三个不同的构造函数，可用于创建 FileInputStream 实例。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构造函数将一个包含文件系统中要读取的文件所在的路径 String 作为参数：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String path = &quot;D:\\.txt&quot;;
FileInputStream fileInputStream = new FileInputStream(path);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意路径需要双反斜杠&lt;code&gt;\\&lt;/code&gt;,因为反斜杠是Java字符串中的转义字符。 要获得单个反斜杠，需要使用转义序列\。&lt;br/&gt;在unix上，文件路径可能如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String path = &quot;/home/czwbig/data/thefile.txt&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意使用正斜杠&lt;code&gt;/&lt;/code&gt;作为目录分隔符。 这是在 unix 上编写文件路径的方法。 实际上，Java 也会理解在 Windows 上使用&lt;code&gt;/&lt;/code&gt;作为目录分隔符,例如&lt;code&gt;new FileInputStream(&quot;D:/out.txt&quot;)&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构造函数将 File 对象作为参数。 File 对象必须指向要读取的文件。 这是一个例子：&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String path = &quot;D:\\out.txt&quot;;
File   file = new File(path);
FileInputStream fileInputStream = new FileInputStream(file);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应该使用哪个构造函数取决于在打开 FileInputStream 之前具有该路径的形式。 如果您已经有一个 String 或 File ，只需按原样使用它。 将 String 转换为 File 或将 File 转换为 String 没有特别的好处。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;public FileInputStream(FileDescriptor fdObj)&lt;br/&gt;通过使用文件描述符 fdObj 创建一个 FileInputStream，该文件描述符表示到文件系统中某个实际文件的现有连接。不常用。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;readbyte&quot;&gt;read(byte[])&lt;/h5&gt;
&lt;p&gt;作为 InputStream 的子类，FileInputStream 还有两个read（）方法，可以将数据读入字节数组。 可以在我的有关 InputStream 的文章中阅读，不展开了。&lt;/p&gt;
&lt;h5 id=&quot;close-统一在-java-io-异常处理讲解了&quot;&gt;close() 统一在 Java IO 异常处理讲解了&lt;/h5&gt;
&lt;hr/&gt;&lt;h3 id=&quot;fileoutputstream&quot;&gt;FileOutputStream&lt;/h3&gt;
&lt;p&gt;这是一个简单的FileOutputStream示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;OutputStream output = new FileOutputStream(&quot;D:\\out.txt&quot;);
while(moreData) {
  int data = getMoreData();
  output.write(data);
}
output.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;fileoutputstream-构造器&quot;&gt;FileOutputStream 构造器&lt;/h5&gt;
&lt;p&gt;和 FileInputStream 的3个构造器差不多，参考上面即可。&lt;br/&gt;另外多了两个构造方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FileOutputStream(File file, boolean append) ;&lt;/li&gt;
&lt;li&gt;FileOutputStream(String name, boolean append) ;&lt;br/&gt;参数 append - 如果为 true，则将字节写入文件末尾处，而不是写入文件开始处，这样就能不覆盖文件，而是追加内容。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;write...-flush&quot;&gt;write(...); flush()&lt;/h5&gt;
&lt;p&gt;参考 OutputStream 。&lt;/p&gt;
&lt;h3 id=&quot;randomaccessfile&quot;&gt;RandomAccessFile&lt;/h3&gt;
&lt;p&gt;这里的随机访问是指，随便指定一个位置，访问它；而不是随便访问一个位置。&lt;br/&gt;在使用RandomAccessFile类之前，必须实例化它。它有两个构造器，如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RandomAccessFile(File file, String mode)&lt;/li&gt;
&lt;li&gt;RandomAccessFile(String name, String mode)&lt;br/&gt;实例：&lt;br/&gt;&lt;code&gt;RandomAccessFile file = new RandomAccessFile(&quot;c:\\data\\file.txt&quot;, &quot;rw&quot;);&lt;/code&gt;&lt;br/&gt;参数：&lt;br/&gt;file、name- 该文件对象&lt;br/&gt;mode - 访问模式，如下表：&lt;/li&gt;
&lt;/ol&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&quot;r&quot;&lt;/td&gt;
&lt;td&gt;以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&quot;rw&quot;&lt;/td&gt;
&lt;td&gt;打开以便读取和写入。如果该文件尚不存在，则尝试创建该文件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&quot;rws&quot;&lt;/td&gt;
&lt;td&gt;&quot;rw&quot; + “sync”，另外还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&quot;rwd&quot;&lt;/td&gt;
&lt;td&gt;&quot;rw&quot; + “data”，另外还要求对文件内容的每个更新都同步写入到底层存储设备。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;rwd-模式&quot;&gt;&quot;rwd&quot; 模式&lt;/h5&gt;
&lt;p&gt;可用于减少执行的 I/O 操作数量.使用 &quot;rwd&quot; 仅要求更新要写入存储的文件的内容；使用 &quot;rws&quot; 要求更新要写入的文件内容及其元数据，这通常要求至少一个以上的低级别 I/O 操作。&lt;/p&gt;
&lt;h5 id=&quot;rws-和-rwd-模式&quot;&gt;&quot;rws&quot; 和 &quot;rwd&quot; 模式&lt;/h5&gt;
&lt;p&gt;如果该文件位于本地存储设备上，那么当返回此类的一个方法的调用时，可以保证由该调用对此文件所做的所有更改均被写入该设备。这对确保在系统崩溃时不会丢失重要信息特别有用。如果该文件不在本地设备上，则无法提供这样的保证。&lt;/p&gt;
&lt;h5 id=&quot;使用-randomaccessfile-在文件中跳转&quot;&gt;使用 RandomAccessFile 在文件中跳转&lt;/h5&gt;
&lt;p&gt;要在 RandomAccessFile 中的特定位置读取或写入，必须首先将文件指针放在要读取或写入的位置。 这是使用 seek() 方法完成的。 可以通过调用 getFilePointer() 方法获取文件指针的当前位置。&lt;br/&gt;read() 方法将文件指针递增为指向刚刚读取的字节后文件中的下一个字节！ 这意味着您可以继续调用 read() 而无需手动移动文件指针。&lt;br/&gt;看如下例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class RandomAccessFileExample {
    public static void main(String[] args) throws IOException {
        // out.txt 此时的文件内容为 &quot;123456789&quot;
        RandomAccessFile file = new RandomAccessFile(&quot;D:\\out.txt&quot;, &quot;rw&quot;);

        System.out.println(&quot;pointer: &quot; + file.getFilePointer()); // 输出 pointer: 0
        System.out.println(&quot;char: &quot; + (char) file.read()); // 输出 char: 1
        System.out.println(&quot;pointer: &quot; + file.getFilePointer()); // 输出 pointer: 1

        file.seek(4); // 下标从 0 开始的，让其指向第 5 个字节

        System.out.println(&quot;pointer: &quot; + file.getFilePointer()); // 输出 pointer: 4
        System.out.println(&quot;char: &quot; + (char) file.read()); // 输出 char: 5
        System.out.println(&quot;pointer: &quot; + file.getFilePointer()); // 输出 pointer: 5
        file.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;read-write&quot;&gt;read &amp;amp; write&lt;/h5&gt;
&lt;p&gt;从 RandomAccessFile 读取是使用其众多 read() 方法之一完成的。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;read(byte[] b)&lt;/td&gt;
&lt;td&gt;将最多 b.length 个数据字节从此文件读入 byte 数组。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;readByte()&lt;/td&gt;
&lt;td&gt;从此文件读取一个有符号的八位值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;readChar()&lt;/td&gt;
&lt;td&gt;从此文件读取一个字符。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;readFully(byte[] b)&lt;/td&gt;
&lt;td&gt;将 b.length 个字节从此文件读入 byte 数组，并从当前文件指针开始。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;readLine()&lt;/td&gt;
&lt;td&gt;从此文件读取文本的下一行。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;skipBytes(int n)&lt;/td&gt;
&lt;td&gt;尝试跳过输入的 n 个字节以丢弃跳过的字节。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;setLength(long newLength)&lt;/td&gt;
&lt;td&gt;设置此文件的长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;writeChars(String s)&lt;/td&gt;
&lt;td&gt;按字符序列将一个字符串写入该文件。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Fri, 23 Nov 2018 15:50:00 +0000</pubDate>
<dc:creator>czwbig</dc:creator>
<og:description>目录：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/czwbig/p/10010293.html</dc:identifier>
</item>
<item>
<title>struts2流程及源码分析 - Autom_liu</title>
<link>http://www.cnblogs.com/autom/p/10010214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/autom/p/10010214.html</guid>
<description>&lt;h2 id=&quot;struts-架构图&quot;&gt;struts 架构图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21289/WEBRESOURCEece083a85543cc5f31bb90d300082fb4&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析这个架构图，我们可以从4个部分，也就struts访问的4个阶段的流程来分析&lt;/p&gt;
&lt;p&gt;这4个阶段包括：Action映射、Action转发、Action执行、结果返回&lt;/p&gt;
&lt;p&gt;首先是Action映射阶段&lt;/p&gt;
&lt;p&gt;当请求到来的时候，首先是struts的核心过滤器接收到请求，然后通过ActionMapper进行映射&lt;/p&gt;
&lt;p&gt;我们以下图struts配置为例，查看一下struts在处理这个请求阶段的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21339/WEBRESOURCEe9f401582aab142a0d693be0141bf121&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;StrutsPrepareAndExecuteFilter&lt;/code&gt;源码中，它本质是一个过滤器，核心的代码在&lt;code&gt;doFilter&lt;/code&gt;部分，我们把这部分代码copy过来如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        try {
            if (excludedPatterns != null &amp;amp;&amp;amp; prepare.isUrlExcluded(request, excludedPatterns)) {
                chain.doFilter(request, response);
            } else {
                prepare.setEncodingAndLocale(request, response);
                prepare.createActionContext(request, response);
                prepare.assignDispatcherToThread();
                request = prepare.wrapRequest(request);
                ActionMapping mapping = prepare.findActionMapping(request, response, true);
                if (mapping == null) {
                    boolean handled = execute.executeStaticResourceRequest(request, response);
                    if (!handled) {
                        chain.doFilter(request, response);
                    }
                } else {
                    execute.executeAction(request, response, mapping);
                }
            }
        } finally {
            prepare.cleanupRequest(request);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;判断是否需要struts处理&quot;&gt;判断是否需要struts处理&lt;/h3&gt;
&lt;p&gt;当请求过来的时候，首先判断是否应该由struts处理这个请求，如果不是那就应该放行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21350/WEBRESOURCE6a01c478e0836d255ea9c6c77c713a99&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们这个请求肯定是要经过struts处理的，所以应该走else部分：&lt;/p&gt;
&lt;h3 id=&quot;创建数据中心actioncontext&quot;&gt;创建数据中心ActionContext&lt;/h3&gt;
&lt;p&gt;接下来需要关注的是这行&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;prepare.createActionContext(request, response);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是干什么呢？从名字上看，就是在创建一个ActionContext数据中心&lt;/p&gt;
&lt;p&gt;还记得吗？这个就是那个包含原生servlet 11个域对象还有值栈的一个大容器（本质上就是map）&lt;/p&gt;
&lt;p&gt;可以进去看下这部分的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Creates the action context and initializes the thread local
 */
public ActionContext createActionContext(HttpServletRequest request, HttpServletResponse response) {
    ActionContext ctx;
    Integer counter = 1;
    Integer oldCounter = (Integer) request.getAttribute(CLEANUP_RECURSION_COUNTER);
    if (oldCounter != null) {
        counter = oldCounter + 1;
    }
    
    ActionContext oldContext = ActionContext.getContext();
    if (oldContext != null) {
        // detected existing context, so we are probably in a forward
        ctx = new ActionContext(new HashMap&amp;lt;String, Object&amp;gt;(oldContext.getContextMap()));
    } else {
        ValueStack stack = dispatcher.getContainer().getInstance(ValueStackFactory.class).createValueStack();
        stack.getContext().putAll(dispatcher.createContextMap(request, response, null));
        ctx = new ActionContext(stack.getContext());
    }
    request.setAttribute(CLEANUP_RECURSION_COUNTER, counter);
    ActionContext.setContext(ctx);
    return ctx;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在初始化阶段，关键在这里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21365/WEBRESOURCEf167d35cd9aff9f0547c672989b82e36&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这三行代码，简单来看，第一步就是创建值栈，第二步就是往Context中准备一些数据&lt;/p&gt;
&lt;p&gt;最后看第三步，可以看到ActionContext这个数据中心实际上就是ValueStack的Context&lt;/p&gt;
&lt;h3 id=&quot;增强包装request对象&quot;&gt;增强包装request对象&lt;/h3&gt;
&lt;p&gt;接下来关注的是91行的这句：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21375/WEBRESOURCE65a04b50a30a15efdc40a4223053c3f5&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在还没运行阶段，这个request还是原生的&lt;code&gt;org.apache.catalina.connector.RequestFacade&lt;/code&gt;类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21377/WEBRESOURCE145c1e6b20f936ed0d5c205094d441d3&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行完后就变成了&lt;code&gt;org.apache.struts2.dispatcher.StrutsRequestWrapper&lt;/code&gt;类型了，这个就是由struts包装的request对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21382/WEBRESOURCEd5715734693e3ca84fe4d03fb41b3670&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那struts包装是做了哪些事情呢，可以勘测一下&lt;code&gt;StrutsRequestWrapper&lt;/code&gt;源码&lt;/p&gt;
&lt;p&gt;其实它就包装（增强）了一个方法&lt;code&gt;getAttribute&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以看下这部分的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Gets the object, looking in the value stack if not found
 *
 * @param key The attribute key
 */
public Object getAttribute(String key) {
    if (key == null) {
        throw new NullPointerException(&quot;You must specify a key value&quot;);
    }

    if (disableRequestAttributeValueStackLookup || key.startsWith(&quot;javax.servlet&quot;)) {
        // don't bother with the standard javax.servlet attributes, we can short-circuit this
        // see WW-953 and the forums post linked in that issue for more info
        return super.getAttribute(key);
    }

    ActionContext ctx = ActionContext.getContext();
    Object attribute = super.getAttribute(key);

    if (ctx != null &amp;amp;&amp;amp; attribute == null) {
        boolean alreadyIn = isTrue((Boolean) ctx.get(REQUEST_WRAPPER_GET_ATTRIBUTE));

        // note: we don't let # come through or else a request for
        // #attr.foo or #request.foo could cause an endless loop
        if (!alreadyIn &amp;amp;&amp;amp; !key.contains(&quot;#&quot;)) {
            try {
                // If not found, then try the ValueStack
                ctx.put(REQUEST_WRAPPER_GET_ATTRIBUTE, Boolean.TRUE);
                ValueStack stack = ctx.getValueStack();
                if (stack != null) {
                    attribute = stack.findValue(key);
                }
            } finally {
                ctx.put(REQUEST_WRAPPER_GET_ATTRIBUTE, Boolean.FALSE);
            }
        }
    }
    return attribute;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内容很长，但简单来说就是注释上的那么一句话：&lt;/p&gt;
&lt;p&gt;Gets the object, looking in the value stack if not found&lt;/p&gt;
&lt;p&gt;翻译过来那就是：这个方法会先从原生request域中去找，如果找不到的话，就会往值栈中去找&lt;/p&gt;
&lt;p&gt;前面说过ValueStack包含两个部分，一个是ROOT栈部分，一个是context部分（从源码上来看，这个部分就是ActionContext）。&lt;/p&gt;
&lt;p&gt;那么拆解开来看，我们可以得到以下结论：&lt;/p&gt;
&lt;p&gt;当我们在struts中调用原生的request.getAttribute()方法时：struts会帮我们从以下几个域中依次寻找属性&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;原生request域&lt;/li&gt;
&lt;li&gt;ValueStack的栈部分&lt;/li&gt;
&lt;li&gt;ValueStack的context部分（ActionContext）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们看一下源码当中这个过程的体现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21410/WEBRESOURCEd327d5fdaedbc5a352c5e0dd35c607dd&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显这一步就是从request域中去找，如果找不到就往下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21413/WEBRESOURCE957bb7b280144c435d82d854edcdfdd0&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的那段注释告诉我们，使用request来寻找ActionContext内容是不需要和OGNL表达式一样带#来访问的，并且也不允许（否则会陷入死循环）&lt;/p&gt;
&lt;p&gt;简单来说，原生的怎么写就怎么写，不需要管里边的具体实现&lt;/p&gt;
&lt;h3 id=&quot;actionmapping&quot;&gt;ActionMapping&lt;/h3&gt;
&lt;p&gt;最后它要做的操作就是把请求转换为ActionMapping对象，好方便接下来后期处理，&lt;/p&gt;
&lt;p&gt;这个过程简单来说就是把我们访问的url地址&lt;/p&gt;
&lt;p&gt;http://localhost/strutsLearn/customer/list&lt;/p&gt;
&lt;p&gt;解析成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ActionMapping{name='list', namespace='/customer', method='null', extension='null', params=null, result=null}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种形式的对象&lt;/p&gt;
&lt;p&gt;上面的形式是可以解析出来的情况，但是我们知道每一次请求也肯定有很多静态资源文件，这些都是struts解析不了的，这时候mapping得到的结果就为&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21433/WEBRESOURCE3b3a46d7a807637536b73d73444351eb&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，也就是我们第一阶段所要完成的任务了，就是通过ActionMapper工具获取ActionMapping对象。&lt;/p&gt;
&lt;p&gt;那么再往下，就是把ActionMapping交给下一个阶段往下执行了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;execute.executeAction(request, response, mapping);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;核心代理转发阶段创建actionproxy&quot;&gt;核心代理转发阶段——创建ActionProxy&lt;/h3&gt;
&lt;p&gt;这个方法只是一个中间方法，它再具体调用下一个&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dispatcher.serviceAction(request, response, mapping);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，关键部分是try catch语句中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;try {
    UtilTimerStack.push(timerKey);
    String namespace = mapping.getNamespace();
    String name = mapping.getName();
    String method = mapping.getMethod();

    ActionProxy proxy = getContainer().getInstance(ActionProxyFactory.class).createActionProxy(
            namespace, name, method, extraContext, true, false);

    request.setAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY, proxy.getInvocation().getStack());

    // if the ActionMapping says to go straight to a result, do it!
    if (mapping.getResult() != null) {
        Result result = mapping.getResult();
        result.execute(proxy.getInvocation());
    } else {
        proxy.execute();
    }

    // If there was a previous value stack then set it back onto the request
    if (!nullStack) {
        request.setAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY, stack);
    }
} catch (ConfigurationException e) {
    logConfigurationException(request, e);
    sendError(request, response, HttpServletResponse.SC_NOT_FOUND, e);
} catch (Exception e) {
    if (handleException || devMode) {
        sendError(request, response, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e);
    } else {
        throw new ServletException(e);
    }
} finally {
    UtilTimerStack.pop(timerKey);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先是提取ActionMapping中的各种信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21447/WEBRESOURCEf86c2fe8559090941121bd0c3d293a45&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就是创建ActionProxy对象了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ActionProxy proxy = getContainer().getInstance(ActionProxyFactory.class).createActionProxy(
namespace, name, method, extraContext, true, false);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里如果深入去看proxy创建过程，其实就包含了根据actionMapping的信息去寻找配置文件struts.xml配置项的过程。这里就不再展开了。&lt;/p&gt;
&lt;p&gt;可以看下ActionProxy大概长啥样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21454/WEBRESOURCE9b7ba7d0b40cd1449f9657674ae2bd02&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么创建出来后就需要分派给人去执行了，但是执行分两种情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21458/WEBRESOURCEaf828ec35310a68bd247402f939cd2d7&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两种其实都一样，我们这里是第一次初始访问，没有结果返回，因此直接进入的是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;proxy.execute();&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public String execute() throws Exception {
    ActionContext previous = ActionContext.getContext();
    ActionContext.setContext(invocation.getInvocationContext());
    try {
// This is for the new API:
//            return RequestContextImpl.callInContext(invocation, new Callable&amp;lt;String&amp;gt;() {
//                public String call() throws Exception {
//                    return invocation.invoke();
//                }
//            });

        return invocation.invoke();
    } finally {
        if (cleanupContext)
            ActionContext.setContext(previous);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法里，即将进入的就是 invoke 方法了！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;return invocation.invoke();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;action执行阶段拦截器执行&quot;&gt;Action执行阶段——拦截器执行&lt;/h3&gt;
&lt;p&gt;调用这个方法，也就意味着进入第三阶段——Aciton执行阶段了&lt;/p&gt;
&lt;p&gt;在这个阶段，我们知道它即将进入执行N多个拦截器，我们进入看看它里面的关键代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (interceptors.hasNext()) {
    final InterceptorMapping interceptor = interceptors.next();
    String interceptorMsg = &quot;interceptor: &quot; + interceptor.getName();
    UtilTimerStack.push(interceptorMsg);
    try {
        resultCode = interceptor.getInterceptor().intercept(DefaultActionInvocation.this);
    }
    finally {
        UtilTimerStack.pop(interceptorMsg);
    }
} else {
    resultCode = invokeActionOnly();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中interceptors被定义成拦截器容器的迭代器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected Iterator&amp;lt;InterceptorMapping&amp;gt; interceptors;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个拦截器容器就是Proxy阶段传过来的&lt;/p&gt;
&lt;p&gt;这其中一行代码第一眼看上去确实让人奇怪：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (interceptors.hasNext())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常对迭代器的循环应该是while这里为什么变成if 呢&lt;/p&gt;
&lt;p&gt;先不管，继续往下看：&lt;/p&gt;
&lt;p&gt;首先是获取拦截器容器中的拦截器和拦截器名称：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final InterceptorMapping interceptor = interceptors.next();
String interceptorMsg = &quot;interceptor: &quot; + interceptor.getName();
UtilTimerStack.push(interceptorMsg);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个拦截器的类型是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21497/WEBRESOURCEa782d0aff0f61f2e434eff718325bf7f&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Exception拦截器&lt;/p&gt;
&lt;p&gt;和struts-default配置拦截器栈的第一个拦截器是一样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21501/WEBRESOURCE9424f1c6a4107f9cd83efcb121572855&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，看似真的是要遍历&lt;/p&gt;
&lt;p&gt;接下来断定肯定去执行这个拦截器里的内容&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;resultCode = interceptor.getInterceptor().intercept(DefaultActionInvocation.this);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取到具体的拦截器，调用拦截器的intercept方法，注意到的是这里把this作为参数穿进去了。&lt;/p&gt;
&lt;p&gt;我们看看这里面做了什么&lt;/p&gt;
&lt;p&gt;结果一进来就做了这么一件事情：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;result = invocation.invoke();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候就得出结论了：&lt;/p&gt;
&lt;p&gt;invocation的invoke方法调用interceptor的intercept方法&lt;br/&gt;接着反过来interceptor的intercept方法又调回invocation的invoke方法&lt;/p&gt;
&lt;p&gt;这不就形成了另一种形式的递归吗？&lt;/p&gt;
&lt;p&gt;所以接下来又回到invocation的invoke方法执行&lt;/p&gt;
&lt;p&gt;那个迭代器的结束条件if&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (interceptors.hasNext())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就没什么奇怪了。&lt;/p&gt;
&lt;p&gt;但是为什么要这么设计递归了，普通的遍历不是挺好的吗？接着往下看。&lt;/p&gt;
&lt;p&gt;执行完一轮后，再看拦截器的名字：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21516/WEBRESOURCE5a3ff81b97bb828d621384fcb05072df&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是Exception的下一个拦截器alias&lt;/p&gt;
&lt;p&gt;这个拦截器的invoke方法进行了比较多的复杂处理，但是不管结果如何，最终都会调用：&lt;/p&gt;
&lt;p&gt;return invocation.invoke();&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override public String intercept(ActionInvocation invocation) throws Exception {
    ....... 此处省略n行代码
    return invocation.invoke();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，这下明白了这么设计的用意何在了吧。&lt;/p&gt;
&lt;p&gt;每个拦截器的invoke方法执行的方式不一样，通过这种间接递归的方式就能把所有不同功能的器件全部执行一遍了。&lt;/p&gt;
&lt;p&gt;看完后，不得不说，这种设计的精妙之处啊&lt;/p&gt;
&lt;h3 id=&quot;action执行&quot;&gt;Action执行&lt;/h3&gt;
&lt;p&gt;拦截器执行完成后接下来就到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;resultCode = invokeActionOnly();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只执行Action了&lt;/p&gt;
&lt;p&gt;接下来可以推测，它就是去找到我们自己写的Action中的类去执行去了。&lt;/p&gt;
&lt;p&gt;跳出这个过程，我们可以看到resultCode返回结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21538/WEBRESOURCEda6bd6a8fddb6db6ba693c3b43e052a6&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么可以猜想，接下来就会拿着这个结果根据我们定义的配置文件处理去，也就是进入我们所说的第四阶段了&lt;/p&gt;
&lt;p&gt;接下来就会去执行结果处理函数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// now execute the result, if we're supposed to
if (proxy.getExecuteResult()) {
    executeResult();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，到这里先告一段落，关于后续的结果处理函数后期再补充吧&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 15:26:00 +0000</pubDate>
<dc:creator>Autom_liu</dc:creator>
<og:description>struts 架构图 分析这个架构图，我们可以从4个部分，也就struts访问的4个阶段的流程来分析 这4个阶段包括：Action映射、Action转发、Action执行、结果返回 首先是Action</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/autom/p/10010214.html</dc:identifier>
</item>
<item>
<title>python异常处理 - 张风闲</title>
<link>http://www.cnblogs.com/zhangfengxian/p/python-exception.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangfengxian/p/python-exception.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;异常的概念&quot;&gt;1. 异常的概念&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;程序在运行时，如果 &lt;code&gt;Python 解释器&lt;/code&gt; &lt;strong&gt;遇到&lt;/strong&gt; 到一个错误，&lt;strong&gt;会停止程序的执行，并且提示一些错误信息&lt;/strong&gt;，这就是 &lt;strong&gt;异常&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;程序停止执行并且提示错误信息&lt;/strong&gt; 这个动作，我们通常称之为：&lt;strong&gt;抛出(raise)异常&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;程序开发时，很难将 &lt;strong&gt;所有的特殊情况&lt;/strong&gt; 都处理的面面俱到，通过 &lt;strong&gt;异常捕获&lt;/strong&gt; 可以针对突发事件做集中的处理，从而保证程序的 &lt;strong&gt;稳定性和健壮性&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;捕获异常&quot;&gt;2. 捕获异常&lt;/h2&gt;
&lt;h3 id=&quot;简单的捕获异常语法&quot;&gt;2.1 简单的捕获异常语法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在程序开发中，如果 &lt;strong&gt;对某些代码的执行不能确定是否正确&lt;/strong&gt;，可以增加 &lt;code&gt;try(尝试)&lt;/code&gt; 来 &lt;strong&gt;捕获异常&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;捕获异常最简单的语法格式：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;try:
    尝试执行的代码
except:
    出现错误的处理&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;try&lt;/code&gt; &lt;strong&gt;尝试&lt;/strong&gt;，下方编写要尝试代码，不确定是否能够正常执行的代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;except&lt;/code&gt; &lt;strong&gt;如果不是&lt;/strong&gt;，下方编写尝试失败的代码&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;简单异常捕获演练-要求用户输入整数&quot;&gt;简单异常捕获演练 —— 要求用户输入整数&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;try:
    int(input(&quot;请输入一个整数：&quot;))
except:
    print(&quot;请输入的不是一个整数&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;错误类型捕获&quot;&gt;2.2 错误类型捕获&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在程序执行时，可能会遇到 &lt;strong&gt;不同类型的异常&lt;/strong&gt;，并且需要 &lt;strong&gt;针对不同类型的异常，做出不同的响应&lt;/strong&gt;，这个时候，就需要捕获错误类型了&lt;/li&gt;
&lt;li&gt;语法如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;try:
    # 尝试执行的代码
    pass
except 错误类型1:
    # 针对错误类型1，对应的代码处理
    pass
except (错误类型2, 错误类型3):
    # 针对错误类型2 和 3，对应的代码处理
    pass
except Exception as result:
    print(&quot;未知错误 %s&quot; % result)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;当 &lt;code&gt;Python&lt;/code&gt; 解释器 &lt;strong&gt;抛出异常&lt;/strong&gt; 时，&lt;strong&gt;最后一行错误信息的第一个单词，就是错误类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;异常类型捕获演练-要求用户输入整数&quot;&gt;异常类型捕获演练 —— 要求用户输入整数&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提示用户输入一个整数&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;8&lt;/code&gt; 除以用户输入的整数并且输出&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;try:
    num = int(input(&quot;请输入一个整数：&quot;))

    result = 8 / num
except ValueError:
    print(&quot;请输入正确的整数&quot;)
except ZeroDivisionError:
    print(&quot;除0错误&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;捕获未知错误&quot;&gt;捕获未知错误&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在开发时，&lt;strong&gt;要预判到所有可能出现的错误&lt;/strong&gt;，还是有一定难度的&lt;/li&gt;
&lt;li&gt;如果希望程序 &lt;strong&gt;无论出现任何错误&lt;/strong&gt;，都不会因为 &lt;code&gt;Python&lt;/code&gt; 解释器 &lt;strong&gt;抛出异常而被终止&lt;/strong&gt;，可以再增加一个 &lt;code&gt;except&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;语法如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;except Exception as result:
    print(&quot;未知错误 %s&quot; % result)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异常捕获完整语法&quot;&gt;2.3 异常捕获完整语法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;try:
    # 尝试执行的代码
    pass
except 错误类型1:
    # 针对错误类型1，对应的代码处理
    pass
except 错误类型2:
    # 针对错误类型2，对应的代码处理
    pass
except (错误类型3, 错误类型4):
    # 针对错误类型3 和 4，对应的代码处理
    pass
except Exception as result:
    # 打印错误信息
    print(result)
else:
    # 没有异常才会执行的代码
    pass
finally:
    # 无论是否有异常，都会执行的代码
    print(&quot;无论是否有异常，都会执行的代码&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;else&lt;/code&gt; 只有在没有异常时才会执行的代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finally&lt;/code&gt; 无论是否有异常，都会执行的代码&lt;/li&gt;
&lt;li&gt;之前一个演练的 &lt;strong&gt;完整捕获异常&lt;/strong&gt; 的代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;try:
    num = int(input(&quot;输入一个整数：&quot;))

    result = 8 / num

    print(result)
except ValueError:
    print(&quot;输入正确的整数&quot;)
except ZeroDivisionError:
    print(&quot;除0错误&quot;)
except Exception as result:

    print(&quot;未知错误 %s &quot; % result)

else:
    print(&quot;正常执行&quot;)
finally:
    print(&quot;总是会执行的代码&quot;)

print(&quot;-&quot; * 40)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;异常的传递&quot;&gt;3. 异常的传递&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义函数 &lt;code&gt;demo1()&lt;/code&gt; &lt;strong&gt;提示用户输入一个整数并且返回&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;定义函数 &lt;code&gt;demo2()&lt;/code&gt; 调用 &lt;code&gt;demo1()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在主程序中调用 &lt;code&gt;demo2()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def demo1():
    return int(input(&quot;请输入一个整数:&quot;))


def demo2():
    return demo1()


try:
    print(demo2())
except ValueError:
    print(&quot;输入正确的整数&quot;)
except Exception as result:
    print(&quot;未知错误 %s&quot; % result)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;抛出raise异常&quot;&gt;4. 抛出raise异常&lt;/h2&gt;
&lt;h3 id=&quot;应用场景&quot;&gt;4.1 应用场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在开发中，除了 &lt;strong&gt;代码执行出错&lt;/strong&gt; &lt;code&gt;Python&lt;/code&gt; 解释器会 &lt;strong&gt;抛出&lt;/strong&gt; 异常之外&lt;/li&gt;
&lt;li&gt;还可以根据 &lt;strong&gt;应用程序&lt;/strong&gt; &lt;strong&gt;特有的业务需求&lt;/strong&gt; &lt;strong&gt;主动抛出异常&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提示用户 &lt;strong&gt;输入密码&lt;/strong&gt;，如果 &lt;strong&gt;长度少于 8&lt;/strong&gt;，抛出 &lt;strong&gt;异常&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当前函数 &lt;strong&gt;只负责&lt;/strong&gt; 提示用户输入密码，如果 &lt;strong&gt;密码长度不正确，需要其他的函数进行额外处理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;因此可以 &lt;strong&gt;抛出异常&lt;/strong&gt;，由其他需要处理的函数 &lt;strong&gt;捕获异常&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;抛出异常&quot;&gt;4.2 抛出异常&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Python&lt;/code&gt; 中提供了一个 &lt;code&gt;Exception&lt;/code&gt; &lt;strong&gt;异常类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在开发时，如果满足 &lt;strong&gt;特定业务需求时&lt;/strong&gt;，希望 &lt;strong&gt;抛出异常&lt;/strong&gt;，可以：
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;创建&lt;/strong&gt; 一个 &lt;code&gt;Exception&lt;/code&gt; 的 &lt;strong&gt;对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;raise&lt;/code&gt; &lt;strong&gt;关键字&lt;/strong&gt; 抛出 &lt;strong&gt;异常对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义 &lt;code&gt;input_password&lt;/code&gt; 函数，提示用户输入密码&lt;/li&gt;
&lt;li&gt;如果用户输入长度 &amp;lt; 8，抛出异常&lt;/li&gt;
&lt;li&gt;如果用户输入长度 &amp;gt;=8，返回输入的密码&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def input_password():

    pwd = input(&quot;输入密码：&quot;)

    if len(pwd) &amp;gt;= 8:
        return pwd

    ex = Exception(&quot;密码长度不够&quot;)
    raise ex


try:
    print(input_password())
except Exception as result:
    print(result)
    &lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 23 Nov 2018 14:59:00 +0000</pubDate>
<dc:creator>张风闲</dc:creator>
<og:description>[TOC] 1. 异常的概念 程序在运行时，如果 遇到 到一个错误， 会停止程序的执行，并且提示一些错误信息 ，这就是 异常 程序停止执行并且提示错误信息 这个动作，我们通常称之为： 抛出(raise</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangfengxian/p/python-exception.html</dc:identifier>
</item>
<item>
<title>Android Handler消息机制源码解析 - 九路313</title>
<link>http://www.cnblogs.com/start1225/p/10010121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/start1225/p/10010121.html</guid>
<description>&lt;p&gt;好记性不如烂笔头，今天来分析一下Handler的源码实现&lt;/p&gt;
&lt;p&gt;Handler机制是Android系统的基础，是多线程之间切换的基础。下面我们分析一下Handler的源码实现。&lt;/p&gt;
&lt;p&gt;Handler消息机制有4个类合作完成，分别是&lt;code&gt;Handler,MessageQueue,Looper,Message&lt;/code&gt;&lt;br/&gt;Handler : 获取消息，发送消息，以及处理消息的类&lt;br/&gt;MessageQueue:消息队列，先进先出&lt;br/&gt;Looper : 消息的循环和分发&lt;br/&gt;Message : 消息实体类，分发消息和处理消息的就是这个类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要工作原理就是：&lt;/strong&gt;&lt;br/&gt;Looper 类里面有一个无限循环，不停的从MessageQueue队列中取出消息，然后把消息分发给Handler进行处理&lt;/p&gt;
&lt;p&gt;先看看在子线程中发消息，去在主线程中更新，我们就在主线程中打印一句话。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：&lt;br/&gt;在MainActivity中有一个属性uiHandler，如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Handler uiHandler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            if(msg.what == 100){
                Log.d(&quot;TAG&quot;,&quot;我是线程1 msg.what=&quot; + msg.what + &quot; msg.obj=&quot; + msg.obj.toString());
            }else if(msg.what == 200){
                Log.d(&quot;TAG&quot;,&quot;我是线程2 msg.what=&quot; + msg.what + &quot; msg.obj=&quot; + msg.obj.toString());
            }
        }
    };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个Handler实例，重写了handleMessage方法。根据message中what的标识来区别不同线程发来的数据并打印&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：&lt;br/&gt;在按钮的点击事件中开2个线程，分别在每个线程中使用 uiHandler获取消息，并发送消息。如下&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
        findViewById(R.id.tv_hello).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //线程1
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        //1 获取消息
                        Message message = uiHandler.obtainMessage();
                        message.what = 100;
                        message.obj = &quot;hello,world&quot;;
                        
                        //2 分发消息
                        uiHandler.sendMessage(message);
                    }
                }).start();

                //线程2
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        //1 获取消息
                        Message message = uiHandler.obtainMessage();
                        message.what = 200;
                        message.obj = &quot;hello,android&quot;;
                        
                        //2 分发消息
                        uiHandler.sendMessage(message);
                    }
                }).start();
            }
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用很简单，两步就完成了从子线程把数据发送到主线程并在主线程中处理&lt;br/&gt;我们来先分析Handler的源码&lt;/p&gt;
&lt;h2 id=&quot;handler-的源码分析&quot;&gt;Handler 的源码分析&lt;/h2&gt;
&lt;p&gt;Handler的构造函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public Handler() {
        this(null, false);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用了第两个参数的构造函数，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public Handler(Callback callback, boolean async) {
        //FIND_POTENTIAL_LEAKS 为 false, 不走这块
        if (FIND_POTENTIAL_LEAKS) {
            final Class&amp;lt;? extends Handler&amp;gt; klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;amp;&amp;amp;
                    (klass.getModifiers() &amp;amp; Modifier.STATIC) == 0) {
                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                    klass.getCanonicalName());
            }
        }

        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                &quot;Can't create handler inside thread &quot; + Thread.currentThread()
                        + &quot; that has not called Looper.prepare()&quot;);
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要是下面几句：&lt;br/&gt;mLooper = Looper.myLooper(); 调用Looper的静态方法获取一个Looper&lt;br/&gt;如果 mLooper == null ，就会抛出异常&lt;br/&gt;Can't create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;;&lt;br/&gt;说明我们的线程中如果没有一个looper的话，直接 new Handler() 是会抛出这个异常的。必须首先调用 Looper.prepare()，这个等下讲Looper的源码时就会清楚了。&lt;/p&gt;
&lt;p&gt;接下来，把 mLooper中的 mQueue赋值给Handler中的 mQueue,callback是传出来的值，为null&lt;br/&gt;这样我们的Handler里面就保存了一个Looper变量，一个MessageQueue消息队列.&lt;/p&gt;
&lt;p&gt;接下来就是 &lt;code&gt;Message message = uiHandler.obtainMessage();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;obtainMessage()的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public final Message obtainMessage()
    {
        //注意传的是一个 this, 其实就是 Handler本身
        return Message.obtain(this);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又调用了Message.obtain(this);方法，源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Message obtain(Handler h) {
        //1 调用obtain()获取一个Message实例m
        Message m = obtain();
        
        //2 关键的这句，把 h 赋值给了消息的 target，这个target肯定也是Handler了
        m.target = h;

        //3 返回 m
        return m;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，获取的消息里面就保存了 Handler 的实例。&lt;br/&gt;我们随便看一下 obtain() 方法是如何获取消息的。如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public static Message obtain() {
        //sPoolSync同步对象用的
        synchronized (sPoolSync) {
            //sPool是Message类型，静态变量
            if (sPool != null) {
                //就是个单链表，把表头返回，sPool再指向下一个
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        
        //如果sPool为空，则直接 new 一个
        return new Message();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;obtain()获取消息就是个享元设计模式，享元设计模式用大白话说就是：&lt;br/&gt;&lt;strong&gt;池中有，就从池中返回一个，如果没有，则新创建一个，放入池中，并返回。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用这种模式可以节省过多的创建对象。复用空闲的对象，节省内存。&lt;/p&gt;
&lt;p&gt;最后一句发送消息&lt;code&gt;uiHandler.sendMessage(message);&lt;/code&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public final boolean sendMessage(Message msg)
    {
        return sendMessageDelayed(msg, 0);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sendMessageDelayed(msg, 0) 源码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public final boolean sendMessageDelayed(Message msg, long delayMillis)
    {
        if (delayMillis &amp;lt; 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又调用了sendMessageAtTime() 源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        // Handler中的mQueue，就是前面从Looper.get
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用enqueueMessage()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        //注意这句，如果我们发送的消息不是 uiHandler.obtainMessage()获取的，而是直接 new Message()的，这个时候target为null
        //在这里，又把this 给重新赋值给了target了，保证不管怎么获取的Message,里面的target一定是发送消息的Handler实例
        msg.target = this;
        
        // mAsynchronous默认为false,不会走这个
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后调用&lt;code&gt;queue.enqueueMessage(msg, uptimeMillis)&lt;/code&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    boolean enqueueMessage(Message msg, long when) {
        if (msg.target == null) {
            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
        }
        if (msg.isInUse()) {
            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
        }

        synchronized (this) {
            if (mQuitting) {
                IllegalStateException e = new IllegalStateException(
                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }

            msg.markInUse();
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when &amp;lt; p.when) {
                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                // Inserted within the middle of the queue.  Usually we don't have to wake
                // up the event queue unless there is a barrier at the head of the queue
                // and the message is the earliest asynchronous message in the queue.
                needWake = mBlocked &amp;amp;&amp;amp; p.target == null &amp;amp;&amp;amp; msg.isAsynchronous();
                Message prev;
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when &amp;lt; p.when) {
                        break;
                    }
                    if (needWake &amp;amp;&amp;amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;enqueue单词的英文意思就是 排队，入队的意思。所以enqueueMessage()就是把消息进入插入单链表中，上面的源码可以看出，主要是按照时间的顺序把msg插入到由单链表中的第一个位置中，接下来我们就需要从消息队列中取出msg并分了处理了。这时候就调用Looper.loop()方法了。&lt;/p&gt;
&lt;p&gt;Looper.loop()的源码我简化了一下，把主要的流程留下，方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;);
        }
        final MessageQueue queue = me.mQueue;


        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }
        
            msg.target.dispatchMessage(msg);
           

            msg.recycleUnchecked();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，loop()方法就是在无限循环中不停的从queue中拿出下一个消息&lt;br/&gt;然后调用 msg.target.dispatchMessage(msg) , 上文我们分析过，Message的target保存的就是发送的Handler实例，这我们的这个demo中，就是uiHandler对象。&lt;/p&gt;
&lt;p&gt;说白了就是不停的从消息队列中拿出一个消息，然后发分给Handler的dispatchMessage()方法处理。&lt;/p&gt;
&lt;p&gt;Handler的dispatchMessage()方法源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，一个消息分发给dispatchMessage()之后&lt;br/&gt;1 首先看看消息的callback是否为null，如果不为null，就交给消息的handleCallback()方法处理，如果为null&lt;/p&gt;
&lt;p&gt;2 再看看Handler自己的mCallback是否为null，如果不为null，就交给mCallback.handleMessage(msg)进行处理，并且如果返回true,消息就不往下分发了，如果返回false&lt;/p&gt;
&lt;p&gt;3 就交给Handler的handleMessage()方法进行处理。&lt;/p&gt;
&lt;p&gt;有三层拦截，注意，有好多插件化在拦截替换activity的时候，就是通过反射，把自己实例的Handler实例赋值通过hook赋值给了ActivityThread相关的变量中，并且mCallback不为空，返回了false，这样不影响系统正常的流程，也能达到拦截的目的。说多了。&lt;/p&gt;
&lt;p&gt;前面分析了handler处理消息的机制，也提到了Looper类的作用，下面我们看看Looper的源码分析&lt;/p&gt;
&lt;h2 id=&quot;looper源码分析&quot;&gt;Looper源码分析&lt;/h2&gt;
&lt;p&gt;我们知道，APP进程的也就是我们应用的入口是ActivityThread.main()函数。&lt;br/&gt;对这块不熟悉的需要自己私下补课了。&lt;/p&gt;
&lt;p&gt;ActivityThread.main()的源码同样经过简化，如下：&lt;/p&gt;
&lt;p&gt;文件位于 &lt;em&gt;/frameworks/base/core/java/android/app/ActivityThread.java&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    //1 创建一个looper
    Looper.prepareMainLooper();
        
    //2 创建一个ActivityThread实例并调用attach()方法
    ActivityThread thread = new ActivityThread();
    thread.attach(false, startSeq);

    //3 消息循环
    Looper.loop();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，主线程中第一句就是创建一个looper，并调用了Looper.loop()进行消息循环，因为线程只有有了一个looper，才能消息循环，才能不停的从消息队列中取出消息，分发消息，并处理消息。没有消息的时候就阻塞在那，等待消息的到来并处理，这样的我们的app就是通过这种消息驱动的方式运行起来了。&lt;/p&gt;
&lt;p&gt;我们来看下 &lt;code&gt;Looper.prepareMainLooper()&lt;/code&gt; 的源码，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
            }
            sMainLooper = myLooper();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一句，调用了prepare(false)&lt;br/&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private static void prepare(boolean quitAllowed) {
        //1 查看当前线程中是否有looper存在，有就抛个异常
        //这表明，一个线程只能有一个looper存在 
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        
        //2 创建一个Looper并存放在sThreadLocal中
        sThreadLocal.set(new Looper(quitAllowed));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sThreadLocal的定义如下&lt;br/&gt;&lt;code&gt;static final ThreadLocal&amp;lt;Looper&amp;gt; sThreadLocal = new ThreadLocal&amp;lt;Looper&amp;gt;();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;是一个静态的变量。整个APP进程中只有一个sThreadLocal，sThreadLocal是线程独有的，每个线程都调用sThreadLocal保存，关于sThreadLocal的原理，其实就是类似HashMap（当然和HashMap是有区别的），也是key,value保存数据，只不过key就是sThreadLocal本身 ，但是映射的数组却是每个线程中独有的，这样就保证了sThreadLocal保存的数据每个线程独有一份，关于ThreadLocal的源码分析，后面几章会讲。&lt;/p&gt;
&lt;p&gt;既然Looper和线程有关，那么我们来看下Looper类的定义，源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
  * Class used to run a message loop for a thread.  Threads by default do
  * not have a message loop associated with them; to create one, call
  * {@link #prepare} in the thread that is to run the loop, and then
  * {@link #loop} to have it process messages until the loop is stopped.
  *
  * &amp;lt;p&amp;gt;Most interaction with a message loop is through the
  * {@link Handler} class.
  *
  * &amp;lt;p&amp;gt;This is a typical example of the implementation of a Looper thread,
  * using the separation of {@link #prepare} and {@link #loop} to create an
  * initial Handler to communicate with the Looper.
  *
  * &amp;lt;pre&amp;gt;
  *  class LooperThread extends Thread {
  *      public Handler mHandler;
  *
  *      public void run() {
  *          Looper.prepare();
  *
  *          mHandler = new Handler() {
  *              public void handleMessage(Message msg) {
  *                  // process incoming messages here
  *              }
  *          };
  *
  *          Looper.loop();
  *      }
  *  }&amp;lt;/pre&amp;gt;
  */
public final class Looper {
    .......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看上面的注释&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  * &amp;lt;pre&amp;gt;
  *  class LooperThread extends Thread {
  *      public Handler mHandler;
  *
  *      public void run() {
  *          Looper.prepare();
  *
  *          mHandler = new Handler() {
  *              public void handleMessage(Message msg) {
  *                  // process incoming messages here
  *              }
  *          };
  *
  *          Looper.loop();
  *      }
  *  }&amp;lt;/pre&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是经典的Looper的用法 ，可以在一个线程中开始处调用 Looper.prepare();&lt;br/&gt;然后在最后调用 Looper.loop();进行消息循环，可以把其它线程中的Handler实传进来，这样，一个Looper线程就有了，可以很方便的切换线程了。&lt;br/&gt;下章节我们来自己设计一个Looper线程，做一些后台任务。&lt;/p&gt;
&lt;p&gt;Handler的消息机制源码就分析到这了&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 14:54:00 +0000</pubDate>
<dc:creator>九路313</dc:creator>
<og:description>好记性不如烂笔头，今天来分析一下Handler的源码实现 Handler机制是Android系统的基础，是多线程之间切换的基础。下面我们分析一下Handler的源码实现。 Handler消息机制有4个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/start1225/p/10010121.html</dc:identifier>
</item>
<item>
<title>maven生命周期和插件详解 - yuanrw</title>
<link>http://www.cnblogs.com/yuanrw/p/9979875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanrw/p/9979875.html</guid>
<description>&lt;p&gt;    生命周期和插件是Maven的两个核心概念，命令行的输入往往就对应了生命周期，如mvn package就表示执行默认生命周期阶段package。Maven的生命周期是抽象的，其实际行为都由插件来完成。Maven的生命周期是为了对所有的构建过程进行抽象和统一。&lt;/p&gt;
&lt;p&gt;    Maven拥有三套相互独立的生命周期，分别为clean、default和site。clean生命周期的目的是清理项目，default生命周期的目的是构建项目，site目的是建立项目站点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;clean&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1. pre-clean 执行一些清理前需要完成的工作。&lt;/p&gt;
&lt;p&gt;2. clean 清理上一次构建生成的文件。&lt;/p&gt;
&lt;p&gt;3. post-clean 执行一些清理后需要完成的工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;default&lt;/strong&gt; 包含的操作很多，以下列出主要的：&lt;/p&gt;
&lt;p&gt;process-sources 处理项目主资源文件。一般来说，是对src/main/resources目录的内容进行变量替换等工作后，复制到项目输出的主classpath目录中。&lt;/p&gt;
&lt;p&gt;compile 编译项目的主代码。一般来说，是编译src/main/java目录下的Java文件至项目输出的主classpath目录中。&lt;/p&gt;
&lt;p&gt;process-test-sources 处理项目测试资源文件 src/main/resources。&lt;/p&gt;
&lt;p&gt;test-compile 编译项目的测试代码。src/test/java。&lt;/p&gt;
&lt;p&gt;test 使用单元测试框架运行测试，测试代码不会被打包或部署。&lt;/p&gt;
&lt;p&gt;package 接受编译好的代码，打包成可发布的格式，如jar。&lt;/p&gt;
&lt;p&gt;install 将包安装到Maven本地仓库，供本地其他Maven项目使用。&lt;/p&gt;
&lt;p&gt;deploy 将最终的包复制到远程仓库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;site&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pre-site&lt;/p&gt;
&lt;p&gt;site 生成项目站点文档。&lt;/p&gt;
&lt;p&gt;post-site &lt;/p&gt;
&lt;p&gt;site-deploy 将生成的项目站点发布到服务器上。&lt;/p&gt;

&lt;h2&gt;插件目标（Plugin Goal）：&lt;/h2&gt;
&lt;p&gt;    一个插件往往能够完成多个任务。例如maven-dependency-plugin，它能够基于项目依赖做很多事情，例如分析项目依赖，帮助找出所有已解析的依赖等等，每个功能就是一个插件目标。用法是 &amp;lt;插件前缀:目标&amp;gt;。例如maven-dependency-plugin有十多个目标，最常用的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mvn dependency:analyze

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行结果：&lt;/span&gt;
&lt;span&gt;[WARNING] Used undeclared dependencies found:
[WARNING]    org.springframework:spring&lt;/span&gt;-web:jar:5.0.4&lt;span&gt;.RELEASE:compile
[WARNING]    org.springframework.boot:spring&lt;/span&gt;-boot-autoconfigure:jar:2.0.0&lt;span&gt;.RELEASE:compile
[WARNING]    org.springframework:spring&lt;/span&gt;-tx:jar:5.0.4&lt;span&gt;.RELEASE:compile
[WARNING]    org.springframework.boot:spring&lt;/span&gt;-boot:jar:2.0.0&lt;span&gt;.RELEASE:compile
[WARNING] Unused declared dependencies found:
[WARNING]    com.alibaba:fastjson:jar:&lt;/span&gt;1.2.31&lt;span&gt;:compile
[WARNING]    org.springframework.boot:spring&lt;/span&gt;-boot-starter-test:jar:2.0.0&lt;span&gt;.RELEASE:test
[WARNING]    org.springframework.boot:spring&lt;/span&gt;-boot-starter-web:jar:2.0.0&lt;span&gt;.RELEASE:compile
[WARNING]    org.mybatis.spring.boot:mybatis&lt;/span&gt;-spring-boot-starter:jar:1.3.0&lt;span&gt;:compile
[WARNING]    com.google.guava:guava:jar:&lt;/span&gt;23.0:compile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Unused declared dependencies found即声明了没使用的依赖，通过这个插件，就能看到项目依赖的情况。如果是因为继承了父pom文件而导致无用依赖太多，那么可以使用dependencyManagement管理。&lt;/span&gt; &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;插件绑定：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;    Maven的生命周期与插件相互绑定，用以完成实际的构建任务。例如项目编译这一任务，它对应了default生命周期的compile阶段，而maven-compile-plugin这一插件的compile目标能完成该任务。因此，将它们绑定，就能实现编译的目的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500605/201811/1500605-20181123205349025-382347111.png&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;230&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　Maven在核心为一些主要的生命周期阶段绑定了很多插件的目标，当用户通过命令行调用生命周期阶段的时候，对于的插件目标就会执行相应的任务。例如clean绑定mavevn-clean-plugin:clean。&lt;/p&gt;
&lt;p&gt;　　而default生命周期，由于项目的打包类型会影响构建的具体过程，因此，default生命周期的阶段与插件的目标绑定关系由项目打包类型所决定，通过POM中的packaging元素定义。最常用的打包类型是jar。以下是基于jar，default生命周期的内置插件绑定关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500605/201811/1500605-20181123210029376-582675833.png&quot; alt=&quot;&quot; width=&quot;666&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;default生命周期还有很多其他阶段，默认它们没有绑定任何插件，因此也没有实际行为。&lt;/p&gt;

&lt;h2&gt;自定义绑定：&lt;/h2&gt;
&lt;p&gt;　　除了内置绑定以外，用户还能够自己选择将某个插件目标绑定到生命周期的某个阶段上。例如一个常用的插件 Maven Archetype Plugin，用户通过这个插件可以生成一个Maven项目的骨架，也可以从一个现成的项目中生成模板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500605/201811/1500605-20181123212123241-923585218.png&quot; alt=&quot;&quot; width=&quot;655&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通常的用法是使用 &lt;span class=&quot;cnblogs_code&quot;&gt;mvn archetype:create-from-project&lt;/span&gt; 指令生成模板。如果我正在编写一个模板项目，我希望在打包的时候自动生成模板，那么我可以把这个目标绑定到default的package生命周期上，如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;/plugins&amp;gt;
　　&amp;lt;plugin&amp;gt;
　　　　&amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
　　　　&amp;lt;artifactId&amp;gt;maven-archetype-plugin&amp;lt;/artifactId&amp;gt;
　　　　&amp;lt;version&amp;gt;3.0.1&amp;lt;/version&amp;gt;
　　　　　　&amp;lt;executions&amp;gt;
　　　　　　　　&amp;lt;execution&amp;gt;
　　　　　　　　　　&amp;lt;id&amp;gt;create-archetype&amp;lt;/id&amp;gt;
　　　　　　　　　　&amp;lt;phase&amp;gt;&lt;span&gt;package&lt;/span&gt;&amp;lt;/phase&amp;gt;
　　　　　　　　　　&amp;lt;goals&amp;gt;
　　　　　　　　　　　　&amp;lt;goal&amp;gt;create-from-project&amp;lt;/goal&amp;gt;
　　　　　　　　　　&amp;lt;/goals&amp;gt;
　　　　　　　　&amp;lt;/execution&amp;gt;
　　　　　&amp;lt;/executions&amp;gt;
    &amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在POM的build元素下的plugins子元素中声明插件的使用，除了配置插件的坐标声明外，还有插件的执行配置，executeions下每个execution子元素可以用来配置执行一个任务。我们配置了一个id为create-archetype的任务，通过phrase配置，将其绑定到package生命周期阶段上，再通过goals配置指定要执行的插件目标。&lt;/p&gt;
&lt;p&gt;执行 &lt;span class=&quot;cnblogs_code&quot;&gt;mvn clean &lt;span&gt;package&lt;/span&gt;&lt;/span&gt; 就能看到有以下输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;......以上省略......&lt;/span&gt;
&lt;span&gt;
[INFO] &lt;/span&gt;--- maven-jar-plugin:3.0.2:jar (&lt;span&gt;default&lt;/span&gt;-jar) @ demo ---&lt;span&gt;
[INFO] Building jar: &lt;/span&gt;/Users/yrw/Desktop/github/demo/target/demo-1.0-&lt;span&gt;SNAPSHOT.jar
[INFO] 
[INFO] &lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; maven-archetype-plugin:3.0.1:create-from-project (create-archetype) &amp;gt; generate-sources @ demo &amp;gt;&amp;gt;&amp;gt;&lt;span&gt;
[INFO] 
[INFO] &lt;/span&gt;&amp;lt;&amp;lt;&amp;lt; maven-archetype-plugin:3.0.1:create-from-project (create-archetype) &amp;lt; generate-sources @ demo &amp;lt;&amp;lt;&amp;lt;&lt;span&gt;
[INFO] 
[INFO] 
[INFO] &lt;/span&gt;--- maven-archetype-plugin:3.0.1:create-from-project (create-archetype) @ demo ---&lt;span&gt;
[INFO] Setting &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; groupId: com.yrw
[INFO] Setting &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; artifactId: demo
[INFO] Setting &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; version: 1.0-&lt;span&gt;SNAPSHOT
[INFO] Setting &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt;: com.yrw.test
[INFO] Scanning &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; projects...
[INFO] 
[INFO] &lt;/span&gt;-----------------------&amp;lt; com.yrw:demo-archetype &amp;gt;-----------------------&lt;span&gt;
[INFO] Building demo&lt;/span&gt;-archetype 1.0-&lt;span&gt;SNAPSHOT
[INFO] &lt;/span&gt;--------------------------[ maven-archetype ]---------------------------&lt;span&gt;
[INFO] 
[INFO] &lt;/span&gt;--- maven-resources-plugin:3.1.0:resources (&lt;span&gt;default&lt;/span&gt;-resources) @ demo-archetype ---&lt;span&gt;
[WARNING] Using platform encoding (UTF&lt;/span&gt;-8 actually) to copy filtered resources, i.e. build is platform dependent!&lt;span&gt;
[INFO] Copying &lt;/span&gt;84&lt;span&gt; resources
[INFO] 
[INFO] &lt;/span&gt;--- maven-resources-plugin:3.1.0:testResources (&lt;span&gt;default&lt;/span&gt;-testResources) @ demo-archetype ---&lt;span&gt;
[WARNING] Using platform encoding (UTF&lt;/span&gt;-8 actually) to copy filtered resources, i.e. build is platform dependent!&lt;span&gt;
[INFO] Copying &lt;/span&gt;2&lt;span&gt; resources
[INFO] 
[INFO] &lt;/span&gt;--- maven-archetype-plugin:3.0.1:jar (&lt;span&gt;default&lt;/span&gt;-jar) @ demo-archetype ---&lt;span&gt;
[INFO] Building archetype jar: &lt;/span&gt;/Users/yrw/Desktop/github/demo/target/generated-sources/archetype/target/demo-archetype-1.0-&lt;span&gt;SNAPSHOT
[INFO] &lt;/span&gt;------------------------------------------------------------------------&lt;span&gt;
[INFO] BUILD SUCCESS
[INFO] &lt;/span&gt;------------------------------------------------------------------------&lt;span&gt;
[INFO] Total time: &lt;/span&gt;1.110&lt;span&gt; s
[INFO] Finished at: &lt;/span&gt;2018-11-23T22:12:15+08:00&lt;span&gt;
[INFO] &lt;/span&gt;------------------------------------------------------------------------&lt;span&gt;
[INFO] Archetype project created in &lt;/span&gt;/Users/yrw/Desktop/github/demo/target/generated-sources/&lt;span&gt;archetype
[INFO] &lt;/span&gt;------------------------------------------------------------------------&lt;span&gt;
[INFO] BUILD SUCCESS
[INFO] &lt;/span&gt;------------------------------------------------------------------------&lt;span&gt;
[INFO] Total time: &lt;/span&gt;5.689&lt;span&gt; s
[INFO] Finished at: &lt;/span&gt;2018-11-23T22:12:15+08:00&lt;span&gt;
[INFO] &lt;/span&gt;------------------------------------------------------------------------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，在打包的时候执行了archetype:create-from-project，进入/target/generated-sources/archetype目录，就能看到生成的模板了。&lt;/p&gt;

&lt;h2&gt;命令行配置插件：&lt;/h2&gt;
&lt;p&gt;    插件目标支持命令行配置，可以通过-D参数，并伴随一个参数=参数值的形式，来配置插件目标的参数。例如命令 &lt;span class=&quot;cnblogs_code&quot;&gt;mvn install -Dmaven.test.skip=&lt;span&gt;true&lt;/span&gt;&lt;/span&gt; ，就会跳过执行测试。&lt;/p&gt;

&lt;h2&gt;在pom中配置全局插件：&lt;/h2&gt;
&lt;p&gt;　　并不是所有的插件参数都适合从命令行配置，有些参数的值从项目发布都不会改变，对于这种情况，可以在pom文件中一次性配置。例如需要配置maven-compiler-plugin编译java1.8.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　&amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.8.0&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;source&amp;gt;8&amp;lt;/source&amp;gt;
                    &amp;lt;target&amp;gt;8&amp;lt;/target&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;plugins&amp;gt;
　　&amp;lt;build&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，不管绑定到compile阶段的maven-compiler-plugin:compile任务，还是绑定到test-compiler阶段的maven-compiler-plugin:testCompiler任务，就都能够使用该配置，基于1.8版本进行编译。&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 14:25:00 +0000</pubDate>
<dc:creator>yuanrw</dc:creator>
<og:description>生命周期和插件是Maven的两个核心概念，命令行的输入往往就对应了生命周期，如mvn package就表示执行默认生命周期阶段package。Maven的生命周期是抽象的，其实际行为都由插件来完成。M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanrw/p/9979875.html</dc:identifier>
</item>
<item>
<title>Jenkins持续集成介绍及插件安装版本更新演示（一）--技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/10001180.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/10001180.html</guid>
<description>
&lt;h2&gt;Jenkins介绍&lt;/h2&gt;

&lt;p&gt;&lt;span&gt; Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Jenkins功能包括:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、持续的软件版本发布/测试项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、监控外部调用执行的工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                                             --摘自360百科&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. jenkins就是基于Java开发的一种持续集成的工具&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 可以将运维用到的各个脚本整合起来，并且可以通过页面方式集中管理，而且可以也可以实现和gitlab、github交互，也可以实现自动编译、部署程序&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;持续集成&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建(包括编译，发布，自动化测试)来验证，从而尽早地发现集成错误。&lt;/p&gt;

&lt;p&gt;持续集成&lt;/p&gt;
&lt;p&gt;持续集成：Continuous Intergration （&lt;span&gt;CI&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;持续交付：Continuous Delivery（&lt;span&gt;CD&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;持续部署：Continuous Deployment（&lt;span&gt;CD&lt;/span&gt;）&lt;/p&gt;

&lt;p&gt;持续集成流程&lt;/p&gt;
&lt;p&gt;1. 提交（&lt;span&gt;git&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;2. 测试&lt;/p&gt;
&lt;p&gt;3. 构建（&lt;span&gt;jenkins&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;4. 测试&lt;/p&gt;
&lt;p&gt;5. 部署（&lt;span&gt;ansible&lt;/span&gt;，&lt;span&gt;shell&lt;/span&gt;，&lt;span&gt;puppet&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;6. 回滚（&lt;span&gt;ansible&lt;/span&gt;）&lt;/p&gt;

&lt;h2&gt;Jenkins的安装&lt;/h2&gt;

&lt;p&gt; jenkins是基于java开发的所以需要安装java环境&lt;/p&gt;
&lt;p&gt;jenkins提供了一个友好的web界面操控，安装完成之后我们可以在web端进行管理&lt;/p&gt;
&lt;p&gt;大家可以在如下的网站下载所需要的jenkins版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122172037850-1341422281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第一步：关闭防火墙&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# systemctl stop firewalld
[root@ken &lt;/span&gt;~]# setenforce &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：安装java环境&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install java -y
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：上传安装包及解压安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# ls |&lt;span&gt; grep jenkins
jenkins&lt;/span&gt;-&lt;span&gt;2.138&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;-&lt;span&gt;1.1&lt;/span&gt;.noarch.rpm&lt;br/&gt;[root@ken ~]# rpm -ivh jenkins-2.138.3-1.1.noarch.rpm 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第四步：启动jenkins&lt;/p&gt;
&lt;p&gt;jenkins默认监听的是8080端口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# systemctl restart jenkins
[root@ken &lt;/span&gt;~]# ss -tnl | grep &lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;50&lt;/span&gt;          :::&lt;span&gt;8080&lt;/span&gt;                    :::*                  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第五步：浏览器访问&lt;/p&gt;
&lt;p&gt;可以看到如下的界面&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：安装jenkins会卡在安装界面&lt;/span&gt;&lt;br/&gt;&lt;span&gt;原因：当前主机尝试连接jenkins官方站点，但是无法连接上&lt;/span&gt;&lt;br/&gt;&lt;span&gt;解决：断开当前主机的网络连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122165915110-760146147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第六步：linux中找到上述密码并复制进上述框中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# cat /&lt;span&gt;var&lt;/span&gt;/lib/jenkins/secrets/&lt;span&gt;initialAdminPassword
f10ee04f771042638d1c152355efc8c8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把上面这个密码输入上述框中点击继续即可&lt;/p&gt;
&lt;p&gt;选择跳过插件安装即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122170233417-1178710907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在如下界面创建用户和密码，点击保存并完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122170345578-598226152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现如下界面直接点保存并完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122170457187-167233026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 点下下面出现的开始使用Jenkins&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122170520403-347497511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到如下界面即表示安装配置完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122170613010-1640694024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Jenkins获取插件并安装&lt;/h2&gt;

&lt;p&gt; 第一步：查看插件信息&lt;/p&gt;
&lt;p&gt;点击系统管理&amp;gt;插件管理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122172632401-1810903991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击插件管理&lt;/p&gt;
&lt;p&gt;可以看到已安装处为空&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122172719346-1857954528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载插件之前可以在系统管理&amp;gt;关于jenkins查看自己的jenkins版本信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122173319581-1804217609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二步：下载插件&lt;/p&gt;
&lt;p&gt;访问如下网站，选择你的jenkins版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122173505457-250990269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择latest&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122173554048-1933904849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择你需要安装的插件即可&lt;/p&gt;
&lt;p&gt;插件都是以hpi结尾的&lt;/p&gt;

&lt;p&gt;第三步：把下载的插件传入到你的linux系统中&lt;/p&gt;
&lt;p&gt;需要把插件传到jenkins的插件目录中即下面的目录下&lt;/p&gt;
&lt;p&gt;这里我准备了一个插件安装包 plugins-2.138.3.tar.gz &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# ls /&lt;span&gt;var&lt;/span&gt;/lib/jenkins/plugins/
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;p&gt;[root@ken ~]# tar xf plugins-2.138.3.tar.gz&lt;br/&gt;[root@ken ~]# cp plugins/* /var/lib/jenkins/plugins/ -a&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;第四步：重启jenkins&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart jenkins
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第五步：浏览器端查看&lt;/p&gt;
&lt;p&gt;需要刷新一下浏览器，可能还需要你重新输入账号和密码&lt;/p&gt;
&lt;p&gt;可以看到在已安装里面已经有很多的插件了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122174939713-1045191078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Jenkins版本更新&lt;/h2&gt;

&lt;p&gt;第一步：下载安装更新的软件包&lt;/p&gt;
&lt;p&gt;还是访问这个网站&lt;/p&gt;
&lt;p&gt;选择你需要升级到的版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122182136155-201983760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择latest&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122182238437-1713053188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择war结尾的包下载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122182303266-1023001692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二步：把选本的war包删掉&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken plugins]# rpm -ql jenkins |&lt;span&gt; grep war
&lt;/span&gt;/usr/lib/jenkins/jenkins.war
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：替换成你下载的包&lt;/p&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;p&gt;第四步：重启jenkins即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart jenkins
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 23 Nov 2018 14:19:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>Jenkins介绍 Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 Jenkins功能包括:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/10001180.html</dc:identifier>
</item>
<item>
<title>自己动手实现java数据结构（一） 向量 - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/9977275.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/9977275.html</guid>
<description>&lt;p&gt;　　计算机程序主要运行在内存中，而内存在逻辑上可以被看做是连续的地址。为了充分利用这一特性，在主流的编程语言中都存在一种底层的被称为&lt;strong&gt;数组(Array)&lt;/strong&gt;的数据结构与之对应。在使用数组时需要事先声明&lt;strong&gt;固定的大小&lt;/strong&gt;以便程序在运行时为其开辟内存空间；数组通过下标值计算出地址偏移量来对内部元素进行访问。&lt;/p&gt;
&lt;p&gt;　　可以看到，原始的数组很基础，所以运行效率非常的高。但同时也存在着严重的问题：&lt;/p&gt;
&lt;p&gt;　　1.由于数组的大小需要在创建时被固定下来，但大多数程序在编写时无法很好的预测到可能的数据量大小，因而也就无法在创建时设置合适的数组大小，过大则&lt;strong&gt;浪费内存空间&lt;/strong&gt;；过小则会出现&lt;strong&gt;上溢&lt;/strong&gt;，需要编程人员进行特别的处理。&lt;/p&gt;
&lt;p&gt;　　2.访问数组时，很容易出现数组下标越界的情况。由于数组的访问是非常频繁的，因而在追求性能的语言中(如&lt;strong&gt;C语言&lt;/strong&gt;)，编译器都没有对数组下标越界进行额外的检查，当程序出现了意外的数组下标越界时，依然允许程序访问和修改数组外部的内存地址，这很容易造成古怪的，难以复现的bug。(&lt;strong&gt;Java&lt;/strong&gt;，&lt;strong&gt;python&lt;/strong&gt;等较为高级的语言为了安全起见，即使舍弃掉一定的性能也要对数组下标越界进行检查)。&lt;/p&gt;
&lt;p&gt;　　针对上述问题，我们需要对原始的数组进行一定程度的封装，在不改变基本使用方式的前提下，使其在运行过程中能够针对所存储的数据量大小自适应的&lt;strong&gt;扩容；&lt;/strong&gt;对数组下标的越界访问进行检查，同时提供一系列的常用接口供用户使用。&lt;/p&gt;
&lt;p&gt;　　而这个基于数组封装之后的数据结构，我们一般称之为&quot;&lt;strong&gt;向量(vector)&lt;/strong&gt;&quot;或者&quot;&lt;strong&gt;顺序表(sequence list)&lt;/strong&gt;&quot;。&lt;/p&gt;

&lt;p&gt;　　由于是使用java作为实现的语言，因此在设计上参考了jdk自带的向量数据结构：&lt;strong&gt;java.util.ArrayList&lt;/strong&gt;类。&lt;/p&gt;
&lt;h3&gt;　　1.size()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;int size();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：返回当前列表中元素的个数。&lt;/p&gt;
&lt;h3&gt;　　2.isEmpty()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;boolean isEmpty();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：如果当前列表中元素个数为0，返回&lt;strong&gt;true&lt;/strong&gt;；否则，返回&lt;strong&gt;false&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;　　3.indexOf()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;int indexOf(E e);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：判断元素&quot;e&quot;是否存在于列表中&lt;/p&gt;
&lt;h3&gt;　　4.contains()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;boolean contains(E e);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;接口描述: 判断元素&quot;e&quot;是否存在于列表中&lt;/p&gt;
&lt;h3&gt;　　5.add()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;boolean add(E e);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：在列表的最后插入元素&lt;strong&gt;&quot;e&quot;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;　　　　&lt;/em&gt;接口定义：&lt;strong&gt;void add(int index,E e);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：在列表的下标为&lt;strong&gt;&quot;index&quot;&lt;/strong&gt;位置处插入元素&lt;strong&gt;&quot;e&quot;&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;　　6.remove()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;boolean remove(E e);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;接口描述：从列表中找到并且移除&lt;strong&gt;&quot;&lt;/strong&gt;e&quot;对象，找到并且成功移除返回&lt;strong&gt;true&lt;/strong&gt;；否则返回&lt;strong&gt;false&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　　　　接口定义：&lt;strong&gt;E remove(int index);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：移除列表中下标为&lt;strong&gt;&quot;index&quot;&lt;/strong&gt;位置处的元素，返回被移除的元素。&lt;/p&gt;
&lt;h3&gt;　　7.set()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;E set(int index,E e);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：将列表中下标为&lt;strong&gt;&quot;index&quot;&lt;/strong&gt;位置处的元素替代为&lt;strong&gt;&quot;e&quot;&lt;/strong&gt;,返回被替代的元素。&lt;/p&gt;
&lt;h3&gt;　　8.get()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;E get(int index);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：返回列表中下标为&lt;strong&gt;&quot;index&quot;&lt;/strong&gt;位置处的元素。&lt;/p&gt;

&lt;h2&gt;3.1 向量属性&lt;/h2&gt;
&lt;p&gt;　　向量作为数组的进一步封装，内部持有着一个数组，首先我们有以下属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArrayList &amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; List &amp;lt;E&amp;gt;&lt;span&gt;{&lt;br/&gt;&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部封装的数组
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object[] elements;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 线性表默认的容量大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CAPACITY = 16&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 扩容翻倍的基数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; EXPAND_BASE = 1.5&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部数组的实际大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当前线性表的实际大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=================================================构造方法======================================================&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认的无参构造方法
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ArrayList() {
        size &lt;/span&gt;= 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::设置数组大小为默认&lt;/span&gt;
        elements = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[DEFAULT_CAPACITY];
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 设置内部数组初始大小的构造方法
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; capacity 内部数组初始大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; ArrayList(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; capacity;
        size &lt;/span&gt;= 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::设置数组大小&lt;/span&gt;
        elements = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[capacity];
    }
｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.2 较为简单的 &lt;strong&gt;size()，isEmpty()，indexOf()，contains()&lt;/strong&gt;方法实现：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.size == 0)&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; indexOf(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前参数是否为null&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;::::参数不为null
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::从前到后依次比对&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;&lt;span&gt;this&lt;/span&gt;.size; i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前item是否 equals 参数e&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(e.equals(elements[i])){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::匹配成功，立即返回当前下标&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
                }
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::参数为null
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::从前到后依次比对&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;&lt;span&gt;this&lt;/span&gt;.size; i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前item是否为null&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.elements[i] == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::为null，立即返回当前下标&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::遍历列表未找到相等的元素，返回特殊值&quot;-1&quot;代表未找到&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contains(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::复用indexOf方法,如果返回-1代表不存在;反之，则代表存在&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; (indexOf(e) != -1&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;indexOf、contains方法——时间复杂度：　　&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　可以看到&lt;strong&gt;indexOf&lt;/strong&gt;方法的内部是通过一次循环遍历来查询的。&lt;/p&gt;
&lt;p&gt;　　因此&lt;strong&gt;indexOf&lt;/strong&gt;方法、&lt;strong&gt;contains&lt;/strong&gt;方法的&lt;strong&gt;渐进时间复杂度&lt;/strong&gt;都是&lt;strong&gt;O(n)&lt;/strong&gt;，这个查询效率比未来要介绍的&lt;strong&gt;哈希表&lt;/strong&gt;的查询时间复杂度&lt;strong&gt;O(1)&lt;/strong&gt;有明显差距&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;3.3.增删改查接口实现：&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;3.3.1 下标越界检查&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;部分增删改查接口会通过下标来进行操作，必须对访问数组的下标进行校验。&lt;/p&gt;
&lt;h4&gt;下标越界检查&lt;strong&gt;方法实现：&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入时,下标越界检查
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index 下标值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rangeCheckForAdd(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果下标小于0或者大于size的值，抛出异常
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::注意：插入时，允许插入向量的末尾，因此(index == size)是合法的&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(index &amp;gt; &lt;span&gt;this&lt;/span&gt;.size || index &amp;lt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;index error  index=&quot; + index + &quot; size=&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size) ;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 下标越界检查
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index 下标值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rangeCheck(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果下标小于0或者大于等于size的值，抛出异常&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(index &amp;gt;= &lt;span&gt;this&lt;/span&gt;.size || index &amp;lt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;index error  index=&quot; + index + &quot; size=&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size) ;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;3.3.2 插入方法实现：&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::插入新数据前进行扩容检查&lt;/span&gt;
&lt;span&gt;        expandCheck();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;;::在末尾插入元素&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;.size] =&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::size自增&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.size++&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::插入时，数组下标越界检查&lt;/span&gt;
&lt;span&gt;        rangeCheckForAdd(index);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::插入新数据前进行扩容检查&lt;/span&gt;
&lt;span&gt;        expandCheck();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::插入位置下标之后的元素整体向后移动一位(防止数据被覆盖，并且保证数据在数组中的下标顺序)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::Tips: 比起for循环，System.arraycopy基于native的内存批量复制在内部数组数据量较大时具有更高的执行效率&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;this&lt;/span&gt;.size; i&amp;gt;index; i--&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elements[i] = &lt;span&gt;this&lt;/span&gt;.elements[i-1&lt;span&gt;];
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::在index下标位置处插入元素&quot;e&quot;&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements[index] =&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::size自增&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.size++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;插入方法——时间复杂度:&lt;/h4&gt;
&lt;p&gt;　　可以看到，向量的插入操作会导致插入位置之后的数据整体向后平移一位。&lt;/p&gt;
&lt;p&gt;　　在这里，使用了for循环将数据一个一个的进行复制。事实上，由于数组中下标连续的数据段在内存中也是连续成片的(&lt;strong&gt;逻辑意义上的&lt;/strong&gt;)，因此操作系统可以通过批量复制内存的方法来优化这种&quot;&lt;strong&gt;数组中一片连续数据复制&lt;/strong&gt;&quot;的操作。java在jdk中自带的向量实现中采用了&lt;strong&gt;native&lt;/strong&gt;的&lt;strong&gt;System.arraycopy()&lt;/strong&gt;方法来实现这个优化操作。&lt;/p&gt;
&lt;p&gt;　　在我的向量实现中，有多处这种&quot;数组中一片连续数据复制&quot;的操作，为了增强代码的可理解性，都使用了for循环这种较低效率的实现方式，希望能够理解。&lt;/p&gt;
&lt;p&gt;　　虽然&lt;strong&gt;System.arraycopy&lt;/strong&gt;能够优化这一操作的效率，但是在渐进的意义上，&lt;strong&gt;向量&lt;/strong&gt;&lt;strong&gt;插入操作&lt;/strong&gt;的&lt;strong&gt;时间复杂度&lt;/strong&gt;为&lt;strong&gt;O(n)&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;动态扩容：&lt;/h4&gt;
&lt;p&gt;　　前面我们提到，向量相比数组的一大&lt;strong&gt;改进&lt;/strong&gt;就是向量能够在数据新增时根据存储的数据量进行&lt;strong&gt;动态的扩容&lt;/strong&gt;，而不需要人工的干预。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;向量扩容方法的实现：&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部数组扩容检查
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; expandCheck(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果当前元素个数 = 当前内部数组容量&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.size == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::需要扩容

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::先暂存之前内部数组的引用&lt;/span&gt;
            Object[] tempArray = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前内部数组扩充 一定的倍数&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.capacity = (&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;this&lt;/span&gt;.capacity *&lt;span&gt; EXPAND_BASE);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::内部数组指向扩充了容量的新数组&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.elements = &lt;span&gt;new&lt;/span&gt; Object[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::为了代码的可读性，使用for循环实现新老数组的copy操作
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::Tips: 比起for循环，System.arraycopy基于native的内存批量复制在内部数组数据量较大时具有更高的执行效率&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;tempArray.length; i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elements[i] =&lt;span&gt; tempArray[i];
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;动态扩容——时间复杂度：&lt;/h4&gt;
&lt;p&gt;　　动态扩容的操作由于需要进行内部数组的整体copy，&lt;strong&gt;其时间复杂度是O(n)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;但是站在全局的角度，动态扩容只会在插入操作导致空间不足时&lt;strong&gt;偶尔&lt;/strong&gt;的被触发，所以&lt;strong&gt;整体来看，动态扩容的时间复杂度为O(1)&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.3.3 删除方法实现：&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; E remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::数组下标越界检查&lt;/span&gt;
&lt;span&gt;        rangeCheck(index);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::先暂存将要被移除的元素&lt;/span&gt;
        E willBeRemoved = (E)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[index];
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将删除下标位置之后的数据整体前移一位
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::Tips: 比起for循环，System.arraycopy基于native的内存批量复制在内部数组数据量较大时具有更高的执行效率&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=index+1; i&amp;lt;&lt;span&gt;this&lt;/span&gt;.size; i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elements[i-1] = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[i];
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::由于数据整体前移了一位，释放列表末尾的失效引用，增加GC效率&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements[(&lt;span&gt;this&lt;/span&gt;.size - 1)] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::size自减&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.size--&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回被删除的元素&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; willBeRemoved;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;删除方法——时间复杂度:&lt;/h4&gt;
&lt;p&gt;　　向量的删除操作会导致被删除位置之后的数据整体前移一位。&lt;/p&gt;
&lt;p&gt;　　和插入操作类似，&lt;strong&gt;向量&lt;/strong&gt;&lt;strong&gt;删除操作&lt;/strong&gt;的&lt;strong&gt;时间复杂度&lt;/strong&gt;为&lt;strong&gt;O(n)&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;3.3.4 修改/查询方法实现：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; E set(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::数组下标越界检查&lt;/span&gt;
&lt;span&gt;        rangeCheck(index);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::先暂存之前index下标处元素的引用&lt;/span&gt;
        E oldValue = (E)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[index];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将index下标元素设置为参数&quot;e&quot;&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements[index] =&lt;span&gt; e;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回被替换掉的元素&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
    }

    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; E get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::数组下标越界检查&lt;/span&gt;
&lt;span&gt;        rangeCheck(index);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回对应下标的元素&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; (E)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[index];
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;修改/查询方法——时间复杂度：&lt;/h4&gt;
&lt;p&gt;　　可以看到，向量的修改和查询操作都直接通过下标访问内部数组。&lt;/p&gt;
&lt;p&gt;　　通过下标访问数组内部元素只需要计算偏移量即可直接访问对应数据，因此&lt;strong&gt;向量&lt;/strong&gt;&lt;strong&gt;修改/查询操作&lt;/strong&gt;的&lt;strong&gt;时间复杂度&lt;/strong&gt;为&lt;strong&gt;O(1)&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;3.4 向量其它接口：&lt;/h2&gt;
&lt;h3&gt;3.4.1 clear方法&lt;/h3&gt;
&lt;p&gt;　　clear方法用于清空向量内的元素，初始化向量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::遍历列表，释放内部元素引用，增加GC效率&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;&lt;span&gt;this&lt;/span&gt;.size; i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elements[i] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将size重置为0&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.size = 0&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.4.2 trimToSize方法&lt;/h3&gt;
&lt;p&gt;　　前面提到，向量在空间不足时会自动的进行扩容。自动增长的特性非常方便，但是也带来了一个问题：向量会在新增元素时扩容，但出于效率的考量，删除元素却不会自动的收缩。举个例子：一个很大的向量执行&lt;strong&gt;clear&lt;/strong&gt;时，虽然内部元素的引用被销毁，但是内部数组&lt;strong&gt;elements&lt;/strong&gt;依然占用了很多不必要的内存空间。&lt;/p&gt;
&lt;p&gt;　　因此，向量提供了&lt;strong&gt;trimToSize&lt;/strong&gt;方法，允许用户在必要的时候手动的使向量&lt;strong&gt;收缩&lt;/strong&gt;，以增加空间效率。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 收缩内部数组，使得&quot;内部数组的大小&quot;和&quot;向量逻辑大小&quot;相匹配，提高空间利用率
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; trimToSize(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果当前向量逻辑长度 小于 内部数组的大小&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.size &amp;lt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::创建一个和当前向量逻辑大小相等的新数组&lt;/span&gt;
            Object[] newElements = &lt;span&gt;new&lt;/span&gt; Object[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将当前旧内部数组的数据复制到新数组中
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::Tips: 这里使用Arrays.copy方法进行复制,效率更高&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i&amp;lt; newElements.length; i++&lt;span&gt;){
                newElements[i] &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[i];
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::用新数组替换掉之前的老内部数组&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.elements =&lt;span&gt; newElements;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::设置当前容量&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.capacity = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.4.3 toString方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::空列表&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEmpty()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;[]&quot;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::列表起始使用&quot;[&quot;&lt;/span&gt;
        StringBuilder s = &lt;span&gt;new&lt;/span&gt; StringBuilder(&quot;[&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::从第一个到倒数第二个元素之间&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;size-1; i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::使用&quot;, &quot;进行分割&lt;/span&gt;
            s.append(elements[i]).append(&quot;,&quot;).append(&quot; &quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::最后一个元素使用&quot;]&quot;结尾&lt;/span&gt;
        s.append(elements[size - 1]).append(&quot;]&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s.toString();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在我们使用数据结构容器时，会遇见以下问题：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1. 需要理解内部设计才能遍历容器中数据。&lt;/strong&gt;如果说基于数组的&lt;strong&gt;向量&lt;/strong&gt;还可以较&lt;strong&gt;轻松&lt;/strong&gt;的通过循环下标来进行遍历，那么更加复杂的数据结构例如&lt;strong&gt;哈希表&lt;/strong&gt;、&lt;strong&gt;平衡二叉树&lt;/strong&gt;等在遍历时将变得更加&lt;strong&gt;困难&lt;/strong&gt;。同时在业务代码中如果存储数据的容器类型一旦被改变(&lt;strong&gt;向量---&amp;gt;链表&lt;/strong&gt;)  ，意味着大量代码的推倒重写。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2. 缺少对容器遍历行为的抽象，导致重复代码的出现&lt;/strong&gt;。这一问题必须在实现了多个数据结构容器之后才会体现出来。例如，上面提到的向量的toString方法中，如果将遍历内部数组的行为抽象出来，则可以使得多种不同的类型的数据结构容器复用同一个&lt;strong&gt;toString&lt;/strong&gt;方法。&lt;/p&gt;
&lt;p&gt;　　为此java在设计数据结构容器架构时，抽象出了&lt;strong&gt;Iterator&lt;/strong&gt;接口，用于整合容器遍历的行为，并要求所有的容器都必须提供&lt;strong&gt;对应的Iterator接口&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Iterator接口设计：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;1. hasNext()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;boolean hasNext();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：当前迭代器 是否存在下一个元素。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2. next()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;E next();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;接口描述：获得迭代器 迭代的下一个元素。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3. remove()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;void remove();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述:  移除迭代器指针当前指向的元素&lt;/p&gt;
&lt;p&gt;　　个人认为迭代器之所以加上了remove接口，是因为很多时候迭代的操作都伴随着删除容器内部元素的需求。由于删除元素会导致内部数据结构的变化，导致无法简单的完成遍历，需要使用者熟悉容器内部实现原理，小心谨慎的实现遍历代码。&lt;/p&gt;
&lt;p&gt;　　而&lt;strong&gt;Iterator&lt;/strong&gt;接口的出现，将这一问题带来的复杂度交给了容器的设计者，降低了用户使用数据结构容器的难度。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;向量Iterator实现：&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 向量 迭代器内部类
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Itr &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 迭代器下一个元素 指针下标
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nextIndex = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 迭代器当前元素 指针下标
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; currentIndex = -1&lt;span&gt;;

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果&quot;下一个元素指针下标&quot; 小于 &quot;当前向量长度&quot; ==&amp;gt; 说明迭代还未结束&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.nextIndex &amp;lt; ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size;
        }

        @Override
        @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前元素指针下标 = 下一个元素指针下标&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.currentIndex =&lt;span&gt; nextIndex;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::下一个元素指针下标自增,指向下一元素&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.nextIndex++&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回当前元素&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; (E)ArrayList.&lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentIndex];
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::删除当前元素&lt;/span&gt;
            ArrayList.&lt;span&gt;this&lt;/span&gt;.remove(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentIndex);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::由于删除了当前下标元素，数据段整体向前平移一位，因此nextIndex不用自增

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::为了防止用户在一次迭代(next调用)中多次使用remove方法，将currentIndex设置为-1&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.currentIndex = -1&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　5.1 向量的性能&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　　　空间效率：&lt;/strong&gt;向量中空间占比最大的就是一个随着存储数据规模增大而不断增大的内部数组。而数组是十分紧凑的，因此&lt;strong&gt;向量&lt;/strong&gt;的&lt;strong&gt;空间效率&lt;/strong&gt;&lt;strong&gt;非常高&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;时间效率：&lt;/strong&gt;评估一个数据结构容器的时间效率，可以从最常用的增删改查接口来进行衡量。&lt;/p&gt;
&lt;p&gt;　　　　我们已经知道，向量的&lt;strong&gt;增加、删除&lt;/strong&gt;操作的&lt;strong&gt;时间复杂度&lt;/strong&gt;为&lt;strong&gt;O(n)，&lt;/strong&gt;效率较低；而向量的随机&lt;strong&gt;修改、查询&lt;/strong&gt;操作效率则非常高，为常数的时间复杂度&lt;strong&gt;O(1)&lt;/strong&gt;。对于&lt;strong&gt;有序向量&lt;/strong&gt;，其查找特定元素的&lt;strong&gt;时间复杂度&lt;/strong&gt;也能够被控制在&lt;strong&gt;O(logn)&lt;/strong&gt;对数时间复杂度上。&lt;/p&gt;
&lt;p&gt;　　　　因此向量在随机查询较多，而删除和增加较少的场景表现优异，但是并不适合频繁插入和删除的场景。&lt;/p&gt;
&lt;h3&gt;　　5.2 当前向量实现存在的缺陷&lt;/h3&gt;
&lt;p&gt;　　　　到这里，我们已经完成了一个最基础的向量数据结构。限于个人水平，以及为了代码尽可能的简单和易于理解，所以并没有做进一步的改进。&lt;/p&gt;
&lt;p&gt;　　　　下面是我认为当前实现版本的主要缺陷：&lt;/p&gt;
&lt;h4&gt;　　　　1.不支持并发&lt;/h4&gt;
&lt;p&gt;　　　　java是一门支持多线程的语言，因此容器也必然会在多线程并发的环境下运行。&lt;/p&gt;
&lt;p&gt;　　　　jdk的向量数据结构，&lt;strong&gt;Vector&lt;/strong&gt;主要通过对方法添加&lt;strong&gt;synchronized&lt;/strong&gt;关键字，用&lt;strong&gt;悲观锁&lt;/strong&gt;来实现线程安全，效率较低。而另一个向量的实现，&lt;strong&gt;ArrayList&lt;/strong&gt;则是采用了快速失败的，基于版本号的&lt;strong&gt;乐观锁&lt;/strong&gt;对并发提供一定的支持。&lt;/p&gt;
&lt;h4&gt;　　　　2.没有站在足够高的角度构建数据结构容器的关系&lt;/h4&gt;
&lt;p&gt;　　　　java在设计自身的数据结构容器的架构时，高屋建瓴的设计出了一个庞大复杂的集合类型关系。这使得java的数据结构容器&lt;strong&gt;API&lt;/strong&gt;接口非常的灵活，各种内部实现迥然不同的容器可以很轻松的互相转化，使用者可以无负担的切换所使用的数据结构容器。同时，这样的设计也使编写出抽象程度很高的API接口成为可能，减少了大量的重复代码。&lt;/p&gt;
&lt;h4&gt;　　　　3.接口不够丰富&lt;/h4&gt;
&lt;p&gt;　　　　限于篇幅，这里仅仅列举和介绍了主要的向量接口，还有许多常见的需求接口没有实现。其实，在理解了前面内容的基础之上，实现一些其它常用的接口也并不困难。&lt;/p&gt;
&lt;h4&gt;　　　　4.异常处理不够严谨&lt;/h4&gt;
&lt;p&gt;　　　　在当前版本的下标越界校验中，没有对容器可能产生的各种异常进行仔细的归类和设计，抛出的是最基础的&lt;strong&gt;RunTimeException，&lt;/strong&gt;这使得用户无法针对容器抛出的异常类型进行更加细致的处理。&lt;/p&gt;
&lt;h3&gt;　　5.3 &quot;自己动手实现java数据结构&quot;系列博客后续&lt;/h3&gt;
&lt;p&gt;　　这是&quot;自己动手实现java数据结构&quot;系列的第一篇博客，因此选择了相对比较简单的&quot;&lt;strong&gt;向量&lt;/strong&gt;&quot;数据结构入手。&lt;/p&gt;
&lt;p&gt;　　我的目标并不在于写出非常完善的数据结构实现，而是尝试着用&lt;strong&gt;最易于接受的方式&lt;/strong&gt;使大家&lt;strong&gt;熟悉常用的数据结构&lt;/strong&gt;。如果读者能够在阅读这篇博客之后，在理解思路，原理的基础之上，自己动手实现一个初级，原始的向量数据结构，以及在此基础上进行优化，那么这篇博客的目标就完美达成啦。&lt;/p&gt;
&lt;p&gt;　　本系列博客的代码在我的 github上：&lt;span&gt;https://github.com/1399852153/DataStructures&lt;/span&gt; ，欢迎交流 0.0。&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 13:54:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>1.向量介绍 计算机程序主要运行在内存中，而内存在逻辑上可以被看做是连续的地址。为了充分利用这一特性，在主流的编程语言中都存在一种底层的被称为数组(Array)的数据结构与之对应。在使用数组时需要事先</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxiongcanguan/p/9977275.html</dc:identifier>
</item>
<item>
<title>Linux资源分析工具杂谈(长文慎入) - SolidMango</title>
<link>http://www.cnblogs.com/pugang/p/10009896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pugang/p/10009896.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;Linux资源分析工具杂谈&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       开篇之前请大家先思考一个问题：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;       磁盘的平均I/O响应时间是1 ms，这个指标是好，还是差？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       众所周知，计算机科学是客观的，也就是说对于一个给定的问题，我们总是能给出明确的答案，比如我们网上购物买了两件100元的衣服，我们应该付款200元，但是系统给我们计算出的金额确是300元，我们可以明确的告诉商家，结果算错了。与此不同，性能却常常是主观的，甚至对性能问题的判断都可能是不准确的，比如我们刚刚提到的1ms，一定有人认为是好的，也有人认为是差的，要客观的回答这个问题，可能是一项系统性的工作，必须需要首先定义基准（基准定义本身相对复杂，内容可以写一本书，在此不做深入讨论），有了基准指标，通过比较才能得出合理的结论。表1列出了一些数值，期望可以使大家对计算机科学的一些延时有一个粗略的概念，表中以一个3.3GHZ主频的CPU一次访问寄存器为基准进行说明，比如如果我们认为计算机世界中一次寄存器访问的时间0.3纳秒是现实生活中的1秒，那么访问一次内存的相对时间就是6分钟，表1中参考数据源自互联网。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213210143-848508298.png&quot; alt=&quot;&quot; width=&quot;795&quot; height=&quot;509&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表1. 计算机科学中的延时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       软件发展到今天可谓日新月异，短短的几十年中极大的提高了人类的生产力。伴随着软件功能的发展，软件的复杂度也在几何级的增长，从经济性的角度来讲，人们总是希望投入更少的硬件资源，更少的电力，更少的时间来完成更多的生产任务，人们期望自己的每一度电，每一分钟时间都在用在有意义的生产活动中。面对复杂的软件，我们如何知道软件在做有意义的事情而不是在无意义的阻塞，或者系统的哪一部分确实存在性能瓶颈，比如内存太小，硬盘太慢，CPU太慢等等。系统性能分析可以在不同的维度进行审视，常用的维度有负载分析和资源分析，本文希望从资源分析的角度对相关的工具进行讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       中国有句古话，工欲善其事，必先利其器，人类文明进步的最重要的标志就是可以在对的时候使用对的工具。但是问题来了，什么是对的时候使用对的工具？前人对问题总结后分成了三类，第一种是理解问题，也知道如何解决问题，第二种是理解问题，但是以个人的能力无法解决问题，第三类问题是不知道问题的存在，更不知道如何解决问题。第一种问题和第二种问题我们称之为基础问题，因为我们可以通过个人能力或者团队合作解决这类问题，第三种问题未知的未知才是我们需要重点关注的问题，理论上来说，在一个成熟的软件开发周期中，不允许存在未知的未知，我们需要对系统的各个层次都有透彻的理解和深入的把握。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       当今世界的三大主流操作系统Linux, Windows NT, Mac OS都提供了系统的工具集来监控，排查各类性能问题，比如Windows平台上Mark Russinovich的Sysinternals工具集，Windbg工具集，Linux 平台上的Sysstat工具集, Brendan Gregg力推的DTrace工具集。为了解决已知和未知的问题，我们首先需要对操作系统和硬件的相关指标有一个基础的认识，否则即使有了适合的工具，统计出了详尽的结果，我们仍然无法透彻的理解软件和系统发生了什么。如图1所示是性能分析大神Brendan Gregg对常用的性能分析工具进行的详尽总结。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213325906-1951116992.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1. Linux Performance Tools&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;基础篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;       下面我们对图1中的一些常用基础分析工具以及应用场景进行简单的分析。常用的性能分析工具包括：uptime, vmstat, mpstat, sar, ps, top, pidstat等等，这些命令的简单描述请见表2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213506920-662989955.png&quot; alt=&quot;&quot; width=&quot;657&quot; height=&quot;357&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表2. 常用性能分析工具简单描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       系统发生CPU性能问题时通常第一个使用的命令是uptime和top，uptime命令输出系统过去1分钟，5分钟和15分钟的平均负载，通过这三个数值可以粗略的分析出系统过去15分钟内负载是降低了，升高了，或者是持平，uptime运行结果如图2所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213616090-1892950589.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2. uptime运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       多核系统分析中接下来要使用的命令通常是mpstat，我们可以通过mpstat对CPU的每个核的使用情况都进行监控，mpstat不仅可以对每个核心的数据进行分别统计，还可以对所有核心的平均使用情况进行统计，mpstat运行结果如图3所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213700254-486566474.png&quot; alt=&quot;&quot; width=&quot;1440&quot; height=&quot;263&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3. mpstat运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       当我们使用top发现某一个进程的CPU或者其他资源使用异常的时候，我们可能需要引入第三个命令pidstat，我们甚至可以将这一统计数据精确到具体的线程。Top和pidstat运行结果见图4和图5。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213746744-1275884705.png&quot; alt=&quot;&quot; width=&quot;1265&quot; height=&quot;726&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图4. Top运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213811347-2123799377.png&quot; alt=&quot;&quot; width=&quot;1263&quot; height=&quot;447&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图5. Pidstat分线程运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       当我们需要对tcp流量进行简单统计，又不愿意要引入更复杂的tcpdump网络监控的时候，sar命令是个不错的选择，当然，统计网络流量只是sar的一个功能而已，更多功能可以参考sar man page， 使用sar命令统计tcp流量运行结果如图6所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213908268-460277872.png&quot; alt=&quot;&quot; width=&quot;1268&quot; height=&quot;556&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图6. sar命令统计tcp流量运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       限于篇幅的原因，此处不再一一讨论图1中的每一个命令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;进阶篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;       动态追踪是一种高级调试技术可以帮助开发人员以非常低的成本快速排查和解决软件性能问题。当今世界软件面临的问题一是规模，二是复杂度。随着 BPF 追踪系统（基于时间采样）最后一个主要功能被合并至 Linux 4.9-rc1 版本的内核中，Linux内核拥有了类似DTrace的原生追踪功能。DTrace是Solaris系统中的高级追踪器，功能强大，对于长期使用 DTrace 的用户，这是一个振奋人心的消息，现在Linux系统上可以在生产环境中使用安全的、低负载的定制追踪系统，通过执行时间的柱状图和频率统计等信息，分析应用的性能以及内核。最初用于Linux的追踪项目有很多，但是这个最终被合并进Linux内核的技术从一开始就根本不是一个追踪项目：它最开始是用于伯克利包过滤器 Berkeley Packet Filter（BPF）的一个增强功能。这些补丁允许BPF重定向数据包，从而创建软件定义网络。久而久之，对事件追踪的支持就被添加进来了，使得程序追踪可用于Linux系统。BPF Compiler Collection (BCC), PLY 和 BPFTRACE都是正在开发的BPF前端，BCC架构如图7所示，下面以BCC为例对Linux动态追踪技术进行简单说明，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213947648-393501706.png&quot; alt=&quot;&quot; width=&quot;1193&quot; height=&quot;835&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图7. Linux BCC/BPF Tracing Tools&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       假设我们有这样一个场景，系统中偶尔会运行新的进程，这些新的进程可能会消耗大量系统资源，从而对我们生产上运行的环境产生干扰，但是这种进程可能运行时间极为短暂，我们怎样才能知道发生了这种情况呢？top？可能不行，时间太短了，可能top还没来得及统计，进程已经退出了。这种情况下最适合使用的工具之一就是BCC工具集中的execsnoop，图8中可以看出，每一个新启动的进程都会被记录在案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123214023414-1879492529.png&quot; alt=&quot;&quot; width=&quot;1245&quot; height=&quot;492&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图8. Execsnoop命令运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       网络程序开发中我们可能想要按照TCP连接来统计一下通信两端的吞吐量和生命周期，这个时候tcplife就派上用场了，tcplife对TCP会话的生命周期和吞吐量统计如图9所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123214050846-1867111544.png&quot; alt=&quot;&quot; width=&quot;1334&quot; height=&quot;391&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图9. Tcplife命令运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       对于一个给定的进程，我们甚至可以要求内核通过BPF统计CPU处理之外时间的内核和用户堆栈，具体使用方法和示例请见图10。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123214111639-731792182.png&quot; alt=&quot;&quot; width=&quot;1345&quot; height=&quot;1275&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图10 offcputime命令运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       本文对Linux资源分析相关的基础工具、高级工具以及典型应用场景进行了简单的总结，算是抛砖引玉，希望对大家有所帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 13:45:00 +0000</pubDate>
<dc:creator>SolidMango</dc:creator>
<og:description>Linux资源分析工具杂谈 开篇之前请大家先思考一个问题： 磁盘的平均I/O响应时间是1 ms，这个指标是好，还是差？ 众所周知，计算机科学是客观的，也就是说对于一个给定的问题，我们总是能给出明确的答</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pugang/p/10009896.html</dc:identifier>
</item>
</channel>
</rss>