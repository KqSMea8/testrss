<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>推荐几个IDEA插件，Java开发者撸码利器。 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/8799437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/8799437.html</guid>
<description>&lt;h2 id=&quot;2-JRebel-for-IntelliJ&quot;&gt;这里只是推荐一下好用的插件，具体的使用方法不一一详细介绍。 &lt;/h2&gt;
&lt;h2&gt;JRebel for IntelliJ&lt;/h2&gt;
&lt;p&gt;一款热部署插件，只要不是修改了项目的配置文件，用它都可以实现热部署。收费的，破解比较麻烦。不过功能确实很强大。算是开发必备神器了。热部署快捷键是control+F9/command+F9。&lt;/p&gt;
&lt;h2&gt;.ignore&lt;/h2&gt;
&lt;p&gt;git提交时过滤掉不需要提交的文件，很方便，有些本地文件是不需要提交到Git上的。&lt;/p&gt;
&lt;h2&gt;CamelCase&lt;/h2&gt;
&lt;p&gt;将不是驼峰格式的名称，快速转成驼峰格式，安装好后，选中要修改的名称，按快捷键shift+alt+u。&lt;/p&gt;
&lt;h2&gt;Lombok plugin&lt;/h2&gt;
&lt;p&gt;开发神器，可以简化你的实体类，让你i不再写get/set方法，还能快速的实现builder模式，以及链式调用方法，总之就是为了简化实体类而生的插件。&lt;/p&gt;
&lt;h2&gt;Mybatis plugin&lt;/h2&gt;
&lt;p&gt;可以在mapper接口中和mapper的xml文件中来回跳转，就想接口跳到实现类那样简单。&lt;/p&gt;
&lt;h2&gt;codehelper.generator&lt;/h2&gt;
&lt;p&gt;可以让你在创建一个对象并赋值的时候，快速的生成代码，不需要一个一个属性的向里面set,根据new关键字，自动生成掉用set方法的代码，还可以一键填入默认值。&lt;/p&gt;
&lt;div class=&quot;page__content&quot;&gt;
&lt;div class=&quot;g-container&quot;&gt;
&lt;div class=&quot;g-row plugin-content&quot;&gt;
&lt;div class=&quot;g-col-8 _md-12&quot;&gt;
&lt;div class=&quot;plugin-content__description article-content&quot;&gt;
&lt;p&gt;GenAllSetter 特性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Java方法中, 根据 &lt;code&gt;new&lt;/code&gt; 关键词, 为Java Bean 生成所有Setter方法。&lt;/li&gt;
&lt;li&gt;按GenAllSetter键两次, 会为Setter方法生成默认值。&lt;/li&gt;
&lt;li&gt;可在&lt;code&gt;Intellij Idea&lt;/code&gt;中为&lt;code&gt;GenAllSetter&lt;/code&gt;设置快捷键。&lt;/li&gt;
&lt;li&gt;如何使用:
&lt;ul&gt;&lt;li&gt;将光标移动到 &lt;code&gt;new&lt;/code&gt; 语句的下一行。&lt;/li&gt;
&lt;li&gt;点击主菜单Tools-&amp;gt; Codehelper-&amp;gt; GenAllSetter, 或者按下&lt;code&gt;GenAllSetter&lt;/code&gt;快捷键。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;GenDaoCode 特性&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;根据Pojo 文件一键生成 Dao，Service，Xml，Sql文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Pojo文件更新后一键更新对应的Sql和mybatis xml文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;提供insert，insertList，update，select，delete五种方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;能够批量生成多个Pojo的对应的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自动将pojo的注释添加到对应的Sql文件的注释中。 &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;丰富的配置，如果没有配置文件，则会使用默认配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以在Intellij Idea中快捷键配置中配置快捷键。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;目前支持MySQL + Java，后续会支持更多的DB。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果喜欢我们的插件，非常感谢您的分享。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;GenDaoCode 使用方法&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;主菜单Tools-&amp;gt; Codehelper-&amp;gt; GenDaoCode 按键便可生成代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方法一：点击GenDaoCode，然后根据提示框输入Pojo名字，多个Pojo以 | 分隔。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Codehelper Generator会根据默认配置为您生成代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方法二：在工程目录下添加文件名为codehelper.properties的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;点击GenDaoCode，Codehelper Generator会根据您的配置文件为您生成代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;下面几个是装X神器了（让你的开发工具变得靓丽起来）&lt;/h2&gt;
&lt;h2&gt;Material Theme UI&lt;/h2&gt;
&lt;p&gt;这是一款主题插件，可以让你的ide的图标变漂亮，配色搭配的很到位，还可以切换不同的颜色，甚至可以自定义颜色。默认的配色就很漂亮了，如果需要修改配色，可以在工具栏中Tools-&amp;gt;Material Theme然后修改配色等。&lt;/p&gt;
&lt;h2&gt;Background image Plus&lt;/h2&gt;
&lt;p&gt;这是一款可以设置idea背景图片的插件，不但可以设置固体的图片，还可以设置一段时间后随机变化背景图片，以及设置图片的透明度等等。&lt;/p&gt;
&lt;h2&gt;active-power-mode&lt;/h2&gt;
&lt;p&gt;这是一款让你在编码的时候，整个屏幕都为之颤抖的插件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/772743/201804/772743-20180411232130374-2087271550.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;TOP-3-Nyan-progress-bar&quot;&gt;Nyan progress bar&lt;/h2&gt;
&lt;p&gt;这是一个将你idea中的所有的进度条都变成萌新动画的小插件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/772743/201804/772743-20180411233141721-621184731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;好的开发工具可以提高开发效率，所以的能让自己提高效率，把时间节省出来去学习，去提升自己。这些插件只是日常开发当中用到的一些，等到以后再发现了新的好玩的有意思，和提高工作效率的插件，继续分享出来。&lt;/p&gt;


</description>
<pubDate>Wed, 11 Apr 2018 15:39:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jimoer/p/8799437.html</dc:identifier>
</item>
<item>
<title>JDBC入门学习 - KrAchill</title>
<link>http://www.cnblogs.com/xld21/p/8799443.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xld21/p/8799443.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;我是通过传智博客学习的，也向大家推荐一下&lt;/strong&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;JDBC&lt;span&gt;入门&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;l &lt;span&gt;导&lt;/span&gt;jar&lt;span&gt;包：驱动！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;加载驱动类：&lt;/span&gt;Class.forName(“类名”);&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;给出&lt;/span&gt;url&lt;span&gt;、&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;，其中&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;背下来！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;使用&lt;/span&gt;DriverManager&lt;span&gt;类来得到&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;对象！&lt;/span&gt;&lt;/p&gt;



&lt;h6&gt;&lt;strong&gt;1&lt;span&gt;　什么是&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;JDBC&lt;span&gt;（&lt;/span&gt;Java DataBase Connectivity&lt;span&gt;）就是&lt;/span&gt;Java&lt;span&gt;数据库连接，说白了就是用&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;语言来操作数据库。原来我们操作数据库是在控制台使用&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语句来操作数据库，&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;span&gt;是用&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;语言向数据库发送&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语句。&lt;/span&gt;&lt;/p&gt;

&lt;h6&gt;&lt;strong&gt;2&lt;span&gt;　&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;span&gt;原理&lt;/span&gt;&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;早期&lt;/span&gt;SUN&lt;span&gt;公司的天才们想编写一套可以连接天下所有数据库的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;，但是当他们刚刚开始时就发现这是不可完成的任务，因为各个厂商的数据库服务器差异太大了。后来&lt;/span&gt;&lt;span&gt;SUN&lt;/span&gt;&lt;span&gt;开始与数据库厂商们讨论，最终得出的结论是，由&lt;/span&gt;&lt;span&gt;SUN&lt;/span&gt;&lt;span&gt;提供一套访问数据库的规范（就是一组接口），并提供连接数据库的协议标准，然后各个数据库厂商会遵循&lt;/span&gt;&lt;span&gt;SUN&lt;/span&gt;&lt;span&gt;的规范提供一套访问自己公司的数据库服务器的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;出现。&lt;/span&gt;&lt;span&gt;SUN&lt;/span&gt;&lt;span&gt;提供的规范命名为&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;span&gt;，而各个厂商提供的，遵循了&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;span&gt;规范的，可以访问自己数据库的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;被称之为驱动！&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;JDBC&lt;span&gt;是接口，而&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;span&gt;驱动才是接口的实现，没有驱动无法完成数据库连接！每个数据库厂商都有自己的驱动，用来连接自己公司的数据库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然还有第三方公司专门为某一数据库提供驱动，这样的驱动往往不是开源免费的！&lt;/p&gt;

&lt;h6&gt;&lt;strong&gt;3&lt;span&gt;　&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;span&gt;核心类（接口）介绍&lt;/span&gt;&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;JDBC&lt;span&gt;中的核心类有：&lt;/span&gt;&lt;span&gt;DriverManager&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;，和&lt;/span&gt;&lt;span&gt;ResultSet&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;DriverManger&lt;span&gt;（驱动管理器）的作用有两个：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;注册驱动：这可以让&lt;/span&gt;JDBC&lt;span&gt;知道要使用的是哪个驱动；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;获取&lt;/span&gt;Connection&lt;span&gt;：如果可以获取到&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;，那么说明已经与数据库连接上了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Connection&lt;span&gt;对象表示连接，与数据库的通讯都是通过这个对象展开的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l Connection&lt;span&gt;最为重要的一个方法就是用来获取&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;对象；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Statement&lt;span&gt;是用来向数据库发送&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语句的，这样数据库就会执行发送过来的&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语句：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l void executeUpdate(String sql)&lt;span&gt;：执行更新操作（&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;等）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l ResultSet executeQuery(String sql)&lt;span&gt;：执行查询操作，数据库在执行查询后会把查询结果，查询结果就是&lt;/span&gt;&lt;span&gt;ResultSet&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;ResultSet&lt;span&gt;对象表示查询结果集，只有在执行查询操作后才会有结果集的产生。结果集是一个二维的表格，有行有列。操作结果集要学习移动&lt;/span&gt;&lt;span&gt;ResultSet&lt;/span&gt;&lt;span&gt;内部的“行光标”，以及获取当前行上的每一列上的数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l boolean next()&lt;span&gt;：使“行光标”移动到下一行，并返回移动后的行是否存在；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l XXX getXXX(int col)&lt;span&gt;：获取当前行指定列上的值，参数就是列数，列数从&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;开始，而不是&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h6&gt;&lt;strong&gt;4&lt;span&gt;　&lt;/span&gt;&lt;span&gt;Hello JDBC&lt;/span&gt;&lt;/strong&gt;&lt;/h6&gt;

&lt;p&gt;&lt;span&gt;下面开始编写第一个&lt;/span&gt;JDBC&lt;span&gt;程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1&lt;span&gt;　&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;数据库的驱动&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;mysql-connector-java-5.1.13-bin.jar&lt;/strong&gt;&lt;strong&gt;；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.2&lt;span&gt;　获取连接&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取连接需要两步，一是使用&lt;/span&gt;DriverManager&lt;span&gt;来注册驱动，二是使用&lt;/span&gt;&lt;span&gt;DriverManager&lt;/span&gt;&lt;span&gt;来获取&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注册驱动&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;看清楚了，注册驱动就只有一句话：&lt;/span&gt;Class.forName(&lt;/strong&gt;&lt;strong&gt;“&lt;/strong&gt;&lt;strong&gt;com.mysql.jdbc.Driver&lt;/strong&gt;&lt;strong&gt;”&lt;/strong&gt;&lt;strong&gt;)&lt;span&gt;，下面的内容都是对这句代码的解释。今后我们的代码中，与注册驱动相关的代码只有这一句。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DriverManager&lt;span&gt;类的&lt;/span&gt;&lt;span&gt;registerDriver()&lt;/span&gt;&lt;span&gt;方法的参数是&lt;/span&gt;&lt;span&gt;java.sql.Driver&lt;/span&gt;&lt;span&gt;，但&lt;/span&gt;&lt;span&gt;java.sql.Driver&lt;/span&gt;&lt;span&gt;是一个接口，实现类由&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;驱动来提供，&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;驱动中的&lt;/span&gt;&lt;span&gt;java.sql.Driver&lt;/span&gt;&lt;span&gt;接口的实现类为&lt;/span&gt;&lt;span&gt;com.mysql.jdbc.Driver&lt;/span&gt;&lt;span&gt;！那么注册驱动的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;DriverManager.registerDriver(new com.mysql.jdbc.Driver());&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面代码虽然可以注册驱动，但是出现硬编码（代码依赖&lt;/span&gt;mysql&lt;span&gt;驱动&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包），如果将来想连接&lt;/span&gt;&lt;span&gt;Oracle&lt;/span&gt;&lt;span&gt;数据库，那么必须要修改代码的。并且其实这种注册驱动的方式是注册了两次驱动！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JDBC&lt;span&gt;中规定，驱动类在被加载时，需要自己“主动”把自己注册到&lt;/span&gt;&lt;span&gt;DriverManger&lt;/span&gt;&lt;span&gt;中，下面我们来看看&lt;/span&gt;&lt;span&gt;com.mysql.jdbc.Driver&lt;/span&gt;&lt;span&gt;类的源代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;com.mysql.jdbc.Driver.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Driver &lt;span&gt;extends&lt;/span&gt; NonRegisteringDriver &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; java.sql.Driver {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            java.sql.DriverManager.registerDriver(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Driver());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException E) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;Can't register driver!&quot;&lt;span&gt;);
        }
    }
……
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;com.mysql.jdbc.Driver&lt;span&gt;类中的&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;块会创建本类对象，并注册到&lt;/span&gt;&lt;span&gt;DriverManager&lt;/span&gt;&lt;span&gt;中。这说明只要去加载&lt;/span&gt;&lt;span&gt;com.mysql.jdbc.Driver&lt;/span&gt;&lt;span&gt;类，那么就会执行这个&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;块，从而也就会把&lt;/span&gt;&lt;span&gt;com.mysql.jdbc.Driver&lt;/span&gt;&lt;span&gt;注册到&lt;/span&gt;&lt;span&gt;DriverManager&lt;/span&gt;&lt;span&gt;中，所以可以把&lt;/span&gt;&lt;strong&gt;注册驱动类&lt;/strong&gt;的代码修改为&lt;strong&gt;加载驱动类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Class.forName(“com.mysql.jdbc.Driver”);&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;获取连接&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;获取连接的也只有一句代码：&lt;/span&gt;DriverManager.getConnection(url,username,password)&lt;span&gt;，其中&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;是登录数据库的用户名和密码，如果我没说错的话，你的&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;数据库的用户名和密码分别是：&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;url&lt;span&gt;查对复杂一点，它是用来找到要连接数据库“网址”，就好比你要浏览器中查找百度时，也需要提供一个&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;。下面是&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;jdbc:mysql://localhost:3306/mydb1&lt;/p&gt;
&lt;p&gt;JDBC&lt;span&gt;规定&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;的格式由三部分组成，每个部分中间使用逗号分隔。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;第一部分是&lt;/span&gt;jdbc&lt;span&gt;，这是固定的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;第二部分是数据库名称，那么连接&lt;/span&gt;mysql&lt;span&gt;数据库，第二部分当然是&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;第三部分是由数据库厂商规定的，我们需要了解每个数据库厂商的要求，&lt;/span&gt;mysql&lt;span&gt;的第三部分分别由数据库服务器的&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址（&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;）、端口号（&lt;/span&gt;&lt;span&gt;3306&lt;/span&gt;&lt;span&gt;），以及&lt;/span&gt;&lt;span&gt;DATABASE&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;(mydb1)&lt;/span&gt;&lt;span&gt;组成。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;下面是获取连接的语句：&lt;/p&gt;
&lt;p&gt;Connection con = DriverManager.getConnection(“jdbc:mysql://localhost:3306/mydb1”,”root”,”123”);&lt;/p&gt;

&lt;p&gt;&lt;span&gt;还可以在&lt;/span&gt;url&lt;span&gt;中提供参数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;jdbc:mysql://localhost:3306/mydb1&lt;strong&gt;?&lt;/strong&gt;&lt;strong&gt;useUnicode=true&lt;/strong&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt;&lt;strong&gt;characterEncoding=&lt;/strong&gt;&lt;strong&gt;UTF8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;useUnicode&lt;span&gt;参数指定这个连接数据库的过程中，使用的字节集是&lt;/span&gt;&lt;span&gt;Unicode&lt;/span&gt;&lt;span&gt;字节集；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;characherEncoding&lt;span&gt;参数指定穿上连接数据库的过程中，使用的字节集编码为&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;编码。请注意，&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;中指定&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;编码是给出的是&lt;/span&gt;&lt;span&gt;UTF8&lt;/span&gt;&lt;span&gt;，而不是&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;。要小心了！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.3&lt;span&gt;　获取&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在得到&lt;/span&gt;Connectoin&lt;span&gt;之后，说明已经与数据库连接上了，下面是通过&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;获取&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;对象的代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Statement stmt = con.createStatement();&lt;/p&gt;
&lt;p&gt;Statement&lt;span&gt;是用来向数据库发送要执行的&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语句的！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.4&lt;span&gt;　发送&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;增、删、改语句&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String sql = “insert into user value(’zhangSan’, ’123’)”;&lt;/p&gt;
&lt;p&gt;int m = stmt.executeUpdate(sql);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;/span&gt;int&lt;span&gt;类型的返回值表示执行这条&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语句所影响的行数，我们知道，对&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;来说，最后只能影响一行，而&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;可能会影响&lt;/span&gt;&lt;span&gt;0~n&lt;/span&gt;&lt;span&gt;行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果&lt;/span&gt;SQL&lt;span&gt;语句执行失败，那么&lt;/span&gt;&lt;span&gt;executeUpdate()&lt;/span&gt;&lt;span&gt;会抛出一个&lt;/span&gt;&lt;span&gt;SQLException&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.5&lt;span&gt;　发送&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;查询语句&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String sql = “select * from user”;&lt;/p&gt;
&lt;p&gt;ResultSet rs = stmt.executeQuery(sql);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请注册，执行查询使用的不是&lt;/span&gt;executeUpdate()&lt;span&gt;方法，而是&lt;/span&gt;&lt;span&gt;executeQuery()&lt;/span&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;span&gt;executeQuery()&lt;/span&gt;&lt;span&gt;方法返回的是&lt;/span&gt;&lt;span&gt;ResultSet&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;ResultSet&lt;/span&gt;&lt;span&gt;封装了查询结果，我们称之为结果集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.6&lt;span&gt;　读取结果集中的数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ResultSet&lt;span&gt;就是一张二维的表格，它内部有一个“行光标”，光标默认的位置在“第一行上方”，我们可以调用&lt;/span&gt;&lt;span&gt;rs&lt;/span&gt;&lt;span&gt;对象的&lt;/span&gt;&lt;span&gt;next()&lt;/span&gt;&lt;span&gt;方法把“行光标”向下移动一行，当第一次调用&lt;/span&gt;&lt;span&gt;next()&lt;/span&gt;&lt;span&gt;方法时，“行光标”就到了第一行记录的位置，这时就可以使用&lt;/span&gt;&lt;span&gt;ResultSet&lt;/span&gt;&lt;span&gt;提供的&lt;/span&gt;&lt;span&gt;getXXX(int col)&lt;/span&gt;&lt;span&gt;方法来获取指定列的数据了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;rs.next();//&lt;span&gt;光标移动到第一行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;rs.getInt(1);//&lt;span&gt;获取第一行第一列的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你使用&lt;/span&gt;rs.getInt(1)&lt;span&gt;方法时，你必须可以肯定第&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;列的数据类型就是&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;类型，如果你不能肯定，那么最好使用&lt;/span&gt;&lt;span&gt;rs.getObject(1)&lt;/span&gt;&lt;span&gt;。在&lt;/span&gt;&lt;span&gt;ResultSet&lt;/span&gt;&lt;span&gt;类中提供了一系列的&lt;/span&gt;&lt;span&gt;getXXX()&lt;/span&gt;&lt;span&gt;方法，比较常用的方法有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Object getObject(int col)&lt;/p&gt;
&lt;p&gt;String getString(int col)&lt;/p&gt;
&lt;p&gt;int getInt(int col)&lt;/p&gt;
&lt;p&gt;double getDouble(int col)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.7&lt;span&gt;　关闭&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与&lt;/span&gt;IO&lt;span&gt;流一样，使用后的东西都需要关闭！关闭的顺序是先得到的后关闭，后得到的先关闭。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;rs.close();&lt;/p&gt;
&lt;p&gt;stmt.close();&lt;/p&gt;
&lt;p&gt;con.close();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.8&lt;span&gt;　代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static Connection getConnection() throws Exception {
                Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
                String url = &quot;jdbc:mysql://localhost:3306/mydb1&quot;;
                return DriverManager.getConnection(url, &quot;root&quot;, &quot;123&quot;);
        }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insert() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Connection con &lt;/span&gt;=&lt;span&gt; getConnection();
        Statement stmt &lt;/span&gt;=&lt;span&gt; con.createStatement();
        String sql &lt;/span&gt;= &quot;insert into user values('zhangSan', '123')&quot;&lt;span&gt;;
        stmt.executeUpdate(sql);
        System.out.println(&lt;/span&gt;&quot;插入成功！&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; update() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Connection con &lt;/span&gt;=&lt;span&gt; getConnection();
        Statement stmt &lt;/span&gt;=&lt;span&gt; con.createStatement();
        String sql &lt;/span&gt;= &quot;update user set password='456' where username='zhangSan'&quot;&lt;span&gt;;
        stmt.executeUpdate(sql);
        System.out.println(&lt;/span&gt;&quot;修改成功！&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; delete() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Connection con &lt;/span&gt;=&lt;span&gt; getConnection();
        Statement stmt &lt;/span&gt;=&lt;span&gt; con.createStatement();
        String sql &lt;/span&gt;= &quot;delete from user where username='zhangSan'&quot;&lt;span&gt;;
        stmt.executeUpdate(sql);
        System.out.println(&lt;/span&gt;&quot;删除成功！&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; query() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Connection con &lt;/span&gt;=&lt;span&gt; getConnection();
        Statement stmt &lt;/span&gt;=&lt;span&gt; con.createStatement();
        String sql &lt;/span&gt;= &quot;select * from user&quot;&lt;span&gt;;
        ResultSet rs &lt;/span&gt;=&lt;span&gt; stmt.executeQuery(sql);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(rs.next()) {
            String username &lt;/span&gt;= rs.getString(1&lt;span&gt;);
            String password &lt;/span&gt;= rs.getString(2&lt;span&gt;);
            System.out.println(username &lt;/span&gt;+ &quot;, &quot; +&lt;span&gt; password);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.9&lt;span&gt;　规范化代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所谓规范化代码就是无论是否出现异常，都要关闭&lt;/span&gt;ResultSet&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;，以及&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;，如果你还记得&lt;/span&gt;&lt;span&gt;IO&lt;/span&gt;&lt;span&gt;流的规范化代码，那么下面的代码你就明白什么意思了。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; query() {
        Connection con &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Statement stmt &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        ResultSet rs &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
[在try外给出引用的定义]        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            con &lt;/span&gt;=&lt;span&gt; getConnection();[在try内为对象实例化]
            stmt &lt;/span&gt;=&lt;span&gt; con.createStatement();
            String sql &lt;/span&gt;= &quot;select * from user&quot;&lt;span&gt;;
            rs &lt;/span&gt;=&lt;span&gt; stmt.executeQuery(sql);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(rs.next()) {
                String username &lt;/span&gt;= rs.getString(1&lt;span&gt;);
                String password &lt;/span&gt;= rs.getString(2&lt;span&gt;);
                System.out.println(username &lt;/span&gt;+ &quot;, &quot; +&lt;span&gt; password);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(rs != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) rs.close();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(stmt != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) stmt.close();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(con != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) con.close();
[在finally中进行关闭]            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(SQLException e) {}
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 11 Apr 2018 15:38:00 +0000</pubDate>
<dc:creator>KrAchill</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xld21/p/8799443.html</dc:identifier>
</item>
<item>
<title>从零开始：一个正式的vue+webpack项目的目录结构是怎么形成的 - 闰土大叔</title>
<link>http://www.cnblogs.com/running-runtu/p/8799415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/8799415.html</guid>
<description>&lt;div readability=&quot;85&quot;&gt;
&lt;p&gt;如何从零开始一个vue+webpack前端工程工作流的搭建，首先我们先从项目的目录结构入手。一个持续可发展，不断加入新功能，方便后期维护的目录结构究竟是长什么样子的？接下来闰土大叔带你们一起手摸手学起来。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;初级前端初始化目录篇&lt;/h2&gt;
&lt;p&gt;项目伊始，我们肯定是先在terminal终端命令行（以下简称terminal）cd进入&amp;lt;project name&amp;gt;根目录，然后输入 &lt;code&gt;npm init&lt;/code&gt; 初始化一个npm项目，在项目根目录下面就会出现一个package.json文件。 然后就可以安装依赖了，直接在terminal里输入 &lt;code&gt;npm i webpack vue vue-loader -D&lt;/code&gt;。当我们把这几个安装好以后，terminal这边会提示我们WARN（警告⚠️）：&lt;/p&gt;

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4bc347a6104b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4bc347a6104b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;327&quot;/&gt;
&lt;p&gt;翻译过来大意是，vue-loader需要一个css-loader和vue-template-compiler作为它的第三方依赖,所以听它的话，我们去进行一下安装：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm i css-loader vue-template-compiler -D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那下面的警告信息提示我们缺少一些信息，这个其实无关痛痒，所以不需要去关心它。&lt;/p&gt;
&lt;p&gt;通过以上简单几个步骤，我们的项目就初始化好了。然后在根目录下面创建一个src文件夹，这是我们源码放置的目录。然后我们在src目录下面新建一个app.vue文件，里面就可以写一些关于项目的业务代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&amp;lt;template&amp;gt;
    &amp;lt;div id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&amp;gt;{{text}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span class=&quot;hljs-built_in&quot;&gt;export default {
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;data () {
            text: &lt;span class=&quot;hljs-string&quot;&gt;'闰土大叔'
        }
    }
&amp;lt;/script&amp;gt;
&amp;lt;style&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然这个后缀为.vue 文件是不可以在浏览器里直接运行的，我们需要想办法让它运行起来。&lt;/p&gt;
&lt;p&gt;现在我们要在项目根目录下新建一个webpack.config.js文件，webpack是帮我们前端来打包资源的，前端资源有很多不同的类型，比如说JavaScript，css，html，image，iconfont等这些资源都是需要通过http请求加载的东西。webpack是将一个js文件加载到浏览器端之后，然后去把所有的内容去渲染出来。所以，很多时候，我们可以把js文件作为项目的入口文件。&lt;/p&gt;
&lt;p&gt;这个时候，我们在src目录下新建一个index.js作为入口文件，顺便在里面写点东西：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;import Vue from &lt;span class=&quot;hljs-string&quot;&gt;'vue'
import App from &lt;span class=&quot;hljs-string&quot;&gt;'./app.vue'

const root = document.createElement(&lt;span class=&quot;hljs-string&quot;&gt;'div')
document.body.appendChild(root)

new Vue({
    render: (h) =&amp;gt; h(App)
}).&lt;span class=&quot;hljs-variable&quot;&gt;$mount(root)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;index.js准备完毕之后，那么在webpack.config.js里面就可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;const path = require(&lt;span class=&quot;hljs-string&quot;&gt;'path')

module.exports = {
    entry:  path.join(__dirname, &lt;span class=&quot;hljs-string&quot;&gt;'src/index.js'),
    output: {
        filename: &lt;span class=&quot;hljs-string&quot;&gt;'bundle.js',
        path: path.join(__dirname, &lt;span class=&quot;hljs-string&quot;&gt;'dist')
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，__dirname就代表这个文件所在的目录地址，path.join()的意思就是和后面的字符串路径拼接起来，形成一个绝对的路径。&lt;/p&gt;
&lt;p&gt;然后通过webpack把所有的文件打包成一个bundle.js文件，并且是能在浏览器里面直接运行的代码。现在我们可以在package.json 文件里的scripts对象里面添加一个脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;scripts&quot;: {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;build&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;webpack --config webpack.config.js&quot;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这儿，肯定有童鞋要问了，为什么要在这里面调用webpack而不是在terminal里面直接运行呢？&lt;/p&gt;
&lt;p&gt;因为只有在这里调用webpack，它才会优先调用我们项目里面安装的webpack版本，如果我们在命令行里面输入webpack，它会调动全局的webpack，这个时候全局的webpack可能会跟我们项目中的webpack版本不一致，所以我们还是采取这种方式比较稳妥。&lt;/p&gt;
&lt;p&gt;写完之后，我们就可以在terminal输入&lt;code&gt;npm run build&lt;/code&gt;跑一下，会尴尬地发现报错了：&lt;/p&gt;

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4e9708eac1be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4e9708eac1be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;672&quot;/&gt;
&lt;p&gt;这个错误告诉我们，需要为.vue文件去声明一个loader。因为webpack原生是只支持JS文件类型的，并且只支持ES5的语法，所以我们在使用超出它理解范围的语法的时候，我们要使用一些帮它去处理的工具。所以我们要在webpack.config.js文件里面继续写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;module: {
    rules: [
        {
            &lt;span class=&quot;hljs-built_in&quot;&gt;test: /.vue$/,
            loader: &lt;span class=&quot;hljs-string&quot;&gt;'vue-loader'
        }
    ]
}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加完这段之后，我们再去terminal执行下&lt;code&gt;npm run build&lt;/code&gt;，你会发现项目根目录下多了一个dist文件夹，点开里面发现webpack为我们自动打包生成了一个bundle.js文件，感兴趣的童鞋可以点开这个js文件看看：&lt;/p&gt;
&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4f43c4e29c1b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4f43c4e29c1b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;717&quot;/&gt;&lt;/div&gt;


&lt;div readability=&quot;128&quot;&gt;它里面代码很多，上面是固有的webpack的代码，这些代码是处理项目中的模块依赖的，因为我们项目里有很多的js相互依赖。

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4f5081d9a947?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4f5081d9a947?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;721&quot;/&gt;
&lt;p&gt;往下翻到100多行左右的时候，你会发现有很多的代码其实是vue源码。因为我们项目要依赖vue.js，所以webpack会把vue.js文件打包进来。&lt;/p&gt;

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4f82b0c9e685?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4f82b0c9e685?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;593&quot;/&gt;
&lt;p&gt;你可以通过快捷键 command (Ctrl) + F 查找关键词$mount看到，红线圈住的这段代码就是我们自己写的代码，其实webpack做的工作就是把这些不同的静态资源的类型打包成一个js，然后我们在html里面引用这个js，就可以正常运行。&lt;/p&gt;
&lt;p&gt;相信大家做前端都知道，在做一个项目开发的时候，我们希望把一些零碎的js文件打包到一起，这样可以减少http请求。同样的，我们希望使用模块依赖，因为项目中会做很多可复用的代码，把它写到一个模块里面去，这样的话当我们再去写一个新项目的时候，不用再把原来的代码重新写一遍，或者是拷贝一份。&lt;/p&gt;
&lt;p&gt;当然这里面我们暂时没有提到.babelrc、.eslintrc、editorconfig、postcss.config.js等，这些我们留到后面再讲。&lt;/p&gt;

&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;中级前端合理细化目录篇&lt;/h2&gt;

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b2e670d04f87a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b2e670d04f87a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;564&quot;/&gt;
&lt;p&gt;初始化工作完成之后，接下来我们要细分目录了。首先我们需要在项目的根目录下新建一个文件夹叫build，把webpack的文件单独放到这个文件夹里面。因为我们项目中会用到很多不同的相关文件的配置，接下来先新建一个 webpack.config.base.js 文件，我们把webpack里面需要用到的共同的配置放到这个base的文件里面。比如开发环境和正式环境，以及后期我们要提到的服务端渲染的环境。我们都依赖于base这个配置。&lt;/p&gt;
&lt;p&gt;以下是webpack.config.base.js文件里的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;const path = require(&lt;span class=&quot;hljs-string&quot;&gt;'path')
const createVueLoaderOptions = require(&lt;span class=&quot;hljs-string&quot;&gt;'./vue-loader.config')

const isDev = process.env.NODE_ENV === &lt;span class=&quot;hljs-string&quot;&gt;'development'

const config = {
  target: &lt;span class=&quot;hljs-string&quot;&gt;'web',
  entry: path.join(__dirname, &lt;span class=&quot;hljs-string&quot;&gt;'../client/index.js'),
  output: {
    filename: &lt;span class=&quot;hljs-string&quot;&gt;'bundle.[hash:8].js',
    path: path.join(__dirname, &lt;span class=&quot;hljs-string&quot;&gt;'../dist')
  },
  module: {
    rules: [
      {
        &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.(vue|js|jsx)$/,
        loader: &lt;span class=&quot;hljs-string&quot;&gt;'eslint-loader',
        exclude: /node_modules/,
        enforce: &lt;span class=&quot;hljs-string&quot;&gt;'pre'
      },
      {
        &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.vue$/,
        loader: &lt;span class=&quot;hljs-string&quot;&gt;'vue-loader',
        options: createVueLoaderOptions(isDev)
      },
      {
        &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.jsx$/,
        loader: &lt;span class=&quot;hljs-string&quot;&gt;'babel-loader'
      },
      {
        &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.js$/,
        loader: &lt;span class=&quot;hljs-string&quot;&gt;'babel-loader',
        exclude: /node_modules/
      },
      {
        &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.(gif|jpg|jpeg|png|svg)$/,
        use: [
          {
            loader: &lt;span class=&quot;hljs-string&quot;&gt;'url-loader',
            options: {
              &lt;span class=&quot;hljs-built_in&quot;&gt;limit: 1024,
              name: &lt;span class=&quot;hljs-string&quot;&gt;'resources/[path][name].[hash:8].[ext]'
            }
          }
        ]
      }
    ]
  }
}

module.exports = config

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们再新建一个 webpack.config.client.js ，这个client文件依赖于base文件，在此基础上扩展一些其他配置。因此我们需要在webpack.config.client.js里面敲入一行代码引入base文件 ：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const baseConfig = require('./webpack.config.base')&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;基础工作做完之后，我们该如何去扩展配置呢？首先在terminal终端命令行安装下 &lt;code&gt;npm i webpack-merge -D&lt;/code&gt; 我们需要webpack-merge这个工具帮助去扩展、合并不同的webpack配置，然后根据声明好的isDev来判断应该怎么合并配置。&lt;/p&gt;
&lt;p&gt;以下是webpack.config.client.js文件里的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;const path = require(&lt;span class=&quot;hljs-string&quot;&gt;'path')
const HTMLPlugin = require(&lt;span class=&quot;hljs-string&quot;&gt;'html-webpack-plugin')
const webpack = require(&lt;span class=&quot;hljs-string&quot;&gt;'webpack')
const merge = require(&lt;span class=&quot;hljs-string&quot;&gt;'webpack-merge')
const ExtractPlugin = require(&lt;span class=&quot;hljs-string&quot;&gt;'extract-text-webpack-plugin')
const baseConfig = require(&lt;span class=&quot;hljs-string&quot;&gt;'./webpack.config.base')

const isDev = process.env.NODE_ENV === &lt;span class=&quot;hljs-string&quot;&gt;'development'

const defaultPlugins = [
  new webpack.DefinePlugin({
    &lt;span class=&quot;hljs-string&quot;&gt;'process.env': {
      NODE_ENV: isDev ? &lt;span class=&quot;hljs-string&quot;&gt;'&quot;development&quot;' : &lt;span class=&quot;hljs-string&quot;&gt;'&quot;production&quot;'
    }
  }),
  new HTMLPlugin()
]

const devServer = {
  port: 8000,
  host: &lt;span class=&quot;hljs-string&quot;&gt;'0.0.0.0',
  overlay: {
    errors: &lt;span class=&quot;hljs-literal&quot;&gt;true
  },
  hot: &lt;span class=&quot;hljs-literal&quot;&gt;true
}

&lt;span class=&quot;hljs-built_in&quot;&gt;let config

&lt;span class=&quot;hljs-keyword&quot;&gt;if (isDev) {
  // 开发环境的配置
  config = merge(baseConfig, {
    devtool: &lt;span class=&quot;hljs-string&quot;&gt;'#cheap-module-eval-source-map',
    module: {
      rules: [
        {
          &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.styl/,
          use: [
            &lt;span class=&quot;hljs-string&quot;&gt;'vue-style-loader',
            &lt;span class=&quot;hljs-string&quot;&gt;'css-loader',
            // {
            //   loader: &lt;span class=&quot;hljs-string&quot;&gt;'css-loader',
            //   options: {
            //     module: &lt;span class=&quot;hljs-literal&quot;&gt;true,
            //     &lt;span class=&quot;hljs-built_in&quot;&gt;localIdentName: isDev ? &lt;span class=&quot;hljs-string&quot;&gt;'[path]-[name]-[hash:base64:5]' : &lt;span class=&quot;hljs-string&quot;&gt;'[hash:base64:5]'
            //   }
            // },
            {
              loader: &lt;span class=&quot;hljs-string&quot;&gt;'postcss-loader',
              options: {
                &lt;span class=&quot;hljs-built_in&quot;&gt;sourceMap: &lt;span class=&quot;hljs-literal&quot;&gt;true
              }
            },
            &lt;span class=&quot;hljs-string&quot;&gt;'stylus-loader'
          ]
        }
      ]
    },
    devServer,
    plugins: defaultPlugins.concat([
      new webpack.HotModuleReplacementPlugin(),
      new webpack.NoEmitOnErrorsPlugin()
    ])
  })
} &lt;span class=&quot;hljs-keyword&quot;&gt;else {
  // 正式环境的配置
  config = merge(baseConfig, {
    entry: {
      app: path.join(__dirname, &lt;span class=&quot;hljs-string&quot;&gt;'../client/index.js'),
      vendor: [&lt;span class=&quot;hljs-string&quot;&gt;'vue']
    },
    output: {
      filename: &lt;span class=&quot;hljs-string&quot;&gt;'[name].[chunkhash:8].js'
    },
    module: {
      rules: [
        {
          &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.styl/,
          use: ExtractPlugin.extract({
            fallback: &lt;span class=&quot;hljs-string&quot;&gt;'vue-style-loader',
            use: [
              &lt;span class=&quot;hljs-string&quot;&gt;'css-loader',
              {
                loader: &lt;span class=&quot;hljs-string&quot;&gt;'postcss-loader',
                options: {
                  &lt;span class=&quot;hljs-built_in&quot;&gt;sourceMap: &lt;span class=&quot;hljs-literal&quot;&gt;true
                }
              },
              &lt;span class=&quot;hljs-string&quot;&gt;'stylus-loader'
            ]
          })
        }
      ]
    },
    plugins: defaultPlugins.concat([
      new ExtractPlugin(&lt;span class=&quot;hljs-string&quot;&gt;'styles.[contentHash:8].css'),
      new webpack.optimize.CommonsChunkPlugin({
        name: &lt;span class=&quot;hljs-string&quot;&gt;'vendor'
      }),
      new webpack.optimize.CommonsChunkPlugin({
        name: &lt;span class=&quot;hljs-string&quot;&gt;'runtime'
      })
    ])
  })
}

module.exports = config

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，这个src文件夹我们要重命名一下，叫client，因为我们后期还要写服务端的代码，对应的就命名成server，正好对应它的含义。这样看起来，名称就变得更加的合理。&lt;/p&gt;
&lt;p&gt;当我们万事大吉的时候，千万记得要把 webpack.config.base.js 和 webpack.config.client.js 里面的src路径改掉，换成client，否则就会报错。&lt;/p&gt;

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b513d1c5fc7c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b513d1c5fc7c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;720&quot;/&gt;
&lt;p&gt;以上就是我们项目最终形成的目录结构，client目录下分别有assets、layout、views这三个文件夹，其中assets目录下放静态资源，例如images、styles等；layout目录下放通用布局的组件；views目录下放具体的业务代码的组件。&lt;/p&gt;
&lt;p&gt;当然，这个目录其实还可以随着项目的开发再细分下去，这里就不展开叙述了。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;大家一定要注意，在我们正式开发项目、创建一个项目工程的时候，一定要先把目录结构理顺，条理一定要清楚。每个目录结构里面放什么东西，心里一定要先有个概念。以后新建的文件不要乱放，因为项目一旦做大，维护时间比较久的时候，可能两三个月里面都有一个文件你不会去碰它。到时候如果要去找一个东西的时候，你会找不到它，这是非常令人难受的一件事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最重要的一点是，目录结构的混乱，会导致你后续开发项目的效率变得非常的低。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这次关于“一个正式项目的目录结构是怎么形成的”的话题就说到这里，我之后的文章会讲些什么呢？文章预告如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;eslint的错误修复小技巧&lt;/li&gt;
&lt;li&gt;vue-loader是如何配置的&lt;/li&gt;
&lt;li&gt;如何回答“对vue生命周期的理解”才能让面试官满意？&lt;/li&gt;
&lt;li&gt;浅谈css-module的配置&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;li&gt;正式环境打包以及异步模块打包优化&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;以上内容均会第一时间发布在我的公众号：闰土大叔 ，欢迎关注。&lt;/h3&gt;

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b5210a4abba19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b5210a4abba19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;258&quot; data-height=&quot;258&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 11 Apr 2018 15:34:00 +0000</pubDate>
<dc:creator>闰土大叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/8799415.html</dc:identifier>
</item>
<item>
<title>用js来实现那些数据结构（数组篇03） - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/8784575.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/8784575.html</guid>
<description>&lt;p&gt;　　终于，这是有关于数组的最后一篇，下一篇会真真切切给大家带来数据结构在js中的实现方式。那么这篇文章还是得啰嗦一下数组的相关知识，因为数组真的太重要了！不要怀疑数组在JS中的重要性与实用性。这篇文章分为两部分，第一部分会给大家简单说一下数组原生的排序方法sort和reverse。第二部分会给大家简单说一下二维和三维数组。都不难，仔细看，很简单的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、reverse()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;reverse比较容易理解，颠倒数组中元素的顺序，也就是第一个变成最后一个，最后一个呢变成第一个。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4,5,6,7&lt;span&gt;];
nums.reverse();
console.log(nums)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[7, 6, 5, 4, 3, 2, 1, 0]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　reverse方法只是无差别的对数组进行倒叙，可能很多时候并不适用于我们的应用场景，所以才出现了sort()方法。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2、sort()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　　　sort()方法可以说是js数组中不太容易记忆和使用的方法，但是sort()是十分重要的一个方法，那么下面我就详细的说明一下，sort()的应用场景和使用方法。&lt;/p&gt;
&lt;p&gt; 　　sort()方法允许传入一个匿名函数作为排序的依据，也可以不传参数，但是我想大家都知道，在不传参数的情况下，很多时候的结果并不是我们想要的，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,2,4,9,10,11,20,32,3,6,7,8,15,26&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newNums =&lt;span&gt; nums.sort();
console.log(newNums)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0, 10, 11, 15, 2, 20, 26, 3, 32, 4, 6, 7, 8, 9]&lt;/span&gt;
console.log(nums)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0, 10, 11, 15, 2, 20, 26, 3, 32, 4, 6, 7, 8, 9]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码说明，sort会改变原来的数组，而不是生成一个排序后的新数组，大家看到上面的排序并不是依据数字从大到小排序的。这是因为，sort在排序的时候会默认把数组中的各个元素转换成字符串，并且依据字符串对应的&lt;a href=&quot;https://baike.baidu.com/item/ASCII/309296?fr=aladdin&amp;amp;fromid=99077&amp;amp;fromtitle=ascii%E7%A0%81&quot; target=&quot;_blank&quot;&gt;ASCII码值&lt;/a&gt;来比较的，那&lt;a href=&quot;https://baike.baidu.com/item/ASCII/309296?fr=aladdin&amp;amp;fromid=99077&amp;amp;fromtitle=ascii%E7%A0%81&quot; target=&quot;_blank&quot;&gt;ASCII&lt;/a&gt;是什么？&lt;a href=&quot;https://baike.baidu.com/item/ASCII/309296?fr=aladdin&amp;amp;fromid=99077&amp;amp;fromtitle=ascii%E7%A0%81&quot; target=&quot;_blank&quot;&gt;ASCII&lt;/a&gt;是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。&lt;/p&gt;
&lt;p&gt;　　显然这不是我们想要的结果，所以就需要给sort传入一个函数（compareFunction）来使排序得到我们想要的结果或者自定义排序的方式。&lt;/p&gt;
&lt;p&gt;　　在大多数实际工作的排序中，我们都会依据id值得大小，或者一些依据数值大小来排序的场景。那么我们看看如何使用compareFunction来使sort排序可以得到正确的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,2,4,9,10,11,20,32,3,6,7,8,15,26&lt;span&gt;];
nums.sort(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (a,b) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a -&lt;span&gt; b;
})
console.log(nums)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [0, 2, 3, 4, 6, 7, 8, 9, 10, 11, 15, 20, 26, 32]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我在刚接触sort时候看到这样的写法，第一个反应就是a和b是什么？他所代表的参数是什么意义？为什么要用a和b?我用其他的参数可以么？&lt;/p&gt;
&lt;p&gt;　　首先，a和b在这里只是代表数组中任意两个元素的值，你可以使用任何两个参数来代表它。&lt;/p&gt;
&lt;p&gt;　　那么再给大家看一个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,2,4,9,10,11,20,32,3,6,7,8,15,26&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; i = 0&lt;span&gt;;
nums.sort(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (m,n) {
    console.log(m,n)
    console.log(&lt;/span&gt;++&lt;span&gt;i)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; m -&lt;span&gt; n;
})
console.log(nums)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [0, 2, 3, 4, 6, 7, 8, 9, 10, 11, 15, 20, 26, 32]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码，给大家留下一个疑问自己去找答案。这里不会多说，看看再不同数组长度下sort会循环多少次？m，n每一次的值又是什么样的？其实一个sort方法就包含很多更深层次的问题。&lt;/p&gt;
&lt;p&gt;　　那么还有一种场景，比如说后端传给我一个包含对象元素的数组，我需要依照id的大小来给这个数组排序，要怎么做呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
objArr.sort(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a,b){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; m =&lt;span&gt; a.id;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; n =&lt;span&gt; b.id;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; m -&lt;span&gt; n;
})
console.log(objArr)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　console出来的结果是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201804/1184971-20180411221656128-228285468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么这样就实现了我们在工作场景中排序的大多数的情况。那么如果你想要倒叙排序怎么办呢？a-b变成b-a。其实a-b这样的方式是简写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
nums.sort(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (a,b) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a&amp;lt;&lt;span&gt;b) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a&amp;gt;&lt;span&gt;b) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;或许这样更清晰一点，判断a和b值得大小来决定是否要调换两个值得位置，如果a&amp;lt;b那么a就放在b的后面，如果a&amp;gt;b，那么久把a放在b的前面，如果a既不大于b，也不小于b，那么说明a=b，则不改变两个值得位置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;这里有一篇文章，大家可以去看一下，&lt;a href=&quot;https://segmentfault.com/a/1190000000410506&quot;&gt;JS基础篇--sort()方法的用法，参数以及排序原理&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3、多维数组的使用及场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;其实多维数组在平时的工作中还是很常见的，最普通的要说是二维数组了，也可以叫做矩阵。但是其实js是不支持二维或者多维数组的，但是好在js够灵活，我没有的，都可以模拟出来。那么我们也可以通过数组嵌套数组的方式来模拟多维数组。&lt;/p&gt;
&lt;p&gt;　　我们先来看看二维数组：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; matrix = [[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;],[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;],[1,2,3,4]];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这就是一个简单的二维数组形式，我们通常需要遍历数组获取其中的每一个值，其实我们可以把二维数组视为行和列，第一层循环每一行，第二层循环每一行的每一列，这样就可以得到二维数组中的每一个元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; matrix = [[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;],[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;],[1,2,3,4&lt;span&gt;]];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; matrix.length; i++&lt;span&gt;) {
    document.write(&lt;/span&gt;&quot;&amp;lt;/br&amp;gt;&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; matrix[i].length;j++&lt;span&gt;) {
        document.write(matrix[i][j])
    }    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样我们就得到了一个二维数组内所有的元素。&lt;/p&gt;
&lt;p&gt;　　其实三维数组也是一样的，只是再多循环一层，我们来看一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; matrix3 =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
    matrix3[i] &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; 3; j++&lt;span&gt;) {
        matrix3[i][j] &lt;/span&gt;=&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; k = 0; k &amp;lt; 3; k++&lt;span&gt;) {
            matrix3[i][j][k] &lt;/span&gt;= i + j +&lt;span&gt; k;
        }
    }
}
console.log(matrix3)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201804/1184971-20180411225312177-447656454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　数组的介绍到这里就基本结束了，下一篇文章会跟大家一起来看看如何用JS来实现栈这种数据结构。&lt;/p&gt;
&lt;p&gt;　　最后，&lt;strong&gt;由于本人水平有限，能力与大神仍相差甚远，若有错误或不明之处，还望大家不吝赐教指正。非常感谢！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Apr 2018 15:08:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/8784575.html</dc:identifier>
</item>
<item>
<title>【原创】自己动手实现RPC服务调用框架 - 孤独烟</title>
<link>http://www.cnblogs.com/rjzheng/p/8798556.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rjzheng/p/8798556.html</guid>
<description>&lt;p&gt;本文利用java自带的socket编程实现了一个简单的rpc调用框架，由两个工程组成分别名为battercake-provider（服务提供者）、battercake-consumer（服务调用者）。&lt;/p&gt;
&lt;h2 id=&quot;服务提供者&quot;&gt;服务提供者&lt;/h2&gt;
&lt;p&gt;本部分的工程为battercake-provider，项目结构图如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1194802/o_batterprovider.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先上rpc框架调用部分的代码，RpcProvider，该部分代码可以总结为两步&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将需要发布的服务存储在一个内存变量serviceList中&lt;/li&gt;
&lt;li&gt;启动socket，server.accept()方法阻塞在那，监听输入&lt;/li&gt;
&lt;li&gt;针对每一个请求，单独启动一个线程处理&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.rpc;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.net.ServerSocket;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.net.Socket;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Arrays;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * RPC服务提供器&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@author &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;zhengrongjun&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RpcProvider {
    
    &lt;span class=&quot;co&quot;&gt;//存储注册的服务列表&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; List&amp;lt;Object&amp;gt; serviceList;
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 发布rpc服务&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param object&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param port&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@throws Exception&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;export&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; port,Object&lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;services) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        serviceList=Arrays.&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(services);
        ServerSocket server = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ServerSocket(port);
        Socket client = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;) {
            &lt;span class=&quot;co&quot;&gt;//阻塞等待输入&lt;/span&gt;
            client = server.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;//每一个请求，启动一个线程处理&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ServerThread&lt;/span&gt;(client,serviceList)).&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来ServerThread线程处理类的代码，ServerThread主要做以下几个步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;读取客户端发送的服务名&lt;/li&gt;
&lt;li&gt;判断服务是否发布&lt;/li&gt;
&lt;li&gt;如果发布，则走反射逻辑，动态调用，返回结果&lt;/li&gt;
&lt;li&gt;如果未发布，则返回提示通知&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.rpc;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.IOException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.ObjectInputStream;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.ObjectOutputStream;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.Method;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.net.Socket;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ServerThread &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Runnable {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Socket client = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; List&amp;lt;Object&amp;gt; serviceList = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ServerThread&lt;/span&gt;(Socket client, List&amp;lt;Object&amp;gt; service) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;client&lt;/span&gt; = client;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;serviceList&lt;/span&gt; = service;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
        ObjectInputStream input = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        ObjectOutputStream output = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            input = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ObjectInputStream(client.&lt;span class=&quot;fu&quot;&gt;getInputStream&lt;/span&gt;());
            output = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ObjectOutputStream(client.&lt;span class=&quot;fu&quot;&gt;getOutputStream&lt;/span&gt;());
            &lt;span class=&quot;co&quot;&gt;// 读取客户端要访问那个service&lt;/span&gt;
            Class serviceClass = (Class) input.&lt;span class=&quot;fu&quot;&gt;readObject&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 找到该服务类&lt;/span&gt;
            Object obj = &lt;span class=&quot;fu&quot;&gt;findService&lt;/span&gt;(serviceClass);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (obj == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                output.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(serviceClass.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;服务未发现&quot;&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;//利用反射调用该方法，返回结果&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                    String methodName = input.&lt;span class=&quot;fu&quot;&gt;readUTF&lt;/span&gt;();
                    Class&amp;lt;?&amp;gt;[] parameterTypes = (Class&amp;lt;?&amp;gt;[]) input.&lt;span class=&quot;fu&quot;&gt;readObject&lt;/span&gt;();
                    Object[] arguments = (Object[]) input.&lt;span class=&quot;fu&quot;&gt;readObject&lt;/span&gt;();
                    Method method = obj.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getMethod&lt;/span&gt;(methodName, parameterTypes);  
                    Object result = method.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(obj, arguments);  
                    output.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(result); 
                } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable t) {
                    output.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(t);
                }
            }
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                client.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
                input.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
                output.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
                &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated catch block&lt;/span&gt;
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
        }

    }

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;findService&lt;/span&gt;(Class serviceClass) {
        &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Object obj : serviceList) {
            &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; isFather = serviceClass.&lt;span class=&quot;fu&quot;&gt;isAssignableFrom&lt;/span&gt;(obj.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;());
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (isFather) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; obj;
            }
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来是使用的部分&lt;br/&gt;先创建一个微服务，接口如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.service;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; BatterCakeService {
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 卖煎饼的服务&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param name&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * @return&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;sellBatterCake&lt;/span&gt;(String name);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现类如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.service.impl;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.rjzheng.service.BatterCakeService;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BatterCakeServiceImpl &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; BatterCakeService {

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;sellBatterCake&lt;/span&gt;(String name) {
        &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; name+&lt;span class=&quot;st&quot;&gt;&quot;煎饼,卖的特别好&quot;&lt;/span&gt;;
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来就是发布服务&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.start;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.rjzheng.rpc.RpcProvider;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.rjzheng.service.BatterCakeService;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.rjzheng.service.impl.BatterCakeServiceImpl;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RpcBootStrap {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        BatterCakeService batterCakeService =&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BatterCakeServiceImpl&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;//发布卖煎饼的服务，注册在20006端口&lt;/span&gt;
        RpcProvider.&lt;span class=&quot;fu&quot;&gt;export&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;20006&lt;/span&gt;,batterCakeService);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;服务消费者&quot;&gt;服务消费者&lt;/h2&gt;
&lt;p&gt;本部分的工程为battercake-consumer，项目结构图如下图所示&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1194802/o_batterconsumer.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先上rpc框架调用部分的代码RpcConsumer，步骤分两步&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;封装一个代理类处理器&lt;/li&gt;
&lt;li&gt;返回service的代理类对象&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.rpc;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.Proxy;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RpcConsumer {
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T &lt;span class=&quot;fu&quot;&gt;getService&lt;/span&gt;(Class&amp;lt;T&amp;gt; clazz,String ip,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; port) {
        ProxyHandler proxyHandler =&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ProxyHandler&lt;/span&gt;(ip,port);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (T)Proxy.&lt;span class=&quot;fu&quot;&gt;newProxyInstance&lt;/span&gt;(RpcConsumer.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getClassLoader&lt;/span&gt;(), &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[] {clazz}, proxyHandler);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来上代理类处理器的代码，代理类处理步骤分以下几步&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;建立socket连接&lt;/li&gt;
&lt;li&gt;封装请求数据，发送给服务提供者&lt;/li&gt;
&lt;li&gt;返回结果&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.rpc;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.ObjectInputStream;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.ObjectOutputStream;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.InvocationHandler;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.Method;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.net.Socket;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.rjzheng.service.BatterCakeService;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProxyHandler &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; InvocationHandler {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String ip;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; port;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ProxyHandler&lt;/span&gt;(String ip, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; port) {
        &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated constructor stub&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;ip&lt;/span&gt; = ip;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;port&lt;/span&gt; = port;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(Object proxy, Method method, Object[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Throwable {
        &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;
        Socket socket = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Socket(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;ip&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;port&lt;/span&gt;);
        ObjectOutputStream output = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ObjectOutputStream(socket.&lt;span class=&quot;fu&quot;&gt;getOutputStream&lt;/span&gt;());
        ObjectInputStream input = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ObjectInputStream(socket.&lt;span class=&quot;fu&quot;&gt;getInputStream&lt;/span&gt;());
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            output.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(proxy.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getInterfaces&lt;/span&gt;()[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]);
            output.&lt;span class=&quot;fu&quot;&gt;writeUTF&lt;/span&gt;(method.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;());
            output.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(method.&lt;span class=&quot;fu&quot;&gt;getParameterTypes&lt;/span&gt;());
            output.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(args);
            output.&lt;span class=&quot;fu&quot;&gt;flush&lt;/span&gt;();
            Object result = input.&lt;span class=&quot;fu&quot;&gt;readObject&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(result &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; Throwable) {
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; (Throwable) result;
            }
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            socket.&lt;span class=&quot;fu&quot;&gt;shutdownOutput&lt;/span&gt;();
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来建立一个测试类RpcTest如下（跑该测试类前，记得运行在battercake-provider端的RpcBootstrap类发布BatterCakeService服务）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.start;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.rjzheng.rpc.RpcConsumer;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.rjzheng.service.BatterCakeService;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RpcTest {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        BatterCakeService batterCakeService=RpcConsumer.&lt;span class=&quot;fu&quot;&gt;getService&lt;/span&gt;(BatterCakeService.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;20006&lt;/span&gt;);
        String result=batterCakeService.&lt;span class=&quot;fu&quot;&gt;sellBatterCake&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;双蛋&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(result);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;双蛋煎饼,卖的特别好&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们就实现了一个简易的rpc服务调用框架&lt;/p&gt;
</description>
<pubDate>Wed, 11 Apr 2018 14:40:00 +0000</pubDate>
<dc:creator>孤独烟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rjzheng/p/8798556.html</dc:identifier>
</item>
<item>
<title>如何从0开发一个Atom组件 - 贾顺名</title>
<link>http://www.cnblogs.com/jiasm/p/8799046.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiasm/p/8799046.html</guid>
<description>&lt;p class=&quot;post-title&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;最近用Atom写博客比较多，然后发现一个很严重的问题。。&lt;br/&gt;没有一个我想要的上传图片的方式，比如某乎上边就可以直接copy/paste文件，然后进行上传。&lt;br/&gt;然而在Atom上没有找到类似的插件，最接近的一个，也还是需要手动选择文件，然后进行上传。&lt;br/&gt;这个操作流程太繁琐，索性自己写一个插件用好了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;成品插件下载地址：&lt;a href=&quot;https://atom.io/packages/atom-image-uploader&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;https://atom.io/packages/atom-image-uploader&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;规划&quot;&gt;规划&lt;/h2&gt;
&lt;p&gt;首先，我们确定了需求，要通过可以直接&lt;code&gt;copy&lt;/code&gt;文件，然后在Atom中&lt;code&gt;paste&lt;/code&gt;即可完成上传的操作。&lt;br/&gt;确定了以后，我们就要开始搬砖了。&lt;/p&gt;
&lt;h2 id=&quot;插件开发&quot;&gt;插件开发&lt;/h2&gt;
&lt;p&gt;因为&lt;code&gt;Atom&lt;/code&gt;是一个&lt;code&gt;Electron&lt;/code&gt;应用：&lt;a href=&quot;https://electronjs.org/&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;https://electronjs.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是使用&lt;code&gt;JavaScript&lt;/code&gt;来开发的桌面应用，所以对于一个前端来说，简直是太美好了。&lt;br/&gt;我们先去翻看&lt;code&gt;Atom&lt;/code&gt;的官方文档，查看关于创建插件相关的操作：&lt;br/&gt;首先我们在&lt;code&gt;Atom&lt;/code&gt;中打开命令面板，然后输入&lt;code&gt;Generate Package&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://os4ty6tab.qnssl.com/test/atom-editor/rf2.png&quot; alt=&quot;&quot; width=&quot;978&quot; height=&quot;237&quot;/&gt;&lt;br/&gt;按下回车后，将会弹出一个对话框，在框中输入要建立的包名即可完成一个&lt;code&gt;Package&lt;/code&gt;的创建。&lt;br/&gt;&lt;img src=&quot;https://os4ty6tab.qnssl.com/test/atom-editor/sba1.png&quot; alt=&quot;&quot; width=&quot;978&quot; height=&quot;130&quot;/&gt;&lt;br/&gt;&lt;code&gt;Atom&lt;/code&gt;会生成一套默认文件，并打开一个新的窗口。&lt;/p&gt;
&lt;h2 id=&quot;项目结构&quot;&gt;项目结构&lt;/h2&gt;
&lt;p&gt;生成的插件目录如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.
├── keymaps
│   └── first&lt;/span&gt;-&lt;span&gt;package.json
├── lib
│   ├── first&lt;/span&gt;-package-&lt;span&gt;view.js
│   └── first&lt;/span&gt;-&lt;span&gt;package.js
├── menus
│   └── first&lt;/span&gt;-&lt;span&gt;package.json
├── package.json
├── spec
│   ├── first&lt;/span&gt;-package-&lt;span&gt;spec.js
│   └── first&lt;/span&gt;-package-view-&lt;span&gt;spec.js
└── styles
    └── first&lt;/span&gt;-package.less
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;keymaps&quot;&gt;keymaps&lt;/h3&gt;
&lt;p&gt;这里可以配置要监听的快捷键，我们可以设置一些自定义快捷键来触发一些我们插件的行为。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;atom-workspace&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;ctrl-alt-o&quot;: &quot;first-package:toggle&quot;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以添加各种自定义的快捷键在这里。&lt;br/&gt;&lt;code&gt;Value&lt;/code&gt;的定义为：&lt;code&gt;包名:触发的事件名&lt;/code&gt;&lt;br/&gt;需要注意的是：&lt;br/&gt;这里配置的快捷键还有一个作用域的概念。也就是&lt;code&gt;JSON&lt;/code&gt;外边的那个&lt;code&gt;key&lt;/code&gt;。&lt;br/&gt;&lt;code&gt;atom-workspace&lt;/code&gt;表示在&lt;code&gt;Atom&lt;/code&gt;中生效&lt;br/&gt;&lt;code&gt;atom-text-editor&lt;/code&gt;表示只在文本编辑器范围内生效。&lt;br/&gt;&lt;img src=&quot;https://os4ty6tab.qnssl.com/test/atom-editor/ip8k.png&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;561&quot;/&gt;&lt;br/&gt;&lt;a href=&quot;https://flight-manual.atom.io/behind-atom/sections/keymaps-in-depth/&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;Atom官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;lib&quot;&gt;lib&lt;/h3&gt;
&lt;p&gt;这里就是存放插件主要代码的地方了。&lt;br/&gt;默认会生成两个文件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;package.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;package.view.js&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;默认插件生成的主入口文件指向这里。&lt;br/&gt;&lt;img src=&quot;https://os4ty6tab.qnssl.com/test/atom-editor/gd.png&quot; alt=&quot;&quot; width=&quot;750&quot; height=&quot;694&quot;/&gt;&lt;/p&gt;
&lt;p&gt;入口文件的表现方式为一个&lt;code&gt;JSON&lt;/code&gt;对象，可以实现如下几个函数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;activate&lt;/code&gt;: 当&lt;code&gt;Package&lt;/code&gt;被激活时会执行该方法，函数的签名表示会接受一个&lt;code&gt;state&lt;/code&gt;参数，该参数是通过&lt;code&gt;serialize&lt;/code&gt;方法传递过来的（如果有实现它的话）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deactivate&lt;/code&gt;: 当&lt;code&gt;Package&lt;/code&gt;失效时会出发的方法，这两个方法可以理解为&lt;code&gt;React&lt;/code&gt;中的&lt;code&gt;componentWillMount&lt;/code&gt;和&lt;code&gt;componentWillUnmount&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;serialize&lt;/code&gt;: 也就是上边说到的那个方法，可以返回一个&lt;code&gt;JSON&lt;/code&gt;对象供下次激活后使用&lt;/li&gt;
&lt;li&gt;自定义快捷键对应的事件名: 每次&lt;code&gt;Package&lt;/code&gt;被触发对应快捷键时都会执行的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里存放的是在应用菜单和编辑区域菜单栏的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;context-menu&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;atom-text-editor&quot;&lt;span&gt;: [
      {
        &lt;/span&gt;&quot;label&quot;: &quot;Toggle first-package&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;command&quot;: &quot;first-package:toggle&quot;&lt;span&gt;
      }
    ]
  },
  &lt;/span&gt;&quot;menu&quot;&lt;span&gt;: [
    {
      &lt;/span&gt;&quot;label&quot;: &quot;Packages&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;submenu&quot;&lt;span&gt;: [
        {
          &lt;/span&gt;&quot;label&quot;: &quot;first-package&quot;&lt;span&gt;,
          &lt;/span&gt;&quot;submenu&quot;&lt;span&gt;: [
            {
              &lt;/span&gt;&quot;label&quot;: &quot;Toggle&quot;&lt;span&gt;,
              &lt;/span&gt;&quot;command&quot;: &quot;first-package:toggle&quot;&lt;span&gt;
            }
          ]
        }
      ]
    }
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;context-menu&lt;/code&gt;对应的元素会在对应的区域内右键触发时显示。&lt;br/&gt;&lt;code&gt;menu&lt;/code&gt;则是出现在&lt;code&gt;Atom&lt;/code&gt;主菜单栏上：&lt;br/&gt;&lt;img src=&quot;https://os4ty6tab.qnssl.com/test/atom-editor/8opc.png&quot; alt=&quot;&quot; width=&quot;365&quot; height=&quot;733&quot;/&gt;&lt;br/&gt;同样的，&lt;code&gt;context-menu&lt;/code&gt;会区分两个环境，&lt;code&gt;text-editor&lt;/code&gt;和&lt;code&gt;workspace&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;spec&quot;&gt;spec&lt;/h3&gt;
&lt;p&gt;这里存放的是一些测试用例，创建&lt;code&gt;Package&lt;/code&gt;会生成一些默认的断言。&lt;br/&gt;&lt;em&gt;写测试确实是一个好习惯。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;styles&quot;&gt;styles&lt;/h3&gt;
&lt;p&gt;如果&lt;code&gt;Package&lt;/code&gt;有很多&lt;code&gt;View&lt;/code&gt;要展示的话，可以在这里编写，默认使用的是&lt;code&gt;Less&lt;/code&gt;语法。&lt;br/&gt;由于我们只做一个&lt;code&gt;C/V&lt;/code&gt;的操作，不会涉及到界面，所以&lt;code&gt;styles&lt;/code&gt;直接就删掉了。&lt;/p&gt;
&lt;h2 id=&quot;开始搬砖&quot;&gt;开始搬砖&lt;/h2&gt;
&lt;p&gt;大致结构已经了解了，我们就可以开始搬砖了。&lt;br/&gt;因为是一个&lt;code&gt;Electron&lt;/code&gt;应用，所以我们直接在&lt;code&gt;Atom&lt;/code&gt;中按下&lt;code&gt;alt + command + i&lt;/code&gt;，呼出我们熟悉的控制台界面。&lt;br/&gt;&lt;img src=&quot;https://os4ty6tab.qnssl.com/test/atom-editor/f7qn.png&quot; alt=&quot;&quot; width=&quot;922&quot; height=&quot;489&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Atom&lt;/code&gt;是不会把&lt;code&gt;Electron&lt;/code&gt;的各种文档重新写一遍的，所以我们现在控制台里边试一下我们的猜测是否正确。&lt;br/&gt;一些想要的东西是否存在。&lt;br/&gt;&lt;img src=&quot;https://os4ty6tab.qnssl.com/test/atom-editor/4qjt.png&quot; alt=&quot;&quot; width=&quot;922&quot; height=&quot;489&quot;/&gt;&lt;br/&gt;经过验证确定了，&lt;code&gt;Electron&lt;/code&gt;的&lt;code&gt;clipboard&lt;/code&gt;对象可以直接在&lt;code&gt;Atom&lt;/code&gt;中使用，这就很开心了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
require('electron').clipboard.readImage().toPng()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样我们就拿到剪切板中的图片数据了，一个二进制的数组对象。&lt;br/&gt;我们在触发&lt;code&gt;Paste&lt;/code&gt;操作时，从&lt;code&gt;clipboard&lt;/code&gt;中获取，如果剪切板中是图片的话，我们就将它上传并显示到编辑器中。&lt;br/&gt;所以，接下来我们要做的就是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进行上传图片的操作&lt;/li&gt;
&lt;li&gt;将上传后的图片显示到编辑器中&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;上传图片&quot;&gt;上传图片&lt;/h3&gt;
&lt;p&gt;上传图片我们选择的是七牛，我们选择七牛来作为图床使用，因为他家提供了10GB的免费存储，灰常适合自己这样的笔记型博客。&lt;br/&gt;但是用他家SDK时发现一个问题。。我将二进制数据转换为&lt;code&gt;ReadStream&lt;/code&gt;后上传的资源损坏了-.-目前还没有找到原因。&lt;br/&gt;所以我们做了曲线救国的方式。&lt;br/&gt;将剪切板中的数据转换为&lt;code&gt;Buffer&lt;/code&gt;然后暂存到本地，通过本地文件的方式来进行上传七牛。&lt;br/&gt;在操作完成后我们再将临时文件移除。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
  let buffer &lt;/span&gt;=&lt;span&gt; clipboard.readImage().toPng()
  let tempFilePath &lt;/span&gt;= 'XXX'&lt;span&gt;
  fs.writeFileSync(tempFilePath, Buffer.from(buffer))
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; catch error&lt;/span&gt;
} &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
  fs.unlink(tempFilePath) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为我们并不依赖于删除成功的回调，所以直接空调用异步方法即可&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;将上传后的资源显示到编辑器中&quot;&gt;将上传后的资源显示到编辑器中&lt;/h3&gt;
&lt;p&gt;因为考虑到上传可能会受到网络影响，从而上传时间不可预估。&lt;br/&gt;所以我们会先在文件中显示一部分占位文字。&lt;br/&gt;通过全局的&lt;code&gt;atom&lt;/code&gt;对象可以拿到当前活跃的窗口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let editor = atom.workspace.getActiveTextEditor()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了避免同时上传多张图片时出现问题，我们将临时文件名作为填充的一部分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
editor.insertText(`![](${placeHolderText})`, editor)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后在上传成功后，我们将对应的填充字符替换为上传后的URL就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
editor.scan(&lt;span&gt;new&lt;/span&gt; RegExp(placeHolderText), tools =&amp;gt; tools.replace(url))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;scan&lt;/code&gt;方法接收一个正则对象和回调函数。&lt;br/&gt;我们将前边用到的占位文本作为正则对象，然后在回调将其替换为上传后的&lt;code&gt;url&lt;/code&gt;。&lt;br/&gt;至此，我们的代码已经编写完了，剩下的就是一些交互上的优化。&lt;/p&gt;
&lt;p&gt;完成后的效果图：&lt;br/&gt;&lt;img src=&quot;https://i.github-camo.com/9f326d047cc2560bcbc6114c5634edff8bed528e/68747470733a2f2f6f73347479367461622e716e73736c2e636f6d2f63626c7565642f7374617469632f64656d6f2e316361696f367439356675656f622e676966&quot; alt=&quot;&quot; width=&quot;939&quot; height=&quot;488&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以及，最后：我们要进行&lt;code&gt;Package&lt;/code&gt;的上传。&lt;/p&gt;
&lt;h3 id=&quot;上传开发完的Package&quot;&gt;上传开发完的Package&lt;/h3&gt;
&lt;p&gt;首先我们需要保证&lt;code&gt;package.json&lt;/code&gt;中存在如下几个参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;description&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repository&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们可以先使用如下命令来检查包名是否冲突。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
apm show 你的包名
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果没有冲突，我们就可以直接执行以下命令进行上传了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
apm publish 你的包名
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;后续的代码修改，只需在该包的目录下执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
apm publish
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一些可选的参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;major&lt;/code&gt;，增加版本号的第一位&lt;code&gt;1.0.0&lt;/code&gt; -&amp;gt; &lt;code&gt;2.0.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minor&lt;/code&gt;，增加版本号的第二位&lt;code&gt;0.1.0&lt;/code&gt; -&amp;gt; &lt;code&gt;0.2.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;patch&lt;/code&gt;，增加版本号的第三位&lt;code&gt;0.0.1&lt;/code&gt; -&amp;gt; &lt;code&gt;0.0.2&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过&lt;code&gt;apm help&lt;/code&gt;可以获取到更多的帮助信息。&lt;/p&gt;
&lt;p&gt;以上，就是开发一个&lt;code&gt;Atom&lt;/code&gt;插件的完整流程咯。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://flight-manual.atom.io/hacking-atom/&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;hacking-atom&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://electronjs.org/docs&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;electron-doc&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Apr 2018 14:03:00 +0000</pubDate>
<dc:creator>贾顺名</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiasm/p/8799046.html</dc:identifier>
</item>
<item>
<title>基于Verilog HDL的超前进位全加器设计 - NingHeChuan</title>
<link>http://www.cnblogs.com/ninghechuan/p/8798972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ninghechuan/p/8798972.html</guid>
<description>&lt;p&gt;       通常我们所使用的加法器一般是串行进位，将从输入的ci逐位进位地传递到最高位的进位输出co，由于电路是有延迟的，这样的长途旅行是需要时间的，所以为了加快加法器的运算，引入了超前进位全加器。&lt;/p&gt;
&lt;h2&gt;全加器的两个逻辑表达式&lt;/h2&gt;
&lt;p&gt;       sum = a ^ b ^ cin;&lt;/p&gt;
&lt;p&gt;       co = a &amp;amp; b | (a ^ b) &amp;amp; cin;&lt;/p&gt;
&lt;p&gt;　　sum = a ^ b ^ cin;&lt;/p&gt;
&lt;p&gt;       co = a &amp;amp; b + a &amp;amp; cin + b &amp;amp; cin;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201804/1057546-20180411214219598-1348915748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201804/1057546-20180411214234736-431442145.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201804/1057546-20180411214245166-2129761866.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;       这两个公式的电路图看起来不一样，但其实是一样的，同一个功能的电路可以有不同的描述方式。而且把co这两个表达式展开，观察其最小项表达式（画卡诺图），最终的结果也是一样的和真值表完全相符。&lt;/p&gt;
&lt;h2&gt;四位超前进位全加器&lt;/h2&gt;
&lt;p&gt;根据一位全加器的表达式可以推理出，四位全加器每一位的计算通式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201804/1057546-20180411214259366-1918547152.png&quot; alt=&quot;&quot;/&gt;&lt;br clear=&quot;all&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201804/1057546-20180411214308257-112099863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201804/1057546-20180411214314573-528347464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       为了达到并行的效果，通过公式化简，得到co和sum的表达式，每一位之间的运算都是独立的，和低位的运算没有关系，这样做达到完全并行，这就是四位超前进位全加器。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201804/1057546-20180411214320937-403822130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       有了四位全加器，我们可以以通过四位超前进位全加器设计出16位、32位、64位超前进位全加器，有些设计方法是将四个四位超前进位全加器串联起来，即将低四位的co连接到高四位的cin上，但这样并不能算得上是真正的并行，每四位是并行的，但每四位之间是串行的，博主目的是要达到完全并行的设计，继续往下看吧。&lt;/p&gt;
&lt;p&gt;       这里的g是generation（生成）的意思，当a和b同时为1时，1位全加器必然产生进位，p表示propagation（传到）的意思，当a或b中有一个是1时，如果进位cin位1，1位全加器必然产生进位，利用这个原理即可做出四位超前进位全加器之间的超前进位。&lt;/p&gt;
&lt;p&gt;       四位超前进位全加器的co进位输出端为&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201804/1057546-20180411214332312-271671567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       这与一位全加器的进位类似，&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201804/1057546-20180411214336826-1820716999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201804/1057546-20180411214342182-1899015443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       我们可以推出如下关系式&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201804/1057546-20180411214350122-774600699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201804/1057546-20180411214357302-1240591343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201804/1057546-20180411214407914-1030570879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       我们通过调用四个超前进位全加器即可实现16位超前进位全加器，那么实现64位超前进位全加器其实也是和这个实现方法一样了，调用4个16位超前进位全加器就可以实现64位超前进位全加器。不过实际中CPU采用的是超前进位和串行进位集合，并行设计占面积，串行设计速度慢，尽量做到面积与速度之间的权衡。&lt;/p&gt;
&lt;p&gt;       博主最近要学Verilog设计一个32位的简易CPU，其中ALU中想用上32位超前进位全加器。对于32位超前进位全加器，也是一样的方法。我选择的是三级并行设计，即四个四位超前进位全加器组间并行实现16位超前进位全加器，两个16位超前进位全加器组间并行实现32位超前进位全加器，至于两级并行还是多级并行看自己选择了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1057546/201706/1057546-20170611114905559-478053885.jpg&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;289&quot;/&gt;&lt;/p&gt;

&lt;p&gt;转载请注明出处：NingHeChuan（宁河川）&lt;/p&gt;
&lt;p&gt;个人微信订阅号：开源FPGA&lt;/p&gt;
&lt;p&gt;如果你想及时收到个人撰写的博文推送，可以扫描左边二维码（或者长按识别二维码）关注个人微信订阅号&lt;/p&gt;
&lt;p&gt;知乎ID：&lt;a href=&quot;https://www.zhihu.com/people/zhu-he-chuan/activities&quot; target=&quot;_blank&quot;&gt;NingHeChuan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微博ID：&lt;a href=&quot;http://weibo.com/6059461073/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot;&gt;NingHeChuan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 基于Verilog HDL的超前进位全加器设计&quot; href=&quot;http://www.cnblogs.com/ninghechuan/p/8798972.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/ninghechuan/p/8798972.html&lt;/a&gt; &lt;/p&gt;

</description>
<pubDate>Wed, 11 Apr 2018 13:50:00 +0000</pubDate>
<dc:creator>NingHeChuan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ninghechuan/p/8798972.html</dc:identifier>
</item>
<item>
<title>并查集入门及相关例题 - Nishikino_Curtis</title>
<link>http://www.cnblogs.com/nishikino-curtis/p/8798952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nishikino-curtis/p/8798952.html</guid>
<description>&lt;h2 id=&quot;并查集的基础概念及实现&quot;&gt;并查集的基础概念及实现&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;部分内容引用自wikipedia.org&lt;/em&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;并查集(Union-Find Sets)是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题，定义了两个用于此数据结构的操作：&lt;/li&gt;
&lt;li&gt;Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。&lt;/li&gt;
&lt;li&gt;Union：将两个子集合并成同一个集合。&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;在实际应用中，常随着find操作进行路径压缩，均摊复杂度为反阿克曼函数，接近线性。&lt;/p&gt;
&lt;h4 id=&quot;source&quot;&gt;Source&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;int find(int x)//返回x的父节点，并将其挂载到根节点上
{
if(x==fa[x])return x;
return x=find(fa[x]);
}
int link(int x,int y)
{
int fx=find(x),fy=find(y);
if(fx!=fy)fa[fx]=fy;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;example-codeforces277a-learninglanguages&quot;&gt;Example CodeForces277A LearningLanguages&lt;/h2&gt;
&lt;h2 id=&quot;description&quot;&gt;Description&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;The &quot;BerCorp&quot; company has got n employees. These employees can use m approved official languages for the formal correspondence. The languages are numbered with integers from 1 to m. For each employee we have the list of languages, which he knows. This list could be empty, i. e. an employee may know no official languages. But the employees are willing to learn any number of official languages, as long as the company pays their lessons. A study course in one language for one employee costs 1 berdollar.&lt;/li&gt;
&lt;li&gt;Find the minimum sum of money the company needs to spend so as any employee could correspond to any other one (their correspondence can be indirect, i. e. other employees can help out translating).&lt;/li&gt;
&lt;li&gt;BerCorp公司有n名雇员。这些雇员共掌握m种官方语言（以从1到m的整数编号）用于正式交流。对于每个雇员，我们有一个他掌握的语言列表，列表可以为空，这意味着一个雇员可能不掌握任何官方语言。但是雇员们愿意学习语言，只要公司为课程付费。每名雇员学习一种语言需要花费 1 Ber元。请找出能让所有雇员直接或间接（可由其他雇员提供中间翻译）交流的最小花费。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;inputoutput&quot;&gt;Input&amp;amp;Output&lt;/h2&gt;
&lt;h4 id=&quot;input&quot;&gt;Input&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;The first line contains two integers n and m (2 ≤ n, m ≤ 100) — the number of employees and the number of languages.&lt;/li&gt;
&lt;li&gt;Then n lines follow — each employee's language list. At the beginning of the i-th line is integer ki (0 ≤ ki ≤ m) — the number of languages the i-th employee knows. Next, the i-th line contains ki integers — aij (1 ≤ aij ≤ m) — the identifiers of languages the i-th employee knows. It is guaranteed that all the identifiers in one list are distinct. Note that an employee may know zero languages.&lt;/li&gt;
&lt;li&gt;The numbers in the lines are separated by single spaces.&lt;/li&gt;
&lt;li&gt;第一行为两个整数n,m(2&amp;lt;=n,m&amp;lt;=100)，为雇员的数量和语言的数量。&lt;/li&gt;
&lt;li&gt;接下来n行，每行首先有一个整数ki(0&amp;lt;=ki&amp;lt;=m)，为雇员i掌握的语言数量，接下来有ki个整数，为雇员i掌握的语言。这意味着一个表中所有的编号都不同。注意一个雇员可能掌握0种语言。&lt;/li&gt;
&lt;li&gt;每行中的数字都用一个空格隔开。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;output&quot;&gt;Output&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Print a single integer — the minimum amount of money to pay so that in the end every employee could write a letter to every other one (other employees can help out translating).&lt;/li&gt;
&lt;li&gt;一个整数——能让所有雇员直接或间接交流的最小花费。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;h4 id=&quot;input1&quot;&gt;Input#1&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;5 5
1 2
2 2 3
2 3 4
2 4 5
1 5&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;output1&quot;&gt;Output#1&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;0&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;input2&quot;&gt;Input#2&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;8 7
0
3 1 2 3
1 1
2 5 4
2 6 7
1 3
2 7 4
1 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;output2&quot;&gt;Output#2&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;del&gt;我会告诉你第三组懒得粘了吗&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li&gt;非常裸的并查集，同时需要维护联通块，处理结束后，输出联通块个数-1。容易证明：如果读入结束后仍有大于1个联通块，对于联通块A，B，一定存在至少一种语言，A中有人掌握，且B中无人掌握，此时令B中一人学习一种该语言即可。以此类推，直到联通块总数为1，则需要sum-1个人学习新语言。&lt;br/&gt;&lt;em&gt;注意一些细节：&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;可以开一个二维vector，维护掌握每种语言的员工编号，每当读入一名员工掌握一种语言，尝试将其与所有已知的掌握该语言的员工联通，完成后将其压入vector。&lt;/li&gt;
&lt;li&gt;如果所有员工都掌握零种语言，答案应为员工数，因为此时所有员工都要学习一门语言。&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;vector&amp;gt;
#define maxn 105
using namespace std;
int n,m,k,l,spj,sum,fa[maxn];//sz[maxn];
vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; v(maxn);
int find(int x)
{
if(x==fa[x])return x;
else return fa[x]=find(fa[x]);
}
void link(int x,int y)
{
int fx=find(x),fy=find(y);
if(fx!=fy) fa[fx]=fy,sum--;
}
int main()
{
scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
for(int i=1;i&amp;lt;=n;++i)
{
    fa[i]=i;
    scanf(&quot;%d&quot;,&amp;amp;k);
    if(!k){spj++;sum++;continue;}
    sum++;
    for(int j=1;j&amp;lt;=k;++j)
    {
        scanf(&quot;%d&quot;,&amp;amp;l);
        for(int p=0;p&amp;lt;v[l].size();++p)link(i,v[l][p]);
        v[l].push_back(i);
    }
}
if(spj==n){printf(&quot;%d&quot;,n);return 0;}
printf(&quot;%d&quot;,sum-1);
return 0;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;example-luogu1955-noi2015-程序自动分析&quot;&gt;Example Luogu1955 NOI2015 程序自动分析&lt;/h2&gt;
&lt;h2 id=&quot;description-1&quot;&gt;Description&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。&lt;/li&gt;
&lt;li&gt;考虑一个约束满足问题的简化版本：假设x1,x2,x3...代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2,x2=x3,x3=x4,x4≠x1，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。&lt;/li&gt;
&lt;li&gt;现在给出一些约束满足问题，请分别对它们进行判定。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;inputoutput-1&quot;&gt;Input&amp;amp;Output&lt;/h2&gt;
&lt;h4 id=&quot;input-1&quot;&gt;Input&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;输入文件的第1行包含1个正整数t，表示需要判定的问题个数。注意这些问题之间是相互独立的。&lt;/li&gt;
&lt;li&gt;对于每个问题，包含若干行：&lt;/li&gt;
&lt;li&gt;第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xj；若e=0，则该约束条件为xi≠xj；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;output-1&quot;&gt;Output&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;输出文件包括t行。&lt;/li&gt;
&lt;li&gt;输出文件的第 k行输出一个字符串“ YES” 或者“ NO”（不包含引号，字母全部大写），“ YES” 表示输入中的第k个问题判定为可以被满足，“ NO” 表示不可被满足。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;sample-1&quot;&gt;Sample&lt;/h2&gt;
&lt;h4 id=&quot;input-2&quot;&gt;Input&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;2
2
1 2 1
1 2 0
2
1 2 1
2 1 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;output-2&quot;&gt;Output&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;NO
YES&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;solution-1&quot;&gt;Solution&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;我这种蒟蒻也就刷刷水题了，对于每个类型为1的条件，先尝试并，然后再处理类型为0的条件，如果冲突(在同一颗树中)，直接输出NO，break掉。&lt;/li&gt;
&lt;li&gt;需要注意的是，有三个毒瘤测试点，所以要离散化。&lt;/li&gt;
&lt;li&gt;代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#define maxn 100010
using namespace std;
struct node {
    int x, y,type;
    node(int x=0, int y=0,int t=0) {
        x = x;
        y = y;
        type=t;
    }
    bool operator &amp;lt;(const node &amp;amp;a)const{
        return type&amp;gt;a.type;//操作一波可以把所有类型为1的条件前置
    }
}opt[maxn];
int n, a, b,t,m,fa[maxn&amp;lt;&amp;lt;1],big[200010];
int find(int x) {
    return(x == fa[x]) ? x : fa[x] = find(fa[x]);
}
void link(int x, int y) {
    int fx = find(x), fy = find(y);
    if (fx != fy)fa[fx] = fy;
}
bool same(int x, int y) {
    return find(x) == find(y);
}
int main()
{
    scanf(&quot;%d&quot;, &amp;amp;n);
    for (int i = 1;i &amp;lt;= n;++i) {
        for (int j = 1;j &amp;lt;= 200010;++j)fa[j] = j;
        int ptr2=0;bool flg=true;
        scanf(&quot;%d&quot;, &amp;amp;m);
        for (int j = 1;j &amp;lt;= m;++j) {
            scanf(&quot;%d%d%d&quot;, &amp;amp;a, &amp;amp;b, &amp;amp;t);
            opt[j].x = a, opt[j].y = b,opt[j].type=t;
            big[++ptr2]=a,big[++ptr2]=b;
        }
        sort(opt+1,opt+1+m);
        sort(big+1,big+1+ptr2);
        int tot=unique(big+1,big+1+ptr2)-(big+1);
        for(int j=1;j&amp;lt;=m;++j){
            opt[j].x=lower_bound(big+1,big+1+tot,opt[j].x)-big,
            opt[j].y=lower_bound(big+1,big+1+tot,opt[j].y)-big;
            if(opt[j].type)link(opt[j].x,opt[j].y);
            else if(!opt[j].type&amp;amp;&amp;amp;same(opt[j].x,opt[j].y)){puts(&quot;NO&quot;);flg=false;break;}
        }
        if(flg)puts(&quot;YES&quot;);
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 11 Apr 2018 13:40:00 +0000</pubDate>
<dc:creator>Nishikino_Curtis</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nishikino-curtis/p/8798952.html</dc:identifier>
</item>
<item>
<title>基于UDP协议的控制台聊天程序（c++版） - Rcchio</title>
<link>http://www.cnblogs.com/Rcchio/p/8762613.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rcchio/p/8762613.html</guid>
<description>
&lt;p&gt;                                                                                                                                                                                                                                                   本博客由Rcchio原创，转载请告知作者&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;前言：聊天程序是生活中经常使用到的程序，典型的代表便是腾讯的QQ、微信。实现一个简易的聊天程序，可以很好使TCP/IP协议编程的知识得到很好的运用，同时加深我们对c/s模式的理解。&lt;/p&gt;
&lt;p&gt;          本文讲述了一个基于UDP协议的简单的控制台聊天程序的实现。程序虽然简易，但却具有很好的扩展性，从功能上看，可以进一步丰富该聊天程序的功能，如增添添加好友和群，传输文件，视频通话；从形式上看，如尝试学习一些 &lt;/p&gt;
&lt;p&gt;          c++GUI库来为程序添加图形界面，如学习使用数据库的使用来为服务器存储用户信息等。所以说，聊天程序练习编程的一个不错的选择。作者已将完整代码的链接和可执行程序的链接放在文章末尾，有需要的同学可以自取。话不多说，&lt;/p&gt;
&lt;p&gt;         下面来看一下这个简单的程序是如何实现的吧~&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;一、聊天程序的功能&lt;/p&gt;
&lt;p&gt;     1.登录账号、注册新账号&lt;/p&gt;
&lt;p&gt;     2.进行群聊&lt;/p&gt;
&lt;p&gt;     3.进行私聊&lt;/p&gt;
&lt;p&gt;     注：该程序对传统的聊天程序进行了简化：&lt;/p&gt;
&lt;p&gt;             1.服务器中只有一个群&lt;/p&gt;
&lt;p&gt;             2.新注册的账号，默认已经添加到该群中&lt;/p&gt;
&lt;p&gt;             3.私聊对象范围为该群的在线用户&lt;/p&gt;
&lt;p&gt;二、程序的实现语言&lt;/p&gt;
&lt;p&gt;c++&lt;/p&gt;
&lt;p&gt;三、聊天程序的架构&lt;/p&gt;
&lt;p&gt;       该程序采用经典的c/s架构，即采用客户端/服务器架构。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1044488/201804/1044488-20180410104118511-102599219.png&quot; alt=&quot;&quot; width=&quot;624&quot; height=&quot;351&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      1.服务器的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  接收发送器的消息请求，并根据消息类型进行不同的处理&lt;/li&gt;
&lt;li&gt;  通过文件存储用户的用户名和密码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      2.客户端的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  发送器：注册新账号，登录已有账号，发送群聊消息和私聊消息&lt;/li&gt;
&lt;li&gt;  接收器：接收服务器转发的群聊消息和私聊消息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三、具体实现&lt;/p&gt;
&lt;p&gt;        对于聊天程序，最主要的过程就是服务器与客户端程序之间的通信，本文已经默认读者已经具备了最基本的网络编程知识，某些具体细节便不再详述。&lt;/p&gt;
&lt;p&gt;       考虑到服务器程序是整个聊天程序的核心，因此重点讲述服务器程序的实现。其实，服务器程序实现以后，客户端的编程也就十分简单了。&lt;/p&gt;
&lt;p&gt;       1.服务器程序&lt;/p&gt;
&lt;p&gt;        服务器程序由一个server类实现，类的声明代码如下，各成员函数的功能也已详细注释好。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; server
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; Startup();                                                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测是否满足服务器运行的环境&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; SetServerSocket();                                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置服务器用来监听信息的socket套接字&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; Checktxt();                                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测存储文件是否存在，若不存在，创建一个&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; work();                                                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器运行的主函数&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; SendMessage(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;struct&lt;/span&gt; sockaddr_in x);           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送信息的函数&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; Sendonlinelist();                                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;向客户端发送好友在线列表&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; TestUsernameAndPassword(&lt;span&gt;string&lt;/span&gt; username, &lt;span&gt;string&lt;/span&gt; password);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试用户名和密码是否正确&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; TestDuplicateLogin(&lt;span&gt;string&lt;/span&gt; username);                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试是否重复登录&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; TestDuplicateRigister(&lt;span&gt;string&lt;/span&gt; username);                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试是否重复注册&lt;/span&gt;
    &lt;span&gt;string&lt;/span&gt; Getusername(&lt;span&gt;string&lt;/span&gt; ip,&lt;span&gt;int&lt;/span&gt; port);                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据ip和端口号获得用户名&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;  Getuserindex(&lt;span&gt;string&lt;/span&gt; username);                               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据用户名获得用户在在线用户表的索引号    &lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; extractLoginuserinfor(&lt;span&gt;string&lt;/span&gt; userinfor, &lt;span&gt;string&lt;/span&gt; &amp;amp;username, &lt;span&gt;string&lt;/span&gt; &amp;amp;password, &lt;span&gt;string&lt;/span&gt; &amp;amp;receiverport); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提取登录请求中的用户名密码和显示器端口号&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; extractRegisteruserinfor(&lt;span&gt;string&lt;/span&gt; userinfor, &lt;span&gt;string&lt;/span&gt;&amp;amp;username,&lt;span&gt;string&lt;/span&gt;&amp;amp;password);                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提取注册请求中的用户名和密码&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; extactPersonalMessageReceivername(&lt;span&gt;string&lt;/span&gt; &amp;amp;message,&lt;span&gt;string&lt;/span&gt; &amp;amp;receivername);                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提取私聊消息中的接收者的姓名&lt;/span&gt;
                                                   
&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    WSADATA wsaData;
    SOCKET sSocket;                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来接收消息的套接字&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; sockaddr_in ser;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器地址&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; sockaddr_in cli;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户地址&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; cli_length=&lt;span&gt;sizeof&lt;/span&gt;(cli);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户地址长度&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; recv_buf[BUFFER_LENGTH];              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收数据的缓冲区&lt;/span&gt;
    vector&amp;lt;user&amp;gt; usertable;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在线用户表&lt;/span&gt;
    &lt;span&gt;string&lt;/span&gt; sendmessage,printmessage;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储服务器转发、打印用的字符串&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; iSend, iRecv;                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储服务器发送和接收的字符串的长度&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下面具体讲一下这些成员函数的实现&lt;/p&gt;

&lt;p&gt;首先服务器运行需要检测运行环境是否得到满足，这里使用成员函数&lt;strong&gt;&lt;em&gt;Startup()&lt;/em&gt;&lt;/strong&gt;，服务器程序可以运行返回布尔值true，否则返回布尔值false，函数实现如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; server::Startup()
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (WSAStartup(MAKEWORD(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), &amp;amp;wsaData) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failed to load Winsock.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;服务器的套接字sSocket是用来接收客户端发送的各种类型的消息的。设置sSocket时除了要用&lt;strong&gt;&lt;em&gt;socket()&lt;/em&gt;&lt;/strong&gt;函数创建，还要用&lt;strong&gt;&lt;em&gt;bind()&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; &lt;/em&gt;函数为服务器绑定一个地址，这里的地址是指服务器的ip地址和端口号，是客户端默认知道的。本程序中服务&lt;/p&gt;
&lt;p&gt;器使用的端口号为 5055，已用用宏定义设置好&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; DEFAULT_PORT 5055
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;设置套接字sSocket的代码实现为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; server::SetServerSocket()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;产生服务器端套接口&lt;/span&gt;
    sSocket = socket(AF_INET, SOCK_DGRAM, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sSocket ==&lt;span&gt; INVALID_SOCKET)
    {
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socket()Failed:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; WSAGetLastError() &amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立服务器端地址&lt;/span&gt;
    ser.sin_family =&lt;span&gt; AF_INET;
    ser.sin_port &lt;/span&gt;= htons(DEFAULT_PORT);               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;htons()函数把一个双字节主机字节顺序的数转换为网络字节顺序的数&lt;/span&gt;
    ser.sin_addr.s_addr = htonl(INADDR_ANY);          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;htonl()函数把一个主机字节顺序的数转换为网络字节顺序的数   &lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (bind(sSocket, (LPSOCKADDR)&amp;amp;ser, &lt;span&gt;sizeof&lt;/span&gt;(ser)) ==&lt;span&gt; SOCKET_ERROR)
    {
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bind()Failed:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; WSAGetLastError() &amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;检查完运行环境，设置好套接字，就可以运行服务器主函数&lt;strong&gt;&lt;em&gt;work()&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; &lt;/em&gt;了，&lt;strong&gt;&lt;em&gt;work()&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; &lt;/em&gt;函数的工作过程为使用sSocket接收一个字符串，然后判断该字符串是哪种消息类型，从而进行相应的处理，如此无限循环。&lt;/p&gt;
&lt;p&gt;服务器要处理的消息类型一共有五种，分别是登录请求、注册请求、群聊消息、私聊消息、退出命令。这五种消息类型，可以用字符串的第一个字符来进行区分，比如’L‘是Login的首字母，用来作为登录请求的标志，’R‘是Rigister的首字母，用来&lt;/p&gt;
&lt;p&gt;作为注册请求的标志，’G‘是Group的首字母，用来作为群聊消息的标志，’P'是Personal的首字母，用来作为私聊消息的标志，最后字符串&quot;exit&quot;可以作为用户退出的命令。&lt;/p&gt;
&lt;p&gt;        （1）处理登录请求&lt;/p&gt;
&lt;p&gt;            首先，将登录请求中的用户名和密码，与服务器存储的用户名和密码进行对比，若存在用户名和密码与之匹配，则表明该账号是合法账号，否则为未注册账号或者登录密码错误。进一步查看用户在线列表中是否存在该用户，如果已经存&lt;/p&gt;
&lt;p&gt;在该用户，则表明该账号重复登录，若不存在，则允许登录该账户，并将该账户加入用户在线列表。用户用一个名为User的类来表示，用来存储用户的信息，如客户端的ip地址，发送器的端口号，接收器的端口号，用户名等。理所当然地，用户在线列表可以用一个User类型的vector来存储。该User类的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; user
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    user(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; username,&lt;span&gt;string&lt;/span&gt; ip,&lt;span&gt;int&lt;/span&gt; sender_port,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; receiver_port)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;username =&lt;span&gt; username;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;ip =&lt;span&gt; ip;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;sender_port =&lt;span&gt; sender_port;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;receiver_port =&lt;span&gt; receiver_port;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置接收器的地址&lt;/span&gt;
        receiver.sin_family =&lt;span&gt; AF_INET;          
        receiver.sin_port &lt;/span&gt;=&lt;span&gt; htons(receiver_port);
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *addr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[ip.length() + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        strcpy(addr, ip.c_str());
        receiver.sin_addr.s_addr &lt;/span&gt;=&lt;span&gt; inet_addr(addr);
    }
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; username;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;
    &lt;span&gt;string&lt;/span&gt; ip;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端ip地址&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; sender_port;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送器端口&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; receiver_port;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收器端口&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; sockaddr_in receiver;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储接收器的地址&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;       （2）处理注册请求&lt;/p&gt;
&lt;p&gt;           将注册请求中的设置的用户名和密码，与文件中存储的用户名进行匹配，若存在匹配的用户名，则已存在该用户名，为重复注册。若无匹配的用户名则表示无人注册该用户名，将该用户名和密码写入文件，并返回注册成功的信息。&lt;/p&gt;
&lt;p&gt;       （3）处理群聊消息&lt;/p&gt;
&lt;p&gt;            接收群聊消息时将发送者的名称，加在该群聊消息的首部，并转发给所有在线的用户。&lt;/p&gt;
&lt;p&gt;       （4）处理私聊消息&lt;/p&gt;
&lt;p&gt;            首先确定私聊消息的接收者是否在线，如果在线，在该私聊消息的首部加上发送者的姓名，转发给该接收者。若该用户不在线，则将在线的用户列表返回给发送者，让发送者根据此列表重新选择私聊对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;work()&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; &lt;/em&gt;函数里实现了对这五种消息类型的处理过程。下面给出该函数的实现过程。需要注意的是该函数的实现过程还牵扯到其他函数，这里不再详列出代码，读者只需要清楚它们的功能，是如何为&lt;strong&gt;&lt;em&gt;work()&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; &lt;/em&gt;函数服务的，先了解主函数的思&lt;/p&gt;
&lt;p&gt;路，其他函数的实现也是轻而易举了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; server::work()
{
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Server running&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;)                                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进入一个无限循环，进行数据接收和发送&lt;/span&gt;
&lt;span&gt;    {
        memset(recv_buf, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(recv_buf));         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化接收缓冲区&lt;/span&gt;
        iRecv = recvfrom(sSocket, recv_buf, BUFFER_LENGTH, &lt;span&gt;0&lt;/span&gt;, (&lt;span&gt;struct&lt;/span&gt; sockaddr*)&amp;amp;cli, &amp;amp;&lt;span&gt;cli_length);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (iRecv ==&lt;span&gt; SOCKET_ERROR)
        {
            cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recvfrom()Failed:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; WSAGetLastError() &amp;lt;&amp;lt;&lt;span&gt; endl;
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取发送方的地址（ip和端口）&lt;/span&gt;
        &lt;span&gt;char&lt;/span&gt; *x = inet_ntoa(cli.sin_addr); &lt;span&gt;string&lt;/span&gt; address(x);         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取客户端ip&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; userport = ntohs(cli.sin_port);                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取客户端端口&lt;/span&gt;

        &lt;span&gt;string&lt;/span&gt; infortype=&lt;span&gt;string&lt;/span&gt;(recv_buf);                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据infortype[0]来判断消息的类型       &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (infortype[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)                                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;登录请求&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; userinfor = infortype.substr(&lt;span&gt;1&lt;/span&gt;);                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;除去消息类型&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt;&lt;span&gt; username,password,receiver_port;
            extractLoginuserinfor(userinfor, username, password, receiver_port);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提取用户名和密码
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向不合法用户发送登录失败的回应&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;TestUsernameAndPassword(username,password))
            {
                SendMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cli);
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询该用户是否重复登录&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (TestDuplicateLogin(username))
            {
                SendMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cli);
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将合法的未登录的用户加入列表&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; receiver_port_int =&lt;span&gt; atoi(receiver_port.c_str());
            user newuser(username, address, userport, receiver_port_int);
            usertable.push_back(newuser);
            
            printmessage&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(上线消息)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+ newuser.username + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已上线&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要打印的消息&lt;/span&gt;
            sendmessage = printmessage;                                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要转发的消息    &lt;/span&gt;
            SendMessage(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, cli);                                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;向客户端发送登录成功的回应&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (infortype[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册信息&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; userinfor = infortype.substr(&lt;span&gt;1&lt;/span&gt;);                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;除去消息类型        &lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt;&lt;span&gt; username, password;
            extractRegisteruserinfor(userinfor, username, password); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提取用户名和密码
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测用户名是否已经注册过&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (TestDuplicateRigister(username))
            {
                SendMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cli);
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向文件写入新注册的用户名和密码&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Checktxt())
            {
                SendMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cli);
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            fstream &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\userform\\userform.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ios::app);
            &lt;/span&gt;&lt;span&gt;out&lt;/span&gt; &amp;lt;&amp;lt; userinfor &amp;lt;&amp;lt;&lt;span&gt; endl;
            &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.close();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送注册成功的回应&lt;/span&gt;
            SendMessage(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cli);
            cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;注册成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; endl&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新用户名为:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;username&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;&lt;span&gt;endl;
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (infortype[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;G&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)                                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;群聊消息&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; message = infortype.substr(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sendername = Getusername(address, userport);                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取发送者姓名&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (sendername == &lt;span&gt;&quot;&quot;&lt;/span&gt;)   &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            printmessage &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(群消息）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + sendername + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + message;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要打印的消息&lt;/span&gt;
            sendmessage =&lt;span&gt; printmessage;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sendmessage = &quot;G#&quot;+sendername + &quot;:&quot; + message;                       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要转发的消息&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (infortype[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;私聊消息&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (infortype[&lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取在线好友列表的请求&lt;/span&gt;
&lt;span&gt;            {
                Sendonlinelist();
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (infortype[&lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;私聊消息&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; message = infortype.substr(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sendername = Getusername(address, userport);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提取发送者姓名&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (sendername == &lt;span&gt;&quot;&quot;&lt;/span&gt;)  &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提取接收者姓名&lt;/span&gt;
                &lt;span&gt;string&lt;/span&gt;&lt;span&gt; receivername;
                extactPersonalMessageReceivername(message, receivername);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查接收者是否离线&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; Getuserindex(receivername);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == usertable.size())                              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收者已经离线&lt;/span&gt;
&lt;span&gt;                {
                    Sendonlinelist();                                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新将一份好友在线列表发送给发送方&lt;/span&gt;
                    &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                SendMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, cli);                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;向发送方发送成功的响应&lt;/span&gt;
                printmessage = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(私消息)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + sendername + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + receivername + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + message;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要打印的消息&lt;/span&gt;
                cout &amp;lt;&amp;lt; printmessage &amp;lt;&amp;lt;&lt;span&gt; endl;
                cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户ip:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; address &amp;lt;&amp;lt;&lt;span&gt; endl;
                cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户端口:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; userport &amp;lt;&amp;lt;&lt;span&gt; endl;
                cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前在线人数:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; usertable.size() &amp;lt;&amp;lt; endl &amp;lt;&amp;lt;&lt;span&gt; endl;
                sendmessage&lt;/span&gt;= printmessage;                                                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要发送的消息&lt;/span&gt;
&lt;span&gt;                SendMessage(sendmessage, usertable[i].receiver);
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (infortype == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sendername =&lt;span&gt; Getusername(address, userport);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sendername == &lt;span&gt;&quot;&quot;&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; Getuserindex(sendername);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;= usertable.size() || i &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            SendMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, usertable[i].receiver);                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;向该用户显示器发送退出命令&lt;/span&gt;
            usertable.erase(usertable.begin() +&lt;span&gt; i);
            printmessage &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(下线消息)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +sendername + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已下线&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要打印的消息&lt;/span&gt;
            sendmessage = printmessage;                                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要转发的消息&lt;/span&gt;
&lt;span&gt;            
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在服务器上打印消息    &lt;/span&gt;
        cout &amp;lt;&amp;lt; printmessage &amp;lt;&amp;lt;&lt;span&gt; endl;
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户ip:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; address &amp;lt;&amp;lt;&lt;span&gt; endl;
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户端口:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; userport &amp;lt;&amp;lt;&lt;span&gt; endl;
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前在线人数:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; usertable.size() &amp;lt;&amp;lt; endl &amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向客户端发送消息&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; usertable.size(); i++&lt;span&gt;)
            SendMessage(sendmessage, usertable[i].receiver);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;       值得注意的是，如果客户端非正常退出，那么服务器仍然认为该用户在线，继续向该用户转发消息，那么向该客户端消息的套接字就会出现问题，表现为再用该套接字监听消息时会产生编号为10054的错误。因此为了避免服务器程序崩溃，&lt;/p&gt;
&lt;p&gt;非常有必要为专门建立一个套接字用来接收客户端发来的消息，而不用该套接字发送任何消息。这样即使客户端非正常退出，也不会影响服务器继续运行，处理其他客户端发送的消息，提高了服务器的容错性。&lt;/p&gt;


&lt;p&gt;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;2.客户端程序&lt;/p&gt;
&lt;p&gt;客户端程序要满足发送消息和接收消息两个功能，发送消息和接收消息这两个过程要独立进行，互不干扰，因此发送消息和接收消息可以用两个线程或者是进程来实现。考虑到，若采用多线程的方法，那么发送消息的线程和接收消息的线&lt;/p&gt;
&lt;p&gt;程会抢占控制台的控制权。当客户端频繁接收消息时，接收消息的线程会一直在控制台上输出接收到的消息，会造成用户无法发送消息的尴尬情况。因此，我决定将发送消息和接收消息这两个功能用两个进程实现。这样接收消息的控制台程序成&lt;/p&gt;
&lt;p&gt;为接收器（显示器），发送消息的控制台程序叫做发送器。&lt;/p&gt;
&lt;p&gt;      但是这样做存在一个问题，即在服务器的角度上如何将一个显示器进程和已上线的用户名相关联呢？举个例子，当服务器收到A转发给B的私信时，服务器是如何知道用户B的显示器的端口号呢？&lt;/p&gt;
&lt;p&gt;一个简单的方法是，发送器和显示器采用一个提前确定好的端口号，显示器通过该端口来接收服务器转发来的信息。用户通过发送器登录时，除了将用户名和密码发送给服务器，还要将显示器的端口号发送给服务器。当服务器验证用户的登录成&lt;/p&gt;
&lt;p&gt;功以后，将显示器端口号存储在User类的对象中，当服务器要转发消息给该用户时便知道了该用户显示器的地址。这种做法的优点是简单，缺点也很明显，显示器在运行时使用的是固定的端口号，当一台主机上运行多个显示器程序时，就会发生&lt;/p&gt;
&lt;p&gt;端口冲突，报编号为10048的错误。&lt;/p&gt;
&lt;p&gt;为解决端口冲突的问题，需要让显示器在每次运行时使用不同的端口号，这个可以通过随机函数来实现，让显示器在运行时首先通过随机函数产生一个端口号，再建立套接字接收消息。但是这样的话，显示器随机产生的端口号发送器是不知道&lt;/p&gt;
&lt;p&gt;的，那么如何告知服务器该端口号呢？如果让显示器直接给服务器发送端口号，需要同时发送用户名和端口号，才能使服务器将这两者关联起来。为了显示器获取用户名，需要用户在运行显示器时再一次输入用户名。这种做法是不符合使用逻辑&lt;/p&gt;
&lt;p&gt;的，因为按正常的逻辑，当我们通过发送器登录账号后，打开显示器就应该可以直接接收消息，所以让显示器发送端口号的方法也同样不太可取。&lt;/p&gt;
&lt;p&gt;我采用的方法是前面两种方法的综合，即显示器的端口号要由发送器发送给服务器，且显示器的端口号也要用随机函数产生。那么显示器如何知道发送器产生的端口号呢？考虑到显示器和发送器运行在一台主机上，发送器可以将随机产生的端口&lt;/p&gt;
&lt;p&gt;号写入文件，显示器运行时读取该文件，便得到了自己接收服务器消息的端口号。而且由于是随机产生的端口号，在主机上运行多个显示器程序也不会发生冲突。&lt;/p&gt;
&lt;p&gt;         这个问题解决以后，发送器和接收器实现起来就很方便了。发送器根据登录、注册、群聊、私聊、退出这五种操作设置不同的消息类型（已在服务器实现中详述），发送给服务器处理就可以了。显示器更简单，从文件中读取端口号建立套&lt;/p&gt;
&lt;p&gt;接字以后，就在无限循环中接收服务器转发的消息并显示在控制台端口中。逻辑很简单，不再罗列代码。&lt;/p&gt;

&lt;p&gt;四、运行&lt;/p&gt;
&lt;p&gt;     代码已在vs2015中运行成功。&lt;/p&gt;
&lt;p&gt;     若运行编译运行源代码请注意以下事项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编译代码时请在 源文件属性-c/c++-常规-SDL检查 这一路径中将SDL检查设置为否&lt;/li&gt;
&lt;li&gt;由于发送器sender.exe运行时要调用显示器receiver.exe,所以将编译receiver.cpp文件产生的receiver.exe文件以相对路径放在发送器的工程文件夹下&lt;/li&gt;
&lt;li&gt;运行时请确保主机已关闭防火墙&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    1.服务器&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1044488/201804/1044488-20180411183456005-1479346040.png&quot; alt=&quot;&quot; width=&quot;442&quot; height=&quot;379&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       用户上线提醒&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1044488/201804/1044488-20180411183742733-1307847547.png&quot; alt=&quot;&quot; width=&quot;442&quot; height=&quot;385&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      注册提醒&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1044488/201804/1044488-20180411184115918-974565723.png&quot; alt=&quot;&quot; width=&quot;443&quot; height=&quot;396&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      显示私聊消息&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1044488/201804/1044488-20180411184322042-318170487.png&quot; alt=&quot;&quot; width=&quot;443&quot; height=&quot;263&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       显示群聊消息&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1044488/201804/1044488-20180411184508852-1290784168.png&quot; alt=&quot;&quot; width=&quot;446&quot; height=&quot;290&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.发送器&lt;/p&gt;

&lt;p&gt;       登录界面&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1044488/201804/1044488-20180411183628171-933214279.png&quot; alt=&quot;&quot; width=&quot;445&quot; height=&quot;455&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      登录成功的界面&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1044488/201804/1044488-20180411184630626-1112229444.png&quot; alt=&quot;&quot; width=&quot;444&quot; height=&quot;414&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      私聊界面&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1044488/201804/1044488-20180411185530769-128701736.png&quot; alt=&quot;&quot; width=&quot;443&quot; height=&quot;409&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      群聊界面&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1044488/201804/1044488-20180411185608449-545474976.png&quot; alt=&quot;&quot; width=&quot;442&quot; height=&quot;395&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.显示器&lt;/p&gt;

&lt;p&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/1044488/201804/1044488-20180411185659912-1589025415.png&quot; alt=&quot;&quot; width=&quot;437&quot; height=&quot;426&quot;/&gt;    &lt;/p&gt;

&lt;p&gt; 五、可执行文件和源代码链接&lt;/p&gt;
</description>
<pubDate>Wed, 11 Apr 2018 13:34:00 +0000</pubDate>
<dc:creator>Rcchio</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Rcchio/p/8762613.html</dc:identifier>
</item>
<item>
<title>创建以mybatis为基础的web项目（2）mabitis中的一对一关系项目实战 - 邢逸</title>
<link>http://www.cnblogs.com/xyblogs/p/8780870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xyblogs/p/8780870.html</guid>
<description>&lt;p&gt;&lt;span&gt;mabitis中的一对一关系项目实战：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.首先根据创建以mybatis为基础的web项目（1）中的流程将web项目部署好&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开IDE，建立web工程&lt;/li&gt;
&lt;li&gt;在lib下面粘贴mybatis的jar，log4j的jar，mysql 连接的jar 最后最最重要的是要添加到构建路径中去，这样才能够被项目所使用&lt;/li&gt;
&lt;li&gt;新建一个源文件夹config，用于存放xml文件&lt;/li&gt;
&lt;li&gt;在src目录把下面新建四个包，分别是：
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;com.pojo:存放数据库表对应的实体类&lt;/li&gt;
&lt;li&gt;com.imp:存放接口类&lt;/li&gt;
&lt;li&gt;com.test:存放测试类&lt;/li&gt;
&lt;li&gt;com.util:存放工具类（最好写成静态方法，可以用类点方法的方式调用方法）&lt;/li&gt;
&lt;li&gt;目录结构如下图所示：
&lt;ul&gt;&lt;li&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368438/201804/1368438-20180410232826514-214744405.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在config下面新建一个com.imp包:存放接口类对应的xml文件（使用mapper代理接口方式： 使用接口和XML文件，在后台自动生成操作数据库的类）&lt;/li&gt;
&lt;li&gt;在config下面新建一个main_config.xml文件用于配置数据库和一些相关的映射，环境，插件，别名，配置文件
&lt;ol&gt;&lt;li&gt;　　&lt;img id=&quot;code_img_closed_e276508c-fd13-4502-8648-bffc6a5dc38c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;main_config.xml&lt;/span&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;相应的再建立一个main_config.properties(这是一个键值对的文件，可用于存放jdbc的连接，便于修改)
&lt;ol&gt;&lt;li&gt;　　&lt;img id=&quot;code_img_closed_1062590c-83d8-4eb1-a87f-a7faffb74ed8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;main_config.properties&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;写一个工具类（MybatisConnection.java ），用于获取连接：
&lt;ol&gt;&lt;li&gt;　　
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_2026d088-5e35-42e1-bf58-d93293d7fcd4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2026d088-5e35-42e1-bf58-d93293d7fcd4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2026d088-5e35-42e1-bf58-d93293d7fcd4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.util;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.io.Resources;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSession;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactory;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactoryBuilder;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyBatisConnection {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SqlSession getSqlSession() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取主配置文件&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         InputStream inputStream = Resources.getResourceAsStream(&quot;main_config.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建会话工厂&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         SqlSessionFactory sqlSessionFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder().build(inputStream);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         SqlSession sqlSession =&lt;span&gt; sqlSessionFactory.openSession();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sqlSession;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt;         
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;MyBatisConnection.java&lt;/span&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;写一个测试类（TestConnection）：测试是否可以获取连接
&lt;ol&gt;&lt;li&gt;　　
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e372b0a3-ed96-40dd-bbf4-ad7a727d1c22&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e372b0a3-ed96-40dd-bbf4-ad7a727d1c22&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e372b0a3-ed96-40dd-bbf4-ad7a727d1c22&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSession;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.util.MyBatisConnection;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestConnection {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         SqlSession sqlSession =&lt;span&gt; MyBatisConnection.getSqlSession();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        System.out.println(sqlSession);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TestConnection.java　　&lt;/span&gt;  &lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 2.建立一个人的表（t_person）,每个人对应一个身份证（一一对应关系）所以建立一个（t_card）表&lt;/p&gt;
&lt;p&gt;表结构如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368438/201804/1368438-20180410235251186-1235030233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368438/201804/1368438-20180410235355250-1644117427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.建立对应的实体类（pojo）&lt;/p&gt;
&lt;p&gt;注意在person.java中cid对应写的是card的对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_7a83445c-1765-4b0f-8841-e8b449950cd9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7a83445c-1765-4b0f-8841-e8b449950cd9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7a83445c-1765-4b0f-8841-e8b449950cd9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.pojo;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Card {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; cardid;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Card() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 自动生成的构造函数存根&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCardid() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cardid;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCardid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cardid) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.cardid =&lt;span&gt; cardid;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Card [id=&quot; + id + &quot;, cardid=&quot; + cardid + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Card.java&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_9729c843-d64e-4f3b-8aa9-76ccf86eea4a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9729c843-d64e-4f3b-8aa9-76ccf86eea4a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9729c843-d64e-4f3b-8aa9-76ccf86eea4a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.pojo;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Card card;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 自动生成的构造函数存根&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Card getCard() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; card;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCard(Card card) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.card =&lt;span&gt; card;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Person [id=&quot; + id + &quot;, name=&quot; + name + &quot;, card=&quot; + card + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Person.java&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;4.写接口或者对应的xml文件（要注意三个规范：1.接口名和映射文件名相同，2.在同一目录下，3.使用mapper代理接口（接口和XML文件，在后台自动生成操作数据库的类）） &lt;/p&gt;
&lt;p&gt;建议先写接口，有了接口之后再考虑怎么实现&lt;/p&gt;
&lt;p&gt;我先写了一个接口（IPerson.java）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_0be1b0aa-8988-4854-b0d9-c22bc310ec3b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0be1b0aa-8988-4854-b0d9-c22bc310ec3b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0be1b0aa-8988-4854-b0d9-c22bc310ec3b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.imp;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.pojo.Person;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IPerson {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询所有&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     List&amp;lt;Person&amp;gt;&lt;span&gt; sqlall();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;IPerson.java&lt;/span&gt;&lt;/div&gt;

&lt;p&gt; 再写对应的xml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_eacfbdd1-da33-4b22-9097-d910742ede4e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_eacfbdd1-da33-4b22-9097-d910742ede4e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_eacfbdd1-da33-4b22-9097-d910742ede4e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; namespace：命名空间， 用于隔离sql语句 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.imp.IPerson&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; id是sql语句的唯一标识符，名字要与 接口中的方法名相同 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;sqlall&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    SELECT
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    t_person.id,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    t_person.`name`,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    t_person.cid,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    t_card.id,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    t_card.cardid
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    FROM
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    t_card
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    INNER JOIN t_person ON t_person.cid = t_card.id
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;person&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; association 是一对一映射关系使用的标签 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;association &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;association&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;association &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;card&quot;&lt;/span&gt;&lt;span&gt; javaType&lt;/span&gt;&lt;span&gt;=&quot;card&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;cid&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;cardid&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;cardid&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;association&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;IPerson.xml&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;在IPerson.xml中namepace的值为对应的接口的全限定名（com.imp.IPerson） &lt;/p&gt;
&lt;p&gt;在IPerson.xml的查询中我们没有使用resultType而是使用了resultMap&lt;/p&gt;
&lt;p&gt;这是因为数据库表中的字段和实体类的属性不一致，这时候我们使用resultMap&lt;/p&gt;
&lt;p&gt;&lt;em&gt;id表示主键， &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;result 表示普通的字段&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;association：一对一关系&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;column表示：查询结果对应的字段&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;property：实体类对应的属性&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;查询语句可以直接通过工具直接生成（直接拖动到空白处即可生成查询语句）&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368438/201804/1368438-20180411210302176-931212023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.接下来就应该是在主配置文件中写映射文件的路径了&lt;/p&gt;
&lt;p&gt;大家发现没有，我在IPerson.xml文件中写的Type，javaType都是实体类名，没有加包名，（这里我们要注意，我在主配置&lt;/p&gt;
&lt;p&gt;文件中写了别名，是通过包来加载的，所以只要写类名即可，首字母的大小写不作区分）&lt;/p&gt;
&lt;p&gt;在主配置文件的mappers标签中我使用的也是package映射，这是为了使用更加方便，如果有很多的xml文件要映射，那不是要写很多，这里只写一句就够了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_2bf5db63-e363-4942-95c1-da7e11b378a1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2bf5db63-e363-4942-95c1-da7e11b378a1&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2bf5db63-e363-4942-95c1-da7e11b378a1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 取别名 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;com.pojo&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 添加映射文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;com.imp&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;main_config.xml&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;注意标签的顺序，这个有严格的规定&lt;/p&gt;
&lt;p&gt;Content Model : (properties?, settings?, typeAliases?, typeHandlers?, objectFactory?,&lt;br/&gt;objectWrapperFactory?, reflectorFactory?, plugins?, environments?, databaseIdProvider?, mappers?)&lt;/p&gt;
&lt;p&gt;6.接下来我们就要写一个测试文件，看看我们是否写成功了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_2f0eefdd-7aa3-45dc-894c-b47a26e772e9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2f0eefdd-7aa3-45dc-894c-b47a26e772e9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2f0eefdd-7aa3-45dc-894c-b47a26e772e9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSession;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.imp.IPerson;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.pojo.Person;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.util.MyBatisConnection;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSqlAll {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         SqlSession sqlSession =&lt;span&gt; MyBatisConnection.getSqlSession();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         IPerson person = sqlSession.getMapper(IPerson.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         List&amp;lt;Person&amp;gt; list =&lt;span&gt; person.sqlall();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Person person2 : list) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            System.out.println(person2);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TestSqlAll.java&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;可能测试的时候会发生错误，我们要仔细看看报的什么错误，找到错误所在，改正即可&lt;/p&gt;
&lt;p&gt;7.测试结果如下（如果为空，那是因为你的数据库是空的啊）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368438/201804/1368438-20180411211757804-914573173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt; &lt;/p&gt;
</description>
<pubDate>Wed, 11 Apr 2018 13:22:00 +0000</pubDate>
<dc:creator>邢逸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xyblogs/p/8780870.html</dc:identifier>
</item>
</channel>
</rss>