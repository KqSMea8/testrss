<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MyBatis 框架之快速入门程序 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8993151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8993151.html</guid>
<description>&lt;p&gt;关于如何快速创建 Maven 项目，这个可以参考下面这篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU5MTE0ODcwNQ==&amp;amp;mid=2247484175&amp;amp;idx=1&amp;amp;sn=3bfecf0c6f889560d02f07ad30879961&amp;amp;chksm=fe3220c1c945a9d75f5a3205edfe8907081d931c69d9377128b422b7c622440ae59c352f01fb#rd&quot;&gt;Maven 项目管理工具基础入门系列（一）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打开 &lt;code&gt;pom.xml&lt;/code&gt; 文件，快速配置 jar 包，配置代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&amp;lt;project xmlns=&lt;span class=&quot;st&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt; xmlns:xsi=&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
  xsi:schemaLocation=&lt;span class=&quot;st&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;modelVersion&amp;gt;&lt;span class=&quot;fl&quot;&gt;4.0.0&lt;/span&gt;&amp;lt;/modelVersion&amp;gt;
  &amp;lt;groupId&amp;gt;com.&lt;span class=&quot;fu&quot;&gt;mybatis&lt;/span&gt;&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;MyBatisDemo&amp;lt;/artifactId&amp;gt;
  &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
  &amp;lt;version&amp;gt;&lt;span class=&quot;fl&quot;&gt;0.0.1&lt;/span&gt;-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;name&amp;gt;MyBatisDemo Maven Webapp&amp;lt;/name&amp;gt;
  &amp;lt;url&amp;gt;http:&lt;span class=&quot;co&quot;&gt;//maven.apache.org&amp;lt;/url&amp;gt;&lt;/span&gt;
  &amp;lt;dependencies&amp;gt;

    &amp;lt;!-- MyBatis 依赖包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.&lt;span class=&quot;fu&quot;&gt;mybatis&lt;/span&gt;&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;&lt;span class=&quot;fl&quot;&gt;3.4.5&lt;/span&gt;&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- 数据库驱动依赖包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;&lt;span class=&quot;fl&quot;&gt;5.1.25&lt;/span&gt;&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- junit 测试依赖包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;&lt;span class=&quot;fl&quot;&gt;3.8.1&lt;/span&gt;&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    
  &amp;lt;/dependencies&amp;gt;

  &amp;lt;build&amp;gt;
    &amp;lt;finalName&amp;gt;MyBatisDemo&amp;lt;/finalName&amp;gt;
    &amp;lt;resources&amp;gt;
      &amp;lt;resource&amp;gt;
        &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
        &amp;lt;includes&amp;gt;
          &amp;lt;include&amp;gt;**&lt;span class=&quot;co&quot;&gt;/*.xml&amp;lt;/include&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        &amp;lt;/includes&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      &amp;lt;/resource&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &amp;lt;/resources&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;  &amp;lt;/build&amp;gt;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建 pojo 类 &lt;code&gt;User.java&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.mybatis.pojo;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; User{

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; id;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String username;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String password;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; age;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; id;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; id) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt; = id;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; username;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setUsername&lt;/span&gt;(String username) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;username&lt;/span&gt; = username;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getPassword&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; password;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setPassword&lt;/span&gt;(String password) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;password&lt;/span&gt; = password;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getAge&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; age;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setAge&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; age) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;age&lt;/span&gt; = age;
    }
    
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;User [id=&quot;&lt;/span&gt; + id + &lt;span class=&quot;st&quot;&gt;&quot;, username=&quot;&lt;/span&gt; + username + &lt;span class=&quot;st&quot;&gt;&quot;, password=&quot;&lt;/span&gt;
                + password + &lt;span class=&quot;st&quot;&gt;&quot;, age=&quot;&lt;/span&gt; + age + &lt;span class=&quot;st&quot;&gt;&quot;]&quot;&lt;/span&gt;;
    }
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;新建数据库 mybatis_db，创建表 t_user，建表代码如下：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;CREATE TABLE `t_user`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '',
  `age` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;创建接口 &lt;code&gt;UserDao.java&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.mybatis.dao;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.mybatis.pojo.User;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; UserDAO {
    
    &lt;span class=&quot;co&quot;&gt;//新增用户&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addUser&lt;/span&gt;(User user);
    
    &lt;span class=&quot;co&quot;&gt;//根据id删除用户&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;deleteUser&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; id);
    
    &lt;span class=&quot;co&quot;&gt;//修改用户&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;updateUser&lt;/span&gt;(User user);
    
    &lt;span class=&quot;co&quot;&gt;//根据id查询用户&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; User &lt;span class=&quot;fu&quot;&gt;selectUserById&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; id);
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建 xml 文件 &lt;code&gt;UserDaoMapper.java&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt; 

&lt;span class=&quot;kw&quot;&gt;&amp;lt;mapper&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; namespace=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.mybatis.dao.UserDao&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
     
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;insert&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;addUser&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; parameterType=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.mybatis.pojo.User&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
       insert into t_user (username,password,age) values (#{username},#{password},#{age})
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/insert&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;delete&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;deleteUser&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; parameterType=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;int&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
       delete from t_user where id=#{id}  
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/delete&amp;gt;&lt;/span&gt; 
    
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;update&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;updateUser&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
       update t_user set username=#{username},password=#{password},age=#{age} where id=#{id}
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/update&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;select&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;selectUserById&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; parameterType=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;int&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; resultType=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.mybatis.pojo.User&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
       select * from t_user where id=#{id}
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;
    
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/mapper&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建 xml 文件 &lt;code&gt;mybatis-comfig.xml&lt;/code&gt;，具体配置如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 配置 MyBatis 运行环境 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;environments&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; default=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;environment&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 配置 JDBC 事务管理 --&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;transactionManager&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;JDBC&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- POOLED 配置 JDBC 数据源连接池 --&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;dataSource&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;POOLED&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;driver&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;url&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jdbc:mysql://localhost:3306/mybatis_db?useUnicode=true&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;&amp;amp;amp;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;characterEncoding=UTF-8&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dataSource&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/environment&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/environments&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 注册 UserDAO.xml --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;mapper&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; resource=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com/mybatis/dao/UserDaoMapper.xml&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/mappers&amp;gt;&lt;/span&gt;
    
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建测试类 &lt;code&gt;Test.java&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.mybatis.test;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.InputStream;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.session.SqlSession;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.session.SqlSessionFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.session.SqlSessionFactoryBuilder;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.mybatis.dao.UserDao;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.mybatis.pojo.User;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Test {
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {

        &lt;span class=&quot;co&quot;&gt;//加载MyBatis配置文件&lt;/span&gt;
        InputStream is = Test.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getClassLoader&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getResourceAsStream&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;mybatis-config.xml&quot;&lt;/span&gt;);
        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SqlSessionFactoryBuilder&lt;/span&gt;();
        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;(is);

        &lt;span class=&quot;co&quot;&gt;//获取SqlSession&lt;/span&gt;
        SqlSession sqlSession = sqlSessionFactory.&lt;span class=&quot;fu&quot;&gt;openSession&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;//获取实现接口的代理对象&lt;/span&gt;
        UserDao userDAO = sqlSession.&lt;span class=&quot;fu&quot;&gt;getMapper&lt;/span&gt;(UserDao.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
        
        &lt;span class=&quot;co&quot;&gt;//新增用户&lt;/span&gt;
        User user = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;User&lt;/span&gt;();
        user.&lt;span class=&quot;fu&quot;&gt;setUsername&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;孔乙己&quot;&lt;/span&gt;);
        user.&lt;span class=&quot;fu&quot;&gt;setPassword&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;123456&quot;&lt;/span&gt;);
        user.&lt;span class=&quot;fu&quot;&gt;setAge&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;21&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(userDAO.&lt;span class=&quot;fu&quot;&gt;addUser&lt;/span&gt;(user));
        sqlSession.&lt;span class=&quot;fu&quot;&gt;commit&lt;/span&gt;();
        
&lt;span class=&quot;co&quot;&gt;//      //删除用户&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      System.out.println(userDAO.deleteUser(1));&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      sqlSession.commit();&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      //查询用户&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      User user1 = userDAO.selectUserById(1);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      System.out.println(user1);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      //修改用户&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      User user2 = userDAO.selectUserById(1);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      user2.setUsername(&quot;指南者&quot;);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      System.out.println(userDAO.updateUser(user2));&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      sqlSession.commit();&lt;/span&gt;

    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/4/1632b98599f10f30?w=425&amp;amp;h=140&amp;amp;f=png&amp;amp;s=6649&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/4/1632b98788288aed?w=547&amp;amp;h=236&amp;amp;f=png&amp;amp;s=12242&quot;/&gt;&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;-----------------------------------------&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/4/1632b9a25daec092?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27341&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 04 May 2018 15:41:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8993151.html</dc:identifier>
</item>
<item>
<title>【基础】CSS实现多重边框的5种方式 - 毛三十</title>
<link>http://www.cnblogs.com/ifat3/p/8993088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ifat3/p/8993088.html</guid>
<description>&lt;h2 id=&quot;简言&quot;&gt;简言&lt;/h2&gt;
&lt;p&gt;目前最优雅地实现多重边框的方案是利用&lt;code&gt;CSS3&lt;/code&gt; 的 &lt;code&gt;box-shadow&lt;/code&gt;属性，但如果要兼容老的浏览器，则需要选择其它的方案。本文简要地列举了几种多重边框的实现方案，大家可以根据项目实际及兼容性要求等情况，选择最适合的实现方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://res.42du.cn/up/201805/eaflrdo1.jpg&quot; alt=&quot;CSS多重边框&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;利用描边outline属性&quot;&gt;1 利用描边(&lt;code&gt;outline&lt;/code&gt;)属性&lt;/h2&gt;
&lt;p&gt;方案1利用描边(&lt;code&gt;outline&lt;/code&gt;)属性结合&lt;code&gt;border&lt;/code&gt;属性实现双重边框。此方案实现简单，兼容性好，能兼容除&lt;code&gt;IE6,7&lt;/code&gt;以外的浏览器。&lt;/p&gt;
&lt;h3 id=&quot;核心代码&quot;&gt;1.1 核心代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.borders&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;6px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#fff&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;outline:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;6px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#888&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;演示程序&quot;&gt;1.2 演示程序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://res.42du.cn/up/201805/df9cihc8.jpg&quot; alt=&quot;利用outline实现双重边框&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.42du.cn/run/175&quot;&gt;演示程序&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;说明&quot;&gt;1.3 说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;只能实现双重边框&lt;/li&gt;
&lt;li&gt;边框样式灵活，可以实现虚线等样式的边框&lt;/li&gt;
&lt;li&gt;描边在盒模型之外，会与外部元素发生重叠&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;利用额外的div&quot;&gt;2 利用额外的DIV&lt;/h2&gt;
&lt;p&gt;方案2利用额外的DIV嵌套的方式实现多重边框。这也是唯一不存在兼容性问题的方案。&lt;/p&gt;
&lt;h3 id=&quot;核心代码-1&quot;&gt;2.1 核心代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.outer&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;6px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#888&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#fff&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.inner&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#222&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;6px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;演示程序-1&quot;&gt;2.2 演示程序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://res.42du.cn/up/201805/mbamxafi.jpg&quot; alt=&quot;利用额外的DIV嵌套实现双重边框&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.42du.cn/run/176&quot;&gt;演示程序&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;说明-1&quot;&gt;2.3 说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;兼容性好&lt;/li&gt;
&lt;li&gt;可以实现多重边框，虚线边框等样式&lt;/li&gt;
&lt;li&gt;需要额外的DIV元素，增加了代码复杂性&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;利用伪元素&quot;&gt;3 利用伪元素&lt;/h2&gt;
&lt;p&gt;方案3利用伪元素（&lt;code&gt;:before&lt;/code&gt;）的方式实现双重边框。实现代码略复杂，属于hack的实现方式，不推荐。&lt;/p&gt;
&lt;h3 id=&quot;核心代码-2&quot;&gt;3.1 核心代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.borders&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;6px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#fff&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.borders&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;:before&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;content:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;absolute&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;-12px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;left:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;-12px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;right:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;-12px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;bottom:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;-12px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;6px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#888&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;演示程序-2&quot;&gt;3.2 演示程序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://res.42du.cn/up/201805/amlsefsh.jpg&quot; alt=&quot;利用伪元素实现双重边框&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.42du.cn/run/177&quot;&gt;演示程序&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;说明-2&quot;&gt;3.3 说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IE6,7,8&lt;/code&gt;不兼容&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;:after&lt;/code&gt;也可以&lt;/li&gt;
&lt;li&gt;同时应用&lt;code&gt;:before&lt;/code&gt;和&lt;code&gt;:after&lt;/code&gt;可以实现三重边框&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;利用border-image属性&quot;&gt;4 利用&lt;code&gt;border-image&lt;/code&gt;属性&lt;/h2&gt;
&lt;p&gt;方案4利用&lt;code&gt;CSS3&lt;/code&gt;的&lt;code&gt;border-image&lt;/code&gt;属性实现多重边框。实现方法简单，但需要制做一个额外的边框图片，兼容性较差。&lt;/p&gt;
&lt;h3 id=&quot;核心代码-3&quot;&gt;4.1 核心代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.borders&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;12px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;transparent&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;border-image:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;url(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'borders.jpg'&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;repeat&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;演示程序-3&quot;&gt;4.2 演示程序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://res.42du.cn/up/201805/qluvsthf.jpg&quot; alt=&quot;利用border-image属性实现双重边框&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.42du.cn/run/178&quot;&gt;演示程序&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;说明-3&quot;&gt;4.3 说明&lt;/h3&gt;
&lt;p&gt;本例中，利用&lt;code&gt;border-image-slice&lt;/code&gt;将边框图片分成如下图所示的9个区域：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://res.42du.cn/up/201805/1bmrorni.jpg&quot; alt=&quot;border-image-slice示例图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中包括四个角（1，2，3，4），四条边（5，6，7，8）以及中间区域（9）。&lt;br/&gt;&lt;code&gt;repeat&lt;/code&gt;表示四条边都在相应的边框上重复的平铺。&lt;/p&gt;
&lt;h2 id=&quot;利用box-shadow属性&quot;&gt;5 利用&lt;code&gt;box-shadow&lt;/code&gt;属性&lt;/h2&gt;
&lt;p&gt;方案5利用&lt;code&gt;box-shadow&lt;/code&gt;属性实现多重边框。方案5是最简单，最直接的实现多重边框的方式。只有一行代码就可以实现多重边框效果。利用了阴影（&lt;code&gt;box-shadow&lt;/code&gt;）实现边框多少有一些hack的味道。&lt;/p&gt;
&lt;h3 id=&quot;核心代码-4&quot;&gt;5.1 核心代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.borders&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;box-shadow:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;6px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#fff&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;12px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#888&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;演示程序-4&quot;&gt;5.2 演示程序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://res.42du.cn/up/201805/ecfwlrrk.jpg&quot; alt=&quot;利用box-shadow属性实现多重边框&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.42du.cn/run/179&quot;&gt;演示程序&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;说明-4&quot;&gt;5.3 说明&lt;/h3&gt;
&lt;p&gt;为了用阴影模拟边框，本例中使用了两个阴影效果，设置偏移值和模糊值为&lt;code&gt;0&lt;/code&gt;，并适当地设置阴影的尺寸，从而实现了双重边框的效果。因为一个阴影重叠在另一个阴影之上，第二个阴影的尺寸要设置成第一个阴影尺寸的两倍。关键部分是将模糊值设成0，从而产生像边框一样的纯色阴影，看起来和边框一样。&lt;/p&gt;
&lt;p&gt;和描边（&lt;code&gt;outline&lt;/code&gt;）属性一样，&lt;code&gt;box-shadow&lt;/code&gt;属性可能会和周边元素发生重叠，因此要适当地设置元素的外边距。&lt;code&gt;box-shadow&lt;/code&gt;兼容性一般。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;6 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/border-image&quot;&gt;MDN border-image&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow&quot;&gt;MDN box-shadow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.impressivewebs.com/multiple-borders-css/&quot;&gt;Multiple Borders with CSS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://css-tricks.com/snippets/css/multiple-borders/&quot;&gt;CSS-tricks Multiple Borders&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;7 结语&lt;/h2&gt;
&lt;p&gt;本文简述了5种多重边框的实现方式，各有优缺点，大家要根据实际情况进行取舍。&lt;/p&gt;
&lt;p&gt;文中所述部分文字及代码汇编于网络。因时间不足，能力有限等原因，存在文字阐述不准及代码测试不足等诸多问题。&lt;/p&gt;
</description>
<pubDate>Fri, 04 May 2018 15:29:00 +0000</pubDate>
<dc:creator>毛三十</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ifat3/p/8993088.html</dc:identifier>
</item>
<item>
<title>用js来实现那些数据结构14（树02-AVL树） - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/8976362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/8976362.html</guid>
<description>&lt;p&gt;　　在使用二叉搜索树的时候会出现 一个问题，就是树的一条分支会有很多层，而其他的分支却只有几层，就像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180501165824710-1188482354.png&quot; alt=&quot;&quot; width=&quot;1011&quot; height=&quot;429&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果数据量够大，那么我们在某条边上进行增删改查的操作时，就会消耗大量的时间。我们花费精力去构造一个可以提高效率的结构，反而事与愿违。这不是我们想要的。所以，我们需要另外一种树来解决这样的问题，那就是自平衡二叉搜索树--Adelson-Velskii-Landi（AVL）。什么意思呢？就是说这种树的任何一个节点左右两侧子树的高度之差最多为1。也就是说这种树会在添加或删除节点时尽量试着成为一棵完全树。&lt;/p&gt;
&lt;p&gt;　　自平衡二叉搜索树和二叉搜索树的实现几乎是一模一样的，唯一的区别就在于每次在插入或者删除节点的时候，我们需要检测它的&lt;strong&gt;平衡因子&lt;/strong&gt;（因为只有再插入或者删除的时候才有可能会影响到树的平衡性）&lt;strong&gt;。&lt;/strong&gt;如果有需要，那么就将其逻辑应用于树的自平衡。&lt;/p&gt;
&lt;p&gt;　　首先我们需要知道这个平衡因子是如何计算的。平衡因子的计算是来自于每个节点的右子树高度（hr）和左子树高度（hl）的差值， 该值应为0，1，-1.如果不是这三个值，那么说明需要平衡该AVL树。这就是平衡因子的简单计算方式。什么意思呢？&lt;/p&gt;
&lt;p&gt; 　　我们以上图为例，根节点11的平衡因子6 - 3 = 3。左侧子节点7的平衡因子是2 - 2 = 0；右侧子节点18的平衡因子就是5 - 2 = 3；节点70的平衡因子是0，要记住所有的叶节点（外部节点）的平衡因子都是0。因为叶节点没有子节点。还有一点一定要注意。我们所计算的平衡因子，是&lt;strong&gt;该节点的左右子树的高度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我们学会了如何去计算平衡因子，那么我们下面进行一项及其重要的仪式......噢，sorry。是及其重要的知识——&lt;strong&gt;旋转。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在开始讲解旋转之前，我们先来点开胃菜。看看我们插入子节点后，导致该树不平衡的可能的情况有哪些。我会画几个图，以便大家看得仔细透彻。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504200406909-1770788260.png&quot; alt=&quot;&quot; width=&quot;251&quot; height=&quot;186&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　首先，我们以上面这张图（截取前面树结构的一部分）作为初始的树，这棵树绝对一定必然是平衡的。大家都没意见吧。那么RR,LL,RL,LR是什么意思呢？那么我们继续往下看。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;第一种情况：RR。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　我们在18的右侧子节点再加一个节点20，右侧是要加入比父节点大的值的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504200851899-874560197.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;358&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　　　在我们加入了一个节点20之后，我们发现这棵树还是平衡的！唉？不对啊，跟我想要的结果好像不太一样。我再加一个节点试试？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504202638277-308936184.png&quot; alt=&quot;&quot; width=&quot;671&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　　　嗯......现在绝壁不平衡了。那么我们来看看怎么回事。在加入节点21（19）后，11节点左侧子树的深度是1，而右侧子树的深度是1，2，3。是3没错。那么1-3等于-2。嗯，十以内加减法应该不会算错。我们确定在节点18后面加入了两个右侧（R）节点后，这棵树就不平衡了。而现在有一个重要的问题。就是是哪一棵子树导致这棵树不平衡的呢？是在我们加入节点21（19）之后，也就是上图我们用小圈圈诅咒它的那一部分。那么我们可以用一句话来描述，我们在&lt;strong&gt;该树右侧子节点的右侧子节点加入了一个右侧子节点(如果加入的是左侧子节点也是一样的)之后&lt;/strong&gt;，导致了该树的不平衡，所以我们这时候需要去操作也就是旋转&lt;strong&gt;右侧的子节点&lt;/strong&gt;也就是18节点，来使这颗自平衡树来自平衡。换句话说，如果我们加入了一个节点（或者删除了一个节点），导致了我们整颗树的不平衡，那么我们首先要找到&lt;strong&gt;最近的不平衡的树来进行调整。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　上面RR情况的我分别加入了19，和21两个字节点，要说明一下，这两个子节点是为了更为清晰的告诉大家在&lt;span&gt;root的右节点的右节点下，无论插入的是左节点还是右节点都属于RR的情况&lt;/span&gt;。下同。在具体旋转的时候会给大家详细介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　换句话说，我们判断在增删节点的时候是否会导致不平衡的情况，由插入节点的前两个父节点来确定！大家要注意噢！很重要！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;趁热打铁，上面解释了RR的情况，那么其实下面的LL，LR，RL等情况也是一样的。思路没有任何区别。但是这个时候我想打断大家一下。问大家两个问题。这两个问题的解决会为后面的学习带来极大的便利。&lt;/p&gt;
&lt;p&gt;　　　　1、在AVL树或者其他树中，是否可以出现重复的值，比如树中已经有了一个11，我还想再加入一个11，是否允许？是否可以？&lt;/p&gt;
&lt;p&gt;　　　　2、看上图（RR情况图），是否有可能出现除了这四种情况外的其他情况？或者说，节点的平衡因子是否可能出现大于2或者小于-2的情况？（这种情况我们要旋转树超过两次，也就超出了我们这四种情况之外。）&lt;/p&gt;
&lt;p&gt;　　　　OK。希望大家闭上眼睛，想一想你的梦中情人，哦不对。想一想你的答案。&lt;/p&gt;
&lt;p&gt;　　　　不卖关子了，但是我真的希望大家想一想，因为这很必要也很重要。&lt;/p&gt;
&lt;p&gt;　　　　好吧，我开始回答第一个问题。其实在前一篇实现的树中是不允许重复的值出现的，我们可以去看一下上一篇的代码，如果相等则会覆盖。那么可能有人会问，我想要这棵树存储重复的值（当然其实这种情况出现的话大多数都是你的设计有问题。。。没有唯一标识了啊......需求还怎么实现）。那么我记得在&lt;a href=&quot;http://www.cnblogs.com/zaking/p/8950607.html&quot; target=&quot;_blank&quot;&gt;hashMap篇&lt;/a&gt;中有一个解决冲突的办法，是不是可以通过链表来存储key值相同的映射呢？是否还可以使用其他的存储方式？答案比较开放。所以是否可以存放重复的值，看你的实际需求咯。&lt;/p&gt;
&lt;p&gt;　　　　第二个问题的答案，不可能出现，因为大家一定要记住一个前提，&lt;strong&gt;就是我们在插入了一个导致该树不平衡的节点前，该树一定是平衡的。&lt;/strong&gt;为什么这么说呢？因为我们的AVL树，是自平衡二叉搜索树，如果在插入之前就是不平衡的，那你告诉我你这是啥?赶紧回头看代码，有BUG了亲。&lt;/p&gt;
&lt;p&gt;　　　　这里希望大家已经解除了心中不少的疑惑，如果还有问题，大家可以继续留言探讨。&lt;/p&gt;
&lt;p&gt;　　　　那么我们下面继续，把其它几种情况的图示画完。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;第二种情况：LL。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504202910521-1120364309.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;484&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;第三种情况：LR。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504203110712-1017393203.png&quot; alt=&quot;&quot; width=&quot;654&quot; height=&quot;502&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;第四种情况：RL。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504203238973-188631473.png&quot; alt=&quot;&quot; width=&quot;711&quot; height=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　那么看完上面这几幅图想必大家都了解了在插入节点的时候影响到树的平衡的4种可能性。那么为了面对这4种可能性。我们给出了与之相对应的4种解决不平衡的方法(其实就两种)。那么这里我们就要进入本篇最重要的内容了，&lt;strong&gt;旋转&lt;/strong&gt;。在开始之前，希望大家记住一句话。那就是，&lt;strong&gt;什么情况导致的不平衡，那就用相反方向的旋转&lt;/strong&gt;。什么意思呢，比如是LL导致的不平衡，那么我们就向右旋转。如果是RR导致的不平衡我们就向左，如果是RL，我们就LL再RR。如果是LR，我们就先RR再LL。好了，下面我们来看看究竟是如何旋转的吧。&lt;/p&gt;
&lt;p&gt;　　　那么下面就有点意思了。希望大家可以仔细看。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、RR情况的&lt;strong&gt;左旋转&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;我们还得来看图说话，我尽量把图画的让人容易误解，哦不，容易理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504204934636-991364172.png&quot; alt=&quot;&quot; width=&quot;971&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　本人那个，画图工具用得还不是太熟练，拐歪的曲线没画出来，我拿嘴说吧......&lt;/p&gt;
&lt;p&gt;　　大家看上图，左旋是以18为轴心整个树的左部分向左旋转，这样就使18变成了根节点，11变成了18的左侧子节点。这样旋转一下，就相当于减少了一层右侧字树的一层深度，从而使整颗树变成了平衡树。那么可能还有下面的这种情况，但其实是一样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504205449853-253239433.png&quot; alt=&quot;&quot; width=&quot;669&quot; height=&quot;304&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么这种情况是要旋转的轴心节点（18），还有左侧子节点，在旋转之后，&lt;strong&gt;18的左侧子节点13就会变成11的右侧子节点。其实可以简单的认为是左旋过后被节点11给“&lt;/strong&gt;挤”过来的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;其实，18的左侧子节点在旋转过后会成为11的右侧子节点还有一个原因，就是，&lt;strong&gt;18左侧子节点的值一定是大于11小于18的（旋转之前的图）&lt;/strong&gt;。为什么自己想。那么在旋转过后，它也一定是大于11的，所以它可以成为11的右侧子节点。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、LL情况的&lt;strong&gt;右旋转&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　那么LL情况的右旋转就没什么好说的了，跟RR情况是一样的，我们直接上图吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504210239188-943252077.png&quot; alt=&quot;&quot; width=&quot;813&quot; height=&quot;437&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这绝壁没问题吧，原理都是一样的。只不过换了一个方向而已。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504210358940-1268146257.png&quot; alt=&quot;&quot; width=&quot;983&quot; height=&quot;405&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样没啥好说的了，对吧。下面我们看看其他地情况。双旋转......&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、LR情况的&lt;strong&gt;左旋（RR）&lt;/strong&gt;再&lt;strong&gt;右旋（LL）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们还是直接上图，然后再解释，解释完这个RL情况的又不用再啰嗦了。挺好......挺省事，嘿嘿。&lt;/p&gt;
&lt;p&gt;　　其实让人有点懵逼的是名字，我特意加了个括号，希望你别懵逼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504212506581-669244102.png&quot; alt=&quot;&quot; width=&quot;1298&quot; height=&quot;438&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　不知道大家看没看懂，总感觉这图不是很友好啊，还有8节点的小瑕疵就不要在意了，反正都是虚线......还有指向节点10的那条线是虚线.....不影响.....嘿嘿。&lt;/p&gt;
&lt;p&gt;　　解释一下，我们需要双旋转的情况下，第一次旋转的是红框部分，也就是说，&lt;strong&gt;如果我们需要双旋转，两次旋转的轴心点是不一样的，第一次旋转的轴心是&lt;span&gt;插入节点的父节点&lt;span&gt;，而第二次旋转的轴心是&lt;span&gt;插入节点的祖父节点&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;大家一定要注意。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　那么这里可能会有一个疑问，就是8节点在第一次旋转过后，为什么会成为7节点的右侧子节点。这里十分重要，直接关系到你是否理解了AVL树的旋转。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　我们先看第一次旋转，如果插入的是8节点而不是10节点，那么在第一次左旋的时候，节点7会成为节点9的左侧子节点，而这个时候8节点是无处可去的，因为7占了我的位置，这咋整，不能因为一次平衡就删除我这个节点啊，节点8肯定不干，不然你插入我干啥.....哎？感觉有点不对劲.....额咳咳....咱们继续吧....而节点8这个位置一定比9小比7大，所以我们在旋转过后，让它成为7节点的右子节点就可以了。希望我说明白了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　那么这个时候可能还存在7节点有左侧子节点的情况，上面没画，没关系啊，你是7节点的左侧子节点，左旋转过后你还在原来的位置，没人占你的位置，你就不用动了。嗯，就这样.....完毕！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;四、RL情况的&lt;strong&gt;右旋（LL）&lt;/strong&gt;&lt;strong&gt;再&lt;/strong&gt;&lt;/span&gt;左&lt;strong&gt;旋（RR）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;其实这里真没啥好说的了，我一点都不解释，大家自己看，看不懂你就从头看！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504215125824-1291387398.png&quot; alt=&quot;&quot; width=&quot;1209&quot; height=&quot;495&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　唉.......说了一大堆，终于可以到最后的代码了，&lt;span&gt;&lt;strong&gt;上代码！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是我们计算当前节点的高度的方法&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; heightNode = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有那就为-1&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(node === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果存在执行逻辑&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么说一下这里我的理解吧，Math.max比较左节点和右节点的大小，返回大的那个值，然后 + 1。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为什么要返回大的那个值呢？因为如果左节点存在，那么值为0（-1 + 1）；并且右节点是不存在的，那么右节点为-1。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;但是此时我们是有高度的，所以我们要选取有高度的那个节点，也就是值大的那一个。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;那为什么要+1呢？因为高度只能为0不能为-1。-1是我们通过相减计算得到的，而不是计算高度得到的。记住这里是计算高度。&lt;/span&gt;
            console.log(Math.max(heightNode(node.left),heightNode(node.right)) + 1&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.max(heightNode(node.left),heightNode(node.right)) + 1&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;RR:向左的单旋转&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; rotationRR = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tmp =&lt;span&gt; node.right;
        node.right &lt;/span&gt;=&lt;span&gt; tmp.left;
        tmp.left &lt;/span&gt;=&lt;span&gt; node;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmp;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LL:向右的单旋转&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; rotationLL = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tmp =&lt;span&gt; node.left;
        node.left &lt;/span&gt;=&lt;span&gt; tmp.right;
        tmp.right &lt;/span&gt;=&lt;span&gt; node;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmp;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LR:向右得到双旋转&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; rotationLR = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node) {
        node.left &lt;/span&gt;=&lt;span&gt; rotationRR(node.left);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotationLL(node);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;RL:向左的双旋转&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; rotationRL = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node) {
        node.right &lt;/span&gt;=&lt;span&gt; rorarionLL(node.right);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rorarionRR(node);
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; balanceInsertNode = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node,element) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果node的位置没有值，那么直接加入就好了。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(node === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            node &lt;/span&gt;=&lt;span&gt; newNode(element);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果假如的值是小于当前节点的话，说明我们要加在当前节点的左侧。&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(element &amp;lt;&lt;span&gt; node.key) {
            node.left &lt;/span&gt;=&lt;span&gt; insertNode(node.left,element);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么下面就要判断是否是null，如果是null，那么没问题，直接加上就好了。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(node.left !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不是，我们就要计算node的左侧高度减去右侧高度是否大于1，如果是，说明不平衡，需要来调用平衡方法来平衡。&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;((heightNode(node.left) - heightNode(node.right)) &amp;gt; 1&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前插入的节点的值小于node.left的值，说明是LL的情况，我们需要右旋。否则的话我们就需要先左旋，再右旋。&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(element &amp;lt;&lt;span&gt; node.left.key) {
                        node &lt;/span&gt;=&lt;span&gt; rorarionLL(node);
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        node &lt;/span&gt;=&lt;span&gt; rorarionLR(node);
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(element &amp;gt;&lt;span&gt; node.key) {
            node.right &lt;/span&gt;=&lt;span&gt; insertNode(node.right,element);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(node.right !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((heightNode(node.right) - heightNode(node.left)) &amp;gt; 1&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(element &amp;gt;&lt;span&gt; node.right.key) {
                        node &lt;/span&gt;=&lt;span&gt; rorarionRR(node);
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        node &lt;/span&gt;=&lt;span&gt; rorarionRL(node);
                    }&lt;br/&gt;}
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　代码中多了一个balanceInsertNode方法，这个方法是需要替换我们前面写好的insertNode方法的，这样写是为了让大家更好的对比下。这些代码不像以前那样，写了一大堆的注释用来解释。其实要说的很多，都在前面的图和语言描述中说过了。所以大家看这个代码的时候。有不明白的地方，对照着前面的逻辑一点一点看，肯定就看明白了。比如rotationLL和rotationRR内部的替换以及为什么要这样替换，都在前面说过了。所以就不再在代码中啰嗦了。&lt;/p&gt;
&lt;p&gt;　　这一篇文章有点长，也花了我一点心思才完成。很重要，如果你想要对树有一个不错的了解，这些必须要会。我尽可能的用我理解的思路给大家讲解，如果有什么不清楚的地方，大家可以留言讨论。&lt;/p&gt;
&lt;p&gt;　　哦对了，本来还要跟大家说说其他树的，但是想了想也没什么必要，给大家一个链接，大家可以自行去做一些简单的了解，比如红黑树，堆积树，还有B树等等等等。种类很多。要想都讲完大概几十篇都不够，希望这两篇树结构的文章可以抛砖引玉。让大家提起对数据结构的兴趣。&lt;/p&gt;
&lt;p&gt;　　大家可以看一下这个了解&lt;a href=&quot;https://zh.wikipedia.org/wiki/AVL%E6%A0%91&quot; target=&quot;_blank&quot;&gt;https://zh.wikipedia.org/wiki/AVL%E6%A0%91&lt;/a&gt;，滑动到页底，你就能看到其他的树结构了。&lt;/p&gt;
&lt;p&gt;　　好了，终于，自平衡二叉搜索树到这里基本就结束了。下一部分会讲解最后一种也是最复杂的一种非线性数据结构——图。&lt;/p&gt;

&lt;p&gt;　　最后，&lt;strong&gt;由于本人水平有限，能力与大神仍相差甚远，若有错误或不明之处，还望大家不吝赐教指正。非常感谢！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 04 May 2018 14:34:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/8976362.html</dc:identifier>
</item>
<item>
<title>继续死磕SDRAM控制器 - NingHeChuan</title>
<link>http://www.cnblogs.com/ninghechuan/p/8992683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ninghechuan/p/8992683.html</guid>
<description>&lt;h2&gt;SDRAM控制器&lt;/h2&gt;
&lt;p&gt;       博主上一篇介绍了一些SDRAM的基本原理&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/ninghechuan/p/8903938.html&quot;&gt;是否有必要学习使用纯Verilog写一个SDRAM控制器&lt;/a&gt;，接下来记录SDRAM控制器的工作原理。首先是上电初始化。&lt;/p&gt;
&lt;h2&gt;上电初始化&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214530880-1503814774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时序图中，tRP、tRC、这些时间参数可以从手册中找到，这里的系统时钟采用50Mhz。&lt;/p&gt;
&lt;p&gt;从初始化的时序图可以看出，首先在进行预充电（Precharge）命令之前要等待100us（手册要求是至少100us，我们设定延时200us），等待系统上电稳定和时钟稳定，然后对所有bank进行预充电（Precharge），经历一个trp（20ns，一个时钟周期，手册可以查询）时间，然后进行至少两次自刷新（Auto refresh）（我这里设置进行8次自刷新，），每次自刷新至少需要trc（63ns，四个时钟周期，手册查询）时间，最后进行模式寄存器（MODE register）的配置，需要tmrd（两个时钟周期）时间，初始化完成。&lt;/p&gt;
&lt;p&gt;预充电时当A10为高电平对所有的bank进行操作，当A10为低电平时对单个bank进行操作，BA0，BA1选择bank。我们这里预充电时对所有的bank操作，把A10置高即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214540592-795716570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214547992-1389575754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;SDRAM初始化流程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;上电后延时200us&lt;/li&gt;
&lt;li&gt;对所有的bank进行预充电（Precharge）&lt;/li&gt;
&lt;li&gt;8个自刷新操作，每次自刷新使用四个时钟周期&lt;/li&gt;
&lt;li&gt;进行模式寄存器的配置 ，配置完后输出初始化完成标志。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里先设置SDRAM的突发长度为4               Addr = 12’b0000_0110_0010&lt;/p&gt;
&lt;h4&gt;SDRAM初始化仿真&lt;/h4&gt;
&lt;p&gt;这里仿真需要用到SDRAM的仿真模型，通过仿真模型可以把当前SDRAM进行的操作打印出来，如果有错误也会提示错误，这时候再去查看波形时序。这里需要注意的是仿真的时候sdram_dqm信号必须和仿真模型连接，否则数据是写不进去的，设置sdram_dqm = 0就可以了。&lt;/p&gt;
&lt;p&gt;将SDRAM仿真模型添加进去后，要对放着模型的参数进行重定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214619802-2010736069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于各个参数的值，不同的SDRAM芯片的参数是不同的，具体根据手册而定，mem_sizes设置的是1个bank的容量。Verilog语法笔记：这种方式可以对例化模块里面已有的宏定义进行重定义，写法是defparam + 例化之后的模块名+ . +需要重定义名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214627482-1121142286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在transcript中输入run 200us，先跑200us等待系统上电稳定，在输入run 50us，如上图所示CAS Latency（列选通潜伏期）为3，burst length（突发长度）为4，burst type（突发类型）顺序（Sequrntial）执行，模式寄存器配置都按照我们设置的进行。&lt;/p&gt;
&lt;h2&gt;SDRAM工作原理&lt;/h2&gt;
&lt;p&gt;初始化模块设计完成后，对SDRAM已经有了一些简单的了解，下面先来看看SDRAM的工作原理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214647069-1576227981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;粗线——自动跳转，细线——受到命令后才能跳转（看不清楚图片点击阅读原文）&lt;/p&gt;
&lt;p&gt;从一个官方给的SDRAM手册的参考状态转移图看，我们可以简单写一下SDRAM的工作流程。这部分用状态机来实现最好不过了。&lt;/p&gt;
&lt;p&gt;上电后，给一个Precharge命令，进入Precharge状态，然后自动进入IDLE（初始化）状态，然后给自刷新命令，进入自刷新状态，自刷新完后回到IDLE状态，IDLE状态给一个配置模式寄存器命令，进入模式寄存器的配置，配置完后才能自动回到IDLE状态，然后进行读写状态的操作。&lt;/p&gt;
&lt;p&gt;以写操作为例，需要给一个行激发命令，进入行激发状态，给出写命令才能进入写状态，写完后自动返回行激发状态，给一次写命令，会写入一个突发长度的数据，在一行没有写完不需要跳回行激发状态，只需要继续给写命令，只有当一行写完或刷新请求来临或数据写完才会跳出写状态，这里后面设计写模块再讲。数据写完或刷新请求来临或数据写完，需要先进入预充电状态，给一次预充电命令，然后自动跳转到初始状态进行重新等待命令。至于读模块的操作和写模块是完全一样的，读者自行读图。&lt;/p&gt;
&lt;p&gt;这里要提的是图中有两个状态WRITEA和READA，这里我们不需要用到，如图也可以看到，这两个状态在进行一次读或写后会自动跳入预充电状态，从而回到初始化状态，这样和WRITE和READ这两个状态相比，读写速度肯定是会慢的，WRITE和READ可以连续给读写命令进行读写，所以直接忽略掉这两个状态不管。&lt;/p&gt;
&lt;h2&gt;仲裁机制&lt;/h2&gt;
&lt;p&gt;       这里要引出一个设计技巧，初始化完成后，进行自刷新和读写操作状态都是相互独立的，所以我们需要写一个状态机去完后这些状态之间的跳转，大概意思就如下图所示，写一个仲裁状态机，当SDRAM控制器要进行自刷新时，自刷新模块需要给一个刷新请求，仲裁状态收到后，就结束当前进行的状态，给一个刷新使能，刷新模块才会进行刷新操作。同样的，当SDRAM控制器要进行写数据时，写数据模块需要给一个写请求，仲裁状态收到后，就结束当前进行的状态，给一个写使能，写数据模块才会进行写操作。后面的模块相应的也是这样的设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214659870-1252278010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;刷新模块&lt;/h2&gt;
&lt;p&gt;手册规定SDRAM自刷新需在64ms内刷新4096次（不同型号的芯片对应的不同），必须64ms是因为SDRAM内部使用电容存储数据的，它保证不断电的时间就是64ms。4096次的意思是，我所使用的这款SDRAM芯片它的行地址为A0~A11，一共是12位，2的12次方一共是4096行，我们每给一次刷新命令实际上是刷新一行，且是四个bank同时刷新，所以说一共要刷新4096次。两次刷新间隔15us。刷新是在SDRAM初始化完成后就要开始进行刷新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214708328-1229574275.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;从时序图可以看出，先给一个precharge命令（一般都是对all bank进行操作），经过trp（20ns，一个周期）时间进行一次自刷新命令，再过trc时间，进行再一次自刷新命令，然后trc（63ns， 四个周期）时间后激发读或写命令。&lt;/p&gt;
&lt;p&gt;在时序图中我们看到了两次自刷新命令，但是实际上只要给一次自刷新命令即可，所以不要被时序图忽悠了，当然给两次也是没有什么关系的。这里的意思是，每次进行自刷新操作都需要给一次预充电即可。&lt;/p&gt;
&lt;h3&gt;刷新模块仿真&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214716057-991571163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仿真的时候发现我犯了一个错误，就是每15us的刷新操作是不用每次都给预充电（Percharge）命令，但是从另一个状态跳转到自刷新状态是需要给一个预充电（Percharge）命令。之后便不需要再给了，这上面这里的原因是因为在刷新模块里有预充电（Percharge）命令，所以每次状态跳转到执行刷新模块，都会给一个预充电（Percharge）命令。这个问题已经得到解决。如图每15us进行一个自刷新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214721858-304578974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       关于SDRAM的读模块和写模块操作，下一篇再写。博主最近基于上次50Mhz下的简易SDRAM控制器的基础上修改成100Mhz的SDRAM控制器，实现用上位机串口发送一副彩色图片到SDRAM存储，再用VGA显示，下一步的目标是实现摄像头实时采集视频流数据显示。目前把最近写的这两个项目工程放到了Github上分享出来，希望能一起讨论，多多指点，这个东西我个人感觉不懂内部的操作时序，想要移植也是很麻烦的，所以干脆直接分享出来，后面博主会继续优化，尽量做成一个像IP Core一样的直接修改参数就可以调用的一个SDRAM控制器。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NingHeChuan/Open-FPGA.git&quot;&gt;https://github.com/NingHeChuan/Open-FPGA.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504215344741-1000234809.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1057546/201706/1057546-20170611114905559-478053885.jpg&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;289&quot;/&gt;&lt;/p&gt;

&lt;p&gt;转载请注明出处：NingHeChuan（宁河川）&lt;/p&gt;
&lt;p&gt;个人微信订阅号：开源FPGA&lt;/p&gt;
&lt;p&gt;如果你想及时收到个人撰写的博文推送，可以扫描左边二维码（或者长按识别二维码）关注个人微信订阅号&lt;/p&gt;
&lt;p&gt;知乎ID：&lt;a href=&quot;https://www.zhihu.com/people/zhu-he-chuan/activities&quot; target=&quot;_blank&quot;&gt;NingHeChuan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微博ID：&lt;a href=&quot;http://weibo.com/6059461073/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot;&gt;NingHeChuan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 死磕SDRAM控制器（二）&quot; href=&quot;http://www.cnblogs.com/ninghechuan/p/8992683.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/ninghechuan/p/8992683.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 04 May 2018 14:31:00 +0000</pubDate>
<dc:creator>NingHeChuan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ninghechuan/p/8992683.html</dc:identifier>
</item>
<item>
<title>C 标准库基础 IO 操作总结 - 肖邦linux</title>
<link>http://www.cnblogs.com/liwei0526vip/p/8992792.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liwei0526vip/p/8992792.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;其实输入与输出对于不管什么系统的设计都是异常重要的，比如设计 C 接口函数，首先要设计好输入参数、输出参数和返回值，接下来才能开始设计具体的实现过程。C 语言标准库提供的接口功能很有限，不像 Python 库。不过想把它用好也不容易，本文总结 C 标准库基础 IO 的常见操作和一些特别需要注意的问题，如果你觉着自己还不是大神，那么请相信我，读完全文后你肯定会有不少收获。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一操作句柄&quot;&gt;一、操作句柄&lt;/h2&gt;
&lt;p&gt;打开文件其实就是在操作系统中分配一些资源用于保存该文件的状态信息及文件的标识，以后用户程序可以用这个标识做各种读写操作，关闭文件则释放占用的资源。&lt;/p&gt;
&lt;p&gt;打开文件的函数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
FILE *fopen(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *path, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *mode);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FILE 是 C 标准库定义的结构体类型，其包含文件在内核中的标识（文件描述符）、I／O 缓冲区和当前读写位置信息，调用者不需知道 FILE 的具体成员，由库函数内部维护，调用者不应该直接访问这些成员。像 FILE* 这样的文件指针称为句柄（Handle）。&lt;/p&gt;
&lt;p&gt;打开文件操作是对文件资源进行操作的，所以有可能打开文件失败，所以在打开函数时一定要判断返回值，如果失败则返回错误信息，以方便快速定位错误。&lt;/p&gt;
&lt;p&gt;打开文件应该与关闭文件成对存在，虽然程序在退出时会释放相应的资源，但是对于一个长时间运行服务程序来说，经常打开而不关闭文件是会造成进程资源耗尽的，因为进程的文件描述符个数是有限的，及时关闭文件是个好习惯。&lt;/p&gt;
&lt;p&gt;关闭文件的函数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fclose(FILE *fp);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fopen 函数参数 mode 总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&quot;r&quot;：只读，文件必须存在。&lt;/li&gt;
&lt;li&gt;&quot;w&quot;：只写，如果不存在则创建，存在则覆盖。&lt;/li&gt;
&lt;li&gt;&quot;a&quot;：追加，如果不存在则创建。&lt;/li&gt;
&lt;li&gt;&quot;r+&quot;：允许读和写，文件必须存在。&lt;/li&gt;
&lt;li&gt;&quot;w+&quot;：允许读和写，文件不存在则创建，存在则覆盖。&lt;/li&gt;
&lt;li&gt;&quot;a+&quot;：允许读和追加，文件不存在则创建。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二关于stdinstdoutstderr&quot;&gt;二、关于stdin/stdout/stderr&lt;/h2&gt;
&lt;p&gt;在用户程序启动时，main 函数还没开始执行之前，会自动打开三个 FILE* 指针分别是：stdin、stdout、stderr，这三个文件指针是 libc 中定义的全局变量，在 stdio.h 中声明，printf 向 stdout 写，而 scanf 从 stdin 读，用户程序也可以直接使用这三个文件指针。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;stdin 只用于读操作，称为标准输入&lt;/li&gt;
&lt;li&gt;stdout 只用于写操作，称为标准输出&lt;/li&gt;
&lt;li&gt;stderr 也用于写操作，称为标准错误输出&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常程序的运行结果打印到标准输出，而错误提示打印到标准错误输出，一般标准输出和标准错误都是屏幕。通常可以标准输出重定向到一个常规文件，而标准错误输出仍然对应终端设备，这样就可以将运行结果与错误信息分开。&lt;/p&gt;
&lt;h2 id=&quot;三以字节为单位的io函数&quot;&gt;三、以字节为单位的IO函数&lt;/h2&gt;
&lt;p&gt;fgetc 函数从指定的文件中读一个字节，getchar从标准输入读一个字节，调用 getchar() 相当于 fgetc(stdin)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fgetc(FILE *stream);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; getchar(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fputc 函数向指定的文件写入一个字节，putchar 向标准输出写一个字节，调用 putchar() 相当于调用 fputc(c, stdout)。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fputc(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c, FILE *stream);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; putchar(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数和返回值类型为什么使用 int 类型？可以看到这几个函数的参数和返回值类型都是 int，而非 unsigned char 型。因为错误或读到文件末尾时将返回 EOF，即 -1，如果返回值是 unsigned char（0xff），与实际读到字节 0xff 无法区分，如果使用 int 就可以避免这个问题。&lt;/p&gt;
&lt;h2 id=&quot;四操作读写位置函数&quot;&gt;四、操作读写位置函数&lt;/h2&gt;
&lt;p&gt;当我们在操作文件时，有一个叫「文件指针」的家伙来记录当前操作的文件位置，比如刚打开文件，调用了 1 次 fgetc 后，此时文件指针指向了第 1 个字节后边，注意是以字节为单位记录的。&lt;/p&gt;
&lt;p&gt;改变文件指针位置的函数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fseek(FILE *stream, &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; offset, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; whence);
whence：从何处开始移动，取值：SEEK_SET | SEEK_CUR | SEEK_END
offset：移动偏移量，取值：可取正 | 负
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; rewind(FILE *stream);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举几个简单例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;fseek(fp, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, SEEK_SET);     &lt;span class=&quot;co&quot;&gt;// 从文件头向后移动5个字节&lt;/span&gt;
fseek(fp, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, SEEK_CUR);     &lt;span class=&quot;co&quot;&gt;// 从当前位置向后移动6个字节&lt;/span&gt;
fseek(fp, -&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, SEEK_END);    &lt;span class=&quot;co&quot;&gt;// 从文件尾向前移动3个字节&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;offset 可正可负，负值表示向文件开头的方向移动，正值表示向文件尾方向移动，如果向前移动的字节数超过文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入会增加文件尺寸，文件空洞字节都是 0&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;$ echo &lt;span class=&quot;st&quot;&gt;&quot;5678&quot;&lt;/span&gt; &amp;gt; file.txt

fp = fopen(&lt;span class=&quot;st&quot;&gt;&quot;file.txt&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;r+&quot;&lt;/span&gt;);
fseek(fp, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, SEEK_SET);
fputc('K', fp)
fclose(fp)

&lt;span class=&quot;co&quot;&gt;// 通过结果可以看出字母K是从第10个位置开始写的&lt;/span&gt;
liwei:/tmp$ od -tx1 -tc -Ax file.txt 
&lt;span class=&quot;dv&quot;&gt;0000000&lt;/span&gt;    &lt;span class=&quot;dv&quot;&gt;35&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;37&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;38&lt;/span&gt;  0a  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  4b                    
           &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;  \n  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   K&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;rewind(fp) 等价于 fseek(fp, 0, SEEK_SET)&lt;/p&gt;
&lt;p&gt;ftell(fp) 函数比较简单，直接返回当前文件指针在文件中的位置&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 实现计算文件字节数的功能&lt;/span&gt;
fseek(fp, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, SEEK_END);
ftell(fp);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;五以字符串为单位的io函数&quot;&gt;五、以字符串为单位的IO函数&lt;/h2&gt;
&lt;p&gt;fgets 从指定的文件中读一行字符到调用者提供的缓冲区，读入内容不超过 size 。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *fgets(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *s, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; size, FILE *stream);
&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *gets(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *s);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先要说明 gets() 函数强烈不推荐使用，类似 strcpy 函数，用户不可以指定缓冲区大小，很容易造成缓冲区溢出错误。不过 strcpy 程序员还是可以避免，而 gets 的输入用户可以提供任意长的字符串，唯一避免方法就是不使用 gets，而使用 fgets(buf, size, stdin)&lt;/p&gt;
&lt;p&gt;fgets 函数从 stream 所指文件读取以 '\n' 结尾的一行，包括 '\n' 在内，存到缓冲区中，并在该行结尾添加一个 '\0' 组成完整的字符串。如果文件一行太长，fgets 从文件中读了 size-1 个字符还没有读到 '\n'，就把已经读到的 size-1 个字符和一个 '\0' 字符存入缓冲区，文件行剩余的内容可以在下次调用 fgets 时继续读。&lt;/p&gt;
&lt;p&gt;若一次 fgets 调用在读入若干字符后到达文件末尾，则将已读到的字符加上 '\0' 存入缓冲区并返回，如果再次调用则返回 NULL，可以据此判断是否读到文件末尾。&lt;/p&gt;
&lt;p&gt;fputs 向指定文件写入一个字符串，缓冲区保存的是以 '\0' 结尾的字符串，与 fgets 不同的是，fputs 不关心字符串中的 '\n' 字符。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fputs(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *s, FILE *stream);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; puts(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *s);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;六以记录为单位的io函数&quot;&gt;六、以记录为单位的IO函数&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;size_t fread(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *ptr, size_t size, size_t nmemb, FILE *stream);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fread 和 fwrite 用于读写记录，这里的记录是指一串固定长度的字节，比如一个 int、一个结构体货或一个定长数组。&lt;/p&gt;
&lt;p&gt;参数 size 指出一条记录的长度，nmemb 指出要读或写多少条记录，这些记录在 ptr 所指内存空间连续存放，共占 size * nmemb 个字节。&lt;/p&gt;
&lt;p&gt;fread 和 fwrite 返回的记录数有可能小于 nmemb 指定的记录数。例如当读写位置距文件末尾只有一条记录长度，调用 fread 指定 nmemb 为 2，则返回值为 1。如果写文件时出错，则 fwrite 的返回值小于 nmemb 指定的值。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; t{
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;   a;
    &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt; b;
};
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; t val = {&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;};
FILE *fp = fopen(&lt;span class=&quot;st&quot;&gt;&quot;file.txt&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;w&quot;&lt;/span&gt;);
fwrite(&amp;amp;val, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(val), &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, fp);
fclose(fp);

liwei:/tmp$ od -tx1 -tc -Ax file.txt 
&lt;span class=&quot;dv&quot;&gt;0000000&lt;/span&gt;    &lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;02&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;                                
         &lt;span class=&quot;dv&quot;&gt;001&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;002&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从结果可以看出，写入的是 8 个字节，有兴趣的同学可以就此分析下系统的「大小端」和结构体的「对齐补齐」问题。&lt;/p&gt;
&lt;h2 id=&quot;七格式化io函数&quot;&gt;七、格式化IO函数&lt;/h2&gt;
&lt;h3 id=&quot;printf-scanf&quot;&gt;(1). printf / scanf&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; printf(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; scanf(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个函数是我们学习 C 语言最早接触，可能也是接触比较多的了，没什么特别要说的。printf 就是格式化打印到标准输出。下面总结下 printf 常用的方式。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;printf(&lt;span class=&quot;st&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;);            &lt;span class=&quot;co&quot;&gt;// 打印整数 5&lt;/span&gt;
printf(&lt;span class=&quot;st&quot;&gt;&quot;-%10s-&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;hello&quot;&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;// 设置显示宽度并左对齐：-     hello-&lt;/span&gt;
printf(&lt;span class=&quot;st&quot;&gt;&quot;-%-10s-&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;hello&quot;&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;// 设置显示宽度并右对齐：-     hello-&lt;/span&gt;
printf(&lt;span class=&quot;st&quot;&gt;&quot;%#x&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;bn&quot;&gt;0xff&lt;/span&gt;);        &lt;span class=&quot;co&quot;&gt;// 0xff 不加#则显示ff&lt;/span&gt;
printf(&lt;span class=&quot;st&quot;&gt;&quot;%p&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, main);         &lt;span class=&quot;co&quot;&gt;// 打印 main 函数首地址&lt;/span&gt;
printf(&lt;span class=&quot;st&quot;&gt;&quot;%%&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);               &lt;span class=&quot;co&quot;&gt;// 打印一个 %&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;scanf 就是从标准输入中读取格式化数据，简单举个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; year, month, day;
scanf(&lt;span class=&quot;st&quot;&gt;&quot;%d/%d/%d&quot;&lt;/span&gt;, &amp;amp;year, &amp;amp;month, &amp;amp;day);
printf(&lt;span class=&quot;st&quot;&gt;&quot;year = %d, month = %d, day = %d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, year, month, day);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;sprintf-sscanf-snprintf&quot;&gt;(2). sprintf / sscanf / snprintf&lt;/h3&gt;
&lt;p&gt;sprintf 并不打印到文件，而是打印到用户提供的缓冲区中并在末尾加 '\0'，由于格式化后的字符串长度很难预计，所以很可能造成缓冲区溢出，强烈推荐 snprintf 更好一些，参数 size 指定了缓冲区长度，如果格式化后的字符串超过缓冲区长度，snprintf 就把字符串截断到 size - 1 字节，再加上一个 '\0'，保证字符串以 '\0' 结尾。如果发生截断，返回值是截断之前的长度，通过对比返回值与缓冲区实际长度对比就知道是否发生截断。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sscanf(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *str, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sprintf(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *str, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; snprintf(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *str, size_t size, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sscanf 是从输入字符串中按照指定的格式去读取相应的数据，函数功能非常的强大，支持类似正则表达式匹配的功能。具体的使用格式请自行查询官方手册，这里总结出最常用、最重要的几种使用场景和方式。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;最基本的用法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; buf[&lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt;] = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
sscanf(&lt;span class=&quot;st&quot;&gt;&quot;123456&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, buf);
printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：123456&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;取指定长度的字符串&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;123456&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%4s&quot;&lt;/span&gt;, buf);
printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：1234&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;取第1个字符串&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;hello world&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, buf);
printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：hello  因为默认是以空格来分割字符串的，%s读取第一个字符串hello&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;读取到指定字符为止的字符串&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;123456#abcdef&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%[^#]&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：123456&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// %[^#]表示读取到#符号停止，不包括#&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;读取仅包含指定字符集的字符串&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;123456abcdefBCDEF&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%[1-9a-z]&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：123456abcdef&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 表达式是要匹配数字和小写字母，匹配到大写字母就停止匹配了。&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;读取指定字符集为止的字符串&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;123456abcdefBCDEF&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%[^A-Z]&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：123456abcdef&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;读取两个符号之间的内容(@和.之间的内容)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;liwei0526vip@linuxblogs.cn&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%*[^@]@%[^.]&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：linuxblogs&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 先读取@符号前边内容并丢弃，然后读@，接着读取.符号之前的内容linuxblogs，不包含字符.&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;给一个字符串&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%*s%s&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：world&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 先忽略一个字符串&quot;hello,&quot;，遇到空格直接跳过，匹配%s，保存 world 到 buf&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// %*s 表示第 1 个匹配到的被过滤掉，即跳过&quot;hello,&quot;，如果没有空格，则结果为 NULL&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;稍微复杂点的&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;ABCabcAB=&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%*[A-Z]%*[a-z]%[^a-z=]&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：AB  自己尝试分析哈&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;包含特殊字符处理&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;201*1b_-cdZA&amp;amp;&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%[0-9|_|--|a-z|A-Z|&amp;amp;|*]&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：201*1b_-cdZA&amp;amp;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果能将上述几个例子搞明白，相信基本上已经掌握了 sscanf 的用法，实践才是检验真理的唯一标准，只有多使用，多思考才能真正理解它的用法。&lt;/p&gt;
&lt;h3 id=&quot;fprintf-fscanf&quot;&gt;(3). fprintf / fscanf&lt;/h3&gt;
&lt;p&gt;fprintf 打印到指定的文件 stream 中，fscanf 从文件中格式化读取数据，类似 scanf 函数。相关函数的声明如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fprintf(FILE *stream, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fscanf(FILE *stream, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还是通过简单实例来说明基本用法。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;FILE *fp = fopen(&lt;span class=&quot;st&quot;&gt;&quot;file.txt&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;w&quot;&lt;/span&gt;);
fprintf(fp, &lt;span class=&quot;st&quot;&gt;&quot;%d-%s-%f&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;hello&quot;&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.12&lt;/span&gt;);
fclose(fp);

liwei:/tmp$ cat file.txt 
&lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;-hello&lt;span class=&quot;fl&quot;&gt;-0.120000&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而 fscanf 函数的使用基本上与 sscanf 函数使用方式相同。&lt;/p&gt;
&lt;h2 id=&quot;八io缓冲区&quot;&gt;八、IO缓冲区&lt;/h2&gt;
&lt;p&gt;还有个关于 IO 非常重要的概念，就是 IO 缓冲区。&lt;/p&gt;
&lt;p&gt;C 标准库为每个打开的文件分配一个 I/O 缓冲区，用户调用读写函数大多数都在 I/O 缓冲区中读写，只有少数请求传递给内核。&lt;/p&gt;
&lt;p&gt;以 fgetc／fputc 为例，当第一次调用 fgetc 读一个字节时，fgetc 函数可能通过系统调用进入内核读 1k 字节到缓冲区，然后返回缓冲区中第一个字节给用户，以后用户再调用 fgetc，就直接从缓冲区读取。&lt;/p&gt;
&lt;p&gt;另一方面，fputc 通常只是写到缓冲区中，如果缓冲区满了，fputc 就通过系统调用把缓冲区数据传递给内核，内核将数据写回磁盘。如果希望把缓冲区数据立即写入磁盘，可以调用 fflush 函数。&lt;/p&gt;
&lt;p&gt;C 标准库 IO 缓冲区有三种类型：全缓冲、行缓冲和无缓冲区，不同类型的缓冲区具有不同的特性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;全缓冲&lt;/code&gt;：如果缓冲区写满了就写回内核。常规文件通常是全缓冲的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;行缓冲&lt;/code&gt;：如果程序写的数据中有换行符就把这一行写回内核，或者缓冲区满就写回内核。标准输入和标准输出对应终端设备时通常是行缓冲的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;无缓冲&lt;/code&gt;：用户程序每次调用库函数做写操作都要通过系统调用写回内核。标准错误输出通常是无缓冲的，用户程序的错误信息可以尽快输出到设备。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;printf(&lt;span class=&quot;st&quot;&gt;&quot;hello world&quot;&lt;/span&gt;);
&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
&lt;span class=&quot;co&quot;&gt;// 运行程序会发现屏幕并没有打印hello world&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 因为缓冲区没满，且没有\n符号&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了写满缓冲区、写入换行符之外，行缓冲还有一种情况会自动做 flush 操作，如果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户程序调用库函数从无缓冲的文件中读取&lt;/li&gt;
&lt;li&gt;或从行缓冲的文件中读取，且这次读操作会引发系统调用从内核读取数据，那么会读之前自动 flush 所有行缓冲&lt;/li&gt;
&lt;li&gt;程序退出时通常也会自动 flush 缓冲区&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果不想完全依赖自动的 flush 操作，可以调用 fflush 函数手动操作。若调用 fflush(NULL) 可以对所有打开文件的 IO 缓冲区做 flush 操作。缓冲区大小也可以自定义设置，一般情况无需设置，默认即可。&lt;/p&gt;
&lt;h3 id=&quot;欢迎关注公众号-linuxblogs&quot;&gt;欢迎关注公众号: 「linuxblogs」&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yVibDjicRT1VsV0RH8KV6zMUhvJIajBDGibNAM19nKibia5Ae59EOnic3MJNrhJYdXOPqpVLXAvnr4ICAaZTBhW1JUxA/0?wx_fmt=jpeg&quot; alt=&quot;微信二维码&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 04 May 2018 14:15:00 +0000</pubDate>
<dc:creator>肖邦linux</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liwei0526vip/p/8992792.html</dc:identifier>
</item>
<item>
<title>python--Numpy and Pandas 基本语法 - 渔单渠</title>
<link>http://www.cnblogs.com/yudanqu/p/python_numpy_pandas.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yudanqu/p/python_numpy_pandas.html</guid>
<description>&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;numpy和pandas是python进行数据分析的非常简洁方便的工具，话不多说，下面先简单介绍一些关于他们入门的一些知识。下面我尽量通过一些简单的代码来解释一下他们该怎么使用。以下内容并不是系统的知识体系，我只是尽可能把最基础的知识点列写一下。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、numpy&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1、array&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
&lt;/span&gt;2 list_1 = [1,2,3,4&lt;span&gt;]
&lt;/span&gt;3 array_1 = numpy.array(list_1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一维数组&lt;/span&gt;
4 list_2 = [4,5,6,7&lt;span&gt;]
&lt;/span&gt;5 array_2 = numpy.array([list_1,list_2]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 二维数组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; array_2.shape &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看数组特征，eg：2行4列&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; array_2.size &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看元素个数, eg:8&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; array_2.dtype &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看数组类型，eg：int64&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注：numpy.arange(n) #与python中的range区别是前面有个a&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; numpy.zeros(s) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 全0矩阵，s可以为一个数也可以为一个列表，eg：[2,3]表示2*3的二维数组&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; numpy.eye(a) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 单位矩阵，生成的是浮点数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;访问数组中元素：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　一维：array_1[2] 、array_1[1:4]&lt;br/&gt;　　二维：array_2[1][2] 、array_2[1,2] 、array_2[:1,1:4]&lt;/p&gt;
&lt;p&gt;　　其中可以根据python中列表的切片来访问数据&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、数组与矩阵运算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;~~数组array&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; numpy.random.randn(10) &lt;span&gt;# &lt;/span&gt;&lt;span&gt;十个元素的一维数组&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; numpy.random.randint(10,size=20).reshape(4,5) &lt;span&gt;# &lt;/span&gt;&lt;span&gt;产生20个10以内的随机整数，后面的reshape是将这些数重新写成一个4*5的二维数组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;数组之间维度相同可以直接进行加减乘除（除数不能为0）&lt;/li&gt;
&lt;li&gt;numpy.unique(array_1) # 找到里面所有的数但不重复&lt;/li&gt;
&lt;li&gt;sum:二维数组中对每一列求和 sum(array_2)
&lt;ul&gt;&lt;li&gt;sum(array_2[0) 对第一行求和&lt;/li&gt;
&lt;li&gt;sum(array_2[:,0] 对第一列求和&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;array_2.max() #求最大值，对某行某列求则同sum&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;~~矩阵matric&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; numpy.mat([1,2,3],[4,5,6]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成一个二维矩阵&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; numpy.mat(array_1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将数组转换成矩阵&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注：矩阵之间维度相同可以直接进行加减运算，而乘除运算需要行和列交叉对应，参照线性代数中的知识。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3、input和output:&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x.pkl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;序列化到硬盘&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;pickle&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pickle
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; pickle.dump(x,f) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 产生pkl文件&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; pickle.load(f) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取pkl文件&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;numpy本身的工具&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; numpy.save(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one_array&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,x)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; numpy.load(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one_array.npy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; numpy.savez(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;two_array.npz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,a=x,b=y) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对多个进行操作，进行压缩储存&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; c = numpy.load(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;two_array.npz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取文件&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; c[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第一个文件&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; c[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第二个文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;1、Series&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;下面是创建Series的三种方法&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;方法1：s1 = pd.Series([1,2,3,4]) &lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;方法2：s2 = pd.Series(np.arange(10)) # 通过numpy.arange创建&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;方法3：s3 = pd.Series({'1':1,'2':2,'3':3}) # 通过字典创建&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; s1.values &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看值&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; s1.index &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看索引&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; s4 = pa.Series([1,2,3,4],index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置索引&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; s4.to_dict() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转化成字典&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; pd.isnull(s4) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断其中元素是否为NaN，pd.notnull()同理&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2、DataFrame&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; pandas &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Series,DataFrame
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过粘贴板导入dataframe&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; df = pd.read_clipboard() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在此之前需要你copy一个表&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; df.columns  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出列名&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; df.&lt;span&gt;'&lt;/span&gt;&lt;span&gt;列名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出列的数值(是一个Series)&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; df_new = DataFrame(df,columns=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;列名1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;列名2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; s1 = pd.Series(df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;列名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出这一列，dataframe的每一列是一个series&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; s1.index\values 即对series操作，或者通过s1[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;索引值&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;df1.iterrows() #返回一个生成器，可以用for循环来访问
&lt;ul&gt;&lt;li&gt;eg: for row in df1.iterrows():&lt;/li&gt;
&lt;li&gt;print(row) #返回的数据为一个tuple&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;s1,s2,s3为3个Series，用其组成一个人dataframe：
&lt;ul&gt;&lt;li&gt;df_new = pd.DataFrame([s1,s2,s3],index=['A','B','C'])&lt;/li&gt;
&lt;li&gt;　　# index是每个Series的名称&lt;/li&gt;
&lt;li&gt;　　# 初始是按横向拼接成的dataframe&lt;/li&gt;
&lt;li&gt;　　df1 = df1.T #转置，转置之后就和直接用dataframe生成的一样了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1、从粘贴板读取&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; df1 =&lt;span&gt; pd.read_clipboard()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; df1.to_clipboard() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入粘贴板&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2、CSV文件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; df1.to_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;名字.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,index=False) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; false则表示不添加索引号&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; df2 = pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df1.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取CSV文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3、json&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; df1.to_json() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转化成json文件&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; pd.read_json(df1.to_json()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取json文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4、html&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; df1.to_html(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df1_html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转换成HTML文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5、excel&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; df1.to_excel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df1.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成Excel文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; df.head() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回前五行&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; df.tail() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回后五行&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回更多的内容则在括号中写出来，不写则默认为五行&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; df.iloc[:,:] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;索引切片，定位，基于index，与索引名无关&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; df.loc[:,:] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据索引名来，label来过滤&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Reindex:&lt;/h2&gt;
&lt;h3&gt;~~series&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; s1.reindex(index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],fill_value=10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; fill_value 是指当重新写的index中有原来没有的，那么他本身输出为NaN，fill值为添加到这个索引下的值&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个新Series，另一种赋值的方法&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; s2 = Series([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],index=[1,5,10&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; s2.reindex(index=range(15)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成15个索引的Series，除了原有的其他的都是NaN&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; s2.reindex(index=range(15)，method=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ffill&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在上一步的基础上，按顺序将上一个value填充到他下面的几个中（forward fill）&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; s1.drop(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表示删除A的内容&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;~~dataframe&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个5*5的，通过numpy进行reshape&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; df1 = DataFrame(np.random.rand(25).reshape([5,5]),index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],colums=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遗漏的index中的C，通过reindex来恢复&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; df1.reindex(index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; C被恢复并把value填充为NaN&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; columns 同理&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当index减少时就表现出切割的现象&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; df1.drop(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,axis=0) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; axis=0，代表删除行；axis=1，代表删除列（后面遇到axis同样是这个意思）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;n = np.nan
&lt;ul&gt;&lt;li&gt;type(n) 是个浮点数float&lt;/li&gt;
&lt;li&gt;与nan的运算结果均是nan&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;nan in series：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;s1.isnull\notnull() 判断是否为nan&lt;/li&gt;
&lt;li&gt;s1.dropna() # 删除掉value为NaN的行&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;nan in dataframe：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;判断同series&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; df.dropna(axis=0,how=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;any&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;，thresh=None) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; axis表示行和列0,1来表示,how为any时表示有Nan就删掉，为all时表示全为nan时才删掉；thresh表示一个界限，超过这个数字的nan则被删掉&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; df.fillna(value=1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表示所有为nan的地方填充为1&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; df.fillna(value={0:0,1:1,2:2,3:3}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表示第一列的填充1，第二列的填充2，后面同理&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注：dropna,fillna不改变原始数组&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;index=[['1','1','1','2','2','2'],['a','b','c','a','b','c']] # 1,2为一级标题，abc为二级标题，即1的series下有abc，原始series下有1,2；获取内容时，可以s1['1']['a']&lt;/li&gt;
&lt;li&gt;s1[:,'a'] 返回所有一级series里的a&lt;/li&gt;
&lt;li&gt;与dataframe的转换：
&lt;ul&gt;&lt;li&gt;df1 = s1.unstack()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;逆转换：
&lt;ul&gt;&lt;li&gt;s2 = df1.unstack() # 这时一二级换了位置&lt;/li&gt;
&lt;li&gt;s2 = df1.T.unstack() # 这时是和原始完全一样的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;注：dataframe的index和columns都可以转换成多级的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;当想在一个dataframe中加一列(columns)，可以直接加df['列名']=Series([数据])&lt;br/&gt;也可以通过map：创建一个字典，字典中的键是dataframe中的columns：&lt;br/&gt;df1['新列名'] = df1['字典中的键那一列'].map(那个字典) 这个可以固定对应位置，方便改值，可以指定index来改值&lt;/p&gt;
&lt;h3&gt;replace in series:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; s1.replace({1,np.nan}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过字典来改值&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; s1.replace([1,2,3],[10,20,30]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把123索引改成10,20,30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;em&gt;以上内容是我的一点点总结，希望能给有需要的朋友带来带你帮助，也希望有大神来指点指点。&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 04 May 2018 13:07:00 +0000</pubDate>
<dc:creator>渔单渠</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yudanqu/p/python_numpy_pandas.html</dc:identifier>
</item>
<item>
<title>Python 3 中的json模块使用 - 不写日记</title>
<link>http://www.cnblogs.com/mithrilon/p/8954690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mithrilon/p/8954690.html</guid>
<description>&lt;p&gt;JSON (JavaScript Object Notation)是一种使用广泛的轻量数据格式. Python标准库中的&lt;code&gt;json&lt;/code&gt;模块提供了JSON数据的处理功能.&lt;/p&gt;
&lt;p&gt;Python中一种非常常用的基本数据结构就是字典(Dictionary). 它的典型结构如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;d = {
    'a': 123,
    'b': {
        'x': ['A', 'B', 'C']
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而JSON的结构如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;a&quot;: 123,
    &quot;b&quot;: {
        &quot;x&quot;: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到, Dictionary和JSON非常接近, 而Python中的&lt;code&gt;json&lt;/code&gt;库提供的主要功能, 也是两者之间的转换.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;json.loads&lt;/code&gt;方法可以将包含了一个JSON数据的&lt;code&gt;str&lt;/code&gt;, &lt;code&gt;bytes&lt;/code&gt;或者&lt;code&gt;bytearray&lt;/code&gt;对象, 转化为一个Python Dictionary. 它的完型接口签名如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;json.loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最简单的例子&quot;&gt;2.1 最简单的例子&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;json.loads&lt;/code&gt;最基本的使用方式就是将一个包含JSON数据的&lt;code&gt;str&lt;/code&gt;传递给这个方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.loads('{&quot;a&quot;: 123}')
{'a': 123}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Python中, &lt;code&gt;str&lt;/code&gt;值可以放在一对单引号中, 也可以放在一对双引号中:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 'ABC' == &quot;ABC&quot;
True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以, 在定义Dictionary的&lt;code&gt;str&lt;/code&gt;类型的键和值的时候, 使用单引号或者双引号都是合法和等价的:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; {&quot;a&quot;: 'ABC'} == {'a': &quot;ABC&quot;}
True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是, 在JSON中, 字符串数据只能放在双引号中, 因而&lt;code&gt;json.loads&lt;/code&gt;方法处理的字符串的JSON内容中, 字符串必须使用双引号. 否则就会发生解码错误:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.loads(&quot;{'a': 123}&quot;)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/json/__init__.py&quot;, line 354, in loads
    return _default_decoder.decode(s)
  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/json/decoder.py&quot;, line 339, in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/json/decoder.py&quot;, line 355, in raw_decode
    obj, end = self.scan_once(s, idx)
json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果被处理的Python字符串是包含在双引号中的, 那么JSON中的双引号就需要转义:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.loads(&quot;{\&quot;a\&quot;: 123}&quot;)
{'a': 123}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bytes和bytearray数据&quot;&gt;2.2 &lt;code&gt;bytes&lt;/code&gt;和&lt;code&gt;bytearray&lt;/code&gt;数据&lt;/h2&gt;
&lt;p&gt;对于内容是JSON数据的&lt;code&gt;bytes&lt;/code&gt;和&lt;code&gt;bytearray&lt;/code&gt;, &lt;code&gt;json.loads&lt;/code&gt;方法也可以处理:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.loads('{&quot;a&quot;: 123}'.encode('UTF-8'))
{'a': 123}
&amp;gt;&amp;gt;&amp;gt; json.loads(bytearray('{&quot;a&quot;: 123}', 'UTF-8'))
{'a': 123}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编码格式&quot;&gt;2.3 编码格式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;json.loads&lt;/code&gt;的第二个参数是&lt;code&gt;encoding&lt;/code&gt;没有实际作用.&lt;/p&gt;
&lt;p&gt;由于Python 3中&lt;code&gt;str&lt;/code&gt;类型总是使用UTF-8编码, 所以&lt;code&gt;s&lt;/code&gt;参数为&lt;code&gt;str&lt;/code&gt;类型时, &lt;code&gt;json.loads&lt;/code&gt;方法自动使用UTF-8编码. 并且, &lt;code&gt;str&lt;/code&gt;不能以BOM字节开头.&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;s&lt;/code&gt;参数为&lt;code&gt;bytes&lt;/code&gt;或者&lt;code&gt;bytearray&lt;/code&gt;时, &lt;code&gt;json.loads&lt;/code&gt;方法会自动判断为UTF-8, UTF-16还是UTF-32编码. 默认也是将其按照UTF-8编码转化为&lt;code&gt;str&lt;/code&gt;对象进行后续处理.&lt;/p&gt;
&lt;h2 id=&quot;数据类型转换&quot;&gt;2.4 数据类型转换&lt;/h2&gt;
&lt;p&gt;JSON可以表示四种主类型数据&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;字符串 string&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字 number&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;布尔类 boolean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空值 null&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以及两结数据结构&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;对象 object&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组 array&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;默认实现中, JSON和Python之间的数据转换对应关系如下表:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;dict&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;array&lt;/td&gt;
&lt;td&gt;list&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;str&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;number (int)&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;number (real)&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;实际转换情况如下例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.loads(&quot;&quot;&quot;
... {
...     &quot;obj&quot;: {
...             &quot;str&quot;: &quot;ABC&quot;,
...             &quot;int&quot;: 123,
...             &quot;float&quot;: -321.89,
...             &quot;bool_true&quot;: true,
...             &quot;bool_false&quot;: false,
...             &quot;null&quot;: null,
...             &quot;array&quot;: [1, 2, 3]
...     }
... }&quot;&quot;&quot;)
{'obj': {'str': 'ABC', 'int': 123, 'float': -321.89, 'bool_true': True, 'bool_false': False, 'null': None, 'array': [1, 2, 3]}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于JSON中数字number类型的数据, 有以下几点需要注意:&lt;/p&gt;
&lt;ol readability=&quot;10&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;JSON中的实数real number类型的精度不能超过Python中的float类型的精度范围, 否则就有精度损失. 如下例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.loads('3.141592653589793238462643383279')
3.141592653589793&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;JSON标准不包括非数字NaN, 正无穷Infinity和负无穷-Infinity, 但是&lt;code&gt;json.loads&lt;/code&gt;方法默认会将JSON字符串中的&lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;转化为Python中的&lt;code&gt;float('nan')&lt;/code&gt;, &lt;code&gt;float('inf')&lt;/code&gt;和&lt;code&gt;float('-inf')&lt;/code&gt;. &lt;strong&gt;注意&lt;/strong&gt;, 这里JSON中的&lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;必须大小写正确并且拼写完整. 如下例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.loads('{&quot;inf&quot;: Infinity, &quot;nan&quot;: NaN, &quot;ninf&quot;: -Infinity}')
{'inf': inf, 'nan': nan, 'ninf': -inf}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;自定义json对象转换类型&quot;&gt;2.5 自定义JSON对象转换类型&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;json.loads&lt;/code&gt;默认将JSON中的对象数据转化为Dictionary类型, &lt;code&gt;object_hook&lt;/code&gt;参数可以用来改变构造出的对象.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;object_hook&lt;/code&gt;接受一个函数, 这个函数的输入参数为JSON中对象数据转化出的Dictionary对象, 其返回值则为自定义的对象. 如下例所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class MyJSONObj:
...     def __init__(self, x):
...             self.x = x
...
&amp;gt;&amp;gt;&amp;gt; def my_json_obj_hook(data):
...     print('obj_hook data: %s' % data)
...     return MyJSONObj(data['x'])
...
&amp;gt;&amp;gt;&amp;gt; result = json.loads('{&quot;x&quot;: 123}', object_hook=my_json_obj_hook)
obj_hook data: {'x': 123}
&amp;gt;&amp;gt;&amp;gt; type(result)
&amp;lt;class '__main__.MyJSONObj'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; result.x
123&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当JSON中的对象有嵌套时, &lt;code&gt;json.loads&lt;/code&gt;方法会按照深度优先的方式遍历对象树, 将各层的对象数据传递给&lt;code&gt;object_hook&lt;/code&gt;. 叶节点的JSON对象构造出的Python对象, 会作为父节点的一个值, 传递给父节点的&lt;code&gt;object_hook&lt;/code&gt;方法. 如下例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class MyJSONObj:
...     def __init__(self, x, y):
...             self.x = x
...             self.y = y
...
&amp;gt;&amp;gt;&amp;gt; def my_json_obj_hook(data):
...     print('obj_hook data: %s' % data)
...     return MyJSONObj(**data)
...
&amp;gt;&amp;gt;&amp;gt; result = json.loads('{&quot;x&quot;: {&quot;x&quot;: 11, &quot;y&quot;: 12}, &quot;y&quot;: {&quot;x&quot;: 21, &quot;y&quot;:22}}', object_hook=my_json_obj_hook)
obj_hook data: {'x': 11, 'y': 12}
obj_hook data: {'x': 21, 'y': 22}
obj_hook data: {'x': &amp;lt;__main__.MyJSONObj object at 0x10417ef28&amp;gt;, 'y': &amp;lt;__main__.MyJSONObj object at 0x10417ed68&amp;gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了&lt;code&gt;object_hook&lt;/code&gt;参数以外, 还有一个&lt;code&gt;object_pairs_hook&lt;/code&gt;参数. 这个参数同样可以用来改变&lt;code&gt;json.loads&lt;/code&gt;方法构造出的Python对象的类型. 这个参数和&lt;code&gt;object_hook&lt;/code&gt;的不同, 在于传入的方法所接收到的输入数据不是一个Dictionary, 而是一个包含&lt;code&gt;tuple&lt;/code&gt;的&lt;code&gt;list&lt;/code&gt;. 每个&lt;code&gt;tuple&lt;/code&gt;都有两个元素, 第一个元素是JSON数据中的键, 第二个元素是这个键对应的值. 如JSON对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;a&quot;: 123,
    &quot;b&quot;: &quot;ABC&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的输入数据是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[
    ('a': 123),
    ('b', 'ABC')
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当调用&lt;code&gt;json.loads&lt;/code&gt;方法时, 同时指定&lt;code&gt;object_hook&lt;/code&gt;和&lt;code&gt;object_pairs_hook&lt;/code&gt;, &lt;code&gt;object_pairs_hook&lt;/code&gt;会覆盖&lt;code&gt;object_hook&lt;/code&gt;参数.&lt;/p&gt;
&lt;h2 id=&quot;自定义json数字转换类型&quot;&gt;2.6 自定义JSON数字转换类型&lt;/h2&gt;
&lt;p&gt;默认实现中, JSON中的实数被转换为Python的&lt;code&gt;float&lt;/code&gt;类型, 整数被转换为&lt;code&gt;int&lt;/code&gt;或者&lt;code&gt;long&lt;/code&gt;类型. 类似&lt;code&gt;object_hook&lt;/code&gt;, 我们可以通过&lt;code&gt;parse_float&lt;/code&gt;和&lt;code&gt;parse_int&lt;/code&gt;参数指定自定义的转换逻辑. 这两个方法的输入参数为表示JSON实数或者整数的字符串. 下例中, 我们将实数转换为&lt;code&gt;numpy.float64&lt;/code&gt;, 将整数转换为&lt;code&gt;numpy.int64&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def my_parse_float(f):
...     print('%s(%s)' % (type(f), f))
...     return numpy.float64(f)
...
&amp;gt;&amp;gt;&amp;gt; def my_parse_int(i):
...     print('%s(%s)' % (type(i), i))
...     return numpy.int64(i)
...
&amp;gt;&amp;gt;&amp;gt; result = json.loads('{&quot;i&quot;: 123, &quot;f&quot;: 321.45}', parse_float=my_parse_float, parse_int=my_parse_int)
&amp;lt;type 'str'&amp;gt;(123)
&amp;lt;type 'str'&amp;gt;(321.45)
&amp;gt;&amp;gt;&amp;gt; type(result['i'])
&amp;lt;type 'numpy.int64'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; type(result['f'])
&amp;lt;type 'numpy.float64'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义nan-infinity和-infinity转换类型&quot;&gt;2.6.1 自定义&lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;和&lt;code&gt;-Infinity&lt;/code&gt;转换类型&lt;/h3&gt;
&lt;p&gt;由于标准JSON数据不支持&lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;和&lt;code&gt;-Infinity&lt;/code&gt;, 所以&lt;code&gt;parse_float&lt;/code&gt;并不会接收到这几个值. 当需要自定义这几个值转换的对象的时候, 就需要使用另外一个接口&lt;code&gt;parse_constant&lt;/code&gt;. 比如下例中, 将这几个值同样转换为&lt;code&gt;numpy.float64&lt;/code&gt;类型:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def my_parse_constant(data):
...     print('%s(%s)' % (type(data), data))
...     return numpy.float64(data)
...
&amp;gt;&amp;gt;&amp;gt; result = json.loads('{&quot;inf&quot;: Infinity, &quot;nan&quot;: NaN, &quot;ninf&quot;: -Infinity}', parse_constant=my_parse_constant)
&amp;lt;type 'str'&amp;gt;(Infinity)
&amp;lt;type 'str'&amp;gt;(NaN)
&amp;lt;type 'str'&amp;gt;(-Infinity)
&amp;gt;&amp;gt;&amp;gt; result['inf']
inf
&amp;gt;&amp;gt;&amp;gt; type(result['inf'])
&amp;lt;type 'numpy.float64'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;非对象顶级值&quot;&gt;2.7 非对象顶级值&lt;/h2&gt;
&lt;p&gt;根据JSON规范, 一个JSON数据中, 可以只包含一个值, 而不是一个完整的对象. 这个值可以是一个字符串, 一个数字, 布尔值, 空值, 或者一个数组. 除了这三种JSON规范中给出的类型, 还可以是&lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;或者&lt;code&gt;-Infinity&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.loads('&quot;hello&quot;')
'hello'
&amp;gt;&amp;gt;&amp;gt; json.loads('123')
123
&amp;gt;&amp;gt;&amp;gt; json.loads('123.34')
123.34
&amp;gt;&amp;gt;&amp;gt; json.loads('true')
True
&amp;gt;&amp;gt;&amp;gt; json.loads('false')
False
&amp;gt;&amp;gt;&amp;gt; print(json.loads('null'))
None
&amp;gt;&amp;gt;&amp;gt; json.loads('[1, 2, 3]')
[1, 2, 3]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;重复键名&quot;&gt;2.8 重复键名&lt;/h2&gt;
&lt;p&gt;在同一层级JSON对象中, 不应当出现重复的键名, 不过JSON规范中没有给出这种情况的处理标准. 在&lt;code&gt;json.loads&lt;/code&gt;中, 当JSON数据中有重复键名, 则后面的键值会覆盖前面的:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.loads('{&quot;a&quot;: 123, &quot;b&quot;: &quot;ABC&quot;, &quot;a&quot;: 321}')
{'a': 321, 'b': 'ABC'}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;处理json数据文件&quot;&gt;2.9 处理JSON数据文件&lt;/h2&gt;
&lt;p&gt;当JSON数据是保存在一个文件中的时候, &lt;code&gt;json.load&lt;/code&gt;方法可以用来从这个文件中读取数据, 并转换为Python对象. &lt;code&gt;json.load&lt;/code&gt;方法的第一个参数就是指向JSON数据文件的文件类型对象.&lt;/p&gt;
&lt;p&gt;比如&lt;code&gt;/tmp/data.json&lt;/code&gt;文件的内含如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;a&quot;: 123,
    &quot;b&quot;: &quot;ABC&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用下例中的代码来读取并转化文件中的JSON数据:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; with open('/tmp/data.json') as jf:
...     json.load(jf)
...
{u'a': 123, u'b': u'ABC'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了文件类型的对象, 只要是实现了&lt;code&gt;read&lt;/code&gt;方法的类文件对象, 都可以作为&lt;code&gt;fp&lt;/code&gt;参数, 比如下例中的&lt;code&gt;io.StringIO&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sio = io.StringIO('{&quot;a&quot;: 123}')
&amp;gt;&amp;gt;&amp;gt; json.load(sio)
{'a': 123}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;json.load&lt;/code&gt;方法的其他参数的意义和使用方法和上文中的&lt;code&gt;json.loads&lt;/code&gt;相同, 这里不再赘述.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;json.dumps&lt;/code&gt;方法可以将Python对象转换为一个表示JONS数据的字符串. 它的完整接口签名如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的第一个参数&lt;code&gt;obj&lt;/code&gt;即为要转换的数据对象.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.dumps({'a': 123, 'b': 'ABC'})
'{&quot;a&quot;: 123, &quot;b&quot;: &quot;ABC&quot;}'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编码格式-1&quot;&gt;3.1 编码格式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;json.dumps&lt;/code&gt;的&lt;code&gt;ensure_ascii&lt;/code&gt;参数用来控制生成的JSON字符串的编码. 其默认值为&lt;code&gt;True&lt;/code&gt;, 此时, 所有的非ASCII码字条都会转义. 如果不希望自动进行转义, 则会保持原有编码, 限UTF-8. 如下例所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.dumps({'数字': 123, '字符': '一二三'})
'{&quot;\\u6570\\u5b57&quot;: 123, &quot;\\u5b57\\u7b26&quot;: &quot;\\u4e00\\u4e8c\\u4e09&quot;}'
&amp;gt;&amp;gt;&amp;gt; json.dumps({'数字': 123, '字符': '一二三'}, ensure_ascii=False)
'{&quot;数字&quot;: 123, &quot;字符&quot;: &quot;一二三&quot;}'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数据类型转换-1&quot;&gt;3.2 数据类型转换&lt;/h2&gt;
&lt;p&gt;在默认实现中, &lt;code&gt;json.dumps&lt;/code&gt;可以处理的Python对象, 及其所有的属性值, 类型必须为&lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;或者&lt;code&gt;int&lt;/code&gt;. 这些类型与JSON的数据转换关系如下表:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;dict&lt;/td&gt;
&lt;td&gt;object&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;list, tuple&lt;/td&gt;
&lt;td&gt;array&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;str&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;int, float, int-&amp;amp;float-derived emuns&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;实际转换情况如下示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.dumps(
...     {
...             'str': 'ABC',
...             'int': 123,
...             'float': 321.45,
...             'bool_true': True,
...             'bool_false': False,
...             'none': None,
...             'list': [1, 2, 3],
...             'tuple': [12, 34]
...     }
... )
'{&quot;str&quot;: &quot;ABC&quot;, &quot;int&quot;: 123, &quot;float&quot;: 321.45, &quot;bool_true&quot;: true, &quot;bool_flase&quot;: false, &quot;none&quot;: null, &quot;list&quot;: [1, 2, 3], &quot;tuple&quot;: [12, 34]}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然JSON标准规范不支持&lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;和&lt;code&gt;-Infinity&lt;/code&gt;, 但是&lt;code&gt;json.dumps&lt;/code&gt;的默认实现会将&lt;code&gt;float('nan')&lt;/code&gt;, &lt;code&gt;float('inf')&lt;/code&gt;和&lt;code&gt;float('-inf')&lt;/code&gt;转换为常量NaN, Infinity, 和-Infinity. 如下例所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.dumps(
...     {
...             'nan': float('nan'),
...             'inf': float('inf'),
...             '-inf': float('-inf')
...     }
... )
'{&quot;nan&quot;: NaN, &quot;inf&quot;: Infinity, &quot;-inf&quot;: -Infinity}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于这些常量可能会导致生成的JSON字符串不能被其他的JSON实现处理, 为了防止这种情况出现, 可以将&lt;code&gt;json.dumps&lt;/code&gt;的&lt;code&gt;allow_nan&lt;/code&gt;参数设置为&lt;code&gt;True&lt;/code&gt;. 此时, 当处理的Python对象中出现这些值时, &lt;code&gt;json.dumps&lt;/code&gt;方法会抛出异常.&lt;/p&gt;
&lt;h2 id=&quot;循环引用&quot;&gt;3.3 循环引用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;json.dumps&lt;/code&gt;方法会检查Python对象中是否有循环引用, 如果发现了循环引用, 就会抛出异常. 如下例所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; circular_obj = {}
&amp;gt;&amp;gt;&amp;gt; circular_obj['self'] = circular_obj
&amp;gt;&amp;gt;&amp;gt; circular_obj
{'self': {...}}
&amp;gt;&amp;gt;&amp;gt; json.dumps(circular_obj)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/json/__init__.py&quot;, line 231, in dumps
    return _default_encoder.encode(obj)
  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py&quot;, line 199, in encode
    chunks = self.iterencode(o, _one_shot=True)
  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py&quot;, line 257, in iterencode
    return _iterencode(o, 0)
ValueError: Circular reference detected&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不希望&lt;code&gt;json.dumps&lt;/code&gt;方法检查循环引用, 可以将参数&lt;code&gt;check_circular&lt;/code&gt;设置为&lt;code&gt;False&lt;/code&gt;. 但如果此时Python对象中有循环引用, 有可能发生递归嵌套过深的错误或者其他错误, 这么做是比较危险的. 如下例所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.dumps(circular_obj, check_circular=False)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/json/__init__.py&quot;, line 238, in dumps
    **kw).encode(obj)
  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py&quot;, line 199, in encode
    chunks = self.iterencode(o, _one_shot=True)
  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py&quot;, line 257, in iterencode
    return _iterencode(o, 0)
RecursionError: maximum recursion depth exceeded while encoding a JSON object&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;json字符串输出格式&quot;&gt;3.4 JSON字符串输出格式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;json.dumps&lt;/code&gt;方法的&lt;code&gt;indent&lt;/code&gt;参数可以用来控制JSON字符串的换行和缩进效果.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;indent&lt;/code&gt;参数默认值为&lt;code&gt;None&lt;/code&gt;. 此时, JSON字符串不会有换行和缩进效果. 如下示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(json.dumps({'a': 123, 'b': {'x': 321, 'y': 'ABC'}}))
{&quot;a&quot;: 123, &quot;b&quot;: {&quot;x&quot;: 321, &quot;y&quot;: &quot;ABC&quot;}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当&lt;code&gt;indent&lt;/code&gt;为0或者负数时, JSON字符会包含换行:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(json.dumps({'a': 123, 'b': {'x': 321, 'y': 'ABC'}}, indent=-1))
{
&quot;a&quot;: 123,
&quot;b&quot;: {
&quot;x&quot;: 321,
&quot;y&quot;: &quot;ABC&quot;
}
}
&amp;gt;&amp;gt;&amp;gt; print(json.dumps({'a': 123, 'b': {'x': 321, 'y': 'ABC'}}, indent=0))
{
&quot;a&quot;: 123,
&quot;b&quot;: {
&quot;x&quot;: 321,
&quot;y&quot;: &quot;ABC&quot;
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而当&lt;code&gt;indent&lt;/code&gt;为正整数时, 除了换行, JSON还会以指定数量的空格为单位在对象层次间进行缩进:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(json.dumps({'a': 123, 'b': {'x': 321, 'y': 'ABC'}}, indent=2))
{
  &quot;a&quot;: 123,
  &quot;b&quot;: {
    &quot;x&quot;: 321,
    &quot;y&quot;: &quot;ABC&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;indent&lt;/code&gt;还可以是&lt;code&gt;str&lt;/code&gt;, 此时, JSON会以&lt;code&gt;str&lt;/code&gt;内容为单位进行缩进, 比如制表符&lt;code&gt;\t&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(json.dumps({'a': 123, 'b': {'x': 321, 'y': 'ABC'}}, indent='\t'))
{
        &quot;a&quot;: 123,
        &quot;b&quot;: {
            &quot;x&quot;: 321,
            &quot;y&quot;: &quot;ABC&quot;
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;json.dumps&lt;/code&gt;的另外一个参数&lt;code&gt;separators&lt;/code&gt;可以用来设置输出的分隔符. 这个参数的值应当是一个有两个元素的&lt;code&gt;tuple&lt;/code&gt;. 其第一个值为成员间的分隔符, 第二个值为键值之间的分隔符. 其默认值也会随上文中的&lt;code&gt;indent&lt;/code&gt;参数影响. 当&lt;code&gt;indent&lt;/code&gt;为&lt;code&gt;None&lt;/code&gt;时, &lt;code&gt;separators&lt;/code&gt;的默认值为&lt;code&gt;(', ', ': ')&lt;/code&gt;, 即分隔符后都有一个空格. 当&lt;code&gt;indent&lt;/code&gt;不为&lt;code&gt;None&lt;/code&gt;时, 其默认值则为&lt;code&gt;(',', ':')&lt;/code&gt;, 即只有键值间分隔符后会有一个空格, 而元素间分隔符则不带空格, 因为此时会有换行.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;separators&lt;/code&gt;参数的一种可能的使用场景是希望移除所有的非必要格式字符, 以此来减小JSON字符串的大小. 此时可以将&lt;code&gt;separator&lt;/code&gt;设置为&lt;code&gt;(',', ';')&lt;/code&gt;, 并不设置&lt;code&gt;indent&lt;/code&gt;参数, 或者将其显式设置为&lt;code&gt;None&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(json.dumps({'a': 123, 'b': {'x': 321, 'y': 'ABC'}}, indent=None, separators=(',', ':')))
{&quot;a&quot;:123,&quot;b&quot;:{&quot;x&quot;:321,&quot;y&quot;:&quot;ABC&quot;}}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;转换自定义python对象&quot;&gt;3.5 转换自定义Python对象&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;json.dumps&lt;/code&gt;的默认实现只能转换Dictionary类型的对象. 如果想要转换自定义对象, 需要使用&lt;code&gt;default&lt;/code&gt;参数. 这个参数接收一个函数, 这个函数的参数是一个要转换的Python对象, 返回值是能够表示这个Python对象的Dictionary对象. &lt;code&gt;default&lt;/code&gt;函数会从对象引用树的顶层开始, 逐层遍历整个对象引用树. 因此, 不用自己实现对象树的遍历逻辑, 只需要处理当前层次的对象. 如下例所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class MyClass:
...     def __init__(self, x, y):
...             self.x = x
...             self.y = y
...
&amp;gt;&amp;gt;&amp;gt; def my_default(o):
...     if isinstance(o, MyClass):
...             print('%s.y: %s' % (type(o), o.y))
...             return {'x': o.x, 'y': o.y}
...     print(o)
...     return o
...
&amp;gt;&amp;gt;&amp;gt; obj = MyClass(x=MyClass(x=1, y=2), y=11)
&amp;gt;&amp;gt;&amp;gt; json.dumps(obj, default=my_default)
&amp;lt;class '__main__.MyClass'&amp;gt;.y: 11
&amp;lt;class '__main__.MyClass'&amp;gt;.y: 2
'{&quot;x&quot;: {&quot;x&quot;: 1, &quot;y&quot;: 2}, &quot;y&quot;: 11}'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;非字符串类型键名&quot;&gt;3.6 非字符串类型键名&lt;/h2&gt;
&lt;p&gt;在Python中, 只是可哈希(hashable)的对象和数据都可以做为Dictionary对象的键, 而JSON规范中则只能使用字符串做为键名. 所以在&lt;code&gt;json.dumps&lt;/code&gt;的实现中, 对这个规则进行了检查, 不过键名允许的范围有所扩大, &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;和&lt;code&gt;None&lt;/code&gt;类型的数据都可以做为键名. 不过当键名非&lt;code&gt;str&lt;/code&gt;的情况时, 键名会转换为对应的&lt;code&gt;str&lt;/code&gt;值. 如下例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.dumps(
...     {
...             'str': 'str',
...             123: 123,
...             321.54: 321.54,
...             True: True,
...             False: False,
...             None: None
...     }
... )
'{&quot;str&quot;: &quot;str&quot;, &quot;123&quot;: 123, &quot;321.54&quot;: 321.54, &quot;true&quot;: true, &quot;false&quot;: false, &quot;null&quot;: null}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而当出现其他类型的键名时, 默认出抛出异常:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.dumps({(1,2): 123})
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/json/__init__.py&quot;, line 231, in dumps
    return _default_encoder.encode(obj)
  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py&quot;, line 199, in encode
    chunks = self.iterencode(o, _one_shot=True)
  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py&quot;, line 257, in iterencode
    return _iterencode(o, 0)
TypeError: keys must be a string&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;json.dumps&lt;/code&gt;的&lt;code&gt;skipkeys&lt;/code&gt;参数可以改变这个行为. 当将&lt;code&gt;skipkeys&lt;/code&gt;设置为&lt;code&gt;True&lt;/code&gt;时, 遇到非法的键名类型, 不会抛出异常, 而是跳过这个键名:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.dumps({(1,2): 123}, skipkeys=True)
'{}'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;生成json文件&quot;&gt;3.7 生成JSON文件&lt;/h2&gt;
&lt;p&gt;当需要将生成的JSON数据保存到文件时, 可以使用&lt;code&gt;json.dump&lt;/code&gt;方法. 这个方法比&lt;code&gt;json.dumps&lt;/code&gt;多了一个参数&lt;code&gt;fp&lt;/code&gt;, 这个参数就是用来保存JSON数据的文件对象. 比如, 下例中的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; with open('/tmp/data.json', mode='a') as jf:
...     json.dump({'a': 123}, jf)
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就会将JSON数据写入到&lt;code&gt;/tmp/data.json&lt;/code&gt;文件里. 代码执行完后, 文件内容为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;a&quot;: 123}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;json.dump&lt;/code&gt;方法也可以接受其他类文件对象:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sio = io.StringIO()
&amp;gt;&amp;gt;&amp;gt; json.dump({'a': 123}, sio)
&amp;gt;&amp;gt;&amp;gt; sio.getvalue()
'{&quot;a&quot;: 123}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;json.dump&lt;/code&gt;的其他参数和&lt;code&gt;json.dumps&lt;/code&gt;的用法相同, 这里不再赘述.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;json.loads&lt;/code&gt;, &lt;code&gt;json.load&lt;/code&gt;, &lt;code&gt;json.dumps&lt;/code&gt;和&lt;code&gt;json.dump&lt;/code&gt;这四个方法是通过&lt;code&gt;json.JSONDecoder&lt;/code&gt;和&lt;code&gt;json.JSONEncoder&lt;/code&gt;这两个类来完成各自的任务的. 所以也可以直接使用这两个类来完成前文描述的功能:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; json.JSONDecoder().decode('{&quot;a&quot;: 123}')
{'a': 123}
&amp;gt;&amp;gt;&amp;gt; json.JSONEncoder().encode({'a': 123})
'{&quot;a&quot;: 123}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;json.loads&lt;/code&gt;, &lt;code&gt;json.load&lt;/code&gt;, &lt;code&gt;json.dumps&lt;/code&gt;和&lt;code&gt;json.dump&lt;/code&gt;这个四个方法的参数主要都是传递给了&lt;code&gt;json.JSONDecoder&lt;/code&gt;和&lt;code&gt;json.JSONEncoder&lt;/code&gt;的构造方法, 所以使用这些方法可以满足绝大部分需求. 当需要自定义&lt;code&gt;json.JSONDecoder&lt;/code&gt;和&lt;code&gt;json.JSONEncoder&lt;/code&gt;子类的时候, 只需要将子类传递给&lt;code&gt;cls&lt;/code&gt;参数. 同时, 这些方法都有&lt;code&gt;**kw&lt;/code&gt;参数. 当自定义实现类的构造函数需要标准参数列表之外的新参数时, 这个参数就会将新参数传递给实现类的构造方法.&lt;/p&gt;

</description>
<pubDate>Fri, 04 May 2018 12:31:00 +0000</pubDate>
<dc:creator>不写日记</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mithrilon/p/8954690.html</dc:identifier>
</item>
<item>
<title>java并发编程——通过ReentrantLock,Condition实现银行存取款 - NeilZhang</title>
<link>http://www.cnblogs.com/NeilZhang/p/8992353.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeilZhang/p/8992353.html</guid>
<description>&lt;p&gt;　     java.util.concurrent.locks包为锁和等待条件提供一个框架的接口和类，它不同于内置同步和监视器。该框架允许更灵活地使用锁和条件，但以更难用的语法为代价。 &lt;/p&gt;
&lt;p&gt;        Lock 接口支持那些语义不同（重入、公平等）的锁规则，可以在非阻塞式结构的上下文（包括 hand-over-hand 和锁重排算法）中使用这些规则。主要的实现是 ReentrantLock。 &lt;/p&gt;
&lt;p&gt;        ReadWriteLock 接口以类似方式定义了一些读取者可以共享而写入者独占的锁。此包只提供了一个实现，即 ReentrantReadWriteLock，因为它适用于大部分的标准用法上下文。但程序员可以创建自己的、适用于非标准要求的实现。 &lt;/p&gt;
&lt;p&gt; 　　以下是locks包的相关类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/918077/201805/918077-20180504185647609-1158006901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;        在之前我们同步一段代码或者对象时都是使用 synchronized关键字，使用的是Java语言的内置特性，然而 synchronized的特性也导致了很多场景下出现问题，比如：&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;在一段同步资源上，首先线程A获得了该资源的锁，并开始执行，此时其他想要操作此资源的线程就必须等待。如果线程A因为某些原因而处于长时间操作的状态，比如等待网络，反复重试等等。&lt;/span&gt;那么其他线程就没有办法及时的处理它们的任务，只能无限制的等待下去。&lt;span&gt;如果线程A的锁在持有一段时间后可自动被释放，那么其他线程不就可以使用该资源了吗？&lt;/span&gt;再有就是类似于数据库中的共享锁与排它锁，是否也可以应用到应用程序中？所以引入Lock机制就可以很好的解决这些问题。&lt;/p&gt;
&lt;p&gt;　　Lock提供了比 synchronized更多的功能。但是要注意以下几点：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;•&lt;/strong&gt; Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;•&lt;/strong&gt; Lock和synchronized有一点非常大的不同，采用 synchronized不需要用户去手动释放锁，当synchronized方法或者 synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；&lt;span&gt;而 Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;一、可重入锁 ReentrantLock&lt;/h3&gt;
&lt;p&gt;　　想到锁我们一般想到的是同步锁即 Synchronized,这里介绍的可重入锁ReentrantLock的效率更高。IBM对于可重入锁进行了一个介绍：&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-jtp10264/index.html&quot; target=&quot;_blank&quot;&gt;JDK 5.0 中更灵活、更具可伸缩性的锁定机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　这里简单介绍下可重入锁的分类：（假设线程A获取了锁，现在A执行完成了，释放了锁同时唤醒了正在等待被唤醒的线程B。但是，A执行唤醒操作到B真正获取锁的时间里可能存在线程C已经获取了锁，造成正在排队等待的B无法获得锁）&lt;/p&gt;
&lt;p&gt;　　1) 公平锁： &lt;/p&gt;
&lt;p&gt;　　　　　由于B先在等待被唤醒，为了保证公平性原则，公平锁会先让B获得锁。&lt;/p&gt;
&lt;p&gt;　　2) 非公平锁&lt;/p&gt;
&lt;p&gt;　　　　　不保证B先获取到锁对象。&lt;/p&gt;
&lt;p&gt;　　这两种锁只要在构造ReentrantLock对象时加以区分就可以了，当参数设置为true时为公平锁，false时为非公平锁，同时默认构造函数也是创建了一个非公平锁。&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
　　　　private Lock lock = new ReentrantLock(true);&lt;p&gt;ReentrantLock的公平锁在性能和实效性上作了很大的牺牲，可以参考IBM上发的那篇文章中的说明。&lt;/p&gt;&lt;/pre&gt;
&lt;h3&gt;二、条件变量 Condition&lt;/h3&gt;
&lt;p&gt;　　Condition是java.util.concurrent.locks包下的一个接口,  Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。 &lt;/p&gt;
&lt;p&gt;       Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set（wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。 &lt;/p&gt;
&lt;p&gt; 　　Condition（也称为条件队列 或条件变量）为线程提供了一种手段，在某个状态条件下直到接到另一个线程的通知，一直处于挂起状态（即“等待”）。因为访问此共享状态信息发生在不同的线程中，所以它必须受到保护，因此要将某种形式的锁与 Condition相关联。&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;  Condition 实例实质上被绑定到一个锁上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这里不再对Locks包下的源码进行分析。&lt;/p&gt;

&lt;h3&gt;三、ReentrantLock和Condition设计多线程存取款&lt;/h3&gt;
&lt;p&gt;1. 存款的时候，不能有线程在取款 。取款的时候，不能有线程在存款。&lt;/p&gt;
&lt;p&gt;2. 取款时，余额大于取款金额才能进行取款操作，否则提示余额不足。&lt;/p&gt;
&lt;p&gt;3.  当取款时，如果金额不足，则阻塞当前线程，并等待2s（可能有其他线程将钱存入）。&lt;/p&gt;
&lt;p&gt;    如果2s之内没有其它线程完成存款，或者还是金额不足则打印金额不足。&lt;/p&gt;
&lt;p&gt;    如果其它存入足够金额则通知该阻塞线程，并完成取款操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 普通银行账户，不可透支
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyCount {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String oid; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 账号&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cash;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 账户余额
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;账户锁，这里采用公平锁，挂起的取款线程优先获得锁，而不是让其它存取款线程获得锁&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt; ReentrantLock(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Condition _save = lock.newCondition(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存款条件&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Condition _draw = lock.newCondition(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取款条件&lt;/span&gt;
&lt;span&gt;
    MyCount(String oid, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cash) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.oid =&lt;span&gt; oid;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cash =&lt;span&gt; cash;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 存款
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; x 操作金额
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name 操作人
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; saving(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x, String name) {
        lock.lock(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取锁&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (x &amp;gt; 0&lt;span&gt;) {
            cash &lt;/span&gt;+= x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存款&lt;/span&gt;
            System.out.println(name + &quot;存款&quot; + x + &quot;，当前余额为&quot; +&lt;span&gt; cash);
        }
        _draw.signalAll(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒所有等待线程。&lt;/span&gt;
        lock.unlock(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放锁&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取款
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; x  操作金额
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name 操作人
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; drawing(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x, String name) {
        lock.lock(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取锁&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cash - x &amp;lt; 0&lt;span&gt;) {
                System.out.println(name &lt;/span&gt;+ &quot;阻塞中&quot;&lt;span&gt;);
                _draw.await(&lt;/span&gt;2000,TimeUnit.MILLISECONDS); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 阻塞取款操作, await之后就隐示自动释放了lock，直到被唤醒自动获取&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cash-x&amp;gt;=0&lt;span&gt;){
                cash &lt;/span&gt;-= x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取款&lt;/span&gt;
                System.out.println(name + &quot;取款&quot; + x + &quot;，当前余额为&quot; +&lt;span&gt; cash);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                System.out.println(name&lt;/span&gt;+&quot; 余额不足,当前余额为 &quot;+cash+&quot;   取款金额为 &quot;+&lt;span&gt;x);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒所有存款操作，这里并没有什么实际作用，因为存款代码中没有阻塞的操作&lt;/span&gt;
&lt;span&gt;            _save.signalAll();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放锁&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的可重入锁也可以设置成非公平锁，这样阻塞取款线程可能后与其它存取款操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 存款线程类
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SaveThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String name; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 操作人&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; MyCount myCount; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 账户&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存款金额&lt;/span&gt;
&lt;span&gt;
        SaveThread(String name, MyCount myCount, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.myCount =&lt;span&gt; myCount;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            myCount.saving(x, name);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取款线程类
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DrawThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String name; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 操作人&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; MyCount myCount; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 账户&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存款金额&lt;/span&gt;
&lt;span&gt;
        DrawThread(String name, MyCount myCount, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.myCount =&lt;span&gt; myCount;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            myCount.drawing(x, name);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建并发访问的账户&lt;/span&gt;
        MyCount myCount = &lt;span&gt;new&lt;/span&gt; MyCount(&quot;95599200901215522&quot;, 1000&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个线程池&lt;/span&gt;
        ExecutorService pool = Executors.newFixedThreadPool(3&lt;span&gt;);
        Thread t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SaveThread(&quot;张三&quot;, myCount, 100&lt;span&gt;);
        Thread t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SaveThread(&quot;李四&quot;, myCount, 1000&lt;span&gt;);
        Thread t3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DrawThread(&quot;王五&quot;, myCount, 12600&lt;span&gt;);
        Thread t4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SaveThread(&quot;老张&quot;, myCount, 600&lt;span&gt;);
        Thread t5 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DrawThread(&quot;老牛&quot;, myCount, 2300&lt;span&gt;);
        Thread t6 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DrawThread(&quot;胖子&quot;, myCount, 1800&lt;span&gt;);
        Thread t7 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SaveThread(&quot;测试&quot;, myCount, 200&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行各个线程&lt;/span&gt;
&lt;span&gt;        pool.execute(t1);
        pool.execute(t2);
        pool.execute(t3);
        pool.execute(t4);
        pool.execute(t5);
        pool.execute(t6);
        pool.execute(t7);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;3000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭线程池&lt;/span&gt;
&lt;span&gt;        pool.shutdown();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述类中定义了多个存取款的线程，执行结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;p&gt;S1存款100，当前余额为1100&lt;br/&gt;S3存款600，当前余额为1700&lt;br/&gt;D2阻塞中&lt;br/&gt;S2存款1000，当前余额为2700&lt;br/&gt;D2取款2300，当前余额为400&lt;br/&gt;D3阻塞中&lt;br/&gt;S4存款200，当前余额为600&lt;br/&gt;D3 余额不足,当前余额为 600 取款金额为 1800&lt;br/&gt;D1阻塞中&lt;br/&gt;D1 余额不足,当前余额为 600 取款金额为 12600&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;执行步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化账户，有余额100。&lt;/li&gt;
&lt;li&gt;S1，S3完成存款。&lt;/li&gt;
&lt;li&gt;D2取款，余额不足，释放锁并阻塞线程，进入等待队列中。&lt;/li&gt;
&lt;li&gt; S2完成存款操作后，会唤醒挂起的线程，这时D2完成了取款。&lt;/li&gt;
&lt;li&gt; D3取款，余额不足，释放锁并阻塞线程，进入等待队列中。&lt;/li&gt;
&lt;li&gt; S4完成存款操作后，唤醒D3，但是依然余额不足，D3 取款失败。&lt;/li&gt;
&lt;li&gt; D1 进行取款，等待2s钟，无任何线程将其唤醒，取款失败。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里需要注意的是，当Condition调用await()方法时，当前线程会释放锁（否则就和Sychnize就没有区别了）&lt;/p&gt;
&lt;p&gt;将银行账户中的 锁改成非公平锁时，执行的结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1存款100，当前余额为1100
S3存款600，当前余额为1700
D2阻塞中
S2存款1000，当前余额为2700
D3取款1800，当前余额为900
D2 余额不足,当前余额为 &lt;/span&gt;900   取款金额为 2300&lt;span&gt;
S4存款200，当前余额为1100
D1阻塞中
D1 余额不足,当前余额为 &lt;/span&gt;1100   取款金额为 12600
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;D2 取款出现余额不足后释放锁，进入等待状态。但是当S2线程完成存款后并没有立刻执行D2线程，而是被D3插队了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过执行结果可以看出 公平锁和非公平锁的区别，公平锁能保证等待线程优先执行，但是非公平锁可能会被其它线程插队。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;四、ArrayBlockingQueue中关于ReentrantLock和Condition的应用&lt;/h3&gt;
&lt;p&gt;JDK源码中关于可重入锁的非常典型的应用是 BlockingQueue，从它的源码中的成员变量大概就能知道了（ArrayBlockingQueue为例）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
 /** The queued items */
    final Object[] items;

    /** items index for next take, poll, peek or remove */
    int takeIndex;

    /** items index for next put, offer, or add */
    int putIndex;

    /** Number of elements in the queue */
    int count;

    /*
     * Concurrency control uses the classic two-condition algorithm
     * found in any textbook.
     */

    /** Main lock guarding all access */
&lt;/pre&gt;
&lt;pre&gt;
    // 主要解决多线程访问的线程安全性问题
    final ReentrantLock lock;

    /** Condition for waiting takes */
&lt;/pre&gt;
&lt;pre&gt;
   &lt;span&gt; // 添加元素时，通过notEmpty 唤醒消费线程（在等待该条件）&lt;/span&gt;
    private final Condition notEmpty;

    /** Condition for waiting puts */
&lt;/pre&gt;
&lt;pre&gt;
    // 删除元素时，通过 notFull 唤醒生成线程（在等待该条件）
    private final Condition notFull;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ArrayBlockingQueue 是一个典型的生产者消费者模型，通过一个数组保存元素。为了保证添加和删除元素的线程安全性，增加了可重入锁和条件变量。&lt;/p&gt;
&lt;p&gt;可重入锁主要保证多线程对阻塞队列的操作是线程安全的，同时为了让被阻塞的消费者或者生产者能够被自动唤醒，这里引入了条件变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/918077/201805/918077-20180504195829368-1811239748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当队列已满时，Producer会被阻塞，此时如果Customer消费一个元素时，被阻塞的Producer就会被自动唤醒并往队列中添加元素。&lt;/p&gt;

&lt;p&gt;上面的两个例子可见java.util.concurrent.locks包下的ReentrantLock和Condition配合起来的灵活性及实用性。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;可重入锁介绍：https://blog.csdn.net/yanyan19880509/article/details/52345422&lt;/p&gt;
&lt;p&gt;IBM关于Lock介绍：&lt;a href=&quot;http://www.ibm.com/developerworks/cn/java/j-jtp10264/index.html&quot; target=&quot;_blank&quot;&gt;http://www.ibm.com/developerworks/cn/java/j-jtp10264/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;http://286.iteye.com/blog/2296249&lt;/p&gt;
</description>
<pubDate>Fri, 04 May 2018 12:13:00 +0000</pubDate>
<dc:creator>NeilZhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeilZhang/p/8992353.html</dc:identifier>
</item>
<item>
<title>JS（作用域和闭包） - 姜皓</title>
<link>http://www.cnblogs.com/jianghao233/p/8992289.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jianghao233/p/8992289.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.对变量提升的理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.变量定义（上下文）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.函数声明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.说明 this 几种不同的使用场景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常见用法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.作为构造函数执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.作为对象属性执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.作为普通函数执行(this === window)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.call apply bind&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.创建10个 &amp;lt;a&amp;gt;标签，点击的时候弹出来对应的序号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504210646202-1582101136.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;结果：&lt;span&gt;均显示&lt;/span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504212145379-1070282839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这种的结果是：每次点击时 i 都为10；点击 click 时，弹出 i，i 是自由变量，这时 i 已经变为 10了，故每次输出都为10；i 是全局作用域，存在覆盖的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504211043404-1691887970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 i 将函数包住，相当于创建 10 个函数 i ,不存在覆盖问题。&lt;/p&gt;
&lt;p&gt;自执行函数：不用调用，只要定义完成，立即执行的函数（i 为 自执行函数）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.如何理解作用域&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.自由变量（当前作用域没有定义的变量）&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.作用域链（自由变量的查找）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;变量与函数的查找规则: 当我们调用一条数据的时候，js首先会在当前作用域中进行查找，如果找不到，就向上找到父级的作用域，如果在父级的作用域中也找不到，就继续向上查找，直到window的作用域。如果在window中也找不到，就报错了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.闭包的两个场景：1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;函数作为返回值2.函数作为参数传递&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;5.实际开发中闭包的应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;封装变量，收敛权限(不能更改的部分）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504212823647-749800681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;检验该数组是否在之前存在过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 闭包的意义：在 isFirstLoad 函数外面，根本不可能修改掉 _list 的值（没来过的就是 &amp;lt; 0）&lt;/p&gt;
&lt;p&gt;一、执行上下文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504170632428-100518098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.范围：一段&amp;lt;script&amp;gt;或者一个函数  （&lt;span&gt;都会生成一个执行上下文&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.全局：变量定义、函数声明  &lt;span&gt;（一段&amp;lt;script&amp;gt;先将变量定义和函数声明拿出来）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.函数：变量定义、函数声明、this、arguments  &lt;span&gt;（一个函数在执行之前姜变量定义、函数声明、this、arguments 拿出来）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数声明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504171515087-681934311.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;将整个函数拿出来，故 function fn(name) 输出为 'zhangsan' 20  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数表达式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504171659296-1495805973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先将变量定义拿出来，即将 a 拿出来，故console.log(a) 输出 undefined（代替）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （不推荐这样写，应将 定义 var a = 100 放在前面）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、this&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;this 要在执行时（函数后面有（））才能确认值，定义时无法确认&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504172603814-1514688204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常见用法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.作为构造函数执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.作为对象属性执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.作为普通函数执行(this === window)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.call apply bind&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504195058707-1144040164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504195210403-802005007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、作用域&lt;/p&gt;
&lt;p&gt; 1.没有块级作用域&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504195457449-1084328015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为 JS 中没有块级作用域，所以在{}里声明变量和在 if 之前声明变量是一样的（但尽量不要在块级作用域里面声明变量，不易读）&lt;/p&gt;
&lt;p&gt;推荐写法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504203409246-995878348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.只有函数和&lt;a href=&quot;http://www.cnblogs.com/jianghao233/p/8989769.html&quot; target=&quot;_blank&quot;&gt;全局作用域&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504195512206-2046397952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为保证变量不会被污染，可以将所有的变量定义在一个大的函数里。&lt;/p&gt;
&lt;p&gt;作用域(scope)：一条数据可以在哪个范围中使用。 通常来说，一段程序代码中所用到的数据并不总是有效/可用的，而限定这个数据的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。&lt;/p&gt;
&lt;p&gt;变量(数据)js中，变量的作用域有两中，一种是全局作用域（全局变量） ，一种局部作用域（局部变量），一个变量是全局变量还是局部变量，主要看变量声明的位置。声明在函数内部，就是这个函数（function）的局部变量。&lt;/p&gt;
&lt;p&gt;全局作用域 --- 在任何地方都能访问 函数外定义的变量拥有全局作用域 不使用var定义的变量拥有全局作用域 所有window对象上的属性拥有全局作用域 没有声明在任何函数内部的函数拥有全局作用域 局部作用域 --- 只能在函数内部访问 使用var在函数内部定义的变量,和使用function在函数内部声明的函数,拥有局部作用域&lt;/p&gt;
&lt;p&gt;四、作用域链&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504201956836-1044635798.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504203601337-1229205468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
var b = 200

console.log(a)

console.log(b)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　执行 console.log(a)时，在其父集作用域中去找 a,父集作用域为全局作用域，故 a 找到 var a = 100&lt;/span&gt;;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504202712929-723399778.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：100 200 300&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;寻找父集作用域要关注函数声明定义的位置&lt;/span&gt;；F1 的父集作用域为 a ,F2 的父集作用域为 F1故输出结果：100 200 300，这种寻找方式即为作用域链&lt;/p&gt;
&lt;p&gt;变量与函数的查找规则: 当我们调用一条数据的时候，js首先会在当前作用域中进行查找，如果找不到，就向上找到父级的作用域，如果在父级的作用域中也找不到，就继续向上查找，直到window的作用域。如果在window中也找不到，就报错了&lt;/p&gt;
&lt;p&gt;五、闭包&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504203916297-1613994381.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504205548312-1716863474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;函数 F1 最后返回一个函数 a，F1 赋值给 f1,所以 f1 为函数， 最终执行 f1(),&lt;span&gt;输出 100；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;过程如下：执行 f1()---执行F1---执行函数 a---在 a 的父集作用域 F1 中寻找a---a = 100&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; var a =200 中的 a 是全局作用域，与 var a = 100 无关系&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里面可以访问外边的，但是外边不能访问里边的。 闭包： 形式函数中套了一个函数，内层函数可以访问外层函数中的局部数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包使用场景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.函数作为返回值（如上所述）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.函数作为参数传递&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把函数传到另一个函数中执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504205740570-818107659.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180504205548312-1716863474.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;过程：执行 F2---执行 f1---执行 F1 ---执行函数 a---在其父集作用域中寻找 a --- a=100&lt;/p&gt;
</description>
<pubDate>Fri, 04 May 2018 11:45:00 +0000</pubDate>
<dc:creator>姜皓</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jianghao233/p/8992289.html</dc:identifier>
</item>
<item>
<title>点击劫持漏洞之理解 python打造一个挖掘点击劫持漏洞的脚本 - 东京$</title>
<link>http://www.cnblogs.com/haq5201314/p/8992273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haq5201314/p/8992273.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;放假了，上个星期刚刚学习完点击劫持漏洞。没来的及写笔记，今天放学总结了一下&lt;/p&gt;
&lt;p&gt;并写了一个检测点击劫持的脚本。点击劫持脚本说一下哈。= =原本是打算把网站源码&lt;/p&gt;
&lt;p&gt;中的js也爬出来将一些防御的代码匹配一下。可惜，爬出来的js链接乱的一匹。弄了很久&lt;/p&gt;
&lt;p&gt;也很乱。所以就没有匹配js文件了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;漏洞介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;漏洞名称：点击劫持漏洞（Clicking hijacking）&lt;/p&gt;
&lt;p&gt;级别：中级&lt;/p&gt;
&lt;p&gt;漏洞用于场景：钓鱼，欺骗。&lt;/p&gt;
&lt;p&gt;《黑客攻防之浏览器篇》里有详细的利用教程。&lt;/p&gt;
&lt;p&gt;里面所介绍的工具做出来的payload能以假乱真&lt;/p&gt;
&lt;p&gt;攻击手法：在一个页面的中嵌入一个iframe标签，放入诱惑信息，引诱用户点击&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;漏洞复现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;后台管理员添加&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  body&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-repeat&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; no-repeat&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;background-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100% 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;background-attachment&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; fixed&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  h2&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;background&lt;/span&gt;&lt;span&gt;=&quot;bei.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;管理员添加&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;text-align:center;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;x.php&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;POST&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; required&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; required&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;提交&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201805/1174022-20180504184026590-804122834.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;payload&lt;/p&gt;
&lt;p&gt;将opacity设置为0.3可以看见你所填的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;点击劫持&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  iframe&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; absolute&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;z-index&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1800px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 900px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;opacity&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; alpha(opacity=0)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  button&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; absolute&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;z-index&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 125px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 878px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  input&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; absolute&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;z-index&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 65px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 820px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  body&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-repeat&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;no-repeat&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;text-align:center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;靓丽美女账号注册&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;position: absolute;z-index: 1;top: 43px;left: 5px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;注册&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;iframe &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;http://127.0.0.1/jiechi/index.html&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201805/1174022-20180504192240218-1497930317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加上背景&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201805/1174022-20180504192412010-761257262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;漏洞防御：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.加入js脚本防御&lt;/p&gt;
&lt;h3&gt;目前最好的js的防御方案为：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;head&amp;gt;
&amp;lt;style&amp;gt;&lt;span&gt;
 body { display : none;} 
&lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;script&amp;gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (self ==&lt;span&gt; top) {    
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; theBody = document.getElementsByTagName('body')[0];    &lt;br/&gt;theBody.style.display = &quot;block&quot;&lt;span&gt;;
} 
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
{   
 top.location &lt;/span&gt;=&lt;span&gt; self.location;
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.添加&lt;span&gt;X-FRAME-OPTIONS头进行防御&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;X-FRAME-OPTIONS头是微软开发的，使用该头后禁止页面被iframe嵌套&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;防御结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将index.html改为index.php，代码改为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
X-FRAME-&lt;span&gt;OPTIONS头使用说明：
&lt;/span&gt;1.&lt;span&gt;DENY  拒绝任何域加载
&lt;/span&gt;2.&lt;span&gt;SAMEORIHIN  同源下可以加载
&lt;/span&gt;3.ALLOW-FROM 可以定义允许frame加载的页面
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;header&lt;/span&gt; ( &quot;X-FRAME-OPTIONS:DENY&quot;&lt;span&gt;);
&lt;/span&gt;?&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;后台管理员添加&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;&lt;span&gt;
  body{ background&lt;/span&gt;-repeat: no-repeat;background-size: 100% 100%;background-attachment:&lt;span&gt; fixed;}
  h2{ color&lt;/span&gt;:blue;text-align:&lt;span&gt; center;}
  &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body background=&quot;bei.jpg&quot;&amp;gt;
  &amp;lt;h2&amp;gt;管理员添加&amp;lt;/h2&amp;gt;
  &amp;lt;div style=&quot;text-align:center;&quot;&amp;gt;
    &amp;lt;form action=&quot;x.php&quot; method=&quot;POST&quot;&amp;gt;
      &amp;lt;input type=&quot;text&quot; required&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
      &amp;lt;input type=&quot;password&quot; required&amp;gt;&amp;lt;br&amp;gt;
      &amp;lt;input type=&quot;submit&quot; value=&quot;提交&quot;&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将payload.html的opacity设置为0.3&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201805/1174022-20180504193329689-1181749117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201805/1174022-20180504193340607-1049155331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可以看到已经嵌套不了了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;检测是否有点击劫持漏洞的脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原理直接判断是否有X-FROM-OPTIONS头。如果没有就有点击劫持漏洞&lt;/p&gt;
&lt;p&gt;并提醒使用者可能有js脚本防御请自行测试。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests,tqdm,time,optparse
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    usage&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dianjijieci.py [-u url]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    parser&lt;/span&gt;=&lt;span&gt;optparse.OptionParser(usage)
    parser.add_option(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,dest=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,help=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;The web site to be tested URL&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    (options,args)&lt;/span&gt;=&lt;span&gt;parser.parse_args()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; options.url:
        url&lt;/span&gt;=&lt;span&gt;options.url
        jiechi(url)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        parser.print_help()
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; jiechi(url):
    urls&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(url)
    headers&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
    reqst&lt;/span&gt;=requests.get(url=urls,headers=headers,timeout=6&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; reqst.status_code == 200&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[+]Target stability&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
          hea&lt;/span&gt;=&lt;span&gt;reqst.headers
          &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(hea[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;X-FRAME-OPTIONS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
          &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[n]X-FRAME-OPTIONS header, no click hijacking vulnerability can be used&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
          &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[+]There is no X-FRAME-OPTIONS header. There is a clicking hijacking vulnerability&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
          &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[!]Remind:It may be a defense against JS. Please test it yourself&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[n]bjective instability&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201805/1174022-20180504193929215-1522582717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 04 May 2018 11:40:00 +0000</pubDate>
<dc:creator>东京$</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haq5201314/p/8992273.html</dc:identifier>
</item>
</channel>
</rss>