<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于springMVC的RESTful服务实现 - 沉梦昂志~</title>
<link>http://www.cnblogs.com/mmmmyblog/p/9598693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mmmmyblog/p/9598693.html</guid>
<description>&lt;p&gt;  &lt;span&gt;&lt;strong&gt;&lt;span&gt;一,什么是&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;RESTful&lt;/strong&gt;&lt;/span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　&lt;span&gt;&lt;strong&gt;RESTful(RESTful Web Services)一种架构风格,表述性状态转移,它不是一个软件,也不是一个标准,而是一种思想,不依赖于任何通信协议,但是开发时要成功映射到某协议时也需要遵循其标准,但不包含对通信协议的更改&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;&lt;span&gt;　特征:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　　　1.通过url地址来标识资源,系统中的每个对象或资源都可以通过其url地址来获取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2.统一接口,显式地使用HTTP方法,来进行crud(create,update,insert,delete)映射&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　创建资源使用POST&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　更新资源使用PUT&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　检索资源使用GET&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　删除资源使用DELETE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3.资源多重反映.通过url地址访问的每个资源都可以根据客户端的规定进行返回,例:JSON,XML&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;span&gt;&lt;strong&gt;RESTful服务适用web应用中创建服务的API,将资源以JSON或XML等数据格式进行暴露,从而可以更方便的让客户端进行调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二.基于SpringMVC的&lt;/strong&gt;RESTful&lt;/span&gt;服务&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　&lt;span&gt;　&lt;span&gt;在SpringMVC中对&lt;strong&gt;RESTful&lt;/strong&gt;支持,主要通过注解来实现&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　@Controller:声明一个处理请求的控制器&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　@RequestMapping:请求映射地址到对应的方法,该注解又可以分为一下几种类型:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　@GetMapping&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　@PostMpping&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　@PutMapping&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　@DeleteMapping&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　@PatchMapping&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　@ResponsrBody:响应内容转换为JSON格式&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　@RequestBody:请求内容转换为JSON格式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　@RestContrller:等同&lt;/strong&gt;@Controller+&lt;strong&gt;@ResponsrBody&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;实例环境:&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;JDK1.8;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　Maven3.5&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　Spring Boot Web Starter 2.0.0&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;整体API设计(基于用户管理模块):&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　Get/user:获取所有用户&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　Get/user/{id}:根据ID获取该用户信息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　Post/insert:保存用户信息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　Put/update:更新用户信息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　Delete/delete/{id}:根据用户ID删除用户&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　Get/user/from:获取创建用户表单&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　Get/update/{id}:根据ID获取用户信息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906140259397-40401340.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906140340549-1770689974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906140359718-393713926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906140414314-92218561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  USER 实体&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906140534206-479015468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　mapper&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906151100946-1136469698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;service&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906151200927-419745010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Main控制器&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906151245094-283974966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;application.properties&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906151349055-971931388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三. 安装Postman&lt;/p&gt;
&lt;p&gt;　　下载地址:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四.运行,测试&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906152129301-1284965593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　运行完成,访问端口8080&lt;/p&gt;
&lt;p&gt;　　1.Get&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906152621809-1412280399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.Post&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906152917850-1162147041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3.Put&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906153055777-414914229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4.Delete&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906153154838-1565651899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;测试返回200状态,至此测试成功,RESTful服务的实现完成&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;更多java学习请关注Terry公众号,有问题请在此留言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282595/201809/1282595-20180906153503660-337791408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;












&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 06 Sep 2018 07:36:00 +0000</pubDate>
<dc:creator>沉梦昂志~</dc:creator>
<og:description>一,什么是RESTful RESTful(RESTful Web Services)一种架构风格,表述性状态转移,它不是一个软件,也不是一个标准,而是一种思想,不依赖于任何通信协议,但是开发时要成功映</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mmmmyblog/p/9598693.html</dc:identifier>
</item>
<item>
<title>深入理解JavaScript事件循环机制 - 渔歌</title>
<link>http://www.cnblogs.com/yugege/p/9598265.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yugege/p/9598265.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;众所周知，JavaScript 是一门单线程语言，虽然在 html5 中提出了 Web-Worker ，但这并未改变 JavaScript 是单线程这一核心。可看&lt;a href=&quot;https://www.w3.org/TR/html5/webappapis.html#event-loops&quot;&gt;HTML规范中&lt;/a&gt;的这段话：&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. There are two kinds of event loops: those for browsing contexts, and those for workers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，用户引擎必须使用 event loops。Event Loop 包含两类：一类是基于 Browsing Context ，一种是基于 Worker ，二者是独立运行的。 下面本文用一个例子，着重讲解下基于 Browsing Context 的事件循环机制。&lt;/p&gt;
&lt;p&gt;来看下面这段 JavaScript 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先猜测一下这段代码的输出顺序是什么，再去浏览器控制台输入一下，看看实际输出的顺序和你猜测出的顺序是否一致，如果一致，那就说明，你对 JavaScript 的事件循环机制还是有一定了解的，继续往下看可以巩固下你的知识；而如果实际输出的顺序和你的猜测不一致，那么本文下面的部分会为你答疑解惑。&lt;/p&gt;
&lt;h3 id=&quot;任务队列&quot;&gt;任务队列&lt;/h3&gt;
&lt;p&gt;所有的任务可以分为同步任务和异步任务，同步任务，顾名思义，就是立即执行的任务，同步任务一般会直接进入到主线程中执行；而异步任务，就是异步执行的任务，比如ajax网络请求，setTimeout 定时函数等都属于异步任务，异步任务会通过任务队列( Event Queue )的机制来进行协调。具体的可以用下面的图来大致说明一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/698814/201809/698814-20180906144953689-838865376.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入 Event Queue 。主线程内的任务执行完毕为空，会去 Event Queue 读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。&lt;/p&gt;
&lt;p&gt;在事件循环中，每进行一次循环操作称为tick，通过阅读规范可知，每一次 tick 的任务处理模型是比较复杂的，其关键的步骤可以总结如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在此次 tick 中选择最先进入队列的任务( oldest task )，如果有则执行(一次)&lt;/li&gt;
&lt;li&gt;检查是否存在 Microtasks ，如果存在则不停地执行，直至清空Microtask Queue&lt;/li&gt;
&lt;li&gt;更新 render&lt;/li&gt;
&lt;li&gt;主线程重复执行上述步骤&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以用一张图来说明下流程：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/698814/201809/698814-20180906145003189-254912994.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里相信有人会想问，什么是 microtasks ?规范中规定，task分为两大类, 分别是 Macro Task （宏任务）和 Micro Task（微任务）, 并且每个宏任务结束后, 都要清空所有的微任务,这里的 Macro Task也是我们常说的 task ，有些文章并没有对其做区分，后面文章中所提及的task皆看做宏任务( macro task)。&lt;/p&gt;
&lt;p&gt;(macro)task 主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)&lt;/p&gt;
&lt;p&gt;microtask主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)&lt;/p&gt;
&lt;p&gt;setTimeout/Promise 等API便是任务源，而进入任务队列的是由他们指定的具体执行任务。来自不同任务源的任务会进入到不同的任务队列。其中 setTimeout 与 setInterval 是同源的。&lt;/p&gt;
&lt;h3 id=&quot;分析示例代码&quot;&gt;分析示例代码&lt;/h3&gt;
&lt;p&gt;千言万语，不如就着例子讲来的清楚。下面我们可以按照规范，一步步执行解析下上面的例子，先贴一下例子代码（免得你往上翻）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;整体 script 作为第一个宏任务进入主线程，遇到 console.log，输出 script start&lt;/li&gt;
&lt;li&gt;遇到 setTimeout，其回调函数被分发到宏任务 Event Queue 中&lt;/li&gt;
&lt;li&gt;遇到 Promise，其 then函数被分到到微任务 Event Queue 中,记为 then1，之后又遇到了 then 函数，将其分到微任务 Event Queue 中，记为 then2&lt;/li&gt;
&lt;li&gt;遇到 console.log，输出 script end&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至此，Event Queue 中存在三个任务，如下表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;setTimeout&lt;/td&gt;
&lt;td&gt;then1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;then2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ol&gt;&lt;li&gt;执行微任务，首先执行then1，输出 promise1, 然后执行 then2，输出 promise2，这样就清空了所有微任务&lt;/li&gt;
&lt;li&gt;执行 setTimeout 任务，输出 setTimeout 至此，输出的顺序是：script start, script end, promise1, promise2, setTimeout&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;so，你猜对了吗？&lt;/p&gt;
&lt;p&gt;看看你掌握了没&lt;/p&gt;
&lt;p&gt;再来一个题目，来做个练习：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
console.log('script start');

setTimeout(function() {
  console.log('timeout1');
}, 10);

new Promise(resolve =&amp;gt; {
    console.log('promise1');
    resolve();
    setTimeout(() =&amp;gt; console.log('timeout2'), 10);
}).then(function() {
    console.log('then1')
})

console.log('script end');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个题目就稍微有点复杂了，我们再分析下：&lt;/p&gt;
&lt;p&gt;首先，事件循环从宏任务 (macrotask) 队列开始，最初始，宏任务队列中，只有一个 scrip t(整体代码)任务；当遇到任务源 (task source) 时，则会先分发任务到对应的任务队列中去。所以，就和上面例子类似，首先遇到了console.log，输出 script start； 接着往下走，遇到 setTimeout 任务源，将其分发到任务队列中去，记为 timeout1； 接着遇到 promise，new promise 中的代码立即执行，输出 promise1, 然后执行 resolve ,遇到 setTimeout ,将其分发到任务队列中去，记为 timemout2, 将其 then 分发到微任务队列中去，记为 then1； 接着遇到 console.log 代码，直接输出 script end 接着检查微任务队列，发现有个 then1 微任务，执行，输出then1 再检查微任务队列，发现已经清空，则开始检查宏任务队列，执行 timeout1,输出 timeout1； 接着执行 timeout2，输出 timeout2 至此，所有的都队列都已清空，执行完毕。其输出的顺序依次是：script start, promise1, script end, then1, timeout1, timeout2&lt;/p&gt;
&lt;p&gt;用流程图看更清晰：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/698814/201809/698814-20180906145019481-518705719.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;有个小 tip：从规范来看，microtask 优先于 task 执行，所以如果有需要优先执行的逻辑，放入microtask 队列会比 task 更早的被执行。&lt;/p&gt;
&lt;p&gt;最后的最后，记住，&lt;strong&gt;JavaScript 是一门单线程语言，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，并没有专门的异步执行线程。&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/&quot;&gt;这一次，彻底弄懂 JavaScript 执行机制 Tasks, microtasks, queues and schedules 从一道题浅说 JavaScript 的事件循环&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Sep 2018 06:44:00 +0000</pubDate>
<dc:creator>渔歌</dc:creator>
<og:description>前言 众所周知，JavaScript 是一门单线程语言，虽然在 html5 中提出了 Web Worker ，但这并未改变 JavaScript 是单线程这一核心。可看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yugege/p/9598265.html</dc:identifier>
</item>
<item>
<title>JavaScript中高阶函数 - _枪枪</title>
<link>http://www.cnblogs.com/sheep-sheep/p/9598220.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheep-sheep/p/9598220.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;高阶函数是指至少满足下列条件之一的函数 1：函数可以作为参数被传递 2：函数可以作为返回值输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;JavaScript语言中的函数显然的是满足了高阶函数的条件，下面我们一起来探寻JavaScript种高阶函数的魅力。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;高阶函数实现aop&quot;&gt;## 高阶函数实现AOP&lt;/h2&gt;
&lt;p&gt;AOP(面向切面编程)的主要作用就是把一些和核心业务逻辑模块无关的功能抽取出来，然后再通过“动态织入”的方式掺到业务模块种。这些功能一般包括日志统计,安全控制,异常处理等。AOP是Java Spring架构的核心。下面我们就来探索一下再Javascript种如何实现AOP&lt;br/&gt;在JavaScript种实现AOP，都是指把一个函数“动态织入”到另外一个函数中，具体实现的技术有很多，我们使用&lt;code&gt;Function.prototype&lt;/code&gt;来做到这一点。代码如下&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
* 织入执行前函数
* @param {*} fn 
*/
Function.prototype.aopBefore = function(fn){
  console.log(this)
  // 第一步：保存原函数的引用
  const _this = this
  // 第四步：返回包括原函数和新函数的“代理”函数
  return function() {
    // 第二步：执行新函数，修正this
    fn.apply(this, arguments)
    // 第三步 执行原函数
    return _this.apply(this, arguments)
  }
}
/**
* 织入执行后函数
* @param {*} fn 
*/
Function.prototype.aopAfter = function (fn) {
  const _this = this
  return function () {
    let current = _this.apply(this,arguments)// 先保存原函数
    fn.apply(this, arguments) // 先执行新函数
    return current
  }
}
/**
* 使用函数
*/
let aopFunc = function() {
  console.log('aop')
}
// 注册切面
aopFunc = aopFunc.aopBefore(() =&amp;gt; {
  console.log('aop before')
}).aopAfter(() =&amp;gt; {
  console.log('aop after')
})
// 真正调用
aopFunc()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;currying柯里化&quot;&gt;## currying（柯里化）&lt;/h2&gt;
&lt;p&gt;关于curring我们首先要聊的是什么是函数柯里化。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;curring又称部分求值。一个curring的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，二十继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数中被真正的需要求值的时候，之前传入的所有参数被一次性用于求值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;生硬的看概念不太好理解，我们来看接下来的例子 我们需要一个函数来计算一年12个月的消费，在每个月月末的时候我们都要计算消费了多少钱。正常代码如下&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 未柯里化的函数计算开销
let totalCost = 0
const cost = function(amount, mounth = '') {
 console.log(`第${mounth}月的花销是${amount}`)
 totalCost += amount
 console.log(`当前总共消费：${totalCost}`)
}
cost(1000, 1) // 第1个月的花销
cost(2000, 2) // 第2个月的花销
// ...
cost(3000, 12) // 第12个月的花销&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结一下不难发现，如果我们要计算一年的总消费，没必要计算12次。只需要在年底执行一次计算就行，接下来我们对这个函数进行部分柯里化的函数帮助我们理解&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 部分柯里化完的函数
const curringPartCost = (function() {
 // 参数列表
 let args = []
 return function (){
   /**
    * 区分计算求值的情况
    * 有参数的情况下进行暂存
    * 无参数的情况下进行计算
    */
   if (arguments.length === 0) {
     let totalCost = 0
     args.forEach(item =&amp;gt; {
       totalCost += item[0]
     })
     console.log(`共消费：${totalCost}`)
     return totalCost
   } else {
     // argumens并不是数组，是一个类数组对象
     let currentArgs = Array.from(arguments)
     args.push(currentArgs)
     console.log(`暂存${arguments[1] ? arguments[1] : '' }月，金额${arguments[0]}`)
   }
 }
})()
curringPartCost(1000,1)
curringPartCost(100,2)
curringPartCost()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们编写一个通用的curring， 以及一个即将被curring的函数。代码如下&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 通用curring函数
const curring = function(fn) {
 let args = []
 return function () {
   if (arguments.length === 0) {
     console.log('curring完毕进行计算总值')
     return fn.apply(this, args)
   } else {
     let currentArgs = Array.from(arguments)[0]
     console.log(`暂存${arguments[1] ? arguments[1] : '' }月，金额${arguments[0]}`)
     args.push(currentArgs)
     // 返回正被执行的 Function 对象，也就是所指定的 Function 对象的正文，这有利于匿名函数的递归或者保证函数的封装性
     return arguments.callee
   }
 }
}
// 求值函数
let costCurring = (function() {
 let totalCost = 0
 return function () {
   for (let i = 0; i &amp;lt; arguments.length; i++) {
     totalCost += arguments[i]
   }
   console.log(`共消费：${totalCost}`)
   return totalCost
 }
})()
// 执行curring化
costCurring = curring(costCurring)
costCurring(2000, 1)
costCurring(2000, 2)
costCurring(9000, 12)
costCurring()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数节流&quot;&gt;## 函数节流&lt;/h2&gt;
&lt;p&gt;JavaScript中的大多数函数都是用户主动触发的，一般情况下是没有性能问题，但是在一些特殊的情况下不是由用户直接控制。容易大量的调用引起性能问题。毕竟DOM操作的代价是非常昂贵的。下面将列举一些这样的场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;window.resise事件。&lt;/li&gt;
&lt;li&gt;mouse, input等事件。&lt;/li&gt;
&lt;li&gt;上传进度&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面通过高阶函数的方式我们来实现函数节流&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
* 节流函数
* @param {*} fn 
* @param {*} interval 
*/
const throttle = function (fn, interval = 500) {
 let timer = null, // 计时器 
     isFirst = true // 是否是第一次调用
 return function () {
   let args = arguments, _me = this
   // 首次调用直接放行
   if (isFirst) {
     fn.apply(_me, args)
     return isFirst = false
   }
   // 存在计时器就拦截
   if (timer) {
     return false
   }
   // 设置timer
   timer = setTimeout(function (){
    console.log(timer)
    window.clearTimeout(timer)
    timer = null
    fn.apply(_me, args)
   }, interval)
 }
}
// 使用节流
window.onresize = throttle(function() {
 console.log('throttle')
},600)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;分时函数&quot;&gt;## 分时函数&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;节流函数为我们提供了一种限制函数被频繁调用的解决方案。下面我们将遇到另外一个问题，某些函数是用户主动调用的，但是由于一些客观的原因，这些操作会严重的影响页面性能，此时我们需要采用另外的方式去解决。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们需要在短时间内才页面中插入大量的DOM节点，那显然会让浏览器吃不消。可能会引起浏览器的假死，所以我们需要进行分时函数，分批插入。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
* 分时函数
* @param {*创建节点需要的数据} list 
* @param {*创建节点逻辑函数} fn 
* @param {*每一批节点的数量} count 
*/
const timeChunk = function(list, fn, count = 1){
 let insertList = [], // 需要临时插入的数据
     timer = null // 计时器
 const start = function(){
   // 对执行函数逐个进行调用
   for (let i = 0; i &amp;lt; Math.min(count, list.length); i++) {
     insertList = list.shift()
     fn(insertList)
   }
 }
 return function(){
   timer = setInterval(() =&amp;gt; {
     if (list.length === 0) {
       return window.clearInterval(timer)
     }
     start()
   },200)
 }
}
// 分时函数测试
const arr = []
for (let i = 0; i &amp;lt; 94; i++) {
 arr.push(i)
}
const renderList = timeChunk(arr, function(data){
 let div =document.createElement('div')
 div.innerHTML = data + 1
 document.body.appendChild(div)
}, 20)
renderList()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;惰性加载函数&quot;&gt;## 惰性加载函数&lt;/h2&gt;
&lt;p&gt;在Web开发中，因为一些浏览器中的差异，一些嗅探工作总是不可避免的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为浏览器的差异性，我们要常常做各种各样的兼容，举一个非常简单常用的例子：在各个浏览器中都能够通用的事件绑定函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常见的写法是这样的：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 常用的事件兼容
const addEvent = function(el, type, handler) {
 if (window.addEventListener) {
   return el.addEventListener(type, handler, false)
 }
 // for IE
 if (window.attachEvent) {
   return el.attachEvent(`on${type}`, handler)
 }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个函数存在一个缺点，它每次执行的时候都会去执行if条件分支。虽然开销不大，但是这明显是多余的，下面我们优化一下， 提前一下嗅探的过程：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const addEventOptimization = (function() {
 if (window.addEventListener) {
   return (el, type, handler) =&amp;gt; {
     el.addEventListener(type, handler, false)
   }
 }
 // for IE
 if (window.attachEvent) {
   return (el, type, handler) =&amp;gt; {
     el.attachEvent(`on${type}`, handler)
   }
 }
})()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就可以在代码加载之前进行一次嗅探，然后返回一个函数。但是如果我们把它放在公共库中不去使用，这就有点多余了。下面我们使用惰性函数去解决这个问题：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 惰性加载函数
let addEventLazy = function(el, type, handler) {
 if (window.addEventListener) {
   // 一旦进入分支，便在函数内部修改函数的实现
   addEventLazy = function(el, type, handler) {
     el.addEventListener(type, handler, false)
   }
 } else if (window.attachEvent) {
   addEventLazy = function(el, type, handler) {
     el.attachEvent(`on${type}`, handler)
   }
 }
 addEventLazy(el, type, handler)
}
addEventLazy(document.getElementById('eventLazy'), 'click', function() {
 console.log('lazy ')
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦进入分支，便在函数内部修改函数的实现，重写之后函数就是我们期望的函数，在下一次进入函数的时候就不再存在条件分支语句。&lt;/p&gt;
&lt;p&gt;总结&lt;br/&gt;该文章主要是读&lt;code&gt;《Javascript设计模式》&lt;/code&gt;的总结。&lt;/p&gt;
&lt;p&gt;转自：https://juejin.im/post/5b8c8a6951882542ee717c86&lt;/p&gt;
</description>
<pubDate>Thu, 06 Sep 2018 06:38:00 +0000</pubDate>
<dc:creator>_枪枪</dc:creator>
<og:description>高阶函数是指至少满足下列条件之一的函数 1：函数可以作为参数被传递 2：函数可以作为返回值输出 高阶函数实现AOP AOP(面向切面编程)的主要作用就是把一些和核心业务逻辑模块无关的功能抽取出来，然后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sheep-sheep/p/9598220.html</dc:identifier>
</item>
<item>
<title>AI应用开发实战 - 手写算式计算器 - UniversalAIPlatform</title>
<link>http://www.cnblogs.com/ms-uap/p/9587879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ms-uap/p/9587879.html</guid>
<description>&lt;h2 id=&quot;识别并计算简单手写数学表达式&quot;&gt;识别并计算简单手写数学表达式&lt;/h2&gt;
&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;了解MNIST数据集&lt;/li&gt;
&lt;li&gt;了解如何扩展数据集&lt;/li&gt;
&lt;li&gt;实现手写算式计算器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文将介绍一例支持识别手写数学表达式并对其进行计算的人工智能应用的开发案例。本文的应用是基于前文&lt;a href=&quot;https://www.cnblogs.com/ms-uap/p/9182530.html&quot;&gt;“手写识别应用入门”&lt;/a&gt;中的基础应用进行扩展实现的。本文将通过这一案例，展示基本的数据整理和扩展人工智能模型的过程，以及介绍如何利用手写输入的特性来简化字符分割的过程。并且本文将演示如何利用Visual Studio Tools for AI进行批量推理，以便利用底层人工智能框架的并行计算，实现推理加速。此外，本文还将对该应用的主要代码逻辑进行分析、讲解。&lt;br/&gt; &lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/ms-uap/p/9182530.html&quot;&gt;“手写识别应用入门”&lt;/a&gt;中，我们介绍了能识别单个手写字母、基于MNIST数据集的人工智能应用，并且在我们的几次试验中，该应用表现良好，能比较准确地将手写的数字图形识别成对应的数字。那么，该应用能不能识别更多种类的手写字符，甚至是同时的出现多个字符呢？这样的情形有很多，比如生活中常见的数学表达式（形如&lt;code&gt;1+2x3&lt;/code&gt;）。这样的复合情形更为常见，也更具现实意义。相比之下，如果一次识别仅能一个手写数字，应用就会有比较大的局限性。&lt;/p&gt;
&lt;p&gt;首先，我们可以尝试一下多个字符同时出现这类情形中最基本的特例，即一次出现两个数字的情况。请启动手写数字识别博客中构建的应用，并在现有的应用里一次写下两个数字，看看识别效果（为了更方便书写及展示效果，我们将前一示例中笔画的宽度由40调整为20。可以体验出这一改动对单个数字的识别并无大的影响）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201809/700062-20180904185853576-20183789.png&quot; alt=&quot;识别范围只是单个数字&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是一次试验的结果。进行多次试验，我们看到现有应用对两个数字的识别效果不尽人意。&lt;/p&gt;
&lt;p&gt;如上图所示，应用窗口右上角展示的结果准确地反应了模型对我们手写输入的推理结果（即&lt;code&gt;result.First().First().ToString()&lt;/code&gt;），然而这一结果并不像期望的那样，是我们在左侧绘图区写下的“42”。&lt;/p&gt;
&lt;p&gt;其实对这个现象的解释已经蕴含在我们之前的博客内容中了。在&lt;a href=&quot;https://www.cnblogs.com/ms-uap/p/9182530.html&quot;&gt;“手写识别应用入门”&lt;/a&gt;的模型介绍章节中，我们对用于训练模型的MNIST数据集做了大致的介绍。归根结底，上述现象的症结在于：作为我们人工智能应用核心的模型，本身并不具备识别多个数字的能力——作为模型的源头，也即是训练数据的MNIST数据集只覆盖了单个的手写数字。并且，在应用的输入处理部分，我们并未对笔迹图形作额外的处理。&lt;/p&gt;
&lt;p&gt;这两点的综合结果就是，在写下多个数字的情况下，我们实际上在“强行”让AI模型做超出其适应性范围的推理。这属于AI模型的误用。其结果自然难以令人满意。&lt;/p&gt;
&lt;p&gt;那么，为了增强应用的可用性，我们能不能改善这款应用，让其能处理常见的数学表达式呢？这要求我们的应用既能识别数字和符号，又能识别同时出现的多个字符：首先对于多个数字这种情况，我们很自然地想到，既然MNIST模型已经能很好地识别单个数字，那我们只需要把多个数字分开，一个一个地让MNIST模型进行识别就好了；对于识别其他数学符号，我们可以尝试通过扩展MNIST模型的识别范围，也即扩展MNIST数据集来实现。两者合二为一，就是一种非常可行的解决方案。这样，我们就引入了两个新的子问题，即“扩充MNIST数据集”和“多个手写字符的分割”。&lt;/p&gt;
&lt;p&gt;结合上文陈述的问题和潜在的解决方案，本文将以“识别并计算简单的数学表达式”这一问题为导向，对现有的手写数字识别应用进行扩展。&lt;/p&gt;
&lt;p&gt;我们的目标是对克服现存的只能对单个数字进行识别这一局限，让新应用可以识别数字、加减乘除和括号这些能构成简单数学表达式的元素，并对识别出的数学表达式进行计算。本文希望通过这些，能最终获得一款更具现实意义的人工智能应用。&lt;/p&gt;
&lt;p&gt;最终的应用效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201809/700062-20180904185906848-580478385.png&quot; alt=&quot;应用效果&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“识别可能出现的多种字符”和“识别同时出现的多个字符”是完全不同的，请注意区别。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;准备数据&quot;&gt;准备数据&lt;/h2&gt;
&lt;h3 id=&quot;数据格式&quot;&gt;数据格式&lt;/h3&gt;
&lt;p&gt;为了让我们的新模型能支持除了数字以外的字符，一个简单的做法是扩展MNIST数据集并尝试复用已有的模型训练算法（卷积神经网络）。在&lt;a href=&quot;https://www.cnblogs.com/ms-uap/p/9182530.html&quot;&gt;“手写识别应用入门”&lt;/a&gt;的数据预处理章节中，我们部分了解了MNIST数据集所采用的数据格式和规范。为了尽可能地复用已有的资源，我们有必要让扩展的那部分数据贴近原始的MNIST数据。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Microsoft/samples-for-ai/blob/master/examples/tensorflow/MNIST/mnist.py&quot;&gt;Samples-for-ai样例库中使用的MNIST示例&lt;/a&gt;，在初运行时会从&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot; class=&quot;uri&quot;&gt;http://yann.lecun.com/exdb/mnist/&lt;/a&gt;下载MNIST数据集并作为训练数据。当我们顺利运行mnist.py脚本并完成训练后，我们可以在&lt;code&gt;samples-for-ai\examples\tensorflow\MNIST\input&lt;/code&gt;目录中看到四个扩展名为&lt;code&gt;.gz&lt;/code&gt;的文件，这四个文件就是从网上下载下来的MNIST数据集，即手写数字的位图和标记。不过这些文件是经过压缩的数据，我们使用的训练程序在下载完成后还会对这些压缩文件进行解压。训练程序只将解压后的数据储存在内存中，并没有回写到硬盘上，所以我们在input目录下找不到储存了原始位图数据的文件。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;em&gt;小提示&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们仍可以使用支持这种压缩格式的工具将其解压。并使用二进制工具查看其内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot; class=&quot;uri&quot;&gt;http://yann.lecun.com/exdb/mnist/&lt;/a&gt;页面上，我们可以了解到MNIST数据集的位图文件和标签文件的文件格式。其中最主要的，是用于训练的位图都是&lt;code&gt;28x28&lt;/code&gt;尺寸的、单通道的灰度图，前景色（笔画）对应值为255（按颜色表示即是白色），背景色对应值0（按颜色表示即是黑色）。从之前博客中我们已经了解到，MNIST数据集是取反保存位图像素的，如果将其直接显示为位图，则和我们在界面上所见的白底黑字相反。&lt;/p&gt;
&lt;p&gt;结合页面上的描述和&lt;code&gt;mnist.py&lt;/code&gt;中数据预处理部分的相关逻辑，我们了解到目前使用的卷积神经网络要求的最终的输入数据格式如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;strong&gt;四维数组&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;一维数组&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;第一维大小为输入的图片总数；&lt;br/&gt;第二维、第三维大小为输入位图的宽高，此处皆为28；&lt;br/&gt;第四维大小为输入位图的颜色通道数，MNIST只使用灰度图片，故为1。&lt;/td&gt;
&lt;td&gt;大小为输入的图片总数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;每个元素（在第四维）都是32位浮点数。取值大于等于-0.5，小于等于0.5。其中0.5表示前景像素的最大值，-0.5表示背景像素的最大值。&lt;/td&gt;
&lt;td&gt;每个元素都是64位整数。取值0-9，分别代表对应的手写0-9的数字。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;根据上述的输入格式，我们已经可以确定我们扩展训练数据的方向了。这里我们需要注意，这些格式是最终输入到卷积神经网络的数据必须满足的，而非我们即将搜集、准备的新数据。虽然这表明了我们新搜集的数据不一定要精确地满足这些条件，这些输入格式仍然对我们的数据搜集起到重要的指导作用。&lt;/p&gt;
&lt;h3 id=&quot;收集并格式化数据&quot;&gt;收集并格式化数据&lt;/h3&gt;
&lt;p&gt;搜集数据的方式多种多样。就本文的需要来说，我们可以在网络上搜索已有的数据集，可以自行开发小型应用以在触摸屏甚至手机上搜集手写图形，或者扫描手写文档并通过图像分割的方式提取运算符。并且，在搜集完原始数据之后，我们还可以通过缩放、扭曲、添加噪点等方式来扩展、增强我们的数据集，以获得更广泛的适应性。&lt;/p&gt;
&lt;p&gt;在我们搜集足够多的新图片后（考虑到原始MNIST数据集共70000张图片，我们搜集40000张左右比较合适，虽然数量不是绝对的），我们还需要对其进行一定的格式化，以方便我们最终将其作为神经网络的输入。&lt;/p&gt;
&lt;p&gt;位图部分所需的处理非常直观。我们可以参考前一篇手写数字识别博客中对应用图形界面上捕获的手写图形的处理方式，将搜集的图片（可能具有RGB通道）转换成&lt;strong&gt;28x28像素的、单通道的灰度图片，并且前景色（即笔画）色值为0（黑色），背景色色值为255（白色）&lt;/strong&gt;。符合要求的位图样例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201809/700062-20180904185918687-118588812.png&quot; alt=&quot;合适的位图示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此处更需要注意的是对图片标记的处理。在原始MNIST数据集中我们看到整数0-9被用来标记对应的图形，这是非常自然的做法。因为我们此处要解决的是多分类问题，解决这类问题的一个先决条件就是我们必须为每个分类提供一一对应的标记。我们很容易就想到用诸如10、11、12来标记加号、减号、乘号等图形类别。这是可行的。&lt;/p&gt;
&lt;p&gt;此处我们不由得思考，延续已被占用的自然数取标记新类别，虽然可行，但让对应关系变得混乱了。10和加号、11和减号之间，并不像0-9的整数和图形之间有那么自然的联系。作为开发者的我们不禁想到，能否用ASCII表里加减乘除的字符对应的数值来做标记呢（如加号对应53，减号对应55）？这种标记的设定方法实际上是很难使用的，特别是本文中出现的MNIST训练程序基于的是TensorFlow框架，框架本身要求了标记占用的整数值必须小于类别总数。在保证标记和类别一一对应的前提条件下，我们接着已有0-9标记，再为我们新搜集的图形类别增加标记。此时我们需要清楚的定义标记到类别的对应关系，以便我们正确处理模型的输入和输出。&lt;/p&gt;
&lt;p&gt;我们用10-15分别表示加号、减号、乘号、除号、正括号、反括号。并且，为了便于训练，我们要求这六种数学符号对应的位图，分别放置于&lt;code&gt;add、minus、mul、div、lp、rp&lt;/code&gt;这六个文件夹中，并且这六个文件夹需要在同一个目录下。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201809/700062-20180904185926660-849514944.png&quot; alt=&quot;需要的六个文件夹&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;训练模型&quot;&gt;训练模型&lt;/h2&gt;
&lt;p&gt;为了支持我们新增的六种数学符号，我们需要修改原始的MNIST模型训练脚本（即之前所用的&lt;code&gt;mnist.py&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;训练模型所需的Python脚本，可以在这里找到：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MS-UAP/edu/tree/master/AI301/self-built_mnist_extenstion&quot; class=&quot;uri&quot;&gt;https://github.com/MS-UAP/edu/tree/master/AI301/self-built_mnist_extenstion&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一仓库中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在&lt;code&gt;./tensorflow_model/&lt;/code&gt;路径下，是支持扩展的MNIST数据集的训练脚本&lt;code&gt;mnist_extension.py&lt;/code&gt;。这一脚本要求额外的命令行参数&lt;code&gt;--extension_dir&lt;/code&gt;，用于指定我们扩展的六种数学符号的位图所在；&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;./extended_mnist_calculator/MNIST.App&lt;/code&gt;目录下，是本文这款应用的主体代码。我们会在下文中用到。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上文中，我们要求新搜集的数据最后需要被格式化为以色值0（黑色）为前景色，以色值255（白色）为前景色的单通道位图。我们修改后的训练脚本会读取这些位图并其反色，以到达和原始MNIST数据同样的效果（也和我们应用中输入处理的部分一致）。&lt;br/&gt;假设我们存放&lt;code&gt;add、minus&lt;/code&gt;等六个文件夹的目录是&lt;code&gt;D:\extension_images&lt;/code&gt;，我们就可以在克隆好了的仓库的&lt;code&gt;/training&lt;/code&gt;目录下，通过命令行执行：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;python mnist_extension.py --extension_dir D:\extension_images&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来启动针对包含了六种数学符号的扩展数据集的训练。该训练脚本在导入原始MNIST数据之后，还会从&lt;code&gt;D:\extension_images&lt;/code&gt;目录分别读取六种新类别的数据。再混合新旧数据之后进行训练。可能的训练结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201809/700062-20180904185932982-841582673.png&quot; alt=&quot;训练结果&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;em&gt;小提示&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;混合新旧数据在这里非常有用。因为训练过程中，目前的脚本是一次仅将一部分数据用于迭代优化和模型参数更新。如果不进行混合，就会发生新数据迟迟不被利用的情况，影响模型的训练结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们对MNIST模型的训练是基于卷积神经网络的。并且上本中的脚本在处理扩展的符号位图之外，并没有对用于训练原始MNIST模型的卷积神经网络的结构进行修改。我们知道系统的结构决定其功能，那么我们针对原始MNIST数据设计的网络结构能否支撑扩展后的数据集呢？对这一问题最简单的回答就是进行一次训练并观察模型性能。&lt;/p&gt;
&lt;p&gt;用这种方法进行试验后，我们通过错误率（主要是Validation error，在此例中反映了每100次小批量训练之后，模型当前在整个验证集上的错误率；和Test error，在此例中反映了训练结束后模型在整个测试集上的错误率）发现新模型的性能还是不错的。足以支持我们接下来的应用。&lt;/p&gt;

&lt;p&gt;如上文所述，我们为了对多个同时出现的字符进行识别，还必须解决一个子问题，那就是要对这些同时出现的字符进行分割。&lt;/p&gt;
&lt;p&gt;我们注意到本文介绍的应用有一个特点，那就是最终用作输入的图形，是用户当场写下的，而非通过图片文件导入的静态图片。也就是说，我们拥有笔画产生过程中的全部动态信息，比如笔画的先后顺序，笔画的重叠关系等等。而且我们期望这些笔画基本都是横向书写的。考虑到这些信息，我们可以设计一种基本的分割规则：在水平面上的投影相重叠的笔画，我们就认为它们同属于一个数字。&lt;/p&gt;
&lt;p&gt;笔画和水平方向上投影的关系示意如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201809/700062-20180904185940543-624459684.png&quot; alt=&quot;投影示意图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此书写时，就要求不同的数字之间尽量隔开。当然为了尽可能处理不经意的重叠，我们还可以为重叠部分相对每一笔画的位置设定一个阈值，如至少进入笔画一端的10%以内。&lt;/p&gt;
&lt;p&gt;加入对重叠的容忍阈值后，对笔画的分割的结果可以参看下图。在分割后被认为是属于同一字符的笔画我们使用了相同的颜色绘制，并且用不同的颜色区分了不属于同一字符的笔画。在字符的上方，我们用一系列水平方向的半透明色块表现了每一笔画在水平方向上的的有效重叠区域和字符之间的重叠关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201809/700062-20180904185945774-867278079.png&quot; alt=&quot;分组示意图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用这样的规则后，我们就能简便而又有效地对多个笔画进行分割，并能利用Visual Studio Tools for AI提供的批量推理功能，一次性对所有分割出的图形做推理。&lt;/p&gt;

&lt;h2 id=&quot;完成应用&quot;&gt;完成应用&lt;/h2&gt;
&lt;p&gt;同&lt;a href=&quot;https://www.cnblogs.com/ms-uap/p/9182530.html&quot;&gt;“手写识别应用入门”&lt;/a&gt;类似，我们还是先于GitHub克隆主体的应用代码，再加以引用模型来完成本文中这款应用。&lt;/p&gt;
&lt;p&gt;按照训练模型一节中所述，获取上面提到的Git仓库后，我们可以通过Visual Studio打开&lt;code&gt;./extended_mnist_calculator&lt;/code&gt;目录下的MnistDemo.sln解决方案，并和之前一样，在解决方案里添加AI Tools – Inference模型项目。不过与上一博客稍有不同的是，为了对我们扩展的新模型加以区分，我们需要将新模型项目命名为&lt;strong&gt;ExtendedModel&lt;/strong&gt;（同时也是默认的命名空间名字），并将新的模型包装类命名为&lt;code&gt;MnistExtension&lt;/code&gt;。并且这一次，在模型项目创建向导中，我们需要选择上文中训练出的新模型。&lt;/p&gt;
&lt;p&gt;新的Inference模型项目和模型包装类配置如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201809/700062-20180904185952165-1404566144.png&quot; alt=&quot;Inference项目&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201809/700062-20180904185958214-1150185299.png&quot; alt=&quot;Inference向导&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;理解代码&quot;&gt;理解代码&lt;/h2&gt;
&lt;h3 id=&quot;输入处理&quot;&gt;输入处理&lt;/h3&gt;
&lt;p&gt;在新应用的代码部分，和我们在手写数字识别博客中介绍的代码比起来，差别最大的地方就在于如何处理输入。在上个案例中，我们只需要简单地将正方形区域中的图像格式调整一下，即可用作MNIST模型的输入。而在本文的案例中，我们必须先对笔画进行分割处理。分割笔画之后我们再将每一个笔画组合转换成MNIST模型所需的单个输入。&lt;/p&gt;
&lt;p&gt;新应用需要响应的界面事件，还是和之前一致：需要响应鼠标的按下、移动和抬起三类事件。我们对其中按下和移动的响应事件的修改比较简单，我们只需要在这些响应时间里对新写下的笔画做记录就好了。&lt;/p&gt;
&lt;h4 id=&quot;记录笔画的产生过程&quot;&gt;记录笔画的产生过程&lt;/h4&gt;
&lt;p&gt;首先我们为窗体类新增一个&lt;code&gt;List&amp;lt;Point&amp;gt;&lt;/code&gt;类型的字段，用于记录每次鼠标按下、抬起之间鼠标移动过的点，将这些点按顺序连接起来就形成了一道笔画。我们在鼠标按下事件里清空以前记录的所有鼠标移动点，以便记录这次书写产生的新一动点；并在鼠标抬起事件里将这些点转换成笔画对应的数据结构&lt;code&gt;StrokeRecord&lt;/code&gt;（定义见后文）。同样的，我们也为窗体类新增一个&lt;code&gt;List&amp;lt;StrokeRecord&amp;gt;&lt;/code&gt;类型的字段，用于记录已经写下的所有笔画。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;private List&amp;lt;Point&amp;gt; strokePoints = new List&amp;lt;Point&amp;gt;();
private List&amp;lt;StrokeRecord&amp;gt; allStrokes = new List&amp;lt;StrokeRecord&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;writeArea_MouseDown&lt;/code&gt;方法中新增以下语句用于清空以前记录的鼠标移动点：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;strokePoints.Clear();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并在&lt;code&gt;writeArea_MouseMove&lt;/code&gt;方法中记录鼠标这次移动所到达的点：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;strokePoints.Add(e.Location);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;writeArea_MouseUp&lt;/code&gt;方法里将这次鼠标按下、抬起之间产生的所有点转换成笔画对应的数据结构。并且因为如果鼠标在抬起之前并没有移动，就不会有点被记录，在这之前我们还通过&lt;code&gt;strokePoints.Any()&lt;/code&gt;先判断一下是否有点被记录。下面是转化移动点的代码：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var thisStrokeRecord = new StrokeRecord(strokePoints);
allStrokes.Add(thisStrokeRecord);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;包括构造函数在内的StrokeRecord结构定义如下：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 用于记录历史笔画信息的数据结构。
/// &amp;lt;/summary&amp;gt;
class StrokeRecord
{
    public StrokeRecord(List&amp;lt;Point&amp;gt; strokePoints)
    {
        // 拷贝所有Point以避免列表在外部被修改。
        Points = new List&amp;lt;Point&amp;gt;(strokePoints);

        HorizontalStart = Points.Min(pt =&amp;gt; pt.X);
        HorizontalEnd = Points.Max(pt =&amp;gt; pt.X);
        HorizontalLength = HorizontalEnd - HorizontalStart;

        OverlayMaxStart = HorizontalStart + (int)(HorizontalLength * (1 - ProjectionOverlayRatioThreshold));
        OverlayMinEnd = HorizontalStart + (int)(HorizontalLength * ProjectionOverlayRatioThreshold);
    }

    /// &amp;lt;summary&amp;gt;
    /// 构成这一笔画的点。
    /// &amp;lt;/summary&amp;gt;
    public List&amp;lt;Point&amp;gt; Points { get; }

    /// &amp;lt;summary&amp;gt;
    /// 这一笔画在水平方向上的起点。
    /// &amp;lt;/summary&amp;gt;
    public int HorizontalStart { get; }

    /// &amp;lt;summary&amp;gt;
    /// 这一笔画在水平方向上的终点。
    /// &amp;lt;/summary&amp;gt;
    public int HorizontalEnd { get; }

    /// &amp;lt;summary&amp;gt;
    /// 这一笔画在水平方向上的长度。
    /// &amp;lt;/summary&amp;gt;
    public int HorizontalLength { get; }

    /// &amp;lt;summary&amp;gt;
    /// 另一笔画必须越过这些阈值点，才被认为和这一笔画重合。
    /// &amp;lt;/summary&amp;gt;
    public int OverlayMaxStart { get; }
    public int OverlayMinEnd { get; }

    private bool CheckPosition(StrokeRecord other)
    {
        return (other.HorizontalStart &amp;lt; OverlayMaxStart) || (OverlayMinEnd &amp;lt; other.HorizontalEnd);
    }

    /// &amp;lt;summary&amp;gt;
    /// 检查另一笔画是否和这一笔画重叠。
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;other&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public bool OverlayWith(StrokeRecord other)
    {
        return this.CheckPosition(other) || other.CheckPosition(this);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;分割笔画&quot;&gt;分割笔画&lt;/h4&gt;
&lt;p&gt;在将新产生的笔画添加到所有笔画的列表中之后，我们就有了当前用户写下的所有笔画了，接下来我们要对这些笔画进行分组。&lt;/p&gt;
&lt;p&gt;本文在这里对上文所述的“快速”分割的实现非常简单。在按笔画在水平方向上最左端的坐标，将笔画有小到大排序后，我们从最左边开始扫描所有笔画。如果一个笔画还没有分组，我们就为它指定唯一分组编号，然后再看其右侧有哪些笔画和当前笔画在水平方向上的投影是有效重合的（如上文所述，此处有阈值10%），并将这些重合的笔画定为属于同一组。直到所有笔画都被扫描。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;allStrokes = allStrokes.OrderBy(s =&amp;gt; s.HorizontalStart).ToList();
int[] strokeGroupIds = new int[allStrokes.Count];
int nextGroupId = 1;

for (int i = 0; i &amp;lt; allStrokes.Count; i++)
{
    // 为了避免水平方向太多笔画被连在一起，我们采取一种简单的办法：
    // 当1、2笔画重叠时，我们就不会在检查笔画2和更右侧笔画是否重叠。
    if (strokeGroupIds[i] != 0)
    {
        continue;
    }

    strokeGroupIds[i] = nextGroupId;
    nextGroupId++;

    var s1 = allStrokes[i];
    for (int j = 1; i + j &amp;lt; allStrokes.Count; j++)
    {
        var s2 = allStrokes[i + j];

        if (s2.HorizontalStart &amp;lt; s1.OverlayMaxStart) // 先判断临界条件（阈值10%）
        {
            if (strokeGroupIds[i + j] == 0)
            {
                if (s1.OverlayWith(s2)) // 在考虑阈值的条件下做完整地判断重合
                {
                    strokeGroupIds[i + j] = strokeGroupIds[i];
                }
            }
        }
        else
        {
            break;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后即可按对应的分组编号将笔画归组：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;List&amp;lt;IGrouping&amp;lt;int, StrokeRecord&amp;gt;&amp;gt; groups = allStrokes
    .Zip(strokeGroupIds, Tuple.Create)
    .GroupBy(tuple =&amp;gt; tuple.Item2, tuple =&amp;gt; tuple.Item1) // Item2是分组编号, Item1是StrokeRecord
    .ToList();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;em&gt;小提示&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;为了方便理解笔画的分割效果，应用界面上预留了“显示笔画分组”的开关。勾选之后写下的笔画会像上文那样被不同的颜色标记出其所在的分组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;为每个分组生成单一位图&quot;&gt;为每个分组生成单一位图&lt;/h4&gt;
&lt;p&gt;分割完成后，我们得到了一个数组&lt;code&gt;groups&lt;/code&gt;，它的每个元素都是一个分组，包括了分组编号和组内的所有笔画。这里我们得到的每一个分组都对应着一个字符。如果分组里有多个笔画，那么这些笔画就是这个字符的组成部分（想象加号和乘号，它们都需要两笔才能写成）。我们可以想到，这个数组&lt;code&gt;groups&lt;/code&gt;里的元素的顺序是很重要的，因为我们要保证最终识别出的表达式里的字符的顺序，才能正确地计算表达式。&lt;/p&gt;
&lt;p&gt;我们在循环中顺序访问&lt;code&gt;groups&lt;/code&gt;的每个元素。命名循环变量为&lt;code&gt;group&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;foreach (IGrouping&amp;lt;int, StrokeRecord&amp;gt; group in groups)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;循环变量&lt;code&gt;group&lt;/code&gt;的类型是&lt;code&gt;IGrouping&amp;lt;int, StrokeRecord&amp;gt;&lt;/code&gt;，它代表着一个分组，包括分组的编号（一个整数）和其中的元素（元素都是&lt;code&gt;StrokeRecord&lt;/code&gt;）。&lt;code&gt;IGrouping&amp;lt;TKey, TElement&amp;gt;&lt;/code&gt;泛型接口同时也是一个可迭代的&lt;code&gt;IEnumerable&amp;lt;TElement&amp;gt;&lt;/code&gt;泛型接口，所以我们可以把&lt;code&gt;group&lt;/code&gt;变量直接当做&lt;code&gt;IEnumerable&amp;lt;StrokeRecord&amp;gt;&lt;/code&gt;类型的对象来使用。&lt;/p&gt;
&lt;p&gt;然后我们需要确定这个分组（即其中所有笔画组合成的图形）的位置区域，其中我们最关心水平方向上最左端、最右端的坐标（水平方向的坐标轴是从左向右的）。&lt;/p&gt;
&lt;p&gt;通过这两个坐标我们就能确定该分组在水平方向上的投影的长度。我们计算这个长度的目的，是为了在我们为每个分组生成单一位图时，尽量将这个分组的图形放置在单一位图的中间位置。虽然我们还是先创建一个大尺寸的正方形位图（边长为绘图区高度），但是分割后的图形在这个正方形区域上不再具有天然的位置。下面的代码进行了这些位置的计算，和居中该分组所需的水平方向的偏移量的计算：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var groupedStrokes = group.ToList(); // IGrouping&amp;lt;TKey, TElement&amp;gt;本质上也是一个可迭代的IEnumerable&amp;lt;TElement&amp;gt;

// 确定整个分组的所有笔画的范围。
int grpHorizontalStart = groupedStrokes.Min(s =&amp;gt; s.HorizontalStart);
int grpHorizontalEnd = groupedStrokes.Max(s =&amp;gt; s.HorizontalEnd);
int grpHorizontalLength = grpHorizontalEnd - grpHorizontalStart;

int canvasEdgeLen = writeArea.Height;
Bitmap canvas = new Bitmap(canvasEdgeLen, canvasEdgeLen);
Graphics canvasGraphics = Graphics.FromImage(canvas);
canvasGraphics.Clear(Color.White);

// 因为我们提取了每个笔画，就不能把长方形的绘图区直接当做输入了。
// 这里我们把宽度小于 writeArea.Height 的分组在 canvas 内居中。
int halfOffsetX = Math.Max(canvasEdgeLen - grpHorizontalLength, 0) / 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后我们就在新创建出的位图上绘制当前分组内的笔画了（通过&lt;code&gt;canvasGraphics&lt;/code&gt;对象进行绘制）：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;foreach (var stroke in groupedStrokes)
{
    Point startPoint = stroke.Points[0];
    foreach (var point in stroke.Points.Skip(1))
    {
        var from = startPoint;
        var to = point;

        // 因为每个分组都是在长方形的绘图区被记录的，所以在单一位图上，需要先减去相对于长方形绘图区的偏移量 grpHorizontalStart
        from.X = from.X - grpHorizontalStart + halfOffsetX;
        to.X = to.X - grpHorizontalStart + halfOffsetX;
        canvasGraphics.DrawLine(penStyle, from, to);

        startPoint = point;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;批量推理&quot;&gt;批量推理&lt;/h3&gt;
&lt;p&gt;在新应用中，我们一次需要识别多个字符。而以前我们一次只需要识别一个字符，哪怕我们每次都为了识别一个字符调用了一次模型的推理方法（&lt;code&gt;model.Infer(...)&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;不过我们现在已经准备好了多组数据，这使得我们有机会利用底层AI框架的并行处理能力，来加速我们的推理过程，还省去了手动处理多线程的麻烦。在这里我们采用Visual Studio Tools for AI提供的批量推理功能，一次对所有数据进行推理并得到全部结果。&lt;/p&gt;
&lt;p&gt;首先我们在为所得分组创建位图之前，需要先创建一个用于储存所有数据的动态数组：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var batchInferInput = new List&amp;lt;IEnumerable&amp;lt;float&amp;gt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在处理所有分组的循环内部，处理完每个分组后，我们需要将该分组对应的像素数据暂时存放在动态数组&lt;code&gt;batchInferInput&lt;/code&gt;中：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;// 1. 将分割出的笔画图片缩小至 28 x 28，与训练数据格式一致。
Bitmap clonedBmp = new Bitmap(canvas, ImageSize, ImageSize);

var image = new List&amp;lt;float&amp;gt;(ImageSize * ImageSize);
for (var x = 0; x &amp;lt; ImageSize; x++)
{
    for (var y = 0; y &amp;lt; ImageSize; y++)
    {
        var color = clonedBmp.GetPixel(y, x);
        image.Add((float)(0.5 - (color.R + color.G + color.B) / (3.0 * 255)));
    }
}

// 将这一组笔画对应的矩阵保存下来，以备批量推理。
batchInferInput.Add(image);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我们对每个分组的处理，都和以前对整个正方形绘图区的像素的处理，是完全一致的。唯一的不同是在以前的应用代码中，&lt;code&gt;List&amp;lt;IEnumerable&amp;lt;float&amp;gt;&amp;gt;&lt;/code&gt;类型的数组（在上文中为&lt;code&gt;batchInferInput&lt;/code&gt;变量）仅有一个元素，就是唯一一张位图的像素数据。而在本文中这个数组可能有很多元素，每个元素都是一组位图数据。对这样的位图数据集合进行批量推理后，得到的结果（即&lt;code&gt;inferResult&lt;/code&gt;变量）是一个可枚举的类型，我们叫它“第一层枚举”。第一层枚举得到的每个元素也是一个可枚举类型，我们叫它“第二层枚举”。&lt;/p&gt;
&lt;p&gt;第一层枚举中的每个元素都对应着一组位图数据的推理结果。同时第一层枚举也是对应着批量推理的输入数组，枚举的结果总数和输入数组的长度相同。对于第二层枚举，由于我们的推理结果只是一个整数，所以第二层枚举总是只有一个元素。我们可以通过&lt;code&gt;.First()&lt;/code&gt;将其取出。这里我们可以看到，在以前的应用代码里，我们通过&lt;code&gt;inferResult.First().First()&lt;/code&gt;取出了唯一的结果，而在这里我们则需要考虑批量推理结果的二维结构。&lt;/p&gt;
&lt;p&gt;进行推理的代码如下：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;// 2. 进行批量推理
//    batchInferInput 是一个列表，它的每个元素都是一次推量的输入。
IEnumerable&amp;lt;IEnumerable&amp;lt;long&amp;gt;&amp;gt; inferResult = model.Infer(batchInferInput);

//    推量的结果是一个可枚举对象，它的每个元素代表了批量推理中一次推理的结果。我们用 仅一次.First() 将它们的结果都取出来，并格式化。
outputText.Text = string.Join(&quot;&quot;, inferResult.Select(singleResult =&amp;gt; singleResult.First().ToString()));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;计算表达式&quot;&gt;计算表达式&lt;/h3&gt;
&lt;p&gt;至此，我们对于多个手写字符的识别就完成了。我们已经得到了可以表示用户手写图形的、易于计算机程序处理的字符串。接下来我们开始对字符串记载的数学表达式进行计算。&lt;/p&gt;
&lt;p&gt;本文需要计算的数学表达式的格式，由上文的数据准备和模型训练部分可知，是相对简单的。其中只涉及数字0-9、加减乘除和小括号。对这样的表达式进行求值，是一种非常典型的问题。因为这样的数学表达式有非常清晰、确定的语法规则，对其最直观的处理方法，就是先根据其语法进行解析，构造语法树后进行求值即可。或者，因为这种问题非常经典，我们也可以寻找已有的组件来解决这个问题。&lt;/p&gt;
&lt;p&gt;本文直接复用&lt;code&gt;System.Data.DataTable&lt;/code&gt;类提供的&lt;code&gt;Compute&lt;/code&gt;方法来进行表达式的计算。这个方法完全支持本文案例中出现的表达式语法。&lt;/p&gt;
&lt;p&gt;因为表达式的计算这部分逻辑边界非常清晰，我们引入一个独立的方法来获取最后的结果：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;string EvaluateAndFormatExpression(List&amp;lt;int&amp;gt; recognizedLabels)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;EvaluateAndFormatExpression&lt;/code&gt;方法接受一个标签序列，其中我们仍在用整数10-15来表示各种数学符号。在这个方法内我们对字符标签做两种映射，分别将标签序列转换成用于输入到计算器进行求值的，和用于在用户界面上展示的。&lt;code&gt;EvaluateAndFormatExpression&lt;/code&gt;方法的返回结果形如“(3+2)÷2=2.5”。其中各种符号皆采用传统的数学写法。该方法的实现如下：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;private string EvaluateAndFormatExpression(List&amp;lt;int&amp;gt; recognizedLabels)
{
    string[] operatorsToEval = { &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;(&quot;, &quot;)&quot; };
    string[] operatorsToDisplay = { &quot;+&quot;, &quot;-&quot;, &quot;×&quot;, &quot;÷&quot;, &quot;(&quot;, &quot;)&quot; };

    string toEval = string.Join(&quot;&quot;, recognizedLabels.Select(label =&amp;gt;
    {
        if (0 &amp;lt;= label &amp;amp;&amp;amp; label &amp;lt;= 9)
        {
            return label.ToString();
        }

        return operatorsToEval[label - 10];
    }));

    var evalResult = new DataTable().Compute(toEval, null);
    if (evalResult is DBNull)
    {
        return &quot;Error&quot;;
    }
    else
    {
        string toDisplay = string.Join(&quot;&quot;, recognizedLabels.Select(label =&amp;gt;
        {
            if (0 &amp;lt;= label &amp;amp;&amp;amp; label &amp;lt;= 9)
            {
                return label.ToString();
            }

            return operatorsToDisplay[label - 10];
        }));

        return $&quot;{toDisplay}={evalResult}&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时需要注意的是，根据表达式求值方案的不同，我们可能需要对表达式中的字符进行对应的调整。比如当我们希望在用户界面上将除号显示为更可读的“÷”时，我们采用的求值方案可能并不支持这种除号，而只支持C#语言中的除号&lt;code&gt;/&lt;/code&gt;。那么我们在将识别出的结果输入到表达式计算器中之前，还需要对识别的结果进行合适的映射。&lt;/p&gt;

&lt;h2 id=&quot;新模型对括号和数字1的识别很差&quot;&gt;新模型对括号和数字1的识别很差&lt;/h2&gt;
&lt;p&gt;这是一种非常容易出现的情况。因为在手写时，正反小括号和数字1极易混淆。这一问题有时会在扩展数据中体现。我们观察到原始MNIST数据集中（参见上文的数据可视化），很多数字1的形状和弯曲程度已经和括号相近。如果我们在扩展数据部分不做明显的区分，并且我们采用的卷积神经网络对这样微小的数据差别不敏感的话，就会导致造型相近的字符被错误识别的情况。&lt;/p&gt;
&lt;p&gt;同理，这样的问题还可能发生在加号和乘号之间。因为加号和乘号的形状基本完全一样，只是靠角度得以区分。如果我们搜集的扩展数据里，这两种符号各自都具有一定的旋转角度，以致角度区分不够明显，这也会导致模型对其识别能力不强的情况出现。&lt;/p&gt;

&lt;p&gt;经过一番扩展，我们的新应用已经具备一些不错的功能，初步满足了现实规格的应用需求。从本文的案例中，我们也能得到关于如何将人工智能和传统的技术手段融合起来，帮助我们更好地解决问题的一些启示。当然，这款新应用仍然不够强大和健壮。对此，我们注意到有这样一些问题仍待解决：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;笔画分割的算法相对比较简单、粗糙，如何提升整体的分割效果，以顺利处理重叠、连笔、噪点等可能情况？&lt;/li&gt;
&lt;li&gt;作为一款计算器应用，本文介绍的新应用具备的特性还是很少。如何增加新的数学计算特性，比如开根号、分数或者更多的数学符号？&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 06 Sep 2018 05:53:00 +0000</pubDate>
<dc:creator>UniversalAIPlatform</dc:creator>
<og:description>扩展手写数字识别应用 === 识别并计算简单手写数学表达式 主要知识点 了解MNIST数据集 了解如何扩展数据集 实现手写算式计算器 简介 本文将介绍一例支持识别手写数学表达式并对其进行计算的人工智能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ms-uap/p/9587879.html</dc:identifier>
</item>
<item>
<title>【原创】分库分表后如何部署上线 - 孤独烟</title>
<link>http://www.cnblogs.com/rjzheng/p/9597810.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rjzheng/p/9597810.html</guid>
<description>&lt;p&gt;最近忙着搬家，所以停更了一段时间，今天给大家补上。&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;我们先来讲一个段子&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;面试官：“有并发的经验没？”&lt;br/&gt;应聘者：“有一点。”&lt;br/&gt;面试官：“那你们为了处理并发，做了哪些优化？”&lt;br/&gt;应聘者：“前后端分离啊，限流啊，分库分表啊。。”&lt;br/&gt;面试官:&quot;谈谈分库分表吧？&quot;&lt;br/&gt;应聘者：“bala。bala。bala。。”&lt;br/&gt;面试官心理活动:这个仁兄讲的怎么这么像网上的博客抄的，容我再问问。&lt;br/&gt;面试官:“你们分库分表后，如何部署上线的？”&lt;br/&gt;应聘者：“这！！！！！！”&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要惊讶，我写这篇文章前，我特意去网上看了下分库分表的文章，很神奇的是，都在讲怎么进行分库分表，却不说分完以后，怎么部署上线的。这样在面试的时候就比较尴尬了。&lt;br/&gt;你们自己摸着良心想一下，如果你真的做过分库分表，你会不知道如何部署的么？因此我们来学习一下如何部署吧。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ps:&lt;/code&gt;我发现一个很神奇的现象。因为很多公司用的技术比较low，那么一些求职者为了提高自己的竞争力，就会将一些高大上的技术写进自己的low项目中。然后呢，他出去面试害怕碰到从这个公司出来的人，毕竟从这个公司出来的人，一定知道自己以前公司的项目情形。因此为了圆谎，他就会说：“他们从事的是这个公司的老项目改造工作，用了很多新技术进去！”&lt;br/&gt;&lt;strong&gt;那么，请你好好思考一下，你们的老系统是如何平滑升级为新系统的！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何部署&quot;&gt;如何部署&lt;/h2&gt;
&lt;h3 id=&quot;停机部署法&quot;&gt;停机部署法&lt;/h3&gt;
&lt;p&gt;大致思路就是，挂一个公告，半夜停机升级，然后半夜把服务停了，跑数据迁移程序，进行数据迁移。&lt;br/&gt;步骤如下:&lt;br/&gt;(1)出一个公告，比如“今晚00:00～6:00进行停机维护，暂停服务”&lt;br/&gt;(2)写一个迁移程序，读&lt;code&gt;db-old&lt;/code&gt;数据库，通过中间件写入新库&lt;code&gt;db-new1&lt;/code&gt;和&lt;code&gt;db-new2&lt;/code&gt;，具体如下图所示&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/rjzheng/1281019/o_bushu1.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;(3)校验迁移前后一致性，没问题就切该部分业务到新库。&lt;/p&gt;
&lt;p&gt;顺便科普一下，这个中间件。现在流行的分库分表的中间件有两种，一种是&lt;code&gt;proxy&lt;/code&gt;形式的，例如&lt;code&gt;mycat&lt;/code&gt;，是需要额外部署一台服务器的。还有一种是&lt;code&gt;client&lt;/code&gt;形式的，例如当当出的&lt;code&gt;Sharding-JDBC&lt;/code&gt;，就是一个jar包，使用起来十分轻便。我个人偏向&lt;code&gt;Sharding-JDBC&lt;/code&gt;，这种方式，无需额外部署，无其他依赖，DBA也无需改变原有的运维方式。&lt;/p&gt;
&lt;p&gt;评价：&lt;br/&gt;大家不要觉得这种方法low，我其实一直觉得这种方法可靠性很强。而且我相信各位读者所在的公司一定不是什么很牛逼的互联网公司，如果你们的产品凌晨1点的用户活跃数还有超过1000的，你们握个爪！毕竟不是所有人都在什么电商公司的，大部分产品半夜都没啥流量。所以此方案，并非没有可取之处。&lt;br/&gt;但是此方案有一个缺点，&lt;strong&gt;累！&lt;/strong&gt;不止身体累，心也累！你想想看，本来定六点结束，你五点把数据库迁移好，但是不知怎么滴，程序切新库就是有点问题。于是，眼瞅着天就要亮了，赶紧把数据库切回老库。第二个晚上继续这么干，简直是身心俱疲。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ps：&lt;/code&gt;这里教大家一些技巧啊，如果你真的没做过分库分表，又想吹一波，涨一下工资，建议答这个方案。因为这个方案比较low，low到没什么东西可以深挖的，所以答这个方案，比较靠谱。&lt;br/&gt;另外，如果面试官的问题是&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;你们怎么进行分库分表的？&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题问的很泛，所以回答这个问题建议自己主动把分表的策略，以及如何部署的方法讲出来。因为这么答，显得严谨一些。&lt;br/&gt;不过，很多面试官为了卖弄自己的技术，喜欢这么问&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;分表有哪些策略啊？你们用哪种啊？&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ok。。这个问题具体指向了分库分表的某个方向了，你不要主动答如何进行部署的。等面试官问你，你再答。如果面试官没问，在面试最后一个环节，面试官会让你问让几个问题。你就问&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;你刚才刚好有提到分库分表的相关问题，我们当时部署的时候，先停机。然后半夜迁移数据，然后第二天将流量切到新库，这种方案太累，不知道贵公司有没有什么更好的方案？&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么这种情况下，面试官会有两种回答。第一种，面试官硬着头皮随便扯。第二种，面试官真的做过，据实回答。记住，面试官怎么回答的不重要。重点的是，你这个问题出去，会给面试官一种错觉:&quot;这个小伙子真的做过分库分表。&quot;&lt;/p&gt;
&lt;p&gt;如果你担心进去了，真派你去做分库分表怎么办？OK，不要怕。我赌你试用期碰不到这个活。因为能进行分库分表，必定对业务非常熟。还在试用期的你，必定对业务不熟，如果领导给你这种活，我只能说他有一颗大心脏。&lt;/p&gt;
&lt;p&gt;ok，指点到这里。面试本来就是一场斗智斗勇的过程，扯远了，回到我们的主题。&lt;/p&gt;
&lt;h3 id=&quot;双写部署法一&quot;&gt;双写部署法(一)&lt;/h3&gt;
&lt;p&gt;这个就是不停机部署法，这里我需要先引进两个概念:&lt;strong&gt;历史数据&lt;/strong&gt;和&lt;strong&gt;增量数据&lt;/strong&gt;。&lt;br/&gt;假设，我们是对一张叫做&lt;code&gt;test_tb&lt;/code&gt;的表进行拆分，因为你要进行双写，系统里头和&lt;code&gt;test_tb&lt;/code&gt;表有关的业务之前必定会加入一段双写代码，同时往老库和新库中写，然后进行部署，那么&lt;br/&gt;&lt;strong&gt;历史数据&lt;/strong&gt;:在该次部署前，数据库表&lt;code&gt;test_tb&lt;/code&gt;的有关数据，我们称之为历史数据。&lt;br/&gt;&lt;strong&gt;增量数据&lt;/strong&gt;:在该次部署后，数据库表&lt;code&gt;test_tb&lt;/code&gt;的新产生的数据，我们称之为增量数据。&lt;br/&gt;然后迁移流程如下&lt;br/&gt;(1)先计算你要迁移的那张表的&lt;code&gt;max(主键)&lt;/code&gt;。在迁移过程中，只迁移&lt;code&gt;db-old&lt;/code&gt;中&lt;code&gt;test_tb&lt;/code&gt;表里，主键小等于该&lt;code&gt;max(主键)&lt;/code&gt;的值，也就是所谓的历史数据。&lt;br/&gt;这里有特殊情况，如果你的表用的是uuid，没法求出&lt;code&gt;max(主键)&lt;/code&gt;，那就以创建时间作为划分历史数据和增量数据的依据。如果你的表用的是uuid,又没有创建时间这个字段，我相信机智的你，一定有办法区分出历史数据和增量数据。&lt;br/&gt;(2)在代码中，与&lt;code&gt;test_tb&lt;/code&gt;有关的业务，多加一条往消息队列中发消息的代码，将操作的sql发送到消息队列中，至于消息体如何组装，大家自行考虑。&lt;strong&gt;需要注意的是，&lt;/strong&gt;只发写请求的sql，只发写请求的sql，只发写请求的sql。重要的事情说三遍！&lt;br/&gt;原因有二:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1)只有写请求的sql对恢复数据才有用。&lt;/li&gt;
&lt;li&gt;(2)系统中，绝大部分的业务需求是读请求，写请求比较少。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意了，在这个阶段，我们不消费消息队列里的数据。我们只发写请求，消息队列的消息堆积情况不会太严重！&lt;br/&gt;(3)系统上线。另外，写一段迁移程序，迁移&lt;code&gt;db-old&lt;/code&gt;中&lt;code&gt;test_tb&lt;/code&gt;表里，主键小于该&lt;code&gt;max(主键)&lt;/code&gt;的数据，也就是所谓的历史数据。&lt;br/&gt;上面步骤(1)～步骤(3)的过程如下&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/rjzheng/1281019/o_bushu2.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;等到&lt;code&gt;db-old&lt;/code&gt;中的历史数据迁移完毕，则开始迁移增量数据，也就是在消息队列里的数据。&lt;br/&gt;(4)将迁移程序下线，写一段订阅程序订阅消息队列中的数据&lt;br/&gt;(5)订阅程序将订阅到到数据，通过中间件写入新库&lt;br/&gt;(6)新老库一致性验证，去除代码中的双写代码，将涉及到&lt;code&gt;test_tb&lt;/code&gt;表的读写操作，指向新库。&lt;br/&gt;上面步骤(4)～步骤(6)的过程如下&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/rjzheng/1281019/o_bushu3.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里大家可能会有一个问题，在步骤(1)～步骤(3),系统对历史数据进行操作，会造成不一致的问题么？&lt;br/&gt;OK，不会。这里我们对&lt;code&gt;delete&lt;/code&gt;操作和&lt;code&gt;update&lt;/code&gt;操作做分析，因为只有这两个操作才会造成历史数据变动，&lt;code&gt;insert&lt;/code&gt;进去的数据都是属于增量数据。&lt;br/&gt;(1)对&lt;code&gt;db-old&lt;/code&gt;的&lt;code&gt;test_tb&lt;/code&gt;表的历史数据发出&lt;code&gt;delete&lt;/code&gt;操作，数据还未删除，就被迁移程序给迁走了。此时&lt;code&gt;delete&lt;/code&gt;操作在消息队列里还有记录，后期订阅程序订阅到该&lt;code&gt;delete&lt;/code&gt;操作，可以进行删除。&lt;br/&gt;(2)对&lt;code&gt;db-old&lt;/code&gt;的&lt;code&gt;test_tb&lt;/code&gt;表的历史数据发出&lt;code&gt;delete&lt;/code&gt;操作，数据已经删除，迁移程序迁不走该行数据。此时&lt;code&gt;delete&lt;/code&gt;操作在消息队列里还有记录，后期订阅程序订阅到该&lt;code&gt;delete&lt;/code&gt;操作，再执行一次&lt;code&gt;delete&lt;/code&gt;，并不会对一致性有影响。&lt;br/&gt;对&lt;code&gt;update&lt;/code&gt;的操作类似，不赘述。&lt;/p&gt;
&lt;h3 id=&quot;双写部署法二&quot;&gt;双写部署法(二)&lt;/h3&gt;
&lt;p&gt;上面的方法有一个硬伤，注意我有一句话&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;(2)在代码中，与test_tb有关的业务，多加一条往消息队列中发消息的代码，将操作的sql发送到消息队列中，至于消息体如何组装，大家自行考虑。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家想一下，这么做，是不是造成了严重的代码入侵。将非业务代码嵌入业务代码，这么做，后期删代码的时候特别累。&lt;br/&gt;&lt;strong&gt;有没什么方法，可以避免这个问题的?&lt;/strong&gt;&lt;br/&gt;有的，订阅&lt;code&gt;binlog&lt;/code&gt;日志。关于&lt;code&gt;binlog&lt;/code&gt;日志，我尽量下周写一篇《研发应该掌握的binlog知识》，这边我就介绍一下作用&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的二进制日志。binlog不会记录SELECT和SHOW这类操作，因为这类操作对据本身并没有修改。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还记得我们在&lt;strong&gt;双写部署法(一)&lt;/strong&gt;里介绍的，往消息队列里发的消息，都是写操作的消息。而&lt;code&gt;binlog&lt;/code&gt;日志记录的也是写操作。所以订阅该日志，也能满足我们的需求。&lt;br/&gt;于是步骤如下&lt;br/&gt;(1)打开binlog日志，系统正常上线就好&lt;br/&gt;(2)还是写一个迁移程序，迁移历史数据。步骤和上面类似，不啰嗦了。&lt;br/&gt;步骤(1)~步骤(2)流程图如下&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/rjzheng/1281019/o_bushu6.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;(3)写一个订阅程序，订阅binlog(mysql中有&lt;code&gt;canal&lt;/code&gt;。至于oracle中，大家就随缘自己写吧)。然后将订阅到到数据通过中间件，写入新库。&lt;br/&gt;(4)检验一致性，没问题就切库。&lt;br/&gt;步骤(3)~步骤(4)流程图如下&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/rjzheng/1281019/o_bushu5.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;怎么验数据一致性&quot;&gt;怎么验数据一致性&lt;/h3&gt;
&lt;p&gt;这里大概介绍一下吧，这篇的篇幅太长了，大家心里有底就行。&lt;br/&gt;(1)先验数量是否一致，因为验数量比较快。&lt;br/&gt;至于验具体的字段，有两种方法:&lt;br/&gt;(2.1)有一种方法是，只验关键性的几个字段是否一致。&lt;br/&gt;(2.2)还有一种是 ，一次取50条(不一定50条，具体自己定，我只是举例),然后像拼字符串一样，拼在一起。用md5进行加密，得到一串数值。新库一样如法炮制，也得到一串数值，比较两串数值是否一致。如果一致，继续比较下50条数据。如果发现不一致，用二分法确定不一致的数据在0-25条，还是26条-50条。以此类推，找出不一致的数据，进行记录即可。&lt;br/&gt;ok，啰嗦完毕。&lt;/p&gt;
</description>
<pubDate>Thu, 06 Sep 2018 05:33:00 +0000</pubDate>
<dc:creator>孤独烟</dc:creator>
<og:description>最近忙着搬家，所以停更了一段时间，今天给大家补上。 引言 我们先来讲一个段子 面试官：“有并发的经验没？” 应聘者：“有一点。” 面试官：“那你们为了处理并发，做了哪些优化？” 应聘者：“前后端分离啊</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rjzheng/p/9597810.html</dc:identifier>
</item>
<item>
<title>从壹开始前后端分离 [ Vue2.0+.NET Core2.1] 十七 ║Vue基础：使用Vue.js 来画博客首页（一） - 老张的哲学</title>
<link>http://www.cnblogs.com/laozhang-is-phi/p/9593740.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laozhang-is-phi/p/9593740.html</guid>
<description>&lt;p&gt;书说前两篇文章《&lt;a id=&quot;post_title_link_9580807&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9580807.html&quot;&gt; 十五 ║ Vue前篇：JS对象&amp;amp;字面量&amp;amp;this&lt;/a&gt;》和 《&lt;a id=&quot;post_title_link_9585766&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9585766.html&quot;&gt; 十六 ║ Vue前篇：ES6初体验 &amp;amp; 模块化编程&lt;/a&gt;》，已经通过对js面向对象，类和模式封装，ES6新特性等多个角度讲解了Vue入门的一些储备知识，之所以说储备知识，是值，这些内容不会也可以学Vue，但是，如果学的不错，那下一步学习Vue的时候会比较容易，要是能看得懂，写的出来，会修改别人的，嗯！继续大步往前走哈哈，今天呢，终于到了写代码的时候了，这两天一般预习这Vue，一边修改这之前.Net Core 的问题和优化，一直有个心结还是没有接口，望看到这个问题的小哥哥小姐姐能帮忙，《基于AOP的Redis 缓存技术》，嗯名字我都想好了，内容迟迟下不去，看来只能抽时间跪大神去了 [苦笑]，好啦，开始今天的Vue讲解。&lt;/p&gt;
&lt;p&gt; 一言不合就放图系列，今天简单做一个博客首页的列表展示，通过引用Vue.js的方法安装环境，简单的固定数据操作来完成如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180906133527928-458410245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180906130025464-504929234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;1、首先，我们就来认识一下Vue.js，官网中的定义是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过尽可能简单的 API 实现响应式的数据绑定和组合的视图组件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，数据绑定，组件，是整个Vue的核心，而且是响应式的，这个划重点要考（值得注意的是只有当实例被创建时 &lt;code&gt;data&lt;/code&gt; 中存在的属性才是响应式的）。&lt;/p&gt;

&lt;p&gt;2、&lt;strong&gt;数据驱动&lt;/strong&gt;，数据的改变驱动了视图的自动更新，以前我们的写法都是通过js或者Jquery来操作DOM，前两章咱们也说到了，整个页面里都充斥着DOM操作的语法，不仅仅不美观，而且从效率上大大折扣，多次的渲染使得浏览器疲惫不堪。但是vue就不一样，通过ViewModel来控制，只需要我们修改数据，就能控制DOM，进而控制视图View的展示，而且速度很快，嗯！而且再也不用去操作DOM，去找控件选择器了，（还记得那年，页面里为了做事件而添加的各种id或者class），哈哈这就是MVVM思想的实现。&lt;/p&gt;

&lt;p&gt;3、&lt;strong&gt;组件化，&lt;/strong&gt;也是一大核心，通过分离页面，使得整个页面由很多个组件构成，给我们的第一个印象就是，就像我们平时使用到的MVC中的分视图，或者子视图，但是又不一样，虽然组件是一部分，但是却是自己的一个整体，和其他组件相互独立，高内聚低耦合，可以通过自定义标签的形式来使用，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Vue.component(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fruit-select&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {
    template: `&lt;/span&gt;&amp;lt;section&amp;gt;
        &amp;lt;section&amp;gt;
            &amp;lt;section&amp;gt;
                &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
                &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Go&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
                &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/section&amp;gt;
            &amp;lt;ul&amp;gt;
                &amp;lt;li&amp;gt;苹果&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;香蕉&amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/section&amp;gt;
    &amp;lt;/section&amp;gt;&lt;span&gt; `,
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引用组件名，还可以传递参数，以及通讯等等&lt;/span&gt;
&amp;lt;fruit-&lt;span&gt;select&lt;/span&gt;&amp;gt;&amp;lt;/fruit-&lt;span&gt;select&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;1、想要使用，必须要学会安装Vue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里呢，我不想直接用Npm安装一个项目，一般大项目才会用到 NPM 搭建，如果我们只是想在打印一个 Hello Blog ，嗯，或者是一个简单的Html的 todoList 页面，我们可以直接引用vue.js 文件，声明一个全局变量来使用（当然，我们在之后的教程中，会开发一个个人博客系统，里边会有前后台多个页面，那个时候我们再重新搭建我们的工程环境，可以复用今天的样式等，今天就先通过引用一个文件来即可）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vue.js 官网下载地址：&lt;/strong&gt;&lt;a href=&quot;http://vuejs.org/guide/installation.html&quot; target=&quot;_blank&quot;&gt;http://vuejs.org/guide/installation.html&lt;/a&gt;，推荐使用开发版本，因为里边会由很多的错误提示等等，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180906003335076-1899043591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在下来，直接在Html页面里引用就行，今天我就用在线的文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2、开始使用Vue来实例化对象赋值&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

    &amp;lt;title&amp;gt;简易安装 Vue.js&amp;lt;/title&amp;gt;
    &amp;lt;!--引用vue.js在线文件，安装--&amp;gt;
    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;!--定义一个容器 id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;--&amp;gt;
    &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        博客园：{{ name }} &lt;/span&gt;&amp;lt;!--获取变量 name Mustache语法 两个花括号 --&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;script&amp;gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义全局变量vm&lt;/span&gt;
        let vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;el表示element，表示定义在#app这个html标签容器元素内&lt;/span&gt;
&lt;span&gt;            data: {
                name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;老张的哲学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            }
        });
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行代码，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180906111027895-704457466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个 Vue 应用由一个通过 &lt;code&gt;new Vue&lt;/code&gt; 创建的根 Vue 实例，以及可选的嵌套的、可复用的组件树组成。举个例子，一个 todo 应用的组件树可以是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;根实例
└─ TodoList
   ├─ TodoItem
   │  ├─ DeleteTodoButton
   │  └─ EditTodoButton
   └─ TodoListFooter
      ├─ ClearTodosButton
      └─ TodoListStatistics&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们会在下一篇文件中的 &lt;strong&gt;组件系统 &lt;/strong&gt;章节具体展开。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、我们还可以通过控制数据来控制页面内容的展示&lt;/strong&gt;，我们知道，vm就是我们定义的全局变量，如果我们想修改其中的值，我们可以这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
vm.name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello Blog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 &lt;code&gt;$&lt;/code&gt;，以便与用户定义的属性区分开来。
vm.$data.name=&quot;Hello Blog&quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;vm._data.name=&quot;Hello Blog&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;动图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180906112755805-828430236.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;4、不仅如此，我们上边说到了，vue还可以双向数据绑定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改html展示代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        博客园：{{ name }} &lt;/span&gt;&amp;lt;!--获取变量 name--&amp;gt;
        &amp;lt;br /&amp;gt;
        &amp;lt;br /&amp;gt;
        &amp;lt;input v-model=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; &amp;lt;!--v-model是vue的一个指令--&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180906132225969-1886388179.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到我们操作的view控件数据，直接影响到了我们的vm.data，并且又进一步影响到了页面，这个时候我们可以想想，以前我们是怎么用Jquery来操作DOM的，是不是简直不敢相信自己的眼睛！都可以这么直接的操作DOM结构和Data数据，嗯！这个时候我们就可以进一步理解到了，VM 这个监控者在一直干什么了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180906011440020-921998950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;1、v-text 和 v-html 指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;code&gt;v-text&lt;/code&gt; 指令用于更新标签包含的文本，它的作用跟双大括号的效果一样。我们看看它的用法&lt;/p&gt;
&lt;p&gt;两者差不多，但是v-html 可以带样式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
       &amp;lt;p &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; v-text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/p&amp;gt;
       &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; v-html=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authorHtml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/a&amp;gt;

       &lt;span&gt;var&lt;/span&gt; myVueTest = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容器&lt;/span&gt;
&lt;span&gt;            data: {
                author: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;老张的哲学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                authorHtml: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;strong&amp;gt;老张的哲学&amp;lt;/strong&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
              
            },
            methods: {
               
            },
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过计算属性过滤数据&lt;/span&gt;
&lt;span&gt;            computed: {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个明天讲到&lt;/span&gt;
&lt;span&gt;            }
        });    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180906125243097-1540925866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、v-show 指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;v-show&lt;/code&gt; ，用来控制元素的显示/隐藏 ，主要是控制元素的display css属性的。&lt;code&gt;v-show&lt;/code&gt; 指令的取值为true/false，分别对应着显示/隐藏。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nav-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; v-show=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;isShow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
       &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/rss.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;CSDN&amp;lt;/a&amp;gt;
  &amp;lt;/li&amp;gt;

 &amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &lt;span&gt;var&lt;/span&gt; myVueTest1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容器&lt;/span&gt;
&lt;span&gt;            data: {
                author: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;老张的哲学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                authorHtml: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;strong&amp;gt;老张的哲学&amp;lt;/strong&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                isShow: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
            }
        });
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180906125149634-809455645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;3、v-if 、v-else-if、 v-else 指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;code&gt;v-if&lt;/code&gt; 指令的取值也是为true或false，通过一定的条件，它控制元素是否需要被渲染出来，感觉上和上边的 v-show 很相似，请看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
     &amp;lt;div&amp;gt;
        &amp;lt;div v-&lt;span&gt;if&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list.length &amp;gt; 20 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
            MOST
        &lt;/span&gt;&amp;lt;/div&amp;gt;
        &amp;lt;div v-&lt;span&gt;else&lt;/span&gt;-&lt;span&gt;if&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list.length &amp;gt; 6 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
            MORE
        &lt;/span&gt;&amp;lt;/div&amp;gt;
        &amp;lt;div v-&lt;span&gt;else&lt;/span&gt;&amp;gt;&lt;span&gt;
             ALL
        &lt;/span&gt;&amp;lt;/div&amp;gt;
     &amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180906125055278-1544039989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;4、v-for 指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 这个时候，我们就用到了经常用的三大指令之一，列表渲染 &lt;strong&gt;v-for&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候，我们的data中的存放的数据不是个简单的数字或者字符串，而是数组Array类型，这个时候，我们要把数组的元素展示在视图上，就需要用到vue提供的 &lt;code&gt;v-for&lt;/code&gt; 指令，来实现列表的渲染。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
  &amp;lt;ul &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post-list non-style-list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

      &amp;lt;li v-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item in list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post-list-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
          &amp;lt;a :href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'https://www.cnblogs.com/laozhang-is-phi/p/'+ item.id +'.html'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{item.name}}&amp;lt;/a&amp;gt;
          &amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post-list-date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;({{item.date}})&amp;lt;/span&amp;gt;
      &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;

 &amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
     &lt;span&gt;var&lt;/span&gt; myVueTest1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
         el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容器&lt;/span&gt;
&lt;span&gt;         data: {
             author: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;老张的哲学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
             authorHtml: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;strong&amp;gt;老张的哲学&amp;lt;/strong&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
             list: [
                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假数据&lt;/span&gt;
                 { name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Vue前篇：ES6初体验 &amp;amp; 模块化编程&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id: &lt;span&gt;9585766&lt;/span&gt;, date: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年9月5日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                 { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Vue前篇：JS对象&amp;amp;字面量&amp;amp;this&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id: &lt;span&gt;9580807&lt;/span&gt;, date: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年9月4日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                 { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; VUE 计划书 &amp;amp; 我的前后端开发简史&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id: &lt;span&gt;9577805&lt;/span&gt;, date: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年9月3日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                 { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; DTOs 对象映射使用，项目部署Windows+Linux完整版&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id: &lt;span&gt;3800&lt;/span&gt;, date: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年9月1日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                 { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 三种跨域方式比较，DTOs(数据传输对象)初探&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id: &lt;span&gt;4200&lt;/span&gt;, date: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年8月31日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                 { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VUE 计划书 &amp;amp; 我的前后端开发简史&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id: &lt;span&gt;3200&lt;/span&gt;, date: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年9月2日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                 { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VUE 实战预告&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id: &lt;span&gt;3200&lt;/span&gt;, date: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年9月12日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
             ],
             isShow: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
         }
     });
 &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180906125614153-1861219184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;5、代码总结：代码已经上传到Git&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

    &amp;lt;title&amp;gt;个人博客 Vue.js&amp;lt;/title&amp;gt;
    &amp;lt;!--引用 样式文件 --&amp;gt;
    &amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rexo.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &lt;span&gt;&amp;lt;!--引用vue.js在线文件，安装--&amp;gt;&lt;/span&gt;
    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;header&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;div style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-image: url(https://pic.cnblogs.com/avatar/1468246/20180817230353.png); width: 128px; height: 128px; background-size: cover; border-radius: 50%; margin: 0 auto;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;p &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; v-text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/p&amp;gt;&lt;span&gt;//指令v-text&lt;/span&gt;
                &amp;lt;p &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Software Engineer.Currently working &lt;span&gt;in&lt;/span&gt; Microsoft co-operation.&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;nav&amp;gt;
                &amp;lt;ul &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nav&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                    &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nav-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                        &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/laozhang-is-phi/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;博客园&amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;
                    &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nav-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                        &amp;lt;a href=&lt;span&gt;&quot;https://www.jianshu.com/u/94102b59cc2a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;简书&amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;
                    &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nav-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                        &amp;lt;a href=&lt;span&gt;&quot;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;阿里云栖&amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;
                    &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nav-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                        &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/rss.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Git&amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;
                    &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nav-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; v-show=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;isShow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;//指令v-show&lt;/span&gt;
                        &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/rss.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;CSDN&amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;

                &amp;lt;/ul&amp;gt;
            &amp;lt;/nav&amp;gt;
        &amp;lt;/header&amp;gt;
        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;h2 &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;span&amp;gt;About Me&amp;lt;/span&amp;gt;
            &amp;lt;/h2&amp;gt;
            &amp;lt;p&amp;gt;My name &lt;span&gt;is&lt;/span&gt; &amp;lt;span v-html=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;. An amateur programmer who writes code every day and watches movies every day.&amp;lt;/p&amp;gt;
            &amp;lt;h2 &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;span&amp;gt;featured&amp;lt;/span&amp;gt;
            &amp;lt;/h2&amp;gt;
            &amp;lt;ul &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post-list non-style-list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

                &amp;lt;li v-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item in list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post-list-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;//指令 v-for&lt;/span&gt;
                    &amp;lt;a :href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'https://www.cnblogs.com/laozhang-is-phi/p/'+ item.id +'.html'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{item.name}}&amp;lt;/a&amp;gt;
                    &amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post-list-date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;({{item.date}})&amp;lt;/span&amp;gt;
                &amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
            &amp;lt;div&amp;gt;
                &amp;lt;div v-&lt;span&gt;if&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list.length &amp;gt; 20 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;//指令 v-if v-else-if v-else&lt;/span&gt;&lt;span&gt;
                    MOST
                &lt;/span&gt;&amp;lt;/div&amp;gt;
                &amp;lt;div v-&lt;span&gt;else&lt;/span&gt;-&lt;span&gt;if&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list.length &amp;gt; 6 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
                    MORE
                &lt;/span&gt;&amp;lt;/div&amp;gt;
                &amp;lt;div v-&lt;span&gt;else&lt;/span&gt;&amp;gt;&lt;span&gt;
                    ALL
                &lt;/span&gt;&amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;

            &amp;lt;h2 &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;span&amp;gt;Skills&amp;lt;/span&amp;gt;
            &amp;lt;/h2&amp;gt;
            &amp;lt;ul &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;skill-list non-style-list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

                &amp;lt;li v-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(item, key) in list3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post-list-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{item.name}}&amp;lt;/li&amp;gt;

            &amp;lt;/ul&amp;gt;



            &amp;lt;h2 &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;span&amp;gt;Contact&amp;lt;/span&amp;gt;
            &amp;lt;/h2&amp;gt;
            &amp;lt;ul &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;contact-list non-style-list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

                &amp;lt;li&amp;gt;
                    &amp;lt;b &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;twitter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;TWITTER&amp;lt;/b&amp;gt;: &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;@laozhang&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;

                &amp;lt;li&amp;gt;
                    &amp;lt;b &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;weibo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;微博&amp;lt;/b&amp;gt;: &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;@laozhang&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;

                &amp;lt;li&amp;gt;
                    &amp;lt;b &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhihu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;知乎&amp;lt;/b&amp;gt;: &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; v-html=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authorHtml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/a&amp;gt;&lt;span&gt;//指令 v-html&lt;/span&gt;
                &amp;lt;/li&amp;gt;

                &amp;lt;li&amp;gt;
                    &amp;lt;b &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;github&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;GITHUB&amp;lt;/b&amp;gt;: &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://github.com/anjoy8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;anjoy8&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;

                &amp;lt;li&amp;gt;
                    &amp;lt;b &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;EMAIL&amp;lt;/b&amp;gt;: &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mailto:laozhang@azlinli.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;randypriv at azlinli&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;

            &amp;lt;/ul&amp;gt;

        &amp;lt;/div&amp;gt;
        &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;footer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;p&amp;gt;&lt;span&gt;2018&lt;/span&gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;LZ&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s Blog&amp;lt;/a&amp;gt; - Hosted by &amp;lt;a href=&quot;#&quot; style=&quot;font-weight: bold&quot;&amp;gt;Coding Pages&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
            &amp;lt;p&amp;gt;
                &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;京ICP备00000000号&amp;lt;/a&amp;gt;
            &amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layout-bg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容器&lt;/span&gt;
&lt;span&gt;            data: {
                author: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;老张的哲学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                authorHtml: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;strong&amp;gt;老张的哲学&amp;lt;/strong&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                list: [
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假数据&lt;/span&gt;
                    { name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Vue前篇：ES6初体验 &amp;amp; 模块化编程&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id: &lt;span&gt;9585766&lt;/span&gt;, date: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年9月5日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Vue前篇：JS对象&amp;amp;字面量&amp;amp;this&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id: &lt;span&gt;9580807&lt;/span&gt;, date: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年9月4日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; VUE 计划书 &amp;amp; 我的前后端开发简史&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id: &lt;span&gt;9577805&lt;/span&gt;, date: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年9月3日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; DTOs 对象映射使用，项目部署Windows+Linux完整版&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id: &lt;span&gt;3800&lt;/span&gt;, date: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年9月1日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 三种跨域方式比较，DTOs(数据传输对象)初探&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id: &lt;span&gt;4200&lt;/span&gt;, date: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年8月31日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VUE 计划书 &amp;amp; 我的前后端开发简史&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id: &lt;span&gt;3200&lt;/span&gt;, date: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年9月2日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VUE 实战预告&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id: &lt;span&gt;3200&lt;/span&gt;, date: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018年9月12日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                ],
                list3: [
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假数据&lt;/span&gt;
                    { name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Html5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CSS3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JAVASCTIPT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wechat小程序&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASP.NET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                ],
                isShow: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
            },
            methods: {

            },
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过计算属性过滤数据&lt;/span&gt;
&lt;span&gt;            computed: {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个明天讲到&lt;/span&gt;
&lt;span&gt;            }
        });
    &lt;/span&gt;&amp;lt;/script&amp;gt;

    
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;今天就暂时讲到这里，目前呢，咱们的个人博客的首页1.0 在样式上已经差不多，达到了开篇中截图的效果。但是还有很多的还没有说到，明天咱们继续说指令总结 （下） ：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;5、v-bind （ : ）指令&lt;/p&gt;
&lt;p&gt;6、v-on （ @）指令&lt;/p&gt;
&lt;p&gt;7、v-model 指令&lt;/p&gt;
&lt;p&gt;8、v-once 指令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 然后还会说到 &lt;strong&gt;动态绑定class和style 和 过滤器等，&lt;/strong&gt;明天再见哟~~~&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/anjoy8/Blog.Vue&quot; target=&quot;_blank&quot;&gt; https://github.com/anjoy8/Blog.Vue&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 06 Sep 2018 05:12:00 +0000</pubDate>
<dc:creator>老张的哲学</dc:creator>
<og:description>缘起 书说前两篇文章《 十五 ║ Vue前篇：JS对象&amp;字面量&amp;this》和 《 十六 ║ Vue前篇：ES6初体验 &amp; 模块化编程》，已经通过对js面向对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laozhang-is-phi/p/9593740.html</dc:identifier>
</item>
<item>
<title>ldap配置系列三：grafana集成ldap - LinuxPanda</title>
<link>http://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_liunx_51_ldap_for_grafana.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_liunx_51_ldap_for_grafana.html</guid>
<description>&lt;h2&gt;grafana的简介&lt;/h2&gt;
&lt;p&gt; grafana是一个类似kibana的东西，是对来自各种数据源的数据进行实时展示的平台，拥有这牛逼的外观。给一个官方的demo体验地址： &lt;a href=&quot;https://play.grafana.org/d/000000012/grafana-play-home?orgId=1&quot; target=&quot;_blank&quot;&gt;https://play.grafana.org/d/000000012/grafana-play-home?orgId=1&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;grafana的安装&lt;/h2&gt;
&lt;p&gt;grfana安装的官方参考:&lt;a href=&quot;%20http://docs.grafana.org/installation/rpm/&quot; target=&quot;_blank&quot;&gt; http://docs.grafana.org/installation/rpm/&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@VM_0_15_centos ~]# &lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-5.1.4-1.x86_64.rpm&lt;/span&gt;
[root@VM_0_15_centos ~]# rpm -ql grafana |&lt;span&gt;grep&lt;/span&gt; /&lt;span&gt;etc
&lt;/span&gt;/etc/&lt;span&gt;grafana
&lt;/span&gt;/etc/init.d/grafana-&lt;span&gt;server
&lt;/span&gt;/etc/sysconfig/grafana-&lt;span&gt;server

[root@VM_0_15_centos &lt;/span&gt;~]# systemctl start grafana-&lt;span&gt;server
[root@VM_0_15_centos &lt;/span&gt;~]# systemctl status grafana-&lt;span&gt;server

[root@VM_0_15_centos &lt;/span&gt;~]# firewall-cmd --permanent  --add-port=&lt;span&gt;3000&lt;/span&gt;/&lt;span&gt;tcp
success
[root@VM_0_15_centos &lt;/span&gt;~]# firewall-cmd --&lt;span&gt;reload 
success

# 添加域名grafana.linuxpanda.tech 
# web访问下grafana.linuxpanda.tech:3000 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主界面如下： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/429277/201809/429277-20180905215100517-1891464173.png&quot; alt=&quot;&quot; width=&quot;966&quot; height=&quot;503&quot;/&gt;&lt;/p&gt;

&lt;p&gt;默认的用户名和密码都是admin。&lt;/p&gt;
&lt;h2&gt;ldap用户组和用户创建&lt;/h2&gt;
&lt;p&gt;如果没有ldap服务，可以参考：&lt;a href=&quot;https://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_liunx_52_ldap.html&quot; target=&quot;_blank&quot;&gt; https://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_liunx_52_ldap.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/429277/201809/429277-20180905215611413-1130036155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们使用 &lt;a href=&quot;http://www.ldapadmin.org/download/ldapadmin.html&quot; target=&quot;_blank&quot;&gt;ldapadmin.exe&lt;/a&gt; 这个小软件连接到ldap服务， 在group这个ou里面添加一个grafana的ou，然后在grafana这个ou里面添加3个组， 对应管理，编辑和预览。&lt;/p&gt;
&lt;p&gt;创建三个用户test01,test02,test03 ，设置密码为oracle, 让其分别属于三个不同的组，方便后续的测试。&lt;/p&gt;
&lt;h2&gt;ldap配置文件&lt;/h2&gt;
&lt;p&gt;grafana的ldap配置官方参考：&lt;a href=&quot;%20http://docs.grafana.org/installation/ldap/&quot; target=&quot;_blank&quot;&gt; http://docs.grafana.org/installation/ldap/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;grafana.ini配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@VM_0_15_centos ~]# cd /etc/grafana/&lt;span&gt;
[root@VM_0_15_centos grafana]# ll
total &lt;/span&gt;&lt;span&gt;24&lt;/span&gt;
-rw-r----- &lt;span&gt;1&lt;/span&gt; root grafana &lt;span&gt;13655&lt;/span&gt; Sep  &lt;span&gt;5&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;39&lt;/span&gt;&lt;span&gt; grafana.ini
&lt;/span&gt;-rw-r----- &lt;span&gt;1&lt;/span&gt; root grafana  &lt;span&gt;3468&lt;/span&gt; Sep  &lt;span&gt;5&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;39&lt;/span&gt;&lt;span&gt; ldap.toml
drwxr&lt;/span&gt;-xr-x &lt;span&gt;4&lt;/span&gt; root grafana  &lt;span&gt;4096&lt;/span&gt; Sep  &lt;span&gt;5&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;39&lt;/span&gt;&lt;span&gt; provisioning
[root@VM_0_15_centos grafana]# &lt;/span&gt;&lt;span&gt;cp&lt;/span&gt;&lt;span&gt; ldap.toml  ldap.toml.default 
[root@VM_0_15_centos grafana]# &lt;/span&gt;&lt;span&gt;cp&lt;/span&gt;&lt;span&gt; grafana.ini grafana.ini.default&lt;br/&gt;[root@VM_0_15_centos grafana]# chown grafana.grafana grafana.ini ldap.toml 

[root@VM_0_15_centos grafana]# vim grafana.ini
# 这个文件修改2项，log的其实没有必要，但是ldap调试比较麻烦，建议先开启debug，等配置好ldap后，在修改回去info级别。
[auth.ldap]
&lt;span&gt;enabled &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= true&lt;/span&gt;&lt;span&gt;

[log]
&lt;span&gt;level &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= debug&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;配置前需要先做几个查询&lt;/h3&gt;
&lt;h3&gt;查询所有用户&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
[root@VM_0_15_centos ~]# ldapsearch  -LLL -&lt;span&gt;w&lt;/span&gt; oracle   -x -H ldap:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&lt;span&gt;ldap.linuxpanda.tech&lt;/span&gt; -D&quot;&lt;span&gt;cn=admin,dc=linuxpanda,dc=tech&lt;/span&gt;&quot; -b &quot;&lt;span&gt;ou=people,dc=linuxpanda,dc=tech&lt;/span&gt;&quot; &lt;/span&gt;
dn: ou=people,dc=linuxpanda,dc=&lt;span&gt;tech
objectClass: organizationalUnit
ou: user
ou: people

dn: uid&lt;/span&gt;=test01,ou=people,dc=linuxpanda,dc=&lt;span&gt;tech
objectClass: posixAccount
objectClass: top
objectClass: inetOrgPerson
gidNumber: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
givenName: test01
sn: test01
displayName:: 5rWL6K&lt;/span&gt;+VMQ==&lt;span&gt;&lt;span&gt;
uid: test01&lt;/span&gt;
homeDirectory: &lt;/span&gt;/home/&lt;span&gt;test01
loginShell: &lt;/span&gt;/bin/&lt;span&gt;bash
&lt;span&gt;mail: test01@linuxpanda.tech&lt;/span&gt;
cn:: 5rWL6K&lt;/span&gt;+VMQ==&lt;span&gt;
uidNumber: &lt;/span&gt;&lt;span&gt;55545&lt;/span&gt;&lt;span&gt;
userPassword:: e1NIQX1ReE5rdGtVUHhIek52Mm9pQmQvYkc2NjNsQkk9

dn: uid&lt;/span&gt;=test02,ou=people,dc=linuxpanda,dc=&lt;span&gt;tech
objectClass: posixAccount
objectClass: top
objectClass: inetOrgPerson
gidNumber: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
givenName: test02
sn: test02
displayName:: 5rWL6K&lt;/span&gt;+VMg==&lt;span&gt;
uid: test02
homeDirectory: &lt;/span&gt;/home/&lt;span&gt;test02
loginShell: &lt;/span&gt;/bin/&lt;span&gt;bash
mail: test02@linuxpanda.tech
cn:: 5rWL6K&lt;/span&gt;+VMg==&lt;span&gt;
uidNumber: &lt;/span&gt;&lt;span&gt;50880&lt;/span&gt;&lt;span&gt;
userPassword:: e1NIQX1ReE5rdGtVUHhIek52Mm9pQmQvYkc2NjNsQkk9

dn: uid&lt;/span&gt;=test03,ou=people,dc=linuxpanda,dc=&lt;span&gt;tech
objectClass: posixAccount
objectClass: top
objectClass: inetOrgPerson
gidNumber: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
givenName: test03
sn: test03
displayName:: 5rWL6K&lt;/span&gt;+VMw==&lt;span&gt;
uid: test03
homeDirectory: &lt;/span&gt;/home/&lt;span&gt;test03
loginShell: &lt;/span&gt;/bin/&lt;span&gt;bash
mail: test03@linuxpanda.tech
cn:: 5rWL6K&lt;/span&gt;+VMw==&lt;span&gt;
uidNumber: &lt;/span&gt;&lt;span&gt;46507&lt;/span&gt;&lt;span&gt;
userPassword:: e1NIQX1ReE5rdGtVUHhIek52Mm9pQmQvYkc2NjNsQkk9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查询特定用户&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
[root@VM_0_15_centos ~]# ldapsearch  -LLL -&lt;span&gt;w&lt;/span&gt; oracle   -x -H ldap:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ldap.linuxpanda.tech -D&quot;cn=admin,dc=linuxpanda,dc=tech&quot; -b &quot;ou=people,dc=linuxpanda,dc=tech&quot; &quot;(uid=test01)&quot;   &lt;/span&gt;
dn: uid=test01,ou=people,dc=linuxpanda,dc=&lt;span&gt;tech
objectClass: posixAccount
objectClass: top
objectClass: inetOrgPerson
gidNumber: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
givenName: test01
sn: test01
displayName:: 5rWL6K&lt;/span&gt;+VMQ==&lt;span&gt;&lt;span&gt;
uid: test01&lt;/span&gt;
homeDirectory: &lt;/span&gt;/home/&lt;span&gt;test01
loginShell: &lt;/span&gt;/bin/&lt;span&gt;bash
&lt;span&gt;mail: test01@linuxpanda.tech&lt;/span&gt;
cn:: 5rWL6K&lt;/span&gt;+VMQ==&lt;span&gt;
uidNumber: &lt;/span&gt;&lt;span&gt;55545&lt;/span&gt;&lt;span&gt;
userPassword:: e1NIQX1ReE5rdGtVUHhIek52Mm9pQmQvYkc2NjNsQkk9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查询所有组&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
[root@VM_0_15_centos grafana]# ldapsearch  -LLL -&lt;span&gt;w&lt;/span&gt; oracle   -x -H ldap:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ldap.linuxpanda.tech -D&quot;cn=admin,dc=linuxpanda,dc=tech&quot; -b &quot;ou=grafana,ou=group,dc=linuxpanda,dc=tech&quot;  &lt;/span&gt;
dn: ou=grafana,ou=group,dc=linuxpanda,dc=&lt;span&gt;tech
objectClass: top
objectClass: organizationalUnit
ou: grafana

dn: cn&lt;/span&gt;=grafana-admins,ou=grafana,ou=group,dc=linuxpanda,dc=&lt;span&gt;tech
objectClass: posixGroup
objectClass: top
cn: grafana&lt;/span&gt;-&lt;span&gt;admins
gidNumber: &lt;/span&gt;&lt;span&gt;49004&lt;/span&gt;&lt;span&gt;
memberUid: test01

dn: cn&lt;/span&gt;=grafana-editors,ou=grafana,ou=group,dc=linuxpanda,dc=&lt;span&gt;tech
objectClass: posixGroup
objectClass: top
gidNumber: &lt;/span&gt;&lt;span&gt;34366&lt;/span&gt;&lt;span&gt;
cn: grafana&lt;/span&gt;-&lt;span&gt;editors
memberUid: test02

&lt;span&gt;dn: cn&lt;/span&gt;&lt;/span&gt;&lt;span&gt;=grafana-viewers,ou=grafana,ou=group,dc=linuxpanda,dc=&lt;/span&gt;&lt;span&gt;&lt;span&gt;tech&lt;/span&gt;
objectClass: posixGroup
objectClass: top
&lt;span&gt;cn: grafana&lt;/span&gt;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&lt;span&gt;viewers&lt;/span&gt;
gidNumber: &lt;/span&gt;&lt;span&gt;25527&lt;/span&gt;&lt;span&gt;
memberUid: test03&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 查询用户所在的组&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
[root@VM_0_15_centos grafana]# ldapsearch  -LLL -&lt;span&gt;w&lt;/span&gt; oracle   -x -H ldap:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ldap.linuxpanda.tech -D&quot;cn=admin,dc=linuxpanda,dc=tech&quot; -b &quot;ou=grafana,ou=group,dc=linuxpanda,dc=tech&quot;   &quot;(&amp;amp;(objectClass=posixGroup)(memberUid=test03))&quot;&lt;/span&gt;
dn: cn=grafana-viewers,ou=grafana,ou=group,dc=linuxpanda,dc=&lt;span&gt;tech
objectClass: posixGroup
objectClass: top
&lt;span&gt;cn: grafana&lt;/span&gt;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&lt;span&gt;viewers&lt;/span&gt;
gidNumber: &lt;/span&gt;&lt;span&gt;25527&lt;/span&gt;&lt;span&gt;
memberUid: test03&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;修改ldap.toml文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@VM_0_15_centos grafana]# vim ldap.toml
[root@VM_0_15_centos grafana]# &lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt; ldap.toml

[[servers]]
host &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ldap.linuxpanda.tech&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
port &lt;/span&gt;= &lt;span&gt;389&lt;/span&gt;&lt;span&gt;
use_ssl &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
start_tls &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
ssl_skip_verify &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;

bind_dn &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cn=admin,dc=linuxpanda,dc=tech&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
bind_password &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;oracle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

search_filter &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(uid=%s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

search_base_dns &lt;/span&gt;= [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ou=people,dc=linuxpanda,dc=tech&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

group_search_filter &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(&amp;amp;(objectClass=posixGroup)(memberUid=%s))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
group_search_base_dns &lt;/span&gt;= [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ou=grafana,ou=group,dc=linuxpanda,dc=tech&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
[servers.attributes]
name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;givenName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
surname &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
username &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#member_of &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;memberOf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
member_of&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
email &lt;/span&gt;=  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

[[servers.group_mappings]]
group_dn &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grafana-admins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
org_role &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

[[servers.group_mappings]]
group_dn &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grafana-editors&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
org_role &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Editor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

[[servers.group_mappings]]
group_dn &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grafana-viewers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#group_dn &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
org_role &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Viewer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;主要配置说明&lt;/h2&gt;
&lt;p&gt;host：就是指定你的ldap服务器，可以指定多个，需要分隔符。&lt;/p&gt;
&lt;p&gt;port：你的ldap服务器的监听的端口。&lt;/p&gt;
&lt;p&gt;bind_dn: 你需要特定ou的管理员账号，我这里使用了域管理者。&lt;/p&gt;
&lt;p&gt;bind_password: 上面账号的密码。&lt;/p&gt;
&lt;p&gt;search_filter:  用户搜索的过滤表达式，配合search_base_dns。&lt;/p&gt;
&lt;p&gt;search_base_dns: 用户搜索的范围，这里在people这个ou里面搜索所有的用户，需要配合search_filter来完成用户的过滤。&lt;/p&gt;
&lt;p&gt;group_search_filter: 组搜索的过滤表达式，配合group_search_base_dns。&lt;/p&gt;
&lt;p&gt;group_search_base_dns: 指定组搜索的范围，我们的grafana这个ou里面设置了3个组。&lt;/p&gt;
&lt;p&gt;servers.attributes: 这个主要是用户获取特定提取到的用户条目有特定字段的提取， username从查询的用户信息取特定字段值作为grafana的用户名， &lt;/p&gt;
&lt;p&gt;                              member_of 代表，根据group_search_base_dns和group_search_filter 得到特定的一个组后，取那个字段作为组名字。 这个取到的结果需要和下面的映射保持一致。&lt;/p&gt;
&lt;p&gt;                              email代表取特定用户的mail字段作为grafana用户的email信息。&lt;/p&gt;
&lt;p&gt;servers_group_mappings: 这个是用于定义ldap用户组和grafana角色组的映射关系的， 上面member_of ,group_search_base_dns和group_search_filter 这三个条件可以获取到ldap的组名，这里要和三个条件获取的一致。&lt;/p&gt;

&lt;h3&gt;一张图说清楚&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/429277/201809/429277-20180906103432261-79308049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改完毕重启服务进行测试。&lt;/p&gt;
&lt;h2&gt;最终结果图&lt;/h2&gt;
&lt;h2&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/429277/201809/429277-20180906095956649-279826665.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;修改grafana的日志级别为info。&lt;/p&gt;
&lt;h2&gt;调试&lt;/h2&gt;
&lt;h3&gt; 判定ldap服务是否可通&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@VM_0_15_centos grafana]# telnet ldap.linuxpanda.tech &lt;span&gt;389&lt;/span&gt;&lt;span&gt;
Trying &lt;/span&gt;&lt;span&gt;58.87&lt;/span&gt;.&lt;span&gt;98.84&lt;/span&gt;&lt;span&gt;...
Connected to ldap.linuxpanda.tech.
Escape character is &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;确定开启了ldap配置&lt;/h3&gt;
&lt;p&gt;检查grafana.ini文件确认有ldap=true启用的，&lt;span&gt;默认去掉注释还是false,注意啦。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;关注日志信息&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;主要的日志有2个，一个是grafana的日志， 一个是ldap的日志。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
[root@VM_0_15_centos grafana]# journalctl -&lt;span&gt;f  
Sep &lt;/span&gt;&lt;span&gt;05&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;:&lt;span&gt;50&lt;/span&gt; VM_0_15_centos grafana-server[&lt;span&gt;12052&lt;/span&gt;]: t=&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt;-05T22:&lt;span&gt;51&lt;/span&gt;:&lt;span&gt;50&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; lvl=dbug msg=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ldap User found&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; logger=ldap &lt;span&gt;info&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(*login.LdapUserInfo)(0xc420030fc0)({\n DN: (string) (len=42) \&quot;uid=test01,ou=people,dc=linuxpanda,dc=tech\&quot;,\n FirstName: (string) (len=6) \&quot;test01\&quot;,\n LastName: (string) (len=6) \&quot;test01\&quot;,\n Username: (string) (len=22) \&quot;test01@linuxpanda.tech\&quot;,\n Email: (string) (len=22) \&quot;test01@linuxpanda.tech\&quot;,\n MemberOf: ([]string) &amp;lt;nil&amp;gt;\n})\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
Sep &lt;/span&gt;&lt;span&gt;05&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;:&lt;span&gt;50&lt;/span&gt; VM_0_15_centos grafana-server[&lt;span&gt;12052&lt;/span&gt;]: t=&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt;-05T22:&lt;span&gt;51&lt;/span&gt;:&lt;span&gt;50&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; lvl=dbug msg=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Updating last user_seen_at&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; logger=context userId=&lt;span&gt;2&lt;/span&gt; orgId=&lt;span&gt;1&lt;/span&gt; &lt;span&gt;uname&lt;/span&gt;=test01@linuxpanda.tech user_id=&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@VM_0_15_centos grafana]# &lt;span&gt;tail&lt;/span&gt; -f /var/log/slapd/slapd.log 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;参考 &lt;/h2&gt;
&lt;p&gt;grafana官方帮助文档：&lt;a href=&quot;http://docs.grafana.org/&quot; target=&quot;_blank&quot;&gt; http://docs.grafana.org/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Sep 2018 04:59:00 +0000</pubDate>
<dc:creator>LinuxPanda</dc:creator>
<og:description>ldap配置系列三：grafana集成ldap grafana的简介 grafana是一个类似kibana的东西，是对来自各种数据源的数据进行实时展示的平台，拥有这牛逼的外观。给一个官方的demo体验</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_liunx_51_ldap_for_grafana.html</dc:identifier>
</item>
<item>
<title>不懂高性能的负载均衡设计？没关系，架构师带你飞 - IVAN-jsjwk</title>
<link>http://www.cnblogs.com/jsjwk/p/9597748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jsjwk/p/9597748.html</guid>
<description>&lt;p&gt;&lt;span&gt;在软件系统的架构设计中，对集群的负载均衡设计是作为高性能系统优化环节中必不可少的方案。负载均衡本质上是用于将用户流量进行均衡减压的，因此在互联网的大流量项目中，其重要性不言而喻。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;一、什么是负载均衡？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;早期的互联网应用，由于用户流量比较小，业务逻辑也比较简单，往往一个单服务器就能满足负载需求。随着现在互联网的流量越来越大，稍微好一点的系统，访问量就非常大了，并且系统功能也越来越复杂，那么单台服务器就算将性能优化得再好，也不能支撑这么大用户量的访问压力了，这个时候就需要使用多台机器，设计高性能的集群来应对。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，多台服务器是如何去均衡流量、如何组成高性能的集群的呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时就需要请出 「负载均衡器」 入场了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;负载均衡（Load Balancer）是指把用户访问的流量，通过「负载均衡器」，根据某种转发的策略，均匀的分发到后端多台服务器上，后端的服务器可以独立的响应和处理请求，从而实现分散负载的效果。负载均衡技术提高了系统的服务能力，增强了应用的可用性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.6173228346456693&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkeNtRicwBYNcibD0RLSzMRJNNCNkYsCQn1MIwo7HGYl9B7uicwj9Ys3nz0Wjib4qu6MeVHicuLoaoISKIZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（可以按照图中去理解，图片来源网络）&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;二、负载均衡方案有几种？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;目前市面上最常见的负载均衡技术方案主要有三种：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;基于DNS负载均衡&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;基于硬件负载均衡&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;基于软件负载均衡&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;三种方案各有优劣，DNS负载均衡可以实现在地域上的流量均衡，硬件负载均衡主要用于大型服务器集群中的负载需求，而软件负载均衡大多是基于机器层面的流量均衡。在实际场景中，这三种是可以组合在一起使用。下面来详细讲讲：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;基于DNS负载均衡&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;span&gt;&lt;img title=&quot;Alt text&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkeNtRicwBYNcibD0RLSzMRJNNCQTevuskYDQib7ERrwd0iabUqIz3s0uicicw9PAYFducrYFfEJHU8QSatvg/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;511&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;30&quot; data-ratio=&quot;0.3561847988077496&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkeNtRicwBYNcibD0RLSzMRJNNCQTevuskYDQib7ERrwd0iabUqIz3s0uicicw9PAYFducrYFfEJHU8QSatvg/640?wx_fmt=png&quot; data-w=&quot;671&quot; data-type=&quot;png&quot; data-fail=&quot;0&quot;/&gt;（网络图片）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;基于DNS来做负载均衡其实是一种最简单的实现方案，通过在DNS服务器上做一个简单配置即可。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其原理就是当用户访问域名的时候，会先向DNS服务器去解析域名对应的IP地址，这个时候我们可以让DNS服务器根据不同地理位置的用户返回不同的IP。比如南方的用户就返回我们在广州业务服务器的IP，北方的用户来访问的话，我就返回北京业务服务器所在的IP。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个模式下，用户就相当于实现了按照「就近原则」将请求分流了，既减轻了单个集群的负载压力，也提升了用户的访问速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用DNS做负载均衡的方案，天然的优势就是配置简单，实现成本非常低，无需额外的开发和维护工作。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;但是也有一个明显的缺点是：当配置修改后，生效不及时。这个是由于DNS的特性导致的，DNS一般会有多级缓存，所以当我们修改了DNS配置之后，由于缓存的原因，会导致IP变更不及时，从而影响负载均衡的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，使用DNS做负载均衡的话，大多是基于地域或者干脆直接做IP轮询，没有更高级的路由策略，所以这也是DNS方案的局限所在。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;基于硬件负载均衡&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;span&gt;&lt;img title=&quot;Alt text&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkeNtRicwBYNcibD0RLSzMRJNNCaKtXyWpN9KgCJcF28CdDBP6xiak7FZ3Jkokia5libibqLKdAUb59ebHeTg/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;511&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;30&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkeNtRicwBYNcibD0RLSzMRJNNCaKtXyWpN9KgCJcF28CdDBP6xiak7FZ3Jkokia5libibqLKdAUb59ebHeTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6931567328918322&quot; data-w=&quot;453&quot; data-fail=&quot;0&quot;/&gt;（网络图片）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;硬件的负载均衡那就比较牛逼了，比如大名鼎鼎的 &lt;strong&gt;F5 Network Big-IP&lt;/strong&gt;，也就是我们常说的 &lt;strong&gt;F5&lt;/strong&gt;，它是一个网络设备，你可以简单的理解成类似于网络交换机的东西，完全通过硬件来抗压力，性能是非常的好，每秒能处理的请求数达到百万级，即 几百万/秒 的负载，当然价格也就非常非常贵了，十几万到上百万人民币都有。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为这类设备一般用在大型互联网公司的流量入口最前端，以及政府、国企等不缺钱企业会去使用。一般的中小公司是不舍得用的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;采用 &lt;strong&gt;F5&lt;/strong&gt; 这类硬件做负载均衡的话，主要就是省心省事，买一台就搞定，性能强大，一般的业务不在话下。而且在负载均衡的算法方面还支持很多灵活的策略，同时还具有一些防火墙等安全功能。但是缺点也很明显，一个字：贵。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;3&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;基于软件负载均衡&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;span&gt;&lt;img title=&quot;Alt text&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkeNtRicwBYNcibD0RLSzMRJNNC9HY0Xqa7ibk2eicvXW0bU55yFPzOH1xRN0rCo56bHlPMgxuFqBGlW2uA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;511&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;30&quot; data-ratio=&quot;0.5948158253751705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkeNtRicwBYNcibD0RLSzMRJNNC9HY0Xqa7ibk2eicvXW0bU55yFPzOH1xRN0rCo56bHlPMgxuFqBGlW2uA/640?wx_fmt=png&quot; data-w=&quot;733&quot; data-type=&quot;png&quot; data-fail=&quot;0&quot;/&gt;（网络图片）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;软件负载均衡是指使用软件的方式来分发和均衡流量。软件负载均衡，分为7层协议 和 4层协议。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;网络协议有七层，基于第四层传输层来做流量分发的方案称为4层负载均衡，例如 &lt;strong&gt;LVS&lt;/strong&gt;，而基于第七层应用层来做流量分发的称为7层负载均衡，例如 &lt;strong&gt;Nginx&lt;/strong&gt;。这两种在性能和灵活性上是有些区别的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于4层的负载均衡性能要高一些，一般能达到 几十万/秒 的处理量，而基于7层的负载均衡处理量一般只在 几万/秒 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于软件的负载均衡的特点也很明显，便宜。在正常的服务器上部署即可，无需额外采购，就是投入一点技术去优化优化即可，因此这种方式是互联网公司中用得最多的一种方式。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;三、常用的均衡算法有哪些？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;上面讲完了常见的负载均衡技术方案，那么接下来咱们看一下，在实际方案应用中，一般可以使用哪些均衡算法？&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;轮询策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;负载度策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;响应策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;哈希策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下面来分别介绍一下这几种均衡算法/策略的特点：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;轮询策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;轮询策略其实很好理解，就是当用户请求来了之后，「负载均衡器」将请求轮流的转发到后端不同的业务服务器上。这个策略在DNS方案中用的比较多，无需关注后端服务的状态，只药有请求，就往后端轮流转发，非常的简单、实用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在实际应用中，轮询也会有多种方式，有按顺序轮询的、有随机轮询的、还有按照权重来轮询的。前两种比较好理解，第三种按照权重来轮询，是指给每台后端服务设定一个权重值，比如性能高的服务器权重高一些，性能低的服务器给的权重低一些，这样设置的话，分配流量的时候，给权重高的更多流量，可以充分的发挥出后端机器的性能。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;负载度策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;负载度策略是指当「负载均衡器」往后端转发流量的时候，会先去评估后端每台服务器的负载压力情况，对于压力比较大的后端服务器转发的请求就少一些，对于压力比较小的后端服务器可以多转发一些请求给它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种方式就充分的结合了后端服务器的运行状态，来动态的分配流量了，比轮询的方式更为科学一些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是这种方式也带来了一些弊端，因为需要动态的评估后端服务器的负载压力，那这个「负载均衡器」除了转发请求以外，还要做很多额外的工作，比如采集 连接数、请求数、CPU负载指标、IO负载指标等等，通过对这些指标进行计算和对比，判断出哪一台后端服务器的负载压力较大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此这种方式带来了效果优势的同时，也增加了「负载均衡器」的实现难度和维护成本。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;3&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;响应策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;响应策略是指，当用户请求过来的时候，「负载均衡器」会优先将请求转发给当前时刻响应最快的后端服务器。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;也就是说，不管后端服务器负载高不高，也不管配置如何，只要觉得这个服务器在当前时刻能最快的响应用户的请求，那么就优先把请求转发给它，这样的话，对于用户而言，体验也最好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那「负载均衡器」是怎么知道哪一台后端服务在当前时刻响应能力最佳呢？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这就需要「负载均衡器」不停的去统计每一台后端服务器对请求的处理速度了，比如一分钟统计一次，生成一个后端服务器处理速度的排行榜。然后「负载均衡器」根据这个排行榜去转发服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么这里的问题就是统计的成本了，不停的做这些统计运算本身也会消耗一些性能，同时也会增加「负载均衡器」的实现难度和维护成本。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;4&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;哈希策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;Hash策略也比较好理解，就是将请求中的某个信息进行hash计算，然后根据后端服务器台数取模，得到一个值，算出相同值的请求就被转发到同一台后端服务器中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常见的用法是对用户的IP或者ID进行这个策略，然后「负载均衡器」就能保证同一个IP来源或者同一个用户永远会被送到同一个后端服务器上了，一般用于处理缓存、会话等功能的时候特别好用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上，就是实现高性能负载均衡的常见技术方案和策略了，欢迎大家一起交流。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流互联网认知、项目管理、大数据、Web、区块链技术。&lt;/span&gt;&lt;/p&gt;
&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1453917/201809/1453917-20180906125446966-851690955.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/blockquote&gt;
</description>
<pubDate>Thu, 06 Sep 2018 04:56:00 +0000</pubDate>
<dc:creator>IVAN-jsjwk</dc:creator>
<og:description>在软件系统的架构设计中，对集群的负载均衡设计是作为高性能系统优化环节中必不可少的方案。负载均衡本质上是用于将用户流量进行均衡减压的，因此在互联网的大流量项目中，其重要性不言而喻。 一、什么是负载均衡？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jsjwk/p/9597748.html</dc:identifier>
</item>
<item>
<title>前端开发数据mock神器 -- xl_mock - 小结巴巴吧</title>
<link>http://www.cnblogs.com/jiebba/p/9596707.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiebba/p/9596707.html</guid>
<description>&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;1、为什么要实现数据 mock &lt;/h3&gt;

&lt;p&gt;　　要理解为什么要实现数据 mock，我们可以提供几个场景来解释，&lt;/p&gt;
&lt;p&gt;　　1、现在的开发很多都是前后端分离的模式，前后端的工作是不同的，当我们前端界面已经完成，但是后端的接口迟迟不能提供&lt;/p&gt;
&lt;p&gt;　　　 前端很多时候都会等接口。&lt;/p&gt;
&lt;p&gt;　　2、测试人员想要你提供一份可以直接测试，自行修改后端接口，测试 UI 的时候。&lt;/p&gt;
&lt;p&gt;　　3、后端的接口，不能提供一些匹配不到的场景的时候。&lt;/p&gt;

&lt;p&gt;　　这个时候如果前端可以实现自己的一套 mock 数据，这里的问题都会迎刃而解，我们可以模拟真实的接口，提供我们自己需要的数据及其数据结构。&lt;/p&gt;
&lt;p&gt;　　这样，我们可以在后端未完成的情况下，完成测试，调试以及优化。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2、mock 数据的方案&lt;/h3&gt;

&lt;p&gt;　　说到前端开发，那么实现前端数据到 mock 是在前端构建中不可缺少到一个步骤，不管是在开发或者调试都是必不可少的。&lt;/p&gt;
&lt;p&gt;　　那么我们要实现数据的 mock ，有哪些操作呢？其中最常规到方法就那么几种：&lt;/p&gt;
&lt;p&gt;　　例如：&lt;/p&gt;
&lt;p&gt;　　1、引入 mock.js 实现请求拦截。&lt;/p&gt;
&lt;p&gt;　　2、搭建一个属于自己到 mock 服务器，模拟自己想要到数据及其数据结构。&lt;/p&gt;
&lt;p&gt;　　3、搭建RAP 可视化到一个 mock 服务器&lt;/p&gt;
&lt;p&gt;　　4、还有其他很多特别到手段....&lt;/p&gt;

&lt;p&gt;　　在这几种方法中，都是利用了模拟数据，来实现前端的展示，提高前端开发效率以及开发节奏。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;　　xl_mock 介绍&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;xl_mock 是一个基于 mock.js 开发的一个可视化的数据 mock 的 npm 包。&lt;/p&gt;
&lt;p&gt;　　它可以实现在你的项目中通过命令开启一个本地数据 mock 服务器。&lt;/p&gt;
&lt;p&gt;　　并且 mock 的数据类型会存在在项目中，以供合作开发。　　&lt;/p&gt;

&lt;h3&gt;　　xl_mock 使用及其预览&lt;/h3&gt;

&lt;p&gt;　　1、首先全局安装 xl_mock&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
npm install -g xl_mock
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://xiao-1251424696.cos.ap-guangzhou.myqcloud.com/E831BF48-0F46-4739-B970-AF8670F08145.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;183&quot; align=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　在全局安装，可以实现全局命令。&lt;/p&gt;
&lt;p&gt;　　如果不在项目项目中安装，则会开启一个全局的 mock 服务器。这是不可取的。&lt;/p&gt;

&lt;p&gt;　　2、在项目中添加 npm 包 xl_mock&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
yarn add xl_mock
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在项目中添加 xl_mock ,这样开启服务的时候只会在当前项目生效。&lt;/p&gt;

&lt;p&gt;　　3、在项目开启 mock 服务器&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
xl_mock start -p 2048
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这里开启的项目的 mock 服务器，并且监听的端口好是 2048 。&lt;/p&gt;
&lt;p&gt;　　如果端口号被占用，会先停止端口号的进程，然后重新开启。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://xiao-1251424696.cos.ap-guangzhou.myqcloud.com/generator_1223.gif&quot; alt=&quot;&quot; width=&quot;1027&quot; height=&quot;584&quot; align=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　首先，这里会在项目的根目录生成一个 mock 目录，用于存放数据。（ 如果存在 mock 目录，则不会重新生成 ）&lt;/p&gt;
&lt;p&gt;　　可以看到这里开启的是一个本地服务器，并且打开了 http://127.0.0.1:2014/index.html&lt;/p&gt;
&lt;p&gt;　　这里我们看到的是一个可视化，接口添加，接口修改，以及接口类型添加等。&lt;/p&gt;

&lt;p&gt;　　4、添加一个接口&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://xiao-1251424696.cos.ap-guangzhou.myqcloud.com/generator_12232.gif&quot; alt=&quot;&quot; width=&quot;1029&quot; height=&quot;585&quot; align=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这里添加了一个 uesrInfo 接口&lt;/p&gt;
&lt;p&gt;　　并且请求地址为 /get/userInfo&lt;/p&gt;
&lt;p&gt;　　这里还可以进行方法的选择，以及接口的描述，还有接口具体信息。&lt;/p&gt;
&lt;p&gt;　　当我们点击提交数据，接口的信息已经写入了本地项目目录下的 mock 文件夹内，以供提取。&lt;/p&gt;

&lt;p&gt;　　5、接口验证和调用&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://xiao-1251424696.cos.ap-guangzhou.myqcloud.com/generator_122322.gif&quot; alt=&quot;&quot; width=&quot;1032&quot; height=&quot;587&quot; align=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　在这里，我是直接输入接口地址到浏览器中验证接口是否生效。&lt;/p&gt;
&lt;p&gt;　　那么在项目中，我们如何调用呢？&lt;/p&gt;
&lt;p&gt;　　我们可以判定一个 mock 环境，将请求地址都替换成 http://127.0.0.0:2048 , 实现接口的调用。。&lt;/p&gt;

&lt;h3&gt;　　xl_mock 相对于其他的优点：&lt;/h3&gt;

&lt;p&gt;　　相对于 mock.js ：&lt;/p&gt;
&lt;p&gt;　　xl_mock 已经从项目中提出了，不需要进行接口请求拦截，使开发更接近于后端接口&lt;/p&gt;
&lt;p&gt;　　xl_mock 提供了可视化的界面，这样接口浏览更直观&lt;/p&gt;

&lt;p&gt;　　相对于一般 mock 服务器：&lt;/p&gt;
&lt;p&gt;　　不需要专门搭建 mock 服务器&lt;/p&gt;
&lt;p&gt;　　在这里，我们可以更方便，更简洁的完成一个 mock 功能&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;　　项目还在开发和完善之中，如果大家觉得有什么 bug 或者什么不合理的位置 ，尽情提出了，尽快优化和修改。。。&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;　　博客：&lt;a href=&quot;https://gilea.cn/article/af33bd60-a786-11e8-b2a2-b1037d08a2a6&quot; target=&quot;_blank&quot;&gt;npm工具--mock服务器（ xl_mock ）&lt;/a&gt;&lt;/p&gt;


&lt;h3&gt;3、开发 xl_mock 知识梳理&lt;/h3&gt;

&lt;p&gt;　　开发一个 xl_mock npm 包需要哪些知识呢？&lt;/p&gt;
&lt;p&gt;　　这里列出来了基本的几项：&lt;/p&gt;
&lt;p&gt;　　1、mock.js    mock.js 的基本使用方法&lt;/p&gt;
&lt;p&gt;　　2、创建一个自己的 npm 包&lt;/p&gt;
&lt;p&gt;　　3、node 的相关知识  主要是命令行工具&lt;/p&gt;

&lt;h3&gt;4、mock.js 的介绍&lt;/h3&gt;

&lt;p&gt;　　这里我会简单的介绍一下 mock.js ，具体想要了解可以浏览官网&lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;http://mockjs.com/&quot; target=&quot;_blank&quot;&gt;mock.js 官网&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;　　mock.js 安装&lt;/h3&gt;

&lt;p&gt;　　普通直接引入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
直接在 html 中引入  &amp;lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&amp;gt;&amp;lt;/script&amp;gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　以模块形式安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
安装: 
npm install mockjs --save-dev
yarn add mockjs
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;　　mock.js 实现 mock 数据的方法:&lt;/h3&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
Mock.mock(template)

Mock.mock(rurl,function(options))

Mock.mock(rurl,rtype,template)

Mock.mock(rurl,rtype,function(options))
&lt;/pre&gt;&lt;/div&gt;

&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;template 表示数据的模版 ，Mock.mock(template) 这里，会根据模版返回数据及其数据结构&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;rurl  mock.js 可以对请求进行拦截，这里就是要拦截的地址，拦截地址之后，根据函数或者模版返回需要的数据&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;rtype 这个是拦截的请求类型&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;function 这里的函数表示生成数据的函数，这里可以更直观&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;　　mock.js 模版的简单介绍&lt;/h3&gt;

&lt;h4&gt;　　定义数据模版的规则：　　&lt;/h4&gt;
&lt;p&gt;　　数据模版中每一个属性由3个部分构成的：属性的名称，生成值的规则，以及属性值&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
'name|rule': value

属性名称|生成值的规则 : 属性值
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;　　占位符的定义：&lt;/h4&gt;
&lt;p&gt;　　占位符是在属性值的位置写入带有 @ 的字符串，并不会出现在最终的数据中，而是一个数据格式&lt;/p&gt;
&lt;p&gt;　　格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
@占位符
@占位符(参数 [, 参数])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
     name: '@cname',&lt;br/&gt;　　  city: '@city(true)'
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　生成的数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
     name: '中文名称',
　   city: '中国城市'
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;　　mock.js 中的工具集&lt;/h4&gt;
&lt;p&gt;　　在数据模版中有占位符，对应的 Mock.Random 工具集也可以实现各种数据的生成&lt;/p&gt;
&lt;p&gt;　　例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
ar Random = Mock.Random;
Random.email()       // Random 中的函数生成数据       
// =&amp;gt;&quot;long.xiao@qq.com&quot;
Mock.mock('@EMAIL')  // mock 函数实现生成数据
// =&amp;gt;&quot;xiao.da@gil.org&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　创建一个完成的模版：&lt;/h3&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
    &quot;users|1-2&quot;: [{   // 随机生成1到2个数组元素
        'name': '@cname',  // 中文名称
        'id|+1': 108,    // 属性值自动加 1，初始值108
        'birthday': '@date(&quot;yyyy-MM-dd&quot;)',  // 日期
        'city': '@city(true)',   // 中国城市
     
    }]
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　生成的数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
　　users:[
　　　　{name:'xiaol',
　　　　 id:1,
　　　　 birthday:'2018-09-12',
　　　　 city:'北京'
　　　　}，
　　　　{name:'dal',
　　　　 id:2,
　　　　 birthday:'2014-09-12',
　　　　 city:'上海'
　　　　}，
　　]
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这里介绍 mock.js 的基本的操作和功能。&lt;/p&gt;
&lt;h3&gt;　　了解 mock.js 更多介绍可以去官网上面浏览下　&lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;5、创建一个自己的 npm 包&lt;/h3&gt;
&lt;p&gt;　　创建一个自己的 npm 包，首先要知道如果创建&lt;/p&gt;
&lt;p&gt;　　这里有一个简单例子 ：&lt;a href=&quot;https://gilea.cn/article/3be33be0-b183-11e8-b2a2-b1037d08a2a6&quot; target=&quot;_blank&quot;&gt;如何开发一个自己的 npm 包&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　1、修改 package.json &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
  &quot;name&quot;: &quot;xl_mock&quot;,
  &quot;version&quot;: &quot;1.0.5&quot;,
  &quot;description&quot;: &quot;用于创建 mock ，创建 mock 服务，生成mock 目录...&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;
  },



   // 主要修改，添加 命令属性
  &quot;bin&quot;: &quot;./bin/xl_mock.js&quot;,



  &quot;author&quot;: &quot;xiaolong&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;body-parser&quot;: &quot;^1.18.3&quot;,
    &quot;chalk&quot;: &quot;^2.4.1&quot;,
    &quot;commander&quot;: &quot;^2.17.1&quot;,
    &quot;ejs&quot;: &quot;^2.6.1&quot;,
    &quot;express&quot;: &quot;^4.16.3&quot;,
    &quot;express-session&quot;: &quot;^1.15.6&quot;,
    &quot;forever&quot;: &quot;^0.15.3&quot;,
    &quot;kp&quot;: &quot;^1.1.2&quot;,
    &quot;mockjs&quot;: &quot;^1.0.1-beta3&quot;,
    &quot;opn&quot;: &quot;^5.3.0&quot;,
    &quot;shelljs&quot;: &quot;^0.8.2&quot;,
    &quot;yargs&quot;: &quot;^12.0.1&quot;
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　添加我们的命令入口  ./bin/xl_mock.js&lt;/p&gt;

&lt;p&gt;　　2、命令入口文件修改&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
#!/usr/bin/env node

//  主要是在第一个行添加语言解析
//  这个告诉系统用 node 来解析该文件
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　简单介绍了 npm 开发主要两个点&lt;/p&gt;
&lt;p&gt;　　如果需要更详细了解 npm 包开发。&lt;/p&gt;
&lt;p&gt;　　可以浏览这个简单教程 ： &lt;a href=&quot;https://gilea.cn/article/3be33be0-b183-11e8-b2a2-b1037d08a2a6&quot; target=&quot;_blank&quot;&gt;如何开发一个自己的 npm 包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　或者浏览官网 ： &lt;a href=&quot;https://docs.npmjs.com/&quot; target=&quot;_blank&quot;&gt;npm 官网&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;3、Node 相关工具和知识&lt;/h3&gt;
&lt;p&gt;　　 npm 是基于 node 开发的，所以我们必不可少的知识就是 node 的知识。&lt;/p&gt;
&lt;p&gt;　　如 node 对文件的操作模块 fs ， node 的进程管理 process ，子进程  child_precess&lt;/p&gt;
&lt;p&gt;　　还有一些命令行工具：&lt;/p&gt;
&lt;h3&gt;　　chalk&lt;/h3&gt;
&lt;p&gt;　　chalk是一个颜色的插件。可以通过chalk.blue(‘hello world’)来改变颜色，&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const chalk = require('chalk');
const log = console.log;

// 改变文本在命令行中的颜色

// 这里会打印蓝色的 Hello world
log(chalk.blue('Hello world!'));

// 打印蓝色的 Hello  和 红色的 ！
log(chalk.blue('Hello') + 'World' + chalk.red('!'));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这个工具可以提高我们在命令操作时候的，命令行美观。&lt;/p&gt;

&lt;h3&gt;　　commander&lt;/h3&gt;
&lt;p&gt;　　commander是一个轻巧的nodejs模块，提供了用户命令行输入和参数解析强大功能。&lt;/p&gt;
&lt;p&gt;　　这个工具主要是用来实现用户在命令的交互。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　commander 的特性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　记录代码，生成帮助文档&lt;/p&gt;
&lt;p&gt;　　合并短参数，记录参数&lt;/p&gt;
&lt;p&gt;　　实现各种选项&lt;/p&gt;
&lt;p&gt;　　解析命令，并保存&lt;/p&gt;
&lt;p&gt;　　简单命令提示&lt;/p&gt;


&lt;p&gt;　&lt;strong&gt;　commander 的API：&lt;/strong&gt;&lt;/p&gt;

&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Option(): 初始化自定义参数对象，设置“关键字”和“描述”&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Command(): 初始化命令行参数对象，直接获得命令行输入&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Command#command(): 定义一个命令名字&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Command#action(): 注册一个callback函数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;Command#option(): 定义参数，需要设置“关键字”和“描述”，关键字包括“简写”和“全写”两部分，以”,”,”|”,”空格”做分隔。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Command#parse(): 解析命令行参数argv&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Command#description(): 设置description值&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Command#usage(): 设置usage值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43.5&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot; readability=&quot;10&quot;&gt;
program
    .version(package.version)
    .usage('[cmd] [options]')
    .option('-p', '配置端口号')
    .option('-d', '配置mock目录名称 ，默认 mock')
    .option('-x', '设置密码')&lt;p&gt;// 创建一个 strt 的命令
program
    .command('start')
    .description('开启mock服务器..')
    .action((path, options) =&amp;gt; {
        start(argv)
    })
program
    .command('add &amp;lt;path&amp;gt;')
    .description('添加 mock 数据..')
    .action((path) =&amp;gt; {
        opn(`http://127.0.0.1:${port}/index.html`,{app: 'google chrome'});
    })
program.parse(process.argv)
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在命令行中可以执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
xl_mock start options
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这里会执行 start 命令中的相应操作&lt;/p&gt;

&lt;p&gt;　　还有很多很用的命令行和node 的相关 npm 包&lt;/p&gt;
&lt;p&gt;　　node 工具包 ：&lt;a href=&quot;https://gilea.cn/article/f3d65440-a67e-11e8-b2a2-b1037d08a2a6&quot; target=&quot;_blank&quot;&gt;node工具 -- NPM 包&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;4、项目简单介绍&lt;/h3&gt;
&lt;p&gt;　　代码开发和流程，这里知识简单介绍。&lt;/p&gt;
&lt;p&gt;　　如果想要具体了解，可以浏览我的代码原件，后面发布 github 地址。&lt;/p&gt;

&lt;p&gt;　　浏览项目介绍的时候最好对照的源码看 ： &lt;a href=&quot;https://github.com/longfei59418888/xl_mock&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;源码github&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    入口文件：&lt;/p&gt;
&lt;p&gt;    主要有两个功能 ： 一个是 start 开启 mock 服务器，一个是添加 api 接口&lt;/p&gt;
&lt;p&gt;    开启 mock 服务器&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;
program
    .version(package.version)
    .usage(&lt;span class=&quot;hljs-string&quot;&gt;'[cmd] [options]')
    .option(&lt;span class=&quot;hljs-string&quot;&gt;'-p', &lt;span class=&quot;hljs-string&quot;&gt;'配置端口号')
    .option(&lt;span class=&quot;hljs-string&quot;&gt;'-d', &lt;span class=&quot;hljs-string&quot;&gt;'配置mock目录名称 ，默认 mock')
program
    .command(&lt;span class=&quot;hljs-string&quot;&gt;'start')
    .description(&lt;span class=&quot;hljs-string&quot;&gt;'开启mock服务器..')
    .action(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;path, options) =&amp;gt; {
        start(argv)   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;     打开浏览器添加 api 接口页面&lt;/p&gt;


&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;
program
.command(&lt;span class=&quot;hljs-string&quot;&gt;'add &amp;lt;path&amp;gt;')
.description(&lt;span class=&quot;hljs-string&quot;&gt;'添加 mock 数据..')
.action(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;path) =&amp;gt; {
    opn(&lt;span class=&quot;hljs-string&quot;&gt;`http://127.0.0.1:&lt;span class=&quot;hljs-subst&quot;&gt;${port}/index.html`,{&lt;span class=&quot;hljs-attr&quot;&gt;app: &lt;span class=&quot;hljs-string&quot;&gt;'google chrome'});
})
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;


&lt;h3&gt;    开始 mock 服务器文件：&lt;/h3&gt;

&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://xiao-1251424696.cos.ap-guangzhou.myqcloud.com/7A4815D5-554D-4057-9520-958AC2B20042.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;432&quot; align=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    步骤：&lt;/p&gt;
&lt;p&gt;   1、将必要的模版文件复制到项目目录 mock 文件夹中&lt;/p&gt;
&lt;p&gt;        这样就不会丢失 mock 的数据&lt;/p&gt;
&lt;p&gt;   2、开发服务器，如果端口占用则杀掉端口进程，重新开启&lt;/p&gt;

&lt;h3&gt;    服务器文件：&lt;/h3&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://xiao-1251424696.cos.ap-guangzhou.myqcloud.com/CF983375-BAD8-465E-A2DE-941F1168C442.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;293&quot; align=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    主要功能：&lt;/p&gt;
&lt;p&gt;    1、主页，用于 添加/展示  接口及其接口分类&lt;/p&gt;
&lt;p&gt;    2、添加接口分类的接口&lt;/p&gt;
&lt;p&gt;    3、获取某个分类下的接口&lt;/p&gt;
&lt;p&gt;    4、添加接口&lt;/p&gt;
&lt;p&gt;    5、获取接口信息&lt;/p&gt;
&lt;p&gt;    6、根据获取地址得倒 mock 的数据&lt;/p&gt;

&lt;p&gt;    主页代码：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://xiao-1251424696.cos.ap-guangzhou.myqcloud.com/24AC47E7-3498-4A16-89FC-813C644E85A6.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;219&quot; align=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    这里使用的  ejs  模版引擎，将分类和默认分类下的所有接口列表展示出来&lt;/p&gt;

&lt;p&gt;    添加分类代码：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://xiao-1251424696.cos.ap-guangzhou.myqcloud.com/ECE12BB2-586D-4AEA-8287-873C798617FC.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;381&quot; align=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    主要功能：&lt;/p&gt;
&lt;p&gt;    添加分类&lt;/p&gt;
&lt;p&gt;    1、将分类信息保存在 ./data/index.json 文件中。&lt;/p&gt;
&lt;p&gt;    2、创建一个分类 json 用于以后添加该分类下的 api 接口提供&lt;/p&gt;

&lt;p&gt;    获取分类代码：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://xiao-1251424696.cos.ap-guangzhou.myqcloud.com/55767601-B932-47EC-BCD7-0C722908DB6F.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;212&quot; align=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    主要功能：&lt;/p&gt;
&lt;p&gt;    1、获取 index.json 下的数据&lt;/p&gt;
&lt;p&gt;    2、获取对应分类 api json 的 api 数据列表&lt;/p&gt;

&lt;p&gt;    添加 api 接口代码：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://xiao-1251424696.cos.ap-guangzhou.myqcloud.com/353264AE-28DA-4922-AB99-2E0450FE0F18.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;331&quot; align=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    主要功能：&lt;/p&gt;
&lt;p&gt;    1、将接口添加到对应分类到 api json 中，便于调用和 mock 数据&lt;/p&gt;
&lt;p&gt;    2、将接口信息添加到 index.json 中，在 mock 调用到时候，快速到定位 mock 模版&lt;/p&gt;

&lt;p&gt;    获取 api 数据 / 获取 mock 数据代码：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://xiao-1251424696.cos.ap-guangzhou.myqcloud.com/F42FAC13-6508-46D7-B9C8-3246E434E879.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;366&quot; align=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    这里主要是最重要是：&lt;/p&gt;
&lt;p&gt;    将输入的数据转为 mock 数据，这里主要是 getMockData 方法。&lt;/p&gt;


&lt;h3&gt;5、xl_mock 用法&lt;/h3&gt;
&lt;p&gt;    1、全局安装&lt;/p&gt;
&lt;p&gt;    npm  install  -g  xl_mock&lt;/p&gt;

&lt;p&gt;    2、项目安装依赖&lt;/p&gt;
&lt;p&gt;    yarn   add   xl_mock&lt;/p&gt;

&lt;p&gt;    3、开启 mock 服务器&lt;/p&gt;
&lt;p&gt;    xl_mock  start  -p   3000&lt;/p&gt;

&lt;p&gt;    4、访问地址  http://127.0.0.0:3000/index.html&lt;/p&gt;
&lt;p&gt;    项目目录&lt;/p&gt;


&lt;h3&gt;　　代码刚刚开发完成，如若有不足或者建议请留言讨论.... &lt;/h3&gt;

&lt;h3&gt; 　&lt;a href=&quot;https://www.cnblogs.com/jiebba/p/9596707.html%20&quot; target=&quot;_blank&quot;&gt;博客园小结巴巴： https://www.cnblogs.com/jiebba/p/9596707.html &lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;   &lt;a href=&quot;https://gilea.cn/index&quot; target=&quot;_blank&quot;&gt; XiaoLong's Blog&lt;/a&gt;&lt;/h3&gt;




</description>
<pubDate>Thu, 06 Sep 2018 04:42:00 +0000</pubDate>
<dc:creator>小结巴巴吧</dc:creator>
<og:description>1、为什么要实现数据 mock 要理解为什么要实现数据 mock，我们可以提供几个场景来解释， 1、现在的开发很多都是前后端分离的模式，前后端的工作是不同的，当我们前端界面已经完成，但是后端的接口迟迟</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiebba/p/9596707.html</dc:identifier>
</item>
<item>
<title>Wepy--小程序自定义底部tabBar - _病猫</title>
<link>http://www.cnblogs.com/yk95/p/9597493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yk95/p/9597493.html</guid>
<description>&lt;p&gt;因为需求,小程序自带的tabBar不能满足, 所以只能来自己重新写一个. 先看效果图吧&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;首页:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471498/201809/1471498-20180906105814618-512419075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发现:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471498/201809/1471498-20180906105840738-625623093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471498/201809/1471498-20180906105937275-353834011.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471498/201809/1471498-20180906110006866-1445219230.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接下来看代码:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1- 组件-- tabBarBottom.wpy  这里页面也可以用循环来写, 不过就要在样式上再去调整, 我这里没有用循环, 就将就看吧..... &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　view 中的 c-y 与 c-gray 是公共样式中, 控制图标颜色的切换;  因为这里的图标我用的是阿里云图标, 不是图片, 可以自己替换成图片, 根据 selected 进行图片切换&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
    &amp;lt;view class=&quot;tabBarBox&quot;&amp;gt;
        &amp;lt;!-- 首页 --&amp;gt;
        &amp;lt;navigator class=&quot;itemView&quot; url=&quot;{{tabBar.list[0].pagePath}}&quot; open-type=&quot;redirect&quot; hover-class=&quot;none&quot;&amp;gt;
            &amp;lt;view class=&quot;item_icon {{tabBar.list[0].selected ? 'c-y' : 'c-gray'}} {{tabBar.list[0].icon_class}}&quot;&amp;gt;&amp;lt;/view&amp;gt;&lt;br/&gt;　　　　　　　　//如果替换成图片 写法  替换图片注意样式, 样式应该要进行调整&lt;br/&gt;　　　　　　　 //&amp;lt;image class=&quot;&quot; src=&quot;{{tabBar.list[0].selected ? 'tabBar.list[0].img_act' : 'tabBar.list[0].img'}}&quot;&amp;gt;
            &amp;lt;view class=&quot;item_text {{tabBar.list[0].selected ? 'c-y' : 'c-gray'}}&quot;&amp;gt;{{tabBar.list[0].text}}&amp;lt;/view&amp;gt;
        &amp;lt;/navigator&amp;gt;
        &amp;lt;!-- 发现 --&amp;gt;
        &amp;lt;navigator class=&quot;itemView&quot; url=&quot;{{tabBar.list[1].pagePath}}&quot; open-type=&quot;redirect&quot; hover-class=&quot;none&quot;&amp;gt;
            &amp;lt;view class=&quot;item_icon {{tabBar.list[1].selected ? 'c-y' : 'c-gray'}} {{tabBar.list[1].icon_class}}&quot;&amp;gt;&amp;lt;/view&amp;gt;
            &amp;lt;view class=&quot;item_text {{tabBar.list[1].selected ? 'c-y' : 'c-gray'}}&quot;&amp;gt;{{tabBar.list[1].text}}&amp;lt;/view&amp;gt;
        &amp;lt;/navigator&amp;gt;
        &amp;lt;!-- 发布 --&amp;gt;
        &amp;lt;view class=&quot;addView&quot;&amp;gt;
            &amp;lt;image class=&quot;add_icon&quot; src=&quot;../images/add.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
        &amp;lt;/view&amp;gt;
        &amp;lt;!-- 消息 --&amp;gt;
        &amp;lt;navigator class=&quot;itemView2 itemView&quot; url=&quot;{{tabBar.list[2].pagePath}}&quot; open-type=&quot;redirect&quot; hover-class=&quot;none&quot;&amp;gt;
            &amp;lt;view class=&quot;item_icon {{tabBar.list[2].selected ? 'c-y' : 'c-gray'}} {{tabBar.list[2].icon_class}}&quot;&amp;gt;&amp;lt;/view&amp;gt;
            &amp;lt;view class=&quot;item_text {{tabBar.list[2].selected ? 'c-y' : 'c-gray'}}&quot;&amp;gt;{{tabBar.list[2].text}}&amp;lt;/view&amp;gt;
        &amp;lt;/navigator&amp;gt;
        &amp;lt;!-- 我的 --&amp;gt;
        &amp;lt;navigator class=&quot;itemView&quot; url=&quot;{{tabBar.list[3].pagePath}}&quot; open-type=&quot;redirect&quot; hover-class=&quot;none&quot;&amp;gt;
            &amp;lt;view class=&quot;item_icon {{tabBar.list[3].selected ? 'c-y' : 'c-gray'}} {{tabBar.list[3].icon_class}}&quot;&amp;gt;&amp;lt;/view&amp;gt;
            &amp;lt;view class=&quot;item_text {{tabBar.list[3].selected ? 'c-y' : 'c-gray'}}&quot;&amp;gt;{{tabBar.list[3].text}}&amp;lt;/view&amp;gt;
        &amp;lt;/navigator&amp;gt;
        &amp;lt;!-- &amp;lt;view&amp;gt;&amp;lt;/view&amp;gt; --&amp;gt;
    &amp;lt;/view&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
import wepy from &lt;/span&gt;'wepy'&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; class tabBar extends wepy.component {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    props 接收父组件传递过来的值&lt;/span&gt;
    props =&lt;span&gt; {　　&lt;br/&gt;　　　　// 接收父级传递的tabBar信息
       tabBar: {
           type: Object,
           &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: {}
       }
    }

    components &lt;/span&gt;=&lt;span&gt; {
        
    }

    data &lt;/span&gt;=&lt;span&gt; {
        
    }

    onLoad() {
       
    }

    computed &lt;/span&gt;=&lt;span&gt; {}
    methods &lt;/span&gt;=&lt;span&gt; {
       
    }
    event &lt;/span&gt;=&lt;span&gt; {}
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;style lang=&quot;scss&quot;&amp;gt;&lt;span&gt;
    .tabBarBox{
        width: &lt;/span&gt;100%&lt;span&gt;;
        height: 100rpx;
        background&lt;/span&gt;-&lt;span&gt;color: #fff;
        position: fixed;
        bottom: &lt;/span&gt;0&lt;span&gt;;
        z&lt;/span&gt;-index: 9999&lt;span&gt;;
        border&lt;/span&gt;-&lt;span&gt;top: 1px #afafaf solid;
    }
    .itemView2{
        margin&lt;/span&gt;-&lt;span&gt;left: 150rpx;
    }
    .itemView{
        width: 150rpx;
        height: 100rpx;
        text&lt;/span&gt;-&lt;span&gt;align: center;
        display: inline&lt;/span&gt;-&lt;span&gt;block;
        padding&lt;/span&gt;-&lt;span&gt;top: 6rpx;
        .item_icon{
           font&lt;/span&gt;-&lt;span&gt;size: 50rpx;
        }
        .item_text{
            font&lt;/span&gt;-&lt;span&gt;size: 28rpx;
        }
    }
    .addView{
        width: 150rpx;
        position: fixed;
        bottom: &lt;/span&gt;0&lt;span&gt;;
        text&lt;/span&gt;-&lt;span&gt;align: center;
        display: inline&lt;/span&gt;-&lt;span&gt;block;
        .add_icon{
            width: 120rpx;
            height: 120rpx;
        }
    }
&lt;/span&gt;&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2- tabBar的数据 , 我放在了启动文件中 app.wpy&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   globalData =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     userInfo: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;br/&gt;　　　　// tabBar数据
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    tabBar:{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      list: [
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;           pagePath: &quot;home&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;           text: &quot;首页&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;           icon_class: &quot;iconfont icon-tab-home&quot;&lt;span&gt;,  //这里用的是阿里图标,  可以替换成图片
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;           selected: &lt;span&gt;true&lt;br/&gt;　　　　　　　　//图片写法&lt;br/&gt;&lt;/span&gt;　　　　　　　　// img: '未选中的图片路径',&lt;br/&gt;　　　　　　　　// img_act: '被选中的图片路径'&lt;br/&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;           pagePath: &quot;find&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;           text: &quot;发现&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;           icon_class: &quot;iconfont icon-tab-find&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;           selected: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }, 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;           pagePath: &quot;news&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;           text: &quot;消息&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;           icon_class: &quot;iconfont icon-tab-news&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;           selected: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;           pagePath: &quot;myInfo&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;           text: &quot;我的&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;           icon_class: &quot;iconfont icon-tab-my&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;           selected: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;      ]
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;  }&lt;br/&gt;　　　　// &lt;span&gt;处理tabBar中点击, 被点击,将当前的数据对象中 selected 改成true, 其余的就得改成 false;  这里的id是标识, 在调用时手动传入的; id 与 tabBar数组每一个对象索引要对应
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;  tabBarClickHandle(id, that) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;       let tbList = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.globalData.tabBar.list;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;       tbList.forEach((item, index) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt; (id ==&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;               tbList[id].selected = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;           } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;               tbList[index].selected = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;      });
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;      that.$apply();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.globalData.tabBar;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3- 首页中使用组件  剩余的 发现,消息,我的这三个页面中都是这样的用法, 都是这五步, 不过&lt;span&gt;剩余的三个 在第四步中 id要变  &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt; 发现--id-1  消息-&lt;/strong&gt;&lt;strong&gt;-id-2  我的&lt;/strong&gt;&lt;strong&gt;--id-3&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;template&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &amp;lt;view id=&quot;HomePage&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt;         &amp;lt;view&amp;gt;&lt;br/&gt;　　　　　　　　　　//&lt;span&gt; ⑤: 使用组件, 将数据传递给组件&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &amp;lt;tabBarBottom :tabBar.sync=&quot;tabBarData&quot;&amp;gt;&amp;lt;/tabBarBottom&amp;gt;
&lt;span&gt; 5&lt;/span&gt;         &amp;lt;/view&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;/view&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &amp;lt;/template&amp;gt;
&lt;span&gt; 8&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 9&lt;/span&gt; import wepy from 'wepy'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; import tabBarBottom from '@/components/tabBarBottom'&lt;span&gt;;  //&lt;span&gt;①:先导入组价 &lt;/span&gt;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; class Home extends wepy.page{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     config =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         navigationBarTitleText: &quot;&lt;span&gt;首页
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    components = {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        tabBarBottom,  // &lt;span&gt;② 声明组件
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    data = {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        tabBarData: {}, //③ 组件数据 &amp;lt;传递给组件的&amp;gt;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    onLoad() {&lt;br/&gt;　　　　　　　　//&lt;span&gt;④: 获取数据,更新数据  &lt;/span&gt;&lt;/span&gt;&lt;span&gt;tabBarClickHandle()启动文件中编写的---- 0就是形参id的实参&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        this.tabBarData = this.$parent.tabBarClickHandle(0, this);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        this.$apply();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    computed = {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    methods = {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    event = {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;慢慢积累,慢慢成长,加油!!&lt;/p&gt;
&lt;p&gt;文章中如果有错误,请您指出,我会第一时间去修改; &lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;①:&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 06 Sep 2018 03:45:00 +0000</pubDate>
<dc:creator>_病猫</dc:creator>
<og:description>因为需求,小程序自带的tabBar不能满足, 所以只能来自己重新写一个. 先看效果图吧 首页: 发现: 消息: 我的: 接下来看代码: 1- 组件-- tabBarBottom.wpy 这里页面也可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yk95/p/9597493.html</dc:identifier>
</item>
</channel>
</rss>