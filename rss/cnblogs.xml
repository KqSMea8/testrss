<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>1.Memcached 中文文档 - 概论（译官方文档） - 淡定的小孩</title>
<link>http://www.cnblogs.com/jingying/p/9456653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingying/p/9456653.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;原文地址：memcached手册     &lt;a href=&quot;https://github.com/memcached/memcached/wiki/Overview&quot; target=&quot;_blank&quot;&gt;https://github.com/memcached/memcached/wiki/Overview&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;简介&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Free &amp;amp; open source, high-performance, distributed memory object caching system&lt;/em&gt;, generic in nature, but intended for use in speeding up dynamic web applications by alleviating database load.&lt;/p&gt;
&lt;p&gt;免费，开源，高性能，分布式对象缓存数据库，一般在业界中，它的目的是通过减轻数据库负载来加速动态web应用程序。&lt;/p&gt;
&lt;p&gt;Memcached is an in-memory key-value store for small arbitrary data (strings, objects) from results of database calls, API calls, or page rendering.&lt;/p&gt;
&lt;p&gt;Memcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Memcached is simple yet powerful&lt;/em&gt;. Its simple design promotes quick deployment, ease of development, and solves many problems facing large data caches. Its API is available for most popular languages.&lt;/p&gt;
&lt;p&gt;Memcached简洁而强大。它的简洁设计便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题。它的API兼容大部分流行的开发语言。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Memcached is a developer tool, not a &quot;code accelerator&quot;, nor is it database middleware. If you're trying to set up an application you have downloaded or purchased to use memcached, read your app's documentation. This wiki and community will not be able to help you.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-0&quot;&gt;Memcached是一种开发工具，而不是“代码加速器”，也不是数据库中间件。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-1&quot;&gt;如果你试图建立一个你已经下载或购买的应用程序来使用memcached，请阅读你的应用程序的文档。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-2&quot;&gt;这个文档和社区将无法帮助你。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组成部分&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Client software, which is given a list of available memcached servers.&lt;/li&gt;
&lt;li&gt;A client-based hashing algorithm, which chooses a server based on the &quot;key&quot;.&lt;/li&gt;
&lt;li&gt;Server software, which stores values with their keys into an internal hash table.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;LRU, which determine when to throw out old data (if out of memory), or reuse memory.&lt;/p&gt;
&lt;h2&gt;Design Philosophy  设计理念&lt;/h2&gt;
&lt;h3&gt;Simple Key/Value Store    简单的键/值 存储&lt;/h3&gt;
&lt;p&gt;The server does not care what your data looks like. Items are made up of a key, an expiration time, optional flags, and raw data. It does not understand data structures; you must upload data that is pre-serialized. Some commands (incr/decr) may operate on the underlying data, but in a simple manner.&lt;/p&gt;
&lt;p&gt;Memcached不关心你的数据是什么。items由一个key，一个过期时间，可选择的标记，还有一个数据。它不了解数据结构，所以你必须提交一个已经序列化的数据给它。一些命令（incr/decr）可以用简单的方式对底层数据进行操作。 &lt;/p&gt;
&lt;h3&gt;Logic Half in Client, Half in Server   逻辑处理一半在客户端，一半在服务器&lt;/h3&gt;
&lt;p&gt;A &quot;memcached implementation&quot; is partially in a client, and partially in a server. Clients understand how to choose which server to read or write to for an item, what to do when it cannot contact a server.&lt;/p&gt;
&lt;p&gt;memcached的实现，部分在客户端，部分在服务器。客户端知道如何选择要为项目读取或写入的服务器，以及在无法联系服务器时要执行的操作。&lt;/p&gt;
&lt;p&gt;The servers understand how store and fetch items. They also manage when to evict or reuse memory.&lt;/p&gt;
&lt;p&gt;服务器了解如何存储和获取数据。 他们也可以从内存中移除数据或者复用数据。&lt;/p&gt;
&lt;h3&gt;Servers are Disconnected From Each Other 服务器彼此之间是无连接的&lt;/h3&gt;
&lt;p&gt;Memcached servers are unaware of each other. There is no crosstalk, no syncronization, no broadcasting, no replication. Adding servers increases the available memory. Cache invalidation is simplified, as clients delete or overwrite data on the server which owns it directly.&lt;/p&gt;
&lt;p&gt;Memcached服务器彼此之间是无联系的。它们之间没有串扰，没有同步，没有广播，没有复制。添加服务器，就会增加可用内存。让缓存失效的操作很简单，你可以让客户端删除这条记录或者覆盖服务器上面的数据。&lt;/p&gt;
&lt;h3&gt;O(1)  最低的时空复杂度&lt;/h3&gt;
&lt;p&gt;All commands are implemented to be as fast and lock-friendly as possible. This gives allows near-deterministic query speeds for all use cases.&lt;/p&gt;
&lt;p&gt;全部的命令实现起来都是非常快的并且对锁尽可能的友好。对查询速度速度也是非常快的。&lt;/p&gt;
&lt;p&gt;Queries on slow machines should run in well under 1ms. High end servers can serve millions of keys per second in throughput.&lt;/p&gt;
&lt;p&gt;慢速机器上的查询应该在1ms以下运行。 高端服务器的吞吐量可以达到每秒数百万个密钥。&lt;/p&gt;
&lt;h3&gt;Forgetting is a Feature  缓存过期&lt;/h3&gt;
&lt;p&gt;Memcached is, by default, a Least Recently Used cache. Items expire after a specified amount of time. Both of these are elegant solutions to many problems; Expire items after a minute to limit stale data being returned, or flush unused data in an effort to retain frequently requested information.&lt;/p&gt;
&lt;p&gt; 数据在指定的时间后过期。 这些都是许多问题的优雅解决方案; 一分钟后过期数据以限制返回的陈旧数据，或将缓存中未使用的数据替换为经常请求的信息数据。&lt;/p&gt;
&lt;h3&gt;Cache Invalidation  缓存失效&lt;/h3&gt;
&lt;p&gt;Rather than broadcasting changes to all available hosts, clients directly address the server holding the data to be invalidated&lt;/p&gt;
&lt;p&gt;客户机不直接向所有可用主机广播更改，而是直接向服务器保存数据，以使其失效。&lt;/p&gt;

</description>
<pubDate>Wed, 15 Aug 2018 15:52:00 +0000</pubDate>
<dc:creator>淡定的小孩</dc:creator>
<og:description>原文地址：memcached手册 https://github.com/memcached/memcached/wiki/Overview 简介 Free &amp; open source, hig</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jingying/p/9456653.html</dc:identifier>
</item>
<item>
<title>NetBeans远程调试Linux c++ 11项目 - SolidMango</title>
<link>http://www.cnblogs.com/pugang/p/9484685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pugang/p/9484685.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;NetBeans远程调试Linux c++ 11项目&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;由于好多原因，好久没有写博客了，随着c++ 11的普及率越来越高，开发c++ 项目的人也越来越多，可以说c++ 11 给了c++ 这门语言第二次生命，而且据笔者了解，使用c++ 11 新开发的项目大部分是基于linux的，具体原因不多解释。当然c++圈子里面开发工具百花齐放，有人喜欢使用vi作为主力开发工具，有人用eclipse, 有人用visual studio, 也有人喜欢clion, 抛开个人偏好不谈，我们来谈一下远程调试的支持。 说实话，调试体验最好的个人认为是直接SSH连上去GDB调试，但是这样做有一个问题就是修改代码，和跳转代码不是特别友好，如果需要大量改代码，分析逻辑，同时调试，可能开发体验不是特别好。笔者要介绍的是一种基于NetBeans远程调试Linux c++ 11项目，具体效果如下。其实NetBeans最早是作为Java开发工具而出名的，因此很多人没有太注意他其实也可以开发c++项目，而且对makefile/cmake的支持还比较出众。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/60039/201808/60039-20180815224922717-139240529.png&quot; alt=&quot;&quot; width=&quot;880&quot; height=&quot;474&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;示例代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * power - Calculate the power of number.
 * @param base: Base value.
 * @param exponent: Exponent value.
 *
 * @return base raised to the power exponent.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt; power(&lt;span&gt;double&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; exponent)
{    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result = &lt;span&gt;base&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (exponent == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; exponent; ++&lt;span&gt;i){
        result &lt;/span&gt;= result * &lt;span&gt;base&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (argc &amp;lt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;){
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Usage: %s base exponent \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, argv[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; &lt;span&gt;base&lt;/span&gt; = atof(argv[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; exponent = atoi(argv[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; result = power(&lt;span&gt;base&lt;/span&gt;&lt;span&gt;, exponent);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%g ^ %d is %g\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;base&lt;/span&gt;&lt;span&gt;, exponent, result);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
cmake_minimum_required (VERSION &lt;span&gt;2.8&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;(CMAKE_BUILD_TYPE &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;(CMAKE_CXX_FLAGS_DEBUG &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$ENV{CXXFLAGS} -O0 -Wall -g -ggdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;(CMAKE_CXX_FLAGS_RELEASE &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$ENV{CXXFLAGS} -O3 -Wall&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

project (Demo1)
add_executable(Demo main.cc)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;但是远程调试是需要设置的，而且网上这方面的资料不是特别多，那么我就把重点的部分和大家分享一下，第一个重点的设置是下图的&lt;strong&gt;构建结果&lt;/strong&gt;，这项必须要要填，NetBeans根据这个去找可执行文件，否则会报如下的错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/60039/201808/60039-20180815225338309-1015998595.png&quot; alt=&quot;&quot; width=&quot;673&quot; height=&quot;264&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/60039/201808/60039-20180815225958626-891366605.png&quot; alt=&quot;&quot; width=&quot;421&quot; height=&quot;264&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二个问题是NetBeans远程attach到进程的时候会报如下到错误 gdb attach fails with ptrace: Operation not permitted， 解决方案如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;echo&lt;/span&gt; 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本位给出了一种基于NetBeans的linux c++ 11 远程调试方案，NetBeans远程调试对makefile和cmake工程都有比较好的支持，亲测可用。使用NetBeans远程调试的另外一个好处是代码跳转比较方便，再也不用配置mingw/cygwin了，因为我们已经可以在linux文件系统中随意跳转了。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 15 Aug 2018 15:25:00 +0000</pubDate>
<dc:creator>SolidMango</dc:creator>
<og:description>NetBeans远程调试Linux c++ 11项目 由于好多原因，好久没有写博客了，随着c++ 11的普及率越来越高，开发c++ 项目的人也越来越多，可以说c++ 11 给了c++ 这门语言第二次生</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pugang/p/9484685.html</dc:identifier>
</item>
<item>
<title>网络模型探究 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/network-model.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/network-model.html</guid>
<description>&lt;p&gt;计算机网络是指由通信线路互相连接的许多自主工作的计算机构成的集合体，各个部件之间以何种规则进行通信，就是网络模型研究的问题。&lt;br/&gt;网络模型一般是指OSI七层参考模型和TCP/IP四层参考模型。这两个模型在网络中应用最为广泛。&lt;/p&gt;
&lt;h2 id=&quot;osi七层模型&quot;&gt;OSI七层模型&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;物理层(Physical Layer)&lt;/li&gt;
&lt;li&gt;数据链路层(Data-Link Layer)&lt;/li&gt;
&lt;li&gt;网络层(Network Layer)&lt;/li&gt;
&lt;li&gt;传输层(Transport Layer)&lt;/li&gt;
&lt;li&gt;会话层(Session Layer)&lt;/li&gt;
&lt;li&gt;表示层(Presentation Layer)&lt;/li&gt;
&lt;li&gt;应用层(Application Layer)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中低三层即物理层、数据链路层和网络层用于实现通信子网中的信息传输，或者说它们是面向通信的（一般称之为通信子网），&lt;br/&gt;最高三层即会话层、表示层和应用层是向应用进程提供资源子网功能的服务，因此他们是面向应用的，&lt;br/&gt;中间层即传输层，它是在高三层和低三层之间起桥梁作用。&lt;/p&gt;
&lt;h3 id=&quot;物理层&quot;&gt;物理层&lt;/h3&gt;
&lt;p&gt;物理层是建立在通讯介质的基础上实现系统和通讯介质的接口功能，为数据链路实体之间透明的传输比特流提供服务。&lt;/p&gt;
&lt;p&gt;物理层的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;物理链接的建立和拆除（通信前建立链接，通信结束拆除链接）&lt;/li&gt;
&lt;li&gt;物理服务数据单元传输（数据的发送和接收）&lt;/li&gt;
&lt;li&gt;物理层管理（管理本层的某些事务如功能的激活、差错控制等）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;数据链路层&quot;&gt;数据链路层&lt;/h3&gt;
&lt;p&gt;数据链路层的主要用途是在相邻两系统的网络实体之间建立、维持和释放数据链路链接，以及正确无误的传输数据链路服务数据单元。&lt;/p&gt;
&lt;p&gt;数据链路层功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据链路连接的建立和释放&lt;/li&gt;
&lt;li&gt;数据链路协议数据单元的形成&lt;/li&gt;
&lt;li&gt;定界和同步&lt;/li&gt;
&lt;li&gt;顺序和流量控制&lt;/li&gt;
&lt;li&gt;差错检测和恢复&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;网络层&quot;&gt;网络层&lt;/h3&gt;
&lt;p&gt;网络层主要涉及通信子网和主机的接口，网络层提供建立、维持和释放网络连接的手段，以实现两个端系统中传输实体间的通信。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网络层的功能
&lt;ul&gt;&lt;li&gt;网络连接服务&lt;/li&gt;
&lt;li&gt;路径选择（两个网络地址之间选择一条适当的传输路径）&lt;/li&gt;
&lt;li&gt;网络连接多路复用&lt;/li&gt;
&lt;li&gt;分段与组段&lt;/li&gt;
&lt;li&gt;有序传输和流量控制&lt;/li&gt;
&lt;li&gt;差错的检测和恢复&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;网络层提供的数据传输服务
&lt;ul&gt;&lt;li&gt;数据报服务（收、发双方无需建立连接）&lt;/li&gt;
&lt;li&gt;虚电路服务（通信双方之间建立一条虚电路进行通信）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;传输层&quot;&gt;传输层&lt;/h3&gt;
&lt;p&gt;传输层在低三层和高三层间起桥梁作用，该层消除了 OSI 高层所要求的服务与各类网络层所提供的服务之间的差异，具体表现在以下三方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;传输出错率和建立连接的失败率（传输层应针对不同的网络服务再增加相应的服务使之满足高层的要求）&lt;/li&gt;
&lt;li&gt;数据传输速率、吞吐量和传输时延（如果通信子网所提供的这几项指标不能满足上层要求，传输层应增加相应措施改善这些指标）&lt;/li&gt;
&lt;li&gt;分段和组段功能（网络层所传输的数据单元大小是一定的，但会话层数据单元大小是任意的，传输层应具有分段和组段的功能，通过对会话层数据单元进行分段、组段来构成适合在网络连接上传送的数据单元）&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;会话层&quot;&gt;会话层&lt;/h3&gt;
&lt;p&gt;会话层的作用是对基本的传输连接服务进行“增值”，以提供一个能满足多方面要求的会话连接服务。&lt;/p&gt;
&lt;p&gt;会话层的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;半双工通信&lt;/li&gt;
&lt;li&gt;更有效的差错纠正机制&lt;/li&gt;
&lt;li&gt;允许暂停发送消息&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;表示层&quot;&gt;表示层&lt;/h3&gt;
&lt;p&gt;表示层主要用途是对不同系统的表示方法进行转换，消除网内各应用实体之间的语言差异以实现不同系统之间的数据交换。&lt;/p&gt;
&lt;p&gt;表现层功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;协商各种传送语法以实现传送语法和本地语法的交换&lt;/li&gt;
&lt;li&gt;数据加密&lt;/li&gt;
&lt;li&gt;数据压缩&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;应用层&quot;&gt;应用层&lt;/h3&gt;
&lt;p&gt;应用层为应用进程访问 OSI 环境提供了手段，并直接为应用进程服务。&lt;/p&gt;
&lt;p&gt;应用层所提供的服务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;公共应用服务元素（提供应用层中最基本的服务）&lt;/li&gt;
&lt;li&gt;特定应用服务元素（为特定需要提供服务如文件传送、虚拟终端等）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;tcpip四层模型&quot;&gt;TCP/IP四层模型&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;网络访问层/网络接口层&lt;/li&gt;
&lt;li&gt;网络互连层/网际层&lt;/li&gt;
&lt;li&gt;传输层&lt;/li&gt;
&lt;li&gt;应用层&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;网络访问层&quot;&gt;网络访问层&lt;/h3&gt;
&lt;p&gt;在源主机系统，网络访问层接收由网络互连层送下来的IP数据报，并对它做一些处理后，将它发送给选定的网络，再将它传送给目标主机。目标主机系统的网络访问层接收由目标主机物理层向上传送的IP数据包，经处理后，再向上是那个给网络互连层。&lt;/p&gt;
&lt;p&gt;网络访问层关注的是两个端系统之间的数据通信，以及两个端系统借以通信的网络类型。&lt;/p&gt;
&lt;h3 id=&quot;网络互连层&quot;&gt;网络互连层&lt;/h3&gt;
&lt;p&gt;网络互连层是 TCP/IP 模型中最重要的层次，其中的IP协议主要用于异构型网络之间的相互连接和路由选择。&lt;/p&gt;
&lt;p&gt;IP 所提供的是面向无连接的、不可靠的传输服务，它可使由源主机发送的IP数据包穿越由各种WAN和不同LAN互连形成的互连网络，到达目标主机。&lt;/p&gt;
&lt;h3 id=&quot;传输层-1&quot;&gt;传输层&lt;/h3&gt;
&lt;p&gt;传输层中最主要的协议是传输控制协议TCP，它所提供的是面向连接的、可靠的端到端的通信机制。TCP协议是建立再网络层的基础上的，在制定TCP时，已考虑到它所依赖的通信子网可能是不可靠的，因此，TCP协议张采取了增强可靠性的措施以确保传输层能正确无误地运行。&lt;br/&gt;UDP也是属于传输层的协议，UDP是一种无连接、不可靠的协议。&lt;/p&gt;
&lt;h3 id=&quot;应用层-1&quot;&gt;应用层&lt;/h3&gt;
&lt;p&gt;应用层提供了许多用于支持各种应用程序的网络服务，相应地，在应用层有许多应用层协议，如FTP,SMTP,TELNET,SNMP,HTTP,DNS等&lt;/p&gt;
&lt;h2 id=&quot;对比&quot;&gt;对比&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2432073-05187b4806ec7649.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;network model&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2432073-41b4ae06665f8e4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;tcp/ip&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Wed, 15 Aug 2018 15:19:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>网络模型 计算机网络是指由通信线路互相连接的许多自主工作的计算机构成的集合体，各个部件之间以何种规则进行通信，就是网络模型研究的问题。 网络模型一般是指OSI七层参考模型和TCP/IP四层参考模型。这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weihanli/p/network-model.html</dc:identifier>
</item>
<item>
<title>pyinstaller打包注意事项 - guangzhao17</title>
<link>http://www.cnblogs.com/guangzhao17/p/9484661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guangzhao17/p/9484661.html</guid>
<description>&lt;p&gt;&lt;span&gt;pyinstaller是可以加密的，目前是最好用的一个，通过对比py2exe，nutika等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;环境 3.6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;命令行用法：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;pyinstaller.exe --key 1234567890123456 -F -w -i icon_filepath --paths=C:\Python36\Lib\site-packages\PyQt5\Qt\bin;C:\Python36\Lib\site-packages\PyQt5\Qt\plugins hello.py&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数解释：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;--key 加密&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-F 1个文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-w 表示是带界面的程序。则打包后没有cmd窗口。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-i icon图标位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完整：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-F, –onefile 产生一个文件用于部署 (参见XXXXX).&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-D, –onedir 产生一个目录用于部署 (默认)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-K, –tk 在部署时包含 TCL/TK&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-a, –ascii 不包含编码.在支持Unicode的python版本上默认包含所有的编码.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-d, –debug 产生debug版本的可执行文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-w,–windowed,–noconsole 使用Windows子系统执行.当程序启动的时候不会打开命令行(只对Windows有效)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-c,–nowindowed,–console 使用控制台子系统执行(默认)(只对Windows有效)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-s,–strip 可执行文件和共享库将run through strip.注意Cygwin的strip往往使普通的win32 Dll无法使用.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-X, –upx 如果有UPX安装(执行Configure.py时检测),会压缩执行文件(Windows系统中的DLL也会)(参见note)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-o DIR, –out=DIR 指定spec文件的生成目录,如果没有指定,而且当前目录是PyInstaller的根目录,会自动创建一个用于输出(spec和生成的可执行文件)的目录.如果没有指定,而当前目录不是PyInstaller的根目录,则会输出到当前的目录下.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-p DIR, –path=DIR 设置导入路径(和使用PYTHONPATH效果相似).可以用路径分割符(Windows使用分号,Linux使用冒号)分割,指定多个目录.也可以使用多个-p参数来设置多个导入路径&lt;/span&gt;&lt;br/&gt;&lt;span&gt;–icon=&amp;lt;FILE.ICO&amp;gt; 将file.ico添加为可执行文件的资源(只对Windows系统有效)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;–icon=&amp;lt;FILE.EXE,N&amp;gt; 将file.exe的第n个图标添加为可执行文件的资源(只对Windows系统有效)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-v FILE, –version=FILE 将verfile作为可执行文件的版本资源(只对Windows系统有效)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-n NAME, –name=NAME 可选的项目(产生的spec的)名字.如果省略,第一个脚本的主文件名将作为spec的名字&lt;/span&gt;&lt;br/&gt;&lt;span&gt;————————&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;错误：1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;打开命令行输入x.exe回车发现错误：ModuleNotFoundError：No module named typedefs，经过不断搜索发现是sklearn和scipy库的问题，有些库不能自动导入，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在.spec文件中将hiddenimports=[]修改为：hiddenimports=['cython', 'sklearn', 'sklearn.ensemble','sklearn.neighbors.typedefs','sklearn.neighbors.quad_tree','sklearn.tree._utils','scipy._lib.messagestream']后，再运行命令pyinstaller x.spec，等它跑完之后再点击.exe文件会发现这个错误没有了~（好像是和pandas，scipy，sklearn相关的导入错误都可以这样QAQ）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;错误：2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;错误：This application failed to start because it could not find or load the Qt platform plugin &quot;windows&quot;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;缺少Qt组件无法正常启动，参考网上的评论，需要有...\Qt\plugins\platforms这个文件夹，把这个文件夹拷贝到和.exe文件一个路径下，最终完美解决，出现了想要的Qt界面~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要注意的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.1 如果你的GUI程序带有图片（或者其它资源）的文件夹（我的是在\res文件夹下），需要把这个文件夹拷贝到.exe文件同一路径下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.2 如果你的.py文件不止一个，仅仅需要把其它.py文件都放在一个目录下，只对入口.py文件打包即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;错误：4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;database error: driver not loadd driver not loaded&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制 C:\Python36\Lib\site-packages\PyQt5\Qt\plugins 里面的 sqldriver 文件夹到exe所在目录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;错误：5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;路径问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;spec文件举例：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# -*- mode: python -*-&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;block_cipher = pyi_crypto.PyiBlockCipher(key='0123456789123456')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;a = Analysis(['1.py', '2.py'],&lt;/span&gt;&lt;br/&gt;&lt;span&gt;pathex=['D:\\0软件设计\\aa&lt;/span&gt;&lt;span&gt;软件版'],&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;binaries=[],&lt;/span&gt;&lt;br/&gt;&lt;span&gt;datas=[],&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hiddenimports=[],&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hookspath=[],&lt;/span&gt;&lt;br/&gt;&lt;span&gt;runtime_hooks=[],&lt;/span&gt;&lt;br/&gt;&lt;span&gt;excludes=[],&lt;/span&gt;&lt;br/&gt;&lt;span&gt;win_no_prefer_redirects=False,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;win_private_assemblies=False,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;cipher=block_cipher)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;pyz = PYZ(a.pure, a.zipped_data,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;cipher=block_cipher)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;exe = EXE(pyz,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a.scripts,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a.binaries,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a.zipfiles,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a.datas,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;name='XX.exe',&lt;/span&gt;&lt;br/&gt;&lt;span&gt;debug=False,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;strip=False,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;upx=True,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;runtime_tmpdir=None,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console=False ,&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;icon='XXXX.ico')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——————&lt;/span&gt;&lt;br/&gt;&lt;span&gt;pyinstaller xx.spec&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;千万注意，如果pyinstaller文件夹内放入UPX后，虽然可以压缩文件，但不知道为什么，打包带pyqt5的代码，exe运行会导致下面的错误。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;切记，切记。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DLL load failed: 内存位置访问无效。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Traceback (most recent call last):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;File &quot;xunlei_cdk_jihuo_0811.py&quot;, line 29, in &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;File &quot;c:\python36\lib\site-packages\PyInstaller\loader\pyimod03_importers.py&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;line 714, in load_module&lt;/span&gt;&lt;br/&gt;&lt;span&gt;module = loader.load_module(fullname)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ImportError: DLL load failed: 内存位置访问无效。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 15:16:00 +0000</pubDate>
<dc:creator>guangzhao17</dc:creator>
<og:description>pyinstaller是可以加密的，目前是最好用的一个，通过对比py2exe，nutika等。 环境 3.6 命令行用法：pyinstaller.exe --key 1234567890123456</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guangzhao17/p/9484661.html</dc:identifier>
</item>
<item>
<title>【java算法】---余弦相似度计算字符串相似率 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9484274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9484274.html</guid>
<description>&lt;p&gt;&lt;strong&gt;功能需求&lt;/strong&gt;：最近在做通过爬虫技术去爬取各大相关网站的新闻，储存到公司数据中。这里面就有一个技术点，就是如何保证你已爬取的新闻，再有相似的新闻&lt;/p&gt;
&lt;p&gt;               或者一样的新闻，那就不存储到数据库中。（因为有网站会去引用其它网站新闻，或者把其它网站新闻拿过来稍微改下内容就发布到自己网站中）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解析方案&lt;/strong&gt;：最终就是采用余弦相似度算法，来计算两个新闻正文的相似度。现在自己写一篇博客总结下。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、理论知识&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;先推荐一篇博客，对于余弦相似度算法的理论讲的比较清晰，我们也是按照这个方式来计算相似度的。网址：&lt;a href=&quot;https://blog.csdn.net/zz_dd_yy/article/details/51926305&quot; target=&quot;_blank&quot;&gt;相似度算法之余弦相似度&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、说重点&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  我这边先把计算两个字符串的相似度理论知识再梳理一遍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）&lt;span&gt;首先是要明白通过向量来计算相识度公式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201808/1090617-20180815214058330-1312704165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）明白：&lt;span&gt;余弦值越接近1，也就是两个向量越相似，这就叫&quot;余弦相似性&quot;，&lt;/span&gt;&lt;br/&gt;                 &lt;span&gt;余弦值越接近0，也就是两个向量越不相似，也就是这两个字符串越不相似&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;&lt;br/&gt;&lt;span&gt;2、案例理论知识&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;举一个例子来说明，用上述理论计算文本的相似性。为了简单起见，先从句子着手。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;句子A&lt;/strong&gt;&lt;/span&gt;：这只皮靴号码大了。那只号码合适。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;句子B&lt;/span&gt;&lt;/strong&gt;：这只皮靴号码不小，那只更合适。&lt;/p&gt;
&lt;p&gt;怎样计算上面两句话的相似程度？&lt;/p&gt;
&lt;p&gt;基本思路是：如果这两句话的用词越相似，它们的内容就应该越相似。因此，可以从词频入手，计算它们的相似程度。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步，分词。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;句子A：这只/皮靴/号码/大了。那只/号码/合适。&lt;/p&gt;
&lt;p&gt;句子B：这只/皮靴/号码/不/小，那只/更/合适。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步，计算词频。&lt;/span&gt;（也就是每个词语出现的频率）&lt;/p&gt;
&lt;p&gt;句子A：这只1，皮靴1，号码2，大了1。那只1，合适1，不0，小0，更0&lt;/p&gt;
&lt;p&gt;句子B：这只1，皮靴1，号码1，大了0。那只1，合适1，不1，小1，更1&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步，写出词频向量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　句子A：(1，1，2，1，1，1，0，0，0)&lt;/p&gt;
&lt;p&gt;　　句子B：(1，1，1，0，1，1，1，1，1)&lt;/p&gt;
&lt;p&gt;第四步：运用上面的公式：计算如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201808/1090617-20180815214345288-1095555724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;计算结果中夹角的余弦值为0.81非常接近于1，所以，上面的句子A和句子B是基本相似的&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、实际开发案例 &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;    我把我们实际开发过程中字符串相似率计算代码分享出来。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;  1、pom.xml&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  展示一些主要jar包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;结合操作工具包&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.commons&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;commons-lang3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;bean实体注解工具包&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.projectlombok&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;lombok&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;汉语言包，主要用于分词&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.hankcs&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hanlp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;portable-1.6.5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;2、main方法&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 计算两个字符串的相识度
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Similarity {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;  String content1=&quot;今天小小和爸爸一起去摘草莓，小小说今天的草莓特别的酸，而且特别的小，关键价格还贵&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;  String content2=&quot;今天小小和妈妈一起去草原里采草莓，今天的草莓味道特别好，而且价格还挺实惠的&quot;&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;  score=&lt;span&gt;CosineSimilarity.getSimilarity(content1,content2);
        System.out.println(&lt;/span&gt;&quot;相似度：&quot;+&lt;span&gt;score);

        score&lt;/span&gt;=&lt;span&gt;CosineSimilarity.getSimilarity(content1,content1);
        System.out.println(&lt;/span&gt;&quot;相似度：&quot;+&lt;span&gt;score);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先看运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201808/1090617-20180815215306072-1733815165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 通过运行结果得出：&lt;/p&gt;
&lt;p&gt;  （1）第一次比较相似率为：0.772853 （说明这两条句子还是挺相似的），第二次比较相似率为：1.0  （说明一模一样）。&lt;/p&gt;
&lt;p&gt;  （2）我们可以看到这个句子的分词效果，后面是词性。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、Tokenizer（分词工具类）&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.hankcs.hanlp.HanLP;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.hankcs.hanlp.seg.common.Term;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.stream.Collectors;


&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 中文分词工具类&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Tokenizer {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 分词&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Word&amp;gt;&lt;span&gt; segment(String sentence) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、 采用HanLP中文自然语言处理中标准分词进行分词&lt;/span&gt;
        List&amp;lt;Term&amp;gt; termList =&lt;span&gt; HanLP.segment(sentence);
&lt;br/&gt;&lt;span&gt;//上面控制台打印信息就是这里输出的&lt;/span&gt;
        System.out.println(termList.toString());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、重新封装到Word对象中（term.word代表分词后的词语，term.nature代表改词的词性）&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; termList.stream().map(term -&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Word(term.word, term.nature.toString())).collect(Collectors.toList());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;4、Word（封装分词结果）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这里面真正用到的其实就&lt;span&gt;词名和权重。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.Data;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Objects;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 封装分词结果&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Data
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Word &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Comparable {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 词名&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 词性&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String pos;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 权重，用于词向量分析&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Float weight;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Word(String name, String pos) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.pos =&lt;span&gt; pos;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Objects.hashCode(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getClass() !=&lt;span&gt; obj.getClass()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Word other =&lt;span&gt; (Word) obj;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Objects.equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name, other.name);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        StringBuilder str &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            str.append(name);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pos != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            str.append(&lt;/span&gt;&quot;/&quot;&lt;span&gt;).append(pos);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str.toString();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(Object o) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; o) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.name == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Word)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
        }
        String t &lt;/span&gt;=&lt;span&gt; ((Word) o).getName();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name.compareTo(t);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;5、CosineSimilarity（相似率具体实现工具类）&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.jincou.algorithm.tokenizer.Tokenizer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.jincou.algorithm.tokenizer.Word;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.lang3.StringUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.CollectionUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.math.BigDecimal;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ConcurrentHashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicInteger;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 判定方式：余弦相似度，通过计算两个向量的夹角余弦值来评估他们的相似度 余弦夹角原理： 向量a=(x1,y1),向量b=(x2,y2) similarity=a.b/|a|*|b| a.b=x1x2+y1y2
 * |a|=根号[(x1)^2+(y1)^2],|b|=根号[(x2)^2+(y2)^2]&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CosineSimilarity {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(CosineSimilarity.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/**
     * 1、计算两个字符串的相似度
     */&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getSimilarity(String text1, String text2) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果wei空，或者字符长度为0，则代表完全相同&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (StringUtils.isBlank(text1) &amp;amp;&amp;amp;&lt;span&gt; StringUtils.isBlank(text2)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1.0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果一个为0或者空，一个不为，那说明完全不相似&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (StringUtils.isBlank(text1) ||&lt;span&gt; StringUtils.isBlank(text2)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0.0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个代表如果两个字符串相等那当然返回1了（这个我为了让它也分词计算一下，所以注释掉了）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        if (text1.equalsIgnoreCase(text2)) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            return 1.0;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//第一步：进行分词&lt;/span&gt;
        List&amp;lt;Word&amp;gt; words1 =&lt;span&gt; Tokenizer.segment(text1);
        List&lt;/span&gt;&amp;lt;Word&amp;gt; words2 =&lt;span&gt; Tokenizer.segment(text2);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getSimilarity(words1, words2);
    }

    &lt;/span&gt;&lt;span&gt;/**
     * 2、对于计算出的相似度保留小数点后六位
     */&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; getSimilarity(List&amp;lt;Word&amp;gt; words1, List&amp;lt;Word&amp;gt;&lt;span&gt; words2) {

        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; score =&lt;span&gt; getSimilarityImpl(words1, words2);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(int) (score * 1000000 + 0.5)其实代表保留小数点后六位 ,因为1034234.213强制转换不就是1034234。对于强制转换添加0.5就等于四舍五入&lt;/span&gt;
        score = (&lt;span&gt;int&lt;/span&gt;) (score * 1000000 + 0.5) / (&lt;span&gt;double&lt;/span&gt;) 1000000&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; score;
    }

    &lt;/span&gt;&lt;span&gt;/**
     * 文本相似度计算 判定方式：余弦相似度，通过计算两个向量的夹角余弦值来评估他们的相似度 余弦夹角原理： 向量a=(x1,y1),向量b=(x2,y2) similarity=a.b/|a|*|b| a.b=x1x2+y1y2
     * |a|=根号[(x1)^2+(y1)^2],|b|=根号[(x2)^2+(y2)^2]
     */&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; getSimilarityImpl(List&amp;lt;Word&amp;gt; words1, List&amp;lt;Word&amp;gt;&lt;span&gt; words2) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向每一个Word对象的属性都注入weight（权重）属性值&lt;/span&gt;
&lt;span&gt;        taggingWeightByFrequency(words1, words2);

        &lt;/span&gt;&lt;span&gt;//第二步：计算词频
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过上一步让每个Word对象都有权重值，那么在封装到map中（key是词，value是该词出现的次数（即权重））&lt;/span&gt;
        Map&amp;lt;String, Float&amp;gt; weightMap1 =&lt;span&gt; getFastSearchMap(words1);
        Map&lt;/span&gt;&amp;lt;String, Float&amp;gt; weightMap2 =&lt;span&gt; getFastSearchMap(words2);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将所有词都装入set容器中&lt;/span&gt;
        Set&amp;lt;Word&amp;gt; words = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
        words.addAll(words1);
        words.addAll(words2);

        AtomicFloat ab &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AtomicFloat();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a.b&lt;/span&gt;
        AtomicFloat aa = &lt;span&gt;new&lt;/span&gt; AtomicFloat();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |a|的平方&lt;/span&gt;
        AtomicFloat bb = &lt;span&gt;new&lt;/span&gt; AtomicFloat();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |b|的平方

        &lt;/span&gt;&lt;span&gt;// 第三步：写出词频向量，后进行计算&lt;/span&gt;
        words.parallelStream().forEach(word -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;看同一词在a、b两个集合出现的此次&lt;/span&gt;
            Float x1 =&lt;span&gt; weightMap1.get(word.getName());
            Float x2 &lt;/span&gt;=&lt;span&gt; weightMap2.get(word.getName());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x1 != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; x2 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x1x2&lt;/span&gt;
                &lt;span&gt;float&lt;/span&gt; oneOfTheDimension = x1 *&lt;span&gt; x2;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;
&lt;span&gt;                ab.addAndGet(oneOfTheDimension);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x1 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(x1)^2&lt;/span&gt;
                &lt;span&gt;float&lt;/span&gt; oneOfTheDimension = x1 *&lt;span&gt; x1;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;
&lt;span&gt;                aa.addAndGet(oneOfTheDimension);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x2 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(x2)^2&lt;/span&gt;
                &lt;span&gt;float&lt;/span&gt; oneOfTheDimension = x2 *&lt;span&gt; x2;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;
&lt;span&gt;                bb.addAndGet(oneOfTheDimension);
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;|a| 对aa开方&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; aaa =&lt;span&gt; Math.sqrt(aa.doubleValue());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;|b| 对bb开方&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; bbb =&lt;span&gt; Math.sqrt(bb.doubleValue());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用BigDecimal保证精确计算浮点数
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;double aabb = aaa * bbb;&lt;/span&gt;
        BigDecimal aabb =&lt;span&gt; BigDecimal.valueOf(aaa).multiply(BigDecimal.valueOf(bbb));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;similarity=a.b/|a|*|b|
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;divide参数说明：aabb被除数,9表示小数点后保留9位，最后一个表示用标准的四舍五入法&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; cos = BigDecimal.valueOf(ab.get()).divide(aabb, 9&lt;span&gt;, BigDecimal.ROUND_HALF_UP).doubleValue();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cos;
    }


    &lt;/span&gt;&lt;span&gt;/**
     * 向每一个Word对象的属性都注入weight（权重）属性值
     */&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; taggingWeightByFrequency(List&amp;lt;Word&amp;gt; words1, List&amp;lt;Word&amp;gt;&lt;span&gt; words2) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (words1.get(0).getWeight() != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; words2.get(0).getWeight() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;词频统计（key是词，value是该词在这段句子中出现的次数）&lt;/span&gt;
        Map&amp;lt;String, AtomicInteger&amp;gt; frequency1 = getFrequency(words1);&lt;span&gt;
        Map&lt;/span&gt;&amp;lt;String, AtomicInteger&amp;gt; frequency2 =&lt;span&gt; getFrequency(words2);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是DEBUG模式输出词频统计信息
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        if (LOGGER.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            LOGGER.debug(&quot;词频统计1：\n{}&quot;, getWordsFrequencyString(frequency1));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            LOGGER.debug(&quot;词频统计2：\n{}&quot;, getWordsFrequencyString(frequency2));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标注权重（该词出现的次数）&lt;/span&gt;
        words1.parallelStream().forEach(word -&amp;gt; word.setWeight(frequency1.get(word.getName()).floatValue()));&lt;span&gt;
        words2.parallelStream().forEach(word &lt;/span&gt;-&amp;gt;&lt;span&gt; word.setWeight(frequency2.get(word.getName()).floatValue()));
    }

    &lt;/span&gt;&lt;span&gt;/**
     * 统计词频
     * @return 词频统计图
     */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, AtomicInteger&amp;gt; getFrequency(List&amp;lt;Word&amp;gt;&lt;span&gt; words) {

        Map&lt;/span&gt;&amp;lt;String, AtomicInteger&amp;gt; freq = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这步很帅哦&lt;/span&gt;
        words.forEach(i -&amp;gt; freq.computeIfAbsent(i.getName(), k -&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger()).incrementAndGet());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; freq;
    }

    &lt;/span&gt;&lt;span&gt;/**
     * 输出：词频统计信息
     */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String getWordsFrequencyString(Map&amp;lt;String, AtomicInteger&amp;gt;&lt;span&gt; frequency) {
        StringBuilder str &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (frequency != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;frequency.isEmpty()) {
            AtomicInteger integer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger();
            frequency.entrySet().stream().sorted((a, b) &lt;/span&gt;-&amp;gt; b.getValue().get() -&lt;span&gt; a.getValue().get()).forEach(
                    i &lt;/span&gt;-&amp;gt; str.append(&quot;\t&quot;).append(integer.incrementAndGet()).append(&quot;、&quot;).append(i.getKey()).append(&quot;=&quot;&lt;span&gt;)
                            .append(i.getValue()).append(&lt;/span&gt;&quot;\n&quot;&lt;span&gt;));
        }
        str.setLength(str.length() &lt;/span&gt;- 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str.toString();
    }

    &lt;/span&gt;&lt;span&gt;/**
     * 构造权重快速搜索容器
     */&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, Float&amp;gt; getFastSearchMap(List&amp;lt;Word&amp;gt;&lt;span&gt; words) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isEmpty(words)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.emptyMap();
        }
        Map&lt;/span&gt;&amp;lt;String, Float&amp;gt; weightMap = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;&lt;span&gt;(words.size());

        words.parallelStream().forEach(i &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i.getWeight() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;weightMap.put(i.getName(), i.getWeight());&lt;span&gt;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                LOGGER.error(&lt;/span&gt;&quot;no word weight info:&quot; +&lt;span&gt; i.getName());
            }
        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; weightMap;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个具体实现代码因为思维很紧密所以有些地方写的比较绕，同时为了性能提升还手写了AtomicFloat原子类。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;6、AtomicFloat原子类&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicInteger;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * jdk没有AtomicFloat，写一个
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AtomicFloat &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Number {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AtomicInteger bits;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AtomicFloat() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(0f);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AtomicFloat(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; initialValue) {
        bits &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger(Float.floatToIntBits(initialValue));
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;叠加&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; addAndGet(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; delta) {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; expect;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; update;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            expect &lt;/span&gt;=&lt;span&gt; get();
            update &lt;/span&gt;= expect +&lt;span&gt; delta;
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.compareAndSet(expect, update));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; update;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; getAndAdd(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; delta) {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; expect;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; update;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            expect &lt;/span&gt;=&lt;span&gt; get();
            update &lt;/span&gt;= expect +&lt;span&gt; delta;
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.compareAndSet(expect, update));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; expect;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; getAndDecrement() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getAndAdd(-1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; decrementAndGet() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; addAndGet(-1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; getAndIncrement() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getAndAdd(1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; incrementAndGet() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; addAndGet(1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; getAndSet(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; newValue) {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; expect;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            expect &lt;/span&gt;=&lt;span&gt; get();
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.compareAndSet(expect, newValue));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; expect;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; compareAndSet(&lt;span&gt;float&lt;/span&gt; expect, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; update) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bits.compareAndSet(Float.floatToIntBits(expect), Float.floatToIntBits(update));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; set(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; newValue) {
        bits.set(Float.floatToIntBits(newValue));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; get() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Float.intBitsToFloat(bits.get());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; floatValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; get();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; doubleValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;) floatValue();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; intValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) get();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; longValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;long&lt;/span&gt;&lt;span&gt;) get();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Float.toString(get());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;7、总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;把大致思路再捋一下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; （1）先分词： &lt;/strong&gt;分词当然要按一定规则，不然随便分那也没有意义，那这里通过&lt;span&gt;采用HanLP中文自然语言处理中标准分词进行分词。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt; （2）统计词频： &lt;/strong&gt;就统计上面词出现的次数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; （3）通过每一个词出现的次数，变成一个向量，通过向量公式计算相似率。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 我只是偶尔安静下来，对过去的种种思忖一番。那些曾经的旧时光里即便有过天真愚钝，也不值得谴责。毕竟，往后的日子，还很长。不断鼓励自己，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 天一亮，又是崭新的起点，又是未知的征程（上校3）&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 15 Aug 2018 14:44:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>余弦相似度计算字符串相似率 功能需求：最近在做通过爬虫技术去爬取各大相关网站的新闻，储存到公司数据中。这里面就有一个技术点，就是如何保证你已爬取的新闻，再有相似的新闻 或者一样的新闻，那就不存储到数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9484274.html</dc:identifier>
</item>
<item>
<title>Hibernate一级缓存测试分析 - 白超华</title>
<link>http://www.cnblogs.com/bc8web/p/java.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bc8web/p/java.html</guid>
<description>&lt;h4 id=&quot;hibernate的一级缓存就是指session缓存此session非http的session会话技术可以理解为jdbc的connection连接会话session缓存就是一块内存空间用来存放相互管理的java对象在使用hibernate查询对象的时候首先使用对象的oidobject-id在hibernate-的一级缓存空间进行查找如果通过oid匹配到了对象就直接从一级缓存中取出使用如果没有找到匹配该oid值的对象这才会进行查询数据库当从数据库中查询数据的时候该数据就会被放入到session缓存中目的就是为了减少数据库的访问次数从而提高性能&quot;&gt;Hibernate的一级缓存就是指Session缓存，此Session非http的session会话技术，可以理解为JDBC的Connection，连接会话，Session缓存就是一块内存空间，用来存放相互管理的java对象，在使用Hibernate查询对象的时候，首先使用对象的OID（&lt;code&gt;Object ID&lt;/code&gt;）在Hibernate 的一级缓存空间进行查找，如果通过OID匹配到了对象，就直接从一级缓存中取出使用，如果没有找到匹配该OID值的对象，这才会进行查询数据库。当从数据库中查询数据的时候，该数据就会被放入到Session缓存中，目的就是为了减少数据库的访问次数，从而提高性能。&lt;/h4&gt;
&lt;h2 id=&quot;hibernate缓存特点&quot;&gt;Hibernate缓存特点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;当应用程序调用Session接口的 &lt;strong&gt;save(), update(), saveOrUpdate()&lt;/strong&gt; 时候，如果缓存中没 有相应的对象，Hb就会自动的把查询信息加入到缓存。&lt;/li&gt;
&lt;li&gt;当应用程序调用Session接口的 &lt;strong&gt;load(), get(), list()&lt;/strong&gt; 等查询方法的时候，会进行判断缓存中是否有数据，同摘要。&lt;/li&gt;
&lt;li&gt;当应用程序调用Session接口的 &lt;strong&gt;close()&lt;/strong&gt; Session缓存会被清空&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;接下来进行测试一级缓存&quot;&gt;接下来进行测试一级缓存&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;首先测试一级缓存是否存在？对user表的主键为“1”的分别进行两次查询：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public void demo1 (){
        Session session = HibernateUtils.openSession();
        Transaction transaction = session.beginTransaction();
        
        User user1 = session.get(User.class, &quot;1&quot;);
        System.out.println(user1);
        System.out.println(&quot;-------------&quot;);
        User user2 = session.get(User.class, &quot;1&quot;);
        System.out.println(user2);
        System.out.println(user1 == user2);
        
        transaction.commit();
        session.close();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/901316/201808/901316-20180815204731169-1445605516.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们发现第一次执行Session的get()方法的时候，由于一级缓存中没有数据，所以会向数据库发送一条sql语句进行查询，第二次调用get()的时候，则不会发送sql语句，而是从一级缓存中取的，所以user和user2的内存地址相等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一级缓存的快照区&quot;&gt;### 一级缓存的快照区&lt;/h2&gt;
&lt;p&gt;Hibernate向一级缓存放入数据的时候，同时复制一份放到Hibernate快照中，当使用commot()提交事务的时候，同时会清理Session的一级缓存，这是会用&lt;code&gt;OID&lt;/code&gt;判断一级缓存中的对象和快照中的对象是否一致，如果一致则执行 update 语句，将缓存中的内容同步到数据库，并且更新快照，这也就实现了不使用 update 语句就可以自动更新数据库，Hibernate快照的作用也就是为了保持缓存中的数据和数据库中的数据的一致性。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;快照区代码测试&lt;br/&gt;我们在get的时候设置断点，看到右侧变量 session-&amp;gt;persitenceContext-&amp;gt;entitlxxx-&amp;gt;head，也就是缓存中是为空的&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/901316/201808/901316-20180815211553759-745894955.png&quot;/&gt;&lt;br/&gt;现在继续执行&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/901316/201808/901316-20180815211937967-377970790.png&quot;/&gt;&lt;br/&gt;我们发现在缓存区域已经有了数据了，同时Hibernate 也会在快照区域创建数据，在 Hibernate3 里面它使用的是Map进行存储的，map的key作为一级缓存去，value作为一级快照区，当进行查询的时候，会同时给缓存和快照去放入相同的数据，当orm对象属性发生变化的时候，会首先改变缓存区的值，当进行事务提交的时候，会比较缓存和快照的内容，如果一致则不操作，不一致则更新数据库。&lt;br/&gt;继续执行:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/901316/201808/901316-20180815213405380-732585390.png&quot;/&gt;&lt;br/&gt;commin()的时候，自动进行更新，clear().evict()的时候会清除缓存（删除表中数据的时候也会）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public void demo1 (){
        Session session = HibernateUtils.openSession();
        Transaction transaction = session.beginTransaction();
        
        User user1 = session.get(User.class, &quot;1&quot;);
        System.out.println(user1);
        System.out.println(&quot;-------------&quot;);
        session.clear();
        User user2 = session.get(User.class, &quot;1&quot;);
        System.out.println(user2);
        System.out.println(user1 == user2);
        
        transaction.commit();
        session.close();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输入如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;Hibernate: 
    select
        user0_.uid as uid1_1_0_,
        user0_.name as name2_1_0_,
        user0_.username as username3_1_0_,
        user0_.password as password4_1_0_,
        user0_.email as email5_1_0_,
        user0_.telephone as telephon6_1_0_,
        user0_.sex as sex7_1_0_ 
    from
        user user0_ 
    where
        user0_.uid=?
User{uid=1, username=baiChaoHua, password=null, name=null, email=null, telephone=null, birthady=null, sex=null, state=0, code=null}
-------------
Hibernate: 
    select
        user0_.uid as uid1_1_0_,
        user0_.name as name2_1_0_,
        user0_.username as username3_1_0_,
        user0_.password as password4_1_0_,
        user0_.email as email5_1_0_,
        user0_.telephone as telephon6_1_0_,
        user0_.sex as sex7_1_0_ 
    from
        user user0_ 
    where
        user0_.uid=?
User{uid=1, username=baiChaoHua, password=null, name=null, email=null, telephone=null, birthady=null, sex=null, state=0, code=null}
false&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可以看出执行执行了两次sql，user对象的内存地址也就自然不一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一级缓存常用的API：&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 13:46:00 +0000</pubDate>
<dc:creator>白超华</dc:creator>
<og:description>Hibernate 一级缓存测试分析 ===================== Hibernate的一级缓存就是指Session缓存，此Session非http的session会话技术，可以理解为J</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bc8web/p/java.html</dc:identifier>
</item>
<item>
<title>如何创建一个基于Node的HTTP服务器 - 余大彬</title>
<link>http://www.cnblogs.com/yuliangbin/p/9429062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuliangbin/p/9429062.html</guid>
<description>&lt;p&gt;首先创建一个HTTP服务器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; http = require('http'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; serve(request,response) {
    console.log(request.method);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求的方法&lt;/span&gt;
    console.log(request.url);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求里的url,只含有路径名，并不是完整的url&lt;/span&gt;
    console.log(request.header) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取请求头&lt;/span&gt;
&lt;span&gt;
    response.statusCode &lt;/span&gt;= 200&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置响应类型，编码为utf-8。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器返回资源给浏览器时，还应该告诉浏览器这是什么类型的文件，以什么方式解析。不指定的话可能会造成乱码&lt;/span&gt;
    response.setHeader('Content-Type','text/html;charset=utf-8'&lt;span&gt;);
    response.setHeader(&lt;/span&gt;'name','zfpx'&lt;span&gt;);
    response.write(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().toString());
    response.end();
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server =&lt;span&gt; http.createServer(serve);
server.listen(&lt;/span&gt;3000);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们希望读取其他文件的内容，则需要先导入fs模块，该模块是&lt;span&gt;读取文件的模块&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var fs = require('fs');&lt;/span&gt;&lt;br/&gt;function&lt;/span&gt;&lt;span&gt; serve(request,response) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url =&lt;span&gt; request.url;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置响应类型，编码为utf-8。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器返回资源给浏览器时，还应该告诉浏览器这是什么类型的文件，以什么方式解析&lt;/span&gt;
    response.setHeader('Content-Type','text/html;charset=utf-8'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果我们希望返回的是其他文件的内容，则需要先读取其他文件，这时需要fs模块来读取文件&lt;/span&gt;
    fs.readFile('index.html',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,data) {
        response.write(data);
        response.end();
    })
}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这样又有一个问题，就是：在对返回的HTML代码开始解析时，解析过程中如果遇到引用的服务器上的资源（额外的CSS，JS代码，图片等资源），需要再次向服务器发送请求，但是不管是发送什么请求，服务器返回的都是index.html文件。这时，我们就需要对不同的请求资源做一个判断，让其返回不同类型的资源。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; serve(request,response) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url =&lt;span&gt; request.url;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (url == '/'&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置响应类型，编码为utf-8。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器返回资源给浏览器时，还应该告诉浏览器这是什么类型的文件，以什么方式解析&lt;/span&gt;
        response.setHeader('Content-Type','text/html;charset=utf-8'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果我们希望返回的是其他文件的内容，则需要先读取其他文件，这时需要fs模块来读取文件&lt;/span&gt;
        fs.readFile('index.html',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,data) {
            response.write(data);
            response.end();
        })
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (url == '/style.css'&lt;span&gt;) {
        response.setHeader(&lt;/span&gt;'Content-Type','text/css;charset=utf-8'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果我们希望返回的是其他文件的内容，则需要先读取其他文件，这时需要fs模块来读取文件&lt;/span&gt;
        fs.readFile('style.css',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,data) {
            response.write(data);
            response.end();
        })
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个页面里，我们可能会请求非常多的静态资源，如果每次都加一个else if 显然让页面更复杂，且不利于维护。所以我们希望将所有的静态资源请求都封装在一个函数里。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; parseMime(pathname) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg = /\.(HTML|JS|CSS|JSON|TXT|ICO|JPG)/&lt;span&gt;i;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (reg.test(pathname)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取请求文件的后缀名&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; suffix = reg.exec(pathname)[1&lt;span&gt;].toUpperCase();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据请求文件的后缀名获取到当前文件的MIME类型&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; suffixMIME = &quot;text/plain&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(suffix) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;HTML&quot;&lt;span&gt;:
                suffixMIME &lt;/span&gt;= &quot;text/html&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;CSS&quot;&lt;span&gt;:
                suffixMIME &lt;/span&gt;= &quot;text/css&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;JS&quot;&lt;span&gt;:
                suffixMIME &lt;/span&gt;= &quot;text/javascript&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;JSON&quot;&lt;span&gt;:
                suffixMIME &lt;/span&gt;= &quot;application/json&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;ICO&quot;&lt;span&gt;:
                suffixMIME &lt;/span&gt;= &quot;application/octet-stream&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;JPG&quot;&lt;span&gt;:
                suffixMIME &lt;/span&gt;= &quot;image/jpg&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; suffixMIME;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上，Node中还提供了一个第三方的模块能够自动帮我们判断文件的&lt;span&gt;MIME类型&lt;/span&gt;，我们这里还需要用到一个第三方的模块&quot;mine&quot;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; mime = require('mime'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; serve(request,response) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url =&lt;span&gt; request.url;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (url == '/'&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置响应类型，编码为utf-8。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器返回资源给浏览器时，还应该告诉浏览器这是什么类型的文件，以什么方式解析&lt;/span&gt;
        response.setHeader('Content-Type','text/html;charset=utf-8'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果我们希望返回的是其他文件的内容，则需要先读取其他文件，这时需要fs模块来读取文件&lt;/span&gt;
        fs.readFile('index.html',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,data) {
            response.write(data);
            response.end();
        })
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        static(url,response)
    }    
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; static(url,response) {
    response.setHeader(&lt;/span&gt;'Content-Type',mime.lookup(url) + ';charset=utf-8'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果我们希望返回的是其他文件的内容，则需要先读取其他文件，这时需要fs模块来读取文件&lt;/span&gt;
    fs.readFile(url.slice(1),&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,data) {
        response.write(data);
        response.end();
    })
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 现在我们的url都是类似http://localhost:3000/index.html这样的，就是客户端只是单纯的获取数据，并不涉及向服务器端发送数据。&lt;/p&gt;
&lt;p&gt;前面我们说过，request.url获取的是'3000:'之后的内容，那么当我们需要向服务器传一些内容的时候，比如说http://localhost:3000/index.html/?name=&quot;xiaoyu&quot;。这时request.url获取的就是/index.html/?name=&quot;xiaoyu&quot;。&lt;/p&gt;
&lt;p&gt;这样的url显然不能再作为我们判断路径的依据，所以我们得进一步处理这个url。其实node提供了一个更加强大的url解析库给我们，这个库就是”url“。&lt;span&gt;这个库能够解析整个完整的url路径。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;传送地址：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yuliangbin/p/9483918.html&quot;&gt;url模块学习小结&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 13:33:00 +0000</pubDate>
<dc:creator>余大彬</dc:creator>
<og:description>首先创建一个HTTP服务器。 如果我们希望读取其他文件的内容，则需要先导入fs模块，该模块是读取文件的模块。 但是这样又有一个问题，就是：在对返回的HTML代码开始解析时，解析过程中如果遇到引用的服务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuliangbin/p/9429062.html</dc:identifier>
</item>
<item>
<title>这些年，在数据挖掘项目中踩的“坑” - 小糖球ai大萝卜</title>
<link>http://www.cnblogs.com/xiaotangqiu/p/9484157.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaotangqiu/p/9484157.html</guid>
<description>&lt;p&gt;数据挖掘项目是一个涉及的环节也比较多，而且高度依赖数据的项目。所以在其中一个过程中遇到点坑，简直太正常不过了。&lt;br/&gt;需求不明确是第一大坑。需求不明确会把后面的分析方向完全带沟沟里面去，也容易被迫接受一些不可能完成的挖掘目标和商业目标。不过这种一般只会发生在一个公司刚开始有这个岗位的时候，随着项目的增加，后面大家普遍就知道数据挖掘的极限了，也知道数据挖掘任务所存在的风险了，便不会提出不可能完成的目标了。说一个曾经被带沟沟里去的需求。有一次接到领导说做一个需求，要找出影响用户忠诚度的关键因子，然后我吭哧吭哧的提取数要求，等数据，写分析报告，确认了几个关键因子，然后去见客户才发现人家提的是影响高端用户粘性的因子。范围都不对，大受打击。此处避坑方式，可以去接触一线客户的时候，不要退缩，一定要了解他们的真实想法，不要被口口相传后带歪了，然后白干了。&lt;br/&gt;数据本身质量问题是第二大坑。大部分生产系统收集的数据都不是专门为做挖掘而做的，基本都是为直接盈利而存在的，所以也就只有直接影响到市场营销的指标最可靠。别的辅助指标，只能说质量实在一般。我们提出的上百个指标，真正能用的有20来个就不错了。除了数据在记录的时候可能发生的错误问题，还可能是数据精度/偏倚和准确率，数据不一致，数据遗漏，数据离群点，数据重复等问题。没别的避坑方式，只能是尽可能多的了解系统的基础数据，搜集各方信息，在想法设法的提高数据质量的基础上发散思维生成更多分析维度，然后尽人事知天命！&lt;br/&gt;取数过程中发生的数据问题是第三大坑。尤其记得刚毕业那年，还是个小透明的时候。有一次做一个甲方的挖掘项目，因为第二天要交付（取数周期长耽误了工期），一伙人拿着乱七八糟的数据分析到凌晨3点，结果发现一个关键ID都弄错了，导致全部数据都没法用。那种想死的心情，那种想杀人的心情。也给我们一个血的教训，千万不要因为信任某个人或者项目时间紧而放弃认真检查数据。数据有问题就只能打回去重整，就算是时间紧也没办法。不过话说回来，本来从各个数据仓库取数就是个又杂又累的苦活，好一点的取数人员只是犯的傻逼错误少一些。有些逻辑上考虑不全是正常的。而且他们对于数据的指标含义什么的，不像我们这么敏感，他们也是要在短时间内完成任务。所以此处的避坑方式其实也很简单，那就是检查数据！检查数据！检查数据！！！&lt;br/&gt;如果说前面的三大坑还算是可以填满的，那么接下来要说的超级大坑靠我们普通小辈基本填不满的。那就是能否得到实权人物的支持。说到底，数据挖掘到现在为止，还只是个锦上添花的事业。对于广大身处各种生产问题无法自拔的一线人员和实权领导，是不会有时间和精力来做这些锦上添花的事情的。因此项目经常因为这样或那样的问题延期或者拒绝上线。总的来说，数据挖掘的理论和技术都发展的比较成熟了。但是受现阶段采集数据和系统建设的影响，要真正达到高级应用阶段还有一段距离。现在更多的是停留在数据分析和数据可视化阶段。&lt;br/&gt;做项目就是这样，克服困难完成任务才是重点。处理问题才能体现我们的价值嘛。如果项目顺利什么问题都没有不就变成了搞科研了吗？&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 13:32:00 +0000</pubDate>
<dc:creator>小糖球ai大萝卜</dc:creator>
<og:description>数据挖掘项目是一个涉及的环节也比较多，而且高度依赖数据的项目。所以在其中一个过程中遇到点坑，简直太正常不过了。需求不明确是第一大坑。需求不明确会把后面的分析方向完全带沟沟里面去，也容易被迫接受一些不可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaotangqiu/p/9484157.html</dc:identifier>
</item>
<item>
<title>Android 9.0新特性 - 安卓笔记侠</title>
<link>http://www.cnblogs.com/ganchuanpu/p/9484120.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ganchuanpu/p/9484120.html</guid>
<description>&lt;p&gt;1、全面屏支持，Android P加入了对刘海屏的支持，谷歌称之为凹口屏幕（display with a cutout）。借助最新的提供的DisplayCutout类，开发者可以找到非功能区域的位置和形状，而非功能区域是不应显示功能的；使用getDisplayCutout（）就可以获取这个区域的详细信息，未来刘海屏手机很有可能成为主流趋势，在前摄像头没有比较好的隐藏方案出现之前，这可能是提高屏占比的好方法。&lt;/p&gt;
&lt;p&gt;2、通知栏的多种通知，从牛轧糖开始，你就可以增加一个action以对消息或从通知直接进入文字的行为作出反应。而在Android P版本中，你还可以在消息中展示图像；新的Notification.Person类可以识别对话中的任务，包括他们的头像和URI；当用户关闭消息通知时，你的app可以获取由系统发出的EXTRAREMOTEINPUT_DRAFT。你可以使用这个extra值来在app中进行预填充……&lt;/p&gt;
&lt;p&gt;3、多摄像头的更多画面，可以即时获取到两个或者更多的相机数据流，可以想象将有更多有趣的设计和实现出来&lt;/p&gt;
&lt;p&gt;4、GPS定位之外的WiFi定位，Android P增加了平台级支持IEEE 802.11 mc Wi-Fi协议(即Wi-Fi Round-Trip-Time,RTT), 从而让开发者可在App中使用室内定位。使用有硬件支持的Android P设备上，你的应用可以使用最新的RTT API以测量附近具有RTT功能的Wi-Fi AP。当然，前提是你的设备必须有定位功能而且你的App已经获取了ACCESS_COARSE_LOCATION及其以上的权限，可以想象将来更加精准的定位所带来的丰富的应用场景。&lt;/p&gt;
&lt;p&gt;5、网络还有神经网络，在Android P上，任务可以声明它们估算的数据大小，信号预读取并且指定详细的网络需求--任务载体则可以报告网络是否拥挤或是否不计量。JobScheduler便可按照网络状态管理任务。另一方面，神经网络API在Android 8.1引入，目的是加速Android设备上的机器学习。Android P扩展并改进了这些API, 为9个操作增加了支持，分别是Pad, BatchToSpaceND, SpaceToBatchND, Transpose, Strided Slice, Mean, Div, Sub和Squeeze。在Android P之后，设备将会对网络有更精细的调整：根据任务需求的数据大小和当前的网络环境。在收费网络里延迟一些网络要求，而在不计费的网络里可以通过消息预获取来得到更好的用户体验。神经网络API的更多操作则是让设备变得更智能、更聪明。智能的一种体现，节省流量和网络速度优化体验的一种好的改进。&lt;/p&gt;
&lt;p&gt;6、Material Design迎来2.0时代，神经网络Android 9.0加入了大量的圆角设计，UI方面的优化，感觉有些鸡肋，在现在各种模仿的设计趋势和各种定制化UI下，许多功能只是看看而已，用不到多少。&lt;/p&gt;
&lt;p&gt;7、Android Dashboard：用户可以看清楚自己在受手机上都干了哪些事情，从而提醒自己是否过多的浪费了不必要的时间，比如后是否看电影看视频太多，是否玩游戏太多等等。并在必要的时候提醒你应当休息一下。对某一款应用进行时间限制，用户使用到一定时间之后就会提醒，甚至让图标变灰色，以提醒用户尽量少用这个APP&lt;/p&gt;
&lt;p&gt;8、Wind Down：夜间模式；&lt;/p&gt;
&lt;p&gt;9、Adaptive Battery：更智能的方式来适应电池和屏幕，从而整体改善续航能力。谷歌加入了Adaptive Battery功能，不过这个模式需要单独开启，在该模式下，程序不需要唤醒可以极大的降低资源占用，更关注用户最常用的服务和应用程序，也算是AI技术的应用之一。这样就可以最大限度的降低后台占用，从而提升电池续航能力。这是Android团队与Google DeepMiind团队合作开发的成果，不仅可以预测用户接下来几个小时内将使用的应用程序，而且还包括在当天用户何时会使用哪些应用程序。智能的一种应用。&lt;/p&gt;
&lt;p&gt;10、Shush：屏幕朝下时进入完全勿扰状态；除了能够阻挡电话和通知的打扰，还有视觉免打扰的功能，屏幕不会点亮，直到用户主动打开手机。有趣的是在这个模式下，如果用户将手机屏幕朝下放置，那么手机会自动调整为震动或者静音模式，只保留闹钟的声音。&lt;/p&gt;
&lt;p&gt;11、Actions和Slices：通过检测用户的行为，让系统作出对应的动作。如插入耳机孔自动播放音乐，搜索“打车”自动显示打车软件等。&lt;/p&gt;
&lt;p&gt;总结：对更大屏幕显示的追求和视觉等体验的优化，智能的开始体现（用户行为的学习及正确化引导，网络环境的智能适应，电池电量的优化），更加人性化。期待更好的android，期待更好的智能体验，加油！&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 13:26:00 +0000</pubDate>
<dc:creator>安卓笔记侠</dc:creator>
<og:description>1、全面屏支持，Android P加入了对刘海屏的支持，谷歌称之为凹口屏幕（display with a cutout）。借助最新的提供的DisplayCutout类，开发者可以找到非功能区域的位置和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ganchuanpu/p/9484120.html</dc:identifier>
</item>
<item>
<title>我的第一个python web开发框架（29）——定制ORM（六） - AllEmpty</title>
<link>http://www.cnblogs.com/EmptyFS/p/9483706.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EmptyFS/p/9483706.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　在开发中，查询操作是使用最多的，而查询列表是其中之一，查询列表可分为分页查询和不分页查询（它们之间多了一次总记录数查询），还可以分为单表查询和多表关联查询，返回的结构体根据前端使用的表单框架不同而有所区别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们先看看，对于列表分页查询，在接口中是如何处理的&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0e4794a2-ffbf-42ab-9024-49a39092c8b2')&quot; readability=&quot;43&quot;&gt;&lt;img id=&quot;code_img_closed_0e4794a2-ffbf-42ab-9024-49a39092c8b2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0e4794a2-ffbf-42ab-9024-49a39092c8b2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0e4794a2-ffbf-42ab-9024-49a39092c8b2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0e4794a2-ffbf-42ab-9024-49a39092c8b2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    获取列表数据
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置查询条件&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     wheres = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 产品分类id&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     product_class_id = convert_helper.to_int0(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;product_class_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;产品分类id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, is_check_null=&lt;span&gt;False))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; product_class_id &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         wheres = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;where product_class_id=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; str(product_class_id)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面索引&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     page_number = convert_helper.to_int1(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面显示记录数量&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     page_size = convert_helper.to_int0(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 排序字段&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     sidx = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sidx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 顺序还是倒序排序&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     sord = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sord&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化排序字段&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     order_by = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id desc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 设置排序 ###&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; sidx:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         order_by = sidx + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; +&lt;span&gt; sord
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类型&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     type = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;类型&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否是前台提交获取数据&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; type != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;backstage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否已经存在查询条件了，是的话在原查询条件后面拼接&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; wheres:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             wheres = wheres + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; and is_enable=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             wheres = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;where is_enable=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化输出格式（前端使用jqgrid列表，需要指定输出格式）&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     data =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: [],
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行sql，获取指定条件的记录总数量&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     sql = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select count(1) as records from product %(wheres)s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wheres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: wheres}
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     result =&lt;span&gt; db_helper.read(sql)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果查询失败或不存在指定条件记录，则直接返回初始值&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; result &lt;span&gt;or&lt;/span&gt; result[0][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存总记录数量&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;     data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = result[0].get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, 0)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 设置分页索引与页面大小 ###&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置分页大小&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; page_size &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;or&lt;/span&gt; page_size &amp;lt;=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         page_size = 10
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算总页数&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] % page_size ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] //&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] // page_size + 1
&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录总页面数量&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;     data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断提交的页码是否超出范围&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; page_number &amp;lt; 1 &lt;span&gt;or&lt;/span&gt; page_number &amp;gt;&lt;span&gt; page_total:
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         page_number =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录当前页面索引值&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt;     data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_number
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算当前页面要显示的记录起始位置&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt;     record_number = (page_number - 1) *&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置查询分页条件&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt;     paging = &lt;span&gt;'&lt;/span&gt;&lt;span&gt; limit &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(page_size) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; offset &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; str(record_number)
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;78&lt;/span&gt; 
&lt;span&gt;79&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 组合sql查询语句&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;     sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from product %(wheres)s order by %(orderby)s %(paging)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;            {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wheres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: wheres, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;orderby&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: order_by, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;paging&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: paging}
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取记录&lt;/span&gt;
&lt;span&gt;83&lt;/span&gt;     result =&lt;span&gt; db_helper.read(sql)
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存储记录&lt;/span&gt;
&lt;span&gt;86&lt;/span&gt;         data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; result
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; 
&lt;span&gt;88&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; data:
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接输出json&lt;/span&gt;
&lt;span&gt;90&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_raise(json.dumps(data, cls=&lt;span&gt;json_helper.CJsonEncoder))
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　代码看起来很长，有点复杂，对于这种列表分页查询，如果不封装的话，开发时复制粘贴就很容易出错，所以我们需要重新处理才行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从上面代码可以看到，具体功能分为几个部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一部分（9到33行）是接收并组合查询条件，接收分页参数和排序参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第二部分（37到42行）是初始化结果输出参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第三部分（44到51行）是获取查询总记录数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第四部分（55到75行）是计算总页数，计算当前分页位置要显示的记录位置区间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第五部分（80到92行）是组合查询语句，查询并输出结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　除了产品列表这个接口，大家可以看看产品分类列表接口，会发现两个接口第二部分到第五部分都差不多，所以我们封装ORM时，可以将这些相似部分进行处理，将它们封装到ORM对应的方法里。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　首先，我们对上面代码的分析，可以提炼出分页查询方法需要有下面参数：查询字段、查询条件、当前分页索引值、每页显示记录数量、排序。如果是多表查询时，我们的ORM是直接绑定当前表单的就不适用了，所以还需要有个设置表名的参数，好灵活处理各种需求，根据这些要求，我们可以创建好列表查询方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; get_list(self, column_name_list=&lt;span&gt;''&lt;/span&gt;, wheres=&lt;span&gt;''&lt;/span&gt;, page_number=None, page_size=None, orderby=None, table_name=&lt;span&gt;None):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    获取指定条件的数据库记录集
    :param column_name_list:      查询字段
    :param wheres:      查询条件
    :param page_number:   分页索引值
    :param page_size:    分页大小， 存在值时才会执行分页
    :param orderby:     排序规则
    :param table_name:     查询数据表，多表查询时需要设置
    :return: 返回记录集总数量与分页记录集
        {'records': 0, 'total': 0, 'page': 0, 'rows': []}
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在接收到这些参数以后，我们需要对相关参数进行初始化操作，方便后续代码的执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化输出参数：总记录数量与列表集&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     data =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0,   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 总记录数&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0,     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 总页数&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1,      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前页面索引&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [],     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询结果（记录列表）&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化查询数据表名称&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; table_name:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         table_name = self.&lt;span&gt;__table_name&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化查询字段名&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; column_name_list:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         column_name_list = self.&lt;span&gt;__column_name_list&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化查询条件&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; wheres:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果是字符串，表示该查询条件已组装好了，直接可以使用&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; isinstance(wheres, str):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             wheres = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;where &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; wheres
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果是list，则表示查询条件有多个，可以使用join将它们用and方式组合起来使用&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt;&lt;span&gt; isinstance(wheres, list):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             wheres = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;where &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; and &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(wheres)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化排序&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; orderby:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         orderby = self.&lt;span&gt;__pk_name&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; desc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化分页查询的记录区间&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     paging = &lt;span&gt;''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这里是对传入的参数和后续需要用到的参数进行初始化操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里需要初始化查询结果输出参数结构，在进行记录数查询时，如果没有记录存在，就可以直接将结果返回出去了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　默认数据表为当前类实体指定的表名称，如果进行多表联合查询时，就需要设置多表联合查询的组合表名称，比如：product left join product_class on product.product_class_id = product_class.id&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　同时我们还需要设置查询字段内容，如果想查询出所有字段，直接使用*，如果只想要输出指定的几个字段值，则可以填写这几个字段值，比如：id,name,content&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在查询时，有时不需要查询条件，这时我们可以不填写条件，如果有指定条件时，我们可以将它们组合好，也可以放到list中。它们的区别在于，有多个查询条件时，我们有时很难判断当前条件前需不需要添加and，这时我们就可以使用' and '.join(列表) 来进行合成了，当然用list方式条件之间只能是and的关系。对于复杂的条件，我们可以组合好以后提交进来直接使用；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在查询时，如果没有指定排序方式，我们默认使用主键倒序来进行排序&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　在分页列表操作时，我们通常需要获取总记录数返回给前端，所以在执行查询前，我们需要获取当前查询条件的总记录数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     with db_helper.PgHelper(self.&lt;span&gt;__db&lt;/span&gt;, self.&lt;span&gt;__is_output_sql&lt;/span&gt;&lt;span&gt;) as db:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否需要进行分页&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; page_size &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 执行sql，获取指定条件的记录总数量&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             sql = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select count(1) as records from %(table_name)s %(wheres)s &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                   {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;table_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: table_name, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wheres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: wheres}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             result =&lt;span&gt; db.execute(sql)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果查询失败或不存在指定条件记录，则直接返回初始值&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; result &lt;span&gt;or&lt;/span&gt; result[0][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置记录总数量&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = result[0].get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　加上if not page_size is None判断，是因为有时候我们查询时，不需要分页操作，直接将所有记录输出了，这里加上判断可以减少不必要的记录总数量查询&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　当我们获取到总记录数量以后，我们需要根据前端页面显示的记录数进行计算，计算出总页面数量，排除页面索引值超出限制可能会带来的异常，还有需要计算当前页面查询时对应的记录起始位置，组合分页查询条件pagin&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;########################################################&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 设置分页索引与页面大小 ###&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; page_size &amp;lt;=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 page_size = 10
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算总分页数量：通过总记录数除于每页显示数量来计算总分页数量&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] % page_size ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] //&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] // page_size + 1
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断页码是否超出限制，超出限制查询时会出现异常，所以将页面索引设置为最后一页&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; page_number &amp;lt; 1 &lt;span&gt;or&lt;/span&gt; page_number &amp;gt;&lt;span&gt; page_total:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 page_number =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录总页面数量&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录当前页面值&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_number
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算当前页面要显示的记录起始位置（limit指定的位置）&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             record_number = (page_number - 1) *&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置查询分页条件&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             paging = &lt;span&gt;'&lt;/span&gt;&lt;span&gt; limit &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(page_size) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; offset &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; str(record_number)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　最后，我们组合最终查询条件，查询并输出结果&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 按条件查询数据库记录&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select %(column_name_list)s from %(table_name)s %(wheres)s order by %(orderby)s %(paging)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;               {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;column_name_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: column_name_list,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                &lt;span&gt;'&lt;/span&gt;&lt;span&gt;table_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: table_name,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wheres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: wheres,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                &lt;span&gt;'&lt;/span&gt;&lt;span&gt;orderby&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: orderby,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                &lt;span&gt;'&lt;/span&gt;&lt;span&gt;paging&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: paging}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         result =&lt;span&gt; db.execute(sql)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; result
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不需要分页查询时，直接在这里设置总记录数&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; page_size &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; len(result)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; data
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　完整代码&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;def&lt;/span&gt; get_list(self, column_name_list=&lt;span&gt;''&lt;/span&gt;, wheres=&lt;span&gt;''&lt;/span&gt;, page_number=None, page_size=None, orderby=None, table_name=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        获取指定条件的数据库记录集
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        :param column_name_list:      查询字段
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        :param wheres:      查询条件
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        :param page_number:   分页索引值
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        :param page_size:    分页大小， 存在值时才会执行分页
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        :param orderby:     排序规则
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        :param table_name:     查询数据表，多表查询时需要设置
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        :return: 返回记录集总数量与分页记录集
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            {'records': 0, 'total': 0, 'page': 0, 'rows': []}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化输出参数：总记录数量与列表集&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         data =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0,   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 总记录数&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0,     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 总页数&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1,      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前页面索引&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [],     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询结果（记录列表）&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化查询数据表名称&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; table_name:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             table_name = self.&lt;span&gt;__table_name&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化查询字段名&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; column_name_list:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             column_name_list = self.&lt;span&gt;__column_name_list&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化查询条件&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; wheres:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果是字符串，表示该查询条件已组装好了，直接可以使用&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; isinstance(wheres, str):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 wheres = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;where &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; wheres
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果是list，则表示查询条件有多个，可以使用join将它们用and方式组合起来使用&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;elif&lt;/span&gt;&lt;span&gt; isinstance(wheres, list):
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 wheres = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;where &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; and &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(wheres)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化排序&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; orderby:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             orderby = self.&lt;span&gt;__pk_name&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; desc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化分页查询的记录区间&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         paging = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         with db_helper.PgHelper(self.&lt;span&gt;__db&lt;/span&gt;, self.&lt;span&gt;__is_output_sql&lt;/span&gt;&lt;span&gt;) as db:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否需要进行分页&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; page_size &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 执行sql，获取指定条件的记录总数量&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                 sql = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select count(1) as records from %(table_name)s %(wheres)s &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                       {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;table_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: table_name, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wheres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: wheres}
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 result =&lt;span&gt; db.execute(sql)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果查询失败或不存在指定条件记录，则直接返回初始值&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; result &lt;span&gt;or&lt;/span&gt; result[0][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置记录总数量&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;                 data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = result[0].get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;########################################################&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 设置分页索引与页面大小 ###&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; page_size &amp;lt;=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     page_size = 10
&lt;span&gt;59&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算总分页数量：通过总记录数除于每页显示数量来计算总分页数量&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] % page_size ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                     page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] //&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                     page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] // page_size + 1
&lt;span&gt;64&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断页码是否超出限制，超出限制查询时会出现异常，所以将页面索引设置为最后一页&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; page_number &amp;lt; 1 &lt;span&gt;or&lt;/span&gt; page_number &amp;gt;&lt;span&gt; page_total:
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                     page_number =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录总页面数量&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;                 data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录当前页面值&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt;                 data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_number
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算当前页面要显示的记录起始位置（limit指定的位置）&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;                 record_number = (page_number - 1) *&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置查询分页条件&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt;                 paging = &lt;span&gt;'&lt;/span&gt;&lt;span&gt; limit &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(page_size) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; offset &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; str(record_number)
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 按条件查询数据库记录&lt;/span&gt;
&lt;span&gt;78&lt;/span&gt;             sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select %(column_name_list)s from %(table_name)s %(wheres)s order by %(orderby)s %(paging)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;                   {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;column_name_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: column_name_list,
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;                    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;table_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: table_name,
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;                    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wheres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: wheres,
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;                    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;orderby&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: orderby,
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;                    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;paging&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: paging}
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;             result =&lt;span&gt; db.execute(sql)
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;                 data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; result
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不需要分页查询时，直接在这里设置总记录数&lt;/span&gt;
&lt;span&gt;88&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; page_size &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;                     data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; len(result)
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; 
&lt;span&gt;91&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; data
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;　　我们在单元测试中跑一跑，看看结果吧&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/evn python&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; common.string_helper &lt;span&gt;import&lt;/span&gt;&lt;span&gt; string
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; logic &lt;span&gt;import&lt;/span&gt;&lt;span&gt; product_logic
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DbHelperTest(unittest.TestCase):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;数据库操作包测试类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;初始化测试环境&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------ini------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;清理测试环境&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------clear------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(self):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#############################################&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只需要看这里，其他代码是测试用例的模板代码 #&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#############################################&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化product表操作类ProductLogic&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         _product_logic =&lt;span&gt; product_logic.ProductLogic()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         result = _product_logic.get_list(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, 1, 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#############################################&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     unittest.main()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　输出结果&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; -- -- --ini-- -- --
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 4&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: [{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;place_of_origin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;front_cover_img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;201808031245678&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quality_guarantee_period&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;product_class_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;standard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;add_time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: datetime.datetime(2018, 8, 3, 16, 51, 3&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 15&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_enable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }, {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;place_of_origin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;front_cover_img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;201807251234568&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quality_guarantee_period&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;product_class_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;standard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;add_time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: datetime.datetime(2018, 8, 3, 0, 14, 14&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 14&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_enable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; -- -- --clear-- -- --
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　前面的接口我们也改造一下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    获取列表数据
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 产品分类id&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     product_class_id = convert_helper.to_int0(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;product_class_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;产品分类id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, is_check_null=&lt;span&gt;False))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类型&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     type = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;类型&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面索引&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     page_number = convert_helper.to_int1(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面显示记录数量&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     page_size = convert_helper.to_int0(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 排序字段&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     sidx = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sidx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 顺序还是倒序排序&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     sord = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sord&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置查询条件&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     wheres =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; product_class_id &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         wheres.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;product_class_id=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; str(product_class_id))
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否是前台提交获取数据&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; type != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;backstage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         wheres.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_enable=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化排序字段&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     orderby =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 设置排序 ###&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; sidx:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         orderby = sidx + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; +&lt;span&gt; sord
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化product表操作类ProductLogic&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     _product_logic =&lt;span&gt; product_logic.ProductLogic()
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     result = _product_logic.get_list(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, wheres, page_number, page_size, orderby)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_raise(json.dumps(result, cls=&lt;span&gt;json_helper.CJsonEncoder))
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　这样处理以后，代码看起来舒服多了&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;版权声明：本文原创发表于 &lt;a href=&quot;http://www.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;博客园&lt;/span&gt;&lt;/a&gt;，作者为 &lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/EmptyFS/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;AllEmpty&lt;/span&gt;&lt;/a&gt; &lt;/strong&gt;本文欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则视为侵权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python开发QQ群：669058475    作者博客：http://www.cnblogs.com/EmptyFS/&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 13:20:00 +0000</pubDate>
<dc:creator>AllEmpty</dc:creator>
<og:description>在开发中，查询操作是使用最多的，而查询列表是其中之一，查询列表可分为分页查询和不分页查询（它们之间多了一次总记录数查询），还可以分为单表查询和多表关联查询，返回的结构体根据前端使用的表单框架不同而有所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EmptyFS/p/9483706.html</dc:identifier>
</item>
</channel>
</rss>