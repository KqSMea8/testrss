<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【杂谈】从CGI到Servlet - 猫毛·波拿巴</title>
<link>http://www.cnblogs.com/longfurcat/p/9781369.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longfurcat/p/9781369.html</guid>
<description>&lt;p&gt;&lt;strong&gt;访问服务器的静态页面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　每个Web服务器都运行着一个HTTP服务软件，用于响应web浏览器的请求，返回客户想要的页面。HTTP服务器都会有一个文件夹用于放置相关的页面文件，默认是  &lt;span&gt;/user/local/apache/htdocs&lt;/span&gt; 。例如，服务器的域名叫 &lt;span&gt;example.com&lt;/span&gt;。那客户端浏览器访问&lt;span&gt;http://example.com/index.html &lt;/span&gt;  就是访问服务器上的HTTP服务器（URL如果没有指定端口，就是访问80端口，80端口绑定的是HTTP服务，80端口是默认对外开启的），那HTTP服务器就会重定向到 &lt;span&gt;/user/local/apache/htdocs&lt;/span&gt; 文件夹，并查询是否有index.html 文件，有则返回，没有则返回错误报文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问服务器的动态页面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　服务器只提供静态页面还不够，客户端想要更多的服务，比如动态的页面（页面上显示当前使用者信息等等），或者修改数据库内容。这时候，服务端就不能单纯地映射并返回文件来实现了，这时候就需要有可执行的脚本程序来对页面进行更改，或者其他操作。就拿动态页面来说，客户端浏览器访问 &lt;span&gt;http://example.com/home?name=randy&lt;/span&gt; 这里用户带上了自己的用户名，希望访问的主页右上角能显示自己的名字。这里 &lt;span&gt;home&lt;/span&gt; 通过映射到一个CGI程序，并执行。该程序通过标准I/O流，解析HTTP报文，获取到了请求参数，并通过程序生成对应的HTML文件，在通过标准I/O流，将文件返回给请求客户。&lt;/p&gt;
&lt;p&gt;注：CGI （Common Gateway Interface）通用网关接口，CGI程序常见的由Perl，Python，C，C++  或者任何可利用标准I/O流的语言。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java的一种想法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一开始，人们想最理想的方式就是完全基于Java的实现方案， servlets &amp;lt;=&amp;gt; applets 。即&lt;/p&gt;
&lt;p&gt;　　客户端用applet校验并发送数据，&lt;/p&gt;
&lt;p&gt;　　服务端用servlet接收并处理数据。&lt;/p&gt;
&lt;p&gt;　　就连这名称都是一对。&lt;/p&gt;
&lt;p&gt;　　但是，并非所有浏览器都支持Java。这样就带来一个问题，那就是你搭建的网站，只有部分浏览能够访问，而且需要安装对应程序。后来，就把所有的操作都交给服务器处理，然后把最终生成的网页发给客户端浏览器。这样，只要有浏览器，就可以访问对应网站，且不需要安装任何程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Servlet的引入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Servlet是基于Java的CGI程序框架。首先，因为它是一个框架，所以就可以省去很多底层编写的工作。又因为是用Java实现的，Java程序运行于Java虚拟机，跨平台性好，便于网站迁移。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Servlet的体系架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Servlet容器，如Tomcat，接收所有客户端请求，如 &lt;span&gt;http://example.com:8080/project/oneServlet&lt;/span&gt;，根据&quot;project&quot;找到对应的项目（tomcat的server.xml保存项目映射信息），再根据&quot;oneServlet&quot;找到对应的Servlet（Web项目的web.xml保存Servlet映射信息），然后调用该Servlet对象的service()方法。service方法会根据请求的方式，委派给doGet、doPost、doDelete等方法进行处理。&lt;/p&gt;
&lt;p&gt;　　注：Servlet的多数内容由容器实现，如Session的保存和获取，Tomcat实现内容在其子目录lib下的catalina相关包内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Servlet的持久化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Servlet会保存其变量域的值，使其在多个请求之间保留相应变量值。Servlet容器会持久化Servlet对象。至于什么时候刷新，尚未考察，应该是在每次service()方法返回之后。&lt;/p&gt;
&lt;p&gt;如果是CGI程序，则需要自己手动将数据写入到磁盘，这也是Servlet的优点之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Servlet的页面生成与JSP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果单纯用Servlet生成页面，那么将会非常痛苦，因为这样代码里就会掺杂大量的 &lt;span&gt;换行符、转义标识、“+”符号&lt;/span&gt;，字符串的构建以及代码阅读都非常困难。后来就有了JSP文件，整合了HTML和Java代码。使得文件内可以直接抒写HTML代码，而不需要用字符串拼接。也可以用有特殊标签包围的Java代码。（实际上JSP就是Servlet，它会被容器内会被转换成Servlet的.java文件，然后在编译成.class文件）但是，JSP还有问题没解决，那就是，负责维护JSP的开发人员必须既懂HTML又懂Java。而且两种语言混合在一起（一种程序语言，一种标记语言），在加上各种标签库，看起来比较吃力。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;偏题内容：页面渲染的位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　早期是服务器把网页完全渲染好后，然后发给客户端浏览器，浏览器负责显示就可以了。但是这样的话，服务器的压力就比较大，而且响应时间会比较长，客户端要等到服务端把页面完全渲染好后才能看见页面。后来的做法，是这样的，服务器先把有基本内容的网页文件发给客户端浏览器，然后浏览器再异步地请求（如通过Ajax）获取数据，然后根据获取到的数据对网页进行渲染（例如获取到一个数组对象，然后根据数组生成一个表格，显示数据）。这样，服务器的压力就小多了，而且客户端也能较早地看见页面（尚不完整，部分数据还未加载）。&lt;/p&gt;
&lt;p&gt;　　那浏览器有是怎么就知道发异步请求呢？是这样的，用javascript写全局代码，或者覆盖Vue对象中的created函数，这样浏览器一收到网页文件并加载的时候，这些JS代码就会被触发执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Servlet与多线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Servlet容器维护有一个线程池用于分派处理客户端的请求。所以，多个请求可以并发，甚至并行处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Servlet处理会话（Session）—— 利用Cookie&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;HTTP是无状态协议，多次请求中，单纯靠HTTP协议，我们并不能辨别其是否是同一个人。但是，有处理会话的需求（例如购物车的实现需求），这时候就要追踪会话。追踪会话的方式有很多，最常见的是持久化Cookie。&lt;/p&gt;
&lt;p&gt;Session-Cookie机制：Cookie是服务器发给客户端的一小段信息（包含Session的唯一标识符），浏览器收到Cookie后，把它写入到磁盘持久化。无论何时，如果访问与某个Cookie相关联的URL时，请求中就会带上这个Cookie。Servlet如果想要获取本次请求的会话，就调用HttpServletRequest.getSession()获取。getSession()方法获取Session的实现方式尚未考察，但猜测应该是根据请求中的Cookie，从Servlet容器内检索对应的Session。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Session的存活时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Session即会话的存活时间默认是30min，但是具体情况，得看对应的Servlet容器。每个容器的会话存活时间都不尽相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Session的用途&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Session对象的作用就是捕捉客户端与服务端交互的有用数据，如前面提到的购物车信息，还有就是Session对象可以用来保存认证信息（即是否已登录），这样多次请求中，Servlet只要确认&quot;是否登录&quot;状态即可，而不需要用户每次请求都登录。&lt;/p&gt;

</description>
<pubDate>Fri, 12 Oct 2018 16:05:00 +0000</pubDate>
<dc:creator>猫毛&amp;#183;波拿巴</dc:creator>
<og:description>访问服务器的静态页面 每个Web服务器都运行着一个HTTP服务软件，用于响应web浏览器的请求，返回客户想要的页面。HTTP服务器都会有一个文件夹用于放置相关的页面文件，默认是 /user/local</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longfurcat/p/9781369.html</dc:identifier>
</item>
<item>
<title>Django2.1.2创建默认管理后台 - 渣渣辉</title>
<link>http://www.cnblogs.com/Dev0ps/p/9781348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/9781348.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1、在app的models.py中添加以下代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from django.db import models

# Create your models here.
# Register your models here.
class UserType(models.Model):
    name = models.CharField(max_length=32)

class UserInfo(models.Model):

    username = models.CharField(max_length=32)
    pwd = models.CharField(max_length=32)
    email = models.CharField(max_length=32)
    user_type = models.ForeignKey('UserType',on_delete=models.CASCADE,)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注意一些书上写的是user_type = models.ForeignKey(UserType)，因为他们用的是Django2.0之前的版本，如果不加“on_delete=models.CASCADE”则以下错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201810/1271786-20181012234316328-531458936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在django2.0后，定义外键和一对一关系的时候需要加on_delete选项，此参数为了避免两个表里的数据不一致问题，不然会报错：&lt;br/&gt;TypeError: __init__() missing 1 required positional argument: 'on_delete'&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;参数说明：&lt;br/&gt;on_delete有CASCADE、PROTECT、SET_NULL、SET_DEFAULT、SET()五个可选择的值&lt;br/&gt;CASCADE：此值设置，是级联删除。&lt;br/&gt;PROTECT：此值设置，是会报完整性错误。&lt;br/&gt;SET_NULL：此值设置，会把外键设置为null，前提是允许为null。&lt;br/&gt;SET_DEFAULT：此值设置，会把设置为外键的默认值。&lt;br/&gt;SET()：此值设置，会调用外面的值，可以是一个函数。&lt;br/&gt;&lt;span&gt;一般情况下使用CASCADE就可以了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、在app的admin.py中添加以下代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from django.contrib import admin
from cmdb import models
admin.site.register(models.UserInfo)
admin.site.register(models.UserType)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 3、在主工程的setting.py文件中添加app：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201810/1271786-20181012234753395-1370923364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、在cmd中依次运行以下命令：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;python manage.py makemigrations&lt;br/&gt;python manage.py migrate&lt;br/&gt;python manage.py createsuperuser&lt;br/&gt;  --上面这条命令是创建超级管理员的&lt;br/&gt;python manage.py runserver&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;5、运行成功后访问：http://127.0.0.1:8000/admin/  登录后即可进入Django的默认管理后台。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201810/1271786-20181012235243810-263035874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 12 Oct 2018 15:56:00 +0000</pubDate>
<dc:creator>渣渣辉</dc:creator>
<og:description>1、在app的models.py中添加以下代码： 注意一些书上写的是user_type = models.ForeignKey(UserType)，因为他们用的是Django2.0之前的版本，如果不加</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dev0ps/p/9781348.html</dc:identifier>
</item>
<item>
<title>我要翻译《Think Python》-002 贡献列表 &amp; 目录部分 - 鬼画符</title>
<link>http://www.cnblogs.com/simba/p/9781317.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/simba/p/9781317.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;PDF源文件地址 ：  http://www.greenteapress.com/thinkpython/thinkpython.pdf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;贡献列表&lt;/h2&gt;
&lt;p&gt;自从本书诞生之后，有超过上百个目光敏锐且有想法的读者给我发来了许多建议并指出了一些需要修正的地方。他们的热情和无私的奉献给了我巨大的帮助。如果你有任何建议或者发现需要修正的地方，请发邮件至：feedback@thinkpython.com。如果您的建议被采纳，您的大名将会出现在我们的贡献人员列表（除非你本人过于低调拒绝承认）.如果您发现文中的错误内容，敬请提供一下出错的关键语句，或者章节和页码，这样方便我们及时准确的找到问题所在。感谢！&lt;/p&gt;
&lt;p&gt;&lt;em&gt;[接下来的原文就是一段很长的篇幅介绍每一个为本书作出贡献的人员姓名，以及他们做过的具体事情，为了体现精简的原则，我就不一一翻译了，一是我觉得没必要，二是我即便翻译了，您也没时间看，通常拿到手一本书，序言是90%以上的人都懒得翻看的。&lt;/em&gt;&lt;br/&gt;&lt;em&gt;因此为了节省篇幅和时间，我只提一个人Patryk Wolowiec，这位哥们把整本书转换成了HTML版本，如今官网这本书就是用他的。&lt;/em&gt;&lt;br/&gt;&lt;em&gt;因此，希望对比原版英文进行阅读的朋友可以点击这个传送门：&lt;/em&gt;&lt;br/&gt;&lt;em&gt;http://www.greenteapress.com/thinkpython/html/index.html&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;再接下来就是目录，虽然内容多，您也不一定有耐心逐个看，但是我还是觉得有必要翻译一下，因为我本人想先了解一下整本书的框架结构和大致内容。再者待我翻译到后面章节的内容，如果发现翻译得不恰当，我还会修改更正这里目录内容。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;后记：原本以为不会花费太多时间翻译目录这一块，结果花了好几个晚上的时间对每一个小标题进行逐个理解，由于平时写程序对这些术语概念不求甚解，所以翻译的过程中不断的重复着：查看原文内容揣测标题含义，各种翻译工具进行比较... ... 不过总算翻完了！如有翻译得不合适的地方，敬请各位指正！]&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;&lt;br/&gt;目录 Contents&lt;/h2&gt;

&lt;h3&gt;&lt;strong&gt;1 编程方法 The way of the program&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1.1 Python 编程语言 　　The Python programming language&lt;br/&gt;1.2 什么是程序? 　　　　What is a program?&lt;br/&gt;1.3 什么是调试? 　　　　What is debugging?&lt;br/&gt;1.4 形式语言和自然语言 　　Formal and natural languages&lt;br/&gt;1.5 第一个程序 　　　　　　The first program&lt;br/&gt;1.6 调试 　　Debugging&lt;br/&gt;1.7 术语表 　　Glossary&lt;br/&gt;1.8 练习 　　Exercises&lt;/p&gt;
&lt;h3&gt;2 变量, 表达式和语法 Variables, expressions and statements&lt;/h3&gt;
&lt;p&gt;2.1 值和类型 　　Values and types&lt;br/&gt;2.2 变量 　　　　Variables&lt;br/&gt;2.3 变量名和关键字 　　Variable names and keywords&lt;br/&gt;2.4 运算符和运算 　　　　Operators and operands&lt;br/&gt;2.5 表达式和语法 　　Expressions and statements&lt;br/&gt;2.6 交互模式和脚本模式 　　Interactive mode and script mode&lt;br/&gt;2.7 运算顺序 　　Order of operations&lt;br/&gt;2.8 字符串操作 　　String operations&lt;br/&gt;2.9 注释 　　　　Comments&lt;br/&gt;2.10 调试 　　　　Debugging&lt;br/&gt;2.11 术语表 　　　Glossary&lt;br/&gt;2.12 练习 　　Exercises&lt;/p&gt;
&lt;h3&gt;3 函数 Functions&lt;/h3&gt;
&lt;p&gt;3.1 函数调用 Function calls&lt;br/&gt;3.2 类型转换函数 Type conversion functions&lt;br/&gt;3.3 数学函数 Math functions&lt;br/&gt;3.4 类组合 Composition&lt;br/&gt;3.5 建立新函数 Adding new functions&lt;br/&gt;3.6 定义和引用 Definitions and uses&lt;br/&gt;3.7 执行流程 Flow of execution&lt;br/&gt;3.8 形参和实参 Parameters and arguments&lt;br/&gt;3.9 变量和形参是局部的 Variables and parameters are local&lt;br/&gt;3.10 堆栈图 Stack diagrams&lt;br/&gt;3.11 有返回结果函数和无返回结果函数 Fruitful functions and void functions&lt;br/&gt;3.12 什么是函数 Why functions?&lt;br/&gt;3.13 用from导入 Importing with from&lt;br/&gt;3.14 调试 Debugging&lt;br/&gt;3.15 术语表 Glossary&lt;br/&gt;3.16 练习 Exercises&lt;/p&gt;
&lt;h3&gt;4 学习案例：接口设计 Case study: interface design&lt;/h3&gt;
&lt;p&gt;4.1 [Swampy包] - TurtleWorld TurtleWorld&lt;br/&gt;4.2 简单循环 Simple repetition&lt;br/&gt;4.3 练习 Exercises&lt;br/&gt;4.4 封装 Encapsulation&lt;br/&gt;4.5 泛化 Generalization&lt;br/&gt;4.6 接口设计 Interface design&lt;br/&gt;4.7 重构 Refactoring&lt;br/&gt;4.8 开发方案 A development plan&lt;br/&gt;4.9 文档字符串 docstring&lt;br/&gt;4.10 调试 Debugging&lt;br/&gt;4.11 术语表 Glossary&lt;br/&gt;4.12 练习 Exercises&lt;/p&gt;
&lt;h3&gt;5 条件和递归 Conditionals and recursion&lt;/h3&gt;
&lt;p&gt;5.1 求余运算符 Modulus operator&lt;br/&gt;5.2 布尔表达式 Boolean expressions&lt;br/&gt;5.3 逻辑运算符 Logical operators&lt;br/&gt;5.4 条件执行 Conditional execution&lt;br/&gt;5.5 选择执行 Alternative execution&lt;br/&gt;5.6 链式条件 Chained conditionals&lt;br/&gt;5.7 嵌入条件 Nested conditionals&lt;br/&gt;5.8 递归 Recursion&lt;br/&gt;5.9 递归函数堆栈图 Stack diagrams for recursive functions&lt;br/&gt;5.10 无限递归 Infinite recursion&lt;br/&gt;5.11 键盘输入 Keyboard input&lt;br/&gt;5.12 调试 Debugging&lt;br/&gt;5.13 术语表 Glossary&lt;br/&gt;5.14 练习 Exercises&lt;/p&gt;
&lt;h3&gt;6 有返回值函数 Fruitful functions&lt;/h3&gt;
&lt;p&gt;6.1 返回值 Return values&lt;br/&gt;6.2 增量开发 Incremental development&lt;br/&gt;6.3 类组合 Composition&lt;br/&gt;6.4 布尔函数 Boolean functions&lt;br/&gt;6.5 更多递归 More recursion&lt;br/&gt;6.6 胸有成竹/得心应手 Leap of faith&lt;br/&gt;6.7 又一个例子 One more example&lt;br/&gt;6.8 检查类型 Checking types&lt;br/&gt;6.9 调试 Debugging&lt;br/&gt;6.10 术语表 Glossary&lt;br/&gt;6.11 练习 Exercises&lt;/p&gt;
&lt;h3&gt;7 迭代 Iteration&lt;/h3&gt;
&lt;p&gt;7.1 多次赋值 Multiple assignment&lt;br/&gt;7.2 更新变量 Updating variables&lt;br/&gt;7.3 while语句 The while statement&lt;br/&gt;7.4 break用法 break&lt;br/&gt;7.5 平方根 Square roots&lt;br/&gt;7.6 算法 Algorithms&lt;br/&gt;7.7 调试 Debugging&lt;br/&gt;7.8 术语表 Glossary&lt;br/&gt;7.9 练习 Exercises&lt;/p&gt;
&lt;h3&gt;8 字符串 Strings&lt;/h3&gt;
&lt;p&gt;8.1 字符串序列 A string is a sequence&lt;br/&gt;8.2 len用法 len&lt;br/&gt;8.3 for循环遍历 Traversal with a for loop&lt;br/&gt;8.4 字符串分割 String slices&lt;br/&gt;8.5 字符串是不可变的 Strings are immutable&lt;br/&gt;8.6 搜索 Searching&lt;br/&gt;8.7 循环计数 Looping and counting&lt;br/&gt;8.8 字符串方法 String methods&lt;br/&gt;8.9 in操作 The in operator&lt;br/&gt;8.10 字符串比较 String comparison&lt;br/&gt;8.11 调试 Debugging&lt;br/&gt;8.12 术语表 Glossary&lt;br/&gt;8.13 练习 Exercises&lt;/p&gt;
&lt;h3&gt;9 案例学习：单词游戏 Case study: word play&lt;/h3&gt;
&lt;p&gt;9.1 读取单词列表 Reading word lists&lt;br/&gt;9.2 练习 Exercises&lt;br/&gt;9.3 搜索 Search&lt;br/&gt;9.4 索引循环 Looping with indices&lt;br/&gt;9.5 调试 Debugging&lt;br/&gt;9.6 术语表 Glossary&lt;br/&gt;9.7 练习 Exercises&lt;/p&gt;
&lt;h3&gt;10 列表 Lists&lt;/h3&gt;
&lt;p&gt;10.1 列表是一个序列 A list is a sequence&lt;br/&gt;10.2 列表是可变的 Lists are mutable&lt;br/&gt;10.3 遍历列表 Traversing a list&lt;br/&gt;10.4 列表运算 List operations&lt;br/&gt;10.5 列表分割 List slices&lt;br/&gt;10.6 列表方法 List methods&lt;br/&gt;10.7 映射，过滤和缩减 Map, filter and reduce&lt;br/&gt;10.8 删除元素 Deleting elements&lt;br/&gt;10.9 列表和字符串 Lists and strings&lt;br/&gt;10.10 对象和值 Objects and values&lt;br/&gt;10.11 别名 Aliasing&lt;br/&gt;10.12 实参列表 List arguments&lt;br/&gt;10.13 调试 Debugging&lt;br/&gt;10.14 术语表 Glossary&lt;br/&gt;10.15 练习 Exercises&lt;/p&gt;
&lt;h3&gt;11 字典 Dictionaries&lt;/h3&gt;
&lt;p&gt;11.1 字典——计数器集合 Dictionary as a set of counters&lt;br/&gt;11.2 循环和字典 Looping and dictionaries&lt;br/&gt;11.3 逆向查找 Reverse lookup&lt;br/&gt;11.4 字典和列表 Dictionaries and lists&lt;br/&gt;11.5 备忘录 Memos&lt;br/&gt;11.6 全局变量 Global variables&lt;br/&gt;11.7 长整型 Long integers&lt;br/&gt;11.8 调试 Debugging&lt;br/&gt;11.9 术语表 Glossary&lt;br/&gt;11.10 练习 Exercises&lt;/p&gt;
&lt;h3&gt;12 元组 Tuples&lt;/h3&gt;
&lt;p&gt;12.1 元组是不可变的 Tuples are immutable&lt;br/&gt;12.2 元组赋值 Tuple assignment&lt;br/&gt;12.3 元组作为返回值 Tuples as return values&lt;br/&gt;12.4 可变长度实参元组 Variable-length argument tuples&lt;br/&gt;12.5 列表和元组 Lists and tuples&lt;br/&gt;12.6 字典和元组 Dictionaries and tuples&lt;br/&gt;12.7 比较元组 Comparing tuples&lt;br/&gt;12.8 序列的序列 Sequences of sequences&lt;br/&gt;12.9 调试 Debugging&lt;br/&gt;12.10 术语表 Glossary&lt;br/&gt;12.11 练习 Exercises&lt;/p&gt;
&lt;h3&gt;13 案例学习：数据结构选择 Case study: data structure selection&lt;/h3&gt;
&lt;p&gt;13.1 词频分析 Word frequency analysis&lt;br/&gt;13.2 随机数 Random numbers&lt;br/&gt;13.3 单词直方图 Word histogram&lt;br/&gt;13.4 最常用单词 Most common words&lt;br/&gt;13.5 可选形参 Optional parameters&lt;br/&gt;13.6 字典差集 Dictionary subtraction&lt;br/&gt;13.7 随机单词 Random words&lt;br/&gt;13.8 马尔可夫分析 Markov analysis&lt;br/&gt;13.9 数据结构 Data structures&lt;br/&gt;13.10 分析 Debugging&lt;br/&gt;13.11 词汇表 Glossary&lt;br/&gt;13.12 练习 Exercises&lt;/p&gt;
&lt;h3&gt;14 文件 Files&lt;/h3&gt;
&lt;p&gt;14.1 持久化 Persistence&lt;br/&gt;14.2 读和写 Reading and writing&lt;br/&gt;14.3 格式化操作 Format operator&lt;br/&gt;14.4 文件名和路径 Filenames and paths&lt;br/&gt;14.5 捕获异常 Catching exceptions&lt;br/&gt;14.6 数据库 Databases&lt;br/&gt;14.7 pickle用法 Pickling&lt;br/&gt;14.8 管道 Pipes&lt;br/&gt;14.9 编写模块 Writing modules&lt;br/&gt;14.10 调试 Debugging&lt;br/&gt;14.11 术语表 Glossary&lt;br/&gt;14.12 练习 Exercises&lt;/p&gt;
&lt;h3&gt;15 类和对象 Classes and objects&lt;/h3&gt;
&lt;p&gt;15.1 用户自定义类型 User-defined types&lt;br/&gt;15.2 属性 Attributes&lt;br/&gt;15.3 矩形 Rectangles&lt;br/&gt;15.4 实例作为返回值 Instances as return values&lt;br/&gt;15.5 对象是可变的 Objects are mutable&lt;br/&gt;15.6 复制 Copying&lt;br/&gt;15.7 调试 Debugging&lt;br/&gt;15.8 术语表 Glossary&lt;br/&gt;15.9 练习 Exercises&lt;/p&gt;
&lt;h3&gt;16 类和函数 Classes and functions&lt;/h3&gt;
&lt;p&gt;16.1 时间类 Time&lt;br/&gt;16.2 纯函数 Pure functions&lt;br/&gt;16.3 类方法 Modifiers&lt;br/&gt;16.4 原型vs计划 Prototyping versus planning&lt;br/&gt;16.5 调试 Debugging&lt;br/&gt;16.6 术语表 Glossary&lt;br/&gt;16.7 练习 Exercises&lt;/p&gt;
&lt;h3&gt;17 类和方法 Classes and methods&lt;/h3&gt;
&lt;p&gt;17.1 面向对象的特征 Object-oriented features&lt;br/&gt;17.2 打印对象 Printing objects&lt;br/&gt;17.3 另一个例子 Another example&lt;br/&gt;17.4 一个更复杂的例子 A more complicated example&lt;br/&gt;17.5 init方法 The init method&lt;br/&gt;17.6 __str__方法 The __str__ method&lt;br/&gt;17.7 运算符重载 Operator overloading&lt;br/&gt;17.8 类型分发 Type-based dispatch&lt;br/&gt;17.9 多态 Polymorphism&lt;br/&gt;17.10 调试 Debugging&lt;br/&gt;17.11 接口和实现 Interface and implementation&lt;br/&gt;17.12 术语表 Glossary&lt;br/&gt;17.13 练习 Exercises&lt;/p&gt;
&lt;h3&gt;18 继承 Inheritance&lt;/h3&gt;
&lt;p&gt;18.1 牌对象 Card objects&lt;br/&gt;18.2 类属性 Class attributes&lt;br/&gt;18.3 比大小Comparing cards&lt;br/&gt;18.4 一副牌 Decks&lt;br/&gt;18.5 打印一副牌 Printing the deck&lt;br/&gt;18.6 新增，删除，洗牌和排序 Add, remove, shuffle and sort&lt;br/&gt;18.7 继承Inheritance&lt;br/&gt;18.8 类图 Class diagrams&lt;br/&gt;18.9 调试 Debugging&lt;br/&gt;18.10 数据封装 Data encapsulation&lt;br/&gt;18.11 术语表 Glossary&lt;br/&gt;18.12 练习 Exercises&lt;/p&gt;
&lt;h3&gt;19 案例学习：Tkinter Case study: Tkinter&lt;/h3&gt;
&lt;p&gt;19.1 图形用户界面 GUI&lt;br/&gt;19.2 按钮和回调函数 Buttons and callbacks&lt;br/&gt;19.3 画布组件 Canvas widgets&lt;br/&gt;19.4 坐标 Coordinate sequences&lt;br/&gt;19.5 更多组件 More widgets&lt;br/&gt;19.6 打包组件 Packing widgets&lt;br/&gt;19.7 菜单和可调用对象 Menus and Callables&lt;br/&gt;19.8 绑定 Binding&lt;br/&gt;19.9 调试 Debugging&lt;br/&gt;19.10 术语表 Glossary&lt;br/&gt;19.11 练习 Exercises&lt;/p&gt;
&lt;h3&gt;A 调试 Debugging&lt;/h3&gt;
&lt;p&gt;A.1 语法错误 Syntax errors&lt;br/&gt;A.2 运行时错误 Runtime errors&lt;br/&gt;A.3 语义错误 Semantic errors&lt;/p&gt;
&lt;h3&gt;B 算法分析 Analysis of Algorithms&lt;/h3&gt;
&lt;p&gt;B.1 阶数增长 Order of growth&lt;br/&gt;B.2 基本Python运算分析 Analysis of basic Python operations&lt;br/&gt;B.3 搜索算法分析 Analysis of search algorithms&lt;br/&gt;B.4 哈希表 Hashtables&lt;/p&gt;
&lt;h3&gt;&lt;br/&gt;C Lumpy的用法 Lumpy&lt;/h3&gt;
&lt;p&gt;C.1 状态图 State diagram&lt;br/&gt;C.2 堆栈图 Stack diagram&lt;br/&gt;C.3 对象图 Object diagrams&lt;br/&gt;C.4 函数和类对象 Function and class objects&lt;br/&gt;C.5 类图 Class Diagrams&lt;/p&gt;


</description>
<pubDate>Fri, 12 Oct 2018 15:43:00 +0000</pubDate>
<dc:creator>鬼画符</dc:creator>
<og:description>我要翻译《Think Python》-002 贡献列表 &amp; 目录部分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/simba/p/9781317.html</dc:identifier>
</item>
<item>
<title>database---many to many relationships（多对多关系型数据库） - 丹华抱一鷇音子</title>
<link>http://www.cnblogs.com/cpl9412290130/p/9781311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cpl9412290130/p/9781311.html</guid>
<description>&lt;p&gt;A many-to-many relationship occurs when multiple records in a table are associated with multiple records in another table. For example, a many-to-many relationship exists between customers and products: customers can purchase various products, and products can be purchased by many customers.&lt;/p&gt;
&lt;p&gt;Relational database systems usually don't allow you to implement a direct many-to-many relationship between two tables. Consider the example of keeping track of invoices. If there were many invoices with the same invoice number and one of your customers inquired about that invoice number, you wouldn’t know which number they were referring to. This is one reason for assigning a unique value to each invoice.&lt;/p&gt;
&lt;p&gt;To avoid this problem, you can break the many-to-many relationship into two one-to-many relationships by using a third table, called a join table. Each record in a join table includes a match field that contains the value of the primary keys of the two tables it joins. (In the join table, these match fields are foreign keys.) These foreign key fields are populated with data as records in the join table are created from either table it joins.&lt;/p&gt;
&lt;p&gt;A typical example of a many-to many relationship is one between students and classes. A student can register for many classes, and a class can include many students.&lt;/p&gt;
&lt;p&gt;The following example includes a Students table, which contains a record for each student, and a Classes table, which contains a record for each class. A join table, Enrollments, creates two one-to-many relationships—one between each of the two tables.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425775/201810/1425775-20181012233929202-2140050535.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The primary key Student ID uniquely identifies each student in the Students table. The primary key Class ID uniquely identifies each class in the Classes table. The Enrollments table contains the foreign keys Student ID and Class ID.&lt;/p&gt;
&lt;p&gt;To set up a join table for a many-to-many relationship:&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Using the example above, create a table named Enrollments. This will be the join table.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;In the Enrollments table, create a Student ID field and a Class ID field.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Join tables typically hold fields that might not make sense to have in any other table. You can add fields to the Enrollments table, such as a Date field to keep track of when someone started a class, and a Cost field to track how much a student paid to take a class.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Create a relationship between the two Student ID fields in the tables. Then create a relationship between the two Class ID fields in the tables.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Using this design, if a student registers for three classes, that student will have one record in the Students table and three records in the Enrollments table—one record for each class the student enrolled in.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Join tables can access fields and data across tables without having to create a separate relationship. For example, to display a list of all the classes a student enrolled in, create a portal on a layout based on the Students table. Design the portal to show related records from the Classes table. Then add the appropriate fields from Classes to the portal. As you browse through records in the Students layout, the portal displays all the classes a particular student is enrolled in.&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;参考链接：&lt;/em&gt;&lt;/strong&gt;&lt;a href=&quot;https://fmhelp.filemaker.com/help/17/fmp/en/index.html#page/FMP_Help%2Fmany-to-many-relationships.html%23&quot;&gt;https://fmhelp.filemaker.com/help/17/fmp/en/index.html#page/FMP_Help%2Fmany-to-many-relationships.html%23&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 12 Oct 2018 15:41:00 +0000</pubDate>
<dc:creator>丹华抱一鷇音子</dc:creator>
<og:description>Many to many Relationships A many to many relationship occurs when multiple records in a table are a</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cpl9412290130/p/9781311.html</dc:identifier>
</item>
<item>
<title>【Java】HashMap源码分析——常用方法详解 - 松饼人</title>
<link>http://www.cnblogs.com/a526583280/p/9781301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/a526583280/p/9781301.html</guid>
<description>&lt;p&gt;上一篇介绍了HashMap的基本概念，这一篇着重介绍HasHMap中的一些常用方法：&lt;br/&gt;put()&lt;br/&gt;get()&lt;br/&gt;**resize()**&lt;/p&gt;
&lt;p&gt;首先介绍resize()这个方法，在我看来这是HashMap中一个非常重要的方法，是用来调整HashMap中table的容量的，在很多操作中多需要重新计算容量。&lt;br/&gt;源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] resize() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Node&amp;lt;K,V&amp;gt;[] oldTab =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; oldCap = (oldTab == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : oldTab.length;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; oldThr =&lt;span&gt; threshold;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; newCap, newThr = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt;=&lt;span&gt; MAXIMUM_CAPACITY) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 threshold =&lt;span&gt; Integer.MAX_VALUE;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldTab;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
&lt;span&gt;12&lt;/span&gt;                      oldCap &amp;gt;=&lt;span&gt; DEFAULT_INITIAL_CAPACITY)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 newThr = oldThr &amp;lt;&amp;lt; 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; double threshold&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldThr &amp;gt; 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; initial capacity was placed in threshold&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             newCap =&lt;span&gt; oldThr;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; {               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; zero initial threshold signifies using defaults&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             newCap =&lt;span&gt; DEFAULT_INITIAL_CAPACITY;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             newThr = (&lt;span&gt;int&lt;/span&gt;)(DEFAULT_LOAD_FACTOR *&lt;span&gt; DEFAULT_INITIAL_CAPACITY);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (newThr == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;float&lt;/span&gt; ft = (&lt;span&gt;float&lt;/span&gt;)newCap *&lt;span&gt; loadFactor;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (&lt;span&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY ?
&lt;span&gt;24&lt;/span&gt;                       (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ft : Integer.MAX_VALUE);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         threshold =&lt;span&gt; newThr;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node[newCap];
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         table =&lt;span&gt; newTab;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (oldTab != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; oldCap; ++&lt;span&gt;j) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 Node&amp;lt;K,V&amp;gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; ((e = oldTab[j]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     oldTab[j] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (e.next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                         newTab[e.hash &amp;amp; (newCap - 1)] =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                         ((TreeNode&amp;lt;K,V&amp;gt;)e).split(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, newTab, j, oldCap);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; preserve order&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;                         Node&amp;lt;K,V&amp;gt; loHead = &lt;span&gt;null&lt;/span&gt;, loTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                         Node&amp;lt;K,V&amp;gt; hiHead = &lt;span&gt;null&lt;/span&gt;, hiTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                         Node&amp;lt;K,V&amp;gt;&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                         &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                             next =&lt;span&gt; e.next;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; ((e.hash &amp;amp; oldCap) == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (loTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                                     loHead =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;                                     loTail.next =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                                 loTail =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (hiTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                                     hiHead =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;                                     hiTail.next =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                                 hiTail =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                         } &lt;span&gt;while&lt;/span&gt; ((e = next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (loTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                             loTail.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                             newTab[j] =&lt;span&gt; loHead;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (hiTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;                             hiTail.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                             newTab[j + oldCap] =&lt;span&gt; hiHead;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; newTab;
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到这段代码非常庞大，其内容可以分为两大部分：&lt;br/&gt;第一部分计算并生成新的哈希表（空表）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录原表&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] oldTab =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到原来哈希表的总长度，及原来总容量&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; oldCap = (oldTab == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : oldTab.length;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到原来最佳容量&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; oldThr =&lt;span&gt; threshold;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存放新的总容量、新最佳容量的变量&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; newCap, newThr = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原来总容量达到或超过HashMap的最大容量，则最佳容量设置为int类型的最大值
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 且原来容量不变，直接返回，不做后需调整&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt;=&lt;span&gt; MAXIMUM_CAPACITY) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;        threshold =&lt;span&gt; Integer.MAX_VALUE;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldTab;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让新的总容量等于原来容量的二倍&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
&lt;span&gt;18&lt;/span&gt;             oldCap &amp;gt;=&lt;span&gt; DEFAULT_INITIAL_CAPACITY)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新的最佳容量也变为原来的二倍&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;        newThr = oldThr &amp;lt;&amp;lt; 1&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原来总容量为0，将新的总容量设置为最佳容量，构造方法出入参数是一个派生的Map的时候，就会使用派生的Map计算出新的最佳容量&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldThr &amp;gt; 0&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;    newCap =&lt;span&gt; oldThr;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;&lt;span&gt; { 
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原来总容量和原来最佳容量都没有定义
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新的总容量设为默认值16
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新的最佳容量=默认负载因子×默认容量=0.75×16=12              &lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;    newCap =&lt;span&gt; DEFAULT_INITIAL_CAPACITY;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;    newThr = (&lt;span&gt;int&lt;/span&gt;)(DEFAULT_LOAD_FACTOR *&lt;span&gt; DEFAULT_INITIAL_CAPACITY);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断上述操作后新的最佳容量是否计算，若没有，就利用负载因子和新的总容量计算&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (newThr == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;    &lt;span&gt;float&lt;/span&gt; ft = (&lt;span&gt;float&lt;/span&gt;)newCap *&lt;span&gt; loadFactor;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;    newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (&lt;span&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY ?
&lt;span&gt;36&lt;/span&gt;              (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ft : Integer.MAX_VALUE);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新当前的最佳容量&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; threshold =&lt;span&gt; newThr;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成新的哈希表，即一维数组&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node[newCap];
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新哈希表&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; table = newTab;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出上述操作仅仅是生成了一张大小合适的哈希表，但表还是空的，后面的操作就是把以前的表中的元素重新排列，移动到当前表中合适的位置！&lt;/p&gt;
&lt;p&gt;第二部分将原表元素移动到新表合适的位置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先判断原表是或否为空&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldTab != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历原表（一维数组）中的所有元素，&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; oldCap; ++&lt;span&gt;j) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录原来一维数组中下标为j的元素&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;        Node&amp;lt;K,V&amp;gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只对有效元素进行操作&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; ((e = oldTab[j]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将原表中的元素置空&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;            oldTab[j] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; (e.next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前元素没有后继，那么直接把它放在新表中合适位置
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其中e.hash &amp;amp; (newCap - 1)在我上一篇博客有介绍
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 就是以该节点的hash值和新表总容量取余，将余数作为下标&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                newTab[e.hash &amp;amp; (newCap - 1)] =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前元素有后继，且后继是红黑树
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行有关红黑树的相应操作
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里不详细介绍红黑树的操作&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                ((TreeNode&amp;lt;K,V&amp;gt;)e).split(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, newTab, j, oldCap);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;            &lt;span&gt;else&lt;/span&gt;&lt;span&gt; { 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里就进行有关链表的移动
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这两组结点变量，分别代表两条不同链表的头和尾
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低位的头和尾 &lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                Node&amp;lt;K,V&amp;gt; loHead = &lt;span&gt;null&lt;/span&gt;, loTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 高位的头和尾&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                Node&amp;lt;K,V&amp;gt; hiHead = &lt;span&gt;null&lt;/span&gt;, hiTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下一节点&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                Node&amp;lt;K,V&amp;gt;&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让next等于当前结点的后继结点&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;                    next =&lt;span&gt; e.next;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个位运算实际上判断的是该节点在新表中的位置是否发生改变
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成立则说明没有改变，还是原来表中下标为j的位置&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                    &lt;span&gt;if&lt;/span&gt; ((e.hash &amp;amp; oldCap) == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若是首结点，则让低位的头等于当前结点&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;                        &lt;span&gt;if&lt;/span&gt; (loTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                            loHead =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                        &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若不是首结点，则让低位的尾等于当前结点&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                            loTail.next =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让低位的尾移动到当前&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;                        loTail =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                   }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里就说明其在新表中的位置发生了改变，则要将其放入另一条链表&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;                    &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若是首结点，则让高位的头等于当前结点&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;                        &lt;span&gt;if&lt;/span&gt; (hiTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                            hiHead =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                        &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;                               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若不是首结点，则让高位的尾等于当前结点&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;                            hiTail.next =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让高位的尾移动到当前&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;                        hiTail =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                   }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                } &lt;span&gt;while&lt;/span&gt; ((e = next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原来位置的这条链表还存在&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;                &lt;span&gt;if&lt;/span&gt; (loTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 置空低位的尾的next&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;                    loTail.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将该链表的头结点放入新表下标为j的位置，即原表中的原位置&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;                    newTab[j] =&lt;span&gt; loHead;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;               }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新位置上的链表存在&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;                &lt;span&gt;if&lt;/span&gt; (hiTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 置空高位的尾的next&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;                    hiTail.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将该链表的头结点放入新表中下标为j+原表长度的位置&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;                    newTab[j + oldCap] =&lt;span&gt; hiHead;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;               }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; newTab;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;链表的移动如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1376080/201810/1376080-20181012233310616-259470729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，这个方法可以使得单个结点重新散列，链表可以拆分成两条，红黑树重新移动，这样使得新的哈希表分布比以前均匀！&lt;/p&gt;
&lt;p&gt;下面来分析put方法：&lt;br/&gt;源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;      &lt;span&gt;return&lt;/span&gt; putVal(hash(key), key, value, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们可以知道其调用了内部的一个putVal方法：&lt;br/&gt;首先第一个参数是通过内部的hash方法（在前一篇博客有介绍过）计算出键对象的hash（int类型）值，再把key和value对象传过去，置于后面两个参数先不着急&lt;br/&gt;先来看下putVal方法是如何说明的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Implements Map.put and related methods
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; hash hash for key
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key the key
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value the value to put
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * // 看以看出，put方法传入的onlyIfAbsent是false，那么就会改变原来已存在的值
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; onlyIfAbsent if true, don't change existing value
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * // 这个参数先不考虑，往后慢慢分析
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; evict if false, the table is in creation mode.
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; previous value, or null if none
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; V putVal(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;boolean&lt;/span&gt; onlyIfAbsent, &lt;span&gt;boolean&lt;/span&gt; evict)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于保存原表&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;  Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] tab;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存下标为hash的结点 &lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;  Node&amp;lt;K,V&amp;gt;&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; n用来记录表长&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, i;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先检查原表是否存在，或者是空表&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果为空就生成一张大小为16的新表&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;      n = (tab =&lt;span&gt; resize()).length;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; ((p = tab[i = (n - 1) &amp;amp; hash]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果以该方法形参hash对表长取余，令其作为下标的表中的元素为空，那么就产生一个新结点放在这个位置&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;      tab[i] = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果该结点不空，那么就会出现两种情况：链表和红黑树&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;      Node&amp;lt;K,V&amp;gt;&lt;span&gt; e; K k;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt; (p.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;18&lt;/span&gt;          ((k = p.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前结点的hash并且key值（指针值和内容值）相等，由于onlyIfAbsent是false，那么就会改变这个结点的V值，先用e将其保存起来&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;          e =&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;      &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前结点是一棵红黑树，那么就进行红黑树的平衡，这里不讨论红黑树的问题&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;          e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, tab, hash, key, value);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;      &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里就对链表进行操作
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从头开始遍历这条链表&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;          &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; binCount = 0; ; ++&lt;span&gt;binCount) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;              &lt;span&gt;if&lt;/span&gt; ((e = p.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果该节点的next为空
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 就需要新增一个结点追加其后&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;                  p.next = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                  &lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1 for 1st
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里进行红黑树阈值的判断，由于TREEIFY_THRESHOLD默认值是8，binCount是从0开始，那么当链表长度大于等于8的时候，就将该链表转换成红黑树，并且结束循环&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                     treeifyBin(tab, hash);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                  &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;             }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里和之前的判断是一样的&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;              &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;39&lt;/span&gt;                  ((k = e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                  &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让p = p-&amp;gt;next&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;              p =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若e非空，则就是说明原表中存在hash值相等，且key的值或内容相同的结点&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) { 
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将原来的V值保存&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;          V oldValue =&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否是需要进行覆盖原来V值的操作&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 覆盖原来的V值&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;              e.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个方法是一个空的方法，预留的一个操作，不用去管它     &lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;         afterNodeAccess(e);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由于在这里面的操作只是替换了原来的V值，并没有改变原来表的大小，直接返回oldValue&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;          &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 操作数自增&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;  ++&lt;span&gt;modCount;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际大小自增
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若其大于最佳容量进行扩容的操作，使其分布均匀&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (++size &amp;gt;&lt;span&gt; threshold)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;     resize();
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这也是一个空的方法，预留操作&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt; &lt;span&gt; afterNodeInsertion(evict);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并没有替换原来的V值，返回null&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;下来是get方法，逻辑相对简单不难分析：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     Node&amp;lt;K,V&amp;gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; (e = getNode(hash(key), key)) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : e.value;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样也是通过hash方法计算出key对象的hash值，调用内部的getNode方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; getNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash, Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录表对象&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] tab;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录第一个结点和当前节点 &lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     Node&amp;lt;K,V&amp;gt;&lt;span&gt; first, e; 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录表长&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n; 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录K值&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    K k;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表非空或者长度大于0才对其操作
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并且key的hash值对表长取余为下标，其所对应的哈希表中的结点存在&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((tab = table) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
&lt;span&gt;13&lt;/span&gt;         (first = tab[(n - 1) &amp;amp; hash]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前结点满足情况，直接返回给该节点&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (first.hash == hash &amp;amp;&amp;amp; 
&lt;span&gt;16&lt;/span&gt;             ((k = first.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; first;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后面就分为两种情况：在红黑树或者链表中查找&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((e = first.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前结点是红黑树，进行红黑树的查找&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (first &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; ((TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;)first).getTreeNode(hash, key);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行链表的遍历&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;26&lt;/span&gt;                     ((k = e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             } &lt;span&gt;while&lt;/span&gt; ((e = e.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若有不足还请指出！&lt;/p&gt;

&lt;p&gt;我在CSDN也放了一篇&lt;a href=&quot;https://blog.csdn.net/Z_ChenChen/article/details/83004969&quot; target=&quot;_blank&quot;&gt;【Java】HashMap源码分析——常用方法详解&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 12 Oct 2018 15:37:00 +0000</pubDate>
<dc:creator>松饼人</dc:creator>
<og:description>上一篇介绍了HashMap的基本概念，这一篇着重介绍HasHMap中的一些常用方法：put()get()**resize()** 首先介绍resize()这个方法，在我看来这是HashMap中一个非常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/a526583280/p/9781301.html</dc:identifier>
</item>
<item>
<title>Java 软引用 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/9781216.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/9781216.html</guid>
<description>&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;软引用是使用SoftReference创建的引用，强度弱于强引用，被其引用的对象在内存不足的时候会被回收，不会产生内存溢出。&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;软引用，顾名思义就是比较“软”一点的引用。&lt;/p&gt;
&lt;p&gt;当一个对象与GC Roots之间存在强引用时，无论何时都不会被GC回收掉。如果一个对象与GC Roots之间没有强引用与其关联而存在软引用关联时，那么垃圾回收器对它的态度就取决于内存的紧张程度了。如果内存空间足够，垃圾回收器就不会回收这个对象，但如果内存空间不足了，它就难逃被回收的厄运。&lt;/p&gt;
&lt;p&gt;如果一个对象与GC Roots之间不存在强引用，但是存在软引用，则称这个对象为&lt;code&gt;软可达（soft reachable）&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;在垃圾回收器没有回收它的时候，软可达对象就像强可达对象一样，可以被程序正常访问和使用，但是需要通过软引用对象间接访问，需要的话也能重新使用强引用将其关联。所以软引用适合用来做内存敏感的高速缓存。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String s = new String(&quot;Frank&quot;);    // 创建强引用与String对象关联，现在该String对象为强可达状态
SoftReference&amp;lt;String&amp;gt; softRef = new SoftReference&amp;lt;String&amp;gt;(s);     // 再创建一个软引用关联该对象
s = null;        // 消除强引用，现在只剩下软引用与其关联，该String对象为软可达状态
s = softRef.get();  // 重新关联上强引用&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里变量s持有对字符串对象的强引用，而softRef持有对该对象的软引用，所以当执行s = null后，字符串对象就只剩下软引用了，这时如果因为内存不足发生Full GC，就会把这个字符串对象回收掉。&lt;/p&gt;
&lt;p&gt;注意，在垃圾回收器回收一个对象前，SoftReference类所提供的get方法会返回Java对象的强引用，一旦垃圾线程回收该对象之后，get方法将返回null。所以在获取软引用对象的代码中，一定要先判断返回是否为null，以免出现NullPointerException异常而导致应用崩溃。&lt;/p&gt;
&lt;p&gt;下面的代码会让s再次持有对象的强引用：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;s = softRef.get();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在softRef指向的对象被回收前，用强引用指向该对象，那这个对象又会变成强可达。&lt;/p&gt;
&lt;p&gt;来看一个使用SoftReference的栗子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestA {
    static class OOMClass{
        private int[] oom = new int[1024 * 100];// 100KB
    }

    public static void main(String[] args) throws InterruptedException {
        ReferenceQueue&amp;lt;OOMClass&amp;gt; queue = new ReferenceQueue&amp;lt;&amp;gt;();
        List&amp;lt;SoftReference&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        while(true){
            for (int i = 0; i &amp;lt; 100; i++) {
                list.add(new SoftReference&amp;lt;OOMClass&amp;gt;(new OOMClass(), queue));
            }
            Thread.sleep(500);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，ReferenceQueue中声明的类型为OOMClass，即与SoftReference引用的类型一致。&lt;/p&gt;
&lt;p&gt;设置一下虚拟机参数：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;-verbose:gc -Xms4m -Xmx4m -Xmn2m&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[GC (Allocation Failure)  1017K-&amp;gt;432K(3584K), 0.0017239 secs]
[GC (Allocation Failure)  1072K-&amp;gt;472K(3584K), 0.0099237 secs]
[GC (Allocation Failure)  1323K-&amp;gt;1296K(3584K), 0.0009528 secs]
[GC (Allocation Failure)  2114K-&amp;gt;2136K(3584K), 0.0009951 secs]
[Full GC (Ergonomics)  2136K-&amp;gt;1992K(3584K), 0.0040658 secs]
[Full GC (Ergonomics)  2807K-&amp;gt;2791K(3584K), 0.0036280 secs]
[Full GC (Allocation Failure)  2791K-&amp;gt;373K(3584K), 0.0032477 secs]
[Full GC (Ergonomics)  2786K-&amp;gt;2773K(3584K), 0.0034554 secs]
[Full GC (Allocation Failure)  2773K-&amp;gt;373K(3584K), 0.0032667 secs]
[Full GC (Ergonomics)  2798K-&amp;gt;2775K(3584K), 0.0036231 secs]
[Full GC (Allocation Failure)  2775K-&amp;gt;375K(3584K), 0.0055482 secs]
[Full GC (Ergonomics)  2799K-&amp;gt;2776K(3584K), 0.0031358 secs]
...省略n次GC信息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在TestA中，我们使用死循环不断的往list中添加新对象，如果是强引用，会很快因为内存不足而抛出OOM，因为这里的堆内存大小设置为了4M，而一个对象就有100KB，一个循环添加100个对象，也就是差不多10M，显然一个循环都跑不完就会内存不足，而这里，因为使用的是软引用，所以JVM会在内存不足的时候将软引用回收掉。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[Full GC (Allocation Failure)  2791K-&amp;gt;373K(3584K), 0.0032477 secs]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这一条可以看出，在内存不足发生Full GC时，回收掉了大部分的软引用指向的对象，释放了大量的内存。&lt;/p&gt;
&lt;p&gt;因为这里新生代只分配了2M，所以很快就会发生GC，如果你的程序运行没有看到这个结果，请先确认一下虚拟机参数是否设置正确，如果设置正确还是没有看到，那么将循环次数由1000改为10000或者100000在试试看。&lt;img src=&quot;http://www.cnblogs.com/mfrank/p/141.png&quot; width=&quot;50&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;应用场景&quot;&gt;应用场景&lt;/h2&gt;
&lt;p&gt;软引用关联的对象，只有在内存不足的时候JVM才会回收该对象。这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。&lt;/p&gt;
&lt;p&gt;现在考虑这样一个场景 ，在很多应用中，都会出现大量的默认图片，比如说QQ的默认头像，应用内的默认图标等等，这些图片很多地方会用到。&lt;/p&gt;
&lt;p&gt;如果每次都去读取图片，由于读取文件速度较慢，大量重复的读取会导致性能下降。所以可以考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存的图片过多会占用比较多的内存，就可能比较容易发生OOM。这时候，软引用就派得上用场了。&lt;img src=&quot;http://www.cnblogs.com/mfrank/p/0009.png&quot; width=&quot;50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，SoftReference对象是用来保存软引用的，但它同时也是一个Java对象。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null，但SoftReference对象本身并不是null，而此时这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。&lt;/p&gt;
&lt;p&gt;ReferenceQueue就是用来保存这些需要被清理的引用对象的。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。&lt;/p&gt;
&lt;p&gt;下面用SoftReference来实现一个简单的缓存类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SoftCache&amp;lt;T&amp;gt; {
    // 引用队列
    private ReferenceQueue&amp;lt;T&amp;gt; referenceQueue = new ReferenceQueue&amp;lt;&amp;gt;();
    // 保存软引用集合，在引用对象被回收后销毁
    private List&amp;lt;Reference&amp;lt;T&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    // 添加缓存对象
    public synchronized void add(T obj){
        // 构建软引用
        Reference&amp;lt;T&amp;gt; reference = new SoftReference&amp;lt;T&amp;gt;(obj, referenceQueue);
        // 加入列表中
        list.add(reference);
    }

    // 获取缓存对象
    public synchronized T get(int index){
        // 先对无效引用进行清理
        clear();
        if (index &amp;lt; 0 || list.size() &amp;lt; index){
            return null;
        }
        Reference&amp;lt;T&amp;gt; reference = list.get(index);
        return reference == null ? null : reference.get();
    }

    public int size(){
        return list.size();
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private void clear(){
        Reference&amp;lt;T&amp;gt; reference;
        while (null != (reference = (Reference&amp;lt;T&amp;gt;) referenceQueue.poll())){
            list.remove(reference);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后测试一下这个缓存类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SoftCacheTest {
    private static int num = 0;

    public static void main(String[] args){
        SoftCache&amp;lt;OOMClass&amp;gt; softCache = new SoftCache&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; 40; i++) {
            softCache.add(new OOMClass(&quot;OOM Obj-&quot; + ++num));
        }
        System.out.println(softCache.size());
        for (int i = 0; i &amp;lt; softCache.size(); i++) {
            OOMClass obj = softCache.get(i);
            System.out.println(obj == null ? &quot;null&quot; : obj.name);
        }
        System.out.println(softCache.size());
    }

    static class OOMClass{
        private String name;
        private int[] oom = new int[1024 * 100];// 100KB

        public OOMClass(String name) {
            this.name = name;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仍使用之前的虚拟机参数：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;-verbose:gc -Xms4m -Xmx4m -Xmn2m&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[GC (Allocation Failure)  1017K-&amp;gt;432K(3584K), 0.0012236 secs]
[GC (Allocation Failure)  1117K-&amp;gt;496K(3584K), 0.0016875 secs]
[GC (Allocation Failure)  1347K-&amp;gt;1229K(3584K), 0.0015059 secs]
[GC (Allocation Failure)  2047K-&amp;gt;2125K(3584K), 0.0018090 secs]
[Full GC (Ergonomics)  2125K-&amp;gt;1994K(3584K), 0.0054759 secs]
[Full GC (Ergonomics)  2822K-&amp;gt;2794K(3584K), 0.0023167 secs]
[Full GC (Allocation Failure)  2794K-&amp;gt;376K(3584K), 0.0036056 secs]
[Full GC (Ergonomics)  2795K-&amp;gt;2776K(3584K), 0.0042365 secs]
[Full GC (Allocation Failure)  2776K-&amp;gt;376K(3584K), 0.0035122 secs]
[Full GC (Ergonomics)  2795K-&amp;gt;2776K(3584K), 0.0054760 secs]
[Full GC (Allocation Failure)  2776K-&amp;gt;376K(3584K), 0.0036965 secs]
[Full GC (Ergonomics)  2802K-&amp;gt;2777K(3584K), 0.0044513 secs]
[Full GC (Allocation Failure)  2777K-&amp;gt;376K(3584K), 0.0041400 secs]
[Full GC (Ergonomics)  2796K-&amp;gt;2777K(3584K), 0.0025255 secs]
[Full GC (Allocation Failure)  2777K-&amp;gt;376K(3584K), 0.0037690 secs]
[Full GC (Ergonomics)  2817K-&amp;gt;2777K(3584K), 0.0037759 secs]
[Full GC (Allocation Failure)  2777K-&amp;gt;377K(3584K), 0.0042416 secs]
缓存列表大小：40
OOM Obj-37
OOM Obj-38
OOM Obj-39
OOM Obj-40
缓存列表大小：4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，缓存40个软引用对象之后，如果一次性全部存储，显然内存大小无法满足，所以在不断创建软引用对象的过程中，不断发生GC来进行垃圾回收，最终只有4个软引用未被清理掉。&lt;/p&gt;
&lt;h2 id=&quot;强引用与软引用对比&quot;&gt;强引用与软引用对比&lt;/h2&gt;
&lt;p&gt;没有对比就没有伤害，来将强引用和软引用对比一下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {

    static class OOMClass{
        private int[] oom = new int[1024];
    }

    public static void main(String[] args) {
        testStrongReference();
        //testSoftReference();
    }

    public static void testStrongReference(){
        List&amp;lt;OOMClass&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; 1000; i++) {
            list.add(new OOMClass());
        }
    }

    public static void testSoftReference(){
        ReferenceQueue&amp;lt;OOMClass&amp;gt; referenceQueue = new ReferenceQueue&amp;lt;&amp;gt;();
        List&amp;lt;SoftReference&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; 1000; i++) {
            OOMClass oomClass = new OOMClass();
            list.add(new SoftReference(oomClass, referenceQueue));
            oomClass = null;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行testStrongReference方法的结果如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[GC (Allocation Failure)  1019K-&amp;gt;384K(3584K), 0.0033595 secs]
[GC (Allocation Failure)  1406K-&amp;gt;856K(3584K), 0.0013098 secs]
[GC (Allocation Failure)  1880K-&amp;gt;1836K(3584K), 0.0014382 secs]
[Full GC (Ergonomics)  1836K-&amp;gt;1756K(3584K), 0.0039761 secs]
[Full GC (Ergonomics)  2778K-&amp;gt;2758K(3584K), 0.0021269 secs]
[Full GC (Ergonomics)  2779K-&amp;gt;2770K(3584K), 0.0016329 secs]
[Full GC (Ergonomics)  2779K-&amp;gt;2775K(3584K), 0.0023157 secs]
[Full GC (Ergonomics)  2775K-&amp;gt;2775K(3584K), 0.0015927 secs]
[Full GC (Ergonomics)  3037K-&amp;gt;3029K(3584K), 0.0025071 secs]
[Full GC (Ergonomics)  3067K-&amp;gt;3065K(3584K), 0.0017529 secs]
[Full GC (Allocation Failure)  3065K-&amp;gt;3047K(3584K), 0.0033445 secs]
[Full GC (Ergonomics)  3068K-&amp;gt;3059K(3584K), 0.0016623 secs]
[Full GC (Ergonomics)  3070K-&amp;gt;3068K(3584K), 0.0028357 secs]
[Full GC (Allocation Failure)  3068K-&amp;gt;3068K(3584K), 0.0017616 secs]
java.lang.OutOfMemoryError: Java heap space
Dumping heap to java_pid3352.hprof ...
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space
Heap dump file created [3855956 bytes in 0.017 secs]
[Full GC (Ergonomics)  3071K-&amp;gt;376K(3584K), 0.0032068 secs]
    at reference.Test$OOMClass.&amp;lt;init&amp;gt;(Test.java:11)
    at reference.Test.testStrongReference(Test.java:22)
    at reference.Test.main(Test.java:15)

Process finished with exit code 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，很快就抛出了OOM，原因是Java heap space，也就是堆内存不足。&lt;/p&gt;
&lt;p&gt;如果运行testSoftReference方法，将会得到如下结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[GC (Allocation Failure)  1019K-&amp;gt;464K(3584K), 0.0019850 secs]
[GC (Allocation Failure)  1484K-&amp;gt;844K(3584K), 0.0015920 secs]
[GC (Allocation Failure)  1868K-&amp;gt;1860K(3584K), 0.0043236 secs]
[Full GC (Ergonomics)  1860K-&amp;gt;1781K(3584K), 0.0044581 secs]
[Full GC (Ergonomics)  2802K-&amp;gt;2754K(3584K), 0.0041726 secs]
[Full GC (Ergonomics)  2802K-&amp;gt;2799K(3584K), 0.0031293 secs]
[Full GC (Ergonomics)  3023K-&amp;gt;3023K(3584K), 0.0024830 secs]
[Full GC (Ergonomics)  3071K-&amp;gt;3068K(3584K), 0.0035025 secs]
[Full GC (Allocation Failure)  3068K-&amp;gt;405K(3584K), 0.0040672 secs]
[GC (Allocation Failure)  1512K-&amp;gt;1567K(3584K), 0.0011170 secs]
[Full GC (Ergonomics)  1567K-&amp;gt;1496K(3584K), 0.0048438 secs]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，并没有抛出OOM，而是进行多次了GC，可以明显的看到这一条：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[Full GC (Allocation Failure)  3068K-&amp;gt;405K(3584K), 0.0040672 secs]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当内存不足时进行了一次Full GC，回收了大部分内存空间，也就是将大部分软引用指向的对象回收掉了。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;软引用弱于强引用&lt;/li&gt;
&lt;li&gt;软引用指向的对象会在内存不足时被垃圾回收清理掉&lt;/li&gt;
&lt;li&gt;JVM会优先回收长时间闲置不用的软引用对象，对那些刚刚构建的或刚刚使用过的软引用对象会尽可能保留&lt;/li&gt;
&lt;li&gt;软引用可以有效的解决OOM问题&lt;/li&gt;
&lt;li&gt;软引用适合用作非必须大对象的缓存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至此，本篇就告一段落了，这里只简单的介绍了软引用的作用以及用法。其实软引用并没有这么好，它的使用有一些可能是致命的缺点，如果想要更深入的了解软引用的运行原理以及软引用到底是在何时进行回收，又是如何进行回收的话，可以查看翻阅后续的章节。&lt;/p&gt;
</description>
<pubDate>Fri, 12 Oct 2018 15:09:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<og:description>定义 软引用是使用SoftReference创建的引用，强度弱于强引用，被其引用的对象在内存不足的时候会被回收，不会产生内存溢出。 说明 软引用，顾名思义就是比较“软”一点的引用。 当一个对象与GC</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/9781216.html</dc:identifier>
</item>
<item>
<title>Markdown 版本演进 - 云是风的梦</title>
<link>http://www.cnblogs.com/lijinfeng042/p/9780864.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijinfeng042/p/9780864.html</guid>
<description>&lt;p&gt;本文作为 Markdown 系列的第二篇，对上一篇&lt;a href=&quot;https://www.cnblogs.com/lijinfeng042/p/9678684.html&quot;&gt;使用 Markdown 写技术博客，我踩过的 6个坑&lt;/a&gt;博客提到的版本变迁进行简要的提纲说明。&lt;br/&gt;本文内容做成一张思维导图，使用 Atom + markdown-mindmap，由于格式不支持 SVG,转换为 PNG 显示，如果满足不了无损需求，请到百度网盘文件下载：&lt;br/&gt;&lt;a href=&quot;https://pan.baidu.com/s/1e6RVxc_GRF9wV0jP42BuRw&quot; title=&quot;Markdown 版本演进思维导图无损svg下载&quot;&gt;Markdown 版本演进思维导图&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/66cf5bc0ly1fw5v1e165tj23qy2nxu0x.jpg&quot; alt=&quot;Markdown 版本演进思维导图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;markdown&quot;&gt;Markdown&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;初始版本：2004-03-19&lt;/li&gt;
&lt;li&gt;最新版本：2004-12-17 , V1.0.1&lt;/li&gt;
&lt;li&gt;作者：John Gruber 和 Aaron Swartz（互联网之子，已逝）&lt;/li&gt;
&lt;li&gt;语言： 第一个版本为 Perl，目前有其他实现&lt;/li&gt;
&lt;li&gt;网站：
&lt;/li&gt;
&lt;li&gt;特性：易读易写
&lt;ul&gt;&lt;li&gt;文字格式：粗体，斜体&lt;/li&gt;
&lt;li&gt;插入内容：标题，图片，链接，引用，水平线，块（`）&lt;/li&gt;
&lt;li&gt;功能：列表（无序，有序）&lt;/li&gt;
&lt;li&gt;限制：
&lt;ul&gt;&lt;li&gt;不支持表格&lt;/li&gt;
&lt;li&gt;块级标签必须前后空行，且不能被空格或制表符缩进&lt;/li&gt;
&lt;li&gt;块级标签内不能使用 Markdown 语法&lt;/li&gt;
&lt;li&gt;支持列表、段落、引用嵌套，方法为每行行首使用4个空格或1个制表符进行缩进&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;commonmark&quot;&gt;CommonMark&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;初始版本：2012 年发起，2014-10-25 发布 Release 0.5&lt;/li&gt;
&lt;li&gt;最新版本： V0.28.1（2017-8-2）&lt;/li&gt;
&lt;li&gt;作者：Jeff Atwood 和 John MacFarlane 为首的小组&lt;/li&gt;
&lt;li&gt;语言： 实现版本众多，commonmark.js 和 cmark 是最广泛。&lt;/li&gt;
&lt;li&gt;网站：
&lt;/li&gt;
&lt;li&gt;特性：严格定义了 Markdown 语法转为 Html 的实现&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;github-flavored-markdown-gfm&quot;&gt;GitHub Flavored Markdown (GFM)&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;初始版本：2017-08-01，V0.28-gfm&lt;/li&gt;
&lt;li&gt;最新版本：2018-09-10，V0.28.3.gfm.16&lt;/li&gt;
&lt;li&gt;作者：Github&lt;/li&gt;
&lt;li&gt;语言：C 语言，forked from commonmark/cmark&lt;/li&gt;
&lt;li&gt;网站：
&lt;/li&gt;
&lt;li&gt;特性：描述代码项目功能和变更
&lt;ul&gt;&lt;li&gt;基于 CommonMark 的 cmark 分支
&lt;ul&gt;&lt;li&gt;文字格式新增：删除线（~~）&lt;/li&gt;
&lt;li&gt;插入内容新增：自动链接，修订版本（+/-）&lt;/li&gt;
&lt;li&gt;功能新增：简单表格（支持对齐：），任务列表，代码块及高亮功能（```）&lt;/li&gt;
&lt;li&gt;限制：
&lt;ul&gt;&lt;li&gt;Html 支持限制&lt;/li&gt;
&lt;li&gt;列表嵌套方法：改为每次嵌套缩进两个空格&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;初始版本：First release 1.3 (11 Apr 2013)&lt;/li&gt;
&lt;li&gt;最新版本：1.8.0 (14 Jan 2018)&lt;/li&gt;
&lt;li&gt;作者：Michel Fortin&lt;/li&gt;
&lt;li&gt;语言：初始版本为 PHP&lt;/li&gt;
&lt;li&gt;网站：&lt;a href=&quot;https://github.com/michelf/php-markdown&quot; class=&quot;uri&quot;&gt;https://github.com/michelf/php-markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;特性：加强网页展示功能
&lt;ul&gt;&lt;li&gt;基于 Markdown
&lt;ul&gt;&lt;li&gt;插入内容新增：
&lt;ul&gt;&lt;li&gt;标题增加锚点属性（方便引用，样式，属性设置）&lt;/li&gt;
&lt;li&gt;增加脚注&lt;/li&gt;
&lt;li&gt;缩写备注（HTML tag &lt;abbr&gt;）&lt;/abbr&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;功能新增：&lt;/abbr&gt;
&lt;ul&gt;&lt;li&gt;&lt;abbr&gt;表格（支持对齐：）&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;任务列表&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;与 GFM 相似的代码块及代码高亮功能&lt;/abbr&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;修改:&lt;/abbr&gt;
&lt;ul&gt;&lt;li&gt;&lt;abbr&gt;内嵌 Html：块标签可缩进不超3空格，可在块标签使用 Markdown 语法&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;强调：两字词中间的下划线不会被解释成强调&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;不支持多词强调，反斜杠使用替代的 ： 和 |&lt;/abbr&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;multimarkdown&quot;&gt;&lt;abbr&gt;MultiMarkdown&lt;/abbr&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;abbr&gt;初始版本：2011 年 4 月&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;最新版本：V6 (2018.02.23)&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;作者：Fletcher T. Penney&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;语言&lt;/abbr&gt;
&lt;ul&gt;&lt;li&gt;&lt;abbr&gt;初始版本为 perl&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;V3 后基于 peg-markdown 项目重构修改为 C 语言&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;使用 PEG（解析表达文法）处理文本&lt;/abbr&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;网站：&lt;/abbr&gt;
&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;特性：加强导出转换功能&lt;/abbr&gt;
&lt;ul&gt;&lt;li&gt;&lt;abbr&gt;基于 Markdown，兼容 PHP Markdown Extra&lt;/abbr&gt;
&lt;ul&gt;&lt;li&gt;&lt;abbr&gt;插入内容新增：支持脚注，参考文献，缩略语，交叉引用，上下标（^,~）&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;功能新增：&lt;/abbr&gt;
&lt;ul&gt;&lt;li&gt;&lt;abbr&gt;支持元数据&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;数学公式（MathJax），行内&lt;span class=&quot;math inline&quot;&gt;\(，块\)&lt;/span&gt;$&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;部分复杂表格&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;修订功能（CriticMarkup）显示修订痕迹&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;内嵌其他文件&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;目录（TOC）&lt;/abbr&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;修改&lt;/abbr&gt;
&lt;ul&gt;&lt;li&gt;&lt;abbr&gt;换行方式改为行末使用\换行（原生Markdown使用2个空格换行）&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;Html 块内语法支持&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;导出支持 HTML,LaTeX,OPML,OpenDocument Text document&lt;/abbr&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;pandocs-markdown&quot;&gt;&lt;abbr&gt;Pandoc's Markdown&lt;/abbr&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;abbr&gt;初始版本：2006&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;最新版本：V2.3&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;作者：John MacFarlane&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;语言： Haskell&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;网站：&lt;/abbr&gt;
&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;特性：多格式文档的转换工具&lt;/abbr&gt;
&lt;ul&gt;&lt;li&gt;&lt;abbr&gt;根据配置可以支持多种 Markdown 扩展格式，自由配置启用或不用特性（+/-EXTENSION）&lt;/abbr&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考文献&quot;&gt;&lt;abbr&gt;参考文献&lt;/abbr&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;abbr&gt;感谢 John Gruber 和 Aaron Swartz 给我们带来如此美妙的 Markdown&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;参考了大量的文章：&lt;br/&gt;2.1 &lt;a href=&quot;https://en.wikipedia.org/wiki/Markdown&quot;&gt;维基百科&lt;/a&gt;&lt;br/&gt;2.2 &lt;a href=&quot;https://aringfireball.net/projects/markdown/&quot;&gt;Markdown 原始的John Gruber站点&lt;/a&gt;&lt;br/&gt;2.3 &lt;a href=&quot;https://sspai.com/post/37264&quot;&gt;少数派 Markdown 专题&lt;/a&gt;&lt;br/&gt;2.4 &lt;a href=&quot;https://commonmark.org/&quot;&gt;Commonmark 官网&lt;/a&gt;&lt;br/&gt;2.5 &lt;a href=&quot;https://github.github.com/gfm/&quot;&gt;GitHub Flavored Markdown 官网&lt;/a&gt;&lt;br/&gt;2.6 &lt;a href=&quot;https://github.com/michelf/php-markdown&quot;&gt;PHP Markdown Extra 官网&lt;/a&gt;&lt;br/&gt;2.7 &lt;a href=&quot;http://fletcherpenney.net/multimarkdown/&quot;&gt;Multimarkdown 官网&lt;/a&gt;&lt;br/&gt;2.8 &lt;a href=&quot;http://pandoc.org/MANUAL.html#pandocs-markdown&quot;&gt;Pandoc 官网 Markdown 帮助&lt;/a&gt;&lt;/abbr&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;abbr&gt;博客是我学习过程的输出，希望你有所收获。&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;有想法请留言，共同探讨学习。&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;由于博主能力有限，文中可能存在描述不正确，欢迎指正、补充！&lt;/abbr&gt;&lt;/li&gt;
&lt;li&gt;&lt;abbr&gt;你也可以关注我的公众号：&lt;strong&gt;ProgramLife042&lt;/strong&gt;，名称：&lt;strong&gt;风之程序人生&lt;/strong&gt;，方便接收最新内容。&lt;/abbr&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;abbr&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/mw690/66cf5bc0ly1fv6etki980j20760763yz.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/abbr&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 12 Oct 2018 13:39:00 +0000</pubDate>
<dc:creator>云是风的梦</dc:creator>
<og:description>本文作为 Markdown 系列的第二篇，对上一篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijinfeng042/p/9780864.html</dc:identifier>
</item>
<item>
<title>说说GIL - 毒逆天</title>
<link>http://www.cnblogs.com/dunitian/p/9780821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dunitian/p/9780821.html</guid>
<description>&lt;p&gt;上一篇：&lt;a href=&quot;https://mp.weixin.qq.com/s/wzy-ywunElf6LiA8jtvlrQ&quot; target=&quot;_blank&quot;&gt;线程深入篇引入&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Code：&lt;code&gt;https://github.com/lotapp/BaseCode/tree/master/python/5.concurrent/Thread/3.GIL&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;说说gil&quot;&gt;说说GIL&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;尽管Python完全支持多线程编程， 但是解释器的C语言实现部分在完全并行执行时并不是线程安全的，所以这时候才引入了GIL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释器被一个全局解释器锁保护着，它确保任何时候都只有一个Python线程执行(保证C实现部分能线程安全) GIL最大的问题就是Python的多线程程序并不能利用多核CPU的优势 （比如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行）&lt;/p&gt;
&lt;p&gt;注意：&lt;strong&gt;GIL只会影响到那些严重依赖CPU的程序（比如计算型的）如果你的程序大部分只会涉及到I/O，比如网络交互，那么使用多线程就很合适&lt;/strong&gt; ~ 因为它们大部分时间都在等待（线程被限制到同一时刻只允许一个线程执行这样一个执行模型。GIL会根据执行的字节码行数和时间片来释放GIL，在遇到IO操作的时候会主动释放权限给其他线程）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以Python的线程&lt;strong&gt;更适用于处理&lt;code&gt;I/O&lt;/code&gt;和其他需要并发执行的阻塞操作，而不是需要多处理器并行的计算密集型任务&lt;/strong&gt;（对于IO操作来说，多进程和多线程性能差别不大）&lt;/span&gt;【&lt;strong&gt;&lt;a href=&quot;https://github.com/ray-project/ray&quot; target=&quot;_blank&quot;&gt;计算密集现在可以用Python的&lt;code&gt;Ray&lt;/code&gt;框架&lt;/a&gt;&lt;/strong&gt;】&lt;/p&gt;
&lt;p&gt;网上摘取一段关于&lt;code&gt;IO密集和计算密集&lt;/code&gt;的说明：（IO密集型可以结合异步）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。

计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。

第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。

IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;process-and-thread-test&quot;&gt;Process and Thread Test&lt;/h2&gt;
&lt;p&gt;其实用不用多进程看你需求，不要麻木使用，Linux下还好点，Win下进程开销就有点大了（好在服务器基本上都是Linux，程序员开发环境也大多Linux了）这边只是简单测了个启动时间差距就来了，其他的都不用测试了&lt;/p&gt;
&lt;p&gt;测试Code：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;from time import sleep
from multiprocessing import Process

def test(i):
    sleep(1)
    print(i)

def main():
    t_list = [Process(target=test, args=(i, )) for i in range(1000)]
    for t in t_list:
        t.start()

if __name__ == '__main__':
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;real    0m3.980s
user    0m2.034s
sys  0m3.119s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;操作系统几千个进程开销还是有点大的&lt;/strong&gt;（毕竟进程是有上线的）&lt;code&gt;ulimit -a&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201810/1127869-20181012165257226-1648541203.png&quot; alt=&quot;9.MaxProcess.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试Code：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;from time import sleep
from multiprocessing.dummy import Process

def test(i):
    sleep(1)
    print(i)

def main():
    t_list = [Process(target=test, args=(i, )) for i in range(1000)]
    for t in t_list:
        t.start()

if __name__ == '__main__':
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;real    0m1.130s
user    0m0.158s
sys  0m0.095s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;multiprocessing.dummy&lt;/code&gt;里面的Process上面也说过了，就是在线程基础上加点东西使得用起来和&lt;code&gt;multiprocessing&lt;/code&gt;的&lt;code&gt;Process&lt;/code&gt;编程风格基本一致（本质还是线程）&lt;/p&gt;
&lt;p&gt;测试Code:&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;from time import sleep
from multiprocessing.dummy import threading

def test(i):
    sleep(1)
    print(i)

def main():
    t_list = [threading.Thread(target=test, args=(i, )) for i in range(1000)]
    for t in t_list:
        t.start()

if __name__ == '__main__':
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;real    0m1.123s
user    0m0.154s
sys  0m0.085s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实Redis就是使用单线程和多进程的经典，它的性能有目共睹。所谓性能无非看个人能否充分发挥罢了。不然就算给你轰炸机你也不会开啊？扎心不老铁～&lt;/p&gt;
&lt;p&gt;PS：&lt;strong&gt;线程和进程各有其好处，无需一棍打死，具体啥好处可以回顾之前写的进程和线程篇～&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;利用共享库来扩展&quot;&gt;利用共享库来扩展&lt;/h2&gt;
&lt;h3 id=&quot;c系扩展&quot;&gt;C系扩展&lt;/h3&gt;
&lt;p&gt;GIL是Python解释器设计的历史遗留问题，多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。计算密集型任务要真正利用多核，除非重写一个不带GIL的解释器（&lt;code&gt;PyPy&lt;/code&gt;）如果一定要通过多线程利用多核，可以通过C扩展来实现（&lt;strong&gt;Python很多模块都是用C系列写的，所以用C扩展也就不那么奇怪了&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;只要用C系列写个简单功能（不需要深入研究高并发），然后使用&lt;code&gt;ctypes&lt;/code&gt;导入使用就行了：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;  

void test()  
{  
  while(1){}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译成共享库：&lt;strong&gt;&lt;code&gt;gcc 2.test.c -shared -o libtest.so&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201810/1127869-20181012174437403-37264231.png&quot; alt=&quot;9.共享库.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Python运行指定方法：（&lt;code&gt;太方便了，之前一直以为C#调用C系列最方便，用完Python才知道更简方案&lt;/code&gt;）&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;from ctypes import cdll
from os import cpu_count
from multiprocessing.dummy import Pool

def main():
    # 加载C共享库（动态链接库）
    lib = cdll.LoadLibrary(&quot;./libtest.so&quot;)

    pool = Pool()  # 默认是系统核数
    pool.map_async(lib.test, range(cpu_count()))
    pool.close()
    pool.join()

if __name__ == '__main__':
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看这时候HTOP的信息：（充分利用多核）【&lt;strong&gt;ctypes在调用C时会自动释放GIL&lt;/strong&gt;】&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201810/1127869-20181012184752135-732557811.png&quot; alt=&quot;9.ctypes.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;go扩展&quot;&gt;Go扩展&lt;/h3&gt;
&lt;p&gt;利用Go写个死循环，然后编译成so动态链接库（共享库）：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import &quot;C&quot;

//export test
func test(){
    for true{
    }
}

func main() {
    test()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;非常重要的事情：&lt;code&gt;//export test&lt;/code&gt;一定要写，不然就被自动改成其他名字（我当时被坑过）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Python调用和上面一样：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;from ctypes import cdll
from os import cpu_count
from multiprocessing.dummy import Pool

def main():
    # 加载动态链接库
    lib = cdll.LoadLibrary(&quot;./libtestgo.so&quot;)

    pool = Pool()  # 默认是系统核数
    pool.map_async(lib.test, range(cpu_count()))
    pool.close()
    pool.join()

if __name__ == '__main__':
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果：&lt;code&gt;go build -buildmode=c-shared -o libtestgo.so 2.test.go&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201810/1127869-20181012211715940-910630688.png&quot; alt=&quot;9.golang.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;题外话～如果想等CPython的GIL消失可以先看一个例子：MySQL把大锁改成各个小锁花了5年。在是在MySQL有专门的团队和公司前提下，而Python完全靠社区重构就太慢了&lt;/p&gt;
&lt;p&gt;速度方面微软除外，更新快本来是好事，但是动不动断层更新，这学习成本就太大了(这也是为什么Net能深入的人比较少的原因：人家刚深入一个，你就淘汰一个了...)&lt;/p&gt;
&lt;p&gt;可能还有人不清楚，贴下官方推荐技术吧（&lt;code&gt;NetCore&lt;/code&gt;、&lt;code&gt;Orleans&lt;/code&gt;、&lt;code&gt;EFCore&lt;/code&gt;、&lt;code&gt;ML.Net&lt;/code&gt;、&lt;code&gt;CoreRT&lt;/code&gt;）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://github.com/aspnet/AspNetCore

https://github.com/aspnet/EntityFrameworkCore

https://github.com/dotnet/machinelearning

https://github.com/dotnet/orleans

https://github.com/aspnet/Mvc

https://github.com/dotnet/corert&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;课外拓展：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;用go语言给python3开发模块
https://www.jianshu.com/p/40e069954804
https://blog.filippo.io/building-python-modules-with-go-1-5

Python与C/C++相互调用
https://www.cnblogs.com/apexchu/p/5015961.html

使用C/C++代码编写Python模块
https://www.cnblogs.com/silvermagic/p/9087896.html

快速实现python c扩展模块
https://www.cnblogs.com/chengxuyuancc/p/6374239.html

Python的C语言扩展
https://python3-cookbook.readthedocs.io/zh_CN/latest/chapters/p15_c_extensions.html

python调用golang生成的so库
https://studygolang.com/articles/10228
https://www.cnblogs.com/huangguifeng/p/8931837.html

python调用golang并回调
https://blog.csdn.net/gtd138/article/details/79801235

Python3.x AttributeError: libtest.so: undefined symbol: fact
https://www.cnblogs.com/tanglizi/p/8965230.html&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;运行在其他编译器上&quot;&gt;运行在其他编译器上&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;先看最重要的一点，一旦运行在其他编译器意味着很多Python第三方库&lt;code&gt;可能&lt;/code&gt;就不能用了，相对来说&lt;code&gt;PyPy&lt;/code&gt;兼容性是最好的了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果是&lt;code&gt;Python2&lt;/code&gt;系列我推荐谷歌的&lt;a href=&quot;https://github.com/google/grumpy&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;grumpy&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Grumpy是一个 Python to Go 源代码转换编译器和运行时。旨在成为CPython2.7的近乎替代品。关键的区别在于它将Python源代码编译为Go源代码，然后将其编译为本机代码，而不是字节码。这意味着Grumpy没有VM

已编译的Go源代码是对Grumpy运行时的一系列调用，Go库提供与 Python C API类似的目的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是&lt;code&gt;Python3&lt;/code&gt;系列，可以使用&lt;strong&gt;&lt;code&gt;PyPy&lt;/code&gt;&lt;/strong&gt; &lt;code&gt;PythonNet&lt;/code&gt; &lt;code&gt;Jython3&lt;/code&gt; &lt;code&gt;ironpython3&lt;/code&gt;等等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PyPy&lt;/strong&gt;:&lt;a href=&quot;https://bitbucket.org/pypy/pypy&quot; target=&quot;_blank&quot;&gt;https://bitbucket.org/pypy/pypy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Net方向：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://github.com/pythonnet/pythonnet
https://github.com/IronLanguages/ironpython3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java方向：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://github.com/jython/jython3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Other：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;源码：https://github.com/sbinet/go-python
参考：https://studygolang.com/articles/13019

可惜CoreRT一直没完善，不然就Happy了
https://github.com/dotnet/corert&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;经验&lt;/code&gt;：&lt;strong&gt;平时基本上多线程就够用了，如果想多核利用-多进程基本上就搞定了（分布式走起）实在不行一般都是分析一下性能瓶颈在哪，然后写个扩展库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果需要和其他平台交互才考虑上面说的这些项目。如果是Web项目就更不用担心了，现在哪个公司还不是混用？&lt;code&gt;JavaScript and Python and Go or Java or NetCore&lt;/code&gt;。基本上上点规模的公司都会用到Python，之前都是&lt;code&gt;Python and Java&lt;/code&gt;搭配使用，这几年开始慢慢变成&lt;code&gt;Python and Go or NetCore&lt;/code&gt;搭配使用了~&lt;/p&gt;
&lt;p&gt;下集预估：&lt;code&gt;Actor模型&lt;/code&gt; and &lt;code&gt;消息发布/订阅模型&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 12 Oct 2018 13:28:00 +0000</pubDate>
<dc:creator>毒逆天</dc:creator>
<og:description>上一篇：线程深入篇引入 Code： 说说GIL 尽管Python完全支持多线程编程， 但是解释器的C语言实现部分在完全并行执行时并不是线程安全的，所以这时候才引入了GIL 解释器被一个全局解释器锁保护</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dunitian/p/9780821.html</dc:identifier>
</item>
<item>
<title>3.Netty的粘包、拆包（二） - 零度微笑</title>
<link>http://www.cnblogs.com/TimerHotel/p/netty03.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TimerHotel/p/netty03.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;1.前言&lt;/h2&gt;
&lt;p&gt;关于TCP的数据拆包、粘包的介绍，我在上一篇文章里面已经有过介绍。&lt;/p&gt;
&lt;p&gt;想要了解一下的，请点击这里 &lt;a href=&quot;https://www.cnblogs.com/TimerHotel/p/netty02.html&quot;&gt;Chick Here！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天我们要讲解的是Netty提供的两种解决方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;DelimiterBasedFrameDecoder&lt;/li&gt;
&lt;li&gt;FixedLengthFrameDecoder&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;关于decoder&quot;&gt;2.关于Decoder&lt;/h2&gt;
&lt;ol readability=&quot;11&quot;&gt;&lt;li readability=&quot;11&quot;&gt;
&lt;h3 id=&quot;先观察下两段代码的不同&quot;&gt;先观察下两段代码的不同&lt;/h3&gt;
&lt;p&gt;（1）使用StringDecoder之前&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
 public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {


     try {

         ByteBuf in = (ByteBuf) msg;
         String str = in.toString(CharsetUtil.UTF_8);
         System.out.println(&quot;Client:&quot;+str);

     } finally {
         ReferenceCountUtil.release(msg);
     }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）使用StringDecoder之后&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
 public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {


     try {
         String str = (String) msg;
         System.out.println(&quot;Client:&quot;+str);

     } finally {
         ReferenceCountUtil.release(msg);
     }
 }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;关于Decoder&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;decoder：n. 解码器&lt;/p&gt;
&lt;p&gt;在我看来，Netty数据的解析方式大概为：&lt;/p&gt;
&lt;p&gt;发送过程：Buffer------&amp;gt;数据报------&amp;gt;比特流&lt;/p&gt;
&lt;p&gt;接受过程：Buffer&amp;lt;------数据报&amp;lt;------比特流&lt;/p&gt;
&lt;p&gt;所以我们接受到的msg是一个ButeBuf&lt;/p&gt;
&lt;p&gt;使用了Decoder（这里使用StringDecoder举例）之后：&lt;/p&gt;
&lt;p&gt;发送过程：Buffer------&amp;gt;数据报------&amp;gt;比特流&lt;/p&gt;
&lt;p&gt;接受过程：String&amp;lt;------Buffer&amp;lt;------数据报&amp;lt;------比特流&lt;/p&gt;
&lt;p&gt;相当于ByteBuf按照StringDecoder的解码规则，把msg翻译成为了一个字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;如何使用Decoder&lt;/p&gt;
&lt;p&gt;（1）实际代码演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.xm.netty.demo02;

import java.net.InetSocketAddress;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.codec.string.StringDecoder;

public class Server {

 private final int port;

 public Server(int port) {
     this.port = port;
 }



 public static void main(String[] args) {

     int port = 8989;
     try {
         new Server(port).start();
     } catch (InterruptedException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
     }

 }



 private void start() throws InterruptedException {
     EventLoopGroup g1 = new NioEventLoopGroup();
     EventLoopGroup g2 = new NioEventLoopGroup();
     try {
         ServerBootstrap bootstrap = new ServerBootstrap();
          bootstrap
                 .group(g1,g2)
                 .channel(NioServerSocketChannel.class)
                 .localAddress(new InetSocketAddress( port))
                 .childHandler(new ChannelInitializer() {
                     @Override
                     protected void initChannel(Channel ch) throws Exception {
                         ch.pipeline().addLast(new StringDecoder());
                         ch.pipeline().addLast(new ServerHandler());
                     }
                 });
          ChannelFuture future = bootstrap.bind().sync();
          future.channel().closeFuture().sync();
     } finally {
         g1.shutdownGracefully().sync();
         g2.shutdownGracefully().sync();
     }
 }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码改动：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;ch.pipeline().addLast(new StringDecoder());&lt;br/&gt;​&lt;/p&gt;
&lt;p&gt;​ ch.pipeline().addLast(new ServerHandler());&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（2）多个Decoder的使用顺序：&lt;/p&gt;
&lt;p&gt;从前往后，依次解码&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;假设我们有个通过字符串变化为时间的TimeDecoder：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;ch.pipeline().addLast(new StringDecoder());&lt;/p&gt;
&lt;p&gt;ch.pipeline().addLast(new TimeDecoder());&lt;/p&gt;
&lt;p&gt;​ ch.pipeline().addLast(new ServerHandler());&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解析规则为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422573/201810/1422573-20181012211924238-2070265722.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;delimiterbasedframedecoder&quot;&gt;3.DelimiterBasedFrameDecoder&lt;/h2&gt;
&lt;ol readability=&quot;17&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;关于DelimiterBasedFrameDecoder&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;其实很简单，就是在一个缓冲区的末尾添加一个结束字符。&lt;/p&gt;
&lt;p&gt;在规定了最大长度的缓冲区里，遇到一个特殊字符，就截取一次。&lt;/p&gt;
&lt;p&gt;原理类似于String的split（）方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;31&quot;&gt;
&lt;p&gt;代码实现&lt;/p&gt;
&lt;p&gt;（1）服务端Server&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.xm.netty.demo03;

import java.net.InetSocketAddress;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.codec.DelimiterBasedFrameDecoder;
import io.netty.handler.codec.string.StringDecoder;

public class Server {

 private final int port;

 public Server(int port) {
     this.port = port;
 }



 public static void main(String[] args) {

     int port = 8989;
     try {
         new Server(port).start();
     } catch (InterruptedException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
     }

 }



 private void start() throws InterruptedException {
     EventLoopGroup g1 = new NioEventLoopGroup();
     EventLoopGroup g2 = new NioEventLoopGroup();
     try {
         ServerBootstrap bootstrap = new ServerBootstrap();
          bootstrap
                 .group(g1,g2)
                 .channel(NioServerSocketChannel.class)
                 .localAddress(new InetSocketAddress( port))
                 .childHandler(new ChannelInitializer() {
                     @Override
                     protected void initChannel(Channel ch) throws Exception {
                         ByteBuf buf = Unpooled.copiedBuffer(&quot;$&quot;.getBytes());
                         ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,buf));
                         ch.pipeline().addLast(new StringDecoder());
                         ch.pipeline().addLast(new ServerHandler());
                     }
                 });
          ChannelFuture future = bootstrap.bind().sync();
          future.channel().closeFuture().sync();
     } finally {
         g1.shutdownGracefully().sync();
         g2.shutdownGracefully().sync();
     }
 }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）服务端ServerHandler&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.xm.netty.demo03;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerAdapter;
import io.netty.channel.ChannelHandlerContext;
import io.netty.util.CharsetUtil;

public class ServerHandler extends ChannelHandlerAdapter {

 @Override
 public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {

     String str = (String) msg;
     System.out.println(&quot;Server:&quot;+str);
     str = &quot;服务器返回---&amp;gt;&quot;+ str+&quot;$&quot;;
     ctx.writeAndFlush(Unpooled.copiedBuffer(str.getBytes()));
 }

 @Override
 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
     cause.printStackTrace();
     ctx.close();
 }

 @Override
 public void channelActive(ChannelHandlerContext ctx) throws Exception {
     System.out.println(DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now())+&quot;一个客户端连接上服务器！&quot;);
 }


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）客户端Client&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.xm.netty.demo03;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.DelimiterBasedFrameDecoder;
import io.netty.handler.codec.string.StringDecoder;

public class Client {

 private final int port;
 private final String host;



 public Client(int port, String host) {
     this.port = port;
     this.host = host;
 }

 public static void main(String[] args) {
     String host = &quot;127.0.0.1&quot;;
     int port = 8989;
     try {
         new Client(port, host).start();
     } catch (InterruptedException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
     }
 }

 private void start() throws InterruptedException {

     EventLoopGroup group = new NioEventLoopGroup();
     try {
         Bootstrap bootstrap = new Bootstrap();
         bootstrap
                 .group(group)
                 .channel(NioSocketChannel.class)
                 .remoteAddress(host, port)
                 .handler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {

                     @Override
                     protected void initChannel(SocketChannel ch) throws Exception {
                         ByteBuf buf = Unpooled.copiedBuffer(&quot;$&quot;.getBytes());
                         ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,buf));
                         ch.pipeline().addLast(new StringDecoder());
                         ch.pipeline().addLast(new ClientHandler());
                     }

                 });

         ChannelFuture future = bootstrap.connect().sync();

         for(int i=10;i&amp;lt;20;i++) {
             String str = DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now()) + &quot;---- &quot; +i+&quot;&amp;lt;&amp;lt;&amp;lt;$&quot;;
             future.channel().write(Unpooled.copiedBuffer(str.getBytes()));
         }

         future.channel().flush();


         //future.channel().writeAndFlush(Unpooled.copiedBuffer(&quot;Hello Netty!&quot;.getBytes()));



         future.channel().closeFuture().sync();
     } finally {
         group.shutdownGracefully().sync();
     }

 }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）客户端ClientHandler&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.xm.netty.demo03;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerAdapter;
import io.netty.channel.ChannelHandlerContext;
import io.netty.util.CharsetUtil;
import io.netty.util.ReferenceCountUtil;

public class ClientHandler extends ChannelHandlerAdapter {

 @Override
 public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {


     try {
         String str = (String) msg;
         System.out.println(&quot;Client:&quot;+str);

     } finally {
         ReferenceCountUtil.release(msg);
     }
 }

 @Override
 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
     cause.printStackTrace();
     ctx.close();
 }

 @Override
 public void channelActive(ChannelHandlerContext ctx) throws Exception {
     System.out.println(DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now())+&quot;已连接服务器！&quot;);
 }


}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;运行结果截图&lt;/p&gt;
&lt;p&gt;（1）服务端运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422573/201810/1422573-20181012211515714-1883431825.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）客户端运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422573/201810/1422573-20181012211529950-1890423686.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;fixedlengthframedecoder&quot;&gt;4.FixedLengthFrameDecoder&lt;/h2&gt;
&lt;ol readability=&quot;16&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;关于FixedLengthFrameDecoder&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;其实很简单，就是对规定的发送的数据进行限制长度，&lt;/p&gt;
&lt;p&gt;当符合这个长度的情况下，就可以解析。&lt;/p&gt;
&lt;p&gt;假设你发送一个’123456‘，’654321‘&lt;/p&gt;
&lt;p&gt;那么解析的状况为’12345‘，’66543‘&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;29&quot;&gt;
&lt;p&gt;代码实现&lt;/p&gt;
&lt;p&gt;（1）服务端Server&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.xm.netty.demo04;

import java.net.InetSocketAddress;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.codec.FixedLengthFrameDecoder;
import io.netty.handler.codec.string.StringDecoder;

public class Server {

 private final int port;

 public Server(int port) {
     this.port = port;
 }



 public static void main(String[] args) {

     int port = 8989;
     try {
         new Server(port).start();
     } catch (InterruptedException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
     }

 }



 private void start() throws InterruptedException {
     EventLoopGroup g1 = new NioEventLoopGroup();
     EventLoopGroup g2 = new NioEventLoopGroup();
     try {
         ServerBootstrap bootstrap = new ServerBootstrap();
          bootstrap
                 .group(g1,g2)
                 .channel(NioServerSocketChannel.class)
                 .localAddress(new InetSocketAddress( port))
                 .childHandler(new ChannelInitializer() {
                     @Override
                     protected void initChannel(Channel ch) throws Exception {
                         ch.pipeline().addLast(new FixedLengthFrameDecoder(5));
                         ch.pipeline().addLast(new StringDecoder());
                         ch.pipeline().addLast(new ServerHandler());
                     }
                 });
          ChannelFuture future = bootstrap.bind().sync();
          future.channel().closeFuture().sync();
     } finally {
         g1.shutdownGracefully().sync();
         g2.shutdownGracefully().sync();
     }
 }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）服务端ServerHandler&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.xm.netty.demo04;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerAdapter;
import io.netty.channel.ChannelHandlerContext;
import io.netty.util.CharsetUtil;

public class ServerHandler extends ChannelHandlerAdapter {

 @Override
 public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {

     String str = (String) msg;
     System.out.println(&quot;Server:&quot;+str);
     ctx.writeAndFlush(Unpooled.copiedBuffer(str.getBytes()));
 }

 @Override
 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
     cause.printStackTrace();
     ctx.close();
 }

 @Override
 public void channelActive(ChannelHandlerContext ctx) throws Exception {
     System.out.println(DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now())+&quot;一个客户端连接上服务器！&quot;);
 }


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）客户端Client&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.xm.netty.demo04;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.FixedLengthFrameDecoder;
import io.netty.handler.codec.string.StringDecoder;

public class Client {

 private final int port;
 private final String host;



 public Client(int port, String host) {
     this.port = port;
     this.host = host;
 }

 public static void main(String[] args) {
     String host = &quot;127.0.0.1&quot;;
     int port = 8989;
     try {
         new Client(port, host).start();
     } catch (InterruptedException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
     }
 }

 private void start() throws InterruptedException {

     EventLoopGroup group = new NioEventLoopGroup();
     try {
         Bootstrap bootstrap = new Bootstrap();
         bootstrap
                 .group(group)
                 .channel(NioSocketChannel.class)
                 .remoteAddress(host, port)
                 .handler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {

                     @Override
                     protected void initChannel(SocketChannel ch) throws Exception {
                         ch.pipeline().addLast(new FixedLengthFrameDecoder(5));
                         ch.pipeline().addLast(new StringDecoder());
                         ch.pipeline().addLast(new ClientHandler());
                     }

                 });

         ChannelFuture future = bootstrap.connect().sync();

         for(int i=123450;i&amp;lt;123460;i++) {
             String str = &quot;&quot;+i;
             future.channel().write(Unpooled.copiedBuffer(str.getBytes()));
         }
         future.channel().flush();

         //future.channel().writeAndFlush(Unpooled.copiedBuffer(&quot;Hello Netty!&quot;.getBytes()));



         future.channel().closeFuture().sync();
     } finally {
         group.shutdownGracefully().sync();
     }

 }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）客户端ClientHandler&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.xm.netty.demo04;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerAdapter;
import io.netty.channel.ChannelHandlerContext;
import io.netty.util.CharsetUtil;
import io.netty.util.ReferenceCountUtil;

public class ClientHandler extends ChannelHandlerAdapter {

 @Override
 public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {


     try {
         String str = (String) msg;
         System.out.println(&quot;Client:&quot;+str);

     } finally {
         ReferenceCountUtil.release(msg);
     }
 }

 @Override
 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
     cause.printStackTrace();
     ctx.close();
 }

 @Override
 public void channelActive(ChannelHandlerContext ctx) throws Exception {
     System.out.println(DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now())+&quot;已连接服务器！&quot;);
 }


}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;运行结果截图&lt;/p&gt;
&lt;p&gt;（1）服务端运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422573/201810/1422573-20181012211710250-259989958.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）客户端运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422573/201810/1422573-20181012211744527-1365042887.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 12 Oct 2018 13:19:00 +0000</pubDate>
<dc:creator>零度微笑</dc:creator>
<og:description>Netty提供的TCP数据拆包、粘包解决方案 1.前言 关于TCP的数据拆包、粘包的介绍，我在上一篇文章里面已经有过介绍。 想要了解一下的，请点击这里</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TimerHotel/p/netty03.html</dc:identifier>
</item>
<item>
<title>重构 -改变既有代码的设计 ---- 笔记 - 王守昌</title>
<link>http://www.cnblogs.com/wangshouchang/p/9780732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangshouchang/p/9780732.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;这是一篇《重构 》的总结 ，我在学习的同时并使用它作为参考。这不是一本书的替代品，所以你要想真的想学习里面的内容，买一本书使用这个文章作为参考和指南。&lt;/p&gt;
&lt;p&gt;另外： 建议 评论 还 PR 都是十分欢迎的&lt;/p&gt;


&lt;h3 id=&quot;duplicated-code-重复的代码&quot;&gt;1. Duplicated code （重复的代码）&lt;/h3&gt;
&lt;p&gt;多个地方使用相同的代码&lt;/p&gt;
&lt;h3 id=&quot;long-method很长的方法&quot;&gt;2. Long Method（很长的方法）&lt;/h3&gt;
&lt;p&gt;一个很长的程序是很难被理解的&lt;/p&gt;
&lt;h3 id=&quot;large-classes超级大的类&quot;&gt;3. Large Classes（超级大的类）&lt;/h3&gt;
&lt;p&gt;当一个类变的越来越大的时候，是难以阅读的&lt;/p&gt;
&lt;h3 id=&quot;long-parameter-list长参数列表&quot;&gt;4. Long Parameter List(长参数列表)&lt;/h3&gt;
&lt;p&gt;长参数是很难去理解，不符合也较难使用&lt;/p&gt;
&lt;h3 id=&quot;divergent-change发散的改变&quot;&gt;5. Divergent Change（发散的改变）&lt;/h3&gt;
&lt;p&gt;当一个类经常因为不同原因发生在不同的方向发生变化&lt;/p&gt;
&lt;h3 id=&quot;shotgun-surgery散弹枪修改&quot;&gt;6. Shotgun Surgery（散弹枪修改）&lt;/h3&gt;
&lt;p&gt;每次你做一小部分修改时，都不的不需要做大量的修改在很多不同的类中&lt;/p&gt;
&lt;h3 id=&quot;feature-envy依恋情结&quot;&gt;7. Feature Envy（依恋情结）&lt;/h3&gt;
&lt;p&gt;某个方法似乎在另外的类的兴趣高于自己所处的类&lt;/p&gt;
&lt;h3 id=&quot;data-clumps数据泥团&quot;&gt;8. Data Clumps（数据泥团）&lt;/h3&gt;
&lt;p&gt;一堆数据杂糅在一起（字段， 参数）&lt;/p&gt;
&lt;h3 id=&quot;primitive-obsession基本类型偏执&quot;&gt;9. Primitive Obsession（基本类型偏执）&lt;/h3&gt;
&lt;p&gt;使用基本类型替代小对象&lt;/p&gt;
&lt;h3 id=&quot;switch-statementsswitch-惊悚现身&quot;&gt;10. Switch Statements（Switch 惊悚现身）&lt;/h3&gt;
&lt;p&gt;当程序中出现很多 switch 语句在很多地方，使用多态来进行替换&lt;/p&gt;
&lt;h3 id=&quot;parallel-inheritance-hierarchies平行继承类&quot;&gt;11. Parallel Inheritance Hierarchies（平行继承类）&lt;/h3&gt;
&lt;p&gt;每当你为一个类增加一个子类，你不得不为另一个类增加相应的一个子类&lt;/p&gt;
&lt;h3 id=&quot;lazy-class冗余类&quot;&gt;12. Lazy Class（冗余类）&lt;/h3&gt;
&lt;p&gt;当一个类不足与为其自身买单它就应该被删除&lt;/p&gt;
&lt;h3 id=&quot;speculative-generality夸夸其谈未来性&quot;&gt;13. Speculative Generality（夸夸其谈未来性）&lt;/h3&gt;
&lt;p&gt;所有的钩子和特殊情况处理那些不需要的&lt;/p&gt;
&lt;h3 id=&quot;temporary-field令人迷惑的临时变量&quot;&gt;14. Temporary Field（令人迷惑的临时变量）&lt;/h3&gt;
&lt;p&gt;一个临时变量仅仅为某种特殊情况做而定，这样的代码让人难以理解&lt;/p&gt;
&lt;h3 id=&quot;message-chain过长的消息链&quot;&gt;15. Message Chain（过长的消息链）&lt;/h3&gt;
&lt;p&gt;当一个类请求调用一个对象，但是这个类又在调用其他的方法&lt;/p&gt;
&lt;h3 id=&quot;middle-man中间人&quot;&gt;16. Middle Man（中间人）&lt;/h3&gt;
&lt;p&gt;当一个对象委托大部分功能，开发中可能会过度的使用委托模式，导致某个类中的方法大都委托给其他方法处理&lt;/p&gt;
&lt;h3 id=&quot;inappropriate-intimacy不恰当的亲密关系&quot;&gt;17. Inappropriate Intimacy（不恰当的亲密关系）&lt;/h3&gt;
&lt;p&gt;当两个类过度的亲密，需要将其拆散&lt;/p&gt;
&lt;h3 id=&quot;alternative-classes-with-different-interfaces异曲同工的类&quot;&gt;18. Alternative Classes with Different Interfaces（异曲同工的类）&lt;/h3&gt;
&lt;p&gt;类的方法过度相似&lt;/p&gt;
&lt;h3 id=&quot;incomplete-library-class不完美的库&quot;&gt;19. Incomplete Library Class（不完美的库）&lt;/h3&gt;
&lt;p&gt;当我们使用外部依赖库时&lt;/p&gt;
&lt;h3 id=&quot;data-class数据类&quot;&gt;20. Data Class（数据类）&lt;/h3&gt;
&lt;p&gt;不要操作数据类，我们通过封装它的不变性&lt;/p&gt;
&lt;h3 id=&quot;refused-bequest被拒绝的遗赠&quot;&gt;21. Refused Bequest（被拒绝的遗赠）&lt;/h3&gt;
&lt;p&gt;子类不想使用父类的方法&lt;/p&gt;

&lt;p&gt;当一个方法使用过度的注释解释其中的逻辑时，说明这个方法应该被重构了。&lt;/p&gt;


&lt;p&gt;你可以将一些代码组合起来，然后放到一个方法中&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    void printOwing(double amount) {
        printBanner();
        //print details
        System.out.println (&quot;name:&quot; + _name);
        System.out.println (&quot;amount&quot; + amount);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    void printOwing(double amount) {
        printBanner();
        printDetails(amount);
    }

    void printDetails (double amount) {
        System.out.println (&quot;name:&quot; + _name);
    System.out.println (&quot;amount&quot; + amount);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;增加代码被复用的机会&lt;br/&gt;* 阅读方法就像阅读一系列声明一样简单&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    void printOwing(double previousAmount) {
        Enumeration e = _orders.elements();
        double outstanding = previousAmount * 1.2;
        printBanner();

        // calculate outstanding
        while (e.hasMoreElements()) {
            Order each = (Order) e.nextElement();
            outstanding += each.getAmount();
        }
        printDetails(outstanding);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    void printOwing(double previousAmount) {
        printBanner();
        double outstanding = getOutstanding(previousAmount * 1.2);
        printDetails(outstanding);
    }

    double getOutstanding(double initialValue) {
        double result = initialValue;
        Enumeration e = _orders.elements();

        while (e.hasMoreElements()) {
            Order each = (Order) e.nextElement();
            result += each.getAmount();
        }
        return result;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;inline-method-内联函数&quot;&gt;2. Inline Method （内联函数）&lt;/h2&gt;
&lt;p&gt;一个函数本体和函数名称一样容易理解&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    int getRating() {
        return (moreThanFiveLateDeliveries()) ? 2 : 1;
    }

    boolean moreThanFiveLateDeliveries() {
        return _numberOfLateDeliveries &amp;gt; 5;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    int getRating() {
        return (_numberOfLateDeliveries &amp;gt; 5) ? 2 : 1;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当间接不是必要的时候&lt;/li&gt;
&lt;li&gt;当一组方法被严格的分解，会使这个方法变得清晰&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;inline-temp-内联临时变量&quot;&gt;3. Inline Temp （内联临时变量）&lt;/h2&gt;
&lt;p&gt;你申明了一个临时的变量在一段表达里面，然后临时的变量将会阻挡你重构&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    double basePrice = anOrder.basePrice();
    return (basePrice &amp;gt; 1000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    return (anOrder.basePrice() &amp;gt; 1000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Motivation&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;replace-temp-with-query-以查询取代临时变量&quot;&gt;4. Replace Temp with Query （以查询取代临时变量）&lt;/h2&gt;
&lt;p&gt;你正在使用临时变量来保存表达式的结果&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    double basePrice = _quantity * _itemPrice;
    if (basePrice &amp;gt; 1000){
        return basePrice * 0.95;
    }
    else{
        return basePrice * 0.98;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    if (basePrice() &amp;gt; 1000){
        return basePrice() * 0.95;
    }
    else{
        return basePrice() * 0.98;
    }
    ...
    double basePrice() {
        return _quantity * _itemPrice;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用方法代替临时变量，类中的任何方法都可以获取信息&lt;/li&gt;
&lt;li&gt;这是一个十分重要的步骤在其之前&lt;a href=&quot;http://www.cnblogs.com/wangshouchang/p/9780732.html#1-extract-method&quot;&gt;1. Extract Method&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;introduce-explaining-variable-引入解释性变量&quot;&gt;5. Introduce Explaining Variable （引入解释性变量）&lt;/h2&gt;
&lt;p&gt;有一个复杂的表达式&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    if ( (platform.toUpperCase().indexOf(&quot;MAC&quot;) &amp;gt; -1) &amp;amp;&amp;amp;
        (browser.toUpperCase().indexOf(&quot;IE&quot;) &amp;gt; -1) &amp;amp;&amp;amp;
        wasInitialized() &amp;amp;&amp;amp; resize &amp;gt; 0 )
    {
        // do something
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    final boolean isMacOs = platform.toUpperCase().indexOf(&quot;MAC&quot;) &amp;gt;-1;
    final boolean isIEBrowser = browser.toUpperCase().indexOf(&quot;IE&quot;) &amp;gt;-1;
    final boolean wasResized = resize &amp;gt; 0;
    if (isMacOs &amp;amp;&amp;amp; isIEBrowser &amp;amp;&amp;amp; wasInitialized() &amp;amp;&amp;amp; wasResized) {
        // do something
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当一个表达式难以理解时&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;split-temporary-variable-分解临时变量&quot;&gt;6. Split Temporary Variable （分解临时变量）&lt;/h2&gt;
&lt;p&gt;你能有一个临时变量声明不止一次，但是它不是循环体中的变量或者要被存储的变量&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    double temp = 2 * (_height + _width);
    System.out.println (temp);
    temp = _height * _width;
    System.out.println (temp);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    final double perimeter = 2 * (_height + _width);
    System.out.println (perimeter);
    final double area = _height * _width;
    System.out.println (area);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量不应该有多次的声明&lt;/li&gt;
&lt;li&gt;使用临时变量在两次不同的地方，是阅读者十分迷惑的&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;remove-assignments-to-parameters移除对参数的赋值&quot;&gt;7. Remove Assignments to Parameters（移除对参数的赋值）&lt;/h2&gt;
&lt;p&gt;下的代码将对参数进行了赋值&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    int discount (int inputVal, int quantity, int yearToDate) {
        if (inputVal &amp;gt; 50) {
            inputVal -= 2;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    int discount (int inputVal, int quantity, int yearToDate) {
        int result = inputVal;
        if (inputVal &amp;gt; 50) {
            result -= 2;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;改变内部的对象时可以的，但是不能将这个对象指向别的对象&lt;/li&gt;
&lt;li&gt;参数的作用仅仅是表达传递对象&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;replace-method-with-method-object-以函数对象取代函数&quot;&gt;8. Replace Method with Method Object （以函数对象取代函数）&lt;/h2&gt;
&lt;p&gt;将这个函数放进一个单独的对象，如此一来局部变量就变成对象内部的字段，然后你可以在同一个对象中将这个大型函数分解为多个小型函数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Order...
        double price() {
            double primaryBasePrice;
            double secondaryBasePrice;
            double tertiaryBasePrice;
            // long computation;
            ...
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Order...
        double price(){
            return new PriceCalculator(this).compute()
        }
    }

    class PriceCalculato...
    compute(){
        double primaryBasePrice;
        double secondaryBasePrice;
        double tertiaryBasePrice;
        // long computation;
        return ...
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当一个方法有很多的本地变量时进行分解时不容易的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;它的样本本不应该这样的重构，但是为显示这样做的方法&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    Class Account
        int gamma (int inputVal, int quantity, int yearToDate) {
            int importantValue1 = (inputVal * quantity) + delta();
            int importantValue2 = (inputVal * yearToDate) + 100;
            if ((yearToDate - importantValue1) &amp;gt; 100)
            importantValue2 -= 20;
            int importantValue3 = importantValue2 * 7;
            // and so on.
            return importantValue3 - 2 * importantValue1;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Gamma...
        private final Account _account;
        private int inputVal;
        private int quantity;
        private int yearToDate;
        private int importantValue1;
        private int importantValue2;
        private int importantValue3;

        Gamma (Account source, int inputValArg, int quantityArg, int yearToDateArg) {
            _account = source;
            inputVal = inputValArg;
            quantity = quantityArg;
            yearToDate = yearToDateArg;
        }

        int compute () {
            importantValue1 = (inputVal * quantity) + _account.delta();
            importantValue2 = (inputVal * yearToDate) + 100;
            if ((yearToDate - importantValue1) &amp;gt; 100)
            importantValue2 -= 20;
            int importantValue3 = importantValue2 * 7;
            // and so on.
            return importantValue3 - 2 * importantValue1;
        }

        int gamma (int inputVal, int quantity, int yearToDate) {
            return new Gamma(this, inputVal, quantity,yearToDate).compute();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;substitute-algorithm-算法替换&quot;&gt;9. Substitute Algorithm (算法替换)&lt;/h2&gt;
&lt;p&gt;你想更换一个更为清晰高效的算法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    String foundPerson(String[] people){
        for (int i = 0; i &amp;lt; people.length; i++) {
            if (people[i].equals (&quot;Don&quot;)){
                return &quot;Don&quot;;
            }
            if (people[i].equals (&quot;John&quot;)){
                return &quot;John&quot;;
            }
            if (people[i].equals (&quot;Kent&quot;)){
                return &quot;Kent&quot;;
            }
        }
        return &quot;&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    String foundPerson(String[] people){
        List candidates = Arrays.asList(new String[] {&quot;Don&quot;, &quot;John&quot;,&quot;Kent&quot;});
    for (int i = 0; i&amp;lt;people.length; i++)
        if (candidates.contains(people[i]))
            return people[i];
    return &quot;&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打破一些复杂的概念&lt;/li&gt;
&lt;li&gt;使算法更容易修改&lt;/li&gt;
&lt;li&gt;替换一个大的复杂的算法是十分困难的，让算法变的简单更容易对算法进行替换&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;move-method-移动方法&quot;&gt;10. Move method （移动方法）&lt;/h2&gt;
&lt;p&gt;在进行方法的初始定义的时候要想下以后会不会有其他的类也将会用到它&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一个类它通常会创建一个新的简单的方法体， 同时它会将9⃣旧的方法做一个简单的委托或者移除它&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Class1 {
        aMethod()
    }

    class Class2 {  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Class1 {  }

    class Class2 {
        aMethod()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个类做了很多工作，或者这个类过度的耦合&lt;/p&gt;
&lt;h2 id=&quot;move-field-移动字段&quot;&gt;11. Move field （移动字段）&lt;/h2&gt;
&lt;p&gt;当一个字段被定义的时候，可能不仅被不止一个类使用。&lt;br/&gt;&lt;em&gt;创建一个字段在一个目标类中，然后改变所有的拥有者&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Class1 {
        aField
    }

    class Class2 {  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Class1 {  }

    class Class2 {
        aField
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个字段被超过多个类引用&lt;/p&gt;

&lt;p&gt;你有一个类，但是这个类做了它份外的事情&lt;/p&gt;
&lt;p&gt;&lt;em&gt;创建一个新的类，然后将相关字段移入到新的类中&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Person {
        name,
        officeAreaCode,
        officeNumber,
        getTelephoneNumber()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Person {
        name,
        getTelephoneNumber()
    }

    class TelephoneNumber {
        areaCode,
        number,
        getTelephoneNumber()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类随着业务的增长在变化&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在合适的时候进行分解它&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;相似的方法组合在一起&lt;/li&gt;
&lt;li&gt;数据子集通常一起变化或者相互依赖&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;inline-class-一致的类&quot;&gt;13. Inline Class （一致的类）&lt;/h2&gt;
&lt;p&gt;一个其实没做多少事情的类&lt;/p&gt;
&lt;p&gt;&lt;em&gt;将这个类整合到另外一个类中，然后删除这个类&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Person {
        name,
        getTelephoneNumber()
    }

    class TelephoneNumber {
        areaCode,
        number,
        getTelephoneNumber()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Person {
        name,
        officeAreaCode,
        officeNumber,
        getTelephoneNumber()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在重构的时候将这个类的基本信息移入到另外一个类中，然后在移除这个类&lt;/p&gt;
&lt;h2 id=&quot;hide-delegate-隐藏委托&quot;&gt;14. Hide Delegate （隐藏委托）&lt;/h2&gt;
&lt;p&gt;客户端其实调用的是对象的委托类&lt;br/&gt;&lt;em&gt;在服务端创建一个方法，然后隐藏这个委托类&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class ClientClass {
        //Dependencies
        Person person = new Person()
        Department department = new Department()
        person.doSomething()
        department.doSomething()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class ClientClass {
        Person person = new Person()
        person.doSomething()
    }

    class Person{
        Department department = new Department()
        department.doSomething()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;解决方法&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class ClientClass{
        Server server = new Server()
        server.doSomething()
    }

    class Server{
        Delegate delegate = new Delegate()
        void doSomething(){
            delegate.doSomething()
        }
    }
    //委托类其实隐藏在客户类里面
    // 改变不会传播到客户端那边，因为它之后影响到服务端这边
    class Delegate{
        void doSomething(){...}
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;关键在于封装&lt;/em&gt;&lt;br/&gt;&lt;em&gt;类应该尽量的使用其他的类&lt;/em&gt;&lt;br/&gt;&lt;code&gt;&amp;gt; manager = john.getDepartment().getManager();&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;


    class Person {
        Department _department;
        public Department getDepartment() {
            return _department;
        }
        public void setDepartment(Department arg) {
            _department = arg;
            }
        }

    class Department {
        private String _chargeCode;
        private Person _manager;
        public Department (Person manager) {
            _manager = manager;
        }
        public Person getManager() {
            return _manager;
        }
        ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt; manager = john.getManager();&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Person {
        ...
        public Person getManager() {
            return _department.getManager();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;remove-middle-man-移除中间人&quot;&gt;15. Remove Middle Man （移除中间人）&lt;/h2&gt;
&lt;p&gt;一个类通过代理干了太多的事情&lt;br/&gt;&lt;em&gt;让客户直接调用委托&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class ClientClass {
        Person person = new Person()
        person.doSomething()
    }

    class Person{
        Department department = new Department()
        department.doSomething()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class ClientClass {
        //Dependencies
        Person person = new Person()
        Department department = new Department()
        person.doSomething()
        department.doSomething()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当客户类使用过多的中间人调用委托的方法&lt;/p&gt;
&lt;h2 id=&quot;introduce-foreign-method-引入外加的函数&quot;&gt;16. Introduce Foreign Method （引入外加的函数）&lt;/h2&gt;
&lt;p&gt;一个类是引用的外部开源包，但是不能修改其内部的逻辑&lt;br/&gt;&lt;em&gt;创建一个新的方法在这个类中，并以第一个参数的形式传入一个服务类实例&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    Date newStart = new Date(previousEnd.getYear(),previousEnd.getMonth(),previousEnd.getDate()+1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    Date newStart = nextDay(previousEnd);

    private static Date nextDay(Date date){
        return new Date(date.getYear(),date.getMonth(),date.getDate()+1);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你使用一个类，这个类你又不能对其进行修改的时候可以采用这样方式&lt;/p&gt;
&lt;h2 id=&quot;introduce-local-extension-引入本地扩展&quot;&gt;17. Introduce Local Extension （引入本地扩展）&lt;/h2&gt;
&lt;p&gt;你需要为一个服务类提供一些额外的方法，但是你无法修改这个子类&lt;br/&gt;&lt;em&gt;创建一个新的类，使它包含这些额外的方法。这个扩展的类成为源类的子类或者包装类&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class ClientClass(){

        Date date = new Date()
        nextDate = nextDay(date);

        private static Date nextDay(Date date){
            return new Date(date.getYear(),date.getMonth(),date.getDate()+1);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class ClientClass() {
        MfDate date = new MfDate()
        nextDate = nextDate(date)
    }
    class MfDate() extends Date {
        ...
        private static Date nextDay(Date date){
            return new Date(date.getYear(),date.getMonth(),date.getDate()+1);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们使用 &lt;a href=&quot;http://www.cnblogs.com/wangshouchang/p/9780732.html#16-introduce-foreign-method&quot;&gt;16. Introduce Foreign Method&lt;/a&gt; 我们需要在这个类中添加额外的方法&lt;/p&gt;

&lt;h2 id=&quot;self-encapsulate-field-对字段获取进行封装&quot;&gt;18. Self Encapsulate Field （对字段获取进行封装）&lt;/h2&gt;
&lt;p&gt;你可以直接获取对象，但是这样的话会变得越来越复杂&lt;br/&gt;&lt;em&gt;通过创建setting getting 方法来获取这些字段&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    private int _low, _high;
    boolean includes (int arg) {
        return arg &amp;gt;= _low &amp;amp;&amp;amp; arg &amp;lt;= _high;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    private int _low, _high;
    boolean includes (int arg) {
        return arg &amp;gt;= getLow() &amp;amp;&amp;amp; arg &amp;lt;= getHigh();
    }
    int getLow() {return _low;}
    int getHigh() {return _high;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;允许子类可以覆盖如何get方法，并且这样的话它更加的支持灵活的管理，例如延迟加载&lt;/p&gt;
&lt;h2 id=&quot;replace-data-value-with-object-用对象替换数据值&quot;&gt;19. Replace Data Value with Object （用对象替换数据值）&lt;/h2&gt;
&lt;p&gt;当你有个数据项需要进行添加数据或行为&lt;br/&gt;&lt;em&gt;将数据项转换为对象&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Order...{
        private String _customer;
        public Order (String customer) {
            _customer = customer;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Order...{
        public Order (String customer) {
            _customer = new Customer(customer);
        }
    }

    class Customer {
        public Customer (String name) {
            _name = name;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;简单的数据对象并不简单&lt;/p&gt;
&lt;h2 id=&quot;change-value-to-reference-将值改为引用&quot;&gt;20. Change Value to Reference （将值改为引用）&lt;/h2&gt;
&lt;p&gt;你有个类拥有很多单个对象，这些对象需要用一个单独的对象替代&lt;br/&gt;&lt;em&gt;将这个对象转换为引用对象&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Order...{
        public Order (String customer) {
            _customer = new Customer(customer);
        }
    }

    class Customer {
        public Customer (String name) {
            _name = name;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    //Use Factory Method
    //使用工厂方法
    class Customer...
        static void loadCustomers() {
            new Customer (&quot;Lemon Car Hire&quot;).store();
            new Customer (&quot;Associated Coffee Machines&quot;).store();
            new Customer (&quot;Bilston Gasworks&quot;).store();
        }
        private void store() {
            _instances.put(this.getName(), this);
        }
        public static Customer create (String name) {
            return (Customer) _instances.get(name);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;引用对象是类似于消费者或者账单这样的对象，每个对象代表这一类对象在一个真实的世界，并使用对象表示来测试它们是否相同&lt;/p&gt;
&lt;h2 id=&quot;change-reference-to-value-将引用改为值&quot;&gt;21. Change Reference to Value （将引用改为值）&lt;/h2&gt;
&lt;p&gt;你有一个有一个引用对象是很小，不变，难以管理的&lt;br/&gt;&lt;em&gt;将其转换为值对象&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    new Currency(&quot;USD&quot;).equals(new Currency(&quot;USD&quot;)) // returns false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    new Currency(&quot;USD&quot;).equals(new Currency(&quot;USD&quot;)) // now returns true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;使用引用对象是变得越来月复杂，并且引用对象是不变和单一的。尤其在分布式和并发系统中&lt;/p&gt;
&lt;h2 id=&quot;replace-array-with-object-用对象代替数组&quot;&gt;22. Replace Array with Object （用对象代替数组）&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;你拥有一个数组，其中这些元素是不同的&lt;/em&gt;&lt;br/&gt;&lt;em&gt;使用一个对象来替换这个数组，将数组的元素赋值在对象的属性上&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    String[] row = new String[3];
    row [0] = &quot;Liverpool&quot;;
    row [1] = &quot;15&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    Performance row = new Performance();
    row.setName(&quot;Liverpool&quot;);
    row.setWins(&quot;15&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组应该被用在一些相似的集合对象序列中&lt;/p&gt;
&lt;h2 id=&quot;duplicate-observed-data-监控数据对象&quot;&gt;23. Duplicate Observed Data （监控数据对象）&lt;/h2&gt;
&lt;p&gt;可能你有一些domain数据是通过GUI控制的与此同时这些domain数据是需要访问的&lt;br/&gt;&lt;em&gt;往一些实体对象复制一些数据，通过设置观察者来同步两部分数据&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;为了将代码从用户界面分解到业务处理层&lt;/p&gt;
&lt;h2 id=&quot;change-unidirectional-association-to-bidirectional将单向联系改为双向联系&quot;&gt;24. Change Unidirectional Association to Bidirectional（将单向联系改为双向联系）&lt;/h2&gt;
&lt;p&gt;你有两个对象，这两个对象需要使用对方的特征属性，但是目前只有一种连接方式&lt;br/&gt;&lt;em&gt;添加返回指针，然后更改修饰符已更改两个对象&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Order...
        Customer getCustomer() {
            return _customer;
        }
        void setCustomer (Customer arg) {
            _customer = arg;
        }
        Customer _customer;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Order...
        Customer getCustomer() {
            return _customer;
        }
        void setCustomer (Customer arg) {
            if (_customer != null) _customer.friendOrders().remove(this);
            _customer = arg;
            if (_customer != null) _customer.friendOrders().add(this);
        }
        private Customer _customer;

        class Customer...
            void addOrder(Order arg) {
                arg.setCustomer(this);
            }
            private Set _orders = new HashSet();

            Set friendOrders() {
                /** should only be used by Order */
                return _orders;
            }
        }
    }

    // Many to Many
    class Order... //controlling methods
        void addCustomer (Customer arg) {
            arg.friendOrders().add(this);
            _customers.add(arg);
        }
        void removeCustomer (Customer arg) {
            arg.friendOrders().remove(this);
            _customers.remove(arg);
        }
    class Customer...
        void addOrder(Order arg) {
            arg.addCustomer(this);
        }
        void removeOrder(Order arg) {
            arg.removeCustomer(this);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;当对象引用需要互相引用的时候，你应该采用这种方法&lt;/p&gt;
&lt;h2 id=&quot;change-bidirectional-association-to-unidirectional-将单向改为双向的联系&quot;&gt;25. Change Bidirectional Association to Unidirectional （将单向改为双向的联系）&lt;/h2&gt;
&lt;p&gt;当你有个双向联系的类，但是在后期一个类不在需要另一个类中的属性了&lt;br/&gt;&lt;em&gt;扔掉不需要的联系&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;当双向联系不在需要，减少复杂度，移除僵尸对象，消除相互依赖&lt;/p&gt;
&lt;h2 id=&quot;replace-magic-number-with-symbolic-constant-使用符号来替代魔法字符串&quot;&gt;26. Replace Magic Number with Symbolic Constant （使用符号来替代魔法字符串）&lt;/h2&gt;
&lt;p&gt;你有一个特定含义的字符串&lt;/p&gt;
&lt;p&gt;&lt;em&gt;创建一个常量，名称根据它的意思命名然后替换那个数字&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    double potentialEnergy(double mass, double height) {
        return mass * 9.81 * height;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    double potentialEnergy(double mass, double height) {
        return mass * GRAVITATIONAL_CONSTANT * height;
    }
    static final double GRAVITATIONAL_CONSTANT = 9.81;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;避免使用魔法数字&lt;/p&gt;
&lt;h2 id=&quot;encapsulate-field-封装字段&quot;&gt;27. Encapsulate Field （封装字段）&lt;/h2&gt;
&lt;p&gt;这里有一个公共的字段&lt;br/&gt;&lt;em&gt;将它改为私有的并提供访问函数&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    public String _name&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    private String _name;
    public String getName() {
        return _name;
    }
    public void setName(String arg) {
        _name = arg;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;你应该将你数据公开&lt;/p&gt;
&lt;h2 id=&quot;encapsulate-collection-封装集合&quot;&gt;28. Encapsulate Collection （封装集合）&lt;/h2&gt;
&lt;p&gt;一个返回几个的方法&lt;br/&gt;&lt;em&gt;确保返回一个只读的影像对象，然后提供添加和移除方法&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Person {
        Person (String name){
            HashSet set new HashSet()
        }
        Set getCourses(){}
        void setCourses(:Set){}
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Person {
        Person (String name){
            HashSet set new HashSet()
        }
        Unmodifiable Set getCourses(){}
        void addCourses(:Course){}
        void removeCourses(:Course){}
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;封装减少了拥有类和和其客户端的耦合&lt;/li&gt;
&lt;li&gt;getter 方法不应该返回集合的本身&lt;/li&gt;
&lt;li&gt;getter方法应返回对集合进行操作的内容并隐藏其中不必要的细节&lt;/li&gt;
&lt;li&gt;这个几个不应该有setter方法，只能添加和移除操作&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;remove-record-with-data-class-在数据类中移除-记录值&quot;&gt;29. Remove Record with data class (在数据类中移除 记录值)&lt;/h2&gt;
&lt;p&gt;你必须面对一个记录值在传统的编程环境中&lt;br/&gt;&lt;em&gt;使用一个僵尸数据对象代替记录值&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;复制一个传奇代码&lt;/li&gt;
&lt;li&gt;使用传统的API编程和数据库来代替一个记录值&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;replace-type-code-with-class-使用类来替代类别代码&quot;&gt;30. Replace Type Code with Class (使用类来替代类别代码)&lt;/h2&gt;
&lt;p&gt;一个类拥有数字类别码，不能影响其行为&lt;br/&gt;&lt;em&gt;使用类来代替数字&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Person{
        O:Int;
        A:Int;
        B:Int;
        AB:Int;
        bloodGroup:Int;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Person{
        bloodGroup:BloodGroup;
    }

    class BloodGroup{
        O:BloodGroup;
        A:BloodGroup;
        B:BloodGroup; 
        AB:BloodGroup;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;静态类别检查&lt;/p&gt;
&lt;h2 id=&quot;replace-type-code-with-subclasses-使用子类来替代类别代码&quot;&gt;31. Replace Type Code with Subclasses （使用子类来替代类别代码）&lt;/h2&gt;
&lt;p&gt;在一个类中拥有一个不变的类型码影响整个类的行为&lt;br/&gt;&lt;em&gt;使用子类来替代这个不变的类型码&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee...
        private int _type;

        static final int ENGINEER = 0;
        static final int SALESMAN = 1;
        static final int MANAGER = 2;

        Employee (int type) {
            _type = type;
        }
    } &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    abstract int getType();
    static Employee create(int type) {
        switch (type) {
            case ENGINEER:
                return new Engineer();
            case SALESMAN:
                return new Salesman();
            case MANAGER:
                return new Manager();
            default:
                throw new IllegalArgumentException(&quot;Incorrect type code value&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行不同的代码逻辑取决于这个type的值&lt;/li&gt;
&lt;li&gt;当每个type对象有着唯一的特征&lt;/li&gt;
&lt;li&gt;应用于架构体&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;replace-type-code-with-statestrategy通过状态模式或者策略模式来代替类型码&quot;&gt;32. Replace Type Code with State/Strategy（通过状态模式或者策略模式来代替类型码）&lt;/h2&gt;
&lt;p&gt;在类中有个类型码，并通过这个类型码来影响行为，但是你不能使用子类&lt;br/&gt;&lt;em&gt;通过状态对象来代替这个类型码&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee {
        private int _type;

        static final int ENGINEER = 0;
        static final int SALESMAN = 1;
        static final int MANAGER = 2;

        Employee (int type) {
            _type = type;
        }
        int payAmount() {
            switch (_type) {
                case ENGINEER:
                    return _monthlySalary;
                case SALESMAN:
                    return _monthlySalary + _commission;
                case MANAGER:
                    return _monthlySalary + _bonus;
                default:
                    throw new RuntimeException(&quot;Incorrect Employee&quot;);
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee...
        static final int ENGINEER = 0;
        static final int SALESMAN = 1;
        static final int MANAGER = 2;

        void setType(int arg) {
            _type = EmployeeType.newType(arg);
        }
        class EmployeeType...
            static EmployeeType newType(int code) {
                switch (code) {
                    case ENGINEER:
                        return new Engineer();
                    case SALESMAN:
                        return new Salesman();
                    case MANAGER:
                        return new Manager();
                    default:
                        throw new IllegalArgumentException(&quot;Incorrect Employee Code&quot;);
                }
            }
        }
        int payAmount() {
            switch (getType()) {
                case EmployeeType.ENGINEER:
                    return _monthlySalary;
                case EmployeeType.SALESMAN:
                    return _monthlySalary + _commission;
                case EmployeeType.MANAGER:
                    return _monthlySalary + _bonus;
                default:
                    throw new RuntimeException(&quot;Incorrect Employee&quot;);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;和&lt;a href=&quot;http://www.cnblogs.com/wangshouchang/p/9780732.html#31-replace-type-code-with-subclasses&quot;&gt;31. Replace Type Code with Subclasses&lt;/a&gt; 是相似的，但是它可以使用在类型码发生了改变在对象的生命周期发生了变化或者另一个原因阻止了子类的变化，则可以使用它&lt;/li&gt;
&lt;li&gt;它通常是和状态模式或者策略模式配合使用&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;replace-subclass-with-fields用字段代替子类&quot;&gt;32. Replace Subclass with Fields（用字段代替子类）&lt;/h2&gt;
&lt;p&gt;你的子类仅在返回常数变量数据变量的方法中有所不同&lt;br/&gt;&lt;em&gt;将这个方法提升到父类中，并移除这个子类&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    abstract class Person {
        abstract boolean isMale();
        abstract char getCode();
        ...
    }
    class Male extends Person {
            boolean isMale() {
            return true;
        }
        char getCode() {
            return 'M';
        }
    }
    class Female extends Person {
        boolean isMale() {
            return false;
        }
        char getCode() {
            return 'F';
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Person{
        protected Person (boolean isMale, char code) {
            _isMale = isMale;
            _code = code;
        }
        boolean isMale() {
            return _isMale;
        }
        static Person createMale(){
            return new Person(true, 'M');
        }
        static Person createFemale(){
            return new Person(false, 'F');
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当子类的某个方法不足与继续存在&lt;/li&gt;
&lt;li&gt;将这个子类彻底删除，并将这个字段上移到父类中&lt;/li&gt;
&lt;li&gt;删除额外的子类&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;decompose-conditional-分解条件&quot;&gt;33. Decompose Conditional （分解条件）&lt;/h2&gt;
&lt;p&gt;你有一个复杂的条件（大量的if else then ）&lt;br/&gt;&lt;em&gt;使用额外的方法代替这个表达式，将then 放在一部分，else 放在一部分&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    if (date.before (SUMMER_START) || date.after(SUMMER_END))
        charge = quantity * _winterRate + _winterServiceCharge;
    else 
        charge = quantity * _summerRate;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    if (notSummer(date))
        charge = winterCharge(quantity);
    else 
        charge = summerCharge (quantity);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将条件表达式高亮，这样的话你能清楚将其分开&lt;/li&gt;
&lt;li&gt;对分叉之后的结果进行高亮&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;consolidate-conditional-expression&quot;&gt;34. Consolidate Conditional Expression&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    double disabilityAmount() {
    if (_seniority &amp;lt; 2) return 0;
    if (_monthsDisabled &amp;gt; 12) return 0;
    if (_isPartTime) return 0;
    // compute the disability amount&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    double disabilityAmount() {
    if (isNotEligableForDisability()) return 0;
    // compute the disability amount&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;consolidate-duplicate-conditional-fragments-合并重复的条件片段&quot;&gt;35. Consolidate Duplicate Conditional Fragments （合并重复的条件片段）&lt;/h2&gt;
&lt;p&gt;在条件表达式的每个分支上有着相同的一片代码&lt;br/&gt;&lt;em&gt;将这段重复代搬移到条件表达式之外&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    if (isSpecialDeal()) {
        total = price * 0.95;
        send();
    }
    else {
        total = price * 0.98;
        send();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    if (isSpecialDeal()) {
        total = price * 0.95;
    }
    else {
        total = price * 0.98;
    }
    send();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;使得变量清晰并保持相同&lt;/p&gt;
&lt;h2 id=&quot;remove-control-flag-移除控制标记&quot;&gt;36. Remove Control Flag （移除控制标记）&lt;/h2&gt;
&lt;p&gt;在一系列的布尔表达式中，某个变量带有“控制标记”的作用&lt;br/&gt;&lt;em&gt;已break或者return语句取代控制标记&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    void checkSecurity(String[] people) {
        boolean found = false;
            for (int i = 0; i &amp;lt; people.length; i++) {
                if (! found) {
                    if (people[i].equals (&quot;Don&quot;)){
                        sendAlert();
                        found = true;
                    }
                    if (people[i].equals (&quot;John&quot;)){
                        sendAlert();
                        found = true;
                    }
                }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    void checkSecurity(String[] people) {
        for (int i = 0; i &amp;lt; people.length; i++) {
            if (people[i].equals (&quot;Don&quot;)){
                sendAlert();
                break; // or return
            }
            if (people[i].equals (&quot;John&quot;)){
                sendAlert();
                break; // or return
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;控制标记的作用是在于决定是否继续下面流程，但是现代语言注重于使用&lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;确保真实的条件表达式是清晰的&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;replace-nested-conditional-with-guard-clauses-以卫语句取代嵌套的条件表达式&quot;&gt;37. Replace Nested Conditional with Guard Clauses （以卫语句取代嵌套的条件表达式）&lt;/h2&gt;
&lt;p&gt;函数的条件逻辑使人难以看清正常的执行路径&lt;br/&gt;&lt;em&gt;使用卫语句表现所有的特殊情况&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    double getPayAmount() {
        double result;
        if (_isDead) result = deadAmount();
        else {
            if (_isSeparated) result = separatedAmount();
            else {
                if (_isRetired) result = retiredAmount();
                else result = normalPayAmount();
            };
        }
        return result;
    };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    double getPayAmount() {
        if (_isDead) return deadAmount();
        if (_isSeparated) return separatedAmount();
        if (_isRetired) return retiredAmount();
        return normalPayAmount();
    };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果这个条件是非同寻常的条件，检查这条件是否符合然后返回true&lt;/li&gt;
&lt;li&gt;这样大度的检查被称为“卫语句”&lt;/li&gt;
&lt;li&gt;对某一条分支已特别的重，如果使用if-then-else 结构，你对if分支和else分支的重要性是同等的&lt;/li&gt;
&lt;li&gt;各个分支具有同一样的重要性&lt;/li&gt;
&lt;li&gt;取代之前的观念 “每个函数只能有一个入口和一个出口”&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;replace-conditional-with-polymorphism-以多态取代条件表达式&quot;&gt;38. Replace Conditional with Polymorphism （以多态取代条件表达式）&lt;/h2&gt;
&lt;p&gt;你手上有一个条件表达式，它根据对象的类型的不同选择不同的行为&lt;br/&gt;&lt;em&gt;将条件表达式的所有分支放进一个子类内的覆盖函数中，然后将原始函数声明为抽象函数&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee {
        private int _type;

        static final int ENGINEER = 0;
        static final int SALESMAN = 1;
        static final int MANAGER = 2;

        Employee (int type) {
            _type = type;
        }
        int payAmount() {
            switch (_type) {
                case ENGINEER:
                    return _monthlySalary;
                case SALESMAN:
                    return _monthlySalary + _commission;
                case MANAGER:
                    return _monthlySalary + _bonus;
                default:
                    throw new RuntimeException(&quot;Incorrect Employee&quot;);
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee...
        static final int ENGINEER = 0;
        static final int SALESMAN = 1;
        static final int MANAGER = 2;

        void setType(int arg) {
            _type = EmployeeType.newType(arg);
        }
        int payAmount() {
            return _type.payAmount(this);
        }
    }

    class Engineer...
        int payAmount(Employee emp) {
            return emp.getMonthlySalary();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果对象的行为因其类型而异，请避免编写显示的条件&lt;/li&gt;
&lt;li&gt;Switch 声明在面向对象语言中应该尽量少的被使用&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;introduce-null-object-引入null-对象&quot;&gt;39. Introduce Null Object （引入Null 对象）&lt;/h2&gt;
&lt;p&gt;你不得不检查对象是否为Null对象&lt;br/&gt;&lt;em&gt;将null值替换为null对象&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    if (customer == null){
        plan = BillingPlan.basic();
    } 
    else{
        plan = customer.getPlan();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Customer {

    }

    class NullCusomer extends Customer {

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对象根据其类型做正确的事情，Null对象也应该遵守这个规则&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;introduce-assertion-引入断言&quot;&gt;40. Introduce Assertion （引入断言）&lt;/h2&gt;
&lt;p&gt;某段代码需要对程序状态做出某种假设&lt;br/&gt;&lt;em&gt;已断言明确表现这种假设&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    double getExpenseLimit() {
        // should have either expense limit or a primary project
        return (_expenseLimit != NULL_EXPENSE) ?
            _expenseLimit:
            _primaryProject.getMemberExpenseLimit();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    double getExpenseLimit() {
        Assert.isTrue (_expenseLimit != NULL_EXPENSE || _primaryProject != null);
        return (_expenseLimit != NULL_EXPENSE) ?
            _expenseLimit:
            _primaryProject.getMemberExpenseLimit();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;断言是一种明确表达会为true的行为&lt;/li&gt;
&lt;li&gt;当断言失败时往往是一个非受控的异常&lt;/li&gt;
&lt;li&gt;断言往往在生产代码中移除&lt;/li&gt;
&lt;li&gt;交流层面 ： 断言能使程序的阅读者理解代码所做的假设&lt;/li&gt;
&lt;li&gt;在调试的角度 ： 断言能使编程者尽可能近的接触bug&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;rename-method-函数改名&quot;&gt;41. Rename method （函数改名）&lt;/h2&gt;
&lt;p&gt;函数的名称不能表达函数的用途&lt;br/&gt;&lt;em&gt;修改函数名称&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    getinvcdtlmt()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    getInvoiceableCreditLimit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;函数的名称最好能表达函数的意图&lt;/p&gt;
&lt;h2 id=&quot;add-parameter-添加参数&quot;&gt;42. Add Parameter （添加参数）&lt;/h2&gt;
&lt;p&gt;某个函数需要从调用端得到更多的信息&lt;br/&gt;&lt;em&gt;为此函数添加一个对象函数，让改对象带进函数所需要信息&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    getContact()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    getContact(:Date)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;在改变方法之后，你获得更多的信息&lt;/p&gt;
&lt;h2 id=&quot;remove-parameter移除参数&quot;&gt;43. Remove Parameter（移除参数）&lt;/h2&gt;
&lt;p&gt;一个参数不在函数中使用了&lt;br/&gt;&lt;em&gt;移除它&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    getContact(:Date)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    getContact()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;一个参数不再使用还留着它干嘛？&lt;/p&gt;
&lt;h2 id=&quot;separate-query-from-modifier-将查询函数和修改函数分离&quot;&gt;44. Separate Query from Modifier （将查询函数和修改函数分离）&lt;/h2&gt;
&lt;p&gt;某个函数即返回函数的状态值，又修改对象的状态&lt;br/&gt;&lt;em&gt;创建两个不同的函数，其中一个负责查询，另一个负责修改&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    getTotalOutStandingAndSetReadyForSummaries()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    getTotalOutStanding()
    SetReadyForSummaries()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;将有副作用的方法和没有副作用的方法分开&lt;/p&gt;
&lt;h2 id=&quot;parameterize-method-令函数携带参数&quot;&gt;45. Parameterize Method （令函数携带参数）&lt;/h2&gt;
&lt;p&gt;若干函数做了类似的工作，但在函数本体中却包含了不同的值&lt;br/&gt;&lt;em&gt;创建单一函数，已参数表达那些不同的值&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    fivePercentRaise()
    tenPercentRaise()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    raise(percentage)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;移除重复的代码提高灵活度&lt;/p&gt;
&lt;h2 id=&quot;replace-parameter-with-explicit-methods-已明确函数取代参数&quot;&gt;46. Replace Parameter with Explicit Methods （已明确函数取代参数）&lt;/h2&gt;
&lt;p&gt;🈶一个函数，其中完全取决于参数值而采取不同的行为&lt;br/&gt;&lt;em&gt;针对该函数的每一个可能值，建立一个独立函数&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    void setValue (String name, int value) {
        if (name.equals(&quot;height&quot;)){}
            _height = value;
            return;
        }
        if (name.equals(&quot;width&quot;)){
            _width = value;
            return;
        }
        Assert.shouldNeverReachHere();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    void setHeight(int arg) {
        _height = arg;
    }
    void setWidth (int arg) {
        _width = arg;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;避免条件行为&lt;/li&gt;
&lt;li&gt;在编译器进行检查&lt;/li&gt;
&lt;li&gt;清晰的接口&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;preserve-whole-object-保持对象的完整&quot;&gt;47. Preserve Whole Object （保持对象的完整）&lt;/h2&gt;
&lt;p&gt;你从某个对象支行取出若干值，将他们作为某一次函数调用时的参数&lt;br/&gt;&lt;em&gt;改为传递一整个对象&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    int low = daysTempRange().getLow();
    int high = daysTempRange().getHigh();
    withinPlan = plan.withinRange(low, high);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    withinPlan = plan.withinRange(daysTempRange());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使参数列表在变化的时候具有鲁棒性&lt;/li&gt;
&lt;li&gt;使代码更与易读&lt;/li&gt;
&lt;li&gt;在代码中移除相似的重复的代码&lt;/li&gt;
&lt;li&gt;消极的 ： 增加了函数参数在调用时的依赖&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;replace-parameter-with-method-已函数取代参数&quot;&gt;48. Replace Parameter with Method （已函数取代参数）&lt;/h2&gt;
&lt;p&gt;对象调用某个函数，并将其所得的结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用钱一个函数&lt;br/&gt;&lt;em&gt;将函数接受者去除该项参数，并直接调用前一个函数&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    int basePrice = _quantity * _itemPrice;
    discountLevel = getDiscountLevel();
    double finalPrice = discountedPrice (basePrice, discountLevel);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    int basePrice = _quantity * _itemPrice;
    double finalPrice = discountedPrice (basePrice);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果一个函数可以通过其他的途径获得参数值，那么它就不应该通过参数取得该值&lt;/li&gt;
&lt;li&gt;如果你能有其他的方法或者相同的计算值&lt;/li&gt;
&lt;li&gt;如果要在对调用对象的引用的其他对象上调用方法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;introduce-parameter-object-引入参数对象&quot;&gt;49. Introduce Parameter Object （引入参数对象）&lt;/h2&gt;
&lt;p&gt;某些参数总是很自然的同时出现&lt;br/&gt;&lt;em&gt;以一个对象取代这些参数&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Customer{
        amountInvoicedIn (start : Date, end : Date)
        amountReceivedIn (start : Date, end : Date)
        amountOverdueIn (start : Date, end : Date)
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Customer{
        amountInvoicedIn (: DateRange)
        amountReceivedIn (: DateRange)
        amountOverdueIn (: DateRange)
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;减少参数列表的长度&lt;/li&gt;
&lt;li&gt;使代码看的更加简洁&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;remove-setting-method-移除设值函数&quot;&gt;50. Remove Setting Method （移除设值函数）&lt;/h2&gt;
&lt;p&gt;类中的某个字段应该在对象创建时被设值，然后就不再改变&lt;br/&gt;&lt;em&gt;去掉该字段的所有设值函数&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee{
        setImmutableValue()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee{
        ¯\_(ツ)_/¯
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;确保你的清晰的目的 ： 如果你想你的字段在创建之后就不要被改变了，你就不应该提供一个setting方法用于确保你的字段是否不被改变的&lt;/p&gt;
&lt;h2 id=&quot;hide-method-隐藏函数&quot;&gt;51. Hide Method （隐藏函数）&lt;/h2&gt;
&lt;p&gt;有一个函数，从来没有被其他任何类用到&lt;br/&gt;&lt;em&gt;将这个函数修改为 private&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee{
        public method()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee{
        private method()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;如果一个方法不需要被外部调用，那么就应该讲这个方法隐藏&lt;/p&gt;
&lt;h2 id=&quot;replace-constructor-with-factory-method-已工厂函数取代构造函数&quot;&gt;52. Replace Constructor with Factory Method （已工厂函数取代构造函数）&lt;/h2&gt;
&lt;p&gt;在创建对象时不仅仅是做简单的健够动作&lt;br/&gt;&lt;em&gt;将构造函数替换为工厂函数&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    Employee (int type) {
        _type = type;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    static Employee create(int type) {
        return new Employee(type);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个对象依赖于其子类，构造函数只能返回单一类型的对象，因此你需要将构造函数替换为一个工厂函数&lt;/p&gt;
&lt;h2 id=&quot;encapsulate-downcast-封装向下转型&quot;&gt;53. Encapsulate Downcast （封装向下转型）&lt;/h2&gt;
&lt;p&gt;某个函数返回的对象，需要由调用者执行向下转型&lt;br/&gt;&lt;em&gt;将向下转型动作转移到函数中&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    Object lastReading() {
        return readings.lastElement();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    Reading lastReading() {
        return (Reading) readings.lastElement();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;将一个方法最有效的返回值进行返回给函数的调用者&lt;br/&gt;如果类型是准确的，检查使用这个对象的方法并提供一个更为有效的方法&lt;/p&gt;
&lt;h2 id=&quot;replace-error-code-with-exception-以异常取代错误码&quot;&gt;54. Replace Error Code with Exception （以异常取代错误码）&lt;/h2&gt;
&lt;p&gt;某个函数返回一个特定的代码，用以表示某种错误情况&lt;br/&gt;&lt;em&gt;改用异常将其抛出去&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    int withdraw(int amount) {
        if (amount &amp;gt; _balance)
            return -1;
        else {
            _balance -= amount;
            return 0;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    void withdraw(int amount) throws BalanceException {
        if (amount &amp;gt; _balance)
            throw new BalanceException();
        _balance -= amount;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;当一个程序在发生了一个不可处理的错误时，你需要使这个函数的调用者知道。向上抛出异常，让上层调用者知道&lt;/p&gt;
&lt;h2 id=&quot;replace-exception-with-test-已测试取代异常&quot;&gt;55. Replace Exception with Test （已测试取代异常）&lt;/h2&gt;
&lt;p&gt;面对一个调用者可以预先检查的条件，你抛出了一个异常&lt;br/&gt;&lt;em&gt;修改调用者，使它在调用函数之前先做检查&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    double getValueForPeriod (int periodNumber) {
        try {
            return _values[periodNumber];
        } catch (ArrayIndexOutOfBoundsException e) {
            return 0;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    double getValueForPeriod (int periodNumber) {
        if (periodNumber &amp;gt;= _values.length)
            return 0;
        return _values[periodNumber];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不要过度使用异常，它们应该被用在检查异常上&lt;/li&gt;
&lt;li&gt;不要用它来代替条件测试&lt;/li&gt;
&lt;li&gt;检查异常错误条件在调用方法之前&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;pull-up-field-字段上移&quot;&gt;56. Pull up field （字段上移）&lt;/h2&gt;
&lt;p&gt;两个子类拥有相同的字段&lt;br/&gt;&lt;em&gt;将该字段移到超类中&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Salesman extends Employee{
        String name;
    }
    class Engineer extends Employee{
        String name;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee{
        String name;
    }
    class Salesman extends Employee{}
    class Engineer extends Employee{}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;删除重复的代码&lt;/li&gt;
&lt;li&gt;允许将子类的行为转移到父类中&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;pull-up-method-构造函数本体上移&quot;&gt;57. Pull Up Method （构造函数本体上移）&lt;/h2&gt;
&lt;p&gt;你在各个子类中拥有一些构造函数，他们的本体几乎完全一致&lt;br/&gt;&lt;em&gt;在超类中新建一个构造函数，并在子类构造函数中调用它&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Salesman extends Employee{
        String getName();
    }
    class Engineer extends Employee{
        String getName();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee{
        String getName();
    }
    class Salesman extends Employee{}
    class Engineer extends Employee{}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;消除重复的行为&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;pull-up-constructor-body-构造函数本体上移&quot;&gt;58. Pull Up Constructor Body （构造函数本体上移）&lt;/h2&gt;
&lt;p&gt;在子类中的构造函数与父类中的构造函数是相同的&lt;br/&gt;&lt;em&gt;在超类中创建一个构造函数，并在子类构造函数中调用它&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Manager extends Employee...
        public Manager (String name, String id, int grade) {
        _name = name;
        _id = id;
        _grade = grade;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    public Manager (String name, String id, int grade) {
        super (name, id);
        _grade = grade;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构造函数与方法不同&lt;/li&gt;
&lt;li&gt;消除重复的代码&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;push-down-method-方法下移&quot;&gt;59. Push Down Method （方法下移）&lt;/h2&gt;
&lt;p&gt;父类的某个方法至于某个子类相关&lt;br/&gt;&lt;em&gt;将其移到子类中&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee{
        int getQuota();
    }
    class Salesman extends Employee{}
    class Engineer extends Employee{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Salesman extends Employee{
        int getQuota();
    }
    class Engineer extends Employee{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;当方法只在子类中显现&lt;/p&gt;
&lt;h2 id=&quot;push-down-field-字段下移&quot;&gt;60. Push Down Field （字段下移）&lt;/h2&gt;
&lt;p&gt;超类的字段只在某个子类中用到&lt;br/&gt;&lt;em&gt;将这个字段移到需要它的那些子类中去&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee{
        int quota;
    }
    class Salesman extends Employee{}
    class Engineer extends Employee{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Salesman extends Employee{
        int quota;
    }
    class Engineer extends Employee{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;当一个字段只在子类中使用时&lt;/p&gt;

&lt;p&gt;类中的某些特性只被某些实例用到&lt;br/&gt;&lt;em&gt;新建一个子类，将上面所说的那一部分特性移到子类中去&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class JobItem   {
        getTotalPrices()
        getUnitPrice()
        getEmployee()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    JobItem {
        getTotalPrices()
        getUnitPrice()
    }
    class class LabotItem extends JobItem   {
        getUnitPrice()
        getEmployee()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;当一个类的行为只用在某些实例中而不用在其他类中&lt;/p&gt;

&lt;p&gt;两个类具有相似特性&lt;br/&gt;&lt;em&gt;创建一个父类，然后将这两个类中相同的部分移到父类中，然后在继承这个父类&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Department{
        getTotalAnnualCost()
        getName()
        getHeadCount
    }
    class Employee{
        getAnnualCost()
        getName()
        getId
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Party{
        getAnnualCost()
        getName()
    }
    class Department {
        getAnnualCost()
        getHeadCount
    }
    class Employee {
        getAnnualCost()
        getId
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;当两个类有过多相似的地方的时候，就需要考虑下是否需要将这个类进行下抽象了&lt;/p&gt;

&lt;p&gt;若干客户使用类接口中的同一个子类，或者两个类的接口有相同的部分&lt;br/&gt;&lt;em&gt;将相同的子集提炼到一个独立接口中&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee {
        getRate()
        hasSpecialSkill()
        getName()
        getDepartment()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    interface Billable  {
        getRate()
        hasSpecialSkill()
    }
    class Employee implements Billable  {
        getRate
        hasSpecialSkill()
        getName()
        getDepartment()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若一个类的子集明确被一系列的客户使用&lt;/li&gt;
&lt;li&gt;如果一个类需要和多个类处理并能处理确定的请求&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;collapse-hierarchy-折叠继承体系&quot;&gt;64. Collapse Hierarchy （折叠继承体系）&lt;/h2&gt;
&lt;p&gt;超类和子类无太大区别&lt;br/&gt;&lt;em&gt;将它们合为一个&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee{ }
    class Salesman extends Employee{    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Employee{ }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;该子类没有带来任何价值&lt;/p&gt;
&lt;h2 id=&quot;form-template-method-塑造模板函数&quot;&gt;65. Form Template Method （塑造模板函数）&lt;/h2&gt;
&lt;p&gt;有些子类，其中对应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同&lt;br/&gt;&lt;em&gt;将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移到超类&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Site{}
    class ResidentialSite extends Site{
        getBillableAmount()
    }
    class LifelineSite extends Site{
        getBillableAmount()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Site{     
        getBillableAmount()
        getBaseAmount()
        getTaxAmount()
    }
    class ResidentialSite extends Site{
        getBaseAmount()
        getTaxAmount()
    }
    class LifelineSite extends Site{
        getBaseAmount()
        getTaxAmount()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;replace-inheritance-with-delegation-以委托取代继承&quot;&gt;66. Replace Inheritance with Delegation （以委托取代继承）&lt;/h2&gt;
&lt;p&gt;某个子类只使用了超类接口中的一部分，或是根本不需要继承而来的数据&lt;br/&gt;_在子类中创建一个字段用以保存超类，调整子类函数，令它改2而委托超类：然后去除两者之间的继承关系&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Vector{
        isEmpty()
    }

    class Stack extends Vector {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Vector {
        isEmpty()
    }

    class Stack {
        Vector vector
        isEmpty(){
            return vector.isEmpty()
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当你使用委托类的时候会对你使用的数据字段更加的清晰&lt;/li&gt;
&lt;li&gt;在你控制之外的方法都会被忽略，你只需要关注于自身&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;replace-delegation-with-inheritance-以继承取代委托&quot;&gt;67. Replace Delegation with Inheritance （以继承取代委托）&lt;/h2&gt;
&lt;p&gt;你在两个类之间使用简单的委托关系，并经常为整个接口编写许多很多简单的委托函数&lt;br/&gt;&lt;em&gt;让委托类继承委托类&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Person {
        getName()
    }

    class Employee {
        Person person
        getName(){
            return person.getName()
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Person{
        getName()
    }
    class Employee extends Person{}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果你使用所有的方法在委托类中&lt;/li&gt;
&lt;li&gt;如果你不能使用委托类的所有函数，那么久不应该使用它&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;tease-apart-inheritance-梳理并分解继承体系&quot;&gt;68. Tease Apart Inheritance （梳理并分解继承体系）&lt;/h2&gt;
&lt;p&gt;某个继承体系同时承担两项责任&lt;br/&gt;&lt;em&gt;建立两个继承体系，并通过委托关系让其中一个可以调用另外一个&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Deal{}
    class ActiveDeal extends Deal{}
    class PassiveDeal extends Deal{}
    class TabularActiveDeal extends ActiveDeal{}
    class TabularPassiveDeal extends PassiveDeal{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Deal{
        PresentationStyle presettationStyle;
    }
    class ActiveDeal extends Deal{}
    class PassiveDeal extends Deal{}

    class PresentationStyle{}
    class TabularPresentationStyle extends PresentationStyle{}
    class SinglePresentationStyle extends PresentationStyle{}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;过度的继承会导致代码重复&lt;/li&gt;
&lt;li&gt;如果继承体系中的某一特定层级上的所有类，其子类名称都已相同的形容词开始，那么这个体系可能肩负着两项不同的责任。&lt;br/&gt;| |&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;convert-procedural-design-to-objects-过程化设计转为对象设计&quot;&gt;69. Convert Procedural Design to Objects （过程化设计转为对象设计）&lt;/h2&gt;
&lt;p&gt;你手上有些传统过程化风格的代码&lt;br/&gt;&lt;em&gt;将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象中&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class OrderCalculator{
        determinePrice(Order)
        determineTaxes(Order)
    }
    class Order{}
    class OrderLine{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class Order{
        getPrice()
        getTaxes()
    }
    class OrderLine{
        getPrice()
        getTaxes()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;br/&gt;使用面向对象思想进行变成&lt;/p&gt;
&lt;h2 id=&quot;separate-domain-from-presentation-将领域和表述显示分离&quot;&gt;70. Separate Domain from Presentation （将领域和表述/显示分离）&lt;/h2&gt;
&lt;p&gt;某些GUI类中包含了领域逻辑&lt;br/&gt;&lt;em&gt;将领域逻辑分离出来吗，为他们创建独立的领域类&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class OrderWindow{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class OrderWindow{
        Order order;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分裂两个过于复杂的代码，使他们更易于修改&lt;/li&gt;
&lt;li&gt;允许多层风格编写的程序&lt;/li&gt;
&lt;li&gt;这是值得被使用的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有某个类做了太多的工作其中一部分工作是以大量的条件表达式完成的&lt;br/&gt;&lt;em&gt;创建一个继承体系，已一个子类来表达某一种特殊的情况&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class BillingScheme{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    class BillingScheme{}
    class BusinessBillingScheme extends BillingScheme{}
    class ResidentialBillingScheme extends BillingScheme{}
    class DisabilityBillingScheme extends BillingScheme{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个类实现一个概念演变成实现多个概念&lt;/li&gt;
&lt;li&gt;保持单一责任&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/wsccoder/Refactoring-Summary-To-Chinese/blob/master/README.md&quot;&gt;GitHub地址欢迎Star Fork Follower&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 12 Oct 2018 13:07:00 +0000</pubDate>
<dc:creator>王守昌</dc:creator>
<og:description>这是一篇《重构 》的总结 ，我在学习的同时并使用它作为参考。这不是一本书的替代品，所以你要想真的想学习里面的内容，买一本书使用这个文章作为参考和指南。 另外： 建议 评论 还 PR 都是十分欢迎的 1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangshouchang/p/9780732.html</dc:identifier>
</item>
</channel>
</rss>