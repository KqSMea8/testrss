<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>加载动态链接库——dlopen dlsym dlclose - zxzhang</title>
<link>http://www.cnblogs.com/ZhaoxiCheung/p/9424930.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhaoxiCheung/p/9424930.html</guid>
<description>&lt;h2 id=&quot;dlopendlmopendlclose&quot;&gt;DLOPEN DLMOPEN DLCLOSE&lt;/h2&gt;
&lt;h3 id=&quot;name&quot;&gt;NAME&lt;/h3&gt;
&lt;p&gt;    &lt;strong&gt;dlclose, dlopen, dlmopen&lt;/strong&gt; - 打开／关闭共享对象&lt;/p&gt;
&lt;h3 id=&quot;synopsis&quot;&gt;SYNOPSIS&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;dlfcn.h&amp;gt;

void *dlopen(const char *filename, int flags);

int dlclose(void *handle);

#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;

void *dlmopen (Lmid_t lmid, const char *filename, int flags);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;description&quot;&gt;DESCRIPTION&lt;/h3&gt;
&lt;h4 id=&quot;dlopen&quot;&gt;dlopen()&lt;/h4&gt;
&lt;p&gt;    这个函数加载由以null结尾的字符串文件名命名的动态共享对象（共享库）文件，并为加载的对象返回不透明的“句柄”。此句柄与 dlopen API 中的其他函数一起使用，例如&lt;code&gt;dlsym()&lt;/code&gt;，&lt;code&gt;dladdr()&lt;/code&gt;，&lt;code&gt;dlinfo()&lt;/code&gt;和&lt;code&gt;dlclose()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果 &lt;u&gt;filename&lt;/u&gt; 为 NULL，则返回的句柄用于主程序。如果 &lt;u&gt;filename&lt;/u&gt; 包含斜杠（“/”），则它被解释为（相对或绝对）路径名。否则，动态链接器将按如下方式搜索对象（有关详细信息，请参阅&lt;code&gt;ld.so(8)&lt;/code&gt;）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（仅限ELF）如果调用程序的可执行文件包含 DT_RPATH 标记，并且不包含 DT_RUNPATH 标记，则会搜索 DT_RPATH 标记中列出的目录。&lt;/li&gt;
&lt;li&gt;如果在程序启动时，环境变量 LD_LIBRARY_PATH 被定义为包含以冒号分隔的目录列表，则会搜索这些目录。 （作为安全措施，set-user-ID 和 set-group-ID程序将忽略此变量。）&lt;/li&gt;
&lt;li&gt;（仅限ELF）如果调用程序的可执行文件包含　DT_RUNPATH　标记，则搜索该标记中列出的目录。&lt;/li&gt;
&lt;li&gt;检查缓存文件/etc/ld.so.cache（由ldconfig（8）维护）以查看它是否包含filename的条目。&lt;/li&gt;
&lt;li&gt;搜索目录 /lib和 /usr/lib（按此顺序）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    如果 &lt;u&gt;filename&lt;/u&gt; 指定的对象依赖于其他共享对象，则动态链接器也会使用相同的规则自动加载这些对象。 （如果这些对象依次具有依赖性，则此过程可以递归地发生）&lt;/p&gt;
&lt;p&gt;&lt;u&gt;flags&lt;/u&gt; 参数必须包括以下两个值中的一个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RTLD_LAZY&lt;br/&gt;执行延迟绑定。仅在执行引用它们的代码时解析符号。如果从未引用该符号，则永远不会解析它（只对函数引用执行延迟绑定;在加载共享对象时，对变量的引用总是立即绑定）。自 glibc 2.1.1，此标志被&lt;strong&gt;LD_BIND_NOW&lt;/strong&gt;环境变量的效果覆盖。&lt;/li&gt;
&lt;li&gt;RTLD_NOW&lt;br/&gt;如果指定了此值，或者环境变量&lt;strong&gt;LD_BIND_NOW&lt;/strong&gt;设置为非空字符串，则在&lt;code&gt;dlopen()&lt;/code&gt;返回之前，将解析共享对象中的所有未定义符号。如果无法执行此操作，则会返回错误。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;u&gt;flags&lt;/u&gt; 也可以通过以下零或多个值进行或运算设置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RTLD_GLOBAL&lt;br/&gt;此共享对象定义的符号将可用于后续加载的共享对象的符号解析。&lt;/li&gt;
&lt;li&gt;RTLD_LOCAL&lt;br/&gt;这与&lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt;相反，如果未指定任何标志，则为默认值。此共享对象中定义的符号不可用于解析后续加载的共享对象中的引用。&lt;/li&gt;
&lt;li&gt;RTLD_NODELETE (since glibc 2.2)&lt;br/&gt;在&lt;code&gt;dlclose()&lt;/code&gt;期间不要卸载共享对象。因此，如果稍后使用&lt;code&gt;dlopen()&lt;/code&gt;重新加载对象，则不会重新初始化对象的静态变量。&lt;/li&gt;
&lt;li&gt;RTLD_NOLOAD (since glibc 2.2)&lt;br/&gt;不要加载共享对象。这可用于测试对象是否已经驻留（如果不是，则&lt;code&gt;dlopen()&lt;/code&gt;返回 NULL，如果是驻留则返回对象的句柄）。此标志还可用于提升已加载的共享对象上的标志。例如，以前使用&lt;strong&gt;RTLD_LOCAL&lt;/strong&gt;加载的共享对象可以使用&lt;strong&gt;RTLD_NOLOAD | RTLD_GLOBAL&lt;/strong&gt;重新打开。&lt;/li&gt;
&lt;li&gt;RTLD_DEEPBIND (since glibc 2.3.4)&lt;br/&gt;将符号的查找范围放在此共享对象的全局范围之前。这意味着自包含对象将优先使用自己的符号，而不是全局符号，这些符号包含在已加载的对象中。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;dlmopen&quot;&gt;dlmopen()&lt;/h4&gt;
&lt;p&gt;    这个函数除了以下几点与&lt;code&gt;dlopen()&lt;/code&gt;有所不同外，都执行同样的任务。&lt;br/&gt;    &lt;code&gt;dlmopen()&lt;/code&gt;与&lt;code&gt;dlopen()&lt;/code&gt;的主要不同之处主要在于它接受另一个参数 &lt;u&gt;lmid&lt;/u&gt;，它指定应该被加载的共享对象的链接映射列表（也称为命名空间）。对于命名空间，&lt;u&gt;Lmid_t&lt;/u&gt; 是个不透明的句柄。&lt;br/&gt;&lt;u&gt;lmid&lt;/u&gt; 参数要么是已经存在的命名空间的ID（这个命名空间可以通过&lt;code&gt;dlinfo RTLD_DI_LMID&lt;/code&gt;请求获得）或者是以下几个特殊值中的其中一个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;LM_ID_BASE&lt;br/&gt;在初始命名空间中加载共享对象（即应用程序的命名空间）。&lt;/li&gt;
&lt;li&gt;LM_ID_NEWLM&lt;br/&gt;创建新的命名空间并在该命名空间中加载共享对象。该对象必须已正确链接到引用 所有其他需要的共享对象，因为新的命名空间最初为空。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果 &lt;u&gt;filename&lt;/u&gt; 是 NULL，那么 &lt;u&gt;lmid&lt;/u&gt; 的值只能是&lt;strong&gt;LM_ID_BASE&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;dlclose&quot;&gt;dlclose()&lt;/h4&gt;
&lt;p&gt;    &lt;code&gt;dlclose()&lt;/code&gt;减少指定句柄 &lt;u&gt;handle&lt;/u&gt; 引用的动态加载共享对象的引用计数。如果引用计数减少为０，那么这个动态加载共享对象将被真正卸载。所有在&lt;code&gt;dlopen()&lt;/code&gt;被调用的时候自动加载的共享对象将以相同的方式递归关闭。&lt;/p&gt;
&lt;p&gt;    &lt;code&gt;dlclose()&lt;/code&gt;成功返回并不保证与句柄相关的符号将从调用方的地址空间中删除。除了显式通过&lt;code&gt;dlopen()&lt;/code&gt;调用产生的引用之外，一些共享对象作为依赖项可能已被隐式加载（和引用计数）。只有当所有引用都已被释放才可以从地址空间中删除共享对象。&lt;/p&gt;
&lt;h3 id=&quot;return-value&quot;&gt;RETURN VALUE&lt;/h3&gt;
&lt;p&gt;    执行成功时，&lt;code&gt;dlopen()&lt;/code&gt;和&lt;code&gt;dlmopen()&lt;/code&gt;返回一个非空句柄。&lt;br/&gt;    执行失败时（文件找不到、不可读、错误的格式或者在加载的时候出现错误），&lt;code&gt;dlopen()&lt;/code&gt;和&lt;code&gt;dlmopen()&lt;/code&gt;返回 NULL。&lt;br/&gt;    对于&lt;code&gt;dlclose()&lt;/code&gt;成功执行，将返回０值，失败时，返回一个非０值。&lt;/p&gt;
&lt;p&gt;以上这些函数产生的错误，其错误信息都可以通过&lt;code&gt;dlerror()&lt;/code&gt;获知。&lt;/p&gt;
&lt;h3 id=&quot;notes&quot;&gt;NOTES&lt;/h3&gt;
&lt;h4 id=&quot;dlmopen-与-命名空间&quot;&gt;dlmopen() 与 命名空间&lt;/h4&gt;
&lt;p&gt;    链接映射列表定义了通过动态链接器解析的符号的孤立命名空间。在命名空间内，被依赖的共享对象根据通常的规则被隐式加载，符号引用同样以通常的规则被解析。但是这种方案受限于已经被（显式和隐式）加载进命名空间的对象的定义。&lt;/p&gt;
&lt;p&gt;    &lt;code&gt;dlmopen()&lt;/code&gt;函数允许对象隔离加载——在新的命名空间中加载共享对象而不暴露其余的应用于新对象提供的符号。注意使用&lt;strong&gt;RTLD_LOCAL&lt;/strong&gt;标志不足以达到此目的，因为它防止一个共享对象的符号对&lt;strong&gt;任何其他&lt;/strong&gt;共享对象可用。在某些情况下，我们可能想使得由一些动态加载共享对象提供的符号对于其他共享对象可用，而不将这些符号暴露给整个应用。这可以通过使用单独的命名空间和&lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt;标志来实现。&lt;/p&gt;
&lt;p&gt;    &lt;code&gt;dlmopen()&lt;/code&gt;函数可以提供比&lt;strong&gt;RTLD_LOCAL&lt;/strong&gt;标志更好的隔离效果。特别是，当共享对象是通过&lt;strong&gt;RTLD_LOCAL&lt;/strong&gt;标志加载的，并且其依赖的共享对象是通过&lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt;加载的，那么有可能升级为&lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt;。因此，明确控制了所有共享对象的依赖的这种情况外，&lt;strong&gt;RTLD_LOCAL&lt;/strong&gt;是不足以隔离加载的共享对象，。&lt;/p&gt;
&lt;p&gt;    &lt;code&gt;dlmopen()&lt;/code&gt;函数的一种用法是多次加载同样的对象。不使用&lt;code&gt;dlmopen()&lt;/code&gt;函数来实现这个功能的话，需要创建共享对象的一个副本。而如果使用&lt;code&gt;dlmopen()&lt;/code&gt;函数来实现的话，可以通过将相同的共享对象文件加载到不同的命名空间来实现。&lt;br/&gt;glibc实现最多支持16个命名空间。&lt;/p&gt;
&lt;h4 id=&quot;初始化和终结功能&quot;&gt;初始化和终结功能&lt;/h4&gt;
&lt;p&gt;    共享对象可以使用&lt;strong&gt;&lt;strong&gt;attribute&lt;/strong&gt; ((constructor))&lt;/strong&gt;和&lt;strong&gt;&lt;strong&gt;attribute&lt;/strong&gt; ((destructor))&lt;/strong&gt;函数属性。构造函数在&lt;code&gt;dlopen()&lt;/code&gt;返回之前执行，而析构函数在&lt;code&gt;dlclose()&lt;/code&gt;返回之前执行。共享对象可以导出多个构造函数和析构函数并且优先顺序可以和每个函数相关联来决定它们的执行顺序。&lt;/p&gt;
&lt;h2 id=&quot;dlsym&quot;&gt;DLSYM&lt;/h2&gt;
&lt;h3 id=&quot;name-1&quot;&gt;NAME&lt;/h3&gt;
&lt;p&gt;    &lt;strong&gt;dlsym, dlvsym&lt;/strong&gt; - 获取共享对象或可执行文件中符号的地址&lt;/p&gt;
&lt;h3 id=&quot;synopsis-1&quot;&gt;SYNOPSIS&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;dlfcn.h&amp;gt;

void *dlsym(void *handle, const char *symbol);

#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;

void *dlvsym(void *handle, char *symbol, char *version);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;description-1&quot;&gt;DESCRIPTION&lt;/h3&gt;
&lt;p&gt;    &lt;code&gt;dlsym()&lt;/code&gt;接受由&lt;code&gt;dlopen()&lt;/code&gt;返回的动态加载的共享对象的“句柄”，并返回该符号加载到内存中的地址。如果未找到符号，则在加载该对象时，在指定对象或&lt;code&gt;dlopen()&lt;/code&gt;自动加载的任何共享对象中，&lt;code&gt;dlsym()&lt;/code&gt;将返回NULL。（&lt;code&gt;dlsym()&lt;/code&gt;通过这些共享对象的依赖关系树进行宽度优先搜索。）&lt;br/&gt;    因为符号本身可能是 NULL（所以&lt;code&gt;dlsym()&lt;/code&gt;返回 NULL 并不意味着错误），因此判断是否错误的正确做法是调用&lt;code&gt;dlerror()&lt;/code&gt;清除任何旧的错误条件，然后调用&lt;code&gt;dlsym()&lt;/code&gt;，并且再次调用&lt;code&gt;dlerror()&lt;/code&gt;，保存其返回值，判断这个保存的值是否是 NULL。&lt;br/&gt;    可以在句柄中指定两个特殊的伪句柄：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RTLD_DEFAULT&lt;br/&gt;使用默认共享对象搜索顺序查找所需符号的第一个匹配项。搜索将包括可执行文件中的全局符号及其依赖项，以及使用&lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt; 标志动态加载的共享对象中的符号。&lt;/li&gt;
&lt;li&gt;RTLD_NEXT&lt;br/&gt;在当前对象之后的搜索顺序中查找下一个所需符号。这允许人们在另一个共享对象中提供一个函数的包装器，因此，例如，预加载的共享对象中的函数定义（参见ld.so（8）中的&lt;strong&gt;LD_PRELOAD&lt;/strong&gt;）可以找到并调用在另一个共享对象中提供的“真实”函数（或者就此而言，在存在多个预加载层的情况下，函数的“下一个”定义）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    &lt;code&gt;dlvsym()&lt;/code&gt;除了比&lt;code&gt;dlsym()&lt;/code&gt;多提供了一个额外的参数外，其余与&lt;code&gt;dlsym()&lt;/code&gt;相同。&lt;/p&gt;
&lt;h3 id=&quot;return-value-1&quot;&gt;RETURN VALUE&lt;/h3&gt;
&lt;p&gt;    执行成功，这些函数将会返回　&lt;u&gt;symbol&lt;/u&gt; 关联的地址。执行失败，它们将返回 NULL。错误的原因可以通过&lt;code&gt;dlerror()&lt;/code&gt;进行诊断。&lt;/p&gt;
&lt;h2 id=&quot;example&quot;&gt;EXAMPLE&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;dlfcn.h&amp;gt;
#include &amp;lt;gnu/lib-names.h&amp;gt;  /* Defines LIBM_SO (which will be a
                              string such as &quot;libm.so.6&quot;) */
int
main(void)
{
    void *handle;
    double (*cosine)(double);
    char *error;

    handle = dlopen(LIBM_SO, RTLD_LAZY);
    if (!handle) {
       fprintf(stderr, &quot;%s\n&quot;, dlerror());
       exit(EXIT_FAILURE);
    }

    dlerror();    /* Clear any existing error */

    cosine = (double (*)(double)) dlsym(handle, &quot;cos&quot;);

    /* According to the ISO C standard, casting between function
      pointers and 'void *', as done above, produces undefined results.
      POSIX.1-2003 and POSIX.1-2008 accepted this state of affairs and
      proposed the following workaround:

          *(void **) (&amp;amp;cosine) = dlsym(handle, &quot;cos&quot;);

      This (clumsy) cast conforms with the ISO C standard and will
      avoid any compiler warnings.

      The 2013 Technical Corrigendum to POSIX.1-2008 (a.k.a.
      POSIX.1-2013) improved matters by requiring that conforming
      implementations support casting 'void *' to a function pointer.
      Nevertheless, some compilers (e.g., gcc with the '-pedantic'
      option) may complain about the cast used in this program. */

    error = dlerror();
    if (error != NULL) {
       fprintf(stderr, &quot;%s\n&quot;, error);
       exit(EXIT_FAILURE);
    }

    printf(&quot;%f\n&quot;, (*cosine)(2.0));
    dlclose(handle);
    exit(EXIT_SUCCESS);
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 29 Sep 2018 15:02:00 +0000</pubDate>
<dc:creator>zxzhang</dc:creator>
<og:description>DLOPEN DLMOPEN DLCLOSE NAME      dlclose, dlopen, dlmopen 打开／关闭共享对象 SY</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZhaoxiCheung/p/9424930.html</dc:identifier>
</item>
<item>
<title>Antd-Select组件的深入用法 - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9726838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9726838.html</guid>
<description>&lt;h3&gt;一、Antd-Select提供几种类型&lt;/h3&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最基础版只提供下拉功能的选择器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;带搜索功能的下拉选择器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可多选的下拉选择器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可搜索、可多选、可随意输入内容的tag下拉选择器(支持自动分词)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;多级联动下拉选择器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;搜索远程数据下拉框&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;二、一些潜在用法&lt;/h3&gt;
&lt;h4&gt;如果Select.Option选项的数量特别大:2k、3k...&lt;/h4&gt;
&lt;p&gt;假设请求数据时间我们都解决好了,信心满满地准备把数据填充到&lt;code&gt;&amp;lt;Select.Option&amp;gt;&lt;/code&gt;后下班!过会你会发现有多绝望..&lt;/p&gt;
&lt;p&gt;这下拉框加载了&lt;code&gt;10s&lt;/code&gt;还没出来！?这时候先想着去antd文档上找解决方法,无果后百度、SF、google....因为antd每次都会重新渲染&lt;code&gt;&amp;lt;Select.Option&amp;gt;&lt;/code&gt;,所以要降低卡顿时间,唯一办法就是&lt;strong&gt;减少渲染的数量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以来体验一下:&lt;a href=&quot;https://codepen.io/anon/pen/eygNeR?editors=0010&quot; target=&quot;_blank&quot;&gt;《antd-Select加载2k条数据演示》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发现问的人倒挺多,真正解决的回答没见到几个(我还没找到..)&lt;br/&gt;有的劝着放弃吧,加了那么多用户也不会看(确实如此),改做成一个搜索下拉框.稍微执拗一点的继续挣扎,终于找到了一个能优化加载速度的插件&lt;a href=&quot;https://github.com/bvaughn/react-select-fast-filter-options&quot; target=&quot;_blank&quot;&gt;《react-select-fast-filter-options》&lt;/a&gt;&lt;br/&gt;然后过会又发现,搜索功能肯定也需要的呀!总不能让用户翻那2000条数据.可能半夜还会被投诉.&lt;/p&gt;
&lt;p&gt;带着最后一点希望,找了一下github上&lt;code&gt;antd&lt;/code&gt;的Issues,里面给的回答倒是挺有启发的,但是还是没有正确的解决办法.&lt;a href=&quot;https://github.com/ant-design/ant-design/issues/7086&quot; target=&quot;_blank&quot;&gt;《ant-design:Issues》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;于是就自己设计了一个,新手代码请见谅,希望对你有帮助.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//render
const { optionsData } = this.state;

&amp;lt;Select style={{ width: 200 }} 
    showSearch
    onChange={this.handleSecChange}
    placeholder=&quot;请输入/选择xxx&quot;   
    onSearch={this.handleSerach}
&amp;gt;
{
    optionsData.length &amp;amp;&amp;amp; optionsData.map( (item, index) =&amp;gt; (
        &amp;lt;Select.Option key={index} value={item}&amp;gt;{item}&amp;lt;/Select.Option&amp;gt;)
    ) 
}
&amp;lt;/Select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//搜索Value值改变触发回调函数
handleSerach(e){
  let { clusterValue } = this.state;
  let that = this;
  //类似函数节流
  setTimeout(function(){
    that.loadOption(clusterValue, e)
  },300)
  
}

loadOption(clusterValue, keyWords){
    const { options } = this.props.data;   //获得2k条数据
    let newOptionsData = [];
    let arrData = options[clusterValue]; 
    if(Object.keys(options).length){
      let len;
      if(arrData.length &amp;gt; 100)  len = 100;
      else len = arrData.length;
      
      //初始化
      if(keyWords == ''){
        for(var i=0;i&amp;lt;len;i++){
          newOptionsData.push(arrData[i])
        } 
      }
        
      //用户搜索
      else{
        newOptionsData = [];
        for(var j = 0; j &amp;lt; arrData.length; j++){
          if(arrData[j].indexOf(keyWords) != -1){
            newOptionsData.push(arrData[j]);
            if(newOptionsData.length &amp;gt; 100) break;
          }
        }         
      } 
    }

    // return newOptionsData
    this.setState({
      optionsData: newOptionsData
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在&lt;code&gt;handleSearch&lt;/code&gt;函数添加定时是为了解决每次输入都立刻请求,导致卡顿;用户输入完成后再统一查找,虽然会导致在搜索的时候增加300ms空白期,但是比用户输入卡顿要好&lt;/li&gt;
&lt;li&gt;把渲染数量控制在&lt;code&gt;100条内&lt;/code&gt;,防止卡顿,一般用户查找一个数据,也会输入得比较完整,不可能会在100条内查找。&lt;/li&gt;
&lt;li&gt;区分初始化和搜索两个不同情况,用户刚进入界面的时候,并没有关键字搜索,所以这时候要初始化&lt;code&gt;前100条&lt;/code&gt;内容给用户,当然你也可以按照一定的条件渲染数据给用户,只要保证合理数量以内即可&lt;/li&gt;
&lt;li&gt;因为我的数据是多级联动的&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;options:{
'key': [xxx,xxx1,xxx2...],
'key1': [xxx,xxx1,xxx2...]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以我的写法是&lt;code&gt;options[xxx]&lt;/code&gt;,然后遍历相应的数组即可&lt;/p&gt;
&lt;p&gt;当然这仅仅是一种思路,更好的实现方法有很多！希望这能成为你的方法的一个垫脚石&lt;/p&gt;
&lt;p&gt;有时候多看看官方文档真的很有帮助.学习的不仅仅是它的方法,还有它的思路。如果遇到它的一些特殊语法(语法糖),也可以到&lt;code&gt;ant-design-pro&lt;/code&gt;里查阅&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pro.ant.design/docs/getting-started-cn&quot; target=&quot;_blank&quot;&gt;《ant-design-pro》&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Sep 2018 13:53:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>一、Antd Select提供几种类型 1. 最基础版只提供下拉功能的选择器 2. 带搜索功能的下拉选择器 3. 可多选的下拉选择器 4. 可搜索、可多选、可随意输入内容的tag下拉选择器(支持自动分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9726838.html</dc:identifier>
</item>
<item>
<title>.NET Core中的数据保护组件 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9726191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9726191.html</guid>
<description>&lt;blockquote readability=&quot;1.3917525773196&quot;&gt;
&lt;p&gt;原文地址： &lt;a href=&quot;https://tahirnaushad.com/2017/09/09/preventing-insecure-object-references-in-asp-net-core-2-0/&quot;&gt;PREVENTING INSECURE OBJECT REFERENCES IN ASP.NET CORE 2.0&lt;/a&gt;&lt;br/&gt;作者： &lt;a href=&quot;https://tahirnaushad.com/about/&quot;&gt;Tahir Naushad&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 OWASP(开放式 Web 应用程序安全项目) 2013 年发布的报告中，将不安全的直接对象引用(Insecure Direct Object Reference)标记为 十大 Web 应用程序风险之一, 其表现形式是对象的引用(例如数据库主键)被各种恶意攻击利用, 所以对于Api返回的各种主键外键ID, 我们需要进行加密。&lt;/p&gt;

&lt;p&gt;.NET Core 中内置了一个&lt;code&gt;IDataProtectionProvider&lt;/code&gt;接口和一个&lt;code&gt;IDataProtector&lt;/code&gt;接口。其中IDataProtectionProvider是创建保护组件的接口，IDataProtector是数据保护的接口。开发人员可以实现这 2 个接口，创建数据保护组件。&lt;/p&gt;
&lt;h2 id=&quot;内置的数据保护组件&quot;&gt;内置的数据保护组件&lt;/h2&gt;
&lt;p&gt;.NET Core 中默认提供了一个数据保护组件, 下面我们来尝试使用这个默认组件来保护我们的数据。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;例: 当前我们有一个&lt;code&gt;Movie&lt;/code&gt;类，代码如下, 我们期望当获取Movie对象的时候，Id字段是加密的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class Movie
    {
        public Movie(int id, string title)
        {
            Id = id;
            Title = title;
        }

        public int Id { get; set; }
        public string Title { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们需要在&lt;code&gt;Startup.cs&lt;/code&gt;中&lt;code&gt;ConfigureService&lt;/code&gt;方法中配置使用默认的数据保护组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();
        services.AddDataProtection();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码会启用.NET Core默认的数据保护器。&lt;/p&gt;
&lt;p&gt;然后我们创建一个&lt;code&gt;MoviesController&lt;/code&gt;, 并在构造函数中注入&lt;code&gt;IDataProtectionProvider&lt;/code&gt;对象, 然后使用这个Provider对象创建一个实现&lt;code&gt;IDataProtector&lt;/code&gt;接口的数据保护器对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [Route(&quot;movies&quot;)]
    public class MoviesController : Controller
    {
        private readonly IDataProtector protector;
 
        public MoviesController(IDataProtectionProvider provider)
        {
            this.protector = provider.CreateProtector(&quot;protect_my_query_string&quot;);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;TIPS: 使用Provider创建Protector的时候，我们传入了一个参数&quot;protect_my_query_string&quot;, 这个参数标明了这个保护器的用途，你也可以把它就当成这个保护器的名字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意： &lt;strong&gt;不同用途的保护器不能解密对方的加密字符串。&lt;/strong&gt;, 如果使用了保护器A去解密保护器B生成的字符串，会产生以下异常CryptographicException: The payload was invalid.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后我们在&lt;code&gt;MovieController&lt;/code&gt;中添加2个Api, 一个是获取所有Movies对象的，一个是获取指定Movie对象的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   [HttpGet]
   public IActionResult Get()
   {
       var model = GetMovies();
       
       var outputModel = model.Select(item =&amp;gt; new
       {
           Id = this.protector.Protect(item.Id.ToString()),
           item.Title,
           item.ReleaseYear,
           item.Summary
       });

       return Ok(outputModel);
   }

   [HttpGet(&quot;{id}&quot;)]
   public IActionResult Get(string id)
   {
       var orignalId = int.Parse(this.protector.Unprotect(id));

       var model = GetMovies(); 
       
       var outputModel = model.Where(item =&amp;gt; item.Id == orignalId);

       return Ok(outputModel);
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码解释&quot;&gt;代码解释&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在获取Movie列表的api中，我们使用了&lt;code&gt;IDataProtector&lt;/code&gt;接口的&lt;code&gt;Protect&lt;/code&gt;方法对Id字段进行了加密&lt;/li&gt;
&lt;li&gt;相应的在获取单个Movie对象的api中, 我们需要使用&lt;code&gt;IDataProtector&lt;/code&gt;接口的&lt;code&gt;Unprotect&lt;/code&gt;方法对Id字段进行解密。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;最终效果&quot;&gt;最终效果&lt;/h3&gt;
&lt;p&gt;首先我们调用/api/movies, 返回结果如下, id字段已经被正确加密了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[{
   &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6ygyO6avkgI2teCQGZQShNwsxC9ApDdsnyYd1K5IyNHjhZcRoGd6W31se3W6TWM8H9UdLEPn4fJpS5uKkqUa0PMV6a0ZZHBQSnlGoisSnj29g&quot;,
   &quot;title&quot;: &quot;泰坦尼克号&quot;
}, {
   &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6wkMUYyzflIzy3CwoMhcaO-np2WOy4czIL3WZd2FWi7Tsy119tDeFq7yAeye4o2W-KmbffpGXnTDZzNv2QbCrAm7-AyEN35g3pkfAYHa3X7aQ&quot;,
   &quot;title&quot;: &quot;我是谁&quot;
}, {
   &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6x2AXM6ulCwts2-uQSfzIU8UquTz-OAZIl-49D5-CYYl5H4mfZH8VihhCBJ60MMrZOlZla9qvb8EIP6GYRkEap4nhktbzGxW0Qu5r3edm6_Kg&quot;,
   &quot;title&quot;: &quot;蜘蛛侠&quot;
}, {
   &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6zDZeLtPIVlkRLCd_V6Mr2kTzWsCkfYgmS0-cqhFAOu4dUWGtx6d402_eKnObAOFUClEDdF4mrUeDQawE71DDa805umhbAvX2712i7UgYO5MA&quot;,
   &quot;title&quot;: &quot;钢铁侠&quot;
}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们继续调用api, 查询钢铁侠的电影信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/api/movies/CfDJ8D9KlbQBeipPoQwll5uLR6zDZeLtPIVlkRLCd_V6Mr2kTzWsCkfYgmS0-cqhFAOu4dUWGtx6d402_eKnObAOFUClEDdF4mrUeDQawE71DDa805umhbAvX2712i7UgYO5MA  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果也正确的返回了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[{&quot;id&quot;:4,&quot;title&quot;:&quot;钢铁侠&quot;}]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;带过期时间的数据保护器limited-lifetime&quot;&gt;带过期时间的数据保护器(Limited Lifetime)&lt;/h2&gt;
&lt;p&gt;.NET Core默认还提供了一种带过期时间的数据保护器, 这种数据保护器许多使用场景，最常用的场景就是当为一个重置密码操作的Token设置失效时间, 这样一旦超时的, Token就不能解密成功, 从而我们就可以认定重置密码操作超时了。&lt;/p&gt;
&lt;p&gt;.NET Core中, 我们可以使用&lt;code&gt;IDataProtector&lt;/code&gt;接口的&lt;code&gt;ToTimeLimitedDataProtector&lt;/code&gt;方法创建一个带过期时间的数据保护器。&lt;/p&gt;
&lt;p&gt;这里我们还是使用默认还是继续以上面的例子为例, 代码修改如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private readonly ITimeLimitedDataProtector protector;

    public MoviesController(IDataProtectionProvider provider)
    {
        this.protector = provider.CreateProtector(&quot;protect_my_query_string&quot;)
                 .ToTimeLimitedDataProtector();
    }

    [HttpGet]
    public IActionResult Get()
    {
        var model = GetMovies(); // simulate call to repository
        
        var outputModel = model.Select(item =&amp;gt; new
        {
            Id = this.protector.Protect(item.Id.ToString(), 
                                        TimeSpan.FromSeconds(10)),
            item.Title,
            item.ReleaseYear,
            item.Summary
        });

        return Ok(outputModel);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码解释-1&quot;&gt;代码解释&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;这里我们定义了一个&lt;code&gt;ITimeLimitedDataProtector&lt;/code&gt;接口对象protector, 并在构造函数中使用&lt;code&gt;ToTimeLimitedDataProtector&lt;/code&gt;方法，将一个普通的数据保护器转换成了一个带过期时间的数据保护器&lt;/li&gt;
&lt;li&gt;在获取Movie列表的api中, 我们依然使用&lt;code&gt;Protect&lt;/code&gt;方法来加密Id字段, 与之前不同的是，这里我们加入了第二个&lt;code&gt;TimeSpan&lt;/code&gt;参数，这个参数表示了当前加密的有效时间只有10秒。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;最终效果-1&quot;&gt;最终效果&lt;/h3&gt;
&lt;p&gt;现在我们重新运行项目，还是和之前一样先调用/api/movies方法来获取Movies列表, 结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[{
    &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6yzbDbZ931toH32VC6Jqg8DWsrmiLrOxOFFViH4QWZne43jwSVzBjzJIfctYKZniZKNVbr50RRIZpW2fe9UtPajEzBhI-H32Effm-F0ColUaA&quot;,
    &quot;title&quot;: &quot;泰坦尼克号&quot;
}, {
    &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6zDDVymvftZK9lKBIjEyuoNTzOEu0SC2-qfTy6quXir2S8f3A1r44f9Yz3Sd_cyLZUp-_4gfJAasMfE8_ngYLrJmdsjN9LZ0g4vox0WJLjiGA&quot;,
    &quot;title&quot;: &quot;我是谁&quot;
}, {
    &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6zL-M2jzv2HCeTiHjevkXvI2216NERplp43TOjCXtj4S52ll68sLyQNtG2FhhWlsOmFGvYY5G4gm5SKfASMMgE1jBr20xc2b_djWdLhWLIxnA&quot;,
    &quot;title&quot;: &quot;蜘蛛侠&quot;
}, {
    &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6wAoZKCHTG0lvgYS3If_0_eAD30a2YV8RjNagwLXUdCSKsO3kyS58hqDqAPHw_KHwNpd-hjDFl3hFPa8LOWHyk901oc6ZuSxwzxFlljaVreFA&quot;,
    &quot;title&quot;: &quot;钢铁侠&quot;
}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待10秒钟后，我们继续调用api, 查询钢铁侠的电影信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/api/movies/CfDJ8D9KlbQBeipPoQwll5uLR6wAoZKCHTG0lvgYS3If_0_eAD30a2YV8RjNagwLXUdCSKsO3kyS58hqDqAPHw_KHwNpd-hjDFl3hFPa8LOWHyk901oc6ZuSxwzxFlljaVreFA&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回了错误信息CryptographicException: The payload expired at 9/29/2018 11:25:05 AM +00:00. 这说明当前加密的有效期已过, 不能正确解密了。&lt;/p&gt;
&lt;h2 id=&quot;tips-使用action-filter解密参数&quot;&gt;Tips: 使用Action Filter解密参数&lt;/h2&gt;
&lt;p&gt;在之前的代码中，我们在获取单个Movie的方法中，我们手动调用了&lt;code&gt;Unprotected&lt;/code&gt;方法来解密id属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [HttpGet(&quot;{id}&quot;)]
    public IActionResult Get(string id)
    {
        var orignalId = int.Parse(this.protector.Unprotect(id));

        var model = GetMovies(); // simulate call to repository
        
        var outputModel = model.Where(item =&amp;gt; item.Id == orignalId);

        return Ok(outputModel);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们改用Action Filter来改进这部分代码。&lt;/p&gt;
&lt;p&gt;首先我们创建一个&lt;code&gt;DecryptReferenceFilter&lt;/code&gt;, 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class DecryptReferenceFilter : IActionFilter
    {
        private readonly IDataProtector protector;

        public DecryptReferenceFilter(IDataProtectionProvider provider)
        {
            this.protector = provider.CreateProtector(&quot;protect_my_query_string&quot;);
        }

        public void OnActionExecuting(ActionExecutingContext context)
        {
            object param = context.RouteData.Values[&quot;id&quot;].ToString();
            var id = int.Parse(this.protector.Unprotect(param.ToString()));
            context.ActionArguments[&quot;id&quot;] = id;
        }

        public void OnActionExecuted(ActionExecutedContext context)
        {

        }
    }

    public class DecryptReferenceAttribute : TypeFilterAttribute
    {
        public DecryptReferenceAttribute() :
            base(typeof(DecryptReferenceFilter))
        { }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码解释-2&quot;&gt;代码解释&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;这里&lt;code&gt;DecryptReferenceFilter&lt;/code&gt;实现了&lt;code&gt;IActionFilter&lt;/code&gt;接口, 并实现了&lt;code&gt;OnActionExecuting&lt;/code&gt;和&lt;code&gt;OnActionExecuted&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;DecryptReferenceFilter&lt;/code&gt;类中，我们注入了默认的数据保护器提供器，并在构造函数中初始化了一个数据保护器&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;OnActionExecuting&lt;/code&gt;中我们从&lt;code&gt;RouteData&lt;/code&gt;中获取到未解密的id字段, 然后将其解密之后，替换了之前未解密的id字段，这样ModelBinder就会使用解密后的字符串来绑定模型。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;最终修改&quot;&gt;最终修改&lt;/h3&gt;
&lt;p&gt;最后我们修改一下获取单个Movie的api, 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [HttpGet(&quot;{id}&quot;)]
    [DecryptReference]
    public IActionResult Get(int id)
    {
        var model = GetMovies();

        var outputModel = model.Where(item =&amp;gt; item.Id == id);

        return Ok(outputModel);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在获取单个Movie的方法上添加了&lt;code&gt;DecryptReference&lt;/code&gt;特性。&lt;br/&gt;运行代码之后，代码和之前的效果一样。&lt;/p&gt;
</description>
<pubDate>Sat, 29 Sep 2018 13:20:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>原文地址：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9726191.html</dc:identifier>
</item>
<item>
<title>Flask：01-三分钟入门Flask，多一分钟手把手带飞 - Sunwj_Monkey</title>
<link>http://www.cnblogs.com/swjblog/p/9726612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swjblog/p/9726612.html</guid>
<description>&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;视图函数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'&amp;lt;h1&amp;gt;Hello Flask!&amp;lt;/h1&amp;gt;'&lt;/span&gt;


&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/welcome/&amp;lt;name&amp;gt;/&amp;lt;uid&amp;gt;/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;welcome&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(name, uid)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'Hello {} {}'&lt;/span&gt;.format(name, uid)


&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/user/&amp;lt;int:uid&amp;gt;/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(uid)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'Hello {}号'&lt;/span&gt;.format(uid)


&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/path/&amp;lt;path:p&amp;gt;/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(p)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; p
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;1.路由末尾的'/'建议都加上，防止出现路由多敲'/'出现的问题
2.若需要路由参数，参数需要放在&amp;lt;&amp;gt;中，对应的视图函数需要同名的参数
3.路由参数可以指定多个，也可以指定类型
4.常用参数类型：str(默认)、int、float、path，使用时放在参数前面，使用':'与参数连接
5.path类型其实是str类型，只是将'/'作为普通字符处理罢了。
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;请求(request)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; request


&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/request/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; request.headers.get(&lt;span class=&quot;hljs-string&quot;&gt;'User-Agent'&lt;/span&gt;)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;响应(response)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; make_response


&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/response/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    
    
    
    
    
    resp = make_response(&lt;span class=&quot;hljs-string&quot;&gt;'这是通过函数构造的响应'&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;404&lt;/span&gt;)
    
    resp.headers[&lt;span class=&quot;hljs-string&quot;&gt;'uid'&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;250&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; resp
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;重定向(redirect)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; redirect, url_for


&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/old/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    
    
    
    
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; redirect(url_for(&lt;span class=&quot;hljs-string&quot;&gt;'new'&lt;/span&gt;))

&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/new/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'新的数据'&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;反向构造路由(url_for)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/urlfor/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;urlfor&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    
    
    
    
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; url_for(&lt;span class=&quot;hljs-string&quot;&gt;'user'&lt;/span&gt;, uid=&lt;span class=&quot;hljs-number&quot;&gt;250&lt;/span&gt;, name=&lt;span class=&quot;hljs-string&quot;&gt;'cuihua'&lt;/span&gt;, _external=&lt;span class=&quot;hljs-keyword&quot;&gt;True&lt;/span&gt;)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;终止及错误定制&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/abort/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    
    
    abort(&lt;span class=&quot;hljs-number&quot;&gt;404&lt;/span&gt;)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'正常'&lt;/span&gt;


&lt;span class=&quot;hljs-decorator&quot;&gt;@app.errorhandler(404)&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;page_not_found&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(e)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'是不是搞错了大哥？'&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
</description>
<pubDate>Sat, 29 Sep 2018 12:48:00 +0000</pubDate>
<dc:creator>Sunwj_Monkey</dc:creator>
<og:description>Flask入门 WEB工作原理 C/S与B/S架构：客户端-服务器，浏览器-服务器 B/S架构工作原理 客户端(浏览器) &lt;=&gt; WEB服务器(nginx) &lt;=&gt; WSGI(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/swjblog/p/9726612.html</dc:identifier>
</item>
<item>
<title>java之servlet学习基础（一） - 孙好烦</title>
<link>http://www.cnblogs.com/sy-deku/p/9726578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sy-deku/p/9726578.html</guid>
<description>&lt;p&gt;&lt;span&gt;这一阵子在学java三大框架。却在学习过程中发现前面的知识已经忘记了。所以决定写一篇博客来总结回顾之前的学习。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;1.Servlet是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　servlet是一个运行在服务器端的小应用程序。通过HTTP协议接受和相应来自Web客户端的请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　提到web客户端的请求和对web客户端的响应，必须了解HTTP协议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.HTTP协议&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　HTTP协议用于定义web浏览器（客户端）和web服务器（服务器端）之间交换数据的过程以及交换的数据的格式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;span&gt;（1）请求部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　请求部分包括请求消息行、请求消息头以及消息正文。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　请求消息行：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　请求方式　　URI　　协议/版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　[GET|POST]  uri　　　http/1.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　请求消息头&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　Accept-[Charset|Encoding|Language]：告诉服务器浏览器可接受的MIME类型（即客户端能接受什么类型的文件）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　Accept-Charset:客户端浏览器支持哪种字符集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　Accept-Encoding:客户端浏览器能进进行解码的数据编码方式。eg.gzip&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　Accept-Language:客户端浏览器希望接受的语言种类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　Host：初始URL中的主机和端口号&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　Referer:包含一个url，用户从该url代表的页面出发访问当前请求的页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　Content-Type:内容类型。告诉服务器，客户端浏览器传输数据的MIME类型（文件传输类型）.eg.application/x-www-form-urlencoded;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　User-Agent:浏览器类型;IE,Chrome&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　Content-Length:请求消息正文的长度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　Connection:表示是否需要持久连接。默认为Keep-Alive（持久连接）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　Cookie：设置服务器使用Set-Cookie发送的http cookie。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　Date：请求时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　消息正文：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　当请求方式是POST时，才能看到消息正文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　（2）响应部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　响应部分包括响应消息行、响应消息头和响应正文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　响应消息行：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　协议/版本　　响应状态码　　对响应状态码的描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　HTTP/1.1　　200　　　　　　OK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　响应状态码包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　200　　正常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　302/307　　重定向&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　304　　未修改（表示当前客户端缓存的版本是最新版）　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　404　　服务器上不存在客户端请求的资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　500　　服务器内部错误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　响应消息头：（常用）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　Location：指示新的资源的位置。通常和302/307一起使用完成请求重定向&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　Server：apache tomcat指示服务器的类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　Content-Encoding：gzip服务器发送的数据采用的编码类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　Content-Length：80 告知客户端浏览器响应正文的长度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　Content-Language：zh-cn 服务器发送的文本的语言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　Content-Type：text/html;charset=GB2312服务器发送的内容的MIME类型（文件的传输类型）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　Refresh：1；url=http://www.xxx.com指示客户端刷新的频率，单位为秒。可用于还剩几秒跳转页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　Content-Dispositation:attachment;filename=aaa.zip 告诉客户端这是要下载的文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　Set-Cookie：xx=xx 服务器端发送的Cookie&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　响应正文：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　在网页右键查看源码即可查看&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.Servlet生命周期&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　实例化-》初始化-》服务-》销毁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　出生：（实例化new-》初始化init）第一次访问servlet时出生&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　活着：（服务service）应用活着，servlet就活着&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　死亡：（销毁）应用卸载了，servlet就销毁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：可通过在注解@WebServlet中配置load-on-startup，使servlet在服务器启动时就创建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.Servlet的三种创建方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（1）实现javax.servlet.Servlet接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（2）继承javax.servlet.GenericServlet类（适配器模式）重写service方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　适配器模式，GenericSelvlet是个抽象类，只有service方法是抽象方法，其余的都已经实现了servlet的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（3）继承javax.servlet.http.HttpServlet类（模板方法设计模式） 常用。但注意不要重写servic()方法。只重写doGet()和doPost()即可。因为HttpServlet的service方法中使用的是doget和dopost方法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5.Serlvet配置url-pattern&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　匹配规则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　优先级：绝对匹配 &amp;gt; /开头匹配 &amp;gt; 扩展名方式匹配&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　绝对匹配是指没有使用通配符*，*代表任意字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　/* 任意字符都能识别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　*.字符串  以*.字符串结尾的请求都可以访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　/action/*   以/action开头的请求都可以访问&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　如果url-pattern的值是/，表示执行默认映射。所有的资源都可以访问。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6.Servlet的线程安全&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　Servlet只创建一次，销毁一次。每次访问都是多线程。所以有线程安全问题。所以不要写全局变量，只写局部变量，用户不共用变量。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;7.ServletConfig的使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用1：获取Servlet的配置信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;作用2：获得ServletContext对象&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 第一种方式获得配置信息，其实就是获得web.xml里面servlet标签下的init-param标签内的param-&lt;span&gt;value
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ServletConfig config;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init(ServletConfig config) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.config =&lt;span&gt; config;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 第二种方式获得config配置信息*/
&lt;span&gt; 8&lt;/span&gt;       String encoding = &lt;span&gt;this&lt;/span&gt;.getServletConfig().getInitParameter(&quot;encoding&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;第三种方式获得配置信息
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     String encoding = &lt;span&gt;this&lt;/span&gt;.getInitParameter(&quot;encoding&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为什么能使用this.get...是因为该类是继承了httpservlet，httpservlet继承了GenericServlet
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                                                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后GenericServlet的getIniParameter()返回servletconfig内的getinitParameter方法，所以
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                                                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;就可以直接调用。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 &lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;获取ServletContext对象&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; String name = (String) &lt;span&gt;this&lt;/span&gt;.getServletContext().getAttribute(&quot;name&quot;);&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;8.ServletContext&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　ServletContext代表的是整个应用。一个应用只有一个ServletContext对象。单实例。ServletContext对象实际上就是一个Map（setAttribute和getAttribute）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;常用方法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　域对象：setAttribute(sString , Object ) ,getAttribute(String ) ,rmoveAttribute(String)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　获取全局配置信息：getInitParameter(String )  根据配置文件中&amp;lt;context-param&amp;gt;标签下的name得到value&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　获取资源路径：getRealPath(String path)  根据资源名称得到资源的绝对路径。可以得到当前应用任何位置的任何资源。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　实现servlet的转发：getRequestDispatcher(String path); 参数表示要跳转到那里去。其实质就是请求转发。注意不是重定向。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 29 Sep 2018 12:37:00 +0000</pubDate>
<dc:creator>孙好烦</dc:creator>
<og:description>这一阵子在学java三大框架。却在学习过程中发现前面的知识已经忘记了。所以决定写一篇博客来总结回顾之前的学习。 1.Servlet是什么？ servlet是一个运行在服务器端的小应用程序。通过HTTP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sy-deku/p/9726578.html</dc:identifier>
</item>
<item>
<title>zookeeper-非常重要的zab协议-《每日五分钟搞定大数据》 - 大叔据</title>
<link>http://www.cnblogs.com/uncleData/p/9726566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/uncleData/p/9726566.html</guid>
<description>&lt;p&gt;上篇文章&lt;a href=&quot;https://www.cnblogs.com/uncleData/p/9708496.html&quot;&gt;paxos与一致性&lt;/a&gt;说到zab是在paxos的基础上做了重要的改造，解决了一系列的问题，这一篇我们就来说下这个zab。&lt;/p&gt;
&lt;p&gt;zab协议的全称是ZooKeeper Atomic Broadcast即zookeeper“原子”“广播”协议。它规定了两种模式：崩溃恢复和消息广播&lt;/p&gt;
&lt;h2 id=&quot;恢复模式&quot;&gt;恢复模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么时候进入？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当整个服务框架在启动过程中&lt;/li&gt;
&lt;li&gt;当Leader服务器出现网络中断崩溃退出与重启等异常情况&lt;/li&gt;
&lt;li&gt;当有新的服务器加入到集群中且集群处于正常状态（广播模式），新服会与leader进行数据同步，然后进入消息广播模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这三种情况ZAB都会进入恢复模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;干了什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选举产生新的Leader服务器，同时集群中已有的过半的机器会与该Leader完成状态同步，这些工作完成后，ZAB协议就会退出崩溃恢复模式&lt;/p&gt;
&lt;h2 id=&quot;广播模式&quot;&gt;广播模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么时候进入？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;集群状态稳定，有了leader且过半机器状态同步完成，退出崩溃恢复模式后进入消息广播模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;干了什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正常的消息同步，把日常产生数据从leader同步到learner的过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1491039/201809/1491039-20180929203118265-2054191905.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;总结一下zab协议规定的两种模式在实际操作中经历了三个步骤，如上图，下面我再详细地说下这两个过程都干了些什么&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;进入崩溃恢复模式说明集群目前是存在问题的了，那么此时就需要开始一个选主的过程。&lt;/p&gt;
&lt;p&gt;zookeeper使用的默认选主算法是FastLeaderElection，它是标准的Fast Paxos算法实现，可解决LeaderElection选举算法收敛速度慢的问题（上篇文章也有提到过）。&lt;/p&gt;
&lt;h2 id=&quot;zab协议规定的状态&quot;&gt;zab协议规定的状态&lt;/h2&gt;
&lt;p&gt;LOOKING 当前集群没有leader，准备选举&lt;br/&gt;FOLLOWING 已经存在leader，当前服务器为跟随者&lt;br/&gt;LEADING 唯一的领导，维护与Follower间的心跳&lt;br/&gt;OBSERVING 观察者状态。表明当前服务器角色是Observer&lt;/p&gt;
&lt;p&gt;投票流程&lt;/p&gt;
&lt;h2 id=&quot;投票的依据&quot;&gt;投票的依据&lt;/h2&gt;
&lt;p&gt;投票的依据就是下面的两个id，投票即是给所有服务器发送&lt;strong&gt;(myid,zxid)&lt;/strong&gt;信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;myid&lt;/strong&gt;：用户在配置文件中自己配置，每个节点都要配置的一个唯一值，从1开始往后累加。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;zxid&lt;/strong&gt;：zxid有64位，分成两部分：&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;高32位是Leader的epoch&lt;/strong&gt;：选举时钟，每次选出新的Leader，epoch累加1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;低32位是在这轮epoch内的事务id&lt;/strong&gt;：对于用户的每一次更新操作集群都会累加1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：zk把epoch和事务id合在一起，每次epoch变化，都将低32位的序号重置，这样做是为了方便对比出最新的数据，保证了zxid的全局递增性。（其实这样也会存在问题，虽然概率小，这里就先不说了后面的文章会详细讲）。&lt;/p&gt;
&lt;h2 id=&quot;关于发送选票&quot;&gt;关于发送选票&lt;/h2&gt;
&lt;p&gt;第一轮投给自己，之后每个服把上述所有信息发送给其他所有服，票箱中只会记录每一投票者的最后一票&lt;/p&gt;
&lt;h2 id=&quot;关于接收投票&quot;&gt;关于接收投票&lt;/h2&gt;
&lt;p&gt;服务器会尝试从其它服务器获取投票，并记入自己的投票箱内。如果无法获取任何外部投票，则会确认自己是否与集群中其它服务器保持着有效连接。如果是，则再次发送自己的投票；如果否，则马上与之建立连接。&lt;/p&gt;
&lt;h2 id=&quot;关于选举轮次&quot;&gt;关于选举轮次&lt;/h2&gt;
&lt;p&gt;由于所有有效的投票都必须在同一轮次中。每开始新一轮投票自身的logicClock自增1。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接收到的logicClock大于自己的。说明自己落后了，更新logicClock后正常。&lt;/li&gt;
&lt;li&gt;接收到的logicClock小于自己的。忽略该票。&lt;/li&gt;
&lt;li&gt;接收到的logickClock与自己的相等，正常判断。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;关于选票判断&quot;&gt;关于选票判断&lt;/h2&gt;
&lt;p&gt;对比自身的和接收到的(myid,zxid)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先对比zxid高32位的选举时钟epoch&lt;/li&gt;
&lt;li&gt;一致则对比zxid低32的事务id&lt;/li&gt;
&lt;li&gt;仍然一致则对比用户自己配置的myid&lt;br/&gt;选完后广播选出的(myid,zxid)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于选举结束&lt;br/&gt;过半服务器选了同一个，则投票结束，根据投票结果更新自身状态为leader或者follower&lt;/p&gt;
&lt;h2 id=&quot;还有两个问题&quot;&gt;还有两个问题&lt;/h2&gt;
&lt;p&gt;上面说过zookeeper是一个原子广播协议，在这个崩溃恢复的过程就体现了它的原子性，zookeeper在选主过程保证了两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;commit过的数据不丢失&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;未commit过的数据丢弃&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(myid,zxid)的选票设计刚好解决了这两个问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;commit过的数据半数以上参加选举的follwer都有，而且成为leader的条件是要有最高事务id即数据是最新的。&lt;/li&gt;
&lt;li&gt;未commit过的数据只存在于leader，但是leader宕机无法参加首轮选举，epoch会小一轮，最终数据会丢弃。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1491039/201809/1491039-20180929202817472-126140210.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，client端发起请求，读请求由follower和observer直接返回，写请求由它们转发给leader。&lt;/p&gt;
&lt;p&gt;Leader 首先为这个事务分配一个全局单调递增的唯一事务ID (即 ZXID )。&lt;/p&gt;
&lt;p&gt;然后发起proposal给follower，Leader 会为每一个 Follower 都各自分配一个单独的队列，然后将需要广播的事务 Proposal 依次放入这些队列中去，并且根据 FIFO策略进行消息发送。&lt;/p&gt;
&lt;p&gt;每一个 Follower 在接收到这个事务 Proposal 之后，都会首先将其以事务日志的形式写入到本地磁盘中去，并且在成功写入后反馈给 Leader 服务器一个 Ack 响应。&lt;/p&gt;
&lt;p&gt;当 Leader 服务器接收到超过半数 Follower 的 Ack 响应后，就会广播一个Commit 消息给所有的 Follower 服务器以通知其进行事务提交，同时&lt;br/&gt;Leader 自身也会完成对事务的提交。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/uncleData/p/9678956.html&quot;&gt;zookeeper-操作与应用场景-《每日五分钟搞定大数据》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/uncleData/p/9672696.html&quot;&gt;zookeeper-架构设计与角色分工-《每日五分钟搞定大数据》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/uncleData/p/9708496.html&quot;&gt;zookeeper-paxos与一致性-《每日五分钟搞定大数据》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近这几篇理论性的东西太多，下一篇写点简单的代码，zookeeper分布式锁的实现。感谢阅读。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1491039/201809/1491039-20180929202750189-71365630.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Sep 2018 12:30:00 +0000</pubDate>
<dc:creator>大叔据</dc:creator>
<og:description>上篇文章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/uncleData/p/9726566.html</dc:identifier>
</item>
<item>
<title>golang 项目实战简明指南 - _toby</title>
<link>http://www.cnblogs.com/tobycnblogs/p/9726461.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tobycnblogs/p/9726461.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://litang.me/post/golang-project-guide/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;开发环境搭建&quot;&gt;开发环境搭建&lt;/h3&gt;
&lt;p&gt;golang 的开发环境搭建比较简单，由于是编译型语言，写好 golang 源码后，只需要执行 &lt;code&gt;go build&lt;/code&gt; 就能将源码编译成对应平台(本文中默认为 linux)上的可执行程序。本文不再赘述如何搭建 golang 开发环境，只说明下需要注意的地方。&lt;br/&gt;从官网下载对应平台的 golang 安装包中包括 golang 的编译器、一些工具程序和标准库源码。早期的 golang 版本中，需要设置 &lt;code&gt;GOROOT&lt;/code&gt; 和 &lt;code&gt;GOPATH&lt;/code&gt; 两个环境变量。&lt;br/&gt;从 1.8 版开始，&lt;code&gt;GOPATH&lt;/code&gt; 不再需要显示设置。如果没有显示设置，则 &lt;code&gt;GOPATH&lt;/code&gt; 的默认值为 &lt;code&gt;$HOME/go&lt;/code&gt; 。&lt;code&gt;GOPATH&lt;/code&gt; 可以设置多个目录，但推荐只设置一个或直接使用默认值，多个 &lt;code&gt;GOPATH&lt;/code&gt; 会造成依赖管理的困难。推荐将 &lt;code&gt;$GOPATH/bin&lt;/code&gt; 加到 &lt;code&gt;$PATH&lt;/code&gt; 里，这样通过 &lt;code&gt;go install&lt;/code&gt; 会安装到 &lt;code&gt;$GOPATH/bin&lt;/code&gt; 目录的可执行程序可以像系统命令一样直接运行，不用输入完整路径。&lt;br/&gt;从 1.10 版开始, &lt;code&gt;GOROOT&lt;/code&gt; 也不再需要显示设置了，只需要将安装包中的 bin 目录加到 &lt;code&gt;$PATH&lt;/code&gt; 里，系统会自动推导出 &lt;code&gt;GOROOT&lt;/code&gt; 的值。&lt;br/&gt;编辑器根据个人喜好选择，作者主要使用 vim 和 vscode 。&lt;a href=&quot;https://studygolang.com/articles/1785&quot;&gt;这里&lt;/a&gt;介绍了使用 vim 时需要安装的插件(安装过程可能需要FQ，YCM 安装比较复杂可以不要，gocode 够用了)。&lt;/p&gt;
&lt;h3 id=&quot;hello-world&quot;&gt;hello world&lt;/h3&gt;
&lt;p&gt;以下是 golang 版本的 hello world：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
)

func main() {
    fmt.Println(&quot;hello world&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;golang 安装包自带的 gofmt 能将源码格式化成官方推荐的风格，建议将这个工具整合到编辑器里。&lt;br/&gt;这个简单的程序用 go build 编译出来可执行程序用 ldd 查看发现没有任何动态库依赖，size 也比较大(1.8M ，对等的 C 程序版本只有 7.5K)。实际上这里也体现了 golang 的哲学：直接通过源代码分发软件，所有的代码编到一整个可执行程序里，基本没有动态库依赖(或者只依赖 C/C++ 运行时库和基本的系统库)，这也方便了 docker 化(C/C++ 程序员应试能体会动态库依赖有多恶心)。通过 readelf 查看可执行程序会发现代码段和调试信息段占用了比较大的空间，代码段大是因为 golang 的运行时也在里面。调试信息段方便 golang 进程 panic 时会打印详细的进程堆栈及源码信息，这也是为什么 golang 的可执行程序比较大的原因。&lt;/p&gt;
&lt;h3 id=&quot;命名规范&quot;&gt;命名规范&lt;/h3&gt;
&lt;p&gt;golang 的标准库提供了 golang 程序命名规范很好的参考标准，命名规范应该尽量和标准库的风格接近，多看下标准库的代码就能体会到 golang 的命名哲学了。&lt;br/&gt;命名在很大程序上也体现了一名程序员的修养，用好的命名写出的代码通常是自注释的，只需要在有复杂的逻辑需要解释的情况下才额外注释。&lt;br/&gt;好的命名应该具有以下特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一致性：见名知义，比如标准库中将对象序列化成字符串的操作名为 &lt;code&gt;String&lt;/code&gt; ，在你自己的代码里将自定义类型的对象序列化成字符串也应该叫这个名字，并且签名和标准库要一致；&lt;/li&gt;
&lt;li&gt;简明精炼：减少敲键盘的次数；&lt;/li&gt;
&lt;li&gt;精确性：不要使用有歧义的命名。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Tip: 通常变量的作用域越广，变量的名字应该越长，反之亦然。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;golang 中一般使用驼峰命名法，尽量不要使用下划线(基本只在全大写的常量命名中使用)。首字母缩略词应该全部大写，比如 &lt;code&gt;ServeHTTP&lt;/code&gt; , &lt;code&gt;IDProcessor&lt;/code&gt; 。&lt;br/&gt;本文中出现的&lt;strong&gt;必须&lt;/strong&gt;、 &lt;strong&gt;禁止&lt;/strong&gt;是指强烈推荐的 golang 风格的规范，但违反这个规范并不会导致程序编译不过。&lt;/p&gt;
&lt;h4 id=&quot;常量&quot;&gt;常量&lt;/h4&gt;
&lt;p&gt;全大写或者驼峰命名都可以，全大写的情况下可使用下划线分隔单词：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;const (
    SEEK_SET int = 0 // seek relative to the origin of the file
    SEEK_CUR int = 1 // seek relative to the current offset
    SEEK_END int = 2 // seek relative to the end
)

const (
    MaxInt8   = 1&amp;lt;&amp;lt;7 - 1
    MinInt8   = -1 &amp;lt;&amp;lt; 7
    MaxInt16  = 1&amp;lt;&amp;lt;15 - 1
    MinInt16  = -1 &amp;lt;&amp;lt; 15
    MaxInt32  = 1&amp;lt;&amp;lt;31 - 1
    MinInt32  = -1 &amp;lt;&amp;lt; 31
    MaxInt64  = 1&amp;lt;&amp;lt;63 - 1
    MinInt64  = -1 &amp;lt;&amp;lt; 63
    MaxUint8  = 1&amp;lt;&amp;lt;8 - 1
    MaxUint16 = 1&amp;lt;&amp;lt;16 - 1
    MaxUint32 = 1&amp;lt;&amp;lt;32 - 1
    MaxUint64 = 1&amp;lt;&amp;lt;64 - 1
)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;局部变量&quot;&gt;局部变量&lt;/h4&gt;
&lt;p&gt;通过以下代码片断举例说明局部变量的命名原则：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func RuneCount(buffer []byte) int {
    runeCount := 0
    for index := 0; index &amp;lt; len(buffer); {
        if buffer[index] &amp;lt; RuneSelf {
            index++
        } else {
            _, size := DecodeRune(buffer[index:])
            index += size
        }
        runeCount++
    }
    return runeCount
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;惯用的变量名应该尽可能短：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 &lt;code&gt;i&lt;/code&gt; 而不是 &lt;code&gt;index&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;r&lt;/code&gt; 而不是 &lt;code&gt;reader&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;b&lt;/code&gt; 而不是 &lt;code&gt;buffer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这几个字母在 golang 中有约定俗成的含义，使用单字母名字是更 golang 的方式(可能在其他语言的规范中是反例)，其他可以举一反三。&lt;br/&gt;变量名中不要有冗余的信息，在函数 &lt;code&gt;RuneCount&lt;/code&gt; 里，计数器命名就不需再把 &lt;code&gt;rune&lt;/code&gt; 包含进来了，直接用 &lt;code&gt;count&lt;/code&gt; 就好了。&lt;br/&gt;在判断 Map 中是否存在某个键值或者接口的转型操作里，通常用 &lt;code&gt;ok&lt;/code&gt; 来接收判断结果：&lt;code&gt;v, ok := m[k]&lt;/code&gt;。&lt;br/&gt;上文中的示例代码按照以上原则重构后应该是这个样子：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func RuneCount(b []byte) int {
    count := 0
    for i := 0; i &amp;lt; len(b); {
        if b[i] &amp;lt; RuneSelf {
            i++
        } else {
            _, n := DecodeRune(b[i:])
            i += n
        }
        count++
    }
    return count
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;形参&quot;&gt;形参&lt;/h4&gt;
&lt;p&gt;形参的命名原则和局部变量一致。另外 golang 软件是以源代码形式发布的，形参连同函数签名通常会作为接口文档的一部分，所以形参的命名规范还有以下特点。&lt;br/&gt;如果形参的类型已经能明确说明形参的含义了，形参的名字就可以尽量简短：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func AfterFunc(d Duration, f func()) *Timer

func Escape(w io.Writer, s []byte)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果形参类型不能说明形参的含义，形参的命名则应该做到见名知义：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func Unix(sec, nsec int64) Time

func HasPrefix(s, prefix []byte) bool&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;返回值&quot;&gt;返回值&lt;/h4&gt;
&lt;p&gt;跟形参一样，可导出函数的返回值也是接口文档的一部分，所以可导出函数的必须使用命名返回值：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func Copy(dst Writer, src Reader) (written int64, err error)

func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;接收器receivers&quot;&gt;接收器(Receivers)&lt;/h4&gt;
&lt;p&gt;习惯上接收器的命名命名一般是 1 到 2 个字母的接收器类型的缩写：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (b *Buffer) Read(p []byte) (n int, err error)

func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request)

func (r Rectangle) Size() Point&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同个类型的不同方法中接收器命名要保持一致，不要在一个方法中叫 &lt;code&gt;r&lt;/code&gt; ，在另一个方法中又变成了 &lt;code&gt;rdr&lt;/code&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;包级导出名&quot;&gt;包级导出名&lt;/h4&gt;
&lt;p&gt;包导出的变量、常量、函数、类型使用时有包名的修饰。这些导出名字里就不再需要包含包名的信息了，所以标准库中 &lt;code&gt;bytes&lt;/code&gt; 包里的 &lt;code&gt;Buffer&lt;/code&gt; 不需要叫 &lt;code&gt;BytesBuffer&lt;/code&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;接口&quot;&gt;接口&lt;/h4&gt;
&lt;p&gt;只有 1 个方法的接口名通常用方法名加上 &lt;code&gt;er&lt;/code&gt; 后缀，不引起迷惑的前提下方法名可以使用缩写：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Reader interface {
    Read(p []byte) (n int, err error)
}

type Execer interface {
    Exec(query string, args []Value) (Result, error)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法名本身是复合词的情况下，可以酌情调整以符合英文文法：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type ByteReader interface {
    ReadByte() (c byte, err error)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果接口有多个方法，则需要选择一个最能精确概括描述接口目的的名词命名(有点难度)，但是禁止用多个方法中的某个方法加上 &lt;code&gt;er&lt;/code&gt; 后缀来命名，否则别人会误解此接口只有一个方法。可以参考标准库这几个接口所包含的方法及接口的命名：&lt;code&gt;net.Conn&lt;/code&gt;, &lt;code&gt;http.ResponseWriter&lt;/code&gt;, &lt;code&gt;io.ReadWriter&lt;/code&gt; 。&lt;br/&gt;&lt;code&gt;Read&lt;/code&gt;, &lt;code&gt;Write&lt;/code&gt;, &lt;code&gt;Close&lt;/code&gt;, &lt;code&gt;Flush&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt; 这几个方法在标准库里已经有约定俗成的含义和签名。自定义的接口方法应该要避免使用这几个名字，除非方法的行为确实和标准库这几个接口方法一致，这时候可以使用这些名字，但必须要确保方法的签名和标准库一致。序列化成字符串的方法命名成 &lt;code&gt;String&lt;/code&gt; 而不是 &lt;code&gt;ToString&lt;/code&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;错误&quot;&gt;错误&lt;/h4&gt;
&lt;p&gt;自定义错误类型以 &lt;code&gt;Error&lt;/code&gt; 作为后缀，采用 &lt;code&gt;XyzError&lt;/code&gt; 的格式命名：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type ExitError struct {
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;错误值以 &lt;code&gt;Err&lt;/code&gt; 作为前缀，采用 &lt;code&gt;ErrXyz&lt;/code&gt; 的格式命名：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var ErrFormat = errors.New(&quot;image: unknown format&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;错误描述全部小写，未尾不需要加结束句点。&lt;/p&gt;
&lt;h4 id=&quot;gettersetter&quot;&gt;Getter/Setter&lt;/h4&gt;
&lt;p&gt;struct 的首字母大写的字段是导出字段，可以直接读写不需要 Getter/Setter ，首字母小写的字段是私有字段，必要的情况下可以增加读写私有字段的 Getter/Setter 方法。私有字段首字母变大写即为 Getter 方法名字，不需要加 &lt;code&gt;Get&lt;/code&gt; 前缀。私有字段首字母变大写加上 &lt;code&gt;Set&lt;/code&gt; 前缀即为 Setter 方法名字。例如 struct 中名为 &lt;code&gt;obj&lt;/code&gt; 的私有字段，其 Getter/Setter 方法命名分别为 &lt;code&gt;Obj&lt;/code&gt;/&lt;code&gt;SetObj&lt;/code&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;包&quot;&gt;包&lt;/h4&gt;
&lt;p&gt;包名使用纯小写、能精确描述包功能且精炼的名词(有点难度)，不带下划线，不引起迷惑的前提下可以用缩写，比如标准库的 &lt;code&gt;strconv&lt;/code&gt; 。如果包名比较复杂出现了多个单词，就应该考虑是不是要分层了，参考标准库的 &lt;code&gt;crypto/md5&lt;/code&gt;, &lt;code&gt;net/http/cgi&lt;/code&gt; 等包。包名应该要和包所在目录名一致，比如标准库的 &lt;code&gt;src/encoding/base64&lt;/code&gt; 目录下，源文件的包名为 &lt;code&gt;base64&lt;/code&gt; 。避免以下命名：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;和标准库同名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;util&lt;/code&gt;, &lt;code&gt;common&lt;/code&gt; 等太过笼统的名字&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;包路径&quot;&gt;包路径&lt;/h4&gt;
&lt;p&gt;包路径的最底层路径名和包名一致：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;&quot;compress/gzip&quot; // gzip 路径下源文件的的包名也为 gzip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;包路径有良好的层级关系但要避免重复罗嗦：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;&quot;code.google.com/p/goauth2/oauth2&quot; // bad, goath2 和 oauth2 重复罗嗦&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不是所有平台的文件系统都是大小敏感的，包路径名不要有大写字母：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;&quot;github.com/Masterminds/glide&quot; // bad&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在导入包路径时，按照标准库包、第三方库包、项目内部包的顺序导入，各部分用空行隔开：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;import (
    &quot;encoding/json&quot;
    &quot;strconv&quot;
    &quot;time&quot;

    &quot;github.com/golang/protobuf/proto&quot;
    &quot;github.com/gomodule/redigo/redis&quot;

    &quot;dc_agent/attr&quot;
    &quot;dc_agent/dc&quot;
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;禁止使用相对路径导入包：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;import (
    &quot;./attr&quot; // bad
)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;项目代码布局&quot;&gt;项目代码布局&lt;/h3&gt;
&lt;p&gt;开发 golang 库时如何组织项目代码可以参考 golang 的标准库。开发应用程序和开发库在工程实践上还是有点不同。有一些开源项目把所有的代码都放在一个包里 (main) ，项目比较小时还能接受，项目比较大时就难以阅读了。golang 的项目代码布局目前业界也没有一个统一的标准。&lt;a href=&quot;https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1&quot;&gt;这篇文章&lt;/a&gt;讨论了几种布局方案缺陷，然后提出了一些建议。&lt;a href=&quot;http://peter.bourgon.org/go-best-practices-2016/#dependency-management&quot;&gt;这篇文章&lt;/a&gt;在此基础上给出了一个可操作的方案，这也是本文推荐的方案。以下以 &lt;code&gt;xauth&lt;/code&gt; 项目为例说明。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git.yingzhongtong.com/combase/xauth # 项目根目录
├── cmd                             # cmd 目录存放可执行文件(binary)代码
│   ├── client                      # binary: client 不同的可执行程序各自建立目录存放
│   │   └── main.go
│   └── xauth                       # binary: xauth
|       ├── main.go
│       ├── config                  # 编译当前可执行程序需要的内部库组织成不同包各自建立目录存放
│       │   └── config.go
│       ├── handler
│       │   └── handler.go
│       ├── httpproxy
│       │   └── httpproxy.go
│       └── zrpcproxy
│           └── zrpcproxy.go
├── pkg                             # pkg 目录存放库代码
│   ├── model                       # package: model 不同库组织成不同包，各自建一个目录存放
│   │   └── contract.go
│   ├── ratelimiter                 # package: ratelimiter
│   │   ├── inmemory.go
│   │   ├── inmemory_test.go
│   │   ├── ratelimiter.go
│   │   ├── redis.go
│   │   └── redis_test.go
│   └── version                     # package: version
│       └── version.go
├── glide.lock                      # 项目依赖库文件
├── glide.yaml
├── Makefile
├── README.md                       # 项目说明文档
├── Dockerfile                      # 用来创建 docker 镜像
└── xauth.yaml                      # 项目配置&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种布局特别适合既有可执行程序又有库的复杂项目。主要规范是在项目根目录下建立 &lt;code&gt;cmd&lt;/code&gt; 和 &lt;code&gt;pkg&lt;/code&gt; 目录。&lt;code&gt;cmd&lt;/code&gt; 目录下存放编译可执行文件的代码。通常一个复杂项目可能会有多个可执行程序，每个可执行程序的代码在 &lt;code&gt;cmd&lt;/code&gt; 目录各建立目录存放。比如 &lt;code&gt;git.yingzhongtong.com/combase/xauth/cmd/xauth&lt;/code&gt; 下是编译可执行文件 &lt;code&gt;xauth&lt;/code&gt; 的源码。编译 &lt;code&gt;xauth&lt;/code&gt; 需要使用的内部库直接在 &lt;code&gt;git.yingzhongtong.com/combase/xauth/cmd/xauth&lt;/code&gt; 建立目录存放。多个可执行程序都需要用到的公共库应该放到项目根目录下的 &lt;code&gt;pkg&lt;/code&gt; 目录里。根目录的 &lt;code&gt;pkg&lt;/code&gt; 目录下每个目录都是一个单独的公共库。&lt;br/&gt;建议项目根目录下放一个 &lt;code&gt;Makefile&lt;/code&gt; 文件，方便一键编译出所有可执行程序。&lt;br/&gt;总之，这种布局的主要思想是按功能模块划分库，区分私有库和公共库，分别放在不同层级别的目录里。使用这种布局编写代码时，通常可执行程序对应的 main 包一般只有一个 &lt;code&gt;main.go&lt;/code&gt; 文件，而且这个文件通常代码很少，基本就是把需要用到的库拼到一起。 github 的&lt;a href=&quot;https://github.com/thockin/go-build-template&quot;&gt;这个项目&lt;/a&gt;提供了这种布局的模板，可以 clone 下来直接使用(有些文件需要适当调整下)。&lt;br/&gt;github 上很多优秀的开源项目也是采用的这种布局，熟悉这种布局也能帮助你更好的阅读这些开源项目。&lt;br/&gt;以上介绍的项目代码布局是开发大型项目时强烈建议的方案。如果是小型项目代码量很少，直接放在一个目录里也是可以接受的。&lt;/p&gt;
&lt;h3 id=&quot;依赖管理&quot;&gt;依赖管理&lt;/h3&gt;
&lt;p&gt;golang 早期版本中，依赖管理比较简单，依赖的第三方库通过 &lt;code&gt;go get&lt;/code&gt; 下载到 &lt;code&gt;GOPATH&lt;/code&gt; 中，编译时会根据 import 的路径去 &lt;code&gt;GOPATH&lt;/code&gt; 和 &lt;code&gt;GOROOT&lt;/code&gt; 中查找依赖的库。这种方式虽然简单，但是也有很多缺陷：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对依赖的第三方库没有版本管理，每次 go get 时都是下载最新的版本，最新的版本可能存在 bug；&lt;/li&gt;
&lt;li&gt;基于域名的第三方库路径可能失效；&lt;/li&gt;
&lt;li&gt;多个项目依赖共同的第三方库时，一个项目更新依赖库会影响其他项目。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;golang 从 1.6 版本开始引入了 &lt;code&gt;vendor&lt;/code&gt; 用来管理第三方库。&lt;code&gt;vendor&lt;/code&gt; 是项目根目录下的一个特殊目录，&lt;code&gt;go doc&lt;/code&gt; 会忽略这个目录。编译时会优先从 &lt;code&gt;vendor&lt;/code&gt; 目录中查找依赖的第三方库，找不到时再去 &lt;code&gt;GOPATH&lt;/code&gt; 和 &lt;code&gt;GOROOT&lt;/code&gt; 中查找。&lt;br/&gt;&lt;code&gt;vendor&lt;/code&gt; 机制解决上述的第 2 个和第 3 个缺陷，因此强烈建议工程实践中将项目的第三方库(所有本项目之外的库，包括开源库及公司级的公共库)全部放到 &lt;code&gt;vendor&lt;/code&gt; 中管理。使用这种方式， &lt;code&gt;GOPATH&lt;/code&gt; 存在的意义基本很小了，这也是上文中提到 &lt;code&gt;GOPATH&lt;/code&gt; 只需要设置 1 个目录或者干脆使用默认值的原因。&lt;br/&gt;&lt;code&gt;vendor&lt;/code&gt; 机制支持嵌套使用，即 &lt;code&gt;vendor&lt;/code&gt; 中的第三方库中也可以有 &lt;code&gt;vendor&lt;/code&gt; 目录，但这样做会导致更复杂的依赖链甚至循环依赖，而且目前也没有完美的解决方案。因此只有在开发可执行程序项目时才需要使用 &lt;code&gt;vendor&lt;/code&gt; 。开发库时禁止使用 &lt;code&gt;vendor&lt;/code&gt; 。&lt;br/&gt;&lt;code&gt;vendor&lt;/code&gt; 机制并没有解决上述的依赖库版本管理问题，并且目前官方也没有提供配套的工具。可以使用开源的第三方工具解决这个问题，推荐 &lt;a href=&quot;https://github.com/Masterminds/glide&quot;&gt;glide&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/tools/godep&quot;&gt;godep&lt;/a&gt; 。使用教程参考官方文档，这里就不赘述了。&lt;br/&gt;使用 &lt;code&gt;vendor&lt;/code&gt; 时要注意，项目中的 &lt;code&gt;vendor&lt;/code&gt; 目录不要提交到代码仓库中，但是第三方工具生成的依赖库列表文件必须提交，比如 glide 生成的 &lt;code&gt;glide.lock&lt;/code&gt; 和 &lt;code&gt;glide.yaml&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;可执行程序版本管理&quot;&gt;可执行程序版本管理&lt;/h3&gt;
&lt;p&gt;有时候生产环境跑的可执行程序可能有问题需要找到对应的源码进行定位。如果发布系统也没有把源码信息和可执行程序关联的话，可能根本找不到可执行程序是哪个版本的源码编译出来的。因此建议在可执行程序中嵌入版本和编译信息，程序启动时可以直接作为启动信息打印。&lt;br/&gt;版本号建议采用通用的 3 级点分字符串形式： &lt;code&gt;&amp;lt;大版本号&amp;gt;.&amp;lt;小版本号&amp;gt;.&amp;lt;补丁号&amp;gt;&lt;/code&gt;，比如 &lt;code&gt;0.0.1&lt;/code&gt; 。简单的 2 级也可以。使用 git 的话可以把 git commit SHA (通过 &lt;code&gt;git rev-parse --short HEAD&lt;/code&gt; 获取)作为 build id 。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

var (
    version string
    commit  string
)

func main() {
    println(&quot;demo server version:&quot;, version, &quot;commit:&quot;, commit)
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上示例代码中，&lt;code&gt;version&lt;/code&gt; 和 &lt;code&gt;commit&lt;/code&gt; 变量可以在源码中硬编码设置。更优雅的方式是在编译脚本(Makefile)里通过环境变量设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;VERSION = &quot;0.0.1&quot;
COMMIT = $(shell git rev-parse --short HEAD)

all :
    go build -ldflags &quot;-X main.version=$(VERSION) -X main.commit=$(COMMIT)&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;性能剖析profiling&quot;&gt;性能剖析(profiling)&lt;/h3&gt;
&lt;p&gt;程序的性能通常和使用的范式、算法、语言特性有关。在性能敏感的场景下，需要使用性能剖析工具分析进程的瓶颈所在，进而针对性的优化。golang 自带了性能剖析工具 pprof ，可以方便的剖析 golang 程序的时间/空间运行性能，以下是从某项目中部分代码改编后的示例代码，用来说明 pprof 的使用。直观上似乎函数 &lt;code&gt;bar&lt;/code&gt; 里有更多的计算，调用函数 &lt;code&gt;bar&lt;/code&gt; 应该比调用函数 &lt;code&gt;foo&lt;/code&gt; 占用更多的 CPU 时间，实际情况却并非如此。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// test.go

package main

import (
    &quot;net/http&quot;
    _ &quot;net/http/pprof&quot;
)

func foo() []byte {
    var buf [1000]byte
    return buf[:10]
}

var c int

func bar(b []byte) {
    c++
    for i := 0; i &amp;lt; len(b); i++ {
        b[i] = byte(c*i*i*i + 4*c*i*i + 8*c*i + 12*c)
    }
}

func main() {
    go http.ListenAndServe(&quot;:8200&quot;, nil)
    for {
        b := foo()
        bar(b)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后台程序一般是 HTTP 常驻服务(如果不是 HTTP 服务的话也可以直接在代码里启动一个)，import 列表里加上 &lt;code&gt;_ &quot;net/http/pprof&quot;&lt;/code&gt; 后，程序启动后 golang 运行时就会定时对进程运行状态采样，采样到的数据可能通过 HTTP 接口获取。还有一种方式是使用 &lt;code&gt;&quot;runtime/pprof&quot;&lt;/code&gt; 包，在需要剖析的程序代码里插入启动采样代码将，采样数据写到本地文件用来分析，具体使用方式参考&lt;a href=&quot;https://golang.org/pkg/runtime/pprof/&quot;&gt;这里&lt;/a&gt;。原理和第一种方式一样，只是采样数据读取方式不一样。&lt;br/&gt;启用运行时采样后，以下命令通过 HTTP 接口获取一段时间内(5 秒)的采样数据进行分析，然后进入命令行交互模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# go tool pprof http://localhost:8200/debug/pprof/profile?seconds=5

(pprof) top
Showing nodes accounting for 4990ms, 100% of 4990ms total
      flat  flat%   sum%        cum   cum%
    3290ms 65.93% 65.93%     3290ms 65.93%  runtime.duffzero
    1540ms 30.86% 96.79%     1540ms 30.86%  main.bar
     110ms  2.20% 99.00%     3400ms 68.14%  main.foo (inline)
      50ms  1.00%   100%     4990ms   100%  main.main
         0     0%   100%     4990ms   100%  runtime.main&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 top 命令会打印前 10 个最耗时的调用(top20 打印前20个，依此类推)，从输出的信息可以看出大部分 CPU 耗时在 &lt;code&gt;runtime.duffzero&lt;/code&gt; 调用上。这种命令行方式的输出不是很直观，看不出这个调用的来源是哪里。pprof 也支持可视化输出，不过需要安装 &lt;a href=&quot;https://www.graphviz.org/&quot;&gt;graphivz&lt;/a&gt; 绘图工具，centos 下可以通过以下命令安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# sudo yum install graphviz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 HTTP 接口采样 5 秒钟的 CPU 性能数据生成 PNG 格式(通过 &lt;code&gt;-png&lt;/code&gt; 选项开启)的性能剖析图并保存到文件 &lt;code&gt;cpupprof.png&lt;/code&gt; 里：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# go tool pprof -png http://localhost:8200/debug/pprof/profile?seconds=5 &amp;gt; cpupprof.png&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的性能剖析图如下：&lt;br/&gt;&lt;img src=&quot;http://pf6zo0htu.bkt.clouddn.com/cpupprof.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出调用函数 &lt;code&gt;foo&lt;/code&gt; 占用的 CPU 时间要远大于调用函数 &lt;code&gt;bar&lt;/code&gt; 的(耗时占比越大，表示调用的箭头线段也越粗)，并且在函数 &lt;code&gt;foo&lt;/code&gt; 的耗时主要又耗在调用 &lt;code&gt;runtime&lt;/code&gt; 的函数 &lt;code&gt;duffzero&lt;/code&gt; 上。虽然这是 golang 的内置函数，但看名字基本上已经能猜到性能瓶颈出在哪里了，这样就可以进行有针对性的优化。这里不解释为什么调用函数 &lt;code&gt;foo&lt;/code&gt; 占用的 CPU 时间会远大于调用函数 &lt;code&gt;bar&lt;/code&gt;的，留给读者思考。&lt;br/&gt;以上这个示例也说明了优化 CPU 性能关键是要找到影响整个系统的瓶颈，对于一个只占系统总耗时 1% 的函数，就算优化 10 倍意义也没什么意义。&lt;br/&gt;大多数情况下 golang 后台应用性能剖析只需要优化 CPU 占用耗时就可以了。 golang 是自带垃圾回收(GC)的语言，由于 GC 的复杂性，和程序员自己管理内存的 C 语言相比，这类语言一般占用内存都比较大。自带 GC 语言很少会有内存泄露问题，不过也有一种特殊场景的内存泄漏：比如往一个全局的切片里不断 append 数据又不自行清理，这种一般是程序有逻辑错误引起的。pprof 也可以在运行时对对象占用内存进行分析：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# go tool pprof -png http://localhost:8200/debug/pprof/heap &amp;gt; memused.png&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上命令输出的是对象占用空间的视图，默认只有 512KB 以上的内存分配才会写到内存分析文件里，因此建议在程序开始时加上以下代码让每个内存分配都写到到内存分析文件：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    runtime.MemProfileRate = 1 // 修改默认值 512KB 为 1B
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;-inuse_objects&lt;/code&gt; 选项可以把采样对象设成对象数目。内存采样数据是对象占用内存状况的实时快照，不需要像采样 CPU 性能数据那样要让进程跑一段时间。&lt;br/&gt;&lt;a href=&quot;https://go101.org/article/memory-leaking.html&quot;&gt;这篇文章&lt;/a&gt;介绍了更多 golang 内存泄露的场景，有兴趣可以阅读下。&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;golang 语言自带了测试工具和相关库，可以很方便的对 golang 程序进行测试。&lt;br/&gt;推荐表驱动测试的方式进行单元测试，golang 标准库中也有很多例子。以下是一个表驱动测试的示例：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func TestAdd(t *testing.T) {
    cases := []struct{ A, B, Expected int }{
        // 测试用例表
        {1, 1, 2},
        {1, -1, 0},
        {1, 0, 1},
        {0, 0, 0},
    }
    for _, tc := range cases {
        actual := tc.A + tc.B
        if actual != expected {
            t.Errorf(
                &quot;%d + %d = %d, expected %d&quot;,
                tc.A, tc.B, actual, tc.Expected)
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用表驱动测试可以很方便的增加测试用例测试各种边界条件。&lt;a href=&quot;https://github.com/cweill/gotests&quot;&gt;这个工具&lt;/a&gt;可以很方便的生成表驱动测试的桩代码。&lt;br/&gt;单元测试一般只需要对包中的导出函数进行测试，非导出函数作为内部实现，除非有比较复杂逻辑，一般不用测试。&lt;br/&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=yszygk1cpEc&quot;&gt;这个视频&lt;/a&gt;(&lt;a href=&quot;https://speakerdeck.com/mitchellh/advanced-testing-with-go&quot;&gt;PPT&lt;/a&gt;)更详细介绍了 golang 测试的最佳实践，值得一看。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文不是 golang 语法和工具使用的教程，这些内容在网上可以方便找到。本文假设读者已经对 golang 语法有了基本的了解，给了一些使用 golang 进行实际项目开发时的一些建议和方法指导。文中的主题主要是基于作者的实践经验和一些技术博客的总结，不免带有一些个人偏见。另外 golang 也是一门不断演进中的语言(从官方版本发布频率也可以看出来)，文中的内容也非一成不变，保持与时俱进应该是 golang 开发者应有的心态。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
</description>
<pubDate>Sat, 29 Sep 2018 12:01:00 +0000</pubDate>
<dc:creator>_toby</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tobycnblogs/p/9726461.html</dc:identifier>
</item>
<item>
<title>MUI框架-11-MUI前端 +php后台接入百度文字识别API - 肖朋伟</title>
<link>http://www.cnblogs.com/xpwi/p/9726363.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xpwi/p/9726363.html</guid>
<description>&lt;h2 id=&quot;mui框架-11-mui前端-php后台接入百度文字识别api&quot;&gt;MUI框架-11-MUI前端 +php后台接入百度文字识别API&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;这里后台不止一种，Python，Java，PHP，Node，C++，C# 都可以&lt;/li&gt;
&lt;li&gt;这里使用的是 php 来介绍，已经解决所有问题，因为处理很多错误，可能会比较复杂，请大家坚持按步骤来，&lt;/li&gt;
&lt;li&gt;大概流程就是：前端发送 Ajax 请求，php 后台实现文字识别，并将识别后的文字返回到前端页面&lt;/li&gt;
&lt;li&gt;先放上效果图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180929192704844?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;一准备阶段&quot;&gt;（一）准备阶段&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1.到百度云官网注册，几秒就可以，这个不需要审核，不像腾讯开发者认证好几天，注册然后登陆&lt;/li&gt;
&lt;li&gt;百度云官网：https://cloud.baidu.com/?from=console&lt;/li&gt;
&lt;li&gt;2.按照下面截图，产品&amp;gt;人工智能&amp;gt;文字识别，我们找到文字识别：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180929174156970?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; height=&quot;450px&quot;/&gt;&lt;/li&gt;
&lt;li&gt;3.点击【立即使用】：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180929174457364?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; height=&quot;450px&quot;/&gt;&lt;/li&gt;
&lt;li&gt;4.然后点击【创建应用】，填写名称，描述，非常快，不需要审核&lt;/li&gt;
&lt;li&gt;5.这里我们主要是为了得到 API Key 和 Secret Key&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180929175101223?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;二生成签名&quot;&gt;（二）生成签名&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;这里不必按照官方文档写的用服务器去发请求，设置一堆请求头&lt;/li&gt;
&lt;li&gt;直接将下面地址替换自己刚才的API Key 和 Secret Key，然后打开浏览器访问：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;amp;client_id=【官网获取的AK】&amp;amp;client_secret=【官网获取的SK】&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后会返回 json 格式的数据，access_token： 要获取的Access Token；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;【注意】：第二行可能还有，这个要拷贝下来，存起来备用&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180929180220796?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;温馨提示：Access Token的有效期为30天（以秒为单位），请您集成时注意在程序中定期请求新的token&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;在-hbuilder-搭建-mui-项目&quot;&gt;在 HBuilder 搭建 mui 项目&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;如果你还没有在 HBuilder 配置 php 服务器，请参考：&lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/details/81356662&quot;&gt;HBuilder+wampserver配置PHP外置web服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在 HBuilder 【新建】&amp;gt;【移动app】&amp;gt;【模板选择含MUI的模板】&lt;/li&gt;
&lt;li&gt;打开 index.html 文件&lt;/li&gt;
&lt;li&gt;新建目录命名PHP，新建 test.php 文件，在目录下再新建 img 目录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;【特别注意】：新手的话你要知道请求 php 服务器，是绝对不允许通过什么 ../ 返回上级目录，下级目录访问的，因为php 服务器的端口和你 HTML web 服务器是不一样的，我就别这个坑过，要是想在感觉上实现前后端分离，也可以创建一个新的项目，这里没必要因为只有一个 php 文件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;现在我们有了下面目录了&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180929195615341?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;打开 test.php 粘贴下面代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1.替换自己从浏览器获取的access_token，2.替换自己图片路径&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;test.php 文件代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
/**
 * 发起http post请求(REST API), 并获取REST请求的结果
 * @param string $url
 * @param string $param
 * @return - http response body if succeeds, else false.
 * 
 */

 function request_post($url = '', $param = '')
{
    if (empty($url) || empty($param)) {
        return false;
    }

    $postUrl = $url;
    $curlPost = $param;
    // 初始化curl
    $curl = curl_init();
    curl_setopt($curl, CURLOPT_URL, $postUrl);
    curl_setopt($curl, CURLOPT_HEADER, 0);
    // 要求结果为字符串且输出到屏幕上
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);
    // post提交方式
    curl_setopt($curl, CURLOPT_POST, 1);
    curl_setopt($curl, CURLOPT_POSTFIELDS, $curlPost);
    // 运行curl
    $data = curl_exec($curl);
    curl_close($curl);

    return $data;
}

//替换自己从浏览器获取的access_token 
$url = 'https://aip.baidubce.com/rest/2.0/ocr/v1/accurate_basic?access_token=【自己的access_token】';

//图片只能是本题图片，替换自己的图片
$img = file_get_contents('img/chi1.jpg');
$img = base64_encode($img);
$bodys = array(
    &quot;image&quot; =&amp;gt; $img
);
$res = request_post($url, $bodys);

echo $res;
//var_dump($res);

?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后我们就可以写前端页面了，打开 index.html，粘贴下面代码：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;替换自己 test.php 文件在 web 浏览器的路径，然后把本机127.0.0.1替换成 ipv4地址，cmd 输入ipv4查看 截图：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180929193159890?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;index.html 文件代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&amp;gt;
        &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
        &amp;lt;script src=&quot;js/mui.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;link href=&quot;css/mui.min.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;
        &amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;
            mui.init();
        &amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &amp;lt;header class=&quot;mui-bar mui-bar-nav&quot;&amp;gt;
            &amp;lt;a class=&quot;mui-action-back mui-icon mui-icon-left-nav mui-pull-left&quot;&amp;gt;&amp;lt;/a&amp;gt;
            &amp;lt;h1 class=&quot;mui-title&quot;&amp;gt;百度文字识别&amp;lt;/h1&amp;gt;
        &amp;lt;/header&amp;gt;
        &amp;lt;div class=&quot;mui-content&quot;&amp;gt;
            &amp;lt;br&amp;gt;
            &amp;lt;button id=&quot;queren&quot; type=&quot;button&quot; style=&quot;background-color: brown;color: #eeeeee;&quot;&amp;gt;发送请求&amp;lt;/button&amp;gt;
            &amp;lt;!--空的h2 用来存放返回的数据--&amp;gt;
            &amp;lt;hr&amp;gt;
            &amp;lt;p id=&quot;res&quot; style=&quot;font-size: larger;&quot;&amp;gt; &amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
        
        

        &amp;lt;!--处理请求--&amp;gt;
        &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            var upload = function(c, d) {
                &quot;use strict&quot;;
                var $c = document.querySelector(c),
                    $d = document.querySelector(d),
                    file = $c.files[0],
                    //预览框
                    reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = function(e) {
                    $d.setAttribute(&quot;src&quot;, e.target.result);
                };
            };

            var btn = document.getElementById(&quot;queren&quot;);
            //监听点击事件
            btn.addEventListener(&quot;tap&quot;, function() {
                //ajax
                
                //替换自己 test.php 文件在 web 浏览器的路径
                //用自己的 ipv4 地址，cmd 获取ipconfig 获取 
                mui.ajax('http://10.160.62.75/myphp/mui/php/test.php', {

                    dataType: 'json', //服务器返回json格式数据
                    type: 'get', //HTTP请求类型
                    timeout: 10000, //超时时间设置为10秒；
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    success: function(data) {
                        //服务器返回响应，根据响应结果，分析是否登录成功；
                        
                        //这里要对自己的数据进行处理
                        var html = &quot; &quot;;
                        for(var i = 0; i &amp;lt; data.words_result_num; i++){
 
                          html = html + data.words_result[i].words;
                         
                        };
                         
                        console.log(html)
                        document.getElementById(&quot;res&quot;).innerHTML = html;

                    },
                    error: function(xhr, type, errorThrown) {
                        //异常处理；
                        console.log(type);
                    }
                });
            });
            //触发submit按钮的点击事件

            mui.trigger(btn, 'tap');
        &amp;lt;/script&amp;gt;

    &amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行&quot;&gt;运行&lt;/h3&gt;
&lt;h3 id=&quot;更多文章链接mui-框架&quot;&gt;更多文章链接：&lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/category/8079041&quot;&gt;MUI 框架&lt;/a&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;本笔记不允许任何个人和组织转载&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 29 Sep 2018 11:37:00 +0000</pubDate>
<dc:creator>肖朋伟</dc:creator>
<og:description>MUI框架 11 MUI前端 +php后台接入百度文字识别API 这里后台不止一种，Python，Java，PHP，Node，C++，C 都可以 这里使用的是 php 来介绍，已经解决所有问题，因为处</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xpwi/p/9726363.html</dc:identifier>
</item>
<item>
<title>CSS 盒子模型及 float 和 position - 筱小程序媛</title>
<link>http://www.cnblogs.com/xlb-happymoment/p/9726350.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xlb-happymoment/p/9726350.html</guid>
<description>&lt;p&gt;## CSS和模型 ##&lt;br/&gt;CSS盒模型本质上是一个盒子，封装周围的 HTML 元素，包括 外边距（marign），边框（border），填充（padding），内容物（content）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1130325/201809/1130325-20180929192954287-94727679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;盒子模型的类型：W3C 标准和模型和 IE 盒模型（怪异盒模型）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;line&quot; data-start=&quot;6&quot; data-end=&quot;6&quot; data-id=&quot;10669523&quot;&gt;W3C 标准盒模型：属性 width 和 height 只包含 content，不包括 border 和 padding&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;line&quot; data-start=&quot;7&quot; data-end=&quot;7&quot; data-id=&quot;10669523&quot;&gt;IE 盒模型：属性 width 和 height 包含 border 和 padding，指的是 content + padding + border&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;8&quot; data-start-original=&quot;9&quot; data-end=&quot;9&quot; data-id=&quot;10669523&quot;&gt;&lt;em&gt;css3新增的 box-sizing 属性的值 content-box 就是标准盒模型，border-box 就是 IE 盒模型&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;10&quot; data-start-original=&quot;11&quot; data-end=&quot;11&quot; data-id=&quot;10669523&quot;&gt;&lt;strong&gt;盒模型 -- 基本框&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;hljs nginx&quot;&gt;
&lt;code&gt;&lt;span class=&quot;line&quot; data-start=&quot;12&quot; data-end=&quot;12&quot; data-id=&quot;10669523&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;CSS 假定每个元素都会生成一个或多个矩形框，各元素框中心又一个内容区，这个内容区周围有可选的内边距、边框和外边距。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;14&quot; data-end=&quot;14&quot; data-id=&quot;10669523&quot;&gt;&lt;strong&gt;盒模型 -- 包含块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;
&lt;code&gt;&lt;span class=&quot;line&quot; data-start=&quot;15&quot; data-end=&quot;15&quot; data-id=&quot;10669523&quot;&gt;每个元素都相对于其包含块摆放，包含块就是一个元素的布局上下文。
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;17&quot; data-end=&quot;17&quot; data-id=&quot;10669523&quot;&gt;&lt;strong&gt;盒模型 -- 正常流&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;hljs julia&quot;&gt;
&lt;code&gt;&lt;span class=&quot;line&quot; data-start=&quot;18&quot; data-end=&quot;18&quot; data-id=&quot;10669523&quot;&gt;指的是西方语言文本从左向右、从上向下显示，这也是传统 &lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;HTML 文档的文本布局。大多数元素都是在正常流中，要让一个元素不在正常流中，唯一的办法就是使之成为浮动或定位元素。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;20&quot; data-end=&quot;20&quot; data-id=&quot;10669523&quot;&gt;&lt;strong&gt;块级元素&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;21&quot; data-start-original=&quot;22&quot; data-end=&quot;22&quot; data-id=&quot;10669523&quot;&gt;&lt;span class=&quot;line&quot; data-start=&quot;21&quot; data-start-original=&quot;22&quot; data-end=&quot;22&quot; data-id=&quot;10669523&quot;&gt;控制盒模型的水平方向的有 7 个值：margin-left、border-left、padding-left、width、padding-right、border-right、margin-right（加在一起必须等于包含快的宽度）。其中 margin 和 width 可以设置为 auto，其他的要么是确定的值，要么就是默认的 0。margin 值可以设置为负，padding 不可以。水平外边距不会合并。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;23&quot; data-start-original=&quot;25&quot; data-end=&quot;25&quot; data-id=&quot;10669523&quot;&gt;一个元素的默认高度是由其内容确定，可以对任何块级元素设置显示高度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;26&quot; data-start-original=&quot;27&quot; data-end=&quot;27&quot; data-id=&quot;10669523&quot;&gt;同样，控制盒模型的竖直方向的有 7 个值：margin-top、border-top、padding-top、height、padding-top、border-top、margin-top（加在一起必须等于包含快的高度）。其中 margin 和 height 可以设为 auto，但是上下外边距设置为 auto 没什么用，因为会被重置为 0。如果块级正常流的高度设为 auto，而且只有块级子元素，其默认高度是从最高块级子元素的外边框边界到最低块级子元素外边框边界之间的距离。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;28&quot; data-start-original=&quot;29&quot; data-end=&quot;29&quot; data-id=&quot;10669523&quot;&gt;垂直方向上另一个重要的方面是：相邻的元素外边距会合并。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;30&quot; data-start-original=&quot;31&quot; data-end=&quot;31&quot; data-id=&quot;10669523&quot;&gt;如果相邻两个元素垂直外边距都设置为负值，浏览器会取绝对值大的作为外边距。如果一正一负，会取正外边距减去负外边距的绝对值的差作为外边距。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;32&quot; data-start-original=&quot;33&quot; data-end=&quot;33&quot; data-id=&quot;10669523&quot;&gt;&lt;strong&gt;block、inline、inline-block 对比&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;line&quot; data-start=&quot;34&quot; data-start-original=&quot;35&quot; data-end=&quot;35&quot; data-id=&quot;10669523&quot;&gt;block：元素独占一行，默认情况下，元素宽度自动填满父元素宽度。可以设置 width、height 属性，设置了宽高的块级元素仍独占一行。块级元素可以设置 margin 和 padding.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;line&quot; data-start=&quot;36&quot; data-end=&quot;36&quot; data-id=&quot;10669523&quot;&gt;inline：元素不会独占一行，多个相邻的元素会在一行排列，排列不下会自动换行，其宽度随元素内容而变化。内联元素设置 width、height 无效。内联元素的 margin 和 padding 属性，水平方向有效，竖直方向不会产生边距效果。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;line&quot; data-start=&quot;37&quot; data-end=&quot;37&quot; data-id=&quot;10669523&quot;&gt;inline-block：将对象呈现为内联对象，但是对象的内容具有块级元素的属性。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span class=&quot;line&quot; data-start=&quot;38&quot; data-start-original=&quot;39&quot; data-end=&quot;39&quot; data-id=&quot;10669523&quot;&gt;float 与 position 的区别&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;40&quot; data-start-original=&quot;41&quot; data-end=&quot;41&quot; data-id=&quot;10669523&quot;&gt;&lt;span class=&quot;line&quot; data-start=&quot;40&quot; data-start-original=&quot;41&quot; data-end=&quot;41&quot; data-id=&quot;10669523&quot;&gt;文档流：在 css 中有一个 z-index 属性，默认情况下，所有页面元素均位于 z-index: 0 这一层，而这一层顺序排列的元素就叫文档流。float 和 position 都是通过改变文档流来实现定位。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;42&quot; data-start-original=&quot;43&quot; data-end=&quot;43&quot; data-id=&quot;10669523&quot;&gt;CSS 有 三种定位机制：文档流、浮动和绝对定位。除非专门指定，否则所有元素都在文档流中定位。CSS 定位的基本思想很简单，它允许你使得元素相对于其正常应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置来进行定位。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;44&quot; data-start-original=&quot;45&quot; data-end=&quot;45&quot; data-id=&quot;10669523&quot;&gt;&lt;strong&gt;float&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;46&quot; data-start-original=&quot;47&quot; data-end=&quot;47&quot; data-id=&quot;10669523&quot;&gt;float 属性定位的元素位于 z-index: 0 层，它是通过 float: left 和 float: right 来控制元素在 0层左浮还是右浮，float会改变整成的文档流排列，影响到周围的元素，但是不会脱离文档流。float 元素在文档流中一个挨着一个排列，但只是float 元素之间一个挨着一个排列，对于非 float 元素，float 元素会越过它们，即 float: left 会把非 float的元素挤到所有 float 的元素右边，float: right 则挤到左边。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;48&quot; data-start-original=&quot;49&quot; data-end=&quot;49&quot; data-id=&quot;10669523&quot;&gt;&lt;strong&gt;position&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;line&quot; data-start=&quot;50&quot; data-start-original=&quot;51&quot; data-end=&quot;51&quot; data-id=&quot;10669523&quot;&gt;postion 属性有四个值：static（默认值）、relative、absolute、fixed&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;line&quot; data-start=&quot;52&quot; data-start-original=&quot;53&quot; data-end=&quot;53&quot; data-id=&quot;10669523&quot;&gt;static：静态定位。元素框正常生成，元素顺序显示，在一个文档流中，一个挨着一个，内容遵守正常从上到下的 HTML 流。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;line&quot; data-start=&quot;54&quot; data-end=&quot;54&quot; data-id=&quot;10669523&quot;&gt;relative：相对定位。元素偏移某个距离。元素仍保持其未定位前的框的形状，它原本所占的空间仍保留。一个相对定位的元素相对它在 HTML 流中当前位置而放置。相对定位的主要用处不是移动一个元素，而是给行内在它内部的绝对定位的元素设定一个新的参考点。position: relative 的元素是相对于自己本来应该在的位置进行偏移。偏移后的位置是浮在上方的，但仍会保留自己在 z-index: 0 中的位置，不会影响相邻元素。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;line&quot; data-start=&quot;55&quot; data-end=&quot;55&quot; data-id=&quot;10669523&quot;&gt;absolute：绝对定位。绝对定位可以通过 px、em、% 来指定一个左、右、上、下的位置来确定一个元素的位置。此外，绝对定位的元素被完全与页面流分离。&lt;br/&gt;&lt;span class=&quot;line&quot; data-start=&quot;56&quot; data-end=&quot;56&quot; data-id=&quot;10669523&quot;&gt;absolute 的一般用法：如果一个元素被设定为绝对定位，并且不在任何其他应用了 absolute、relative、fixed 定位的标签里，那么它是相对于页面（body 元素）进行定位的。如果一个元素在另一个带有 absolute、relative 或者 fixed 定位的标签里，那么它是相对于该元素的边界进行定位的。即：position: absolute 的元素在 static 的父元素中是相对页面进行偏移的，在非 static 的父元素中，是相对父元素进行偏移的。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;line&quot; data-start=&quot;57&quot; data-end=&quot;57&quot; data-id=&quot;10669523&quot;&gt;fixed：一个元素被固定定位在屏幕的某个位置上，是相对浏览器窗口进行定位的。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 29 Sep 2018 11:32:00 +0000</pubDate>
<dc:creator>筱小程序媛</dc:creator>
<og:description>## CSS和模型 ##CSS盒模型本质上是一个盒子，封装周围的 HTML 元素，包括 外边距（marign），边框（border），填充（padding），内容物（content） 盒子模型的类型：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xlb-happymoment/p/9726350.html</dc:identifier>
</item>
<item>
<title>搭建MHA时 yum 安装perl模块提示 baseurl 错误 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9726339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9726339.html</guid>
<description>&lt;p&gt;今天在搭建MySQL MHA  安装MHA node所需的perl模块（DBD:mysql）时遇到了一个小的错误，如果思路不对的话，还是产生不少麻烦。&lt;/p&gt;
&lt;p&gt;现梳理记录下来。&lt;/p&gt;
&lt;h2&gt;问题现象&lt;/h2&gt;
&lt;p&gt;执行的命令 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;yum install perl-DBD-MySQL -y&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;报错信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180929172509911-241450160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出错误的关键字为 ：&lt;strong&gt;Cannot find a valid baseurl&lt;/strong&gt; for repo: base/7/x86_64。&lt;/p&gt;
&lt;p&gt;这个问题 说明&lt;strong&gt;&lt;span&gt;&lt;em&gt;url 无效。&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;分析处理&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在这个错误提示中其实有显示url的数据，我们可以从错误信息中的二、三两行来定位。数据如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;amp;arch=x86_64&amp;amp;repo=os&amp;amp;infra=stock error was&lt;br/&gt;14: curl#6 - &quot;Could not resolve host: &lt;span&gt;&lt;strong&gt;mirrorlist.centos.org&lt;/strong&gt;&lt;/span&gt;; Unknown error&quot;&lt;/p&gt;
&lt;p&gt;判读是否有效，我们可以首先看是否可以ping通。&lt;/p&gt;
&lt;p&gt;执行命令：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ping mirrorlist.centos.org&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180929171213024-1318844360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现此时是ping 不通的，说明确实有问题。但此时尚不可以判断是源主机（网址）不存在或非法，也有一种可能，就是本地请求没有成功发出去。&lt;/p&gt;
&lt;p&gt;怎么验证呢？其实很简单，我们只要Ping下百度就可以了。&lt;/p&gt;
&lt;p&gt;执行命令&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ping www.baidu.com&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180929171625532-1362485430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从以上截图中可以看出百度也ping不通，此时说明不是url的问题。问题在于我们request请求，根本就没有发送出到host主机。&lt;/p&gt;
&lt;p&gt;所以，问题很可能在我们本机的网络设置。但是考虑到，本机已成功分配到IP地址，ip addr 显示正常，可以在局域网内互联。&lt;/p&gt;
&lt;p&gt;此时感觉很是奇怪。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;忽然想到，可能是DNS的问题。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;安装本机时同事使用的老的装机模板，所以DNS参数没有及时更新。&lt;/p&gt;
&lt;p&gt;问题基本定位到了，下一步修改。&lt;/p&gt;
&lt;p&gt;马上进入 /etc/sysconfig/network-scripts目录，修改文件 ifcfg-ens32 中的DNS1参数。&lt;/p&gt;
&lt;p&gt;修改DNS1配置后，记得&lt;strong&gt;&lt;span&gt;一定要重启 network 服务&lt;/span&gt;&lt;/strong&gt;，否则无效。&lt;/p&gt;
&lt;p&gt;执行重启的命令如下： &lt;/p&gt;
&lt;p&gt;&lt;em&gt;service network restart&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;结果验证&lt;/h2&gt;
&lt;p&gt;此时  ping 百度正常&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180929173122386-821706590.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;ping 安装程序的url正常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180929173251527-941847074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次安装perl模块（DBD:mysql），成功执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180929173453006-112580892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180929173529414-1652708757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;后记&lt;/h2&gt;
&lt;p&gt;这只是个小问题，没有太大的科技含量。我们在yum安装模块时，经常会遇到各种各样的坑。总结下，记于此，更多的是经常提醒自己，怎么处理问题。如果能对初学者有所裨益，那是更好。&lt;/p&gt;
</description>
<pubDate>Sat, 29 Sep 2018 11:29:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>今天在搭建MySQL MHA 安装MHA node所需的perl模块（DBD:mysql）时遇到了一个小的错误，如果思路不对的话，还是产生不少麻烦。 现梳理记录下来。 问题现象 执行的命令 yum i</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9726339.html</dc:identifier>
</item>
</channel>
</rss>