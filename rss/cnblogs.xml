<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>button JS篇ant Design of react之二 - 核桃大号</title>
<link>http://www.cnblogs.com/hetaojs/p/9946955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hetaojs/p/9946955.html</guid>
<description>&lt;p&gt;最近更新有点慢，更新慢的原因最近在看&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《css世界》这本书，感觉很不错&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-96058d5a29a1a4a69de40ee2b7315af8_hd.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《JavaScript高级程序设计》 这本书已经看了很多遍了，主要是复习前端的基础知识，基础知识经常会过一段时间记忆就会慢慢模糊，特别是现在用vue、react、angularjs已经很少用原生js了，对dom的原生api方法已经忘记很多了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-d3adfa516d382425e3f1b601873d3d92_hd.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《梦的解析》--弗洛伊德，看这本书主要是自己的兴趣爱好，里面的内容有点难度，想通过心理学改变自己，做更好更真实的自己。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=fd5dd8bae124b899de3c7e3e563d7aa8/0823dd54564e9258046c74549482d158ccbf4e34.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;题外话说完了，这篇主要是针对上一篇对ant of react的代码解析只是加了注释反应很难懂，没有那么时间去一个一个仔细看。后面ant发布了新版本在button组件上对动画效果做了一些处理，大概的逻辑结构没变。这篇就用思维导图来展示下ant of react button组件js代码的逻辑结构，画的不好敬请谅解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;结构主线&quot;&gt;结构主线&lt;/h4&gt;
&lt;p&gt;按钮的代码逻辑结构的主线其实就是围绕按钮对外开放的功能实现的，所有我想来看看ant desgin of ract 按钮组件对外开放的功能导图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-021d0f51338c7da9f797de5df7f64695_hd.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;disabled 按钮失效状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ghost 幽灵属性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;href 点击跳转的地址，指定此属性 button 的行为和 a 链接一致&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;htmlType 设置 button 原生的 type 值，可选值请参考 HTML 标准&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;icon 设置按钮的图标类型&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;loading 设置按钮载入状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shape 设置按钮形状&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;size 设置按钮大小&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;target 相当于 a 链接的 target 属性，href 存在时生效&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;type 设置按钮类型，可选值为 primary dashed danger(版本 2.7 中增加) 或者不设&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;onClick 点击按钮时的回调&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;block 将按钮宽度调整为其父宽度的选项&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中导致组件html结构不一样的是href功能，所以先看href的实现&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;   /**
   * 组件内容
   */
  render() {
    const {
      type, shape, size, className, children, icon, prefixCls, ghost, loading: _loadingProp, block, ...rest
    } = this.props;

    const { loading, hasTwoCNChar } = this.state;

    // large =&amp;gt; lg
    // small =&amp;gt; sm
    let sizeCls = '';
    switch (size) {
      case 'large':
        sizeCls = 'lg';
        break;
      case 'small':
        sizeCls = 'sm';
      default:
        break;
    }

    const now = new Date();
    const isChristmas = now.getMonth() === 11 &amp;amp;&amp;amp; now.getDate() === 25;
    /**
     * 拼接className
     */
    const classes = classNames(prefixCls, className, {
      [`${prefixCls}-${type}`]: type,//对应type功能
      [`${prefixCls}-${shape}`]: shape,//对应shape功能
      [`${prefixCls}-${sizeCls}`]: sizeCls,//对应size功能
      [`${prefixCls}-icon-only`]: !children &amp;amp;&amp;amp; icon,//对应icon功能
      [`${prefixCls}-loading`]: loading,//对应loading功能
      [`${prefixCls}-background-ghost`]: ghost,//对应ghost功能
      [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar,
      [`${prefixCls}-block`]: block,//对应block功能
      christmas: isChristmas,
    });
    /**
       * 设置图标
       */
    const iconType = loading ? 'loading' : icon;
    const iconNode = iconType ? &amp;lt;Icon type={iconType} /&amp;gt; : null;
    const kids = (children || children === 0)
      ? React.Children.map(children, child =&amp;gt; insertSpace(child, this.isNeedInserted())) : null;

    const title = isChristmas ? 'Ho Ho Ho!' : rest.title;
    /**
        * 判断是a标签还是button标签，对应href功能
        */
    if ('href' in rest) {
      return (
        &amp;lt;a
          {...rest}
          className={classes}
          onClick={this.handleClick}
          title={title}
        &amp;gt;
          {iconNode}{kids}
        &amp;lt;/a&amp;gt;
      );
    } else {
      // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
      const { htmlType, ...otherProps } = rest;

      return (
        &amp;lt;Wave&amp;gt;
          &amp;lt;button
            {...otherProps}
            type={htmlType || 'button'}
            className={classes}
            onClick={this.handleClick}
            title={title}
          &amp;gt;
            {iconNode}{kids}
          &amp;lt;/button&amp;gt;
        &amp;lt;/Wave&amp;gt;
      );
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的那些功能配置属性是通过父组件通过props传递进来的，那组件代码中要有接收参数已经检验参数类型的处理块：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/**
 * 类型别名,这个类型的只能是对应的值
 */
export type ButtonType = 'default' | 'primary' | 'ghost' | 'dashed' | 'danger';
export type ButtonShape = 'circle' | 'circle-outline';
export type ButtonSize = 'small' | 'default' | 'large';
export type ButtonHTMLType = 'submit' | 'button' | 'reset';
/**
 * 声明一个接口BaseButtonProps 
 */
export interface BaseButtonProps {
  type?: ButtonType;
  icon?: string;
  shape?: ButtonShape;
  size?: ButtonSize;
  loading?: boolean | { delay?: number };
  prefixCls?: string;
  className?: string;
  ghost?: boolean;
  block?: boolean;
  children?: React.ReactNode;
}
/**
 * a标签的参数组合
 */
export type AnchorButtonProps = {
  href: string;
  target?: string;
  onClick?: React.MouseEventHandler&amp;lt;HTMLAnchorElement&amp;gt;;
} &amp;amp; BaseButtonProps &amp;amp; React.AnchorHTMLAttributes&amp;lt;HTMLAnchorElement&amp;gt;;
/**
 * button标签的参数组合
 */
export type NativeButtonProps = {
  htmlType?: ButtonHTMLType;
  onClick?: React.MouseEventHandler&amp;lt;HTMLButtonElement&amp;gt;;
} &amp;amp; BaseButtonProps &amp;amp; React.ButtonHTMLAttributes&amp;lt;HTMLButtonElement&amp;gt;;
/**
 * 类型别名
 */
export type ButtonProps = AnchorButtonProps | NativeButtonProps;
/**
 * button class声明
 */
export default class Button extends React.Component&amp;lt;ButtonProps, any&amp;gt; {
  static Group: typeof Group;
  static __ANT_BUTTON = true;
  /**
   * 设置props默认值
   */
  static defaultProps = {
    prefixCls: 'ant-btn',
    loading: false,
    ghost: false,
    block: false,
  };
  /**
    * props类型校验
    */
  static propTypes = {
    type: PropTypes.string,
    shape: PropTypes.oneOf(['circle', 'circle-outline']),
    size: PropTypes.oneOf(['large', 'default', 'small']),
    htmlType: PropTypes.oneOf(['submit', 'button', 'reset']),
    onClick: PropTypes.func,
    loading: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),
    className: PropTypes.string,
    icon: PropTypes.string,
    block: PropTypes.bool,
  };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码大概意思是在typescript中声明接口和自定义类型来校验参数对象里面的键值对的数据类型，defaultProps设置参数的某些默认值，propTypes在react中通过prop-types来校验参数的数据量类型和值。&lt;/p&gt;
&lt;p&gt;剩下就是单击事件和组件声明周期的一些处理事件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;组件的构造函数 声明state的值&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  /**
   * 构造函数
   */
  constructor(props: ButtonProps) {
    super(props);
    this.state = {
      loading: props.loading,
      hasTwoCNChar: false,
    };
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;单击事件，如果是加载状态不触发单击事件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  /**
    * 单击事件
    */
  handleClick: React.MouseEventHandler&amp;lt;HTMLButtonElement | HTMLAnchorElement&amp;gt; = e =&amp;gt; {
    const { loading } = this.state;
    const { onClick } = this.props;
    if (!!loading) {
      return;
    }
    if (onClick) {
      (onClick as React.MouseEventHandler&amp;lt;HTMLButtonElement | HTMLAnchorElement&amp;gt;)(e);
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;组件的生命周期处理&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; /**
     * 组件渲染之后调用，只调用一次。
     */
  componentDidMount() {
    this.fixTwoCNChar();
  }
  /**
    * props改变时调用触发，nextProps.loading赋值到setState的loading
    * @param nextProps 
    */
  componentWillReceiveProps(nextProps: ButtonProps) {
    const currentLoading = this.props.loading;
    const loading = nextProps.loading;

    if (currentLoading) {
      clearTimeout(this.delayTimeout);
    }

    if (typeof loading !== 'boolean' &amp;amp;&amp;amp; loading &amp;amp;&amp;amp; loading.delay) {
      this.delayTimeout = window.setTimeout(() =&amp;gt; this.setState({ loading }), loading.delay);
    } else {
      this.setState({ loading });
    }
  }
  /**
    * 组件更新完成后调用
    */
  componentDidUpdate() {
    this.fixTwoCNChar();
  }
  /**
   * 组件将要卸载时调用,清除定时器
   */
  componentWillUnmount() {
    if (this.delayTimeout) {
      clearTimeout(this.delayTimeout);
    }
  }
  /**
    * 判断botton的内容是否有两个中文字
    */
  fixTwoCNChar() {
    // Fix for HOC usage like &amp;lt;FormatMessage /&amp;gt;
    const node = (findDOMNode(this) as HTMLElement);
    const buttonText = node.textContent || node.innerText;
    if (this.isNeedInserted() &amp;amp;&amp;amp; isTwoCNChar(buttonText)) {
      if (!this.state.hasTwoCNChar) {
        this.setState({
          hasTwoCNChar: true,
        });
      }
    } else if (this.state.hasTwoCNChar) {
      this.setState({
        hasTwoCNChar: false,
      });
    }
  }
  /**
 * 判断是否是字符串类型
 */
function isString(str: any) {
  return typeof str === 'string';
}
/**
 * 多个中文间插入空格
 * @param {Object} child 组件的子内容
 * @param {Boolean} needInserted 是否插入空格
 * @returns {ReactElement} 
 */
// Insert one space between two chinese characters automatically.
function insertSpace(child: React.ReactChild, needInserted: boolean) {
  // Check the child if is undefined or null.
  if (child == null) {
    return;
  }
  const SPACE = needInserted ? ' ' : '';
  // strictNullChecks oops.
  if (typeof child !== 'string' &amp;amp;&amp;amp; typeof child !== 'number' &amp;amp;&amp;amp;
    isString(child.type) &amp;amp;&amp;amp; isTwoCNChar(child.props.children)) {
    return React.cloneElement(child, {},
      child.props.children.split('').join(SPACE));
  }
  if (typeof child === 'string') {
    if (isTwoCNChar(child)) {
      child = child.split('').join(SPACE);
    }
    return &amp;lt;span&amp;gt;{child}&amp;lt;/span&amp;gt;;
  }
  return child;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 12 Nov 2018 07:54:00 +0000</pubDate>
<dc:creator>核桃大号</dc:creator>
<og:description>最近更新有点慢，更新慢的原因最近在看 《css世界》这本书，感觉很不错 《JavaScript高级程序设计》 这本书已经看了很多遍了，主要是复习前端的基础知识，基础知识经常会过一段时间记忆就会慢慢模糊</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hetaojs/p/9946955.html</dc:identifier>
</item>
<item>
<title>Bootstrap 4/3 页面基础模板 与 兼容旧版本浏览器 - 痴者工良</title>
<link>http://www.cnblogs.com/whuanle/p/9946705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whuanle/p/9946705.html</guid>
<description>&lt;p&gt;Bootstrap 3 与 4 差别很大，目录文件结构、所引入的内容也不同，这里说说一下 Bootstrap 引入的文件、网页模板和兼容性问题。本网站刚刚搭建好，正好发一下文章原来测试网站。&lt;/p&gt;
&lt;hr/&gt;&lt;h3&gt;Bootstrap 4&lt;/h3&gt;
&lt;p&gt;目录结构如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
bootstrap/
├── css/
│   ├── bootstrap.css
│   ├── bootstrap.css.map
│   ├── bootstrap.min.css
│   ├── bootstrap.min.css.map
│   ├── bootstrap-grid.css
│   ├── bootstrap-grid.css.map
│   ├── bootstrap-grid.min.css
│   ├── bootstrap-grid.min.css.map
│   ├── bootstrap-reboot.css
│   ├── bootstrap-reboot.css.map
│   ├── bootstrap-reboot.min.css
│   └── bootstrap-reboot.min.css.map
└── js/
    ├── bootstrap.bundle.js
    ├── bootstrap.bundle.min.js
    ├── bootstrap.js
    └── bootstrap.min.js
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt;Bootstrap 4需要依赖的文件比 Bootstrap 3多，许多组件需要依赖 JavaScript才能运行。例如， jQuery、Popper.js 以及JavaScript插件。&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;官方网页模板如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;doctype html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Required meta tags &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Bootstrap CSS &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css&quot;&lt;/span&gt;&lt;span&gt; integrity&lt;/span&gt;&lt;span&gt;=&quot;sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm&quot;&lt;/span&gt;&lt;span&gt; crossorigin&lt;/span&gt;&lt;span&gt;=&quot;anonymous&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello, world!&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello, world!&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Optional JavaScript &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; jQuery first, then Popper.js, then Bootstrap JS &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.slim.min.js&quot;&lt;/span&gt;&lt;span&gt; integrity&lt;/span&gt;&lt;span&gt;=&quot;sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN&quot;&lt;/span&gt;&lt;span&gt; crossorigin&lt;/span&gt;&lt;span&gt;=&quot;anonymous&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/popper.js/1.12.9/umd/popper.min.js&quot;&lt;/span&gt;&lt;span&gt; integrity&lt;/span&gt;&lt;span&gt;=&quot;sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q&quot;&lt;/span&gt;&lt;span&gt; crossorigin&lt;/span&gt;&lt;span&gt;=&quot;anonymous&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js&quot;&lt;/span&gt;&lt;span&gt; integrity&lt;/span&gt;&lt;span&gt;=&quot;sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl&quot;&lt;/span&gt;&lt;span&gt; crossorigin&lt;/span&gt;&lt;span&gt;=&quot;anonymous&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;手机看着乱的话，看图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.whuanle.cn/UpLoad/Images/201810/65a53325e30c47e8ad5d12494e4da07e.png&quot; alt=&quot;&quot; width=&quot;772&quot; height=&quot;503&quot;/&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;精简后看一下&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;doctype html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;./css/bootstrap.min.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 666 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./jquery/3.2.1/jquery.slim.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./popper.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./js/bootstrap.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Bootstrap 4中，没有 &lt;span&gt;Popper.js&lt;/span&gt;文件&lt;/li&gt;
&lt;li&gt;但是 &lt;span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bootstrap.bundle.js&lt;/code&gt;&lt;/span&gt; 和压缩后的 &lt;span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bootstrap.bundle.min.js&lt;/code&gt; &lt;/span&gt;已经包含了 &lt;span&gt;Popper &lt;/span&gt;&lt;br/&gt;仔细看一下，上面官方模板中，引入了 &lt;span&gt;jquery.slim.min.js&lt;/span&gt; 而不是&lt;span&gt; jquery.min.js&lt;/span&gt; 。不知道官方为什么做~~~&lt;/li&gt;
&lt;li&gt;&lt;span&gt;jquery.slim.min.js &lt;/span&gt;与 &lt;span&gt;jquery.min.js&lt;/span&gt; 的区别是 &lt;span&gt;jquery.slim.min.js&lt;/span&gt; 是瘦身版，去除了Ajax功能。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3&gt;Bootstrap 3&lt;/h3&gt;
&lt;p&gt;目录结构如下&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
bootstrap/
├── css/
│   ├── bootstrap.css
│   ├── bootstrap.css.map
│   ├── bootstrap.min.css
│   ├── bootstrap.min.css.map
│   ├── bootstrap-theme.css
│   ├── bootstrap-theme.css.map
│   ├── bootstrap-theme.min.css
│   └── bootstrap-theme.min.css.map
├── js/
│   ├── bootstrap.js
│   └── bootstrap.min.js
└── fonts/
    ├── glyphicons-halflings-regular.eot
    ├── glyphicons-halflings-regular.svg
    ├── glyphicons-halflings-regular.ttf
    ├── glyphicons-halflings-regular.woff
    └── glyphicons-halflings-regular.woff2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;基础模板和引入的文件如下&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;zh-CN&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;  声明为响应式页面  &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;  [end]  &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; meta 标签需要放在最前面 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Bootstrap 官方给出的示例&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Bootstrap 文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;./3.3.7/dist/css/bootstrap.min.css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; HTML5 shim 和 Respond.js 是为了让旧版本的IE浏览器支持Bootstrap，因为 IE9 以下可能不支持 HTML5 元素和媒体查询（media queries）功能 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;[if lt IE 9]&amp;gt;
      &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;![endif]&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./1.12.4/dist/jquery.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./3.3.7/dist/js/bootstrap.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;手机看不清楚请看图&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.whuanle.cn/UpLoad/Images/201810/f92c0f463a444d8bb642afac2c079944.png&quot; alt=&quot;&quot; width=&quot;759&quot; height=&quot;637&quot;/&gt;&lt;/p&gt;

&lt;p&gt;精简后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;zh-CN&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Bootstrap 官方给出的示例&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;./3.3.7/dist/css/bootstrap.min.css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./1.12.4/dist/jquery.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./3.3.7/dist/js/bootstrap.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 注意：&lt;/p&gt;
&lt;p&gt;官方提供的压缩的源代码中，不包含 &lt;span&gt;html5shiv&lt;/span&gt;和 &lt;span&gt;Respond.js&lt;/span&gt;文件，需要使用到这两个文件，要自行下载。&lt;/p&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;如何兼容&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;上面已经说了引用&lt;span&gt; html5shiv&lt;/span&gt;和 &lt;span&gt;Respond.js &lt;/span&gt;文件，用以支持 IE9 及以下的浏览器。&lt;/li&gt;
&lt;li&gt;细心的朋友可能发现，在示例模板中，Bootstrap 4没有兼容性文件，而 Bootstrap 3中，有 &lt;span&gt;html5shiv.js&lt;/span&gt; 和 &lt;span&gt;respond.js&lt;/span&gt;。&lt;br/&gt;↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓&lt;/li&gt;
&lt;li&gt;这是因为Bootstrap 4放弃了对 IE8 以及 iOS 6 的支持，现在仅仅支持 IE9 以上 以及 iOS 7 以上版本的浏览器。&lt;br/&gt;也就是说，Bootstrap3 能够通过引用两个文件实现浏览器兼容，而Bootstrap 4已经不能再支持旧版本浏览器了。。。(别急，下面介绍解决办法)&lt;/li&gt;
&lt;li&gt;&lt;span&gt; html5shiv 和 &lt;span&gt;Respond.js 两个文件&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;具体怎么用 ，请点击 &lt;a href=&quot;https://blog.csdn.net/bluefish_flying/article/details/72594152&quot;&gt;https://blog.csdn.net/bluefish_flying/article/details/72594152&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;html5shiv.js &lt;/span&gt;和 &lt;span&gt;respond.js&lt;/span&gt; 引入不起作用解决 ，请点击 &lt;a href=&quot;https://www.cnblogs.com/xiaoshudian/p/7138624.html&quot;&gt;https://www.cnblogs.com/xiaoshudian/p/7138624.html&lt;br/&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;html5shiv html5shiv&lt;/span&gt;是一个针对 IE 浏览器的 HTML5 JavaScript 补丁，目的是让 IE 识别并支持 HTML5 元素&lt;/li&gt;
&lt;li&gt;详细介绍和各个版本，请点击 &lt;a href=&quot;https://www.bootcdn.cn/html5shiv/&quot;&gt;https://www.bootcdn.cn/html5shiv/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 官方虽然不再支持IE9以下的浏览器，但是有 “民间组织” 闲的慌，甚至实现了对IE6 的支持。。。&lt;/p&gt;
&lt;p&gt;这个就是 “bsie项目” 。 地址 &lt;a title=&quot;http://www.bootcss.com/p/bsie/&quot; href=&quot;http://www.bootcss.com/p/bsie/&quot; target=&quot;_blank&quot;&gt;http://www.bootcss.com/p/bsie/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1315495/201811/1315495-20181112155214106-1548901245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 12 Nov 2018 07:53:00 +0000</pubDate>
<dc:creator>痴者工良</dc:creator>
<og:description>Bootstrap 3 与 4 差别很大，目录文件结构、所引入的内容也不同，这里说说一下 Bootstrap 引入的文件、网页模板和兼容性问题。本网站刚刚搭建好，正好发一下文章原来测试网站。 Boot</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whuanle/p/9946705.html</dc:identifier>
</item>
<item>
<title>SpringBoot从介绍到各个框架的整合 - 一头生猛的程序猿</title>
<link>http://www.cnblogs.com/shenhanboBlog/p/9946946.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shenhanboBlog/p/9946946.html</guid>
<description>&lt;p&gt;1.背景：以前假如想创建一个Spring应用， 比如Spring、SpringMVC、Mybatis三大框架的整合， 我们需要一对繁琐的步骤：maven导一堆依赖--&amp;gt;写一堆配置文件--&amp;gt;测试--&amp;gt;打成war包部署到Servlet容器上，可以说是相当繁琐。SpringBoot就是来简化这些步骤的。&lt;/p&gt;
&lt;p&gt;2.SpringBoot的作用：帮助我们很快的创建一个产品级别的Spring应用，简化J2EE开发。SpringBoot会自动帮我们配置好Spring&lt;/p&gt;
&lt;p&gt;的相关配置，因此用户可以无需去清楚Spring的配置，就可以从SpringBoot这个微小的入口打开J2EE的大门。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1530724/201811/1530724-20181112145828904-1916981645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.归纳一下SpringBoot的优点：&lt;/p&gt;
&lt;p&gt;　　（1）快速创建独立运行的Spring项目以及与主流框架集成&lt;/p&gt;
&lt;p&gt;　　（2）使用嵌入式的Servlet容器，应用无需打成WAR包跑在servlet容器上。打成Jar包，然后java -jar即可运行&lt;/p&gt;
&lt;p&gt;　　（3）starters自动依赖与版本控制&lt;/p&gt;
&lt;p&gt;　　（4）大量的自动配置，简化开发，也可以修改默认值&lt;/p&gt;
&lt;p&gt;　　（5）无需配置XML，无代码生成，开箱即用&lt;/p&gt;
&lt;p&gt;　　（6）准生产环境的运行时应用监控&lt;/p&gt;
&lt;p&gt;　　（7）与云计算的天然集成&lt;/p&gt;
&lt;p&gt;4，SpringBoot的缺点：入门容易，精通难。之所以那么说，是因为SpringBoot是基于SpringBoot的一个再封装，如果你对Spring框架一无所知，那就做不到精通。&lt;/p&gt;
&lt;p&gt;5.HelloWord&lt;/p&gt;
&lt;p&gt;　　（1）创建一个maven工程。&lt;/p&gt;
&lt;p&gt;　　（2）导入SpringBoot的依赖&lt;/p&gt;
&lt;p&gt;　　（3）建一个类，在类上标注@SpringBootApplication,来告诉SpringBoot这是一个主程序类，说明这是一个SpringBoot应用&lt;/p&gt;
&lt;p&gt;　　（4）再主程序类里添加main方法（idea快捷键：psvm），然后在main方法里添加SpringApplication.run(主程序类.class,args);&lt;/p&gt;
&lt;p&gt;　　（5）编写相关的Controller、Service等。&lt;/p&gt;
&lt;p&gt;　　（6）运行测试：主程序里直接运行main方法即可开启应用。tomcat8080端口（内置了tomcat）。&lt;/p&gt;
&lt;p&gt;　　（7）部署：导入SpingBoot的Maven插件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1530724/201811/1530724-20181112154058257-1427976925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　这个插件的作用就是将应用打包成可执行的jar包。&lt;/p&gt;
&lt;p&gt;　　（8）运行：java -jar命令即可启动。即使目标服务器里没有装tomcat也没问题。&lt;/p&gt;



</description>
<pubDate>Mon, 12 Nov 2018 07:53:00 +0000</pubDate>
<dc:creator>一头生猛的程序猿</dc:creator>
<og:description>1.背景：以前假如想创建一个Spring应用， 比如Spring、SpringMVC、Mybatis三大框架的整合， 我们需要一对繁琐的步骤：maven导一堆依赖--&gt;写一堆配置文件--&gt;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shenhanboBlog/p/9946946.html</dc:identifier>
</item>
<item>
<title>IOC和AOP使用拓展 - 安心。</title>
<link>http://www.cnblogs.com/anxin0/p/9946835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anxin0/p/9946835.html</guid>
<description>&lt;h3 id=&quot;多种方式实现依赖注入&quot;&gt;多种方式实现依赖注入&lt;/h3&gt;
&lt;h4 id=&quot;构造注入&quot;&gt;构造注入&lt;/h4&gt;
&lt;p&gt;编写测试类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UserServiceImpl implements UserService {

    // 声明接口类型的引用,和具体实现类解耦合
    private UserDao dao;

    // 无参构造
    public UserServiceImpl() {
    }

    // 用于为dao属性赋值的构造方法
    public UserServiceImpl(UserDao dao) {
        this.dao = dao;
    }

    public void addNewUser(User user) {
        // 调用用户DAO的方法保存用户信息
        dao.save(user);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用设值注入时,Spring通过JavaBean无参构造方法实例化对象,当我们编写带参构造方法后,java虚拟机不会再提供默认的无参构造方法,为了保证使用的灵活性,建议自行添加一个无参构造方法&lt;br/&gt;配置文件代码如下:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd &quot;&amp;gt;
    &amp;lt;!-- 定义UserDaoImpl对象,并指定id为userDao --&amp;gt;
    &amp;lt;bean id=&quot;userDao&quot; class=&quot;dao.impl.UserDaoImpl&quot; /&amp;gt;
    &amp;lt;!-- 定义UserServiceImpl对象,并指定id为userService --&amp;gt;
    &amp;lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;&amp;gt;
        &amp;lt;!-- 通过定义的单参构造为userService的dao属性赋 值 --&amp;gt;
        &amp;lt;constructor-arg&amp;gt;
            &amp;lt;!-- 引用id为userDao的对象为userService的dao属性赋值 --&amp;gt;
            &amp;lt;ref bean=&quot;userDao&quot; /&amp;gt;
        &amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1 一个 constructor-arg元素表示构造方法的一个参数，且使用时不区分顺序。&lt;br/&gt;2 通过constructor-arg元素的index 属性可以指定该参数的位置索引，位置从0 开始。&lt;br/&gt;3 constructor-arg元素还提供了type 属性用来指定参数的类型，避免字符串和基本数据类型的混淆。&lt;/p&gt;
&lt;p&gt;constructor-arg节点下的四个属性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;index是索引，指定注入的属性，从0开始，如：0代表personDao，1代表str属性；&lt;/li&gt;
&lt;li&gt;type是指该属性所对应的类型，如Persondao对应的是com.aptech.dao.PersonDAO；&lt;/li&gt;
&lt;li&gt;ref 是指引用的依赖对象；&lt;/li&gt;
&lt;li&gt;value 当注入的不是依赖对象，而是基本数据类型时，就用value；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;Rod&quot; class=&quot;cn.springdemo.Greeting&quot;&amp;gt;
    &amp;lt;constructor-arg index=&quot;1&quot;&amp;gt;
    &amp;lt;value&amp;gt;Rod&amp;lt;/value&amp;gt;
    &amp;lt;/constructor-arg&amp;gt;
    &amp;lt;constructor-arg index=&quot;0&quot;&amp;gt;
    &amp;lt;value&amp;gt;世界上有10种人&amp;lt;/value&amp;gt;
    &amp;lt;/constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用p命名空间实现属性注入&quot;&gt;使用p命名空间实现属性注入&lt;/h4&gt;
&lt;p&gt;p命名空间的特点:使用属性而不是子元素的形式配置Bean的属性,从而简化了配置代码&lt;br/&gt;语法:&lt;br/&gt;对于直接量（基本数据类型、字符串）属性：p:属性名=&quot;属性值&quot;&lt;br/&gt;对于引用Bean的属性：p:属性名-ref=&quot;Bean的id&quot;&lt;br/&gt;使用前先要在Spring配置文件中引入p命名空间&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;!-- 使用p命名空间注入属性值 --&amp;gt;
    &amp;lt;bean id=&quot;user&quot; class=&quot;entity.User&quot; p:username=&quot;皮皮&quot; p:age=&quot;21&quot;
        p:email=&quot;pipi@anxin.com&quot; /&amp;gt;
    &amp;lt;bean id=&quot;userDao&quot; class=&quot;dao.impl.UserDaoImpl&quot; /&amp;gt;
    &amp;lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot; p:dao-ref=&quot;userDao&quot; /&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;注入不同数据类型&quot;&gt;注入不同数据类型&lt;/h4&gt;
&lt;h5 id=&quot;注入直接量&quot;&gt;注入直接量&lt;/h5&gt;
&lt;p&gt;  使用&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;user&quot; class=&quot;entity.User&quot;&amp;gt;
    &amp;lt;property name=&quot;username&quot;&amp;gt;
        &amp;lt;value&amp;gt;张三&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;age&quot;&amp;gt;
        &amp;lt;value&amp;gt;23&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果属性值中包含了XML文件的特殊字符(&amp;amp; &amp;lt; &amp;gt; &quot; '),则注入需要进行处理,通常可以采用两种办法,使用&amp;lt;[CDATA[]]&amp;gt;标记或把特殊字符替换为实体引用.&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;product&quot; class=&quot;entity.Product&quot;&amp;gt;
         &amp;lt;!-- 使用&amp;lt;![CDATA[]]&amp;gt;标记处理XML特 殊字符 --&amp;gt;
        &amp;lt;property name=&quot;specialCharacter1&quot;&amp;gt;
            &amp;lt;value&amp;gt;&amp;lt;![CDATA[P&amp;amp;G]]&amp;gt;&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!-- 把XML特殊字符替换为实体引用 --&amp;gt;
        &amp;lt;property name=&quot;specialCharacter2&quot;&amp;gt;
            &amp;lt;value&amp;gt;P&amp;amp;amp;G&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
&amp;lt;bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;amp; lt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;amp; gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;&amp;amp; amp;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;'&lt;/td&gt;
&lt;td&gt;&amp;amp; apos;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&quot;&lt;/td&gt;
&lt;td&gt;&amp;amp; quot;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注意:在XML文件中字符&quot;&amp;lt;&quot;和“&amp;amp;”是非法的,其他3个符号是合法的,但是将它们替换为实体引用是个好习惯&lt;/p&gt;
&lt;h5 id=&quot;引用其他bean组件&quot;&gt;引用其他Bean组件&lt;/h5&gt;
&lt;p&gt;Spring中定义的Bean可以互相引用,从而建立依赖关系,除了使用ref属性,还可以通过&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;userDao&quot; class=&quot;dao.impl.UserDaoImpl&quot;/&amp;gt;
&amp;lt;bean id=&quot;userService&quot;  class=&quot;service.impl.UserServiceImpl&quot;&amp;gt;
    &amp;lt;property name=&quot;dao&quot;&amp;gt;
        &amp;lt;ref bean=&quot;userDao&quot;/&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用内部Bean&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- 定义内部Bean --&amp;gt;
&amp;lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;&amp;gt;
    &amp;lt;property name=&quot;dao&quot;&amp;gt;
        &amp;lt;bean class=&quot;dao.impl.UserDaoImpl&quot;/&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样这个UserDaoImpl类型的Bean就只能被userUservice使用,其他的Bean则无法使用&lt;/p&gt;
&lt;h5 id=&quot;注入集合类型的属性&quot;&gt;注入集合类型的属性&lt;/h5&gt;
&lt;p&gt;对于List或数组类型的属性,可以使用&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- 注入List类型 --&amp;gt;
&amp;lt;property name=&quot;list&quot;&amp;gt;
    &amp;lt;list&amp;gt;
        &amp;lt;!-- 定义List中的元素 --&amp;gt;
        &amp;lt;value&amp;gt;足球&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;篮球&amp;lt;/value&amp;gt;
    &amp;lt;/list&amp;gt;
&amp;lt;/property&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- 注入Map类型 --&amp;gt;
&amp;lt;property name=&quot;map&quot;&amp;gt;
    &amp;lt;map&amp;gt;
        &amp;lt;!-- 定义Map中的键值对 --&amp;gt;
        &amp;lt;entry&amp;gt;
            &amp;lt;key&amp;gt;
                &amp;lt;value&amp;gt;football&amp;lt;/value&amp;gt;
            &amp;lt;/key&amp;gt;
            &amp;lt;value&amp;gt;足球&amp;lt;/value&amp;gt;
        &amp;lt;/entry&amp;gt;
        &amp;lt;entry&amp;gt;
            &amp;lt;key&amp;gt;
                &amp;lt;value&amp;gt;basketball&amp;lt;/value&amp;gt;
            &amp;lt;/key&amp;gt;
            &amp;lt;value&amp;gt;篮球&amp;lt;/value&amp;gt;
        &amp;lt;/entry&amp;gt;
    &amp;lt;/map&amp;gt;
&amp;lt;/property&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注入null和空字符串值&lt;br/&gt;可以使用注入空字符串,使用&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- 注入空字符串值 --&amp;gt;
&amp;lt;property name=&quot;emptyValue&quot;&amp;gt;
    &amp;lt;value&amp;gt;&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
    &amp;lt;!-- 注入null值 --&amp;gt;
&amp;lt;property name=&quot;nullValue&quot;&amp;gt;
    &amp;lt;null/&amp;gt;
&amp;lt;/property&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;其他增强类型&quot;&gt;其他增强类型&lt;/h4&gt;
&lt;p&gt;Spring支持多种增强类型,除了我们上一篇文章说的前置增强和后置增强,在这里我们在补充几种常用的增强类型&lt;/p&gt;
&lt;h5 id=&quot;异常抛出增强&quot;&gt;异常抛出增强&lt;/h5&gt;
&lt;p&gt;异常抛出增强的特点是在目标方法抛出异常时织入增强处理。使用异常抛出增强,可以为各功能模块提供统一的,可拨插的异常处理方案&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 定义包含增强方法的JavaBean
 */
public class ErrorLogger {
    private static final Logger log = Logger.getLogger(ErrorLogger.class);

    public void afterThrowing(JoinPoint jp, RuntimeException e) {
        log.error(jp.getSignature().getName() + &quot; 方法发生异常：&quot; + e);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring配置文件&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- 声明增强方法所在的Bean --&amp;gt;
&amp;lt;bean id=&quot;theLogger&quot; class=&quot;aop.ErrorLogger&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置切面 --&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;!-- 定义切入点 --&amp;gt;
        &amp;lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* service.UserService.*(..))&quot; /&amp;gt;
        &amp;lt;!-- 引用包含增强方法的Bean --&amp;gt;
        &amp;lt;aop:aspect ref=&quot;theLogger&quot;&amp;gt;
            &amp;lt;!-- 将afterThrowing()方法定义为异常抛出增强并引用pointcut切入点 --&amp;gt;
            &amp;lt;!-- 通过throwing属性指定为名为e的参数注入异常实例 --&amp;gt;
            &amp;lt;aop:after-throwing method=&quot;afterThrowing&quot;
                pointcut-ref=&quot;pointcut&quot; throwing=&quot;e&quot; /&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;expression指示符我们上一篇文章已经说话大家可以先看一下上一篇文章&lt;br/&gt;使用&lt;/p&gt;
&lt;h5 id=&quot;最终增强&quot;&gt;最终增强&lt;/h5&gt;
&lt;p&gt;最终增强的特点是无论抛出异常还是正常退出,该增强都会得到执行,类似于异常处理机制中finally块的作用,一般用于释放资源,使用最终增强,就可以为各功能模块提供统一的,可拨插的处理方案.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 定义包含增强方法的JavaBean
 */
public class AfterLogger {
    private static final Logger log = Logger.getLogger(AfterLogger.class);

    public void afterLogger(JoinPoint jp) {
        log.info(jp.getSignature().getName() + &quot; 方法结束执行。&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring配置文件&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- 声明增强方法所在的Bean --&amp;gt;
    &amp;lt;bean id=&quot;theLogger&quot; class=&quot;aop.AfterLogger&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置切面 --&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;!-- 定义切入点 --&amp;gt;
        &amp;lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* service.UserService.*(..))&quot; /&amp;gt;
        &amp;lt;!-- 引用包含增强方法的Bean --&amp;gt;
        &amp;lt;aop:aspect ref=&quot;theLogger&quot;&amp;gt;
            &amp;lt;!-- 将afterLogger()方法定义为最终增强并引用pointcut切入点 --&amp;gt;
            &amp;lt;aop:after method=&quot;afterLogger&quot; pointcut-ref=&quot;pointcut&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;h5 id=&quot;环绕增强&quot;&gt;环绕增强&lt;/h5&gt;
&lt;p&gt;环绕增强在目标方法的前后都可以织入增强处理.环绕增强是功能最强大的增强处理,Spring把目标方法的控制权全部交给它,在环绕增强处理中,可以获取或修改目标方法的参数,返回值可以对它进行异常处理,甚至可以决定目标方法是否被执行.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 定义包含增强方法的JavaBean
 */
public class AroundLogger {
    private static final Logger log = Logger.getLogger(AroundLogger.class);

    public Object aroundLogger(ProceedingJoinPoint jp) throws Throwable {
        log.info(&quot;调用 &quot; + jp.getTarget() + &quot; 的 &quot; + jp.getSignature().getName()
                + &quot; 方法。方法入参：&quot; + Arrays.toString(jp.getArgs()));
        try {
            Object result = jp.proceed();
            log.info(&quot;调用 &quot; + jp.getTarget() + &quot; 的 &quot;
                    + jp.getSignature().getName() + &quot; 方法。方法返回值：&quot; + result);
            return result;
        } catch (Throwable e) {
            log.error(jp.getSignature().getName() + &quot; 方法发生异常：&quot; + e);
            throw e;
        } finally {
            log.info(jp.getSignature().getName() + &quot; 方法结束执行。&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring配置文件&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- 声明增强方法所在的Bean --&amp;gt;
&amp;lt;bean id=&quot;theLogger&quot; class=&quot;aop.AroundLogger&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置切面 --&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;!-- 定义切入点 --&amp;gt;
        &amp;lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* service.UserService.*(..))&quot; /&amp;gt;
        &amp;lt;!-- 引用包含增强方法的Bean --&amp;gt;
        &amp;lt;aop:aspect ref=&quot;theLogger&quot;&amp;gt;
            &amp;lt;!-- 将aroundLogger()方法定义为环绕增强并引用pointcut切入点 --&amp;gt;
            &amp;lt;aop:around method=&quot;aroundLogger&quot; pointcut-ref=&quot;pointcut&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Before&lt;/td&gt;
&lt;td&gt;前置增强处理，在目标方法前织入增强处理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;AfterReturning&lt;/td&gt;
&lt;td&gt;后置增强处理，在目标方法正常执行（不出现异常）后织入增强处理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;AfterThrowing&lt;/td&gt;
&lt;td&gt;异常增强处理，在目标方法抛出异常后织入增强处理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;After&lt;/td&gt;
&lt;td&gt;最终增强处理，不论方法是否抛出异常，都会在目标方法最后织入增强处理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Around&lt;/td&gt;
&lt;td&gt;环绕增强处理，在目标方法的前后都可以织入增强处理&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Spring AOP配置元素&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;aop:config&lt;/td&gt;
&lt;td&gt;AOP配置的顶层元素，大多数的&amp;lt;aop:*&amp;gt;元素必须包含在&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;aop:pointcut&lt;/td&gt;
&lt;td&gt;定义切点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;aop:aspect&lt;/td&gt;
&lt;td&gt;定义切点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;aop:after&lt;/td&gt;
&lt;td&gt;定义最终增强（不管被通知的方法是否执行成功）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;aop:after-returning&lt;/td&gt;
&lt;td&gt;定义after-returning增强&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;aop:after-throwing&lt;/td&gt;
&lt;td&gt;定义after-throwing增强&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;aop:around&lt;/td&gt;
&lt;td&gt;定义环绕增强&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;aop:before&lt;/td&gt;
&lt;td&gt;定义前置增强&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;aop:aspectj-autoproxy&lt;/td&gt;
&lt;td&gt;启动@AspectJ注解驱动的切面&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;使用注解实现ioc的配置&quot;&gt;使用注解实现IOC的配置&lt;/h4&gt;
&lt;p&gt;前面我们说过用xml的形式配置IOC,那种方式是比较麻烦的,在Spring2.0以后的版本我们就可以使用注解来配置,进一步减少了配置文件的代码&lt;br/&gt;使用注解定义Bean&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 用户业务类,实现对User功能的业务管理
 */
@Service(&quot;userService&quot;)
public class UserServiceImpl implements UserService {

    @Autowired  // 默认按类型匹配
    @Qualifier(&quot;userDao&quot;) // 按指定名称匹配
    private UserDao dao;

    // 使用@Autowired直接为属性注入，可以省略setter方法
    /*public void setDao(UserDao dao) {
        this.dao = dao;
    }*/

    public void addNewUser(User user) {
        // 调用用户DAO的方法保存用户信息
        dao.save(user);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码我们通过注解定义了一个名为userDao的Bean@Autowired的作用和在xml文件中编写&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--扫描包中注解标注的类--&amp;gt;
&amp;lt;context:component-scan base-package=&quot;service,dao&quot;/&amp;gt;
&amp;lt;!--多个包之前用逗号隔开--&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring还提供了其他的注解&lt;br/&gt;@Componet:实现Bean组件的定义&lt;br/&gt;@Repository:用于标注DAO类&lt;br/&gt;@Service:用于标注业务类&lt;br/&gt;@Controller:用于标注控制器类&lt;br/&gt;@Autowired:实现Bean的自动装配&lt;br/&gt;@Qualifier:指定Bean的名称&lt;br/&gt;@Resource:实现Bean的组件装配&lt;br/&gt;大家可以查看Spring的&lt;a href=&quot;http://shouce.jb51.net/spring/&quot;&gt;开发手册&lt;/a&gt; 进一步了解他们的用法&lt;/p&gt;
&lt;h4 id=&quot;使用注解定义切面&quot;&gt;使用注解定义切面&lt;/h4&gt;
&lt;p&gt;AspectJ&lt;br/&gt;面向切面的框架，它扩展了Java语言，定义了AOP 语法，能够在编译期提供代码的织入&lt;br/&gt;@AspectJ&lt;br/&gt;AspectJ 5新增的功能，使用JDK 5.0 注解技术和正规的AspectJ切点表达式语言描述切面&lt;br/&gt;Spring通过集成AspectJ实现了以注解的方式定义增强类，大大减少了配置文件中的工作量&lt;br/&gt;利用轻量级的字节码处理框架asm处理@AspectJ中所描述的方法参数名&lt;br/&gt;使用注解定义切面实现日志功能&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 使用注解定义切面
 */
@Aspect
public class UserServiceLogger {
    private static final Logger log = Logger.getLogger(UserServiceLogger.class);
    
    @Pointcut(&quot;execution(* service.UserService.*(..))&quot;)
    public void pointcut() {}

    @Before(&quot;pointcut()&quot;)
    public void before(JoinPoint jp) {
        log.info(&quot;调用 &quot; + jp.getTarget() + &quot; 的 &quot; + jp.getSignature().getName()
                + &quot; 方法。方法入参：&quot; + Arrays.toString(jp.getArgs()));
    }
    @AfterReturning(pointcut = &quot;pointcut()&quot;, returning = &quot;returnValue&quot;)
    public void afterReturning(JoinPoint jp, Object returnValue) {
        log.info(&quot;调用 &quot; + jp.getTarget() + &quot; 的 &quot; + jp.getSignature().getName()
                + &quot; 方法。方法返回值：&quot; + returnValue);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切入点表达式使用@Pointcut注解来表示,而切入点签名则需要一个普通的方法定义来提供,&lt;br/&gt;如上面代码中的pointcut()方法,作为切入点签名的方法必须返回void类型,切入点定义好后,就可以使用pointcut()签名进行引用&lt;br/&gt;定义完切面后,还需要在Spring配置文件中完成织入工作&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt; &amp;lt;context:component-scan base-package=&quot;service,dao&quot; /&amp;gt;
    &amp;lt;bean class=&quot;aop.UserServiceLogger&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;aop:aspectj-autoproxy /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件中首先要导入aop命名空间,只需要在配置文件中添加&lt;/p&gt;
&lt;h5 id=&quot;使用注解定义其他类型增强&quot;&gt;使用注解定义其他类型增强&lt;/h5&gt;
&lt;p&gt;异常抛出增强&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 通过注解实现异常抛出增强
 */
@Aspect
public class ErrorLogger {
    private static final Logger log = Logger.getLogger(ErrorLogger.class);

    @AfterThrowing(pointcut = &quot;execution(* service.UserService.*(..))&quot;, throwing = &quot;e&quot;)
    public void afterThrowing(JoinPoint jp, RuntimeException e) {
        log.error(jp.getSignature().getName() + &quot; 方法发生异常：&quot; + e);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用AfterThrowing注解可以定义异常抛出增强,如果需要获取抛出的异常,可以为增强方法声明相关类型的参数,并通过@AfterThrowing注解的throwing属性指定该参数名称,Spring会为其注入从目标方法抛出的异常实例&lt;br/&gt;其他的方法都是大同小异,大家可以自己动手试一试&lt;br/&gt;@Aspect(定义一个切面 )&lt;br/&gt;@Before(前置增强)&lt;br/&gt;@AfterReturning(后置增强)&lt;br/&gt;@Around (环绕增强)&lt;br/&gt;@AfterThrowing(异常抛出增强)&lt;br/&gt;@After(最终增强)&lt;/p&gt;
&lt;p&gt;在配置文件中添加&lt;/p&gt;
&lt;p&gt;写的不好还有不懂的地方,大家可以留言一下 我会尽量解决&lt;br/&gt;by安心&lt;/p&gt;
</description>
<pubDate>Mon, 12 Nov 2018 07:39:00 +0000</pubDate>
<dc:creator>安心。</dc:creator>
<og:description>多种方式实现依赖注入 构造注入 编写测试类 在使用设值注入时,Spring通过JavaBean无参构造方法实例化对象,当我们编写带参构造方法后,java虚拟机不会再提供默认的无参构造方法,为了保证使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anxin0/p/9946835.html</dc:identifier>
</item>
<item>
<title>Elasticsearch Java Rest Client API 整理总结 (二) —— SearchAPI - ReyCG</title>
<link>http://www.cnblogs.com/reycg-blog/p/9946821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reycg-blog/p/9946821.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/reycg-blog/p/9931482.html&quot;&gt;上一篇&lt;/a&gt; 中主要整理了 Document API，本节中主要讲解 &lt;code&gt;search API&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;search-apis&quot;&gt;Search APIs&lt;/h2&gt;
&lt;p&gt;Java High Level REST Client 支持下面的 Search API：&lt;/p&gt;
&lt;p&gt;对于普通查询需求来说， &lt;code&gt;Search API&lt;/code&gt; 使用最多，本篇只介绍这一部分。&lt;/p&gt;
&lt;h3 id=&quot;search-api&quot;&gt;Search API&lt;/h3&gt;
&lt;h4 id=&quot;search-request&quot;&gt;Search Request&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;searchRequest&lt;/code&gt; 用来完成和查询文档，聚合文章，获取查询建议以及提供了各种方式来完成对查询结果的高亮操作。&lt;/p&gt;
&lt;p&gt;最基本的查询操作如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SearchRequest searchRequest = new SearchRequest(); 
SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); 
searchSourceBuilder.query(QueryBuilders.matchAllQuery()); // 添加 match_all 查询
searchRequest.source(searchSourceBuilder); // 将 SearchSourceBuilder  添加到 SeachRequest 中&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;可选参数&quot;&gt;可选参数&lt;/h4&gt;
&lt;p&gt;限制 index, 限制 type&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SearchRequest searchRequest = new SearchRequest(&quot;posts&quot;); 
searchRequest.types(&quot;doc&quot;); &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用-searchsourcebuilder&quot;&gt;使用 SearchSourceBuilder&lt;/h4&gt;
&lt;p&gt;对查询行为的配置可以使用 &lt;code&gt;SearchSourceBuilder&lt;/code&gt; 来完成，先来看一个实例&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();  // 默认配置
sourceBuilder.query(QueryBuilders.termQuery(&quot;user&quot;, &quot;kimchy&quot;)); // 设置查询，可以是任何类型的 QueryBuilder
sourceBuilder.from(0); // 起始 index
sourceBuilder.size(5); // 大小 size
sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS)); // 设置查询的超时时间&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置完成，添加到 &lt;code&gt;SearchRequest&lt;/code&gt; 中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SearchRequest searchRequest = new SearchRequest();
searchRequest.source(sourceBuilder);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;构建查询条件&quot;&gt;构建查询条件&lt;/h4&gt;
&lt;p&gt;查询请求是通过使用 &lt;code&gt;QueryBuilder&lt;/code&gt; 对象来完成的，并且支持 &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.3/query-dsl.html&quot;&gt;Query DSL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用构造函数创建 &lt;code&gt;QueryBuilder&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;MatchQueryBuilder matchQueryBuilder = new MatchQueryBuilder(&quot;user&quot;, &quot;kimchy&quot;); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;QueryBuilder&lt;/code&gt; 创建后，就可以通过各种方法来配置查询选项：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;matchQueryBuilder.fuzziness(Fuzziness.AUTO);  // 模糊查询
matchQueryBuilder.prefixLength(3); // 前缀查询的长度
matchQueryBuilder.maxExpansions(10); // max expansion 选项，用来控制模糊查询&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用&lt;code&gt;QueryBuilders&lt;/code&gt; 工具类来创建 &lt;code&gt;QueryBuilder&lt;/code&gt; 对象。这个类提供了函数式编程风格的各种方法用来快速创建 &lt;code&gt;QueryBuilder&lt;/code&gt; 对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;QueryBuilder matchQueryBuilder = QueryBuilders.matchQuery(&quot;user&quot;, &quot;kimchy&quot;)
                                            .fuzziness(Fuzziness.AUTO)
                                                .prefixLength(3)
                                                .maxExpansions(10);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不论什么方式创建的 &lt;code&gt;QueryBuilder&lt;/code&gt; ，最后都需要添加到 `&lt;code&gt;SearchSourceBuilder&lt;/code&gt; 中&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;searchSourceBuilder.query(matchQueryBuilder);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.3/java-rest-high-query-builders.html&quot;&gt;构建查询&lt;/a&gt; 文档中提供了一个丰富的查询列表，大家可以去参考。&lt;/p&gt;
&lt;h4 id=&quot;指定排序&quot;&gt;指定排序&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;SearchSourceBuilder&lt;/code&gt; 允许添加一个或多个&lt;code&gt;SortBuilder&lt;/code&gt; 实例。这里包含 4 种特殊的实现, (&lt;code&gt;Field-&lt;/code&gt;, &lt;code&gt;Score-&lt;/code&gt;, &lt;code&gt;GeoDistance-&lt;/code&gt; 和 &lt;code&gt;ScriptSortBuilder&lt;/code&gt;)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;sourceBuilder.sort(new ScoreSortBuilder().order(SortOrder.DESC)); // 根据分数 _score 降序排列 (默认行为)
sourceBuilder.sort(new FieldSortBuilder(&quot;_uid&quot;).order(SortOrder.ASC));  // 根据 id 降序排列&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;过滤数据源&quot;&gt;过滤数据源&lt;/h4&gt;
&lt;p&gt;默认情况下，查询请求会返回文档的内容 &lt;code&gt;_source&lt;/code&gt; ,当然我们也可以覆盖它。例如，禁止对 &lt;code&gt;_source&lt;/code&gt; 的获取&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;sourceBuilder.fetchSource(false);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用通配符模式以更细的粒度包含或排除特定的字段：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String[] includeFields = new String[] {&quot;title&quot;, &quot;user&quot;, &quot;innerObject.*&quot;};
String[] excludeFields = new String[] {&quot;_type&quot;};
sourceBuilder.fetchSource(includeFields, excludeFields);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;高亮请求&quot;&gt;高亮请求&lt;/h4&gt;
&lt;p&gt;可以通过在 &lt;code&gt;SearchSourceBuilder&lt;/code&gt; 上设置 ·&lt;code&gt;HighlightBuilder&lt;/code&gt; 完成对结果的高亮，而且可以配置字段具有不同的高亮行为。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
HighlightBuilder highlightBuilder = new HighlightBuilder(); 
HighlightBuilder.Field highlightTitle =
        new HighlightBuilder.Field(&quot;title&quot;); // title 字段高亮
highlightTitle.highlighterType(&quot;unified&quot;);  // 配置高亮类型
highlightBuilder.field(highlightTitle);  // 添加到 builder
HighlightBuilder.Field highlightUser = new HighlightBuilder.Field(&quot;user&quot;);
highlightBuilder.field(highlightUser);
searchSourceBuilder.highlighter(highlightBuilder);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;聚合请求&quot;&gt;聚合请求&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.3/java-rest-high-search.html&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;建议请求&quot;&gt;建议请求&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.3/java-rest-high-search.html&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
SuggestionBuilder termSuggestionBuilder =
    SuggestBuilders.termSuggestion(&quot;user&quot;).text(&quot;kmichy&quot;); 
SuggestBuilder suggestBuilder = new SuggestBuilder();
suggestBuilder.addSuggestion(&quot;suggest_user&quot;, termSuggestionBuilder); 
searchSourceBuilder.suggest(suggestBuilder);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;分析请求和聚合&quot;&gt;分析请求和聚合&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.3/search-profile.html&quot;&gt;分析 API&lt;/a&gt; 可用来对一个特定的查询操作中的请求和聚合进行分析，此时要将&lt;code&gt;SearchSourceBuilder&lt;/code&gt; 的 profile标志位设置为 true&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
searchSourceBuilder.profile(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只要 &lt;code&gt;SearchRequest&lt;/code&gt; 执行完成，对应的 &lt;code&gt;SearchResponse&lt;/code&gt; 响应中就会包含 &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.3/java-rest-high-search.html#java-rest-high-retrieve-profile-results&quot;&gt;分析结果&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;同步执行&quot;&gt;同步执行&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SearchResponse searchResponse = client.search(searchRequest);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;异步执行&quot;&gt;异步执行&lt;/h4&gt;
&lt;p&gt;异步执行使用的是 &lt;code&gt;listener&lt;/code&gt; 对结果进行处理。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ActionListener&amp;lt;SearchResponse&amp;gt; listener = new ActionListener&amp;lt;SearchResponse&amp;gt;() {
    @Override
    public void onResponse(SearchResponse searchResponse) {
        // 查询成功
    }

    @Override
    public void onFailure(Exception e) {
        // 查询失败
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;查询响应-searchresponse&quot;&gt;查询响应 SearchResponse&lt;/h4&gt;
&lt;p&gt;查询执行完成后，会返回 &lt;code&gt;SearchResponse&lt;/code&gt; 对象，并在对象中包含查询执行的细节和符合条件的文档集合。&lt;/p&gt;
&lt;p&gt;归纳一下， &lt;code&gt;SerchResponse&lt;/code&gt; 包含的信息如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;请求本身的信息，如 HTTP 状态码，执行时间，或者请求是否超时&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;RestStatus status = searchResponse.status();
TimeValue took = searchResponse.getTook();
Boolean terminatedEarly = searchResponse.isTerminatedEarly();
boolean timedOut = searchResponse.isTimedOut();&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查询影响的分片数量的统计信息，成功和失败的分片&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int totalShards = searchResponse.getTotalShards();
int successfulShards = searchResponse.getSuccessfulShards();
int failedShards = searchResponse.getFailedShards();
for (ShardSearchFailure failure : searchResponse.getShardFailures()) {
    // failures should be handled here
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;检索-searchhits&quot;&gt;检索 SearchHits&lt;/h5&gt;
&lt;p&gt;要访问返回的文档，首先要在响应中获取其中的 &lt;code&gt;SearchHits&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SearchHits hits = searchResponse.getHits();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SearchHits&lt;/code&gt; 中包含了所有命中的全局信息，如查询命中的数量或者最大分值：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;long totalHits = hits.getTotalHits();
float maxScore = hits.getMaxScore();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询的结果嵌套在 &lt;code&gt;SearchHits&lt;/code&gt; 中，可以通过遍历循环获取&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SearchHit[] searchHits = hits.getHits();
for (SearchHit hit : searchHits) {
    // do something with the SearchHit
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SearchHit&lt;/code&gt; 提供了如 &lt;code&gt;index&lt;/code&gt; ， &lt;code&gt;type&lt;/code&gt;， &lt;code&gt;docId&lt;/code&gt; 和每个命中查询的分数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String index = hit.getIndex();
String type = hit.getType();
String id = hit.getId();
float score = hit.getScore();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而且，还可以获取到文档的源数据，以 JSON-String 形式或者 key-value map 对的形式。在 map 中，字段可以是普通类型，或者是列表类型，嵌套对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String sourceAsString = hit.getSourceAsString();
Map&amp;lt;String, Object&amp;gt; sourceAsMap = hit.getSourceAsMap();
String documentTitle = (String) sourceAsMap.get(&quot;title&quot;);
List&amp;lt;Object&amp;gt; users = (List&amp;lt;Object&amp;gt;) sourceAsMap.get(&quot;user&quot;);
Map&amp;lt;String, Object&amp;gt; innerObject =
        (Map&amp;lt;String, Object&amp;gt;) sourceAsMap.get(&quot;innerObject&quot;);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本篇包含了 &lt;strong&gt;Java High level Rest Client&lt;/strong&gt; 的 SearchAPI 部分，下篇会包含 &lt;strong&gt;查询构建 Building Queries&lt;/strong&gt;，敬请期待~&lt;/p&gt;
</description>
<pubDate>Mon, 12 Nov 2018 07:38:00 +0000</pubDate>
<dc:creator>ReyCG</dc:creator>
<og:description>[TOC] 引言 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/reycg-blog/p/9946821.html</dc:identifier>
</item>
<item>
<title>jdk源码阅读笔记-LinkedList - 姓码名农小小</title>
<link>http://www.cnblogs.com/rainple/p/9944713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rainple/p/9944713.html</guid>
<description>&lt;p&gt;　　LinkedList的底层数据结构为双向链表结构，与ArrayList相同的是LinkedList也可以存储相同或null的元素。相对于ArrayList来说，LinkedList的插入与删除的速度更快，时间复杂度为O(1),查找的速度就相对比较慢了，因为每次遍历的时候都必须从链表的头部或者链表的尾部开始遍历，时间复杂度为O(n/2)。为了实现快速插入或删除数据，LinkedList在每个节点都维护了一个前继节点和一个后续节点，这是一种典型的以时间换空间的思想。LinkedList同时也可以实现栈与队列的功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201811/1519364-20181112103029740-1282848869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在LinkedList中每个节点有会有两个指针，一个指向前一个节点，另一个指向下一个节点。链表的头部的前指针为null，尾部的后指针也为null，因此也可以说明LinkedList（基于jdk1.8）是非循环双向链表结构。源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; {
        E item;
        Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; next;
        Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; prev;

        Node(Node&lt;/span&gt;&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.item =&lt;span&gt; element;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prev =&lt;span&gt; prev;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是一个私有静态内部类&lt;/p&gt;

&lt;p&gt;　　1、size: 链表的长度&lt;/p&gt;
&lt;p&gt;　　2、first：链表的第一个节点&lt;/p&gt;
&lt;p&gt;　　3、last：链表的最后一个节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
transient &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Pointer to first node.
     * Invariant: (first == null &amp;amp;&amp;amp; last == null) ||
     *            (first.prev == null &amp;amp;&amp;amp; first.item != null)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    transient Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; first;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Pointer to last node.
     * Invariant: (first == null &amp;amp;&amp;amp; last == null) ||
     *            (last.next == null &amp;amp;&amp;amp; last.item != null)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    transient Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; last;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Constructs an empty list.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;　　1、链表头部添加新节点&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Links e as first element.
     *  链接头部
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; linkFirst(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表的第一个节点&lt;/span&gt;
        final Node&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建节点&lt;/span&gt;
        final Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, e, f);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新创建的节点放到链条头部&lt;/span&gt;
        first =&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当链表为null时，链表头部和尾部都指向新节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            last &lt;/span&gt;=&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            f.prev &lt;/span&gt;= newNode;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把原本第一个节点的前一个节点指向新的节点&lt;/span&gt;
        size++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表长度加1&lt;/span&gt;
        modCount++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表修改次数加1&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当链表为空的时候比较简单，直接将链表的头部和尾部都指向新节点即可，下面我来说一下在非空的情况下头部插入新节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201811/1519364-20181112105544259-1483299907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;　　2、往链表尾部插入新节点&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Links e as last element.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; linkLast(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原来的最后一个节点&lt;/span&gt;
        final Node&amp;lt;E&amp;gt; l =&lt;span&gt; last;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建新的节点，next为null&lt;/span&gt;
        final Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(l, e, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新节点指向最后一个节点&lt;/span&gt;
        last =&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            first &lt;/span&gt;= newNode;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表为空时第一个节点也指向新节点&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            l.next &lt;/span&gt;= newNode;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将原最后一个节点的next指针指向新节点&lt;/span&gt;
        size++&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201811/1519364-20181112110534779-1099582226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;　　3、在指定节点之前插入新节点&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Inserts element e before non-null Node succ.
     *  指定节点之前插入新节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; linkBefore(E e, Node&amp;lt;E&amp;gt;&lt;span&gt; succ) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert succ != null;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定的节点的前一个节点&lt;/span&gt;
        final Node&amp;lt;E&amp;gt; pred =&lt;span&gt; succ.prev;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;待插入的新节点，新节点的前一个节点为 指定节点的前一个节点，下一个节点为指定节点&lt;/span&gt;
        final Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;&lt;span&gt;(pred, e, succ);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定节点的前一个节点指向新节点&lt;/span&gt;
        succ.prev =&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pred == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            first &lt;/span&gt;= newNode;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果指定节点为第一个节点，那么将节点设置为头部&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            pred.next &lt;/span&gt;= newNode;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则将前一个的下一个节点指向新节点&lt;/span&gt;
        size++&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 流程：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201811/1519364-20181112112914863-2103468261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;　　1、删除第一个节点&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Unlinks non-null first node f.
     * 删除第一个节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; E unlinkFirst(Node&amp;lt;E&amp;gt;&lt;span&gt; f) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert f == first &amp;amp;&amp;amp; f != null;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个节点&lt;/span&gt;
        final E element =&lt;span&gt; f.item;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个节点的前一个节点&lt;/span&gt;
        final Node&amp;lt;E&amp;gt; next =&lt;span&gt; f.next;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将前一个节点和原第一个节点掷为空，方便回收&lt;/span&gt;
        f.item = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        f.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把原第一个节点设置成第一个节点&lt;/span&gt;
        first =&lt;span&gt; next;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表只有一个节点的情况&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            last &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            next.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将原节点的下一个的前一个节点设置为null，因为该节点已经设置为第一个节点，而第一个节点的前一个节点为null&lt;/span&gt;
        size--&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201811/1519364-20181112113921692-741124235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;　　2、删除链表最后一个节点&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Unlinks non-null last node l.
     * 删除最后一个节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; E unlinkLast(Node&amp;lt;E&amp;gt;&lt;span&gt; l) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert l == last &amp;amp;&amp;amp; l != null;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后一个节点&lt;/span&gt;
        final E element =&lt;span&gt; l.item;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后一个节点的前一个节点&lt;/span&gt;
        final Node&amp;lt;E&amp;gt; prev =&lt;span&gt; l.prev;
        l.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        l.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
        last =&lt;span&gt; prev;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有一个节点的情况&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (prev == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            first &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            prev.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将前一个节点的下一个节点掷为null&lt;/span&gt;
        size--&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201811/1519364-20181112114459781-1197120491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;　　3、删除指定节点&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Unlinks non-null node x.
     * 删除指定节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E unlink(Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; x) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert x != null;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定节点的数据&lt;/span&gt;
        final E element =&lt;span&gt; x.item;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定节点的下一个节点&lt;/span&gt;
        final Node&amp;lt;E&amp;gt; next =&lt;span&gt; x.next;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定节点的前一个节点&lt;/span&gt;
        final Node&amp;lt;E&amp;gt; prev =&lt;span&gt; x.prev;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定节点为第一个节点，将下一个节点设置为第一个节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (prev == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            first &lt;/span&gt;=&lt;span&gt; next;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则，将指定节点的前一个节点指向指定节点的下一个节点&lt;/span&gt;
            prev.next =&lt;span&gt; next;
            x.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定节点为最后一个节点，将前一个节点设置为最后一个节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            last &lt;/span&gt;=&lt;span&gt; prev;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则，&lt;/span&gt;
            next.prev =&lt;span&gt; prev;
            x.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        x.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        size&lt;/span&gt;--&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201811/1519364-20181112123731760-1384609545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;　　1、add方法：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Appends the specified element to the end of this list.
     *
     * &amp;lt;p&amp;gt;This method is equivalent to {@link #addLast}.
     *
     * @param e element to be appended to this list
     * @return {@code true} (as specified by {@link Collection#add})
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean add(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向链表的最后位置插入一个节点&lt;/span&gt;
&lt;span&gt;        linkLast(e);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;　　2、addFirst方法：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Inserts the specified element at the beginning of this list.
     *
     * @param e the element to add
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addFirst(E e) {
        linkFirst(e);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体的插入流程可参照第4部分；&lt;/p&gt;
&lt;h2&gt;　　3、addLast方法：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Appends the specified element to the end of this list.
     *
     * &amp;lt;p&amp;gt;This method is equivalent to {@link #add}.
     *
     * @param e the element to add
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addLast(E e) {
        linkLast(e);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体流程参照第四部分的linkLast方法解释；&lt;/p&gt;


&lt;p&gt;　　获取数据也是分为3个方法，获取链表头部的节点数据，尾部节点数据和其他的节点数据。获取头部和尾部比简单，直接获取first节点或last节点就可以了，这里我们主要看一下是怎么获取其他的节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Returns the element at the specified position in this list.
     *
     * @param index index of the element to return
     * @return the element at the specified position in this list
     * @throws IndexOutOfBoundsException {@inheritDoc}
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; E &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        checkElementIndex(index);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node(index).item;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从源码中可以看到，获取其他节点的数据时，是根据下标来获取的，首先先检查输入的index下标是否有越界的嫌疑，然后node方法，下面我们看一下node方法具体实现方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Returns the (non-null) Node at the specified element index.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Node&lt;/span&gt;&amp;lt;E&amp;gt; node(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert isElementIndex(index);&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 传入的index如果大于链表长度的一半，那个从链表后面向前遍历
         * 否则，从前面开始遍历
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)) {
            Node&lt;/span&gt;&amp;lt;E&amp;gt; x =&lt;span&gt; first;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; index; i++&lt;span&gt;)
                x &lt;/span&gt;=&lt;span&gt; x.next;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Node&lt;/span&gt;&amp;lt;E&amp;gt; x =&lt;span&gt; last;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size - &lt;span&gt;1&lt;/span&gt;; i &amp;gt; index; i--&lt;span&gt;)
                x &lt;/span&gt;=&lt;span&gt; x.prev;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从代码中可以看到，如果使用get(index)方法时，每一次都需要从头部或尾部开始遍历，效率比较低。如果要遍历LinkedList，也不推荐这种方式。&lt;/p&gt;


&lt;p&gt;　　删除数据也是3中方法，只讲删除其他节点数据的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Removes the first occurrence of the specified element from this list,
     * if it is present.  If this list does not contain the element, it is
     * unchanged.  More formally, removes the element with the lowest index
     * {@code i} such that
     * &amp;lt;tt&amp;gt;(o==null&amp;amp;nbsp;?&amp;amp;nbsp;get(i)==null&amp;amp;nbsp;:&amp;amp;nbsp;o.equals(get(i)))&amp;lt;/tt&amp;gt;
     * (if such an element exists).  Returns {@code true} if this list
     * contained the specified element (or equivalently, if this list
     * changed as a result of the call).
     *
     * @param o element to be removed from this list, if present
     * @return {@code true} if this list contained the specified element
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean remove(Object o) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为null的情况，从头部开始查找&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    unlink(x);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非null，从头部开始查找，然后删除掉&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(x.item)) {
                    unlink(x);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从源码中可以看到，在删除元素的时候是从第一个节点开始一个一个遍历，通过equals方法的来获取到需要删除节点，然后调用unlinke方法将节点删除掉的。&lt;/p&gt;


&lt;p&gt;　　栈的数据结构实现了FIFO的顺序，即先进先出的规则。&lt;/p&gt;
&lt;h2&gt;　　1、push方法：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Pushes an element onto the stack represented by this list.  In other
     * words, inserts the element at the front of this list.
     *
     * &amp;lt;p&amp;gt;This method is equivalent to {@link #addFirst}.
     *
     * @param e the element to push
     * @since 1.6
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; push(E e) {
        addFirst(e);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　每次添加数据的时候都是添加到链表头部。&lt;/p&gt;
&lt;h2&gt;　　2、pop方法：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Pops an element from the stack represented by this list.  In other
     * words, removes and returns the first element of this list.
     *
     * &amp;lt;p&amp;gt;This method is equivalent to {@link #removeFirst()}.
     *
     * @return the element at the front of this list (which is the top
     *         of the stack represented by this list)
     * @throws NoSuchElementException if this list is empty
     * @since 1.6
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E pop() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; removeFirst();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　往栈中获取一个数据，同时也将栈的第一个数据删除。&lt;/p&gt;
&lt;h2&gt;　　3、peek方法：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Retrieves, but does not remove, the head (first element) of this list.
     *
     * @return the head of this list, or {@code null} if this list is empty
     * @since 1.5
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peek() {
        final Node&lt;/span&gt;&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : f.item;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看栈中的第一个数据，跟pop方法的区别是peek方法只是查看数据，并没有删除数据，pop是从栈中弹出一个数据，需要从栈中删除数据。&lt;/p&gt;


&lt;p&gt;　　队列也是我们在开发的过程经常使用到数据结构，比如消息队列等，队列的特点是每次添加数据的时候都是添加大队列的尾部，获取数据时总是从头部拉取。基于以上特点，我们可以使用LinkedList中的linkLast方式实现数据的添加，使用unLinkfirst方法实现数据的拉取，使用getFisrt方法实现数据的查看，源码如下：&lt;/p&gt;
&lt;h2&gt;　　1、添加数据：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Adds the specified element as the tail (last element) of this list.
     *
     * @param e the element to add
     * @return {@code true} (as specified by {@link Queue#offer})
     * @since 1.5
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean offer(E e) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; add(e);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;　　2、拉取数据：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Retrieves and removes the head (first element) of this list.
     *
     * @return the head of this list, or {@code null} if this list is empty
     * @since 1.5
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E poll() {
        final Node&lt;/span&gt;&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : unlinkFirst(f);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;　　3、查看数据：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Retrieves, but does not remove, the head (first element) of this list.
     *
     * @return the head of this list, or {@code null} if this list is empty
     * @since 1.5
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peek() {
        final Node&lt;/span&gt;&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : f.item;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　1、LinkedList是非线程安全的，在多线程的环境下可能会发生不可预知的结果，所以在多线程环境中谨慎使用它，可以转换成线程类，或是使用线程安全的集合类来代替LinkedList的使用。&lt;/p&gt;
&lt;p&gt;　　2、遍历LinkedList中的数据的时候，切记别使用fori方式（即随机顺序访问get(index)）去遍历，建议使用迭代器或foreach方式遍历。原因在上面的源码中也说到过，可以看一下第七部分数据获取中，使用get(index)方法获取数据时每次都是链表头部或尾部开始遍历，这样是非常不合理的，时间复杂度为O(n^2)。在数据量较小的情况下是没有什么区别，但是数据上去之后，可能会出现程序假死的现象。测试如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws Exception {

        List&lt;/span&gt;&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100000&lt;/span&gt;; i++&lt;span&gt;) {
            list.add(i);
        }

        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++&lt;span&gt;) {
            list.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(i);
        }
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用fori方式所需时间：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (end -&lt;span&gt; start));

        start &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Integer integer : list) {

        }
        end &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用foreach方式所需时间：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (end -&lt;span&gt; start));
        start &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
        Iterator&lt;/span&gt;&amp;lt;Integer&amp;gt; iterator =&lt;span&gt; list.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iterator.hasNext()){
            Integer next &lt;/span&gt;=&lt;span&gt; iterator.next();
        }
        end &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用迭代器方式所需时间：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (end -&lt;span&gt; start));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　三种遍历10万条数据所需要时间：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
使用fori方式所需时间：&lt;span&gt;5288&lt;/span&gt;&lt;span&gt;
使用foreach方式所需时间：&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
使用迭代器方式所需时间：&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从结果中可以看到，使用迭代器或foreach方式比fori方式快的不是十倍百倍，原因是使用foreach和迭代器的时候每次获取数据后都记录当前的位置index，当下个循环的时候直接在index+1处获取即可，而不需要从新在头部或尾部开始遍历了。&lt;/p&gt;


&lt;p&gt;　　1、LinkedList是非线程安全的。&lt;/p&gt;
&lt;p&gt;　　2、LinkedList可以存储null值或重复的数据。&lt;/p&gt;
&lt;p&gt;　　3、LinkedList底层存储结构为双向链式非循环结构，这种结构添加删除的效率高于查询效率。&lt;/p&gt;
&lt;p&gt;　　4、与ArrayList相比较，LinkedList的删除添加数据效率要比ArrayList高，查询数据效率低于ArrayList。&lt;/p&gt;
&lt;p&gt;　　5、LinkedList可以用于实现stack和queue数据结构，比如：Queue&amp;lt;T&amp;gt; queue = new LinkedList&amp;lt;T&amp;gt;();&lt;/p&gt;
&lt;p&gt;　　6、遍历数据时切勿使用随机访问方式遍历，推荐使用foreach或迭代器遍历。&lt;/p&gt;
&lt;p&gt;　　7、如果文章中有什么写得不对的地方，欢迎大家指出来。&lt;/p&gt;
</description>
<pubDate>Mon, 12 Nov 2018 07:25:00 +0000</pubDate>
<dc:creator>姓码名农小小</dc:creator>
<og:description>一、LinkedList概述 LinkedList的底层数据结构为双向链表结构，与ArrayList相同的是LinkedList也可以存储相同或null的元素。相对于ArrayList来说，Linke</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rainple/p/9944713.html</dc:identifier>
</item>
<item>
<title>Mybatis之拦截器原理（jdk动态代理优化版本） - 郝二驴</title>
<link>http://www.cnblogs.com/haoerlv/p/9946535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haoerlv/p/9946535.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;在介绍Mybatis拦截器代码之前，我们先研究下jdk自带的动态代理及优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实动态代理也是一种设计模式...优于静态代理，同时动态代理我知道的有两种，一种是面向接口的jdk的代理，第二种是基于第三方的非面向接口的cglib.&lt;/p&gt;
&lt;p&gt;我们现在说的是jdk的动态代理，因为mybatis拦截器也是基于这个实现的。&lt;/p&gt;

&lt;p&gt;简单介绍就是建立一个目标类的代理类。在执行目标类的方法前先执行代理类的方法，目标类的方法是在代理类中执行的，所以目标类方法执行前后，可以再代理类中进行其他操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;简单版：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Target {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TargetImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Target {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.println(&quot;我就只能做这么多了&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面创建一个代理类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TargetProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TargetProxy(Object target){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     *   缺点   代理需要做的事情不是很灵活。直接在这里面写死了。
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; proxy
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; method
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Throwable
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         System.out.println(&quot;代理在前面做事情了&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; method.invoke(target, args);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvocationTargetException e) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e.getCause();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object getProxyObject(Object target){
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TargetProxy(target));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Target target = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TargetImpl();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        target.work();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         System.out.println(&quot;-----------------------------&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Target target1 = (Target) TargetProxy.getProxyObject(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TargetImpl());
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        target1.work();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;我就只能做这么多了&lt;br/&gt;-----------------------------&lt;br/&gt;代理在前面做事情了&lt;br/&gt;我就只能做这么多了&lt;/p&gt;
&lt;p&gt;———————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样是最常见的代理了，但是有个缺点，代理类要做的事情在代理类写死了，要换就得多写一个代理类。那下面我们就把代理的事项单独拿出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;增加拦截器接口和实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Interceptor {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doOtherThings();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterceptorImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt;  Interceptor {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doOtherThings() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.println(&quot;还可以灵活地做其他事情&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代理类变一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TargetProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Interceptor interceptor;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TargetProxy(Object target, Interceptor interceptor) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.interceptor =&lt;span&gt; interceptor;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        interceptor.doOtherThings();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; method.invoke(target, args);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * 获取代理对象的时候顺便把拦截逻辑对象也传过来
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; interceptor
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * @paramarget
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object getProxyObject(Object target, Interceptor interceptor) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TargetProxy(target, interceptor));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Target target = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TargetImpl();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        target.work();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         System.out.println(&quot;-----------------------------&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Interceptor interceptor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterceptorImpl();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Target target1 = (Target) TargetProxy.getProxyObject(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TargetImpl(),interceptor);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        target1.work();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(&quot;-----------------------------&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         Interceptor interceptor1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Interceptor() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doOtherThings() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 System.out.println(&quot;换个拦截方式？&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Target target2 = (Target) TargetProxy.getProxyObject(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TargetImpl(),interceptor1);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        target2.work();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;我就只能做这么多了&lt;br/&gt;-----------------------------&lt;br/&gt;还可以灵活地做其他事情&lt;br/&gt;我就只能做这么多了&lt;br/&gt;-----------------------------&lt;br/&gt;换个拦截方式？&lt;br/&gt;我就只能做这么多了&lt;/p&gt;
&lt;p&gt;———————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;这样写是不是感觉挺好了。但是你是不是要拦截所有方法的呢？正常场景是不是只需要拦截method中某个某几个方法呢？那这样就把拦截器加个参数，method好了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Interceptor {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doOtherThings(Method method, Object[] args);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {  
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    interceptor.doOtherThings(method, args);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; method.invoke(target, args); 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：java设计模式中有一个规则就迪米特法则，也叫最少知识法则，意思应该就是一个类知道的越少越好，对一个对象知道的越少越好。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那这样看反正拦截器都需要method还不如让代理类也不知道method好了，method执行需要代理类的target那就把target也传过去。&lt;/p&gt;
&lt;p&gt;传了这么多参数，我们可以不可以把这些参数封装成一个对象传过去，暂时就叫Invocation&lt;/p&gt;
&lt;p&gt;然后method.invoke执行就需要这三个参数，那么这三个操作就放在Invocation里面好了，要不然你还得让拦截器去获取这些属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Invocation {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Method method;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object[] args;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Invocation(Object target, Method method, Object[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.method =&lt;span&gt; method;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.args =&lt;span&gt; args;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object proceed() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvocationTargetException, IllegalAccessException {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; method.invoke(target,args);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getTarget() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTarget(Object target) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Method getMethod() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; method;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMethod(Method method) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.method =&lt;span&gt; method;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object[] getArgs() {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; args;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setArgs(Object[] args) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.args =&lt;span&gt; args;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面看拦截器怎么实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Interceptor {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object intercept(Invocation invocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvocationTargetException, IllegalAccessException;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterceptorImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Interceptor {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object intercept(Invocation invocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvocationTargetException, IllegalAccessException {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(invocation.getMethod().getName().equals(&quot;work&quot;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             System.out.println(&quot;真的假的&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; invocation.proceed();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TargetProxyTwo &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Interceptor interceptor;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TargetProxyTwo(Object target, Interceptor interceptor) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.interceptor =&lt;span&gt; interceptor;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; interceptor.intercept(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Invocation(target,method,args));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object getProxyObj(Object target,Interceptor interceptor){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Proxy.newProxyInstance(target.getClass().getClassLoader(),
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                target.getClass().getInterfaces(),
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TargetProxyTwo(target, interceptor));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         Target target = (Target) TargetProxyTwo.getProxyObj(&lt;span&gt;new&lt;/span&gt; TargetImpl(),&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterceptorImpl());
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        target.work();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;真的假的&lt;br/&gt;我就只能做这么多了&lt;/p&gt;
&lt;p&gt;———————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;迪米特法则来看，客户端现在需要知道 拦截器，和代理类。 那么能不能把代理类的注册放到拦截器里面呢？可以的。来看下&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Interceptor {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object register(Object target);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object intercept(Invocation invocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvocationTargetException, IllegalAccessException;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterceptorImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Interceptor {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object register(Object target) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; TargetProxyTwo.getProxyObj(target,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object intercept(Invocation invocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvocationTargetException, IllegalAccessException {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(invocation.getMethod().getName().equals(&quot;work&quot;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             System.out.println(&quot;真的假的&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; invocation.proceed();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;invocation.procedd()&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;         Target target = (Target) &lt;span&gt;new&lt;/span&gt; InterceptorImpl().register(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TargetImpl());
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        target.work();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样是不是很完美？&lt;/p&gt;
&lt;p&gt;这样写是有问题的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(invocation.getMethod().getName().equals(&quot;work&quot;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             System.out.println(&quot;真的假的&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; invocation.proceed();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; invocation.proceed();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;把判断方法的逻辑方法拦截方法里面，那么假如十个方法，十个拦截逻辑呢？你是不是要写大一堆if else?这样是美观的。怎么解决呢？注解啊！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在拦截器上添加要拦截的方法注解不就好了嘛。&lt;/p&gt;
&lt;p&gt;来看代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@java.lang.annotation.Target(ElementType.TYPE)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MethodName {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String value();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @MethodName(&quot;work&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterceptorImpl &lt;span&gt;implements&lt;/span&gt; Interceptor
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TargetProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Interceptor interceptor;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TargetProxy(Object target, Interceptor interceptor) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.interceptor =&lt;span&gt; interceptor;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         MethodName methodName = &lt;span&gt;this&lt;/span&gt;.interceptor.getClass().getAnnotation(MethodName.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (methodName == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;拦截器注解方法名字为空&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         String name =&lt;span&gt; methodName.value();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (name.equals(method.getName())) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; interceptor.intercept(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Invocation(target, method, args));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; method.invoke(target, args);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * 获取代理对象的时候顺便把拦截逻辑对象也传过来
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; interceptor
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     * @paramarget
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object getProxyObject(Object target, Interceptor interceptor) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TargetProxy(target, interceptor));
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;怎么样，这样是不是就很完美了。&lt;/p&gt;
&lt;p&gt;先预告下： 上面的类对应Mybatis的类：&lt;/p&gt;
&lt;p&gt;Invocation,Interceptor完全一样。TargetProxy对应Plugin类。regist方法对应wrap方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;好的下面来看Mybatis的拦截器了&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)&lt;/li&gt;
&lt;li&gt;ParameterHandler (getParameterObject, setParameters)&lt;/li&gt;
&lt;li&gt;ResultSetHandler (handleResultSets, handleOutputParameters)&lt;/li&gt;
&lt;li&gt;StatementHandler (prepare, parameterize, batch, update, query)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Mybatis的拦截器的使用方式是通过xml配置的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;plugins&amp;gt;
    &amp;lt;plugin interceptor=&quot;org.format.mybatis.cache.interceptor.ExamplePlugin&quot;&amp;gt;&amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这样的配置，就有了默认的拦截器：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;那么这四种拦截器分别在什么时候添加的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;XMLConfigBuilder&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pluginElement(XNode parent) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (parent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (XNode child : parent.getChildren()) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         String interceptor = child.getStringAttribute(&quot;interceptor&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Properties properties =&lt;span&gt; child.getChildrenAsProperties();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Interceptor interceptorInstance =&lt;span&gt; (Interceptor) resolveClass(interceptor).newInstance();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        interceptorInstance.setProperties(properties);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        configuration.addInterceptor(interceptorInstance);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Mybatis中有一个拦截器链，典型的责任链模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么这四种拦截器分别在什么时候开始执行拦截呢？&lt;/p&gt;
&lt;p&gt;先介绍下责任链获取恰当的拦截器的方法，Configuration类中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     ParameterHandler parameterHandler =&lt;span&gt; mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     parameterHandler =&lt;span&gt; (ParameterHandler) interceptorChain.pluginAll(parameterHandler);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; parameterHandler;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;      ResultHandler resultHandler, BoundSql boundSql) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     ResultSetHandler resultSetHandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     resultSetHandler =&lt;span&gt; (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultSetHandler;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     StatementHandler statementHandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     statementHandler =&lt;span&gt; (StatementHandler) interceptorChain.pluginAll(statementHandler);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; statementHandler;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Executor newExecutor(Transaction transaction) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; newExecutor(transaction, defaultExecutorType);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Executor newExecutor(Transaction transaction, ExecutorType executorType) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     executorType = executorType == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; defaultExecutorType : executorType;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     executorType = executorType == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; ExecutorType.SIMPLE : executorType;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    Executor executor;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ExecutorType.BATCH ==&lt;span&gt; executorType) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;       executor = &lt;span&gt;new&lt;/span&gt; BatchExecutor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, transaction);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ExecutorType.REUSE ==&lt;span&gt; executorType) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;       executor = &lt;span&gt;new&lt;/span&gt; ReuseExecutor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, transaction);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;       executor = &lt;span&gt;new&lt;/span&gt; SimpleExecutor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, transaction);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cacheEnabled) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;       executor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CachingExecutor(executor);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     executor =&lt;span&gt; (Executor) interceptorChain.pluginAll(executor);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; executor;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterceptorChain {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Interceptor&amp;gt; interceptors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Interceptor&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object pluginAll(Object target) {&lt;br/&gt;&lt;strong&gt;&lt;span&gt;       //遍历所有的拦截器看那个拦截器适用。plugin方法就是每个拦截器的适配方法
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Interceptor interceptor : interceptors) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       target =&lt;span&gt; interceptor.plugin(target);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addInterceptor(Interceptor interceptor) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    interceptors.add(interceptor);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   
&lt;span&gt;16&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; List&amp;lt;Interceptor&amp;gt;&lt;span&gt; getInterceptors() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.unmodifiableList(interceptors);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面开始看那块开始拦截的&lt;/p&gt;
&lt;p&gt;1.Executor接口的拦截器：&lt;/p&gt;
&lt;p&gt;　　获取SqlSession的时候，就获取了代理拦截器：&lt;/p&gt;
&lt;p&gt;　　类：DefaultSqlSessionFactory&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; autoCommit) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Transaction tx = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       &lt;span&gt;final&lt;/span&gt; Environment environment =&lt;span&gt; configuration.getEnvironment();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       &lt;span&gt;final&lt;/span&gt; TransactionFactory transactionFactory =&lt;span&gt; getTransactionFactoryFromEnvironment(environment);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       tx =&lt;span&gt; transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       &lt;strong&gt;&lt;span&gt;final Executor executor = configuration.newExecutor(tx, execType);
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultSqlSession(configuration, executor, autoCommit);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       closeTransaction(tx); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; may have fetched a connection so lets call close()&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;       &lt;span&gt;throw&lt;/span&gt; ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; +&lt;span&gt; e, e);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;      ErrorContext.instance().reset();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2 StatementHandler&lt;/p&gt;
&lt;p&gt;处理SQL逻辑等方法&lt;/p&gt;
&lt;p&gt;具体类：SimpleExecutor&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Statement stmt = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       Configuration configuration =&lt;span&gt; ms.getConfiguration();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       &lt;strong&gt;&lt;span&gt;StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 6&lt;/span&gt;       stmt =&lt;span&gt; prepareStatement(handler, ms.getStatementLog());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; handler.&amp;lt;E&amp;gt;&lt;span&gt;query(stmt, resultHandler);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      closeStatement(stmt);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.parameterHandler;resultSetHandler&lt;/p&gt;
&lt;p&gt;一个参数的一个结果集的。&lt;/p&gt;
&lt;p&gt;都在statementHandler确定后在类：BaseStatementHandler构造器中初始化的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; BaseStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.configuration =&lt;span&gt; mappedStatement.getConfiguration();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.executor =&lt;span&gt; executor;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.mappedStatement =&lt;span&gt; mappedStatement;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.rowBounds =&lt;span&gt; rowBounds;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.typeHandlerRegistry =&lt;span&gt; configuration.getTypeHandlerRegistry();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.objectFactory =&lt;span&gt; configuration.getObjectFactory();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (boundSql == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; issue #435, get the key before calculating the statement&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;      generateKeys(parameterObject);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       boundSql =&lt;span&gt; mappedStatement.getBoundSql(parameterObject);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.boundSql =&lt;span&gt; boundSql;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;strong&gt;&lt;span&gt;17     this.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);
18     this.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;19&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这下总体应该了解了，这四类接口都是在获取实现类之前，先通过代理获取对象。如果存在拦截器，则执行拦截器的方法，否则直接返回对象本身。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Mybatis好的地方在于他把四类拦截器用一个拦截器链管理了起来。 用责任链模式解决了要单独判断哪类拦截逻辑用什么拦截器的判断逻辑。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 12 Nov 2018 07:03:00 +0000</pubDate>
<dc:creator>郝二驴</dc:creator>
<og:description>在介绍Mybatis拦截器代码之前，我们先研究下jdk自带的动态代理及优化 其实动态代理也是一种设计模式...优于静态代理，同时动态代理我知道的有两种，一种是面向接口的jdk的代理，第二种是基于第三方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haoerlv/p/9946535.html</dc:identifier>
</item>
<item>
<title>vue中的slot（插槽） - 妖色调</title>
<link>http://www.cnblogs.com/loveyt/p/9946450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/loveyt/p/9946450.html</guid>
<description>&lt;h2 id=&quot;什么是插槽&quot;&gt;什么是插槽？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。&lt;/li&gt;
&lt;li&gt;插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;怎么用插槽&quot;&gt;怎么用插槽？&lt;/h2&gt;
&lt;h4 id=&quot;默认插槽&quot;&gt;默认插槽&lt;/h4&gt;
&lt;p&gt;父组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    我是父组件
    &amp;lt;slotOne1&amp;gt;
      &amp;lt;p style=&quot;color:red&quot;&amp;gt;我是父组件插槽内容&amp;lt;/p&amp;gt;
    &amp;lt;/slotOne1&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在父组件引用的子组件中写入想要显示的内容（可以使用标签，也可以不用）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;子组件(slotOne1)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;slotOne1&quot;&amp;gt;
    &amp;lt;div&amp;gt;我是slotOne1组件&amp;lt;/div&amp;gt;
    &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在子组件中写入slot，slot所在的位置就是父组件要显示的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472147/201811/1472147-20181112144105784-1098819459.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当然再父组件引用的子组件中也可以写入其他组件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;父组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    我是父组件
    &amp;lt;slotOne1&amp;gt;
      &amp;lt;p style=&quot;color:red&quot;&amp;gt;我是父组件插槽内容&amp;lt;/p&amp;gt;
      &amp;lt;slot-one2&amp;gt;&amp;lt;/slot-one2&amp;gt;
    &amp;lt;/slotOne1&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子组件(slotOne2)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;slotOne2&quot;&amp;gt;
    我是slotOne2组件
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472147/201811/1472147-20181112144222661-2039934595.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;具名插槽&quot;&gt;具名插槽&lt;/h4&gt;
&lt;p&gt;子组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;slottwo&quot;&amp;gt;
    &amp;lt;div&amp;gt;slottwo&amp;lt;/div&amp;gt;
    &amp;lt;slot name=&quot;header&quot;&amp;gt;&amp;lt;/slot&amp;gt;
    &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
    &amp;lt;slot name=&quot;footer&quot;&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在子组件中定义了三个slot标签，其中有两个分别添加了name属性header和footer&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;父组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    我是父组件
    &amp;lt;slot-two&amp;gt;
      &amp;lt;p&amp;gt;啦啦啦，啦啦啦，我是卖报的小行家&amp;lt;/p&amp;gt;
      &amp;lt;template slot=&quot;header&quot;&amp;gt;
          &amp;lt;p&amp;gt;我是name为header的slot&amp;lt;/p&amp;gt;
      &amp;lt;/template&amp;gt;
      &amp;lt;p slot=&quot;footer&quot;&amp;gt;我是name为footer的slot&amp;lt;/p&amp;gt;
    &amp;lt;/slot-two&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在父组件中使用template并写入对应的slot值来指定该内容在子组件中现实的位置（当然也不用必须写到template），没有对应值的其他内容会被放到子组件中没有添加name属性的slot中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472147/201811/1472147-20181112144415380-998676771.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;插槽的默认内容&quot;&gt;插槽的默认内容&lt;/h4&gt;
&lt;p&gt;父组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    我是父组件
    &amp;lt;slot-two&amp;gt;&amp;lt;/slot-two&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;slottwo&quot;&amp;gt;
    &amp;lt;slot&amp;gt;我不是卖报的小行家&amp;lt;/slot&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以在子组件的slot标签中写入内容，当父组件没有写入内容时会显示子组件的默认内容，当父组件写入内容时，会替换子组件的默认内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472147/201811/1472147-20181112144645560-431732801.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;编译作用域&quot;&gt;编译作用域&lt;/h4&gt;
&lt;p&gt;父组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    我是父组件
    &amp;lt;slot-two&amp;gt;
      &amp;lt;p&amp;gt;{{name}}&amp;lt;/p&amp;gt;
    &amp;lt;/slot-two&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  data () {
    return {
      name： 'Jack'
    }
  }
}
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;slottwo&quot;&amp;gt;
    &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472147/201811/1472147-20181112145001679-568383132.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;作用域插槽&quot;&gt;作用域插槽&lt;/h4&gt;
&lt;p&gt;子组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    我是作用域插槽的子组件
    &amp;lt;slot :data=&quot;user&quot;&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  name: 'slotthree',
  data () {
    return {
      user: [
        {name: 'Jack', sex: 'boy'},
        {name: 'Jone', sex: 'girl'},
        {name: 'Tom', sex: 'boy'}
      ]
    }
  }
}
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在子组件的slot标签上绑定需要的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;父组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    我是作用域插槽
    &amp;lt;slot-three&amp;gt;
      &amp;lt;template slot-scope=&quot;user&quot;&amp;gt;
        &amp;lt;div v-for=&quot;item in user.data&quot; :key=&quot;item.id&quot;&amp;gt;
        {{item}}
        &amp;lt;/div&amp;gt;
      &amp;lt;/template&amp;gt;
    &amp;lt;/slot-three&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在父组件上使用slot-scope属性，user.data就是子组件传过来的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472147/201811/1472147-20181112145113196-1793166190.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Nov 2018 06:52:00 +0000</pubDate>
<dc:creator>妖色调</dc:creator>
<og:description>vue中的插槽————slot 什么是插槽？ 插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/loveyt/p/9946450.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 搭配 Nginx 的真实IP问题 - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/9946262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/9946262.html</guid>
<description>&lt;h2 id=&quot;一.前言&quot;&gt;一.前言&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201811/668104-20181112142600934-224917427.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Nginx（Engine X）是一个高性能HTTP和反向代理服务，是由俄罗斯人伊戈尔·赛索耶夫为访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 如果你是一名 ASP.NET Core 开发人员，并且你的 ASP.NET Core 应用部署在Linux上，相信你应该或多或少与 Nginx 有过接触，在我们将 ASP.NET Core 部署在 Linux 上时，它是被用做反向代理的最好选择之一。今天和大家聊一聊当我们使用了 Nginx 反向代理后，我们程序中获取真实IP（客户端真实ip，本文简称“真实IP”）的问题。&lt;/p&gt;
&lt;h2 id=&quot;二.发现问题&quot;&gt;二.发现问题&lt;/h2&gt;
&lt;h3 id=&quot;安装-nginx&quot;&gt;1.安装 Nginx&lt;/h3&gt;
&lt;p&gt;这里我就选用我安装在 CentOS 7.2 上的 Nginx，在 CentOS 安装 Nginx 的同学可以参考我以前写的文章：&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/9291223.html&quot;&gt;CentOS 7 源码编译安装 Nginx&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;新建-asp.net-core-项目&quot;&gt;2.新建 ASP.NET Core 项目&lt;/h3&gt;
&lt;p&gt;第一步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201811/668104-20181112142600589-779021477.png&quot; alt=&quot;1541941721350&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201811/668104-20181112142600166-1349750470.png&quot; alt=&quot;1541941745624&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;编写代码&quot;&gt;3.编写代码&lt;/h3&gt;
&lt;p&gt;编辑 &lt;code&gt;ValuesController&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        private readonly HttpContext _context;
        public ValuesController(IHttpContextAccessor accessor)
        {
            _context = accessor.HttpContext;
        }
        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            return Ok($&quot;获取到的真实IP：{_context.Connection.RemoteIpAddress}&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编辑 &lt;code&gt;Startup&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
            services.AddSingleton&amp;lt;IHttpContextAccessor, HttpContextAccessor&amp;gt;();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;4.测试&lt;/h3&gt;
&lt;h4 id=&quot;将程序部署到服务器&quot;&gt;（1）将程序部署到服务器&lt;/h4&gt;
&lt;p&gt;本文略此步&lt;/p&gt;
&lt;h4 id=&quot;配置-nginx-反向代理&quot;&gt;（2）配置 Nginx 反向代理&lt;/h4&gt;
&lt;p&gt;新建配置文件 &lt;code&gt;realiptest.conf&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
    listen 5002;
    access_log  off;
    location / {
       proxy_pass http://localhost:5000; 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试访问&quot;&gt;（3）测试访问&lt;/h4&gt;
&lt;p&gt;服务器地址：192.168.157.132&lt;/p&gt;
&lt;p&gt;我本机地址：192.168.157.1&lt;/p&gt;
&lt;p&gt;那么我本机通过访问 &lt;a href=&quot;http://192.168.157.132:5002/api/values&quot; class=&quot;uri&quot;&gt;http://192.168.157.132:5002/api/values&lt;/a&gt; api获取到的ip地址应该是我本机的，即 192.168.157.1&lt;/p&gt;
&lt;p&gt;通过浏览器访问验证：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201811/668104-20181112142559758-335868942.png&quot; alt=&quot;1541946415816&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可是却获取到了 127.0.0.1，这是因为 们的请求到了 Nginx，然后 Nginx 再将我们的请求转发到 ASP.NET Core 应用程序，实际上与 ASP.NET Core 应用程序 建立连接的是 Nginx ，所以获取到了服务器本地 IP （Nginx和程序部署在一台机子上）。请求流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201811/668104-20181112142559427-1947885132.png&quot; alt=&quot;1541984724645&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三.解决问题&quot;&gt;三.解决问题&lt;/h2&gt;
&lt;p&gt;修改程序代码以便显示更详细的信息：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ValuesController&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            StringBuilder sb=new StringBuilder();
            sb.AppendLine($&quot;RemoteIpAddress：{_context.Connection.RemoteIpAddress}&quot;);

            if (Request.Headers.ContainsKey(&quot;X-Real-IP&quot;))
            {
                sb.AppendLine($&quot;X-Real-IP：{Request.Headers[&quot;X-Real-IP&quot;].ToString()}&quot;);
            }

            if (Request.Headers.ContainsKey(&quot;X-Forwarded-For&quot;))
            {
                sb.AppendLine($&quot;X-Forwarded-For：{Request.Headers[&quot;X-Forwarded-For&quot;].ToString()}&quot;);
            }
            return Ok(sb.ToString());
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改反向代理配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
    listen 5002;
    access_log  off;
    location / {
       proxy_set_header   X-Real-IP        $remote_addr;
       proxy_set_header   Host             $host;
       proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
       proxy_pass                          http://localhost:5000;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次访问：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201811/668104-20181112142559025-1128348440.png&quot; alt=&quot;1541948087185&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到&lt;code&gt;X-Real-IP&lt;/code&gt; 和 &lt;code&gt;X-Forwarded-For&lt;/code&gt;请求头获取到了真实IP，我们通过修改 Nginx 配置，让程序接收到的请求信息携带真实IP。Nginx 通过在 X-Real-IP 、X-Forwarded-For 请求头设置了&lt;strong&gt;与它连接的远程ip&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以上解决办法对于没有使用CDN是适用的。&lt;/p&gt;
&lt;h2 id=&quot;四.使用cdn如何解决&quot;&gt;四.使用CDN如何解决&lt;/h2&gt;
&lt;p&gt;我们的请求经过一个或者多个cdn结点以后，我们的程序如何获取真实IP呢，这就要看cdn服务商提供的解决办法了，一般有两种：&lt;/p&gt;
&lt;p&gt;1.cdn服务商支持设置真实ip到某个指定的请求头，这样我们通过这个请求头就能获取了 。&lt;/p&gt;
&lt;p&gt;2.一般经过cdn都会把真实ip经过的结点ip信息添加到头 &lt;code&gt;X-Forwarded-For&lt;/code&gt;，我们取这个头里的第一个ip就是真实ip。&lt;/p&gt;
&lt;p&gt;添加 nginx 配置，让他再次代理 5002 端口（前面添加的代理ASP.NET Core 程序），模拟cdn第二种方案：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
    listen 5003;
    access_log  off;
    location / {
       proxy_set_header   X-Real-IP        $remote_addr;
       proxy_set_header   Host             $host;
       proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
       proxy_pass                          http://192.168.157.132:5002;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再次访问：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201811/668104-20181112142558699-471258984.png&quot; alt=&quot;1541949268726&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们的真实ip被放到 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 请求头的第一个IP，X-Real-IP 获取到的是上一层代理的ip。&lt;/p&gt;
&lt;p&gt;X-Forwarded-For 来自百度百科的解释：X-Forwarded-For 简称XFF头，它代表客户端，也就是&lt;a href=&quot;https://baike.baidu.com/item/HTTP&quot;&gt;HTTP&lt;/a&gt;的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项。它不是RFC中定义的标准请求头信息，在squid缓存代理服务器开发文档中可以找到该项的详细介绍。标准格式如下：X-Forwarded-For: client1, proxy1, proxy2。请求流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201811/668104-20181112142558074-1609308405.png&quot; alt=&quot;1541985228889&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五.如何在代码里最小改动&quot;&gt;五.如何在代码里最小改动&lt;/h2&gt;
&lt;p&gt;经过上面的讲解，显而易见我们在代码里无法直接通过 &lt;code&gt;RemoteIpAddress&lt;/code&gt; 获取真实ip，那么如果我们在编写代码时，很多地方直接采用 &lt;code&gt;RemoteIpAddress&lt;/code&gt;获取真实ip怎么办，难道需要修改每一处吗，这里分享一个简单的解决办法，就是利用 ASP.NET Core 中间件给 RemoteIpAddress 重新赋值。&lt;/p&gt;
&lt;p&gt;编写 RealIpMiddleware 中间件：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class RealIpMiddleware
{
    private readonly RequestDelegate _next;

    public RealIpMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public Task Invoke(HttpContext context)
    {
        var headers = context.Request.Headers;
        if (headers.ContainsKey(&quot;X-Forwarded-For&quot;))
        {
            context.Connection.RemoteIpAddress=IPAddress.Parse(headers[&quot;X-Forwarded-For&quot;].ToString().Split(',', StringSplitOptions.RemoveEmptyEntries)[0]);
        }
        return _next(context);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果是前面提到的cdn的第一种情况，只需判断cdn服务商提供的特殊请求头就行了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Startup中配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201811/668104-20181112142557412-1580300902.png&quot; alt=&quot;1541950121051&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应放在最靠前的位置，以免有中间件获取到了未重置的IP地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;保持前面的模拟cdn第二中情况架构，再次进行测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201811/668104-20181112142557053-378448701.png&quot; alt=&quot;1541950299862&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到通过 &lt;code&gt;RemoteIpAddress&lt;/code&gt; 获取到了真实ip。这种解决方案算是比较好的了。&lt;/p&gt;
&lt;p&gt;这里提一下 Nginx RealIP Module 是 Nginx 获取真实ip的一个模块，有兴趣的同学可以自己去研究一下。&lt;/p&gt;
&lt;h2 id=&quot;六.使用组件-unicorn.aspnetcore&quot;&gt;六.使用组件 Unicorn.AspNetCore&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Unicorn.AspNetCore&lt;/code&gt; 里面我有封装处理ip的中间件。&lt;/p&gt;
&lt;p&gt;通过nuget安装：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Install-Package Unicorn.AspNetCore&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 Program 中添加：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/668104/201811/668104-20181112142556578-46303085.png&quot; alt=&quot;1542003717012&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/UCPlan/Unicorn/tree/master/src/Infrastructure/Unicorn.AspNetCore/Middleware/RealIp&quot; class=&quot;uri&quot;&gt;https://github.com/UCPlan/Unicorn/tree/master/src/Infrastructure/Unicorn.AspNetCore/Middleware/RealIp&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Nov 2018 06:32:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<og:description>一.前言 Nginx（Engine X）是一个高性能HTTP和反向代理服务，是由俄罗斯人伊戈尔·赛索耶夫为访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stulzq/p/9946262.html</dc:identifier>
</item>
<item>
<title>为什么我要放弃javaScript数据结构与算法（第九章）—— 图 - 赖同学</title>
<link>http://www.cnblogs.com/lbh2018/p/JavaScript_Data_Structures_and_Algorithms_Part9.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lbh2018/p/JavaScript_Data_Structures_and_Algorithms_Part9.html</guid>
<description>&lt;p&gt;本章中，将学习另外一种非线性数据结构——图。这是学习的最后一种数据结构，后面将学习排序和搜索算法。&lt;/p&gt;
&lt;h2 id=&quot;第九章-图&quot;&gt;第九章 图&lt;/h2&gt;
&lt;h3 id=&quot;图的相关术语&quot;&gt;图的相关术语&lt;/h3&gt;
&lt;p&gt;图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。学习图是重要的，因为在任何二元关系都可以用图来表示。&lt;/p&gt;
&lt;p&gt;任何社交网络都可以用图来表示。&lt;/p&gt;
&lt;p&gt;我们还可以用图来表示道路、航班以及通信状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://laibh.top/images/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE-%E9%81%93%E8%B7%AF.png&quot; alt=&quot;道路&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个图 G= （V,E）由以下元素组成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;V：一组顶点&lt;/li&gt;
&lt;li&gt;E：一组边。连接V中的顶点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://laibh.top/images/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE-%E5%AE%9E%E4%BE%8B.png&quot; alt=&quot;道路&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由一条边连接在一起的顶点称为相邻顶点。比如，A和B 是相邻的，A和D是相邻的，A和C是相邻的，A和E是不相邻的。&lt;/p&gt;
&lt;p&gt;一个顶点的度是其相邻顶点的数量。比如，A和其他三个顶点相连接，因此，A的度为3；E和其他两个顶点相连接，因此E的度为2.&lt;/p&gt;
&lt;p&gt;路径是顶点&lt;em&gt;v1,v2,...vk&lt;/em&gt;的一个连续序列，其中 &lt;em&gt;vi&lt;/em&gt; 和 vi+1 （下标）是相邻的。以上一示意图为例，其中包含的路径A B E I 和 A C D G。&lt;/p&gt;
&lt;p&gt;简单路径要求不包含重复的顶点。举个例子，A D G是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是简单路径，比如A D C A（最后一个顶点重新回到A）&lt;/p&gt;
&lt;p&gt;如果途中不存在环则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有向图和无向图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图可以是无向的（边没有方向）或是有向的（有向图）。下图就是有向图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://laibh.top/images/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE-%E6%9C%89%E5%90%91%E5%9B%BE.png&quot; alt=&quot;有向图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有向图的边有一个方向。如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C和D就是强连通的。图还可以是未加权的或者加权的。加权图的边被赋予了权值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://laibh.top/images/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE-%E5%8A%A0%E6%9D%83%E5%9B%BE.png&quot; alt=&quot;加权图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用图来解决计算机科学世界中的很多问题，比如搜索图中的一个特定顶点或搜索一条特定边，寻找图中的一条路径（从一个顶点到另一个顶点），寻找两个顶点之间的最短路径。&lt;/p&gt;
&lt;h3 id=&quot;图的表示&quot;&gt;图的表示&lt;/h3&gt;
&lt;p&gt;从数据结构角度来说，我们有多种方式来表示图。在所有表示法中，不存在绝对正确的方法方式。图的正确表示法取决于解决的问题和图的类型。&lt;/p&gt;
&lt;h3 id=&quot;邻接矩阵&quot;&gt;邻接矩阵&lt;/h3&gt;
&lt;p&gt;图最常见的实现就是邻接矩阵。每个节点和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示顶点之间的连接。如果索引为&lt;em&gt;i&lt;/em&gt;的节点和索引为 &lt;em&gt;j&lt;/em&gt;的节点为邻，则 &lt;code&gt;array[i][j] === 1&lt;/code&gt;,否则 &lt;code&gt;array[i][j] === 0&lt;/code&gt;,如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://laibh.top/images/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png&quot; alt=&quot;邻接矩阵&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。例如，找给定顶点的相邻顶点，即使该顶点只有一个相邻的顶点，我们也不得不迭代一整行。邻接矩阵表示法不够好的另一个理由是，图中顶点的数量可能会变化，而二维数组不太灵活。&lt;/p&gt;
&lt;p&gt;邻接表&lt;/p&gt;
&lt;h3 id=&quot;邻接表&quot;&gt;邻接表&lt;/h3&gt;
&lt;p&gt;我们也可以使用一种叫做邻接表的动态数据来表示图。邻接表由图中每个顶点相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是散列表或者是字典来表示相邻顶点列表。下面的示意图展示了邻接表等数据结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://laibh.top/images/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE-%E9%82%BB%E6%8E%A5%E8%A1%A8.png&quot; alt=&quot;邻接表&quot;/&gt;&lt;/p&gt;
&lt;p&gt;尽管邻接表可能对大多数问题来说都是更好的选择，但以上两种表示法都有用，且它们有着不同的性质（例如，要找出顶点 &lt;em&gt;v&lt;/em&gt;和&lt;em&gt;w&lt;/em&gt;是否相邻，使用邻接矩阵会比较快）。在本章中，就会使用邻接表表示法。&lt;/p&gt;
&lt;h3 id=&quot;关联矩阵&quot;&gt;关联矩阵&lt;/h3&gt;
&lt;p&gt;我们还可以用关联矩阵来表示图。在关联矩阵中，矩阵的行表示顶点，列表示边。如下图所示，我们使用二维数组来表示两者之间的连通性，如果顶点 &lt;em&gt;v&lt;/em&gt; 是 边&lt;em&gt;e&lt;/em&gt;的入射点，则 &lt;code&gt;array[v][e] === 1&lt;/code&gt;,否则 &lt;code&gt;array[v][e] === 0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://laibh.top/images/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE-%E5%85%B3%E8%81%94%E7%9F%A9%E9%98%B5.png&quot; alt=&quot;关联矩阵&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建-graph-类&quot;&gt;创建 Graph 类&lt;/h3&gt;
&lt;p&gt;我们先创建类的骨架&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Graph(){
    var vertices = [];
    var adjList = new Dictionary();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们使用一个数组来存储图中所有顶点的名字，以及一个字典来存储邻接表。字典将会使用顶点的名字作为键，邻接顶点列表作为值。 &lt;code&gt;vertices&lt;/code&gt;数组和 &lt;code&gt;adjList&lt;/code&gt;字典两者都是我们 &lt;code&gt;Graph&lt;/code&gt;类的私有属性。&lt;/p&gt;
&lt;p&gt;接着我们实现两个方法：一个用来向图中添加一个新的顶点（因为图实例化后是空的），另外一个方法用来添加顶点之间的边。我们先实现 addVertex 方法&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;this.addVertex = function(v){
    vertices.push(v);
    adjList.set(v,[]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法接受顶点 v 作为参数。我们将该顶点添加到顶点列表中，并且在邻接表中，设置顶点 v 作为键对应的字典值为一个空数组。&lt;/p&gt;
&lt;p&gt;实现 addEdge 方法&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;this.addEdge = function(v,w){
    adjList.get(v).push(w);         
    adjList.get(w).push(v);         
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法接受两个顶点作为参数。首先，通过将 w 加入到 v 的邻接表中，我们添加了一条自顶点 v 到顶点 w 的边。如果你想实现一个有向图，则（adjList.get(v).push(w)）就足够了。但是本章中大多数的例子都是基于无向图，我们需要添加一条自w向v的边。&lt;/p&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const graph = new Graph();
const myVertices = ['A','B','C','D','E','F','G','H','I'];
for(var i = 0; i &amp;lt; myVertices.length; i++){
    graph.addVertex(myVertices[i]);
}
graph.addEdge('A','B');
graph.addEdge('A','C');
graph.addEdge('A','D');
graph.addEdge('C','D');
graph.addEdge('C','G');
graph.addEdge('D','G');
graph.addEdge('D','H');
graph.addEdge('B','E');
graph.addEdge('B','F');
graph.addEdge('E','I');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现 Graph类的 toString 方法，便于在控制台输出图&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;this.toString = function(){
    var s = '';
    for(var i = 0; i &amp;lt; vertices.length; i++){
        s += vertices[i] + ' -&amp;gt; ';
        var neighbors = adjList.get(vertices[i]);
        for(var j = 0; j &amp;lt; neighbors.length; j++){
            s += neighbors[j] + ' ';
        }
        s += '\n';
    }
    return s;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们为邻接表表示法构建了一个字符串，首先迭代 vertices 数组列表，将顶点的名字加入字符串中，接着取得该顶点的邻接表，同样也迭代该邻接表，将相邻顶点加入我们的字符串。邻接表迭代完成后，给我们的字符串添加一个换行符。这样就可以在控制看到一个漂亮的输出了。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;A -&amp;gt; B C D 
B -&amp;gt; A E F 
C -&amp;gt; A D G 
D -&amp;gt; A C G H 
E -&amp;gt; B I 
F -&amp;gt; B 
G -&amp;gt; C D 
H -&amp;gt; D 
I -&amp;gt; E &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;图的遍历&quot;&gt;图的遍历&lt;/h3&gt;
&lt;p&gt;和树数据结构相似，我们可以访问图的所有节点。有两种算法可以对图进行遍历：广度优先搜索（Breadth-First Search,BFS）和深度优先搜索（Depth-First Search,DFS）。图遍历可以用来寻找特定的顶点或者是寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环等。&lt;/p&gt;
&lt;p&gt;图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索，对于两种图遍历算法，都需要明确指出第一个被访问的节点。&lt;/p&gt;
&lt;p&gt;完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加入待访问的顶点。&lt;/p&gt;
&lt;p&gt;为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。&lt;/p&gt;
&lt;p&gt;广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;深度优先搜索&lt;/td&gt;
&lt;td&gt;栈&lt;/td&gt;
&lt;td&gt;通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;广度优先搜索&lt;/td&gt;
&lt;td&gt;队列&lt;/td&gt;
&lt;td&gt;通过将顶点存入队列，最先入队列的顶点先被探索&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;当要标注已经访问过的顶点时，我们可以用三种颜色来放映它们的状态&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;白色：表示该顶点还没有被访问&lt;/li&gt;
&lt;li&gt;灰色：表示该顶点被访问过，但是还没有探索过&lt;/li&gt;
&lt;li&gt;黑色：表示该顶点被访问过且被完全探索过&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;广度优先搜索&quot;&gt;广度优先搜索&lt;/h3&gt;
&lt;p&gt;广度优先搜索算法会从指定的第一个顶点开始遍历图，会访问其所有相邻点，就像一次访问图的一层。换句话说，就是先宽后深地访问顶点，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://laibh.top/images/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.png&quot; alt=&quot;广度优先搜索&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是从顶点 v 开始的广度优先搜索算法所遵循的步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个队列 Q&lt;/li&gt;
&lt;li&gt;将 v 标注为被发现的（灰色），并将 v 入队列Q&lt;/li&gt;
&lt;li&gt;如果队列Q 非空，则运行以下步骤
&lt;ol&gt;&lt;li&gt;将 u 从 Q 中出队列&lt;/li&gt;
&lt;li&gt;将标注 u 为被发现的（灰色）&lt;/li&gt;
&lt;li&gt;将 u 所有未被访问过的邻点（白色）入队列&lt;/li&gt;
&lt;li&gt;将 u 标注为已被探索的（黑色）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实现广度优先搜索算法&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 颜色辅助-广度优先搜索算法
this.initializeColor = function(){
    var color = [];
    for(var i = 0; i &amp;lt; vertices.length; i++){
        color[vertices[i]] = 'white';
    }
    return color;
}   
// 广度优先搜索算法
this.bfs = function(v,callback){
    var color = this.initializeColor(),
    queue = new Queue();
    queue.enqueue(v);
    while(!queue.isEmpty()){
        var u = queue.dequeue(),
        neighbors = adjList.get(u);
        color[u] = 'grey';
        for(var i = 0; i &amp;lt; neighbors.length; i++){
            var w = neighbors[i];
            if(color[w] === 'white'){                   
                color[w] = 'grey';
                queue.enqueue(w);
            }
        }
        color[u] = 'black';
        if(callback){
            callback(u)
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;广度优先搜索和深度优先搜索多需要标注被访问过的顶点，为此，我们将使用一个辅助数组 color,由于当算法开始执行时，所有的顶点颜色都是白色，所以我们可以创建一个辅助函数 initializeColor 为这两个算法执行此初始化操作。&lt;/p&gt;
&lt;p&gt;我们要的第一件事情是用 initializeColor 函数来将 color 数组初始化为 white ,我们还需要声明和创建一个 Queue 实例，它将会存储待访问和待探索的顶点。&lt;/p&gt;
&lt;p&gt;bfs 方法接受一点顶点作为算法的起始点。起始顶点是必要的，我们将此顶点如队列。&lt;/p&gt;
&lt;p&gt;如果队列为空，我们将通过出队列操作从队列中移除一个顶点，并取得一个包含其所有邻点的邻接表。该顶点将被标注为 grey,表示我们已经发现了它（但还未被完全对其的探索）。&lt;/p&gt;
&lt;p&gt;对于 u 的每个邻点，我们取得其值，如果它还未被访问过，则将其标注了grey,并将这个顶点加入队列中，这样当从队列中出列的时候，我们可以完成对其的探索。&lt;/p&gt;
&lt;p&gt;当完全探索该顶点和及其邻点后，我们将标注该顶点为已探索过（黑色）。&lt;/p&gt;
&lt;p&gt;我们实现的这个 bfs 方法也接受一个回调。这个参数是可选的，如果我们传递了回调函数，会用到它。&lt;/p&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function printNode(value){
    console.log('访问了顶点：' + value);
}
graph.bfs(myVertices[0],printNode);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到下面的结果&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;访问了顶点：A
访问了顶点：B
访问了顶点：C
访问了顶点：D
访问了顶点：E
访问了顶点：F
访问了顶点：G
访问了顶点：H
访问了顶点：I&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;顶点访问顺序和之前的示意图所展示的一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用 BFS 寻找最短路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到目前为止，我们只展示了 BFS 算法的基本原理。我们可以用该算法做更多事情，而不只是输出被访问顶点的顺序。例如，考虑如何来解决下面的问题。&lt;/p&gt;
&lt;p&gt;给定一个图G和源顶点v，找出每个顶点u,u和v之间最短的路径（以边的数量计）&lt;/p&gt;
&lt;p&gt;对于给定顶点v，广度优化算法会访问所有与其距离为1的顶点，接着是距离为2的顶点，以此类推。所以，可以用广度优先算法来解决这个问题。我们可以修改bfs方法以返回给我们一些信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从v到u的距离d[u]&lt;/li&gt;
&lt;li&gt;前溯点pred[u],用来推导出从v到其他每个顶点u的最短路径。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 广度优先搜索算法优化版本
this.BFS = function(v){
    var color = this.initializeColor(),
    queue = new Queue(),
    d = [],
    pred = [];
    queue.enqueue(v);

    for(var i = 0; i &amp;lt; vertices.length; i++){
        d[vertices[i]] = 0;
        pred[vertices[i]] = null;
    }
    while(!queue.isEmpty()){
        var u = queue.dequeue();
        neighbors = adjList.get(u);
        color[u] = 'grey';
        for(var i = 0; i &amp;lt; neighbors.length; i++){
            // w相邻顶点
            var w = neighbors[i];
            if(color[w] === 'white'){
                color[w] == 'grey';
                d[w] = d[u] + 1;
                pred[w] = u;
                queue.enqueue(w);
            }
        }
        color[u] = 'black';
    }
    return {
        distance:d,
        predecessors: pred
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先需要声明数组 d 来表示距离，以及 pred 数组来表示前溯点。下一步用0来初始化数组d，把pred赋值为 null。&lt;/p&gt;
&lt;p&gt;当我们发现 顶点u的相邻点w时，则设置w的前溯点值为u。我们还通过给d[u]加1来设置顶点v和相邻点w之间的距离。&lt;/p&gt;
&lt;p&gt;方法的最后返回一个包含d和pred的对象。&lt;/p&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var shortestPathA = graph.BFS(myVertices[0]);
console.log(shortestPathA);
// distance: [A: 0, B: 1, C: 1, D: 2, E: 2, F: 2, G: 2, H: 3, I: 3]
// predecessors: [A: null, B: &quot;A&quot;, C: &quot;A&quot;, D: &quot;C&quot;, E: &quot;B&quot;, F: &quot;B&quot;,G: &quot;D&quot;, , H: &quot;D&quot;, , I: &quot;E&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过前溯数组，我们可以用下面这段代码来构建从顶点A到其他顶点的路径：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var fromVertex = myVertices[0];
for(var i = 1; i &amp;lt; myVertices.length; i++){
    var toVertex = myVertices[i],
    path = new Stack();
    for(var v = toVertex; v !== fromVertex;v = shortestPathA.predecessors[v]){
        path.push(v);
    }
    path.push(fromVertex);
    var s = path.pop();
    while(!path.isEmpty()){
        s += '-' + path.pop();
    }
    console.log(s);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用顶点A作为源顶点。对于每个其他顶点，我们会J计算顶点A到它的路径。我们从顶点数组得到toVertex ，然后会创建一个栈来 存储路劲值。&lt;/p&gt;
&lt;p&gt;接着，我们追溯 toVertext 到 fromVertext 的路径。变量v被赋值为前溯点的值。这样我们就可以方向追溯这条路径。将变量v添加到栈中。最后，源顶点也会被添加到栈中，以得到完整的路径。&lt;/p&gt;
&lt;p&gt;这之后，我们创建了一个s字符串，并将源顶点赋值给它。当栈是非空的时候，我们从栈中移出一个项并将其拼接到字符串s的后面。最后在控制台上输出路径。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;A-B
A-C
A-C-D
A-B-E
A-B-F
A-C-D-G
A-C-D-H
A-B-E-I&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;深入学习的最短路径算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本章中的图不是加权图。如果要计算加权图中的最短路径（例如，城市A 和城市B之间的最短路径——GPS和Google Map 中用到的算法），广度优先搜索未必合适。&lt;/p&gt;
&lt;p&gt;举个栗子，Dijkstra 算法解决了单源中最短路径问题。Bellman-Ford 算法解决了边权值为负的单源最短路径问题。A*搜索算法解决了求仅一对顶点间的最短路径问题，它用经验法则来加速搜索过程。Floyd-Warshall算法解决了求所有顶点对间的最短路径的这一问题。&lt;/p&gt;
&lt;p&gt;图是一个广泛的主体，对最短路径及其变种问题，我们有很多的解决方案。&lt;/p&gt;
&lt;h3 id=&quot;深度优先搜索&quot;&gt;深度优先搜索&lt;/h3&gt;
&lt;p&gt;深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路返回并探索下一条路径。换句话说，它是先深度后广度地访问顶点，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://laibh.top/images/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.png&quot; alt=&quot;深度优先搜索&quot;/&gt;&lt;/p&gt;
&lt;p&gt;深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点v未被访问，则访问该顶点。&lt;/p&gt;
&lt;p&gt;要访问顶点v,照下列的步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标注v为被发现的（灰色）&lt;/li&gt;
&lt;li&gt;对于v的所有未访问的邻点w，访问顶点w，标注v为已被探索的（黑色）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实现&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 深度优先探索算法
this.dfs = function(callback){
    var color = this.initializeColor();
    for(var i = 0 ; i &amp;lt; vertices.length; i++){
        if(color[vertices[i]] === 'white' ){
            this.dfsVisit(vertices[i],color,callback);
        }
    }       
}
this.dfsVisit =function(u,color,callback){
    color[u] = 'grey';
    if(callback){
        callback(u);
    }
    var neighbors = adjList.get(u);
    for(var i = 0 ;i &amp;lt; neighbors.length; i++){
        var w = neighbors[i];
        if(color[w] === 'white'){
            arguments.callee(w,color,callback);
        }
    }
    color[u] = 'black';
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，我们创建了颜色数组，并用值white 为图中的每个顶点对其进行了初始化，广度优先搜索也是这么做的。接着，对于图实例中每一个未被访问过的顶点，我们调用递归函数 dfsVisit ，传递的参数为顶点、颜色数组和回调函数。&lt;/p&gt;
&lt;p&gt;当访问u顶点时，我们标注其为被发现的grey。如果有callback 函数的话，则执行该函数输出已访问过的顶点。接下来一步是取得包含顶点u的所有邻点的列表。对于顶点u的每一个未被访问过的邻点w，我们将调用dfsVisit 函数，传递w和其他参数。最后，在该2顶点和邻点按深度访问之后，我们回退，意思是该顶点已经被完全探索了，并将其标注为black&lt;/p&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;graph.dfs(printNode); 
// 访问了顶点：A
// 访问了顶点：B
// 访问了顶点：E
// 访问了顶点：I
// 访问了顶点：F
// 访问了顶点：C
// 访问了顶点：D
// 访问了顶点：G
// 访问了顶点：H&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面这个示意图展示了该算法每一步的执行过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://laibh.top/images/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png&quot; alt=&quot;深度优先搜索执行过程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;探索深度优化算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们现在只是展示了深度优先搜索算法的工作原理。我们可以用该算法做更多的事情，而不是只输出被访问顶点的顺序。&lt;/p&gt;
&lt;p&gt;对于给定的图G，我们希望深度优先探索算法遍历图G的所有节点，构建“深林”（有根树的一个集合）已经一组源顶点（根），并输出两个数组:发现时间和完成探索时间。我们可以修改 dfs 方法来返回给我们一些信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;顶点u的发现时间d[u]&lt;/li&gt;
&lt;li&gt;当顶点u被标注为黑色时，u的完成探索时间f[u]&lt;/li&gt;
&lt;li&gt;顶点u的前溯点p[u]&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 追踪发现事件和完成探索时间
var time = 0;
// 深度优先探索算法优化版本
this.DFS = function(){
    var color = this.initializeColor(),
    d = [],
    f = [],
    p = [];
    time = 0;

    for(var i = 0; i &amp;lt; vertices.length; i++){
        f[vertices[i]] = 0;
        d[vertices[i]] = 0;
        p[vertices[i]] = null;
    }

    for(i = 0; i&amp;lt; vertices.length; i++){
        if(color[vertices[i]] === 'white'){
            this.DFSVisit(vertices[i],color,d,f,p)
        }
    }
    return {
        discovery:d,
        finished:f,
        predecessors:p
    }
}
this.DFSVisit = function(u,color,d,f,p){
    console.log('发现了'+u);
    color[u] = 'grey';
    d[u] = ++time;
    var neighbors = adjList.get(u);
    for(var i = 0; i &amp;lt; neighbors.length; i++){
        var w = neighbors[i];
        if(color[w] === 'white'){
            p[w] = u;
            arguments.callee(w,color,d,f,p);
        }
    }
    color[u] = 'black';
    f[u] = ++time;
    console.log('探索了'+u);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们需要一个变量来追踪发现时间和完成探索时间。时间变量不能被作为参数传递，因为非对象的变量不能作为引用传递给其他Js方法。接下来，我们声明数组d、f和p。我们需要为图的每一个顶点来初始化这些数组。在这个方法结尾返回这些值。&lt;/p&gt;
&lt;p&gt;当一个顶点第一次被发现时，我们要追踪其发现时间。当它是由引自顶点u的边而被发现的。我们追踪它的前溯点。最后，当这个顶点被完全探索之后，我们追踪其完成时间。&lt;/p&gt;
&lt;p&gt;深度优先算法背后的思想是什么？&lt;/p&gt;
&lt;p&gt;边是从最近发现的u处被向外探索的。只有连接到未发现的顶点的边被探索了。当u所有的边都被探索了，该算法返回u被发现的地方去探索其他的边。这个过程持续到我们发现了虽偶有从原始顶点能够触及的顶点。如果还留有其他未被发现的顶点。我们对新的源顶点将重复这个过程。直到图中所有的顶点都被探索了。&lt;/p&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var deepPath = graph.DFS();
console.log(deepPath);
/**
发现了A
发现了B
发现了E
发现了I
探索了I
探索了E
发现了F
探索了F
探索了B
发现了C
发现了D
发现了G
探索了G
发现了H
探索了H
探索了D
探索了C
探索了A

discovery: [A: 1, B: 2, C: 10, D: 11, E: 3, F: 7, G: 12, H: 14, I: 4]
finished: [A: 18, B: 9, C: 17, D: 16, E: 6, F: 8, G: 13, H: 15, I: 5]
predecessors: [A: null, B: &quot;A&quot;, C: &quot;A&quot;, D: &quot;C&quot;, E: &quot;B&quot;, G: &quot;D&quot;, H: &quot;D&quot;, I: &quot;E&quot;]
*/ &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本章学习了几种不同的方式来表示图这一数据结构。并实现了用邻接表表示图的算法。还学习了广度优先搜索和深度优先搜索的实际应用。&lt;/p&gt;
&lt;p&gt;书籍链接： &lt;a href=&quot;https://book.douban.com/subject/26639401/&quot;&gt;学习JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Nov 2018 06:26:00 +0000</pubDate>
<dc:creator>赖同学</dc:creator>
<og:description>本章中，将学习另外一种非线性数据结构——图。这是学习的最后一种数据结构，后面将学习排序和搜索算法。 第九章 图 图的相关术语 图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。学习图是重要的，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lbh2018/p/JavaScript_Data_Structures_and_Algorithms_Part9.html</dc:identifier>
</item>
</channel>
</rss>