<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据结构 集合_集合接口的定义 - IDreamo</title>
<link>http://www.cnblogs.com/idreamo/p/7907056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/idreamo/p/7907056.html</guid>
<description>&lt;p&gt;&lt;strong&gt;set_init&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;void set_init(Set *set,int(*match)(vonst void *key1,const void *key2),void (*destroy)(void *data));&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：无&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：&lt;strong&gt;初始化由参数set指定的集合&lt;/strong&gt;。该函数必须在其他操作之前调用。&lt;/p&gt;
&lt;p&gt;参数match是一个函数指针，用来在各种集合操作中判断两个成员是否匹配。如果key1等于key2，则match函数应返回1；否则返回0。&lt;/p&gt;
&lt;p&gt;参数destroy提供了一种释放动态分配空间的方法。destroy应该设置为一个由用户自定义的析构函数来释放每个动态分配的成员以及结构体本身所占用的内存空间。如果集合包含的数据不应该被释放的话，destroy应该被设置为NULL。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O(1)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set_destroy&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;void set_destroy(Set *set);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：无&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：&lt;strong&gt;销毁由参数set所指定的集合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调用set_destroy后集合的其他操作都不允许再执行，除非再次调用set_init。set_destroy操作将集合中的所有成员都移除，如果传递给set_init的参数destroy不为NULL的话，则调用destroy所指定的函数，对集合中每个移除的元素施行资源回收操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度：&lt;/strong&gt;O(n)，这里n代表集合中的元素的个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set_insert&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;int set_insert(Set *set ,const void *data);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：如果插入操作成功则返回0，如果插入的成员在集合中已经存在返回1，否则返回-1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：&lt;strong&gt;在由参数set所指定的集合中插入一个成员&lt;/strong&gt;。新成员包含一个指向data的指针，因此只要该成员还在集合中，则data所引用的内存空间就应该保持合法。由调用者负责管理data所关联的存储空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O(n)，这里n代表集合中的元素个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set_remove&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;int set_remove(Set *set ,const void **data);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：如果移除操作成功则返回0，否则返回-1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：&lt;strong&gt;在由参数set所指定的集合中移除数据域同data相吻合的成员&lt;/strong&gt;。函数返回后，data指向移除的成员的数据部分。由调用者负责管理data所关联的存储空间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O(n)，这里n代表集合中的元素个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; set_union&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;int set_union(Set *setu, const Set *set1, const Set *set2);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：如果计算并集成功则返回0；否则返回-1 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述：建立一个集合，其结果是set1和set2所指定的集合的并集。&lt;/strong&gt;返回后setu就代表这个并集。&lt;/p&gt;
&lt;p&gt;因为setu指向set1和set2中成员的数据域，所以set1和set2中的数据必须保持合法，直到setu被set_destroy销毁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O(mn)，这里的m和n分别代表集合set1和set2中的元素个数。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;set_intersection&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;int set_intersection(Set *seti, const Set *set1, const Set *set2);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：如果计算交集成功则返回0；否则返回-1 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述：建立一个集合，其结果是set1和set2所指定的集合的交集&lt;/strong&gt;。返回后seti就代表这个交集。&lt;/p&gt;
&lt;p&gt;因为seti指向set1中的成员的数据域，所以set1中的数据必须保持合法，直到seti被set_destroy销毁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O(mn)，这里的m和n分别代表集合set1和set2中的元素个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; set_difference&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;int set_difference(Set *setd, const Set *set1, const Set *set2);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：如果计算差集成功则返回0；否则返回-1 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述：建立一个集合，其结果是set1和set2所指定的集合的差集。&lt;/strong&gt;返回后setd就代表这个差集。&lt;/p&gt;
&lt;p&gt;因为setd指向set1中的成员的数据域，所以set1中的数据必须保持合法，直到setd被set_destroy销毁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O(mn)，这里的m和n分别代表集合set1和set2中的元素个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set_is_member&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;int set_is_member(const Set *set, const void *data);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：如果找到成员返回1；否则返回0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述：判断由data所指定的成员是否存在于set所指定的集合中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O(n)，这里n代表集合中的元素的个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set_is_subset&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;int set_is_subset(const Set *set1, const Set *set2);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：如果set1是set2的子集返回1；否则返回-1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：判断由参数set1所指定的集合是否为参数set2所指定集合的子集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度：&lt;/strong&gt;O(mn)，这里m、n分别代表集合set1和set2中的元素的个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set_is_equal&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;int set_is_equal(const Set *set1, const Set *set2);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：如果set1和set2相等返回1；否则返回-1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述：判断由参数set1所指定的集合是否等于由参数set2所指定集合&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O(mn)，这里m、n分别代表集合set1和set2中的元素的个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set_size&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;int set_size(const Set *set);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：返回集合中的元素个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述：这是一个宏，用来返回由参数set所指定的集合中的元素个数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O(1)&lt;/p&gt;

</description>
<pubDate>Mon, 27 Nov 2017 22:33:00 +0000</pubDate>
<dc:creator>IDreamo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/idreamo/p/7907056.html</dc:identifier>
</item>
<item>
<title>【smart-transform】取自 Atom 的 babeljs/coffeescript/typescript 智能转 es5 库 - iOS122</title>
<link>http://www.cnblogs.com/ios122/p/7907011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ios122/p/7907011.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;有时间研究下开源库的源码，总是会有些收获的。注意到 Atom 插件编写时，可以直接使用 babel, coffeescript 或者 typescript。有些诧异，毕竟 Electron 中内置的 node 引擎，也一定不是完全兼容 es6，更不用说 coffeescript 和 typescript了。所以，必然在加载插件时，Atom 有某种自动转换的操作。刚好最近有一些类似的需求，需要批量以单个文件的方式转换一些其他语法的文件到 es5 兼容的js文件，于是就把 Atom 的转换机制拆分了出来，写成一个 cli。&lt;/p&gt;
&lt;p&gt;他山之玉，不敢私藏。如果只是使用，请直接在npmjs上查找：&lt;a href=&quot;https://www.npmjs.com/package/smart-transform&quot;&gt;smart-transform&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;特色定制&quot;&gt;特色定制&lt;/h2&gt;
&lt;p&gt;毋容置疑，最核心的地方是取自于 Atom 本身。之所以把这个逻辑单独剥离出来，主要是我很羡慕 Atom 插件编写时，各种语法随心使用的舒爽！要是自己项目，也能这么随意，岂不是爽歪歪！！！&lt;/p&gt;
&lt;p&gt;为了独立于 Atom 使用，同时又具备一定的通用新，主要定制性体现在：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将逻辑剥离成一个 cli 命令行工具，以后不管自己还是别人，拿来即用。不是每个前端，都很擅长 nodejs，所以我觉得，这还是能方便一些人的。&lt;/li&gt;
&lt;li&gt;通过配置文件，允许个性化定制。即，每个项目的输入和输出目录可以通过配置文件来自由配置。现在还不够灵活，只支持指定唯一一个输入文件夹和唯一一个输出文件夹，不过暂时够用了。&lt;/li&gt;
&lt;li&gt;引入 &lt;strong&gt;uglify-js&lt;/strong&gt; 进行压缩和混淆。这一点，确实是项目本身的需要，我相信大部分人，都有这个需求吧？另外，之所以直接使用 &lt;strong&gt;uglify-js&lt;/strong&gt; ，当然是因为我不想再额外配置 webpack 呀！！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;扔一个 &lt;strong&gt;smart-transform.json&lt;/strong&gt; 配置文件示例上来吧：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;in&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;./src&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;out&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;./lib&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;exclude&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;./src/hi-ignore.js&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;minify&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;minifyExclude&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;./src/hi-ts.ts&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;源码解读&quot;&gt;源码解读&lt;/h2&gt;
&lt;h3 id=&quot;package.json&quot;&gt;package.json&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;  &lt;span class=&quot;er&quot;&gt;&quot;bin&quot;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;smart-transform&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;index.js&quot;&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比较特殊的是 bin 字段。第一次写 cli 的童鞋，常常因为没有写这个字段，导致没有以全局命令的形式使用自己的工具库。&lt;/p&gt;
&lt;h3 id=&quot;index.js&quot;&gt;index.js&lt;/h3&gt;
&lt;p&gt;这是定制最多的一个文件。它实现的主要功能是，读取具体项目根目录的配置文件 &lt;strong&gt;smart-transform.json&lt;/strong&gt; ，然后根据内部字段，来进行一些个性化的转换操作。&lt;/p&gt;
&lt;p&gt;目前支持的操作有:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将指定目录的 babeljs/coffeescript/typescript 转为 es5 兼容的js文件，并输出到另一个目录。&lt;/li&gt;
&lt;li&gt;忽略某些文件，不对其进行转换操作。&lt;/li&gt;
&lt;li&gt;转换时，可选支持同时进行压缩和混淆操作。压缩和混淆，目前使用的是 &lt;a href=&quot;https://github.com/mishoo/UglifyJS2&quot;&gt;uglify-js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码不长，但是本身有一些 node 相关的代码，所以我就还是贴出来，感兴趣的顺便瞅一眼：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;26&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;#!/usr/bin/env node&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;'use strict'&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;path&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; fs &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;'fs-plus'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; fse &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'fs-extra'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; os &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;os&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;execSync&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;child_process&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; UglifyJS &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;uglify-js&quot;&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; argv &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'minimist'&lt;/span&gt;)(&lt;span class=&quot;va&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;argv&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;slice&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; project &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;argv&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;project&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; configInfo &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;path&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;resolve&lt;/span&gt;(project&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;./smart-transform.json&quot;&lt;/span&gt;))

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; inDir &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;path&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;resolve&lt;/span&gt;(project&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;configInfo&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;in&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; outDir &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;path&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;resolve&lt;/span&gt;(project&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;configInfo&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;out&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; minify &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;configInfo&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;minify&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; excludeFiles &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;configInfo&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;exclude&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (filePath) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;path&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;resolve&lt;/span&gt;(project&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;filePath)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; minifyExcludeFiles &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;configInfo&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;minifyExclude&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;map&lt;/span&gt;(
  &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (filePath) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;path&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;resolve&lt;/span&gt;(project&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;filePath)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
)

&lt;span class=&quot;va&quot;&gt;fse&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;ensureDirSync&lt;/span&gt;(outDir)

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; inFiles &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;listSync&lt;/span&gt;(inDir&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;[&lt;span class=&quot;st&quot;&gt;&quot;.js&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;.ts&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;coffee&quot;&lt;/span&gt;])

&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; inFile of inFiles) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;excludeFiles&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;includes&lt;/span&gt;(inFile)) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 不需要处理的,直接复制到输出目录&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; outFile &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;path&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;resolve&lt;/span&gt;(project&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;outDir&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;path&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;basename&lt;/span&gt;(inFile))
      &lt;span class=&quot;va&quot;&gt;fse&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;copySync&lt;/span&gt;(inFile&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;outFile)
      &lt;span class=&quot;cf&quot;&gt;continue&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; sourceCode &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;./compile-file&quot;&lt;/span&gt;)(inFile)

    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (minify &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;minifyExcludeFiles&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;includes&lt;/span&gt;(inFile)) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      sourceCode &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;UglifyJS&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;minify&lt;/span&gt;(sourceCode).&lt;span class=&quot;at&quot;&gt;code&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; outFile &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;path&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;resolve&lt;/span&gt;(project&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;outDir&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;path&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;basename&lt;/span&gt;(inFile&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;path&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;extname&lt;/span&gt;(inFile)) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;.js&quot;&lt;/span&gt;)
    &lt;span class=&quot;va&quot;&gt;fse&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;ensureFileSync&lt;/span&gt;(outFile)
    &lt;span class=&quot;va&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;writeFileSync&lt;/span&gt;(outFile&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;sourceCode)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;compile-file.js&quot;&gt;compile-file.js&lt;/h3&gt;
&lt;p&gt;相关预编译逻辑取自原Atom代码中的 &lt;a href=&quot;https://github.com/atom/atom/blob/1.12-releases-archived/src/compile-cache.js&quot;&gt;src/compile-cache.js&lt;/a&gt; 类,主要区别是，禁用代码地图并禁用输出代码内的注释。考虑到项目本身的内部兼容性，并没有直接使用最新版的 Atom 源码演绎。如果自己有其他定制需求，可以直接看 Atom 源码。&lt;/p&gt;
&lt;p&gt;这个文件比较出彩的地方是，它把各种类似的语法都使用 &lt;strong&gt;COMPILERS&lt;/strong&gt; 的机制管理。一种语法对应一个 &lt;strong&gt;COMPILER&lt;/strong&gt;。在某些特定情况下，如果你想解析或转换其他类型的文件，只需要修改这个类，新增一个 &lt;strong&gt;COMPILER&lt;/strong&gt; 即可。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;st&quot;&gt;'use strict'&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'path'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; fs &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'fs-plus'&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; COMPILERS &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;st&quot;&gt;'.js'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./babel'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;st&quot;&gt;'.ts'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./typescript'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;st&quot;&gt;'.coffee'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./coffee-script'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;compileFileAtPath&lt;/span&gt; (filePath) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; extension &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;path&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;extname&lt;/span&gt;(filePath)
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; compiler &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; COMPILERS[extension]

  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; sourceCode &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;readFileSync&lt;/span&gt;(filePath&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'utf8'&lt;/span&gt;)

  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;compiler&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;shouldCompile&lt;/span&gt;(sourceCode&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; filePath)) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; compiledCode &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;compiler&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;compile&lt;/span&gt;(sourceCode&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; filePath)
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; compiledCode
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; sourceCode
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;module&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; compileFileAtPath&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;babel.js-coffee-script.js-typescript.js&quot;&gt;babel.js coffee-script.js typescript.js&lt;/h3&gt;
&lt;p&gt;分别取自 Atom 源码中的 &lt;a href=&quot;https://github.com/atom/atom/blob/1.12-releases-archived/src/babel.js&quot;&gt;babel.js&lt;/a&gt; &lt;a href=&quot;https://github.com/atom/atom/blob/1.12-releases-archived/src/coffee-script.js&quot;&gt;coffee-script.js&lt;/a&gt; &lt;a href=&quot;https://github.com/atom/atom/blob/1.12-releases-archived/src/typescript.js&quot;&gt;typescript.js&lt;/a&gt;。有极小的修改，典型的 &lt;strong&gt;拿来主义&lt;/strong&gt; 。有兴趣的，直接去看下源码，此处不做赘述。&lt;/p&gt;
&lt;h3 id=&quot;注意&quot;&gt;注意&lt;/h3&gt;
&lt;p&gt;使用 bable 的js文件,开头应是以下几种的其中一种,否则无法被识别:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/** @babel */
&quot;use babel&quot;
'use babel'
/* @flow */&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
</description>
<pubDate>Mon, 27 Nov 2017 17:55:00 +0000</pubDate>
<dc:creator>iOS122</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ios122/p/7907011.html</dc:identifier>
</item>
<item>
<title>Java学习笔记17---方法的重载与重写 - 蝉蝉</title>
<link>http://www.cnblogs.com/chanchan/p/7906876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chanchan/p/7906876.html</guid>
<description>&lt;p&gt;&lt;strong&gt;重载是指&lt;/strong&gt;，一个类中定义了一个成员方法后，通过修改参数个数、参数类型或参数顺序，重新实现该方法，则这两个方法互为对方的重载方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重写是指&lt;/strong&gt;，子类重新实现父类的成员方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重载后的方法&lt;/strong&gt;，与原方法相比：&lt;/p&gt;
&lt;p&gt;(1).方法名相同，参数个数、参数类型及参数顺序至少有一个不同；&lt;/p&gt;
&lt;p&gt;(2).返回值类型与访问权限修饰符可以相同也可以不同，只修改这两项不能算重载；&lt;/p&gt;
&lt;p&gt;(3).静态成员方法也可以重载，重载后的方法也可以是非静态成员方法；&lt;/p&gt;
&lt;p&gt;(4).可以有多个重载方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;子类重写后的方法&lt;/strong&gt;，与父类的方法相比：&lt;/p&gt;
&lt;p&gt;(1).方法名、参数个数、参数类型及参数顺序必须一致；&lt;/p&gt;
&lt;p&gt;(2).返回值类型为基本数据类型时，不可以修改，返回值为类类型时，可以修改，具体参见&lt;a href=&quot;http://www.cnblogs.com/chanchan/p/7796472.html&quot; target=&quot;_blank&quot;&gt;笔记13&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;(3).访问权限修饰符可以修改也可以不修改，如果修改的话，必须要大于父类方法的访问范围；&lt;/p&gt;
&lt;p&gt;(4).静态成员方法也可以重写，但重写后的方法只是被隐藏，并未覆盖父类的方法，具体参见&lt;a href=&quot;http://www.cnblogs.com/chanchan/p/7787453.html&quot; target=&quot;_blank&quot;&gt;笔记12&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;(5).一个子类只能重写父类的某个成员方法一次，否则，子类就会出现重名方法，会报错。&lt;/p&gt;

&lt;p&gt; 重载是同一个类内部的多个成员方法互为重载方法，重写是子类的成员方法重写了父类的成员方法；重载一般是为了创建一组要完成相似任务的成员方法，重写的目的是为了实现多态，实现多态有3个条件：继承、重写、向上转型，缺一不可。&lt;/p&gt;

&lt;p&gt;作者： 蝉蝉&lt;/p&gt;
&lt;p&gt;请尊重作者劳动成果，转载请在标题注明“转载”字样，并标明原文链接：&lt;/p&gt;
&lt;p&gt; &lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Java学习笔记17---方法的重载与重写&quot; href=&quot;http://www.cnblogs.com/chanchan/p/7906876.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/chanchan/p/7906876.html&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;下面是简单的程序示例。&lt;/p&gt;
&lt;p&gt;Person类是Student类的父类，TestMain类是测试类，具体代码如下：&lt;/p&gt;
&lt;p&gt;Person类的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package human;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
    String name;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    String gender;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person() {
        
    }
    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;笔记17：重载:方法名不变，参数的个数、类型及顺序至少与原方法有一个不同
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以更改返回值类型及访问权限修饰符，但不是必须的，只修改这两项也不算重载    &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; overLoadP(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, String s) {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + i + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; s);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; i+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public char overLoadP(int i, String s) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        return i+1;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以更改返回值类型及访问权限修饰符&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; overLoadP(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;)(i+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; overLoadP(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + i + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, n = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; n);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; i+&lt;span&gt;n;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; overLoadP(String s, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(s + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; overLoadPS() {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;静态成员方法可以重载吗&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; overLoadPS(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;静态成员方法可以重载&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Student类的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; human;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Student &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Person {
    String stuNumber;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; score;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student() {
        
    }    
    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;笔记17：重写:方法名、参数的个数、类型及顺序都要与父类方法一致
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类重写时，只有返回值为类类型时，才可以更改返回类型，且只能改为返回值类型的子类
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类访问权限修饰符的范围要大于父类的
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public char overLoadP(int i, String s) {&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; overLoadP(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, String s) {
        System.out.println(&lt;/span&gt;&quot;子类重写：i = &quot; + i + &quot;, &quot; +&lt;span&gt; s);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; i+1&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;TestMain类的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; human;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestMain {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        
        Person per &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
        Student stu &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student();
        
        per.overLoadP(&lt;/span&gt;1&lt;span&gt;);
        per.overLoadP(&lt;/span&gt;1, 2&lt;span&gt;);
        per.overLoadP(&lt;/span&gt;1, &quot;bokeyuanchanchan&quot;&lt;span&gt;);
        per.overLoadP(&lt;/span&gt;&quot;bokeyuanchanchan&quot;, 1&lt;span&gt;);
        per.overLoadPS(&lt;/span&gt;2&lt;span&gt;);
        per.overLoadPS();
        
        stu.overLoadP(&lt;/span&gt;1,&quot;博客园蝉蝉&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; i = 1
&lt;span&gt;2&lt;/span&gt; i = 1, n = 2
&lt;span&gt;3&lt;/span&gt; i = 1&lt;span&gt;, bokeyuanchanchan
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; bokeyuanchanchan, i = 1
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;静态成员方法可以重载
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;静态成员方法可以重载吗
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 子类重写：i = 1, 博客园蝉蝉
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;分析如下：&lt;/p&gt;
&lt;p&gt;关于重载：&lt;/p&gt;
&lt;p&gt;(1).最先定义了public int overLoadP(int i, String s)这个方法，方法名为overLoadP，有两个参数，分别为int型和String型，返回值为int型。&lt;/p&gt;
&lt;p&gt;(2).随后又定义了3个重名的方法，分别为：&lt;/p&gt;
&lt;p&gt;protected char overLoadP(int i)&lt;/p&gt;
&lt;p&gt;public int overLoadP(int i, int n)&lt;/p&gt;
&lt;p&gt;public int overLoadP(String s, int i)&lt;/p&gt;
&lt;p&gt;这3个方法与原方法的参数不同点分别在于，参数个数不同、参数类型不同、参数顺序不同，这3个方法都是原方法的重载方法，这4个方法互为对方的重载方法。&lt;/p&gt;
&lt;p&gt;其中protected char overLoadP(int i)，返回值类型与访问权限修饰符也与原方法不同，可见这两项是可以修改的，但只修改这两项并不能算重载，见(3)。&lt;/p&gt;
&lt;p&gt;(3).Person类中下面注释掉的代码行，与第1个方法仅返回值不同，会出现“Duplicate method voerLoadP(int, String) in type Person”的错误。也就是说，&lt;strong&gt;仅返回值类型不同是不能算重载的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;// public char overLoadP(int i, String s) {&lt;/p&gt;
&lt;p&gt;// return i+1;&lt;/p&gt;
&lt;p&gt;// }&lt;/p&gt;
&lt;p&gt;(4).由结果可知，静态成员方法也可以重载。&lt;/p&gt;
&lt;p&gt;关于重写：&lt;/p&gt;
&lt;p&gt;(5).子类重写了父类的public int overLoadP(int i, String s)，方法名、参数个数、参数类型、参数顺序及返回值类型都与父类一致。&lt;/p&gt;
&lt;p&gt;对于代码中注释掉的行，不注释的话会提示返回值类型与父类返回值不一致的错误。&lt;/p&gt;
&lt;p&gt;// &lt;span class=&quot;Apple-tab-span&quot;&gt;public char overLoadP(int i, String s) {&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Nov 2017 16:47:00 +0000</pubDate>
<dc:creator>蝉蝉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chanchan/p/7906876.html</dc:identifier>
</item>
<item>
<title>课外 - Jision</title>
<link>http://www.cnblogs.com/Wision-22/p/7906830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wision-22/p/7906830.html</guid>
<description>&lt;p&gt;/*循环输出数组的值，求和及平均值，查找判断输入数是否在数组里*/&lt;/p&gt;
&lt;p&gt;#include &quot;stdio.h&quot;&lt;br/&gt;void main()&lt;br/&gt;{&lt;br/&gt;    int nums[]={8,4,2,1,23,344,12};&lt;br/&gt;    int i,sum=0,searchNum;&lt;br/&gt;    double avg;&lt;br/&gt; //要查找的数字&lt;br/&gt;    printf(&quot;输出数组元素：\n&quot;);&lt;br/&gt;    for (i=0;i&amp;lt;7;i++)&lt;br/&gt;  {&lt;br/&gt;   printf(&quot;%d\t&quot;,nums[i]);&lt;br/&gt;  }  &lt;br/&gt; printf(&quot;\n&quot;);&lt;br/&gt; &lt;br/&gt; for(i=0;i&amp;lt;7;i++)&lt;br/&gt; {&lt;br/&gt;  sum+=nums[i]; &lt;br/&gt; }&lt;br/&gt; avg=sum/7.0;&lt;/p&gt;
&lt;p&gt;printf(&quot;请输入要查找的数字：&quot;);&lt;br/&gt;scanf(&quot;%d&quot;,&amp;amp;searchNum); &lt;br/&gt;for(i=0;i&amp;lt;7;i++)&lt;br/&gt;{&lt;br/&gt; //一个一个对比&lt;br/&gt; if(searchNum==nums[i]) &lt;br/&gt; {&lt;br/&gt;  printf(&quot;ture&quot;);&lt;br/&gt;  break;&lt;br/&gt;   &lt;br/&gt; } &lt;br/&gt; }&lt;br/&gt;if (i==7)&lt;br/&gt;printf(&quot;false&quot;); &lt;br/&gt;}&lt;/p&gt;
</description>
<pubDate>Mon, 27 Nov 2017 16:12:00 +0000</pubDate>
<dc:creator>Jision</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wision-22/p/7906830.html</dc:identifier>
</item>
<item>
<title>Java8 HashMap源码分析 - -Finley-</title>
<link>http://www.cnblogs.com/Finley/p/7906810.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Finley/p/7906810.html</guid>
<description>&lt;p&gt;&lt;code&gt;java.util.HashMap&lt;/code&gt;是最常用的java容器类之一, 它是一个线程不安全的容器. 本文对JDK1.8.0中的HashMap实现源码进行分析.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;使用位运算巧妙的进行散列并使用链地址法处理冲突. 自JDK1.8后, 若表中某个位置元素数超过阈值 则会将其自动转换为红黑树来提高检索效率.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;中的迭代器同样采用&lt;code&gt;fail-fast&lt;/code&gt;机制, 即若迭代过程中容器发生结构性改变, 则会终止迭代.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;主要有三个视图接口&lt;code&gt;keySet()&lt;/code&gt;, &lt;code&gt;values()&lt;/code&gt;, &lt;code&gt;entrySet()&lt;/code&gt;. 它们都是基于迭代器实现的, 并不实际存储数据.&lt;/p&gt;

&lt;p&gt;自JDK1.8.0开始HashMap使用静态内部类&lt;code&gt;Node&lt;/code&gt;来存储键值对结构, 不再使用&lt;code&gt;Map.Entry&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Map.&lt;span class=&quot;fu&quot;&gt;Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; {
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hash;
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; K key;
    V value;
    Node&amp;lt;K,V&amp;gt; next;

    Node(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {...}

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; K &lt;span class=&quot;fu&quot;&gt;getKey&lt;/span&gt;()        { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; key; }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; V &lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;()      { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; value; }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;() { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; key + &lt;span class=&quot;st&quot;&gt;&quot;=&quot;&lt;/span&gt; + value; }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;() { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; Objects.&lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;(key) ^ Objects.&lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;(value); }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; V &lt;span class=&quot;fu&quot;&gt;setValue&lt;/span&gt;(V newValue) {...}

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(Object o) {...}
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意&lt;code&gt;Node.next&lt;/code&gt;使得Node可以形成单向链表结构. 再来看一下&lt;code&gt;HashMap&lt;/code&gt;中的主要字段:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;transient&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] table;
&lt;span class=&quot;kw&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; size;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;的底层数据结构是存储在&lt;code&gt;table&lt;/code&gt;域中的哈希表(Hash Table, 又称散列表). 哈希表是存储键值对的数组, 在查找元素时根据键的值计算出键值对在数组中的位置, 不需要扫描数组.&lt;/p&gt;
&lt;p&gt;哈希表类似于词典, 可以通过词条快速地找出释义的位置, 不必从头开始逐个寻找. 哈希表访问元素的时间复杂度为O(1), 远高于普通数组的O(n)或树状结构的O(logn).&lt;/p&gt;
&lt;p&gt;最简单的哈希函数自然是&lt;code&gt;key.hashCode() % table.length&lt;/code&gt;, 这就引出了哈希表固有的哈希冲突问题.&lt;/p&gt;
&lt;p&gt;若&lt;code&gt;table.length&lt;/code&gt;为16, &lt;code&gt;key1.hashCode()&lt;/code&gt;为1202, &lt;code&gt;key2.hashCode()&lt;/code&gt;为3218. 那么,&lt;code&gt;key1&lt;/code&gt;和&lt;code&gt;key2&lt;/code&gt;的哈希值同为2, 但是&lt;code&gt;table[2]&lt;/code&gt;只能放置一个元素于是产生了哈希冲突.&lt;/p&gt;
&lt;p&gt;哈希冲突问题主要从两方面考虑, 一是尽量减少哈希冲突的发生, 二是在哈希冲突发生后仍然正常工作.&lt;/p&gt;
&lt;h2 id=&quot;哈希函数&quot;&gt;哈希函数&lt;/h2&gt;
&lt;p&gt;HashMap根据&lt;code&gt;Node.key&lt;/code&gt;计算出&lt;code&gt;Node&lt;/code&gt;在&lt;code&gt;table&lt;/code&gt;数组中的位置, 但是并没有采用上文提及最简单的哈希函数:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt;(Object key) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; h;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (key == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) ? &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; : (h = key.&lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;()) ^ (h &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hash函数的代码非常简练, 我们稍微改写一下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt;(Object key) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(key == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
      &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; h = key.&lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;();
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; h ^ (h &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键的位运算&lt;code&gt;h ^ (h &amp;gt;&amp;gt;&amp;gt; 16)&lt;/code&gt;, 将32位整数h算术右移16位后与原值进行异或操作:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;h = 0xf0f00f0f: 
1111 0000 1111 0000 0000 1111 0000 1111   
h &amp;gt;&amp;gt;&amp;gt; 16 = 0x0000f0f0:
0000 0000 0000 0000 1111 0000 1111 0000  
h ^ (h &amp;gt;&amp;gt;&amp;gt; 16) = 0xf0f0ffff
1111 0000 1111 0000 1111 1111 1111 0000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;中&lt;code&gt;Node&lt;/code&gt;在&lt;code&gt;table&lt;/code&gt;数组中的实际位置为&lt;code&gt;(n - 1) &amp;amp; hash&lt;/code&gt;. n为当前&lt;code&gt;table.length&lt;/code&gt;, &lt;code&gt;HashMap&lt;/code&gt;的扩容机制保证n为2的整数次幂, 因此&lt;code&gt;(n - 1) &amp;amp; hash == hash % n&lt;/code&gt;, 取n=16示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;n - 1 = 15
0000 0000 1111
hash = 2562
1010 0000 0010
(n - 1) &amp;amp; hash = 2
0000 0000 0010&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于n一般较小, 当n &amp;lt; 65535时高16位为0. 若&lt;code&gt;HashMap&lt;/code&gt;采用&lt;code&gt;key.hashCode() % n&lt;/code&gt;来决定键值对的位置, 则&lt;code&gt;hashCode()&lt;/code&gt;的高16位对结果产生影响较小.&lt;/p&gt;
&lt;p&gt;高16位很可能不参与运算意味着产生哈希冲突的可能性增大, 因此&lt;code&gt;HashMap&lt;/code&gt;先让高16位与低16位进行异或计算, 减少了哈希冲突的可能性.&lt;/p&gt;
&lt;h2 id=&quot;链地址法&quot;&gt;链地址法&lt;/h2&gt;
&lt;p&gt;在实践中无论使用什么哈希函数仍然存在冲突的可能性, 因此必须设计合适的机制在发生冲突后仍然能够正常工作. 常用的方法有开放地址法和链地址法.&lt;/p&gt;
&lt;p&gt;使用开放地址法的哈希表每个位置只能放一个元素. 当发生哈希冲突时, 按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止.&lt;/p&gt;
&lt;p&gt;典型的如线性再散列: &lt;code&gt;H = (e.hashCode + n) % table.length&lt;/code&gt;, 其中n为再散列的次数, 即发生第1次冲突时需要再散列时&lt;code&gt;n = 1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;开放地址法的缺点在于再散列占据了哈希表中另一个位置, 增加了后续操作中发生哈希冲突的可能性.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;采用了另一种冲突解决方案 - 链地址法. 即哈希表中每个位置是一个链表, 允许放置多个元素. 发生哈希冲突时, 新元素只需添加到链表尾即可.&lt;/p&gt;
&lt;p&gt;注意到&lt;code&gt;Node.next&lt;/code&gt;域可以让&lt;code&gt;Node&lt;/code&gt;连接为一个单链表, 即可使用链地址法解决哈希冲突.&lt;/p&gt;
&lt;p&gt;若链表长度过长仍会造成查询效率降低, 在JDK1.8中的&lt;code&gt;HashMap&lt;/code&gt;实现中若某个位置链表长度达到阈值&lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt;则会将链表变形为红黑树. 当删除元素使红黑树中元素数低于&lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt;时会变回链表.&lt;/p&gt;
&lt;p&gt;本文将在添加元素一节中详细介绍链地址法的实现.&lt;/p&gt;

&lt;p&gt;与&lt;code&gt;ArrayList&lt;/code&gt;中的构造器类似, &lt;code&gt;HashMap&lt;/code&gt;的构造器只是计算并写入参数, 当第一次添加元素时才会实际分配存储空间:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; HashMap(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; initialCapacity, &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; loadFactor) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (initialCapacity &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;Illegal initial capacity: &quot;&lt;/span&gt; +
                                           initialCapacity);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (loadFactor &amp;lt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; || Float.&lt;span class=&quot;fu&quot;&gt;isNaN&lt;/span&gt;(loadFactor))
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;Illegal load factor: &quot;&lt;/span&gt; +
                                           loadFactor);
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;loadFactor&lt;/span&gt; = loadFactor;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;threshold&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;tableSizeFor&lt;/span&gt;(initialCapacity);
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; HashMap(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; initialCapacity) {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;(initialCapacity, DEFAULT_LOAD_FACTOR);
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; HashMap() {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;loadFactor&lt;/span&gt; = DEFAULT_LOAD_FACTOR; &lt;span class=&quot;co&quot;&gt;// all other fields defaulted&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三个构造器主要是设置&lt;code&gt;initialCapacity&lt;/code&gt;和&lt;code&gt;loadFactor&lt;/code&gt;参数. &lt;code&gt;initialCapcity&lt;/code&gt;是&lt;code&gt;table&lt;/code&gt;的初始大小; 当元素数达到&lt;code&gt;threshold&lt;/code&gt;时, &lt;code&gt;HashMap&lt;/code&gt;会执行扩容.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;loadFactor&lt;/code&gt;是影响&lt;code&gt;threshold&lt;/code&gt;的参数:&lt;code&gt;threshold = table.length * loadFactor&lt;/code&gt;. &lt;code&gt;loadFactor&lt;/code&gt;默认为0.75, 这是在空间利用率和执行效率之间比较平衡的取值.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int tableSizeFor(cap)&lt;/code&gt;方法的返回值是大于cap的最小的2的整数幂. 注意到构造器只是设置了&lt;code&gt;threshold&lt;/code&gt;, 保证在初次扩容时达到&lt;code&gt;initialCapacity&lt;/code&gt;并没有实际分配存储空间.&lt;/p&gt;

&lt;p&gt;首先阅读添加单个键值对的&lt;code&gt;put&lt;/code&gt;方法:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(K key, V value) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;putVal&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt;(key), key, value, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
}

&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; V &lt;span class=&quot;fu&quot;&gt;putVal&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hash, K key, V value, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; onlyIfAbsent,
               &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, i;
    &lt;span class=&quot;co&quot;&gt;// resize方法用于检查空间足够和扩容&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 构造器只指定了参数并没有实际分配空间, 此处调用resize的目的是分配初始空间&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((tab = table) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || (n = tab.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;) == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        n = (tab = &lt;span class=&quot;fu&quot;&gt;resize&lt;/span&gt;()).&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 若没有发生哈希冲突, 直接添加一个Node对象&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((p = tab[i = (n - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &amp;amp; hash]) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
        tab[i] = &lt;span class=&quot;fu&quot;&gt;newNode&lt;/span&gt;(hash, key, value, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        Node&amp;lt;K,V&amp;gt; e; K k;
        &lt;span class=&quot;co&quot;&gt;// 若键相同, 则对值进行更新&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; == hash &amp;amp;&amp;amp;
            ((k = p.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) == key || (key != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(k))))
            e = p;
        &lt;span class=&quot;co&quot;&gt;// 若该位置已经存在一个红黑树节点, 则将新元素添加到树中&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; TreeNode)
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).&lt;span class=&quot;fu&quot;&gt;putTreeVal&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, tab, hash, key, value);
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// 若该位置存在一个链表, 则先查找链表中是否存在相同键&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 若存在相同键则更新值&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 若不存在相同键则添加节点&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; binCount = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; ; ++binCount) {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((e = p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                    p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;newNode&lt;/span&gt;(hash, key, value, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
                    &lt;span class=&quot;co&quot;&gt;// 若添加后达到阈值, 则将链表转换为红黑树&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) 
                        &lt;span class=&quot;fu&quot;&gt;treeifyBin&lt;/span&gt;(tab, hash);
                    &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
                }
                &lt;span class=&quot;co&quot;&gt;// 发现相同键&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (e.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; == hash &amp;amp;&amp;amp;
                    ((k = e.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) == key || (key != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(k))))
                    &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
                p = e;
            }
        }
        &lt;span class=&quot;co&quot;&gt;// 存在相同键, 更新值&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (e != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) { 
            V oldValue = e.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                e.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt; = value;
            &lt;span class=&quot;fu&quot;&gt;afterNodeAccess&lt;/span&gt;(e);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; oldValue;
        }
    }
    ++modCount;
    &lt;span class=&quot;co&quot;&gt;// 添加元素后再次检查是否需要扩容&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (++size &amp;gt; threshold)
        &lt;span class=&quot;fu&quot;&gt;resize&lt;/span&gt;();
    &lt;span class=&quot;fu&quot;&gt;afterNodeInsertion&lt;/span&gt;(evict);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后阅读进行扩容的&lt;code&gt;resize&lt;/code&gt;方法, &lt;code&gt;HashMap&lt;/code&gt;的扩容并不是简单地创建一个更大的&lt;code&gt;table&lt;/code&gt;并把原来的元素复制过去.&lt;/p&gt;
&lt;p&gt;因为&lt;code&gt;table.length&lt;/code&gt;发生了变化, 所以哈希地址&lt;code&gt;hash(key) % table.length&lt;/code&gt;也会随之变化, 因此需要重新计算哈希地址. 除了保证正确索引外, 重新计算哈希值也可以将一个链表分散为多个较短的链表, 提高索引效率.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;resize()&lt;/code&gt;的扩容策略为2倍扩容, 因为原大小为2的整数次幂, 扩容后仍然保持该性质使基于位运算的哈希函数不会失效.&lt;/p&gt;
&lt;p&gt;容量变为2倍使哈希地址增加了1位, 原来哈希地址相同的元素将会根据新增位的0-1取值被分散到两个两个地址中.&lt;/p&gt;
&lt;p&gt;如当容量为16时, &lt;code&gt;5 % 16&lt;/code&gt;, &lt;code&gt;21 % 16&lt;/code&gt;得到的哈希地址均为5, 容量加倍后&lt;code&gt;5 % 32 = 5; 21 % 32 = 21&lt;/code&gt;. 注意到5的二进制表示&lt;code&gt;00101&lt;/code&gt;与21的二进制表示&lt;code&gt;10101&lt;/code&gt;仅有最高位不同.&lt;/p&gt;
&lt;p&gt;计算最高位的取值非常简单, 若&lt;code&gt;e.hashCode &amp;lt; oldCapacity&lt;/code&gt;则最高位取0, 否则最高位取1. 因为 &lt;code&gt;oldCapacity&lt;/code&gt;是2的整数幂(二进制形式为&lt;code&gt;1000...&lt;/code&gt;), 所以可以用&lt;code&gt;e.hashCode &amp;amp; oldCapacity = 0&lt;/code&gt;代替&lt;code&gt;e.hashCode &amp;lt; oldCapacity&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;的实现采用了上述位运算策略将哈希表中的链表一分为二, 而避免重新计算哈希位置的开销.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] &lt;span class=&quot;fu&quot;&gt;resize&lt;/span&gt;() {
    Node&amp;lt;K,V&amp;gt;[] oldTab = table;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; oldCap = (oldTab == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) ? &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; : oldTab.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; oldThr = threshold;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; newCap, newThr = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 计算新的容量, 默认为原容量的2倍&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (oldCap &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.&lt;span class=&quot;fu&quot;&gt;MAX_VALUE&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; oldTab;
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((newCap = oldCap &amp;lt;&amp;lt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                 oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &amp;lt;&amp;lt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// double threshold&lt;/span&gt;
    }
    &lt;span class=&quot;co&quot;&gt;// 指定初始容量的构造器并没有实际分配缓冲区, 而是将大小写入threshold域&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 根据构造器写入的参数分配初始空间&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (oldThr &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) 
        newCap = oldThr;
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;co&quot;&gt;// 没有将初始容量写入threshold则按默认值分配&lt;/span&gt;
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    &lt;span class=&quot;co&quot;&gt;// 确保newThr被正确计算 &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (newThr == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; ft = (&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;)newCap * loadFactor;
        newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY ?
                  (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;)ft : Integer.&lt;span class=&quot;fu&quot;&gt;MAX_VALUE&lt;/span&gt;);
    }
    threshold = newThr;
    &lt;span class=&quot;co&quot;&gt;// 创建新的哈希表&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@SuppressWarnings&lt;/span&gt;({&lt;span class=&quot;st&quot;&gt;&quot;rawtypes&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;})
        Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node[newCap];
    table = newTab;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (oldTab != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; j &amp;lt; oldCap; ++j) {
            Node&amp;lt;K,V&amp;gt; e;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((e = oldTab[j]) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                oldTab[j] = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                &lt;span class=&quot;co&quot;&gt;// 若只有一个元素, 重新计算哈希值&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (e.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                    newTab[e.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; &amp;amp; (newCap - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)] = e;
                &lt;span class=&quot;co&quot;&gt;// 处理红黑树&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (e &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; TreeNode)
                    ((TreeNode&amp;lt;K,V&amp;gt;)e).&lt;span class=&quot;fu&quot;&gt;split&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, newTab, j, oldCap);
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; { 
                    &lt;span class=&quot;co&quot;&gt;// 处理链表, &lt;/span&gt;
                    Node&amp;lt;K,V&amp;gt; loHead = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, loTail = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// low&lt;/span&gt;
                    Node&amp;lt;K,V&amp;gt; hiHead = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, hiTail = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// high&lt;/span&gt;
                    Node&amp;lt;K,V&amp;gt; next;
                    &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; {
                        next = e.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
                        &lt;span class=&quot;co&quot;&gt;// 若新哈希值最高位为0, 则添加到lo链表中&lt;/span&gt;
                        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((e.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; &amp;amp; oldCap) == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (loTail == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                                loHead = e;
                            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                                loTail.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = e;
                            loTail = e;
                        }
                        &lt;span class=&quot;co&quot;&gt;// 若新哈希值最高位为1, 则添加到hi链表中&lt;/span&gt;
                        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (hiTail == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                                hiHead = e;
                            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                                hiTail.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = e;
                            hiTail = e;
                        }
                    } &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((e = next) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (loTail != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                        loTail.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                        newTab[j] = loHead;
                    }
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (hiTail != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                        hiTail.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; newTab;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;批量添加元素的&lt;code&gt;putAll(map)&lt;/code&gt;方法通过&lt;code&gt;map.entrySet&lt;/code&gt;获得要添加的元素, 然后调用&lt;code&gt;putVal&lt;/code&gt;方法逐个添加元素.&lt;/p&gt;

&lt;p&gt;在了解&lt;code&gt;HashMap&lt;/code&gt;的数据结构和添加元素策略之后, 查找元素的实现也不难理解:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(Object key) {
    Node&amp;lt;K,V&amp;gt; e;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (e = &lt;span class=&quot;fu&quot;&gt;getNode&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt;(key), key)) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; : e.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;;
}

&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span class=&quot;fu&quot;&gt;getNode&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hash, Object key) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; first, e; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n; K k;
    &lt;span class=&quot;co&quot;&gt;// 确定哈希表非空, 且目标位置非空&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((tab = table) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;) &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp;
        (first = tab[(n - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &amp;amp; hash]) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;co&quot;&gt;// 首先检查第一个元素是否为目标&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (first.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; == hash &amp;amp;&amp;amp; 
            ((k = first.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) == key || (key != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(k))))
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; first;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((e = first.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;co&quot;&gt;// 若是红黑树则搜索树&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (first &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; TreeNode)
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ((TreeNode&amp;lt;K,V&amp;gt;)first).&lt;span class=&quot;fu&quot;&gt;getTreeNode&lt;/span&gt;(hash, key);
            &lt;span class=&quot;co&quot;&gt;// 否则搜索链表&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (e.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; == hash &amp;amp;&amp;amp;
                    ((k = e.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) == key || (key != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(k))))
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; e;
            } &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((e = e.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
        }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;删除元素同样考虑了单节点, 链表和树三种情况:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;31&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(Object key) {
    Node&amp;lt;K,V&amp;gt; e;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (e = &lt;span class=&quot;fu&quot;&gt;removeNode&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt;(key), key, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;)) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; ?
        &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; : e.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;;
}

&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span class=&quot;fu&quot;&gt;removeNode&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hash, Object key, Object value,
                           &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; matchValue, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; movable) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, index;
    &lt;span class=&quot;co&quot;&gt;// 确定哈希表非空, 且目标位置非空&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((tab = table) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;) &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp;
        (p = tab[index = (n - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &amp;amp; hash]) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        Node&amp;lt;K,V&amp;gt; node = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, e; K k; V v;
        &lt;span class=&quot;co&quot;&gt;// 若目标位置的第一个节点即为要删除的节点&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; == hash &amp;amp;&amp;amp;
            ((k = p.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) == key || (key != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(k))))
            node = p;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((e = p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;co&quot;&gt;// 在红黑树中寻找要删除的节点&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; TreeNode)
                node = ((TreeNode&amp;lt;K,V&amp;gt;)p).&lt;span class=&quot;fu&quot;&gt;getTreeNode&lt;/span&gt;(hash, key);
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;// 在链表中寻找要删除的节点&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; {
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (e.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; == hash &amp;amp;&amp;amp;
                        ((k = e.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) == key ||
                         (key != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(k)))) {
                        node = e;
                        &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
                    }
                    p = e;
                } &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((e = e.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
            }
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (node != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (!matchValue || (v = node.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;) == value ||
                             (value != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; value.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(v)))) {
            &lt;span class=&quot;co&quot;&gt;// 删除树节点&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (node &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; TreeNode)
                ((TreeNode&amp;lt;K,V&amp;gt;)node).&lt;span class=&quot;fu&quot;&gt;removeTreeNode&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, tab, movable);
            &lt;span class=&quot;co&quot;&gt;// 删除单个节点&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (node == p)
                tab[index] = node.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
            &lt;span class=&quot;co&quot;&gt;// 删除链表中的节点&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = node.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
            ++modCount;
            --size;
            &lt;span class=&quot;fu&quot;&gt;afterNodeRemoval&lt;/span&gt;(node);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; node;
        }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 27 Nov 2017 16:02:00 +0000</pubDate>
<dc:creator>-Finley-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Finley/p/7906810.html</dc:identifier>
</item>
<item>
<title>初学者没有搞明白的GOROOT,GOPATH,GOBIN,project目录 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/7906722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/7906722.html</guid>
<description>&lt;p&gt;我们接下来一个一个来看关于Go语言中的三个目录的详细解释&lt;br/&gt;先通过go env查看go的环境变量(我这里是mac的环境，所以可能和你的不同)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
localhost:~ zhaofan$ go &lt;span&gt;env&lt;/span&gt;&lt;span&gt;
GOARCH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOBIN&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOEXE&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOHOSTARCH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOHOSTOS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;darwin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOOS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;darwin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOPATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Users/zhaofan/go_project&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GORACE&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOROOT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/Cellar/go/1.9.2/libexec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOTOOLDIR&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/Cellar/go/1.9.2/libexec/pkg/tool/darwin_amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GCCGO&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gccgo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CC&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOGCCFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/b6/mc1c40c91cld67ps963_r16h0000gn/T/go-build539393745=/tmp/go-build -gno-record-gcc-switches -fno-common&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CXX&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clang++&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_ENABLED&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_CFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-g -O2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_CPPFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
CGO_CXXFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-g -O2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_FFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-g -O2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_LDFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-g -O2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
PKG_CONFIG&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pkg-config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
localhost:&lt;/span&gt;~ zhaofan$
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;GOROOT&lt;/h2&gt;
&lt;p&gt;其实就是golang 的安装路径&lt;br/&gt;当你安装好golang之后其实这个就已经有了&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;GOPATH&lt;/h2&gt;
&lt;p&gt;go命令依赖的一个重要环境变量：$GOPATH&lt;/p&gt;
&lt;p&gt;其实可以把这个目录理解为工作目录，我个人定义的目录是：&lt;br/&gt;GOPATH=&quot;/Users/zhaofan/go_project&quot;&lt;br/&gt;当然这个目录是需要添加到环境变量中的&lt;/p&gt;
&lt;p&gt;go_project // (go_project为GOPATH目录)&lt;br/&gt;-- bin // golang编译可执行文件存放路径&lt;br/&gt;-- pkg // golang编译包时，生成的.a文件存放路径&lt;br/&gt;-- src // 源码路径。按照golang默认约定，go run，go install等命令的当前工作路径（即在此路径下执行上述命令）。&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;GOBIN&lt;/h2&gt;
&lt;p&gt;首先先看一下我的目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201711/997599-20171127233215019-1751642932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们通常是在go_project目录下执行go build,例如:&lt;br/&gt;/Users/zhaofan/go_project/src/go_dev/01/hello/hello.go&lt;br/&gt;我们现在要编译hello.go文件，我只需要切换到&lt;br/&gt;/Users/zhaofan/go_project目录中，然后执行：&lt;br/&gt;go build go_dev/01/hello&lt;br/&gt;golang 会自动去src下找hello目录，因为我的hello.go中代码的开通导入了packag main包，所以可以编译成可执行文件，但是这样默认在当前目录下生成可执行文件,虽然可以指定目录，但是还是感觉不是非常方便&lt;/p&gt;
&lt;p&gt;所以还有两个非常好用的命令：go get 和go install&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;go get&lt;/h3&gt;
&lt;p&gt;go get会做两件事：&lt;br/&gt;1. 从远程下载需要用到的包&lt;br/&gt;2. 执行go install&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;go install&lt;/h3&gt;
&lt;p&gt;go install 会生成可执行文件直接放到bin目录下，当然这是有前提的&lt;br/&gt;你编译的是可执行文件，如果是一个普通的包，会被编译生成到pkg目录下该文件是.a结尾&lt;/p&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;关于go的整体一个开发目录&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
go_project     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; go_project为GOPATH目录&lt;/span&gt;
  --&lt;span&gt; bin
     &lt;/span&gt;-- myApp1  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译生成&lt;/span&gt;
     -- myApp2  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译生成&lt;/span&gt;
     -- myApp3  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译生成&lt;/span&gt;
  --&lt;span&gt; pkg
  &lt;/span&gt;--&lt;span&gt; src
     &lt;/span&gt;-- myApp1     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; project1&lt;/span&gt;
        --&lt;span&gt; models
        &lt;/span&gt;--&lt;span&gt; controllers
        &lt;/span&gt;--&lt;span&gt; others
        &lt;/span&gt;--&lt;span&gt; main.go 
     &lt;/span&gt;-- myApp2     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; project2&lt;/span&gt;
        --&lt;span&gt; models
        &lt;/span&gt;--&lt;span&gt; controllers
        &lt;/span&gt;--&lt;span&gt; others
        &lt;/span&gt;--&lt;span&gt; main.go 
     &lt;/span&gt;-- myApp3     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; project3&lt;/span&gt;
        --&lt;span&gt; models
        &lt;/span&gt;--&lt;span&gt; controllers
        &lt;/span&gt;--&lt;span&gt; others
        &lt;/span&gt;-- main.go 
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 27 Nov 2017 15:33:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/7906722.html</dc:identifier>
</item>
<item>
<title>逆向知识十一讲,识别函数的调用约定,函数参数,函数返回值. - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7906670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7906670.html</guid>
<description>&lt;p&gt;在反汇编中,我们常常的会看到各种的函数调用,或者通过逆向的手段,单独的使用这个函数,那么此时,我们就需要认识一下怎么识别函数了.&lt;/p&gt;
&lt;h2&gt;一丶识别__cdecl 函数(俗称C Call),函数参数,函数返回值&lt;/h2&gt;
&lt;p&gt;首先写一个C Call的函数&lt;/p&gt;
&lt;h3&gt;1.返回值 int类型, 参数int 类型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;高级代码:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; __cdecl MyAdd(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyAdd(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;main函数调用我们的自己写的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Debug下的汇编代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127212553847-933960501.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Debug版本下的调用处,我们会看到这种代码,没有流水线优化,没有任何优化&lt;/p&gt;
&lt;p&gt;看到了,两个push,紧接着一个Call,然后平栈在外面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;识别参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　有经验的可能会说两个push 就是两个参数,其实不然,我们要进入函数内部,看内部的代码用了几个参数,要通过这个来识别.&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127212949690-493682503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　有两处使用,所以是两个参数. 而且直接给eax反回了,此时我们就可以在main函数位置,调用此函数的位置往上数几个push了,这些push才是属于自己这个函数的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;识别参数类型:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　参数类型还是很好识别了,使用参数的地方用的直接是4个字节的寄存器,那么我们可以暂定为int类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;识别调用约定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果在函数外面平栈,那么就是C调用约定,从识别参数来看,函数内部的 retn并没有平栈.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 识别返回值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　从上面的识别参数我们看到,eax重新写入了,那么返回值就是int类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Release版本下的汇编&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127213623565-1799236899.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Release版本和Debug版本差不多一样,优化了少许代码,但是核心代码不变&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.识别参数,看其函数内部使用了几个参数,然后在函数调用的地方往上数几个push这些是属于自己函数的.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.识别参数类型,看其参数是怎么使用.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.识别调用约定,看其函数内部是否平栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4.识别返回值类型,看其eax是否是被重写,如果被重写,则是返回值是int类型&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.返回值 __int64 C调用约定,参数是浮点和double的情况下&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;高级代码:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
__int64 __cdecl MyAdd(&lt;span&gt;float&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; b)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyAdd(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Debug下的汇编代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.main 函数调用处&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127220136222-1605104712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.函数内部&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127220229206-925764984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.函数内部调用的__ftol&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127220318362-85605761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;讲解:&lt;/p&gt;
&lt;p&gt;　　1.识别C约定和上面一样,外面平栈&lt;/p&gt;
&lt;p&gt;　　2.识别参数,看其我们的的函数调用处,发现有三个push,如果不知道,则会陷入坑,直接认为是三个参数.,但是跟随到函数内部,我们发现只有两个参数,而第二个参数是double,所以在32位下要push 两个四字节,其中高位是0,低位是常量(4)的浮点编码.&lt;/p&gt;
&lt;p&gt;　　3.识别参数类型,在MyAdd内部,发现了两处使用参数的地方,用的指令分别是 fld 和fadd指令,这些都是浮点相关的.&lt;/p&gt;
&lt;p&gt;识别技巧.&lt;/p&gt;
&lt;p&gt;　　fld指令 将实数压入浮点协处理器,那么此时我们看下汇编指令,(使用IDA的K命令,可以不是符号显示,也就是下方贴出的汇编指令)&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127221034347-389251612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;FLD 第一个是一个Dword 那么可以确定为是一个32位浮点&lt;/p&gt;
&lt;p&gt;Fadd指令,使用Fadd指令的时候,发现是第二个QWORD,难么可以确定是一个double类型的浮点.功能的还原和汇编逆向前10讲一样,里面都是各种流程和指令&lt;/p&gt;
&lt;p&gt;　　4.识别返回值,在识别返回值的时候,我们发现调用了一个_ftol函数,看到这个函数可以确定返回的是一个__int64,当然我们进入函数内部看到了&lt;/p&gt;
&lt;p&gt;下方使用eax 和edx了,而且直接反会了,那么我们知道,在32位系统下,返回一个64位数字,在汇编中的表现形式就是edx.eax的存储方式.&lt;/p&gt;
&lt;p&gt;Release版本下的汇编&lt;/p&gt;

&lt;p&gt;&lt;span&gt;熟悉总结的四句话,以不变应万变即可,因为类型都不一样.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二丶识别stdcall  函数参数,返回值,参数类型&lt;/h2&gt;
&lt;p&gt;stdcall比较简单.但是和fastcall还是有区别的.因为fastcall会有寄存器传参,所以把两个的区别搞明白就可以了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高级代码:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
__int64 __stdcall MyAdd(&lt;span&gt;float&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt; b,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a + b +&lt;span&gt; c;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyAdd(&lt;/span&gt;&lt;span&gt;3.0f&lt;/span&gt;,&lt;span&gt;4.0f&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接一次性的把各种参数类型,以及返回值设置不一样.观看汇编&lt;/p&gt;
&lt;p&gt;Debug下的汇编代码&lt;/p&gt;
&lt;p&gt;1.函数调用处&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127224556331-1366340754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.MyAdd函数内部&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127224656909-436566598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.识别函数的参数,发现了push 4个进去,但是不要被骗了,在MyAdd内部 分别得出了使用三个参数的位置,所以得出第一个参数为  float 第二个参数类型是 double,第三个参数 是int,又因为其中有一个double参数,所以在调用外面可以看到4个push,因为double是8个字节&lt;/p&gt;
&lt;p&gt;2.识别参数个数,stdcall最好的就是它是内部平栈,也就是retn 10h,当然也可以通过这个来判断函数参数的个数&lt;/p&gt;
&lt;p&gt;3.识别函数返回值类型&lt;/p&gt;
&lt;p&gt;　　函数返回值类型,在MyAdd中调用了_ftol函数,其内部则是返回__int64,返回值是 edx.eax&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Release下的汇编&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127225206081-2144183790.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和Debug汇编一样,有少许优化.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.识别参数类型: 识别参数类型可以通过函数内部使用参数的时候用的指令,比如第一个 float,使用的是fld指令,fld系列指令就是操作浮点的,而又因为它是一个dword,所以判断是float,第三个参数是一个int,使用的是fixxx指令,fixxx指令就是操作的整数,因为它也是一个dword所以判断是int(当然可以看函数参数使用过程中其指令使用的时候表明这个参数是什么类型的)&lt;/p&gt;
&lt;p&gt;　　2.识别参数个数, 识别参数个数在stdcall中有两种方式,第一种,直接看内部指令使用参数的地方,第二种,看平栈的时候平了多少.比如上面的例子, retn 10h(16),也就是4个参数的大小,但因为double是8字节,所以判断是三个参数&lt;/p&gt;
&lt;p&gt;　　3.识别返回值,识别返回值 如果是int指令,那么返回值则放在eax中,如果是__int64指令,返回值则是在 edx.eax中,如果是浮点返回值,返回值则是在浮点协处理器中.&lt;/p&gt;
&lt;p&gt;　　4.识别调用约定,函数内部平栈,如果没有寄存器传参则是stdcall,如果有寄存器传参,则是fastcall&lt;/p&gt;
&lt;h2&gt;三丶识别 fastcall 函数,参数个数,参数类型,返回值&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;高级代码:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;double&lt;/span&gt; __fastcall MyAdd(&lt;span&gt;float&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt; b,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a + b +&lt;span&gt; c;
}

&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; __fastcall MySub(__int64 a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a -&lt;span&gt; b;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyAdd(&lt;/span&gt;&lt;span&gt;3.0f&lt;/span&gt;,&lt;span&gt;4.0f&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
    MySub(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Debug下的汇编代码&lt;/p&gt;
&lt;p&gt;　　1.main函数调用的时候的汇编代码&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127230538206-265990787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. MyAdd函数内部&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127230637722-34557433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3.MySub函数内部&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127230747019-2093238659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.识别调用约定, 我们看MyAdd内部,还是MySub内部,里面都是用了外面传入的ecx,并且没有保存.那么fastcall就是ecx传参了.平栈和stdcall一样,函数内部平栈&lt;/p&gt;
&lt;p&gt;　　　　2.识别函数的个数,识别函数的个数也有两种方法,第一种,看retn的时候,然后加上寄存器, 我们看myadd内部,retn 0ch,平了3个参数,但外面更改了ecx,里面使用了ecx,那么就是4个参数,但因为其中一个参数类型是double,所以还是三个参数.&lt;/p&gt;
&lt;p&gt;　　　　3.识别参数类型,看指令来判断是什么类型,fld指令是浮点,fixxx指令则是使用的int,如果看edx.eax并且符号扩展了,则是__int64&lt;/p&gt;
&lt;p&gt;　　　　4.上面返回值类型么有更改为doubLe和float,可以看出,在main函数下面是用浮点的出栈指令 fstp指令,从浮点协处理器出栈,浮点协处理器是64位的,所以返回double&lt;/p&gt;
&lt;p&gt;总结:&lt;/p&gt;
&lt;p&gt;　　1.调用约定,如果是c call那么外面平栈,stdcall函数内部平栈,fastcall函数内部平栈,但是会使用外面的寄存器.&lt;/p&gt;
&lt;p&gt;　　2.识别参数个数,类型,同上&lt;/p&gt;
&lt;p&gt;　　3.识别返回值,同上.&lt;/p&gt;

</description>
<pubDate>Mon, 27 Nov 2017 15:16:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7906670.html</dc:identifier>
</item>
<item>
<title>分布式一致性的想法 - tylercao</title>
<link>http://www.cnblogs.com/tylercao/p/7906603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylercao/p/7906603.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近一直在思考，工作这么多年下遇到的分布式系统的一下问题，以及针对这些问题提供的解决方案。&lt;br/&gt;借这个机会，顺便梳理清楚这块知识，希望同大家一起探讨下&lt;/p&gt;
&lt;h2 id=&quot;常见一致性问题&quot;&gt;常见一致性问题&lt;/h2&gt;
&lt;h3 id=&quot;下订单减库存&quot;&gt;下订单减库存&lt;/h3&gt;
&lt;p&gt;在我们做的电商系统中，会有这样的一个场景：用户下单购买某个商品，然后进行扣减商品库存的场景。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果先下订单，然后扣减库存，会导致&lt;strong&gt;超卖&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果下订单失败，扣减库存成功，那么会导致&lt;strong&gt;少卖&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两种情况的发生都会导致我们系统出现一致性的问题，严重的话，需要对用户做出一定的经济补偿。&lt;/p&gt;
&lt;h3 id=&quot;调用超时&quot;&gt;调用超时&lt;/h3&gt;
&lt;p&gt;业务开发的过程中，肯定会有我们维护的服务调用其他团队的服务，即使在机房内部进行网络调用，也或多或少的存在系统调用超时的现象，如果出现这样的现象，我们该怎么解决呢？&lt;/p&gt;
&lt;h2 id=&quot;解决一致性问题的思路&quot;&gt;解决一致性问题的思路&lt;/h2&gt;
&lt;h3 id=&quot;酸碱中和&quot;&gt;酸碱中和&lt;/h3&gt;
&lt;p&gt;ACID ： 酸， BASE：碱，其实就是酸碱中和的原理&lt;/p&gt;
&lt;h4 id=&quot;acid&quot;&gt;1. ACID&lt;/h4&gt;
&lt;p&gt;ACID，是指数据库管理系统在写入数据过程中，为保证事务是正确可靠性。&lt;br/&gt;所必须具备的四个特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A: Atomicity 原子性 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节&lt;/li&gt;
&lt;li&gt;C: Consistency 一致性 事务开始之前和事务结束以后，数据库的完整性没有被破坏&lt;/li&gt;
&lt;li&gt;I: Isolation 隔离性 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）&lt;/li&gt;
&lt;li&gt;D: Durability 持久性 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;像 MySQL、Oracle 这样关系型数据库是支持 ACID 特性的强一致性要求的。本身强一致性就不允许出现不一致性的问题，底层都是通过 MVCC 来控制实现的&lt;/p&gt;
&lt;p&gt;刚刚上面提到的下订单减库存就可以关系型数据库的强一致性来解决。将订单表与库存表放在一个数据库 Instance 中，通过数据库 ACID 的特性来解决少卖或者超卖的问题。&lt;/p&gt;
&lt;p&gt;但是如果遇到数据量比较大的情况怎么办？订单表有多张，我们该怎么解决呢？&lt;/p&gt;
&lt;p&gt;其实，即使遇到订单表进行拆分，我们可以仍然采用数据库 ACID 的特性来解决。怎么弄？我们可以将订单表的拆表维度与库存表的拆分维度控制在一个数据分片中，但是具体怎么拆分呢？需要各位根据自己的业务规则来划分开来&lt;/p&gt;
&lt;h4 id=&quot;base&quot;&gt;2. BASE&lt;/h4&gt;
&lt;p&gt;BASE 思想解决了 CAP 提出的分布式一致性与可用性不能同时兼顾的问题。BASE 思想与 ACID 思想截然不同，它其实是满足 CAP 理论，通过牺牲强一致性来换取可用性。&lt;br/&gt;BASE 理论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BA：Basically Available，基本可用性&lt;/li&gt;
&lt;li&gt;S: Soft State 软状态 接受状态在一段时间内部同步&lt;/li&gt;
&lt;li&gt;E：Eventually Consistent 最终一致性 在一定的时间窗口中，最终数据达成一致即可&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;软状态是实现 BASE 的方法，基本可用域最终一致性是必须到达的目标。以 BASE 的思想由于不保证强一致性，所有接受系统在一定时间内数据存在不一致，不过在处理请求的过程中，需要记录知道每次请求的状态，以后出现问题的时候，回滚到中间任何临时状态，达到最终一致性&lt;/p&gt;
&lt;h4 id=&quot;cap&quot;&gt;3. CAP&lt;/h4&gt;
&lt;p&gt;当我们服务发展越来越多，是不可避免就会需要将服务进行拆分。一旦服务进行拆分后，它就不在是一个单机的系统，而是通俗意义上的分布式系统。说到分布式系统，我们一定要说下最为经典的帽子理论。如果我都没有听说过帽子理论，我出门都不好意思打招呼。&lt;br/&gt;分布式系统 CAP 理论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;C: Consistence 一致性 所有节点访问同一份最新的数据副本&lt;/li&gt;
&lt;li&gt;A: Availability 可用性 每次请求都能在有限的时间内获取到响应——但是不保证获取的数据为最新数据&lt;/li&gt;
&lt;li&gt;P: Network partitioning 分区容错性 尽管网络上有部分消息丢失，但仍然可以继续工作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CAP 原理证明：分布式系统只能满足三项中的两项而不可能满足全部三项。理解 CAP 理论的最简单方式就是想象两个节点处在 2 个机房中。允许至少一个节点更新状态会导致数据不一致，即丧失了 C 性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了 A 性质。除非两个节点可以互相通信，才能既保证C 又保证 A，这又会导致丧失P性质。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本次文章介绍 ACID、CAP 和 BASE 思想。在传统数据库领域中采用 ACID 理论，追求强一致性。但是在大型分布式系统中，采用 BASE 的设计思想，通过牺牲强一致性来获取高可用性及最终的一致性。两种设计理念截然不同，大家需要根据自己的业务场景，来决定到底哪用方式。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;分布式服务架构原理、设计与实战&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 27 Nov 2017 14:58:00 +0000</pubDate>
<dc:creator>tylercao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tylercao/p/7906603.html</dc:identifier>
</item>
<item>
<title>webpack中tree-shaking技术介绍 - Young Dreamer</title>
<link>http://www.cnblogs.com/wmhuang/p/7905972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmhuang/p/7905972.html</guid>
<description>&lt;p&gt;之前介绍过webpack3的新特性，里面提到webpack2支持了ES6的import和export，不需要将ES6的模块先转成CommonJS模块，然后再进行打包处理。正基于此，webpack2引入了tree-shaking技术，能够在模块的层面上做到打包后的代码只包含被引用并被执行的模块，而不被引用或不被执行的模块被删除掉，以起到减包的效果。&lt;/p&gt;
&lt;h2&gt;webpack的tree-shaking案例&lt;/h2&gt;
&lt;p&gt;下面结合实际代码来解释webpack2是如何实现tree-shaking的，示例代码可到&lt;a href=&quot;https://github.com/huangwenming/learning-notes/tree/master/webpack-tree-shaking&quot; target=&quot;_blank&quot;&gt;github进行下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;示例代码结构如图：src中index.js为入口文件，module.js是测试的模块文件，dist中是产出的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/605230/201711/605230-20171127195301847-2060238992.png&quot; alt=&quot;&quot; width=&quot;286&quot; height=&quot;275&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据webpack官网的提示，webpack支持tree-shaking，需要修改配置文件，指定babel处理js文件时不要将ES6模块转成CommonJS模块，具体做法就是：&lt;/p&gt;
&lt;p&gt;在.babelrc设置babel-preset-es2015的modules为fasle，表示不对ES6模块进行处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// .babelrc文件
{
  &quot;presets&quot;: [
    &lt;strong&gt;[&quot;es2015&quot;, { &quot;modules&quot;: false }]&lt;/strong&gt; 
  ],
  &quot;comments&quot;: false
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在webpack.config.js中设置babel-preset-es2015的modules为fasle，表示不对ES6模块进行处理。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
// webpack.config.js
...
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                loader: 'babel-loader',
                options: {
                    presets: [
                        &lt;strong&gt;[&quot;es2015&quot;, { &quot;modules&quot;: false }]&lt;/strong&gt;
                    ]
                }
            }
        ]
...　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在module.js文件中创建三个模块sayHello，sayBye，sayHi，并在index.js引用sayHello，sayHi；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// module.js
export const sayHello = name =&amp;gt; `Hello ${name}!`;
export const sayBye = name =&amp;gt; `Bye ${name}!`;
export const sayHi = name =&amp;gt; `Hi ${name}!`;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// index.js
import { sayHello } from './module';
import { sayHi } from './module';
const element = document.createElement('h1');
element.innerHTML = sayHello('World') + sayHi('my friend');
document.body.appendChild(element);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后在当前目录执行 &lt;span&gt;webpack &lt;/span&gt;命令后，产出bundle.js的代码如下&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
&lt;strong&gt;/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, &quot;a&quot;, function() { return sayHello; });
/* unused harmony export sayBye */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, &quot;b&quot;, function() { return sayHi; });&lt;/strong&gt;


var sayHello = function sayHello(name) {
  return &quot;Hello &quot; + name + &quot;!&quot;;
};
var sayBye = function sayBye(name) {
  return &quot;Bye &quot; + name + &quot;!&quot;;
};

var sayHi = function sayHi(name) {
  return &quot;Hi &quot; + name + &quot;!&quot;;
};

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
&lt;strong&gt;Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__module__ = __webpack_require__(0);&lt;/strong&gt;



var element = document.createElement('h1');
element.innerHTML = Object(&lt;strong&gt;__WEBPACK_IMPORTED_MODULE_0__module__[&quot;a&quot; /* sayHello */]&lt;/strong&gt;)('World') + Object(&lt;strong&gt;__WEBPACK_IMPORTED_MODULE_0__module__[&quot;b&quot; /* sayHi */]&lt;/strong&gt;)(' to meet you');
document.body.appendChild(element);

/***/ })
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上面可以知道，sayBye模块被打上了&lt;span&gt;unused harmony export&lt;/span&gt;&lt;span&gt;标签，sayHello和sayHi被设置为__webpack_exports__的属性，在入口文件中通过读取__webpack_exports__的属性取出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bundle.js文件虽然对多余的模块进行了标记，但是并没有删除，这是因为webpack还没有执行压缩混淆操作，可以通过&lt;span&gt;webpack -p&lt;span&gt;命令对产出进行压缩处理，这时候会把打了&lt;span&gt;unused harmony export&lt;/span&gt; &lt;span&gt;标签的模块删除掉。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;webpack的tree-shaking的局限性&lt;/h2&gt;
&lt;p&gt;（1）只能是静态声明和引用的ES6模块，不能是动态引入和声明的；&lt;/p&gt;
&lt;p&gt;在打包阶段对冗余代码进行删除，就需要webpack需要在打包阶段确定模块文件的内部结构，而ES模块的引用和输出必须出现在文件结构的第一级（'import' and 'export' may only appear at the top level），否则会报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// webpack编译时会报错
if (condition) {
  import module1 from './module1';
} else {
  import module2 from './module2';
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而CommonJS模块支持动态结构的，所以不能对CommonJS模块进行tree-shaking处理。&lt;/p&gt;
&lt;p&gt;（2）只能处理模块级别，不能处理函数级别的冗余；&lt;/p&gt;
&lt;p&gt; 因为webpack的tree-shaking是基于模块间的依赖关系，所以并不能对模块内部自身的无用代码进行删除。&lt;/p&gt;
&lt;p&gt;（3）只能处理JS相关冗余代码，不能处理CSS冗余代码。&lt;/p&gt;
&lt;p&gt;目前webpack只对JS文件的依赖进行了处理，CSS的冗余并没有给出很好的工具。最近听了一个讲座，提到了&lt;a href=&quot;https://github.com/lin-xi/webpack-css-treeshaking-plugin&quot; target=&quot;_blank&quot;&gt;webpack-css-treeshaking-plugin&lt;/a&gt;，该插件基于AST对CSS冗余代码进行了很好的处理。&lt;/p&gt;

</description>
<pubDate>Mon, 27 Nov 2017 14:35:00 +0000</pubDate>
<dc:creator>Young Dreamer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wmhuang/p/7905972.html</dc:identifier>
</item>
<item>
<title>Redis 持久化之RDB和AOF - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/7906481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/7906481.html</guid>
<description>&lt;p&gt;Redis 有两种持久化方案，RDB （Redis DataBase）和 AOF （Append Only File）。如果你想快速了解和使用RDB和AOF，可以直接跳到文章底部看总结。本章节通过配置文件，触发快照的方式，恢复数据的操作，命令操作演示，优缺点来学习 Redis 的重点知识&lt;strong&gt;持久化&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;rdb-详解&quot;&gt;RDB 详解&lt;/h2&gt;
&lt;p&gt;RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。&lt;/p&gt;
&lt;h3 id=&quot;从配置文件了解rdb&quot;&gt;从配置文件了解RDB&lt;/h3&gt;
&lt;p&gt;打开 redis.conf 文件，找到 SNAPSHOTTING 对应内容&lt;br/&gt;1 RDB核心规则配置（重点）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;
# save &quot;&quot;
save 900 1
save 300 10
save 60 10000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解说：save &amp;lt;指定时间间隔&amp;gt; &amp;lt;执行指定次数更新操作&amp;gt;，满足条件就将内存中的数据同步到硬盘中。官方出厂配置默认是 900秒内有1个更改，300秒内有10个更改以及60秒内有10000个更改，则将内存中的数据快照写入磁盘。&lt;br/&gt;若不想用RDB方案，可以把 save &quot;&quot; 的注释打开，下面三个注释。&lt;/p&gt;
&lt;p&gt;2 指定本地数据库文件名，一般采用默认的 dump.rdb&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dbfilename dump.rdb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3 指定本地数据库存放目录，一般也用默认配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir ./&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4 默认开启数据压缩&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rdbcompression yes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解说：配置存储至本地数据库时是否压缩数据，默认为yes。Redis采用LZF压缩方式，但占用了一点CPU的时间。若关闭该选项，但会导致数据库文件变的巨大。建议开启。&lt;/p&gt;
&lt;h3 id=&quot;触发rdb快照&quot;&gt;触发RDB快照&lt;/h3&gt;
&lt;p&gt;1 在指定的时间间隔内，执行指定次数的写操作&lt;br/&gt;2 执行save（阻塞， 只管保存快照，其他的等待） 或者是bgsave （异步）命令&lt;br/&gt;3 执行flushall 命令，清空数据库所有数据，意义不大。&lt;br/&gt;4 执行shutdown 命令，保证服务器正常关闭且不丢失任何数据，意义...也不大。&lt;/p&gt;
&lt;h3 id=&quot;通过rdb文件恢复数据&quot;&gt;通过RDB文件恢复数据&lt;/h3&gt;
&lt;p&gt;将dump.rdb 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可。在实际开发中，一般会考虑到物理机硬盘损坏情况，选择备份dump.rdb 。可以从下面的操作演示中可以体会到。&lt;/p&gt;
&lt;h3 id=&quot;rdb-的优缺点&quot;&gt;RDB 的优缺点&lt;/h3&gt;
&lt;p&gt;优点：&lt;br/&gt;1 适合大规模的数据恢复。&lt;br/&gt;2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。&lt;/p&gt;
&lt;p&gt;缺点：&lt;br/&gt;1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。&lt;br/&gt;2 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。&lt;br/&gt;所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。&lt;/p&gt;
&lt;h3 id=&quot;操作演示&quot;&gt;操作演示&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;[root@itdragon bin]# vim redis.conf
save 900 1
save 120 5
save 60 10000
[root@itdragon bin]# ./redis-server redis.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; keys *
(empty list or set)
127.0.0.1:6379&amp;gt; set key1 value1
OK
127.0.0.1:6379&amp;gt; set key2 value2
OK
127.0.0.1:6379&amp;gt; set key3 value3
OK
127.0.0.1:6379&amp;gt; set key4 value4
OK
127.0.0.1:6379&amp;gt; set key5 value5
OK
127.0.0.1:6379&amp;gt; set key6 value6
OK
127.0.0.1:6379&amp;gt; SHUTDOWN
not connected&amp;gt; QUIT
[root@itdragon bin]# cp dump.rdb dump_bk.rdb
[root@itdragon bin]# ./redis-server redis.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; FLUSHALL 
OK
127.0.0.1:6379&amp;gt; keys *
(empty list or set)
127.0.0.1:6379&amp;gt; SHUTDOWN
not connected&amp;gt; QUIT
[root@itdragon bin]# cp dump_bk.rdb  dump.rdb
cp: overwrite `dump.rdb'? y
[root@itdragon bin]# ./redis-server redis.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; keys *
1) &quot;key5&quot;
2) &quot;key1&quot;
3) &quot;key3&quot;
4) &quot;key4&quot;
5) &quot;key6&quot;
6) &quot;key2&quot;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一步：vim 修改持久化配置时间，120秒内修改5次则持久化一次。&lt;br/&gt;第二步：重启服务使配置生效。&lt;br/&gt;第三步：分别set 5个key，过两分钟后，在bin的当前目录下会自动生产一个dump.rdb文件。（set key6 是为了验证shutdown有触发RDB快照的作用）&lt;br/&gt;第四步：将当前的dump.rdb 备份一份（模拟线上工作）。&lt;br/&gt;第五步：执行FLUSHALL命令清空数据库数据（模拟数据丢失）。&lt;br/&gt;第六步：重启Redis服务，恢复数据.....咦？？？？( ′◔ ‸◔`)。数据是空的？？？？这是因为FLUSHALL也有触发RDB快照的功能。&lt;br/&gt;第七步：将备份的 dump_bk.rdb 替换 dump.rdb 然后重新Redis。&lt;/p&gt;
&lt;p&gt;注意点：SHUTDOWN 和 FLUSHALL 命令都会触发RDB快照，这是一个坑，请大家注意。&lt;/p&gt;
&lt;p&gt;其他命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;keys * 匹配数据库中所有 key&lt;/li&gt;
&lt;li&gt;save 阻塞触发RDB快照，使其备份数据&lt;/li&gt;
&lt;li&gt;FLUSHALL 清空整个 Redis 服务器的数据(几乎不用)&lt;/li&gt;
&lt;li&gt;SHUTDOWN 关机走人（很少用）&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;aof-详解&quot;&gt;AOF 详解&lt;/h2&gt;
&lt;p&gt;AOF ：Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个&lt;strong&gt;写操作&lt;/strong&gt;，并&lt;strong&gt;追加&lt;/strong&gt;到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。&lt;/p&gt;
&lt;h3 id=&quot;从配置文件了解aof&quot;&gt;从配置文件了解AOF&lt;/h3&gt;
&lt;p&gt;打开 redis.conf 文件，找到 APPEND ONLY MODE 对应内容&lt;br/&gt;1 redis 默认关闭，开启需要手动把no改为yes&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;appendonly yes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2 指定本地数据库文件名，默认值为 appendonly.aof&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;appendfilename &quot;appendonly.aof&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3 指定更新日志条件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# appendfsync always
appendfsync everysec
# appendfsync no&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解说：&lt;br/&gt;always：同步持久化，每次发生数据变化会立刻写入到磁盘中。性能较差当数据完整性比较好（慢，安全）&lt;br/&gt;everysec：出厂默认推荐，每秒异步记录一次（默认值）&lt;br/&gt;no：不同步&lt;/p&gt;
&lt;p&gt;4 配置重写触发机制&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解说：当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。一般都设置为3G，64M太小了。&lt;/p&gt;
&lt;h3 id=&quot;触发aof快照&quot;&gt;触发AOF快照&lt;/h3&gt;
&lt;p&gt;根据配置文件触发，可以是每次执行触发，可以是每秒触发，可以不同步。&lt;/p&gt;
&lt;h3 id=&quot;根据aof文件恢复数据&quot;&gt;根据AOF文件恢复数据&lt;/h3&gt;
&lt;p&gt;正常情况下，将appendonly.aof 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可。但在实际开发中，可能因为某些原因导致appendonly.aof 文件格式异常，从而导致数据还原失败，可以通过命令redis-check-aof --fix appendonly.aof 进行修复 。从下面的操作演示中体会。&lt;/p&gt;
&lt;h3 id=&quot;aof的重写机制&quot;&gt;AOF的重写机制&lt;/h3&gt;
&lt;p&gt;前面也说到了，AOF的工作原理是将写操作追加到文件中，文件的冗余内容会越来越多。所以聪明的 Redis 新增了重写机制。当AOF文件的大小超过所设定的阈值时，Redis就会对AOF文件的内容压缩。&lt;/p&gt;
&lt;p&gt;重写的原理：Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中。并没有读取旧文件（你都那么大了，我还去读你？？？ o(ﾟДﾟ)っ傻啊！）。最后替换旧的aof文件。&lt;/p&gt;
&lt;p&gt;触发机制：当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。这里的“一倍”和“64M” 可以通过配置文件修改。&lt;/p&gt;
&lt;h3 id=&quot;aof-的优缺点&quot;&gt;AOF 的优缺点&lt;/h3&gt;
&lt;p&gt;优点：数据的完整性和一致性更高&lt;br/&gt;缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。&lt;/p&gt;
&lt;h3 id=&quot;操作演示-1&quot;&gt;操作演示&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[root@itdragon bin]# vim appendonly.aof
appendonly yes
[root@itdragon bin]# ./redis-server redis.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; keys *
(empty list or set)
127.0.0.1:6379&amp;gt; set keyAOf valueAof
OK
127.0.0.1:6379&amp;gt; FLUSHALL 
OK
127.0.0.1:6379&amp;gt; SHUTDOWN
not connected&amp;gt; QUIT
[root@itdragon bin]# ./redis-server redis.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; keys *
1) &quot;keyAOf&quot;
127.0.0.1:6379&amp;gt; SHUTDOWN
not connected&amp;gt; QUIT
[root@itdragon bin]# vim appendonly.aof
fjewofjwojfoewifjowejfwf
[root@itdragon bin]# ./redis-server redis.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
Could not connect to Redis at 127.0.0.1:6379: Connection refused
not connected&amp;gt; QUIT
[root@itdragon bin]# redis-check-aof --fix appendonly.aof 
'x              3e: Expected prefix '*', got: '
AOF analyzed: size=92, ok_up_to=62, diff=30
This will shrink the AOF from 92 bytes, with 30 bytes, to 62 bytes
Continue? [y/N]: y
Successfully truncated AOF
[root@itdragon bin]# ./redis-server redis.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; keys *
1) &quot;keyAOf&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一步：修改配置文件，开启AOF持久化配置。&lt;br/&gt;第二步：重启Redis服务，并进入Redis 自带的客户端中。&lt;br/&gt;第三步：保存值，然后模拟数据丢失，关闭Redis服务。&lt;br/&gt;第四步：重启服务，发现数据恢复了。（额外提一点：有教程显示FLUSHALL 命令会被写入AOF文件中，导致数据恢复失败。我安装的是redis-4.0.2没有遇到这个问题）。&lt;br/&gt;第五步：修改appendonly.aof，模拟文件异常情况。&lt;br/&gt;第六步：重启 Redis 服务失败。这同时也说明了，RDB和AOF可以同时存在，且优先加载AOF文件。&lt;br/&gt;第七步：校验appendonly.aof 文件。重启Redis 服务后正常。&lt;/p&gt;
&lt;p&gt;补充点：aof 的校验是通过 redis-check-aof 文件，那么rdb 的校验是不是可以通过 redis-check-rdb 文件呢？？？&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Redis 默认开启RDB持久化方式，在指定的时间间隔内，执行指定次数的写操作，则将内存中的数据写入到磁盘中。&lt;/li&gt;
&lt;li&gt;RDB 持久化适合大规模的数据恢复但它的数据一致性和完整性较差。&lt;/li&gt;
&lt;li&gt;Redis 需要手动开启AOF持久化方式，默认是每秒将写操作日志追加到AOF文件中。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;AOF 的数据完整性比RDB高，但记录内容多了，会影响数据恢复的效率。&lt;/li&gt;
&lt;li&gt;Redis 针对 AOF文件大的问题，提供重写的瘦身机制。&lt;/li&gt;
&lt;li&gt;若只打算用Redis 做缓存，可以关闭持久化。&lt;/li&gt;
&lt;li&gt;若打算使用Redis 的持久化。建议RDB和AOF都开启。其实RDB更适合做数据的备份，留一后手。AOF出问题了，还有RDB。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;到这里Redis 的持久化就介绍完了，有什么不对的地方可以指出。&lt;br/&gt;Redis 快速入门：&lt;a href=&quot;http://www.cnblogs.com/itdragon/p/7897131.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/itdragon/p/7897131.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Nov 2017 14:22:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/7906481.html</dc:identifier>
</item>
</channel>
</rss>