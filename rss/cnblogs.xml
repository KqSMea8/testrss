<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>初学者没有搞明白的GOROOT,GOPATH,GOBIN,project目录 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/7906722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/7906722.html</guid>
<description>&lt;p&gt;我们接下来一个一个来看关于Go语言中的三个目录的详细解释&lt;br/&gt;先通过go env查看go的环境变量(我这里是mac的环境，所以可能和你的不同)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
localhost:~ zhaofan$ go &lt;span&gt;env&lt;/span&gt;&lt;span&gt;
GOARCH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOBIN&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOEXE&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOHOSTARCH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOHOSTOS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;darwin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOOS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;darwin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOPATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Users/zhaofan/go_project&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GORACE&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOROOT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/Cellar/go/1.9.2/libexec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOTOOLDIR&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/Cellar/go/1.9.2/libexec/pkg/tool/darwin_amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GCCGO&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gccgo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CC&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOGCCFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/b6/mc1c40c91cld67ps963_r16h0000gn/T/go-build539393745=/tmp/go-build -gno-record-gcc-switches -fno-common&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CXX&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clang++&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_ENABLED&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_CFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-g -O2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_CPPFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
CGO_CXXFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-g -O2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_FFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-g -O2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_LDFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-g -O2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
PKG_CONFIG&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pkg-config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
localhost:&lt;/span&gt;~ zhaofan$
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;GOROOT&lt;/h2&gt;
&lt;p&gt;其实就是golang 的安装路径&lt;br/&gt;当你安装好golang之后其实这个就已经有了&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;GOPATH&lt;/h2&gt;
&lt;p&gt;go命令依赖的一个重要环境变量：$GOPATH&lt;/p&gt;
&lt;p&gt;其实可以把这个目录理解为工作目录，我个人定义的目录是：&lt;br/&gt;GOPATH=&quot;/Users/zhaofan/go_project&quot;&lt;br/&gt;当然这个目录是需要添加到环境变量中的&lt;/p&gt;
&lt;p&gt;go_project // (go_project为GOPATH目录)&lt;br/&gt;-- bin // golang编译可执行文件存放路径&lt;br/&gt;-- pkg // golang编译包时，生成的.a文件存放路径&lt;br/&gt;-- src // 源码路径。按照golang默认约定，go run，go install等命令的当前工作路径（即在此路径下执行上述命令）。&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;GOBIN&lt;/h2&gt;
&lt;p&gt;首先先看一下我的目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201711/997599-20171127233215019-1751642932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们通常是在go_project目录下执行go build,例如:&lt;br/&gt;/Users/zhaofan/go_project/src/go_dev/01/hello/hello.go&lt;br/&gt;我们现在要编译hello.go文件，我只需要切换到&lt;br/&gt;/Users/zhaofan/go_project目录中，然后执行：&lt;br/&gt;go build go_dev/01/hello&lt;br/&gt;golang 会自动去src下找hello目录，因为我的hello.go中代码的开通导入了packag main包，所以可以编译成可执行文件，但是这样默认在当前目录下生成可执行文件,虽然可以指定目录，但是还是感觉不是非常方便&lt;/p&gt;
&lt;p&gt;所以还有两个非常好用的命令：go get 和go install&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;go get&lt;/h3&gt;
&lt;p&gt;go get会做两件事：&lt;br/&gt;1. 从远程下载需要用到的包&lt;br/&gt;2. 执行go install&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;go install&lt;/h3&gt;
&lt;p&gt;go install 会生成可执行文件直接放到bin目录下，当然这是有前提的&lt;br/&gt;你编译的是可执行文件，如果是一个普通的包，会被编译生成到pkg目录下该文件是.a结尾&lt;/p&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;关于go的整体一个开发目录&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
go_project     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; go_project为GOPATH目录&lt;/span&gt;
  --&lt;span&gt; bin
     &lt;/span&gt;-- myApp1  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译生成&lt;/span&gt;
     -- myApp2  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译生成&lt;/span&gt;
     -- myApp3  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译生成&lt;/span&gt;
  --&lt;span&gt; pkg
  &lt;/span&gt;--&lt;span&gt; src
     &lt;/span&gt;-- myApp1     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; project1&lt;/span&gt;
        --&lt;span&gt; models
        &lt;/span&gt;--&lt;span&gt; controllers
        &lt;/span&gt;--&lt;span&gt; others
        &lt;/span&gt;--&lt;span&gt; main.go 
     &lt;/span&gt;-- myApp2     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; project2&lt;/span&gt;
        --&lt;span&gt; models
        &lt;/span&gt;--&lt;span&gt; controllers
        &lt;/span&gt;--&lt;span&gt; others
        &lt;/span&gt;--&lt;span&gt; main.go 
     &lt;/span&gt;-- myApp3     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; project3&lt;/span&gt;
        --&lt;span&gt; models
        &lt;/span&gt;--&lt;span&gt; controllers
        &lt;/span&gt;--&lt;span&gt; others
        &lt;/span&gt;-- main.go 
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 27 Nov 2017 15:33:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/7906722.html</dc:identifier>
</item>
<item>
<title>逆向知识十一讲,识别函数的调用约定,函数参数,函数返回值. - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7906670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7906670.html</guid>
<description>&lt;p&gt;在反汇编中,我们常常的会看到各种的函数调用,或者通过逆向的手段,单独的使用这个函数,那么此时,我们就需要认识一下怎么识别函数了.&lt;/p&gt;
&lt;h2&gt;一丶识别__cdecl 函数(俗称C Call),函数参数,函数返回值&lt;/h2&gt;
&lt;p&gt;首先写一个C Call的函数&lt;/p&gt;
&lt;h3&gt;1.返回值 int类型, 参数int 类型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;高级代码:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; __cdecl MyAdd(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyAdd(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;main函数调用我们的自己写的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Debug下的汇编代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127212553847-933960501.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Debug版本下的调用处,我们会看到这种代码,没有流水线优化,没有任何优化&lt;/p&gt;
&lt;p&gt;看到了,两个push,紧接着一个Call,然后平栈在外面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;识别参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　有经验的可能会说两个push 就是两个参数,其实不然,我们要进入函数内部,看内部的代码用了几个参数,要通过这个来识别.&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127212949690-493682503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　有两处使用,所以是两个参数. 而且直接给eax反回了,此时我们就可以在main函数位置,调用此函数的位置往上数几个push了,这些push才是属于自己这个函数的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;识别参数类型:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　参数类型还是很好识别了,使用参数的地方用的直接是4个字节的寄存器,那么我们可以暂定为int类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;识别调用约定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果在函数外面平栈,那么就是C调用约定,从识别参数来看,函数内部的 retn并没有平栈.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 识别返回值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　从上面的识别参数我们看到,eax重新写入了,那么返回值就是int类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Release版本下的汇编&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127213623565-1799236899.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Release版本和Debug版本差不多一样,优化了少许代码,但是核心代码不变&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.识别参数,看其函数内部使用了几个参数,然后在函数调用的地方往上数几个push这些是属于自己函数的.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.识别参数类型,看其参数是怎么使用.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.识别调用约定,看其函数内部是否平栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4.识别返回值类型,看其eax是否是被重写,如果被重写,则是返回值是int类型&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.返回值 __int64 C调用约定,参数是浮点和double的情况下&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;高级代码:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
__int64 __cdecl MyAdd(&lt;span&gt;float&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; b)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyAdd(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Debug下的汇编代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.main 函数调用处&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127220136222-1605104712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.函数内部&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127220229206-925764984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.函数内部调用的__ftol&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127220318362-85605761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;讲解:&lt;/p&gt;
&lt;p&gt;　　1.识别C约定和上面一样,外面平栈&lt;/p&gt;
&lt;p&gt;　　2.识别参数,看其我们的的函数调用处,发现有三个push,如果不知道,则会陷入坑,直接认为是三个参数.,但是跟随到函数内部,我们发现只有两个参数,而第二个参数是double,所以在32位下要push 两个四字节,其中高位是0,低位是常量(4)的浮点编码.&lt;/p&gt;
&lt;p&gt;　　3.识别参数类型,在MyAdd内部,发现了两处使用参数的地方,用的指令分别是 fld 和fadd指令,这些都是浮点相关的.&lt;/p&gt;
&lt;p&gt;识别技巧.&lt;/p&gt;
&lt;p&gt;　　fld指令 将实数压入浮点协处理器,那么此时我们看下汇编指令,(使用IDA的K命令,可以不是符号显示,也就是下方贴出的汇编指令)&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127221034347-389251612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;FLD 第一个是一个Dword 那么可以确定为是一个32位浮点&lt;/p&gt;
&lt;p&gt;Fadd指令,使用Fadd指令的时候,发现是第二个QWORD,难么可以确定是一个double类型的浮点.功能的还原和汇编逆向前10讲一样,里面都是各种流程和指令&lt;/p&gt;
&lt;p&gt;　　4.识别返回值,在识别返回值的时候,我们发现调用了一个_ftol函数,看到这个函数可以确定返回的是一个__int64,当然我们进入函数内部看到了&lt;/p&gt;
&lt;p&gt;下方使用eax 和edx了,而且直接反会了,那么我们知道,在32位系统下,返回一个64位数字,在汇编中的表现形式就是edx.eax的存储方式.&lt;/p&gt;
&lt;p&gt;Release版本下的汇编&lt;/p&gt;

&lt;p&gt;&lt;span&gt;熟悉总结的四句话,以不变应万变即可,因为类型都不一样.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二丶识别stdcall  函数参数,返回值,参数类型&lt;/h2&gt;
&lt;p&gt;stdcall比较简单.但是和fastcall还是有区别的.因为fastcall会有寄存器传参,所以把两个的区别搞明白就可以了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高级代码:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
__int64 __stdcall MyAdd(&lt;span&gt;float&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt; b,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a + b +&lt;span&gt; c;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyAdd(&lt;/span&gt;&lt;span&gt;3.0f&lt;/span&gt;,&lt;span&gt;4.0f&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接一次性的把各种参数类型,以及返回值设置不一样.观看汇编&lt;/p&gt;
&lt;p&gt;Debug下的汇编代码&lt;/p&gt;
&lt;p&gt;1.函数调用处&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127224556331-1366340754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.MyAdd函数内部&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127224656909-436566598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.识别函数的参数,发现了push 4个进去,但是不要被骗了,在MyAdd内部 分别得出了使用三个参数的位置,所以得出第一个参数为  float 第二个参数类型是 double,第三个参数 是int,又因为其中有一个double参数,所以在调用外面可以看到4个push,因为double是8个字节&lt;/p&gt;
&lt;p&gt;2.识别参数个数,stdcall最好的就是它是内部平栈,也就是retn 10h,当然也可以通过这个来判断函数参数的个数&lt;/p&gt;
&lt;p&gt;3.识别函数返回值类型&lt;/p&gt;
&lt;p&gt;　　函数返回值类型,在MyAdd中调用了_ftol函数,其内部则是返回__int64,返回值是 edx.eax&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Release下的汇编&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127225206081-2144183790.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和Debug汇编一样,有少许优化.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.识别参数类型: 识别参数类型可以通过函数内部使用参数的时候用的指令,比如第一个 float,使用的是fld指令,fld系列指令就是操作浮点的,而又因为它是一个dword,所以判断是float,第三个参数是一个int,使用的是fixxx指令,fixxx指令就是操作的整数,因为它也是一个dword所以判断是int(当然可以看函数参数使用过程中其指令使用的时候表明这个参数是什么类型的)&lt;/p&gt;
&lt;p&gt;　　2.识别参数个数, 识别参数个数在stdcall中有两种方式,第一种,直接看内部指令使用参数的地方,第二种,看平栈的时候平了多少.比如上面的例子, retn 10h(16),也就是4个参数的大小,但因为double是8字节,所以判断是三个参数&lt;/p&gt;
&lt;p&gt;　　3.识别返回值,识别返回值 如果是int指令,那么返回值则放在eax中,如果是__int64指令,返回值则是在 edx.eax中,如果是浮点返回值,返回值则是在浮点协处理器中.&lt;/p&gt;
&lt;p&gt;　　4.识别调用约定,函数内部平栈,如果没有寄存器传参则是stdcall,如果有寄存器传参,则是fastcall&lt;/p&gt;
&lt;h2&gt;三丶识别 fastcall 函数,参数个数,参数类型,返回值&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;高级代码:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;double&lt;/span&gt; __fastcall MyAdd(&lt;span&gt;float&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt; b,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a + b +&lt;span&gt; c;
}

&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; __fastcall MySub(__int64 a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a -&lt;span&gt; b;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyAdd(&lt;/span&gt;&lt;span&gt;3.0f&lt;/span&gt;,&lt;span&gt;4.0f&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
    MySub(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Debug下的汇编代码&lt;/p&gt;
&lt;p&gt;　　1.main函数调用的时候的汇编代码&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127230538206-265990787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. MyAdd函数内部&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127230637722-34557433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3.MySub函数内部&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171127230747019-2093238659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.识别调用约定, 我们看MyAdd内部,还是MySub内部,里面都是用了外面传入的ecx,并且没有保存.那么fastcall就是ecx传参了.平栈和stdcall一样,函数内部平栈&lt;/p&gt;
&lt;p&gt;　　　　2.识别函数的个数,识别函数的个数也有两种方法,第一种,看retn的时候,然后加上寄存器, 我们看myadd内部,retn 0ch,平了3个参数,但外面更改了ecx,里面使用了ecx,那么就是4个参数,但因为其中一个参数类型是double,所以还是三个参数.&lt;/p&gt;
&lt;p&gt;　　　　3.识别参数类型,看指令来判断是什么类型,fld指令是浮点,fixxx指令则是使用的int,如果看edx.eax并且符号扩展了,则是__int64&lt;/p&gt;
&lt;p&gt;　　　　4.上面返回值类型么有更改为doubLe和float,可以看出,在main函数下面是用浮点的出栈指令 fstp指令,从浮点协处理器出栈,浮点协处理器是64位的,所以返回double&lt;/p&gt;
&lt;p&gt;总结:&lt;/p&gt;
&lt;p&gt;　　1.调用约定,如果是c call那么外面平栈,stdcall函数内部平栈,fastcall函数内部平栈,但是会使用外面的寄存器.&lt;/p&gt;
&lt;p&gt;　　2.识别参数个数,类型,同上&lt;/p&gt;
&lt;p&gt;　　3.识别返回值,同上.&lt;/p&gt;

</description>
<pubDate>Mon, 27 Nov 2017 15:16:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7906670.html</dc:identifier>
</item>
<item>
<title>分布式一致性的想法 - tylercao</title>
<link>http://www.cnblogs.com/tylercao/p/7906603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylercao/p/7906603.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近一直在思考，工作这么多年下遇到的分布式系统的一下问题，以及针对这些问题提供的解决方案。&lt;br/&gt;借这个机会，顺便梳理清楚这块知识，希望同大家一起探讨下&lt;/p&gt;
&lt;h2 id=&quot;常见一致性问题&quot;&gt;常见一致性问题&lt;/h2&gt;
&lt;h3 id=&quot;下订单减库存&quot;&gt;下订单减库存&lt;/h3&gt;
&lt;p&gt;在我们做的电商系统中，会有这样的一个场景：用户下单购买某个商品，然后进行扣减商品库存的场景。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果先下订单，然后扣减库存，会导致&lt;strong&gt;超卖&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果下订单失败，扣减库存成功，那么会导致&lt;strong&gt;少卖&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两种情况的发生都会导致我们系统出现一致性的问题，严重的话，需要对用户做出一定的经济补偿。&lt;/p&gt;
&lt;h3 id=&quot;调用超时&quot;&gt;调用超时&lt;/h3&gt;
&lt;p&gt;业务开发的过程中，肯定会有我们维护的服务调用其他团队的服务，即使在机房内部进行网络调用，也或多或少的存在系统调用超时的现象，如果出现这样的现象，我们该怎么解决呢？&lt;/p&gt;
&lt;h2 id=&quot;解决一致性问题的思路&quot;&gt;解决一致性问题的思路&lt;/h2&gt;
&lt;h3 id=&quot;酸碱中和&quot;&gt;酸碱中和&lt;/h3&gt;
&lt;p&gt;ACID ： 酸， BASE：碱，其实就是酸碱中和的原理&lt;/p&gt;
&lt;h4 id=&quot;acid&quot;&gt;1. ACID&lt;/h4&gt;
&lt;p&gt;ACID，是指数据库管理系统在写入数据过程中，为保证事务是正确可靠性。&lt;br/&gt;所必须具备的四个特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A: Atomicity 原子性 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节&lt;/li&gt;
&lt;li&gt;C: Consistency 一致性 事务开始之前和事务结束以后，数据库的完整性没有被破坏&lt;/li&gt;
&lt;li&gt;I: Isolation 隔离性 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）&lt;/li&gt;
&lt;li&gt;D: Durability 持久性 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;像 MySQL、Oracle 这样关系型数据库是支持 ACID 特性的强一致性要求的。本身强一致性就不允许出现不一致性的问题，底层都是通过 MVCC 来控制实现的&lt;/p&gt;
&lt;p&gt;刚刚上面提到的下订单减库存就可以关系型数据库的强一致性来解决。将订单表与库存表放在一个数据库 Instance 中，通过数据库 ACID 的特性来解决少卖或者超卖的问题。&lt;/p&gt;
&lt;p&gt;但是如果遇到数据量比较大的情况怎么办？订单表有多张，我们该怎么解决呢？&lt;/p&gt;
&lt;p&gt;其实，即使遇到订单表进行拆分，我们可以仍然采用数据库 ACID 的特性来解决。怎么弄？我们可以将订单表的拆表维度与库存表的拆分维度控制在一个数据分片中，但是具体怎么拆分呢？需要各位根据自己的业务规则来划分开来&lt;/p&gt;
&lt;h4 id=&quot;base&quot;&gt;2. BASE&lt;/h4&gt;
&lt;p&gt;BASE 思想解决了 CAP 提出的分布式一致性与可用性不能同时兼顾的问题。BASE 思想与 ACID 思想截然不同，它其实是满足 CAP 理论，通过牺牲强一致性来换取可用性。&lt;br/&gt;BASE 理论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BA：Basically Available，基本可用性&lt;/li&gt;
&lt;li&gt;S: Soft State 软状态 接受状态在一段时间内部同步&lt;/li&gt;
&lt;li&gt;E：Eventually Consistent 最终一致性 在一定的时间窗口中，最终数据达成一致即可&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;软状态是实现 BASE 的方法，基本可用域最终一致性是必须到达的目标。以 BASE 的思想由于不保证强一致性，所有接受系统在一定时间内数据存在不一致，不过在处理请求的过程中，需要记录知道每次请求的状态，以后出现问题的时候，回滚到中间任何临时状态，达到最终一致性&lt;/p&gt;
&lt;h4 id=&quot;cap&quot;&gt;3. CAP&lt;/h4&gt;
&lt;p&gt;当我们服务发展越来越多，是不可避免就会需要将服务进行拆分。一旦服务进行拆分后，它就不在是一个单机的系统，而是通俗意义上的分布式系统。说到分布式系统，我们一定要说下最为经典的帽子理论。如果我都没有听说过帽子理论，我出门都不好意思打招呼。&lt;br/&gt;分布式系统 CAP 理论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;C: Consistence 一致性 所有节点访问同一份最新的数据副本&lt;/li&gt;
&lt;li&gt;A: Availability 可用性 每次请求都能在有限的时间内获取到响应——但是不保证获取的数据为最新数据&lt;/li&gt;
&lt;li&gt;P: Network partitioning 分区容错性 尽管网络上有部分消息丢失，但仍然可以继续工作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CAP 原理证明：分布式系统只能满足三项中的两项而不可能满足全部三项。理解 CAP 理论的最简单方式就是想象两个节点处在 2 个机房中。允许至少一个节点更新状态会导致数据不一致，即丧失了 C 性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了 A 性质。除非两个节点可以互相通信，才能既保证C 又保证 A，这又会导致丧失P性质。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本次文章介绍 ACID、CAP 和 BASE 思想。在传统数据库领域中采用 ACID 理论，追求强一致性。但是在大型分布式系统中，采用 BASE 的设计思想，通过牺牲强一致性来获取高可用性及最终的一致性。两种设计理念截然不同，大家需要根据自己的业务场景，来决定到底哪用方式。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;分布式服务架构原理、设计与实战&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 27 Nov 2017 14:58:00 +0000</pubDate>
<dc:creator>tylercao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tylercao/p/7906603.html</dc:identifier>
</item>
<item>
<title>webpack中tree-shaking技术介绍 - Young Dreamer</title>
<link>http://www.cnblogs.com/wmhuang/p/7905972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmhuang/p/7905972.html</guid>
<description>&lt;p&gt;之前介绍过webpack3的新特性，里面提到webpack2支持了ES6的import和export，不需要将ES6的模块先转成CommonJS模块，然后再进行打包处理。正基于此，webpack2引入了tree-shaking技术，能够在模块的层面上做到打包后的代码只包含被引用并被执行的模块，而不被引用或不被执行的模块被删除掉，以起到减包的效果。&lt;/p&gt;
&lt;h2&gt;webpack的tree-shaking案例&lt;/h2&gt;
&lt;p&gt;下面结合实际代码来解释webpack2是如何实现tree-shaking的，示例代码可到&lt;a href=&quot;https://github.com/huangwenming/learning-notes/tree/master/webpack-tree-shaking&quot; target=&quot;_blank&quot;&gt;github进行下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;示例代码结构如图：src中index.js为入口文件，module.js是测试的模块文件，dist中是产出的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/605230/201711/605230-20171127195301847-2060238992.png&quot; alt=&quot;&quot; width=&quot;286&quot; height=&quot;275&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据webpack官网的提示，webpack支持tree-shaking，需要修改配置文件，指定babel处理js文件时不要将ES6模块转成CommonJS模块，具体做法就是：&lt;/p&gt;
&lt;p&gt;在.babelrc设置babel-preset-es2015的modules为fasle，表示不对ES6模块进行处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// .babelrc文件
{
  &quot;presets&quot;: [
    &lt;strong&gt;[&quot;es2015&quot;, { &quot;modules&quot;: false }]&lt;/strong&gt; 
  ],
  &quot;comments&quot;: false
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在webpack.config.js中设置babel-preset-es2015的modules为fasle，表示不对ES6模块进行处理。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
// webpack.config.js
...
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                loader: 'babel-loader',
                options: {
                    presets: [
                        &lt;strong&gt;[&quot;es2015&quot;, { &quot;modules&quot;: false }]&lt;/strong&gt;
                    ]
                }
            }
        ]
...　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在module.js文件中创建三个模块sayHello，sayBye，sayHi，并在index.js引用sayHello，sayHi；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// module.js
export const sayHello = name =&amp;gt; `Hello ${name}!`;
export const sayBye = name =&amp;gt; `Bye ${name}!`;
export const sayHi = name =&amp;gt; `Hi ${name}!`;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// index.js
import { sayHello } from './module';
import { sayHi } from './module';
const element = document.createElement('h1');
element.innerHTML = sayHello('World') + sayHi('my friend');
document.body.appendChild(element);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后在当前目录执行 &lt;span&gt;webpack &lt;/span&gt;命令后，产出bundle.js的代码如下&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
&lt;strong&gt;/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, &quot;a&quot;, function() { return sayHello; });
/* unused harmony export sayBye */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, &quot;b&quot;, function() { return sayHi; });&lt;/strong&gt;


var sayHello = function sayHello(name) {
  return &quot;Hello &quot; + name + &quot;!&quot;;
};
var sayBye = function sayBye(name) {
  return &quot;Bye &quot; + name + &quot;!&quot;;
};

var sayHi = function sayHi(name) {
  return &quot;Hi &quot; + name + &quot;!&quot;;
};

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
&lt;strong&gt;Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__module__ = __webpack_require__(0);&lt;/strong&gt;



var element = document.createElement('h1');
element.innerHTML = Object(&lt;strong&gt;__WEBPACK_IMPORTED_MODULE_0__module__[&quot;a&quot; /* sayHello */]&lt;/strong&gt;)('World') + Object(&lt;strong&gt;__WEBPACK_IMPORTED_MODULE_0__module__[&quot;b&quot; /* sayHi */]&lt;/strong&gt;)(' to meet you');
document.body.appendChild(element);

/***/ })
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上面可以知道，sayBye模块被打上了&lt;span&gt;unused harmony export&lt;/span&gt;&lt;span&gt;标签，sayHello和sayHi被设置为__webpack_exports__的属性，在入口文件中通过读取__webpack_exports__的属性取出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bundle.js文件虽然对多余的模块进行了标记，但是并没有删除，这是因为webpack还没有执行压缩混淆操作，可以通过&lt;span&gt;webpack -p&lt;span&gt;命令对产出进行压缩处理，这时候会把打了&lt;span&gt;unused harmony export&lt;/span&gt; &lt;span&gt;标签的模块删除掉。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;webpack的tree-shaking的局限性&lt;/h2&gt;
&lt;p&gt;（1）只能是静态声明和引用的ES6模块，不能是动态引入和声明的；&lt;/p&gt;
&lt;p&gt;在打包阶段对冗余代码进行删除，就需要webpack需要在打包阶段确定模块文件的内部结构，而ES模块的引用和输出必须出现在文件结构的第一级（'import' and 'export' may only appear at the top level），否则会报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// webpack编译时会报错
if (condition) {
  import module1 from './module1';
} else {
  import module2 from './module2';
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而CommonJS模块支持动态结构的，所以不能对CommonJS模块进行tree-shaking处理。&lt;/p&gt;
&lt;p&gt;（2）只能处理模块级别，不能处理函数级别的冗余；&lt;/p&gt;
&lt;p&gt; 因为webpack的tree-shaking是基于模块间的依赖关系，所以并不能对模块内部自身的无用代码进行删除。&lt;/p&gt;
&lt;p&gt;（3）只能处理JS相关冗余代码，不能处理CSS冗余代码。&lt;/p&gt;
&lt;p&gt;目前webpack只对JS文件的依赖进行了处理，CSS的冗余并没有给出很好的工具。最近听了一个讲座，提到了&lt;a href=&quot;https://github.com/lin-xi/webpack-css-treeshaking-plugin&quot; target=&quot;_blank&quot;&gt;webpack-css-treeshaking-plugin&lt;/a&gt;，该插件基于AST对CSS冗余代码进行了很好的处理。&lt;/p&gt;

</description>
<pubDate>Mon, 27 Nov 2017 14:35:00 +0000</pubDate>
<dc:creator>Young Dreamer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wmhuang/p/7905972.html</dc:identifier>
</item>
<item>
<title>Redis 持久化之RDB和AOF - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/7906481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/7906481.html</guid>
<description>&lt;p&gt;Redis 有两种持久化方案，RDB （Redis DataBase）和 AOF （Append Only File）。如果你想快速了解和使用RDB和AOF，可以直接跳到文章底部看总结。本章节通过配置文件，触发快照的方式，恢复数据的操作，命令操作演示，优缺点来学习 Redis 的重点知识&lt;strong&gt;持久化&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;rdb-详解&quot;&gt;RDB 详解&lt;/h2&gt;
&lt;p&gt;RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。&lt;/p&gt;
&lt;h3 id=&quot;从配置文件了解rdb&quot;&gt;从配置文件了解RDB&lt;/h3&gt;
&lt;p&gt;打开 redis.conf 文件，找到 SNAPSHOTTING 对应内容&lt;br/&gt;1 RDB核心规则配置（重点）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;
# save &quot;&quot;
save 900 1
save 300 10
save 60 10000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解说：save &amp;lt;指定时间间隔&amp;gt; &amp;lt;执行指定次数更新操作&amp;gt;，满足条件就将内存中的数据同步到硬盘中。官方出厂配置默认是 900秒内有1个更改，300秒内有10个更改以及60秒内有10000个更改，则将内存中的数据快照写入磁盘。&lt;br/&gt;若不想用RDB方案，可以把 save &quot;&quot; 的注释打开，下面三个注释。&lt;/p&gt;
&lt;p&gt;2 指定本地数据库文件名，一般采用默认的 dump.rdb&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dbfilename dump.rdb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3 指定本地数据库存放目录，一般也用默认配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir ./&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4 默认开启数据压缩&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rdbcompression yes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解说：配置存储至本地数据库时是否压缩数据，默认为yes。Redis采用LZF压缩方式，但占用了一点CPU的时间。若关闭该选项，但会导致数据库文件变的巨大。建议开启。&lt;/p&gt;
&lt;h3 id=&quot;触发rdb快照&quot;&gt;触发RDB快照&lt;/h3&gt;
&lt;p&gt;1 在指定的时间间隔内，执行指定次数的写操作&lt;br/&gt;2 执行save（阻塞， 只管保存快照，其他的等待） 或者是bgsave （异步）命令&lt;br/&gt;3 执行flushall 命令，清空数据库所有数据，意义不大。&lt;br/&gt;4 执行shutdown 命令，保证服务器正常关闭且不丢失任何数据，意义...也不大。&lt;/p&gt;
&lt;h3 id=&quot;通过rdb文件恢复数据&quot;&gt;通过RDB文件恢复数据&lt;/h3&gt;
&lt;p&gt;将dump.rdb 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可。在实际开发中，一般会考虑到物理机硬盘损坏情况，选择备份dump.rdb 。可以从下面的操作演示中可以体会到。&lt;/p&gt;
&lt;h3 id=&quot;rdb-的优缺点&quot;&gt;RDB 的优缺点&lt;/h3&gt;
&lt;p&gt;优点：&lt;br/&gt;1 适合大规模的数据恢复。&lt;br/&gt;2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。&lt;/p&gt;
&lt;p&gt;缺点：&lt;br/&gt;1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。&lt;br/&gt;2 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。&lt;br/&gt;所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。&lt;/p&gt;
&lt;h3 id=&quot;操作演示&quot;&gt;操作演示&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;[root@itdragon bin]# vim redis.conf
save 900 1
save 120 5
save 60 10000
[root@itdragon bin]# ./redis-server redis.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; keys *
(empty list or set)
127.0.0.1:6379&amp;gt; set key1 value1
OK
127.0.0.1:6379&amp;gt; set key2 value2
OK
127.0.0.1:6379&amp;gt; set key3 value3
OK
127.0.0.1:6379&amp;gt; set key4 value4
OK
127.0.0.1:6379&amp;gt; set key5 value5
OK
127.0.0.1:6379&amp;gt; set key6 value6
OK
127.0.0.1:6379&amp;gt; SHUTDOWN
not connected&amp;gt; QUIT
[root@itdragon bin]# cp dump.rdb dump_bk.rdb
[root@itdragon bin]# ./redis-server redis.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; FLUSHALL 
OK
127.0.0.1:6379&amp;gt; keys *
(empty list or set)
127.0.0.1:6379&amp;gt; SHUTDOWN
not connected&amp;gt; QUIT
[root@itdragon bin]# cp dump_bk.rdb  dump.rdb
cp: overwrite `dump.rdb'? y
[root@itdragon bin]# ./redis-server redis.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; keys *
1) &quot;key5&quot;
2) &quot;key1&quot;
3) &quot;key3&quot;
4) &quot;key4&quot;
5) &quot;key6&quot;
6) &quot;key2&quot;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一步：vim 修改持久化配置时间，120秒内修改5次则持久化一次。&lt;br/&gt;第二步：重启服务使配置生效。&lt;br/&gt;第三步：分别set 5个key，过两分钟后，在bin的当前目录下会自动生产一个dump.rdb文件。（set key6 是为了验证shutdown有触发RDB快照的作用）&lt;br/&gt;第四步：将当前的dump.rdb 备份一份（模拟线上工作）。&lt;br/&gt;第五步：执行FLUSHALL命令清空数据库数据（模拟数据丢失）。&lt;br/&gt;第六步：重启Redis服务，恢复数据.....咦？？？？( ′◔ ‸◔`)。数据是空的？？？？这是因为FLUSHALL也有触发RDB快照的功能。&lt;br/&gt;第七步：将备份的 dump_bk.rdb 替换 dump.rdb 然后重新Redis。&lt;/p&gt;
&lt;p&gt;注意点：SHUTDOWN 和 FLUSHALL 命令都会触发RDB快照，这是一个坑，请大家注意。&lt;/p&gt;
&lt;p&gt;其他命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;keys * 匹配数据库中所有 key&lt;/li&gt;
&lt;li&gt;save 阻塞触发RDB快照，使其备份数据&lt;/li&gt;
&lt;li&gt;FLUSHALL 清空整个 Redis 服务器的数据(几乎不用)&lt;/li&gt;
&lt;li&gt;SHUTDOWN 关机走人（很少用）&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;aof-详解&quot;&gt;AOF 详解&lt;/h2&gt;
&lt;p&gt;AOF ：Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个&lt;strong&gt;写操作&lt;/strong&gt;，并&lt;strong&gt;追加&lt;/strong&gt;到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。&lt;/p&gt;
&lt;h3 id=&quot;从配置文件了解aof&quot;&gt;从配置文件了解AOF&lt;/h3&gt;
&lt;p&gt;打开 redis.conf 文件，找到 APPEND ONLY MODE 对应内容&lt;br/&gt;1 redis 默认关闭，开启需要手动把no改为yes&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;appendonly yes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2 指定本地数据库文件名，默认值为 appendonly.aof&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;appendfilename &quot;appendonly.aof&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3 指定更新日志条件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# appendfsync always
appendfsync everysec
# appendfsync no&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解说：&lt;br/&gt;always：同步持久化，每次发生数据变化会立刻写入到磁盘中。性能较差当数据完整性比较好（慢，安全）&lt;br/&gt;everysec：出厂默认推荐，每秒异步记录一次（默认值）&lt;br/&gt;no：不同步&lt;/p&gt;
&lt;p&gt;4 配置重写触发机制&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解说：当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。一般都设置为3G，64M太小了。&lt;/p&gt;
&lt;h3 id=&quot;触发aof快照&quot;&gt;触发AOF快照&lt;/h3&gt;
&lt;p&gt;根据配置文件触发，可以是每次执行触发，可以是每秒触发，可以不同步。&lt;/p&gt;
&lt;h3 id=&quot;根据aof文件恢复数据&quot;&gt;根据AOF文件恢复数据&lt;/h3&gt;
&lt;p&gt;正常情况下，将appendonly.aof 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可。但在实际开发中，可能因为某些原因导致appendonly.aof 文件格式异常，从而导致数据还原失败，可以通过命令redis-check-aof --fix appendonly.aof 进行修复 。从下面的操作演示中体会。&lt;/p&gt;
&lt;h3 id=&quot;aof的重写机制&quot;&gt;AOF的重写机制&lt;/h3&gt;
&lt;p&gt;前面也说到了，AOF的工作原理是将写操作追加到文件中，文件的冗余内容会越来越多。所以聪明的 Redis 新增了重写机制。当AOF文件的大小超过所设定的阈值时，Redis就会对AOF文件的内容压缩。&lt;/p&gt;
&lt;p&gt;重写的原理：Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中。并没有读取旧文件（你都那么大了，我还去读你？？？ o(ﾟДﾟ)っ傻啊！）。最后替换旧的aof文件。&lt;/p&gt;
&lt;p&gt;触发机制：当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。这里的“一倍”和“64M” 可以通过配置文件修改。&lt;/p&gt;
&lt;h3 id=&quot;aof-的优缺点&quot;&gt;AOF 的优缺点&lt;/h3&gt;
&lt;p&gt;优点：数据的完整性和一致性更高&lt;br/&gt;缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。&lt;/p&gt;
&lt;h3 id=&quot;操作演示-1&quot;&gt;操作演示&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[root@itdragon bin]# vim appendonly.aof
appendonly yes
[root@itdragon bin]# ./redis-server redis.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; keys *
(empty list or set)
127.0.0.1:6379&amp;gt; set keyAOf valueAof
OK
127.0.0.1:6379&amp;gt; FLUSHALL 
OK
127.0.0.1:6379&amp;gt; SHUTDOWN
not connected&amp;gt; QUIT
[root@itdragon bin]# ./redis-server redis.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; keys *
1) &quot;keyAOf&quot;
127.0.0.1:6379&amp;gt; SHUTDOWN
not connected&amp;gt; QUIT
[root@itdragon bin]# vim appendonly.aof
fjewofjwojfoewifjowejfwf
[root@itdragon bin]# ./redis-server redis.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
Could not connect to Redis at 127.0.0.1:6379: Connection refused
not connected&amp;gt; QUIT
[root@itdragon bin]# redis-check-aof --fix appendonly.aof 
'x              3e: Expected prefix '*', got: '
AOF analyzed: size=92, ok_up_to=62, diff=30
This will shrink the AOF from 92 bytes, with 30 bytes, to 62 bytes
Continue? [y/N]: y
Successfully truncated AOF
[root@itdragon bin]# ./redis-server redis.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; keys *
1) &quot;keyAOf&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一步：修改配置文件，开启AOF持久化配置。&lt;br/&gt;第二步：重启Redis服务，并进入Redis 自带的客户端中。&lt;br/&gt;第三步：保存值，然后模拟数据丢失，关闭Redis服务。&lt;br/&gt;第四步：重启服务，发现数据恢复了。（额外提一点：有教程显示FLUSHALL 命令会被写入AOF文件中，导致数据恢复失败。我安装的是redis-4.0.2没有遇到这个问题）。&lt;br/&gt;第五步：修改appendonly.aof，模拟文件异常情况。&lt;br/&gt;第六步：重启 Redis 服务失败。这同时也说明了，RDB和AOF可以同时存在，且优先加载AOF文件。&lt;br/&gt;第七步：校验appendonly.aof 文件。重启Redis 服务后正常。&lt;/p&gt;
&lt;p&gt;补充点：aof 的校验是通过 redis-check-aof 文件，那么rdb 的校验是不是可以通过 redis-check-rdb 文件呢？？？&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Redis 默认开启RDB持久化方式，在指定的时间间隔内，执行指定次数的写操作，则将内存中的数据写入到磁盘中。&lt;/li&gt;
&lt;li&gt;RDB 持久化适合大规模的数据恢复但它的数据一致性和完整性较差。&lt;/li&gt;
&lt;li&gt;Redis 需要手动开启AOF持久化方式，默认是每秒将写操作日志追加到AOF文件中。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;AOF 的数据完整性比RDB高，但记录内容多了，会影响数据恢复的效率。&lt;/li&gt;
&lt;li&gt;Redis 针对 AOF文件大的问题，提供重写的瘦身机制。&lt;/li&gt;
&lt;li&gt;若只打算用Redis 做缓存，可以关闭持久化。&lt;/li&gt;
&lt;li&gt;若打算使用Redis 的持久化。建议RDB和AOF都开启。其实RDB更适合做数据的备份，留一后手。AOF出问题了，还有RDB。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;到这里Redis 的持久化就介绍完了，有什么不对的地方可以指出。&lt;br/&gt;Redis 快速入门：&lt;a href=&quot;http://www.cnblogs.com/itdragon/p/7897131.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/itdragon/p/7897131.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Nov 2017 14:22:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/7906481.html</dc:identifier>
</item>
<item>
<title>Drools文档（八） 规则语言参考 - 紫零大仙</title>
<link>http://www.cnblogs.com/prpl/p/7906431.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/prpl/p/7906431.html</guid>
<description>&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;条规则规定当左手侧（LHS）中指定的一组特定条件发生时，则执行查询被指定为右手侧（RHS）中的动作列表。用户的一个常见问题是“为什么要使用when而不是if？” “when”被选择为“if”，因为“if”通常是程序执行流程的一部分，在特定的时间点需要检查一个条件。&lt;/p&gt;
&lt;/div&gt;&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;规则必须有一个名称，在其规则包中是唯一的。如果您在相同的DRL中定义了两次规则，则在加载时会产生错误。如果添加包含规则名称的DRL，它将替换以前的规则。如果规则名称有空格，则需要用双引号括起来（最好总是使用双引号）。&lt;/p&gt;
&lt;/div&gt;&lt;div readability=&quot;33&quot;&gt;
&lt;h4 id=&quot;true__31&quot;&gt;规则属性&lt;/h4&gt;
&lt;div class=&quot;paragraph data-line-1069&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;规则属性提供了一种声明方式来影响规则的行为。有些是非常简单的，而另一些则是复杂子系统的一部分，比如ruleflow。为了充分利用Drools，你应该确保你对每个属性有一个正确的理解。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock data-line-1072&quot;&gt;
&lt;div class=&quot;content&quot;&gt;&lt;img src=&quot;http://localhost:60648/afx/resource/LJF/workspace/documents/drools/images/Image-261117-084337.961.png&quot; alt=&quot;Image 261117 084337.961.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Figure 10. 规则属性&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;paragraph data-line-1076&quot;&gt;
&lt;p&gt;默认值：false&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1078&quot;&gt;
&lt;p&gt;类型: Boolean&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1080&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;当规则的结果修改事实时，可能会导致规则再次激活，导致无限循环。将no-loop设置为true将跳过为具有当前事实集合的规则创建另一个Activation。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1082&quot;&gt;
&lt;p&gt;&lt;code&gt;ruleflow-group&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1084&quot;&gt;
&lt;p&gt;默认值: N/A&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1086&quot;&gt;
&lt;p&gt;类型: String&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1088&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;Ruleflow是一个Drools功能，可以让你控制规则的触发。仅当组的活动时，由同一个ruleflow-group标识符组装的规则才会触发。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1090&quot;&gt;
&lt;p&gt;&lt;code&gt;lock-on-active&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1092&quot;&gt;
&lt;p&gt;默认值:&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;false&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1094&quot;&gt;
&lt;p&gt;类型: Boolean&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1096&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;每当规则流组变为活动状态或者议程组收到焦点时，该组中的任何规则锁定激活设置为true的规则将不再被激活;不管更新的起源如何，匹配规则的激活都被丢弃。这是一个更强大的无循环版本，因为现在不仅可以由规则本身引起变化。对于计算规则而言，如果您有一些修改事实的规则，并且不希望任何规则重新匹配并再次触发，那么这是理想的计算规则。只有在规则流程组不再活动或者议程组失去焦点的情况下，那些锁定活动设置为true的规则才会再次成为其激活被列入议程的条件。&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;paragraph data-line-1100&quot;&gt;
&lt;p&gt;默认值:&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;0&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1102&quot;&gt;
&lt;p&gt;类型: integer&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1104&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;每个规则都有一个整数显着属性，默认为零，可以是负值也可以是正值。显着性是优先级的一种形式，当在激活队列中排序时，具有较高显着性值的规则被赋予较高的优先级。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1106&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;Drools还支持动态显着性，您可以使用涉及绑定变量的表达式。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock data-line-1110&quot; readability=&quot;7.5&quot;&gt;
&lt;p&gt;动态显着性&lt;/p&gt;
&lt;div class=&quot;content&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;highlightjs highlight&quot;&gt;
&lt;code class=&quot;language-java hljs&quot; data-lang=&quot;java&quot;&gt;rule &lt;span class=&quot;hljs-string&quot;&gt;&quot;Fire in rank order 1,2,..&quot;
        salience( -$rank )
    &lt;span class=&quot;hljs-function&quot;&gt;when
        &lt;span class=&quot;hljs-title&quot;&gt;Element&lt;span class=&quot;hljs-params&quot;&gt;( $rank : rank,... )
    then
        ...
end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1120&quot;&gt;
&lt;p&gt;&lt;code&gt;agenda-group&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1122&quot;&gt;
&lt;p&gt;默认值: MAIN&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1124&quot;&gt;
&lt;p&gt;类型: String&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1126&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;议程组允许用户划分议程提供更多的执行控制。只有获得焦点的议程小组的规则才被允许开除。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1128&quot;&gt;
&lt;p&gt;&lt;code&gt;auto-focus&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1130&quot;&gt;
&lt;p&gt;默认值:&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;false&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1132&quot;&gt;
&lt;p&gt;类型: Boolean&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1134&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;如果在自动对焦值为true并且规则的议程组尚未具有焦点的情况下激活规则，则会给予焦点，从而允许规则可能触发。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1136&quot;&gt;
&lt;p&gt;&lt;code&gt;activation-group&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1138&quot;&gt;
&lt;p&gt;默认值: N/A&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1140&quot;&gt;
&lt;p&gt;类型: String&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1142&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;属于同一个激活组的规则（由该属性的字符串值标识）将只能单独激活。更确切地说，激活组中的第一条规则将会取消组中所有规则的所有悬而未决的激活，即阻止它们发射。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1144&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;注意：这个叫Xor组，但是从技术上说它不是Xor。你可能还听到人们提到异或集团;只需在激活组中使用该术语即可。&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;paragraph data-line-1148&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;默认值：如包所指定&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1150&quot;&gt;
&lt;p&gt;类型: String&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1152&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;可能的值: &quot;java&quot; 或者 &quot;mvel&quot;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1154&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;方言种类是在LHS或RHS代码块中用于任何代码表达的语言。目前有两种方言可用，Java和MVEL。虽然可以在包级别指定方言，但是此属性允许为规则覆盖包定义。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1156&quot;&gt;
&lt;p&gt;&lt;code&gt;date-effective&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1158&quot;&gt;
&lt;p&gt;默认值: N/A&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1160&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;类型: String, 包含日期和时间定义&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1162&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;如果当前日期和时间在日期有效属性之后，则规则只能激活。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1164&quot;&gt;
&lt;p&gt;&lt;code&gt;date-expires&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1166&quot;&gt;
&lt;p&gt;默认值: N/A&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1168&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;类型: String, 包含日期和时间定义&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1170&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;如果当前日期和时间在date-expires属性之后，则规则无法激活。&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;paragraph data-line-1174&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;默认值：没有默认值&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1176&quot;&gt;
&lt;p&gt;type: long&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1178&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;持续时间表明规则将在指定的持续时间后触发，如果仍然如此。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock data-line-1182&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;一些属性的例子&lt;/p&gt;
&lt;div class=&quot;content&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;highlightjs highlight&quot;&gt;
&lt;code class=&quot;language-java hljs&quot; data-lang=&quot;java&quot;&gt;rule &lt;span class=&quot;hljs-string&quot;&gt;&quot;my rule&quot;
  salience &lt;span class=&quot;hljs-number&quot;&gt;42
  agenda-group &lt;span class=&quot;hljs-string&quot;&gt;&quot;number 1&quot;
    when ...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div readability=&quot;43.5&quot;&gt;
&lt;h4 id=&quot;true__32&quot;&gt;定时器和日历&lt;/h4&gt;
&lt;div class=&quot;paragraph data-line-1191&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;规则现在支持基于时间间隔和基于cron的定时器，它们取代了现在弃用的持续时间属性。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock data-line-1195&quot; readability=&quot;8.5&quot;&gt;
&lt;p&gt;示例计时器属性使用&lt;/p&gt;
&lt;div class=&quot;content&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;highlightjs highlight&quot;&gt;
&lt;code class=&quot;language-java hljs&quot; data-lang=&quot;java&quot;&gt;timer ( &lt;span class=&quot;hljs-keyword&quot;&gt;int:  &amp;lt;repeat interval&amp;gt;? )
timer ( &lt;span class=&quot;hljs-keyword&quot;&gt;int: &lt;span class=&quot;hljs-number&quot;&gt;30s )
timer ( &lt;span class=&quot;hljs-keyword&quot;&gt;int: &lt;span class=&quot;hljs-number&quot;&gt;30s &lt;span class=&quot;hljs-number&quot;&gt;5m )

timer ( cron: &amp;lt;cron expression&amp;gt; )
timer ( cron:* &lt;span class=&quot;hljs-number&quot;&gt;0/&lt;span class=&quot;hljs-number&quot;&gt;15 * * * ? )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1204&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;Interval（由“int：”指示）定时器遵循java.util.Timer对象的语义，具有初始延迟和可选的重复间隔。 Cron（由“cron：”表示）定时器遵循标准的Unix cron表达式：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock data-line-1208&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;一个Cron例子&lt;/p&gt;
&lt;div class=&quot;content&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;highlightjs highlight&quot;&gt;
&lt;code class=&quot;language-java hljs&quot; data-lang=&quot;java&quot;&gt;rule &lt;span class=&quot;hljs-string&quot;&gt;&quot;Send SMS every 15 minutes&quot;
    timer (cron:* &lt;span class=&quot;hljs-number&quot;&gt;0/&lt;span class=&quot;hljs-number&quot;&gt;15 * * * ?)
when
    $a : Alarm( on == &lt;span class=&quot;hljs-keyword&quot;&gt;true )
then
    channels[ &lt;span class=&quot;hljs-string&quot;&gt;&quot;sms&quot; ].insert( &lt;span class=&quot;hljs-keyword&quot;&gt;new Sms( $a.mobileNumber, &lt;span class=&quot;hljs-string&quot;&gt;&quot;The alarm is still on&quot; );
end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1218&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;定时器控制的规则在匹配时变为激活状态，对于每个单独的匹配则变为一次。根据定时器的设置重复执行其结果。一旦条件不匹配，就停止。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1220&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;即使在控制从调用返回给FireUntilHalt之后，也会执行后果。而且，发动机对工作记忆的任何变化都保持反应。例如，删除涉及触发定时器规则执行的Fact会导致重复执行终止，或插入一个事实，以便某些规则匹配将导致该规则触发。但是，引擎并不是一直活跃的，只有在一个规则触发后，无论出于何种原因。因此，在下一次执行定时器控制的规则之前，不会发生对异步插入的反应。处理会话会终止所有计时器活动。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1222&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;相反，当规则引擎默认运行在被动模式（即：使用fireAllRules而不是fireUntilHalt）时，它不会触发定时规则的后果，除非fireAllRules不再被调用。但是，可以通过使用TimedRuleExecutionOption配置KieSession来更改此默认行为，如以下示例所示。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock data-line-1226&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;配置KieSession自动执行定时规则&lt;/p&gt;
&lt;div class=&quot;content&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;highlightjs highlight&quot;&gt;
&lt;code class=&quot;language-java hljs&quot; data-lang=&quot;java&quot;&gt;KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
ksconf.setOption( TimedRuleExecutionOption.YES );
KSession ksession = kbase.newKieSession(ksconf, &lt;span class=&quot;hljs-keyword&quot;&gt;null);&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1232&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;也可以对定时规则进行更细粒度的控制，这些规则必须自动执行。要做到这一点，有必要设置一个FILTERED TimedRuleExecutionOption，它允许定义一个回调来过滤这些规则，就像下一个例子中所做的那样。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock data-line-1236&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;配置一个过滤器来选择自动执行哪些定时规则&lt;/p&gt;
&lt;div class=&quot;content&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;highlightjs highlight&quot;&gt;
&lt;code class=&quot;language-java hljs&quot; data-lang=&quot;java&quot;&gt;KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
conf.setOption( &lt;span class=&quot;hljs-keyword&quot;&gt;new TimedRuleExecutionOption.FILTERED(&lt;span class=&quot;hljs-keyword&quot;&gt;new TimedRuleExecutionFilter() {
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;boolean &lt;span class=&quot;hljs-title&quot;&gt;accept&lt;span class=&quot;hljs-params&quot;&gt;(Rule[] rules) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return rules[&lt;span class=&quot;hljs-number&quot;&gt;0].getName().equals(&lt;span class=&quot;hljs-string&quot;&gt;&quot;MyRule&quot;);
    }
}) );&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1245&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;对于间隔计时器，也可以将延迟和间隔定义为表达式而不是固定值。为此，有必要使用表达式计时器（由“expr：”表示），如下例所示：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock data-line-1249&quot; readability=&quot;9.5&quot;&gt;
&lt;p&gt;一个表达式计时器示例&lt;/p&gt;
&lt;div class=&quot;content&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;highlightjs highlight&quot;&gt;
&lt;code class=&quot;language-java hljs&quot; data-lang=&quot;java&quot;&gt;declare Bean
    delay   : String = &lt;span class=&quot;hljs-string&quot;&gt;&quot;30s&quot;
    period  : &lt;span class=&quot;hljs-keyword&quot;&gt;long = &lt;span class=&quot;hljs-number&quot;&gt;60000
end

rule &lt;span class=&quot;hljs-string&quot;&gt;&quot;Expression timer&quot;
    timer( expr: $d, $p )
&lt;span class=&quot;hljs-function&quot;&gt;when
    &lt;span class=&quot;hljs-title&quot;&gt;Bean&lt;span class=&quot;hljs-params&quot;&gt;( $d : delay, $p : period )
then
end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1263&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;在这种情况下，表达式$ d和$ p可以使用规则的模式匹配部分中定义的任何变量，并且可以是任何可以在持续时间内解析的字符串，也可以是将在内部长时间内转换的任何数值表示以毫秒表示的持续时间。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1265&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;间隔和表达式定时器都可以有3个可选参数，名称分别为“start”，“end”和“repeat-limit”。当使用这些参数中的一个或多个参数时，定时器定义的第一部分必须跟有分号“;”并且参数必须用逗号“，”分隔，如下例所示：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock data-line-1268&quot; readability=&quot;8.5&quot;&gt;
&lt;p&gt;一个带有开始和结束的间隔定时器&lt;/p&gt;
&lt;div class=&quot;content&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
``timer (int: 30s 10s; start=3-JAN-2010, end=5-JAN-2010)``
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1272&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;开始和结束参数的值可以是日期，表示日期或长的字符串，或者更一般的任何数字，将在Java日期中进行转换，应用以下转换：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock data-line-1274&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;content&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
``new Date( ((Number) n).longValue() )``
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1278&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;相反，repeat-limit只能是一个整数，它定义了定时器允许的最大重复次数。如果同时设定了结束和重复限制参数，则当两者中的第一个匹配时，计时器将停止。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1280&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;启动参数的使用意味着定时器阶段的定义，其中阶段的开始由启动本身加上最终的延迟给出。换句话说，在这种情况下，定时规则将在以下时间被安排：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock data-line-1282&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;content&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
``start + delay + n*period``
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1286&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;达到重复限制时间，不迟于结束时间戳（以先到者为准）。例如具有以下间隔计时器的规则。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock data-line-1288&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;content&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
``timer ( int: 30s 1m; start=&quot;3-JAN-2010&quot; )``
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1292&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;将于2010年1月3日午夜后的每分钟30秒进行。这也意味着，例如，如果您在2010年2月3日午夜打开系统，则不会立即安排，但会保留定时器定义的阶段，因此将在30秒后首次安排午夜。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1294&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;如果由于某种原因系统暂停（例如，会话被序列化，然后在一段时间之后反序列化），规则将仅被安排一次以从缺失的激活中恢复（不管我们错过了多少次激活），并且随后将再次安排与计时器相位。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1296&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;日历用于控制规则何时可以触发。 Calendar API模仿于http://www.quartz-scheduler.org/[Quartz]：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock data-line-1300&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;调整Quartz日历&lt;/p&gt;
&lt;div class=&quot;content&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
``Calendar weekDayCal = QuartzHelper.quartzCalendarAdapter(org.quartz.Calendar quartzCal)``
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1304&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;日历是用“KieSession”注册的：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock data-line-1307&quot; readability=&quot;6.5&quot;&gt;
&lt;p&gt;注册一个日历&lt;/p&gt;
&lt;div class=&quot;content&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
``ksession.getCalendars().set( &quot;weekday&quot;, weekDayCal );``
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph data-line-1311&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;它们可以与包括定时器在内的常规规则和规则结合使用。规则属性“日历”可能包含一个或多个以字符串文字形式书写的以逗号分隔的日历名称。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock data-line-1315&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;一起使用日历和定时器&lt;/p&gt;
&lt;div class=&quot;content&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;highlightjs highlight&quot;&gt;
&lt;code class=&quot;language-java hljs&quot; data-lang=&quot;java&quot;&gt;rule &lt;span class=&quot;hljs-string&quot;&gt;&quot;weekdays are high priority&quot;
   calendars &lt;span class=&quot;hljs-string&quot;&gt;&quot;weekday&quot;
   timer (&lt;span class=&quot;hljs-keyword&quot;&gt;int:&lt;span class=&quot;hljs-number&quot;&gt;0 &lt;span class=&quot;hljs-number&quot;&gt;1h)
&lt;span class=&quot;hljs-function&quot;&gt;when
    &lt;span class=&quot;hljs-title&quot;&gt;Alarm&lt;span class=&quot;hljs-params&quot;&gt;()
then
    &lt;span class=&quot;hljs-title&quot;&gt;send&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-string&quot;&gt;&quot;priority high - we have an alarm&quot; );
end

rule &lt;span class=&quot;hljs-string&quot;&gt;&quot;weekend are low priority&quot;
   calendars &lt;span class=&quot;hljs-string&quot;&gt;&quot;weekend&quot;
   timer (&lt;span class=&quot;hljs-keyword&quot;&gt;int:&lt;span class=&quot;hljs-number&quot;&gt;0 &lt;span class=&quot;hljs-number&quot;&gt;4h)
&lt;span class=&quot;hljs-function&quot;&gt;when
    &lt;span class=&quot;hljs-title&quot;&gt;Alarm&lt;span class=&quot;hljs-params&quot;&gt;()
then
    &lt;span class=&quot;hljs-title&quot;&gt;send&lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-string&quot;&gt;&quot;priority low - we have an alarm&quot; );
end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 27 Nov 2017 14:15:00 +0000</pubDate>
<dc:creator>紫零大仙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/prpl/p/7906431.html</dc:identifier>
</item>
<item>
<title>程序员的自我救赎---1.1： 解决方案命分层规范 - Near_wen</title>
<link>http://www.cnblogs.com/demon28/p/7905369.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/demon28/p/7905369.html</guid>
<description>&lt;p&gt; &lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot;&gt;《目录》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;《Winner2.0框架解决方案命分层规范》&lt;/p&gt;

&lt;p&gt;初学编程，难免要从Hello Word开始，学习Winner框架首先要知道如何建一个项目。有了第一个项目的框架结构就知道如何施展自己的&quot;增删查改&quot;。&lt;/p&gt;
&lt;p&gt;Winner框架 依然遵从MVC模式，这里我就不去赘述什么是MVC。&lt;/p&gt;

&lt;p&gt;数据层：以&quot;项目名.DataAcces&quot;命名，例如：  Shop.DataAccess；   &lt;/p&gt;
&lt;p&gt;实体层：以&quot;项目名.Entities&quot; 命名    例如： Shop.Entities；&lt;/p&gt;
&lt;p&gt;业务层：以“项目名.Facade”命名   例如：Shop.Facade；&lt;/p&gt;
&lt;p&gt;显示层：以“项目名称” 命名  例如： Shop；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/161176/201711/161176-20171127175537269-237024306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;=======================华丽的分割线====================&lt;/p&gt;
&lt;p&gt;winner 框架的核心库有 三个:&lt;/p&gt;





&lt;p&gt;整个Winner框架就以此三个为核心，开展工作。无论是哪一层都需要引用这三个程序集。&lt;/p&gt;

&lt;div class=&quot;toclevel2&quot; data-toclevel=&quot;2&quot; readability=&quot;33&quot;&gt;
&lt;p&gt;=======================华丽的分割线====================&lt;/p&gt;
&lt;p&gt; 数据库命名：&lt;/p&gt;
&lt;p&gt;1.基础规范：&lt;br/&gt;1.由于Oracle做大小写命名非常麻烦，所有统一采用PLSQL规范为大写。为了命名的可读性，每个单词与单词之间用下划线（“_”）隔开。&lt;/p&gt;
&lt;p&gt;2.每个表、字段、试图都必须加上相关备注；&lt;/p&gt;
&lt;p&gt;3.每个表的字段最后必须加上Remarks与Create_Time（默认为sysdate）字段；&lt;/p&gt;
&lt;p&gt;4.凡是有字段在程序中为枚举的，则需要在备注中写明枚举名称和枚举值，例如用户状态的备注为：用户状态$UserStatus${未激活=0,已激活=1,已锁定=2}&lt;/p&gt;
&lt;p&gt;2.命名规范：&lt;br/&gt;1.表名： T模块_表名 例如：用户模块用户表，Tnet_Reginfo&lt;/p&gt;
&lt;p&gt;2.试图： V模块_表名 例如：用户模块用户表，Vnet_Reginfo&lt;/p&gt;
&lt;p&gt;3.主键： PK_表名 例如：PK_Tnet_Reginfo&lt;/p&gt;
&lt;p&gt;4.外键： FK_表名_字段 例如：FK_Tnet_Reginfo_NodeId&lt;/p&gt;
&lt;p&gt;5.唯一键： UK_表名_字段 例如：UK_Tnet_Reginfo_NodeCode&lt;/p&gt;
&lt;p&gt;6.检查约束： CK_表名_字段 例如：CK_Tnet_Reginfo_NodeCode、&lt;/p&gt;

&lt;p&gt;=======================华丽的分割线====================&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt; DataAccess 数据访问层：&lt;/p&gt;

&lt;p&gt;只存放由代码生成器生成的数据访问类,以及我们使用 &lt;strong&gt;“部分类”&lt;/strong&gt; 自己根据需求扩展的数据库操作&lt;/p&gt;
&lt;p&gt;这里我们使用 “部分类” 部分类，也叫分部类，这里就不科普C# 语言基础知识了。（关于代码生成器，在下一篇中再详细概述）&lt;/p&gt;

&lt;p&gt;如下图：&lt;/p&gt;

&lt;div class=&quot;toclevel2&quot; data-toclevel=&quot;2&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/161176/201711/161176-20171127183525831-2132505179.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;


&lt;p&gt;注意： 由代码生成器生成的 文件名规范为：&quot;表名.generate.cs&quot; 自己扩展的不含“generate”字样以此区分。&lt;/p&gt;


&lt;div class=&quot;toclevel2&quot; data-toclevel=&quot;2&quot; readability=&quot;10&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/161176/201711/161176-20171127184420425-114926144.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt; 代码生成器，会帮我们生成实体 和 数据库操作类，Winner框架将单条操作和 多条操作分成了两个类。&lt;/p&gt;
&lt;p&gt;  但是这两个类在同一个文件里，数据库操作类是以表为单位建文件。&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;toclevel2&quot; data-toclevel=&quot;2&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/161176/201711/161176-20171127184746097-1969838709.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt; 这是代码生成器生成的带条操作，如果要根据需求扩展操作 着负责该类文件到Generate文件外,并删除文件名中的.generate。&lt;/p&gt;
&lt;p&gt; 类文件中保留引用，命名空间，类名，删除里面的方法。&lt;/p&gt;


&lt;div class=&quot;toclevel2&quot; data-toclevel=&quot;2&quot; readability=&quot;39&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/161176/201711/161176-20171127185917237-580312601.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt; XXX_XXXXCollection 类中所有的查询类要求统一以List开头例如：  ListUserByStr()；ListUserByAccount()；关于继承的DataAccesBase 和 DataAccessCollectionBase 在后面的篇章中会详细讲到。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/161176/201711/161176-20171127193146815-939169945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这里有一条要注意,winner框架是集成了，数据访问类。整个项目只需要通过配置即可访问数据库，不需要再画蛇添足的去写数据库访问类，我们团队曾经有个新入职的员工，不是特别懂框架开发了两天&lt;/p&gt;
&lt;p&gt;进度一直没上来，结果他一个人自己闭门造车写数据库访问层，如果这些最基础的工作每个项目都要开发者来重复做一遍就不能称之为框架了。 我们很长一段时间开发中有新的公用类，或者比较常用的工具&lt;/p&gt;
&lt;p&gt;我们都会集成到框架里来，整个框架除了 三个 核心dll，扩展的dll 以及第三方的dll加起来有一两百个，比如常见的：NPOI，Newtonsoft，SQLite。这些在TFS中的dll文件夹中都有的，而且一直在更新。&lt;/p&gt;

&lt;p&gt;================================华丽的分割线==============================&lt;/p&gt;

&lt;p&gt;Entities 实体层：&lt;/p&gt;

&lt;p&gt;一般我们Winner框架的代码生成器会自动生成表所对应的实体以及字段在DataAccess中，但是我们实际开发中经常要跨应用对接&lt;/p&gt;
&lt;p&gt;比如要跟Android对接、IOS对接，这个时候我们很多情况下要自己 写Model，并根据model 序列化Json。 所以Entities 主要职责是存放model，&lt;/p&gt;
&lt;p&gt;除了，存放model实体以外Entities还有另外三项职责，总的来说如下四点：&lt;/p&gt;
&lt;p&gt;1，存放实体Model&lt;/p&gt;
&lt;p&gt;2，存放枚举对象&lt;/p&gt;
&lt;p&gt;3，保存产量，或变量。&lt;/p&gt;
&lt;p&gt;4，存放该项目需要的工具对象。&lt;/p&gt;

&lt;p&gt;如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/161176/201711/161176-20171127191822800-1127415039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


上面还有很多，比如根据项目需求写RAS加密工具类，基本上能公用的阿杰都写在了Winner.Framework.Encrypt  和 Winner.Framework.Utils。&lt;/div&gt;
&lt;p&gt;这两个对象中，上图的一些工具，是根据项目需求进行了二次封装。     &lt;/p&gt;
&lt;div class=&quot;toclevel2&quot; data-toclevel=&quot;2&quot; readability=&quot;7&quot;&gt;
&lt;p&gt; ====================================华丽的分割线===============================&lt;/p&gt;

&lt;p&gt;Facade 业务层： &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;  业务层用来，处理逻辑业务。一个业务一个类文件，业务类继承FacadeBase，而在Facadebase中集成了如：log4net，事务等功能。&lt;/p&gt;
&lt;p&gt;在后面的篇章中会详细介绍Facadebase。&lt;/p&gt;

&lt;p&gt;  命名规则为： “业务名Facade.cs”&lt;/p&gt;

&lt;p&gt;如下图：&lt;/p&gt;

&lt;div class=&quot;toclevel2&quot; data-toclevel=&quot;2&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/161176/201711/161176-20171127203720519-1650665047.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt; 我们的业务层，基本只返回bool类型。遵从面对对象的封装思想，就如同ATM机一样。只有一个插卡的“入口”，然后输入“参数“”密码&lt;/p&gt;
&lt;p&gt;最后只有一个“出口”，出钱出来。  业务层里面的方法没有特别要求命名规范，遵从驼峰命名法即可。&lt;/p&gt;



&lt;div class=&quot;toclevel2&quot; data-toclevel=&quot;2&quot; readability=&quot;54&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/161176/201711/161176-20171127210610112-1686320779.png&quot; alt=&quot;&quot;/&gt;

&lt;p&gt;这里，好多新人加入我们团队的时候就好奇这个事务居然不要在数据库中写，这个在后面的篇章中再详细讲，总而言之我们遵循一个原则：&lt;/p&gt;
&lt;p&gt;数据库的职责是做存储数据，我们尽可能不去把业务逻辑放在数据库中去处理。&lt;/p&gt;

&lt;p&gt;这里还出现了Alert()方法，这个也是从FacadeBase中继承而来，在调用业务Facade的时候，我们可能直接拿出Facade业务对象返还的Message错误信息。&lt;/p&gt;
&lt;p&gt;在后期的项目篇章中这个Alert() 会出现很多。 &lt;/p&gt;
&lt;p&gt;另外，这里我们也有一个写Facade业务的基础思想“水渠思想”，就像河水变成自来水的过程，要经过多到工序，有一步有问题我们就结束。&lt;/p&gt;
&lt;p&gt;所以，我们就一层层的判断。 但不是 用嵌套if去写， 而在if判断为false之后 直接return，为true 就执行下一步。&lt;/p&gt;
&lt;p&gt;（好比：“河水过滤失败，不能进行下一步，返回。过滤成功，下一步开始杀毒，杀毒失败返回，杀毒成功，开始氯洗····一直到最后成功”）&lt;/p&gt;
&lt;p&gt;中间每一笔以事务管理起来，失败就RollBack()，成功则Commit()。&lt;/p&gt;

&lt;p&gt;====================华丽的分隔线=====================&lt;/p&gt;
&lt;p&gt;项目 显示层：&lt;/p&gt;
&lt;p&gt;最后的显示层，以前我们用的是Asp.Net，我们会有TopPageBase基类 和 CommPageBase，TopPageBase没有验证登录信息，&lt;/p&gt;
&lt;p&gt;是给不需要登录的界面继承的，而继承了CommPageBase 的页面则必须要登录。 当然还有相应有很多前端插件，比如分页控件，日历控件等等。&lt;/p&gt;

&lt;p&gt;但是现在.net主要都是使用 .net MVC了。 所以我们单独也有一个程序集 Winner.FrameWork.Mvc.dll。  &lt;/p&gt;

&lt;p&gt;如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/161176/201711/161176-20171127212240503-211777257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;  自此也Winner框架的解决方案也就描述的差不多，我们前端没有形成自己的一套JS库，更多的还是使用第三方库。常规的JQuery 和 KnockOut&lt;/p&gt;
&lt;p&gt;我就不再做描述，这方面我个人也用的不好，在这方面Jason和阿jie 都非常厉害。&lt;/p&gt;

&lt;p&gt; 遗憾的是Winner框架 没有形成一套Winner前端的后台模板。相对Ace UI模板用的比较多，另外 &lt;span&gt;Amaze UI 也有一些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阿杰说他有写一套前端，目前在团队内部推广。如果没问题，我也希望Winner有自己的一套前端这样也能省很多事。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不过，我的终极想法是，代码生成器能直接生成前端，这样就更省事了。&lt;/p&gt;

&lt;p&gt;好吧，关于解决方案的命名和结构就写到这里。&lt;/p&gt;



&lt;/div&gt;













</description>
<pubDate>Mon, 27 Nov 2017 13:38:00 +0000</pubDate>
<dc:creator>Near_wen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/demon28/p/7905369.html</dc:identifier>
</item>
<item>
<title>Java数据结构和算法（一）——简介 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/7889153.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/7889153.html</guid>
<description>&lt;p&gt;　　本系列博客我们将学习数据结构和算法，为什么要学习数据结构和算法，这里我举个简单的例子。&lt;/p&gt;
&lt;p&gt;　　编程好比是一辆汽车，而数据结构和算法是汽车内部的变速箱。一个开车的人不懂变速箱的原理也是能开车的，同理一个不懂数据结构和算法的人也能编程。但是如果一个开车的人懂变速箱的原理，比如降低速度来获得更大的牵引力，或者通过降低牵引力来获得更快的行驶速度。那么爬坡时使用1档，便可以获得更大的牵引力；下坡时便使用低档限制车的行驶速度。回到编程而言，比如将一个班级的学生名字要临时存储在内存中，你会选择什么数据结构来存储，数组还是ArrayList，或者HashSet，或者别的数据结构。如果不懂数据结构的，可能随便选择一个容器来存储，也能完成所有的功能，但是后期如果随着学生数据量的增多，随便选择的数据结构肯定会存在性能问题，而一个懂数据结构和算法的人，在实际编程中会选择适当的数据结构来解决相应的问题，会极大的提高程序的性能。&lt;/p&gt;
&lt;h3&gt;1、数据结构&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;数据结构是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。&lt;/p&gt;
&lt;h4&gt;　　一、数据结构的基本功能&lt;/h4&gt;
&lt;p&gt;　　&lt;strong&gt;①、如何插入一条新的数据项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　②、如何寻找某一特定的数据项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　③、如何删除某一特定的数据项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　④、如何迭代的访问各个数据项，以便进行显示或其他操作&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;　　二、常用的数据结构&lt;/h4&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201711/1120165-20171124224517593-271461566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这几种结构优缺点如下：先有个大概印象，后面会详细讲解！！！&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201711/1120165-20171124223229656-408723583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、算法&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;算法简单来说就是解决问题的步骤。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Java中，算法通常都是由类的方法来实现的。前面的数据结构，比如链表为啥插入、删除快，而查找慢，平衡的二叉树插入、删除、查找都快，这都是实现这些数据结构的算法所造成的。后面我们讲的各种排序实现也是算法范畴的重要领域。&lt;/p&gt;
&lt;h4&gt;　　一&lt;strong&gt;、算法的五个特征&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;　　①、&lt;/strong&gt;&lt;code&gt;有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　②、&lt;/strong&gt;确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　③、&lt;/strong&gt;&lt;code&gt;可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　④、&lt;/strong&gt;有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　⑤、&lt;/strong&gt;&lt;code&gt;有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;　　二、算法的设计原则&lt;/h4&gt;
&lt;p&gt;　　&lt;strong&gt;①、正确性&lt;/strong&gt;：首先，算法应当满足以特定的“规则说明”方式给出的需求。其次，对算法是否“正确”的理解可以有以下四个层次：&lt;/p&gt;
&lt;p&gt;　　　　　　　　一、程序语法错误。&lt;/p&gt;
&lt;p&gt;　　　　　　　　二、程序对于几组输入数据能够得出满足需要的结果。&lt;/p&gt;
&lt;p&gt;　　　　　　　　三、程序对于精心选择的、典型、苛刻切带有刁难性的几组输入数据能够得出满足要求的结果。&lt;/p&gt;
&lt;p&gt;　　　　　　　　四、程序对于一切合法的输入数据都能得到满足要求的结果。&lt;/p&gt;
&lt;p&gt;　　　　　　　　PS：通常以第 三 层意义的正确性作为衡量一个算法是否合格的标准。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、可读性&lt;/strong&gt;：算法为了人的阅读与交流，其次才是计算机执行。因此算法应该易于人的理解；另一方面，晦涩难懂的程序易于隐藏较多的错误而难以调试。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、健壮性&lt;/strong&gt;：当输入的数据非法时，算法应当恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果。并且，处理出错的方法不应是中断程序执行，而是应当返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;④、高效率与低存储量需求&lt;/strong&gt;：通常算法效率值得是算法执行时间；存储量是指算法执行过程中所需要的最大存储空间，两者都与问题的规模有关。&lt;/p&gt;
&lt;p&gt;　　前面三点 正确性，可读性和健壮性相信都好理解。对于第四点算法的执行效率和存储量，我们知道比较算法的时候，可能会说“A算法比B算法快两倍”之类的话，但实际上这种说法没有任何意义。因为当数据项个数发生变化时，A算法和B算法的效率比例也会发生变化，比如数据项增加了50%，可能A算法比B算法快三倍，但是如果数据项减少了50%，可能A算法和B算法速度一样。所以描述算法的速度必须要和数据项的个数联系起来。也就是“大O”表示法，它是一种算法复杂度的相对表示方式，这里我简单介绍一下，后面会根据具体的算法来描述。&lt;/p&gt;
&lt;p&gt;　　相对(relative)：你只能比较相同的事物。你不能把一个做算数乘法的算法和排序整数列表的算法进行比较。但是，比较2个算法所做的算术操作（一个做乘法，一个做加法）将会告诉你一些有意义的东西；&lt;/p&gt;
&lt;p&gt;　　表示(representation)：大O(用它最简单的形式)把算法间的比较简化为了一个单一变量。这个变量的选择基于观察或假设。例如，排序算法之间的对比通常是基于比较操作(比较2个结点来决定这2个结点的相对顺序)。这里面就假设了比较操作的计算开销很大。但是，如果比较操作的计算开销不大，而交换操作的计算开销很大，又会怎么样呢？这就改变了先前的比较方式；&lt;/p&gt;
&lt;p&gt;　　复杂度(complexity)：如果排序10,000个元素花费了我1秒，那么排序1百万个元素会花多少时间？在这个例子里，复杂度就是相对其他东西的度量结果。&lt;/p&gt;
&lt;p&gt;　　然后我们在说说算法的存储量，包括：&lt;/p&gt;
&lt;p&gt;　　程序本身所占空间；&lt;/p&gt;
&lt;p&gt;　　输入数据所占空间；&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　辅助变量所占空间；&lt;/p&gt;
&lt;p&gt;　　一个算法的效率越高越好，而存储量是越低越好。&lt;/p&gt;
&lt;h3&gt;3、总结&lt;/h3&gt;
&lt;p&gt;　　本篇文章我们简单的介绍了数据结构和算法的概念，算法是解决问题的步骤，而数据结构的实现离不开算法，可能理解起来比较模糊，不用担心，后面我们会在具体的数据结构和算法实现过程中详细讲解。&lt;/p&gt;

</description>
<pubDate>Mon, 27 Nov 2017 13:36:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/7889153.html</dc:identifier>
</item>
<item>
<title>使用vue2.x+webpack+vuex+sass+axios+elementUI等快速搭建前端项目框架 - 黄大渣渣</title>
<link>http://www.cnblogs.com/superSmile/p/7905943.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/superSmile/p/7905943.html</guid>
<description>&lt;p&gt;一、本文将分享如何快速搭起基于webpack+vue的前端项目框架，利用vue的自己的脚手架工具vue-cli搭建起基本的环境配置，再通过npm包管理工具引入相应的依赖来完善项目的各种依赖框架。下面是具体实操。&lt;/p&gt;
&lt;p&gt;二、基本命令操作。&lt;/p&gt;
&lt;p&gt;1.在开发之前需要首先安装node.js，直接百度搜索或者在其中文官网也可以下载http://nodejs.cn/download/，&lt;/p&gt;
&lt;p&gt;在装完node之后npm包管理工具也自动的安装好，安装完之后，在命令行输入&lt;strong&gt;node -v&lt;/strong&gt;或者&lt;strong&gt;npm -v&lt;/strong&gt;，出现版本号说明安装成功。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240403/201711/1240403-20171127164046440-146338046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.在使用npm之前，最好把镜像换成淘宝的,长久使用，跑一下命令：&lt;strong&gt;npm config&lt;/strong&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;strong&gt;set registry https://registry&lt;/strong&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&lt;strong&gt;.npm&lt;/strong&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&lt;strong&gt;.taobao&lt;/strong&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&lt;strong&gt;.org&lt;/strong&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;替换成功后跑&lt;strong&gt;npm config get registry&lt;/strong&gt;命令显示淘宝镜像路径的话就代表替换成功。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240403/201711/1240403-20171127165430628-1338954265.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.第二步全局安装vue-cli，在命令窗口输入&lt;strong&gt;npm install -g vue-cli，&lt;/strong&gt;然后跑&lt;strong&gt;vue -V&lt;/strong&gt;出现版本号证明安装成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240403/201711/1240403-20171127170806175-877202799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.开始生成项目，在本地硬盘找一个目录存放代码，然后打开命令行cd切换到相应的路径下，然后跑 vue init webpack Vue-Project（项目名称）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vue init webpack Vue-Project（项目名称）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240403/201711/1240403-20171127175032878-120832025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.输入&lt;strong&gt;cd Vue-Project&lt;/strong&gt;  然后安装依赖&lt;strong&gt;npm install&lt;/strong&gt;, 如果平常时开发就跑&lt;strong&gt;npm run dev&lt;/strong&gt;(本地开发跑代码)，如果需要打包则跑&lt;strong&gt;npm run build&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240403/201711/1240403-20171127180157144-1704271602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.项目默认监听的是80端口，容易跟其他应用引起端口冲突，所以在项目下打开config文件夹，打开index.js，把端口改为8888，这样就避免冲突了，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240403/201711/1240403-20171127180718097-1632669108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.最后重新跑指令npm run dev   ,然后再地址栏输入http://localhost:8888,就会出现相应的页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240403/201711/1240403-20171127180944019-1890875647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、添加相应的框架以及依赖&lt;/p&gt;
&lt;p&gt;1.引入sass预编译工具加快编码速度，跑命令&lt;strong&gt;npm install node-sass --save-dev, npm install sass-loader --save-dev&lt;/strong&gt;,如果node-sass比较难装的话可以换成cnpm来下载依赖，具体可百度下做法。&lt;/p&gt;
&lt;p&gt;操作：&lt;/p&gt;
&lt;p&gt;在components目录下新建一个header的目录，新建两个文件header.vue  header.scss，然后引入到app.vue中使用，因为vue讲的是模块化开发，所以我喜欢把样式跟组件放到一个文件夹里跟其他模块区分，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240403/201711/1240403-20171127195732315-1119357360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;App.vue:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240403/201711/1240403-20171127195911269-1838590140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;header.scss:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240403/201711/1240403-20171127200023034-411877460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就证明sass 是安装成功了。&lt;/p&gt;
&lt;p&gt; 2.引入axios接口请求框架，跑命令&lt;strong&gt;npm install axios --save-dev,npm install qs;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 然后在src目录下新建一个http.js文件进行接口请求的相关配置，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;
import axios from &lt;/span&gt;'axios'&lt;span&gt;
import Qs from &lt;/span&gt;'qs'&lt;span&gt;;


&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance =&lt;span&gt; axios.create({
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;baseURL: 'https://some-domain.com/api/',&lt;/span&gt;
&lt;span&gt;  timeout: timeout,
  responseType: &lt;/span&gt;'json', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; default,&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;headers: {'apikey': 'foobar'},&lt;/span&gt;
    transformRequest:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data,headers){
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为了避免qs格式化时对内层对象的格式化先把内层的对象转为&lt;/span&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于使用的form-data传数据所以要格式化&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; data == 'string'&lt;span&gt;) {
        
            headers.post[&lt;/span&gt;'Content-Type'] = &quot;application/json; charset=utf-8&quot;&lt;span&gt;;
        
        }
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(!(data &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; FormData)){
      headers.post[&lt;/span&gt;'Content-Type'] = &quot;application/x-www-form-urlencoded&quot;&lt;span&gt;;
      
         &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data[key]===&lt;span&gt;undefined){
                data[key]&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
         }
         data &lt;/span&gt;=&lt;span&gt; Qs.stringify(data);
    }

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
    }
});
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; instance;  

Vue.prototype.$http&lt;/span&gt;=instance;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在使用请求接口的时候直接可以这样用：(具体用法可以看下官方文档)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.$http.get(url).then((res)=&amp;gt;&lt;span&gt;{
}）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.引入elementUI，跟人感觉elementUI是比较好用的vue组件UI，很多东西不用自己去写，推荐使用，跑指令&lt;strong&gt;npm install element-ui --save,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后在main.js中引入使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;
import ElementUI from &lt;/span&gt;'element-ui'&lt;span&gt;
import &lt;/span&gt;'element-ui/lib/theme-chalk/index.css'&lt;span&gt;
import App from &lt;/span&gt;'./App.vue'&lt;span&gt;

Vue.use(ElementUI)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然也可以按需引入，想用什么组件就引入什么组件，不要全部引入，这样减少体积。&lt;/p&gt;
&lt;p&gt;4.引入vuex&lt;/p&gt;
&lt;p&gt;Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&lt;/p&gt;
&lt;p&gt;安装：&lt;span class=&quot;token function&quot;&gt;npm &lt;span class=&quot;token function&quot;&gt;install vuex --save&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;具体使用这里不做详细介绍，感兴趣的可以看下中文官网：https://vuex.vuejs.org/zh-cn/。&lt;/p&gt;
</description>
<pubDate>Mon, 27 Nov 2017 13:34:00 +0000</pubDate>
<dc:creator>黄大渣渣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/superSmile/p/7905943.html</dc:identifier>
</item>
<item>
<title>Spring学习笔记(二)之装配Bean - 熬过今夜还有明天</title>
<link>http://www.cnblogs.com/daweige/p/7905990.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daweige/p/7905990.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一,介绍Bean的装配机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Spring中,容器负责对象的创建并通过DI来协调对象之间的关系.但是我们要告诉Spring创建哪些Bean并且如何将其装配在一起.,装配wiring就是DI依赖注入的本质. &lt;/p&gt;
&lt;p&gt;Spring装配bean有几种机制:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在XML中进行显式配置&lt;/li&gt;
&lt;li&gt;在Java中进行显式配置&lt;/li&gt;
&lt;li&gt;隐式的bean发现机制和自动装配&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三种机制可能会给我们选择上造成困扰?哪个好?是不是不同情况有不同的选择? &lt;/p&gt;
&lt;p&gt;答:会在很多场景下,选择哪种机制完全取决于个人的喜好,但是我推荐用自动装配,可以自动装配我们为什么还要费力气去配置.而且三种机制可以互相搭配,你可以用XML装配一些Bean,使用Spring基于Java的配置(JavaConfig)来装配另一些Bean,剩余的bean让Spring去自动发现装配.&lt;/p&gt;
&lt;p&gt;但是,尽可能的用自动装配,显式装配越少越好.当不得不显式装配的时候(比如,有些源码不是你来维护的,但你要为这些代码配置bean的时候),推荐使用JavaConfig,因为他XML更安全更强大.只有在你想用XML的命名空间,并且在JavaConfig中没有同样的实现,才选择XML.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二.自动化装配Bean&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring从两个方面实现自动装配:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;组件扫描(component scanning):Spring会自动发现应用上下文所创建的bean.&lt;/li&gt;
&lt;li&gt;自动装配(Autowiring):Spring会自动满足bean之间的依赖.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;组件扫描和自动装配组合在一起能完美的降级显式配置.&lt;/p&gt;
&lt;p&gt;举例:创建一个动物类animal,Spring会发现并将它创建成一个bean.在创建一个people类,并将animal类注入进来.&lt;/p&gt;
&lt;p&gt;1.先创建一个动物接口,定义了有个play方法 用面向接口的方法能松耦.接口的内容并不重要&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;make an animal interface&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;pack test;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Animal{
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; play():
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.创建一个动物的实现类,可以多个实现.(用到了Component注解)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@Component  
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; dog &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Animal{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   
&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; String title = ''wang wang wang ....''&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; String boy =&quot;hahahahha&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; play(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    System.out.println(&quot;dog&quot;+title+&quot;boy&quot;+&lt;span&gt;boy);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@Component注解的意思是:标明该类会作为组件类,并告知Spring要为这个类创建bean.不需要配置XML或者JavaConfig.&lt;/p&gt;
&lt;p&gt;但是我们还要启动组件扫描,因为组件扫描默认是不启用的. 所以需要显式的配合Spring,让他去寻找带有@Component的类,并为其创建Bean.&lt;/p&gt;
&lt;p&gt;3.&lt;/p&gt;
&lt;p&gt;3.1创建组件扫描的配置类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;@ComponentScan
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DogConfig{
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个类通过Java代码定义了Spring 的装配规则,并没有显式的声明任何bean.因为他使用了@ComponentScan注解&lt;br/&gt;@ComponentScan能在Spring中启用组件扫描,还会默认扫描与配配置类相同包下带有@Component注解的类并创建一个bean.&lt;/p&gt;
&lt;p&gt;3.2还有一种开启组件扫描的配置时利用XML,原理是使用Spring context命名空间的&amp;lt;context:component-scan&amp;gt;元素.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&lt;span&gt;3&lt;/span&gt;     xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
&lt;span&gt;4&lt;/span&gt;     xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
&lt;span&gt;5&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt;    &amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt; = &quot;test&quot;/&amp;gt;
&lt;span&gt;9&lt;/span&gt; &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三 为组件扫描的bean命名&lt;br/&gt;Spring应用上下文中所有的bean都会有一个ID.如果没有明确那么ID则是类名首字母小写.当然我们也可以认为的设置一个自己中意的ID,我们要做的就是讲ID作为值传递给@Component注解,比如我想为Dog类创建ID为gouzi :&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@Component(&quot;gouzi&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Animal{
   ...
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;huozhe  yong @Named &lt;/span&gt;
&lt;span&gt;
@Named(&lt;/span&gt;&quot;gouzi&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Animal{
   ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四.设置组件扫描的基础包&lt;br/&gt;我们之前说了@ComponentScan注解会默认扫描当前包及其子包下的带有@Component注解的类并为其创建一个bean. 但是事实上我们是可以指定的.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Cnfiguration
@ComponentScan(&lt;/span&gt;&quot;Dog&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DogConfig{

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;huozhe &lt;/span&gt;
&lt;span&gt;
@Cnfiguration
@ComponentScan(basePackages&lt;/span&gt;=&quot;Dog&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DogConfig{

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;huozhe&lt;/span&gt;
&lt;span&gt;@Cnfiguration
@ComponentScan(basePackages&lt;/span&gt;={&quot;Dog&quot;,&quot;Cat&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DogConfig{

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是以String类型的基础包在代码重构的情况下是不安全的.所以我们用@ComponentScan提供的另外一种方法,就是将其指定为包中所含的类或接口.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Cnfiguration
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; @ComponentScan(basePackageClasses={Dog.class,Cat.class&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DogConfig{
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;五,通过bean添加注解实现自动装配&lt;br/&gt;上面我们学会了怎么将类设置为扫描类,让容器对对象的生老病死负责,但是他们仍然一个个是独立的,怎么让对象之间的相互依赖达成呢?  这就要用到自动注入:将组建扫描得到的Bean和他们的依赖装配在一起.&lt;/p&gt;
&lt;p&gt;在自动装配的过程中,会在spring应用上下文中寻找匹配某个bean需求的其他Bean.然后用@Autowired声明.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@Component  
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Animal{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Dog dog;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dog(Dog dog){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;this&lt;/span&gt;.dog =&lt;span&gt;  dog;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; play(){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     dog.play(;)  
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这表名当Spring在创建DogBean的时候,会通过构造器来进行实例化并且会传入一个可设置的Dog类型bean.&lt;br/&gt;@Autowired注解不仅能够用在构造器上,还能用在setter方法上.比如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDog(Dog dog){
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dog =&lt;span&gt; dog;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@Autowired注解可以用在构造方法,成员属性和其他方法,Spring都会满足参数上所声明的依赖,为防止在应用上下文创建的时候匹配不到bean二报错. 我们可以将@Autowired的required属性设置为false;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @Autowired(required=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDog(Dog dog){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;this&lt;/span&gt;.dog =&lt;span&gt; dog;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是要谨慎的运用required属性,因为如果自动装配没有匹配到bean,并且没有进行null判断会报空指针.&lt;/p&gt;
&lt;p&gt;@Autowired是Spring独有的注解. 可以用@Injecgt注解去取代. &lt;/p&gt;
&lt;p&gt;@Inject和@Named注解都来源于JAva依赖注入规范.&lt;/p&gt;
&lt;p&gt;到此通过组件扫描和自动扫描的基础知识我们已经了解了&lt;/p&gt;
&lt;p&gt;明天会学习通过Java代码装配bean,xml配置装配bean.&lt;/p&gt;

</description>
<pubDate>Mon, 27 Nov 2017 12:44:00 +0000</pubDate>
<dc:creator>熬过今夜还有明天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daweige/p/7905990.html</dc:identifier>
</item>
</channel>
</rss>