<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>从劳动价值到货币再到比特币，从原始社会到“社会大同” - 深蓝医生</title>
<link>http://www.cnblogs.com/bluedoctor/p/8439256.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bluedoctor/p/8439256.html</guid>
<description>&lt;h2&gt;由GDP的笑话说起&lt;/h2&gt;
&lt;p&gt;今天，无意中看了《区块链根本不怕BAT!》这篇文章，他说到：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
按劳分配有一个最大的问题：每个人的贡献值是很难衡量的。随着区块链的出现和应用，将会打开一个新的局面。
区块链是一种分布式、透明的的记账模式，就可以非常公平、公正、透明的衡量出每一个人做出的贡献值，而且是不可篡改的，让分配不公这个事情被解决掉。

所以，我认为马克思在《资本论》中的论述是正确的，但是缺区块链技术。区块链技术可以真正实现按劳分配，挑战传统不公平的公司制度，&lt;br/&gt;让每个人既是员工又是高管又是顾客，三位一体，完全打通。它干掉了资本家，没人获取剩余价值。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;作者还有一个问题，使我陷入了沉思：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
作为消费者，我也属于这个经济体的参与者，我也应该获得更大的价值。

比如说，我每天去汉堡店消费，汉堡店赚了好多钱，然后上市，但是这跟我一点关系也没有，消费者的钱都被老板、股东赚走了，这是很不公平的。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这让我想起了一个笑话：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
两个老板在一起打赌：
A老板:“你要是能够把地上这块狗屎吃了，我立马给你500万。”
于是B老板真捡起地上的狗屎吃了，向A老板索要500万。
A老板气的脸红了，这500万买一块狗屎不值啊，于是自己也捡起地上的一块狗屎吃了，对B老板说：
“500万给你了”！
B老板不依不饶，两个人争吵不休。
这时候路过一个经济学家，他对两个老板说：
“哎呀，二位老板你们贡献了1000万的GDP,了不起啊！”
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 当然，笑话到此，我就继续演绎下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
旁边一个围观的小孩，大声笑道：
“原来GDP就是狗屎啊”！

两个老板和经济学家的脸都红了。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;笑话归笑话，但这个笑话真实的表示了GDP的特点，先看看&lt;a href=&quot;https://baike.baidu.com/item/%E5%9B%BD%E5%86%85%E7%94%9F%E4%BA%A7%E6%80%BB%E5%80%BC/31864?fromtitle=GDP&amp;amp;fromid=41201&quot; target=&quot;_blank&quot;&gt;百科定义&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
GDP(国内生产总值):是指一个国家(或地区)所有常住单位在一定时期内生产的全部最终产品和服务价值的总和，常被认为是衡量国家(或地区)经济状况的指标。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;概念比较抽象，但我们注意到概念分析的第四点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
第四，GDP是计算期内生产的最终产品价值，因而是流量而不是存量。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到这里说的是流量而不是存量，笑话里面的老板虽然最终没有赚到钱，但却实打实的进行了2次价值流动，的确像经济学家说的，产生了1000万的GDP。而这个1000万，说到就是1000万的货币单位，可能大家都会对这个经济学家说的GDP感到好笑，而我认为，产生这个荒唐结果的原因，就是价值的度量形式--货币，并不是一种最佳的形式。&lt;/p&gt;
&lt;h2&gt;价值与价格，劳动价值论的对错&lt;/h2&gt;
&lt;p&gt;货币对价值的度量，就是我们常说的“价格”，价格和价值就在供需关系之间进行浮动了，正是这种浮动，助长了人们的投机，脱离了劳动产生价值这个最初价值来源，才会有“著名经济学家”茅于轼公开否认马克思的价值理论，说“交换产生价值”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;amp;quality=100&amp;amp;size=b4000_4000&amp;amp;sec=1518256468&amp;amp;di=d2fc355338457f4b9088eb998e6566ea&amp;amp;src=http://img.jrjimg.cn/2016/09/20160909170631838.jpg&quot; alt=&quot;价格价值曲线&quot; width=&quot;433&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;

&lt;p&gt;马克思的劳动价值论真错了吗？&lt;/p&gt;
&lt;p&gt;我认为马克思说的没错，他的伟大之处就是发现了这个理论，但是货币度量价值的方式使得人们对劳动产生价值的理论产生怀疑，于至于茅于轼这样的人都成了著名经济学家。&lt;/p&gt;
&lt;p&gt;要澄清这个误区，我们需要一种新的方式来表示价值，而不是传统的货币，而在这之前，有必要先明确我们讨论的关键词：价值。&lt;/p&gt;
&lt;p&gt;参看&lt;a href=&quot;https://baike.baidu.com/item/%E4%BB%B7%E5%80%BC/12756902?fr=aladdin&quot; target=&quot;_blank&quot;&gt;百科词条&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
按照马克思主义政治经济学的观点，价值就是凝结在商品中无差别的人类劳动，即商品价值。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里提到了一句话：无差别的人类劳动，在现在还不是大规模智能机器人劳动的时代，我简化为“无差别劳动”，也就是价值的表现为无差别的劳动，或者说价值来源于劳动，也就是马克思的“&lt;a href=&quot;https://baike.baidu.com/item/%E9%A9%AC%E5%85%8B%E6%80%9D%E5%8A%B3%E5%8A%A8%E4%BB%B7%E5%80%BC%E7%90%86%E8%AE%BA/14111881&quot; target=&quot;_blank&quot;&gt;劳动价值论&lt;/a&gt;”,它是马克思主义价值学说的最一般的基础部分。&lt;/p&gt;&lt;p&gt;马克思的劳动价值论，让那些“不劳而获”的剥削阶层很惊恐，从而在无产阶级和资产阶级之间产生了意识形态上的对立。历史证明，知识分子从来就不是一个独立的阶层，那么依附于资产阶级的知识分子著书立说，否定劳动价值论，进而否定马克思的整个理论，就不足为奇了。当人们谈论起苏联的解体，以及其它社会主义实践中遇到的巨大问题，都要怪罪于马克思了。而今天，社会和科技的进步，可能让老马的劳动价值论沉冤昭雪，因为现在有一种技术，可以解决价值的度量问题，那就是区块链。&lt;/p&gt;
&lt;p&gt;在回到前面的一句话，价值表现为无差别的劳动，但这种无差别劳动怎么表示呢？&lt;/p&gt;

&lt;h2&gt;实物货币时代&lt;/h2&gt;
&lt;p&gt;劳动是人类社会特有的行为，自从发明了工具就表明了人来与动物有了本质区别，而使用工具来劳动，从事生产生活活动，并产生劳动成果。随着生产力的提高，劳动成果有了富裕，并且有别的人需要你的劳动成果，于是有了最原始的交易，人类社会进入了“以物易物”的时代。比如我织一块布，交换你打猎得到的一只兔子。后来，人民觉得这种直接的“以物易物”不仅不方便，而且不太公平：（假设）我织一块布需要花费3天时间，而你这只兔子是你睡觉捡到的（守株待兔），顶多算半天功夫。但是我这块布或者你的兔子又不好分割，所以交易出现了僵局。&lt;/p&gt;
&lt;p&gt;这时候一个聪明人说：我有从东海捡回来的贝壳，很稀有，很好看，你把你的布拿我这里来换10个贝壳，然后你再跟猎人商量下给他几个贝壳可以换换他的兔子。于是卖布人高兴的换到了自己想要的兔子，而猎人也高兴的换到了自己需要的布。&lt;/p&gt;
&lt;p&gt;再后来，交易市场的交易媒介物从贝壳，变成了好看的石头，又变成了银子，金子，最后，变成了纸币直到现在。这些东西，就是我们常说的货币。&lt;/p&gt;
&lt;h2&gt;信用货币时代&lt;/h2&gt;
&lt;p&gt;前面说到原始社会的商品交易使用了稀有的贝壳作为货币，不管后来是石头，还是银子，金子，它们都有一个特点：稀有。而为何后来可以用纸币来做货币呢？原来，纸币是一种信用货币，最早的纸币是南宋的交子，参看&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%A4%E5%AD%90&quot; target=&quot;_blank&quot;&gt;百科词条&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
交子，是发行于北宋于仁宗天圣元年(1023年)的货币，曾作为官方法定的货币流通，称作“官交子”，在四川境内流通近80年。交子是中国古代劳动人民的重要发明，&lt;br/&gt;是中国最早由政府正式发行的纸币，也被认为是世界上最早使用的纸币，比美国（1692年）、法国（1716年）等西方国家发行纸币要早六七百年。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实在交子诞生之前，就已经有很多钱庄发行流通自己的“银票”了，即客人拿着某著名钱庄的银票，可以随时来兑换真金白银；而钱庄发行的银票是以钱庄实际现有的真金白银为依据的，不能超发，否则出现挤兑现象钱庄就会破产。因此，银票代表的是钱庄的信用，随着银票的广泛使用，大小不同的钱庄无法直接流通，并且信用也不相同，那么此时政府出面公开发行一种统一的银票，以政府的官银为发现银票的依据，这样，纸币就产生了。&lt;/p&gt;
&lt;p&gt;纸币的出现标志着货币从实物货币时代进入了信用货币时代。随着硬刷技术的成熟，纸币防伪技术出现并且大量商品交易的需求，使得在近代世界主要国家都发行了自己的官方纸币，比如美国的美元，德国马克和中国民国政府发行的法币。&lt;/p&gt;

&lt;h2&gt;“布雷顿森林体系”的破产&lt;/h2&gt;
&lt;p&gt;二战后，美国成为了世界上实力最强大的国家，建立了以美元为中心的国际货币体系，史称“布雷顿森林体系”。参见&lt;a href=&quot;https://baike.baidu.com/item/%E5%B8%83%E9%9B%B7%E9%A1%BF%E6%A3%AE%E6%9E%97%E4%BD%93%E7%B3%BB/1952162?fr=aladdin&quot; target=&quot;_blank&quot;&gt;百科词条&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1944年7月，西方主要国家的代表在联合国国际货币金融会议上确立了该体系，因为此次会议是在美国新罕布什尔州布雷顿森林举行的，所以称之为“布雷顿森林体系。&lt;br/&gt;”关税总协定作为1944年布雷顿森林会议的补充，连同布雷顿森林会议通过的各项协定，统称为“布雷顿森林体系”，即以外汇自由化、资本自由化和贸易自由化为主要内容的&lt;br/&gt;多边经济制度，构成资本主义集团的核心内容。
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;“布雷顿森林体系”的确立最重要的一点就是美元与黄金挂钩，其它国家货币与美元挂钩，实行可调整的固定汇率。&lt;/p&gt;
&lt;p&gt;布雷顿森林体系的建立，促进了战后资本主义世界经济的恢复和发展。因美元危机与美国经济危机的频繁爆发，以及制度本身不可解脱的矛盾性，该体系于1971年被尼克松政府宣告结束。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
20世纪60～70年代，美国深陷越南战争的泥潭，财政赤字巨大，国际收入情况恶化，美元的信誉受到冲击，爆发了多次美元危机。1971年12月以《史密森协定》为标志，&lt;br/&gt;美元对黄金贬值，美联储拒绝向国外中央银行出售黄金。至此，美元与黄金挂钩的体制名存实亡，“布雷顿森林体系”宣告破产。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;布雷顿森林体系的破产，各国货币的发行均与黄金脱钩，世界货币全面进入了信用扩张时代，此时的纸币已经不是单纯意义上的信用货币了，更多的跟国家的综合实力相关，所以虽然布雷顿森林体系的破产，美元仍然是世界主要货币。&lt;/p&gt;
&lt;p&gt;所以布雷顿森林体系的破产的原因就是货币的信用扩张，而信用的扩张又导致了各种金融衍生品的产生，催生了各种疯狂的投机和炒作，各种投机标的，从黄金到石油，从石油到房地产，从房地产到互联网。在信用扩张的过程中，世界上产生了天量的货币，一些国家和地区这几十年累积了很大的通货膨胀，各国政府都通过有意无意的通胀来促进经济的发展，而通胀又是一个恶魔，通胀严重泡沫破裂财富被洗劫一空。美国政府通过发行美元，向世界其他国家征收“铸币税”，转嫁通胀，收割利益，比如与日本签订《广场协议》刺破日本房地产；国际炒家疯狂炒作东南亚国家资产，引发东南亚经济危机；以至于到后来，爆发了次贷危机，引发全世界金融动荡，加剧了各国的贫富差距，并引起了地区政治和军事危机。&lt;/p&gt;
&lt;h2&gt;金融危机的本质是货币的信用危机&lt;/h2&gt;
&lt;p&gt;从第一个信用货币--交子的诞生，到现在已经1000多年了，既然信用货币如此先进为何中国在长达1000年的时间内没有推广使用纸币而仍然大量使用黄金白银？可能我们的老祖宗早就明白任何信用货币都有它没有信用的时候，还是真金白银实在。现在信用扩张的时代，货币（纸币）大量发行，一次又一次的引发了金融危机而且影响范围越来越大，债务越来越多，发行美元的美国居然成为了世界上最大的债务国，以至于连&lt;a href=&quot;https://tieba.baidu.com/p/2215889966?red_tag=0275121500&quot; target=&quot;_blank&quot;&gt;美国的小学生都来问股神巴菲特&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
在老巴子的年会上，老巴子说：“我们美国的经济就是借钱经济，借全世界的钱推动我们的经济”&lt;br/&gt;一小孩道：“巴菲特爷爷，你说美国的经济就是向别人借钱的经济，那你们借的钱将来不是要我们还吗？”&lt;br/&gt;老巴子意味深长的道：“孩子，好好学习，我们借的钱让你们的孙子替你还。”
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不管这个笑话是不是杜撰的，但是这里巴菲特说出了美国经济以及世界经济的本质：&lt;/p&gt;
&lt;p&gt;美国印刷美元去其它国家买商品-》其它国家生产商品-》其它国家出口商品换取美元-》用美元去其他国家购买商品-》美国发现国债-》其它国家购买美国国债（表现为美国向其它国家借钱）-》美元回流美国。&lt;/p&gt;
&lt;p&gt;现在经济全球化，而美元又是全球主要货币，资本家为了赚取更多的美元，最后结果必然是美国要“借”更多的钱，比如中国就买了美国3万亿以上的美国国债。美国在全世界的债务使得美国每年的GDP都不够还利息，甚至搞得美国政府每过几年就要“关几天门”，出现了这个世界上最奇怪，最荒唐的事情：&lt;/p&gt;
&lt;p&gt;世界上最富裕的国家向最穷的国家借钱！&lt;/p&gt;
&lt;p&gt;所以，美国经济的本质上是在透支美国的信用，美国人习惯了借钱过日子，所以美国必须维持强大的军力和发展科技实力来确保美元的信用，有句话说发展中国家借钱给美国打仗一点不为过。但是，强势美元也是一个双刃剑，既然美元可以便宜的买到世界上的所有商品那么为何要美国自己制造呢？所以结果就是美国实体经济空心化，美国普通老百姓工作机会减少，失业率增加，并且移民人口加剧了这个问题，最终很多低收入美国人的收入不足于支付高额的债务，2008年次贷危机爆发，引发全世界的金融危机，并且引发了“占领华尔街运动”，提出口号“我们才是那99%”。&lt;/p&gt;
&lt;p&gt;真是成也萧何拜也萧何！&lt;/p&gt;
&lt;p&gt;奥巴马政府为了解决问题花了纳税人巨额的的钱，幸亏中国的四万亿计划有力的扩充了世界的需求，拯救了世界经济，美国经济才开始复苏。新任美国总统特朗普提出了“让美国再次伟大”的口号，提出“美国优先”政策，进行减税，推行弱势美元政策，在全世界造麻烦，努力驱使美元回流。特朗普能否成功，拭目以待。&lt;/p&gt;
&lt;p&gt;上面的例子说明了美元信用的无限扩张导致了美国次贷危机并引发了全世界的金融危机，所以可以说金融危机的本质就是货币的信用危机。&lt;/p&gt;
&lt;p&gt;那么让现行货币体制重回“信用货币”时代是否可行呢？&lt;/p&gt;
&lt;p&gt;目前，世界其它经济体纷纷在尝试这个可能性，比如增加黄金储备，比如建立石油货币，但实际上自2008年金融危机之后到现在已经10年了，这些努力并不明显，而且自上次10年后，全球主要国家的债务不仅没有减少，而且更大了。&lt;span&gt;国际金融学会IIF在其最近的年报中指出，&lt;strong&gt;全球的名义债务规模已经上升至历史新高217万亿美元，相当于全球&lt;/strong&gt;&lt;strong&gt;GDP 的327%&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://5b0988e595225.cdn.sohucs.com/images/20170922/2fcc6942cbd1491aa8634c06e2bc6919.jpeg&quot; alt=&quot;&quot; width=&quot;492&quot; height=&quot;337&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（&lt;a href=&quot;http://www.sohu.com/a/193723815_99911517&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;如此巨大的且在不断增长的债务规模像滚雪球一样，迫使货币超发成为各国政府最现实的选择，而过多的货币又引起明显的通货膨胀，人们持有货币的信心不足，大量投机，又催生出更大的资产泡沫，为了维持泡沫又需要借更多的钱，通胀与债务如同一对孪生兄弟如影形随。按理说如果黄金作为普通商品在通胀作用下黄金价格也应该一直上涨，但事实上世界上主要国家一直打压黄金价格，以现有的黄金储备所能折算的总价值显然无法达到这种增长规模，所以世界货币重回“金本位”不具有现实意义。另外，就算挤出泡沫，全世界工业生产的价值也无法使用黄金等贵金属来表示，毕竟储量有限，所以说布雷顿森体系的破产是有必然性，世界需要新的货币体系来解决货币的信用问题，&lt;a href=&quot;https://baike.baidu.com/item/%E6%AF%94%E7%89%B9%E5%B8%81/4143690?fr=aladdin&quot; target=&quot;_blank&quot;&gt;比特币&lt;/a&gt;在这个背景下诞生。&lt;/p&gt;

&lt;h2&gt;比特币能成为新的货币吗？&lt;/h2&gt;
&lt;div class=&quot;para&quot; readability=&quot;8.3622047244094&quot;&gt;2008年爆发全球金融危机，当时有人用“&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%AD%E6%9C%AC%E8%81%AA&quot; target=&quot;_blank&quot;&gt;中本聪&lt;/a&gt;”的化名发表了一篇论文，描述了比特币的模式。&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;album-wrap&quot;&gt;&lt;img class=&quot;picture&quot; src=&quot;https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=1f531876d309b3deefbfe36afcbf6cd3/7c1ed21b0ef41bd5e47357ea53da81cb39db3d8f.jpg&quot; alt=&quot;比特币&quot;/&gt;&lt;/div&gt;
&lt;p&gt;比特币和法定货币相比，比特币没有一个集中的发行方，而是由网络节点的计算生成，谁都有可能参与制造比特币，而且可以全世界流通，可以在任意一台接入互联网的电脑上买卖，不管身处何方，任何人都可以挖掘、购买、出售或收取比特币，并且在交易过程中外人无法辨认用户身份信息。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;2009年，不受央行和任何金融机构控制的比特币诞生。&lt;/p&gt;
&lt;p&gt;2014年9月9日，美国电商巨头&lt;a href=&quot;https://baike.baidu.com/item/eBay&quot; target=&quot;_blank&quot;&gt;eBay&lt;/a&gt;宣布，该公司旗下支付处理子公司Braintree将开始接受比特币支付。&lt;/p&gt;
&lt;p&gt;2017年1月24日中午12：00起，中国三大比特币平台正式开始收取交易费。 &lt;/p&gt;
&lt;p&gt;2017年5月5日，OKCoin币行网的最新数据显示，比特币的价格刚刚再度刷新历史，触及9222点高位，同时比特币等各种数字加密资产也出现空前的泡沫。&lt;/p&gt;
&lt;p&gt;2017年9月4日，中国央行等7个部门联合发文叫停各类ICO融资，代币市场开始暴跌。&lt;/p&gt;
&lt;p&gt;一个市场现象值得留意，即今年以来，虚拟货币市场和美国股市先后见顶，并出现雪崩式下跌。正如著名经济学家易宪容所说，比特币价格的暴涨暴跌，决定其不可能成为货币。比特币及其他加密数字货币没有人或组织给它的信用担保，而成了少数人操纵及过度炒作的工具。加上目前区块链技术的缺陷，从而对这种加密数字货币的炒作所面临的风险会越来越大，甚至可能冲击现有的金融市场。&lt;/p&gt;
&lt;h2&gt;比特币的背后--区块链&lt;/h2&gt;
&lt;p&gt; 区块链技术（Blockchain）是比特币（Bitcoin）的底层技术，区块链是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了一次比特币网络交易的信息，用于验证其信息的有效性（防伪）和生成下一个区块。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;区块组成&quot; src=&quot;https://xqimg.imedao.com/156d968487c3573fedb88e98.jpg!custom660.jpg&quot; alt=&quot;区块链区块内容&quot; width=&quot;660&quot; height=&quot;190&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;区块链是比特币原创的核心技术。在比特币被发明之前，世界上并不存在区块链这个东西。比特币发明之后，很多人参考比特币中的区块链实现，使用类似的技术实现各种应用，这类技术统称区块链技术。用区块链技术实现的各种链即为区块链。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区块链技术解决什么问题&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;如果说互联网技术解决了人类的信息获取问题，那边区块链技术则解决了人类之间的信任问题。&lt;p&gt;作者：书生老徐&lt;br/&gt;链接：http://xueqiu.com/2466651802/74232849&lt;br/&gt;来源：雪球&lt;br/&gt;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt; 如果说互联网技术解决了人类的信息获取问题，那么区块链技术则解决了人类之间的信任问题。&lt;/p&gt;
&lt;p&gt;有关比特币和区块链技术更多内容 ，可以参考书生老徐这篇文章：《&lt;a href=&quot;http://xueqiu.com/2466651802/74232849&quot; target=&quot;_blank&quot;&gt;一文看懂比特币和区块链&lt;/a&gt;》。&lt;/p&gt;
&lt;h2&gt;比特币等虚拟币不是一般等价物&lt;/h2&gt;
&lt;p&gt;实物货币，比如黄金，白银，都是商品价值的一般等价物，早期的纸币由政府依据黄金储备决定纸币代表的价值，在黄金储备不变，纸币发信过多自然纸币贬值，引发通货膨胀，所以政府一般不敢过度发行纸币，这个时期的纸币是具有一般等价物这种信用的，是信用货币。然后布雷顿森体系的破产，货币发行与黄金储备脱钩，信用扩张，债务膨胀，引发较高的通胀率，纸币信用不断下降，比较极端的例子就是津巴布韦本国货币信用已经破产，不得不宣布允许美元等多种外国货币在津巴布韦流通。而其他国家的货币还有政府信用担保所以这些货币也是有信用的。但是，目前比特币等虚拟数字币没有任何国家或组织担保，它没有任何真正的信用，所以它们不是一般等价物。&lt;/p&gt;
&lt;p&gt;前面说区块链技术解决了人类之间的信用问题，那为何这里还是要说以它为基础的比特币等虚拟数字币没有信用呢？&lt;/p&gt;
&lt;p&gt;其实，这是两个层面的问题，前者讲的是交易的信用，也就是确认发生了这样一笔交易，交易方无法反悔，否认这个交易的存在。而后者讲的是比特币等虚拟币，第一它不是实物，本身没有任何价值；第二它没有任何国家或组织的信用担保。这两点，使得&lt;strong&gt;比特币等虚拟币没有作为一般等价物的信用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而第三点，很少有人讲，就是&lt;strong&gt;比特币等虚拟币没有真正包含“无差别的人类劳动”&lt;/strong&gt;，它是计算机计算出来的，生产比特币需要“挖矿”,消耗的是“算力”，而不是“人力”，因而，比特币等虚拟币是没有价值的。&lt;/p&gt;

&lt;h2&gt;从红军币到石油美元--从黄金储备到物资储备的货币信用&lt;/h2&gt;
&lt;p&gt;前面说到现代国家的主权货币发行在布雷顿森体系崩溃之前，都是以黄金储备来发行的。在这之后，货币发行跟黄金脱钩之后，货币的信用又是如何保证的呢？其实，早在布雷顿森会议之前，我国的红军就曾经实验过以“物资储备”为信用基础发行使用红军币的“金融创新”。这种货币是在完全没有金银、外汇作储备的情况下，保持了币值和物价的稳定，这在当时世界上普遍采用以黄金储备来发行货币的潮流下，显得是那么的惊世骇俗…&lt;/p&gt;
&lt;p&gt;当年的红军开始长征。苏区的中央银行也在长征的队伍中。红军长征到达遵义时，当时的遵义约十几万人口，是长征途中较为富裕的地区。红军准备利用在遵义停留的机会，补充各种给养。红军的银行可以自己印刷“红军币”，可以用它向百姓购买物资。然而，遵义并非苏区根据地，老百姓不愿收“红军币”……&lt;br/&gt;怎么办？红军银行通过调查得知，遵义地区的食盐非常昂贵，原因是，食盐供应被几个大财主垄断了。红军便采取了最拿手的“打土豪”政策，没收了大财主的食盐，在遵义市到处贴出布告“红军以低廉的价格大量供应食盐”。这个举措满足了当地绝大多数百姓的需要，因而也深得人心。但是，红军银行的布告同时指出，只有用“红军币”才能购买食盐……百姓们便踊跃将自己的粮食、布匹等物资卖给红军，换取“红军币”，再去购买食盐。红军由此得到了充足的给养补充。&lt;/p&gt;&lt;p&gt;再回过来看看当年蒋介石政府在49年前败走大陆在货币政策上的失误，法币严重通胀，于是废除法币收纳黄金储备，发行金圆券，结果很快金圆券就崩溃了，一文不值。老蒋手下的欧美留学生，始终没搞明白一个剑桥、哈佛不会在课堂上教给他们的道理——光有黄金白银、美元外汇作抵押，但同时没有相匹配数量的生活物资、生产资料、工业品、农产品作为对应，货币依然只是一张印了数字符号的纸而已，不具备任何意义……老百姓过日子需要的是柴米油盐酱醋茶，不是黄金白银，不是美元外汇，这些东西都不能吃、不能用，能换取到柴米油盐酱醋茶、耕牛、火柴的纸币，在老百姓眼里才有信誉，发行它的政府才有威信，发生战争的时候，为这样有威信的政府去流血牺牲才值得……&lt;/p&gt;&lt;p&gt;以上详细内容，可以看看《&lt;a href=&quot;http://bbs.tiexue.net/post2_11450702_1.html&quot; target=&quot;_blank&quot;&gt;红军币是如何干掉法币的&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;这个政策是不是看上去很眼熟啊？？？它简直与与今天美国的货币政策一模一样。美国说服中东产油国，决定用美元结算石油，实际上就是制造市场对美元的需求，大家都需要美元，便用自己的产品换得美元，再去购买石油……这就是石油美元模式。&lt;/p&gt;
&lt;p&gt;类似于金本位，但是不同于金本位的货币时代，黄金作为本位币，具有无限法偿能力，银行券可以自由兑换成金币。任何人都可以向国家造币厂申请将其所有的黄金铸造成金币或将金币溶成金属块。黄金的输入和输出在国与国之间可以自由进行转移。它的权利义务是对等的，欠债还钱是无法逃脱的。唯一就是黄金本身价值波动罢了。&lt;br/&gt;但是石油美元不对称性导致其权利和义务分离，美国制造权利（美元），维护美元信用和威慑力（美元武力），石油生产国提供义务（石油），只要美国的武力仍然可以征服世界，你持有美元就可以兑换任何人的石油资源。&lt;br/&gt;通过锁定石油，美国人享受欠债填写美元支票的权利，负有维护美元信用和美元武力的义务。只要世界的原油还在用美元交易，石油本位的美元就不会垮。&lt;br/&gt;一旦美元换石油的权利受到侵害，美国有义务维护美元武力（震慑力）。所以尽管科威特、伊拉克战争让美国耗费巨大人力物力，但是凡事挑战石油本位的活动必须严厉打击，所以美国不是无缘无故打击他们。&lt;/p&gt;
&lt;p&gt;不过，随着特普朗政府的经济政策由强势美元向弱势美元的转变，美元指数下跌，美元信用受到挑战，石油美元体系开始松动。&lt;/p&gt;
&lt;p&gt;中国是全球最大的原油进口国，在国际原油贸易中却需要用美元交易，原油期货的推出将帮助中国在国际原油市场赢得更大影响力。中国证监会2月9日宣布，经过周密准备，原油期货将于2018年3月26日在上海期货交易所挂牌交易，推出以人民币计价的原油期货也是人民币国际化迈出的重大一步，“&lt;a href=&quot;https://finance.qq.com/a/20180212/002040.htm&quot; target=&quot;_blank&quot;&gt;石油人民币”&lt;/a&gt;开启破冰之旅。&lt;/p&gt;
&lt;h2&gt; 通胀与通缩，现代货币的囚徒困境&lt;/h2&gt;
&lt;p&gt;我们知道信用货币发行过多，会钱不值钱，人们持有货币的信用不足，会想尽办法把钱花出去，购买过多不是很必须的商品，参与投机炒作，甚至借钱消费和投资，制造资产泡沫，比如股票和房地产泡沫，甚至参与比特币等各种虚拟数字资产的投机，导致比特币价格暴涨暴跌。但是通胀不可能一直持续，否则发生恶性通胀，商品价格最终会高到普通民众买不起的地步，直观的印象就是没有钱了，想要买也买不了了，这就是需求不足型通缩。而在另一方，商品生产者大量的商品供给过剩，商品卖不出去，前期为扩大生产的贷款投资没法偿还，银行出现坏账，没法给新的商品生产者提供贷款，对他们而言就是银行也没有钱了，流通在市场中的货币变得吃紧了，这就是通货紧缩。通货紧缩是一种货币现象，表现为价格的持续下跌和货币供给量的连续下降，即所谓的“双要素论”。&lt;br/&gt;可见通胀与通缩像一块硬币的两个面，发生严重通缩往往意味着发生了严重的经济危机，比如1929年美国爆发波及世界的大萧条，1990年日本房地产泡沫破裂后大萧条“失去的10年”，经济停滞不前。要避免严重通缩发生，那就要避免严重通胀，而事实上政府印钞引发通胀的冲动是很难避免的，那么政府同时想避免发生通缩也是不可能的，这就像被分别关押审讯的两个囚犯他们最终选择的是往往是相互揭发而不是相互沉默，这便是通胀与通缩的囚徒困境。&lt;/p&gt;
&lt;p&gt;为了避免发生通缩引发消费不足经济停滞，上世纪30年代美国发生大萧条之后，诞生了&lt;a href=&quot;https://baike.baidu.com/item/%E5%87%AF%E6%81%A9%E6%96%AF%E4%B8%BB%E4%B9%89&quot; target=&quot;_blank&quot;&gt;凯恩斯主义&lt;/a&gt;，主张国家采用扩张性的经济政策，通过增加需求促进经济增长。即扩大政府开支，实行财政赤字，刺激经济，维持繁荣。战后很多国家纷纷采用凯恩斯主义，政府干预经济问题，的确在一定程度上避免了发生严重通缩的情况，比如2008年美国次贷危机之后，美国数次QE为市场注入流动性，同事中国政府4万亿的强力经济干预，使得世界没有发生更严重的经济危机。但是，这种行为也使得美国和其他国家积累了更多的债务，凯恩斯主义似乎穷途末路，世界需要寻找新的经济发展模式。&lt;/p&gt;

&lt;h2&gt; 重拾价值的本质，根本上解决货币的信用问题&lt;/h2&gt;
&lt;p&gt;货币本质上是一种一般等价物，历史上，一般等价物曾由一些特殊的商品承担，比如食盐，石油，随着社会的进步，黄金和白银成了最适合执行一般等价物职能的货币。但是，现代社会科技进步社会物质生产极大丰富，黄金储备总量有限无法满足物质财富等价交换的需求，所以各国发行的信用货币（纸币）纷纷与黄金脱钩，主要以CPI指数，非农指数等为发行货币的依据，在国际上建立石油货币，但结果就是通胀和债务加剧，货币对经济的调节作用越来越有限，这是各国政府面临的难题。&lt;br/&gt;08年之后产生的比特币它的总量有限，似乎成了规避信用货币滥发引起通胀的问题，但事实证明比特币也难堪大用，并且之后出现了以太坊，莱特币等各种虚拟数字币，比特币等虚拟数字币总量有限防通胀的功能落空，成为跟股票、贵金属、房地产等一样投资炒作的标的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;看来要解决货币的信用问题，必须重视一般等价物的探寻，回到价值的根本定义上来。&lt;/p&gt;
&lt;p&gt; 价值的定义有很多种，有社会的，经济的，美学的各方面的价值，有“物以稀为贵”，也有“黄金有价亲情无价”等各种说法。我们经常说的有商品价值，甚至有“著名经济学家”茅于轼说的的“交换产生价值”。&lt;/p&gt;
&lt;p&gt;将社会物质价值与商品价值结合起来形成一整套理论的，是马克思100多年的长篇巨著《资本论》核心理论基础的“&lt;a href=&quot;https://baike.baidu.com/item/%E5%8A%B3%E5%8A%A8%E4%BB%B7%E5%80%BC%E8%AE%BA/2134644&quot; target=&quot;_blank&quot;&gt;劳动价值论&lt;/a&gt;”。&lt;/p&gt;
&lt;p&gt;劳动价值论是关于价值是一种凝结在商品中的无差别的人类劳动，即抽象劳动所创造的理论。商品价值决定于体现和物化在商品中的社会必要劳动的理论是人们在长期的历史过程中逐渐认识到的。（精神或者物质产品）产品成为商品是以交换为前提，交换就有个比率的问题。价值以这个比率，也就是以交换价值为其具体的表达形式，因此，&lt;strong&gt;价值和劳动的这种关系从而价值的实质往往被模糊了&lt;/strong&gt;。&lt;br/&gt;这是我们搞不清楚产品有多少价值的主要原因，然而一个产品被人类生产出来以后，不管你要不要跟人拿去交换，它的价值始终都是在那里的，如果是物质产品，它的价值随着产品生产过程一开始就注入，直到该产品自然消失或者它不在有使用价值；而人类的精神产品更会伴随人类历史发展而持续，比如四大名著，各种艺术品，歌剧戏剧等非物质遗产。这些物质或精神产品，它的价值都包含人类个人或者集体短时间或者长时间的劳动生产创造或者制造而来，而抽象的&lt;strong&gt;价值就是这些产品中包含的人类无差别的社会劳动&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;无差别的人类劳动时间&lt;/h2&gt;
&lt;p&gt;人类生产产品会消耗各种原材料，会生产出各种各样的产品，人类在制造或者创造产品过程中的劳动以原材料或者最终产品来“计算”显然是很复杂的，不稳定的，但是，有一种东西比较容易计算，就是时间，产品包含的&lt;span&gt;无差别的人类劳动时间&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt; 产品有了使用价值，然后作为商品交换，才有了交换价值。交换价值体现出来的就是商品的价格，这个价格使用货币来度量，所谓“一分钱一分货”就有这个意思。如果我们使用“无差别的人类劳动时间”来表示使用价值，那么自然它也可以表示商品的交换价值，这样就实现了使用价值和交换价值的统一，真正的表示了产品的价值。&lt;/p&gt;
&lt;p&gt;“无差别的人类劳动时间”简要的说是劳动时间，但它有两个关键的无法忽视的定语：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;人类劳动：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;产品中体现人类劳动，现代工业社会，大规模使用自动化流水线生产线，很多生产环节由人的劳动被机器取代，所以生产产品的规模越来越大，所需要的人力成本越来越少，这些产品在市场上的价格越来越便宜。如果以劳动价值论来看这个问题，正是因为这些产品所需要的无差别的人类劳动变少了，它的价值变小，所以价格降低。也许大家不认同这个结论，但我们试想，假设未来人工智能高度发达，大量使用机器人生产，其中有些东西根本无需人类劳动参与，且它的产品也不是给人类使用，而是给机器人使用的，那么，这种产品对人类来说，还有价值吗？这些产品只是对机器人世界有价值，对人类没有价值。如果觉得这个例子很遥远，我们再来看看蚂蚁王国，蚂蚁王国有严格的社会等级分工，很像人类社会，工蚁们辛勤劳动给蚁后生产的食物和蚁穴这些“产品”对人类有价值吗？没有。所以，产品要有价值一定要包含人类的劳动，而这种劳动最直接的体现就是劳动时间。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;无差别的人类劳动：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是一种抽象的人类劳动，人类的劳动种类多种多样，总体上可以分为体力劳动和脑力劳动；劳动消耗的原材料多种多样，但都会消耗一个相同的东西--时间，所以劳动时间是劳动的要素之一；劳动成果多种多样，但我们也可以使用它所花费的劳动时间来衡量它的价值。这里需要正视的一个问题就是每种劳动所花费的时间是不一样的，并且一个产品往往是社会化大分工合作的产物，所以一个产品包含很多种劳动。那么人们要获得一种产品，应该如何折算这种产品的价值呢？如果继续使用一般等价物来折算那么这种一般等价物必然被权利垄断或者控制，比如黄金白银，它们的生产历来就是被统治阶级控制的，以至于基于黄金白银的信用货币--纸币的发行，也是受权力控制的。一个事物如果被权力垄断或控制必然不公平，等价物不能完全等价。所以，不能继续使用一般等价物，而是使用多种产品的价值来相互表示，比如红军币使用物资储备来表示货币的信用。&lt;/p&gt;
&lt;p&gt;放弃一般等价物之后，每种产品所耗费的人类劳动时间成为改种产品价值的计算方式，当不同产品相互交换的时候我们可以用价格来表示它的价值，那么我们也可以通过交换不同劳动的时间来表示包含这种产品的无差别的人类劳动，这种时间就是“无差别的人类劳动时间”。这种时间我们需要一个储备的地方，它就是“时间银行”，我们需要一个交易场，它就是“劳动时间交易所”，每种劳动时间，就像股票市场的股票，通过每种劳动时间进行交换的“汇率”来体现抽象的无差别劳动时间。对于同一种劳动时间，要交换就简单了，不需要计算汇率，直接交换，这种交换场所就是时间银行，并且这种银行里面的“货币”没有发生通胀的可能性。&lt;/p&gt;
&lt;p&gt;到这里，我们发现马克思关于价值是人类无差别劳动的观点是十分正确的，只是他的这个思想理论太超前，100多年前还没有技术手段可以来具体实现无差别劳动时间的记录和交换，而现在，技术已经足够成熟，万事俱备，只欠东风。&lt;/p&gt;
&lt;h2&gt;时间银行的出现&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E9%93%B6%E8%A1%8C/10573893?fr=aladdin&quot; target=&quot;_blank&quot;&gt;时间银行&lt;/a&gt;的倡导者是美国人埃德加·卡恩。1980年，卡恩46岁，却经历了一次大面积心肌梗塞，这次经历让他对生活有了重新的理解，他的生活方向也由此改变。所谓时间银行，是指志愿者将参与公益服务的时间存进时间银行，当自己遭遇困难时就可以从中支取“被服务时间”。&lt;br/&gt;时间银行的宗旨是用支付的时间来换取别人的帮助，而银行是时间流通的桥梁。自愿添加时间银行的客户在需要时拿出自己的时间和其他成员交换服务，既解决了一时的困难，又彼此联络了感情，克服了现代社会人们互不往来的缺欠。&lt;br/&gt;时间银行的显着特点就是双向。时间银行不是一个慈善组织，它只在供与求之间发挥穿针引线的作用。因此，参加时间银行的人不需付出一分钱，只需将自己的时间存入时间银行即可。成为正式成员后，时间银行会给每位添加者10张支票，时间银行成员可用支票表示时间的支付情况。支付一次，帮助自己为别人提供了一次帮助，反过来自己也能接受别人的支票。这就是所谓的双向原则。因此，自添加那天起，时间银行成员就要做好准备，既可得到别人的时间与帮助，也要准备在时间允许时为别人付出时间与帮助。&lt;/p&gt;&lt;p&gt;在中国，时间银行也开始逐步实践，比如 “&lt;a href=&quot;http://politics.people.com.cn/n1/2017/1218/c1001-29712159.html&quot; target=&quot;_blank&quot;&gt;南京办了个“时间银行”（民生调查）&lt;/a&gt;”&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
养老服务面临老人多，服务人员少的问题。南京打造“时间银行”互助养老新模式。志愿者可以“存储”自己的志愿服务时间，在自己需要的时候兑换其他志愿者提供的服务，&lt;br/&gt;也能兑换物品和现金。未来全市各个“时间银行”将实现通存通兑，避免“坏账”的出现，运行质量将更加优质完善。
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 时间交易所的设想&lt;/h2&gt;
&lt;p&gt;（由于时间关系，暂时没空论述）&lt;/p&gt;



&lt;p&gt;在写这篇文章之前，我曾经思考了商品交换的问题，发现商品交易需要解决2个问题：交易的信用（不可抵赖）和一般等价物的信用（货币“值钱”）。如果没有一般等价物，那就只好“以物易物”，如果有了一般等价物那么最终它会发生变异，衍生出更多的问题，引起严重的金融危机和经济危机。是一般等价物选的不合适，还是现在或者未来可以在技术保证下舍去一般等价物就能完成商品的交易？在这个过程中我发现要解决这个问题就必须认真研究商品的价值本源问题，而这个问题的答案正是马克思的劳动价值论。马克思基于劳动价值论，论述了社会主义社会的按劳分配和在物质财富极大丰富的时候实现按需分配的共产主义社会，这种社会不就是习主席倡导的“人类命运共同体”和中国古人心中的“社会大同”么？&lt;/p&gt;
&lt;p&gt;由于篇幅有限，无法进行更多的论述，在2017年鸡年除夕，2018年金狗迎春的时刻终于初步收尾，希望更多的朋友一起来讨论，未来如何建设我们的“大同社会”。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;版权所有，欢迎转载，转载请注明版权所有：深蓝医生&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文中有很多内容是网上摘抄的，但经过了一定程度的内容整理，如果您认为侵权请和我联系修改，谢谢。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 15 Feb 2018 15:41:00 +0000</pubDate>
<dc:creator>深蓝医生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bluedoctor/p/8439256.html</dc:identifier>
</item>
<item>
<title>pandas中的分组技术 - 逝雪</title>
<link>http://www.cnblogs.com/songfy/p/8449920.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songfy/p/8449920.html</guid>
<description>&lt;p&gt;我们在这里要讲一个很常用的技术, 就是所谓的分组技术, 这个在数据库中是非常常用的, 要去求某些分组的统计量, 那么我们需要知道在pandas里面, 这些分组技术是怎么实现的.&lt;/p&gt;
&lt;h3 id=&quot;分组操作&quot;&gt;分组操作&lt;/h3&gt;
&lt;p&gt;我们这里要来聊聊在pandas中实现分组运算, 大致上可以按照列, 字典或者Series, 函数, 索引级别进行分组, 我们会逐渐来介绍.&lt;/p&gt;
&lt;h4 id=&quot;按照列进行分组&quot;&gt;按照列进行分组&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; pd
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; pandas &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; DataFrame, Series
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; np

sep &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;---------------------------------------------------------------------------&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; DataFrame({&lt;span class=&quot;st&quot;&gt;&quot;key1&quot;&lt;/span&gt;: [&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;], &lt;span class=&quot;st&quot;&gt;&quot;key2&quot;&lt;/span&gt;: [&lt;span class=&quot;st&quot;&gt;'one'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'two'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'one'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'two'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'one'&lt;/span&gt;], &lt;span class=&quot;st&quot;&gt;'data1'&lt;/span&gt;: np.random.randn(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;st&quot;&gt;'data2'&lt;/span&gt;: np.random.randn(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)})
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(data)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;      data1     data2 key1 key2
0  0.733951  0.000379    a  one
1  1.039029  0.852930    a  two
2  0.921413 -1.644942    b  one
3  0.294560  0.521525    b  two
4  0.286072 -0.074574    a  one&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;data1按照key1分组为:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;groups &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data[&lt;span class=&quot;st&quot;&gt;'data1'&lt;/span&gt;].groupby(data[&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们发现得到了一个SeriesGroupBy 对象, 现在我们对这个对象进行&lt;strong&gt;迭代&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; name, group &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; groups:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sep)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(group)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sep)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;a
---------------------------------------------------------------------------
0    0.733951
1    1.039029
4    0.286072
Name: data1, dtype: float64
---------------------------------------------------------------------------
b
---------------------------------------------------------------------------
2    0.921413
3    0.294560
Name: data1, dtype: float64
---------------------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们发现, &lt;strong&gt;groups有(key, Series)对组成, key根据什么来分组的元素, Series(DataFrame)是分组的元素, Series(DataFrame)的name还是原来的列名&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;对你分组进行迭代, 用:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for name, group in groups&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;groups &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data.groupby(data[&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;])
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; name, group &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; groups:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sep)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(group)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sep)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;a
---------------------------------------------------------------------------
      data1     data2 key1 key2
0  0.733951  0.000379    a  one
1  1.039029  0.852930    a  two
4  0.286072 -0.074574    a  one
---------------------------------------------------------------------------
b
---------------------------------------------------------------------------
      data1     data2 key1 key2
2  0.921413 -1.644942    b  one
3  0.294560  0.521525    b  two
---------------------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;groupby就是按照某个值来分组, 无论是对series还是dataframe, 都成立.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以在分好组的对象上调用统计函数.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby(data[&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;]).mean()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;data1&lt;/th&gt;
&lt;th&gt;data2&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;key1&lt;/th&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;a&lt;/th&gt;
&lt;td&gt;0.686351&lt;/td&gt;
&lt;td&gt;0.259578&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;b&lt;/th&gt;
&lt;td&gt;0.607986&lt;/td&gt;
&lt;td&gt;-0.561709&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;在每个分组上分别对每个每一列求均值, 如果是非数字列, 或默认剔除.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作业1:在每个分组上分别对每个每一行求均值.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提示: data.groupby(data['key1']).mean(axis=1)是行不通的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于多个列进行分组, 分组的key是对应分组元素的元组.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作业2:对DataFrame用多个列进行分组.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面其我们来看一个语法糖:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby([data[&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;], data[&lt;span class=&quot;st&quot;&gt;'key2'&lt;/span&gt;]])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;pandas.core.groupby.DataFrameGroupBy object at 0x000001D080230278&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它等价于:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby([&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'key2'&lt;/span&gt;])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;pandas.core.groupby.DataFrameGroupBy object at 0x000001D080230630&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来验证一下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;groups &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;data.groupby([data[&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;], data[&lt;span class=&quot;st&quot;&gt;'key2'&lt;/span&gt;]])
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; name, group &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; groups:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sep)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(group)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sep)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;('a', 'one')
---------------------------------------------------------------------------
      data1     data2 key1 key2
0  0.733951  0.000379    a  one
4  0.286072 -0.074574    a  one
---------------------------------------------------------------------------
('a', 'two')
---------------------------------------------------------------------------
      data1    data2 key1 key2
1  1.039029  0.85293    a  two
---------------------------------------------------------------------------
('b', 'one')
---------------------------------------------------------------------------
      data1     data2 key1 key2
2  0.921413 -1.644942    b  one
---------------------------------------------------------------------------
('b', 'two')
---------------------------------------------------------------------------
     data1     data2 key1 key2
3  0.29456  0.521525    b  two
---------------------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;groups &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data.groupby([&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'key2'&lt;/span&gt;])
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; name, group &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; groups:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sep)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(group)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sep)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;('a', 'one')
---------------------------------------------------------------------------
      data1     data2 key1 key2
0  0.733951  0.000379    a  one
4  0.286072 -0.074574    a  one
---------------------------------------------------------------------------
('a', 'two')
---------------------------------------------------------------------------
      data1    data2 key1 key2
1  1.039029  0.85293    a  two
---------------------------------------------------------------------------
('b', 'one')
---------------------------------------------------------------------------
      data1     data2 key1 key2
2  0.921413 -1.644942    b  one
---------------------------------------------------------------------------
('b', 'two')
---------------------------------------------------------------------------
     data1     data2 key1 key2
3  0.29456  0.521525    b  two
---------------------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们发现输出结果是一模一样, 总结一下:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;data.groupby([data['key1'], data['key2']])等价于data.groupby(['key1', 'key2'])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进一步:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;data['data1'].groupby([data['key1'], data['key2']])等价于data.groupby(['key1', 'key2'])['data1']&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作业3: 验证data['data1'].groupby([data['key1'], data['key2']])等价于data.groupby(['key1', 'key2'])['data1'].&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby([&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'key2'&lt;/span&gt;])[&lt;span class=&quot;st&quot;&gt;'data1'&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;pandas.core.groupby.SeriesGroupBy object at 0x000001D0FCD95D68&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby([&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'key2'&lt;/span&gt;])[[&lt;span class=&quot;st&quot;&gt;'data1'&lt;/span&gt;]]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;pandas.core.groupby.DataFrameGroupBy object at 0x000001D080232898&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我不知道大家发现没有, 这两个返回的数据类型是有区别的, 我们仔细来看看:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data[[&lt;span class=&quot;st&quot;&gt;'data1'&lt;/span&gt;]] &lt;span class=&quot;co&quot;&gt;# 这是一个DataFrame&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;data1&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;td&gt;0.733951&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;
&lt;td&gt;1.039029&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;2&lt;/th&gt;
&lt;td&gt;0.921413&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;3&lt;/th&gt;
&lt;td&gt;0.294560&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;4&lt;/th&gt;
&lt;td&gt;0.286072&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data[&lt;span class=&quot;st&quot;&gt;'data1'&lt;/span&gt;] &lt;span class=&quot;co&quot;&gt;# 这是一个Series&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;0    0.733951
1    1.039029
2    0.921413
3    0.294560
4    0.286072
Name: data1, dtype: float64&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这里的区别就不言而喻了吧&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;groups &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data.groupby([&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'key2'&lt;/span&gt;])[[&lt;span class=&quot;st&quot;&gt;'data1'&lt;/span&gt;]]

&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; name, group &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; groups:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sep)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(group)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sep)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;('a', 'one')
---------------------------------------------------------------------------
&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
---------------------------------------------------------------------------
('a', 'two')
---------------------------------------------------------------------------
&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
---------------------------------------------------------------------------
('b', 'one')
---------------------------------------------------------------------------
&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
---------------------------------------------------------------------------
('b', 'two')
---------------------------------------------------------------------------
&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
---------------------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果是一样的.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby([&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'key2'&lt;/span&gt;])[[&lt;span class=&quot;st&quot;&gt;'data1'&lt;/span&gt;]].mean()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;th&gt;data1&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;key1&lt;/th&gt;
&lt;th&gt;key2&lt;/th&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th rowspan=&quot;2&quot; valign=&quot;top&quot;&gt;a&lt;/th&gt;
&lt;th&gt;one&lt;/th&gt;
&lt;td&gt;0.510012&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;two&lt;/th&gt;
&lt;td&gt;1.039029&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th rowspan=&quot;2&quot; valign=&quot;top&quot;&gt;b&lt;/th&gt;
&lt;th&gt;one&lt;/th&gt;
&lt;td&gt;0.921413&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;two&lt;/th&gt;
&lt;td&gt;0.294560&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby([&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'key2'&lt;/span&gt;])[&lt;span class=&quot;st&quot;&gt;'data1'&lt;/span&gt;].mean()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;key1  key2
a     one     0.510012
      two     1.039029
b     one     0.921413
      two     0.294560
Name: data1, dtype: float64&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在做数据聚合的时候就发现了不同,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[['data1']]得到的是一个DataFrame, 而['data1']得到的是Series.&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;按照字典进行分组&quot;&gt;按照字典进行分组&lt;/h4&gt;
&lt;p&gt;我们来看一个按照字典进行分组的例子:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; DataFrame(np.random.randn(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), columns&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'c'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'d'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'e'&lt;/span&gt;], index&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;st&quot;&gt;'joe'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'steve'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'wes'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'jim'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'Travis'&lt;/span&gt;])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;d&lt;/th&gt;
&lt;th&gt;e&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;joe&lt;/th&gt;
&lt;td&gt;-0.089597&lt;/td&gt;
&lt;td&gt;1.239307&lt;/td&gt;
&lt;td&gt;2.173063&lt;/td&gt;
&lt;td&gt;-0.519295&lt;/td&gt;
&lt;td&gt;-1.783812&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;steve&lt;/th&gt;
&lt;td&gt;0.539109&lt;/td&gt;
&lt;td&gt;0.724553&lt;/td&gt;
&lt;td&gt;-0.041899&lt;/td&gt;
&lt;td&gt;0.787494&lt;/td&gt;
&lt;td&gt;0.394633&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;wes&lt;/th&gt;
&lt;td&gt;-0.055417&lt;/td&gt;
&lt;td&gt;0.384068&lt;/td&gt;
&lt;td&gt;-0.594006&lt;/td&gt;
&lt;td&gt;-0.451587&lt;/td&gt;
&lt;td&gt;0.722761&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;jim&lt;/th&gt;
&lt;td&gt;-0.056767&lt;/td&gt;
&lt;td&gt;0.398863&lt;/td&gt;
&lt;td&gt;2.140669&lt;/td&gt;
&lt;td&gt;-1.060791&lt;/td&gt;
&lt;td&gt;-0.953756&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Travis&lt;/th&gt;
&lt;td&gt;0.245142&lt;/td&gt;
&lt;td&gt;-0.468819&lt;/td&gt;
&lt;td&gt;-0.863372&lt;/td&gt;
&lt;td&gt;-0.151966&lt;/td&gt;
&lt;td&gt;1.185567&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 定义一个分组的字典, a, b, c --&amp;gt; red, d, e --&amp;gt; blue&lt;/span&gt;
mapping &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'red'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'red'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'c'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'red'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'d'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'blue'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'e'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'blue'&lt;/span&gt;}
data.groupby(mapping, axis&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;).mean()   &lt;span class=&quot;co&quot;&gt;# 对每一个分组求平均&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;blue&lt;/th&gt;
&lt;th&gt;red&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;joe&lt;/th&gt;
&lt;td&gt;-1.151554&lt;/td&gt;
&lt;td&gt;1.107591&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;steve&lt;/th&gt;
&lt;td&gt;0.591063&lt;/td&gt;
&lt;td&gt;0.407255&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;wes&lt;/th&gt;
&lt;td&gt;0.135587&lt;/td&gt;
&lt;td&gt;-0.088452&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;jim&lt;/th&gt;
&lt;td&gt;-1.007273&lt;/td&gt;
&lt;td&gt;0.827589&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Travis&lt;/th&gt;
&lt;td&gt;0.516800&lt;/td&gt;
&lt;td&gt;-0.362350&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;作业4:自己设计一个index的mapping, 按axis=0进行分组.&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;根据函数进行分组&quot;&gt;根据函数进行分组&lt;/h4&gt;
&lt;p&gt;话不多说, 直接来看例子:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby(&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;).mean()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;d&lt;/th&gt;
&lt;th&gt;e&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;3&lt;/th&gt;
&lt;td&gt;-0.067260&lt;/td&gt;
&lt;td&gt;0.674079&lt;/td&gt;
&lt;td&gt;1.239909&lt;/td&gt;
&lt;td&gt;-0.677224&lt;/td&gt;
&lt;td&gt;-0.671602&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;5&lt;/th&gt;
&lt;td&gt;0.539109&lt;/td&gt;
&lt;td&gt;0.724553&lt;/td&gt;
&lt;td&gt;-0.041899&lt;/td&gt;
&lt;td&gt;0.787494&lt;/td&gt;
&lt;td&gt;0.394633&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;6&lt;/th&gt;
&lt;td&gt;0.245142&lt;/td&gt;
&lt;td&gt;-0.468819&lt;/td&gt;
&lt;td&gt;-0.863372&lt;/td&gt;
&lt;td&gt;-0.151966&lt;/td&gt;
&lt;td&gt;1.185567&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;我们发现, &lt;strong&gt;字典和函数都是作用到索引上的.&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;按照list组合&quot;&gt;按照list组合&lt;/h4&gt;
&lt;p&gt;这个例子非常简单:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby([&lt;span class=&quot;st&quot;&gt;'1'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'1'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'1'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'2'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'2'&lt;/span&gt;]).mean()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;d&lt;/th&gt;
&lt;th&gt;e&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;
&lt;td&gt;0.131365&lt;/td&gt;
&lt;td&gt;0.782643&lt;/td&gt;
&lt;td&gt;0.512386&lt;/td&gt;
&lt;td&gt;-0.061130&lt;/td&gt;
&lt;td&gt;-0.222139&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;2&lt;/th&gt;
&lt;td&gt;0.094188&lt;/td&gt;
&lt;td&gt;-0.034978&lt;/td&gt;
&lt;td&gt;0.638649&lt;/td&gt;
&lt;td&gt;-0.606378&lt;/td&gt;
&lt;td&gt;0.115905&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;他会自动判断是按照列还是list.&lt;/p&gt;
&lt;h4 id=&quot;按照索引级别进行分组&quot;&gt;按照索引级别进行分组&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;作业5: 自己学习按索引级别进行分组.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;分组运算&quot;&gt;分组运算&lt;/h3&gt;
&lt;p&gt;分组运算主要设计到3个函数, agg, transform和apply.&lt;/p&gt;
&lt;p&gt;我们一个一个来看.&lt;/p&gt;
&lt;h4 id=&quot;agg&quot;&gt;agg&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; DataFrame({&lt;span class=&quot;st&quot;&gt;&quot;key1&quot;&lt;/span&gt;: [&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;], &lt;span class=&quot;st&quot;&gt;&quot;key2&quot;&lt;/span&gt;: [&lt;span class=&quot;st&quot;&gt;'one'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'two'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'one'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'two'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'one'&lt;/span&gt;], &lt;span class=&quot;st&quot;&gt;'data1'&lt;/span&gt;: np.random.randn(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;st&quot;&gt;'data2'&lt;/span&gt;: np.random.randn(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)})&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;data1&lt;/th&gt;
&lt;th&gt;data2&lt;/th&gt;
&lt;th&gt;key1&lt;/th&gt;
&lt;th&gt;key2&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;td&gt;0.441278&lt;/td&gt;
&lt;td&gt;-0.848457&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;one&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;
&lt;td&gt;1.843375&lt;/td&gt;
&lt;td&gt;-0.522482&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;two&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;2&lt;/th&gt;
&lt;td&gt;-1.435176&lt;/td&gt;
&lt;td&gt;-0.191682&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;one&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;3&lt;/th&gt;
&lt;td&gt;-2.700772&lt;/td&gt;
&lt;td&gt;-0.832993&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;two&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;4&lt;/th&gt;
&lt;td&gt;-1.430386&lt;/td&gt;
&lt;td&gt;-1.910834&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;one&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby(&lt;span class=&quot;st&quot;&gt;&quot;key2&quot;&lt;/span&gt;).agg(np.mean)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;data1&lt;/th&gt;
&lt;th&gt;data2&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;key2&lt;/th&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;one&lt;/th&gt;
&lt;td&gt;-0.808095&lt;/td&gt;
&lt;td&gt;-0.983658&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;two&lt;/th&gt;
&lt;td&gt;-0.428699&lt;/td&gt;
&lt;td&gt;-0.677738&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;当然, 这个等价于:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby(&lt;span class=&quot;st&quot;&gt;&quot;key2&quot;&lt;/span&gt;).mean()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;data1&lt;/th&gt;
&lt;th&gt;data2&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;key2&lt;/th&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;one&lt;/th&gt;
&lt;td&gt;-0.808095&lt;/td&gt;
&lt;td&gt;-0.983658&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;two&lt;/th&gt;
&lt;td&gt;-0.428699&lt;/td&gt;
&lt;td&gt;-0.677738&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;原理: 聚合函数会在group后的每个切片上(group后的每一行或每一列)计算出值.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们也可以自定义函数:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby(&lt;span class=&quot;st&quot;&gt;&quot;key2&quot;&lt;/span&gt;).agg(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; x: x.&lt;span class=&quot;bu&quot;&gt;max&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; x.&lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;())&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;data1&lt;/th&gt;
&lt;th&gt;data2&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;key2&lt;/th&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;one&lt;/th&gt;
&lt;td&gt;1.876454&lt;/td&gt;
&lt;td&gt;1.719153&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;two&lt;/th&gt;
&lt;td&gt;4.544147&lt;/td&gt;
&lt;td&gt;0.310511&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;他会在每个分组的每个列上调用这个函数.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby(&lt;span class=&quot;st&quot;&gt;&quot;key2&quot;&lt;/span&gt;).agg([np.mean, np.&lt;span class=&quot;bu&quot;&gt;max&lt;/span&gt;,np.&lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th colspan=&quot;3&quot;&gt;data1&lt;/th&gt;
&lt;th colspan=&quot;3&quot;&gt;data2&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;mean&lt;/th&gt;
&lt;th&gt;amax&lt;/th&gt;
&lt;th&gt;amin&lt;/th&gt;
&lt;th&gt;mean&lt;/th&gt;
&lt;th&gt;amax&lt;/th&gt;
&lt;th&gt;amin&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;key2&lt;/th&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;one&lt;/th&gt;
&lt;td&gt;-0.808095&lt;/td&gt;
&lt;td&gt;0.441278&lt;/td&gt;
&lt;td&gt;-1.435176&lt;/td&gt;
&lt;td&gt;-0.983658&lt;/td&gt;
&lt;td&gt;-0.191682&lt;/td&gt;
&lt;td&gt;-1.910834&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;two&lt;/th&gt;
&lt;td&gt;-0.428699&lt;/td&gt;
&lt;td&gt;1.843375&lt;/td&gt;
&lt;td&gt;-2.700772&lt;/td&gt;
&lt;td&gt;-0.677738&lt;/td&gt;
&lt;td&gt;-0.522482&lt;/td&gt;
&lt;td&gt;-0.832993&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby(&lt;span class=&quot;st&quot;&gt;&quot;key2&quot;&lt;/span&gt;).agg([(&lt;span class=&quot;st&quot;&gt;&quot;平均值:&quot;&lt;/span&gt;, np.mean), (&lt;span class=&quot;st&quot;&gt;&quot;最大值&quot;&lt;/span&gt;,np.&lt;span class=&quot;bu&quot;&gt;max&lt;/span&gt;), (&lt;span class=&quot;st&quot;&gt;&quot;最小值&quot;&lt;/span&gt;,np.&lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;)]).rename({&lt;span class=&quot;st&quot;&gt;&quot;one&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;第一组&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;two&quot;&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;&quot;第二组&quot;&lt;/span&gt;})&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th colspan=&quot;3&quot;&gt;data1&lt;/th&gt;
&lt;th colspan=&quot;3&quot;&gt;data2&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;平均值:&lt;/th&gt;
&lt;th&gt;最大值&lt;/th&gt;
&lt;th&gt;最小值&lt;/th&gt;
&lt;th&gt;平均值:&lt;/th&gt;
&lt;th&gt;最大值&lt;/th&gt;
&lt;th&gt;最小值&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;key2&lt;/th&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;第一组&lt;/th&gt;
&lt;td&gt;-0.808095&lt;/td&gt;
&lt;td&gt;0.441278&lt;/td&gt;
&lt;td&gt;-1.435176&lt;/td&gt;
&lt;td&gt;-0.983658&lt;/td&gt;
&lt;td&gt;-0.191682&lt;/td&gt;
&lt;td&gt;-1.910834&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;第二组&lt;/th&gt;
&lt;td&gt;-0.428699&lt;/td&gt;
&lt;td&gt;1.843375&lt;/td&gt;
&lt;td&gt;-2.700772&lt;/td&gt;
&lt;td&gt;-0.677738&lt;/td&gt;
&lt;td&gt;-0.522482&lt;/td&gt;
&lt;td&gt;-0.832993&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 对不同列用不同的分组函数 &lt;/span&gt;
data.groupby(&lt;span class=&quot;st&quot;&gt;&quot;key2&quot;&lt;/span&gt;).agg({&lt;span class=&quot;st&quot;&gt;&quot;data1&quot;&lt;/span&gt;:[(&lt;span class=&quot;st&quot;&gt;&quot;平均值:&quot;&lt;/span&gt;, np.mean), (&lt;span class=&quot;st&quot;&gt;&quot;最大值&quot;&lt;/span&gt;,np.&lt;span class=&quot;bu&quot;&gt;max&lt;/span&gt;)], &lt;span class=&quot;st&quot;&gt;&quot;data2&quot;&lt;/span&gt;:[(&lt;span class=&quot;st&quot;&gt;&quot;最小值&quot;&lt;/span&gt;,np.&lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;)]}).rename({&lt;span class=&quot;st&quot;&gt;&quot;one&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;第一组&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;two&quot;&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;&quot;第二组&quot;&lt;/span&gt;})&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;data2&lt;/th&gt;
&lt;th colspan=&quot;2&quot;&gt;data1&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;最小值&lt;/th&gt;
&lt;th&gt;平均值:&lt;/th&gt;
&lt;th&gt;最大值&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;key2&lt;/th&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;第一组&lt;/th&gt;
&lt;td&gt;-1.910834&lt;/td&gt;
&lt;td&gt;-0.808095&lt;/td&gt;
&lt;td&gt;0.441278&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;第二组&lt;/th&gt;
&lt;td&gt;-0.832993&lt;/td&gt;
&lt;td&gt;-0.428699&lt;/td&gt;
&lt;td&gt;1.843375&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h4 id=&quot;transform&quot;&gt;transform&lt;/h4&gt;
&lt;p&gt;transform是一个矢量化的函数, 如果最后我们得到的值和分组切片不一致, 会进行广播:&lt;/p&gt;

&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;data1&lt;/th&gt;
&lt;th&gt;data2&lt;/th&gt;
&lt;th&gt;key1&lt;/th&gt;
&lt;th&gt;key2&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;td&gt;0.441278&lt;/td&gt;
&lt;td&gt;-0.848457&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;one&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;
&lt;td&gt;1.843375&lt;/td&gt;
&lt;td&gt;-0.522482&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;two&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;2&lt;/th&gt;
&lt;td&gt;-1.435176&lt;/td&gt;
&lt;td&gt;-0.191682&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;one&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;3&lt;/th&gt;
&lt;td&gt;-2.700772&lt;/td&gt;
&lt;td&gt;-0.832993&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;two&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;4&lt;/th&gt;
&lt;td&gt;-1.430386&lt;/td&gt;
&lt;td&gt;-1.910834&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;one&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby(&lt;span class=&quot;st&quot;&gt;&quot;key1&quot;&lt;/span&gt;).transform(np.mean)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;data1&lt;/th&gt;
&lt;th&gt;data2&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;td&gt;0.284756&lt;/td&gt;
&lt;td&gt;-1.093924&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;
&lt;td&gt;0.284756&lt;/td&gt;
&lt;td&gt;-1.093924&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;2&lt;/th&gt;
&lt;td&gt;-2.067974&lt;/td&gt;
&lt;td&gt;-0.512338&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;3&lt;/th&gt;
&lt;td&gt;-2.067974&lt;/td&gt;
&lt;td&gt;-0.512338&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;4&lt;/th&gt;
&lt;td&gt;0.284756&lt;/td&gt;
&lt;td&gt;-1.093924&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;仔细看, 0,1, 4一组, 2,3一组, 发生了广播.&lt;/p&gt;
&lt;p&gt;现在有个需求,按分组减去均值.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby(&lt;span class=&quot;st&quot;&gt;&quot;key1&quot;&lt;/span&gt;).transform(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; x: x &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; x.mean())&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;data1&lt;/th&gt;
&lt;th&gt;data2&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;td&gt;0.156523&lt;/td&gt;
&lt;td&gt;0.245468&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;
&lt;td&gt;1.558619&lt;/td&gt;
&lt;td&gt;0.571442&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;2&lt;/th&gt;
&lt;td&gt;0.632798&lt;/td&gt;
&lt;td&gt;0.320656&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;3&lt;/th&gt;
&lt;td&gt;-0.632798&lt;/td&gt;
&lt;td&gt;-0.320656&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;4&lt;/th&gt;
&lt;td&gt;-1.715142&lt;/td&gt;
&lt;td&gt;-0.816910&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;a, b分组的各列都减去了他们的均值, 不信, 来看:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby(&lt;span class=&quot;st&quot;&gt;&quot;key1&quot;&lt;/span&gt;).transform(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; x: x &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; x.mean()).groupby([&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]).mean()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;data1&lt;/th&gt;
&lt;th&gt;data2&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;td&gt;1.110223e-16&lt;/td&gt;
&lt;td&gt;-5.551115e-17&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;
&lt;td&gt;7.401487e-17&lt;/td&gt;
&lt;td&gt;-1.110223e-16&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h4 id=&quot;apply&quot;&gt;apply&lt;/h4&gt;
&lt;p&gt;这个函数是transform的加强版, transform只能返回和原来切片大小一样大的, 但apply是可以任意的. 其实我们之前就用过apply函数, 我们知道, apply是作用在列(行)上的, applymap是作用在函数上的.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; DataFrame({&lt;span class=&quot;st&quot;&gt;&quot;key1&quot;&lt;/span&gt;: [&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;], &lt;span class=&quot;st&quot;&gt;&quot;key2&quot;&lt;/span&gt;: [&lt;span class=&quot;st&quot;&gt;'one'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'two'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'one'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'two'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'one'&lt;/span&gt;], &lt;span class=&quot;st&quot;&gt;'data1'&lt;/span&gt;: np.random.randn(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;st&quot;&gt;'data2'&lt;/span&gt;: np.random.randn(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)})&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;data1&lt;/th&gt;
&lt;th&gt;data2&lt;/th&gt;
&lt;th&gt;key1&lt;/th&gt;
&lt;th&gt;key2&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;td&gt;-0.312694&lt;/td&gt;
&lt;td&gt;0.073574&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;one&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;
&lt;td&gt;-0.902065&lt;/td&gt;
&lt;td&gt;-0.854249&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;two&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;2&lt;/th&gt;
&lt;td&gt;-0.440915&lt;/td&gt;
&lt;td&gt;0.228551&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;one&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;3&lt;/th&gt;
&lt;td&gt;-0.406243&lt;/td&gt;
&lt;td&gt;-0.878505&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;two&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;4&lt;/th&gt;
&lt;td&gt;1.812926&lt;/td&gt;
&lt;td&gt;-0.114598&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;one&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;如果我们要找出one, 和two分组中选出data2最大的前两个呢?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby(&lt;span class=&quot;st&quot;&gt;'key2'&lt;/span&gt;).&lt;span class=&quot;bu&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; x: x.sort_values(by&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'data2'&lt;/span&gt;)[&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;:])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;th&gt;data1&lt;/th&gt;
&lt;th&gt;data2&lt;/th&gt;
&lt;th&gt;key1&lt;/th&gt;
&lt;th&gt;key2&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;key2&lt;/th&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th rowspan=&quot;2&quot; valign=&quot;top&quot;&gt;one&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;td&gt;-0.312694&lt;/td&gt;
&lt;td&gt;0.073574&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;one&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;2&lt;/th&gt;
&lt;td&gt;-0.440915&lt;/td&gt;
&lt;td&gt;0.228551&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;one&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th rowspan=&quot;2&quot; valign=&quot;top&quot;&gt;two&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;td&gt;-0.406243&lt;/td&gt;
&lt;td&gt;-0.878505&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;two&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;
&lt;td&gt;-0.902065&lt;/td&gt;
&lt;td&gt;-0.854249&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;two&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;去掉group层次索引:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data.groupby(&lt;span class=&quot;st&quot;&gt;'key2'&lt;/span&gt;, group_keys&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;).&lt;span class=&quot;bu&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; x: x.sort_values(by&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'data2'&lt;/span&gt;)[&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;:])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;data1&lt;/th&gt;
&lt;th&gt;data2&lt;/th&gt;
&lt;th&gt;key1&lt;/th&gt;
&lt;th&gt;key2&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;td&gt;-0.312694&lt;/td&gt;
&lt;td&gt;0.073574&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;one&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;2&lt;/th&gt;
&lt;td&gt;-0.440915&lt;/td&gt;
&lt;td&gt;0.228551&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;one&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;3&lt;/th&gt;
&lt;td&gt;-0.406243&lt;/td&gt;
&lt;td&gt;-0.878505&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;two&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;
&lt;td&gt;-0.902065&lt;/td&gt;
&lt;td&gt;-0.854249&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;two&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;总结一下: apply就是把分完组的切片挨个(按行, 按列, 或者整体)调用我们的函数, 最后再把结果合并起来.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;利用groupby技术多进程处理dataframe&quot;&gt;利用groupby技术多进程处理DataFrame&lt;/h3&gt;
&lt;p&gt;我们这里要教大家用一种groupby技术, 来实现对DataFrame并行处理.&lt;/p&gt;
&lt;p&gt;pip install joblib&lt;/p&gt;
&lt;p&gt;因为我们windows系统的限制, 我们的代码是在linux上运行的:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; math
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; joblib &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Parallel, delayed
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; pandas &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; DataFrame
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; pd
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; np
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; time

begin &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; time.time()
test &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; DataFrame(np.random.randn(&lt;span class=&quot;dv&quot;&gt;10000000&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;))
test_other &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; test.copy()
groups &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; test.groupby(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; x: x &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; func(x):
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; x.applymap(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; y: math.&lt;span class=&quot;bu&quot;&gt;pow&lt;/span&gt;(y, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;))

pd.concat(Parallel(n_jobs&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)(delayed(func)(group) &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; name, group &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; groups))
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(time.time() &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; begin)


begin &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; time.time()
test_other.applymap(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; x: math.&lt;span class=&quot;bu&quot;&gt;pow&lt;/span&gt;(x, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;))
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(time.time() &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; begin)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运算结果为:&lt;br/&gt;23.35878014564514&lt;br/&gt;62.76386260986328&lt;/p&gt;
&lt;p&gt;速度大概提升了2.5倍, 还是很不错的.&lt;/p&gt;
</description>
<pubDate>Thu, 15 Feb 2018 15:23:00 +0000</pubDate>
<dc:creator>逝雪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songfy/p/8449920.html</dc:identifier>
</item>
<item>
<title>使用Openresty加快网页速度 - ZepheryWen</title>
<link>http://www.cnblogs.com/w1570631036/p/8449373.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w1570631036/p/8449373.html</guid>
<description>&lt;p&gt;新年快乐~~~&lt;br/&gt;上一篇文章讲到使用多级缓存来减少数据库的访问来加快网页的速度，只是，仍旧没有“嗖”一下就加载出来的感觉，想再优化一下，优化代码什么的已经到了极限。上周无意中看到了openresty，能够直接在nginx层直接对请求处理，而不需要每次都访问tomcat，特别是对于自己的首页&lt;a href=&quot;http://www.wenzhihuai.com&quot; class=&quot;uri&quot;&gt;http://www.wenzhihuai.com&lt;/a&gt;来说，由于首页内容广泛，需要涉及的方法太多，每次打开首页都得耗费大量的时间。&lt;/p&gt;

&lt;p&gt;目前本人总共有三个服务器：&lt;br/&gt;&lt;strong&gt;A:119.23.46.71(深圳，Nginx环境，本地Redis，tomcat服务器)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;B:119.29.188.224(广州，tomcat服务器)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;C:47.95.10.139(北京，tomact服务器)&lt;/strong&gt;&lt;br/&gt;为了减少后端的相应时间，之前使用的是在应用里集成ehcache作为一级缓存，redis作为二级缓存。这种架构存在一种特殊的情况：当Nginx将首页的请求分发给北京节点的时候，响应将变得极其缓慢，用户的请求需要从深圳到北京，再从北京回到深圳，光是延时就要耗费40ms(最好的情况)，由于网速是1M/s，最坏的情况下，响应用户的请求也得耗费几秒。所以，为了减少这种极端情况，设计了这款架构（个人项目随便整整而已，怎么来都行啦）。&lt;br/&gt;由于是博客类的项目，对于一致性要求并不高，所以干脆直接将首页缓存到Redis即可。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20180214105827.png&quot;/&gt;&lt;/div&gt;
&lt;br/&gt;步骤：&lt;br/&gt;1.请求到达nginx后，openresty通过lua读取本地缓存，如果不命中，则回源到tomcat集群。&lt;br/&gt;2.tomcat集群首先从自己的服务器中读取一级缓存Ehcache，如果没有命中，则继续回源到二级缓存。&lt;br/&gt;3.读取二级缓存Redis，如果依旧没有命中，则回源到MySQL服务器。

&lt;h3 id=&quot;openresty&quot;&gt;2.1 Openresty&lt;/h3&gt;
&lt;p&gt;安装过程可以直接参考官方文档:&lt;a href=&quot;http://openresty.org/cn/download.html&quot; class=&quot;uri&quot;&gt;http://openresty.org/cn/download.html&lt;/a&gt;，安装前还需安装以下开发库：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;yum install pcre-devel openssl-devel gcc curl&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后进行编译安装:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;tar -xzvf openresty-VERSION.tar.gz
cd openresty-VERSION/
./configure
make
sudo make install&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;nginx相关配置&quot;&gt;2.2 Nginx相关配置&lt;/h3&gt;
&lt;p&gt;Openresty自带了Nginx。所以，只要安装好了Openresty，即可直接使用nginx来配置。&lt;br/&gt;以下只是部分，需要全部的请查看&lt;a href=&quot;https://github.com/Zephery/micro-service/blob/master/conf/nginx/mynginxconfig.ngx&quot;&gt;mynginxconfig&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;http {
    include       mime.types;
    default_type  application/octet-stream;
    # 需要添加lua的相关库
    lua_package_path &quot;/opt/openresty/lualib/?.lua;;&quot;;
    lua_package_cpath &quot;/opt/openresty/lualib/?.so;;&quot;;
    ...

    access_log  logs/access.log  main;
    sendfile        on;
    keepalive_timeout  65;

    upstream backend {
        #consistent_hash was not configured
        hash $uri;
        server 47.95.10.139:8080;
        server 119.23.46.71:8080;
        server 119.29.188.224:8080;
    }
    server {
        listen       80;
        server_name  www.wenzhihuai.com;
        # 精确匹配，打开首页的时候进入
        location  = / {
            default_type    text/html;
            root   html;
            index  index.html index.htm;
            ...
            # 关闭缓存lua脚本，调试的时候专用
            lua_code_cache off;
            content_by_lua_file /opt/lua/hello.lua;
            # 此处不要proxy_pass了，否则lua脚本没用
            # proxy_pass http://backend;

        }
        # 如果上面的不符合，则匹配下面的
        location / {
            default_type    text/html;
            root   html;
            index  index.html index.htm;
            # 对请求进行反向代理
            proxy_pass http://backend;
        }
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;lua脚本&quot;&gt;2.3 lua脚本&lt;/h3&gt;
&lt;p&gt;脚本记得放在/opt/lua/hello.lua目录下，对应nginx的配置，同时需要引入redis模块。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode lua&quot;&gt;
&lt;code class=&quot;sourceCode lua&quot;&gt;&lt;span class=&quot;kw&quot;&gt;local&lt;/span&gt; redis &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;resty.redis&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;local&lt;/span&gt; red &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; redis:new&lt;span class=&quot;ot&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;local&lt;/span&gt; request_uri &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; ngx&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;var&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;request_uri

&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;request_uri &lt;span class=&quot;ot&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;or&lt;/span&gt; request_uri &lt;span class=&quot;ot&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/index.html&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
    red:set_timeout&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- 1 sec&lt;/span&gt;
    red:&lt;span class=&quot;fu&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;119.23.46.71&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6340&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;local&lt;/span&gt; ok&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; err &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; red:auth&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;not&lt;/span&gt; ok &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
        ngx&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;say&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;failed to connect: &quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; err&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;--缓存的首页放在key为index里&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;local&lt;/span&gt; resp&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; errr &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; red:get&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;index&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;not&lt;/span&gt; resp &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; resp &lt;span class=&quot;ot&quot;&gt;==&lt;/span&gt; ngx&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;null &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
        resp &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;h1&amp;gt;hello world&amp;lt;/h1&amp;gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;--如果找到，则输出内容&lt;/span&gt;
    ngx&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;print&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;resp&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
    red:&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;local&lt;/span&gt; pagenum &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; ngx&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;req&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;get_uri_args&lt;span class=&quot;ot&quot;&gt;()[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;pagenum&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--因为在nginx中设置了proxy_pass_request_headers off，即不讲请求头部传到lua，所以头部需要重新设置&lt;/span&gt;
ngx&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;req&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;set_header&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Accept&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;text/html,application/xhtml+xml,application/xml;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--这里回源到tomcat的时候，Accept-Encoding默认为gzip，即返回来数据已经是gzip压缩过了的，返回到用户的时候又被压缩了一次，会造成一堆乱码。所以将Accept-Encoding设置为空。&lt;/span&gt;
ngx&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;req&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;set_header&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Accept-Encoding&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;local&lt;/span&gt; respp &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; ngx&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;location&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;capture&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/index.do&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;{&lt;/span&gt; method &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; ngx&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;HTTP_GET&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; args &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;{&lt;/span&gt; pagenum &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; pagenum &lt;span class=&quot;ot&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--打印&lt;/span&gt;
ngx&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;print&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;respp&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;body&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;更新首页到redis&quot;&gt;2.4 更新首页到redis&lt;/h3&gt;
&lt;p&gt;每隔20秒直接访问后端进行首页的抓取，然后存储到redis里面，简单粗暴。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Controller&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@SuppressWarnings&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TimeController {
    &lt;span class=&quot;co&quot;&gt;//logger&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Logger logger = LoggerFactory.&lt;span class=&quot;fu&quot;&gt;getLogger&lt;/span&gt;(TimeController.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
    &lt;span class=&quot;fu&quot;&gt;@Scheduled&lt;/span&gt;(cron = &lt;span class=&quot;st&quot;&gt;&quot;0/20 * * * * ?&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;refreshIndex&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        String ip = IPUtils.&lt;span class=&quot;fu&quot;&gt;getServerIp&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;replaceAll&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (REGULARIP.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(ip)) {
            String content = HttpHelper.&lt;span class=&quot;fu&quot;&gt;getInstance&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;http://119.29.188.224:8080&quot;&lt;/span&gt;);
            JedisUtil.&lt;span class=&quot;fu&quot;&gt;getInstance&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;index&quot;&lt;/span&gt;, content);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;capture报错&quot;&gt;capture报错&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;2018/02/10 18:53:51 [error] 2833#0: *3942 lua subrequests cycle while processing &quot;/index.html&quot;, client: 113.108.186.130, server: www.wenzhihuai.com, request: &quot;GET /index.html?pagenum=23 HTTP/1.1&quot;, subrequest: &quot;/index.html&quot;, host: &quot;www.wenzhihuai.com&quot;
2018/02/10 18:53:51 [error] 2833#0: *3942 lua entry thread aborted: runtime error: /opt/lua/hello.lua:25: failed to issue subrequest: -1
stack traceback:
coroutine 0:
    [C]: in function 'capture'
    /opt/lua/hello.lua:25: in function &lt;span class=&quot;kw&quot;&gt;&amp;lt;/opt&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;/lua/hello.lua:1&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;, client: 113.108.186.130, server: www.wenzhihuai.com, request: &quot;GET /index.html?pagenum=23 HTTP/1.1&quot;, subrequest: &quot;/index.html&quot;, host: &quot;www.wenzhihuai.com&quot;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;打开网页乱码用curl正常显示&quot;&gt;打开网页乱码，用curl正常显示&lt;/h3&gt;
&lt;p&gt;查了好久，才发现Openresty如果使用nginx.location.capture是重新请求一次的，如果带有请求头并且开启了gzip压缩，那么数据就相当于被再次压缩。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20180210073318.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;解决办法：去掉请求头部&lt;br/&gt;ngx.req.set_header(&quot;Accept-Encoding&quot;, &quot;&quot;);&lt;/p&gt;
</description>
<pubDate>Thu, 15 Feb 2018 15:15:00 +0000</pubDate>
<dc:creator>ZepheryWen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w1570631036/p/8449373.html</dc:identifier>
</item>
<item>
<title>Java数据结构和算法（九）——高级排序 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/8032632.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/8032632.html</guid>
<description>&lt;p&gt;　　春晚好看吗？不存在的！！！&lt;/p&gt;
&lt;p&gt;　　在&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/ysocean/p/7896269.html&quot;&gt;Java数据结构和算法（三）——冒泡、选择、插入排序算法&lt;/a&gt;中我们介绍了三种简单的排序算法，它们的时间复杂度大O表示法都是O(N&lt;sup&gt;2&lt;/sup&gt;)，如果数据量少，我们还能忍受，但是数据量大，那么这三种简单的排序所需要的时间则是我们所不能接受的。接着我们在讲解&lt;a href=&quot;http://www.cnblogs.com/ysocean/p/8005694.html&quot; target=&quot;_blank&quot;&gt;递归&lt;/a&gt; 的时候，介绍了归并排序，归并排序需要O(NlogN)，这比简单排序要快了很多，但是归并排序有个缺点，它需要的空间是原始数组空间的两倍，当我们需要排序的数据占据了整个内存的一半以上的空间，那么是不能使用归并排序的。&lt;/p&gt;
&lt;p&gt;　　本篇博客将介绍几种高级的排序算法：希尔排序和快速排序。&lt;/p&gt;
&lt;h3&gt;1、希尔排序&lt;/h3&gt;
&lt;p&gt;　　希尔排序是基于直接插入排序的，它在直接插入排序中增加了一个新特性，大大的提高了插入排序的执行效率。所以在讲解希尔排序之前，我们先回顾一下直接插入排序。&lt;/p&gt;
&lt;h4&gt;　　①、直接插入排序&lt;/h4&gt;
&lt;p&gt;　　直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171213170427613-1526840268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　实现代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.ys.sort;

public class InsertSort {
        public static int[] sort(int[] array){
                int j;
                //从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
                for(int i = 1 ; i &amp;lt; array.length ; i++){
                        int tmp = array[i];//记录要插入的数据
                        j = i;
                        while(j &amp;gt; 0 &amp;amp;&amp;amp; tmp &amp;lt; array[j-1]){//从已经排序的序列最右边的开始比较，找到比其小的数
                                array[j] = array[j-1];//向后挪动
                                j--;
                        }
                        array[j] = tmp;//存在比其小的数，插入
                }
                return array;
        }
                
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以分析一下这个直接插入排序，首先我们将需要插入的数放在一个临时变量中，这也是一个标记符，标记符左边的数是已经排好序的，标记符右边的数是需要排序的。接着将标记的数和左边排好序的数进行比较，假如比目标数大则将左边排好序的数向右边移动一位，直到找到比其小的位置进行插入。&lt;/p&gt;
&lt;p&gt;　　这里就存在一个效率问题了，如果一个很小的数在很靠近右边的位置，比如上图右边待排序的数据 1 ，那么想让这个很小的数 1 插入到左边排好序的位置，那么左边排好序的数据项都必须向右移动一位，这个步骤就是将近执行了N次复制，虽然不是每个数据项都必须移动N个位置，但是每个数据项平均移动了N/2次，总共就是N&lt;sup&gt;2&lt;/sup&gt;/2，因此插入排序的效率是O(N&lt;sup&gt;2&lt;/sup&gt;)。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;那么如果以某种方式不必一个一个移动中间所有的数据项，就能把较小的数据项移动到左边，那么这个算法的执行效率会有很大的改进。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;　　②、希尔排序图解&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;　　希尔排序应运而生了，希尔排序通过加大插入排序中元素的间隔，并在这些有间隔的元素中进行插入排序，从而使数据项能够大跨度的移动。当这些数据项排过一趟序后，希尔排序算法减小数据项的间隔再进行排序，依次进行下去，最后间隔为1时，就是我们上面说的简单的直接插入排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;下图显示了增量为4时对包含10个数组元素进行排序的第一个步骤，首先对下标为 0,4,8 的元素进行排序，完成排序之后，算法右移一步，对 1,5,9 号元素进行排序，依次类推，直到所有的元素完成一趟排序，也就是说间隔为4的元素都已经排列有序。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171214074919879-1993145552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当我们完成4-增量排序之后，在进行普通的插入排序，即1-增量排序，会比前面直接执行简单插入排序要快很多。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;　　③、&lt;/strong&gt;排序间隔选取&lt;/h4&gt;
&lt;p&gt;　　对于10个元素，我们选取4的间隔，那么100个数据，1000个数据，甚至更多的数据，我们应该怎么选取间隔呢？&lt;/p&gt;
&lt;p&gt;　　希尔的原稿中，他建议间隔选为N/2，也就是每一趟都将排序分为两半，因此对于N=100的数组，逐渐减小的间隔序列为：50,25,12，6,3,1。这个方法的好处是不需要在开始排序前为找到初始序列的间隔而计算序列，只需要用2整除N。但是这已经被证明并不是最好的序列。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;间隔序列中的数字互质是很重要的指标，也就是说，除了1，他们没有公约数。这个约束条件使得每一趟排序更有可能保持前一趟排序已经排好的结果，而希尔最初以N/2的间隔的低效性就是没有遵守这个准则。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;所以一种希尔的变形方法是用2.2来整除每一个间隔，对于n=100的数组，会产生序列45，20，9,4,1。这比用2会整除会显著的改善排序效果。&lt;/p&gt;
&lt;p&gt;　　还有一种很常用的间隔序列：&lt;strong&gt;knuth 间隔序列 3h+1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171214080543269-313678886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;但是无论是什么间隔序列，最后必须满足一个条件，就是逐渐减小的间隔最后一定要等于1，因此最后一趟排序一定是简单的插入排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;下面我们通过knuth间隔序列来实现希尔排序：&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;　　④、knuth间隔序列的希尔排序算法实现&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
//希尔排序 knuth 间隔序列 3h+1
public static void shellKnuthSort(int[] array){
        System.out.println(&quot;原数组为&quot;+Arrays.toString(array));
        int step = 1 ;
        int len = array.length;
        while(step &amp;lt;= len/3){
                step = step*3 + 1;//1,4,13,40......
        }       
        while(step &amp;gt; 0){
                //分别对每个增量间隔进行排序
                for(int i = step ; i &amp;lt; len ; i++){
                        int temp = array[i];
                        int j = i;
                        while(j &amp;gt; step-1 &amp;amp;&amp;amp; temp &amp;lt;= array[j-step]){
                                array[j] = array[j-step];
                                j -= step;
                        }
                        array[j] = temp;
                }//end for
                System.out.println(&quot;间隔为&quot;+step+&quot;的排序结果为&quot;+Arrays.toString(array));
                step = (step-1)/3;
        }//end while(step&amp;gt;0)
                
        System.out.println(&quot;最终排序：&quot;+Arrays.toString(array));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static void main(String[] args) {
        int[] array = {4,2,8,9,5,7,6,1,3,10};
        shellKnuthSort(array);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171214132008342-1392739245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;　　⑤、间隔为2h的希尔排序&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
//希尔排序 间隔序列2h
public static void shellSort(int[] array){
        System.out.println(&quot;原数组为&quot;+Arrays.toString(array));
        int step;
        int len = array.length;
        for(step = len/2 ;step &amp;gt; 0 ; step /= 2){
                //分别对每个增量间隔进行排序
                for(int i = step ; i &amp;lt; array.length ; i++){
                        int j = i;
                        int temp = array[j];
                        if(array[j] &amp;lt; array[j-step]){
                                while(j-step &amp;gt;=0 &amp;amp;&amp;amp; temp &amp;lt; array[j-step]){
                                        array[j] = array[j-step];
                                        j -= step;
                                }
                                array[j] = temp;
                        }
                }
                System.out.println(&quot;间隔为&quot;+step+&quot;的排序结果为&quot;+Arrays.toString(array));
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171214132038592-1921436815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、快速排序&lt;/h3&gt;
&lt;p&gt;　　快速排序是对冒泡排序的一种改进，由C. A. R. Hoare在1962年提出的一种划分交换排序，采用的是分治策略（一般与递归结合使用），以减少排序过程中的比较次数。&lt;/p&gt;
&lt;h4&gt;　　①、快速排序的基本思路&lt;/h4&gt;
&lt;p&gt;　　一、先通过第一趟排序，将数组原地划分为两部分&lt;strong&gt;，&lt;/strong&gt;其中一部分的所有数据都小于另一部分的所有数据&lt;strong&gt;。&lt;/strong&gt;原数组被划分为2份&lt;/p&gt;
&lt;p&gt;　　二、通过递归的处理， 再对原数组分割的两部分分别划分为两部分，同样是使得其中一部分的所有数据都小于另一部分的所有数据。 这个时候原数组被划分为了4份&lt;/p&gt;
&lt;p&gt;　　三、就1,2被划分后的最小单元子数组来看，它们仍然是无序的，但是！ 它们所组成的原数组却逐渐向有序的方向前进。&lt;/p&gt;
&lt;p&gt;　　四、这样不断划分到最后，数组就被划分为多个由一个元素或多个相同元素组成的单元，这样数组就有序了。&lt;/p&gt;
&lt;p&gt;　　具体实例：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201801/1120165-20180114203020379-1788606024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于上图的数组[3,1,4,1,5,9,2,6,5,3]，通过第一趟排序将数组分成了[2,1,1]或[4,5,9,3,6,5,3]两个子数组，且对于任意元素，左边子数组总是小于右边子数组。通过不断的递归处理，最终得到有序数组[1 1 2 3 3 4 5 5 6]&lt;/p&gt;
&lt;h4&gt;　　②、快速排序的算法实现&lt;/h4&gt;
&lt;p&gt;　　假设被排序的无序区间为[A[i],......,A[j]]&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;一、基准元素选取：&lt;/strong&gt;选择其中的一个记录的关键字 v 作为基准元素（控制关键字）;&lt;strong&gt;怎么选取关键字？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　二、划分：&lt;/strong&gt;通过基准元素 v 把无序区间 A[I]......A[j] 划分为左右两部分，使得左边的各记录的关键字都&lt;strong&gt;小于&lt;/strong&gt; v；右边的各记录的关键字都&lt;strong&gt;大于等于&lt;/strong&gt; v；&lt;strong&gt;（如何划分？）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　三、递归求解：重复上面的一、二步骤，&lt;/strong&gt;分别对左边和右边两部分递归进行快速排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　四、组合：&lt;/strong&gt;左、右两部分均有序，那么整个序列都有序。&lt;/p&gt;
&lt;p&gt;　　上面的第 三、四步不用多说，主要是第一步怎么选取关键字，从而实现第二步的划分？&lt;/p&gt;
&lt;p&gt;　　划分的过程涉及到三个关键字：&lt;strong&gt;“基准元素”、“左游标”、“右游标”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　基准元素：&lt;/strong&gt;它是将数组划分为两个子数组的过程中，用于界定大小的值，以它为判断标准，将小于它的数组元素“划分”到一个“小数值的数组”中，而将大于它的数组元素“划分”到一个“大数值的数组”中，这样，我们就将数组分割为两个子数组，而其中一个子数组的元素恒小于另一个子数组里的元素。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;左游标：&lt;/strong&gt;它一开始指向待分割数组最左侧的数组元素，在排序的过程中，它将向右移动。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;右游标：&lt;/strong&gt;它一开始指向待分割数组最右侧的数组元素，在排序的过程中，它将向左移动。&lt;/p&gt;
&lt;p&gt;　　注意：上面描述&lt;strong&gt;的基准元素/右游标/左游标&lt;/strong&gt;都是&lt;strong&gt;针对单趟排序过程&lt;/strong&gt;的， 也就是说，在整体排序过程的&lt;strong&gt;多趟排序中&lt;/strong&gt;，各趟排序取得的基准元素/右游标/左游标&lt;strong&gt;一般都是不同的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　对于基准元素的选取，原则上是任意的。但是一般我们选取数组中第一个元素为基准元素（假设数组是随机分布的）&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;　　&lt;/strong&gt;③、快速排序图示&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201801/1120165-20180114210852832-1262709780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　上面表示的是一个无序数组，选取第一个元素 6 作为基准元素。左游标是 i 哨兵，右游标是 j 哨兵。然后左游标向左移动，右游标向右移动，它们遵循的规则如下：&lt;/p&gt;
&lt;p&gt;　　一、&lt;strong&gt;左游标&lt;/strong&gt;向&lt;strong&gt;右&lt;/strong&gt;扫描， &lt;strong&gt;跨过所有小于基准元素的数组元素&lt;/strong&gt;, 直到遇到一个&lt;strong&gt;大于或等于基准元素&lt;/strong&gt;的数组元素， 在那个位置&lt;strong&gt;停下&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　二、&lt;strong&gt;右游标&lt;/strong&gt;向&lt;strong&gt;左&lt;/strong&gt;扫描， &lt;strong&gt;跨过所有大于基准元素的数组元素, &lt;/strong&gt;直到遇到一个&lt;strong&gt;小于或等于基准元素&lt;/strong&gt;的数组元素，在那个位置&lt;strong&gt;停下。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第一步：&lt;/strong&gt;哨兵 j 先开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵 j 先开始出动，哨兵 j 一步一步的向左挪动，直到找到一个小于 6 的元素停下来。接下来，哨兵 i 再一步一步的向右挪动，直到找到一个大于 6 的元素停下来。最后哨兵 i 停在了数字 7 面前，哨兵 j 停在了数字 5 面前。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201801/1120165-20180114212750644-2017570021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到此，第一次交换结束，接着哨兵 j 继续向左移动，它发现 4 比基准数 6 要小，那么在数字4面前停下来。哨兵 i 也接着向右移动，然后在数字 9 面前停下来，然后哨兵 i 和 哨兵 j 再次进行交换。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201801/1120165-20180114213013301-565254427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第二次交换结束，哨兵 j 继续向左移动，然后在数字 3 面前停下来；哨兵 i 继续向右移动，但是它发现和哨兵 j 相遇了。那么此时说明探测结束，将数字 3 和基准数字 6 进行交换，如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201801/1120165-20180114213225254-1341577969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到此，第一次探测真正结束，此时已基准点 6 为分界线，6 左边的数组元素都小于等于6,6右边的数组元素都大于等于6。&lt;/p&gt;
&lt;p&gt;　　左边序列为【3,1,2,5,4】,右边序列为【9,7,10,8】。接着对于左边序列而言，以数字 3 为基准元素，重复上面的探测操作，探测完毕之后的序列为【2,1,3,5,4】；对于右边序列而言，以数字 9 位基准元素，也重复上面的探测操作。然后一步一步的划分，最后排序完全结束。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;通过这一步一步的分解，我们发现快速排序的每一轮操作就是将基准数字归位，知道所有的数都归位完成，排序就结束了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201801/1120165-20180114214451863-1488356154.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;　　④、快速排序完整代码&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;74&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.ys.high.sort;

public class QuickSort {
        
        //数组array中下标为i和j位置的元素进行交换
        private static void swap(int[] array , int i , int j){
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
        }
        
        private static void recQuickSort(int[] array,int left,int right){
                if(right &amp;lt;= left){
                        return;//终止递归
                }else{
                        
                        int partition = partitionIt(array,left,right);
                        recQuickSort(array,left,partition-1);// 对上一轮排序(切分)时，基准元素左边的子数组进行递归
                        recQuickSort(array,partition+1,right);// 对上一轮排序(切分)时，基准元素右边的子数组进行递归
                }
        }
        
        private static int partitionIt(int[] array,int left,int right){
                //为什么 j加一个1，而i没有加1,是因为下面的循环判断是从--j和++i开始的.
                //而基准元素选的array[left],即第一个元素，所以左游标从第二个元素开始比较
                int i = left;
                int j = right+1;
                int pivot = array[left];// pivot 为选取的基准元素（头元素）
                while(true){
                        while(i&amp;lt;right &amp;amp;&amp;amp; array[++i] &amp;lt; pivot){}
                        
                        while(j &amp;gt; 0 &amp;amp;&amp;amp; array[--j] &amp;gt; pivot){}
                        
                        if(i &amp;gt;= j){// 左右游标相遇时候停止， 所以跳出外部while循环
                                break;
                        }else{
                                swap(array, i, j);// 左右游标未相遇时停止, 交换各自所指元素，循环继续 
                        }
                }
                swap(array, left, j);//基准元素和游标相遇时所指元素交换，为最后一次交换
                return j;// 一趟排序完成， 返回基准元素位置(注意这里基准元素已经交换位置了)
        }
        
        public static void sort(int[] array){
                recQuickSort(array, 0, array.length-1);
        }
        
        //测试
        public static void main(String[] args) {
                //int[] array = {7,3,5,2,9,8,6,1,4,7};
                int[] array = {9,9,8,7,6,5,4,3,2,1};
                sort(array);
                for(int i : array){
                        System.out.print(i+&quot; &quot;);
                }
                //打印结果为：1 2 3 4 5 6 7 7 8 9 
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　⑤、优化分析&lt;/h4&gt;
&lt;p&gt;　　假设我们是对一个逆序数组进行排序，选取第一个元素作为基准点，即最大的元素是基准点，那么第一次循环，左游标要执行到最右边，而右游标执行一次，然后两者进行交换。这也会划分成很多的子数组。&lt;/p&gt;
&lt;p&gt;　　那么怎么解决呢？理想状态下，应该选择被排序数组的中值数据作为基准，也就是说一半的数大于基准数，一般的数小于基准数，这样会使得数组被划分为两个大小相等的子数组，对快速排序来说，&lt;strong&gt;拥有两个大小相等的子数组是最优的情况。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　三项取中划分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;为了找到一个数组中的中值数据，一般是取数组中第一个、中间的、最后一个，选择这三个数中位于中间的数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
   //取数组下标第一个数、中间的数、最后一个数的中间值
        private static int medianOf3(int[] array,int left,int right){
                int center = (right-left)/2+left;
                if(array[left] &amp;gt; array[right]){ //得到 array[left] &amp;lt; array[right]
                        swap(array, left, right);
                }
                if(array[center] &amp;gt; array[right]){ //得到 array[left] array[center] &amp;lt; array[right]
                        swap(array, center, right);
                }
                if(array[center] &amp;gt; array[left]){ //得到 array[center] &amp;lt;  array[left] &amp;lt; array[right]
                        swap(array, center, left);
                }
                
                return array[left]; //array[left]的值已经被换成三数中的中位数， 将其返回
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
    private static int partitionIt(int[] array,int left,int right){
                //为什么 j加一个1，而i没有加1,是因为下面的循环判断是从--j和++i开始的.
                //而基准元素选的array[left],即第一个元素，所以左游标从第二个元素开始比较
                int i = left;
                int j = right+1;
                int pivot = array[left];// pivot 为选取的基准元素（头元素）
                
                int size = right - left + 1;
                if(size &amp;gt;= 3){
                        pivot = medianOf3(array, left, right); //数组范围大于3，基准元素选择中间值。
                }
                while(true){
                        while(i&amp;lt;right &amp;amp;&amp;amp; array[++i] &amp;lt; pivot){}
                        
                        while(j &amp;gt; 0 &amp;amp;&amp;amp; array[--j] &amp;gt; pivot){}
                        
                        if(i &amp;gt;= j){// 左右游标相遇时候停止， 所以跳出外部while循环
                                break;
                        }else{
                                swap(array, i, j);// 左右游标未相遇时停止, 交换各自所指元素，循环继续 
                        }
                }
                swap(array, left, j);//基准元素和游标相遇时所指元素交换，为最后一次交换
                return j;// 一趟排序完成， 返回基准元素位置(注意这里基准元素已经交换位置了)
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;处理小划分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;如果使用三数据取中划分方法，则必须遵循快速排序算法不能执行三个或者少于三个的数据，如果大量的子数组都小于3个，那么使用快速排序是比较耗时的。联想到前面我们讲过简单的排序（冒泡、选择、插入）。&lt;/p&gt;
&lt;p&gt;　　当数组长度小于M的时候（high-low &amp;lt;= M）， 不进行快排，而进行插入排序。&lt;strong&gt;转换参数M的最佳值和系统是相关的，一般来说， 5到15间的任意值在多数情况下都能令人满意。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
    //插入排序
        private static void insertSort(int[] array){
                for(int i = 1 ; i &amp;lt; array.length ; i++){
                        int temp = array[i];
                        int j = i;
                        while(j &amp;gt; 0 &amp;amp;&amp;amp; array[j-1] &amp;gt; temp){
                                array[j] = array[j-1];
                                j--;
                        }
                        array[j] = temp;
                }
        }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 15 Feb 2018 15:04:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/8032632.html</dc:identifier>
</item>
<item>
<title>2017年度总结 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/running2017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/running2017.html</guid>
<description>&lt;p&gt;滴答~ 滴答~ 滴答~&lt;/p&gt;
&lt;p&gt;无论你在意，还是不在意，时间总是按照自己的节奏，从你的身旁悄悄溜走。他无声无息，来去无踪，却又让人着迷。&lt;/p&gt;
&lt;p&gt;这一年，是忙碌的，以至于没有太多的时间捕捉生活的细枝末节。这一年，又是引人思考的，因为有些问题就直愣愣的摆在面前，绕不开，躲不过。这一年，是充实的，因为，写起这篇年度总结的时候，脑海中浮现出很多的关键词……&lt;/p&gt;
&lt;h5 id=&quot;我与生活相互打磨&quot;&gt;我与生活相互打磨&lt;/h5&gt;
&lt;p&gt;细数过往，我们总能从各个途径听到不同的声音——&lt;/p&gt;
&lt;p&gt;“你还不懂，等你以后进入社会就知道了”&lt;/p&gt;
&lt;p&gt;“好好珍惜吧，以后路还长着呢”&lt;/p&gt;
&lt;p&gt;“我跟你说啊，现在该吃吃，该喝喝，以后哪还能这么随心所欲”&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;声音很嘈杂，但是都是在传递一个信号：有些事需要自己经历才深刻！&lt;/p&gt;
&lt;p&gt;年初考虑到实际情况，于是在县城购置一套房产。让原来小步快跑的还贷方式变成了大步流星。我和媳妇在规定的齿轮上中规中矩的运转，一点不敢懈怠，确保严丝合缝。&lt;/p&gt;
&lt;p&gt;儿子的到来，更是一剂胶水，把我们，尤其是媳妇，粘的紧紧的。我们一家五口人，在配合儿子的作息时间上天然很默契。他睡觉，我们吃饭，然后等着他醒来。他醒了，我们轮流逗，轮流抱。他拉尿了，有人负责拿尿不湿，有人负责打热水，老妈负责帮儿子洗屁股，有人负责清理现场。&lt;/p&gt;
&lt;p&gt;第一次当爸妈，第一次当爷爷奶奶的一家人，在遇到困难的时候，总是想象美好的未来来为现在的自己打气。&lt;/p&gt;
&lt;p&gt;“等再长大点，身子长结实了，就不用这么扶着头了”&lt;/p&gt;
&lt;p&gt;“等再长大点，就可以爬了，不用一直抱着”&lt;/p&gt;
&lt;p&gt;“等再长大点，会走了，就不用一家都铺着护垫了”&lt;/p&gt;
&lt;p&gt;“等再长大点，什么都会说，就不用我们猜了”&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;等再长大点，我们就真的可以出去玩一趟了，从三月份推到五月份，从五月份推到十月份，现在的计划是明年出来玩一趟。生活，有时候就是这么生不由己，但又让人割舍不下，因为，说不定哪天冒出来的彩蛋就可以让你又是精神抖擞，把过去经历的所有不容易抛之脑后。&lt;/p&gt;
&lt;p&gt;过去充满诸多挑战和未知的一年，我们也走过来了。&lt;/p&gt;
&lt;p&gt;有时候生活打磨你，是为了让你更加珍惜，有时候你与生活磨合，是为了让前途更加宽阔、平坦。&lt;/p&gt;
&lt;h5 id=&quot;来到这里我看到了更多可能性&quot;&gt;来到这里，我看到了更多可能性&lt;/h5&gt;
&lt;p&gt;“找个会议室，过下需求。。。看来是没有会议室了，去茶水间吧。。。好吧，茶水间有人正在面试，我们去游戏室吧”&lt;/p&gt;
&lt;p&gt;“今天尽快出一版设计方案，下班之前我们再review下”&lt;/p&gt;
&lt;p&gt;“尽快调试对接，准备上线”&lt;/p&gt;
&lt;p&gt;“线上有个bug，快，快，快， 修好赶紧上线”&lt;/p&gt;
&lt;p&gt;上面的诸多场景构成了我2017年的日常。对于我来说，仿佛自己就是一条视频，16年的时候，我是0.5倍速率播放，17年，我已经切换到1.5速率。&lt;/p&gt;
&lt;p&gt;相比过去，我需要关心的是，读懂国外大佬丢给我的设计文档，确保写出符合要求的功能代码，由老大负责merge代码，然后通过Jenkins编译，再由运维人员负责上线，灰度发布，通过集成测试、回归测试。&lt;/p&gt;
&lt;p&gt;规范的流程带来了很多的好处，比如拿到的设计文档很少因为需求变动重新设计，通过Jenkins那关，就大大降低了你代码对于其他已有功能破坏性的嫌疑，通过上线、测试，基本你的任务就告一段落，因为后面有强大的运维团队和售前售后团队保驾护航。&lt;/p&gt;
&lt;p&gt;但凡事都有两面性。在这样一个分工明确，高效协作的团队里，每个人只要也只能做好自己的本职工作，想要跳脱自己螺丝钉的角色的难度就比较大。这应该是很多大公司的通病，在中小型公司就要灵活很多。&lt;/p&gt;
&lt;p&gt;这一年，我不仅仅是一名码农，有时候我是设计师，有时候是开发工程师，有时候是测试工程师，有时候我还是一名客服，一名救火队员。&lt;/p&gt;
&lt;p&gt;通过过去一年的工作，让我切实意识到文档的重要性。估计很多开发人员都不愿意写技术文档或者设计文档，一方面是写文档比较浪费时间，另外是在没有动手写代码之前，也很难把各种可能的情况想的周全。&lt;/p&gt;
&lt;p&gt;但是估计很多人也包括我都有这样的体会，在代码写到中途的时候突然发现有些字段漏了，或者某个流程想不通，思来想去发现之前在大脑中写好的设计方案有点简单了。所以，有时候我们就花费了大量的时间在泥潭中挣扎。即使最终从泥潭中爬出来，也是落得一身泥。&lt;/p&gt;
&lt;p&gt;自己参与几个项目之后，写了一些文档，包括总体技术设计文档，数据库设计文档，接口设计文档，测试用例文档等等，我时常有种庆幸和惊喜的感觉。有次在写一个业务流程稍微复杂的模块代码后，找老大帮忙review，但是看着有点晕头转向的，老大建议画个流程图。于是我就重新梳理了下这块业务，把各种情况都考虑下，画完了流程图，回头对照时，发现自认为写的比较缜密的代码居然遗漏了一种情况，于是，悄悄的把它补上去了，哈哈哈哈哈！&lt;/p&gt;
&lt;p&gt;还有一次，开发好了一个新功能，功能不复杂，但是测试的情况比较多，需要找测试人员测试，之前测试人员也没有对接过这块业务，于是我着手写了一份测试用例文档。写好之后，测试人员只要按照这份文档无脑测试即可，最重要的时，后来发现，因为这块业务比较重要，所以后面很多地方代码变动，都要做回归测试，所以这份文档就更加显得一劳永逸了。&lt;/p&gt;
&lt;p&gt;过去一年，看了阿里的代码规范，读了《代码整洁之道》、《重构，改善既有代码的设计》这样的书，让我对代码有了一颗敬畏之心。每个人都有自己的编码风格，但是代码本身除了能够让机器认识他运行他以外，还要让别人能够读懂他维护他，所以代码规范显得非常重要。17年我有分享过自己对于代码整洁之道的心得体会，同时也贡献了自己关于这方面的第一次视频直播。&lt;/p&gt;
&lt;p&gt;代码规范是平时一点一点的积累和践行，比如如何做好变量命名，如何避免使用魔法值，如何做到函数的单一职责，如何写注释。将这些知识点都收集并消化，写出一手优美的代码，你敬畏代码，代码也会很少找你的茬。&lt;/p&gt;
&lt;p&gt;过去一年，我浅浅的明白了什么是职业素养。当合作方反馈功能有问题时，拖着是无济于事的，因为问题依旧摆在那儿，极小概率会自动恢复正常，而且拖的越久，越是增加双方的负面情绪。及时的沟通和解决问题是一种很好的职业素养，合作方因为你的即使反馈感动不已，你因为合作方鼓励而倍感荣耀。当手机报警短信喋喋不休，邮箱报警邮件狂空滥炸，&lt;a href=&quot;mailto:报警群疯狂@你的时候&quot;&gt;报警群疯狂@你的时候&lt;/a&gt;，此时身心可能是崩溃的。但是职业素养告诉我们，还是静下心来，踏踏实实解决问题，接触报警最重要。&lt;/p&gt;
&lt;p&gt;之前听一位同事告诉我说，他的梦里有一位高人经常在他问题想不通给的时候，在梦里助他一臂之力，帮他解决了很多难题。起初，我觉得很玄乎，半信半疑。直到，后来我也遇到过一次贵人相助，白天工作的时候有个并发的问题始终百思不得其解，看日志，调试都未果。下班回家也一直在想这个问题，一直到睡觉都没想明白。第二天醒来，兴奋的不行，因为我居然在梦里找到了答案，一早去上班，改了下代码，问题真的搞定了。其实，现在我也觉得很玄乎，但是我大概觉得这也跟职业素养有关系吧&lt;/p&gt;
&lt;h5 id=&quot;知道自己不知道&quot;&gt;知道自己不知道&lt;/h5&gt;
&lt;p&gt;认知有四个状态：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不知道自己不知道&lt;/li&gt;
&lt;li&gt;知道自己不知道&lt;/li&gt;
&lt;li&gt;知道自己知道&lt;/li&gt;
&lt;li&gt;不知道自己知道&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;没有当父亲之前，我不知道自己不知道。有时候只是一闪而过，以后我会成为一名父亲，我将会有自己的子女，但我没有想更多更细的事情。&lt;/p&gt;
&lt;p&gt;这一年，我知道自己不知道。虽然我平均大半个月才回去一次，但是每次回去听爸妈媳妇像做汇报表演一样跟我讲述儿子的变化和成长时，我常常大喜过望，同时“不知道”的心里活动也在加强。&lt;/p&gt;
&lt;p&gt;我慢慢开始关注育儿各方面的知识点和经验。婴儿吐奶应该怎么办，婴儿莫名的哭闹到底是什么原因，饮食问题，宝宝发烧了是否能捂着，抗生素尽量少用，咳嗽分为哪几种。遇到知识盲点并且有用的，我就转发给媳妇，我们一家人在应对养孩子问题上其实有时候也是手足无措，像个孩子。&lt;/p&gt;
&lt;p&gt;这一年，90年的已经到27了。此起彼伏的“中年危机”话题让你捂上耳朵也无济于事，因为他一直在你的心底发声，拽着你从“不知道自己不知道”或者“不想知道”一直往“知道自己不知道”方向去。来公司之前，用过很多技术，但是都不深刻，来了这里，开始用Redis、RabbitMQ、RPC、微服务等等新理念和新技术。知道自己不知道的还特别多，我开始通过买书和看书来填补自己内心的恐慌。&lt;/p&gt;
&lt;p&gt;把之前没有看明白的Spring框架源码又看了一遍，得到的体会就是知道自己不知道，同时还有不知道自己不知道的部分。看了Java8的一些好用的特性并渐渐的在实际编码中使用起来。看了RabbitMQ的用法并在做自媒体的那段时间快把入门文档翻译的差不多了……&lt;/p&gt;
&lt;h5 id=&quot;展望&quot;&gt;展望&lt;/h5&gt;
&lt;p&gt;过去一年看了一些书，有技术的、财经的、育儿的、日常护理的，每周累计一个多小时。这个习惯在2018年继续保持，争取每周累计三小时，注意精神食粮营养均衡&lt;/p&gt;
&lt;p&gt;过去一年写了不少文章，博客粉丝累计382位（去年：176），2018年争取抽出更多的时间写出更好的文章，感谢大家的支持&lt;/p&gt;
&lt;p&gt;微信公众号累计关注者703（去年256），曾经有一个多月时间在各大自媒体平台间活跃，包括今日头条、天天新闻、百家号等，积累了一些粉丝，后来因为精力有限都停更了，现在主要是公众号、博客、和腾讯云社区&lt;/p&gt;
&lt;p&gt;将自己的知识块梳理整合，形成自己的方法体系，有自己的思考面&lt;/p&gt;
&lt;p&gt;多出去走走，至少一次出远门旅行&lt;/p&gt;
&lt;h5 id=&quot;结语&quot;&gt;结语&lt;/h5&gt;
&lt;p&gt;祝大家工作顺利，生活幸福，心想事成！&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Feb 2018 11:32:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/running2017.html</dc:identifier>
</item>
<item>
<title>4.C++中的函数重载,C++调用C代码,new/delete关键字,namespace(命名空间) - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8449703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8449703.html</guid>
<description>&lt;p&gt;&lt;span&gt;本章主要内容:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1)&lt;/span&gt;&lt;/strong&gt;函数重载 &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2)&lt;/span&gt;&lt;/strong&gt;C++&lt;span&gt;调用&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;代码 &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;3)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;/&lt;span&gt;delete&lt;/span&gt;关键字实现动态内存分配&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;命名空间&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;大家都知道&lt;/span&gt;,&lt;span&gt;在生活中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;动词和不同的名词搭配一起&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;意义都会大有不同&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;比如&lt;/span&gt;&lt;span&gt;”玩”&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;玩&lt;/span&gt;游戏&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;玩&lt;/span&gt;卡牌&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;玩&lt;/span&gt;足球&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;所以在&lt;/span&gt;C++&lt;span&gt;中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;便出现了&lt;strong&gt;&lt;span&gt;函数重载&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(JAVA,c#&lt;/span&gt;&lt;span&gt;等语言都有函数重载&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.&lt;span&gt;函数重载&lt;/span&gt;&lt;span&gt;(overload)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;表示有多个相同的函数名&lt;/span&gt;&lt;span&gt;(&lt;span&gt;类似上面的&lt;/span&gt;”玩”)&lt;/span&gt;,&lt;span&gt;但是参数表不同&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;类似上面的动词&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数表不同主要有以下几种&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1)&lt;/span&gt; &lt;/strong&gt;参数&lt;span&gt;个数&lt;/span&gt;不同&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2)&lt;/strong&gt; &lt;/span&gt;参数&lt;span&gt;类型&lt;/span&gt;不同&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3) &lt;/span&gt;&lt;/strong&gt;参数&lt;span&gt;顺序&lt;/span&gt;不同&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;1.1&lt;span&gt;举个栗子&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; func(&lt;span&gt;char&lt;/span&gt; *str)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;func1&lt;/span&gt;&lt;span&gt;
{
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str=%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str);  
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; func(&lt;span&gt;int&lt;/span&gt; a)            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;func2&lt;/span&gt;
&lt;span&gt;{
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; func(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;func3&lt;/span&gt;&lt;span&gt;
{
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a*b =%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,a*&lt;span&gt;b);
}


&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
 &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; s[&lt;span&gt;10&lt;/span&gt;]=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

 func(s);
 func(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
 func(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);           
}        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输出结果&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
str=&lt;span&gt;hello
a&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
a&lt;/span&gt;*b =&lt;span&gt;25&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过上个栗子可以看到&lt;/span&gt;,&lt;span&gt;函数名相同&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;参数不同&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;而意义却大有不同&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2&lt;span&gt;那这些重载函数的&lt;span&gt;入口地址&lt;/span&gt;是否相同&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;修改上面栗子的&lt;/span&gt;&lt;span&gt;main()&lt;/span&gt;&lt;span&gt;函数&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;如下图所示&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201802/1182576-20180215182216312-1942813064.png&quot; alt=&quot;&quot; width=&quot;547&quot; height=&quot;125&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可以看到输出结果&lt;/span&gt;,&lt;span&gt;每个函数的入口地址都不一样&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;span&gt;重载函数的入口地址&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;必须使用强制转换来获取&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;也可以通过&lt;/span&gt;&lt;span&gt;nm&lt;/span&gt;&lt;span&gt;&lt;span&gt;命令&lt;/span&gt;来查看符号表&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;如下图所示&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201802/1182576-20180215182231906-1655426569.png&quot; alt=&quot;&quot; width=&quot;370&quot; height=&quot;145&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;注意&lt;/span&gt;:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;重载函数需要&lt;strong&gt;&lt;span&gt;避免使用&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;参数默认值&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;调用重载函数时&lt;/span&gt;,&lt;span&gt;只会匹配函数&lt;strong&gt;&lt;span&gt;参数表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;与函数&lt;strong&gt;&lt;span&gt;返回值&lt;/span&gt;&lt;/strong&gt;无关&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;函数重载必须发生在&lt;strong&gt;&lt;span&gt;同一个作用域&lt;/span&gt;&lt;/strong&gt;中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;重载函数的入口地址&lt;/span&gt;,&lt;span&gt;不能直接通过函数名来获取&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.C++&lt;span&gt;与&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;代码相互调用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;当&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;想调用&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;里的某个函数时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;则使用&lt;/span&gt;&lt;span&gt;&lt;span&gt;extern&lt;/span&gt; “C”&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;还是举个栗子&lt;/span&gt;,&lt;span&gt;通过&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;调用&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;里面的&lt;/span&gt;&lt;span&gt;add()&lt;/span&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1) &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;首先创建&lt;/span&gt;3&lt;span&gt;个文件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201802/1182576-20180215182240296-805041704.png&quot; alt=&quot;&quot; width=&quot;393&quot; height=&quot;83&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;add.c&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;代码如下&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
{
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;add.h&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;代码如下&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;main.cpp&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;代码如下&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;

#ifdef __cplusplus
&lt;/span&gt;&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过C方式来编译add.h,也就是add()函数&lt;/span&gt;&lt;span&gt;
{
  #include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
  printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,add(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;));
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;main.cpp&lt;span&gt;里的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;__cplusplus&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;宏&lt;/span&gt;&lt;/strong&gt;是&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;编译器自带的&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;而&lt;/span&gt;&lt;strong&gt;&lt;span&gt;extern &quot;C&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;只有&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;里才有定义.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以通过&lt;strong&gt;&lt;span&gt;__cplusplus宏&lt;/span&gt;&lt;/strong&gt;判断,&lt;/span&gt;&lt;span&gt;可以使&lt;/span&gt;&lt;span&gt;main.cpp&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;编译器下都能编译运行&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2)&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;编译运行&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
gcc  -c  add.c                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成add.o文件&lt;/span&gt;&lt;span&gt;
g&lt;/span&gt;++  -o  main   main.cpp  add.o   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成main可执行文件&lt;/span&gt;&lt;span&gt;
.&lt;/span&gt;/main
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;3)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;输出结果&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201802/1182576-20180215182252718-1840693196.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. C++&lt;span&gt;中的动态内存分配&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1 &lt;span&gt;回顾&lt;/span&gt;&lt;span&gt;C:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;C&lt;span&gt;语言中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;大家都知道使用&lt;/span&gt;&lt;strong&gt;&lt;span&gt;malloc()&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;free()&lt;/span&gt;&lt;/strong&gt;,&lt;/span&gt;&lt;span&gt;比如&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; *p = malloc(&lt;span&gt;10&lt;/span&gt;*&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));  //申请10个int型空间 
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(p)
{
  ... ...
  free(p);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从上面栗子&lt;/span&gt;,&lt;span&gt;可以看到&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;是通过库函数完成内存分配的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.2&lt;span&gt;而在&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;则通过&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt;关键字&lt;/span&gt;进行内存申请&lt;/span&gt;&lt;span&gt;,&lt;span&gt;delete&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;关键字&lt;/span&gt;进行内存释放&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;比如&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201802/1182576-20180215182307671-52669379.png&quot; alt=&quot;&quot; width=&quot;572&quot; height=&quot;120&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Type: &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;指数据类型&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;比如&lt;/span&gt;&lt;span&gt;int,char,float&lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;N:  &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;指申请的数组个数大小&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;除了上图例子外&lt;/span&gt;,new&lt;span&gt;关键字还可以通过&lt;strong&gt;&lt;span&gt;分配并初始化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;类似&lt;/span&gt;&lt;span&gt;calloc()&lt;/span&gt;&lt;span&gt;函数&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;例如&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; *p1= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态分配一个int空间给p1,并赋值为1&lt;/span&gt;

&lt;span&gt;float&lt;/span&gt; *p2=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;(&lt;span&gt;2.0f&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.0后面加f,表示2.0是个float类型&lt;/span&gt;

&lt;span&gt;char&lt;/span&gt; *p3=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;注意&lt;/span&gt;:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;释放数组的空间时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;必须使用&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;delete[]&lt;/span&gt;&lt;/strong&gt;,&lt;/span&gt;&lt;span&gt;避免内存泄漏&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.C++&lt;span&gt;中的命名空间&lt;/span&gt;&lt;span&gt;(namespace)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.1&lt;span&gt;回顾&lt;/span&gt;&lt;span&gt;C:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;大家都知道&lt;/span&gt;,&lt;span&gt;在&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;语言中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;当编译多个&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;文件时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;可能会遇到同名全局标识符的错误&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;这是因为&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;语言中的所有全局标识符都是共享同一个作用域&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.2&lt;span&gt;所以&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;中便提出命名空间&lt;/span&gt;&lt;span&gt;(namespace)&lt;/span&gt;&lt;span&gt;的概念&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;命名空间会将全局作用域&lt;strong&gt;&lt;span&gt;分成&lt;/span&gt;&lt;span&gt;不同部分&lt;/span&gt;&lt;/strong&gt;的命令空间&lt;/span&gt;,&lt;span&gt;可以将类&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;函数等聚集在一个&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;里&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不同命名空间&lt;/span&gt;&lt;/strong&gt;中的标识符&lt;span&gt;&lt;strong&gt;可以同名&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;命名空间可以&lt;strong&gt;&lt;span&gt;相互嵌套&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;,&lt;span&gt;也就是说&lt;/span&gt;&lt;strong&gt;&lt;span&gt;A&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;命令空间&lt;/span&gt;&lt;/strong&gt;里可以再次定义&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;命令空间&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;C++&lt;span&gt;中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;全局作用域也叫&lt;strong&gt;&lt;span&gt;默认命名空间&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.3&lt;span&gt;命名空间&lt;/span&gt;&lt;span&gt;(namespace)&lt;/span&gt;&lt;span&gt;的使用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1)&lt;/strong&gt;&lt;/span&gt;定义一个命名空间&lt;/span&gt;: &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt; name   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个命名空间,名为name&lt;/span&gt;
&lt;span&gt;{
     &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; varialbe;
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;... ...&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2)&lt;/strong&gt;&lt;/span&gt;使用整个命名空间&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt; name;   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;3)&lt;/strong&gt;&lt;/span&gt;使用整个命名空间中的变量&lt;/span&gt;: &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
::varialbe;     
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4)&lt;/strong&gt;&lt;/span&gt;使用某个命名空间中的变量&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt; name::variable      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用name空间里的variable变量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4.4 举个栗子&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

&lt;span&gt;namespace&lt;/span&gt; First &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义First命名空间&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt; Second &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义Second命名空间&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1;&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt; Internal &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在Second里,再次定义一个Internal空间(实现嵌套)&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Position
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y;
        };
    }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt; First;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用First整个命名空间,成为该main()的默认空间&lt;/span&gt;
    &lt;span&gt;using&lt;/span&gt; Second::Internal::Position; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Second-&amp;gt;Internal空间里的Position结构体&lt;/span&gt;
&lt;span&gt;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;First::i = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i);     

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Second::i = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Second::i);
    
    Position p &lt;/span&gt;= {&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;};  
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p.x = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, p.x);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p.y = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, p.y);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出结果:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
First::i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Second::i &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
p.x &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
p.y &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;未完待续&lt;/span&gt;,&lt;span&gt;下章继续学习&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;中的强制转换&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Feb 2018 10:54:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8449703.html</dc:identifier>
</item>
<item>
<title>DirectSound---简易Wav播放器 - lgxZJ</title>
<link>http://www.cnblogs.com/lgxZJ/p/8449442.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lgxZJ/p/8449442.html</guid>
<description>&lt;p&gt;这篇文章主要给大家介绍下如何用DirectSound打造一个简易播放器，因为篇幅有限且代码逻辑较为复杂，我们只介绍下核心技术内容。该播放器主要包括以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;播放、暂停&lt;/li&gt;
&lt;li&gt;播放进度提示。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;directsound播放概念简介&quot;&gt;1. DirectSound播放概念简介&lt;/h2&gt;
&lt;h3 id=&quot;播放相关概念&quot;&gt;1.1 播放相关概念&lt;/h3&gt;
&lt;p&gt;首先要介绍下DirectSound的设计理念：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/02/14/5a8440af1d779.png&quot; alt=&quot;buffer-pic&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在DirectSound中，你需要播放的音频一般需要（也可以直接放入主缓冲区，但是操作上比较困难而且对其他DirectSound程序不太友好）放入一个被称为&lt;strong&gt;次缓冲区&lt;/strong&gt;（Secondary Buffer）的地址区域中，该缓冲区由开发者人为创建操控。由于DirectSound支持多个音频同时播放，所以我们可以创建多个缓冲区并同时播放。在播放时，放入次缓冲区的音频先会被送入一个叫做&lt;strong&gt;主缓冲区&lt;/strong&gt;（Primary Buffer）的地方进行混音，然后在送入硬件声卡中进行播放。在Windows driver model，即WDM模式下，DirectSound实际上不能直接操作声卡硬件，所有的混音操作不是送给主缓冲区而是被&lt;strong&gt;送往内核混音器&lt;/strong&gt;（Kernel Mixer）进行混音，然后由内核混音器送往硬件。在WDM模式下，内核混音器替代了主缓冲区的功能位置。&lt;/p&gt;
&lt;h3 id=&quot;缓冲区相关概念&quot;&gt;1.2 缓冲区相关概念&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/02/14/5a84440c5777b.png&quot; alt=&quot;circle-buffer&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DirectSound的缓冲区类别大体可以分为两种：1) &lt;strong&gt;静态缓冲区&lt;/strong&gt;，2) &lt;strong&gt;流缓冲区&lt;/strong&gt;。静态缓冲区就是一段较短的音频全部填充到一个缓冲区中，然后从头到尾播放；流缓冲区可以描述为音频流，实际上这种流也是通过单个有长度的缓冲区来抽象模拟的。在流缓冲区模式下，单个缓冲区会被&lt;strong&gt;重复填充和播放&lt;/strong&gt;，也就是说当DirectSound播放到缓冲区的最后一个尾部时，它会回到缓冲区的头部继续开始播放。因此，在播放较长的音频文件时需要开发者手动循环填充缓冲区。&lt;/p&gt;
&lt;p&gt;DirectSound中还有游标（cursor）的概念，游标分两种：1) &lt;strong&gt;播放游标&lt;/strong&gt;（play cusror），2) &lt;strong&gt;写入游标&lt;/strong&gt;（write cursor）。顾名思义，播放游标指向当前播放的地址，写入游标指向当前&lt;strong&gt;可以写入的开始地址&lt;/strong&gt;，写入游标总是在播放游标前面，且两者之间的数据块已经被DirectSound预定，不能被写入。其中，播放指针可以通过函数来更改，而写入指针由DirectSound自己控制，开发者不能操作它。一旦次缓冲区设定好音频格式，在播放中这两个游标会一直保持固定的间距：如果没记错，采样率44100Hz、2声道、8比特的音频数据，两者的位置间隔660字节，也就是&lt;code&gt;1/70&lt;/code&gt;秒的数据。&lt;/p&gt;
&lt;p&gt;为了在适当的时候填充下一块要播放的数据，DirectSound提供了&lt;strong&gt;notify&lt;/strong&gt;的功能：当播放到某一个缓冲区位置的时候，他会提醒你。该notify功能的实现通过Windows的事件对象（Event Object）实现，也就是说你需要等待这个事件被唤醒，在GUI程序中，这通常意味着你需要另起一个线程。&lt;/p&gt;
&lt;h2 id=&quot;播放器实现&quot;&gt;2. 播放器实现&lt;/h2&gt;
&lt;h3 id=&quot;创建缓冲区&quot;&gt;2.1 创建缓冲区&lt;/h3&gt;
&lt;p&gt;通过调用&lt;code&gt;IDirectSound8::CreateSoundBuffer(...)&lt;/code&gt;函数，我们创建一个能够容纳&lt;em&gt;seconds&lt;/em&gt;秒的次缓冲区。参数DSBUFFERDESC中需要指定&lt;code&gt;DSBCAPS_CTRLPOSITIONNOTIFY、DSBCAPS_GETCURRENTPOSITION2&lt;/code&gt;，前者允许我们设置notify，后者保证我们在调用&lt;code&gt;IDirectSoundBuffer8::GetCurrentPosition(...)&lt;/code&gt;时播放游标的位置比较准确。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void WavPlayer::createBufferOfSeconds(unsigned seconds)
{
    DSBUFFERDESC bufferDescription;
    bufferDescription.dwSize = sizeof(bufferDescription);
    bufferDescription.dwFlags = DSBCAPS_CTRLPOSITIONNOTIFY |
                                DSBCAPS_GLOBALFOCUS |
                                DSBCAPS_GETCURRENTPOSITION2 |
                                DSBCAPS_LOCDEFER ;
    bufferDescription.dwBufferBytes = m_secondaryBufferSize
                                    = m_wavFile.getWaveFormat().nAvgBytesPerSec * seconds;
    bufferDescription.dwReserved = 0;
    bufferDescription.lpwfxFormat = &amp;amp;m_wavFile.getWaveFormat();
    bufferDescription.guid3DAlgorithm = GUID_NULL;

    IDirectSoundBuffer* soundBuffer;
    if (m_directSound8-&amp;gt;CreateSoundBuffer(&amp;amp;bufferDescription, &amp;amp;soundBuffer, NULL) != DS_OK) {
        throw std::exception(&quot;create secondary buffer failed:CreateSoundBuffer&quot;);
    }

    if (soundBuffer-&amp;gt;QueryInterface(IID_IDirectSoundBuffer8, (LPVOID*)&amp;amp;m_soundBufferInterface)
            != S_OK) {
        throw std::exception(&quot;IDirectSoundBuffer8 interface not supported!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;预填充缓冲区&quot;&gt;2.2 预填充缓冲区&lt;/h3&gt;
&lt;p&gt;本人尝试过直接在缓冲区头部设置notify，使数据的填充比较自然。大多数情况下这样没有问题，但是在电脑cpu负载较高时会造成音频毛刺，效果不尽如人意。因此我选择预填充数据，防止这类情况出现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void WavPlayer::fillDataIntoBuffer()
{
    Q_ASSERT(m_bufferSliceCount &amp;gt; 1);

    //  fill half buffer to signal the notify event to do next data filling
    LPVOID firstAudioAddress;
    LPVOID secondAudioAddress;
    DWORD  firstAudioBytes;
    DWORD  secondAudioBytes;
    HRESULT result = m_soundBufferInterface-&amp;gt;Lock(0,
                                    m_secondaryBufferSize / m_bufferSliceCount,
                                    &amp;amp;firstAudioAddress, &amp;amp;firstAudioBytes,
                                    &amp;amp;secondAudioAddress, &amp;amp;secondAudioBytes,
                                    0);
    if (result == DSERR_BUFFERLOST) {
        result = m_soundBufferInterface-&amp;gt;Restore();
    }
    if (result != DS_OK) {
        throw std::exception(&quot;Cannot lock entire secondary buffer(restore tryed)&quot;);
    }

    Q_ASSERT(firstAudioBytes == m_secondaryBufferSize / m_bufferSliceCount &amp;amp;&amp;amp;
            secondAudioAddress == nullptr &amp;amp;&amp;amp;
            secondAudioBytes == 0);
    m_nextDataToPlay = static_cast&amp;lt;char*&amp;gt;(m_wavFile.getAudioData());
    CopyMemory(firstAudioAddress, m_nextDataToPlay, firstAudioBytes);
    if (m_soundBufferInterface-&amp;gt;Unlock(firstAudioAddress, firstAudioBytes,
                                    secondAudioAddress, secondAudioBytes)
            != DS_OK) {
        throw std::exception(&quot;Unlick failed when fill data into secondary buffer&quot;);
    }

    m_nextDataToPlay += firstAudioBytes;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置缓冲区notify&quot;&gt;2.3 设置缓冲区notify&lt;/h3&gt;
&lt;p&gt;为了在运行时循环填充数据，我们先要设置notify，这里的notify比较复杂，包含了3种类别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据填充notify。&lt;/li&gt;
&lt;li&gt;音频播放终止notify。&lt;/li&gt;
&lt;li&gt;退出notify。（为了优雅的退出填充线程，我们选择在退出播放时唤醒线程）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，第二种notify可能会也可能不会与第一种notify重合，在不重合情况下我们才新分配一个notify：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;m_additionalNotifyIndex = 0;
if (m_additionalEndNotify)
    for (unsigned i = 1; i &amp;lt; m_bufferSliceCount; ++i)
        if (bufferEndOffset &amp;lt; (m_secondaryBufferSize / m_bufferSliceCount * i)) {
            m_additionalNotifyIndex = i;
            break;
        }

//  add a stop notify count at the end of entire notifies to make the data filling
//  thread exit gracefully
++m_notifyCount;
m_notifyHandles = static_cast&amp;lt;HANDLE*&amp;gt;(malloc(sizeof(HANDLE)* (m_notifyCount)));
if (m_notifyHandles == nullptr)
    throw std::exception(&quot;malloc error&quot;);
m_notifyOffsets = static_cast&amp;lt;DWORD*&amp;gt;(malloc(sizeof(DWORD)* (m_notifyCount)));
if (m_notifyHandles == nullptr)
    throw std::exception(&quot;malloc error&quot;);

for (unsigned i = 0; i &amp;lt; m_notifyCount; ++i) {
    m_notifyHandles[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_notifyHandles[i] == NULL)
        throw std::exception(&quot;CreateEvent error&quot;);

    if (m_additionalEndNotify &amp;amp;&amp;amp; i == m_additionalNotifyIndex) {
        //  set buffer end notify
        m_notifyOffsets[i] = bufferEndOffset;
        m_endNotifyHandle = m_notifyHandles[i];
    }
    else if (i == m_notifyCount - 1) {
        //  do nothing
    } else {
        //  NOTE:   the entire buffer size must can be devided by this `notifyCount`,
        //  or it will lost some bytes when filling data into the buffer. since the end
        //  notify is inside the notify count, we need to calculate the buffer slice index.
        unsigned bufferSliceIndex = getBufferIndexFromNotifyIndex(i);
        m_notifyOffsets[i] = m_secondaryBufferSize / m_bufferSliceCount * bufferSliceIndex;
        
        if (!m_additionalEndNotify &amp;amp;&amp;amp; m_notifyOffsets[i] == bufferEndOffset)
            m_endNotifyHandle = m_notifyHandles[i];
    }
}
//  skip the exit notify which we toggle explicitly
setNotifyEvent(m_notifyHandles, m_notifyOffsets, m_notifyCount - 1);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建数据填充线程播放进度更新&quot;&gt;2.4 创建数据填充线程、播放进度更新&lt;/h3&gt;
&lt;p&gt;该线程一直等待多个notify，并对不同情况进行不同的处理：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;播放终止notify，则发出终止信号、退出线程。&lt;/li&gt;
&lt;li&gt;数据填充notify，则填充数据、更新播放进度。&lt;/li&gt;
&lt;li&gt;非终止非数据填充notify（发生在数据填充完成但播放未结束时），continue。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;DWORD WINAPI WavPlayer::dataFillingThread(LPVOID param)&lt;br/&gt;{&lt;br/&gt;WavPlayer* wavPlayer = reinterpret_cast&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while (!wavPlayer-&amp;gt;m_quitDataFillingThread) {
    try {
        DWORD notifyIndex = WaitForMultipleObjects(wavPlayer-&amp;gt;m_notifyCount, wavPlayer-&amp;gt;m_notifyHandles, FALSE, INFINITE);
        if (!(notifyIndex &amp;gt;= WAIT_OBJECT_0 &amp;amp;&amp;amp;
              notifyIndex &amp;lt;= WAIT_OBJECT_0 + wavPlayer-&amp;gt;m_notifyCount - 1))

            throw std::exception(&quot;WaitForSingleObject error&quot;);

        if (notifyIndex == wavPlayer-&amp;gt;m_notifyCount - 1)
            break;

        //  each notify represents one second(or approximately one second) except the exit notify
        if (!(wavPlayer-&amp;gt;m_additionalNotifyIndex == notifyIndex &amp;amp;&amp;amp; wavPlayer-&amp;gt;m_endNotifyLoopCount &amp;gt; 0)) {
            ++wavPlayer-&amp;gt;m_currentPlayingTime;
            wavPlayer-&amp;gt;sendProgressUpdatedSignal();
        }

        //  if return false, the audio ends
        if (tryToFillNextBuffer(wavPlayer, notifyIndex) == false) {
            wavPlayer-&amp;gt;stop();

            ++wavPlayer-&amp;gt;m_currentPlayingTime;
            wavPlayer-&amp;gt;sendProgressUpdatedSignal();

            wavPlayer-&amp;gt;sendAudioEndsSignal();
            //  not break the loop, we need to update the audio progress although data filling ends
        }
    }
    catch (std::exception&amp;amp; exception) {
        OutputDebugStringA(&quot;exception in data filling thread:&quot;);
        OutputDebugStringA(exception.what());
    }
}
return 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h2 id=&quot;运行结果&quot;&gt;3. 运行结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/02/15/5a851af71dd92.png&quot; alt=&quot;result1&quot;/&gt;&lt;img src=&quot;https://i.loli.net/2018/02/15/5a851af70ddfa.png&quot; alt=&quot;result2&quot;/&gt;&lt;img src=&quot;https://i.loli.net/2018/02/15/5a851af71dd8f.png&quot; alt=&quot;result3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整代码见&lt;a href=&quot;https://github.com/lgxZJ/Miscellaneous/tree/master/Audio/DirectSoundPlay&quot;&gt;链接&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Thu, 15 Feb 2018 05:36:00 +0000</pubDate>
<dc:creator>lgxZJ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lgxZJ/p/8449442.html</dc:identifier>
</item>
<item>
<title>发放春节福利，ASP.NET Core断点续传 - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/8449414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/8449414.html</guid>
<description>&lt;h2 id=&quot;asp.net-core断点续传&quot;&gt;ASP.NET Core断点续传&lt;/h2&gt;
&lt;p&gt;在ASP.NET WebAPi写过完整的断点续传文章，目前我对ASP.NET Core仅止于整体上会用，对于原理还未去深入学习，由于有园友想看断点续传在ASP.NET Core中的具体实现，于是借助在家中休息时间看了下ASP.NET Core是否支持断点续传以及支持后具体实现以及相关APi，花了一点时间，本文而由此而生。&lt;/p&gt;
&lt;h2 id=&quot;断点续传基础&quot;&gt;断点续传基础&lt;/h2&gt;
&lt;p&gt;此前在ASP.NET WebAPi中对于一些基础内容已经详细讲解过，同时也进行了封装，所以再处理ASP.NET Core不过是APi使用不同罢了，断点续传重点在于AcceptRange和ContentRange以及对应响应请求头设置，其余和ASP.NET WebAPi使用别无二致。&lt;/p&gt;
&lt;p&gt;在ASP.NET WebAPi中我们封装了对文件的操作接口IFileProvider和具体实现FileProvider，在控制器中我们是直接实例化，在ASP.NET Core中有了依赖注入，我们可直接借助控制器构造函数注入接口。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();

    services.AddScoped&amp;lt;IFileProvider, FileProvider&amp;gt;();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然前提是新建一个ASP.NET Core Web应用程序，然后我们新建一个DownLoadController控制器。在ASP.NET WebAPi中对于请求-响应机制对象是HttpRequestMessage和HttpResponseMessage，而在ASP.NET Core则是HttpRequest和HttpResponse对象。那么我们在控制器中如何获取这两个对象中呢？如果我们稍微有点经验的话就能明了请求和响应对象必然存储在上下文中，那么我们又如何获取上下文呢？通过IHttpContextAccessor接口获取。所以在控制器构造函数中获取文件接口和上下文以及对应的常量如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private const int BufferSize = 80 * 1024;

private const string MimeType = &quot;application/octet-stream&quot;;
public IFileProvider _fileProvider { get; set; }

private IHttpContextAccessor _contextAccessor;
private HttpContext _context { get { return _contextAccessor.HttpContext; } }
public FileDownloadController(
    IFileProvider fileProvider,
    IHttpContextAccessor contextAccessor)
{
    _fileProvider = fileProvider;
    _contextAccessor = contextAccessor;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ASP.NET WebAPi中获取请求头Range利用请求中的Headers属性获取，但在ASP.NET Core中则需要通过请求中的GetTypedHeaders()方法获取。&lt;/p&gt;
&lt;p&gt;ASP.NET Core对于请求头中参数的获取和值的设置更加友好，比如我们要获取请求头中的请求类型，在ASP.NET WebAPi中我们指定字符串Request.Headers[&quot;Content-Type&quot;]，而在ASP.NET Core中则对应的是Request.Headers[HeaderNames.ContentType]，直接通过枚举指定，如此一来则省事多了。最终在DownLoadController控制器中对于在ASP.NET Core中断点续传的整个逻辑如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class FileDownloadController
{
    private const int BufferSize = 80 * 1024;

    private const string MimeType = &quot;application/octet-stream&quot;;
    public IFileProvider _fileProvider { get; set; }

    private IHttpContextAccessor _contextAccessor;
    private HttpContext _context { get { return _contextAccessor.HttpContext; } }
    public FileDownloadController(
        IFileProvider fileProvider,
        IHttpContextAccessor contextAccessor)
    {
        _fileProvider = fileProvider;
        _contextAccessor = contextAccessor;
    }


    /// &amp;lt;summary&amp;gt;
    /// 下载文件
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;fileName&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    [HttpGet(&quot;api/download&quot;)]
    public IActionResult GetFile(string fileName)
    {
        fileName = &quot;cn_windows_8_1_x64_dvd_2707237.iso&quot;;

        if (!_fileProvider.Exists(fileName))
        {
            return new StatusCodeResult(StatusCodes.Status404NotFound);
        }

        //获取下载文件长度
        var fileLength = _fileProvider.GetLength(fileName);

        //初始化下载文件信息
        var fileInfo = GetFileInfoFromRequest(_context.Request, fileLength);

        //获取剩余部分文件流
        var stream = new PartialContentFileStream(_fileProvider.Open(fileName),
                                             fileInfo.From, fileInfo.To);
        //设置响应 请求头
        SetResponseHeaders(_context.Response, fileInfo, fileLength, fileName);

        return new FileStreamResult(stream, new MediaTypeHeaderValue(MimeType));
    }


    /// &amp;lt;summary&amp;gt;
    /// 根据请求信息赋予封装的文件信息类
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;request&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;entityLength&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private FileInfo GetFileInfoFromRequest(HttpRequest request, long entityLength)
    {
        var fileInfo = new FileInfo
        {
            From = 0,
            To = entityLength - 1,
            IsPartial = false,
            Length = entityLength
        };

        var requestHeaders = request.GetTypedHeaders();

        if (requestHeaders.Range != null &amp;amp;&amp;amp; requestHeaders.Range.Ranges.Count &amp;gt; 0)
        {
            var range = requestHeaders.Range.Ranges.FirstOrDefault();
            if (range.From.HasValue &amp;amp;&amp;amp; range.From &amp;lt; 0 || range.To.HasValue &amp;amp;&amp;amp; range.To &amp;gt; entityLength - 1)
            {
                return null;
            }

            var start = range.From;
            var end = range.To;

            if (start.HasValue)
            {
                if (start.Value &amp;gt;= entityLength)
                {
                    return null;
                }
                if (!end.HasValue || end.Value &amp;gt;= entityLength)
                {
                    end = entityLength - 1;
                }
            }
            else
            {
                if (end.Value == 0)
                {
                    return null;
                }

                var bytes = Math.Min(end.Value, entityLength);
                start = entityLength - bytes;
                end = start + bytes - 1;
            }

            fileInfo.IsPartial = true;
            fileInfo.Length = end.Value - start.Value + 1;
        }      
        return fileInfo;
    }

    /// &amp;lt;summary&amp;gt;
    /// 设置响应头信息
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;response&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;fileInfo&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;fileLength&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;fileName&quot;&amp;gt;&amp;lt;/param&amp;gt;
    private void SetResponseHeaders(HttpResponse response, FileInfo fileInfo,
                                  long fileLength, string fileName)
    {
        response.Headers[HeaderNames.AcceptRanges] = &quot;bytes&quot;;
        response.StatusCode = fileInfo.IsPartial ? StatusCodes.Status206PartialContent
                                  : StatusCodes.Status200OK;

        var contentDisposition = new ContentDispositionHeaderValue(&quot;attachment&quot;);
        contentDisposition.SetHttpFileName(fileName);
        response.Headers[HeaderNames.ContentDisposition] = contentDisposition.ToString();
        response.Headers[HeaderNames.ContentType] = MimeType;
        response.Headers[HeaderNames.ContentLength] = fileInfo.Length.ToString();
        if (fileInfo.IsPartial)
        {
            response.Headers[HeaderNames.ContentRange] = new ContentRangeHeaderValue(fileInfo.From, fileInfo.To, fileLength).ToString();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201802/589642-20180215130934077-1703033212.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;ASP.NET Core中FileResult、FileStreamResult、FilePhsicalResult都已支持断点续传，如果对于很小的文件直接下载即可，如果稍微大一点文件则可利用断点续传即可，如果对于非常大的文件则需要自定义流来下载这样更高效，比如对于获取视频流文件。上述我们依然是采取自定义流的形式来实现断点续传，若对其中封装的自定义流和接口有疑惑请移步右上角我的github参看ASP.NET WebAPi具体实现。无论是ASP.NET WebAPi和ASP.NET Core断点续传都实现了核心逻辑，对于一些细节未考虑其中，希望对想学习断点续传的您有所帮助，祝您阅读愉快，新年快乐！完整代码，我会上传到github！&lt;/p&gt;
</description>
<pubDate>Thu, 15 Feb 2018 05:17:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CreateMyself/p/8449414.html</dc:identifier>
</item>
<item>
<title>Java对象序列化 - zxzhang</title>
<link>http://www.cnblogs.com/zzy19961112/p/8447656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzy19961112/p/8447656.html</guid>
<description>&lt;h2&gt;&lt;span&gt;为什么需要序列化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  当我们创建对象时，只要需要，对象就会一直存在，但在程序终止的时候，无论如何它都不会继续存在。这么做有一定的意义，但是如果对象能够在程序不运行的情况下仍能存在并保存其信息，这样，在下次运行程序时，该对象将被重建并且拥有的信息与在程序上次运行时它所拥有的信息相同。为达到这目的，通常的做法可以写入文件或数据库，这样有其优点，但缺乏了某些便利性，在Java中，通过序列化技术，可以将对象声明为“持久性”的，为我们处理所有细节，显得十分方便。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  Java的对象序列化将那些实现了 Serializable 接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象，这一过程甚至可以通过网络进行，也意味着能自动弥补不同操作系统之间的差异，运行在 Windows 系统的计算机上创建一个对象并序列化，通过网络将其发送给一台运行 Unix 系统的计算机，不必担心数据在不同机器上表示不同从而在那里重新组装。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;序列化的用途&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  利用对象序列化可以实现轻量级持久性。”持久性“意味着一个对象的生存周期并不取决于程序是否正在执行，它可以生存于程序的调用之间。通过将一个序列化对象写入磁盘，然后重新调用程序时恢复该对象，就能够实现持久化的效果。对象序列化主要用于两个方面&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;远程方法调用（Remote Method Invocation，RMI），使存活于其他计算机上的对象使用起来就像是存活于本机上一样，当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Java Beans。使用一个Bean时，一般情况下是在设计阶段对它的状态信息进行配置，这种状态信息必须保存下来，并在程序启动时进行后期恢复，这种具体工作就是由对象序列化完成的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;如何实现序列化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  要序列化一个对象，首先要创建某些OutputStream对象，然后将其封装在一个ObjectOutputStream对象内。这时，只需调用writeObject()即可将对象序列化，并将其发送个 OutputStream（对象化序列是基于字节的，因要使用 InputStream 和 OutputStream 继承层次结构）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  反向序列化（即将一个序列还原为一个对象），需要将一个 InputStream 封装在 ObjectInputStream 内，然后调用 readObject()。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java.io.*&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;SerializableDemo&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; Serializable&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String&lt;span&gt;[]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException&lt;span&gt;,&lt;/span&gt; ClassNotFoundException &lt;span&gt;{&lt;/span&gt;
        User user &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; User&lt;span&gt;();&lt;/span&gt;
        user&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
        user&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPasswd&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;world&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;

        &lt;span&gt;//write Obj to File&lt;/span&gt;
        ObjectOutputStream oos &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectOutputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileOutputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;file&quot;&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;
        oos&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;user&lt;span&gt;);&lt;/span&gt;
        oos&lt;span&gt;.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;

        &lt;span&gt;//read Obj from File&lt;/span&gt;
        File file &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; File&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;file&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
        ObjectInputStream ois &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectInputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileInputStream&lt;span&gt;(&lt;/span&gt;file&lt;span&gt;));&lt;/span&gt;
        User newUser &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt;ois&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
        ois&lt;span&gt;.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
        System&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newUser&lt;span&gt;);&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; Serializable&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String username&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String passwd&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getUsername&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; username&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String username&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;username&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; username&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getPasswd&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; passwd&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setPasswd&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String passwd&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; passwd&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;username = &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; getUsername&lt;span&gt;()&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;\r\n&quot;&lt;/span&gt;
                &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;passwd = &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; getPasswd&lt;span&gt;();&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;Output:&lt;/span&gt;
&lt;span&gt;username = hello&lt;/span&gt;
&lt;span&gt;passwd = world&lt;/span&gt;
&lt;span&gt; */&lt;/span&gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  此外，还可以通过实现 Externalizable 接口——代替实现Serializable接口——来对序列化进行控制。这个 Externalizable 接口继承了 Serialazable 接口，同时增添了两个方法： writeExternal() 和 readExternal()，这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊操作。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;transient（瞬时）关键字&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  当我们对序列化进行控制时，可能不想让 Java 的序列化机制自动保存与恢复某些敏感信息字段，比如密码，即使这些字段是私有属性，一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式来访问它。为了允以控制，可以用transient（瞬时）关键字逐个字段地关闭序列化。修改上述例子，将 passwd 字段设置为 transient：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java.io.*&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;SerializableDemo&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; Serializable&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String&lt;span&gt;[]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException&lt;span&gt;,&lt;/span&gt; ClassNotFoundException &lt;span&gt;{&lt;/span&gt;
        User user &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; User&lt;span&gt;();&lt;/span&gt;
        user&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
        user&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPasswd&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;world&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;

        &lt;span&gt;//write Obj to File&lt;/span&gt;
        ObjectOutputStream oos &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectOutputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileOutputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;file&quot;&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;
        oos&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;user&lt;span&gt;);&lt;/span&gt;
        oos&lt;span&gt;.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;

        &lt;span&gt;//read Obj from File&lt;/span&gt;
        File file &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; File&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;file&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
        ObjectInputStream ois &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectInputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileInputStream&lt;span&gt;(&lt;/span&gt;file&lt;span&gt;));&lt;/span&gt;
        User newUser &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt;ois&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
        ois&lt;span&gt;.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
        System&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newUser&lt;span&gt;);&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; Serializable&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String username&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; String passwd&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getUsername&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; username&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String username&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;username&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; username&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getPasswd&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; passwd&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setPasswd&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String passwd&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; passwd&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;username = &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; getUsername&lt;span&gt;()&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;\r\n&quot;&lt;/span&gt;
                &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;passwd = &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; getPasswd&lt;span&gt;();&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;Output:&lt;/span&gt;
&lt;span&gt;username = hello&lt;/span&gt;
&lt;span&gt;passwd = null&lt;/span&gt;
&lt;span&gt; */&lt;/span&gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，passwd输出的值由 world 变为 null，此外，虽然 toString() 经过重载，但是 null 引用会被自动转换成字符串 null。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;自定义序列化和反序列化策略&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  通过创建 ObjectOutputStream封装对象，然后调用writeObject()方法实现序列化，在调用ObjectOutputStream.writeObject()时，会检查所传递的 Serializable 对象，看看是否实现了它自己的 writeObject()。如果存在自己实现的 writeObject()方法，就跳过正常的序列化过程并调用它的writeObject()，同样，readObject()情形与此相同。此外，在自定义的 writeObject()内部，可以调用 defaultWriteObject() 来选择执行默认的 writeObject()；类似地，在 readObject() 内部，可以调用 defaultReadObject()。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//: io/SerialCtl.java&lt;/span&gt;
&lt;span&gt;// Controlling serialization by adding your own&lt;/span&gt;
&lt;span&gt;// writeObject() and readObject() methods.&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java.io.*&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;SerialCtl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; Serializable &lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; String a&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; String b&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;SerialCtl&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String aa&lt;span&gt;,&lt;/span&gt; String bb&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Not Transient: &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; aa&lt;span&gt;;&lt;/span&gt;
    b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Transient: &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; bb&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; a &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;\n&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; b&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ObjectOutputStream stream&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;throws&lt;/span&gt; IOException &lt;span&gt;{&lt;/span&gt;
    stream&lt;span&gt;.&lt;/span&gt;&lt;span&gt;defaultWriteObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
    stream&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;);&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ObjectInputStream stream&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;throws&lt;/span&gt; IOException&lt;span&gt;,&lt;/span&gt; ClassNotFoundException &lt;span&gt;{&lt;/span&gt;
    stream&lt;span&gt;.&lt;/span&gt;&lt;span&gt;defaultReadObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
    b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;String&lt;span&gt;)&lt;/span&gt;stream&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String&lt;span&gt;[]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;throws&lt;/span&gt; IOException&lt;span&gt;,&lt;/span&gt; ClassNotFoundException &lt;span&gt;{&lt;/span&gt;
    SerialCtl sc &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SerialCtl&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Test1&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;Test2&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
    System&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Before:\n&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; sc&lt;span&gt;);&lt;/span&gt;
    ByteArrayOutputStream buf&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ByteArrayOutputStream&lt;span&gt;();&lt;/span&gt;
    ObjectOutputStream o &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectOutputStream&lt;span&gt;(&lt;/span&gt;buf&lt;span&gt;);&lt;/span&gt;
    o&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;sc&lt;span&gt;);&lt;/span&gt;
    &lt;span&gt;// Now get it back:&lt;/span&gt;
    ObjectInputStream in &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectInputStream&lt;span&gt;(&lt;/span&gt;
      &lt;span&gt;new&lt;/span&gt; ByteArrayInputStream&lt;span&gt;(&lt;/span&gt;buf&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toByteArray&lt;/span&gt;&lt;span&gt;()));&lt;/span&gt;
    SerialCtl sc2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;SerialCtl&lt;span&gt;)&lt;/span&gt;in&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
    System&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;After:\n&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; sc2&lt;span&gt;);&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt; &lt;span&gt;/* Output:&lt;/span&gt;
&lt;span&gt;Before:&lt;/span&gt;
&lt;span&gt;Not Transient: Test1&lt;/span&gt;
&lt;span&gt;Transient: Test2&lt;/span&gt;
&lt;span&gt;After:&lt;/span&gt;
&lt;span&gt;Not Transient: Test1&lt;/span&gt;
&lt;span&gt;Transient: Test2&lt;/span&gt;
&lt;span&gt;*///:~&lt;/span&gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;ArrayList的序列化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;通过阅读源码，我们知道 ArrayList 的底层是数组实现的，其 elementData[] 就是用来保存元素的，其定义如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;transient&lt;/span&gt; Object&lt;span&gt;[]&lt;/span&gt; elementData&lt;span&gt;;&lt;/span&gt; &lt;span&gt;// non-private to simplify nested class access&lt;/span&gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;elementData 通过 transient 声明，因此无法通过序列化技术保存下来，但是我们可以从一个实例中看出，其通过序列化和反序列化技术将 List 中的元素保存下来：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java.io.*&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java.util.ArrayList&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java.util.List&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ListDemo&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String&lt;span&gt;[]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException&lt;span&gt;,&lt;/span&gt; ClassNotFoundException &lt;span&gt;{&lt;/span&gt;
        List&lt;span&gt;&amp;lt;&lt;/span&gt;String&lt;span&gt;&amp;gt;&lt;/span&gt;list &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArrayList&lt;span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        list&lt;span&gt;.&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
        list&lt;span&gt;.&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;world&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;

        &lt;span&gt;//write Obj to File&lt;/span&gt;
        ObjectOutputStream oos &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectOutputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileOutputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;file&quot;&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;
        oos&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;list&lt;span&gt;);&lt;/span&gt;
        oos&lt;span&gt;.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;

        &lt;span&gt;//read Obj from File&lt;/span&gt;
        File file &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; File&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;file&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
        ObjectInputStream ois &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectInputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileInputStream&lt;span&gt;(&lt;/span&gt;file&lt;span&gt;));&lt;/span&gt;
        List&lt;span&gt;&amp;lt;&lt;/span&gt;String&lt;span&gt;&amp;gt;&lt;/span&gt;newList &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;List&lt;span&gt;&amp;lt;&lt;/span&gt;String&lt;span&gt;&amp;gt;)&lt;/span&gt; ois&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
        ois&lt;span&gt;.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
        System&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newList&lt;span&gt;);&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;[hello, world]&lt;/span&gt;
&lt;span&gt; */&lt;/span&gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 再通过源码可知，其添加了 writeObject() 和 readObject() 的方法来控制序列化和反序列化&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;java&lt;span&gt;.&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ObjectInputStream&lt;/span&gt; s&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;throws&lt;/span&gt; java&lt;span&gt;.&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;IOException&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; ClassNotFoundException &lt;span&gt;{&lt;/span&gt;
    elementData &lt;span&gt;=&lt;/span&gt; EMPTY_ELEMENTDATA&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// Read in size, and any hidden stuff&lt;/span&gt;
    s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;defaultReadObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;

    &lt;span&gt;// Read in capacity&lt;/span&gt;
    s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readInt&lt;/span&gt;&lt;span&gt;();&lt;/span&gt; &lt;span&gt;// ignored&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;size &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// be like clone(), allocate array based upon size not capacity&lt;/span&gt;
        ensureCapacityInternal&lt;span&gt;(&lt;/span&gt;size&lt;span&gt;);&lt;/span&gt;

        Object&lt;span&gt;[]&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; elementData&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// Read in all elements in the proper order.&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; size&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            a&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;


&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;java&lt;span&gt;.&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ObjectOutputStream&lt;/span&gt; s&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;throws&lt;/span&gt; java&lt;span&gt;.&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;IOException&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// Write out element count, and any hidden stuff&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; expectedModCount &lt;span&gt;=&lt;/span&gt; modCount&lt;span&gt;;&lt;/span&gt;
    s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;defaultWriteObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;

    &lt;span&gt;// Write out size as capacity for behavioural compatibility with clone()&lt;/span&gt;
    s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeInt&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;size&lt;span&gt;);&lt;/span&gt;

    &lt;span&gt;// Write out all elements in the proper order.&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; size&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;elementData&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]);&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;modCount &lt;span&gt;!=&lt;/span&gt; expectedModCount&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ConcurrentModificationException&lt;span&gt;();&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那到这里，不禁会思考为什么要这么转好几个弯来实现序列化和反序列化，一开始直接不将 elementData 声明为 transient 不就行了？实际上，ArrayList通过动态数组的技术，当数组放满后，自动扩容，而在扩容的这部分假设仅用了一小部分，那么就会序列化一大部分的 null 元素，为了保证在序列化的时候不会将这么多 null 进行序列化，因此设置为 transient。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  因为在阅读 ArrayList 源码的时候，不知道 transient 关键字有何作用，因此在学习之后，以作记录，部分内容源于 《Thinking in Java》&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Feb 2018 03:52:00 +0000</pubDate>
<dc:creator>zxzhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzy19961112/p/8447656.html</dc:identifier>
</item>
<item>
<title>浅析Numpy.genfromtxt及File I/O讲解 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/8449346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/8449346.html</guid>
<description>&lt;div readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Type: raw 
Points: &lt;/span&gt;16200&lt;span&gt; 
Count: &lt;/span&gt;1&lt;span&gt; 
... 
X Units: second 
Y Units: Volt 
XY Data: 
&lt;/span&gt;2.4000000E-008, 1.4349E-002 
2.4000123E-008, 1.6005E-002 
2.4000247E-008, 1.5455E-002 
2.4000370E-008, 1.5702E-002 
2.4000494E-008, 1.5147E-002&lt;span&gt; 
... &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;33&quot;&gt;
&lt;pre&gt;
2018-02-15 21:31:08.781 49.9492 
2018-02-15 21:31:09.296 49.9589 
2018-02-15 21:31:09.811 49.964 
2018-02-15 21:31:10.326 49.9741 
2018-02-15 21:31:10.841 49.983&lt;span&gt;
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;处理文本文件的第一步是&lt;strong&gt;通过 open 命令来获取一个文件对象&lt;/strong&gt;：&lt;/p&gt;&lt;div readability=&quot;37&quot;&gt;
&lt;pre&gt;
file_for_reading = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;thermistor.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'r' 意味着只读 &lt;/span&gt;
file_for_writing = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;thermistor.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'w' 是写入 &lt;/span&gt;
file_for_appending = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;thermistor.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'a' 是添加 &lt;/span&gt;
file_for_xxx.close() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 完成操作后要关闭文件 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为非常容易忘记关闭文件，所以应该在 with 程序块里操作文件，这样结尾处文件会被自动关闭：&lt;/p&gt;&lt;div readability=&quot;33&quot;&gt;
&lt;pre&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;thermistor.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
     data &lt;/span&gt;= function_that_gets_data_form(f) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取数据函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时，f 已经关闭了，就不能试图使用它啦，然后对数据执行相应的操作即可。&lt;/p&gt;&lt;div readability=&quot;32&quot;&gt;
&lt;pre&gt;
process(data) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理数据函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;124.53804001529&quot;&gt;
&lt;p&gt;处理文本文件第二步是&lt;strong&gt;观察数据特征，选择合适的读取命令&lt;/strong&gt;：通过观察，可以发现，文件没有头部，每一行包括三种数据 (编号，时间，温度) 他们之间以空格键分开，每一列是同一类数据，这样我们就可以用 Python 中的 csv 模块中的 csv.reader 对其进行迭代处理，每一行都会被处理成恰当划分的列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; csv 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; with open(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;thermistor.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f: 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       reader = csv.reader(f,delimiter=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       number=&lt;span&gt;[] 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       time =&lt;span&gt; [] 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       data=&lt;span&gt;[] 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; reader: 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;           number.append(row[0]) 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;            time.append(row[1&lt;span&gt;])  
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;            data.append(float(row[2])) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;处理文本文件的第三步是&lt;strong&gt;检测数据读取格式是否正确&lt;/strong&gt;，我们可以用如下的方式检测：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt; number[0], time[0], data[0] 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; 2018-02-15 21:31:08.781 49.9492
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从输出的首个元素来看，以上的读取数据的方式是没有问题的，但是到这里我们并不能完全放心我们的数据格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt; number[0:3], time[0:3], data[0:3] 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xef\xbb\xbf1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-15 21:31:08.781&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-15 21:31:09.296&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-15 21:31:09.811&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] 
[&lt;/span&gt;49.9492, 49.9589, 49.964] 
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;当我们以列表的形式输出时，number 中的首个元素出现了我们没有预料到的“乱码”，这其实是 &lt;strong&gt;BOM&lt;/strong&gt; (byte order mark), 它是为 UTF-16 和 UTF-32 准备的，用以标记字节序。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码区别开，但这样的文件会给我们的数据读取带来问题。还好，我们可以用 Python 中的 &lt;strong&gt;codecs&lt;/strong&gt; 模块解决这个问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; csv 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; codecs 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; with codecs.open(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;thermistor.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8-sig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f: 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     reader = csv.reader(f,delimiter=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     number=[] time=[] data=&lt;span&gt;[] 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; reader: 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        number.append(row[0]) 
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         time.append(row[1&lt;span&gt;]) 
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         data.append(float(row[2])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，我们再以列表形式输出时，就会得到正确的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] 
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-15 21:31:08.781&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-15 21:31:09.296&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-15 21:31:09.811&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] 
[&lt;/span&gt;49.9492, 49.9589, 49.964]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以用得到的数据进行处理分析啦~&lt;/p&gt;

&lt;p&gt;有了上面的经验，我们直接从处理文本文件第二步开始，示波器数据相对上面的数据，复杂的地方在于它包含了&lt;strong&gt;表头&lt;/strong&gt;信息，而这些信息大部分时间是处理数据中不太需要的，它的数据格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Type: raw 
Points: &lt;/span&gt;16200&lt;span&gt; 
Count: &lt;/span&gt;1&lt;span&gt; 
XInc: &lt;/span&gt;1.23457E-013&lt;span&gt; 
XOrg: &lt;/span&gt;2.4000000000E-008&lt;span&gt; 
YData range: &lt;/span&gt;1.48000E-001&lt;span&gt; 
YData center: &lt;/span&gt;5.00000E-004&lt;span&gt; 
Coupling: &lt;/span&gt;50&lt;span&gt; 
Ohms XRange: &lt;/span&gt;2.00000E-009&lt;span&gt; 
XOffset: &lt;/span&gt;2.4000000000E-008&lt;span&gt; 
YRange: &lt;/span&gt;1.44000E-001&lt;span&gt; 
YOffset: &lt;/span&gt;5.00000E-004&lt;span&gt; 
Date: &lt;/span&gt;15 APR 2018&lt;span&gt; 
Time: &lt;/span&gt;16:00:54:74&lt;span&gt; 
Frame: 86100C:MY46520443 
X Units: second 
Y Units: Volt 
XY Data: 
&lt;/span&gt;2.4000000E-008, 1.4349E-002 
2.4000123E-008, 1.6005E-002 
2.4000247E-008, 1.5455E-002 
2.4000370E-008, 1.5702E-002 
2.4000494E-008, 1.5147E-002&lt;span&gt; 
... &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，“表头”是一些参数信息，真正有用的数据是从 “XY Data:” 下一行开始的，对于这样的数据有两种方法进行读取：(1) 直接跳过“表头”读取数据；(2) 利用正则表达式寻找“表头” 和数据的不同特征进行识别读取。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; with open(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waveform.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f: 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     lines = f.readlines() x=[] y=&lt;span&gt;[] 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; lines[18&lt;span&gt;:]: 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         x.append(float(line.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)[0])) 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         y.append(float(line.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[1]))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过观察我们发现有效数据是从第19行开始的，于是我们&lt;strong&gt;直接从19行开始读取数据&lt;/strong&gt;，跳过“表头”，以列表形式输出 x 和 y 前3个元素如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; [2.4e-08, 2.4000123e-08, 2.4000247e-08&lt;span&gt;] 
[&lt;/span&gt;0.014349, 0.016005, 0.015455] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据读取正确&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运用正则表达式读取数据的关键在于&lt;strong&gt;找到有效数据行的独有特征&lt;/strong&gt;，这里以 “&lt;strong&gt;E-002&lt;/strong&gt;” 作为有效数据行区别于“表头”的特征，对数据的读取方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; with open(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waveform.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f: 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     lines =&lt;span&gt; f.readlines() 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     x=&lt;span&gt;[] 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     y=&lt;span&gt;[] 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lines: 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; re.search(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E-002&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,line): 
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;             x.append(float(line.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)[0])) 
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;             y.append(float(line.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[1]))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样，以列表形式输出 x 和 y 前3个元素用于检验：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; [2.4e-08, 2.4000123e-08, 2.4000247e-08&lt;span&gt;] 
[&lt;/span&gt;0.014349, 0.016005, 0.015455] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据读取正确&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：具体的数据读取方式要根据具体文本文件的特征决定，运用合适的方法才能得到更好的结果。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很多时候，经过 process( ) 后的数据，需要备份留用或者供其他程序调用，因此，将处理后的数据&lt;strong&gt;写入文本文件&lt;/strong&gt;也将是关键的一步。根据数据读入的经验，被读入的数据经常存储在 list 中，那么处理后数据也通常存储在 list 中，因此，以 list 的写入作为例子：&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
x = [1, 2, 3, 4&lt;span&gt;]
y &lt;/span&gt;= [2.0, 4.0, 6.0, 8.0] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参考数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来就要考虑的是要&lt;strong&gt;以什么样的格式保存数据&lt;/strong&gt;，为了更加直观的表现数据的关系，我们将 x，y 分别保存为一列，中间以空格键隔开，那么 &lt;strong&gt;csv.writer( )&lt;/strong&gt; 将是很好的工具：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; xy =&lt;span&gt; {} 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(x)): 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     xy[x[i]] =&lt;span&gt; y[i] 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; with open(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;15.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f: 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     writer = csv.writer(f,delimiter=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; x, y &lt;span&gt;in&lt;/span&gt;&lt;span&gt; xy.items(): 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         writer.writerow([x, y]) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了同时保存 x 和 y 的对应值，这里把 x 和 y 写入字典，x 为键 (key), y 为 值 (value) ，xy 就是 x 和 y 构成的字典。保存后的数据格式如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
1   2.0
2   4.0
3   6.0
4   8.0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于字典的键 (key) 和值 (value) 对应的特殊数据结构，写入二维数据较为方便，对于多维数据，我们就需要构建&lt;strong&gt;多维矩阵&lt;/strong&gt;，或者&lt;strong&gt;列表与元组结合&lt;/strong&gt;的方式录入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
x = [1, 2, 3, 4&lt;span&gt;]
y &lt;/span&gt;= [2.0, 4.0, 6.0, 8.0&lt;span&gt;]
z &lt;/span&gt;= [3.0, 6.0, 9.0, 12.0]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里以三维数据为例子。同样，需要将 x，y，z 各一列写入到txt中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; xyz =&lt;span&gt; [] 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(x)): 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    xyz.append([x[i],y[i],z[i]]) 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; with open(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;15.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f: 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     writer = csv.writer(f,delimiter=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; x, y, z &lt;span&gt;in&lt;/span&gt;&lt;span&gt; xyz: 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         writer.writerow([x, y, z]) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，就可以很容易地得到需要的数据格式的文本文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1   2.0 3.0
2   4.0 6.0
3   6.0 9.0
4   8.0 12.0
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;我们已经提到了两种方法读取上述的数据，它们共同点是将数据存储在列表中，正如开头所说，列表在处理大量数据时是非常缓慢的。那么，我们就来看一看 &lt;strong&gt;numpy.genfromtxt&lt;/strong&gt; 如何大显身手。&lt;/p&gt;

&lt;p&gt;为了得到我们需要的有用数据，我们有两个硬的要求： (1) &lt;strong&gt;跳过表头信息&lt;/strong&gt;；(2) &lt;strong&gt;区分横纵坐标&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
data &lt;/span&gt;= np.genfromtxt(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;waveform.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,delimiter=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,skip_header=18)
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;28.793559042114&quot;&gt;
&lt;p&gt;**delimiter: &lt;strong&gt;the str used to separate data. 横纵坐标以 ',' 分割，因此给 &lt;strong&gt;delimiter&lt;/strong&gt; 传入 ','。&lt;/strong&gt;skip_header: ** the number of lines to skip at the beginning of the file. 有用数据是从19行开始的，因此给 &lt;strong&gt;skip_header&lt;/strong&gt; 传入 18。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt; data[0:3,0], data[0:3,1]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为读入的是二维数据，因此利用 numpy &lt;strong&gt;二维数据的切片方式&lt;/strong&gt; (Index slicing) 输出各自的前三个数据验证是否读取正确：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[  2.40000000e-08   2.40001230e-08   2.40002470e-08&lt;span&gt;]
[ &lt;/span&gt;0.014349  0.016005  0.015455]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对数据进行归一化处理后，调用 &lt;strong&gt;Matplotlib&lt;/strong&gt; 画图命令，就可得到图像如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; fig, axes = plt.subplots(figsize=(8,6&lt;span&gt;)) 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; axes.plot(x, y, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, linewidth=3&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; axes.set_xlabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Time(ps)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; axes.set_ylabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Amplitude[a.u.]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; fig.savefig(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;triangular.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, dpi=600)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;4800&quot; data-height=&quot;3600&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2526000-bddc79b58cc79e36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/2526000-bddc79b58cc79e36.png&quot; data-original-width=&quot;4800&quot; data-original-height=&quot;3600&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;344353&quot;/&gt;&lt;/div&gt;
&lt;p&gt;                                                                          triangular waveform&lt;/p&gt;
&lt;div class=&quot;image-caption&quot; readability=&quot;7.956&quot;&gt;

&lt;p&gt;&lt;strong&gt;numpy.genformtxt( )&lt;/strong&gt; 函数提供了众多的入参，实现不同格式数据的读取，详情可参考：&lt;a href=&quot;https://link.jianshu.com/?t=http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;numpy.genfromtxt&lt;/a&gt;&lt;br/&gt;此外，numpy 中还提供了将数据存储为 &lt;strong&gt;CSV&lt;/strong&gt; 格式的函数 &lt;strong&gt;numpy.savetxt( )&lt;/strong&gt;，详情可参考：&lt;a href=&quot;https://link.jianshu.com/?t=http://docs.scipy.org/doc/numpy/reference/generated/numpy.savetxt.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;numpy.savetxt&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 15 Feb 2018 03:31:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/8449346.html</dc:identifier>
</item>
</channel>
</rss>