<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>kubernetes的安装 - LinuxPanda</title>
<link>http://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_liunx_53_k8s.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_liunx_53_k8s.html</guid>
<description>&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;自己学习k8s集群，无奈屌丝一枚，没钱配置vpn服务，安装k8s花费的时间太久了。为了小伙伴们可以快速安装k8s，我花了点时间整理了这篇博客，提供一个不用FQ就可以愉快安装k8s集群的方法。&lt;/p&gt;
&lt;h2&gt;主机环境&lt;/h2&gt;
&lt;h3&gt;主机、IP规划和网络规划&lt;/h3&gt;
&lt;table border=&quot;0&quot; frame=&quot;border&quot; rules=&quot;rows&quot; align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;HOSTNAME&lt;/td&gt;
&lt;td&gt;IP&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;master&lt;/td&gt;
&lt;td&gt;10.8.3.91&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node1&lt;/td&gt;
&lt;td&gt;10.8.3.81&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node2&lt;/td&gt;
&lt;td&gt;10.8.3.82&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;k8s的pod网络采用 10.244.0.0/16 ，网络组件选择flannel。&lt;/p&gt;
&lt;h3&gt;主机名设置&lt;/h3&gt;
&lt;p&gt;这里使用centos7的hostnamectl设置主机名字， centos其他版本参考： &lt;a href=&quot;https://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_linux_043_hostname.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_linux_043_hostname.html&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#master节点
hostnamectl  set&lt;/span&gt;-&lt;span&gt;hostname&lt;/span&gt;  master &amp;amp;&amp;amp;&lt;span&gt; exec bash 
#node1节点
hostnamectl  set&lt;/span&gt;-&lt;span&gt;hostname&lt;/span&gt;  node1 &amp;amp;&amp;amp;&lt;span&gt; exec bash 
#node2节点
hostnamectl  set&lt;/span&gt;-&lt;span&gt;hostname&lt;/span&gt;  node2 &amp;amp;&amp;amp; exec bash 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;hosts文件设置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@master ~]# vim /etc/&lt;span&gt;hosts &lt;br/&gt;# 添加如下3行 &lt;br/&gt;&lt;/span&gt;&lt;span&gt;10.4&lt;/span&gt;.&lt;span&gt;3.91&lt;/span&gt;&lt;span&gt; master &lt;br/&gt;&lt;/span&gt;&lt;span&gt;10.4&lt;/span&gt;.&lt;span&gt;3.81&lt;/span&gt;&lt;span&gt; node1 &lt;br/&gt;&lt;/span&gt;&lt;span&gt;10.4&lt;/span&gt;.&lt;span&gt;3.82&lt;/span&gt; node2
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;# 其他的2个node节点也需要同样操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;防火墙和selinux设置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@master ~]# &lt;span&gt;sed&lt;/span&gt; -i &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s/^SELINUX\=enforcing/SELINUX\=disabled/g&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /etc/selinux/&lt;span&gt;config
[root@master &lt;/span&gt;~]# setenforce &lt;span&gt;0&lt;/span&gt;&lt;span&gt; 
setenforce: SELinux is disabled
[root@master &lt;/span&gt;~&lt;span&gt;]# systemctl stop firewalld 
[root@master &lt;/span&gt;~&lt;span&gt;]# systemctl disable firewalld
# 其他的2个node节点也需要同样操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;内核参数开启&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@master k8s_images]# &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;net.bridge.bridge-nf-call-ip6tables = 1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt;/etc/&lt;span&gt;sysctl.conf 
[root@master k8s_images]# &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;net.bridge.bridge-nf-call-iptables = 1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/&lt;span&gt;sysctl.conf
[root@master k8s_images]# &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;net.ipv4.ip_forward=1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/&lt;span&gt;sysctl.conf 
[root@master k8s_images]# sysctl &lt;/span&gt;-p
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;# 其他的2个node节点也需要同样操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;仓库准备&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
# 备份旧的repo&lt;br/&gt;[root@master ~]# cd /etc/&lt;span&gt;yum&lt;/span&gt;.repos.d/&lt;span&gt;
[root@master &lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;.repos.d]# &lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
CentOS&lt;/span&gt;-Base.repo  CentOS-Debuginfo.repo  CentOS-Media.repo    CentOS-&lt;span&gt;Vault.repo
CentOS&lt;/span&gt;-CR.repo    CentOS-fasttrack.repo  CentOS-&lt;span&gt;Sources.repo
[root@master &lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;.repos.d]# &lt;span&gt;mkdir&lt;/span&gt;&lt;span&gt; bak
[root@master &lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;.repos.d]# &lt;span&gt;mv&lt;/span&gt; *&lt;span&gt;.repo bak
[root@master &lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;.repos.d]# &lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
bak&lt;br/&gt;# 下载base,epel
[root@master &lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;.repos.d]# curl -o /etc/&lt;span&gt;yum&lt;/span&gt;.repos.d/CentOS-Base.repo http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.aliyun.com/repo/Centos-7.repo&lt;/span&gt;
[root@master &lt;span&gt;yum&lt;/span&gt;.repos.d]# &lt;span&gt;wget&lt;/span&gt; -O /etc/&lt;span&gt;yum&lt;/span&gt;.repos.d/epel.repo http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.aliyun.com/repo/epel-7.repo&lt;/span&gt;
# 下载k8s repo
[root@master &lt;span&gt;yum&lt;/span&gt;.repos.d]# &lt;span&gt;cat&lt;/span&gt; &amp;lt;&amp;lt;EOF &amp;gt; /etc/&lt;span&gt;yum&lt;/span&gt;.repos.d/&lt;span&gt;kubernetes.repo
[kubernetes]
name&lt;/span&gt;=&lt;span&gt;Kubernetes
baseurl&lt;/span&gt;=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/&lt;/span&gt;
enabled=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
gpgcheck&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
repo_gpgcheck&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
gpgkey&lt;/span&gt;=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg &lt;/span&gt;&lt;span&gt;https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg&lt;/span&gt;
EOF
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;# 其他的2个node节点也需要同样操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;安装k8s&lt;/h2&gt;
&lt;h3&gt;docker和k8s软件安装&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@master &lt;span&gt;yum&lt;/span&gt;.repos.d]# &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt;&lt;span&gt; docker kubelet kubeadm kubectl
[root@master &lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;.repos.d]# systemctl enable kubelet &amp;amp;&amp;amp;&lt;span&gt; systemctl start kubelet
[root@master &lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;.repos.d]# systemctl enable docker &amp;amp;&amp;amp;&lt;span&gt; systemctl restart docker 

# 其他的2个node节点也需要同样操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;docker加速配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; -p /etc/&lt;span&gt;docker&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;tee&lt;/span&gt; /etc/docker/daemon.json &amp;lt;&amp;lt;-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;EOF&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;registry-mirrors&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://mew8i5li.mirror.aliyuncs.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
}
EOF
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; systemctl daemon-&lt;span&gt;reload
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; systemctl restart docker&lt;br/&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;# 其他的2个node节点也需要同样操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;曲线下载k8s所需的镜像&lt;/h3&gt;
&lt;p&gt;这个我是在dockerhub上面的自动构建，原理就是拉去构建的镜像，给这个镜像打tag为google的tag，这样我们在初始化集群的时候就不会再去google去拉去镜像文件。&lt;/p&gt;
&lt;p&gt;我的dockerhub：&lt;a href=&quot;https://hub.docker.com/r/zhaojiedi1992/&quot; target=&quot;_blank&quot;&gt;https://hub.docker.com/r/zhaojiedi1992&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的github仓库：&lt;a href=&quot;https://github.com/zhaojiedi1992/k8s_images&quot; target=&quot;_blank&quot;&gt;https://github.com/zhaojiedi1992/k8s_images&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@master ~]# cd /&lt;span&gt;root
[root@master &lt;/span&gt;~]# &lt;span&gt;mkdir&lt;/span&gt;&lt;span&gt; git
[root@master &lt;/span&gt;~]# cd git/&lt;span&gt;
[root@master git]# git clone https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/zhaojiedi1992/k8s_images.git&lt;/span&gt;
[root@master git]# cd k8s_images/&lt;span&gt;
[root@master k8s_images]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
create_script.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;                      pull_image_from_dockerhub_v1.&lt;span&gt;10.6&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;  README.md  v1.&lt;span&gt;10.6&lt;/span&gt;&lt;span&gt;
pull_image_from_dockerhub.template    pull_image_from_dockerhub_v1.&lt;/span&gt;&lt;span&gt;10.7&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;  tmp.txt    v1.&lt;span&gt;10.7&lt;/span&gt;&lt;span&gt;
pull_image_from_dockerhub_v1.&lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;  pull_image_from_dockerhub_v1.&lt;span&gt;10.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;  v1.&lt;span&gt;10.0&lt;/span&gt;    v1.&lt;span&gt;10.8&lt;/span&gt;&lt;span&gt;
pull_image_from_dockerhub_v1.&lt;/span&gt;&lt;span&gt;10.1&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;  pull_image_from_dockerhub_v1.&lt;span&gt;11.0&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;  v1.&lt;span&gt;10.1&lt;/span&gt;    v1.&lt;span&gt;11&lt;/span&gt;&lt;span&gt;
pull_image_from_dockerhub_v1.&lt;/span&gt;&lt;span&gt;10.2&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;  pull_image_from_dockerhub_v1.&lt;span&gt;11.1&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;  v1.&lt;span&gt;10.2&lt;/span&gt;    v1.&lt;span&gt;11.0&lt;/span&gt;&lt;span&gt;
pull_image_from_dockerhub_v1.&lt;/span&gt;&lt;span&gt;10.3&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;  pull_image_from_dockerhub_v1.&lt;span&gt;11.2&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;  v1.&lt;span&gt;10.3&lt;/span&gt;    v1.&lt;span&gt;11.1&lt;/span&gt;&lt;span&gt;
pull_image_from_dockerhub_v1.&lt;/span&gt;&lt;span&gt;10.4&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;  pull_image_from_dockerhub_v1.&lt;span&gt;11.3&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;  v1.&lt;span&gt;10.4&lt;/span&gt;    v1.&lt;span&gt;11.2&lt;/span&gt;&lt;span&gt;
pull_image_from_dockerhub_v1.&lt;/span&gt;&lt;span&gt;10.5&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;  pull_image_from_dockerhub_v1.&lt;span&gt;11&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;    v1.&lt;span&gt;10.5&lt;/span&gt;    v1.&lt;span&gt;11.3&lt;/span&gt;&lt;span&gt;
[root@master k8s_images]# &lt;/span&gt;&lt;span&gt;chmod&lt;/span&gt; a+x *.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;

# 查看安装的k8s版本对应需要的镜像
[root@master k8s_images]# kubeadm config images list &lt;/span&gt;--kubernetes-version=v1.&lt;span&gt;11.3&lt;/span&gt;&lt;span&gt;
k8s.gcr.io&lt;/span&gt;/kube-apiserver-amd64:v1.&lt;span&gt;11.3&lt;/span&gt;&lt;span&gt;
k8s.gcr.io&lt;/span&gt;/kube-controller-manager-amd64:v1.&lt;span&gt;11.3&lt;/span&gt;&lt;span&gt;
k8s.gcr.io&lt;/span&gt;/kube-scheduler-amd64:v1.&lt;span&gt;11.3&lt;/span&gt;&lt;span&gt;
k8s.gcr.io&lt;/span&gt;/kube-proxy-amd64:v1.&lt;span&gt;11.3&lt;/span&gt;&lt;span&gt;
k8s.gcr.io&lt;/span&gt;/pause:&lt;span&gt;3.1&lt;/span&gt;&lt;span&gt;
k8s.gcr.io&lt;/span&gt;/etcd-amd64:&lt;span&gt;3.2&lt;/span&gt;.&lt;span&gt;18&lt;/span&gt;&lt;span&gt;
k8s.gcr.io&lt;/span&gt;/coredns:&lt;span&gt;1.1&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;&lt;span&gt;

# 查看脚本的镜像和需要拉去的是否一致。
[root@master k8s_images]# &lt;/span&gt;&lt;span&gt;cat&lt;/span&gt; ./pull_image_from_dockerhub_v1.&lt;span&gt;11.3&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; 
#&lt;/span&gt;!/bin/&lt;span&gt;bash
gcr_name&lt;/span&gt;=&lt;span&gt;k8s.gcr.io
myhub_name&lt;/span&gt;=&lt;span&gt;zhaojiedi1992
# define images 
images&lt;/span&gt;=&lt;span&gt;(
    kube&lt;/span&gt;-apiserver-amd64:v1.&lt;span&gt;11.3&lt;/span&gt;&lt;span&gt;
    kube&lt;/span&gt;-controller-manager-amd64:v1.&lt;span&gt;11.3&lt;/span&gt;&lt;span&gt;
    kube&lt;/span&gt;-scheduler-amd64:v1.&lt;span&gt;11.3&lt;/span&gt;&lt;span&gt;
    kube&lt;/span&gt;-proxy-amd64:v1.&lt;span&gt;11.3&lt;/span&gt;&lt;span&gt;
    pause:&lt;/span&gt;&lt;span&gt;3.1&lt;/span&gt;&lt;span&gt;
    etcd&lt;/span&gt;-amd64:&lt;span&gt;3.2&lt;/span&gt;.&lt;span&gt;18&lt;/span&gt;&lt;span&gt;
    coredns:&lt;/span&gt;&lt;span&gt;1.1&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; image &lt;span&gt;in&lt;/span&gt; ${images[@]}; &lt;span&gt;do&lt;/span&gt;&lt;span&gt; 
    docker pull $myhub_name&lt;/span&gt;/&lt;span&gt;$image
    docker tag $myhub_name&lt;/span&gt;/$image $gcr_name/&lt;span&gt;$image
    docker rmi $myhub_name&lt;/span&gt;/&lt;span&gt;$image
&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;

# 确认上面的无错误，开始下载。
[root@master k8s_images]# .&lt;/span&gt;/pull_image_from_dockerhub_v1.&lt;span&gt;11.3&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; 
[root@master k8s_images]# docker image &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt; 
REPOSITORY TAG IMAGE ID CREATED SIZE
k8s.gcr.io&lt;/span&gt;/pause &lt;span&gt;3.1&lt;/span&gt; 24440bb35d05 About an hour ago &lt;span&gt;742&lt;/span&gt;&lt;span&gt; kB
k8s.gcr.io&lt;/span&gt;/kube-proxy-amd64 v1.&lt;span&gt;11.3&lt;/span&gt; 763b3c45ccd2 &lt;span&gt;4&lt;/span&gt; hours ago &lt;span&gt;97.8&lt;/span&gt;&lt;span&gt; MB
k8s.gcr.io&lt;/span&gt;/kube-scheduler-amd64 v1.&lt;span&gt;11.3&lt;/span&gt; 8434ffab1549 &lt;span&gt;5&lt;/span&gt; hours ago &lt;span&gt;56.8&lt;/span&gt;&lt;span&gt; MB
k8s.gcr.io&lt;/span&gt;/kube-controller-manager-amd64 v1.&lt;span&gt;11.3&lt;/span&gt; 3b0d0349c534 &lt;span&gt;5&lt;/span&gt; hours ago &lt;span&gt;155&lt;/span&gt;&lt;span&gt; MB
k8s.gcr.io&lt;/span&gt;/kube-apiserver-amd64 v1.&lt;span&gt;11.3&lt;/span&gt; 306b76250de9 &lt;span&gt;6&lt;/span&gt; hours ago &lt;span&gt;187&lt;/span&gt;&lt;span&gt; MB
k8s.gcr.io&lt;/span&gt;/coredns &lt;span&gt;1.1&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt; 6b777875393d &lt;span&gt;6&lt;/span&gt; hours ago &lt;span&gt;45.6&lt;/span&gt;&lt;span&gt; MB
k8s.gcr.io&lt;/span&gt;/etcd-amd64 &lt;span&gt;3.2&lt;/span&gt;.&lt;span&gt;18&lt;/span&gt; 7dc1bb5c1af1 &lt;span&gt;6&lt;/span&gt; hours ago &lt;span&gt;219&lt;/span&gt; MB
&lt;/pre&gt;
&lt;pre&gt;
# 其他的2个node节点也需要同样操作
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;初始化k8s&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@master k8s_images]#  kubeadm  init --pod-network-cidr=&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;16&lt;/span&gt; --kubernetes-version=v1.&lt;span&gt;11.3&lt;/span&gt;&lt;span&gt;
省略大量输出
Your Kubernetes master has initialized successfully&lt;/span&gt;!&lt;span&gt;

To start using your cluster, you need to run the following as a regular user:

&lt;/span&gt;&lt;span&gt;mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/&lt;/span&gt;&lt;span&gt;&lt;span&gt;config&lt;/span&gt;

You should now deploy a pod network to the cluster.
Run &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kubectl apply -f [podnetwork].yaml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; with one of the options listed at:
https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;kubernetes.io/docs/concepts/cluster-administration/addons/&lt;/span&gt;
&lt;span&gt;
You can now &lt;/span&gt;&lt;span&gt;join&lt;/span&gt;&lt;span&gt; any number of machines by running the following on each node
as root:

&lt;span&gt;kubeadm &lt;/span&gt;&lt;/span&gt;&lt;span&gt;join 10.4.3.91:6443 --token 1ccx3e.jwbm8pbaq1awiz2z --discovery-token-ca-cert-hash sha256:838517f2d09d04d8ab1d736466311e32db26d2c5a9286fec37204b2de7923a67&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;客户端设置&lt;/h3&gt;
&lt;p&gt;这里kubectl客户端的配置设置，我们直接设置到主节点上面来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@master k8s_images]# &lt;span&gt;mkdir&lt;/span&gt; -p $HOME/&lt;span&gt;.kube
[root@master k8s_images]# &lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;cp&lt;/span&gt; -i /etc/kubernetes/admin.conf $HOME/.kube/&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;cp&lt;/span&gt;: overwrite ‘/root/.kube/config’?&lt;span&gt; y
[root@master k8s_images]# &lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chown&lt;/span&gt; $(&lt;span&gt;id&lt;/span&gt; -u):$(&lt;span&gt;id&lt;/span&gt; -g) $HOME/.kube/&lt;span&gt;config
[root@master k8s_images]# &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; kubeadm join 10.4.3.91:6443 --token 1ccx3e.jwbm8pbaq1awiz2z --discovery-token-ca-cert-hash sha256:838517f2d09d04d8ab1d736466311e32db26d2c5a9286fec37204b2de7923a67&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;/root/k8s.json
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;安装flannel网络组件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@master k8s_images]# kubectl  apply -f https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;node1加入集群&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@node1 k8s_images]#  kubeadm &lt;span&gt;join&lt;/span&gt; &lt;span&gt;10.4&lt;/span&gt;.&lt;span&gt;3.91&lt;/span&gt;:&lt;span&gt;6443&lt;/span&gt; --token 1ccx3e.jwbm8pbaq1awiz2z --discovery-token-ca-cert-&lt;span&gt;hash sha256:838517f2d09d04d8ab1d736466311e32db26d2c5a9286fec37204b2de7923a67 &lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个命令来自与主节点初始化的时候的输出，上面已经保存到主节点的/root/k8s.json。&lt;/p&gt;
&lt;h3&gt;查看集群状态&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@master k8s_images]# kubectl get nodes 
NAME      STATUS    ROLES     AGE       VERSION
master    Ready     master    17m       v1.&lt;/span&gt;&lt;span&gt;11.3&lt;/span&gt;&lt;span&gt;
node1     Ready     &lt;/span&gt;&amp;lt;none&amp;gt;    8m        v1.&lt;span&gt;11.3&lt;/span&gt;&lt;span&gt;
[root@master k8s_images]# kubectl get pod &lt;/span&gt;-n kube-&lt;span&gt;system 
NAME                             READY     STATUS    RESTARTS   AGE
coredns&lt;/span&gt;-78fcdf6894-5zr25         &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          17m
coredns&lt;/span&gt;-78fcdf6894-82v6w         &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          17m
etcd&lt;/span&gt;-master                      &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          7m
kube&lt;/span&gt;-apiserver-master            &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          7m
kube&lt;/span&gt;-controller-manager-master   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          7m
kube&lt;/span&gt;-flannel-ds-amd64-5s962      &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          4m
kube&lt;/span&gt;-flannel-ds-amd64-s2t5b      &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          4m
kube&lt;/span&gt;-proxy-ccvdd                 &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          17m
kube&lt;/span&gt;-proxy-p2fbl                 &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          8m
kube&lt;/span&gt;-scheduler-master            &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          7m
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个状态需要等一段时间才能全是Running。好了，k8s集群就安装完毕了。&lt;/p&gt;

</description>
<pubDate>Thu, 27 Sep 2018 15:52:00 +0000</pubDate>
<dc:creator>LinuxPanda</dc:creator>
<og:description>背景 自己学习k8s集群，无奈屌丝一枚，没钱配置vpn服务，安装k8s花费的时间太久了。为了小伙伴们可以快速安装k8s，我花了点时间整理了这篇博客，提供一个不用翻墙就可以愉快安装k8s集群的方法。 主</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_liunx_53_k8s.html</dc:identifier>
</item>
<item>
<title>发现一个骗粉丝的人后发现博客园的一个bug - 张林-布莱恩特</title>
<link>http://www.cnblogs.com/zhangmumu/p/9716378.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangmumu/p/9716378.html</guid>
<description>&lt;p&gt;&lt;strong&gt;发现一个骗粉丝的人后发现博客园的一个bug&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当你点开这篇文章的时候，如果你已经登录博客园账号，那么你自动回成为我的博客园粉丝，因为我加了自动关注的js，这里并不是想骗粉丝，希望博客园能重视这个bug(当然博客园肯定知道这个bug的)。明天早上我会删除掉这段js的。&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;h3&gt;起因&amp;gt;发现一个骗粉丝的人&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;经过&amp;gt;他是如何实现骗粉丝的&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;我的一些思考&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;1.发现一个骗粉丝的人&lt;/h3&gt;
&lt;p&gt;今天下班，打开博客园的时候看到这篇文章，点了进去，感觉排版不错，自定义的界面体验非常不错，职业性地点击了主页看了看，发现了一个问题，于是乎有了这篇文章。&lt;br/&gt;至于是什么问题，还是看图说话吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201809/1220420-20180927234129109-927152960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201809/1220420-20180927234207379-798675907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;这时我并没有感觉到任何奇怪的地方，感觉体验不错，排版和内容也还不错，我是搞.net 的，所以对于java只是粗略地看了一下，文章写的还是可以的，于是我习惯性地点击了他的主页，我发现我已经关注了他，对于java，很难有充分的理由让我去关注他。那么问题来了，“刚刚点击了那篇文章，是如何实现自动关注，骗粉丝的呢”！&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201809/1220420-20180927234210928-625047935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;其实也就是刷小聪明骗粉丝而已。&lt;/p&gt;
&lt;h3&gt;2.他是如何实现骗粉丝的&lt;/h3&gt;
&lt;p&gt;&lt;br/&gt;点击那篇文章，打开F12，发现了两段自定义的yueshutong.js和guanzhu.js，他申请了自定义的js的权限，可以引入外部的js。第一段yueshutong.js 并没有发现任何奇怪的地方。作为学生来说这段代码写的还是可以的，100分的话我可以给80分。&lt;br/&gt;至于第二段guanzhu.js 非常简单直接，不过现在他已经删除掉了，刷小聪明做贼心虚，不过我已经截取下来了，没图说个jb啊！&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201809/1220420-20180927234306435-861675086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;连博客园的站长都成了他的粉丝了，之前看的时候发现dudu都成了他的粉丝，不过现在dudu取关了，这骗真的是可以的，满分！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201809/1220420-20180927234325590-1656527809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;就是这段guanzhu.js ，懂点js的都知道在网页加载的时候自动发送ajax请求关注，这个参数cb_blogUserGuid就是用户的唯一标识，可以在每篇文章的左键查看源码里面找的到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(document).ready(function(){
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; json = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blogUserGuid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:cb_blogUserGuid};
$.ajax({
type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
url: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/mvc/Follow/FollowBlogger.aspx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
data: JSON.stringify(json),
contentType: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
dataType: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
success: function(data) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(&quot;..&quot;)&lt;/span&gt;
&lt;span&gt;}
});
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201809/1220420-20180927235425287-1545876590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;为了验证正确性，随便打开一篇文章就可以查看“关注我”按钮的js事件，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201809/1220420-20180927234505116-588884926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个fllow方法在blog-common.js中&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201809/1220420-20180927234519305-524378895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至于实现的方式，其实非常low，就是申请js权限，在设置&amp;gt;页脚html代码 添加这段js&lt;/p&gt;
&lt;p&gt;“&amp;lt;script src=&quot;//files.cnblogs.com/files/zhangmumu/test.js/&amp;gt;”&lt;/p&gt;
&lt;p&gt;在网页加载的时候自动发送关注的ajax请求。&lt;/p&gt;

&lt;h3&gt;3.我的看法&lt;/h3&gt;
&lt;p&gt;1. 从技术上来说，这并没有任何难度，博客园给我们开放js权限，是让更好自定义自己的博客，当然博客园肯定是知道这个bug的，而极少部分人却拿这个去“骗粉丝”，也许是为了好玩而已。我还是希望博客园能够修复这个bug，毕竟这个bug实实在在地存在。&lt;br/&gt;2. 从社区的环境来说，博客园是最“纯粹的社区”，可能没有之一。&lt;br/&gt;“是一个面向开发者的知识分享社区。自创建以来，博客园一直致力并专注于为开发者打造一个纯净的技术交流社区，推动并帮助开发者通过互联网分享知识，从而让更多开发者从中受益。博客园的使命是帮助开发者用代码改变世界”&lt;br/&gt;搞.net的，有一些博客园的粉丝，说明还是有一定的含金量的，是一个面向开发者的知识分享社区，，前段时间比较火的是github简历造假，给中国的github社区造成不少的影响，搞.net的，有一些博客园的粉丝，说明还是有一定的含金量的。希望每个在博客园的博主都成为这个为数不多的“干净”社区的维护者和参与者（有点拍马屁了）。&lt;/p&gt;
</description>
<pubDate>Thu, 27 Sep 2018 15:47:00 +0000</pubDate>
<dc:creator>张林-布莱恩特</dc:creator>
<og:description>从技术上来说，这并没有任何难度，博客园给我们开放js权限，是让更好自定义自己的博客，当然博客园肯定是知道这个bug的，而极少部分人却拿这个去“骗粉丝”，也许是为了好玩而已。我还是希望博客园能够修复这个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangmumu/p/9716378.html</dc:identifier>
</item>
<item>
<title>注册表单 - xxxxxxvo</title>
<link>http://www.cnblogs.com/tomorrowtodie/p/9716291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tomorrowtodie/p/9716291.html</guid>
<description>&lt;pre&gt;
&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;登录界面&amp;lt;/title&amp;gt;
&amp;lt;style type=&quot;text/css&quot;&amp;gt;
   h1{
     color:blue;
     font-size:45px;  
   }

&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;load&quot;&amp;gt;
              &amp;lt;h1 align=&quot;center&quot;&amp;gt;哈哈哈&amp;lt;/h1&amp;gt;
    &amp;lt;form method=&quot;get&quot;  action=&quot;http://wenjuan.com&quot;&amp;gt;
       &amp;lt;ul class=&quot;reg-box&quot;&amp;gt;
          &amp;lt;li align=&quot;center&quot;&amp;gt;
               &amp;lt;label for=&quot;username&quot;&amp;gt;账号:&amp;lt;/label&amp;gt;
               &amp;lt;input type=&quot;text&quot;  name=&quot;username&quot; id=&quot;username&quot; value=&quot;&quot; maxlength=&quot;11&quot; style=&quot;color:cornflowerblue&quot; /&amp;gt;
          &amp;lt;/li&amp;gt;
          &amp;lt;br /&amp;gt;

          &amp;lt;li align=&quot;center&quot;&amp;gt;
               &amp;lt;label for=&quot;pass&quot;&amp;gt;密码:&amp;lt;/label&amp;gt;
               &amp;lt;input type=&quot;password&quot;  name=&quot;pass&quot; id=&quot;pass&quot; value=&quot;&quot; style=&quot;color: cornflowerblue&quot; /&amp;gt;  
          &amp;lt;/li&amp;gt;  
          &amp;lt;br /&amp;gt;
             &amp;lt;div align=&quot;center&quot; &amp;gt;
                 &amp;lt;span  id=&quot;control-group&quot; &amp;gt;
                    &amp;lt;label align=&quot;center&quot;&amp;gt;
                      &amp;lt;input type=&quot;checkbox&quot; value=&quot;option1&quot;&amp;gt;
                      记住密码 |
                    &amp;lt;/label&amp;gt;
                    &amp;lt;a href=&quot;http://www.baidu.com&quot; target=&quot;blank&quot;&amp;gt;忘记密码?&amp;lt;/a&amp;gt;
                  &amp;lt;/span&amp;gt;
              &amp;lt;/div&amp;gt;
       &amp;lt;/ul&amp;gt;
           &amp;lt;div align=&quot;center&quot;&amp;gt;
                &amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp; 
                &amp;lt;button onclick=&quot;http://www.wenjuan.com&quot;&amp;gt;立即登录&amp;lt;/button&amp;gt;
                &amp;amp;nbsp;&amp;lt;input type=&quot;reset&quot; value=&quot;重置&quot; name=&quot;reset&quot; /&amp;gt;
               
           &amp;lt;/div&amp;gt;
           
           &amp;lt;div  align=&quot;center&quot;&amp;gt;
              &amp;lt;label&amp;gt;个人简介：&amp;lt;/label&amp;gt;
              &amp;lt;br / &amp;gt;
              &amp;lt;textarea cols=&quot;50&quot; rows=&quot;10&quot;&amp;gt;在这里输入内容...&amp;lt;/textarea&amp;gt;
              &amp;lt;br /&amp;gt;
              &amp;lt;input type=&quot;submit&quot; value=&quot;确定&quot;  name=&quot;submit&quot; /&amp;gt;
              &amp;lt;input type=&quot;reset&quot; value=&quot;重置&quot;  name=&quot;reset&quot; /&amp;gt;

           &amp;lt;/div&amp;gt;
    &amp;lt;/form&amp;gt;  
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 27 Sep 2018 15:29:00 +0000</pubDate>
<dc:creator>xxxxxxvo</dc:creator>
<og:description>&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tomorrowtodie/p/9716291.html</dc:identifier>
</item>
<item>
<title>Microsoft.AspNetCore.Authentication.Cookies从入门到精通 （二） - Net_win</title>
<link>http://www.cnblogs.com/guodf/p/9716262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guodf/p/9716262.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;​ 上篇文章我们介绍了&lt;code&gt;Microsoft.AspNetCore.Authentication.Cookies&lt;/code&gt;的部分内容，由于篇幅问题，不得不分多篇进行介绍，本篇我们继续之前的介绍。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/StudyXX/Auth/tree/master/Authentication/CookieSample/CookieSample2&quot;&gt;&lt;strong&gt;Demo源码地址&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;cookie加密&quot;&gt;Cookie加密&lt;/h2&gt;
&lt;p&gt;​ 在之前的Demo中，浏览器Cookie中的.AspNetCore.Cookies是一个加密字符串，默认Asp.Net Core是对该值做过加密处理的，至于加密方式我们不得而知&lt;em&gt;（翻看源码是可以找到一些蛛丝马迹的）&lt;/em&gt;， 如果我们要修改加密方式只有一种办法就是通过&lt;code&gt;DataProtectionProvider&lt;/code&gt;属性设置我们自己的实现：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Startup.cs&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    ......
    services.AddAuthentication()
        .AddCookie(options=&amp;gt;{
            options.SlidingExpiration = true;
            options.ExpireTimeSpan = TimeSpan.FromMinutes(10);
            options.Cookie.Expiration = TimeSpan.FromDays(365);
            //设置我们自己的数据加密实现
            options.DataProtectionProvider = new MyDataProtectionProvider();
        })
        .AddCookie(&quot;Admin&quot;,&quot;Admin&quot;,options=&amp;gt;{
            options.SlidingExpiration = true;
            options.ExpireTimeSpan = TimeSpan.FromDays(1);
            options.Cookie.Expiration = TimeSpan.FromDays(365);
        }); 
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MyDataProtectionProvider&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class MyDataProtector : IDataProtector
{
    private string _prupose;

    public MyDataProtector() : this(null)
    { }
    
    public MyDataProtector(string purpose)
    {
        _prupose = purpose;
    }
    
    public IDataProtector CreateProtector(string purpose)
    {
        _prupose = purpose;
        //我们也可以在这里返回多个实例
        //return new MyDataProtector(purpose);
        return this;
    }

    public byte[] Protect(byte[] plaintext)
    {
        return plaintext
    }

    public byte[] Unprotect(byte[] protectedData)
    {
        return protectedData;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MyDataProtector是我们自定义的加密类，这里我们没有实现&lt;code&gt;Protect&lt;/code&gt;和&lt;code&gt;Unprotect&lt;/code&gt;方法，只是简单的做了一个&lt;code&gt;return&lt;/code&gt;操作，具体要使用什么加密方式，还是交给需要他的人吧，这里我们只演示一下如何自定义加密类就行了。&lt;/p&gt;
&lt;h2 id=&quot;cookie伪加密序列化反序列化&quot;&gt;Cookie伪加密（序列化/反序列化）&lt;/h2&gt;
&lt;p&gt;​ 伪加密说的是&lt;code&gt;TicketDataFormat&lt;/code&gt;属性，上文我们介绍了&lt;code&gt;IDataProtector&lt;/code&gt;接口中定义的加密解密方法，这里我们介绍&lt;code&gt;ISecureDataFormat&lt;/code&gt;接口中也定义的&lt;code&gt;Protect&lt;/code&gt;和&lt;code&gt;Unprotect&lt;/code&gt;方法，从字面两上看两个接口的方法意思一样，但是从实现代码看，完全不是一回事，&lt;code&gt;ISecureDataFormat&lt;/code&gt;接口处理的并不是加密，准确的说它的作用是序列化与反序列化，我们可以看一下Asp.Net Coro中的默认实现&lt;a href=&quot;https://github.com/aspnet/Security/blob/master/src/Microsoft.AspNetCore.Authentication/Data/SecureDataFormat.cs&quot;&gt;SecureDataFormat&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Startup.cs&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    ......
    services.AddAuthentication()
        .AddCookie(options=&amp;gt;{
            options.SlidingExpiration = true;
            options.ExpireTimeSpan = TimeSpan.FromMinutes(10);
            options.Cookie.Expiration = TimeSpan.FromDays(365);
            options.DataProtectionProvider = new MyDataProtector();
            //使用我们自己的序列化实现,这里的代码看起来有点别扭，上一行我们已经设置MyDataProtector实例，这里又设置一次，原因是Asp.Net Core框架本身在这里设计的有点问题,如果通过依赖注入的方式就可以避免这种让人费解的写法。
            options.TicketDataFormat =new MyTicketDataFormat(new MyDataProtector());
        })
        .AddCookie(&quot;Admin&quot;,&quot;Admin&quot;,options=&amp;gt;{
            options.SlidingExpiration = true;
            options.ExpireTimeSpan = TimeSpan.FromDays(1);
            options.Cookie.Expiration = TimeSpan.FromDays(365);
        }); 
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MyTicketDataFormat&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class MyTicketDataFormat : TicketDataFormat
{
    public MyTicketDataFormat(IDataProtector dataProtector):base(dataProtector)
    {}
    public new string Protect(AuthenticationTicket data)
    {
        return base.Protect(data);
    }

    public new string Protect(AuthenticationTicket data, string purpose)
    {
        return base.Protect(data, purpose);
    }

    public new AuthenticationTicket Unprotect(string protectedText)
    {
        return base.Unprotect(protectedText);
    }

    public new AuthenticationTicket Unprotect(string protectedText, string purpose)
    {
        return base.Unprotect(protectedText, purpose);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们定义了一个序列化类&lt;code&gt;MyTicketDataFormat&lt;/code&gt;，这里我们继承的父类是&lt;code&gt;TicketDataFormat&lt;/code&gt;，&lt;code&gt;TicketDataFormat&lt;/code&gt;是Asp.Net Core的默认实现，如果我们没有设置&lt;code&gt;options.TicketDataFormat&lt;/code&gt;，默认使用的序列化类就是&lt;code&gt;TicketDataFormat&lt;/code&gt;，如果在真实的项目中你需要自定义序列化时，你应该实现&lt;code&gt;ISecureDataFormat&amp;lt;AuthenticationTicket&amp;gt;&lt;/code&gt;接口而不是像我这样偷懒，我这里纯粹是为了演示，我们看一下Asp.Net Core是如何实现&lt;a href=&quot;https://github.com/aspnet/Security/blob/master/src/Microsoft.AspNetCore.Authentication/Data/SecureDataFormat.cs&quot;&gt;SecureDataFormat&lt;/a&gt;类的&lt;em&gt;（SecureDataFormat是TicketDataFormat的父类）&lt;/em&gt;。这里有一点需要注意，如果你实现了&lt;code&gt;ISecureDataFormat&amp;lt;AuthenticationTicket&amp;gt;&lt;/code&gt;接口别忘了在构造函数中注入&lt;code&gt;IDataProtector&lt;/code&gt;，如果你真的忘记了，那么你上文设置的&lt;code&gt;options.DataProtectionProvider = new MyDataProtectionProvider();&lt;/code&gt;将不会起任何作用&lt;em&gt;（我认为这里是一个大坑）&lt;/em&gt;。&lt;/p&gt;
&lt;h2 id=&quot;减少cookie中value的大小&quot;&gt;减少Cookie中Value的大小&lt;/h2&gt;
&lt;p&gt;​ 默认情况下Asp.Net Core的实现是将&lt;code&gt;AuthenticationTicket&lt;/code&gt;对象序列化并加密存储在Cookie中，那么这会有一个隐患，随着&lt;code&gt;AuthenticationTicket&lt;/code&gt;对象存储数据越来越多，Cookie也会越来越大，但是浏览器只给了我们4K的存储空间，有可能在某一天你的Cookie就装不下你的数据流，所以减少Cookie的存储是我们或许终将考虑的一个问题；从另一个方面看，减少Cookie的数据量也利于网络的传输。&lt;/p&gt;
&lt;p&gt;​ 那么我们怎么减小Cookie的存储空间呢？！我们不妨借鉴一下Asp.Net Core中Session的实现原理，将Cookie信息，写入内存、缓存服务器（redis）中，然后通过唯一标识与它对应，这样便可以极大的减少Cookie的存储传输体积。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Startup.cs&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    ......
    services.AddAuthentication()
        .AddCookie(options=&amp;gt;{
            options.SlidingExpiration = true;
            options.ExpireTimeSpan = TimeSpan.FromMinutes(10);
            options.Cookie.Expiration = TimeSpan.FromDays(365);
            options.DataProtectionProvider = new MyDataProtectionProvider();
            options.TicketDataFormat =new MyTicketDataFormat(new MyDataProtector());
            //添加Cookie存储实现
            options.SessionStore = new MyTicketStore();            
        })
        .AddCookie(&quot;Admin&quot;,&quot;Admin&quot;,options=&amp;gt;{
            options.SlidingExpiration = true;
            options.ExpireTimeSpan = TimeSpan.FromDays(1);
            options.Cookie.Expiration = TimeSpan.FromDays(365);
        }); 
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MyTicketStore&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class MyTicketStore : ITicketStore
{
    private Dictionary&amp;lt;string, AuthenticationTicket&amp;gt; _cache = new Dictionary&amp;lt;string, AuthenticationTicket&amp;gt;();

    public Task RemoveAsync(string key)
    {
        _cache.Remove(key);
        return Task.FromResult(0);
    }

    public Task RenewAsync(string key, AuthenticationTicket ticket)
    {
        _cache[key]= ticket;
        return Task.FromResult(0);
    }

    public Task&amp;lt;AuthenticationTicket&amp;gt; RetrieveAsync(string key)
    {
        _cache.TryGetValue(key, out AuthenticationTicket ticket);
        return Task.FromResult(ticket);
    }

    public Task&amp;lt;string&amp;gt; StoreAsync(AuthenticationTicket ticket)
    {
        var key = Guid.NewGuid().ToString(&quot;n&quot;);
        _cache.TryAdd(key, ticket);
        return Task.FromResult(key);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码我们通过实现&lt;code&gt;ITicketStore&lt;/code&gt;的自定义类型&lt;code&gt;MyTicketStore&lt;/code&gt;来自定义&lt;code&gt;AuthenticationTicket&lt;/code&gt;数据的存储，在&lt;code&gt;MyTicketStore&lt;/code&gt;中我们通过&lt;code&gt;Dictionary&amp;lt;string, AuthenticationTicket&amp;gt;&lt;/code&gt;来存储认证数据，这里其实应该使用内存，或者外部缓存系统，例如：用Redis来存储认证数据。&lt;/p&gt;
&lt;h2 id=&quot;自定义cookie管理功能&quot;&gt;自定义Cookie管理功能&lt;/h2&gt;
&lt;p&gt;​ 我们这里说的Cookie管理指的是&lt;code&gt;ICookieManager&lt;/code&gt;接口，该接口主要是用来添加，删除，获取Cookie的信息，也就是&lt;code&gt;Microsoft.AspNetCore.Authentication.Cookies&lt;/code&gt;真正将Cookie写入http头，从http头获取Cookie的入口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Startup.cs&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    ......
    services.AddAuthentication()
        .AddCookie(options=&amp;gt;{
            options.SlidingExpiration = true;
            options.ExpireTimeSpan = TimeSpan.FromMinutes(10);
            options.Cookie.Expiration = TimeSpan.FromDays(365);
            options.DataProtectionProvider = new MyDataProtectionProvider();
            options.TicketDataFormat =new MyTicketDataFormat(new MyDataProtector());
            options.SessionStore = new MyTicketStore();
            options.CookieManager = new MyCookieManager();
        })
        .AddCookie(&quot;Admin&quot;,&quot;Admin&quot;,options=&amp;gt;{
            options.SlidingExpiration = true;
            options.ExpireTimeSpan = TimeSpan.FromDays(1);
            options.Cookie.Expiration = TimeSpan.FromDays(365);
        }); 
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MyCookieManager&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class MyCookieManager : ICookieManager
{
    public void AppendResponseCookie(HttpContext context, string key, string value, CookieOptions options)
    {
        context.Response.Cookies.Append(key, value, options);
    }

    public void DeleteCookie(HttpContext context, string key, CookieOptions options)
    {
        context.Response.Cookies.Delete(key, options);
    }

    public string GetRequestCookie(HttpContext context, string key)
    {
        return context.Request.Cookies[key];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们这里的实现很简单，仅仅调用了一下HttpContext上的对象来操作Cookie，在实现上可能会存在一些问题，更安全的实现请看&lt;a href=&quot;https://github.com/aspnet/Security/blob/master/shared/Microsoft.AspNetCore.ChunkingCookieManager.Sources/ChunkingCookieManager.cs&quot;&gt;ChunkingCookieManager&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;我们介绍了如何通过&lt;code&gt;IDataProtector&lt;/code&gt;接口实现自己的加密方式 。&lt;/li&gt;
&lt;li&gt;我们介绍了如何通过&lt;code&gt;ISecureDataFormat&amp;lt;AuthenticationTicket&amp;gt;&lt;/code&gt;接口实现自己的序列化方式，并提到了这里可能有坑，当我们自定义序列化方式的时候，需要再构造函数中添加&lt;code&gt;IDataProtector&lt;/code&gt;参数，不然可能导致&lt;code&gt;DataProtectionProvider&lt;/code&gt;属性失去意义。&lt;/li&gt;
&lt;li&gt;我们介绍如何通过&lt;code&gt;ITicketStore&lt;/code&gt;接口实现类似Session的存储机制，来减少Cookie在浏览器中的存储以及传输量。&lt;/li&gt;
&lt;li&gt;我们介绍了如何通过&lt;code&gt;ICookieManager&lt;/code&gt;接口实现Cookie的自定义管理功能。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;未完待续......&quot;&gt;未完待续......&lt;/h2&gt;
</description>
<pubDate>Thu, 27 Sep 2018 15:21:00 +0000</pubDate>
<dc:creator>Net_win</dc:creator>
<og:description>Microsoft.AspNetCore.Authentication.Cookies从入门到精通 （二） [TOC] ​ 上篇文章我们介绍了 的部分内容，由于篇幅问题，不得不分多篇进行介绍，本篇我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guodf/p/9716262.html</dc:identifier>
</item>
<item>
<title>微信扫码支付功能（2）---用户扫码支付成功,微信异步回调商户接口 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9716216.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9716216.html</guid>
<description>&lt;p&gt;      上一篇博客完成用户扫码支付功能: &lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/9708534.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qdhxhz/p/9708534.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当用户扫码支付成功之后，微信会异步回调商户接口，告知用户支付成功。好让商户进行下一步操作。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、接口说明&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;   1、流程图&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;这里要做的就是用户支付成功后，微信异步通知商户支付结果，商户收到通知后告知支付通知接收情况。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201809/1090617-20180927225845637-241415423.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;      2、接口说明&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;有关商户接口应注意以下几点:&lt;/p&gt;
&lt;p&gt;     (1)该链接是通过【&lt;span&gt;统一下单API&lt;/span&gt;】中提交的参数&lt;span&gt;notify_url&lt;/span&gt;设置，如果链接无法访问，商户将无法接收到微信通知。&lt;/p&gt;
&lt;p&gt;     (2)&lt;span&gt;notify_url不能有参数，外网可以直接访问，不能有访问控制（比如必须要登录才能操作）&lt;/span&gt;。示例：notify_url：“https://pay.weixin.qq.com/wxpay/pay.action”&lt;/p&gt;
&lt;p&gt;     (3)支付完成后，微信会把相关支付结果和用户信息发送给商户，商户需要接收处理，并返回应答。&lt;/p&gt;
&lt;p&gt;     (4)对后台通知交互时，如果微信收到商户的应答不是成功或超时，微信认为通知失败，微信会通过一定的策略定期重新发起通知，尽可能提高通知的成功率，但微信不&lt;/p&gt;
&lt;p&gt;保证通知最终能成功。（通知频率为15/15/30/180/1800/1800/1800/1800/3600，单位：秒）注意：同样的通知可能会多次发送给商户系统。商户系统必须能够正确处理&lt;/p&gt;
&lt;p&gt;重复的通知。推荐的做法是，当收到通知进行处理时，首先检查对应业务数据的状态，判断该通知是否已经处理过，如果没有处理过再进行处理，如果处理过直接返回结果成功。&lt;/p&gt;
&lt;p&gt;在对业务数据进行状态检查和处理之前，要采用数据锁进行并发控制，以避免函数重入造成的数据混乱。&lt;/p&gt;
&lt;p&gt;    (5)特别提醒：&lt;span&gt;商户系统对于支付结果通知的内容一定要做签名验证，防止数据泄漏导致出现“假通知”，造成资金损失&lt;/span&gt;。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、接口开发&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;    &lt;span&gt;1、回调接口&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;    有关ngrok工具如果不了解的话，可以参考博客:   &lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/9678137.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qdhxhz/p/9678137.html&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 微信支付回调
     * 这里在统一下单中提供的notify_url地址是:&lt;/span&gt;&lt;span&gt;http://jincou.vipgz1.idcfengye.com/api/v1/order/callback&lt;/span&gt;&lt;span&gt;
     * 该域名是sunny-ngrok中的二级域名，通过它映射到微信本地
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&quot;&lt;span&gt;callback&lt;/span&gt;&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; orderCallback(HttpServletRequest request,HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        InputStream inputStream &lt;/span&gt;=&lt;span&gt;  request.getInputStream();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;BufferedReader是包装设计模式，性能更搞&lt;/span&gt;
        BufferedReader in =  &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(inputStream,&quot;UTF-8&quot;&lt;span&gt;));
        StringBuffer sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、将微信回调信息转为字符串&lt;/span&gt;
&lt;span&gt;        String line ;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((line = in.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            sb.append(line);
        }
        in.close();
        inputStream.close();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、将xml格式字符串格式转为map集合&lt;/span&gt;
        Map&amp;lt;String,String&amp;gt; callbackMap =&lt;span&gt; WXPayUtil.xmlToMap(sb.toString());
        System.out.println(callbackMap.toString());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、转为有序的map&lt;/span&gt;
        SortedMap&amp;lt;String,String&amp;gt; sortedMap =&lt;span&gt; WXPayUtil.getSortedMap(callbackMap);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、判断签名是否正确&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(WXPayUtil.isCorrectSign(sortedMap,weChatConfig.getKey())){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、判断回调信息是否成功&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(&quot;SUCCESS&quot;.equals(sortedMap.get(&quot;result_code&quot;&lt;span&gt;))){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取商户订单号
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;商户系统内部订单号，要求32个字符内，只能是数字、大小写字母_-|* 且在同一个商户号下唯一&lt;/span&gt;
                String outTradeNo = sortedMap.get(&quot;out_trade_no&quot;&lt;span&gt;);
                System.out.println(outTradeNo);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6、数据库查找订单,如果存在则根据订单号更新该订单&lt;/span&gt;
                VideoOrder dbVideoOrder =&lt;span&gt; videoOrderService.findByOutTradeNo(outTradeNo);
                System.out.println(dbVideoOrder);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dbVideoOrder != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; dbVideoOrder.getState()==0){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断逻辑看业务场景&lt;/span&gt;
                    VideoOrder videoOrder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VideoOrder();
                    videoOrder.setOpenid(sortedMap.get(&lt;/span&gt;&quot;openid&quot;&lt;span&gt;));
                    videoOrder.setOutTradeNo(outTradeNo);
                    videoOrder.setNotifyTime(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改支付状态，之前生成的订单支付状态是未支付，这里表面已经支付成功的订单&lt;/span&gt;
                    videoOrder.setState(1&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据商户订单号更新订单&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; rows =&lt;span&gt; videoOrderService.updateVideoOderByOutTradeNo(videoOrder);
                    System.out.println(rows);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7、通知微信订单处理成功&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(rows == 0&lt;span&gt;){
                        response.setContentType(&lt;/span&gt;&quot;text/xml&quot;&lt;span&gt;);
                        response.getWriter().println(&lt;/span&gt;&quot;success&quot;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                }}
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7、通知微信订单处理失败&lt;/span&gt;
        response.setContentType(&quot;text/xml&quot;&lt;span&gt;);
        response.getWriter().println(&lt;/span&gt;&quot;fail&quot;&lt;span&gt;);

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;    2、校验签名方法&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 校验签名
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isCorrectSign(SortedMap&amp;lt;String, String&amp;gt;&lt;span&gt; params, String key){

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、再进行一次生成sign&lt;/span&gt;
        String sign =&lt;span&gt; createSign(params,key);
        String weixinPaySign &lt;/span&gt;= params.get(&quot;sign&quot;&lt;span&gt;).toUpperCase();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将两次生成的sign比较看是否一致&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; weixinPaySign.equals(sign);
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 生成微信支付sign
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String createSign(SortedMap&amp;lt;String, String&amp;gt;&lt;span&gt; params, String key){
        StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        Set&lt;/span&gt;&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;&amp;gt; es =&lt;span&gt;  params.entrySet();
        Iterator&lt;/span&gt;&amp;lt;Map.Entry&amp;lt;String,String&amp;gt;&amp;gt; it =&lt;span&gt;  es.iterator();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成 stringA=&quot;appid=wxd930ea5d5a258f4f&amp;amp;body=test&amp;amp;device_info=1000&amp;amp;mch_id=10000100&amp;amp;nonce_str=ibuaiVcKdpRxkhJA&quot;;&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (it.hasNext()){
            Map.Entry&lt;/span&gt;&amp;lt;String,String&amp;gt; entry = (Map.Entry&amp;lt;String,String&amp;gt;&lt;span&gt;)it.next();
             String k &lt;/span&gt;=&lt;span&gt; (String)entry.getKey();
             String v &lt;/span&gt;=&lt;span&gt; (String)entry.getValue();
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; != v &amp;amp;&amp;amp; !&quot;&quot;.equals(v) &amp;amp;&amp;amp; !&quot;sign&quot;.equals(k) &amp;amp;&amp;amp; !&quot;key&quot;&lt;span&gt;.equals(k)){
                sb.append(k&lt;/span&gt;+&quot;=&quot;+v+&quot;&amp;amp;&quot;&lt;span&gt;);
             }
        }
        sb.append(&lt;/span&gt;&quot;key=&quot;&lt;span&gt;).append(key);
        String sign &lt;/span&gt;=&lt;span&gt; CommonUtils.MD5(sb.toString()).toUpperCase();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sign;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;      &lt;span&gt;3、测试&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;（1）支付成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201809/1090617-20180927230239509-63693087.png&quot; alt=&quot;&quot; width=&quot;213&quot; height=&quot;186&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）通过ngrok回调到本地，通过断点可以看出sb字符串格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201809/1090617-20180927230721977-407348669.png&quot; alt=&quot;&quot; width=&quot;759&quot; height=&quot;412&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）将xml格式字符串转为map&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201809/1090617-20180927231019241-910799737.png&quot; alt=&quot;&quot; width=&quot;757&quot; height=&quot;385&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功！&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;github源码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;github&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;: &lt;/strong&gt;&lt;a href=&quot;https://github.com/yudiandemingzi/wechatpay&quot; target=&quot;_blank&quot;&gt;https://github.com/yudiandemingzi/wechatpay&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;我只是偶尔安静下来，对过去的种种思忖一番。那些曾经的旧时光里即便有过天真愚钝，也不值得谴责。毕竟，往后的日子，还很长。不断鼓励自己，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;天一亮，又是崭新的起点，又是未知的征程（上校17）&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 27 Sep 2018 15:15:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>用户扫码支付成功,微信异步回调商户 上一篇博客完成用户扫码支付功能: https://www.cnblogs.com/qdhxhz/p/9708534.html 当用户扫码支付成功之后，微信会异步回调</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9716216.html</dc:identifier>
</item>
<item>
<title>WPF 设置控件阴影后，引发的Y轴位置变化问题 - 唐宋元明清2188</title>
<link>http://www.cnblogs.com/kybs0/p/9716032.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kybs0/p/9716032.html</guid>
<description>[unable to retrieve full-text content]背景 最近遇到一个动画执行时，文本位置变化的问题。如下图： 如果你仔细看的话，当星星变小时，文本往下降了几个像素。 貌似有点莫名其妙，因为控件之间并不在同一个Panel布局控件中，不存在高度限制变化引发此类问题。所以有了如下测试 测试场景 1. 首先新建了一个空项目，前面是一个带阴影的文本，后面用一</description>
<pubDate>Thu, 27 Sep 2018 14:58:00 +0000</pubDate>
<dc:creator>唐宋元明清2188</dc:creator>
<og:description>用户扫码支付成功,微信异步回调商户 上一篇博客完成用户扫码支付功能: https://www.cnblogs.com/qdhxhz/p/9708534.html 当用户扫码支付成功之后，微信会异步回调</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9716216.html</dc:identifier>
</item>
<item>
<title>sonarqube7.2版本web api简析 - phinehasz</title>
<link>http://www.cnblogs.com/zhhiyp/p/9716158.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhhiyp/p/9716158.html</guid>
<description>&lt;h2 id=&quot;sonarqube7.2版本web-api简析&quot;&gt;sonarqube7.2版本web api简析&lt;/h2&gt;
&lt;p&gt;本文介绍sonarqube的部分实用Web API,并试图联系实际进行分析,方便集成.以7.2版本为例,下载移步官网.&lt;br/&gt;&lt;strong&gt;Web API文档路径&lt;/strong&gt;&lt;br/&gt;安装并部署7.2版本的sonar之后(推荐在linux上安装),在浏览器上打开sonar,默认是ip:9000端口.&lt;br/&gt;&lt;code&gt;http://{ip}:9000/web_api&lt;/code&gt;即是sonar的api文档. 由于国内资源较少,当时在官网看了半天文档又查了一堆才发现这个预设的路径.这也是为什么写这篇文章,我认为这样的工具是值得推广的.&lt;br/&gt;&lt;strong&gt;认证api&lt;/strong&gt;&lt;br/&gt;部分的sonar api功能需要依靠权限使用,sonar才用的是Basic Auth,就是最普通的认证.&lt;br/&gt;&lt;code&gt;web_api/api/authentication&lt;/code&gt;下可以查看对应的认证api.&lt;br/&gt;例如:&lt;br/&gt;&lt;code&gt;POST api/authentication/login 参数是login和password&lt;/code&gt; 没有特别说明的话,这里的login和password都是admin,可以在sonar页面的最上方Administration里点进行密码修改,也可以直接修改config文件.&lt;br/&gt;如果使用POSTMAN测试接口需要认证的sonar GET接口,可以在postman的认证里,选basic auth,然后填login和password,再发GET请求就可以了.&lt;br/&gt;&lt;strong&gt;重复度api&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;GET api/duplications/show&lt;/code&gt;&lt;br/&gt;例子参数是&lt;code&gt;key=my_project:/src/foo/Bar.php&lt;/code&gt;,使用该接口可以拿某个代码文件的重复度分析,似乎作用不大.后面会讲另一个比较有用的.&lt;br/&gt;&lt;strong&gt;issues api&lt;/strong&gt;&lt;br/&gt;页面在&lt;code&gt;web_api/api/issues&lt;/code&gt;,issues意为问题,告警,github上常见这个单词,还是建议多熟悉英文.&lt;br/&gt;这里的api很多是修改和添加注释等内容,这类api适合自己在sonar之上再封装一层.&lt;br/&gt;如果只是客户端读取sonar的issues信息,可以使用&lt;code&gt;GET api/issues/search&lt;/code&gt;,这个api的参数非常多,在我看来有几个好用,然后讲解一下.&lt;br/&gt;&lt;code&gt;componentKeys&lt;/code&gt; 这是可选参数,意思是组件key,查阅后发现这个key可以代表projectKey,模块的key,单个文件的key,而且可以用逗号隔开传入多个.&lt;br/&gt;比如:&lt;code&gt;my_project,my_project1,my_project2&lt;/code&gt; 这样是查了三个工程的issue情况.&lt;br/&gt;这里讲解一下&lt;strong&gt;projectKey&lt;/strong&gt;的概念:&lt;br/&gt;点进自己的某一个扫描后的项目project,会在右下角发现一个projectKey.如果是maven工程,默认是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;severities&lt;/code&gt; 问题的等级,如果只需要修改最重要等级的,直接用这个参数去获取要改的部分吧.好用.&lt;br/&gt;其他参数都写挺清晰了.&lt;br/&gt;&lt;strong&gt;issue 返回json&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;&quot;paging&quot;: { &quot;pageIndex&quot;: 1, &quot;pageSize&quot;: 100, &quot;total&quot;: 1 },&lt;/code&gt;&lt;br/&gt;这部分其实是第一页,每页100个,实际上可以用参数分页查询.&lt;br/&gt;issues节点里是个json数组,内容比较多,讲解几个参数.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;key&quot;: &quot;01fc972e-2a3c-433e-bcae-0bd7f88f5123&quot;,  issue的唯一key
    &quot;component&quot;:   &quot;com.github.kevinsawicki:http-request:com.github.kevinsawicki.http.HttpRequest&quot;,  组件Key,这里是具体到类的
    &quot;project&quot;: &quot;com.github.kevinsawicki:http-request&quot;,  projectKe
    &quot;rule&quot;: &quot;checkstyle:com.puppycrawl.tools.checkstyle.checks.coding.MagicNumberCheck&quot;,  规则
    &quot;status&quot;: &quot;RESOLVED&quot;,  解决状态
    &quot;resolution&quot;: &quot;FALSE-POSITIVE&quot;,  是否误报
    &quot;severity&quot;: &quot;MINOR&quot;,  告警等级
    &quot;message&quot;: &quot;'3' is a magic number.&quot;,  告警信息
    &quot;line&quot;: 81,  
    &quot;hash&quot;: &quot;a227e508d6646b55a086ee11d63b21e9&quot;,  
    &quot;author&quot;: &quot;Developer 1&quot;,  
    &quot;effort&quot;: &quot;2h1min&quot;,  解决问题需要的时间
    &quot;creationDate&quot;: &quot;2013-05-13T17:55:39+0200&quot;,  
    &quot;updateDate&quot;: &quot;2013-05-13T17:55:39+0200&quot;,  
    &quot;tags&quot;: [  
      &quot;bug&quot;  
    ], &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后有个flow节点,这个是和数据流规则相关的.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;flows&quot;: [
        {
          &quot;locations&quot;: [
            {
              &quot;textRange&quot;: {
                &quot;startLine&quot;: 16,
                &quot;endLine&quot;: 16,
                &quot;startOffset&quot;: 0,
                &quot;endOffset&quot;: 30
              },
              &quot;msg&quot;: &quot;Expected position: 5&quot;
            }
          ]
        },
        {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提供locations节点,指定具体的行数.照目前这例子看似乎还只是单文件数据流.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;metrics api&lt;/strong&gt;&lt;br/&gt;metrics,意为度量,在代码扫描中,常常对复杂度,cpd重复代码等进行分析,这也都算metrics,度量的范畴.&lt;br/&gt;&lt;code&gt;Get information on automatic metrics&lt;/code&gt;获得自动度量的结果&lt;br/&gt;&lt;code&gt;GET api/metrics/search&lt;/code&gt; 这个api可以查找某个项目的所有度量,应该没大用处...&lt;br/&gt;&lt;strong&gt;measures api&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GET api/measures/component&lt;/code&gt; 以&lt;code&gt;component&lt;/code&gt; 组件key和&lt;code&gt;metricKeys&lt;/code&gt; 度量key作为参数,查询某个项目的度量情况,比如重复度,复杂度,行数统计,例如:&lt;br/&gt;&lt;code&gt;metricKeys=ncloc,complexity,violations&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;先这么多,之后可能继续更新.&lt;/p&gt;
</description>
<pubDate>Thu, 27 Sep 2018 14:54:00 +0000</pubDate>
<dc:creator>phinehasz</dc:creator>
<og:description>sonarqube7.2版本web api简析 本文介绍sonarqube的部分实用Web API,并试图联系实际进行分析,方便集成.以7.2版本为例,下载移步官网. Web API文档路径 安装并部</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhhiyp/p/9716158.html</dc:identifier>
</item>
<item>
<title>【机器学习基础】熵、KL散度、交叉熵 - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/9713038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/9713038.html</guid>
<description>&lt;p&gt;　　熵（entropy）、KL 散度（Kullback-Leibler (KL) divergence）和交叉熵（cross-entropy）在机器学习的很多地方会用到。比如在决策树模型使用信息增益来选择一个最佳的划分，使得熵下降最大；深度学习模型最后一层使用 softmax 激活函数后，我们也常使用交叉熵来计算两个分布的“距离”。KL散度和交叉熵很像，都可以衡量两个分布之间的差异，相互之间可以转化。&lt;/p&gt;
&lt;h2&gt;1. 如何量化信息？&lt;/h2&gt;
&lt;p&gt;　　&lt;a title=&quot;信息论&quot; href=&quot;https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF%E8%AE%BA&quot; target=&quot;_blank&quot;&gt;信息论&lt;/a&gt;是应用数学的一个分支，主要研究的是对一个信号包含信息的多少进行量化。信息论的基本想法是一个不太可能的事件发生了，要比一个非常可能的事件发生，能提供更多的信息。&lt;/p&gt;
&lt;p&gt;　　在信息论中，我们认为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;非常可能发生的事件信息量要比较少。在极端情况下，确保能够发生的事件应该没有信息量。&lt;/li&gt;
&lt;li&gt;较不可能发生的事件具有更高的信息量。&lt;/li&gt;
&lt;li&gt;独立事件应具有增量的信息。例如，投掷的硬币两次正面朝上传递的信息量，应该是投掷一次硬币正面朝上的信息量的两倍。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　为了满足上面 3 个性质，定义了一事件 $\mbox{x} = x$ 的&lt;strong&gt;自信息&lt;/strong&gt;（self-information）为&lt;/p&gt;
&lt;p&gt;\begin{equation}&lt;br/&gt;I(x) = -\log P(x) &lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;p&gt;　　我们使用 $\text{x}$ 表示随机变量，使用 $x_1, x_2,...,x_i,..., x_N$ 或者 $x$ 表示随机变量 $\text{x}$ 可能的取值。当式（1）中 $\log$ 以 2 为底数时，$I(x)$ 单位是比特（bit）或者香农（shannons）；当 $\log$ 以自然常数 $e$ 为底数时，$I(x)$ 单位是奈特（nats）。这两个单位之间可以互相转换，通过比特度量的信息只是通过奈特度量信息的常数倍。（使用对数换底公式转化）&lt;/p&gt;
&lt;p&gt;　　自信息只能处理单个的输出。我们可以使用&lt;strong&gt;香农熵&lt;/strong&gt;（Shannon entropy）来对整个概率分布中的不确定性总量进行量化：&lt;/p&gt;
&lt;p&gt;\begin{equation}&lt;br/&gt;H(\text{x}) = \mathbb{E}_{\text{x} \sim P}[I(x)] = \sum_{i= 1}^{N} P(x_i)I(x_i) = - \sum_{i= 1}^{N} P(x_i)\log P(x_i) &lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;p&gt;式（2）后两个等号是在离散型变量的情况下成立，对于连续型变量，则需要求积分。当 $\text{x}$ 是连续的，香农熵被称为&lt;strong&gt;微分熵&lt;/strong&gt;（differential entropy）。&lt;/p&gt;
&lt;p&gt;　　在1948年，&lt;a class=&quot;mw-redirect&quot; title=&quot;克劳德·艾尔伍德·香农&quot; href=&quot;https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%B3%E5%BE%B7%C2%B7%E8%89%BE%E5%B0%94%E4%BC%8D%E5%BE%B7%C2%B7%E9%A6%99%E5%86%9C&quot; target=&quot;_blank&quot;&gt;克劳德·艾尔伍德·香农&lt;/a&gt;将热力学的熵，引入到信息论，因此它又被称为&lt;strong&gt;香农熵&lt;/strong&gt;。机器学习（ML）中熵的概念都是由信息论而来，所以在 ML 中能看到的熵都是香农熵，而不会是热力学的熵。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;熵的一些性质：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;那些接近确定性的分布（输出几乎可以确定）具有较低的熵。&lt;/li&gt;
&lt;li&gt;那些接近均匀分布的概率分布具有较高的熵。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2. KL 散度&lt;/h2&gt;
&lt;p&gt;　　KL 散度全称 Kullback-Leibler (KL) divergence。&lt;/p&gt;
&lt;p&gt;　　KL 散度可以用来衡量两个分布的差异。&lt;/p&gt;
&lt;p&gt;　　在概率论与统计中，我们经常会将一个复杂的分布用一个简单的近似分布来代替。KL 散度可以帮助我们测量在选择一个近似分布时丢失的信息量。&lt;/p&gt;
&lt;p&gt;　　假设原概率分布为 $P(\text{x})$，近似概率分布为 $Q(\text{x})$，则使用 KL 散度衡量这两个分布的差异：&lt;/p&gt;
&lt;p&gt;\begin{equation}&lt;br/&gt;D_{KL}(P||Q) = \mathbb{E}_{\text{x} \sim P}[\log \frac{P(x)}{Q(x)}] = \mathbb{E}_{\text{x} \sim P}[\log P(x) - \log Q(x)] &lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;p&gt;　　如果 $\text{x}$ 是离散型变量，式（3）还可以写成如下形式：&lt;/p&gt;
&lt;p&gt;\begin{equation}&lt;br/&gt;D_{KL}(P||Q) = \sum_{i= 1}^{N} P(x_i) \log\frac{P(x_i)}{Q(x_i)} = \sum_{i= 1}^{N} P(x_i)[\log P(x_i) - \log Q(x_i)]   &lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;p&gt;　　对于连续型变量，则式（4）不能这么写，需要求积分。如果 $\text{x}$ 是连续型变量，则式（3）中概率分布最好用 $p(\text{x})$和$q(\text{x})$ 代替 $P(\text{x})$和$Q(\text{x})$。习惯上，用小写字母表示连续型变量的概率密度函数（probability density function，PDF），用大写字母表示离散型变量的概率质量函数（probability mass function，PMF）。（PDF和PMF都是用来描述概率分布）&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;KL 散度的一些性质：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;KL 散度是非负的。&lt;/li&gt;
&lt;li&gt;KL 散度为 0，当且仅当 $P$ 和 $Q$ 在离散型变量的情况下是相同的分布，或者在连续型变量的情况下是“几乎处处”相同的。&lt;/li&gt;
&lt;li&gt;KL 散度不是真的距离，它不是对称的，即 $ D_{KL}(P||Q) \ne D_{KL}(Q||P)$。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;3. 交叉熵&lt;/h2&gt;
&lt;p&gt;　　交叉熵（cross-entropy）和 KL 散度联系很密切。同样地，交叉熵也可以用来衡量两个分布的差异。以离散型变量 $\text{x}$ 为例：&lt;/p&gt;
&lt;p&gt;\begin{equation}&lt;br/&gt;H(P, Q) = - \mathbb{E}_{\text{x} \sim P}\log Q(x) = - \sum_{i= 1}^{N} P(x_i) \log Q(x_i) &lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;p&gt;　　交叉熵 $H(P, Q) = H(P) +  D_{KL}(P||Q)$。其中 $H(P)$（即 $H(\text{x})$ ，其中 $\text{x} \sim P$）为分布 $P$ 的熵，$D_{KL}(P||Q)$ 表示两个分布的 KL 散度。当概率分布 $P(\text{x})$ 确定了时，$H(P)$ 也将被确定，即 $H(P)$ 是一个常数。在这种情况下，交叉熵和 KL 散度就差一个大小为 $H(P)$ 的常数。下面给出一个简单的推导：&lt;/p&gt;
&lt;p&gt;　　我们将式（4）中 KL 散度的公式再进行展开：&lt;/p&gt;
&lt;p&gt;\begin{equation}\label{equ:tpr}&lt;br/&gt;\begin{split}&lt;br/&gt;D_{KL}(P||Q) &amp;amp;= \sum_{i= 1}^{N} P(x_i)[\log P(x) - \log Q(x)]  \\ &amp;amp;=  \sum_{i= 1}^{N} P(x_i) \log P(x_i)  - \sum_{i= 1}^{N} P(x_i) \log Q(x_i)  \\ &amp;amp;= -[- \sum_{i= 1}^{N} P(x_i) \log P(x_i)]+ [ - \sum_{i= 1}^{N} P(x_i) \log Q(x_i) ] \\ &amp;amp;= - H(P) + H(P, Q)&lt;br/&gt;\end{split}&lt;br/&gt;\end{equation}&lt;br/&gt;即 $H(P, Q) = H(P) +  D_{KL}(P||Q)$。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;交叉熵的一些性质：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;非负。&lt;/li&gt;
&lt;li&gt;和 KL 散度相同，交叉熵也不具备对称性，即 $H(P, Q) \ne H(Q,P)$。&lt;/li&gt;
&lt;li&gt;对同一个分布求交叉熵等于对其求熵。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　为什么既有 KL 散度又有交叉熵？在信息论中，熵的意义是对 $P$ 事件的随机变量编码所需的最小字节数，KL 散度的意义是“额外所需的编码长度”如果我们使用 $Q$ 的编码来表示 $P$，交叉熵指的是当你使用 $Q$ 作为密码来表示 $P$ 是所需要的 “平均的编码长度”。但是在机器学习评价两个分布之间的差异时，由于分布 $P$ 会是给定的，所以此时 KL 散度和交叉熵的作用其实是一样的，而且因为交叉熵少算一项，更加简单，所以选择交叉熵会更好。&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;Goodfellow, I., Bengio, Y., &amp;amp; Courville, A. (2016). Deep Learning. &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/65288314&quot; target=&quot;_blank&quot;&gt;https://www.zhihu.com/question/65288314&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;yui_3_17_2_1_1538034028351_473&quot; class=&quot;entry-title&quot; data-content-field=&quot;title&quot;&gt;&lt;a title=&quot;Kullback-Leibler Divergence Explained&quot; href=&quot;https://www.countbayesie.com/blog/2017/5/9/kullback-leibler-divergence-explained&quot; target=&quot;_blank&quot;&gt;Kullback-Leibler Divergence Explained&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Sep 2018 14:27:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>熵（entropy）、KL散度（Kullback-Leibler (KL) divergence）和交叉熵（cross-entropy）在机器学习的很多地方会用到。比如在决策树模型使用信息增益来选择一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuliytTaotao/p/9713038.html</dc:identifier>
</item>
<item>
<title>react系列（三）组件间通信 - liuyongjia</title>
<link>http://www.cnblogs.com/liuyongjia/p/9715933.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyongjia/p/9715933.html</guid>
<description>&lt;p&gt;React的基本组件元素是一个个组件，组件之间可能存在关联、组合等关系。不同的组件之间，经常会发生数据传递或者交换，我们称之为组件间通信。&lt;br/&gt;根据传递的复杂程度，可以分为三种情况：&lt;br/&gt;&lt;strong&gt;父子间通信，兄弟间通信，同其他外部库通信。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;父子间通信&quot;&gt;父子间通信&lt;/h2&gt;
&lt;p&gt;在学习组件的时候，props是输入，组件是输出。在这里的props，就是父向子传递的数据。而子向父传递数据，则是通过父级传递进来的props中的函数引用，间接的唤起父级处理函数，并传入参数。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/* 父组件 */
export default class NameInput extends Component {
  constructor(props) {
    super(props);
    this.state = {
      value: &quot;default&quot;
    };
    this.handleSubChange = this.handleSubChange.bind(this);
  }
  handleSubChange(newValue) {
    this.setState({ value: newValue });
  }
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;div&amp;gt;{this.state.value}&amp;lt;/div&amp;gt;
        &amp;lt;Sub sub=&quot;sub1&quot; subClick={this.handleSubChange} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/* 子组件 */
export default class NameInput extends Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
  }
  handleChange() {
    this.props.subClick(&quot;new sub&quot;);
  }
  render() {
    return &amp;lt;div onClick={this.handleChange}&amp;gt;{this.props.sub}&amp;lt;/div&amp;gt;;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子里，通过调用props上传递进来的处理函数，达到了子向父传递数据的目的。&lt;/p&gt;
&lt;h2 id=&quot;兄弟间通信&quot;&gt;兄弟间通信&lt;/h2&gt;
&lt;p&gt;不使用其他库的话，借助React原生API，有两种方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过父组件做中转&lt;/li&gt;
&lt;li&gt;借用父组件以外，也可以使用react的Context API&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关于Context API，我们还是先翻文档&lt;a href=&quot;https://react.docschina.org/docs/context.html&quot;&gt;Context&lt;/a&gt;。&lt;br/&gt;Context主要是为了处理多个组件可能需要获取同一组数据，例如文档中提到的theme，以及B端系统经常需要获取全局登录态，都可以使用ContextAPI。&lt;br/&gt;在Context中，有两个重要的概念，Provider和Consumer。&lt;br/&gt;&lt;strong&gt;Provider提供一个全局的数据源，订阅了它的数据源的Cusumer，不论节点嵌套多深都可以获取到Provider提供的数据。&lt;/strong&gt;&lt;br/&gt;看一个例子。&lt;br/&gt;&lt;a href=&quot;https://codesandbox.io/s/r713nv6qkq&quot;&gt;点我-CodeSandbox&lt;/a&gt;&lt;br/&gt;在一些轻量级的应用中，基本上可以使用ContextAPI解决多级数据共享的问题。当然，如果要更强大，只能用Redux等库了。&lt;br/&gt;关于Redux的使用，会在下一篇详细讲解。&lt;/p&gt;
&lt;h2 id=&quot;同其他外部库通信&quot;&gt;同其他外部库通信&lt;/h2&gt;
&lt;p&gt;如果一个项目中，既有React，又有jQuery，又有Vue怎么办？怎么解决这种情形下得数据流转？&lt;br/&gt;这是阿里的一道面试题，我那时没有怎么写过React，基本上就是zepto和小程序，面试官没有为难我，提了这样的问题。当时我提出了一种想法，发布订阅加适配器模式。下面简单说一下我的想法。&lt;br/&gt;如果把这个场景抽象一下，可以看做是三种不同的组件需要相互通信，它们对数据的要求不一样，数据格式不同，但是一旦数据打到各自的组件内，其实数据流就不需要我们关心了。&lt;br/&gt;所以可以维护一个公共的数据集市，所有人都从数据集市里取数据，也向数据集市中发数据，数据集市是一个公开的发布者，各组件为订阅者。&lt;br/&gt;数据集市承担了适配的工作，对各个组件传进来的数据统一保存，在取数据时，根据组件的类型不同，派发不同形式的组件，这样，基本上就将组件间通信提升至了一个统一的数据集市，避免了组件的之间一对一通信。&lt;br/&gt;当然，这和flux的思想也很类似，统一数据源，统一分发，只和数据源交互，避免了多个组件间复杂通讯带来的数据流混乱。&lt;br/&gt;不管怎么样，在前端应用越来越复杂的今天，数据流的流向问题是绕不开，不论是单向数据流，还是多Model多数据流，都是适配当前场景下的解决方案，以后可能会有新的解决方案。&lt;br/&gt;但是目前，在React体系中，Redux是绕不开的。下一篇，说一下flux和Redux。&lt;/p&gt;
</description>
<pubDate>Thu, 27 Sep 2018 14:02:00 +0000</pubDate>
<dc:creator>liuyongjia</dc:creator>
<og:description>组件间通信 React的基本组件元素是一个个组件，组件之间可能存在关联、组合等关系。不同的组件之间，经常会发生数据传递或者交换，我们称之为组件间通信。 根据传递的复杂程度，可以分为三种情况： 父子间通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyongjia/p/9715933.html</dc:identifier>
</item>
<item>
<title>MUI框架-10-MUI 数据交互-跳转详情页面 - 肖朋伟</title>
<link>http://www.cnblogs.com/xpwi/p/9715921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xpwi/p/9715921.html</guid>
<description>&lt;h2 id=&quot;mui框架-10-mui-数据交互-跳转详情页面&quot;&gt;MUI框架-10-MUI 数据交互-跳转详情页面&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;上一篇介绍了如何实现数据交互，给别人的 API 发送 ajax 请求，我们得到数据，再使用 art-template 模板引擎拼接 HTML，最终实现实现数据交互，如果还没有接触，请先学习：&lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/details/82857401&quot;&gt;MUI框架-09-MUI 与后台数据交互&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本篇介绍 MUI 事件管理，实现点击新闻列表跳转详情页的效果&lt;/li&gt;
&lt;li&gt;放上一张图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180927214059636?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; width=&quot;350px&quot;/&gt;&lt;/li&gt;
&lt;li&gt;官方文档：&lt;a href=&quot;http://dev.dcloud.net.cn/mui/event/&quot;&gt;MUI 事件管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;mui-事件管理&quot;&gt;MUI 事件管理&lt;/h3&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;事件绑定：MUI 的事件绑定，除了可以使用addEventListener()方法监听某个特定元素上的事件外， 也可以使用.on()方法实现批量元素的事件绑定&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;我们先看一下官方文档实例：
&lt;ul&gt;&lt;li&gt;点击新闻列表，获取当前列表项的id，并将该id传给新闻详情页面，然后打开新闻详情页面&lt;/li&gt;
&lt;li&gt;这里 mui，前面是一个 id 选择器，下面一个 on 事件函数&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mui(&quot;.mui-table-view&quot;).on('tap','.mui-table-view-cell',function(){
  //获取id
  var id = this.getAttribute(&quot;id&quot;);
  //传值给详情页面，通知加载新数据
  mui.fire(detail,'getDetail',{id:id});
  //打开新闻详情
  mui.openWindow({
 id:'detail',
 url:'detail.html'
  });
}) &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;项目搭建&quot;&gt;项目搭建&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;因为我们这个最好是跟着我的 文章从开始看，因为后面的文章 需要前面的基础&lt;/li&gt;
&lt;li&gt;请先查看：&lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/details/82857401&quot;&gt;MUI框架-09-MUI 与后台数据交互&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;先按照下面目录，建好项目：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180927214349585?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;源代码文件&quot;&gt;源代码文件：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;因为代码比较复杂，分开讲太乱，大家可以拷贝，详解写在注释，&lt;/li&gt;
&lt;li&gt;1.首先需要自己下载只有 template-web.js 文件，获取方法：
&lt;/li&gt;
&lt;li&gt;2.拷贝 index.html 代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&amp;gt;
        &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
        &amp;lt;script src=&quot;js/mui.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;link href=&quot;css/mui.min.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;

        &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/index.css&quot; /&amp;gt;

    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &amp;lt;!--头部信息--&amp;gt;
        &amp;lt;header class=&quot;mui-bar mui-bar-nav title&quot;&amp;gt;
            &amp;lt;a class=&quot;mui-action-back mui-icon mui-icon-left-nav mui-pull-left&quot;&amp;gt;&amp;lt;/a&amp;gt;
            &amp;lt;h1 class=&quot;mui-title&quot;&amp;gt;知乎日报&amp;lt;/h1&amp;gt;
        &amp;lt;/header&amp;gt;

        &amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;
            mui.init({
                subpages: [{
                    url: 'html/content.html',
                    id: 'content.html',
                    styles: {
                        top: '45px', //mui标题栏默认高度为45px；
                        bottom: '0px' //默认为0px，可不定义；
                    }
                }]
            });
        &amp;lt;/script&amp;gt;

        &amp;lt;nav class=&quot;mui-bar mui-bar-tab&quot;&amp;gt;
            &amp;lt;a class=&quot;mui-tab-item mui-active&quot;&amp;gt;
                &amp;lt;span class=&quot;mui-icon mui-icon-home&quot;&amp;gt;&amp;lt;/span&amp;gt;
                &amp;lt;span class=&quot;mui-tab-label&quot;&amp;gt;首页&amp;lt;/span&amp;gt;
            &amp;lt;/a&amp;gt;
            &amp;lt;a class=&quot;mui-tab-item&quot;&amp;gt;
                &amp;lt;span class=&quot;mui-icon mui-icon-phone&quot;&amp;gt;&amp;lt;/span&amp;gt;
                &amp;lt;span class=&quot;mui-tab-label&quot;&amp;gt;电话&amp;lt;/span&amp;gt;
            &amp;lt;/a&amp;gt;
            &amp;lt;a class=&quot;mui-tab-item&quot;&amp;gt;
                &amp;lt;span class=&quot;mui-icon mui-icon-email&quot;&amp;gt;&amp;lt;/span&amp;gt;
                &amp;lt;span class=&quot;mui-tab-label&quot;&amp;gt;邮件&amp;lt;/span&amp;gt;
            &amp;lt;/a&amp;gt;
            &amp;lt;a class=&quot;mui-tab-item&quot;&amp;gt;
                &amp;lt;span class=&quot;mui-icon mui-icon-gear&quot;&amp;gt;&amp;lt;/span&amp;gt;
                &amp;lt;span class=&quot;mui-tab-label&quot;&amp;gt;设置&amp;lt;/span&amp;gt;
            &amp;lt;/a&amp;gt;
        &amp;lt;/nav&amp;gt;
    &amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3.拷贝 content.html 代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;

    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&amp;gt;
        &amp;lt;link href=&quot;../css/mui.min.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;
        
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;

        &amp;lt;div class=&quot;mui-content&quot;&amp;gt;
            &amp;lt;div class=&quot;mui-slider&quot;&amp;gt;
                &amp;lt;div class=&quot;mui-slider-group&quot;&amp;gt;
                    &amp;lt;!--第一个内容区容器--&amp;gt;
                    &amp;lt;div class=&quot;mui-slider-item&quot;&amp;gt;
                        &amp;lt;!-- 具体内容 --&amp;gt;
                        &amp;lt;img src=&quot;../img/1D52F569E73F611465E9BB3656E9628B.png&quot; /&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;!--第二个内容区--&amp;gt;
                    &amp;lt;div class=&quot;mui-slider-item&quot;&amp;gt;
                        &amp;lt;!-- 具体内容 --&amp;gt;
                        &amp;lt;img src=&quot;../img/8CF9B879550CD10AA9B7B58777367C7F.png&quot; /&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;ul class=&quot;mui-table-view&quot; id=&quot;zhihu&quot;&amp;gt;
                
            &amp;lt;/ul&amp;gt;   
            
            
            
            

        &amp;lt;/div&amp;gt;

        &amp;lt;script src=&quot;../js/mui.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
        
        &amp;lt;!-- 导入 template-web.js
            官网下载：http://aui.github.io/art-template/
            csdn下载：https://download.csdn.net/download/qq_40147863/10689407
        --&amp;gt;
        &amp;lt;script src=&quot;../js/template-web.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;!-- 使用&amp;lt;script id=&quot;list&quot; type=&quot;text/html&quot;&amp;gt; 拼接 html --&amp;gt;
        &amp;lt;script id=&quot;list&quot; type=&quot;text/html&quot;&amp;gt;
                &amp;lt;!-- 循环语法 --&amp;gt;
                {{each stories as list}}
                &amp;lt;li class=&quot;mui-table-view-cell mui-media&quot; id=&quot;{{list.id}}&quot;&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img class=&quot;mui-media-object mui-pull-left&quot; src=&quot;{{list.images[0]}}&quot;&amp;gt;
                        &amp;lt;div class=&quot;mui-media-body&quot;&amp;gt;
                            &amp;lt;!-- 获取 title --&amp;gt;
                            {{list.title}}
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                {{/each}}
            &amp;lt;/script&amp;gt;
            
        &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            
              
            //plusReady，用来定义加载dom后的操作
            mui.plusReady(function() {
                
                //发起 ajax请求，地址使用知乎日报 api 
                mui.ajax('https://news-at.zhihu.com/api/4/theme/11', {
                    /* data 是参数，我们这里不需要，我们只是从 api获取数据
                    data: {
                        username: 'username',
                        password: 'password'
                    },
                    */
                    dataType: 'json', //服务器返回json格式数据
                    type: 'get', //HTTP请求类型
                    timeout: 10000, //超时时间设置为10秒；
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    success: function(data) {
                        //服务器返回响应，根据响应结果，分析是否登录成功；
                        
                        //我们现在控制台打印一下请求结果
                        //console.log(data)
                        
                        //然后获取json数据中的具体值
                        //console.log(data.stories[0].title)
                        
                        //list 对应上面的 id，就是得到 拼接的 html
                        var html = template('list', data);
                        //把得到的 html 放到id为 zhihu 的 ul 标签里
                        document.getElementById(&quot;zhihu&quot;).innerHTML = html;
                        //console.log(html);

                    },
                    error: function(xhr, type, errorThrown) {
                        //异常处理；
                        console.log(type);
                    }
                });

            });
            //网页预加载
            mui.init({
              preloadPages:[{
                id:'info',
                url:'info.html'           
              }
              ]
            });
            
            var detailPage = null;
            //添加列表项的点击事件
            mui('.mui-table-view').on('tap', 'li', function(e) {
              var id = this.getAttribute('id');
              //获得详情页面
              if(!detailPage){
                detailPage = plus.webview.getWebviewById('info');
              }
              //触发详情页面的newsId事件
              mui.fire(detailPage,'id',{
                id:id
              });
            //打开详情页面          
              mui.openWindow({
                id:'info'
              });
            });
        &amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4.拷贝详情页 info.html 代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;

    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&amp;gt;
        &amp;lt;link href=&quot;../css/mui.min.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;
        
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;mui-content&quot;&amp;gt;
            &amp;lt;ul class=&quot;mui-table-view&quot; id=&quot;newsinfo&quot;&amp;gt;&amp;lt;/ul&amp;gt;
&amp;lt;script id=&quot;lists&quot; type=&quot;text/html&quot;&amp;gt;
              {{body}}
            &amp;lt;/script&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;script src=&quot;../js/mui.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

        &amp;lt;!-- 导入 template-web.js
            官网下载：http://aui.github.io/art-template/
            csdn下载：https://download.csdn.net/download/qq_40147863/10689407
        --&amp;gt;
        &amp;lt;script src=&quot;../js/template-web.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;/script&amp;gt;

        &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            mui.init();

            //添加newId自定义事件监听
            window.addEventListener('id', function(event) {
                //获得事件参数
                var id = event.detail.id;
                //根据id向服务器请求新闻详情
                
                
            //plusReady，用来定义加载dom后的操作
            mui.plusReady(function() {
                
                //发起 ajax请求，地址使用知乎日报 api 
                mui.ajax('https://news-at.zhihu.com/api/4/news/'+ id, {
                    /* data 是参数，我们这里不需要，我们只是从 api获取数据
                    data: {
                        username: 'username',
                        password: 'password'
                    },
                    */
                    dataType: 'json', //服务器返回json格式数据
                    type: 'get', //HTTP请求类型
                    timeout: 10000, //超时时间设置为10秒；
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    success: function(data) {
                        //服务器返回响应，根据响应结果，分析是否登录成功；
                        
                        //我们现在控制台打印一下请求结果
                        console.log(&quot;666&quot;);
                        console.log(data);
                        
                        //然后获取json数据中的具体值
                        //console.log(data.stories[0].title)
                        
                        //list 对应上面的 id，就是得到 拼接的 html
                        var html = template('lists', data);
                        //把得到的 html 放到id为 zhihu 的 ul 标签里
                        document.getElementById(&quot;newsinfo&quot;).innerHTML = data.body;
                        //console.log(html);

                    },
                    error: function(xhr, type, errorThrown) {
                        //异常处理；
                        console.log(type);
                    }
                });
            });
            });
                    
        &amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;项目运行&quot;&gt;项目运行&lt;/h3&gt;
&lt;h3 id=&quot;更多文章链接mui-框架&quot;&gt;更多文章链接：&lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/category/8079041&quot;&gt;MUI 框架&lt;/a&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;本笔记不允许任何个人和组织转载&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 27 Sep 2018 14:00:00 +0000</pubDate>
<dc:creator>肖朋伟</dc:creator>
<og:description>MUI框架 10 MUI 数据交互 跳转详情页面 上一篇介绍了如何实现数据交互，给别人的 API 发送 ajax 请求，我们得到数据，再使用 art template 模板引擎拼接 HTML，最终实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xpwi/p/9715921.html</dc:identifier>
</item>
</channel>
</rss>