<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>设计模式之享元模式 - 王若伊_恩赐解脱</title>
<link>http://www.cnblogs.com/jilodream/p/8997059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jilodream/p/8997059.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;享元模式是一种常用的设计模式。尤其是在拥有大数据量的传统后台服务中尤为突出。我们往往在不知不觉中就使用了这个设计模式。&lt;br/&gt;先来看看享元模式的定义：&lt;br/&gt;Flyweight Pattern Flyweight&lt;br/&gt;译为： n. 次最轻量级的拳击选手。 拳击比赛的重量级、轻量级是通过选手的体重来分界的。&lt;br/&gt;享元模式就是通过在程序中“缓存”进而达到“共享”厚重对象，是虚拟机的内存瘦身，减少消耗的设计模式。它可以使一个原本应该很大型的数据服务进程尽可能的瘦下来。这种设计模式相对于其它的模式在理念（思想）上有所差距。这主要体(防盗连接：本文首发自http://www.cnblogs.com/jilodream/ )现在，大部分的设计模式，都是建立在通过对象结构来实现整体架构的低内聚、高耦合。从而使业务在变更和扩展时，软件系统可以很容易的适应。而享元模式的主要目的则是为了减少内存消耗，瘦身程序。这里插句题外话，记得之前看过一本书中说过，如果说计算机世界中新创造了什么划时代的思想的话，那么毫无疑问，就是缓存。&lt;br/&gt;简单点来说，享元模式其实就是对重对进行缓存管理。使得对象只(防盗连接：本文首发自http://www.cnblogs.com/jilodream/ )需要创建一次，各个依赖的地方使用的对象映射到内存中，都是同一块地址的目的。 通过上边对设计模式的描述，经过思考我们可以看出，在这个设计模式中，我们需要用到三个元素：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/704073/201805/704073-20180506030528194-400929267.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面来举一个具体的例子:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;享元工厂&lt;/span&gt;&lt;br/&gt;&lt;span&gt;根据(防盗连接：本文首发自http://www.cnblogs.com/jilodream/ )ID创建、缓存、返回服务器实例&lt;/span&gt;&lt;br/&gt;&lt;span&gt;抽象享元类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;银行服务器：查账、存款、转账、取款&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 具体享元类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;工商银行服务器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;交通银行服务器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;建设银行服务器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码实现：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;享元工厂：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BankServerMgr
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; BankServerMgr()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; BankServerMgr instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BankServerMgr();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; BankServerMgr getInstance()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, IBankServer&amp;gt; bankServerCache = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * 根据ID获取对应的银行服务器实例
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; bankID
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; IBankServer getBankServer(String bankID)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         IBankServer bankServer =&lt;span&gt; bankServerCache.get(bankID);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (bankServer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             bankServer =&lt;span&gt; createBankServerByID(bankID);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            bankServerCache.put(bankID, bankServer);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bankServer;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;     * 根据银行ID创建服务器实例
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; bankID
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; IBankServer createBankServerByID(String bankID)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&quot;ICBC&quot;&lt;span&gt;.equals(bankID))
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ICBCServer();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&quot;BCM&quot;&lt;span&gt;.equals(bankID))
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BCMServer();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&quot;CCB&quot;&lt;span&gt;.equals(bankID))
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CCBServer();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;抽象享元类&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBankServer
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 查询账户信息
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; checkAccount();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * 转账
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; transferAccount(&lt;span&gt;int&lt;/span&gt; money, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; accountID);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * 存钱
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; saveMoney(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; money);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * 取钱
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; drawMoney(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; money);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;具体享元类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ICBCServer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IBankServer
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; checkAccount()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do sth in ICBC&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; transferAccount(&lt;span&gt;int&lt;/span&gt; money, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; accountID)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do sth in ICBC&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; saveMoney(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; money)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do sth in ICBC&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; drawMoney(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; money)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do sth in ICBC&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     
&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BCMServer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IBankServer
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; checkAccount()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do sth in BCM&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; transferAccount(&lt;span&gt;int&lt;/span&gt; money, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; accountID)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do sth in BCM&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; saveMoney(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; money)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do sth in BCM&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; drawMoney(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; money)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do sth in BCM&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CCBServer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IBankServer
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; checkAccount()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do sth in CCB&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; transferAccount(&lt;span&gt;int&lt;/span&gt; money, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; accountID)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do sth in CCB&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; saveMoney(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; money)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do sth in CCB&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; drawMoney(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; money)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do sth in CCB&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     
&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 05 May 2018 19:20:00 +0000</pubDate>
<dc:creator>王若伊_恩赐解脱</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jilodream/p/8997059.html</dc:identifier>
</item>
<item>
<title>不寻常的单例模式 - 凝眸v</title>
<link>http://www.cnblogs.com/zj-blog/p/8996971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zj-blog/p/8996971.html</guid>
<description>&lt;p&gt;                                                                                              &lt;span&gt;&lt;strong&gt;&lt;span&gt;单例模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一.什么是单例模式?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;单例模式是java中最简单的设计模式之一,属于创建型设计模式,这种模式涉及到一个的单一的类,该类负责创建自己的对象,这&lt;/span&gt;&lt;span&gt;个类提供了一种访问其唯一的对象的方式,可以直接访问,不需要实例化该类的对象。(1.单例类只能有一个实例,2.单例类必须自己创建自己唯一实例,2.单例类必须给其它对象提供这个实例)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二.单例模式的应用场景有什么?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   &lt;/strong&gt;&lt;/span&gt; &lt;span&gt;某些对象我们只需要一个实例的,比如:配置文件,工具类,线程池,缓存,日志对象等这些,如果创建的实例过多,就会导致一些问题,比如占用资源,结果不一致的现象等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三.饿汉模式实例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 单例模式Singleton
 * 应用场合:有些对象只需要一个就足够了,比如古代的皇帝
 * 类型:饿汉模式
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.将构造方法私有化,不允许外部直接创建对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){}
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.创建类的唯一实例,使用private static修饰&lt;/span&gt;
     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton instance =&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.提供一个用于获取实例的方法,使用public static修饰&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton getInstance(){
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四.懒汉模式实例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
 * 懒汉模式(线程不安全,安全的话加synchronized)
 */
public class Singleton {
        //1.将构造方法私有化,不允许外部直接创建对象
        private Singleton(){}
        //2.声明类的唯一实例,使用private static修饰
        private static Singleton instance =new Singleton();
        //3.提供一个用于获取实例的方法,使用public static修饰
        public static Singleton getInstance(){
                if(instance==null){
                        return new Singleton() ;
                }
                return instance;
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五.懒汉模式和饿汉模式有什么不同呢?&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   &lt;/strong&gt; &lt;span&gt;饿汉模式的特点是加载类的速度比较慢,但运行是获取对象的速度比较快,而且是线程安全的,懒汉模式的特点是加载类的速度比较快,但运行时获取对象的速度比较慢,而且不是线程安全的.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;六.双重检查锁实例&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
 * 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
 */
public class Singleton {
        private volatile static Singleton instance =new Singleton();
        private Singleton(){}
        public static Singleton getInstance(){
              if(instance==null){
                  synchronized(Singleton.class){
                     if(instance==null){
                           return new Singleton();
                           }
                     }
                }
            return instance;
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;七.登记证/静态内部类&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
 * 这种方式能达到双检锁方式一样的功效,但实现更简单,当 Singleton类被装载了,instance 不一定被初始化。
 * 因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，
 * 才会显式装载 SingletonHolder类从而实例化 instance,比饿汉式合理。
 */
public class Singleton {
        private static class SingletonHolder{
                private static Singleton instance =new Singleton();
        }
        private Singleton(){}
        public static Singleton getInstance(){
                return SingletonHolder.instance;
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;八.枚举&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
 *它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化
 */
public enum Singleton {
        INSTANCE;
        private Object object=new Object();
        private Singleton(){
                object=new Object();
        }
        
        public Object getObject(){
                return object;
        }
}
class SingletonTest{
        public static void main(String[] args){
                Singleton.INSTANCE.getObject();
        }
}
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Sat, 05 May 2018 17:18:00 +0000</pubDate>
<dc:creator>凝眸v</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zj-blog/p/8996971.html</dc:identifier>
</item>
<item>
<title>VueJs(9)---组件（父子通讯） - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/8995572.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/8995572.html</guid>
<description>
&lt;h2&gt;&lt;span&gt;一、概括&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在一个组件内定义另一个组件，称之为父子组件。&lt;/p&gt;
&lt;p&gt;   但是要注意的是：1.子组件只能在父组件内部使用（写在父组件tempalte中）;&lt;/p&gt;
&lt;p&gt;                                2.默认情况下，子组件无法访问父组件上的数据,每个组件实例的作用域是独立的；&lt;/p&gt;
&lt;p&gt;那如何完成父子如何完成通讯，简单一句话：&lt;strong&gt;&lt;span&gt;props down, events up&lt;/span&gt;&lt;/strong&gt; ：父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送&lt;/p&gt;
&lt;p&gt;父传子：&lt;strong&gt;&lt;span&gt;Props&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;子传父：子：&lt;strong&gt;&lt;span&gt;$emit(eventName) 父$on(eventName)&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;父访问子：&lt;span&gt;&lt;strong&gt;ref&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面对三个进行案例讲解：&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、父传子：Props&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;    　组件实例的作用域是孤立的。这意味着不能 (也不应该) 在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，需要通过子组件的 props 选项&lt;/p&gt;
&lt;p&gt;　　使用Prop传递数据包括静态和动态两种形式，下面先介绍静态props&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;1、静态props&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;example&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;要想子组件能够获取父组件的，那么在子组件必须申明:props&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; childNode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
        template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;{{message}}&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        props: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的message要和上面props中值一致&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; parentNode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
        template: `
          &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;child message&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;child&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;child message&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;徐小小&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;child&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;div&amp;gt;`,&lt;/span&gt;
&lt;span&gt;        components: {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: childNode
        }
    };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建根实例&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#example&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        components: {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: parentNode
        }
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201805/1090617-20180506005732919-1228021688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt; 命名约定：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;     对于props声明的属性来说，在父级HTML模板中，属性名需要使用中划线写法&lt;/p&gt;
&lt;p&gt;    子级props属性声明时，使用小驼峰或者中划线写法都可以；而子级模板使用从父级传来的变量时，需要使用对应的小驼峰写法&lt;/p&gt;
&lt;p&gt;上面这句话什么意思呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里需要注意的是props可以写成['my-message']或者['myMessage']都是可以的&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;但是template里的属性名，只能是驼峰式{{myMessage}}，如果也写成{{my-message}}那么是无效的&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; childNode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
        template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;{{myMessage}}&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        props: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myMessage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的属性名为my-message&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; parentNode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
        template: `
          &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;child my&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;child&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;child my&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;徐小小&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;child&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;div&amp;gt;`,&lt;/span&gt;
&lt;span&gt;        components: {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: childNode
        }
    };
   
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       如果我们&lt;span&gt;childNode&lt;/span&gt;中的&lt;span&gt;myMessage&lt;/span&gt;改成&lt;span&gt;{{my-message}}&lt;/span&gt;看运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201805/1090617-20180505185636866-1090977625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2.动态props&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;    在模板中，要动态地绑定父组件的数据到子模板的 &lt;span&gt;props&lt;/span&gt;，与绑定到任何普通的HTML特性相类似，就是用 &lt;strong&gt;&lt;span&gt;&lt;code&gt;v-bind&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;。每当父组件的数据变化时，该变化也会传导给子组件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; var&lt;/span&gt; childNode = {
        template: '&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{myMessage}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;',
        props: ['my-message']
                }

 &lt;span&gt;var&lt;/span&gt; parentNode = {
        template: `
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;parent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;child &lt;/span&gt;&lt;span&gt;:my-message&lt;/span&gt;&lt;span&gt;=&quot;data1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;child &lt;/span&gt;&lt;span&gt;:my-message&lt;/span&gt;&lt;span&gt;=&quot;data2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;`,
        components: {
            'child': childNode
        },
        data() {
            return {
                'data1': '111',
                'data2': '222'
            }
        }
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;3、传递数字&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;初学者常犯的一个错误是使用字面量语法传递数值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;example&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; childNode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
        template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;{{myMessage}}的类型是{{type}}&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        props: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myMessage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
        computed: {
            type() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.myMessage
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; parentNode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
        template: `
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;my&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;child my&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;my-child&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;div&amp;gt;`,&lt;/span&gt;
&lt;span&gt;        components: {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myChild&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: childNode
        }
    };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建根实例&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#example&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        components: {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: parentNode
        }
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201805/1090617-20180505210607666-468446741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     因为它是一个字面 &lt;span&gt;prop&lt;/span&gt;，它的值是字符串 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 而不是 &lt;span&gt;number&lt;/span&gt;。如果想传递一个实际的 number，需要使用&lt;span&gt; &lt;code&gt;v-bind&lt;/code&gt;&lt;/span&gt;，从而让它的值被当作JS表达式计算 &lt;/p&gt;
&lt;p&gt;     如何把String转成number呢，其实只要改一个地方。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;var&lt;/span&gt; parentNode =&lt;span&gt; {
        template: `
  &lt;/span&gt;&amp;lt;div class=&quot;parent&quot;&amp;gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只要把父组件my-message=&quot;1&quot;改成:my-message=&quot;1&quot;结果就变成number类型&lt;/span&gt;
    &amp;lt;my-child :my-message=&quot;1&quot;&amp;gt;&amp;lt;/my-child&amp;gt;
  &amp;lt;/div&amp;gt;`,
&lt;span&gt;     
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     当然你如果想通过&lt;span&gt;v-bind&lt;/span&gt;想传一个&lt;span&gt;string&lt;/span&gt;类型，那该怎么做呢？ &lt;/p&gt;
&lt;p&gt;    我们可以使用动态&lt;span&gt;props&lt;/span&gt;，在data属性中设置对应的数字1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;var&lt;/span&gt; parentNode =&lt;span&gt; {
  template: `
  &lt;/span&gt;&amp;lt;div class=&quot;parent&quot;&amp;gt;
    &amp;lt;my-child :my-message=&quot;data&quot;&amp;gt;&amp;lt;/my-child&amp;gt;
  &amp;lt;/div&amp;gt;`,
&lt;span&gt;  components: {
    &lt;/span&gt;'myChild'&lt;span&gt;: childNode
  },
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里'data': 1代表就是number类型，'data': &quot;1&quot;那就代表String类型&lt;/span&gt;
&lt;span&gt;  data(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;'data': 1&lt;span&gt;
    }
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;三、子转父 ：&lt;strong&gt;$emit&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 关于$emit的用法&lt;/p&gt;
&lt;p&gt;   1、父组件可以使用 props 把数据传给子组件。&lt;br/&gt;   2、子组件可以使用 $emit 触发父组件的自定义事件。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子主键&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;  
  &amp;lt;div class=&quot;train-city&quot;&amp;gt;  
    &amp;lt;span @click='select(`大连`)'&amp;gt;大连&amp;lt;/span&amp;gt;  
  &amp;lt;/div&amp;gt;  
&amp;lt;/template&amp;gt;  
&amp;lt;script&amp;gt;&lt;span&gt;  
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {  
  name:&lt;/span&gt;'trainCity'&lt;span&gt;,  
  methods:{  
    select(val) {  
      let data &lt;/span&gt;=&lt;span&gt; {  
        cityname: val  
      };  
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$emit('showCityName',data);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;select事件触发后，自动触发showCityName事件  &lt;/span&gt;
&lt;span&gt;    }  
  }  
}  
&lt;/span&gt;&amp;lt;/script&amp;gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;父组件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;  
    &amp;lt;trainCity @showCityName=&quot;updateCity&quot; :index=&quot;goOrtoCity&quot;&amp;gt;&amp;lt;/trainCity&amp;gt; //监听子组件的showCityName事件。  
&amp;lt;template&amp;gt;  
&amp;lt;script&amp;gt;&lt;span&gt;  
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {  
  name:&lt;/span&gt;'index'&lt;span&gt;,  
  data () {  
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {  
      toCity:&lt;/span&gt;&quot;北京&quot;&lt;span&gt;  
    }  
  }  
  methods:{  
    updateCity(data){&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;触发子组件城市选择-选择城市的事件    &lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;.toCity = data.cityname;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;改变了父组件的值  &lt;/span&gt;
      console.log('toCity:'+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.toCity)        
    }  
  }  
}  
&lt;/span&gt;&amp;lt;/script&amp;gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;结果为&lt;/strong&gt;&lt;/span&gt;：toCity: 大连&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二个案例&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;counter-event-example&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ total }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button-counter &lt;/span&gt;&lt;span&gt;v-on:increment1&lt;/span&gt;&lt;span&gt;=&quot;incrementTotal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button-counter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button-counter &lt;/span&gt;&lt;span&gt;v-on:increment2&lt;/span&gt;&lt;span&gt;=&quot;incrementTotal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button-counter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;button-counter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
        template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;button v-on:click=&quot;increment&quot;&amp;gt;{{ counter }}&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组件数据就是需要函数式，这样的目的就是让每个button-counter不共享一个counter&lt;/span&gt;
&lt;span&gt;        data: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                counter: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
            } 
        },
        methods: {
            increment: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {&lt;br/&gt;&lt;span&gt;  //这里+1只对button的值加1，如果要父组件加一，那么就需要$emit事件
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.counter &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$emit(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;increment1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, [&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kkk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);
            }
        }
    });
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#counter-event-example&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data: {
            total: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        },
        methods: {
            incrementTotal: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.total &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                console.log(e);
            }
        }
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;详细讲解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   1：&lt;span&gt;button-counter&lt;/span&gt;作为父主键，父主键里有个&lt;span&gt;button&lt;/span&gt;按钮。&lt;/p&gt;
&lt;p&gt;   2:两个button都绑定了click事件，方法里：&lt;span&gt; this.$emit('increment1', [12, 'kkk']);&lt;/span&gt;，那么就会去调用父类&lt;span&gt;v-on所监听的increment1&lt;/span&gt;事件。&lt;/p&gt;
&lt;p&gt;   3：当&lt;span&gt;increment1&lt;/span&gt;事件被监听到，那么执行&lt;span&gt;incrementTotal&lt;/span&gt;，这个时候才会把值传到父组件中，并且调用父类的方法。&lt;/p&gt;
&lt;p&gt;   4：这里要注意第二个&lt;span&gt;button-counter&lt;/span&gt;所对应的&lt;span&gt;v-on:'increment2,&lt;/span&gt;而它里面的button所对应是&lt;span&gt;this.$emit('increment1', [12, 'kkk']);&lt;/span&gt;所以第二个button按钮是无法把值传给他的父主键的。&lt;/p&gt;
&lt;p&gt; &lt;span&gt;示例&lt;/span&gt;：一个按钮点击一次那么它自身和上面都会自增1，而第二个按钮只会自己自增，并不影响上面这个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201805/1090617-20180506002835650-156390702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有就是第一个按钮每点击一次，后台就会打印一次如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201805/1090617-20180506003044920-1434563910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt; 四、ref ($refs)用法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;ref 有三种用法&lt;/p&gt;
&lt;p&gt;    1.ref 加在普通的元素上，用&lt;span&gt;this.ref.name&lt;/span&gt; 获取到的是dom元素&lt;/p&gt;
&lt;p&gt;    2.ref 加在子组件上，用&lt;span&gt;this.ref.name&lt;/span&gt; 获取到的是组件实例，可以使用组件的所有方法。&lt;/p&gt;
&lt;p&gt;    3.如何利用&lt;span&gt;v-for&lt;/span&gt; 和&lt;span&gt;ref&lt;/span&gt; 获取一组数组或者dom 节点&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;1.ref 加在普通的元素上，用this.ref.name 获取到的是dom元素&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;ref-outside-component&quot;&lt;/span&gt;&lt;span&gt; v-on:click&lt;/span&gt;&lt;span&gt;=&quot;consoleRef&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;component-father &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;outsideComponentRef&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;component-father&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ref在外面的组件上&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; refoutsidecomponentTem &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
        template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;div class='childComp'&amp;gt;&amp;lt;h5&amp;gt;我是子组件&amp;lt;/h5&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; refoutsidecomponent &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ref-outside-component&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        components: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;component-father&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: refoutsidecomponentTem
        },
        methods: {
            consoleRef: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; #ref-outside-component     vue实例&lt;/span&gt;
&lt;span&gt;                console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.outsideComponentRef); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; div.childComp vue实例&lt;/span&gt;
&lt;span&gt;            }
        }
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;效果&lt;/span&gt;：当在div访问内点击一次：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201805/1090617-20180506004137272-1400719174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2.ref使用在外面的元素上&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;ref在外面的元素上&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;ref-outside-dom&quot;&lt;/span&gt;&lt;span&gt; v-on:click&lt;/span&gt;&lt;span&gt;=&quot;consoleRef&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;component-father&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;component-father&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;outsideDomRef&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ref在外面的元素上&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; refoutsidedomTem &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
        template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;div class='childComp'&amp;gt;&amp;lt;h5&amp;gt;我是子组件&amp;lt;/h5&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; refoutsidedom &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ref-outside-dom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        components: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;component-father&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: refoutsidedomTem
        },
        methods: {
            consoleRef: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; #ref-outside-dom    vue实例&lt;/span&gt;
&lt;span&gt;                console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.outsideDomRef); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   &amp;lt;p&amp;gt; ref在外面的元素上&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span&gt;            }
        }
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;效果&lt;/span&gt;：当在div访问内点击一次：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201805/1090617-20180506004420804-853743606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3.ref使用在里面的元素上---局部注册组件&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;ref在里面的元素上&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;ref-inside-dom&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;component-father&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;component-father&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ref在里面的元素上&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; refinsidedomTem &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
        template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;div class='childComp' v-on:click='consoleRef'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;
            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;h5 ref='insideDomRef'&amp;gt;我是子组件&amp;lt;/h5&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;
            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        methods: {
            consoleRef: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; div.childComp   vue实例 &lt;/span&gt;
&lt;span&gt;                console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.insideDomRef); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;h5 &amp;gt;我是子组件&amp;lt;/h5&amp;gt;&lt;/span&gt;
&lt;span&gt;            }
        }
    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; refinsidedom &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ref-inside-dom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        components: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;component-father&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: refinsidedomTem
        }
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;span&gt;效果&lt;/span&gt;：当在click范围内点击一次：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201805/1090617-20180506004659516-819905510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;4.ref使用在里面的元素上---全局注册组件&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;ref在里面的元素上--全局注册&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;ref-inside-dom-all&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref-inside-dom-quanjv&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ref-inside-dom-quanjv&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;v-on:input指当input里值发生改变触发showinsideDomRef事件&lt;/span&gt;
&lt;span&gt;    Vue.component(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ref-inside-dom-quanjv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {
        template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;div class='insideFather'&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;
            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;input type='text' ref='insideDomRefAll' v-on:input='showinsideDomRef'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;
            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  &amp;lt;p&amp;gt;ref在里面的元素上--全局注册 &amp;lt;/p&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;
            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        methods: {
            showinsideDomRef: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的this其实还是div.insideFather&lt;/span&gt;
&lt;span&gt;                console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.insideDomRefAll); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;input  type=&quot;text&quot;&amp;gt;&lt;/span&gt;
&lt;span&gt;            }
        }
    });

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; refinsidedomall &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ref-inside-dom-all&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;效果：&lt;/span&gt;当我第一次输入1时，值已改变出发事件，当我第二次在输入时在触发一次事件，所以后台应该打印两次&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201805/1090617-20180506005341357-1677957134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 想太多，做太少，中间的落差就是烦恼。想没有烦恼，要么别想，要么多做。中尉【18】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 05 May 2018 17:01:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/8995572.html</dc:identifier>
</item>
<item>
<title>入职第二天：使用koa搭建node server是种怎样的体验 - 闰土大叔</title>
<link>http://www.cnblogs.com/running-runtu/p/8996932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/8996932.html</guid>
<description>&lt;p&gt;今天是我入职第二天，leader跟我说，昨天配置好了服务端渲染的文件，今天就先研究研究如何使用koa来搭建一个node server吧！&lt;/p&gt;
&lt;p&gt;按照惯例，我去koa官网查了一下什么是koa，结果官网很简单的一句话介绍：&lt;strong&gt;koa--基于node.js平台的下一代web开发框架。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人感觉koa官方文档对于前端小白来说，写的不是很友好，建议上手之前先看看阮一峰的koa框架教程和廖雪峰写的关于koa入门文章。&lt;/p&gt;
&lt;p&gt;然后引入项目第一步，安装koa：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm i koa -S
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完之后，首先在项目根目录下新建一个server文件夹，然后在此文件夹下新建一个server.js文件，然后在里面引入koa：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; Koa = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;koa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Koa()
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; isDev = process.env.NODE_ENV === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;development&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里为什么要声明isDev呢？因为服务端渲染是分开发环境和生产环境两种不同的情况。&lt;/p&gt;
&lt;p&gt;然后我们继续在server.js里面先写一个中间件来记录所有的请求和抓取的错误，这样可以很好的了解到在服务端渲染的过程中是否出现了一些错误，并及时排查掉错误。&lt;/p&gt;
&lt;p&gt;先撸为敬：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
app.use(&lt;span&gt;async&lt;/span&gt; (ctx, next) =&amp;gt;&lt;span&gt; {
 &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
   console.log(`request with path ${ctx.path}`)
   &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next()
 } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (err) {
   console.log(err)
   ctx.status &lt;/span&gt;= &lt;span&gt;500&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDev) {
     ctx.body &lt;/span&gt;=&lt;span&gt; err.message
   } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
     ctx.body &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;please try again later&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
   }
 }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单解释一下：在函数前面加一个async，就代表异步处理函数，而参数next表示执行下一个 异步处理的函数。在try循环体内，console打印出请求的路径。如果是isDev为true的情况，可以直接将错误信息写到body里面，这样就可以在页面上直接看到错误信息。如果不是开发环境，可以写一个友善的提醒文字，例如：“please try again later”。&lt;/p&gt;
&lt;p&gt;这就是最简单的一个koa中间件，用来记录所有的请求及出现的错误，并且返回一个错误信息。&lt;/p&gt;
&lt;p&gt;接下来，聊一聊如何处理服务端渲染。&lt;/p&gt;
&lt;p&gt;在处理服务端渲染之前，首先要在terminal里面安装一下koa-router：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm i koa-router -S
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是koa提供的一个路由的工具。然后在server文件夹下面新建一个routers文件夹，紧接着在里面新建两个文件，一个是dev-ssr.js，另一个是ssr.js。前者是处理开发时服务端渲染的情况，后者是处理正式环境下的情况。&lt;/p&gt;
&lt;p&gt;在dev-ssr.js文件中，首先要引入koa-router：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; Router = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;koa-router&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，还需要使用到两个工具，需要安装下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm i axios -&lt;span&gt;S
npm i memory&lt;/span&gt;-fs -D
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在node端发送请求的axios，当然也可以在浏览器端发送请求。在安装的时候记住后面跟的是-S，因为在业务代码中可以用到。&lt;/p&gt;
&lt;p&gt;而memory-fs只有在开发的时候才会用到，所以后面跟的是-D。可能有童鞋要问了，这个memory-fs是用来干嘛的？别急，闰土给大家截一张官网图片看看便一目了然了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201805/701424-20180506004636633-566864811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大意是：一个简单的内存文件系统。将数据保存在JavaScript对象中。&lt;/p&gt;
&lt;p&gt;然后，话不多说，先把这两个工具引入进来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; axios = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;axios&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; MemoryFS = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;memory-fs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;紧接着，再来引入两个工具：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; webpack = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;webpack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; VueServerRenderer = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vue-server-renderer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为要在node开发环境中打包代码，并且需要服务端渲染。&lt;/p&gt;
&lt;p&gt;接下来，要引入serverConfig，就是入职第一天写的那个配置文件webpack.config.server.js：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; serverConfig = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../../build/webpack.config.server&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，如何能在node开发环境中让webpack跑起来呢？&lt;/p&gt;
&lt;p&gt;答案是通过serverCompiler:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; serverCompiler = webpack(serverConfig)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后去new一个mfs实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; mfs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryFS()
serverCompiler.outputFileSystem &lt;/span&gt;= mfs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就指定了webpack的输出目录在MemoryFS里面。&lt;/p&gt;
&lt;p&gt;有了这些配置之后，再去声明一个bundle：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
let bundle
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用来记录webpack每次打包生成的新的文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
serverCompiler.watch({}, (err, stats) =&amp;gt;&lt;span&gt; {
 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err) &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err
 stats &lt;/span&gt;=&lt;span&gt; stats.toJson()
 stats.erros.forEach(err &lt;/span&gt;=&amp;gt;&lt;span&gt; console.log(err))
 stats.hasWarnings.forEach(warn &lt;/span&gt;=&amp;gt;&lt;span&gt; console.warn(err))

 &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; bundlePath =&lt;span&gt; path.join(
   serverConfig.output.path,
   &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vue-ssr-server-bundle.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
 )
 bundle &lt;/span&gt;= JSON.parse(mfs.readFileSync(bundlePath, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用watch()的好处是：跟使用webpack-dev-server一样，在client目录下每次修改一个文件，它都会重新执行一次打包，然后就可以拿到新的文件了。&lt;/p&gt;
&lt;p&gt;serverCompiler.watch()的第一个参数是空对象，第二个参数是一个回调。如果有err直接抛出。&lt;/p&gt;
&lt;p&gt;然后stats这块我感觉有点晦涩难懂，leader告诉我说，先照着做，然后有空再去看webpack的文档。&lt;/p&gt;
&lt;p&gt;接下来就可以读取生成的bundle文件了，拼接读取文件的路径，设置文件名字，并且制定编码为utf-8，最后通过JSON.parse()将字符串转成JSON。&lt;/p&gt;
&lt;p&gt;执行完以上步骤之后，就可以将内容返回给HTML了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201805/701424-20180506004619894-1989876019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在服务端渲染期间，使用ejs模板引擎生成HTML。通过VueServerRenderer的createBundleRenderer()方法帮助生成一个可以直接调用renderer的函数。在这里面接收几个参数，第一个是inject，设置为false，这样它就不会执行其他的注入的操作了。第二个是clientManifest，它会自动生成一个带有script标签的js文件引用的字符串，这样可以直接添加到ejs的内容里面。&lt;/p&gt;
&lt;p&gt;最后，dev-ssr.js的完整代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; Router = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;koa-router&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; axios = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;axios&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; path = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; fs = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; MemoryFS = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;memory-fs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; webpack = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;webpack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; VueServerRenderer = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vue-server-renderer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; serverConfig = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../../build/webpack.config.server&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; serverCompiler =&lt;span&gt; webpack(serverConfig)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; mfs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryFS()
serverCompiler.outputFileSystem &lt;/span&gt;=&lt;span&gt; mfs

let bundle
serverCompiler.watch({}, (err, stats) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err) &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err
 stats &lt;/span&gt;=&lt;span&gt; stats.toJson()
 stats.erros.forEach(err &lt;/span&gt;=&amp;gt;&lt;span&gt; console.log(err))
 stats.hasWarnings.forEach(warn &lt;/span&gt;=&amp;gt;&lt;span&gt; console.warn(err))

 &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; bundlePath =&lt;span&gt; path.join(
   serverConfig.output.path,
   &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vue-ssr-server-bundle.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
 )
 bundle &lt;/span&gt;= JSON.parse(mfs.readFileSync(bundlePath, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
})

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; handleSSR = &lt;span&gt;async&lt;/span&gt; (ctx) =&amp;gt;&lt;span&gt; {
 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (bundle) {
   ctx.body &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wait a moment...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
 }

 &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; clientManifestResp = &lt;span&gt;await&lt;/span&gt; axios.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(
   &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://127.0.0.1:8080/vue-ssr-client-manifest.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
 )

 &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; clientManifest =&lt;span&gt; clientManifestResp.data

 &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; template =&lt;span&gt; fs.readFileSync(
   path.join(__dirname, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../server.template.ejs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
 )

 &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; renderer =&lt;span&gt; VueServerRenderer
   .createBundleRenderer(bundle, {
     inject: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
     clientManifest
   })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;hljs typescript&quot;&gt;
&lt;span&gt;&lt;strong&gt;写在最后&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;这次使用koa搭建node server的体验只是聊到了renderer这一步，后面我会继续聊聊如何把bundle渲染成实际的HTML内容，并把它添加到template里面。最新的文章都会第一时间更新在我的公众号&amp;lt;&lt;strong&gt;闰土大叔&lt;/strong&gt;&amp;gt;里面，欢迎关注。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201805/701424-20180506004605494-54805707.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 05 May 2018 16:48:00 +0000</pubDate>
<dc:creator>闰土大叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/8996932.html</dc:identifier>
</item>
<item>
<title>Qt与FFmpeg联合开发指南（三）——编码（1）：代码流程演示 - 冷豪</title>
<link>http://www.cnblogs.com/learnhow/p/8996898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learnhow/p/8996898.html</guid>
<description>&lt;p&gt;前两讲演示了基本的解码流程和简单功能封装，今天我们开始学习编码。编码就是封装音视频流的过程，在整个编码教程中，我会首先在一个函数中演示完成的编码流程，再解释其中存在的问题。下一讲我们会将编码功能进行封装并解释针对不同的输出环境代码上需要注意的地方。最后我们还会把之前做好的解码器添加进开发环境，实现PC屏幕和摄像头录制然后再通过播放器播放。&lt;/p&gt;
&lt;p&gt;首先说明一下本章的目标：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过Qt进行视频采集&lt;/li&gt;
&lt;li&gt;通过Qt进行音频采集&lt;/li&gt;
&lt;li&gt;对音视频编码成mp4文件并能够通过vlc播放&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一、通过Qt进行视频采集&lt;/p&gt;
&lt;p&gt;Qt提供了对桌面录屏的支持，我们可以很轻松的完成开发&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先获取到完整桌面的窗口句柄已经宽高信息&lt;/span&gt;
WId wid = QApplication::desktop()-&amp;gt;&lt;span&gt;winId();
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; width = QApplication::desktop()-&amp;gt;&lt;span&gt;width();
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; height = QApplication::desktop()-&amp;gt;&lt;span&gt;height();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 截屏获得图片&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; QScreen *screen =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;screen) {
    screen &lt;/span&gt;=&lt;span&gt; QGuiApplication::primaryScreen();
}
QPixmap pix &lt;/span&gt;= screen-&amp;gt;&lt;span&gt;grabWindow(wid);
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; uchar *rgb = pix.toImage().bits();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有一点需要特别注意，当我们把上面的代码封装进函数以后，我们无法直接通过返回值获取到rgb数据。这个地方曾经卡了我好几天，原因在于经过grabWindow(wid)函数获取到的QPixmap对象是属于函数的局部变量，在函数结束以后这个该变量包括bits()包含的数据都会被清理掉。所以如果我们想在函数外部继续使用图片数据就必须对QImage进行一次深拷贝。我提供两条思路，一是直接将QImage对象进行深拷贝，然后使用它的bits()数据。但是这样的话如果我们只在外部析构bits()中的数据其实对内存的清理工作并不完整。另一个方法是我们直接对bits()里的数据进行拷贝，但是由于QImage对图片的保存数据并非是连续的寻址空间所以我们需要做一次转换。为了方便起见我们先按照第一种思路设计。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; uchar*&lt;span&gt; VideoAcquisition::getRGB()
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; QScreen *screen =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;screen) {
        screen &lt;/span&gt;=&lt;span&gt; QGuiApplication::primaryScreen();
    }
        WId wid &lt;/span&gt;= QApplication::desktop()-&amp;gt;&lt;span&gt;winId();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; width = QApplication::desktop()-&amp;gt;&lt;span&gt;width();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; height = QApplication::desktop()-&amp;gt;&lt;span&gt;height();

    QPixmap pix &lt;/span&gt;= screen-&amp;gt;&lt;span&gt;grabWindow(wid);
    QImage &lt;/span&gt;*image = &lt;span&gt;new&lt;/span&gt; QImage(pix.toImage().copy(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, width, height));

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; image-&amp;gt;&lt;span&gt;bits();
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、通过Qt进行音频采集&lt;/p&gt;
&lt;p&gt;与视频采集的图片不同，音频数据对应的是一段时间的录音。虽然Qt也提供了统一的音频录制接口，不过我们首先需要对录音设备进行初始化。主要是设置录音的参数和控制每次从音频缓存中读取的数据大小。这里我们以CD音质为标准，即采样率：44100Hz，通道数：2，采样位数：16bit，编码格式：audio/pcm。&lt;/p&gt;
&lt;p&gt;首先初始化一个录音设备：QIODevice&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;QAudioFormat fmt;
fmt.setSampleRate(&lt;/span&gt;&lt;span&gt;44100&lt;/span&gt;&lt;span&gt;);
fmt.setChannelCount(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
fmt.setSampleSize(&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 采样大小 = 采样位数 * 8&lt;/span&gt;
&lt;span&gt;fmt.setSampleType(QAudioFormat::UnSignedInt);
fmt.setByteOrder(QAudioFormat::LittleEndian);
fmt.setCodec(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;audio/pcm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
QAudioInput &lt;/span&gt;*audioInput = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QAudioInput(fmt);
QIODevice &lt;/span&gt;*device = audioInput-&amp;gt;start();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设我们每次从音频缓存中读取1024个采样点的数据，已知采样的其它条件为双通道和每个采样点两位。则我们用于保存数据的数组大小为：char *pcm = new char[1024 * 2 * 2]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; AudioAcquisition::getPCM()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; readOnceSize = &lt;span&gt;1024&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次从音频设备中读取的数据大小&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; offset = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前已经读到的数据大小，作为pcm的偏移量&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; pcmSize = &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *pcm = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt;[pcmSize];
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (audioInput) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; remains = pcmSize - offset; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 剩余空间&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; ready = audioInput-&amp;gt;bytesReady(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 音频采集设备目前已经准备好的数据大小&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (ready &amp;lt; readOnceSize) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前音频设备中的数据不足&lt;/span&gt;
            QThread::msleep(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (remains &amp;lt; readOnceSize) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当帧存储（pcmSize）的剩余空间（remainSize）小于单次读取数据预设（readSizeOnce）时&lt;/span&gt;
            device-&amp;gt;read(pcm + offset, remains); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从设备中读取剩余空间大小的数据
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读满一帧数据退出&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len = device-&amp;gt;read(pcm +&lt;span&gt; offset, readOnceSize);
        offset &lt;/span&gt;+=&lt;span&gt; len;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pcm;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完成了音视频采集工作以后，接下来是本章的重点——编码——也就是调用FFmpeg库的过程。&lt;/p&gt;
&lt;p&gt;三、对音视频编码成mp4文件&lt;/p&gt;
&lt;p&gt;（1）初始化FFmpeg&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;av_register_all();
avcodec_register_all();
avformat_network_init();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （2）设置三个参数分别用于保存错误代码、错误信息和输出文件路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; errnum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; errbuf[&lt;span&gt;1024&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *filename = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/test.mp4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 视频采集对象&lt;/span&gt;
VideoAcquisition *va = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VideoAcquisition();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 音频采集对象&lt;/span&gt;
AudioAcquisition *aa = &lt;span&gt;new&lt;/span&gt; AudioAcquisition();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （3）创建输出的包装器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
AVFormatContext *pFormatCtx =&lt;span&gt; NULL;
errnum &lt;/span&gt;= avformat_alloc_output_context2(&amp;amp;&lt;span&gt;pFormatCtx, NULL, NULL, filename);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    av_strerror(errnum, errbuf, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(errbuf));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）创建这对h264的编码器和编码器上下文，并向编码器上下文中配置参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; h264视频编码器&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; AVCodec *vcodec =&lt;span&gt; avcodec_find_encoder(AVCodecID::AV_CODEC_ID_H264);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;vcodec) {
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avcodec_find_encoder failed!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建编码器上下文&lt;/span&gt;
AVCodecContext *pVideoCodecCtx =&lt;span&gt; avcodec_alloc_context3(vcodec);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pVideoCodecCtx) {
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avcodec_alloc_context3 failed!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比特率、宽度、高度&lt;/span&gt;
pVideoCodecCtx-&amp;gt;bit_rate = &lt;span&gt;4000000&lt;/span&gt;&lt;span&gt;;
pVideoCodecCtx&lt;/span&gt;-&amp;gt;width = va-&amp;gt;getWidth(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 视频宽度&lt;/span&gt;
pVideoCodecCtx-&amp;gt;height = va-&amp;gt;getHeight(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 视频高度
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 时间基数、帧率&lt;/span&gt;
pVideoCodecCtx-&amp;gt;time_base = { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;&lt;span&gt; };
pVideoCodecCtx&lt;/span&gt;-&amp;gt;framerate = { &lt;span&gt;25&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关键帧间隔&lt;/span&gt;
pVideoCodecCtx-&amp;gt;gop_size = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不使用b帧&lt;/span&gt;
pVideoCodecCtx-&amp;gt;max_b_frames = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 帧、编码格式&lt;/span&gt;
pVideoCodecCtx-&amp;gt;pix_fmt =&lt;span&gt; AVPixelFormat::AV_PIX_FMT_YUV420P;
pVideoCodecCtx&lt;/span&gt;-&amp;gt;codec_id =&lt;span&gt; AVCodecID::AV_CODEC_ID_H264;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 预设：快速&lt;/span&gt;
av_opt_set(pVideoCodecCtx-&amp;gt;priv_data, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;preset&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;superfast&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 全局头&lt;/span&gt;
pVideoCodecCtx-&amp;gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （5）开启编码器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
errnum =&lt;span&gt; avcodec_open2(pVideoCodecCtx, vcodec, NULL);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avcodec_open2 failed!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （6）为封装器创建视频流&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为封装器创建视频流&lt;/span&gt;
AVStream *pVideoStream =&lt;span&gt; avformat_new_stream(pFormatCtx, NULL);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pVideoStream) {
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avformat_new_stream video stream failed!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;&lt;/span&gt;&lt;span&gt;
}
pVideoStream&lt;/span&gt;-&amp;gt;codec-&amp;gt;codec_tag = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
pVideoStream&lt;/span&gt;-&amp;gt;codecpar-&amp;gt;codec_tag = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置视频流的编码参数&lt;/span&gt;
avcodec_parameters_from_context(pVideoStream-&amp;gt;codecpar, pVideoCodecCtx);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （7）创建从RGB格式到YUV420格式的转码器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
SwsContext *pSwsCtx =&lt;span&gt; sws_getContext(
    va&lt;/span&gt;-&amp;gt;getWidth(), va-&amp;gt;getHeight(), AVPixelFormat::AV_PIX_FMT_BGRA, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入&lt;/span&gt;
    va-&amp;gt;getWidth(), va-&amp;gt;getHeight(), AVPixelFormat::AV_PIX_FMT_YUV420P, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出&lt;/span&gt;
    SWS_BICUBIC, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 算法&lt;/span&gt;
    &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pSwsCtx) {
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sws_getContext failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （8）初始化一个视频帧的对象并分配空间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编码阶段的视频帧结构&lt;/span&gt;
AVFrame *vframe =&lt;span&gt; av_frame_alloc();
vframe&lt;/span&gt;-&amp;gt;format =&lt;span&gt; AVPixelFormat::AV_PIX_FMT_YUV420P;
vframe&lt;/span&gt;-&amp;gt;width = va-&amp;gt;&lt;span&gt;getWidth();
vframe&lt;/span&gt;-&amp;gt;height = va-&amp;gt;&lt;span&gt;getHeight();
vframe&lt;/span&gt;-&amp;gt;pts = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为视频帧分配空间&lt;/span&gt;
errnum = av_frame_get_buffer(vframe, &lt;span&gt;32&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;av_frame_get_buffer failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 以上8个步骤是对视频部分的代码演示，下面是音频部分。基本的操作过程和视频一致。&lt;/p&gt;
&lt;p&gt;（9）创建aac的音频编码器和编码器上下文&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建音频编码器，指定类型为AAC&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; AVCodec *acodec =&lt;span&gt; avcodec_find_encoder(AVCodecID::AV_CODEC_ID_AAC);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;acodec) {
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avcodec_find_encoder failed!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据编码器创建编码器上下文&lt;/span&gt;
AVCodecContext *pAudioCodecCtx =&lt;span&gt; avcodec_alloc_context3(acodec);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pAudioCodecCtx) {
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avcodec_alloc_context3 failed!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比特率、采样率、采样类型、音频通道、文件格式&lt;/span&gt;
pAudioCodecCtx-&amp;gt;bit_rate = &lt;span&gt;64000&lt;/span&gt;&lt;span&gt;;
pAudioCodecCtx&lt;/span&gt;-&amp;gt;sample_rate = &lt;span&gt;44100&lt;/span&gt;&lt;span&gt;;
pAudioCodecCtx&lt;/span&gt;-&amp;gt;sample_fmt =&lt;span&gt; AVSampleFormat::AV_SAMPLE_FMT_FLTP;
pAudioCodecCtx&lt;/span&gt;-&amp;gt;channels = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
pAudioCodecCtx&lt;/span&gt;-&amp;gt;channel_layout = av_get_default_channel_layout(&lt;span&gt;2&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据音频通道数自动选择输出类型（默认为立体声）&lt;/span&gt;
pAudioCodecCtx-&amp;gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （10）开启编码器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开编码器&lt;/span&gt;
errnum =&lt;span&gt; avcodec_open2(pAudioCodecCtx, acodec, NULL);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    avcodec_free_context(&lt;/span&gt;&amp;amp;&lt;span&gt;pAudioCodecCtx);
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avcodec_open2 failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （11）向封装器添加音频流&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加音频流&lt;/span&gt;
AVStream *pAudioStream =&lt;span&gt; avformat_new_stream(pFormatCtx, NULL);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pAudioStream) {
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avformat_new_stream failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
pAudioStream&lt;/span&gt;-&amp;gt;codec-&amp;gt;codec_tag = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
pAudioStream&lt;/span&gt;-&amp;gt;codecpar-&amp;gt;codec_tag = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置音频流的编码器参数&lt;/span&gt;
avcodec_parameters_from_context(pAudioStream-&amp;gt;codecpar, pAudioCodecCtx);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （12）创建从FLTP到S16的音频重采样上下文&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
SwrContext *swrCtx =&lt;span&gt; NULL;
swrCtx &lt;/span&gt;=&lt;span&gt; swr_alloc_set_opts(swrCtx,
    av_get_default_channel_layout(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;), AVSampleFormat::AV_SAMPLE_FMT_FLTP, &lt;span&gt;44100&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出&lt;/span&gt;
    av_get_default_channel_layout(&lt;span&gt;2&lt;/span&gt;), AVSampleFormat::AV_SAMPLE_FMT_S16, &lt;span&gt;44100&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入&lt;/span&gt;
    &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
errnum &lt;/span&gt;=&lt;span&gt; swr_init(swrCtx);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;swr_init failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （13）初始化音频帧的结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建音频帧&lt;/span&gt;
AVFrame *aframe =&lt;span&gt; av_frame_alloc();
aframe&lt;/span&gt;-&amp;gt;format =&lt;span&gt; AVSampleFormat::AV_SAMPLE_FMT_FLTP;
aframe&lt;/span&gt;-&amp;gt;channels = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
aframe&lt;/span&gt;-&amp;gt;channel_layout = av_get_default_channel_layout(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
aframe&lt;/span&gt;-&amp;gt;nb_samples = &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为音频帧分配空间&lt;/span&gt;
errnum = av_frame_get_buffer(aframe, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;av_frame_get_buffer failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 音频部分的代码演示完成。下面是开启输出流，并循环进行音视频采集编码。&lt;/p&gt;
&lt;p&gt;（14）打开输出的IO&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开输出流IO&lt;/span&gt;
errnum = avio_open(&amp;amp;pFormatCtx-&amp;gt;pb, filename, AVIO_FLAG_WRITE); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开AVIO流&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    avio_close(pFormatCtx&lt;/span&gt;-&amp;gt;&lt;span&gt;pb);
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avio_open failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （15）写头文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写文件头&lt;/span&gt;
errnum =&lt;span&gt; avformat_write_header(pFormatCtx, NULL);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avformat_write_header failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （16）编码并将数据写入文件，由于我们还没有设计出控制功能，暂且只编码200帧视频帧。按25帧/秒计算，应该生成长度为8秒视频文件。可由于缓存的缘故，最后往往会丢几帧数据。因此实际长度不足8秒。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; vpts = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; apts = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (vpts &amp;lt; &lt;span&gt;200&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 视频编码&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; uchar *rgb = va-&amp;gt;&lt;span&gt;getRGB();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 固定写法：配置1帧原始视频画面的数据结构通常为RGBA的形式&lt;/span&gt;
    uint8_t *srcSlice[AV_NUM_DATA_POINTERS] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
    srcSlice[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = (uint8_t *&lt;span&gt;)rgb;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; srcStride[AV_NUM_DATA_POINTERS] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
    srcStride[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = va-&amp;gt;getWidth() * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转换&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; h = sws_scale(pSwsCtx, srcSlice, srcStride, &lt;span&gt;0&lt;/span&gt;, va-&amp;gt;getHeight(), vframe-&amp;gt;data, vframe-&amp;gt;&lt;span&gt;linesize);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sws_scale failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pts递增&lt;/span&gt;
    vframe-&amp;gt;pts = vpts++&lt;span&gt;;
    errnum &lt;/span&gt;=&lt;span&gt; avcodec_send_frame(pVideoCodecCtx, vframe);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avcodec_send_frame failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 视频编码报文&lt;/span&gt;
    AVPacket *vpkt =&lt;span&gt; av_packet_alloc();

    errnum &lt;/span&gt;=&lt;span&gt; avcodec_receive_packet(pVideoCodecCtx, vpkt);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt; || vpkt-&amp;gt;size &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        av_packet_free(&lt;/span&gt;&amp;amp;&lt;span&gt;vpkt);
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avcodec_receive_packet failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转换pts&lt;/span&gt;
    av_packet_rescale_ts(vpkt, pVideoCodecCtx-&amp;gt;time_base, pVideoStream-&amp;gt;&lt;span&gt;time_base);
    vpkt&lt;/span&gt;-&amp;gt;stream_index = pVideoStream-&amp;gt;&lt;span&gt;index;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向封装器中写入压缩报文，该函数会自动释放pkt空间，不需要调用者手动释放&lt;/span&gt;
    errnum =&lt;span&gt; av_interleaved_write_frame(pFormatCtx, vpkt);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        av_strerror(errnum, errbuf, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(errbuf));
        cout &lt;/span&gt;&amp;lt;&amp;lt; errbuf &amp;lt;&amp;lt;&lt;span&gt; endl;
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;av_interleaved_write_frame failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 析构图像数据：注意这里只析构了图片的数据，实际的QImage对象还在内存中&lt;/span&gt;
    &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; rgb;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 音频编码

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 固定写法：配置一帧音频的数据结构&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *pcm = aa-&amp;gt;&lt;span&gt;getPCM();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pcm) {
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; uint8_t *&lt;span&gt;in&lt;/span&gt;[AV_NUM_DATA_POINTERS] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;] = (uint8_t *&lt;span&gt;)pcm;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 音频重采样&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; swr_convert(swrCtx,
        aframe&lt;/span&gt;-&amp;gt;data, aframe-&amp;gt;nb_samples, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出&lt;/span&gt;
        &lt;span&gt;in&lt;/span&gt;, aframe-&amp;gt;nb_samples); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (len &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;swr_convert failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 音频编码&lt;/span&gt;
    errnum =&lt;span&gt; avcodec_send_frame(pAudioCodecCtx, aframe);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avcodec_send_frame failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 音频编码报文&lt;/span&gt;
    AVPacket *apkt =&lt;span&gt; av_packet_alloc();
    errnum &lt;/span&gt;=&lt;span&gt; avcodec_receive_packet(pAudioCodecCtx, apkt);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        av_packet_free(&lt;/span&gt;&amp;amp;&lt;span&gt;apkt);
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avcodec_receive_packet failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
    }
    apkt&lt;/span&gt;-&amp;gt;stream_index = pAudioStream-&amp;gt;&lt;span&gt;index;
    apkt&lt;/span&gt;-&amp;gt;pts =&lt;span&gt; apts;
    apkt&lt;/span&gt;-&amp;gt;dts =&lt;span&gt; apts;
    apts &lt;/span&gt;+= av_rescale_q(aframe-&amp;gt;nb_samples, { &lt;span&gt;1&lt;/span&gt;, pAudioCodecCtx-&amp;gt;sample_rate }, pAudioCodecCtx-&amp;gt;&lt;span&gt;time_base);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写音频帧&lt;/span&gt;
    errnum =&lt;span&gt; av_interleaved_write_frame(pFormatCtx, apkt);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        av_strerror(errnum, errbuf, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(errbuf));
        cout &lt;/span&gt;&amp;lt;&amp;lt; errbuf &amp;lt;&amp;lt;&lt;span&gt; endl;
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;av_interleaved_write_frame failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; pcm;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （17）写入文件尾和关闭IO&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写入文件尾&lt;/span&gt;
errnum =&lt;span&gt; av_write_trailer(pFormatCtx);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;av_write_trailer failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}
errnum &lt;/span&gt;= avio_closep(&amp;amp;pFormatCtx-&amp;gt;pb); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭AVIO流&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (errnum != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avio_close failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （18）清理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pFormatCtx) {
    avformat_close_input(&lt;/span&gt;&amp;amp;pFormatCtx); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭封装上下文&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭编码器和清理上下文的所有空间&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pVideoCodecCtx) {
    avcodec_close(pVideoCodecCtx);
    avcodec_free_context(&lt;/span&gt;&amp;amp;&lt;span&gt;pVideoCodecCtx);
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pAudioCodecCtx) {
    avcodec_close(pAudioCodecCtx);
    avcodec_free_context(&lt;/span&gt;&amp;amp;&lt;span&gt;pAudioCodecCtx);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 音视频转换上下文&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pSwsCtx) {
    sws_freeContext(pSwsCtx);
    pSwsCtx &lt;/span&gt;=&lt;span&gt; NULL;
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (swrCtx) {
    swr_free(&lt;/span&gt;&amp;amp;&lt;span&gt;swrCtx);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清理音视频帧&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (vframe) {
    av_frame_free(&lt;/span&gt;&amp;amp;&lt;span&gt;vframe);
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (aframe) {
    av_frame_free(&lt;/span&gt;&amp;amp;&lt;span&gt;aframe);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 四、遗留问题&lt;/p&gt;
&lt;p&gt;运行代码我们可以在设置的盘符下找到生成的mp4文件。查看文件属性，我们可以看到音视频数据都与我们之前的设置完全一致。也可以被播放器正常播放。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/871676/201805/871676-20180506001748841-89836875.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是我们发现，音视频并不同步。另外就是视频采集的时候，QImage也没有被正确析构。我们将在下一章提供解决方案。&lt;/p&gt;

&lt;p&gt;项目源码地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/learnhow/ffmpeg_studio/blob/master/_64bit/src/screen_vcr_v12/demo.cpp&quot; target=&quot;_blank&quot;&gt;https://gitee.com/learnhow/ffmpeg_studio/blob/master/_64bit/src/screen_vcr_v12/demo.cpp&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 05 May 2018 16:26:00 +0000</pubDate>
<dc:creator>冷豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learnhow/p/8996898.html</dc:identifier>
</item>
<item>
<title>Android框架之Volley与Glide - CMusketeer</title>
<link>http://www.cnblogs.com/cmusketeer/p/8996784.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmusketeer/p/8996784.html</guid>
<description>&lt;p&gt;&lt;span&gt;PS：&lt;/span&gt;在看到这个题目的同时，你们估计会想，Volley与Glide怎么拿来一块说呢，他们虽然不是一个框架，但有着相同功能，那就是图片处理方面。首先我们先来看一下什么volley，又什么是glide。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Volley&lt;/span&gt;是Google官方出的一套小而巧的异步请求库，该框架封装的扩展性很强，支持OkHttp，Volley里面也封装了ImageLoader，自身作为图片加载框架，不过这块功能没有一些专门的图片加载框架强大，对于简单的需求可以使用，对于稍复杂点的需求还是需要用到专门的图片加载框架。Volley也有缺陷，比如不支持post大数据，所以不适合上传文件。不过Volley设计的初衷本身也就是为频繁的、数据量小的网络请求而生！&lt;/p&gt;
&lt;h3&gt;个人建议：&lt;/h3&gt;
&lt;p&gt;如果请求的数据比较小的话，建议用volley，因为它代码量小，效果高，但是如果是下载大型文件（视频）,那就不要用它了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Glide&lt;/span&gt;是 Google推荐的图片加载库,它可以支持来自ur，文件,支持gif图片的加载,以及各种图片显示前的bitmap处理(例如:圆角图片,圆形图片,高斯模糊,旋转,灰度等等),缓存处理,请求优先级处理,动画处理,缩略图处理,图片大小自定义等等.&lt;/p&gt;
&lt;p&gt;他们竟然都是Google的，那为什么出了volley还要出Glide呢，其实他们只是有交集而已，并不是二选一，而是相辅相成。我们想要了解他们，就要先学会怎么用他们，下面写说一下Volley。下面分为多个小部分来讲。&lt;/p&gt;

&lt;h2&gt;首先 AndroidStudio中引入Volley三种方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;引入volley.jar文件&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;添加volley到gradle依赖
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
compile 'com.mcxiaoke.volley:library:1.0.19'
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;通过git下载volley，添加为项目module&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;1：StringRequest&lt;/h2&gt;
&lt;p&gt;先热热身，传入一个百度链接，返回一些数据。&lt;/p&gt;
&lt;h3 id=&quot;9424-1523070411476&quot;&gt;1.1简单请求一个网络地址并返回数据，创建队列&lt;/h3&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
RequestQueue queue=Volley.newRequestQueue(context);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;3056-1523070510395&quot;&gt;1.2在需要的地方创建StringRequest（参数..）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;GET/POST&lt;/li&gt;
&lt;li&gt;url地址&lt;/li&gt;
&lt;li&gt;响应监听&lt;/li&gt;
&lt;li&gt;错误监听&lt;/li&gt;
&lt;/ul&gt;&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
String url = &quot;http://www.baidu.com&quot;;
StringRequest request = new StringRequest(&lt;span&gt;Request.Method.GET&lt;/span&gt;,&lt;span&gt;url&lt;/span&gt;,&lt;span&gt;new Response.Listener&lt;/span&gt;&amp;lt;String&amp;gt;(){
@Override
public void onResponse(String response) {&lt;br/&gt;result = SecuritUtil.aesBase64Decode(response); }&lt;br/&gt;,&lt;span&gt;new ErrorListener&lt;/span&gt;() { &lt;br/&gt;@Override &lt;br/&gt;public void onErrorResponse(VolleyError error) {&lt;br/&gt;} }
}); 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;9038-1523071001203&quot;&gt;1.3最后处理要加入到队列中&lt;/h3&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
queue.add(request);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我去，这就可以了，我自己都紧张了，记得以前用httpconnect的时候，写的真的是多，还要配置很多的东西，就连retrofit都要写注解什么的。retrofit我之前有些文章，不怎么会用的同志可以去看看。好了，数据是出来了，我没有截图，大家了解，这什么都不传是简单，但如果想传值呢，那就POST方法呗。&lt;/p&gt;
&lt;h2 id=&quot;2785-1523072496310&quot;&gt;2:POST带参数请求&lt;/h2&gt;
&lt;p&gt;在创建StringRequest方法前，我们先看一下源码方法，4个参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Creates a new request with the given method.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; method the request {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Method} to use
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; url URL to fetch the string at
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; listener Listener to receive the String response
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; errorListener Error listener, or null to ignore errors
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; StringRequest(&lt;span&gt;int&lt;/span&gt; method, String url, Listener&amp;lt;String&amp;gt;&lt;span&gt; listener,
            ErrorListener errorListener) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(method, url, errorListener);
        mListener &lt;/span&gt;=&lt;span&gt; listener;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.1：还是一样的写创建一个StringRequest，看注释&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
 StringRequest request = &lt;span&gt;new&lt;/span&gt; StringRequest(Request.Method.POST, url, &lt;span&gt;new&lt;/span&gt; Response.Listener&amp;lt;String&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onResponse(String response) {
　　　　　　　　//成功后
            }
        }, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Response.ErrorListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onErrorResponse(VolleyError error) {
　　　　　　　　//失败后
            }
        }) &lt;span&gt;{//传值方法书写位置&lt;/span&gt;
            @Override
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Map&amp;lt;String, String&amp;gt; getParams() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; AuthFailureError {
                HashMap&lt;/span&gt;&amp;lt;String, String&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
                map.put(&lt;/span&gt;&quot;name&quot;, &quot;liu&quot;&lt;span&gt;);
                map.put(&lt;/span&gt;&quot;id&quot;, &quot;123456789&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
            }
        &lt;span&gt;}&lt;/span&gt;;&lt;br/&gt;//这里需要注意的是getParams（）方法是写在StringRequest(内)的，括号标红。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.2最后要把该对象放在queue中&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
queue.add(request);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就完事了，传值直接写上就OK了，都是键值对的形式。到这估计有人觉得这是传普通值，如果我传JSON呢，有有有，下面就是。&lt;/p&gt;
&lt;h2 id=&quot;3582-1523072512935&quot;&gt;3：JSON格式传参和接受数据&lt;/h2&gt;
&lt;p&gt;这个JSON传值话也是分GET和PSOT方法，GET一般都不传值，直接填&quot;&quot;。POST则是用专用类JsonObjectRequest，如果你觉得不过瘾还可以用&lt;/p&gt;
&lt;p&gt;JsonArrayRequest。老规矩还是先看一下源码&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Creates a new request.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; method the HTTP method to use
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; url URL to fetch the JSON from
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; requestBody A {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; String} to post with the request. Null is allowed and
     *   indicates no parameters will be posted along with request.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; listener Listener to receive the JSON response
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; errorListener Error listener, or null to ignore errors.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; JsonObjectRequest(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; method, String url, String requestBody,
                             Listener&lt;/span&gt;&amp;lt;JSONObject&amp;gt;&lt;span&gt; listener, ErrorListener errorListener) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(method, url, requestBody, listener,
                errorListener);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;7051-1523073959229&quot;&gt;3.1：请求方式GET，无参数传入&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 JsonObjectRequest json=&lt;span&gt;new&lt;/span&gt; JsonObjectRequest(Request.Method.GET, url, &quot;&quot;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Response.Listener&amp;lt;JSONObject&amp;gt;&lt;span&gt;() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onResponse(JSONObject response) {

                    }
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Response.ErrorListener() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onErrorResponse(VolleyError error) {

                    }
                });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2:请求方式POST&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
      JSONObject jsonO=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; JSONObject();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            jsonO.put(&lt;/span&gt;&quot;name&quot;,&quot;&quot;&lt;span&gt;);
            jsonO.put(&lt;/span&gt;&quot;ID&quot;,&quot;&quot;&lt;span&gt;);
            
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JSONException e) {
            e.printStackTrace();
        }//创建JSONObject对象
        JsonObjectRequest json&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonObjectRequest(Request.Method.POST, url, jsonO,
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Response.Listener&amp;lt;JSONObject&amp;gt;&lt;span&gt;() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onResponse(JSONObject response) {
　　　　　　　　　　　　//ok
                    }
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Response.ErrorListener() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onErrorResponse(VolleyError error) {
　　　　　　　　　　　　//error
                    }
                });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.3:最后要把该对象放在queue中&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
queue.add(request);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里volley怎么用来访问网络数据就完事了，到现在还没有说他的图片处理，不过这个框架真心好用，所以就写的多了点。下面咱们来看一下他的图片处理&lt;/p&gt;
&lt;h2 id=&quot;7076-1523079614557&quot;&gt;&lt;strong&gt;4：ImageRequest, 图片加载&lt;/strong&gt;&lt;/h2&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258190/201805/1258190-20180505234202147-23585947.png&quot; alt=&quot;&quot; width=&quot;939&quot; height=&quot;251&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;10&quot;&gt;源码：图片URL，响应的回调接口，最大图片宽度，最大图片高度，图片配置RGB模式，错误的回调接口
&lt;p&gt;最大图片宽度（高度）如果不写可以写0，&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;25.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Creates a new image request, decoding to a maximum specified width and
     * height. If both width and height are zero, the image will be decoded to
     * its natural size. If one of the two is nonzero, that dimension will be
     * clamped and the other one will be set to preserve the image's aspect
     * ratio. If both width and height are nonzero, the image will be decoded to
     * be fit in the rectangle of dimensions width x height while keeping its
     * aspect ratio.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; url URL of the image
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; listener Listener to receive the decoded bitmap
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; maxWidth Maximum width to decode this bitmap to, or zero for none
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; maxHeight Maximum height to decode this bitmap to, or zero for
     *            none
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; scaleType The ImageViews ScaleType used to calculate the needed image size.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; decodeConfig Format to decode the bitmap to
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; errorListener Error listener, or null to ignore errors
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; ImageRequest(String url, Response.Listener&amp;lt;Bitmap&amp;gt; listener, &lt;span&gt;int&lt;/span&gt; maxWidth, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxHeight,
            ScaleType scaleType, Config decodeConfig, Response.ErrorListener errorListener) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(Method.GET, url, errorListener); 
        setRetryPolicy(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultRetryPolicy(IMAGE_TIMEOUT_MS, IMAGE_MAX_RETRIES, IMAGE_BACKOFF_MULT));
        mListener &lt;/span&gt;=&lt;span&gt; listener;
        mDecodeConfig &lt;/span&gt;=&lt;span&gt; decodeConfig;
        mMaxWidth &lt;/span&gt;=&lt;span&gt; maxWidth;
        mMaxHeight &lt;/span&gt;=&lt;span&gt; maxHeight;
        mScaleType &lt;/span&gt;=&lt;span&gt; scaleType;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用法：每个参数是什么我都在上面写好，第几个参数是干什么的，还有源码供大家参考。&lt;span&gt;url为图片地址&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
ImageRequest   request =&lt;span&gt;new&lt;/span&gt; ImageRequest(url,Response.Listener&amp;lt;Bitmap&amp;gt;&lt;span&gt;(){
 @Override
             &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onResponse(Bitmap s) {
 
                  Log.i(&lt;/span&gt;&quot;aa&quot;, &quot;post请求成功&quot; +&lt;span&gt; s);
                  &lt;/span&gt;&lt;span&gt;
             }
         } ,&lt;/span&gt;0,0,&lt;span&gt;Bitmap.config.RGB_565&lt;/span&gt;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Response.ErrorListener() {
             @Override
             &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onErrorResponse(VolleyError volleyError) {&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　　　　Log.i(&quot;aa&quot;, &quot;post请求失败&quot; +&lt;span&gt; s);&lt;/span&gt;&lt;/span&gt;&lt;span&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2&gt;5:ImageLoader 图片缓存机制（推荐使用）&lt;/h2&gt;
&lt;p&gt;在普通版中自身是调用自己的缓存类，这个是我们不能控制的，如果想要控制的就要自己写类来实现ImageLoader.ImageCache，这就相当于我们的自定义View，或者自定义适配器，我们可以更好的去控制我们想要的结果，比如说，我们要它最大缓存量是10M，超过这个值会发出警报等。&lt;/p&gt;
&lt;p&gt;下面来说简单用法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
ImageLoader imageLoader = &lt;span&gt;new&lt;/span&gt; ImageLoader(requestQueue, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ImageLoader.ImageCache() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Bitmap getBitmap(String url) {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体操作，主要针对对缓存数据大小、如何缓存。&lt;/span&gt;

                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; putBitmap(String url, Bitmap bitmap) {

            }
        });
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;imgShow是imageview控件。后面参数分类是失败和过程时出现的图片&lt;/span&gt;
        ImageLoader.ImageListener listener =&lt;span&gt; ImageLoader.getImageListener(imgShow, R.mipmap.ic_launcher, R.drawable.btn_add_true);
        imageLoader.get(url, listener, &lt;/span&gt;200, 200);        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个就可以对图片进行处理，不过还有一个就是定义接口，里面有两个方法，一个放一个是取，&lt;span&gt;重点是标红&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ImageCache &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ImageLoader.ImageCache{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LruCache 是专门用于缓存的类，String可以作为缓存入后的名称，Bitmap是位图。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;LruCache&lt;/span&gt;&amp;lt;String,Bitmap&amp;gt;&lt;span&gt; lruCache;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxCache=10 * 1024 *1024;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大缓存大小 10M&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ImageCache (){
        lruCache&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; LruCache&amp;lt;&amp;gt;&lt;span&gt;(maxCache);//实例化创建
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Bitmap getBitmap(String url) {//得到位图
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lruCache.get(url);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; putBitmap(String url, Bitmap bitmap) {//存入位图
        lruCache.put(url,bitmap);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;2291-1523079585439&quot;&gt;6:NetWorkImageView自动适配图片（控件）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258190/201805/1258190-20180506000245751-542516413.png&quot; alt=&quot;&quot; width=&quot;957&quot; height=&quot;321&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
netimg =&lt;span&gt; (NetworkImageView) findViewById(R.id.id_net_img);
netimg.setErrorImageResId(R.mipmap.ic_launcher);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误后&lt;/span&gt;
netimg.setDefaultImageResId(R.drawable.btn_add_true);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载中默认
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里new ImageCache()是上面自己写的类&lt;/span&gt;
netimg.setImageUrl(url,&lt;span&gt;new&lt;/span&gt; ImageLoader(queue,&lt;span&gt;new&lt;/span&gt; ImageCache()));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里volley基本用法就已经够用了，原本想写点Glide的用法呢，还有对比，这一篇写的就不少了。大家可以消化一下，下一篇我写Glide的简单用法，然后是Volley对比Glide。&lt;/p&gt;
&lt;h2&gt;总结：&lt;/h2&gt;
&lt;p&gt;Volley是轻量级的网络请求框架，如果请求的数据比较小的话，建议用volley，因为它代码量小，效果高，但是如果是下载大型文件（视频）,那就不要用它了。&lt;/p&gt;
&lt;p&gt;但是如果有一个listview了，GridView了等加载图片的话，可以用Volley，尤其是最后一个NetWorkImageView，可以自动适配图片大小，然后统一作出判断到底该多大才能更好的呈现给用户。每一个框架都是一些人的心血，肯定是优点爆棚的，对于程序员来讲一个好的工具对以后的开发是多么的重要，一个功能省去了一些代码，功能多了代码就非诚客观了，而且简介明了规范。谢谢大家的支持。&lt;/p&gt;

</description>
<pubDate>Sat, 05 May 2018 16:11:00 +0000</pubDate>
<dc:creator>CMusketeer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmusketeer/p/8996784.html</dc:identifier>
</item>
<item>
<title>android传值 - 黄增松</title>
<link>http://www.cnblogs.com/huangzs/p/8996758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangzs/p/8996758.html</guid>
<description>&lt;p&gt;需求&lt;/p&gt;
&lt;p&gt;OneActivity向TwoActivity传值name=hzs，然后TwoActivity向OneActivity传值sex=Y&lt;/p&gt;
&lt;p&gt;第一步：OneActivity向TwoActivity传值name=hzs&lt;/p&gt;
&lt;p&gt;OneActivity 里设置&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td readability=&quot;9&quot;&gt;
&lt;pre&gt;
Intent intent = new Intent(OneActivity.this,TwoActivity.class);&lt;br/&gt;intent.putExtra(&quot;name&quot;,&quot;hzs&quot;);&lt;br/&gt;startActivityForResult(intent,2008); //code是请求码 int类型 
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;TwoActivity 里取值&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;pre&gt;
Intent getIntent = getIntent();&lt;br/&gt;String name = getIntent.getStringExtra(&quot;name&quot;);
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第二步：TwoActivity向OneActivity传值sex=Y&lt;/p&gt;
&lt;p&gt;TwoActivity 里设置&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td readability=&quot;8&quot;&gt;
&lt;pre&gt;
Intent intent = new Intent();&lt;br/&gt;intent.putExtra(&quot;sex&quot;, &quot;Y&quot;);&lt;br/&gt;setResult(1, intent);  //resultCode 为返回码 用于区分从哪里返回。&lt;br/&gt;finish();
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;OneActivity 里取值&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td readability=&quot;13&quot;&gt;
&lt;p&gt;@Override &lt;br/&gt;protected void onActivityResult(int requestCode, int resultCode, Intent data) {&lt;/p&gt;
&lt;p&gt;switch(requestCode){&lt;/p&gt;
&lt;p&gt;case 2000:&lt;/p&gt;
&lt;p&gt;if(resultCode==1){&lt;/p&gt;
&lt;p&gt;String sex = data.getStringExtra(&quot;sex&quot;);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;break;&lt;/p&gt;
&lt;p&gt;default:&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;&lt;p&gt;super.onActivityResult(requestCode, resultCode, data); &lt;br/&gt;}&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Sat, 05 May 2018 15:28:00 +0000</pubDate>
<dc:creator>黄增松</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangzs/p/8996758.html</dc:identifier>
</item>
<item>
<title>Git快速入门 - guan_yan_guan</title>
<link>http://www.cnblogs.com/guanzhyan/p/8996607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guanzhyan/p/8996607.html</guid>
<description>&lt;p&gt;前篇文章&lt;a title=&quot;玩转Git入门篇&quot; href=&quot;http://www.cnblogs.com/guanzhyan/p/8996489.html&quot; target=&quot;_blank&quot;&gt;玩转Git入门篇&lt;/a&gt;我们已经对Git有了一个大概的了解，接下来我们学习下Git的如何管理项目的。&lt;/p&gt;&lt;p align=&quot;left&quot;&gt;Repository(仓库)包含的内容 - Git的目标是管理一个工程，或者说是一些文件的集合，以跟踪它们的变化。Git使用Repository来存储这些信息。一个仓库主要包含以下内容(也包括其他内容)：&lt;/p&gt;&lt;div readability=&quot;252.39005083515&quot;&gt;
&lt;h2&gt;创建Repository(仓库)&lt;/h2&gt;
&lt;p&gt;在使用Repository(仓库)之前，我们首先需要创建仓库，创建仓库有很多种，这里常见的有如下几种：&lt;/p&gt;
&lt;p&gt;这里使用第三方托管平台作为讲解，以 &lt;a href=&quot;http://git.oschina.net/&quot; target=&quot;_blank&quot;&gt;http://git.oschina.net&lt;/a&gt; 为例,注册过程就省略。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;创建仓库&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505225826329-1543167301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击红色箭头指向的”&lt;strong&gt;+&lt;/strong&gt;“号，以创建一个仓库，如下所示 –&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505225951759-622928517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，一个公开的仓库就创建完成了。要记住上面图片创建的路径：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/guanzzh/git-start.git&quot;&gt;https://gitee.com/guanzzh/git-start.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;获取 Git 仓库&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;方法一：从一个服务器克隆一个现有的 Git 仓库。&lt;/p&gt;
&lt;p&gt;方法二：在现有项目或目录下导入所有文件到 Git 中；&lt;/p&gt;
&lt;h3&gt;克隆现有的仓库&lt;/h3&gt;
&lt;p&gt;如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，想为某个开源项目贡献自己的一份力，这时就要用到 &lt;code&gt;git clone&lt;/code&gt; 命令。当你执行 &lt;code&gt;git clone&lt;/code&gt; 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。&lt;/p&gt;
&lt;p&gt;在安装了Git 的 Windows系统上，在一个目录(本示例是：&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;D:\Git_Repository&lt;/span&gt;&lt;/em&gt;)中，单击右键，在弹出的菜单中选择“Git Bash”。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;克隆仓库的命令格式是 git clone [url] 。 比如，要克隆 Git 的上面创建的仓库 git-start.git，可以用下面的命令：&lt;/p&gt;
&lt;p&gt;$ git clone &lt;a href=&quot;https://gitee.com/guanzzh/git-start.git&quot;&gt;https://gitee.com/guanzzh/git-start.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230143640-607658470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这会在当前目录下创建一个名为 “&lt;code&gt;git-start.git&lt;/code&gt;” 的目录，并在这个目录下初始化一个 &lt;code&gt;.git&lt;/code&gt; 文件夹，从远程仓库拉取下所有数据放入 &lt;code&gt;.git&lt;/code&gt; 文件夹，然后从中读取最新版本的文件的拷贝。&lt;/p&gt;
&lt;p&gt;如果想在克隆远程仓库的时候，自定义本地仓库的名字，可以使用如下命令：&lt;/p&gt;
&lt;p&gt;$ git clone &lt;a href=&quot;https://gitee.com/guanzzh/git-start.git&quot;&gt;https://gitee.com/guanzzh/git-start.git&lt;/a&gt; mygit-start&lt;/p&gt;
&lt;p&gt;Git 支持多种数据传输协议。 上面的例子使用的是 &lt;code&gt;https://&lt;/code&gt; 协议，不过也可以使用 &lt;code&gt;git://&lt;/code&gt; 协议或者使用 SSH 传输协议，比如 &lt;code&gt;user&lt;a title=&quot;@server_ip&quot; href=&quot;https://github.com/server_ip&quot; target=&quot;_blank&quot;&gt;@server_ip&lt;/a&gt;-or-host:path/to/repo.git&lt;/code&gt; 。在服务器上搭建 Git 将会介绍所有这些协议在服务器端如何配置使用，以及各种方式之间的利弊。&lt;/p&gt;
&lt;h3&gt;在现有目录中初始化仓库&lt;/h3&gt;
&lt;p&gt;如果不克隆现有的仓库，而是打算使用 Git 来对现有的项目进行管理。假设有一个项目的目录是：&lt;code&gt;D:\Git_Repository\demo-sample&lt;/code&gt;，进入该目录并输入：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ git init&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git init&lt;/code&gt;命令创建一个空的Git仓库或重新初始化一个现有仓库。
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230350718-843377324.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;该命令将创建一个名为 &lt;code&gt;.git&lt;/code&gt; 的子目录，这个子目录含有初始化的 Git 仓库中所有的必须文件，仅仅是做了一个初始化的操作，项目里的文件还没有被跟踪。此时可通过 &lt;code&gt;git add&lt;/code&gt; 命令来实现对指定文件的跟踪，然后执行 &lt;code&gt;git commit&lt;/code&gt; 提交。&lt;/p&gt;
&lt;p&gt;假设在目录 &lt;code&gt;D:\Git_Repository\demo-sample&lt;/code&gt;中有一些代码需要跟踪(版本控制)，可通过 &lt;code&gt;git add&lt;/code&gt; 命令来实现对&lt;em&gt;HelloWorld.java&lt;/em&gt;文件的跟踪 –&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git add &lt;/code&gt;&lt;em&gt;HelloWorld.java&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;$ git commit -m 'initial project version'&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230431945-1474748337.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;
&lt;h2&gt;更新提交到仓库&lt;/h2&gt;
&lt;/p&gt;
&lt;h3&gt;记录每次更新到仓库&lt;/h3&gt;
&lt;p&gt;工作目录下的每一个文件都不外乎这两种状态：&lt;span&gt;&lt;strong&gt;已跟踪或未跟踪&lt;/strong&gt;&lt;/span&gt;。 &lt;strong&gt;已跟踪&lt;/strong&gt;的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于&lt;strong&gt;未修改，已修改或已放入暂存区&lt;/strong&gt;。工作目录中除已跟踪文件以外的所有其它文件都属于&lt;strong&gt;未跟踪文件&lt;/strong&gt;，&lt;strong&gt;它们既不存在于上次快照的记录中，也没有放入暂存区。&lt;/strong&gt; 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。&lt;/p&gt;
&lt;p&gt;编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230511077-1117357199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;检查当前文件状态&lt;/h3&gt;
&lt;p&gt;要查看哪些文件处于什么状态，可以用 &lt;code&gt;git status&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ git status&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;在项目中新建不存在文件&lt;/code&gt;mytext.txt&lt;code&gt;，&lt;/code&gt;使用 &lt;code&gt;git status&lt;/code&gt; 命令，将看到一个新的未跟踪文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230548855-1016136906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若使用 git status -s 命令或 git status --short 命令，将得到一种更为紧凑的格式输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230619968-59985421.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;??标识未跟踪，新增A，修改M，同时出现MM，右M标识文件被修改未放入暂存区，左M标识该文件被修改并放入暂存区。&lt;/p&gt;
&lt;h4&gt;查看已暂存和未暂存的修改&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt; 将通过文件补丁的格式显示具体哪些行发生了改变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230814145-1945520693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请注意，&lt;code&gt;&lt;strong&gt;git diff&lt;/strong&gt;&lt;/code&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;本身只显示尚未暂存的改动&lt;/strong&gt;，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 &lt;code&gt;git diff&lt;/code&gt; 后却什么也没有，就是这个原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后用&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;code&gt;&lt;strong&gt;git diff --cached&lt;/strong&gt;&lt;/code&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;查看已经暂存起来的变化：&lt;/strong&gt;&lt;strong&gt;(&lt;/strong&gt;&lt;code&gt;&lt;strong&gt;--staged&lt;/strong&gt;&lt;/code&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;code&gt;&lt;strong&gt;--cached&lt;/strong&gt;&lt;/code&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;是同义词&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230909783-865102684.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git difftool&lt;/code&gt; 命令来用 &lt;code&gt;Araxis&lt;/code&gt; ，&lt;code&gt;emerge&lt;/code&gt; 或 &lt;code&gt;vimdiff&lt;/code&gt; 等软件输出 &lt;code&gt;diff&lt;/code&gt; 分析结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505230932355-873450465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;qa!&lt;/span&gt;&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;退出窗口&lt;br/&gt;&lt;/strong&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt;跟踪新文件&lt;/h3&gt;
&lt;p&gt;使用命令 &lt;code&gt;git add&lt;/code&gt; 开始跟踪一个文件。 (&lt;span&gt;添加内容到下一次提交中&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ git add mytext.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此时再运行 &lt;code&gt;git status&lt;/code&gt; 命令，会看到 &lt;code&gt;mytext.txt&lt;/code&gt; 文件已被跟踪，并处于暂存状态：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231042477-1222125997.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;只要在 &lt;em&gt;Changes to be committed&lt;/em&gt; 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。&lt;span&gt;&lt;code&gt;&lt;strong&gt;git add&lt;/strong&gt;&lt;/code&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;暂存已修改文件&lt;/h3&gt;
&lt;p&gt;修改一个已被跟踪的文件。然后运行 &lt;code&gt;git status&lt;/code&gt; 命令，会看到下面内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231117037-1018769853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现在 &lt;em&gt;Changes not staged for commit&lt;/em&gt; 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。&lt;strong&gt;要暂存这次更新&lt;/strong&gt;，需要运行 &lt;code&gt;git add&lt;/code&gt; 命令。 这是个多功能命令：可以用它&lt;strong&gt;开始跟踪新文件&lt;/strong&gt;，或者&lt;strong&gt;把已跟踪的文件放到暂存区&lt;/strong&gt;，还能用于&lt;strong&gt;合并时把有冲突的文件标记为已解决状态等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231134654-996434963.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先修改README.md文件，git add之后，现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，修改README.md,再运行 &lt;code&gt;git status&lt;/code&gt; &lt;code&gt;：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231148181-177289404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
现在 &lt;code&gt;README.md&lt;/code&gt; 文件同时出现在暂存区和非暂存区。实际上 Git 只不过暂存了运行 &lt;code&gt;git add&lt;/code&gt; 命令时的版本， 如果现在提交，&lt;code&gt;README.md&lt;/code&gt; 的版本是最后一次运行 &lt;code&gt;git add&lt;/code&gt; 命令时的那个版本，而不是运行 &lt;code&gt;git commit&lt;/code&gt; 时，在工作目录中的当前版本。运行了 &lt;code&gt;git add&lt;/code&gt; 之后又作了修订的文件，需要重新运行 &lt;code&gt;git add&lt;/code&gt; 把最新版本重新暂存起来：
&lt;h3&gt;忽略文件&lt;/h3&gt;
&lt;p&gt;一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。在这种情况下，我们可以创建一个名为 &lt;code&gt;.gitignore&lt;/code&gt; 的文件，列出要忽略的文件模式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ cat .gitignore&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;*.[oa]&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;*~&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;忽略所有以 &lt;code&gt;.o&lt;/code&gt; 或 &lt;code&gt;.a&lt;/code&gt; 结尾的文件。&lt;/p&gt;
&lt;p&gt; 忽略所有以波浪符(&lt;code&gt;~&lt;/code&gt;)结尾的文件，&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;.gitignore&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;的格式规范如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有空行或者以 ＃ 开头的行都会被 Git 忽略。&lt;/li&gt;
&lt;li&gt;可以使用标准的 glob 模式匹配。&lt;/li&gt;
&lt;li&gt;匹配模式可以以(/)开头防止递归。&lt;/li&gt;
&lt;li&gt;匹配模式可以以(/)结尾指定目录。&lt;/li&gt;
&lt;li&gt;要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号(!)取反。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：GitHub 有一个十分详细的针对数十种项目及编程语言的 &lt;code&gt;.gitignore&lt;/code&gt; 文件列表，你可以在 &lt;a href=&quot;http://github.com/github/gitignore&quot; target=&quot;_blank&quot;&gt;http://github.com/github/gitignore&lt;/a&gt; 找到它。&lt;/p&gt;
&lt;h3&gt;提交更新&lt;/h3&gt;
&lt;p&gt;每次准备提交前，先用 &lt;code&gt;git status&lt;/code&gt; 看下，是不是都已暂存起来了，如果没有暂存起来则要先使用命令：&lt;code&gt;git add .&lt;/code&gt;将所有文件暂存起来， 然后再运行提交命令 &lt;code&gt;git commit&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git status&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git add .&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git commit&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;提交后它会告诉你，当前是在哪个分支(&lt;code&gt;master&lt;/code&gt;)提交的，本次提交的完整 SHA-1 校验和是什么(&lt;code&gt;463dc4f&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请记住&lt;/strong&gt;，提交时记录的是放在暂存区域的快照。任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跳过使用暂存区域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git commit&lt;/code&gt; 加上 &lt;code&gt;-a&lt;/code&gt; 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 &lt;code&gt;git add&lt;/code&gt; 步骤：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git commit -a -m 'added new benchmarks'&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;Git&lt;/code&gt;&lt;code&gt;隐藏(stash)操作&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;在Git中，隐藏操作将使您能够修改跟踪文件，阶段更改，并将其保存在一系列未完成的更改中，并可以随时重新应用。要将一个新的存根推到堆栈上，运行&lt;code&gt;git stash&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git stash&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;Saved working directory and index state WIP on master: ef07ab5 synchronized with the remote repository&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;HEAD is now at ef07ab5 synchronized with the remote repository&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过使用&lt;/strong&gt;&lt;code&gt;&lt;strong&gt;git stash list&lt;/strong&gt;&lt;/code&gt;&lt;strong&gt;命令来查看已存在更改的列表。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git stash list&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;stash@{0}: WIP on master: ef07ab5 synchronized with the remote repository&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;想要重新开始新的功能的代码编写，查找上次没有写完成的代码，只需执行&lt;/strong&gt;&lt;code&gt;&lt;strong&gt;git stash pop&lt;/strong&gt;&lt;/code&gt;&lt;strong&gt;命令即可从堆栈中删除更改并将其放置在当前工作目录中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231458188-943016788.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;移除文件&lt;/h3&gt;
&lt;p&gt;要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除(确切地说，是从暂存区域移除)，然后提交。 可以用 &lt;code&gt;git rm&lt;/code&gt; 命令完成此项工作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ rm mytext.txt&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;已经存放到暂存区，则必须要用强制删除选项 &lt;code&gt;-f&lt;/code&gt;(注：即 &lt;code&gt;force&lt;/code&gt; 的首字母)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rm&lt;/code&gt; 命令后面可以列出文件或者目录的名字，也可以使用 &lt;code&gt;glob&lt;/code&gt; 模式。 比方说：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git rm log/\*.log&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;移动文件&lt;/h3&gt;
&lt;p&gt;Git 并不显式跟踪文件移动操作。在 Git 中对文件改名，命令如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git mv file_from file_to&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;相当于如下三个命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ mv README.md README&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git rm README.md&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git add README&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;查看提交历史&lt;/h3&gt;
&lt;p&gt;查看提交历史，&lt;code&gt;git log&lt;/code&gt; 命令。默认不用任何参数的话，&lt;code&gt;git log&lt;/code&gt; 会按提交时间列出所有的更新，最近的更新排在最上面。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231639764-1039136274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个常用的选项是 &lt;code&gt;-p&lt;/code&gt;，用来显示每次提交的内容差异。 你也可以加上 &lt;code&gt;-2&lt;/code&gt; 来仅显示最近两次提交：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231654114-1855859567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想看到每次提交的简略的统计信息，可以使用 &lt;code&gt;--stat&lt;/code&gt; 选项：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231706766-126920780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外一个常用的选项是 &lt;code&gt;--pretty&lt;/code&gt;。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 &lt;code&gt;oneline&lt;/code&gt; 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 &lt;code&gt;short&lt;/code&gt;，&lt;code&gt;full&lt;/code&gt; 和 &lt;code&gt;fuller&lt;/code&gt; 可以用，展示的信息或多或少有些不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231721794-616220142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;撤消操作&lt;/h3&gt;
&lt;p&gt;有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 &lt;code&gt;--amend&lt;/code&gt; 选项的提交命令尝试重新提交：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git commit --amend&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改(例如，在上次提交后马上执行了此命令)，那么快照会保持不变，而你所修改的只是提交信息。&lt;/p&gt;
&lt;h3&gt;取消暂存的文件&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;...&lt;/code&gt; 来取消暂存。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git reset HEAD mytext.txt&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reset强调，撤销&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;git reset head - - filename &lt;ul&gt;&lt;li&gt;撤销上次暂存（取消暂存区的内容，用head指向的目录（版本库）替换暂存区）&lt;/li&gt;
&lt;li&gt;如果只删除暂存，保留工作区，可以使用git rm --cached -r filename,-r表示递归删除&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;git reset - -hard head: &lt;ul&gt;&lt;li&gt;撤销本地和暂存区的所有变动（用head指向的目录（版本库）替换本地和暂存区）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;git reset – hard origin/master &lt;ul&gt;&lt;li&gt;撤销本地、暂存区、版本库(用远程服务器的origin/master替换本地、暂存区、版本库)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;用Git复位移动头指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过少量更改后，可以决定删除这些更改。 &lt;code&gt;git reset&lt;/code&gt;命令用于复位或恢复更改。 我们可以执行三种不同类型的复位操作。语法：git reset [&amp;lt;mode&amp;gt;] [&amp;lt;commit&amp;gt;]&lt;/p&gt;
&lt;p&gt;下图显示了&lt;code&gt;git reset&lt;/code&gt;命令的图示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;git reset&lt;/code&gt;命令之前 -&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231919618-780711756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;git reset&lt;/code&gt;命令之后 -&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505231925329-415093366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;—soft&lt;/strong&gt;&lt;strong&gt;选项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个分支都有一个&lt;code&gt;HEAD&lt;/code&gt;指针，它指向最新的提交。 如果用&lt;code&gt;--soft&lt;/code&gt;选项后跟提交ID的&lt;code&gt;Git reset&lt;/code&gt;命令，那么它将仅重置&lt;code&gt;HEAD&lt;/code&gt;指针而不会破坏任何东西。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.git/refs/heads/master&lt;/code&gt;文件存储&lt;code&gt;HEAD&lt;/code&gt;指针的提交ID。 使用git reset --soft [comittedID]命令。可使用&lt;code&gt;git log -1&lt;/code&gt;命令验证它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505232022249-135563953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;$ git reset --soft 931280a3ec004120c4cee372f45cf7c0b4fed1bc&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505232035156-1712108578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;--mixed&lt;/code&gt;选项的Git重置将从尚未提交的暂存区域还原这些更改。它仅从暂存区域恢复更改。对文件的工作副本进行的实际更改不受影响。 默认Git复位等效于执行&lt;code&gt;git reset -- mixed&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果使用&lt;code&gt;--hard&lt;/code&gt;选项与Git重置命令，它将清除分段区域; 它会将HEAD指针重置为特定提交ID的最新提交，并删除本地文件更改。&lt;/p&gt;
&lt;h3&gt;撤消对文件的修改&lt;/h3&gt;
&lt;p&gt;用暂存区的内容替换工作区的文件。使用 &lt;code&gt;git checkout -- &amp;lt;file&amp;gt;...&lt;/code&gt; 来撤消之前所做的修改。（&lt;strong&gt;未加入暂存区&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;$ git checkout -- mytext.txt&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/497836/201805/497836-20180505232120768-1862242757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;strong&gt;加入暂存区撤销修改&lt;/strong&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
当执行添加操作时，文件将从本地存储库移动到暂存区域。 如果用户意外修改文件并将其添加到暂存区域，则可以使用&lt;code&gt;git checkout&lt;/code&gt;命令恢复其更改。
&lt;/pre&gt;
&lt;pre&gt;
在Git中，有一个&lt;code&gt;HEAD&lt;/code&gt;指针总是指向最新的提交。 如果要从分段区域撤消更改，则可以使用&lt;code&gt;git checkout&lt;/code&gt;命令，但是使用&lt;code&gt;checkout&lt;/code&gt;命令，必须提供一个附加参数，即&lt;code&gt;HEAD&lt;/code&gt;指针。 附加的提交指针参数指示&lt;code&gt;git checkout&lt;/code&gt;命令重置工作树，并删除分段更改。
&lt;/pre&gt;
&lt;p&gt;$ git checkout &lt;strong&gt;head&lt;/strong&gt; -- &lt;code&gt;mytext.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;休息片刻，接下来我们将在&lt;a title=&quot;Git快速入门进阶篇&quot; href=&quot;http://www.cnblogs.com/guanzhyan/p/8996750.html&quot; target=&quot;_blank&quot;&gt;Git快速入门进阶篇&lt;/a&gt;中继续探讨Git是如何管理项目的。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 05 May 2018 15:27:00 +0000</pubDate>
<dc:creator>guan_yan_guan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guanzhyan/p/8996607.html</dc:identifier>
</item>
<item>
<title>[ SSH框架 ] Hibernate框架学习之四（JPA） - Kevin.ZhangCG</title>
<link>http://www.cnblogs.com/Kevin-ZhangCG/p/8996491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Kevin-ZhangCG/p/8996491.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、JPA概述以及它和Hibernate之间的关系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1.Hibernate 概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　JPA Java Persistence API，是EJB3规范中负责对象持久化的应用程序编程接口（ORM接口），它定义一系列的注释。这些注释大体可分为：类级别注释、方法级别注释、字段级别注释。给实体类添加适当的注释可以在程序运行时告诉Hibernate如何将一个实体类保存到数据库中以及如何将数据以对象的形式从数据库中读取出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　目前有两种注释方案可以确定对象与表格之间的对应关系：一种是注释实体类的属性字段（字段级别注释），成为字段访问方式（field access mode）；另一种是注释实体类的属性访问方法（方法级别注释），称为属性访问方式（property access mode）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2 JPA与Hibernate 的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　JPA和Hibernate之间的关系，可以简单的理解为&lt;span&gt;JPA是标准接口&lt;/span&gt;，&lt;span&gt;Hibernate是实现&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么Hibernate是如何实现与JPA的这种关系的呢。Hibernate主要是通过三个组件来实现的，及hibernate-annotation、hibernate-entitymanager和hibernate-core。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;hibernate-annotation：&lt;/strong&gt;是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;hibernate-core：&lt;/strong&gt;是Hibernate的核心实现，提供了Hibernate所有的核心功能。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;hibernate-entitymanager：&lt;/strong&gt;实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、JPA的环境搭建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 主要配置文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用JPA可以省去配置每个实体类的.xml 文件，只需直接在实体类中用注解的方式直接说明即可。先在src目录下的META-INF文件下创建persistence.xml配置文件，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505203623881-484167877.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;persistence.xml配置内容如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://java.sun.com/xml/ns/persistence
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.sun.com/xml/ns/persistence/persistence_2_0.xsd&quot;&lt;/span&gt;
    version=&quot;2.0&quot;&amp;gt;

    
    &amp;lt;!--&lt;span&gt; 配置持久化单元 
        可以制定多个持久化单元，但名称不可重复，name用于指定持久化单元名称        
        transaction&lt;/span&gt;-&lt;span&gt;type：指定事务的类型
                        RESCOURCE_LOCAL:指的是本地代码事务        
    &lt;/span&gt;--&amp;gt;
    &amp;lt;persistence-unit name=&quot;myJPAUnit&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&amp;gt;
    &amp;lt;!-- JPA规范的提供商  可以不写 --&amp;gt;
        &amp;lt;provider&amp;gt;org.hibernate.jpa.HibernatePersistenceProvider&amp;lt;/provider&amp;gt;
    &amp;lt;!-- 指定由JPA注解的实体类位置    可以不写--&amp;gt;    
        &amp;lt;&lt;span&gt;class&lt;/span&gt;&amp;gt;com.Kevin.domain.Customer&amp;lt;/&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;!-- 连接数据库相关的一些配置，都是Hibernate的，所以只需要把之前Hibernate配置文件中的内容拷贝过来即可 --&amp;gt;
        &amp;lt;properties&amp;gt;
            &amp;lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot;/&amp;gt;
            &amp;lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
            &amp;lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:mysql:///hibernateday4&quot;/&amp;gt;
            &amp;lt;property name=&quot;hibernate.connection.username&quot; value=&quot;root&quot;/&amp;gt;
            &amp;lt;property name=&quot;hibernate.connection.password&quot; value=&quot;admin&quot;/&amp;gt;
            &amp;lt;!-- Hibernate显示SQL语句 --&amp;gt;
            &amp;lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&amp;gt;
            &amp;lt;!-- Hibernate格式化SQL语句 --&amp;gt;
            &amp;lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&amp;gt;
            &amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&amp;gt;
            &amp;lt;property name=&quot;hibernate.connection.provider_class&quot; value=&quot;org.hibernate.connection.C3P0ConnectionProvider&quot;/&amp;gt; 
        &amp;lt;/properties&amp;gt;
    &amp;lt;/persistence-unit&amp;gt;
&amp;lt;/persistence&amp;gt;
    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;获取JPA操作数据库的对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;在src目录下com.Kevin.utils包中创建JPAUtil类用来获取数据库操作对象，文件目录如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505204217579-173059649.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取方式如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.Kevin.utils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.EntityManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.EntityManagerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Persistence;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * JPA的工具类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Kevin
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JPAUtil {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于SessionFactory&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; EntityManagerFactory factory;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;EntityManager&amp;gt;&lt;span&gt; tl;
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        factory&lt;/span&gt;=Persistence.createEntityManagerFactory(&quot;myJPAUnit&quot;);　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;名称要与persistence.xml文件中的持久化单元name一致&lt;/span&gt;
        tl=&lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;EntityManager&amp;gt;&lt;span&gt;();
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取JPA操作数据库的对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public static EntityManager createEntityManager(){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        return factory.createEntityManager();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取EntityManager对象
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; EntityManager createEntityManager(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从当前线程上获取EntityManager对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;tl.get();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(em==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            em&lt;/span&gt;=&lt;span&gt;factory.createEntityManager();
            tl.set(em);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tl.get();        
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[]args){
        createEntityManager();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 基本映射注释简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2.1 @Entity：映射实体类（必须）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;@Entity(name=&quot;EntityName&quot;)&lt;/span&gt;  ,name 为可选 , 对应数据库中一的个表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2.2 @Table：映射数据库表名（可选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;@Table(name=&quot;&quot;,catalog=&quot;&quot;,schema=&quot;&quot;)&lt;/span&gt;  , 通常和 @Entity 配合使用 , 只能标注在实体的 class 定义处 , 表示实体对应的数据库表的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 name: 可选 , 表示表的名称 . 默认地 , 表名和实体名称一致 , 只有在不一致的情况下才需要指定表名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 catalog: 可选 , 表示 Catalog 名称 , 默认为 Catalog(&quot;&quot;). schema: 可选 , 表示 Schema 名称 , 默认为 Schema(“”)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2.3 @Id：映射生成主键（必选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;@id 定义了映射到数据库表的主键的属性 , &lt;span&gt;一个实体只能有一个属性被映射为主键&lt;/span&gt; 。置于 getXxxx() 前 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;@GeneratedValue(strategy=GenerationType,generator=&quot;&quot;)&lt;/span&gt; 可选 strategy: 表示主键生成策略 , 有 AUTO,INDENTITY,SEQUENCE 和 TABLE 4 种 , 分别表示让 ORM 框架自动选择。根据数据库的 Identity 字段生成 , 根据数据库表的 Sequence 字段生成 , 以有根据一个额外的表生成主键 , 默认为 AUTO 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　generator: 表示主键生成器的名称 , 这个属性通常和 ORM 框架相关 , 例如 ,Hibernate 可以指定 uuid 等主键生成方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2.4 @Column：映射表格列（可选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Column 描述了数据库表中该字段的详细定义 , 这对于根据 JPA 注解生成数据库表结构的工具非常有作用 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　name: 表示数据库表中该字段的名称 , 默认情形属性名称一致 。nullable: 表示该字段是否允许为 null, 默认为 true。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　unique: 表示该字段是否是唯一标识 , 默认为 false length: 表示该字段的大小 , 仅对 String 类型的字段有效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　insertable: 表示在 ORM 框架执行插入操作时 , 该字段是否应出现 INSETRT 语句中 , 默认为 true。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　updateable: 表示在 ORM 框架执行更新操作时 , 该字段是否应该出现在 UPDATE 语句中 , 默认为 true. 对于一经创建就不可以更改的字段 , 该属性非常有用 , 如对于 birthday 字段 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　columnDefinition: 表示该字段在数据库中的实际类型 . 通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型 , 但是对于 Date 类型仍无法确定数据库中字段类型究竟是 DATE,TIME 还是 TIMESTAMP. 此外 ,String 的默认映射类型为 VARCHAR, 如果要将 String 类型映射到特定数据库的 BLOB 或 TEXT 字段类型 , 该属性非常有用 .。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2.5 @Transient：定义暂态属性（可选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Transient 表示该属性并非一个到数据库表的字段的映射 ,ORM 框架将忽略该属性。如果一个属性并非数据库表的字段映射 , 就务必将其标示为 @Transient, 否则 ,ORM 框架默认其注解为 @Basic。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3 关联类映射注释简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3.1 @ManyToOne（可选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;@ManyToOne(fetch=FetchType,cascade=CascadeType ) &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ManyToOne 表示一个多对一的映射 , 该注解标注的属性通常是数据库表的外键 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　optional: 是否允许该字段为 null, 该属性应该根据数据库表的外键约束来确定 , 默认为 true 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　fetch: 表示抓取策略 , 默认为 FetchType.EAGER cascade: 表示默认的级联操作策略 , 可以指定为 ALL,PERSIST,MERGE,REFRESH 和 REMOVE 中的若干组合 , 默认为无级联操作 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　targetEntity: 表示该属性关联的实体类型 . 该属性通常不必指定 ,ORM 框架根据属性类型自动判断 targetEntity。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3.2 @JoinColumn（可选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@JoinColumn 和 @Column 类似 , 介量描述的不是一个简单字段 , 而一一个关联字段 , 例如 . 描述一个 @ManyToOne 的字段 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　name: 该字段的名称 . 由于 @JoinColumn 描述的是一个关联字段 , 如 ManyToOne, 则默认的名称由其关联的实体决定。例如 , 实体 Order 有一个 user 属性来关联实体 User, 则 Order 的 user 属性为一个外键 , 其默认的名称为实体 User 的名称 + 下划线 + 实体 User 的主键名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3.3 @OneToMany&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;@OneToMany(fetch=FetchType,cascade=CascadeType) &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@OneToMany 描述一个一对多的关联 , 该属性应该为集体类型 , 在数据库中并没有实际字段 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　fetch: 表示抓取策略 , 默认为 FetchType.LAZY, 因为关联的多个对象通常不必从数据库预先读取到内存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　cascade: 表示级联操作策略 , 对于 OneToMany 类型的关联非常重要 , 通常该实体更新或删除时 , 其关联的实体也应当被更新或删除 例如 : 实体 User 和 Order 是 OneToMany 的关系 , 则实体 User 被删除时 , 其关联的实体 Order 也应该被全部删除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3.4 @OneToOne（可选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@OneToOne(fetch=FetchType,cascade=CascadeType)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@OneToOne 描述一个一对一的关联 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　fetch: 表示抓取策略 , 默认为 FetchType.LAZY 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　cascade: 表示级联操作策略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3.5 @ ManyToMany（可选）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ManyToMany 描述一个多对多的关联 . 多对多关联上是两个一对多关联 , 但是在 ManyToMany 描述中 , 中间表是由 ORM 框架自动处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　targetEntity: 表示多对多关联的另一个实体类的全名 , 例如 :package.Book.class。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　mappedBy: 表示多对多关联的另一个实体类的对应集合属性名称。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、JPA入门案例和CRUD操作（单表）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1 创建客户实体类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.Kevin.domain;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Column;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GenerationType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Table;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的实体类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Kevin
 * 使用的注解都是JPA规范，所以导包要导入javax.persistence包下
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Entity      &lt;/span&gt;&lt;span&gt;//表名&lt;/span&gt;&lt;span&gt;该类是一个实体类&lt;/span&gt;
@Table(name=&quot;cst_customer&quot;)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立当前类和数据库的对应关系&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Customer{
    @Id    &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;    @Column(name=&quot;cust_id&quot;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表明对应数据库的主键字段是cust_id&lt;/span&gt;
    @GeneratedValue(strategy=GenerationType.IDENTITY)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定主键生成策略,strategy:使用JPA中提供的主键生成策略，此属性是用不了；generator属性可以使用hibernate主键生成策略&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long cust_id;    
    
    @Column(name&lt;/span&gt;=&quot;cust_name&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_name;
    
    @Column(name&lt;/span&gt;=&quot;cust_address&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_address;
    
    @Column(name&lt;/span&gt;=&quot;cust_industry&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_industry;
    
    @Column(name&lt;/span&gt;=&quot;cust_level&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_level;
    
    
    @Column(name&lt;/span&gt;=&quot;cust_phone&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_phone;
    
    @Column(name&lt;/span&gt;=&quot;cust_mobile&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_mobile;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getCust_id() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_id(Long cust_id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_id =&lt;span&gt; cust_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_name() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_name(String cust_name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_name =&lt;span&gt; cust_name;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_address() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_address;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_address(String cust_address) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_address =&lt;span&gt; cust_address;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_industry() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_industry;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_industry(String cust_industry) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_industry =&lt;span&gt; cust_industry;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_level() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_level;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_level(String cust_level) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_level =&lt;span&gt; cust_level;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_phone() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_phone(String cust_phone) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_phone =&lt;span&gt; cust_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_mobile() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_mobile;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_mobile(String cust_mobile) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_mobile =&lt;span&gt; cust_mobile;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Customer [cust_id=&quot; + cust_id + &quot;, cust_name=&quot; + cust_name + &quot;, cust_address=&quot; +&lt;span&gt; cust_address
                &lt;/span&gt;+ &quot;, cust_industry=&quot; + cust_industry + &quot;, cust_level=&quot; + cust_level + &quot;, cust_phone=&quot; +&lt;span&gt; cust_phone
                &lt;/span&gt;+ &quot;, cust_mobile=&quot; + cust_mobile + &quot;]&quot;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2 编写CRUD测试代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2.1 保存操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存操作&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建客户对象&lt;/span&gt;
        Customer c=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
        c.setCust_name(&lt;/span&gt;&quot;Kevin&quot;&lt;span&gt;);        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.获取EntityManager&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.执行保存操作&lt;/span&gt;
&lt;span&gt;        em.persist(c);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.提交事务&lt;/span&gt;
&lt;span&gt;        tx.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.关闭资源&lt;/span&gt;
&lt;span&gt;        em.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2.2 更新操作（两种方式）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种：正常更新方式（update）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.获取EntityManager&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.执行更新操作（将需要更新的对象查询出来）&lt;/span&gt;
        Customer c=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 1l&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新客户地址&lt;/span&gt;
        c.setCust_address(&quot;China&quot;&lt;span&gt;);&lt;br/&gt;　　　 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.提交事务&lt;/span&gt;
&lt;span&gt;        tx.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.关闭资源&lt;/span&gt;
&lt;span&gt;        em.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第二种：合并方式保存（merge，将两个实体合并）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test4(){    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.获取EntityManager&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.执行更新操作（将需要更新的对象查询出来）&lt;/span&gt;
        Customer c=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 1l&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新客户地址&lt;/span&gt;
        c.setCust_mobile(&quot;66666666&quot;&lt;span&gt;);;
        em.merge(c);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.提交事务&lt;/span&gt;
&lt;span&gt;        tx.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.关闭资源&lt;/span&gt;
&lt;span&gt;        em.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2.3 删除操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test5(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取EntityManager对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取操作对象&lt;/span&gt;
        Customer c=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 1l&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除对象&lt;/span&gt;
&lt;span&gt;        em.remove(c);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交事务&lt;/span&gt;
&lt;span&gt;        tx.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭资源&lt;/span&gt;
&lt;span&gt;        em.close();
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 3.2.4 基本查询&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询所有&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 涉及的对象：
     *             JPA的Query：
     *         如何获取对象：EntityManager的createQuery（String sql）
     *         参数含义：JPAL：Java Persistence Query Language
     *                 写法与HQL很相似，也是把表名换成类名，把字段名换成属性名称
     *                 在写查询所有时，不能直接用    from 类
     *                 需要使用select关键字
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test6(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取EntityManager对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取JPA的查询对象Query&lt;/span&gt;
        Query query=em.createQuery(&quot;select c from Customer c&quot;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;c是一个别名
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行方法获取结果集&lt;/span&gt;
        List list=&lt;span&gt;query.getResultList();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Object o:list)
            System.out.println(o);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交事务&lt;/span&gt;
&lt;span&gt;        tx.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭资源&lt;/span&gt;
&lt;span&gt;        em.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 3.2.5 条件查询&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test7(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取EntityManager对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取JPA的查询对象Query&lt;/span&gt;
        Query query=em.createQuery(&quot;select c from Customer c where cust_name like ?&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给占位符赋值&lt;/span&gt;
        query.setParameter(1, &quot;%k%&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行方法获取结果集&lt;/span&gt;
        List list=&lt;span&gt;query.getResultList();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Object o:list)
            System.out.println(o);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交事务&lt;/span&gt;
&lt;span&gt;        tx.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭资源&lt;/span&gt;
&lt;span&gt;        em.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;多条件查询&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test8(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取EntityManager对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取JPA的查询对象Query&lt;/span&gt;
        Query query=em.createQuery(&quot;select c from Customer c where cust_name like ? and cust_level = ? &quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给占位符赋值&lt;/span&gt;
        query.setParameter(1, &quot;%K%&quot;&lt;span&gt;);
        query.setParameter(&lt;/span&gt;2, &quot;5&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行方法获取结果集&lt;/span&gt;
        List list=&lt;span&gt;query.getResultList();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Object o:list)
            System.out.println(o);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交事务&lt;/span&gt;
&lt;span&gt;        tx.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭资源&lt;/span&gt;
&lt;span&gt;        em.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;TIps：&lt;/span&gt; &lt;/strong&gt; &lt;span&gt;1. persist()方法相当于是save()操作；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2. remove()对应的是delete()；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3. find()方法对应get()方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　4. getReference()是延迟加载；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　5. find()是立即加载；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　6. uniqueResult()对应getSingleResult(),返回唯一的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　7. merge()和update()相似，但是merge干的活update有些不能干；&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt; 3.2.6 区别merge和update&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　当查询了一个对象后，关闭session，再次查询了该对象，并且修改了该对象。此时如果使用update方法时会报错，因为第一次查完后关闭了session，对象的状态转变成了托管态，而此时查询该对象，修改的时候是持久态，对象的状态是不一样的，在一级缓存外边还有一个修改对象。此时更新的话，由于两个对象的OID是一样的，但是却发生了修改，使用update的话，两个对象是不能合并的，只能用merge()方法将其更新，即将两个对象合并。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test10(){
         &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 查询ID为1的客户
         * 关闭EntityManager（清空了一级缓存和快照）
         * 修改id为1的客户的地址为America
         * 在此获取EntityManager
         * 再次查询ID为1的客户
         *  更新刚才修改的客户
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取EntityManager对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx=&lt;span&gt;em.getTransaction();
        tx.begin();
        Customer c&lt;/span&gt;=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 1L);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;持久态&lt;/span&gt;
&lt;span&gt;        tx.commit();
        em.close();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改客户信息&lt;/span&gt;
        c.setCust_address(&quot;America&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;托管态
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取EntityManager对象&lt;/span&gt;
        EntityManager em1=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事务对象，并开启事务&lt;/span&gt;
        EntityTransaction tx1=&lt;span&gt;em.getTransaction();
        tx1.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再次查询&lt;/span&gt;
        Customer c1=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 1L);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;持久态
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新操作&lt;/span&gt;
        em1.persist(c);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将托管态转换为持久态,update(persist)方法是不行的，必须要用到merge方法才可以的&lt;/span&gt;
&lt;span&gt;        em1.merge(c);
        tx1.commit();
        em1.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、 JPA中实体一对多映射配置及操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.1 一对多实体类注解编写&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户实体类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.Kevin.domain;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.CascadeType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Column;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.FetchType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GenerationType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.OneToMany;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Table;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的实体类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Kevin
 * 使用的注解都是JPA规范，所以导包要导入javax.persistence包下
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Entity      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表情该类是一个实体类&lt;/span&gt;
@Table(name=&quot;cst_customer&quot;)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立当前类和数据库的对应关系&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Customer{
    @Id    &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;    @Column(name=&quot;cust_id&quot;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表明对应数据库的主键字段是cust_id&lt;/span&gt;
    @GeneratedValue(strategy=GenerationType.IDENTITY)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定主键生成策略,strategy:使用JPA中提供的主键生成策略，此属性是用不了；generator属性可以使用hibernate主键生成策略&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long cust_id;    
    
    @Column(name&lt;/span&gt;=&quot;cust_name&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_name;
    
    @Column(name&lt;/span&gt;=&quot;cust_address&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_address;
    
    @Column(name&lt;/span&gt;=&quot;cust_industry&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_industry;
    
    @Column(name&lt;/span&gt;=&quot;cust_level&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_level;
    
    
    @Column(name&lt;/span&gt;=&quot;cust_phone&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_phone;
    
    @Column(name&lt;/span&gt;=&quot;cust_mobile&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_mobile;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一对多关系映射：一个客户可以有多个联系人
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;targetEntity=Linkman.class  可以不写&lt;/span&gt;
    @OneToMany(targetEntity=Linkman.&lt;span&gt;class&lt;/span&gt;,mappedBy=&quot;customer&quot;,cascade=CascadeType.ALL,fetch=&lt;span&gt;FetchType.EAGER)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Set&amp;lt;Linkman&amp;gt; linkmans=&lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;Linkman&amp;gt;(0&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getCust_id() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_id(Long cust_id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_id =&lt;span&gt; cust_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_name() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_name(String cust_name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_name =&lt;span&gt; cust_name;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_address() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_address;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_address(String cust_address) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_address =&lt;span&gt; cust_address;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_industry() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_industry;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_industry(String cust_industry) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_industry =&lt;span&gt; cust_industry;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_level() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_level;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_level(String cust_level) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_level =&lt;span&gt; cust_level;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_phone() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_phone(String cust_phone) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_phone =&lt;span&gt; cust_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_mobile() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_mobile;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_mobile(String cust_mobile) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_mobile =&lt;span&gt; cust_mobile;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;Linkman&amp;gt;&lt;span&gt; getLinkmans() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; linkmans;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setLinkmans(Set&amp;lt;Linkman&amp;gt;&lt;span&gt; linkmans) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.linkmans =&lt;span&gt; linkmans;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Customer [cust_id=&quot; + cust_id + &quot;, cust_name=&quot; + cust_name + &quot;, cust_address=&quot; +&lt;span&gt; cust_address
                &lt;/span&gt;+ &quot;, cust_industry=&quot; + cust_industry + &quot;, cust_level=&quot; + cust_level + &quot;, cust_phone=&quot; +&lt;span&gt; cust_phone
                &lt;/span&gt;+ &quot;, cust_mobile=&quot; + cust_mobile + &quot;]&quot;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;联系人实体类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.Kevin.domain;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 创建联系人实体类
 *   `lkm_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '联系人编号(主键)',
  `lkm_name` varchar(16) DEFAULT NULL COMMENT '联系人姓名',
  `lkm_cust_id` bigint(32) NOT NULL COMMENT '客户id',
  `lkm_gender` char(1) DEFAULT NULL COMMENT '联系人性别',
  `lkm_phone` varchar(16) DEFAULT NULL COMMENT '联系人办公电话',
  `lkm_mobile` varchar(16) DEFAULT NULL COMMENT '联系人手机',
  `lkm_email` varchar(64) DEFAULT NULL COMMENT '联系人邮箱',
  `lkm_qq` varchar(16) DEFAULT NULL COMMENT '联系人qq',
  `lkm_position` varchar(16) DEFAULT NULL COMMENT '联系人职位',
  `lkm_memo` varchar(512) DEFAULT NULL COMMENT '联系人备注',
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.CascadeType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Column;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GenerationType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.JoinColumn;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.ManyToOne;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Table;

@Entity
@Table(name&lt;/span&gt;=&quot;cst_linkman&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Linkman &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    @Id
    @Column(name&lt;/span&gt;=&quot;lkm_id&quot;&lt;span&gt;)
    @GeneratedValue(strategy&lt;/span&gt;=&lt;span&gt;GenerationType.IDENTITY)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long lkm_id;
    @Column(name&lt;/span&gt;=&quot;lkm_name&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_name;
    @Column(name&lt;/span&gt;=&quot;lkm_gender&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_gender;
    @Column(name&lt;/span&gt;=&quot;lkm_mobile&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_mobile;
    @Column(name&lt;/span&gt;=&quot;lkm_phone&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_phone;
    @Column(name&lt;/span&gt;=&quot;lkm_email&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_email;
    @Column(name&lt;/span&gt;=&quot;lkm_qq&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_qq;
    @Column(name&lt;/span&gt;=&quot;lkm_position&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_position;
    @Column(name&lt;/span&gt;=&quot;lkm_memo&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lkm_memo;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一对多关系影射
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从表实体包含主表实体的对象引用&lt;/span&gt;
    @ManyToOne(targetEntity=Customer.&lt;span&gt;class&lt;/span&gt;,cascade=&lt;span&gt;CascadeType.ALL)
    @JoinColumn(name&lt;/span&gt;=&quot;lkm_cust_id&quot;,referencedColumnName=&quot;cust_id&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Customer customer;
    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getLkm_id() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_id(Long lkm_id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_id =&lt;span&gt; lkm_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_name() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_name(String lkm_name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_name =&lt;span&gt; lkm_name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_gender() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_gender;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_gender(String lkm_gender) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_gender =&lt;span&gt; lkm_gender;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_mobile() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_mobile;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_mobile(String lkm_mobile) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_mobile =&lt;span&gt; lkm_mobile;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_phone() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_phone(String lkm_phone) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_phone =&lt;span&gt; lkm_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_email() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_email;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_email(String lkm_email) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_email =&lt;span&gt; lkm_email;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_qq() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_qq;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_qq(String lkm_qq) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_qq =&lt;span&gt; lkm_qq;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_position() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_position;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_position(String lkm_position) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_position =&lt;span&gt; lkm_position;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLkm_memo() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lkm_memo;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLkm_memo(String lkm_memo) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lkm_memo =&lt;span&gt; lkm_memo;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Customer getCustomer() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; customer;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomer(Customer customer) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customer =&lt;span&gt; customer;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Linkman [lkm_id=&quot; + lkm_id + &quot;, lkm_name=&quot; + lkm_name + &quot;, lkm_gender=&quot; + lkm_gender + &quot;, lkm_mobile=&quot;
                + lkm_mobile + &quot;, lkm_phone=&quot; + lkm_phone + &quot;, lkm_email=&quot; + lkm_email + &quot;, lkm_qq=&quot; +&lt;span&gt; lkm_qq
                &lt;/span&gt;+ &quot;, lkm_position=&quot; + lkm_position + &quot;, lkm_memo=&quot; + lkm_memo + &quot;]&quot;&lt;span&gt;;
    }
    
    

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.2 一对多关联关系的相关操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.2.1 保存操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存操作
     *         创建一个客户和一个联系人
     *         建立客户和联系人的双向关联关系
     *         先保存客户，在保存联系人
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        Customer c&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
        c.setCust_name(&lt;/span&gt;&quot;Kevin_one2many&quot;&lt;span&gt;);
        Linkman lkm&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Linkman();
        lkm.setLkm_name(&lt;/span&gt;&quot;Kevin_onw2many&quot;&lt;span&gt;);
        
        c.getLinkmans().add(lkm);
        lkm.setCustomer(c);
        
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        em.persist(c);
        em.persist(lkm);
        tx.commit();
        em.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.2.2 更新操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　此时需要配置级联操作：要级联操作哪一方就应该在那一方的上边进行注解配置cascade=CsacadeType.PERSIST属性，即保存或者更新客户的同时保存联系人,但时cascade=CsacadeType.PERSIST只是级联更新。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505221051323-627908734.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;其中mappedBy是映射来自，相当于inverse，即主表不在关心从表的信息，让联系人去维护&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新操作
     * 创建一个联系人
     * 查询id为*客户
     * 为该客户分配该联系人
     * 更新客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){
        Linkman lkm&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Linkman();
        lkm.setLkm_name(&lt;/span&gt;&quot;Kevin_onw2many3&quot;&lt;span&gt;);
        
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        Customer c&lt;/span&gt;=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 7l&lt;span&gt;);
        
        c.getLinkmans().add(lkm);
        lkm.setCustomer(c);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;em.merge(c);        &lt;/span&gt;
&lt;span&gt;        tx.commit();
        em.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.2.3 删除操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　删除主表：若在客户上边配置了放弃维护，即mappedBy=&quot;customer&quot;,直接删除指标会报错，若此时还想要删除的话，需要配置cascade=CascadeType.DELET或者cascade=CascadeType.ALL就可以删除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505221824778-1761227308.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;需要注意的是：联系人（从表）也可以配置cascade=CascadeType.ALL来进行操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除操作
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        Customer c&lt;/span&gt;=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 6l&lt;span&gt;);
        em.remove(c);
        
        tx.commit();
        em.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.2.4 查询操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　JPA中也可以使用对象导航查询，也可以设置查询的时机。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;延迟加载的特点：真正用到该对象的时候才开始查询改对象的属性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果是立即加载，需要在Customer的set集合的注解中加入下边的语句：fetch=FetchType.&lt;em&gt;EAGER，&lt;/em&gt;如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505221622048-1467928226.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其原理是利用了左外连接查询的方式实现了立即加载。没写是EAGER，即默认是EAGER。LinkMan中也可是设置成立即加载。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　mappedBy是映射来自，相当于inverse，即主表不在关心从表的信息，让联系人去维护。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据客户查询联系人&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询id为7的客户&lt;/span&gt;
        Customer c=em.find(Customer.&lt;span&gt;class&lt;/span&gt;, 7l&lt;span&gt;);
        System.out.println(c);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询当前客户下的联系人&lt;/span&gt;
        Set&amp;lt;Linkman&amp;gt; linkmans=&lt;span&gt;c.getLinkmans();
        System.out.println(linkmans);
        tx.commit();
        em.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据联系人查询客户&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询id为7的客户&lt;/span&gt;
        Linkman lkm=em.find(Linkman.&lt;span&gt;class&lt;/span&gt;, 4l&lt;span&gt;);
        System.out.println(lkm);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询当前客户下的联系人&lt;/span&gt;
        Customer c=&lt;span&gt;lkm.getCustomer();
        System.out.println(c);
        tx.commit();
        em.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、 JPA中实体多对多映射配置及操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.1 多对多的实体类注解编写&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在角色实体对象中，如果配置了中间表的表名和在中间表中的列明，则在另外多的一方中只需要配置@ManyToMany(mappedBy=&quot;users&quot;)，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505222014808-1313269583.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哪一方写mappedBy哪一方就不在关心创建中间表了，即让另外一方不在关心创建中间表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户实体类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.Kevin.domain;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 用户实体类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.CascadeType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Column;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GenerationType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.ManyToMany;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Table;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.annotations.GenericGenerator;

@Entity
@Table(name&lt;/span&gt;=&quot;sys_user&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SysUser &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    @Id
    @Column(name&lt;/span&gt;=&quot;user_id&quot;&lt;span&gt;)
    @GenericGenerator(name&lt;/span&gt;=&quot;uuid&quot;,strategy=&quot;uuid&quot;&lt;span&gt;)
    @GeneratedValue(generator&lt;/span&gt;=&quot;uuid&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userId;
    
    @Column(name&lt;/span&gt;=&quot;user_name&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userName;
    
    @Column(name&lt;/span&gt;=&quot;user_password&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userPassword;
    
    @Column(name&lt;/span&gt;=&quot;user_state&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer userState;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多对多关系映射：&lt;/span&gt;
    @ManyToMany(mappedBy=&quot;users&quot;,cascade=&lt;span&gt;CascadeType.ALL)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Set&amp;lt;SysRole&amp;gt; roles=&lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;SysRole&amp;gt;(0&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;SysRole&amp;gt;&lt;span&gt; getRoles() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; roles;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setRoles(Set&amp;lt;SysRole&amp;gt;&lt;span&gt; roles) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roles =&lt;span&gt; roles;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUserId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userId;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserId(String userId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userId =&lt;span&gt; userId;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUserName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserName(String userName) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userName =&lt;span&gt; userName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUserPassword() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userPassword;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserPassword(String userPassword) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userPassword =&lt;span&gt; userPassword;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getUserState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userState;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserState(Integer userState) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userState =&lt;span&gt; userState;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;SysUser [userId=&quot; + userId + &quot;, userName=&quot; + userName + &quot;, userPassword=&quot; +&lt;span&gt; userPassword
                &lt;/span&gt;+ &quot;, userState=&quot; + userState + &quot;]&quot;&lt;span&gt;;
    }
    

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;角色实体类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.Kevin.domain;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 角色的实体类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.CascadeType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Column;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GenerationType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.JoinColumn;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.JoinTable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.ManyToMany;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Table;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.annotations.GenericGenerator;

@Entity
@Table(name&lt;/span&gt;=&quot;sys_role&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SysRole &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    @Id
    @Column(name&lt;/span&gt;=&quot;role_id&quot;&lt;span&gt;)
    @GenericGenerator(name&lt;/span&gt;=&quot;uuid&quot;,strategy=&quot;uuid&quot;)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个主键生成器,name：给生成器起名;strategy:指定的是hibernate中包含的生成策略&lt;/span&gt;
    @GeneratedValue(generator=&quot;uuid&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String roleId;
    
    @Column(name&lt;/span&gt;=&quot;role_name&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String roleName;
    
    @Column(name&lt;/span&gt;=&quot;role_memo&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String roleMemo;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多对多关系映射：一个角色可以赋予多个用户&lt;/span&gt;
    @ManyToMany(cascade=&lt;span&gt;CascadeType.ALL)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入一张表&lt;/span&gt;
    @JoinTable(name=&quot;user_role_ref&quot;,joinColumns={@JoinColumn(name=&quot;role_id&quot;,referencedColumnName=&quot;role_id&quot;)},    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写的是当前实体在中间表的外键字段&lt;/span&gt;
                inverseJoinColumns={@JoinColumn(name=&quot;user_id&quot;,referencedColumnName=&quot;user_id&quot;)}        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写的是对方实体在中间表的外键字段&lt;/span&gt;
&lt;span&gt;                )
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Set&amp;lt;SysUser&amp;gt; users=&lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;SysUser&amp;gt;(0&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;SysUser&amp;gt;&lt;span&gt; getUsers() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; users;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUsers(Set&amp;lt;SysUser&amp;gt;&lt;span&gt; users) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.users =&lt;span&gt; users;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getRoleId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; roleId;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRoleId(String roleId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roleId =&lt;span&gt; roleId;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getRoleName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; roleName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRoleName(String roleName) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roleName =&lt;span&gt; roleName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getRoleMemo() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; roleMemo;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRoleMemo(String roleMemo) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roleMemo =&lt;span&gt; roleMemo;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;SysRole [roleId=&quot; + roleId + &quot;, roleName=&quot; + roleName + &quot;, roleMemo=&quot; + roleMemo + &quot;]&quot;&lt;span&gt;;
    }
    

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.2 多对多关联关系的相关操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.2.1 一般保存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存操作
     *         创建2个用户，3个角色
     *         让1号用户具备1、2号角色    
     *         让2号用户具备2、3号角色
     *         保存用户和角色
     * 正常保存        
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        SysUser u1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysUser();
        SysUser u2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysUser();
        u1.setUserName(&lt;/span&gt;&quot;JPA u1&quot;&lt;span&gt;);
        u2.setUserName(&lt;/span&gt;&quot;JPA u2&quot;&lt;span&gt;);
        SysRole r1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysRole();
        SysRole r2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysRole();
        SysRole r3&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysRole();
        r1.setRoleName(&lt;/span&gt;&quot;JPA r1&quot;&lt;span&gt;);
        r2.setRoleName(&lt;/span&gt;&quot;JPA r2&quot;&lt;span&gt;);
        r3.setRoleName(&lt;/span&gt;&quot;JPA r3&quot;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立用户和角色的关联关系&lt;/span&gt;
&lt;span&gt;        u1.getRoles().add(r1);
        u1.getRoles().add(r2);
        u2.getRoles().add(r2);
        u2.getRoles().add(r3);
        
        r1.getUsers().add(u1);
        r2.getUsers().add(u2);
        r2.getUsers().add(u1);
        r3.getUsers().add(u2);
        
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        
        em.persist(u1);
        em.persist(u2);
        em.persist(r1);
        em.persist(r2);
        em.persist(r3);
        tx.commit();
        em.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.2.2 级联保存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　级联操作是指&lt;span&gt;当主控方执行保存、更新或者删除操作时，其关联对象(被控方)也执行相同的操作&lt;/span&gt;。在映射文件中通过对 cascade属性的设置来控制是否对关联对象采用级联操作，级联操作对各种关联关系都是有效的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在JPA的多对多关联关系中中只需设置一方的级联保存属性即可，本文中以用户为例，实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505215544868-1348436485.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编写测试代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt;级联保存&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){
        SysUser u1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysUser();
        SysUser u2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysUser();
        u1.setUserName(&lt;/span&gt;&quot;JPA u1&quot;&lt;span&gt;);
        u2.setUserName(&lt;/span&gt;&quot;JPA u2&quot;&lt;span&gt;);
        SysRole r1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysRole();
        SysRole r2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysRole();
        SysRole r3&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SysRole();
        r1.setRoleName(&lt;/span&gt;&quot;JPA r1&quot;&lt;span&gt;);
        r2.setRoleName(&lt;/span&gt;&quot;JPA r2&quot;&lt;span&gt;);
        r3.setRoleName(&lt;/span&gt;&quot;JPA r3&quot;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立用户和角色的关联关系&lt;/span&gt;
&lt;span&gt;        u1.getRoles().add(r1);
        u1.getRoles().add(r2);
        u2.getRoles().add(r2);
        u2.getRoles().add(r3);
        
        r1.getUsers().add(u1);
        r2.getUsers().add(u2);
        r2.getUsers().add(u1);
        r3.getUsers().add(u2);
        
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        
        em.persist(u1);
        tx.commit();
        em.close();        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 5.2.3 删除操作（禁用级联删除）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除操作
     *         双向级联删除：不管是在JPA还是hibernate，多对多中都禁止使用 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){
        EntityManager em&lt;/span&gt;=&lt;span&gt;JPAUtil.creatEntityManager();
        EntityTransaction tx&lt;/span&gt;=&lt;span&gt;em.getTransaction();
        tx.begin();
        SysUser user&lt;/span&gt;=em.find(SysUser.&lt;span&gt;class&lt;/span&gt;, &quot;402881ea632f00cf01632f00e6550000&quot;&lt;span&gt;);
        em.remove(user);
        tx.commit();
        em.close();    
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、JPA的c3p0连接池操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先需要导入c3p0的JAR包，而且要在配置文件里面协商c3p0的供应商，如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375044/201805/1375044-20180505223411806-1763069432.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果要从JPA中得到Session对象的话，需要对EntityManager进行unwrap()操作（解包装），就可以得到Session对象，而且用doWork()方法可以得到Connection对象，可以对它进行操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 验证c3p0是否连接成功
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取JPA中的操作对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;JPAUtil.createEntityManager();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取session&lt;/span&gt;
        Session session=em.unwrap(Session.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行session的doWork方法&lt;/span&gt;
        session.doWork(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Work() {
            
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; execute(Connection conn) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;                System.out.println(conn.getClass().getName());
            }
        });
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;七、JPA中的单线程使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;手动编写代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.Kevin.utils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.EntityManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.EntityManagerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Persistence;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * JPA的工具类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Kevin
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JPAUtil {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于SessionFactory&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; EntityManagerFactory factory;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;EntityManager&amp;gt;&lt;span&gt; tl;
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        factory&lt;/span&gt;=Persistence.createEntityManagerFactory(&quot;myJPAUnit&quot;&lt;span&gt;);
        tl&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;EntityManager&amp;gt;&lt;span&gt;();
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取EntityManager对象
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; EntityManager createEntityManager(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从当前线程上获取EntityManager对象&lt;/span&gt;
        EntityManager em=&lt;span&gt;tl.get();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(em==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            em&lt;/span&gt;=&lt;span&gt;factory.createEntityManager();
            tl.set(em);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tl.get();        
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[]args){
        createEntityManager();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){
        EntityManager em1&lt;/span&gt;=&lt;span&gt;JPAUtil.createEntityManager();
        EntityManager em2&lt;/span&gt;=&lt;span&gt;JPAUtil.createEntityManager();
        System.out.println(em1&lt;/span&gt;==&lt;span&gt;em2);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;八、在JPA中用Hibernate的方式进行CRUD操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　配置文件的写法和实体类的创建和普通的JPA是一样的，可以参考第三部分的入门案例，此处演示也仅作单表演示，夺标操作类似。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.1 保存操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存操作
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        Customer c&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
        c.setCust_name(&lt;/span&gt;&quot;Kevin&quot;&lt;span&gt;);
        
        Session s&lt;/span&gt;=&lt;span&gt;HibernateUtil.getCurrentSession();
        Transaction tx&lt;/span&gt;=&lt;span&gt;s.beginTransaction();
        s.save(c);
        tx.commit();
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.2 查询操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询一个客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){
        Session s&lt;/span&gt;=&lt;span&gt;HibernateUtil.getCurrentSession();
        Transaction tx&lt;/span&gt;=&lt;span&gt;s.beginTransaction();
        Customer c&lt;/span&gt;=s.get(Customer.&lt;span&gt;class&lt;/span&gt;, 1l&lt;span&gt;);
        System.out.println(c);
        tx.commit();
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.3 更新操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 修改一个客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){
        Session s&lt;/span&gt;=&lt;span&gt;HibernateUtil.getCurrentSession();
        Transaction tx&lt;/span&gt;=&lt;span&gt;s.beginTransaction();
        Customer c&lt;/span&gt;=s.get(Customer.&lt;span&gt;class&lt;/span&gt;, 1l&lt;span&gt;);
        c.setCust_source(&lt;/span&gt;&quot;China&quot;&lt;span&gt;);
        s.update(c);
        tx.commit();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test4(){
        Session s&lt;/span&gt;=&lt;span&gt;HibernateUtil.getCurrentSession();
        Transaction tx&lt;/span&gt;=&lt;span&gt;s.beginTransaction();
        Customer c&lt;/span&gt;=s.get(Customer.&lt;span&gt;class&lt;/span&gt;, 1l&lt;span&gt;);
        c.setCust_source(&lt;/span&gt;&quot;America&quot;&lt;span&gt;);
        tx.commit();        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;快照机制自动更新&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.4 删除操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除操作&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test5(){
        Session s&lt;/span&gt;=&lt;span&gt;HibernateUtil.getCurrentSession();
        Transaction tx&lt;/span&gt;=&lt;span&gt;s.beginTransaction();
        Customer c&lt;/span&gt;=s.get(Customer.&lt;span&gt;class&lt;/span&gt;, 2l&lt;span&gt;);
        s.delete(c);
        tx.commit();        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;快照机制自动更新&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 05 May 2018 14:28:00 +0000</pubDate>
<dc:creator>Kevin.ZhangCG</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Kevin-ZhangCG/p/8996491.html</dc:identifier>
</item>
<item>
<title>17.QT-事件处理分析、事件过滤器、拖放事件 - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8996425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8996425.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;Qt事件处理介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Qt平台会将系统产生的消息转换为&lt;span&gt;&lt;strong&gt;Qt事件&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Qt事件是一个&lt;span&gt;&lt;strong&gt;QEvent的对象&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Qt事件用来描述程序内部或外部发生的动作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;任意的QObject对象都&lt;span&gt;&lt;strong&gt;具备事件处理&lt;/strong&gt;&lt;/span&gt;的能力&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Qt常见的事件继承图如下:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201805/1182576-20180505214521401-207229066.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;QInputEvent:&lt;/strong&gt;&lt;/span&gt;用户输入事件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;QDropEvent:&lt;/strong&gt;&lt;/span&gt;用户拖放事件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;QPaintEvent:&lt;/strong&gt;&lt;/span&gt;描述操作系统绘制GUI动作的事件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;QCloseEvent:&lt;/strong&gt;&lt;/span&gt;用户关闭窗口事件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;QTimerEvent:&lt;/strong&gt;&lt;/span&gt;计时器事件&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;事件处理方式顺序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.Qt事件产生后立即被&lt;strong&gt;&lt;span&gt;分发到QWidget对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.QWidget中的&lt;span&gt;&lt;strong&gt;event(QEvent*)&lt;/strong&gt;&lt;/span&gt;进行事件处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.event()根据事件类型&lt;span&gt;&lt;strong&gt;调用不同的事件处理函数&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.在事件处理函数中&lt;span&gt;&lt;strong&gt;发送&lt;/strong&gt;&lt;strong&gt;Qt&lt;/strong&gt;&lt;strong&gt;中预定义的信号&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.&lt;span&gt;&lt;strong&gt;调用信号关联的槽函数&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;以按钮点击为例,如下图所示:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201805/1182576-20180505214531347-1037688900.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;QPushButton&lt;/strong&gt;&lt;strong&gt;事件处理总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.当点击按钮后,将会触发&lt;span&gt;&lt;strong&gt;鼠标事件&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.调用&lt;span&gt;&lt;strong&gt;event(QEvent*)&lt;/strong&gt;&lt;/span&gt;成员函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.调用&lt;span&gt;&lt;strong&gt;mouseReleaseEvent(QMouseEvent*)&lt;/strong&gt;&lt;/span&gt;成员函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.调用&lt;span&gt;&lt;strong&gt;click()&lt;/strong&gt;&lt;/span&gt;成员函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.触发信号&lt;span&gt;&lt;strong&gt;SIGNAL(clicked())&lt;/strong&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;同样,当用户点击窗口的关闭按钮时,也会触发closeEvent()事件函数,该函数需要重写,才能实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参考示例:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; void&lt;/span&gt; MainWindow::closeEvent(QCloseEvent *&lt;span&gt;event&lt;/span&gt;&lt;span&gt;)
{
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (maybeSave())                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果还有需要保存的数据&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    {
         writeSettings();
         &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;-&amp;gt;&lt;span&gt;accept();
    } &lt;br/&gt;&lt;/span&gt;&lt;span&gt;     else&lt;/span&gt;                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消关闭窗口&lt;/span&gt;
    {
         &lt;span&gt;event&lt;/span&gt;-&amp;gt;&lt;span&gt;ignore();
    }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;类似的还有keyEvent()获取键盘事件函数, keyReleaseEvent()键盘按下事件函数,&lt;/span&gt;&lt;span&gt;enterEvent光标进入组件事件函数, leaveEvent光标离开组件事件函数等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;其中QCloseEvent继承与QEvent,在QEvent中常用成员函数有&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;  accept ();    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收者处理当前事件&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt;  ignore ();    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收者忽略当前事件,忽略后,事件可能传递给父组件&lt;/span&gt;

&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isAccepted();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断当前事件是否被处理过 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;当使用ignore()&lt;/strong&gt;&lt;strong&gt;处理事件时,&lt;/strong&gt;&lt;strong&gt;该事件可能会传递给其父组件对象继续处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤如下:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;写两个类: &lt;span&gt;&lt;strong&gt;QMyWidget、QMyLineEdit&lt;/strong&gt;&lt;/span&gt;(QMyLineEdit是QMyWidget的类成员)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过QMyLineEdit来重写LineEdit的&lt;span&gt;&lt;strong&gt;keyReleaseEvent()&lt;/strong&gt;&lt;/span&gt;键盘按下事件函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过QMyWidget来重写QWidget的&lt;span&gt;&lt;strong&gt;keyReleaseEvent()&lt;/strong&gt;&lt;/span&gt;键盘按下事件函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;然后通过&lt;span&gt;&lt;strong&gt;ignore()&lt;/strong&gt;&lt;/span&gt;处理QMyLineEdit的keyReleaseEvent()事件函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;判断&lt;/strong&gt;&lt;/span&gt;是否会继续执行QMyWidget父组件的keyReleaseEvent()事件函数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QLineEdit.h如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef QMYLINEEDIT_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; QMYLINEEDIT_H&lt;span&gt;

#include &lt;/span&gt;&amp;lt;QLineEdit&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QtGui&amp;gt;

&lt;span&gt;class&lt;/span&gt; QMyLineEdit : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QLineEdit
{
    Q_OBJECT

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;explicit&lt;/span&gt; QMyLineEdit(QWidget *parent = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;  keyReleaseEvent( QKeyEvent * &lt;span&gt;event&lt;/span&gt;&lt;span&gt; );
};&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; QMYLINEEDIT_H&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QLineEdit.cpp如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QMyLineEdit.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

QMyLineEdit::QMyLineEdit(QWidget &lt;/span&gt;*&lt;span&gt;parent) :
    QLineEdit(parent)
{&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;  QMyLineEdit::keyReleaseEvent( QKeyEvent * &lt;span&gt;event&lt;/span&gt;&lt;span&gt; )
{
    qDebug()&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QMyLineEdit::keyReleaseEvent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    qDebug()&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key value:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;event&lt;/span&gt;-&amp;gt;&lt;span&gt;key();      
    &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;-&amp;gt;ignore();                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;忽略当前事件&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QMyWidget.h如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef QMYWIDGET_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; QMYWIDGET_H&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QMyLineEdit.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QWidget&amp;gt;

&lt;span&gt;class&lt;/span&gt; QMyWidget : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QWidget
{
    Q_OBJECT
    QMyLineEdit line;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;explicit&lt;/span&gt; QMyWidget(QWidget *parent = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;   keyReleaseEvent( QKeyEvent * &lt;span&gt;event&lt;/span&gt;&lt;span&gt; );

};

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; QMYWIDGET_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QMyWidget.cpp如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QMyWidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

QMyWidget::QMyWidget(QWidget &lt;/span&gt;*&lt;span&gt;parent) :
    QWidget(parent),
    line(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
{
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;  QMyWidget::keyReleaseEvent( QKeyEvent * &lt;span&gt;event&lt;/span&gt;&lt;span&gt; )
{
    qDebug()&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QMyWidget::keyReleaseEvent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    qDebug()&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key value:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;event&lt;/span&gt;-&amp;gt;&lt;span&gt;key();

    QWidget::keyPressEvent(&lt;/span&gt;&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;main()函数如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
        QApplication a(argc, argv);

        QMyWidget w;

        w.show();

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.exec();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;效果如下:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201805/1182576-20180505215346821-1769428314.gif&quot; alt=&quot;&quot; width=&quot;921&quot; height=&quot;496&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到成员调用了&lt;span&gt;&lt;strong&gt;event-&amp;gt;ignore()函数&lt;/strong&gt;&lt;/span&gt;忽略事件后,同样也会继续进入&lt;span&gt;&lt;strong&gt;QMyWidget类&lt;/strong&gt;&lt;/span&gt;处理事件 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Qt&lt;/strong&gt;&lt;strong&gt;中的事件过滤器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;事件过滤器可以对需要的组件接收到的事件进行过滤,以及监控&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;任意的&lt;span&gt;&lt;strong&gt;QObject对象&lt;/strong&gt;&lt;/span&gt;都可以作为事件过滤器使用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;事件过滤器的实现,需要重写&lt;span&gt;&lt;strong&gt;eventFilter()&lt;/strong&gt;&lt;/span&gt;函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;组件要想被监控,则需要通过&lt;span&gt;&lt;strong&gt;installEventFilter()&lt;/strong&gt;&lt;/span&gt;安装事件过滤器&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;事件过滤器能够决定是否将事件转发给组件对象,如下图所示:&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201805/1182576-20180505215831990-1458432516.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;230&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;eventFilter函数体如下所示:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt; QObject::eventFilter ( QObject * watched, QEvent * &lt;span&gt;event&lt;/span&gt;&lt;span&gt; );
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; watched:代表被监控的组件  event:代表要转发的事件
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回true,表示该事件也被过滤掉(处理),无需再转发了
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回false,则正常转发给watched&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考示例-&lt;/strong&gt;&lt;strong&gt;实现文本框只允许输入数字:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; MainWindow : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QMainWindow
 {
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
     MainWindow();

 &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
     &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; eventFilter(QObject *obj, QEvent *&lt;span&gt;ev);

 &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
     QTextEdit &lt;/span&gt;*&lt;span&gt;textEdit;
 };
&lt;br/&gt;MainWindow::MainWindow()
 {
     textEdit &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTextEdit;
     setCentralWidget(textEdit);
     textEdit&lt;/span&gt;-&amp;gt;setAttribute(Qt::WA_InputMethodEnabled, &lt;span&gt;false&lt;/span&gt;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;禁止中文输入法&lt;/span&gt;&lt;span&gt;
     textEdit&lt;/span&gt;-&amp;gt;installEventFilter(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
 }

 &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; MainWindow::eventFilter(QObject *obj, QEvent *&lt;span&gt;event&lt;/span&gt;&lt;span&gt;)
 {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj ==&lt;span&gt; textEdit)
     {
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;-&amp;gt;type() ==&lt;span&gt; QEvent::KeyPress)
         {
             QKeyEvent &lt;/span&gt;*keyEvent = static_cast&amp;lt;QKeyEvent*&amp;gt;(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);
             qDebug() &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ate key press&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; keyEvent-&amp;gt;&lt;span&gt;key();
             &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;(keyEvent-&amp;gt;key())         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只接受0~9数字&lt;/span&gt;&lt;span&gt;
             {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_0:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_1:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_2:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_3:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_4:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_5:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_6:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_7:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_8:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Qt::Key_9:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
         }
         &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
         {
             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
         }
     }
     &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
     {
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; QMainWindow::eventFilter(obj, &lt;span&gt;event&lt;/span&gt;&lt;span&gt;);
     }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;用户拖放事件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个QWidget对象都能处理拖放事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;常用的拖放事件相关函数有:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;  dragEnterEvent ( QDragEnterEvent * &lt;span&gt;event&lt;/span&gt; );  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拖事件处理函数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; dropEvent ( QDropEvent * &lt;span&gt;event&lt;/span&gt; ) ;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;放事件处理函数&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;拖放事件所处理的数据是QMimeData类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MIME类型常用处理函数如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201805/1182576-20180505220107600-1129683195.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;拖放事件的步骤如下:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt;在构造函数里通过&lt;span&gt;setAcceptDrops(true)&lt;/span&gt;函数,让该组件能接受拖放事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt;重写&lt;span&gt;dragEnterEvent(&lt;a href=&quot;file:///G:/QT/笔记/qdragenterevent.html&quot;&gt;&lt;span&gt;QDragEnterEvent&lt;/span&gt;&lt;/a&gt;* event)&lt;/span&gt;函数并判断MIME类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  如果是期待的类型,则调用event -&amp;gt;acceptProposedAction();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  否则调用 : event -&amp;gt;ignore();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.&lt;/strong&gt;重写&lt;span&gt;dropEvent()&lt;/span&gt;函数并判断MIME类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  如果是期待的类型,则获取MIME数据并处理.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  否则调用 : event -&amp;gt;ignore();&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; class&lt;/span&gt; MainWindow : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QMainWindow
 {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    QTextEdit &lt;/span&gt;*&lt;span&gt;textEdit;
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dragEnterEvent(QDragEnterEvent *&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dropEvent(QDropEvent *&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    MainWindow();
 };

 MainWindow::MainWindow()
 {
     textEdit &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTextEdit;
     setCentralWidget(textEdit);
     textEdit&lt;/span&gt;-&amp;gt;setAttribute(Qt::WA_InputMethodEnabled, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) ;
     textEdit&lt;/span&gt;-&amp;gt;installEventFilter(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;setAcceptDrops(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
 }

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MainWindow::dragEnterEvent(QDragEnterEvent *&lt;span&gt;event&lt;/span&gt;&lt;span&gt;)
{
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;-&amp;gt;mimeData()-&amp;gt;hasUrls())      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断拖的类型&lt;/span&gt;&lt;span&gt;
      {
            &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;-&amp;gt;&lt;span&gt;acceptProposedAction();
      }
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
      {
            &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;-&amp;gt;&lt;span&gt;ignore();
      }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MainWindow::dropEvent(QDropEvent *&lt;span&gt;event&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;-&amp;gt;mimeData()-&amp;gt;hasUrls())        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断放的类型&lt;/span&gt;&lt;span&gt;
    {
        textEdit&lt;/span&gt;-&amp;gt;&lt;span&gt;clear();
        QList&lt;/span&gt;&amp;lt;QUrl&amp;gt; List = &lt;span&gt;event&lt;/span&gt;-&amp;gt;mimeData()-&amp;gt;&lt;span&gt;urls();

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;List.length();i++&lt;span&gt;)
        {
            textEdit&lt;/span&gt;-&amp;gt;insertPlainText(List[i].toLocalFile()+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
          &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;-&amp;gt;&lt;span&gt;ignore();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;效果:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201805/1182576-20180505220234348-947825655.gif&quot; alt=&quot;&quot; width=&quot;803&quot; height=&quot;615&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 05 May 2018 14:12:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8996425.html</dc:identifier>
</item>
</channel>
</rss>