<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>mfc动态演示排序算法 - Hahallo</title>
<link>http://www.cnblogs.com/bigyang/p/9058588.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigyang/p/9058588.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;实现的排序算法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;冒泡排序、选择排序、快速排序&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;具体实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选用&lt;/span&gt;mfc&lt;span&gt;中的单文档框架&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;①&lt;span&gt;SetTimer&lt;/span&gt;&lt;span&gt;函数的用法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;②使用画笔画直线。&lt;/p&gt;
&lt;p&gt;③使用&lt;span&gt;FillSolidRect()&lt;/span&gt;&lt;span&gt;函数覆盖某一矩形区域内的内容；使用&lt;/span&gt;&lt;span&gt;TextOutW()&lt;/span&gt;&lt;span&gt;函数在某坐标位置输出字符串。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;效果截图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生成随机数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202131/201805/1202131-20180519003007860-892482365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择一种排序算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202131/201805/1202131-20180519003037951-997010689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加速减速暂停继续&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202131/201805/1202131-20180519003059464-520389655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;排序完成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202131/201805/1202131-20180519003115622-209533980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可到我的&lt;/span&gt;Github&lt;span&gt;获取源代码：&lt;/span&gt;&lt;a href=&quot;https://github.com/Hahallo/SortAlgorithmDisplay&quot;&gt;&lt;span&gt;https://github.com/Hahallo/SortAlgorithmDisplay&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 16:36:00 +0000</pubDate>
<dc:creator>Hahallo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigyang/p/9058588.html</dc:identifier>
</item>
<item>
<title>写个批处理脚本来帮忙干活--遍历文件夹&amp;字符串处理 - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/9058554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/9058554.html</guid>
<description>&lt;p&gt;这次打算写几篇关于脚本方面的博客，主要是记录一下 Gradle 脚本和批处理脚本的一些写法，方便后续查阅。&lt;/p&gt;

&lt;p&gt;平常开发过程中，一些较为重复的手工性工作，如果能让脚本来帮忙处理，自然是最好的，刚好之前有些工作有点过于重复且都是手工性去完成，所以就想着能否写个脚本来处理。&lt;/p&gt;
&lt;p&gt;因为我还是用的 windows 开发，所以最开始想到的就是批处理脚本，但写完后发现，重复性工作是可以交给脚本去处理了，但每次要执行这个脚本文件还得打开脚本所在的文件夹找到脚本点击去执行。&lt;/p&gt;
&lt;p&gt;emmm，因为我是开发 Android 的，电脑开机时 Android Stuido 就没关闭过，然后又想到 Gradle 的脚本可以直接通过 AS 来点击执行，这样一来，执行脚本，也就是敲代码过程中随手一个快捷键就搞定，简单、方便。&lt;/p&gt;
&lt;p&gt;所以，这篇就稍微来记录下批处理脚本和 Gradle 脚本的一些写法，很基础简单，因为我的需求就是执行 java 命令来对某个文件夹下的 apk 文件分别进行签名，而后输出新的命名方式的 apk 文件。&lt;/p&gt;
&lt;p&gt;所以，脚本涉及到的操作也就只是文件夹的遍历、字符串的处理、命令的执行这几个方面而已，后续有新接触再慢慢补充。&lt;/p&gt;

&lt;h3 id=&quot;遍历指定文件夹下的文件&quot;&gt;1. 遍历指定文件夹下的文件&lt;/h3&gt;
&lt;h5 id=&quot;命令解释&quot;&gt;1.1 命令解释&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;命令： &lt;code&gt;for [参数] %%变量名 in （匹配符） do （执行的命令）&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;切记：每个指令之间必须以空格隔开，in 与 ( 之间有空格，do 与 （ 间也有空格，否则命令会无法成功执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ps&lt;/strong&gt;：本节只讲用批处理脚本执行 for 命令遍历文件夹的场景，因此以下分析每个指令意义时，不介绍其他含义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[]&lt;/strong&gt;：表示此项指令为可选&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[参数]&lt;/strong&gt;：参数取值一共有四种： &lt;code&gt;/d, /r, /l, /f&lt;/code&gt;，加上无参数，所以一共五种场景&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无参：遍历当前路径的文件夹下的文件，但也可在&lt;code&gt;(匹配符)&lt;/code&gt;中指定路径&lt;/li&gt;
&lt;li&gt;/d：遍历当前路径的文件夹下的文件夹，但也可在&lt;code&gt;(匹配符)&lt;/code&gt;中指定路径&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;/r [路径]：深度遍历指定路径下的所有文件，子目录中的文件也会被遍历到，如果没指定路径，默认当前路径&lt;/li&gt;
&lt;li&gt;/l ：当使用参数 /l 时，需结合&lt;code&gt;(匹配符)&lt;/code&gt;一起使用，此时 &lt;code&gt;()&lt;/code&gt; 括号内部的用法规则为：&lt;code&gt;(start, step, end)&lt;/code&gt;，此时的 for 命令作用等同于 java 语言中的 for 语句&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;/f ：用于解析文件中的内容，本节不做介绍&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;%%变量名&lt;/strong&gt;：作用类似于 &lt;code&gt;for(int i = 0; ; )&lt;/code&gt; 中的 &lt;code&gt;int i = 0&lt;/code&gt;，有些区别点的就是，批处理的 for 循环遍历每一个子项时，&lt;code&gt;%%变量名&lt;/code&gt; &amp;lt;=&amp;gt; 每个子项，即 &lt;code&gt;&amp;amp;&amp;amp;变量名&lt;/code&gt; 已经是指向具体的每个子项了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（匹配符）&lt;/strong&gt;：在 in 指令之后 () 括号里的内容可表示为通配符，用于按照指定的规则过滤文件夹下的文件，如 (*.txt) 表示遍历文件夹内所有以 .txt 结尾的文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(执行的命令)&lt;/strong&gt;：前面的指令就可以取到文件夹内指定的每个子项了，那么接下去要对每个子项如何操作，就在这里写，类似于 java 的 for 命令后的 {} 大括号的作用&lt;/p&gt;
&lt;h5 id=&quot;使用示例&quot;&gt;1.2 使用示例&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-eca5e174e22b8170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;当前目录.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下示例基于上图中的文件路径，批处理脚本为 test.bat&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无参：&lt;code&gt;for %%i in (*) do ( echo %%i )&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-6f5d5efdef6356b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;for无参命令示例.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：遍历当前目录下的所有文件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无参指定路径：&lt;code&gt;for %%i in (c:\softwares\VisualBat\*.url) do ( echo %%i )&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-1ff92bc4da9354d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;for无参指定路径命令示例.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：遍历在&lt;code&gt;(匹配符)&lt;/code&gt;中指定路径下的以 .url 结尾的文件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;带参数 /d：&lt;code&gt;for /d %%i in (*) do ( echo %%i )&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-1a992c48a8a357e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;for参数d命令示例.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：遍历当前目录下所有的文件夹&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;带参数 /d 指定路径：&lt;code&gt;for /d %%i in (c:\softwares\VisualBat\*) do ( echo %%i )&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-b4b2cda8fd31b14f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;for参数d指定路径命令示例.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：遍历指定目录下的所有文件夹，%%i 指向每个子文件夹的绝对路径&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;带参数 /r ：&lt;code&gt;for /r %%i in (*.url) do ( echo %%i )&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-b829be8b50aed33c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;for参数r命令示例.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：深度遍历当前路径下所有以 .url 结尾的文件，因为是深度遍历，因此 %%i 指向文件的绝对路径&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;带参数 /r 指定路径：&lt;code&gt;for /r c:\softwares\VisualBat\ %%i in (*.url) do ( echo %%i )&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;效果：同上图&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;带参数 /l ：&lt;code&gt;for /l %%i in (1, 1, 5) do ( echo %%i )&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-dce7e6c8948d1893.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;for参数l命令示例.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：等效于 java 中的 &lt;code&gt;for (int i = 1; i &amp;lt;= 5; i++)&lt;/code&gt;语句，起始值，递增或递减，终止值都可自行设置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;带参数 /d /r：&lt;code&gt;for /d /r %%i in (*) do ( echo %%i )&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-bc68f937b6a38e91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;for参数dr命令示例.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：参数可结合使用，/d 表示遍历文件夹，/r 表示深度遍历，因此以上命令作用为深度遍历当前目录下的所有文件夹，包括子目录中的文件夹&lt;/p&gt;
&lt;h3 id=&quot;临时变量的使用&quot;&gt;2. 临时变量的使用&lt;/h3&gt;
&lt;h5 id=&quot;变量的基本用法&quot;&gt;2.1 变量的基本用法&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;命令：&lt;code&gt;set key=value&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;切记：&lt;code&gt;key=value&lt;/code&gt; 三者之间绝对不能出现空格，不能为了像遵守 java 风格擅自给添加上空格，这与 java 的 &lt;code&gt;int a = 1&lt;/code&gt; 声明变量不同，切记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量使用：%key%&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;@echo&lt;/span&gt; off
&lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;name=&lt;/span&gt;dasuAndroidTv
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %name%&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-3a3e2d4136a0a3b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;set命令示例.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：name 可当做临时变量使用，使用时需用 %% 将变量名括起来使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;局限&lt;/strong&gt;：不允许在 for 命令中类似上步中声明变量并直接使用，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;@echo&lt;/span&gt; off
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/l&lt;/span&gt; %%i in (0,1,5) &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;name=&lt;/span&gt;dasuAndroidTv
    &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %name%
&lt;span class=&quot;kw&quot;&gt;)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-50009febcf368685.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;set命令示例2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：在 for 命令中声明临时变量，并直接通过 %key% 方式使用时会出现上图中的错误：ECHO 处于关闭状态，但如果 &lt;code&gt;set key=value&lt;/code&gt; 临时变量的声明是放在 for 命令外部，for 命令内部只是使用的话，是可以的，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;@echo&lt;/span&gt; off
&lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;name=&lt;/span&gt;dasuAndroidTv
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/l&lt;/span&gt; %%i in (0,1,5) &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %name%
&lt;span class=&quot;kw&quot;&gt;)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-29cdda5c69c0f7ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;set命令示例3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：在 for 命令外部声明临时变量，for 命令内部只是使用，这种方式是允许的&lt;/p&gt;
&lt;h5 id=&quot;变量在-for-命令中的用法&quot;&gt;2.2 变量在 for 命令中的用法&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;提问：那么如果要在 for 命令中才声明临时变量，并使用的话，该如何做？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for 命令中临时变量的使用：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;需启用变量延迟功能，命令：&lt;code&gt;setlocal enabledelayedexpansion&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;for 命令中的临时变量使用时用 &lt;code&gt;!key!&lt;/code&gt; 感汉号括起来的形式代替 &lt;code&gt;%key%&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;理由：不清楚，google 来的解决方案，感兴趣想深入研究的自行搜索&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;@echo&lt;/span&gt; off
&lt;span class=&quot;kw&quot;&gt;setlocal&lt;/span&gt; enabledelayedexpansion
&lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;name=&lt;/span&gt;dasu
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/l&lt;/span&gt; %%i in (0, 1, 5) &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;name=&lt;/span&gt;dasuAndroidTv 
    &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; !name!
    &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %name%
&lt;span class=&quot;kw&quot;&gt;)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-156580c1ace9f6c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;set命令示例4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：说得白一点，在 for 命令中通过 %name% 方式使用的临时变量，取的 name 这个临时变量的值会一直是它在 for 命令外赋值的内容，即使在 for 命令中通过 set 命令对这个变量又重新赋值，也不会生效。&lt;/p&gt;
&lt;p&gt;那么，如果需要在 for 命令中通过 set 命令赋值后的临时变量能够马上拿来使用，需要两个步骤，一在文件开头启用变量延迟功能，命令：&lt;strong&gt;&lt;code&gt;setlocal enabledelayedexpansion&lt;/code&gt;&lt;/strong&gt;，二在 for 命令中通过 &lt;strong&gt;&lt;code&gt;!name!&lt;/code&gt;&lt;/strong&gt;方式来使用临时变量。&lt;/p&gt;
&lt;h3 id=&quot;字符串处理&quot;&gt;3. 字符串处理&lt;/h3&gt;
&lt;h5 id=&quot;截取&quot;&gt;3.1 截取&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;命令：&lt;code&gt;%key:~[start,num]%&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;：当 &lt;code&gt;%key%&lt;/code&gt; 中出现了 &lt;code&gt;:~&lt;/code&gt;，则表示要对 key 指向的这个字符串做截取操作，截取操作支持以下几种形式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;截取&lt;strong&gt;指定位置开始的 n 个字符串&lt;/strong&gt;：&lt;code&gt;%key:~0,4%&lt;/code&gt;，表示截取从下标 0 开始的之后 4 个字符&lt;/li&gt;
&lt;li&gt;截取从&lt;strong&gt;指定位置开始的整个字符串&lt;/strong&gt;：&lt;code&gt;%key:~4%&lt;/code&gt;，表示截取从下标为 4 开始的整个字符串&lt;/li&gt;
&lt;li&gt;截取&lt;strong&gt;通过倒数方式指定开始位置的整个字符串&lt;/strong&gt;：&lt;code&gt;%key:~-2%&lt;/code&gt;，表示截取从倒数第 2 个字符开始的整个字符串&lt;/li&gt;
&lt;li&gt;截取&lt;strong&gt;通过倒数方式指定位置开始之后的 n 个字符串&lt;/strong&gt;：&lt;code&gt;%key:-4,2%&lt;/code&gt;，表示截取从倒数第 4 个字符开始的 2 个字符&lt;/li&gt;
&lt;li&gt;正数倒数方式相结合：&lt;code&gt;%key:~2,-2%&lt;/code&gt;，表示截取从下标 2 开始到倒数第 2 个之间的字符串&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;@echo&lt;/span&gt; off
&lt;span class=&quot;kw&quot;&gt;rem&lt;/span&gt; (rem表示后面是注释的内容，类似于 java //)原始字符串
&lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;name=&lt;/span&gt;dasuAndroidTv

&lt;span class=&quot;kw&quot;&gt;rem&lt;/span&gt; 注释内容：表示截取从下标 0 开始的之后 4 个字符，输出 dasu
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %name:~0,4%

&lt;span class=&quot;kw&quot;&gt;rem&lt;/span&gt; 注释内容：表示截取从下标为 4 开始的整个字符串，输出 AndroidTv
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %name:~4%  

&lt;span class=&quot;kw&quot;&gt;rem&lt;/span&gt; 注释内容：表示截取从倒数第 2 个字符开始的整个字符串，输出 Tv
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %name:~-2%

&lt;span class=&quot;kw&quot;&gt;rem&lt;/span&gt; 注释内容：表示截取从倒数第 4 个字符开始的 2 个字符，输出 Android
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %name:~4,-2%

&lt;span class=&quot;kw&quot;&gt;rem&lt;/span&gt; 注释内容：表示截取从下标 2 开始到倒数第 2 个之间的字符串，输出 id
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %name:~-4,2%&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-f6b658833dc648fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;字符串截取命令示例.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;拼接&quot;&gt;3.2 拼接&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;命令：&lt;code&gt;%key1%%key2%&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;：将要拼接的那个字符串直接跟在被拼接的后面即可，不需要任何拼接操作符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;@echo&lt;/span&gt; off
&lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;name1=&lt;/span&gt;dasu
&lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;name2=&lt;/span&gt;AndroidTv
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %name1%%name2%  
&lt;span class=&quot;kw&quot;&gt;rem&lt;/span&gt; 这里是注释内容：输出 dasuAndroidTv&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-72430aab40b696bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;字符串截取命令示例2.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;替换&quot;&gt;3.3 替换&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;命令：&lt;code&gt;%key:被替换字符串=替换的字符串%&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;：不解释了，直接看示例，很容易明白&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;@echo&lt;/span&gt; off
&lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;name=&lt;/span&gt;whoAndroidTv
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %name:who=dasu%
&lt;span class=&quot;kw&quot;&gt;rem&lt;/span&gt; 这里是注释内容：输出 dasuAndroid&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-9e759e6969d34134.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;字符串替换命令示例.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;文件特殊操作&quot;&gt;3.4 文件特殊操作&lt;/h5&gt;
&lt;p&gt;如果是在 for 命令中遍历了某个文件夹下的文件，那么此时可以通过一些特殊命令来获取这个文件的各种信息，直接看示例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;@echo&lt;/span&gt; off
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;%%i&lt;/span&gt; in (*.txt) &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;(&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %%i
   &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %%~fi
   &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %%~di
   &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %%~pi
   &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %%~ni
   &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %%~xi
   
   &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %%~ti
   &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; %%~zi
&lt;span class=&quot;kw&quot;&gt;)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-b2f30fecb4518db5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;特殊命令示例.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解释： 在通过 for 命令遍历文件时，%%i 根据不同的 for 使用方式，内容也有所不同，具体见第 1 节。在上述这种用法下，%%i 指向了当前目录下每个文件名，完整的文件名。&lt;/p&gt;
&lt;p&gt;那么，此时就可以通过一些特殊命令来取得文件的相关信息，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;%%~fi&lt;/strong&gt;：表示获取该文件的绝对路径信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%%~di&lt;/strong&gt;：表示获取该文件所在的盘符&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%%~pi&lt;/strong&gt;：表示获取该文件的路径，不包含盘符的信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%%~ni&lt;/strong&gt;：表示获取该文件的文件名，不包含扩展名信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%%~xi&lt;/strong&gt;：表示获取该文件的扩展名&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%%~ti&lt;/strong&gt;：表示获取该文件的上次修改时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%%~zi&lt;/strong&gt;：表示获取该文件的大小&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;完整示例&quot;&gt;4. 完整示例&lt;/h3&gt;
&lt;p&gt;最后，我们来个具体场景，将本篇所学的知识用上一遍，巩固一下。&lt;/p&gt;
&lt;p&gt;场景：遍历指定路径目录下的所有 apk 文件，并通过一个 sign.jar 文件，分别对每个 apk 文件执行 java 命令来进行签名工作，sign.jar 接收两个参数，一个是需要签名的 apk，另外一个为输出的 apk，要求签名后的 apk 命名方式为将原文件名中的 unsign 替换成 google，并输出在跟 apk 同一个目录内即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-a19e2d07e083c304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;完整示例.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;apk 路径：c:\users\suxq\desktop\outputs&lt;/p&gt;
&lt;p&gt;sign.jar 路径：c:\users\suxq\desktop&lt;/p&gt;
&lt;p&gt;java 签名命令示例(要求 sign.jar 和 apk 文件都在同一路径下，即可用如下命令)：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java -jar sign.jar meizi_1_3_0_debug_unsign.apk meizi_1_3_0_debug_google.apk&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;批处理脚本代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;@echo&lt;/span&gt; off
&lt;span class=&quot;kw&quot;&gt;setlocal&lt;/span&gt; enabledelayedexpansion

&lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;sign=&lt;/span&gt;c:\&lt;span class=&quot;kw&quot;&gt;users&lt;/span&gt;\suxq\desktop\sign.jar
&lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;apkPath=&lt;/span&gt;c:\&lt;span class=&quot;kw&quot;&gt;users&lt;/span&gt;\suxq\desktop\outputs\

for %%i in (%apkPath%*.apk) &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;oldApk=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;%%&lt;/span&gt;~nxi
    &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;outApk=&lt;/span&gt;!&lt;span class=&quot;kw&quot;&gt;oldApk&lt;/span&gt;:unsign=google!
    &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; java -jar %sign% !oldApk! !outApk!
    &lt;span class=&quot;kw&quot;&gt;rem&lt;/span&gt; 这里是注释内容：由于 apk 文件 和 sign.jar 文件都是虚拟的，因此真正执行时会报错，这里就只是将 java 整句命令输出，从整句命令就可以确认是否会正确执行，如果这些文件都是真的话。真的脚本应该将 echo 去掉
&lt;span class=&quot;kw&quot;&gt;)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-b267d226fbc883ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;完整示例2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：完美~&lt;/p&gt;
&lt;p&gt;首先，遍历指定目录下的文件达到了，而且可以对文件名字符串进行处理，替换其中一些值，最后，可以根据指定位置的 sign.jar 文件，通过 java 命令来执行签名工作。&lt;/p&gt;
&lt;p&gt;这个场景，刚好把我们今天学的关于批处理的遍历文件夹操作、临时变量使用、字符串的处理三者都包括在内，感兴趣的也去试试看吧~&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-35fed4659c556352.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;QQ图片20180316094923.jpg&quot;/&gt;&lt;br/&gt;最近（2018-03）刚开通了公众号，想激励自己坚持写作下去，初期主要分享原创的Android或Android-Tv方面的小知识，准备可能还有点不足，感兴趣的可以先点一波关注，谢谢支持~~&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 16:17:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/9058554.html</dc:identifier>
</item>
<item>
<title>react-生命周期 - wyao</title>
<link>http://www.cnblogs.com/nordon-wang/p/9058550.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nordon-wang/p/9058550.html</guid>
<description>&lt;ul&gt;&lt;li&gt;通过三种当时获取表单的数据&lt;/li&gt;
&lt;li&gt;包含表单的组件分类&lt;/li&gt;
&lt;li&gt;受控组件：表单项输入数据能够自动收集成状态，案例中的age字段&lt;/li&gt;
&lt;li&gt;非受控组件：需要时才手动读取表单输入框中的数据，案例中的username和password字段&lt;/li&gt;
&lt;li&gt;大部分推荐使用&lt;code&gt;受控组件&lt;/code&gt;，因为其更符合react的思想，不需要进行DOM的操作，而且react也不推荐过多的使用refs&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Login &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt;(props)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(props)

        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;18&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;handleSubmit&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;handleSubmit&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;bind&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;handleChange&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;handleChange&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;bind&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;handleSubmit&lt;/span&gt;(event)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;preventDefault&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 通过旧的refs获取username&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; username &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;refs&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;username&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 通过新的refs获取username&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; pwd &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;pwd&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 通过状态获取age&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;age&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt;

        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(username&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;pwd&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;age)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;handleChange&lt;/span&gt;(event)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 由于原生的onchange事件并不是真的在change时触发事件，而是在失去焦点的时候才会触发change事件&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// react在onChange事件做了优化，会在change的时候就触发事件&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; age &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            age
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)

    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;render&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; (
            &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;form action&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt; method&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;get&quot;&lt;/span&gt; onSubmit&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;handleSubmit&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;input type&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text&quot;&lt;/span&gt; ref&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            &amp;lt;/p&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;input type&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt; ref&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;input &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;pwd&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; input&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            &amp;lt;/p&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;input type&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;number&quot;&lt;/span&gt; value&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; onChange&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;handleChange&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            &amp;lt;/p&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;input type&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;submit&quot;&lt;/span&gt; value&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;login&quot;&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            &amp;lt;/p&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/form&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    }&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;ss&quot;&gt;ReactDOM.render&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;&amp;lt;Login/&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;,&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'app'&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;生命周期理解&lt;/li&gt;
&lt;li&gt;就是一个组件对象从创建到结束的一个过程，在这个过程组件对象会经历特定的阶段，每个特定的阶段都会对应一个相应的勾子函数&lt;/li&gt;
&lt;li&gt;勾子函数本质就是生命周期的回调函数，在组件的生命周期特定时刻进行回调&lt;/li&gt;
&lt;li&gt;React.Component已经定义好了一系列的勾子函数，若是需要在特定的时间节点做一些事情，可以重写特定的勾子函数，在勾子中实现自己的逻辑功能&lt;/li&gt;
&lt;li&gt;生命周期&lt;/li&gt;
&lt;li&gt;组件有三个生命周期状态
&lt;ul&gt;&lt;li&gt;Mount：插入真实DOM，其对应的勾子函数为：componentWillMount()和componentDidMount()&lt;/li&gt;
&lt;li&gt;Update：重新渲染，其对应的勾子函数为：componentWillUpdate()和componentDidMount()&lt;/li&gt;
&lt;li&gt;Unmount：销毁真实DOM，其对应的勾子函数为：componentWillUnmount()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;生命周期流程&lt;/li&gt;
&lt;li&gt;首次初始化渲染显示：ReactDOM.render()
&lt;ul&gt;&lt;li&gt;constructor()：创建对象初始化state&lt;/li&gt;
&lt;li&gt;componentWillMount()：将要插入回调&lt;/li&gt;
&lt;li&gt;render()：插入虚拟DOM回调&lt;/li&gt;
&lt;li&gt;componentDidMount()：插入完成回调&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每次更新state：this.setState()
&lt;ul&gt;&lt;li&gt;componentWillUpdate()：将要更新回调&lt;/li&gt;
&lt;li&gt;render()：更新、重新渲染&lt;/li&gt;
&lt;li&gt;componentDidUpdate()：更新完成回调&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;移除组件:ReactDOM.unmountComponentAtNode()
&lt;ul&gt;&lt;li&gt;componentWillUnmount()：组件将要销毁时的回调&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;常用勾子
&lt;ul&gt;&lt;li&gt;render()：初始化渲染和更新都会调用&lt;/li&gt;
&lt;li&gt;componentDidMount()：开启监听、ajax请求等&lt;/li&gt;
&lt;li&gt;componentWillUnmount()：做一些收尾的工作，清除定时器等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;案例&lt;/li&gt;
&lt;li&gt;实现一个组件&lt;/li&gt;
&lt;li&gt;让文本实现显示/隐藏动画&lt;/li&gt;
&lt;li&gt;切换时间2s&lt;/li&gt;
&lt;li&gt;点击按钮 从界面中移除&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 定义组件 &lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Life &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt;(props)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(props)

        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;opacity&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;`#f0f`&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;cancelTime&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;cancelTime&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;bind&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;componentDidMount&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 定时器作用域问题&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 1. 通过bind解决&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 2. 箭头函数&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;setInterval&lt;/span&gt;( &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;opacity&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt;
            opacity &lt;span class=&quot;op&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt;

            &lt;span class=&quot;co&quot;&gt;//不能使用opacity === 0&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 因为js的计算存在误差&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(opacity &lt;span class=&quot;op&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                opacity &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                opacity
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)

        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;bind&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;)

    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;cancelTime&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 移除组件&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;ReactDOM&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;unmountComponentAtNode&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'app'&lt;/span&gt;))

    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;componentWillUnmount&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 销毁组件之前的勾子&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 定时器必须清除，不然会造成内存泄露的问题&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;clearInterval&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;timer&lt;/span&gt;)

    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;render&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;msg&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;...&lt;span class=&quot;at&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt;

        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; (
            &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;h1 style&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;style&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;gt;{&lt;/span&gt;msg&lt;span class=&quot;op&quot;&gt;}&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            &amp;lt;button onClick={this.cancelTime}&amp;gt;取消定时器&amp;lt;/button&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    }&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;ss&quot;&gt;// 渲染组件&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;ReactDOM.render&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;&amp;lt;Life msg=&quot;生命周期演示&quot;/&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;,&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'app'&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 18 May 2018 16:15:00 +0000</pubDate>
<dc:creator>wyao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nordon-wang/p/9058550.html</dc:identifier>
</item>
<item>
<title>elasticsearch 的安装配置与spring boot的整合应用 - 超级大猩猩</title>
<link>http://www.cnblogs.com/chchyu/p/9058494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chchyu/p/9058494.html</guid>
<description>&lt;h2 id=&quot;linux上的elasticsearch安装&quot;&gt;linux上的elasticsearch安装&lt;/h2&gt;
&lt;p&gt;一、下载elasticsearch&lt;/p&gt;
&lt;p&gt;直接进入elasticsearch的官网，下载最新的安装包：&lt;a href=&quot;https://www.elastic.co/downloads/elasticsearch%EF%BC%8C%E6%AD%A4%E6%95%99%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF5.1.1%E7%89%88%E6%9C%AC&quot; class=&quot;uri&quot;&gt;https://www.elastic.co/downloads/elasticsearch，此教程使用的是5.1.1版本&lt;/a&gt;。&lt;br/&gt;二、安装elasticsearch&lt;/p&gt;
&lt;p&gt;将下载的安装包上传到centos，或者直接在centos使用wget命令下载。&lt;br/&gt;1、解压&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unzip elasticsearch-5.1.1.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、安装jdk1.8&lt;/p&gt;
&lt;p&gt;要安装elasticsearch官方建议使用jdk1.8的版本，所以先安装并部署好jdk，关于jdk的部署参考网上其他资料。&lt;br/&gt;3、运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd bin
./elasticsearch&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能会出现错误，下面列出常见的错误：&lt;br/&gt;（1）elasticsearch不能以root权限来运行，会出现这种错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Exception in thread &quot;main&quot; java.lang.RuntimeException: don't run elasticsearch as root。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为安全问题elasticsearch 不让用root用户直接运行，所以要创建新用户解决办法：&lt;/p&gt;
&lt;p&gt;第一步：liunx创建新用户 adduser XXX 然后给创建的用户加密码 passwd XXX 输入两次密码。&lt;br/&gt;第二步：切换刚才创建的用户 su XXX 然后执行elasticsearch 会显示Permission denied 权限不足。&lt;br/&gt;第三步：给新建的XXX赋权限，chmod 777 * 这个不行，因为这个用户本身就没有权限，肯定自己不能给自己付权限。所以要用root用户登录付权限。&lt;br/&gt;第四步：root给XXX赋权限，chown -R XXX /你的elasticsearch安装目录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在linux上集群配置可能需要配置linux的最大进程数、缓存大小具体看个人安装时的报错 注意看报错！！！如下修改&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;以下数据根据报错的情况修改可能版本不同数据会各不相同&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; vi /etc/security/limits.conf

添加如下内容:
*  soft nofile 65536

* hard nofile 131072

* soft nproc 2048

* hard nproc 4096


2 vi /etc/security/limits.d/90-nproc.conf

找到如下内容：

* soft nproc 1024

修改为

* soft nproc 2048

3 vi /etc/sysctl.conf

添加下面配置：

vm.max_map_count=655360

并执行命令：

sysctl -p

4 文件打开数，要求大于65535
 ulimit -n 65536&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;elasticsearch.yml文件配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cluster.name:  elasticsearch
#这是集群名字，我们 起名为 elasticsearch
#es启动后会将具有相同集群名字的节点放到一个集群下。

node.name: &quot;es-node1&quot;
#节点名字。

discovery.zen.minimum_master_nodes: 2
#指定集群中的节点中有几个有master资格的节点。
#对于大集群可以写3个以上。

discovery.zen.ping.timeout: 40s

#默认是3s，这是设置集群中自动发现其它节点时ping连接超时时间，

discovery.zen.ping.multicast.enabled: false
#设置是否打开多播发现节点，默认是true。

network.bind_host: 192.168.137.100
#设置绑定的ip地址，这是我的master虚拟机的IP。

network.publish_host: 192.168.137.100
#设置其它节点和该节点交互的ip地址。

network.host: 192.168.137.100
#同时设置bind_host和publish_host上面两个参数。

discovery.zen.ping.unicast.hosts: [&quot;192.168.137.100&quot;,  &quot;192.168.137.101&quot;,&quot;192.168.137.100：9301&quot;]
#discovery.zen.ping.unicast.hosts:[&quot;节点1的 ip&quot;,&quot;节点2 的ip&quot;,&quot;节点3的ip&quot;]
#指明集群中其它可能为master的节点ip,
#以防es启动后发现不了集群中的其他节点。
#第一对引号里是node1，默认端口是9300,
#第二个是 node2 ，在另外一台机器上,
#第三个引号里是node3，因为它和node1在一台机器上，所以指定了9301端口。

http.cors.enabled: true  
http.cors.allow-origin: &quot;*&quot; 
head插件需要的配置   head可以访问elasticsearch&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;head插件的安装&quot;&gt;head插件的安装&lt;/h2&gt;
&lt;p&gt;下载node.js ,网址：&lt;a href=&quot;https://nodejs.org/en/&quot; class=&quot;uri&quot;&gt;https://nodejs.org/en/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装node到D盘。如D:\nodejs。&lt;/p&gt;
&lt;p&gt;把NODE_HOME设置到环境变量里(安装包也可以自动加入PATH环境变量)。测试一下node是否生效：&lt;/p&gt;
&lt;p&gt;安装grunt&lt;/p&gt;
&lt;p&gt;grunt是一个很方便的构建工具，可以进行打包压缩、测试、执行等等的工作，5.0里的head插件就是通过grunt启动的。因此需要安装grunt：&lt;/p&gt;
&lt;p&gt;注意：路径切到D:\nodejs下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install -g grunt-cli&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;-g代表全局安装。安装路径为C:\Users\yourname\AppData\Roaming\npm，并且自动加入PATH变量。安装完成后检查一下：&lt;/p&gt;
&lt;p&gt;把head插件的源码git clone下来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone git://github.com/mobz/elasticsearch-head.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;修改head源码&lt;/p&gt;
&lt;p&gt;由于head的代码还是2.6版本的，直接执行有很多限制，比如无法跨机器访问。因此需要用户修改两个地方：&lt;/p&gt;
&lt;p&gt;目录：head/Gruntfile.js：&lt;br/&gt;复制代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;connect: {
    server: {
        options: {
            port: 9100,
            hostname: '*',
            base: '.',
            keepalive: true
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复制代码&lt;/p&gt;
&lt;p&gt;增加hostname属性，设置为*&lt;br/&gt;修改连接地址：&lt;/p&gt;
&lt;p&gt;目录：head/_site/app.js&lt;/p&gt;
&lt;p&gt;修改head的连接地址:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;this.base_uri = this.config.base_uri || this.prefs.get(&quot;app-base_uri&quot;) || &quot;http://localhost:9200&quot;;

把localhost修改成你es的服务器地址，如：

this.base_uri = this.config.base_uri || this.prefs.get(&quot;app-base_uri&quot;) || &quot;http://10.10.10.10:9200&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在head源码目录中，执行npm install 下载的包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; npm install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在这里有报错的话，就把那npm的镜像修改为淘宝的镜像&lt;br/&gt;1.通过config命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm config set registry https://registry.npm.taobao.org 
npm info underscore （如果上面配置正确这个命令会有字符串response）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在执行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; npm install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上一步好了以后执行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;grunt server&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就可以在浏览器上打开localhost:9100（或本机ip:9100）运行head插件了&lt;/p&gt;
&lt;p&gt;|&lt;br/&gt;|&lt;br/&gt;|&lt;/p&gt;
&lt;h2 id=&quot;在centos上使用curl插入数据到elasticsearch里面的正确格式&quot;&gt;在centos上使用curl插入数据到elasticsearch里面的正确格式&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;curl -H &quot;Content-Type: application/json&quot; -XPOST 192.168.14.173:32000/test_index_1221/test_type/5 -d '{&quot;user_name&quot;:&quot;xiaoming&quot;}'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在windows上使用curl插入数据到elasticsearch里面的正确格式&quot;&gt;在windows上使用curl插入数据到elasticsearch里面的正确格式&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;curl -H &quot;Content-Type: application/json&quot; -XPOST 192.168.14.173:32000/test_index_1221/test_type/5 -d &quot;{&quot;&quot;&quot;user_name&quot;&quot;&quot;:&quot;&quot;&quot;xiaoming&quot;&quot;&quot;}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring-boot整合elasticsearch&quot;&gt;spring boot整合elasticsearch&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;application.properties配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//开启 Elasticsearch 仓库。(默认值:true。)
spring.data.elasticsearch.repositories.enabled = true
//集群的地址
spring.data.elasticsearch.cluster-nodes =192.168.175.131:9300

//集群名。(默认值: elasticsearch)
spring.data.elasticsearch.cluster-name= es  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;pom.xml依赖&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-elasticsearch&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;controller类：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.example.demo;

import com.example.demo.User;
import com.example.demo.dom;

import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;



@RestController
public class controller {

    @Autowired
    private dom userRepository;
    @ResponseBody
    //http://localhost:8888/save
    @GetMapping(&quot;save&quot;)
    public String save(){
        User user = new User(System.currentTimeMillis(),&quot;商品&quot;,&quot;这是一个测试商品&quot;,15,&quot;2018-4-25 11:07:42&quot;);
        userRepository.save(user);
        return &quot;success&quot;; 
    }

    //http://localhost:8888/delete?id=1525415333329
    @GetMapping(&quot;delete&quot;)
    public String delete(long id){
        userRepository.deleteById(id);
        return &quot;success&quot;;
    }

    //http://localhost:8888/update?id=1525417362754&amp;amp;name=修改&amp;amp;description=修改
    @GetMapping(&quot;update&quot;)
    public String update(long id,String name,String description,Integer age,String createtm){
        User user = new User(id,
                name,description,age,createtm);
        userRepository.save(user);
        return &quot;success&quot;;
    }


}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;dom类继承ElasticsearchRepository:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.example.demo;

import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;
import org.springframework.stereotype.Component;

import com.example.demo.User;

@Component
public interface dom extends ElasticsearchRepository&amp;lt;User, Long&amp;gt;{

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;User类：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.example.demo;

import java.io.Serializable;

import org.springframework.data.elasticsearch.annotations.Document;

@Document(indexName = &quot;q1&quot;, type = &quot;user&quot;)
public class User implements Serializable {
    private static final long serialVersionUID = 1L;
    /** 编号 */
     private Long id;
     /** 姓名 */
     private String name;
     
     /** 年龄 */
     private Integer age;
     
     /** 描述 */  
     private String description;
     
     /** 创建时间 */
     private String createtm;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getCreatetm() {
        return createtm;
    }

    public void setCreatetm(String createtm) {
        this.createtm = createtm;
    }

    public static long getSerialversionuid() {
        return serialVersionUID;
    }
     public User(Long id, String name, String description,Integer age,String createtm) {
            this.id = id;
            this.name = name;
            this.description = description;
            this.age=age;
            this.createtm=createtm;
        }


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在浏览器输入localhost:8080/save&lt;br/&gt;浏览器会显示success&lt;br/&gt;然后在head中看到以下数据&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1341651/201805/1341651-20180518234445769-1285953258.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;到这里就spring boot整合成功！&lt;/strong&gt;&lt;br/&gt;=&lt;br/&gt;=&lt;br/&gt;=&lt;br/&gt;=======================================================================================&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 15:47:00 +0000</pubDate>
<dc:creator>超级大猩猩</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chchyu/p/9058494.html</dc:identifier>
</item>
<item>
<title>poj~2528 Mayor's posters - 弃疗大表哥</title>
<link>http://www.cnblogs.com/qldabiaoge/p/9058416.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qldabiaoge/p/9058416.html</guid>
<description>&lt;p&gt;Mayor's posters&lt;/p&gt;
&lt;div class=&quot;plm&quot;&gt;
&lt;table align=&quot;center&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Time Limit:&lt;/strong&gt; 1000MS&lt;/td&gt;
&lt;td width=&quot;10px&quot;&gt; &lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Memory Limit:&lt;/strong&gt; 65536K&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;Total Submissions:&lt;/strong&gt; 73869&lt;/td&gt;
&lt;td width=&quot;10px&quot;&gt; &lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Accepted:&lt;/strong&gt; 21303&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p class=&quot;pst&quot;&gt;Description&lt;/p&gt;
&lt;div class=&quot;ptx&quot; lang=&quot;en-US&quot; readability=&quot;22&quot;&gt;The citizens of Bytetown, AB, could not stand that the candidates in the mayoral election campaign have been placing their electoral posters at all places at their whim. The city council has finally decided to build an electoral wall for placing the posters and introduce the following rules: &lt;br/&gt;&lt;ul&gt;&lt;li&gt;Every candidate can place exactly one poster on the wall. &lt;/li&gt;
&lt;li&gt;All posters are of the same height equal to the height of the wall; the width of a poster can be any integer number of bytes (byte is the unit of length in Bytetown). &lt;/li&gt;
&lt;li&gt;The wall is divided into segments and the width of each segment is one byte. &lt;/li&gt;
&lt;li&gt;Each poster must completely cover a contiguous number of wall segments.&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;They have built a wall 10000000 bytes long (such that there is enough place for all candidates). When the electoral campaign was restarted, the candidates were placing their posters on the wall and their posters differed widely in width. Moreover, the candidates started placing their posters on wall segments already occupied by other posters. Everyone in Bytetown was curious whose posters will be visible (entirely or in part) on the last day before elections. &lt;br/&gt;Your task is to find the number of visible posters when all the posters are placed given the information about posters' size, their place and order of placement on the electoral wall. &lt;/div&gt;
&lt;p class=&quot;pst&quot;&gt;Input&lt;/p&gt;
&lt;p&gt;The first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 &amp;lt;= n &amp;lt;= 10000. The subsequent n lines describe the posters in the order in which they were placed. The i-th line among the n lines contains two integer numbers l&lt;sub&gt;i&lt;/sub&gt; and ri which are the number of the wall segment occupied by the left end and the right end of the i-th poster, respectively. We know that for each 1 &amp;lt;= i &amp;lt;= n, 1 &amp;lt;= l&lt;sub&gt;i&lt;/sub&gt; &amp;lt;= ri &amp;lt;= 10000000. After the i-th poster is placed, it entirely covers all wall segments numbered l&lt;sub&gt;i&lt;/sub&gt;, l&lt;sub&gt;i&lt;/sub&gt;+1 ,... , ri.&lt;/p&gt;
&lt;p class=&quot;pst&quot;&gt;Output&lt;/p&gt;
&lt;div class=&quot;ptx&quot; lang=&quot;en-US&quot; readability=&quot;9&quot;&gt;For each input data set print the number of visible posters after all the posters are placed. &lt;p&gt;The picture below illustrates the case of the sample input. &lt;br/&gt;&lt;img src=&quot;http://poj.org/images/2528_1.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/div&gt;
&lt;p class=&quot;pst&quot;&gt;Sample Input&lt;/p&gt;
&lt;pre class=&quot;sio&quot;&gt;
1
5
1 4
2 6
8 10
3 4
7 10
&lt;/pre&gt;
&lt;p class=&quot;pst&quot;&gt;Sample Output&lt;/p&gt;
&lt;pre class=&quot;sio&quot; readability=&quot;6&quot;&gt;
4&lt;p&gt;这题注意要离散化就OK了 ，线段树离散化  ，&lt;br/&gt;但是要注意一个坑点 &lt;br/&gt;if (sum[i] - sum[i - 1] &amp;gt; 1) sum[m++] = sum[i - 1] + 1;&lt;br/&gt;要加一个点，避免区间不正确覆盖。&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;84&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;cstdio&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;cstring&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn = 2e4 + &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tree[maxn &amp;lt;&amp;lt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;], a[maxn], b[maxn];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sum[&lt;span&gt;3&lt;/span&gt; * maxn], vis[&lt;span&gt;3&lt;/span&gt; *&lt;span&gt; maxn], ans;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     memset(tree, -&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(tree));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     memset(vis, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(vis));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pushdown(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; rt) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     tree[rt &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;] = tree[rt &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; tree[rt];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     tree[rt] = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updata(&lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;int&lt;/span&gt; rt, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (x &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;=&lt;span&gt; y ) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         tree[rt] =&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (tree[rt] != -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) pushdown(rt);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; m = (l + r) &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (x &amp;lt;= m) updata(l, m, x, y, rt &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, v);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (y &amp;gt; m ) updata(m + &lt;span&gt;1&lt;/span&gt;, r, x, y, rt &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, v);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; query(&lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; rt) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (tree[rt] != -&lt;span&gt;1&lt;/span&gt;&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;vis[tree[rt]]) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             vis[tree[rt]] = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             ans++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (l == r) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; m = (l + r) &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     query(l, m, rt &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     query(m + &lt;span&gt;1&lt;/span&gt;, r, rt &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; t, n;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;t);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(t--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        init();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;n);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; tot = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; n ; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;a[i], &amp;amp;&lt;span&gt;b[i]);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             sum[tot++] =&lt;span&gt; a[i];
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             sum[tot++] =&lt;span&gt; b[i];
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         sort(sum, sum +&lt;span&gt; tot);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; m = unique(sum, sum + tot) -&lt;span&gt; sum;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; t =&lt;span&gt; m;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt; ; i &amp;lt; t ; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (sum[i] - sum[i - &lt;span&gt;1&lt;/span&gt;] &amp;gt; &lt;span&gt;1&lt;/span&gt;) sum[m++] = sum[i - &lt;span&gt;1&lt;/span&gt;] + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         sort(sum, sum +&lt;span&gt; m);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; n ; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; x = lower_bound(sum, sum + m, a[i]) -&lt;span&gt; sum;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; y = lower_bound(sum, sum + m, b[i]) -&lt;span&gt; sum;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             updata(&lt;span&gt;0&lt;/span&gt;, m - &lt;span&gt;1&lt;/span&gt;, x, y, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, i);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         ans = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         query(&lt;span&gt;0&lt;/span&gt;, m - &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ans);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 18 May 2018 15:20:00 +0000</pubDate>
<dc:creator>弃疗大表哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qldabiaoge/p/9058416.html</dc:identifier>
</item>
<item>
<title>Scrapy爬虫框架第七讲【ITEM PIPELINE用法】 - 疾风_lu</title>
<link>http://www.cnblogs.com/518894-lu/p/9053939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/518894-lu/p/9053939.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;ITEM PIPELINE用法详解&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180514145258553-377347092.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; ITEM PIPELINE作用：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;simple&quot;&gt;&lt;li&gt;清理HTML数据&lt;/li&gt;
&lt;li&gt;验证爬取的数据(检查item包含某些字段)&lt;/li&gt;
&lt;li&gt;去重(并丢弃)【预防数据去重，真正去重是在url,即请求阶段做】&lt;/li&gt;
&lt;li&gt;将爬取结果保存到数据库中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180518085704285-1301830639.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; ITEM PIPELINE核心方法（4个）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）、open_spider(spider)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）、close_spider(spider)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（3）、from_crawler(cls,crawler)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（4）、process_item(item,spider)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面小伙伴们我们依次来分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、open_spider(spider) 【参数spider 即被开启的Spider对象】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该方法非必需，在Spider开启时被调用，主要做一些初始化操作，如连接数据库等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、close_spider(spider)【参数spider 即被关闭的Spider对象】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该方法非必需，在Spider关闭时被调用，主要做一些如关闭数据库连接等收尾性质的工作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、from_crawler(cls,crawler)【参数一：Class类 参数二：crawler对象】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该方法非必需，Spider启用时调用，早于open_spider（）方法，是一个类方法，用@classmethod标识，它与__init__函有关，这里我们不详解（一般我们不对它进行修改）&lt;/p&gt;
&lt;p&gt;4、process_item(item,spider)【参数一：被处理的Item对象 参数二：生成该Item的Spider对象】&lt;/p&gt;
&lt;p&gt;该方法必需实现，定义的Item pipeline会默认调用该方法对Item进行处理，它返回Item类型的值或者抛出DropItem异常&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;实例分析（以下实例来自官网：https://doc.scrapy.org/en/latest/topics/item-pipeline.html）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; scrapy.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DropItem
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PricePipeline(object):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     vat_factor = 1.15
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price_excludes_vat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] *&lt;span&gt; self.vat_factor
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; DropItem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Missing price in %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % item)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码分析：&lt;/p&gt;
&lt;p&gt;首先定义了一个PricePipeline类&lt;/p&gt;
&lt;p&gt;定义了增值税税率因子为1.15&lt;/p&gt;
&lt;p&gt;主函数process_item方法实现了如下功能：判断Item中的price字段，如没计算增值税，则乘以1.15，并返回Item，否则直接抛弃&lt;/p&gt;
&lt;p&gt;总结：该方法要么return item给后边的管道处理，要么抛出异常&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 数据去重&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; scrapy.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DropItem
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DuplicatesPipeline(object):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self.ids_seen =&lt;span&gt; set()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.ids_seen:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; DropItem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Duplicate item found: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; item)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             self.ids_seen.add(item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; item
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码分析：&lt;/p&gt;
&lt;p&gt;首先定义了一个DuplicatesPipeline类&lt;/p&gt;
&lt;p&gt;这里比上面多了一个初始化函数__init__，set()---去重函数&lt;/p&gt;
&lt;p&gt;主函数process_item方法首先判断item数据中的id是否重复，重复的就将其抛弃，否则就增加到id，然后传给下个管道&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 将数据写入文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JsonWriterPipeline(object):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; open_spider(self, spider):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self.file = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;items.jl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; close_spider(self, spider):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        self.file.close()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         line = json.dumps(dict(item)) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        self.file.write(line)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; item
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码分析：&lt;/p&gt;
&lt;p&gt;首先我们定义了一个JsonWritePipeline类&lt;/p&gt;
&lt;p&gt;定义了三个函数：&lt;/p&gt;
&lt;p&gt;first：open_spider（）在Spider开启时启用作用很简单即打开文件，准备写入数据&lt;/p&gt;
&lt;p&gt;second：close_spider()在Spider关闭时启用作用也很简单即关闭文件&lt;/p&gt;
&lt;p&gt;third(主要）：process_items()作用如下首先将item转换为字典类型，在用json.dumps()序列化为json字符串格式，再写入文件，最后返回修改的item给下一个管道&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;综合实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymongo
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MongoPipeline(object):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     collection_name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;scrapy_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, mongo_uri, mongo_db):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.mongo_uri =&lt;span&gt; mongo_uri
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         self.mongo_db =&lt;span&gt; mongo_db
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @classmethod
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; from_crawler(cls, crawler):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cls(
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             mongo_uri=crawler.settings.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MONGO_URI&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             mongo_db=crawler.settings.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MONGO_DATABASE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        )
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; open_spider(self, spider):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         self.client =&lt;span&gt; pymongo.MongoClient(self.mongo_uri)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         self.db =&lt;span&gt; self.client[self.mongo_db]
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; close_spider(self, spider):
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        self.client.close()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        self.db[self.collection_name].insert(dict(item))
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; item
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码分析：&lt;/p&gt;
&lt;p&gt;首先我们定义了一个MongoPipeline类&lt;/p&gt;
&lt;p&gt;这里我们修改了初始化函数__init__，给出了存储到Mongodb的链接地址和数据库名称所以更改了from_crawler()工厂函数函数（生产它的对象），这里指定了链接地址和数据表名称&lt;/p&gt;
&lt;p&gt;最后我们定义了三个函数：&lt;/p&gt;
&lt;p&gt;first:open_spider（）在Spider开启时启用作用是打开mongodb数据库&lt;/p&gt;
&lt;p&gt;second:close_spider()在Spider关闭时启用作用是关闭数据库&lt;/p&gt;
&lt;p&gt;third：process_items()作用如下在数据库中插入item&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;项目实战：&lt;/span&gt;（我们以58同城镇江房屋出租为例）抓取出租信息的标题、价格、详情页的url&lt;/p&gt;
&lt;p&gt;我是在ubuntu16.04环境下跑的&lt;/p&gt;
&lt;p&gt;启动终端并激活虚拟环境：source course_python3.5/bin/activate&lt;/p&gt;
&lt;p&gt;创建一个新目录project：mkdir project&lt;/p&gt;
&lt;p&gt;创建项目：scrapy startproject city58-----cd city58----创建爬虫（这里小伙伴们注意项目名不能与爬虫名重名）scrapy genspider city58_test&lt;/p&gt;
&lt;p&gt;下面我们正式开始&lt;/p&gt;
&lt;p&gt;（1）、修改items.py&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180518225113747-1608841659.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）修改city58_test.py文件（这里我们使用pyquery选择器）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180518225240919-730922761.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）、重点来了，修改pipelines.py文件，小伙伴们可参考上面的案例分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180518225433628-1931444650.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）最后通过settings.py启动pipeline&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180518225544110-1030751486.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里向小伙伴们科普一个小知识点：后面的数字是优先级，数字越小，越优先执行&lt;/p&gt;
&lt;p&gt;（5）项目运行结果(部分)----下次小伙伴们想了解出租信息可以找我，我帮你秒下。哈哈！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180518230230137-574999808.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并且我们可以在同级目录下找到我们写入的文件&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）、首先了解了管道的作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）、掌握了核心的方法，其中特别是process_item()方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）、最后我们通过实例和项目进行实战，后面我们会继续学习如何使用管道进行高级的操作，敬请期待，记得最后一定要在配置文件中开启Spider中间件&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 18 May 2018 15:04:00 +0000</pubDate>
<dc:creator>疾风_lu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/518894-lu/p/9053939.html</dc:identifier>
</item>
<item>
<title>Python +selenium自动化环境的搭建 - 疯了的小蜗</title>
<link>http://www.cnblogs.com/insane-Mr-Li/p/9058348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/insane-Mr-Li/p/9058348.html</guid>
<description>&lt;p&gt;                        Python +selenium+googledriver&lt;/p&gt;
&lt;p&gt;小白的血泪安装使，不停的总结写心得是理解透彻的毕竟之路&lt;/p&gt;
&lt;p&gt;一，python的安装：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先去Python的官网下载安装包：https://www.python.org/&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224520851-1880938557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、下载完成后如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224531132-530004149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、双击exe文件进行安装，如下图，并按照圈中区域进行设置，切记要勾选打钩的框，然后再点击Customize installation进入到下一步：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224545187-885410726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224600928-586789100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、对于上图中，可以通过Browse进行自定义安装路径，也可以直接点击Install进行安装，点击install后便可以完成安装了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224611156-775763655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5.配置环境变量：在path中配置当前，你Python.exe程序的安装路径，注意：只要这个程序的安装路径，不要把这个文件的名字也填上，用半角分号隔开。&lt;/p&gt;
&lt;p&gt;如果后期要使用pip的话，也需要把pip.exe的安装路径配到path中也就是说你最少要配置两次，pip用着比较方便&lt;/p&gt;
&lt;p&gt;6、为了检查我们的python是否安装成功，可以在命令窗口中输入python进行查询，如显示下图一的信息则表示成功了，如显示第二张图的信息则表示出错了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224636323-1331028824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224649259-2032293135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;二，接下来安装pycharm&lt;/p&gt;
&lt;p&gt;1、首先从网站下载pycharm：&lt;a href=&quot;http://www.jetbrains.com/pycharm/download/#section=windows&quot; target=&quot;_blank&quot;&gt;点击打开链接&lt;/a&gt;（链接为：http://www.jetbrains.com/pycharm/download/#section=windows），进入之后如下图，根据自己电脑的操作系统进行选择，对于windows系统选择图中红色圈中的区域。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224700401-1327848736.png&quot; alt=&quot;&quot; width=&quot;987&quot; height=&quot;485&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、下载完成之后如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224734960-787743548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、直接双击下载好的exe文件进行安装，安装截图如下：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224749327-1812838869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击Next进入下一步：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224756627-966383519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击Next进入下一步：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224803747-650371214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击Install进行安装：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224811572-73233130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;安装完成后出现下图界面，点级Finish结束安装：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224818603-113563685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面我们来创建自己的第一个程序：&lt;/p&gt;
&lt;p&gt;1、单击桌面上的pycharm图标，进入到pycharm中，如下图所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224826571-1069486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、我们选择第二个，然后点击Ok：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224833688-2058219732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、点击上图中的Accept进入下一步：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224846367-2120970046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、点击上图中的ok进入下一步：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224852583-803981762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、点击Create New Project，进入如下图的界面，图中的Location是选择你安装的python的位置，选择好后，点击create。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224905000-1804123428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、在进入的界面如下图，鼠标右击图中箭头指向的地方，然后最后选择python file，在弹出的框中填写文件名（任意填写）。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224922974-1488923341.png&quot; alt=&quot;&quot; width=&quot;877&quot; height=&quot;455&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7、文件创建成功后便进入如下的界面，便可以编写自己的程序了，当然如果你对这个界面不满意的话，可以自己设置背景，这里我就不详细说明了（自行百度即可）。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224939433-2091864403.png&quot; alt=&quot;&quot; width=&quot;852&quot; height=&quot;442&quot;/&gt;&lt;/p&gt;


&lt;p&gt;注意：要有破解版的：&lt;/p&gt;
&lt;p&gt;由于最新jetbrains发布了IntelliJ IDEA 15. PyCharm 5.PhpStorm10.WebStorm 11等各个版本，但是改变了注册方法。原先的注册码包括注册机都已经不能使用了。&lt;/p&gt;
&lt;p&gt;现在有个比较简单的注册方法.注册时选择“License server”输入“http://15.idea.lanyus.com/”点击“OK”即可快速激活JetBrains系列产品&lt;/p&gt;
&lt;p&gt;使用最新的更新路径：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://idea.lanyus.com/&quot;&gt;http://idea.lanyus.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;二，        安装request模块，和webdriver&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;查看Python的安装路径下面 F:\Python\Scripts 有没有pip.exe&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518225047568-1790081807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518225102343-812742884.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;注：pip是安装管理工具，如果pip版本太低，可使用上面的命令对pip升级，如果没有pip则需要安装pip，或者直接用外部下载包安装。&lt;/p&gt;
&lt;p&gt;可以使用：F:\Python\Scripts&amp;gt;&lt;strong&gt;easy_install.exe pip（更新pip）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装selenium：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;（1）   使用cmd命令窗口，切换到你Python的安装路径下面，F:\Python\Scripts的pip程序路径下。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;（2）   输入：pip install -U selenium&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;（3）   检查selenium是否安装好，在IDE中import selenium，没报错就是导好了&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;三，        安装谷歌的驱动：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下载与你当前版本匹配的谷歌驱动:一定要与当前版本匹配的&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;如果不匹配的可能出现这个错：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518225424473-709858702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;放到你谷歌的安装路径下面：C:\Program Files (x86)\Google\Chrome\Application&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这样基本上就可以了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在环境变量中配置这个驱动程序的路径。&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;（环境变量时系统其自动调用启动一些程序的寻找路径。）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;四：会出现这样的提示：去掉这个提示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518225434584-487954405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装这个：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518225451184-17672110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;          2．或者配置一下&lt;/p&gt;
&lt;p&gt;还有可能报这个错：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518225502260-620273196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;是谷歌驱动和浏览器不匹配&lt;/p&gt;

</description>
<pubDate>Fri, 18 May 2018 14:56:00 +0000</pubDate>
<dc:creator>疯了的小蜗</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/insane-Mr-Li/p/9058348.html</dc:identifier>
</item>
<item>
<title>加密与安全传输 - 疯狂船长</title>
<link>http://www.cnblogs.com/L-dongf/p/9047846.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/L-dongf/p/9047846.html</guid>
<description>&lt;h3&gt;1、对称加密&lt;/h3&gt;
&lt;p&gt;概念：加密和解密使用同一个秘钥&lt;/p&gt;
&lt;p&gt;算法：DES、3DES、AES、Blowfish、Twofish、IDEA、RC6、CAST5等&lt;/p&gt;
&lt;p&gt;优点：效率高；将数据分割成固定大小的块，逐个进行加密&lt;/p&gt;
&lt;p&gt;缺点：每一个通信就需要一个秘钥；秘钥传递不安全；无法确定数据来源&lt;/p&gt;
&lt;h3&gt;2、非对称加密&lt;/h3&gt;
&lt;p&gt;公钥与私钥：公钥是公开给所有人的；私钥是只有自己知道；通过私钥可以推算出公钥，但是通过私钥无法退出公钥；使用公钥加密必须使用私钥解密，或者使用私钥加密必须使用公钥解密；公私钥必须成对出现&lt;/p&gt;
&lt;p&gt;算法：RSA、DSA、ELGamal&lt;/p&gt;
&lt;p&gt;优缺点：可以实现数字签名来验证数据来源；可以安全的交换对称秘钥；可以实现时间加密，但是对应大的数据解密时效率太低，适合加密少量数据&lt;/p&gt;
&lt;h3&gt;3、单向散列（hash）&lt;/h3&gt;
&lt;p&gt;特性：&lt;/p&gt;
&lt;p&gt;1）雪崩效应：数据不同，摘要一定大不同&lt;/p&gt;
&lt;p&gt;2）单向：不可反推数据&lt;/p&gt;
&lt;p&gt;3）摘要长度固定大小&lt;/p&gt;
&lt;p&gt;算法：md5:128、sha1:160、sha224、sha256、sha384、sha512&lt;/p&gt;
&lt;p&gt;功能：用来验证数据的完整性&lt;/p&gt;
&lt;h3&gt;4、秘钥交换算法（DH）&lt;/h3&gt;
&lt;p&gt;1）A和B协商生成公开的整数a,大素数p&lt;/p&gt;
&lt;p&gt;2）A:生成隐私数据 :x(x&amp;lt;p),计算得出 a^x%p，发送给B；B:生成隐私数据 :y(y&amp;lt;p),计算得出 a^y%p，发送给A&lt;/p&gt;
&lt;p&gt;3）A:计算得出 [(a^y%p)^x] %p = a^xy%p，生成为密钥；B:计算得出 [(a^x%p)^y] %p = a^xy%p，生成为密钥&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180516203001017-1135631294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5、在安全通信过程中：&lt;/h3&gt;
&lt;p&gt;爱丽丝：&lt;/p&gt;
&lt;p&gt;1）原数据通过hash算法得出一个摘要；&lt;/p&gt;
&lt;p&gt;2）用爱丽丝的私钥加密摘要；&lt;/p&gt;
&lt;p&gt;3）将加密的摘要和原数据一块使用对称秘钥加密；&lt;/p&gt;
&lt;p&gt;4）再用鲍勃的公钥将对称秘钥加密；&lt;/p&gt;
&lt;p&gt;5）密文数据发送————&amp;gt;&lt;/p&gt;
&lt;p&gt;鲍勃：&lt;/p&gt;
&lt;p&gt;1）&amp;lt;————接受密文数据；&lt;/p&gt;
&lt;p&gt;2）使用鲍勃的私钥解密对称秘钥；&lt;/p&gt;
&lt;p&gt;3）使用对称秘钥解密原数据和加密后的摘要；&lt;/p&gt;
&lt;p&gt;4）使用爱丽丝的公钥解密摘要；&lt;/p&gt;
&lt;p&gt;5）计算原数据的hash摘要并和解密后的摘要进行比较，从而确定原始数据的完整性。&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en&quot;&gt;&lt;strong&gt;TLS&lt;/strong&gt;：&lt;/span&gt;&lt;span class=&quot;LangWithName&quot;&gt;&lt;span lang=&quot;en&quot;&gt;Transport Layer Security及其前身安全套接层&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;SSL&lt;/span&gt;是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;特性：可以保证数据传输的机密性、完整性，可实现认证，重放保护（重放：由中间人捕获到加密的数据再次传输到目的服务器，有可能会影响账户的安全）等功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TLS协议&lt;/strong&gt;分俩个阶段：&lt;strong&gt;握手阶段(协商阶段)&lt;/strong&gt;：客户端和服务器端认证对方身份（依赖于PKI体系，利用数字证书进行身份认证），并协商通信中使用的安全参数、密码套件以及主密钥。后续通信使用的所有密钥都是通过MasterSecret生成。&lt;strong&gt;应用阶段&lt;/strong&gt;：在握手阶段完成后进入，在应用阶段通信双方使用握手阶段协商好的密钥进行安全通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180518203034747-2090943804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Handshake协议：包括协商安全参数和密码套件、服务器身份认证（客户端身份认证可选）、密钥交换&lt;/li&gt;
&lt;li&gt;ChangeCipherSpec 协议：一条消息表明握手协议已经完成&lt;/li&gt;
&lt;li&gt;Alert 协议：对握手协议中一些异常的错误提醒，分为fatal和warning两个级别，&lt;/li&gt;
&lt;li&gt;atal类型错误会直接中断SSL链接，而warning级别的错误SSL链接仍可继续，只是会给出错误警告&lt;/li&gt;
&lt;li&gt;Record 协议：包括对消息的分段、压缩、消息认证和完整性保护、加密等&lt;/li&gt;
&lt;li&gt;HTTPS 协议：就是“HTTP 协议”和“SSL/TLS 协议”的组合。HTTP over SSL”或“HTTP over TLS”，对http协议的文本数据进行加密处理后，成为二进制形式传输&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;数字证书认证机构（Certificate Authority，缩写为CA）&lt;/strong&gt;&lt;span class=&quot;LangWithName&quot;&gt;&lt;span lang=&quot;en&quot;&gt;，也称为电子商务认证中心、电子商务认证授权机构，是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PKI&lt;/strong&gt;：公开密钥基础建设，包括签证机构（CA）、注册机构（RA）、证书吊销列表（CRL）以及证书存取库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;X.509&lt;/strong&gt;：定义了证书的结构以及认证协议标准，包括版本号、序列号、签名算法、颁发者、有效期限、主体名称、主体公钥、CRL分发点、扩展信息、发行者签名等信息&lt;/p&gt;
&lt;p&gt;ca证书颁发机构分根ca和子ca，根ca的证书为自签证书，然后再为子ca颁发证书；用户只要信任了根ca的证书则就是信任了子ca颁发的证书。&lt;/p&gt;
&lt;p&gt;相关配置文件：&lt;strong&gt;/etc/pki/tls/openssl.cnf&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
####################################################################
[ ca ]
default_ca      = CA_default            #默认CA，在一台服务器可以搭建多个CA
[ CA_default ]　　　　　　　　　　　　　　　 #默认CA的配置
dir             = /etc/pki/CA           #工作目录
certs           = $dir/certs            #存放证书
crl_dir         = $dir/crl              #存放证书吊销列表
database        = $dir/index.txt        #数据库索引文件，需要手动创建
new_certs_dir   = $dir/newcerts         #新证书的路径
certificate     = $dir/cacert.pem       #CA的证书文件
serial          = $dir/serial           #下一个要颁发的证书序列号，16进制
crlnumber       = $dir/crlnumber        #下一个要吊销的证书序列号
crl             = $dir/crl.pem          #证书吊销列表
private_key     = $dir/private/cakey.pem#CA的私钥文件
RANDFILE        = $dir/private/.rand    #生成私钥需要用到的随机数文件&lt;br/&gt;default_days    = 365                   #默认颁发证书的有效期
default_crl_days= 30                    #30天发布一次证书吊销列表
default_md      = sha256                #
preserve        = no                    #
policy          = policy_match　　　　　　#策略匹配，定义客户端和服务端申请证书时的信息匹配策略

[ policy_match ]
countryName             = match　　　　　 #必须匹配
stateOrProvinceName     = match
organizationName        = match
organizationalUnitName  = optional   　　#不要求必须匹配
commonName              = supplied  　　 #必须提供
emailAddress            = optional
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;示例：搭建一个私有CA&lt;/h2&gt;
&lt;p&gt;服务端搭建：&lt;/p&gt;
&lt;p&gt;1、生成CA的私钥&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# (umask 066; openssl genrsa -out /etc/pki/CA/private/cakey.pem 4096)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、生成自签证书&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
# openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem -days 3650
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:beijing
Locality Name (eg, city) [Default City]:beijing
Organization Name (eg, company) [Default Company Ltd]:test
Organizational Unit Name (eg, section) []:it
Common Name (eg, your name or your server's hostname) []:ca.test.com 
Email Address []:
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;-new: 生成新证书签署请求&lt;/li&gt;
&lt;li&gt;-x509: 专用于CA生成自签证书&lt;/li&gt;
&lt;li&gt;-key: 生成请求时用到的私钥文件&lt;/li&gt;
&lt;li&gt;-days n：证书的有效期限&lt;/li&gt;
&lt;li&gt;-out /PATH/TO/SOMECERTFILE: 证书的保存路径&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、创建必要的文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# touch /etc/pki/CA/index.txt
# echo 01 &amp;gt;/etc/pki/CA/serial
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# openssl x509 -in /etc/pki/CA/cacert.pem -noout -text [-subject | -issuer | -dates]  查看证书信息
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端生成注册申请请求：&lt;/p&gt;
&lt;p&gt;1、生成私钥&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# (umask 077; openssl genrsa -out app.key 1024)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、生成签署请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
# openssl req -new -key app.key -out app.csr
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:beijing
Locality Name (eg, city) [Default City]:beijing
Organization Name (eg, company) [Default Company Ltd]:test
Organizational Unit Name (eg, section) []:it
Common Name (eg, your name or your server's hostname) []:app.test.com
Email Address []:
A challenge password []:
An optional company name []:
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、将签署请求发送给CA&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# scp app.csr 192.168.0.7:/etc/pki/CA/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务器端签署：&lt;/p&gt;
&lt;p&gt;1、签署请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# openssl ca -in /etc/pki/CA/app.csr -out /etc/pki/CA/certs/app.crt -days 100
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、将签署后的证书发回客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# scp /etc/pki/CA/certs/app.crt 192.168.0.6:/root
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;CA吊销证书的管理&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
生成吊销列表
[root@centos7 CA]# &lt;strong&gt;echo 01 &amp;gt;/etc/pki/CA/crlnumber&lt;/strong&gt;
[root@centos7 CA]# &lt;strong&gt;openssl ca -gencrl -out crl.pem&lt;/strong&gt;

查看吊销列表
[root@centos7 CA]# openssl &lt;strong&gt;crl&lt;/strong&gt; -in crl.pem -noout -text

查看证书状态
[root@centos7 CA]# cat index.txt
V（正常证书）       180826054533Z           01      unknown /C=CN/ST=BJ/O=test/OU=it/CN=www.test.com
[root@centos7 CA]# openssl &lt;strong&gt;ca&lt;/strong&gt; -status 01
Using configuration from /etc/pki/tls/openssl.cnf
01=Valid (V)（正常证书）

吊销证书
[root@centos7 CA]# openssl &lt;strong&gt;ca&lt;/strong&gt; -revoke newcerts/01.pem 
[root@centos7 CA]# cat index.txt
R  （已被吊销）     180826054533Z   180518060712Z   01      unknown /C=CN/ST=BJ/O=test/OU=it/CN=www.test.com
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;md5sum&lt;/strong&gt;、sha1sum、sha224sum、sha256sum 、sha384sum 、sha512sum：计算散列值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;--check：检查md5值是否正确&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;gpg：&lt;/strong&gt;GunPG&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-c file：加密文件&lt;/li&gt;
&lt;li&gt;-o file -d file.gpg：解密文件&lt;/li&gt;
&lt;li&gt;--gen-key：生成非对称秘钥&lt;/li&gt;
&lt;li&gt;--list-keys：查看已有公钥&lt;/li&gt;
&lt;li&gt;-e -r keyname file：使用指定公钥加密文件&lt;/li&gt;
&lt;li&gt;--import filename.pubkey：导入公钥&lt;/li&gt;
&lt;li&gt;-a --export -o filename.pubkey：导出公钥&lt;/li&gt;
&lt;li&gt;--delete-secret-keys keyname：删除私钥&lt;/li&gt;
&lt;li&gt;--delete-keys keyname：删除公钥&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# rngd -r /dev/urandom  #提供随机数来生成秘钥
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;openssl&lt;/span&gt;：&lt;/strong&gt;多用途的工具集&lt;/p&gt;
&lt;p&gt;组件：&lt;/p&gt;
&lt;p&gt;openssl: 多用途的命令行工具，包openssl&lt;/p&gt;
&lt;p&gt;libcrypto: 加密算法库，包openssl-libs&lt;/p&gt;
&lt;p&gt;libssl：加密模块应用库，实现了ssl及tls，包nss&lt;/p&gt;
&lt;p&gt;子命令：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;enc&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# openssl enc -e -des3 -a -salt -in testfile -out testfile.cipher  使用-des3加密算法对称加密testfile文件&lt;br/&gt;# openssl enc -d -des3 -a -salt -in testfile.cipher -out testfile  解密
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;-e 加密&lt;/li&gt;
&lt;li&gt;-d 解密&lt;/li&gt;
&lt;li&gt;-des3 | -des | -des 加密算法&lt;/li&gt;
&lt;li&gt;-a 表示使用base64编码&lt;/li&gt;
&lt;li&gt;编码：base64 === a-z A-Z 0-9 / + 64个字符&lt;/li&gt;
&lt;li&gt;-salt 加盐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;dgst &lt;/strong&gt; -md5 | -hex  单向加密&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;passwd&lt;/strong&gt; -1 -salt  生成MD5加密密码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rand&lt;/strong&gt; -base64 | -hex # 生成随机数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;genrsa：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# (umask 066; openssl genrsa -out test.key -des 2048)  生成私钥并且使用des加密
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;rsa：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# openssl rsa -in test.key -out test2.key  将加密的私钥解密
# openssl rsa -in test2.key -pubout -out test2.key.pub  从私钥中提取对应的公钥
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;个人学习笔记  记录于22:16&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 14:19:00 +0000</pubDate>
<dc:creator>疯狂船长</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/L-dongf/p/9047846.html</dc:identifier>
</item>
<item>
<title>论文阅读 | CrystalBall: A Visual Analytic System for Future Event Discovery and Analysis from Social Media Data - basasuya</title>
<link>http://www.cnblogs.com/Basasuya/p/9058033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Basasuya/p/9058033.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://wesslen.github.io/assets/documents/papers/crystalball.pdf&quot;&gt;论文地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;abstract&quot;&gt;1 Abstract&lt;/h3&gt;
&lt;p&gt;这是一个可以预测未来一段时间内所发生事情的可视化系统，使用的是twitter数据进行分析。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518210239589-570290288.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;introduction&quot;&gt;2 Introduction&lt;/h3&gt;
&lt;p&gt;识别一个未来的事件并不可以依靠消息量的突增来判断(一般一个很大的事件的到来会引发交际圈的热烈讨论)，一个未来时间的发生并不一定可以激发消息量的增加。&lt;strong&gt;识别未来事件的挑战在于筛选大量社交媒体数据，并识别埋在关于过去和正在进行的事件，个人状态更新等的压倒性信息中的小信号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者看来，未来事件的定义是&quot;与将来的位置和日期/时间(跨度)相关联的事件。 这种情况的特点是地点和时间，通常与特定主题和社交网络相关联。&quot; &lt;strong&gt;位置和时间&lt;/strong&gt;是定义未来事件的主要属性&lt;/p&gt;
&lt;p&gt;通过这个系统。我们既可以发现各种未来事件，也可以对特定的时间地点进行重点调查。&lt;/p&gt;
&lt;h3 id=&quot;related-work&quot;&gt;3 Related Work&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;未来事件提取&lt;/strong&gt;和&lt;strong&gt;可视化交互&lt;/strong&gt;是两个主要的方面&lt;/p&gt;
&lt;h3 id=&quot;system-overview-and-pipeline&quot;&gt;4 System overview and pipeline&lt;/h3&gt;
&lt;p&gt;CrystalBall集成了多个组件，包括来自Twitter Streaming API ，实体提取，未来事件标识 和排名以及交互式可视化界面。 所有的数据收集和分析都是在线进行的。接口每天刷新以显示未来几天或几周内可能发生的事件的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518210355869-2123267321.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;crystalball-future-event-identifiction-and-characterization&quot;&gt;5 CrystalBall: future event identifiction and characterization&lt;/h3&gt;
&lt;h3 id=&quot;如何处理数据&quot;&gt;(如何处理数据)&lt;/h3&gt;
&lt;p&gt;因为未来数据在所有的数据占比小，怎么提取是个问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NPMI&lt;/strong&gt;得到了位置和时间之间的相关性，相比PMI，将其正则化到1和-1之间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518210745961-1759979717.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了上面所说到的NPMI，还有一些其他特征，这些其他属性包括&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链接和比例&lt;/strong&gt;，我们衡量包含链接的推文与所有与可能的未来事件相关的推文的比例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题标签比例&lt;/strong&gt;。同样，我们测量与一个可能的未来事件相关的推文的标签比率&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户可信&lt;/strong&gt;度，我们选择一个简单的度量，即Twitter追随者朋友（TFF）比率来表示用户的可信度。TFF是追随者与朋友的比率。 1.0到2.0之间的比率表示用户具有平衡的跟随/跟随者关系&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户多样性&lt;/strong&gt;，如果关于一个潜在的未来事件的所有推文都来自一个账户，那么这些推文很可能来自被编程为定期发送某些推文的机器人。&lt;/p&gt;
&lt;p&gt;除此之外有些信息并不包括完整的信息，比方说纽约在4.3会有一场音乐会，但是推文里只会提到“我将在4月3日访问我在纽约的朋友”，其实可能是和朋友一起看音乐会。所以我们可以设计一些关于相似推文的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中心性&lt;/strong&gt;。高度连接的推特网络将具有接近1的程度中心性，而分散的推特网络产生接近于0的中心性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推特相似性&lt;/strong&gt;。&lt;a href=&quot;mailto:但是并不是所有推文都有@和转发相关联&quot;&gt;但是并不是所有推文都有@和转发相关联&lt;/a&gt;。所以我们还计算了每篇推文的相似性&lt;/p&gt;
&lt;p&gt;我们已经提出了确定可能的未来事件（NPMI）的措施，以及六个额外措施来描述事件的特征。下一步是结合这些措施来评估已确定的未来事件的质量。我们希望对事件进行排名，以便CrystalBall首先直观地表示高质量的事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们使用RankSVM进行排序&lt;/strong&gt;。为了训练RankSVM，我们开发了一个标签数据集，其中包含三天内提取的未来事件（约1000个事件）。我们为表2列出的事件定义了5个类别。标注决定表明我们重视地缘政治和基层性质的事件。&lt;br/&gt;五位编码者独立完成了1000次提取的未来事件，并使用上述分类对事件进行了排名。然后，我们使用标记的数据集来训练RankSVM，并开发了一个可应用于无标签事件排序的模型。在CrystalBall可视化界面中，事件列表视图中每天显示的事件顺序（如图3所示）反映了RankSVM的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518210813615-2053857173.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;crystalball-visual-interface可视化分析&quot;&gt;5 CrystalBall: Visual Interface（可视化分析）&lt;/h3&gt;
&lt;h4 id=&quot;按时间检索&quot;&gt;按时间检索&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;日期纵览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们从整个时间轴进行查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518210948650-1796043157.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是未来事件的总揽，首先每行该日期所发生的事件，实线连接的是有相同的地点的事件。虚线连接的是具有同样的关键词的事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211003472-1896412935.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个事件都有自己的颜色，颜色代表整个事件的感情属性，而颜色的深浅表达了置信度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单个日期查看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211018189-2069819953.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们也可以查看一天的信息&lt;/p&gt;
&lt;p&gt;A图，花瓣的红色占比代表了这个指标的大小，中间的数字是该日共有几个未来事件。&lt;/p&gt;
&lt;p&gt;B图中，1表是每个时刻的时间数，2表是近30天内将会发生的相似事件，3表是按照感情属性分类的结果。&lt;/p&gt;
&lt;p&gt;C图中，未来事件中的关键词。&lt;/p&gt;
&lt;p&gt;D按钮可以用来收藏&lt;/p&gt;
&lt;h4 id=&quot;按地点检索&quot;&gt;按地点检索&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211037367-849716895.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A图中可以放缩不同尺寸的地点，中间的数字表示的是事件数，不同深浅表达了在不同时间点内的事件。&lt;/p&gt;
&lt;p&gt;B图中当我们点击华盛顿图表，就会跳出所有事件的映像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211052861-1582459437.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图词云显示的是当前区域当中过的关键词&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211109679-1560156204.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图这种模式下，每个节点代表一个事件，节点之间的链接表示两个事件共享相同的位置和时间。节点中的数字表示事件的推文数量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211126255-1334777293.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图每个点是一个用户，颜色代表了TTF比例，越深代表跟随者越多。聚集在一起表示同样的时间地点。点击这个区域，所有这块有的词语都会被标红&lt;/p&gt;
&lt;p&gt;可视化系统的互动方式有 按照 &lt;strong&gt;时间，地点，关键词，类型&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;case-study&quot;&gt;7 Case Study&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211147887-492845910.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211206532-1574055028.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面介绍了一件北卡罗来纳州夏洛特市2016年9月抗议活动有关的一周活动。图1中的实现代表了三个有同样的地点的事物，分析这个时间线，可以发现这个时间线中有很多关于抗议的关键词。关注9.24一天，可以发现很多人的情绪都转变为恐慌，愤怒。与此同时一个有趣的现象就是大家的视线都转向了trump的一篇推文(最右边的一张图)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211218017-531694867.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该系统还可以搜索潜在的用户。用户通过关键词(爱国的欧洲人反对西方的伊斯兰化)搜索，可以非常详细的认识一个活动的开始，组织，和最后收到大家的报道。&lt;/p&gt;
&lt;h3 id=&quot;validation-studies&quot;&gt;8 Validation studies&lt;/h3&gt;
&lt;p&gt;我们希望通过我们的系统预测于&lt;strong&gt;2011年9月17日在纽约市开始的占领运动&lt;/strong&gt;。CrystalBall分析了大约123,000条推文，其中根据我们的初步数据分析，只有120条推文包含标签“占据”。但是CrystalBall可以找到这些蛛丝马迹。下图显示了这个寻找的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211238003-372164027.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着事件的组织，CrystalBall可以识别早期信号。用户从事件日历视图开始，发现了一系列的选举后事件。在确定了多个大型全球地点（例如印度，英国，加拿大，伦敦，以色列）后，她发现跨越多个日期的“华盛顿”。选择那个地点后，她在就职典礼日（1月20日）之前发现了多个未成年人事件。描述未来事件的关键词包括“million womenmarch”，“washton”，“1月”等。查看与这些事件有关的推文显示3月份的&lt;strong&gt;妇女组织活动&lt;/strong&gt;在选举后不久发生。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211250045-1316185010.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;limitation&quot;&gt;9 Limitation&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用 时间-地点 组合进行编码，比较局限。&lt;/li&gt;
&lt;li&gt;识别未来事件错误，关于过去事件的新闻头条的推文可能会被错误地视为未来事件，而且很多转发是在很多天之后才收到转发。&lt;/li&gt;
&lt;li&gt;时间位置的提取算法还是不准确&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;future-work&quot;&gt;10 Future Work&lt;/h3&gt;
&lt;p&gt;处理多个数据源的流量(fb, ins, wiki, google)，新的nlp算法&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 13:06:00 +0000</pubDate>
<dc:creator>basasuya</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Basasuya/p/9058033.html</dc:identifier>
</item>
<item>
<title>jenkins+gitlab自动化编译部署方案探索及服务端编译webpack实战 - 冒雨ing</title>
<link>http://www.cnblogs.com/saysmy/p/8806975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/saysmy/p/8806975.html</guid>
<description>&lt;p&gt;之前我们的开发流程为在本地进行webpack打包编译，然后svn提交源代码和编译后的代码。同时每次提交前也会从svn更新源代码和编译后的代码。这样做有几个缺点：&lt;/p&gt;
&lt;p&gt;1. svn 更新和提交编译后的代码造成大量冲突文件&lt;/p&gt;
&lt;p&gt;2. 由于我们使用非覆盖式发布的命名方式，在经过小组多人多次优化提交测试之后，在整理需要发布的文件列表时，很容易遗漏一些文件&lt;/p&gt;
&lt;p&gt;3. 在涉及到多人开发同一功能时容易产生代码被覆盖、人工安排发布优先级、手动注释他人未上线代码等情况&lt;/p&gt;
&lt;p&gt;4. svn的分支开发繁琐不友好，加重工作量&lt;/p&gt;

&lt;p&gt;最不能容忍的是第一第二点，于是我们改成服务端打包编码，本地只提交和更新源代码，这样就会大大减少冲突。同时，利用jenkins自动把服务端打包编译后的代码部署到测试和线上环境，省去了手动整理待发布文件列表的麻烦，也避免了发布文件遗漏的情况。为了提高开发流程质量，科学友好的规范开发流程，我们选择gitlab作为新的代码仓库，通过分支管理和代码review来提高开发效率，减少发布错误。&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;完成功能：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 代码仓库用gitlab托管，使用&lt;a href=&quot;https://mp.weixin.qq.com/s/0N3isbSZL4fM5HjZo1aafA?&quot; target=&quot;_blank&quot;&gt;AoneFlow&lt;/a&gt;分支管理模式（阿里命名的一种分支管理模式，借鉴于gitflow, githubflow和gitlabflow）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518145225490-1010569428.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;290&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 源代码合并到测试分支后，jenkins自动打包编译并将编译后的代码部署到测试环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 源代码合并到发布分支后，jenkins自动打包编译并将编译后的代码部署到线上环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; 给Master稳定分支打版本tag，同时增加tag版本说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; 脚手架和代码分离，保留一个脚手架仓库，提供给各个环境编译。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518113725442-2079142424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;部署方案探索&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A. jenkins合并代码并编译，ssh发送编译后代码到测试环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缺点：发送代码量大，耗时严重&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B. jenkins合并代码并编译，编译结果提交到gitlab，ssh连接测试环境从gitlab更新代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缺点：编译后代码合并到gitlab冲突多，麻烦&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C. jenkins合并代码，ssh连接测试环境更新gitlab代码，然后运行编译命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：速度快，冲突少&lt;/p&gt;

&lt;p&gt;综上，我们选择方案C进行部署代码。&lt;/p&gt;

&lt;p&gt;发布到线上，不能通过merge到release/prop发布分支后自动触发jenkins构建，因为我可能同时有多个feature分支需要一次性发布到线上，这个时候需要多个feature分支挨个合并到发布分支，然后才能执行构建操作。所以合并到发布分支和构建部署到线上应该分为两个独立部分，分别执行。 &lt;/p&gt;
&lt;p&gt;一图胜千言，结合我司的实际开发环境，目前整体架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518193357830-1357490349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 关于jenkins安装的方案网上有很多，可以另行查询。&lt;/p&gt;
&lt;h2&gt;1. 首先安装插件：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Gitlab Hook Plugin &lt;/li&gt;
&lt;li&gt;GitLab Plugin &lt;/li&gt;
&lt;li&gt;Publish Over SSH&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;系统管理--管理插件--可选插件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518171027262-395950604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180412121502769-1847214559.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;379&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 2. 新建job&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180412120751881-835757453.png&quot; alt=&quot;&quot; width=&quot;599&quot; height=&quot;649&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;3. 配置git源码&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;点击新建的job，点击配置--源码管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518182315480-1659141267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt; Repository URL&lt;/span&gt; ： 填写git仓库地址&lt;/p&gt;

&lt;p&gt;点击add--jenkins &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518192520009-1613972823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;选择 ssh username with private key (需要提前在jenkins服务器生成ssh keys)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;username:  root&lt;/li&gt;
&lt;li&gt;enter directly:  &lt;strong&gt;私钥&lt;/strong&gt;内容   或者 From a file on Jenkins master ： 私钥的存放路径比如/home/role/.ssh/id_rsa&lt;/li&gt;
&lt;li&gt;passphrase:  生成ssh keys时填的密码，如果当时没设置则不填&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果选择私钥内容，那就需要在gitlab上把你的公钥填到gitlab ssh keys:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518192552473-830942288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;点击Credentials选择刚添加的证书，如果此时没有红字报错，证明设置成功！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180412160327080-1599687083.png&quot; alt=&quot;&quot; width=&quot;794&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 4. 设置webhook&lt;/h2&gt;
&lt;p&gt;webhook按我的理解就是可以触发的一个接口，可以用它来在一定条件下触发某个任务。&lt;/p&gt;

&lt;p&gt;在job配置中找到如下选项：如果没有，则先安装&lt;a class=&quot;display-name&quot; href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Gitlab+Hook+Plugin&quot; target=&quot;_blank&quot;&gt;Gitlab Hook Plugin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518154459425-214910359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;复制红框中的webhook url， 打开gitlab如下图在URL处填写webhook地址&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518192721515-879718609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;add后点击test，如果提示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180412183115769-1109546162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;则设置成功，jenkins成功触发！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;！！！注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;gitlab的webhooks url 是根据jenkins构建权限连接设置的，如果必须登录才能构建就必须获取jenkins的用户名及token，可以在jenkins用户-设置里面查看到 ，url格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&amp;lt;username&amp;gt;:&amp;lt;api-token&amp;gt;@&amp;lt;jenkins-server&amp;gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 如果不须登录就能构建就直接设置为 &lt;span class=&quot;cnblogs_code&quot;&gt;http&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jenkins-server/job/security_Usm/build?delay=0sec&lt;/span&gt;&lt;/span&gt;  ，security_Usm是job名称&lt;/p&gt;
&lt;p&gt;所以，如果你出现如下错误提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180412160803910-1141701927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
Hook executed successfully but returned HTTP 403 &amp;lt;!doctype html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;HTTP Status 403 – Forbidden&amp;lt;/title&amp;gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;h1 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:22px;} h2 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:16px;} h3 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:14px;} body {font-family:Tahoma,Arial,sans-serif;color:black;background-color:white;} b {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;} p {font-family:Tahoma,Arial,sans-serif;background:white;color:black;font-size:12px;} a {color:black;} a.name {color:black;} .line {height:1px;background-color:#525D76;border:none;}&amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;HTTP Status 403 – Forbidden&amp;lt;/h1&amp;gt;&amp;lt;hr class=&quot;line&quot; /&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Type&amp;lt;/b&amp;gt; Status Report&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Message&amp;lt;/b&amp;gt; anonymous is missing the Job&amp;amp;#47;Build permission&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Description&amp;lt;/b&amp;gt; The server understood the request but refuses to authorize it.&amp;lt;/p&amp;gt;&amp;lt;hr class=&quot;line&quot; /&amp;gt;&amp;lt;h3&amp;gt;Apache Tomcat/8.5.24&amp;lt;/h3&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需要更改你的gitlab中webhook地址为如下形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maoyu:89w3fseydf96934hy@10.95.10.10:8080/jenkins/project/front-end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;5. ssh部署到服务器&lt;/h2&gt;
&lt;p&gt;全局配置ssh服务器：系统管理--系统设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180424143041909-756430802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180424143102331-501928417.png&quot; alt=&quot;&quot;/&gt;、&lt;/p&gt;
&lt;p&gt;配置好后点击Test，出现success即表示成功。&lt;/p&gt;

&lt;p&gt;然后配置具体的发布内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180425192742893-302455813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518192812308-71319058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;source files: jenkins中工作空间下的路径&lt;/li&gt;
&lt;li&gt;remote directory: 是相对全局配置中Publish over SSH -- SSH server -- Remote Directory的路径&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; source files亦可不填，直接连接服务器后执行exec command.&lt;/p&gt;

&lt;h2&gt;6. 显示构建日志的时间&lt;/h2&gt;
&lt;p&gt;如果想在console output中显示如下的时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518155542703-1415226265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置如下即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518155610548-234850233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 7. 自动合并Gitlab Merge Request&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果你想在Merge request后使用jenkins自动合并代码，可以使用下面的方法，如果不需要这样，比如push到某个分支直接触发webhook则可以跳过此步骤。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的目前构建方案中，在发布到测试环境时，两种都有，即既可以通过Merge Request触发自动合并然后构建，也可以手动合并后产生push事件触发webhook。但很可能之后会改成提交到对应分支后，自动触发webhook，jenkins合并到相应分支然后编译部署。看具体公司的使用习惯和一些规范吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用插件：Gitlab Merge Request Builder&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此插件是通过设定分支，定时检查分支有没有收到Merge Request请求来决定是否进行构建。gitlab是个审核管理 ，当jenkins构建完成之后，gitlab便会合并分支。&lt;/p&gt;
&lt;p&gt; 配置如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518161435895-1849085408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果想在gitlab pipeline成功之后自动执行merge操作，需要勾上下面的配置，可以说这是必须的，不然你就完不成自动合并：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518192958871-1303074149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;gitlab对应的合并界面有如下变化：&lt;/p&gt;

&lt;p&gt;初始界面如下，可以在右上角close 合并请求：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518162201032-1208559847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　在建立合并请求到合并成功，可能会出现如下的红叉提示Could not connect to the CI server. 不用管它，可以忽略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518161920407-1446019063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 如果合并失败，界面提示如下，则需要去jenkins查看日志具体为什么合并失败：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180417113308368-1423955251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;或者你可能会看到如下的提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180417115041425-309523046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;合并成功如下，在discussion中会有jenkins自动添加的一些comment：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518162532707-1271395282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Gitlab Merge Request Builder会触发gitlab的pipeline, 无需配置gitlab的CI/CD。&lt;/p&gt;
&lt;p&gt;如果在gitlab 的merge requests部分，Discussion没有Build Started，Build triggered, Build finished Test Passed.这些提示，说明Gitlab Merge Request Builder插件没有起作用，仔细检查配置Gitlab Project Path等是否正确，如果都正确可以尝试重启jenkins，重新发起merge request。&lt;/p&gt;
&lt;p&gt;如果在配置构建触发器下的 Gitlab Merge Request Builder，点击apply时报如下错误，则在系统管理--系统配置中检查Gitlab Merge Request Builder配置Jenkins Username和Jenkins API Token是否正确。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180420114540153-1774064448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gitlab merge冲突：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180420170135222-132473544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击 &lt;strong&gt;解决冲突 &lt;/strong&gt;手动编辑解决冲突，保存即可重新触发merge request，然后自动合并&lt;/p&gt;

&lt;h2&gt;8. 参数化构建 &lt;/h2&gt;
&lt;p&gt;参数化构建即第一你需要手动点击构建按钮，第二你可以设置一些参数变量在构建中使用，比如开发环境，分支参数等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518163031244-1098192392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为什么需要参数化构建？我们目前项目比较简单，其实无需参数化构建，但在部署到线上后给master打tag时，遇到点麻烦，即不能给tag设置一些个性化的说明文案，这样找起tag单纯看版本号可能很难知道某个版本里面完成什么功能。所以我们在发布到线上时，增加了deploymsg即要发布功能的描述，用来作为tag的描述信息。&lt;/p&gt;
&lt;p&gt;参数化构建可以使用jenkins自带的参数化构建过程，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518163340618-365767472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参加参数中选择string parameter， 第一项名字即你要添加的变量名。&lt;/p&gt;
&lt;p&gt;设置好后保存，即完成了参数化构建的设置。&lt;/p&gt;
&lt;p&gt;第二种方法可以使用jenkins插件，jenkins有着几千款各种功能插件，非常丰富，基本我们想要的功能都会有插件支持。&lt;/p&gt;
&lt;p&gt;这里我们使用的插件是：Generic Webhook Trigger &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180416191252779-35098821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180416191337457-368435164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 按照以上配置即配置了一个ref变量。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;看下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180413111122867-71004681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;更简便的方法是&lt;a href=&quot;https://github.com/jenkinsci/gitlab-plugin&quot; target=&quot;_blank&quot;&gt;gitlab plugin&lt;/a&gt;提供的变量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180413123205334-2120801064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以再shell中打印如下查看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
echo &quot;gitlabBranch: ${gitlabBranch}&quot;&lt;span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;

&lt;p&gt;只需要对文件名命名不同的名字即可，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518170500683-1916966995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;hr/&gt;

&lt;p&gt;如以下表示每2分钟执行一次任务：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180420154524134-930174934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;cron语法有五位，分别的意义是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;MINUTES Minutes in one hour (0-59)&lt;/li&gt;
&lt;li&gt;HOURS Hours in one day (0-23)&lt;/li&gt;
&lt;li&gt;DAYMONTH Day in a month (1-31)&lt;/li&gt;
&lt;li&gt;MONTH Month in a year (1-12)&lt;/li&gt;
&lt;li&gt;DAYWEEK Day of the week (0-7) where 0 and 7 are sunday&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中每个字段除了可以使用取值范围内的值外，还能使用一些特殊的字符。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;*     匹配范围内所有值&lt;/li&gt;
&lt;li&gt;M-N   匹配M~N范围内所有值&lt;/li&gt;
&lt;li&gt;M-N/X 或者 */X   在指定M~N范围内或整个有效区间内每隔X构建一次 &lt;/li&gt;
&lt;li&gt;A,B,...,Z        匹配多个值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了在系统中生成定时任务，符号H（代表“Hash”，后面用“散列”代替）应该用在可能用到的地方，例如：为十几个日常任务配置0 0 * * *将会在午夜产生较大峰值。相比之下，配置H H * * * 仍将每天一次执行每个任务，不是都在同一时刻，可以更好的使用有限资源。&lt;/p&gt;
&lt;p&gt;符号H可用于范围，例如，H H(0-7) * * * 代表凌晨0:00到 上午7:59一段时间。你还可以用H代表有或无范围的区间。&lt;/p&gt;
&lt;p&gt;符号H 在一定范围内可被认为是一个随机值，但实际上它是任务名称的一个散列而不是随机函数。&lt;/p&gt;
&lt;p&gt;需要注意的是，月份中的某天-DOM字段，类似于*/3 或者 H/3 的短周期由于月份的天数不固定，在大多数月尾总不会工作。例如，*/3 将会在一个月里面的第一天、第四天。。。第31天执行，下个月的那天继续重复执行。散列一般被选择在1-28天内，所以H/3将会在跑到月底的3-6天内导致空白。（长时间循环将会导致长度不一，但是这种影响也是不明显的。）&lt;/p&gt;
&lt;p&gt;空行和以#开头的行将会被认为是注释。&lt;/p&gt;
&lt;p&gt;另外，@yearly, @annually, @monthly, @weekly, @daily, @midnight, 和 @hourly也支持别名。这些使用散列系统自动匹配，例如：@hourly 和 H * * * * 一样代表一个小时内的任何时刻。@midnight实际上代表凌晨0:00到凌晨2:59之间的一段时间。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;# 每隔15分钟。(或许:07, :22, :37, :52)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;H/15 * * * *&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;# 每前半小时中每隔10分钟。 (3次, 或许:04, :14, :24)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;H(0-29)/10 * * * *&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;# 每个工作日从早上9点45分开始到下午3点45分结束这段时间内每间隔2小时的45分钟那一刻。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;45 9-16/2 * * 1-5&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#每个工作日从早上9点到下午5点这段时间内每间隔2小时之间的某刻。(或许在上午10:38, 下午12:38, 下午2:38 , 下午4:38)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;H H(9-16)/2 * * 1-5&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#每月（除了12月）从1号到15号这段时间内某刻。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;H H 1,15 1-11 *&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h2&gt;1、关闭Jenkins&lt;/h2&gt;
&lt;p&gt;     只需要在访问jenkins服务器的网址url地址后加上exit。例如我jenkins的地址http://localhost:8080/，那么我只需要在浏览器地址栏上敲下&lt;strong&gt;http://localhost:8080/exit&lt;/strong&gt; 网址就能关闭jenkins服务.&lt;/p&gt;
&lt;h2&gt;2、重启Jenkies&lt;/h2&gt;
&lt;p&gt;    http://localhost:8080/restart&lt;/p&gt;
&lt;h2&gt;3、重新加载配置信息&lt;/h2&gt;
&lt;p&gt;  &lt;strong&gt; &lt;/strong&gt; http://localhost:8080/reload&lt;/p&gt;
&lt;hr/&gt;

&lt;h3&gt;1. GitLab: The project you were looking for could not be found.&lt;/h3&gt;
&lt;p&gt;fatal: Could not read from remote repository.&lt;/p&gt;
&lt;p&gt;Please make sure you have the correct access rights&lt;br/&gt;and the repository exists.&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;查看git用户是否具有提交到gitlab仓库的权限&lt;/p&gt;

&lt;h3&gt; 2. &lt;code class=&quot;hljs livecodeserver has-numbering&quot;&gt;Could &lt;span class=&quot;hljs-operator&quot;&gt;not &lt;span class=&quot;hljs-built_in&quot;&gt;open &lt;span class=&quot;hljs-operator&quot;&gt;a connection &lt;span class=&quot;hljs-built_in&quot;&gt;to your authentication agent.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;需手动开启ssh，如下；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
 eval `ssh-agent -s`
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次执行ssh-add 即可&lt;/p&gt;

&lt;h3&gt;3.  Exception when publishing, exception message [Exec timed out or was interrupted after 120,001 ms&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180427103632748-755462850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;适当调大超时时间，比如调成300000&lt;/p&gt;

&lt;h3&gt;4. ssh_exchange_identification: Connection closed by remote host &lt;/h3&gt;
&lt;h4&gt;解决方法一. 把SSH连接数改大 &lt;/h4&gt;
&lt;p&gt;修改服务器上的这个文件：/etc/ssh/sshd_config 找到这行 &lt;span class=&quot;cnblogs_code&quot;&gt;# MaxSessions 10&lt;/span&gt;  ：&lt;/p&gt;
&lt;p&gt;去掉前面的&quot;#&quot; 并把数字改大，最后重启sshd service sshd restart 然后重新连接即可. &lt;/p&gt;
&lt;h4&gt;解决方法二.  每次正常退出SSH连接&lt;/h4&gt;
&lt;p&gt;每次执行完命令后用输入&quot;exit&quot; 退出, 防止连接数过多.&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;见github: &lt;a href=&quot;https://github.com/saysmy/svnsh&quot; target=&quot;_blank&quot;&gt;https://github.com/saysmy/svnsh&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 18 May 2018 13:03:00 +0000</pubDate>
<dc:creator>冒雨ing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/saysmy/p/8806975.html</dc:identifier>
</item>
</channel>
</rss>