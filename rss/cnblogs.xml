<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MSIL实用指南-闭包的生成和调用 - Z语言</title>
<link>http://www.cnblogs.com/tkt2016/p/8867086.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tkt2016/p/8867086.html</guid>
<description>&lt;p&gt;&lt;span&gt;闭包（Closure）是词法闭包（Lexical Closure）的简称。对闭包的具体定义有很多种说法，这些说法大体可以分为两类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一种说法认为闭包是符合一定条件的函数，比如参考资源中这样定义闭包：闭包是在其词法上下文中引用了自由变量(注1)的函数。&lt;br/&gt;另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。比如参考资源中就有这样的的定义：在实现深约束(注2)时，需要创建一个能显式表示引用环境的东西，并将它与相关的子程序捆绑在一起，这样捆绑起来的整体被称为闭包。&lt;br/&gt;这两种定义在某种意义上是对立的，一个认为闭包是函数，另一个认为闭包是函数和引用环境组成的整体。虽然有些咬文嚼字，但可以肯定第二种说法更确切。闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束所组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。那么为什么要把引用环境与函数组合起来呢？这主要是因为在支持嵌套作用域的语言中，有时不能简单直接地确定函数的引用环境。这样的语言一般具有这样的特性：&lt;/p&gt;
&lt;p&gt;函数是一阶值（First-class value），即函数可以作为另一个函数的返回值或参数，还可以作为一个变量的值。&lt;br/&gt;函数可以嵌套定义，即在一个函数内部可以定义另一个函数。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;在C#里面，变量作用域有三种，一种是属于类的，我们常称之为field；第二种则属于函数的，我们通常称之为局部变量；还有一种，其实也是属于函数的，不过它的作用范围更小，它只属于函数局部的代码片段，这种同样称之为局部变量。这三种变量的生命周期基本都可以用一句话来说明，每个变量都属于它所寄存的对象，即变量随着其寄存对象生而生和消亡。对应三种作用域我们可以这样说，类里面的变量是随着类的实例化而生，同时伴随着类对象的资源回收而消亡(当然这里不包括非实例化的static和const对象)。而函数(或代码片段)的变量也随着函数(或代码片段)调用开始而生，伴随函数(或代码片段)调用结束而自动由GC释放，它内部变量生命周期满足先进后出的特性。&lt;/p&gt;
&lt;p&gt;比如说下面这个闭包例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClosureTest
{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; GetClosure()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; n = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; () =&amp;gt;&lt;span&gt;
            {
                n&lt;/span&gt;++&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n;
            };
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
        {
            Func&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; fn = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            fn &lt;/span&gt;=&lt;span&gt; GetClosure();
            Console.WriteLine(fn());
            Console.WriteLine(fn());
            Console.WriteLine(fn());
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行的结果是&lt;br/&gt;1&lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;而不是别的。&lt;/p&gt;&lt;p&gt;可以看出局部变量n并没有在函数调用后被回收，而是一直存在。&lt;br/&gt;我们这里就讲解怎么实现闭包。&lt;br/&gt;在最后的生成二进制文件中，局部变量n已经不是在函数内，而是转移到了一个内部类中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、生成内部类&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;这个内部类有一下几个成员&lt;br/&gt;1.一个字段，用于存储n的值；&lt;br/&gt;2.一个最简单的构造函数，用于被调用生成实例；&lt;br/&gt;3.一个方法，用于执行lamda表达式。&lt;/p&gt;
&lt;p&gt;生成内部类的&lt;br/&gt;&lt;strong&gt;第1步：声明内部类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
nestedTypeBuilder = typeBuilder.DefineNestedType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ClosureNestedClass&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TypeAttributes.NestedPublic | TypeAttributes.Sealed);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;第2步：创建字段&lt;/strong&gt;&lt;br/&gt;字段的类型和局部变量n的类型是一样的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
nestedFieldBuilder = nestedTypeBuilder.DefineField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NestedFeld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), FieldAttributes.Public);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;第3步：构造函数&lt;/strong&gt;&lt;br/&gt;构造函数是一个无参的构造函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
nestedNewBuilder = nestedTypeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, &lt;span&gt;new&lt;/span&gt; Type[] { });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它的方法体只需要一个最简单ret指令就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; il =&lt;span&gt; nestedNewBuilder.GetILGenerator();
il.Emit(OpCodes.Ret);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;第4步：创建字段&lt;/strong&gt;&lt;br/&gt;方法是无参的，返回类型和局部变量n的类型一样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
nestedLambdsMethod = nestedTypeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Run&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, MethodAttributes.Public, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Type[] { });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法体内声明一个局部变量用于返回结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
LocalBuilder retlocalBuilder = ilGenerator.DeclareLocal(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;按照上面的示例程序给字段n++。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ilGenerator.Emit(OpCodes.Ldarg_0);
ilGenerator.Emit(OpCodes.Ldarg_0);
ilGenerator.Emit(OpCodes.Ldfld, nestedFieldBuilder);
ilGenerator.Emit(OpCodes.Ldc_I4_1);
ilGenerator.Emit(OpCodes.Add);
ilGenerator.Emit(OpCodes.Stfld, nestedFieldBuilder);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;把字段保存到那个局部变量上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ilGenerator.Emit(OpCodes.Ldarg_0);
ilGenerator.Emit(OpCodes.Ldfld, nestedFieldBuilder);
ilGenerator.Emit(OpCodes.Stloc_0);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;返回结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ilGenerator.Emit(OpCodes.Ldloc_0);
ilGenerator.Emit(OpCodes.Ret);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;第5步：完成类型&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
nestedTypeBuilder.CreateType();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、生成GetClosure方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.声明方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
getClosureMethod = typeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetClosure&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, MethodAttributes.Public
&lt;/span&gt;| MethodAttributes.Static, &lt;span&gt;typeof&lt;/span&gt;(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;), &lt;span&gt;new&lt;/span&gt; Type[] { });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.声明两个局部变量&lt;/strong&gt;&lt;br/&gt;用于暂存&lt;br/&gt;LocalBuilder localBuilder0 = ilGenerator.DeclareLocal(nestedTypeBuilder);&lt;br/&gt;用于返回结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
LocalBuilder retlocalBuilder = ilGenerator.DeclareLocal(&lt;span&gt;typeof&lt;/span&gt;(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.创建一个内部类实例，保存到localBuilder0&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ilGenerator.Emit(OpCodes.Newobj, nestedNewBuilder);
ilGenerator.Emit(OpCodes.Stloc_0);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4.给这个实例的字段初始化为0&lt;/strong&gt;&lt;br/&gt;这里是对应示例程序&lt;br/&gt;var n = 0;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ilGenerator.Emit(OpCodes.Ldloc_0);
ilGenerator.Emit(OpCodes.Ldc_I4_0);
ilGenerator.Emit(OpCodes.Stfld, nestedFieldBuilder);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5.生成一个Func&amp;lt;int&amp;gt;实例，并保存&lt;/strong&gt;&lt;br/&gt;这里用Ldftn指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ilGenerator.Emit(OpCodes.Ldloc_0);
ilGenerator.Emit(OpCodes.Ldftn, nestedLambdsMethod);
ilGenerator.Emit(OpCodes.Newobj, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;).GetConstructors()[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
ilGenerator.Emit(OpCodes.Stloc_1);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;6.返回结果&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ilGenerator.Emit(OpCodes.Ldloc_1);
ilGenerator.Emit(OpCodes.Ret);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、生成测试方法&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;这个比较简单，不是本篇重点。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GenerateMain()
        {
            mainMethod &lt;/span&gt;= typeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, MethodAttributes.Public
                &lt;/span&gt;| MethodAttributes.Static, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;void&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Type[] { });
            ILGenerator ilGenerator &lt;/span&gt;=&lt;span&gt; mainMethod.GetILGenerator();

            LocalBuilder localBuilder0 &lt;/span&gt;= ilGenerator.DeclareLocal(&lt;span&gt;typeof&lt;/span&gt;(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;));

            ilGenerator.Emit(OpCodes.Call, getClosureMethod);
            ilGenerator.Emit(OpCodes.Stloc_0);

            ilGenerator.Emit(OpCodes.Ldloc_0);
            ilGenerator.Emit(OpCodes.Callvirt, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invoke&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Type[] { }));
            ilGenerator.Emit(OpCodes.Call, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Console).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WriteLine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)}));

            ilGenerator.Emit(OpCodes.Ldloc_0);
            ilGenerator.Emit(OpCodes.Callvirt, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invoke&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Type[] { }));
            ilGenerator.Emit(OpCodes.Call, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Console).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WriteLine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) }));

            ilGenerator.Emit(OpCodes.Ldloc_0);
            ilGenerator.Emit(OpCodes.Callvirt, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invoke&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Type[] { }));
            ilGenerator.Emit(OpCodes.Call, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Console).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WriteLine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) }));

            EmitReadKey(ilGenerator);
            ilGenerator.Emit(OpCodes.Ret);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完整的程序如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52.5&quot;&gt;&lt;img id=&quot;code_img_closed_d0ce5454-05fd-4cc8-8ca4-a3fdbbc0dbe5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d0ce5454-05fd-4cc8-8ca4-a3fdbbc0dbe5&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d0ce5454-05fd-4cc8-8ca4-a3fdbbc0dbe5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;100&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Reflection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Reflection.Emit;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; LX1_ILDemo
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo29_Closure
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; binaryName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Demo29_Closure.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; namespaceName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LX1_ILDemo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; typeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DemoClosure&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; AssemblyBuilder assemblyBuilder;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; ModuleBuilder moduleBuilder;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; TypeBuilder typeBuilder;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; MethodBuilder mainMethod;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; MethodBuilder getClosureMethod;

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; TypeBuilder nestedTypeBuilder;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; FieldBuilder nestedFieldBuilder;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; MethodBuilder nestedLambdsMethod;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; ConstructorBuilder nestedNewBuilder;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Generate()
        {
            InitAssembly();
            typeBuilder &lt;/span&gt;= moduleBuilder.DefineType(namespaceName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; typeName, TypeAttributes.Public);

            Generate_Nested();
            Generate_GetClosure();
            GenerateMain();

            assemblyBuilder.SetEntryPoint(mainMethod, PEFileKinds.ConsoleApplication);
            SaveAssembly();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生成成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Generate_Nested()
        {
            nestedTypeBuilder &lt;/span&gt;= typeBuilder.DefineNestedType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ClosureNestedClass&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TypeAttributes.NestedPublic |&lt;span&gt; TypeAttributes.Sealed);
            nestedFieldBuilder &lt;/span&gt;= nestedTypeBuilder.DefineField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NestedFeld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;), FieldAttributes.Public);
            nestedLambdsMethod &lt;/span&gt;= nestedTypeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Run&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, MethodAttributes.Public, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Type[] { });
            nestedNewBuilder &lt;/span&gt;= nestedTypeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Type[] { });
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; il =&lt;span&gt; nestedNewBuilder.GetILGenerator();
            il.Emit(OpCodes.Ret);

            ILGenerator ilGenerator &lt;/span&gt;=&lt;span&gt; nestedLambdsMethod.GetILGenerator();
            LocalBuilder retlocalBuilder &lt;/span&gt;= ilGenerator.DeclareLocal(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
            ilGenerator.Emit(OpCodes.Ldarg_0);
            ilGenerator.Emit(OpCodes.Ldarg_0);
            ilGenerator.Emit(OpCodes.Ldfld, nestedFieldBuilder);
            ilGenerator.Emit(OpCodes.Ldc_I4_1);
            ilGenerator.Emit(OpCodes.Add);
            ilGenerator.Emit(OpCodes.Stfld, nestedFieldBuilder);
            ilGenerator.Emit(OpCodes.Ldarg_0);
            ilGenerator.Emit(OpCodes.Ldfld, nestedFieldBuilder);
            ilGenerator.Emit(OpCodes.Stloc_0);

            ilGenerator.Emit(OpCodes.Ldloc_0);
            ilGenerator.Emit(OpCodes.Ret);

            nestedTypeBuilder.CreateType(); 
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Generate_GetClosure()
        {
            getClosureMethod &lt;/span&gt;= typeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetClosure&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, MethodAttributes.Public
               &lt;/span&gt;| MethodAttributes.Static, &lt;span&gt;typeof&lt;/span&gt;(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Type[] { });
            ILGenerator ilGenerator &lt;/span&gt;=&lt;span&gt; getClosureMethod.GetILGenerator();
           
            LocalBuilder localBuilder0 &lt;/span&gt;=&lt;span&gt; ilGenerator.DeclareLocal(nestedTypeBuilder);
            LocalBuilder retlocalBuilder &lt;/span&gt;= ilGenerator.DeclareLocal(&lt;span&gt;typeof&lt;/span&gt;(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;));

            ilGenerator.Emit(OpCodes.Newobj, nestedNewBuilder);
            ilGenerator.Emit(OpCodes.Stloc_0);

            ilGenerator.Emit(OpCodes.Ldloc_0);
            ilGenerator.Emit(OpCodes.Ldc_I4_0);
            ilGenerator.Emit(OpCodes.Stfld, nestedFieldBuilder);

            ilGenerator.Emit(OpCodes.Ldloc_0);
            ilGenerator.Emit(OpCodes.Ldftn, nestedLambdsMethod);
            ilGenerator.Emit(OpCodes.Newobj, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;).GetConstructors()[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
            ilGenerator.Emit(OpCodes.Stloc_1);

            ilGenerator.Emit(OpCodes.Ldloc_1);
            ilGenerator.Emit(OpCodes.Ret);

        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GenerateMain()
        {
            mainMethod &lt;/span&gt;= typeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, MethodAttributes.Public
                &lt;/span&gt;| MethodAttributes.Static, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;void&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Type[] { });
            ILGenerator ilGenerator &lt;/span&gt;=&lt;span&gt; mainMethod.GetILGenerator();

            LocalBuilder localBuilder0 &lt;/span&gt;= ilGenerator.DeclareLocal(&lt;span&gt;typeof&lt;/span&gt;(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;));

            ilGenerator.Emit(OpCodes.Call, getClosureMethod);
            ilGenerator.Emit(OpCodes.Stloc_0);

            ilGenerator.Emit(OpCodes.Ldloc_0);
            ilGenerator.Emit(OpCodes.Callvirt, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invoke&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Type[] { }));
            ilGenerator.Emit(OpCodes.Call, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Console).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WriteLine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)}));

            ilGenerator.Emit(OpCodes.Ldloc_0);
            ilGenerator.Emit(OpCodes.Callvirt, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invoke&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Type[] { }));
            ilGenerator.Emit(OpCodes.Call, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Console).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WriteLine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) }));

            ilGenerator.Emit(OpCodes.Ldloc_0);
            ilGenerator.Emit(OpCodes.Callvirt, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Func&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invoke&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Type[] { }));
            ilGenerator.Emit(OpCodes.Call, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Console).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WriteLine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) }));

            EmitReadKey(ilGenerator);
            ilGenerator.Emit(OpCodes.Ret);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; EmitReadKey(ILGenerator ilGenerator)
        {
            MethodInfo readKeyMethod &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt;(Console).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ReadKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Type[] { });
            ilGenerator.Emit(OpCodes.Call, readKeyMethod);
            ilGenerator.Emit(OpCodes.Pop);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitAssembly()
        {
            AssemblyName assemblyName &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AssemblyName(namespaceName);
            assemblyBuilder &lt;/span&gt;=&lt;span&gt; AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave);
            moduleBuilder &lt;/span&gt;=&lt;span&gt; assemblyBuilder.DefineDynamicModule(assemblyName.Name, binaryName);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SaveAssembly()
        {
            Type t &lt;/span&gt;= typeBuilder.CreateType(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成Type，这是必须的&lt;/span&gt;
&lt;span&gt;            assemblyBuilder.Save(binaryName);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 17 Apr 2018 07:39:00 +0000</pubDate>
<dc:creator>Z语言</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tkt2016/p/8867086.html</dc:identifier>
</item>
<item>
<title>用PHP如何实现这种乘法口诀表？ - 40叔</title>
<link>http://www.cnblogs.com/40shu/p/8867066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/40shu/p/8867066.html</guid>
<description>[unable to retrieve full-text content]用PHP如何实现这种乘法口诀表？ 1x1=1 ,1x2=2 ,1x3=3 ,.....,1x9=9 2x2=4 ,2x3=6 ,......,2x9=18 ........ ...... 8x8=64 , 8x9=72 9x9=81 用 WHILE怎么写，没理出思路，请过来人给出下代码 ，感觉太笨了</description>
<pubDate>Tue, 17 Apr 2018 07:36:00 +0000</pubDate>
<dc:creator>40叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/40shu/p/8867066.html</dc:identifier>
</item>
<item>
<title>JS继承的一些见解 - Mr.苏</title>
<link>http://www.cnblogs.com/suyuanli/p/8866918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suyuanli/p/8866918.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;js在es6之前的继承是五花八门的。而且要在项目中灵活运用面向对象写法也是有点别扭，更多的时候还是觉得面向过程的写法更为简单，效率也高。久而久之对js的继承每隔一段时间就会理解出现困难。所以这次我要把对对象的理解写下来，这样应该就深刻一点了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们先来看看一个对象是怎么生成的&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 三种创建对象的方法&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; obj &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; obj2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Object&lt;/span&gt;()
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; obj3 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;// 创建一个空字符串对象&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; obj4 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;String&lt;/span&gt;()

&lt;span class=&quot;va&quot;&gt;obj&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;obj2&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt;        &lt;span class=&quot;co&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;obj&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;obj2&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;obj4&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;String&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;         &lt;span class=&quot;co&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;obj4&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;__proto__&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;// ture&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这三种方法，前面两种是一样的。它们创建的空对象都具有原型，而第三种方式创建的是一个真正意义上的空对象，它不继承任何属性；而obj4呢是一个字符串对象。看下图的对比：&lt;br/&gt;下面对象除了obj3都有个__proto__的隐性属性，这个属性指向的是该创建该实例的构造函数的原型。&lt;br/&gt;&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1523691451000-012.jpg&quot; title=&quot;js对象图1&quot; alt=&quot;js对象图1&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里obj和obj2虽然是空对象，不过它们具有Object构造函数的属性的方法，而obj4除了有obj拥有的属性和方法，它还具备了String拥有的属性和方法；而obj3是真正的空对象，它的__proto__指向的是null。&lt;/p&gt;
&lt;h5 id=&quot;我们再将obj4全部展开看看&quot;&gt;我们再将obj4全部展开看看：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1523692671000-427.jpg&quot; title=&quot;js对象图2&quot; alt=&quot;js对象图2&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;再来看看它们之间的关系&quot;&gt;再来看看它们之间的关系：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1523695882000-212.png&quot; title=&quot;js对象图3&quot; alt=&quot;js对象图3&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如上图，我举得例子是Object和String这两个原生具有的构造器。它们的关系和我们平时写的父类和子类之间的关系是一样的，所有的类最终都会指向Object。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在es5的时代，我们用到的继承最简单的就是原型链继承了&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 我们先创建一个父类&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Super&lt;/span&gt; (name) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; name
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'我是父类'&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Super&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;move&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'在跑'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 子类继承父类&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Child&lt;/span&gt; (name) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; name
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Child&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Super&lt;/span&gt;()
&lt;span class=&quot;co&quot;&gt;// 原型链继承，子类原型的私有方法和属性要在继承之后添加，不然会被覆盖&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Child&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Child       &lt;span class=&quot;co&quot;&gt;// 修复对构造函数的指向&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Child&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;eat&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; 
  &lt;span class=&quot;co&quot;&gt;// 做点啥&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;原型链继承就是将子类的原型等于父类的实例，然后再添加子类原型的属性和方法。这样的缺点就是只能继承一个父类。而且在创建子类的实例的时候，不能传参给父类。在做单一继承而且父类不需要传参的时候，这种写法是最好的选择了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面在介绍一种我个人觉得已经很不错的继承方式（组合继承）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 子类继承父类&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Child&lt;/span&gt; (name) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;Super&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;call&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; name
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Child&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Super&lt;/span&gt;()
&lt;span class=&quot;va&quot;&gt;Child&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Child       &lt;span class=&quot;co&quot;&gt;// 修复对构造函数的指向&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Child&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;eat&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; 
  &lt;span class=&quot;co&quot;&gt;// 做点啥&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;这种继承方式就是粗暴的将父类Super构造函数利用对象冒充的方式将父类的实例属性复制到子类里。在用原型继承的方式继承父类原型的属性和方法。&lt;/li&gt;
&lt;li&gt;这样的继承方式，你会发现子类的实例的属性和__proto__下都有父类的属性,而子类实例的把子类原型的覆盖了。&lt;/li&gt;
&lt;li&gt;这样的方式可以实现对多个父类（&lt;span&gt;非原型部分&lt;/span&gt;）的继承。因为原型的继承是链式的，所以只能继承一个。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;一般来说这种继承方式已经很好了，代码量少。继承性好，弊端也没有影响。这就是ES6之前的继承。下面再来看看ES6是怎么操作的。&lt;/p&gt;
&lt;h3 id=&quot;es6的class&quot;&gt;ES6的class&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。&lt;/li&gt;
&lt;li&gt;基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;上面这两句话是引用阮一峰对ES6的class的简介(&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/class&quot; target=&quot;_blank&quot;&gt;Class 的基本语法&lt;/a&gt;)。阮大神的ECMAScript 6 入门真的是对es6初学者居家必备的好东西。我在这里就谈谈我的理解好了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 写一个class&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Point &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt;(x&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; y) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; x&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; y&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;at&quot;&gt;toString&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'('&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;', '&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;')'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; point &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Point&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)       &lt;span class=&quot;co&quot;&gt;// new一个实例&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面看下point内部是怎样的，可以看出constructor，toString都是在“&lt;strong&gt;proto&lt;/strong&gt;”内的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1523869463000-173.png&quot; title=&quot;js对象图4&quot; alt=&quot;js对象图4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里会等价于构造函数的什么写法呢&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 写一个class&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Point&lt;/span&gt; (x&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; y) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; x
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; y
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Point&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;toString&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'('&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;', '&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;')'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; point &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Point&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)       &lt;span class=&quot;co&quot;&gt;// new一个实例&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在不考虑class静态属性的情况下，可以简单理解为constructor内this下的新属性和方法都属于构造函数内的，而constructor外的方法都是prototype下的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;在看看class的继承&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ChildPoint &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Point &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt; (x&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; y&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; z) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(x&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; y)
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; z
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;toString&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'('&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;', '&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;','&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;')'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;changeX&lt;/span&gt; (x) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; x
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; childPoint &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;ChildPoint&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)      &lt;span class=&quot;co&quot;&gt;// new一个ChildPoint的实例&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;childPoint&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;x&lt;/span&gt;)                &lt;span class=&quot;co&quot;&gt;// 2&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;childPoint&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;y&lt;/span&gt;)                &lt;span class=&quot;co&quot;&gt;// 3&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;childPoint&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;z&lt;/span&gt;)                &lt;span class=&quot;co&quot;&gt;// 4&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;childPoint&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;toString&lt;/span&gt;())       &lt;span class=&quot;co&quot;&gt;// 2,3,4&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;childPoint&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;changeX&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;childPoint&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;x&lt;/span&gt;)                &lt;span class=&quot;co&quot;&gt;// 5&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;childPoint&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;ChildPoint&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;)    &lt;span class=&quot;co&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;childPoint&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;__proto__&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Point&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;)         &lt;span class=&quot;co&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;childPoint&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; ChildPoint)    &lt;span class=&quot;co&quot;&gt;// true&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里class是通过extends继承父类的，而子类的constructor方法内需要调用super()方法，这相当与调用了父类的constructor()方法。&lt;/p&gt;
&lt;p&gt;下面看下childPoint的内部情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1523875338000-822.png&quot; title=&quot;js对象图5&quot; alt=&quot;js对象图5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图片和上面打印的情况可以看出，es6的继承和组合继承很是相似。唯一的不同点就是es6的继承没有组合继承产生的多余的一份实例属性在原型里。看起来很顺眼。不过相对的es6的不能多继承（&lt;span&gt;虽然组合继承只能多继承多个构造函数，并不能继承多个原型&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;其实组合继承还可以进一步升级成es6继承那个样子的(寄生组合继承)：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 我们先创建一个父类&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Super&lt;/span&gt; (name) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; name
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'我是父类'&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Super&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;move&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'在跑'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;co&quot;&gt;// 子类继承父类&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Child&lt;/span&gt; (name) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;Super&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;call&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; name
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 创建一个没有Super实例的中间类&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; MiddleSuper &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;MiddleSuper&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Super&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototyoe&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;// 跟Super共享原型 &lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 在这里MiddleSuper和Super的区别就是有没有实例了。&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 然后在正常进行组合继承的操作&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;Child&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;MiddleSuper&lt;/span&gt;()
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)()
&lt;span class=&quot;va&quot;&gt;Child&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Child       &lt;span class=&quot;co&quot;&gt;// 修复对构造函数的指向&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Child&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;eat&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; 
  &lt;span class=&quot;co&quot;&gt;// 做点啥&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1523934606000-937.png&quot; title=&quot;js对象图6&quot; alt=&quot;js对象图6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过这一系列复杂的操作后我们就得到了一份和es6一样的结构了。不过es6只需要一个extends，而es6之前我们就得长篇大论的写才能实现，而且还特别绕。所以一句话，快去学es6吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;该文纯属个人见解，有什么问题请指出。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;本文参考了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 17 Apr 2018 07:21:00 +0000</pubDate>
<dc:creator>Mr.苏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suyuanli/p/8866918.html</dc:identifier>
</item>
<item>
<title>Python3 面向对象 - 1024python</title>
<link>http://www.cnblogs.com/zzzhfo/p/8866818.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzzhfo/p/8866818.html</guid>
<description>&lt;h3&gt;一、面向对象的程序设计的由来&lt;/h3&gt;
&lt;p&gt;http://www.cnblogs.com/zzzhfo/p/8855776.html&lt;/p&gt;
&lt;h3&gt;二、什么是面向对象的程序设计及为什么要有它&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;面向过程编程&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;面向过程的程序设计：核心是过程二字，过程指的是解决问题的步骤，即先干什么再干什么....面向过程的设计就好比精心设计好的一条流水线，是一种机械式的思维方式问题。
优点是：复杂度的问题流程化，进而简单化(一个复杂的问题，分成一个个小的步骤去实现，实现小的步骤将会非常简单)
缺点是：一套流水线或者流程就是用来解决一个问题，生产汽水的流水线无法生产汽车，即便是能，也得是大改，改一个组件，牵一发而动全身。
应用场景：一旦完成基本很少改变的场景，著名的例子有：Linux内核，git，以及Apache HTTP Server等。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;面向对象编程&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
面向对象的程序设计：核心是对象二字，（要理解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，不存在的也可以创造出来。面向对象的程序设计好比如来设计西游记，&lt;br/&gt;如来要解决的问题是把经书传给东土大唐，如来想了想解决这个问题需要四个人：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象&lt;br/&gt;的数据属性和方法属性），然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与&lt;br/&gt;妖魔鬼怪神仙交互着直到最后取得真经。如来根本不会管师徒四人按照什么流程去取),对象是特征与技能的结合体，基于面向对象设计程序就好比在创造一个世界，你就是这个世界的上帝，存&lt;br/&gt;在的皆为对象，不存在的也可以创造出来，与面向过程机械式的思维方式形成鲜明对比，面向对象更加注重对现实世界的模拟，是一种“上帝式”的思维方式。
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;面向对象编程的优点：&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
优点是：解决了程序的扩展性。对某一个对象单独修改，会立即反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;面向对象编程的缺点：&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;缺点：
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、编程的复杂度远高于面向过程，不了解面向对象而立即上手基于它设计程序，极容易出现过度设计的问题。一些扩展性要求低的场景使用面向对象会徒增编程的难度，比如管理Linux系统的shell脚本&lt;br/&gt;就不适合面向对象去设计，面向过程反而更加适合。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、无法面向过程的程序设计流水式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法精准地预测最终结果。于是我们经常看到对战类&lt;br/&gt;的游戏，新增一个游戏人物，在对战的过程中极容易出现阴霸的技能，一刀砍死3个人，这种情况是无法准确预知的，只有对象之间交互才能准确地直到最终的结果。
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;面向对象编程的应用场景：&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;面向对象的程序设计并不是全部。对于一个软件质量来说，面向对象的程序设计只是用来解决扩展性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1011251/201804/1011251-20180417144610112-1268419765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;三、类与对象&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;类即类别、种类，是面向对象设计最重要的概念，对象是特征与技能的结合体，而类则是一系列对象相似的特征与技能的结合体
那么问题来了，先有的一个个具体的存在对象(比如一个具体存在的人)，还是先有的人类这个概念，这个问题需要分两种情况去看
在现实世界中：先有对象，再有类

世界上肯定是先出现各种各样的实际存在的物体，然后随着人类文明的发展，人类站在不同的角度总结出了不同的种类，如人类、动物类、植物类等概念

也就说，对象是具体的存在，而类仅仅只是一个概念，并不真实存在

在程序中：务必保证先定义类，后产生对象

这与函数的使用是类似的，先定义函数，后调用函数，类也是一样的，在程序中需要先定义类，后调用类

不一样的是，调用函数会执行函数体代码返回的是函数体执行的结果，而调用类会产生对象，返回的是对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照上述步骤，我们来定义一个类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('013df272-d4c8-459a-a197-f58ca486793d')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_013df272-d4c8-459a-a197-f58ca486793d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_013df272-d4c8-459a-a197-f58ca486793d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('013df272-d4c8-459a-a197-f58ca486793d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_013df272-d4c8-459a-a197-f58ca486793d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#在现实世界中，站在老男孩学校的角度：先有对象，再有类
对象1：李坦克
    特征:
        学校&lt;/span&gt;=&lt;span&gt;oldboy
        姓名&lt;/span&gt;=&lt;span&gt;李坦克
        性别&lt;/span&gt;=&lt;span&gt;男
        年龄&lt;/span&gt;=&lt;span&gt;18&lt;/span&gt;&lt;span&gt;
    技能：
        学习
        吃饭
        睡觉

对象2：王大炮
    特征:
        学校&lt;/span&gt;=&lt;span&gt;oldboy
        姓名&lt;/span&gt;=&lt;span&gt;王大炮
        性别&lt;/span&gt;=&lt;span&gt;女
        年龄&lt;/span&gt;=&lt;span&gt;38&lt;/span&gt;&lt;span&gt;
    技能：
        学习
        吃饭
        睡觉

对象3：牛榴弹
    特征:
        学校&lt;/span&gt;=&lt;span&gt;oldboy
        姓名&lt;/span&gt;=&lt;span&gt;牛榴弹
        性别&lt;/span&gt;=&lt;span&gt;男
        年龄&lt;/span&gt;=&lt;span&gt;78&lt;/span&gt;&lt;span&gt;
    技能：
        学习
        吃饭
        睡觉


现实中的老男孩学生类
    相似的特征:
        学校&lt;/span&gt;=&lt;span&gt;oldboy
    相似的技能：
        学习
        吃饭
        睡觉&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;在现实世界中：先有对象，再有类&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('de8a0ad5-dcc3-4c4b-bbd5-a5430b62d251')&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_de8a0ad5-dcc3-4c4b-bbd5-a5430b62d251&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_de8a0ad5-dcc3-4c4b-bbd5-a5430b62d251&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('de8a0ad5-dcc3-4c4b-bbd5-a5430b62d251',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_de8a0ad5-dcc3-4c4b-bbd5-a5430b62d251&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#在程序中，务必保证：先定义（类），后使用（产生对象）
PS:
  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. 在程序中特征用变量标识，技能用函数标识
  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. 因而类中最常见的无非是：变量和函数的定义

#程序中的类
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldboyStudent:
    school&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    def learn(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;is learning&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        
    def eat(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;is eating&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    
    def sleep(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;is sleeping&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  


#注意：
  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.类中可以有任意python代码，这些代码在类定义阶段便会执行
  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.因而会产生新的名称空间，用来存放类的变量名与函数名，可以通过OldboyStudent.__dict__查看
  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.对于经典类来说我们可以通过该字典操作类名称空间的名字（新式类有限制），但python为我们提供专门的.语法
  &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.点是访问属性的语法，类中定义的名字，都是类的属性

#程序中类的用法
.:专门用来访问属性，本质操作的就是__dict__
OldboyStudent.school #等于经典类的操作OldboyStudent.__dict__[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;school&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
OldboyStudent.school&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; #等于经典类的操作OldboyStudent.__dict__[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;school&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
OldboyStudent.x&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt; #等于经典类的操作OldboyStudent.__dict__[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
del OldboyStudent.x #等于经典类的操作OldboyStudent.__dict__.pop(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


#程序中的对象
#调用类，或称为实例化，得到对象
s1&lt;/span&gt;=&lt;span&gt;OldboyStudent()
s2&lt;/span&gt;=&lt;span&gt;OldboyStudent()
s3&lt;/span&gt;=&lt;span&gt;OldboyStudent()

#如此，s1、s2、s3都一样了，而这三者除了相似的属性之外还各种不同的属性，这就用到了__init__
#注意：该方法是在对象产生之后才会执行，只用来为对象进行初始化操作，可以有任意代码，但一定不能有返回值
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldboyStudent:
    ......
    def __init__(self,name,age,sex):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
        self.sex&lt;/span&gt;=&lt;span&gt;sex
    ......


s1&lt;/span&gt;=OldboyStudent(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;李坦克&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;) #先调用类产生空对象s1，然后调用OldboyStudent.__init__(s1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;李坦克&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;&lt;span&gt;)
s2&lt;/span&gt;=OldboyStudent(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;王大炮&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;38&lt;/span&gt;&lt;span&gt;)
s3&lt;/span&gt;=OldboyStudent(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;牛榴弹&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;78&lt;/span&gt;&lt;span&gt;)


#程序中对象的用法
#执行__init__,s1.name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;牛榴弹&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;，很明显也会产生对象的名称空间
s2.__dict__
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;王大炮&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;38&lt;/span&gt;&lt;span&gt;}

s2.name #s2.__dict__[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
s2.name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;王三炮&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; #s2.__dict__[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;王三炮&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
s2.course&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; #s2.__dict__[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;course&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
del s2.course #s2.__dict__.pop(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;course&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;在程序中：先定义类，后产生对象&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;！！！细说__init__方法！！！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e3258c6d-1167-4456-be2f-6decd3c5606d')&quot; readability=&quot;65.5&quot;&gt;&lt;img id=&quot;code_img_closed_e3258c6d-1167-4456-be2f-6decd3c5606d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e3258c6d-1167-4456-be2f-6decd3c5606d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e3258c6d-1167-4456-be2f-6decd3c5606d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e3258c6d-1167-4456-be2f-6decd3c5606d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;126&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#方式一、为对象初始化自己独有的特征
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; People:
    country&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;China&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    x&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    def run(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-----&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self)

# 实例化出三个空对象
obj1&lt;/span&gt;=&lt;span&gt;People()
obj2&lt;/span&gt;=&lt;span&gt;People()
obj3&lt;/span&gt;=&lt;span&gt;People()

# 为对象定制自己独有的特征
obj1.name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
obj1.age&lt;/span&gt;=&lt;span&gt;18&lt;/span&gt;&lt;span&gt;
obj1.sex&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

obj2.name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
obj2.age&lt;/span&gt;=&lt;span&gt;38&lt;/span&gt;&lt;span&gt;
obj2.sex&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

obj3.name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
obj3.age&lt;/span&gt;=&lt;span&gt;38&lt;/span&gt;&lt;span&gt;
obj3.sex&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

# print(obj1.__dict__)
# print(obj2.__dict__)
# print(obj3.__dict__)
# print(People.__dict__)





#方式二、为对象初始化自己独有的特征
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; People:
    country&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;China&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    x&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    def run(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-----&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self)

# 实例化出三个空对象
obj1&lt;/span&gt;=&lt;span&gt;People()
obj2&lt;/span&gt;=&lt;span&gt;People()
obj3&lt;/span&gt;=&lt;span&gt;People()

# 为对象定制自己独有的特征
def chu_shi_hua(obj, x, y, z): #obj&lt;/span&gt;=obj1,x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,y=&lt;span&gt;18&lt;/span&gt;,z=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    obj.name &lt;/span&gt;=&lt;span&gt; x
    obj.age &lt;/span&gt;=&lt;span&gt; y
    obj.sex &lt;/span&gt;=&lt;span&gt; z

chu_shi_hua(obj1,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
chu_shi_hua(obj2,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;38&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
chu_shi_hua(obj3,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;38&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)





#方式三、为对象初始化自己独有的特征
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; People:
    country&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;China&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    x&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;

    def chu_shi_hua(obj, x, y, z): #obj&lt;/span&gt;=obj1,x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,y=&lt;span&gt;18&lt;/span&gt;,z=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        obj.name &lt;/span&gt;=&lt;span&gt; x
        obj.age &lt;/span&gt;=&lt;span&gt; y
        obj.sex &lt;/span&gt;=&lt;span&gt; z

    def run(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-----&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self)


obj1&lt;/span&gt;=&lt;span&gt;People()
# print(People.chu_shi_hua)
People.chu_shi_hua(obj1,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

obj2&lt;/span&gt;=&lt;span&gt;People()
People.chu_shi_hua(obj2,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;38&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

obj3&lt;/span&gt;=&lt;span&gt;People()
People.chu_shi_hua(obj3,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;38&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)




# 方式四、为对象初始化自己独有的特征
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; People:
    country&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;China&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    x&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;

    def __init__(obj, x, y, z): #obj&lt;/span&gt;=obj1,x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,y=&lt;span&gt;18&lt;/span&gt;,z=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        obj.name &lt;/span&gt;=&lt;span&gt; x
        obj.age &lt;/span&gt;=&lt;span&gt; y
        obj.sex &lt;/span&gt;=&lt;span&gt; z

    def run(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-----&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self)

obj1&lt;/span&gt;=People(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) #People.__init__(obj1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
obj2&lt;/span&gt;=People(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;38&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) #People.__init__(obj2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;38&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
obj3&lt;/span&gt;=People(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;38&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) #People.__init__(obj3,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;38&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


# __init__方法
# 强调：
#   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、该方法内可以有任意的python代码
#   &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;、一定不能有返回值
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; People:
    country&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;China&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    x&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;

    def __init__(obj, name, age, sex): #obj&lt;/span&gt;=obj1,x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,y=&lt;span&gt;18&lt;/span&gt;,z=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        # &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; type(name) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; not str:
        #     raise TypeError(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;名字必须是字符串类型&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        obj.name &lt;/span&gt;=&lt;span&gt; name
        obj.age &lt;/span&gt;=&lt;span&gt; age
        obj.sex &lt;/span&gt;=&lt;span&gt; sex


    def run(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-----&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self)


# obj1&lt;/span&gt;=People(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
obj1&lt;/span&gt;=People(&lt;span&gt;3537&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

# print(obj1.run)
# obj1.run() #People.run(obj1)
# print(People.run)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;__init__方法之为对象定制自己独有的特征&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 站的角度不同，定义出的类是截然不同的，详见面向对象实战之需求分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 现实中的类并不完全等于程序中的类，比如现实中的公司类，在程序中有时需要拆分成部门类，业务类...... &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 有时为了编程需求，程序中也可能会定义现实中不存在的类，比如策略类，现实中并不存在，但是在程序中却是一个很常见的类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1e841fa7-9855-48fc-b29c-c52a8007c606')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_1e841fa7-9855-48fc-b29c-c52a8007c606&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1e841fa7-9855-48fc-b29c-c52a8007c606&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1e841fa7-9855-48fc-b29c-c52a8007c606',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1e841fa7-9855-48fc-b29c-c52a8007c606&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#python为类内置的特殊属性
类名.__name__# 类的名字(字符串)
类名.__doc__# 类的文档字符串
类名.__base__# 类的第一个父类(在讲继承时会讲)
类名.__bases__# 类所有父类构成的元组(在讲继承时会讲)
类名.__dict__# 类的字典属性
类名.__module__# 类定义所在的模块
类名.__class__# 实例对应的类(仅新式类中)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;类的特殊属性(了解即可)&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;！！！补充说明：从代码级别看面向对象 ！！！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8ec6c8e2-2b91-45bc-bb25-94c222dd6f77')&quot; readability=&quot;66&quot;&gt;&lt;img id=&quot;code_img_closed_8ec6c8e2-2b91-45bc-bb25-94c222dd6f77&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8ec6c8e2-2b91-45bc-bb25-94c222dd6f77&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8ec6c8e2-2b91-45bc-bb25-94c222dd6f77',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8ec6c8e2-2b91-45bc-bb25-94c222dd6f77&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;127&quot;&gt;
&lt;pre&gt;
#&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、在没有学习类这个概念时，数据与功能是分离的
def exc1(host,port,db,charset):
    conn&lt;/span&gt;=&lt;span&gt;connect(host,port,db,charset)
    conn.execute(sql)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; xxx


def exc2(host,port,db,charset,proc_name)
    conn&lt;/span&gt;=&lt;span&gt;connect(host,port,db,charset)
    conn.call_proc(sql)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; xxx

#每次调用都需要重复传入一堆参数
exc1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;3306&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from tb1;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
exc2(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;3306&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;存储过程的名字&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)




#&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;、我们能想到的解决方法是，把这些变量都定义成全局变量
HOST&lt;/span&gt;=‘&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;’
PORT&lt;/span&gt;=&lt;span&gt;3306&lt;/span&gt;&lt;span&gt;
DB&lt;/span&gt;=&lt;span&gt;‘db1’
CHARSET&lt;/span&gt;=&lt;span&gt;‘utf8’

def exc1(host,port,db,charset):
    conn&lt;/span&gt;=&lt;span&gt;connect(host,port,db,charset)
    conn.execute(sql)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; xxx


def exc2(host,port,db,charset,proc_name)
    conn&lt;/span&gt;=&lt;span&gt;connect(host,port,db,charset)
    conn.call_proc(sql)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; xxx

exc1(HOST,PORT,DB,CHARSET,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from tb1;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
exc2(HOST,PORT,DB,CHARSET,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;存储过程的名字&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


#&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、但是2的解决方法也是有问题的，按照2的思路，我们将会定义一大堆全局变量，这些全局变量并没有做任何区分，即能够被所有功能使用，然而事实上只有HOST，PORT，DB，CHARSET是给exc1和exc2这两个功能用的。言外之意：我们必须找出一种能够将数据与操作数据的方法组合到一起的解决方法，这就是我们说的类了

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MySQLHandler:
    def __init__(self,host,port,db,charset&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        self.host&lt;/span&gt;=&lt;span&gt;host
        self.port&lt;/span&gt;=&lt;span&gt;port
        self.db&lt;/span&gt;=&lt;span&gt;db
        self.charset&lt;/span&gt;=&lt;span&gt;charset
    def exc1(self,sql):
        conn&lt;/span&gt;=&lt;span&gt;connect(self.host,self.port,self.db,self.charset)
        res&lt;/span&gt;=&lt;span&gt;conn.execute(sql)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res


    def exc2(self,sql):
        conn&lt;/span&gt;=&lt;span&gt;connect(self.host,self.port,self.db,self.charset)
        res&lt;/span&gt;=&lt;span&gt;conn.call_proc(sql)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res


obj&lt;/span&gt;=MySQLHandler(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;3306&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
obj.exc1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from tb1;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
obj.exc2(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;存储过程的名字&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


#改进
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MySQLHandler:
    def __init__(self,host,port,db,charset&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        self.host&lt;/span&gt;=&lt;span&gt;host
        self.port&lt;/span&gt;=&lt;span&gt;port
        self.db&lt;/span&gt;=&lt;span&gt;db
        self.charset&lt;/span&gt;=&lt;span&gt;charset
        self.conn&lt;/span&gt;=&lt;span&gt;connect(self.host,self.port,self.db,self.charset)
    def exc1(self,sql):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.conn.execute(sql)

    def exc2(self,sql):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.conn.call_proc(sql)


obj&lt;/span&gt;=MySQLHandler(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;3306&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
obj.exc1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from tb1;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
obj.exc2(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;存储过程的名字&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;数据与专门操作该数据的功能组合到一起&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;四、属性查找&lt;/h3&gt;
&lt;p&gt;类有两种属性：数据属性和函数属性&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1. 类的数据属性是所有对象共享的&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2. 类的函数属性是绑定给对象用的&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a1a4653b-e084-4ef5-8720-364ea9d0228a')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_a1a4653b-e084-4ef5-8720-364ea9d0228a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a1a4653b-e084-4ef5-8720-364ea9d0228a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a1a4653b-e084-4ef5-8720-364ea9d0228a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a1a4653b-e084-4ef5-8720-364ea9d0228a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#类的数据属性是所有对象共享的,id都一样
print(id(OldboyStudent.school))

print(id(s1.school))
print(id(s2.school))
print(id(s3.school))

&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;4377347328&lt;/span&gt;
&lt;span&gt;4377347328&lt;/span&gt;
&lt;span&gt;4377347328&lt;/span&gt;
&lt;span&gt;4377347328&lt;/span&gt;
&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;


#类的函数属性是绑定给对象使用的,obj.method称为绑定方法,内存地址都不一样
#ps:id是python的实现机制,并不能真实反映内存地址,如果有内存地址,还是以内存地址为准
print(OldboyStudent.learn)
print(s1.learn)
print(s2.learn)
print(s3.learn)
&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&amp;lt;function OldboyStudent.learn at &lt;span&gt;0x1021329d8&lt;/span&gt;&amp;gt;
&amp;lt;bound method OldboyStudent.learn of &amp;lt;__main__.OldboyStudent &lt;span&gt;object&lt;/span&gt; at &lt;span&gt;0x1021466d8&lt;/span&gt;&amp;gt;&amp;gt;
&amp;lt;bound method OldboyStudent.learn of &amp;lt;__main__.OldboyStudent &lt;span&gt;object&lt;/span&gt; at &lt;span&gt;0x102146710&lt;/span&gt;&amp;gt;&amp;gt;
&amp;lt;bound method OldboyStudent.learn of &amp;lt;__main__.OldboyStudent &lt;span&gt;object&lt;/span&gt; at &lt;span&gt;0x102146748&lt;/span&gt;&amp;gt;&amp;gt;
&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1011251/201804/1011251-20180417145630073-896363253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt; 在obj.name会先从obj自己的名称空间里找name，找不到则去类中找，类也找不到就找父类...最后都找不到就抛出异常  &lt;/p&gt;
&lt;h3&gt; 五、绑定到对象的方法的特殊之处&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('77da6673-f2a4-49d9-a6b5-9f82d09b9df2')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_77da6673-f2a4-49d9-a6b5-9f82d09b9df2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_77da6673-f2a4-49d9-a6b5-9f82d09b9df2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('77da6673-f2a4-49d9-a6b5-9f82d09b9df2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_77da6673-f2a4-49d9-a6b5-9f82d09b9df2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#改写
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldboyStudent:
    school&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    def __init__(self,name,age,sex):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
        self.sex&lt;/span&gt;=&lt;span&gt;sex
    def learn(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s is learning&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name) #新增self.name

    def eat(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s is eating&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)

    def sleep(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s is sleeping&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)


s1&lt;/span&gt;=OldboyStudent(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;李坦克&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;&lt;span&gt;)
s2&lt;/span&gt;=OldboyStudent(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;王大炮&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;38&lt;/span&gt;&lt;span&gt;)
s3&lt;/span&gt;=OldboyStudent(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;牛榴弹&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;78&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;类中定义的函数（没有被任何装饰器装饰的）是类的函数属性，类可以使用，但必须遵循函数的参数规则，有几个参数需要传几个参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
OldboyStudent.learn(s1) #李坦克 &lt;span&gt;is&lt;/span&gt;&lt;span&gt; learning
OldboyStudent.learn(s2) #王大炮 &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; learning
OldboyStudent.learn(s3) #牛榴弹 &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; learning
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类中定义的函数(没有被任何装饰器装饰的)，其实主要是给对象使用的，而且是绑定到对象指向的都是相同的功能，但是绑定到不同的对象就是不同的绑定方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强调：&lt;/strong&gt;绑定到对象的方法的特殊之处在于，绑定给谁就由谁来调用，谁来调用，就会将'谁'本身当作第一个参数传给方法，即自动传值(方法__init__也是一样的道理)&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;s1.learn() #等同于OldboyStudent.learn(s1)
s2.learn() #等同于OldboyStudent.learn(s2)
s3.learn() #等同于OldboyStudent.learn(s3)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：绑定到对象的方法的这种自动传值的特征，决定了在类中定义的函数都要默认写一个参数self，self可以是任意名字，但是约定俗称地写slef。&lt;/p&gt;
&lt;p&gt;类即类型&lt;/p&gt;
&lt;p&gt;　　提示：Python的class术语与c++有一定的区别，与Modula-3更像。&lt;/p&gt;
&lt;p&gt;　　Python中一切皆对象，且Python3中类与类型是一个概念，类型就是类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#类型dict就是类dict
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; list
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;

#实例化的到3个对象l1,l2,l3
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; l1=&lt;span&gt;list()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; l2=&lt;span&gt;list()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; l3=&lt;span&gt;list()

#三个对象都有绑定方法append,是相同的功能,但内存地址不同
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; l1.append
&lt;/span&gt;&amp;lt;built-&lt;span&gt;in&lt;/span&gt; method append of list &lt;span&gt;object&lt;/span&gt; at &lt;span&gt;0x10b482b48&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; l2.append
&lt;/span&gt;&amp;lt;built-&lt;span&gt;in&lt;/span&gt; method append of list &lt;span&gt;object&lt;/span&gt; at &lt;span&gt;0x10b482b88&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; l3.append
&lt;/span&gt;&amp;lt;built-&lt;span&gt;in&lt;/span&gt; method append of list &lt;span&gt;object&lt;/span&gt; at &lt;span&gt;0x10b482bc8&lt;/span&gt;&amp;gt;&lt;span&gt;

#操作绑定方法l1.append(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;),就是在往l1添加3,绝对不会将3添加到l2或l3
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; l1.append(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; l1
[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; l2
[]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; l3
[]
#调用类list.append(l3,&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;)等同于l3.append(&lt;span&gt;111&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; list.append(l3,&lt;span&gt;111&lt;/span&gt;) #l3.append(&lt;span&gt;111&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; l3
[&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;] 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;六、对象之间的交互&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Garen:        #定义英雄盖伦的类，不同的玩家可以用它实例出自己英雄;
    camp&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Demacia&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  #所有玩家的英雄(盖伦)的阵营都是Demacia;
    def __init__(self,nickname,aggressivity&lt;/span&gt;=&lt;span&gt;58&lt;/span&gt;,life_value=&lt;span&gt;455&lt;/span&gt;&lt;span&gt;): #英雄的初始攻击力58...;
        self.nickname&lt;/span&gt;=&lt;span&gt;nickname  #为自己的盖伦起个别名;
        self.aggressivity&lt;/span&gt;=&lt;span&gt;aggressivity #英雄都有自己的攻击力;
        self.life_value&lt;/span&gt;=&lt;span&gt;life_value #英雄都有自己的生命值;
    def attack(self,enemy):   #普通攻击技能，enemy是敌人;
        enemy.life_value&lt;/span&gt;-=self.aggressivity #根据自己的攻击力，攻击敌人就减掉敌人的生命值。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以仿照garen类再创建一个Riven类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Riven:
    camp&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Noxus&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  #所有玩家的英雄(锐雯)的阵营都是Noxus;
    def __init__(self,nickname,aggressivity&lt;/span&gt;=&lt;span&gt;54&lt;/span&gt;,life_value=&lt;span&gt;414&lt;/span&gt;&lt;span&gt;): #英雄的初始攻击力54;
        self.nickname&lt;/span&gt;=&lt;span&gt;nickname  #为自己的锐雯起个别名;
        self.aggressivity&lt;/span&gt;=&lt;span&gt;aggressivity #英雄都有自己的攻击力;
        self.life_value&lt;/span&gt;=&lt;span&gt;life_value #英雄都有自己的生命值;
    def attack(self,enemy):   #普通攻击技能，enemy是敌人;
        enemy.life_value&lt;/span&gt;-=self.aggressivity #根据自己的攻击力，攻击敌人就减掉敌人的生命值。 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例出俩英雄&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; g1=Garen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;草丛伦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; r1=Riven(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;锐雯雯&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;交互：锐雯雯攻击草丛伦，反之一样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; g1.life_value
&lt;/span&gt;&lt;span&gt;455&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; r1.attack(g1)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; g1.life_value
&lt;/span&gt;&lt;span&gt;401&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;补充：&lt;/p&gt;
&lt;p&gt;　　garen_hero.Q()称为向garen_hero这个对象发送了一条消息，让他去执行Q这个功能，类似的有：&lt;/p&gt;
&lt;p&gt;　　garen_hero.W()&lt;/p&gt;
&lt;p&gt;　　garen_hero.E()&lt;/p&gt;
&lt;p&gt;　　garen_hero.R()&lt;/p&gt;

</description>
<pubDate>Tue, 17 Apr 2018 07:13:00 +0000</pubDate>
<dc:creator>1024python</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzzhfo/p/8866818.html</dc:identifier>
</item>
<item>
<title>使用 C# (.NET Core) 实现模板方法模式 (Template Method Pattern) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/8865861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/8865861.html</guid>
<description>&lt;p&gt;本文的概念内容来自深入浅出设计模式一书.&lt;/p&gt;

&lt;p&gt;有一家咖啡店, 供应咖啡和茶, 它们的工序如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417130920537-1139976129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咖啡:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417131014827-742852147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;茶:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417131042502-950151242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到咖啡和茶的制作工序是差不多的, 都是有4步, 其中有两步它们两个是一样的, 另外两步虽然具体内容不一样, 但是都做做的同一类工作.&lt;/p&gt;
&lt;p&gt;现在问题也有了, 当前的设计两个类里面有很多重复的代码, 那么应该怎样设计以减少冗余呢?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417131344252-1590114625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把共有的方法放到父类里面, 把不同的方法放到子类里面.&lt;/p&gt;
&lt;p&gt;父类里面有一个抽象的prepareRecipe()方法[翻译为准备烹饪方法/制作方法], 然后在不同的子类里面有不同的实现. 也就是说每个子类都有自己制作饮料的方法.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417131739430-1862609843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现两个饮料的制作方法遵循了同样的&lt;strong&gt;算法&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把水烧开&lt;/li&gt;
&lt;li&gt;用开水冲咖啡或茶&lt;/li&gt;
&lt;li&gt;把冲开的饮料放到杯里&lt;/li&gt;
&lt;li&gt;添加适当的调料&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;现在我们来抽像prepareRecipe()方法:&lt;/p&gt;
&lt;p&gt;1.先看看两个饮料的差异:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417132129427-1914843391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两种饮料都有四道工序, 两个是完全一样的, 另外两个在具体的实现上是略有不同的, 但是还是同样性质的工序.&lt;/p&gt;
&lt;p&gt;这两道不同的工序的本质就是冲饮料和添加调料, 所以prepareRecipe()可以这样写:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417132351738-1731192542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 把上面的方法放到超类里:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417132604346-1521114694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个父类是抽象的, prepareRecipe()将会用来制作咖啡或者茶, 而且我不想让子类去重写这个方法, 因为制作工序(算法)是一定的.&lt;/p&gt;
&lt;p&gt;只不过里面的第2部和第4部是需要子类自己来实现的. 所以brew()和addCondiments()是两个抽象的方法, 而另外两个方法则直接在父类里面实现了.&lt;/p&gt;
&lt;p&gt;3. 最后茶和咖啡就是这个样子的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417132920153-1896367918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417132905151-195401030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们意识到两种饮料的工序大体是一致的, 尽管某些工序需要不同的实现方法. 所以我们把这些饮料的制作方法归纳到了一个基类CaffeineBeverage里面.&lt;/p&gt;
&lt;p&gt;CaffeineBeverage控制着整个工序, 第1, 3部由它自己完成, 第2, 4步则是由具体的饮料子类来完成.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417133443946-1074228416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的需求种, prepareRecipe() 就是模板方法. 因为, 它首先是一个方法, 然后它还充当了算法模板的角色, 这个需求里, 算法就是制作饮料的整个工序.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以说: 模板方法定义了一个算法的步骤, 并允许子类提供其中若干个步骤的具体实现&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;1. 我需要做一个茶:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417133805418-1177498120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 然后调用茶的模板方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417133833072-2018756263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 在模板方法里面执行下列工序:&lt;/p&gt;
&lt;p&gt;boildWater();&lt;/p&gt;
&lt;p&gt;brew();&lt;/p&gt;
&lt;p&gt;pourInCup();&lt;/p&gt;
&lt;p&gt;addCondiments();&lt;/p&gt;

&lt;p&gt;不使用模板方法时:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;咖啡和茶各自控制自己的算法.&lt;/li&gt;
&lt;li&gt;饮料间的代码重复.&lt;/li&gt;
&lt;li&gt;改变算法需要修改多个地方&lt;/li&gt;
&lt;li&gt;添加新饮料需要做很多工作.&lt;/li&gt;
&lt;li&gt;算法分布在了不同的类里面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用模板方法后:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CaffeineBeverage这个父类控制并保护算法&lt;/li&gt;
&lt;li&gt;父类最大化的代码的复用&lt;/li&gt;
&lt;li&gt;算法只在一个地方, 改变算法也只需改变这个地方&lt;/li&gt;
&lt;li&gt;新的饮料只需实现部分工序即可&lt;/li&gt;
&lt;li&gt;父类掌握着算法, 但是依靠子类去做具体的实现.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;模板方法在一个方法里定义了一套算法的骨架, 算法的某些步骤可以让子类来实现. 模板方法让子类重新定义算法的某些步骤而无需改变算法的结构&lt;/strong&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;类图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417134631380-801613273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个抽象类:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417134738328-519084116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对这个抽象类, 我们可以有一些扩展:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417134839278-2111177253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看这个hook方法, 它是一个具体的方法, 但是啥也没做, 这种就叫做钩子方法. 子类可以重写该方法, 也可以不重写.&lt;/p&gt;

&lt;p&gt;所谓的钩子, 它是一个在抽象类里面声明的方法, 但是方法里面默认的实现是空的. 这也就给了子类&quot;钩进&quot;算法某个点的能力, 当然子类也可以不这么做, 就看子类是否需要了.&lt;/p&gt;
&lt;p&gt;看这个带钩子的饮料父类:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417135317577-248752717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;customerWantsCondiments()就是钩子, 子类可以重写它.&lt;/p&gt;
&lt;p&gt;在prepareRecipe()方法里面, 通过这个钩子方法的结果来决定是否添加调料.&lt;/p&gt;
&lt;p&gt;下面是使用这个钩子的咖啡:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417135542298-1473840392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;不带钩子的父类:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TemplateMethodPattern.Abstractions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CaffeineBeverage
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PrepareRecipe()
        {
            BoilWater();
            Brew();
            PourInCup();
            AddCondiments();
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BoilWater()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Boiling water&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Brew();

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PourInCup()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pouring into cup&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddCondiments();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;咖啡和茶:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; TemplateMethodPattern.Abstractions;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TemplateMethodPattern.Beverages
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Coffee: CaffeineBeverage
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Brew()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dripping Coffee through filter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddCondiments()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Adding Sugar and Milk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}

&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; TemplateMethodPattern.Abstractions;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TemplateMethodPattern.Beverages
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Tea: CaffeineBeverage
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Brew()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Steeping the tea&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddCondiments()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Adding Lemon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; tea = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tea();
tea.PrepareRecipe();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417135744171-246712317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;带钩子的父类:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TemplateMethodPattern.Abstractions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CaffeineBeverageWithHook
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PrepareRecipe()
        {
            BoilWater();
            Brew();
            PourInCup();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CustomerWantsCondiments())
            {
                AddCondiments();
            }
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Brew();
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddCondiments();

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BoilWater()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Boiling water&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PourInCup()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pouring into cup&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CustomerWantsCondiments()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;咖啡:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; TemplateMethodPattern.Abstractions;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TemplateMethodPattern.Beverages
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CoffeeWithHook: CaffeineBeverageWithHook
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Brew()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dripping Coffee through filter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddCondiments()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Adding Sugar and Milk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CustomerWantsCondiments()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; answer =&lt;span&gt; GetUserInput();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (answer == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetUserInput()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Would you like milk and sugar with you coffee (y/n) ?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; keyInfo =&lt;span&gt; Console.ReadKey();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; keyInfo.KeyChar == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; MakeCoffeeWithHook()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; coffeeWithHook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CoffeeWithHook();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Making coffee...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            coffeeWithHook.PrepareRecipe();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417135919381-31167438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;钩子和抽象方法的区别?&lt;/h2&gt;
&lt;p&gt;抽象方法是算法里面必须要实现的一个方法或步骤, 而钩子是可选实现的.&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;好莱坞设计原则就是: 别给我们打电话, 我们会给你打电话&lt;/strong&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;好莱坞原则可以防止&lt;strong&gt;依赖关系腐烂&lt;/strong&gt;. 依赖关系腐烂是指高级别的组件依赖于低级别的组件, 它又依赖于高级别组件, 它又依赖于横向组件, 又依赖于低级别组件....以此类推. 当腐烂发生的时候, 没人会看懂你的系统是怎么设计的.&lt;/p&gt;
&lt;p&gt;而使用好莱坞原则, 我们可以让低级别组件钩进一个系统, 但是高级别组件决定何时并且以哪种方式它们才会被需要. 换句话说就是, 高级别组件对低级别组件说: &quot;别给我们打电话, 我们给你们打电话&quot;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417140803960-1108760611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417140920981-1913457636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模板方法里, 父类控制算法, 并在需要的时候调用子类的方法.&lt;/p&gt;
&lt;p&gt;而子类从来不会直接主动调用父类的方法.&lt;/p&gt;

&lt;p&gt;好莱坞原则和依赖反转原则DIP的的区别?&lt;/p&gt;
&lt;p&gt;DIP告诉我们不要使用具体的类, 尽量使用抽象类. 而好莱坞原则则是让低级别组件可以被钩进算法中去, 也没有建立低级别组件和高级别组件间的依赖关系.&lt;/p&gt;
&lt;p&gt;三种模式比较:&lt;/p&gt;
&lt;p&gt;模板方法模式: 子类决定如何实现算法中特定的步骤&lt;/p&gt;
&lt;p&gt;策略模式: 封装变化的行为并使用委托来决定哪个行为被使用.&lt;/p&gt;
&lt;p&gt;工厂方法模式: 子类决定实例化哪个具体的类.&lt;/p&gt;

&lt;p&gt;看看java里面数组的排序方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417142005894-707717005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417142109842-1634173703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;mergeSort就可以看做事模板方法, compareTo()就是需要具体实现的方法.&lt;/p&gt;
&lt;p&gt;但是这个并没有使用子类, 但是根据实际情况, 还是可以灵活使用的, 你需要做的就是实现Comparable接口即可., 这个接口里面只有一个CompareTo()方法.&lt;/p&gt;
&lt;p&gt;具体使用C#就是这样:&lt;/p&gt;
&lt;p&gt;鸭子:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TemplateMethodPattern.ForArraySort
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Duck : IComparable
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _name;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _weight;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Duck(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight)
        {
            _name &lt;/span&gt;=&lt;span&gt; name;
            _weight &lt;/span&gt;=&lt;span&gt; weight;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{_name} weights {_weight}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CompareTo(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Duck otherDuck)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_weight &amp;lt;&lt;span&gt; otherDuck._weight)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_weight ==&lt;span&gt; otherDuck._weight)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比较鸭子:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SortDuck()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ducks = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Duck[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Duck(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Duffy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Duck(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dewey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  &lt;span&gt;2&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Duck(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Howard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Duck(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Louie&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Duck(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Donal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Duck(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Huey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
            };
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Before sorting:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            DisplayDucks(ducks);

            Array.Sort(ducks);

            Console.WriteLine();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;After sorting:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            DisplayDucks(ducks);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DisplayDucks(Duck[] ducks)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (Duck t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ducks)
            {
                Console.WriteLine(t);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417142651370-575155025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;java的JFrame:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417142828849-1254065469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JFrame父类里面有一个update()方法, 它控制着算法, 我们可以使用paint()方法来钩进到该算法的那部分.&lt;/p&gt;
&lt;p&gt;父类里面JFrame的paint()啥也没做, 就是个钩子, 我们可以在子类里面重写paint(), 上面例子的效果就是:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417143038832-1179303642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;另一个例子Applet小程序:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180417143112884-560791021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这5个方法全是重写的钩子...&lt;/p&gt;
&lt;p&gt;我没看过winform或者wpf/sl的源码, 我估计也应该有一些钩子吧.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;好莱坞原则: &quot;别给我们打电话, 我们给你打电话&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模板方法模式: 模板方法在一个方法里定义了一套算法的骨架, 算法的某些步骤可以让子类来实现. 模板方法让子类重新定义算法的某些步骤而无需改变算法的结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该系列的源码: &lt;a href=&quot;https://github.com/solenovex/Head-First-Design-Patterns-in-CSharp&quot; target=&quot;_blank&quot;&gt;https://github.com/solenovex/Head-First-Design-Patterns-in-CSharp&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Apr 2018 06:36:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/8865861.html</dc:identifier>
</item>
<item>
<title>javaScript系列 [04]-javaScript的原型链 - 文顶顶</title>
<link>http://www.cnblogs.com/wendingding/p/8865226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wendingding/p/8865226.html</guid>
<description>&lt;h4 class=&quot;post-title&quot;&gt;[04]-javaScript的原型链&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文旨在花很少的篇幅讲清楚JavaScript语言中的原型链结构，很多朋友认为JavaScript中的原型链复杂难懂，其实不然，它们就像树上的一串猴子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-1-理解原型链&quot;&gt;1.1 理解原型链&lt;/h4&gt;
&lt;p&gt;JavaScript中几乎所有的东西都是对象，我们说数组是对象、DOM节点是对象、函数等也是对象，创建对象的Object也是对象（本身是构造函数），那么有一个重要的问题：&lt;code&gt;对象从哪里来？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是一句废话，对象当然是通过一定方式创建出来的，根据实际类型不同，对象的创建方式也千差万别。比如函数，我们可以声明函数、使用Function构造函数创建等，比如数组，我们可以直接通过var arr = [] 的方式创建空数组，也可以通过new Array的方式创建，比如普通的对象，我们可以字面量创建、使用内置构造函数创建等等，花样太多了，以至于我们学习的时候头昏脑涨、不得要领。&lt;/p&gt;
&lt;p&gt;其实，归根结底所有“类型”的对象都可以认为是由相应构造函数创建出来的。 函数由Function构造函数实例化而来，普通对象由Object构造函数实例化而来，数组对象由Array构造函数实例化而来，至于Object | Array | Function等他们本身是函数，当然也有自己的构造函数。&lt;/p&gt;
&lt;p&gt;理解了上面一点，那么接下来我们在理解原型链的时候就会容易得多。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;请看刺激的推导过程&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前提 所有对象都由构造函数实例化而来，构造函数默认拥有与之相关联的原型对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;❒ ① 构造函数的原型对象也是对象，因此也有自己的构造函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;❒ ② 构造函数原型对象的构造函数，也有与之相关连的原型对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;❒ ③ 构造函数原型对象的原型对象（&lt;code&gt;__proto__&lt;/code&gt;）也有自己的构造函数，其也拥有关联的原型对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;☞ 以上就形成了一种链式的访问结构，是为&lt;code&gt;原型链&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;tip&quot; readability=&quot;9&quot;&gt;其实构造函数也是对象，所以构造函数本身作为对象而言也有自己的构造函数，而这个构造函数也拥有与之相关联的原型对象，以此类推。那么，这就是另一条原型链了。综上，我们可以得出&lt;code&gt;原型链并不孤单&lt;/code&gt;的结论。

&lt;/div&gt;

&lt;h4 id=&quot;1-2-原型链结构&quot;&gt;1.2 原型链结构&lt;/h4&gt;
&lt;p&gt;现在我们基本上把原型链的由来说清楚了，那么接下来通过具体的代码来分析原型链的整体结构。&lt;/p&gt;
&lt;p&gt;示例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;01 自定义构造函数Person和Animal&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Animal() {}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;02 使用构造函数创建实例对象&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Animal();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;03 创建数组对象&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; arrM = [&quot;demoA&quot;,&quot;demoB&quot;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码非常简单，其中p1，p2和a它们是自定义构造函数的实例化对象。其次，我们采用快捷方式创建了arrM数组，arrM其实是内置构造函数Array的实例化对象。另外，Person和Animal这两个构造函数其实是Function构造函数的实例对象。理解以上几点后，我们就可以来看一下这几行代码对应的原型链结构图了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/flowerField/Source/blob/master/Blog/js_07.png?raw=true&quot; alt=&quot;&quot; width=&quot;768&quot; height=&quot;403&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原型链结构图说明：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;① 因为复杂度关系，arrM对象的原型链结构图单独给出。&lt;/p&gt;
&lt;p&gt;② Object.prototype是所有原型链的顶端，终点为null。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;验证原型链相关的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[1] 验证p1、p2的原型对象为Person.prototype&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    验证a    的原型对象为Animal.prototype&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; console.log(p1.__proto__ == Person.prototype); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; console.log(p2.__proto__ == Person.prototype); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; console.log(a.__proto__ == Animal.prototype);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[2] 获取Person.prototype|Animal.prototype构造函数&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    验证Person.prototype|Animal.prototype原型对象为Object.prototype&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    先删除实例成员，通过原型成员访问&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;  Person.prototype.constructor;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;  Animal.prototype.constructor;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; console.log(Person.prototype.constructor == Object);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; console.log(Animal.prototype.constructor == Object);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; console.log(Person.prototype.__proto__ == Object.prototype);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; console.log(Animal.prototype.__proto__ == Object.prototype);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[3] 验证Person和Animal的构造函数为Function&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    验证Person和Animal构造函数的原型对象为空函数&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; console.log(Person.constructor == Function);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; console.log(Animal.constructor == Function);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; console.log(Person.__proto__ == Function.prototype);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; console.log(Animal.__proto__ == Function.prototype);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[4] 验证Function.prototype的构造函数为Function&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; console.log(Function.prototype.constructor == Function);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[5] 验证Function和Object的构造函数为Function&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; console.log(Function.constructor == Function);              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; console.log(Object.constructor == Function);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[6] 验证Function.prototype的原型对象为Object.prototype而不是它自己&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; console.log(Function.prototype.__proto__ == Object.prototype);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[7] 获取原型链的终点&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; console.log(Object.prototype.__proto__);                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面贴出数组对象的原型链结构图&lt;br/&gt;&lt;img src=&quot;https://github.com/flowerField/Source/blob/master/Blog/js_08.png?raw=true&quot; alt=&quot;&quot; width=&quot;736&quot; height=&quot;403&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证数组对象原型链结构的代码示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[1] 验证arrM的构造函数为Array&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法1&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; console.log(arrM.constructor == Array);                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法2&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; console.log(Object.prototype.toString.call(arrM));      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[object Array]&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[2] 验证Array的构造函数为Function&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; console.log(Array.constructor == Function);             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[3] 验证Array构造函数的原型对象为Function.prototype(空函数)&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; console.log(Array.__proto__ == Function.prototype);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[4] 验证Array.prototype的构造函数为Object,原型对象为Object.prototype&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; Array.prototype.constructor;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; console.log(Array.prototype.constructor == Object);         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; console.log(Array.prototype.__proto__ == Object.prototype); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;1-3-原型链的访问&quot;&gt;1.3 原型链的访问&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;原型链的访问规则&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对象在访问属性或方法的时候，先检查自己的实例成员，如果存在那么就直接使用，如果不存在那么找到该对象的原型对象，查找原型对象上面是否有对应的成员，如果有那么就直接使用，如果没有那么就顺着原型链一直向上查找，如果找到则使用，找不到就重复该过程直到原型链的顶端，此时如果访问的是属性就返回undefined，方法则报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.name = &quot;wendingding&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; Person.prototype =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    constructor:Person,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     name:&quot;自来熟&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     showName:&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name.lastIndexOf()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; console.log(p.name);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问的是实例成员上面的name属性：wendingding&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; p.showName();          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印wendingding&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; console.log(p.age);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该属性原型链中并不存在，返回undefined&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; p.showAge();           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该属性原型链中并不存在，报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;概念和访问原则说明&lt;br/&gt;❐ 实例成员：实例对象的属性或者是方法&lt;br/&gt;❐ 原型成员：实例对象的原型对象的属性或者是方法&lt;br/&gt;❐ 访问原则：就近原则&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-4-getPrototypeOf、isPrototypeOf和instanceof&quot;&gt;1.4 getPrototypeOf、isPrototypeOf和instanceof&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Object.getPrototypeOf方法&lt;/strong&gt;用于获取指定实例对象的原型对象，用法非常简单，只需要把实例对象作为参数传递，该方法就会把当前实例对象的原型对象返回给我们。说白了，Object的这个静态方法其作用就是返回实例对象&lt;code&gt;__proto__&lt;/code&gt;属性指向的原型prototype。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;01 声明构造函数F&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; F() {}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;02 使用构造函数F获取实例对象f&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; f = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; F();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;03 测试getPrototypeOf方法的使用&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; console.log(Object.getPrototypeOf(f));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印的结果为一个对象，该对象是F相关联的原型对象&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; console.log(Object.getPrototypeOf(f) === F.prototype);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; console.log(Object.getPrototypeOf(f) === f.__proto__);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;isPrototypeOf方法&lt;/strong&gt;用于检查某对象是否在指定对象的原型链中，如果在，那么返回结果true，否则返回结果false。　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;01 声明构造函数Person&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;02 获取实例化对象p&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;03 测试isPrototypeOf的使用&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; console.log(Person.prototype.isPrototypeOf(p)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; console.log(Object.prototype.isPrototypeOf(p)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; arr = [1,2,3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; console.log(Array.prototype.isPrototypeOf(arr));    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; console.log(Object.prototype.isPrototypeOf(arr));   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; console.log(Object.prototype.isPrototypeOf(Person));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;上述代码的原型链&lt;br/&gt;① p–&amp;gt;Person.prototype –&amp;gt;Object.prototype –&amp;gt;null&lt;br/&gt;② arr–&amp;gt;Array.prototype –&amp;gt;Object.prototype –&amp;gt;null&lt;br/&gt;Object.prototype因处于所有原型链的顶端，故所有实例对象都继承于Object.prototype&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;instanceof运算符&lt;/strong&gt;的作用跟isPrototypeOf方法类似，左操作数是待检测的实例对象，右操作数是用于检测的构造函数。如果右操作数指定构造函数的原型对象在左操作数实例对象的原型链上面，则返回结果true，否则返回结果false。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;01 声明构造函数Person&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;02 获取实例化对象p&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;03 测试isPrototypeOf的使用&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; console.log(p &lt;span&gt;instanceof&lt;/span&gt; Person);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; console.log(p &lt;span&gt;instanceof&lt;/span&gt; Object);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;04 Object构造函数的原型对象在Function这个实例对象的原型链中&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; console.log(Function &lt;span&gt;instanceof&lt;/span&gt; Object); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;05 Function构造函数的原型对象在Object这个实例对象的原型链中&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; console.log(Object &lt;span&gt;instanceof&lt;/span&gt; Function); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：不要错误的认为instanceof检查的是&lt;code&gt;该实例对象是否从当前构造函数实例化创建的&lt;/code&gt;,其实它检查的是实例对象是否从当前指定构造函数的原型对象继承属性。&lt;/p&gt;

&lt;div readability=&quot;38.314801444043&quot;&gt;
&lt;p&gt;我们可以通过下面给出的代码示例来进一步理解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;01 声明构造函数Person&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;02 获取实例化对象p&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;03 测试isPrototypeOf的使用&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; console.log(p1 &lt;span&gt;instanceof&lt;/span&gt; Person);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;04 替换Person默认的原型对象&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; Person.prototype =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    constructor:Person,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     showInfo:&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         console.log(&quot;xxx&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;05 重置了构造函数原型对象之后，因为Person&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; console.log(p1 &lt;span&gt;instanceof&lt;/span&gt; Person); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;06 在Person构造函数重置了原型对象后重新创建实例化对象&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; console.log(p2 &lt;span&gt;instanceof&lt;/span&gt; Person);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;==&amp;gt; 建议开发中，总是先设置构造函数的原型对象，之后在创建实例化对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;贴出上面代码的原型链结构图（部分）&lt;br/&gt;&lt;img src=&quot;https://github.com/flowerField/Source/blob/master/Blog/js_09.png?raw=true&quot; alt=&quot;&quot; width=&quot;805&quot; height=&quot;394&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-5-原型链相关的继承&quot;&gt;1.5 原型链相关的继承&lt;/h4&gt;
&lt;p&gt;继承是面向对象编程的基本特征之一，JavaScript支持面向对象编程，在实现继承的时候，有多种可行方案。接下来，我们分别来认识下&lt;code&gt;原型式继承、原型链继承以及在此基础上演变出来的组合继承&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型式继承基本写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;01 提供超类型|父类型构造函数&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperClass() {}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;02 设置父类型的原型属性和原型方法&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; SuperClass.prototype.info = 'SuperClass的信息'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; SuperClass.prototype.showInfo = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.info);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;03 提供子类型&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubClass() {}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;04 设置继承(原型对象继承)&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; SubClass.prototype =&lt;span&gt; SuperClass.prototype;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; SubClass.prototype.constructor =&lt;span&gt; SubClass;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; sub = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubClass();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; console.log(sub.info);          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SuperClass的信息&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; sub.showInfo();                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SuperClass的信息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;贴出原型式继承结构图&lt;br/&gt;&lt;img src=&quot;https://github.com/flowerField/Source/blob/master/Blog/10.png?raw=true&quot; alt=&quot;&quot; width=&quot;666&quot; height=&quot;311&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;tip&quot; readability=&quot;8&quot;&gt;提示 该方式可以继承超类型中的原型成员，但是存在和超类型原型对象共享的问题

&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;原型链继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现思想&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;核心：把父类的实例对象设置为子类的原型对象 SubClass.prototype = new SuperClass();&lt;br/&gt;问题：无法为父构造函数（SuperClass）传递参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;原型链继承基本写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;01 提供超类型|父类型&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperClass() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.name = 'SuperClass的名称'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.showName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;02 设置父类型的原型属性和原型方法&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; SuperClass.prototype.info = 'SuperClass的信息'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; SuperClass.prototype.showInfo = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.info);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;03 提供子类型&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubClass() {}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;04 设置继承(原型对象继承)&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; sup = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SuperClass();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; SubClass.prototype =&lt;span&gt; sup;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; SubClass.prototype.constructor =&lt;span&gt; SubClass;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; sub = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubClass();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; console.log(sub.name);          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SuperClass的名称&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; console.log(sub.info);          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SuperClass的信息&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; sub.showInfo();                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SuperClass的信息&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; sub.showName();                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SuperClass的名称&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;贴出原型链继承结构图&lt;br/&gt;&lt;img src=&quot;https://github.com/flowerField/Source/blob/master/Blog/11.png?raw=true&quot; alt=&quot;&quot; width=&quot;716&quot; height=&quot;340&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组合继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现思想&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;① 使用原型链实现对原型属性和方法的继承&lt;br/&gt;② 通过伪造(冒充)构造函数来实现对实例成员的继承，并且解决了父构造函数传参问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;组合继承基本写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;01 提供超类型|父类型&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperClass(name) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.showName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;02 设置父类型的原型属性和原型方法&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; SuperClass.prototype.info = 'SuperClass的信息'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; SuperClass.prototype.showInfo = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.info);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;03 提供子类型&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubClass(name) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     SuperClass.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,name);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(1)获取父构造函数的实例成员  Person.call(this,name);&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(2)获取父构造函数的原型成员  SubClass.prototype = SuperClass.prototype;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; SubClass.prototype =&lt;span&gt; SuperClass.prototype;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; SubClass.prototype.constructor =&lt;span&gt; SubClass;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; sub_one = &lt;span&gt;new&lt;/span&gt; SubClass(&quot;zhangsan&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; sub_two = &lt;span&gt;new&lt;/span&gt; SubClass(&quot;lisi&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;console.log(sub_one);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; console.log(sub_two);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，贴出实例对象sub_one和sub_two的打印结果&lt;br/&gt;&lt;img src=&quot;https://github.com/flowerField/Source/blob/master/Blog/12.png?raw=true&quot; alt=&quot;&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 17 Apr 2018 05:54:00 +0000</pubDate>
<dc:creator>文顶顶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wendingding/p/8865226.html</dc:identifier>
</item>
<item>
<title>如何在jenkins的maven项目中，用mvn命令行指定findbugs的黑名单规则文件 - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/8863619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/8863619.html</guid>
<description>&lt;p&gt;最近在研究jenkins的过程中，针对maven项目，打算添加findbugs进行静态检查，但我不太想在项目的pom中进行修改，最好可以只修改jenkins的job配置，即配置外部化。&lt;/p&gt;

&lt;p&gt;我发现：在jenkins安装了findbugs插件后，只需要按照如下配置：&lt;/p&gt;
&lt;h2&gt;1.配置maven的goal&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/519126/201804/519126-20180417124117023-720373838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.配置构建后发布Findbugs分析结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/519126/201804/519126-20180417124137956-753417964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;保存后，点击立即构建，即可正常生成报告，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/519126/201804/519126-20180417124338815-713472172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.问题出现&lt;/h2&gt;
&lt;p&gt;因为我也是看了网上的很多文章，很多都说需要在pom文件里的build和report中配置findbugs插件。&lt;/p&gt;
&lt;p&gt;但配置经过我这样的实测，证明并不需要如此。唯一需要做的就是：如上图所示，在maven的goal中添加findbugs:findbugs即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;但是，我们项目组有自己的要求，比如某些findbugs的错误不需要检查&lt;/span&gt;。&lt;/strong&gt;那么，我要怎么样才能指定，哪些错误需要检查，哪些错误不需要检查呢？&lt;/p&gt;


&lt;h2&gt;1.普遍做法&lt;/h2&gt;
&lt;p&gt; 我首先用搜索引擎查找了几篇，没找到我想要的，网上的做法都是：&lt;/p&gt;
&lt;p&gt;在项目的pom中指定规则文件的位置：&lt;/p&gt;
&lt;p&gt;在pom文件的同级，放置excludeFilterFile（该文件中的规则不需要检查）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/519126/201804/519126-20180417125519812-125914612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.codehaus.mojo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;findbugs-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.0.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;excludeFilterFile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;custom-findbugs-include.xml&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;excludeFilterFile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;threshold&amp;gt;High&amp;lt;/threshold&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;threshold&amp;gt;Low&amp;lt;/threshold&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;effort&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Default&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;effort&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;findbugsXmlOutput&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;findbugsXmlOutput&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;findbugsXmlWithMessages&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;findbugsXmlWithMessages&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xmlOutput&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xmlOutput&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;findbugsXmlOutputDirectory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;target/site&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;findbugsXmlOutputDirectory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;reporting&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.codehaus.mojo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;findbugs-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.0.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xmlOutput&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xmlOutput&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Optional directoryto put findbugs xdoc xml report &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;xmlOutputDirectory&amp;gt;target/site&amp;lt;/xmlOutputDirectory&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;findbugsXmlOutput&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;findbugsXmlOutput&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;findbugsXmlWithMessages&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;findbugsXmlWithMessages&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;reporting&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;经我试验，这样是可行的。但是不符合我的需求：&lt;span&gt;我希望pom里面都是干干净净的，findbugs只配置在jenkins中，项目不需要进行任何配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ok。继续搜索解决方案吧。&lt;/p&gt;
&lt;h2&gt;2.阅读插件官网的文档&lt;/h2&gt;
&lt;p&gt;Maven的findbugs插件的官网地址：&lt;a href=&quot;https://gleclaire.github.io/findbugs-maven-plugin/&quot; target=&quot;_blank&quot;&gt;https://gleclaire.github.io/findbugs-maven-plugin/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这里面，查阅了findbugs：findbugs的文档，看看有哪些配置参数：&lt;/p&gt;
&lt;p&gt;（&lt;a href=&quot;https://gleclaire.github.io/findbugs-maven-plugin/findbugs-mojo.html&quot; target=&quot;_blank&quot;&gt;https://gleclaire.github.io/findbugs-maven-plugin/findbugs-mojo.html&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;此时，有了一点收获，在可选参数部分，看到如下参数，结合上面第一种解决方案的xml的配置，我几何可以认定，&lt;span&gt;要找的就是这个参数：excludeFilterFile&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/519126/201804/519126-20180417130254297-372089041.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;ok。那么我们应该就它配置到jenkins里面的maven goal中就可以了吧。（我的pom文件和下面的custom-findbugs-include.xml同级，因此不需要指定路径）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/519126/201804/519126-20180417130702411-134847408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然而，当我兴冲冲打开findbugs的报告，发现各种bug类型和之前相比，没有变化。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;期间百思不得其解，不明白为什么在pom中指定就可以，在这里指定就不行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;试了很多方法，最后我觉得：或许是这个配置压根没生效。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;3.验证猜想&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;生没生效，这个只能通过maven的debug日志来看了。于是我像上面的图那样，打开了debug日志。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-X -e&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这一次，在debug日志的输出中，&lt;/span&gt;下图所示的位置，是空的&lt;span&gt;（截图我打了码，因为我找不到之前的日志了。）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/519126/201804/519126-20180417131542806-1053317953.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;于是知道了问题的原因，果然是配置没生效。&lt;/p&gt;
&lt;p&gt;为什么不生效呢，应该是我的配置方式不对。&lt;/p&gt;
&lt;p&gt;接下来，我翻遍了baidu、google的前几页的结果，依然没有收获。查到的几乎都是传统方案，也就是在pom中指定。&lt;/p&gt;

&lt;h2&gt;4.问题解决&lt;/h2&gt;
&lt;p&gt;这期间，查搜索引擎无果，于是又上qq，加了两个群，提了问题。可是，没人回答。&lt;/p&gt;
&lt;p&gt;这期间，我也顺便把这个maven插件的源码down了下来。导入到idea中，进行全局搜索：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/519126/201804/519126-20180417132002384-1174392747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;终于，让我发现如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Parameter( property=&quot;findbugs.excludeFilterFile&quot; )
    String excludeFilterFile&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对java熟悉的人，应该很容易猜测：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是个配置项，而key不是我之前猜测的excludeFilterFile，而是findbugs.excludeFilterFile&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后就简单了，我很愉快地在jenkins中修改了配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/519126/201804/519126-20180417132315431-713393289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;终于，问题得到了解决。&lt;/p&gt;

&lt;h2&gt;5.悬而未决的问题&lt;/h2&gt;
&lt;p&gt;这个excludeFilterFile类似于黑名单，那么白名单行不行呢，我按照源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;p&gt;@Parameter( property=&quot;findbugs.includeFilterFile&quot; &lt;span&gt;) String includeFilterFile&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;将jenkins配置改成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/519126/201804/519126-20180417132547206-355692841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;并没有效果。这一点，打算后边再查。（当然，对我们组来说，黑名单，已经够了）&lt;/p&gt;


&lt;p&gt;其实这个问题，很奇怪，翻遍了搜索引擎都没结果，难道大家都没这个需求吗，&lt;span&gt;不管怎么说，希望能帮助到有需要的人。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;抽丝剥茧的过程，其实很快乐。&lt;/p&gt;
&lt;p&gt;另外附上我随便写的custom-findbugs-include.xml文件（仅供测试用，规则是随便写的）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;FindBugsFilter&amp;gt;
    &amp;lt;Match&amp;gt;
        &amp;lt;Bug pattern=&quot;DLS_DEAD_LOCAL_STORE&quot;/&amp;gt;
    &amp;lt;/Match&amp;gt;

    &amp;lt;Match&amp;gt;
        &amp;lt;Bug pattern=&quot;DM_BOXED_PRIMITIVE_FOR_PARSING&quot;/&amp;gt;
    &amp;lt;/Match&amp;gt;

    &amp;lt;Match&amp;gt;
        &amp;lt;Bug pattern=&quot;EI_EXPOSE_REP&quot;/&amp;gt;
    &amp;lt;/Match&amp;gt;

    &amp;lt;Match&amp;gt;
        &amp;lt;Bug pattern=&quot;EI_EXPOSE_REP2&quot;/&amp;gt;
    &amp;lt;/Match&amp;gt;

    &amp;lt;Match&amp;gt;
        &amp;lt;Bug pattern=&quot;ME_ENUM_FIELD_SETTER&quot;/&amp;gt;
    &amp;lt;/Match&amp;gt;
&amp;lt;/FindBugsFilter&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;规则列表：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://findbugs.sourceforge.net/bugDescriptions.html#BSHIFT_WRONG_ADD_PRIORITY&quot; target=&quot;_blank&quot;&gt;http://findbugs.sourceforge.net/bugDescriptions.html#BSHIFT_WRONG_ADD_PRIORITY&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Apr 2018 05:38:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/grey-wolf/p/8863619.html</dc:identifier>
</item>
<item>
<title>Python处理Excel生成CSV文档 - HelloGalaxy</title>
<link>http://www.cnblogs.com/HelloGalaxy/p/8863436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HelloGalaxy/p/8863436.html</guid>
<description>&lt;p&gt;&lt;span&gt;Python是一种解释型的、动态数据类型的、面向对象的高级程序设计语言。拥有丰富的处理数据和文本类库，并且得益于它是一种解释型的语言，在程序修改和功能扩展上，可以很容易做到大规模的调整。综合考虑Python的动态、轻量化特性，使用Python来处理Excel自动生成CSV文档的操作。 程序的运行需要依赖两个Python的类库，Pandas和Xlrd。Pandas是Python的一个数据分析类库。Xlrd则是帮助开发人员从Microsoft的Excel操作数据的好帮手。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至于为什么要把Excel变成CSV就很简单了。由于CSV基于“,”符号切割字符串表单，因此，在程序上，读写访问非常方便。不需要导入厚重的Excel类库，只需要基于string数据结构就可以实现基本的表单管理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1. &lt;span&gt;安装&lt;/span&gt;Python&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请到&lt;/span&gt;Python&lt;span&gt;官网下载并安装&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;运行时：&lt;/span&gt;https://www.python.org/downloads/&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;安装成功后，请打开&lt;/span&gt;Cmd&lt;span&gt;控制台，输入如下命令安装&lt;/span&gt;&lt;span&gt;Pandas&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;pip install pandas&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/131751/201804/131751-20180417125032393-1292512965.png&quot; alt=&quot;&quot; width=&quot;726&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3. &lt;span&gt;接着输入如下命令安装&lt;/span&gt;Xlrd&lt;/p&gt;
&lt;p&gt;pip install xlrd&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/131751/201804/131751-20180417125130046-906170996.png&quot; alt=&quot;&quot; width=&quot;572&quot; height=&quot;159&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4. &lt;span&gt;如果你使用&lt;/span&gt;PyCharm&lt;span&gt;，那么该工程的引用库安装导入方式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　File -&amp;gt; Settings -&amp;gt; Project: [current project name] -&amp;gt; ProjectInterpreter -&amp;gt; +(Add Button) -&amp;gt; &lt;span&gt;弹出的搜索框里分别依次选中&lt;/span&gt;Pandas&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Xlrd&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/131751/201804/131751-20180417125258375-1768799064.png&quot; alt=&quot;&quot; width=&quot;1035&quot; height=&quot;401&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;在开始编码前，我们思考一下转换的流程：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　先收集所有的&lt;/span&gt;Excel&lt;span&gt;文件&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;遍历每一个&lt;/span&gt;&lt;span&gt;Excel&lt;/span&gt;&lt;span&gt;文件&lt;/span&gt; &lt;span&gt;-&amp;gt; Excel&lt;/span&gt;&lt;span&gt;文件中还有众多的&lt;/span&gt;&lt;span&gt;Sheet&lt;/span&gt;&lt;span&gt;组成，也要遍历他们&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;最终把&lt;/span&gt;&lt;span&gt;Sheet&lt;/span&gt;&lt;span&gt;为单位生成独立的&lt;/span&gt;&lt;span&gt;CSV&lt;/span&gt;&lt;span&gt;文件&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;那么接下来就是要研究那些&lt;/span&gt;API&lt;span&gt;可以帮忙我们，如何获取目录文件集，如何打开&lt;/span&gt;&lt;span&gt;excel&lt;/span&gt;&lt;span&gt;文档，如何遍历&lt;/span&gt;&lt;span&gt;sheet&lt;/span&gt;&lt;span&gt;，如何保存成&lt;/span&gt;&lt;span&gt;csv&lt;/span&gt;&lt;span&gt;文档等等。&lt;/span&gt;&lt;span&gt;这里就不流水账罗列过程了，直接贴出成品代码，下面的代码是上述思考过程的最终成品。最后&lt;/span&gt;&lt;span&gt;，我们启动&lt;/span&gt;PyCharm&lt;span&gt;运行脚本，显然当前脚本很好的搜索的指定的目录，并把所有表格的&lt;/span&gt;&lt;span&gt;Sheet&lt;/span&gt;&lt;span&gt;生成对应的&lt;/span&gt;&lt;span&gt;CSV&lt;/span&gt;&lt;span&gt;文档。&lt;/span&gt; &lt;/p&gt;

&lt;p&gt;对了，代码里面我还留一个彩蛋，如何遍历所有的表格单元。这个，可以很好的帮你处理非法的单元格数据，关键的代码就是调用dataframe的applymap方法。代码中示例输入的方法是foreach_cell，该方法的本体是将nan的数据变成0。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，你还会发现，我用了xlrd获取sheet列表，但是我又另外使用pandas打开对应sheet。我之所以这样做，只是觉得pandas生成csv方便。所以，绕了点弯路。但是无大碍，一个转换代码而已，起码能利用各个优点（不是借口的借口吧）。Pandas有一个悲剧的地方就是不能获取Excel的Sheet总体情况，不传入指定的Sheet，默认打开的是第一个Sheet。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; math
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlrd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_all_table_file_name(folder_path):
    table_names &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt;&lt;span&gt; os.listdir(folder_path):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; os.path.splitext(file)[1] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.xls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; os.path.splitext(file)[1] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            table_names.append(file)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; table_names


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foreach_cell(cell):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; type(cell) &lt;span&gt;is&lt;/span&gt; float &lt;span&gt;and&lt;/span&gt;&lt;span&gt; math.isnan(cell):
            cell &lt;/span&gt;=&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cell


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; convert_table_to_csv(folder_path, file_name):
    file_path &lt;/span&gt;= folder_path + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; file_name
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;开始转换Excel文档： &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + file_path + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; 成 CSV 文档&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    tables &lt;/span&gt;=&lt;span&gt; xlrd.open_workbook(file_path)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;..Sheet总数： &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + tables.nsheets.&lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;())

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; sheet_table &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tables.sheets():
        csv_file_name &lt;/span&gt;= file_name.replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
        csv_file_name &lt;/span&gt;= csv_file_name.replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.xls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
        output_path &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;output/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + csv_file_name + sheet_table.name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

        sheet &lt;/span&gt;= pd.read_excel(file_path, sheet_table.name, index_col=None, index=&lt;span&gt;False)
        sheet.columns &lt;/span&gt;= sheet.columns.str.replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Unnamed.*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
        sheet.applymap(foreach_cell)
        sheet.to_csv(output_path, encoding&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, index=&lt;span&gt;False)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;....已经生成 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + csv_file_name + sheet_table.name + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; CSV文档&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; convert_all_tables_to_csv(folder_paths):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; folder_path &lt;span&gt;in&lt;/span&gt;&lt;span&gt; folder_paths:
        table_files &lt;/span&gt;=&lt;span&gt; get_all_table_file_name(folder_path)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; table_file &lt;span&gt;in&lt;/span&gt;&lt;span&gt; table_files:
            convert_table_to_csv(folder_path, table_file)


scan_folders &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tables&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
convert_all_tables_to_csv(scan_folders)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/131751/201804/131751-20180417125343117-1443216389.png&quot; alt=&quot;&quot; width=&quot;813&quot; height=&quot;221&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/131751/201804/131751-20180417125411552-959996933.png&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者：雨天&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Python处理Excel生成CSV文档&quot; href=&quot;http://www.cnblogs.com/HelloGalaxy/p/8863436.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/HelloGalaxy/p/8863436.html&lt;/a&gt;  &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Apr 2018 04:55:00 +0000</pubDate>
<dc:creator>HelloGalaxy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HelloGalaxy/p/8863436.html</dc:identifier>
</item>
<item>
<title>我花了 8 小时，&quot;掌握&quot;了一下 Flutter | Flutter 中文站上线 - 承香墨影</title>
<link>http://www.cnblogs.com/plokmju/p/android_flutter_8h.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/plokmju/p/android_flutter_8h.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/17/162d1ef4061864bc?w=900&amp;amp;h=500&amp;amp;f=jpeg&amp;amp;s=228342&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hi，大家好，我是承香墨影！&lt;/p&gt;
&lt;p&gt;距离 Google 在 2018 世界移动大会上发布 Flutter 的 Beta 版本，Flutter 是 Google 用以帮助开发者在 Android 和 iOS 两个平台，同时开发高质量原生应用的全新移动 UI 框架。&lt;/p&gt;
&lt;p&gt;当时上线的官网资料，都是英文的。而经历了一个多月的整理、翻译、测试。现在 &lt;strong&gt;Flutter 中文站&lt;/strong&gt; 正式上线了。&lt;/p&gt;
&lt;p&gt;Flutter 中文站是 Flutter 官网的一个中文镜像，是目前最全的 Flutter 官方文档的中文翻译，目标是致力于打造 Flutter 的中文开发社区。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/17/162d1ef4062ce555?w=280&amp;amp;h=280&amp;amp;f=jpeg&amp;amp;s=6112&quot; alt=&quot;扫码直达&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://flutterchina.club/&quot; class=&quot;uri&quot;&gt;https://flutterchina.club/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于不抵触英文文档的朋友，还是建议阅读英文文档，毕竟中文站只是一些英文文档的翻译，对于最新的信息，是有一定滞后的。不过 Flutter 中文站的发布，降低了我们学习 Flutter 的成本，有兴趣的可以持续关注。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;现在新技术层出不穷，如果每次出新的技术，我们都深入的研究的话，很容易分散精力。新的技术可能很久之后我们才会在工作中用得上，当学的新技术无法学以致用，很容易被我们遗忘，到最后真的需要使用的时候，又要从头来过（虽然上手会更快）。&lt;/p&gt;
&lt;p&gt;我觉得身为技术人，针对新技术应该是持拥抱态度的，入了这一行你就应该知道这是一个活到老学到老的行业，所以面对新技术，不要抵触，拥抱变化就好了。&lt;/p&gt;
&lt;p&gt;Flutter 明显是一种全新的技术，而对于这个新技术在发布之初，花一个月的时间学习它，成本确实过高。但是周末花一天时间体验一下它的开发流程，了解一下它的优缺点、能干什么或者不能干什么。这个时间，并不是我们不能接受的。&lt;/p&gt;
&lt;p&gt;如果有时间，其实通读一遍 Flutter 的文档，是最全面的一次对 Flutter 的了解过程。但是如果我们只有 8 小时的时间，我希望能关注一些最值得关注的点。接下来，我们来看看，如何用 8 小时的时间，快速体验 Flutter。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; Flutter 的技术概览（15分钟）&lt;/p&gt;
&lt;p&gt;在这一步骤，你尽量通过一些文档的来了解 Flutter，知道它是基于什么来实现的、能做什么、技术边界在哪里。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://flutterchina.club/technical-overview/&quot; class=&quot;uri&quot;&gt;https://flutterchina.club/technical-overview/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; 搭建开发环境（1小时）&lt;/p&gt;
&lt;p&gt;我们是在学习编程，学习编程最重要也是最快捷有效的方式，就是自己上手实验一番，&lt;strong&gt;读代码千遍，不如实际 Run 一下&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这一步一定离不开开发环境的搭建，搭建好环境之后，不如根据文档新建一个 Hello World 项目。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://flutterchina.club/get-started/install/&quot; class=&quot;uri&quot;&gt;https://flutterchina.club/get-started/install/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; Flutter for Android（2小时）&lt;/p&gt;
&lt;p&gt;到这一步，我相信你应该有一个最简单的 Flutter 可运行的项目。Flutter 虽然是面向所有开发者的开发技术，但是 Google 尤为重视 Android 和 Web 开发的首次接触体验。&lt;/p&gt;
&lt;p&gt;如果你正好有 Android 或者 Web 开发经验，Flutter 文档中，还有专门针对这些开发的一些概念类比。例如：Flutter 和 Android 中的 View、Intent 在 Flutter 中等价于什么？这些概念的类比，可以让你更快的在现有技术结构的基础之上，理解和掌握 Flutter。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://flutterchina.club/flutter-for-android/&quot; class=&quot;uri&quot;&gt;https://flutterchina.club/flutter-for-android/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; Flutter 使用 Packages（2小时）&lt;/p&gt;
&lt;p&gt;Android 中，存在大量第三方库，这些库充斥了我们日常的生产项目中，在 Flutter 的开发过程中，也并不是一个人在战斗。Flutter 支持使用由其他开发者贡献给 Flutter 和 Dart 生态系统的共享软件包。例如：网络请求（http）、导航/路由（fluro）。&lt;/p&gt;
&lt;p&gt;了解第三方包的开发和使用，有利于我们更好的理解 Flutter 的生态。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://flutterchina.club/using-packages/&quot; class=&quot;uri&quot;&gt;https://flutterchina.club/using-packages/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;5.&lt;/em&gt; 与特定平台交互（2小时）&lt;/p&gt;
&lt;p&gt;Flutter 在发布之初就是想要有原生的体验，而为了在多个平台上正常使用和发布，总有一些我们功能我们需要和原生进行交互，例如在 Android 上表现为用 Dart 调用 Java/Kotlin 以及反向操作。&lt;/p&gt;
&lt;p&gt;在国内的环境下，我们会用大量的第三方服务，例如统计服务？这些很难要求服务商为我们开发出一款 Dart 的版本，所以如果能够直接和 Java 通信，其实我们只需要自己包一层实现就好了，这也是我比较看重的一点。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://flutterchina.club/platform-channels/&quot; class=&quot;uri&quot;&gt;https://flutterchina.club/platform-channels/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;6.&lt;/em&gt; FAQ（半小时）&lt;/p&gt;
&lt;p&gt;到这里其实已经算是基本了解和体验过 Flutter 了，接下来看看 Flutter 的 FAQ 换换脑子。&lt;/p&gt;
&lt;p&gt;FAQ 会包含大量你现在可能会遇到的，其他的人曾经碰到过的疑问的答案，通过阅读 FAQ，能让我们更了解 Flutter。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://flutterchina.club/faq/&quot; class=&quot;uri&quot;&gt;https://flutterchina.club/faq/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;在某个周末，花 8 个小时，快速了解和体验一下 Flutter，不值得吗？&lt;/p&gt;
&lt;p&gt;在这 8 小时里，我们虽然放弃了很多细节，但是并不影响我们了解 Flutter 是什么。有了这个大体的印象之后，以后如果需要使用或者调研，都会快很多。&lt;/p&gt;
&lt;p&gt;这个过程中，除了开阔了我们的技术栈，其实我们更多的是锻炼我们了解新技术的心态，你今天愿意花 8 个小时了解 Flutter，下次再遇上 谁谁谁 发布的 Xxx，如果你看好它，你也愿意再花上 8 小时了解它。&lt;/p&gt;
&lt;p&gt;你觉得呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;今天在公众号后台回复成长『&lt;strong&gt;成长&lt;/strong&gt;』，将会得到我整理的一些学习资料，也能回复『&lt;strong&gt;加群&lt;/strong&gt;』，一起学习进步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b859885519038?w=1000&amp;amp;h=400&amp;amp;f=jpeg&amp;amp;s=27637&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Apr 2018 04:53:00 +0000</pubDate>
<dc:creator>承香墨影</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/plokmju/p/android_flutter_8h.html</dc:identifier>
</item>
<item>
<title>用js来实现那些数据结构06（队列） - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/8863434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/8863434.html</guid>
<description>&lt;p&gt;　　其实队列跟栈有很多相似的地方，包括其中的一些方法和使用方式，只是队列使用了与栈完全不同的原则，栈是后进先出原则，&lt;strong&gt;而队列是先进先出（First In First Out）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、队列&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;9.8305084745763&quot;&gt;　    &lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481?fr=aladdin&quot; target=&quot;_blank&quot;&gt;队列&lt;/a&gt;&lt;/strong&gt;是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。&lt;/div&gt;
&lt;p&gt;　　队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。&lt;/p&gt;
&lt;p&gt;　　我们对队列有了基本的了解，那么我们来看看如何实现队列。其实跟栈的实现极为类似，只是入队和出队的方法稍有不同，那么我们来看看一个完整的队列需要哪些方法：&lt;/p&gt;
&lt;p&gt;　　　　1、enqueue(element(s))，入队，向队列尾部添加一个或者多个元素。&lt;/p&gt;
&lt;p&gt;　　　　2、dequeue()，出队，移除队列中的第一个元素，也就是队列最前面的元素，并返回该元素。&lt;/p&gt;
&lt;p&gt;　　　　3、front()，获取队列最前面的元素，返回队列中第一个元素（最先被添加，也是最先被移除的元素）。队列并不移除该元素。&lt;/p&gt;
&lt;p&gt;　　　　4、isEmpty()，判断队列是否不包含任何元素。&lt;/p&gt;
&lt;p&gt;　　　　5、size()，返回队列的元素总数。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 //声明Queue类
  function&lt;span&gt; Queue() {
      //声明并初始化一个用来存放队列元素的数组。
      let items =&lt;span&gt; [];
      //添加队列元素
      this.enqueue = function&lt;span&gt; (element) {
          items.push(element)
      };
      //移除并返回该队列元素
      this.dequeue = function&lt;span&gt; () {
          return&lt;span&gt; items.shift();
      };
      //获取队列头部元素
      this.front = function&lt;span&gt; () {
          return items[0&lt;span&gt;];
      };
      //判断队列元素是否为空
      this.isEmpty = function&lt;span&gt; () {
          return items.length == 0&lt;span&gt;;
      };

      //获取队列元素个数
      this.size = function&lt;span&gt; () {
          return&lt;span&gt; items.length;
      };
      //打印该队列
      this.print = function&lt;span&gt; () {
          console.log(items.toString())
      };
  }
const queue = new&lt;span&gt; Queue();
console.log(queue.isEmpty()); // outputs true
queue.enqueue('John'&lt;span&gt;);
queue.enqueue('Jack'&lt;span&gt;);
queue.print(); // John,Jack
queue.enqueue('Camila'&lt;span&gt;);
queue.print(); // John,Jack,Camila
console.log(queue.size()); // outputs 3
console.log(queue.isEmpty()); // outputs false
queue.dequeue(); // remove John
queue.dequeue(); // remove Jack
queue.print(); // Camila&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;　　上面我们就已经实现了队列这种数据结构，同样的，我们是否可以稍微改造一下，让队列的实现看起来更加优美一点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
let Queue = (function&lt;span&gt; () {
      const items = new&lt;span&gt; WeakMap();

      class Queue {
          constructor () {&lt;br/&gt;　　　　　　　　//强调一下，这里items是WeakMap类型的数据，而WeakMap是键值对，有专属的set和get方法来获取和设置值，&lt;br/&gt;　　　　　　　　//所以这里给this设置了[]，即以this为键名，[]为值，所以该方法形成的队列仍旧是对数组的操作
              items.set(this&lt;span&gt;,[]);
          }

          enqueue(element) {
              let q = items.get(this&lt;span&gt;);//这里的q就相当于是[]
              q.push(element);
          }

          dequeue() {
              let q = items.get(this&lt;span&gt;);
              let r =&lt;span&gt; q.shift();
              return&lt;span&gt; r;
          }

          front() {
              return items.get(this)[0&lt;span&gt;];
          }

          isEmpty() {
              return items.get(this).length == 0&lt;span&gt;;
          }

          size() {
              return items.get(this&lt;span&gt;).length;
          }

          print() {
              console.log(items.get(this&lt;span&gt;));
          }
      }

      return&lt;span&gt;     Queue;
  })()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实到这里队列就基本介绍完了，但是感觉实在有点糊弄人啊。所以就把剩下的内容都在这一篇文章写完吧。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二、优先队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们说完了队列，那么我们看看什么是优先队列。普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。就像是我们在窗口买票，机场排队，正常来说我们都是依照排队的顺序从队列的最前面开始依次进入，但是有规定老人孩子军人等优先，那么就赋予了该老人（孩子军人）&lt;strong&gt;插队&lt;/strong&gt;的权利。而优先队列，同样就是给特定元素赋予插队（优先级）的权利。我想要入队，并不一定是直接到尾部。而是根据我设定的优先级来插入队列。&lt;/p&gt;
&lt;p&gt;　　其实优先队列在实现上不同的地方是队列元素的设定和入队方法的不同（这里其实有两种实现方式，一个是按照优先级入列，一个是按照优先级出列，这里我们只用第一种方式实现）。下面我们就看看如何实现优先队列吧。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;19&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
  //声明Queue类
  function&lt;span&gt; PriorityQueue() {
      //声明并初始化一个用来存放队列元素的数组。
      let items =&lt;span&gt; [];
      //创建一个拥有优先级的元素类
      function&lt;span&gt; QueueElement(element,priority) {
          this.element =&lt;span&gt; element;
          this.priority =&lt;span&gt; priority;
      }
      //添加队列元素
      this.enqueue = function&lt;span&gt; (element,priority) {
          let queueElement = new&lt;span&gt; QueueElement(element,priority);
          let added = false&lt;span&gt;;
          //遍历队列元素，1的优先级最高，一次类推，如果当前元素优先级大于items[i]，那么就把该元素放在items[i]前面。
          //splice方法的第二的参数如果为0，那么则把第三个参数添加到i前面。
          for(let i = 0; i &amp;lt; items.length; i++&lt;span&gt;) {
              if(queueElement.priority &amp;lt;&lt;span&gt; items[i].priority) {
                  items.splice(i,0&lt;span&gt;,queueElement);
                  added = true&lt;span&gt;;break&lt;span&gt;;
              }
          }
          // 通过added判断是否可以直接把元素入列。
          if(!&lt;span&gt;added) {&lt;span&gt;
              items.push(queueElement);
          }
      };
      //移除并返回该队列元素
      this.dequeue = function&lt;span&gt; () {
          return&lt;span&gt; items.shift();
      };
      //获取队列头部元素
      this.front = function&lt;span&gt; () {
          return items[0&lt;span&gt;];
      };
      //判断队列元素是否为空
      this.isEmpty = function&lt;span&gt; () {
          return items.length == 0&lt;span&gt;;
      };

      //获取队列元素个数
      this.size = function&lt;span&gt; () {
          return&lt;span&gt; items.length;
      };
      //循环打印元素及其优先级“``”是ES6的模板字符串
      this.print = function&lt;span&gt; () {
          for(let i = 0; i &amp;lt; items.length; i++&lt;span&gt;) {
              console.log(`${items[i].element} -&lt;span&gt; ${items[i].priority}`);
          }
      };
  }
const queue = new&lt;span&gt; PriorityQueue();
console.log(queue.isEmpty()); // outputs true
&lt;span&gt;
queue.enqueue('zaking',2&lt;span&gt;);
queue.enqueue('linbo',6&lt;span&gt;);
queue.enqueue('queue',5&lt;span&gt;);
queue.enqueue('ada',3&lt;span&gt;);
queue.enqueue('John',1&lt;span&gt;);
queue.enqueue('Jack',2&lt;span&gt;);
queue.enqueue('Camila',3&lt;span&gt;);
queue.enqueue('zak',3&lt;span&gt;);
queue.print(); &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　主要的更改在于队列元素的设置和enqueue方法，由于需要为每一个循环队列的元素设置优先级，所以这里稍微更改了一下队列的元素，使其带有两个参数（元素自身和优先级），那么既然要根据不同的优先级来插入队列，所以循环队列的enqueue方法也就需要循环整个队列去判断要插入到哪里。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　　其实这个优先队列的实现并不是很好，比如我不传第二优先级参数，那么队列打印的时候该参数就是undefined，而且在不传参数的时候应该默认为最末优先级。大家可以试着去修改一下代码，使其看起来更符合实际。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、循环队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　除了优先队列以外还有循环队列，循环队列的一个比较容易想象的例子就是击鼓传花游戏，游戏规则就不说了大家小时候都玩过，我们看看如何实现击鼓传花游戏。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;18.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
function&lt;span&gt; hotPotato(nameList, num) {
  const queue = new&lt;span&gt; Queue();
  //把所有的名单（nameList）依次入列
  for (let i = 0; i &amp;lt; nameList.length; i++&lt;span&gt;) {
    queue.enqueue(nameList[i]);
  }

  //声明当前被淘汰的人员名称
  let eliminated = ''&lt;span&gt;;
  //如果队列中的元素大于一个，说明还没有最后的赢家，如果只剩下一个，就出列该最后赢家
  while (queue.size() &amp;gt; 1&lt;span&gt;) {
      //循环当前队列num次，把队列头部的“出列元素”再入列。
    for (let i = 0; i &amp;lt; num; i++&lt;span&gt;) {
      queue.enqueue(queue.dequeue());
    }
    //循环结束后，出列当前队列的元素，也就是淘汰者。
    eliminated =&lt;span&gt; queue.dequeue();
    queue.print();
    console.log(eliminated + &quot;被淘汰&quot;&lt;span&gt;);
  }

  return&lt;span&gt; queue.dequeue();
}

let names = [&quot;zak&quot;,&quot;zaking&quot;,&quot;james&quot;,&quot;lili&quot;,&quot;bole&quot;,&quot;londo&quot;,&quot;fali&quot;&lt;span&gt;]
console.log(hotPotato(names,7))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的方法，每次循环都会依次把头部元素放入到尾部，就实现了一个圈，然后我们以循环结束后，队列最前端的元素视为淘汰，直到最后只剩下一个元素，也就真实的模拟了击鼓传花游戏。&lt;/p&gt;

&lt;p&gt;　　最后，&lt;strong&gt;由于本人水平有限，能力与大神仍相差甚远，若有错误或不明之处，还望大家不吝赐教指正。非常感谢！&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 17 Apr 2018 04:48:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/8863434.html</dc:identifier>
</item>
</channel>
</rss>