<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>新人入坑Redis必会的吐血总结 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/9542496.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/9542496.html</guid>
<description>&lt;h2 id=&quot;一什么是redis&quot;&gt;一、什么是Redis&lt;/h2&gt;
&lt;p&gt;Redis是一个使用C语言开发的开源的高性能的key-value存储系统，我们可以把它近似理解为Java Map。简单来讲，Redis是一种NOSQL内存数据库，小伙伴们可不要把它理解为NO SQL(不是SQL)，它的全称是Not Only SQL(不仅仅是SQL)，换个层面来讲，它是一种非关系型的数据库，它是作为关系型数据库的良好补充，它与传统的MySQL，Oracle不同之处在于，它是通过在内存中读写数据，大大提高了读写速度。可以说，Redis是为了解决网站高并发、高可用、高可扩展、大数据存储等一系列问题而产生的数据库解决方案，不可或缺的一部分。&lt;/p&gt;
&lt;p&gt;它具有以下特点：&lt;/p&gt;
&lt;p&gt;1、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。&lt;br/&gt;2、Redis不仅仅支持简单的key-value类型的数据，同时还提供string、list、set、sortedset、hash等数据结构的存储。&lt;br/&gt;3、Redis支持数据的备份，即master-slave模式的数据备份。&lt;/p&gt;
&lt;h4 id=&quot;redis有五种键值类型&quot;&gt;&lt;strong&gt;Redis有五种键值类型:&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;而本文将基于Redis5.0为例来介绍Redis一些相关命令的使用和踩过的坑&lt;/p&gt;
&lt;h2 id=&quot;二关于redis的安装与启动&quot;&gt;二、关于Redis的安装与启动&lt;/h2&gt;
&lt;h4 id=&quot;环境准备&quot;&gt;&lt;strong&gt;环境准备&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;安装教程请参看这里：&lt;a href=&quot;https://www.cnblogs.com/ECJTUACM-873284962/p/9532043.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/ECJTUACM-873284962/p/9532043.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;在线环境&quot;&gt;&lt;strong&gt;在线环境&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;官网似乎提供了一个在线的Redis平台，链接在这里：&lt;a href=&quot;http://try.redis.io/&quot; class=&quot;uri&quot;&gt;http://try.redis.io/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;redis启动&quot;&gt;&lt;strong&gt;Redis启动&lt;/strong&gt;&lt;/h4&gt;
&lt;h5 id=&quot;前端启动&quot;&gt;&lt;strong&gt;前端启动&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;按照我所提供的教程安装以后，我们只需要输入命令redis-server即可，界面如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/08/27/5b835b1b0014c.png&quot; alt=&quot;5b835b1b0014c&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;前端停止启动&quot;&gt;&lt;strong&gt;前端停止启动&lt;/strong&gt;&lt;/h5&gt;
&lt;h5 id=&quot;后端启动&quot;&gt;&lt;strong&gt;后端启动&lt;/strong&gt;&lt;/h5&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;因为Redis在实际使用中不会只是一个Redis单独工作,启动和关闭方式中的ip地址和端口号可以在配置文件中自行修改,下面会有修改方式.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;启动方式&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;需要将redis解压之后的源码包中的redis.conf文件拷贝到bin目录下.直接复制粘贴即可&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修改redis.conf文件，将daemonize改为yes(vi redis.conf进去，:/daemonize搜索).&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用命令后端启动redis.命令行redis-server redis.conf(以配置文件启动)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查看是否启动成功.命令行 ps -aux | grep redis (直接查看redis的进程)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果你之前按照我所提供的教程修改过，这一过程可以直接忽略就好&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/08/27/5b8361847bc1e.png&quot; alt=&quot;5b8361847bc1e&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关闭方式&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在项目中，建议使用正常关闭。 因为redis作为缓存来使用的话，将数据存储到内存中，如果使用正常关闭，则会将内存数据持久化到本地之后，再关闭。如果是强制关闭，则不会进行持久化操作，可能会造成部分数据的丢失。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;redis客户端启动&quot;&gt;&lt;strong&gt;Redis客户端启动&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;启动客户端命令:[root@sakura]# redis-cli -h ip地址 -p 端口号&lt;/p&gt;
&lt;p&gt;由于默认IP是127.0.0.1，端口是6379，我们只需要输入命令redis-cli即可&lt;/p&gt;
&lt;p&gt;退出:127.0.0.1:6379&amp;gt; quit即可&lt;/p&gt;
&lt;h2 id=&quot;三redis数据类型及常用命令讲解&quot;&gt;三、Redis数据类型及常用命令讲解&lt;/h2&gt;
&lt;h4 id=&quot;redis-string&quot;&gt;1、Redis-String&lt;/h4&gt;
&lt;p&gt;string使用环境:主要用于保存json格式的字符串&lt;/p&gt;
&lt;h5 id=&quot;赋值&quot;&gt;&lt;strong&gt;赋值&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;set key value:设定key持有指定的字符串value，如果该key存在则进行覆盖操作，总是返回&quot;OK&quot;，如果赋予相同的key，新的value会覆盖老的value&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; set username zhangsan
OK&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;取值&quot;&gt;&lt;strong&gt;取值&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;get key:获取key的value。如果与该key关联的value不是string类型，redis将返回错误信息，因为get命令只能用于获取string value；如果该key不存在，返回nil&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; get username
&quot;zhangsan&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;删除&quot;&gt;&lt;strong&gt;删除&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;del key:删除指定key，返回值是数字类型，表示删了几条数据&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; del username
(integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;扩展&quot;&gt;&lt;strong&gt;扩展&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;getset key value:先获取该key的值，然后再设置该key的值&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; getset username zhangsan
(nil)
127.0.0.1:6379&amp;gt; keys *
1) &quot;username&quot;
127.0.0.1:6379&amp;gt; get username
&quot;zhangsan&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;incr key:将指定的key的value原子性的递增1，如果该key不存在，其初始值为0，在incr之后的值为1，如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息，相当于++(作用:统计网站访客人数，当计数器)&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; set age 18
OK
127.0.0.1:6379&amp;gt; incr age
(integer) 19&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;decr key:将指定的key的value原子性的递减1，如果该key不存在，其初始值为0，在incr之后的值为-1，如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息，相当于--i&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; set age 18
OK
127.0.0.1:6379&amp;gt; decr age
(integer) 17&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;append key value:拼接字符串，如果该key存在，则在原有的value后追加该值，如果该key不存在，则重新创建一个key/value&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; set information hel
OK
127.0.0.1:6379&amp;gt; append information lo
(integer) 5
127.0.0.1:6379&amp;gt; get information
&quot;hello&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;incrby和decrby:只能对字符串是数字的进行操作，incrby key value是对原有的key的值增加value，而decrby key value是对原有的key的值减少value&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; get age
&quot;17&quot;
127.0.0.1:6379&amp;gt; incrby age 10
(integer) 27
127.0.0.1:6379&amp;gt; decrby age 10
(integer) 17
127.0.0.1:6379&amp;gt; get information
&quot;hello&quot;
127.0.0.1:6379&amp;gt; incrby information 10
(error) ERR value is not an integer or out of range
127.0.0.1:6379&amp;gt; decrby information 10
(error) ERR value is not an integer or out of range&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;redis-hash&quot;&gt;2、Redis-hash&lt;/h4&gt;
&lt;p&gt;Redis中的hash类型可以看成具有string key和string value的map容器，所以该类型非常适合于存储值对象的信息。如username，password和age等。如果hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个hash可以存储4294967295个键值对。&lt;/p&gt;
&lt;p&gt;hash特点:占用的磁盘空间极少&lt;/p&gt;
&lt;h5 id=&quot;赋值-1&quot;&gt;&lt;strong&gt;赋值:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;hset key field value:为指定的key设定field/value对(键值对)&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; hset key1 field1 123
(integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;hmset key field value[field2 value2...]:设置key中的多个field/value&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; hmset aaa name kitty age 20
OK&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;取值-1&quot;&gt;&lt;strong&gt;取值:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;hget key filed:获取指定的key的field的值&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; hget key1 field1
&quot;123&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;hmget key filed1 field2...:获取key中的多个field的值&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; hmget aaa name age
1) &quot;kitty&quot;
2) &quot;20&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;hgetall key:获取key中的所有field-value2&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; hgetall aaa
1) &quot;name&quot;
2) &quot;kitty&quot;
3) &quot;age&quot;
4) &quot;20&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;删除-1&quot;&gt;&lt;strong&gt;删除&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;hdel key field[field...]:可以删除一个或多个字段，返回值是被删除的字段个数&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; hdel key1 field1
(integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;del key:删除整个list&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; del aaa
(integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;增加数字&quot;&gt;&lt;strong&gt;增加数字&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;hincrby key field increment:设置key中的field增加increment,如age增加20&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; hmset aaa name kitty age 20
OK
127.0.0.1:6379&amp;gt; hincrby aaa age 20
(integer) 40&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;扩展命令&quot;&gt;&lt;strong&gt;扩展命令&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;hexists key field:判断指定的key中的field是否存在&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; hexists aaa name
(integer) 1
127.0.0.1:6379&amp;gt; hexists aaa aaaa
(integer) 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;hlen key:获取key所包含的field的数量&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; hlen aaa
(integer) 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;hkeys key:获得所有的字段&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; hkeys aaa
1) &quot;name&quot;
2) &quot;age&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;redis-list&quot;&gt;3、Redis-list&lt;/h4&gt;
&lt;p&gt;Redis中list选取的是链表，因为在Redis操作中，最多的操作是进行元素的增删&lt;/p&gt;
&lt;h5 id=&quot;赋值-2&quot;&gt;&lt;strong&gt;赋值&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;lpush key value [value1 value2 ...] 在指定的key所关联的list头部插入所有的value，如果该key不存在，该命令在插入之前创建一个与该key关联的空链表，之后再向该链表的头部插入数据，插入成功，返回元素的个数。&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; lpush score1 1 2 3 4 5
(integer) 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;rpush key value [value1 value2 ...] 在该list的尾部添加元素&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; rpush score2 1 2 3 4 5
(integer) 5&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;取值-2&quot;&gt;&lt;strong&gt;取值&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;lrange key start end:获取链表中从start到end的元素的值，start、end从0开始计数；也可以为负数，若为-1则表示链表尾部的元素，-2表示倒数第二个，以此类推...&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; lrange score1 0 -1
1) &quot;5&quot;
2) &quot;4&quot;
3) &quot;3&quot;
4) &quot;2&quot;
5) &quot;1&quot;
127.0.0.1:6379&amp;gt; lrange score2 0 -1
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
5) &quot;5&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;删值&quot;&gt;&lt;strong&gt;删值&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;lpop key:返回并弹出指定的key关联的链表中的第一个元素，即头部元素。如果该key不存在，返回nil；若key存在，则返回链表的头部元素&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; lpop score1
&quot;5&quot;
127.0.0.1:6379&amp;gt; lpop score2
&quot;1&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;rpop key:从尾部弹出元素&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; rpop score1
&quot;1&quot;
127.0.0.1:6379&amp;gt; rpop score2
&quot;5&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;扩展-1&quot;&gt;&lt;strong&gt;扩展&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;llen key:返回指定的key关联的链表中的元素的数量&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; llen score1
(integer) 3
127.0.0.1:6379&amp;gt; llen score2
(integer) 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;lrem key count value:删除count个值为value的元素，如果count大于0，从头到尾遍历并删除count个值为value的元素，如果count小于0，则从尾到头遍历并删除，如果count等于0，则删除链表中所有等于value的元素。&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; lrem score1 1 2
(integer) 1
127.0.0.1:6379&amp;gt; lrem score2 1 2
(integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;通过索引替换&quot;&gt;&lt;strong&gt;通过索引替换&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;lset key index value:设置链表中的index的脚标的元素值，0代表链表的头元素，-1代表链表的尾元素。操作链表的脚标不存在则抛出异常&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; lset score1 0 1
OK
127.0.0.1:6379&amp;gt; lset score2 0 1
OK&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;在索引前后插入元素&quot;&gt;&lt;strong&gt;在索引前/后插入元素&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;linsert key before|after pivot value:在pivot元素前或者后插入value这个元素&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; linsert score1 before 3 aaa
(integer) 3
127.0.0.1:6379&amp;gt; lrange score1 0 -1
1) &quot;1&quot;
2) &quot;aaa&quot;
3) &quot;3&quot;
127.0.0.1:6379&amp;gt; linsert score1 after 3 bbb
(integer) 4
127.0.0.1:6379&amp;gt; lrange score1 0 -1
1) &quot;1&quot;
2) &quot;aaa&quot;
3) &quot;3&quot;
4) &quot;bbb&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;rpoplpush resource destination:将链表中的尾部元素弹出并添加到头部。[循环操作]&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; lrange score1 0 -1
1) &quot;1&quot;
2) &quot;aaa&quot;
3) &quot;3&quot;
127.0.0.1:6379&amp;gt; lrange score2 0 -1
1) &quot;bbb&quot;
2) &quot;1&quot;
3) &quot;4&quot;
127.0.0.1:6379&amp;gt; rpoplpush score1 score2
&quot;3&quot;
127.0.0.1:6379&amp;gt; lrange score1 0 -1
1) &quot;1&quot;
2) &quot;aaa&quot;
127.0.0.1:6379&amp;gt; lrange score2 0 -1
1) &quot;3&quot;
2) &quot;bbb&quot;
3) &quot;1&quot;
4) &quot;4&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;redis-set&quot;&gt;4、Redis-set&lt;/h4&gt;
&lt;h5 id=&quot;赋值-3&quot;&gt;&lt;strong&gt;赋值&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;sadd key value[value1 value2...]:向set中添加元素，如果该key的值已有则不会重复添加&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; sadd abc 1 2 3 4
(integer) 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;srem key member[member1 member2...]:删除set中指定的成员&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; srem abc 1 3
(integer) 2&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;取值-3&quot;&gt;&lt;strong&gt;取值&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;smembers key:获取set中所有的成员&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; smembers abc
1) &quot;2&quot;
2) &quot;4&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sismember key member:判断参数中指定的成员是否在该set中，1表示存在，0表示不存在或者该key本身就不存在(无论集合中有多少元素都可以极速的返回结果)&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; sismember abc 2
(integer) 1
127.0.0.1:6379&amp;gt; sismember abc 3
(integer) 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;删值-1&quot;&gt;&lt;strong&gt;删值&lt;/strong&gt;&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;集合运算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;差集运算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;sdiff key1 key2...:返回key1与key2中相差的成员，而且与key的顺序有关，即返回差集&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; sadd set1 1 2 3 4 5
(integer) 5
127.0.0.1:6379&amp;gt; sadd set2 3 4 5 6 7
(integer) 5
127.0.0.1:6379&amp;gt; sdiff set1 set2
1) &quot;1&quot;
2) &quot;2&quot;
127.0.0.1:6379&amp;gt; sdiff set2 set1
1) &quot;6&quot;
2) &quot;7&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;交集运算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;sinter key1 key2...:返回交集&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; sinter set1 set2
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;5&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;并集运算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;sunion key1 key2...:返回并集&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; sunion set1 set2
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
5) &quot;5&quot;
6) &quot;6&quot;
7) &quot;7&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;扩展命令-1&quot;&gt;&lt;strong&gt;扩展命令&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;scard key:获取set中成员的数量&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; scard set1
(integer) 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;srandmember key:随机返回set中的一个成员&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; srandmember set1
&quot;1&quot;
127.0.0.1:6379&amp;gt; srandmember set1
&quot;5&quot;
127.0.0.1:6379&amp;gt; srandmember set1
&quot;3&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sdiffstore destination key1 key2...:将key1 key2...相差的成员存储在destination上&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; sdiffstore set3 set1 set2
(integer) 2
127.0.0.1:6379&amp;gt; smembers set3
1) &quot;1&quot;
2) &quot;2&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sinterstore destination key[key...]:将返回的交集存储在destination上&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; sinterstore set4 set1 set2
(integer) 3
127.0.0.1:6379&amp;gt; smembers set4
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;5&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;redis-sortedset&quot;&gt;5、Redis-sortedset&lt;/h4&gt;
&lt;h5 id=&quot;赋值-4&quot;&gt;&lt;strong&gt;赋值&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;zadd key score member score2 member2...:将所有成员以及该成员的分数存放到sorted-set中。如果该元素已经存在则会用新的分数代替原有的分数，返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zadd list 50 xiaoming 100 xiaohong 200 xiaozhang
(integer) 3&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;取值-4&quot;&gt;&lt;strong&gt;取值&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;zscore key member:返回指定成员的分数&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zscore list xiaohong
&quot;100&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;zcard key:获取集合中的成员数量&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zcard list
(integer) 3&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;范围查询&quot;&gt;&lt;strong&gt;范围查询&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;zrange key start end[withscores]:获取集合中脚标为start-end的成员，[withscores]参数表明返回的成员包含其分数(分数从小到大排序)&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zrange list 0 -1
1) &quot;xiaoming&quot;
2) &quot;xiaohong&quot;
3) &quot;xiaozhang&quot;
127.0.0.1:6379&amp;gt; zrange list 0 -1 withscores
1) &quot;xiaoming&quot;
2) &quot;50&quot;
3) &quot;xiaohong&quot;
4) &quot;100&quot;
5) &quot;xiaozhang&quot;
6) &quot;200&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;zrevrange key start end[withscores]:获取集合中脚标为start-end的成员，[withscores]参数表明返回的成员包含其分数(分数从大到小排序)&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zrevrange list 0 -1
1) &quot;xiaozhang&quot;
2) &quot;xiaohong&quot;
3) &quot;xiaoming&quot;
127.0.0.1:6379&amp;gt; zrevrange list 0 -1 withscores
1) &quot;xiaozhang&quot;
2) &quot;200&quot;
3) &quot;xiaohong&quot;
4) &quot;100&quot;
5) &quot;xiaoming&quot;
6) &quot;50&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;删值-2&quot;&gt;&lt;strong&gt;删值&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;zrem key member[member...]:移除集合中指定的成员，可以指定多个成员&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zrem list xiaozhang
(integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;zremrangebyrank key start stop:按照排名范围删除元素&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zremrangebyrank list 0 1
(integer) 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;zremrangebyscore key min max:按照分数范围删除元素&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zremrangebyscore list 50 120
(integer) 2&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;扩展命令-2&quot;&gt;&lt;strong&gt;扩展命令&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;zrangebyscore key min max [withscores][LIMIT offset count]:返回分数在[min,max]的成员并按照分数从低到高排序。[withscores]:显示分数；[LIMIT offset count]:offset，表明从脚标为offset的元素开始并返回count个成员&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zrangebyscore list 50 120 withscores limit 0 2
1) &quot;xiaoming&quot;
2) &quot;50&quot;
3) &quot;xiaohong&quot;
4) &quot;100&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;zincrby key increment member:设置指定成员的增加的分数，返回值是更改后的分数&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zincrby list 30 xiaoming
&quot;80&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;zcount key min max:获取分数在[min,max]之间的成员&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zcount list 80 120
(integer) 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;zrank key member:返回成员在集合中的排名(索引从小到大)&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zrank list xiaohong
(integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;zrevrank key member:返回成员在集合中的排名。(索引从大到小)&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zrevrank list xiaozhang
(integer) 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;通用redis命令重点&quot;&gt;6、通用Redis命令【重点】&lt;/h4&gt;
&lt;p&gt;keys pattern:获取所有与pattern匹配的key，返回所有与该key匹配的keys。*表示任意一个或者多个字符&lt;/p&gt;
&lt;p&gt;通配符:&lt;/p&gt;
&lt;p&gt;exits key:判断该key是否存在，1表示存在，0表示不存在&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; exists username
(integer) 1
127.0.0.1:6379&amp;gt; exists admin
(integer) 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;rename key newkey:为当前的key重命名&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; rename username user
OK
127.0.0.1:6379&amp;gt; keys *
 1) &quot;list&quot;
 2) &quot;abc&quot;
 3) &quot;set1&quot;
 4) &quot;information&quot;
 5) &quot;set2&quot;
 6) &quot;age&quot;
 7) &quot;score2&quot;
 8) &quot;set4&quot;
 9) &quot;score1&quot;
10) &quot;set3&quot;
11) &quot;user&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;type key:获取指定的key的值类型，该命令将以字符串的格式返回。返回的字符串为string、list、set、hash和zset，&lt;br/&gt;如果key不存在返回none&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; type user
string
127.0.0.1:6379&amp;gt; type list
zset&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;expire key:设置过期时间，单位:秒 如果某个key过期，redis会将其删除&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; expire abc 10
(integer) 1
127.0.0.1:6379&amp;gt; keys *
 1) &quot;list&quot;
 2) &quot;set1&quot;
 3) &quot;information&quot;
 4) &quot;set2&quot;
 5) &quot;age&quot;
 6) &quot;score2&quot;
 7) &quot;set4&quot;
 8) &quot;score1&quot;
 9) &quot;set3&quot;
10) &quot;user&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ttl key:获取该key所剩的超时时间，如果没有设置超时时间，返回-1.如果返回-2表示超时不存在。&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; expire user 10
(integer) 1
127.0.0.1:6379&amp;gt; ttl user
(integer) 3
127.0.0.1:6379&amp;gt; ttl user
(integer) -2
127.0.0.1:6379&amp;gt; keys *
1) &quot;list&quot;
2) &quot;set1&quot;
3) &quot;information&quot;
4) &quot;set2&quot;
5) &quot;age&quot;
6) &quot;score2&quot;
7) &quot;set4&quot;
8) &quot;score1&quot;
9) &quot;set3&quot;
127.0.0.1:6379&amp;gt; ttl information
(integer) -1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;redis其他特性&quot;&gt;7、Redis其他特性&lt;/h4&gt;
&lt;h5 id=&quot;消息订阅与发布&quot;&gt;&lt;strong&gt;消息订阅与发布&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;subscribe channel:订阅频道&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; subscribe mychat
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;mychat&quot;
3) (integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;psubscribe channel*:批量订阅频道&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; psubscribe s*
Reading messages... (press Ctrl-C to quit)
1) &quot;psubscribe&quot;
2) &quot;s*&quot;
3) (integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;publish channel content:在指定的频道中发布消息&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; publish mychat 'today is a newday'
(integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;多数据库&quot;&gt;&lt;strong&gt;多数据库&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;传统数据库如MySQL数据库可以自己用语句自定义创建，我们可以通过create database xxxx进行创建。Redis 也是有数据库的，不过Redis已经提前创建好了。在redis默认有十六个数据库，0,1,2....15，在radis上所作的所有数据操作，都是默认在0号数据库上操作，数据库与数据库之间是不能共享键值对的。我们可以把Redis数据库理解为一个map集合。&lt;/p&gt;
&lt;h5 id=&quot;切换数据库&quot;&gt;&lt;strong&gt;切换数据库&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;select 数据库名:切换数据库&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; select 1
OK
127.0.0.1:6379[1]&amp;gt; select 15
OK
127.0.0.1:6379[15]&amp;gt; select 16
(error) ERR DB index is out of range&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;数据库的移植&quot;&gt;&lt;strong&gt;数据库的移植&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;move newkey 数据库名:将当前数据库的key移植到指定的数据库中&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; keys *
1) &quot;list&quot;
2) &quot;set1&quot;
3) &quot;information&quot;
4) &quot;set2&quot;
5) &quot;age&quot;
6) &quot;score2&quot;
7) &quot;set4&quot;
8) &quot;score1&quot;
9) &quot;set3&quot;
127.0.0.1:6379&amp;gt; move information 1
(integer) 1
127.0.0.1:6379&amp;gt; keys *
1) &quot;list&quot;
2) &quot;set1&quot;
3) &quot;set2&quot;
4) &quot;age&quot;
5) &quot;score2&quot;
6) &quot;set4&quot;
7) &quot;score1&quot;
8) &quot;set3&quot;
127.0.0.1:6379&amp;gt; select 1
OK
127.0.0.1:6379[1]&amp;gt; keys *
1) &quot;information&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;数据库清空&quot;&gt;&lt;strong&gt;数据库清空&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;flushdb 删除当前数据库中的所有key&lt;/p&gt;
&lt;p&gt;flushall 删除所有数据库中的所有key&lt;/p&gt;
&lt;h5 id=&quot;服务器命令&quot;&gt;&lt;strong&gt;服务器命令&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;ping 测试连接是否存活&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; ping
PONG&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;echo 在命令行打印一些内容&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; echo hehe
&quot;hehe&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;quit/Ctrl+C 退出客户端&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; quit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dbsize 返回当前数据库中的key的数目&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; dbsize
(integer) 8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;info 获取服务器的信息和统计&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; info
# Server
redis_version:4.9.103
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:d727e4f6fe88cefd
redis_mode:standalone
......
......&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;redis持久化策略&quot;&gt;8、Redis持久化策略&lt;/h4&gt;
&lt;h5 id=&quot;rdb策略&quot;&gt;&lt;strong&gt;RDB策略&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;RDB是redis的默认持久化机制，相当于照快照，保存的是一种状态&lt;/p&gt;
&lt;p&gt;优点:&lt;/p&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小内存机器不适合使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;RDB机制符合要求就会照快照(随时随地启动)，会占用一定的系统资源(突然的)很可能内存不足直接宕机。(宕机后，服务器会关闭，属于非正常关闭，数据会丢失)&lt;/p&gt;
&lt;p&gt;RDB机制适用于内存比较充裕的计算机&lt;/p&gt;
&lt;p&gt;RDB是何时进行照快照？&lt;/p&gt;
&lt;h5 id=&quot;aof策略&quot;&gt;&lt;strong&gt;AOF策略&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;AOF策略是一种使用日志功能保存数据操作的机制，默认AOF机制关闭的，它的操作只会保存导致key变化的语句&lt;/p&gt;
&lt;p&gt;优点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;持续性占用极少量的内存资源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点:&lt;/p&gt;
&lt;p&gt;AOF机制适用于内存比较小的计算机&lt;/p&gt;
&lt;p&gt;AOF是如何进行数据备份的呢？&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每秒同步：每秒进行一次AOF保存数据，安全性低，比较节省系统资源&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;每修改同步：只要有key变化语句，就进行AOF保存数据，比较安全，但是这样做极为浪费系统资源，降低效率&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不同步:不进行任何持久化操作，这种配置不安全&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;AOF的配置&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;always #每秒有数据修改发生时都会写入AOF文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;everysec #每秒同步一次，该策略为AOF的缺省策略&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;no #从不同步。高效但是数据不会被持久化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;开启AOF机制的方法&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在redis.config文件中用:/aof找到对应的段落&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将appendonly no改成appendonly yes&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;再修改其中一段成appendfsync always即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 27 Aug 2018 07:28:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<og:description>新人入坑Redis必会的吐血总结 一、什么是Redis Redis是一个使用C语言开发的开源的高性能的key value存储系统，我们可以把它近似理解为Java Map。简单来讲，Redis是一种NO</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/9542496.html</dc:identifier>
</item>
<item>
<title>记一次苏宁小店事故分析和总结 - nivanafish</title>
<link>http://www.cnblogs.com/fishlynn/p/9542477.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fishlynn/p/9542477.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;转java 3年了，记一个最近的坑； &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;临近818，苏宁小店线上 app 搞了个秒杀活动，后台服务出现了异常。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;活动是周五 10 点，收到了系统的告警短信，同事开始有人在公司豆芽（苏宁内部通信工具）反馈有部分用户下单失败；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qdaKw2D1RS1ib1uLLyeaDeUhdoOkShKPqbnRj38JcSQsUVCEOxkl7MG0X8vKNXyMxUWial2utXT0uRagUo4iconkw/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.38657407407407407&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;432&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qdaKw2D1RS1ib1uLLyeaDeUhdoOkShKPqVpm8gFTiac5emTLftjIsmPexJkhOZcQyptKHr4Ey7eFXC4WU4DZnbrA/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.3856812933025404&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;433&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在监控仪表盘上也可以看到访问量开始剧增，同时响应时间开始变长，中台价格系统开始报错，导致后面的接口系统报错。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qdaKw2D1RS1ib1uLLyeaDeUhdoOkShKPqFvkTBvw7Plq77VFzQDL5T05xgC9krtrAiamD8P5EvhNP8LI1IC8bK6Q/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.47785108388312914&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1061&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;去日志平台查看了价格系统接口的调用情况。我们可以看到接口响应时间是慢慢变慢的，最后开始出现了报错现象。去查看报错信息 Timeout 报错。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qdaKw2D1RS1ib1uLLyeaDeUhdoOkShKPqmKDLWwsLBRWkS3cQfjK248lt2JJsLuaePiaufMzo7WZjVdZOL8bsH8A/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.579212916246216&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;991&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;查看耗时过长接口的调用明细，可以看到价格系统的接口已经开始出现了积压，后面的接口需要等待前面的接口处理完成了才会处理，所以接口的耗时也不断的增长。查看了下代码逻辑只是从 Redis 里读取数据，应该几毫秒就处理的事情怎么会这么慢导致了积压呢？难道 Redis 出现了问题？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qdaKw2D1RS1ib1uLLyeaDeUhdoOkShKPq0dia4YhaWh5kicvibNpwk0xkcuSWXlz7icmtkqozJ2gtUtiaQAESWBT6LDw/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.29712955779674166&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1289&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qdaKw2D1RS1ib1uLLyeaDeUhdoOkShKPqtS4GoTkj3yqQT7Mk8sic1Gn3KwUwhN9f6V5ErcV1ZCOMXneK0I09zAQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.2353395061728395&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1296&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;还真是，原来价格系统是和主数据系统共用的一套 Redis  [两组（一主两从）]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图片贴出的是其中两台主库的压力分别是 72w 和 62w 。内存使用率也是居高不下。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;给价格系统独立申请了两组 Redis，晚上通宵发布（苦逼啊）。&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qdaKw2D1RS1ib1uLLyeaDeUhdoOkShKPqKnyxH2YTJiaub7mllibtGzbpjgXZJKTsZgJWsicEwcBibBlJicg1mhBHCyQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.41687344913151364&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;403&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当晚升级后，做了次压测，价格接口可以支持峰值 70w 次/分钟的调用，这周五的活动从仪表盘上也是看到轻轻松松无压力了。（0ms 是因为仪表板精确到ms 四舍五入了）&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  总结  &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.没有按活动人数评估系统压力做相应的压力测试，导致生成事故。做活动时候产品和运营应该预估好活动人数和开发沟通，开发应该对目前的系统能否支持这样的流量有一个认知不能想当然，如果不确定可以联系测试做压力测试。很显然这次的事故并没有做相关的工作。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.没有降级方案对服务进行熔断或降级，导致前台系统直接报错。&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果你看到了这里，那么请长按二维码，关注我，一起成长！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qdaKw2D1RS0DVkp0bg5GLt3Tw9m8F4iadBIAOntZjbadlQgQxng38qOZCTgmUMQJIibicfWR9HToYbrm4QEVFYGxg/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Mon, 27 Aug 2018 07:25:00 +0000</pubDate>
<dc:creator>nivanafish</dc:creator>
<og:description>转java 3年了，记一个最近的坑； 临近818，苏宁小店线上 app 搞了个秒杀活动，后台服务出现了异常。 活动是周五 10 点，收到了系统的告警短信，同事开始有人在公司豆芽（苏宁内部通信工具）反馈</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fishlynn/p/9542477.html</dc:identifier>
</item>
<item>
<title>Volatile的详解 - 多读书多看报</title>
<link>http://www.cnblogs.com/duodushuduokanbao/p/9538067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duodushuduokanbao/p/9538067.html</guid>
<description>&lt;p&gt;&lt;strong&gt;volatile关键字修饰的共享变量主要有两个特点：1.保证了不同线程访问的内存可见性    2.禁止重排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在说内存可见性和有序性之前，我们有必要看一下Java的内存模型(注意和JVM内存模型的区分)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么要有java内存模型？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先我们知道内存访问和CPU指令在执行速度上相差非常大，完全不是一个数量级，为了使得java在各个平台上运行的差距减少，哪些搞处理器的大佬就在CPU上加了各种高速缓存，来减少内存操作和CPU指令的执行速度差距。而Java在java层面又进行了一波抽象，java内存模型将内存分为工作内存和主存，每个线程从主存load数据到工作内存，将load的数据赋值给工作内存上的变量，然后该工作内存对应的线程进行处理，处理结果在赋值给其工作内存，然后再将数据赋值给主存中的变量(这时候需要有一张图)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1373220/201808/1373220-20180826174610675-1209984885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用工作内存和主存虽然加快了处理速度，但是也带来了一些问题，比如下面这个例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         i = i+1;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当在单线程情况下，i最后的值一定是2；但是在两个线程情况下一定是3吗？那就未必了。当线程A读取i的值为1，load到其工作内存，这时CPU切换至线程B，线程B读取i的值也是1，然后对加1然后save到主存，这时线程A也对i进行加1，也save回主存，但最终i的值为2。如果写操作比较慢，你读到的值还有可能是1，这就是缓存不一致的问题。&lt;strong&gt;JMM就是围绕着原子性，内存可见性，有序性这三个特征建立的。通过解决这个三个特征来解决缓存不一致的问题。而volatile主要针对于内存可见性和有序性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原子性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;原子性是指一个操作要么成功，那么失败，没有中间状态，比如i=1，直接读取i的值，这肯定是原子操作；但是i++，看似好像是，其实需要先读取i的值，然后+1，最后在赋值给i，需要三个步骤，这就不是原子性操作。在JDK1.5引入了boolean、long、int对应的原子性类AtomicBoolean、AtomicLong、AtomicInteger，他们可以提供原子性操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存可见性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具有内存可见性的变量在被线程修改以后，会立刻刷新到主存并使其他线程的缓存行上的数据失效&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;volatile修饰的变量具有内存可见性，主要表现为：&lt;strong&gt;当写一个volatile变量时，JMM会将该线程对应的工作内存中的共享变量立即刷新到主存；当读一个volatile变量时，JMM会把该线程对应的工作内存中的值置为无效，然后从主存中进行读取，但是如果没有线程对该共享变量进行修改，则不会触发该操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有序性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JMM是允许处理器和编译器对指令进行重排序的，但规定了as-if-serial，即无论怎么重排序，最终结果都是一样的。比如下面这段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; weight = 10;                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; high = 5;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; area = high * weight * high;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码中可以按照A--&amp;gt;B--&amp;gt;C执行，也可以按照B--&amp;gt;A--&amp;gt;C执行，因为A和B是相互独立的，而C依赖于A、B，所以C不能排到A或B的前面。JMM保证了单线程的重排序，但是在多线程中就容易出现问题。比如下面这种情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; a = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; write(){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; a = 2;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         flag = &lt;span&gt;true&lt;/span&gt;;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; multiply(){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(flag){                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; ret = a * a ;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果有两个线程执行上面的代码，线程1先执行write方法，随后线程2执行multiply方法。最后结果一定是4吗，不一定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1373220/201808/1373220-20180827100220864-1629287737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，JMM对1和2进行了重排序，先将flag设置为true，这是线程2执行，由于a还没有赋值，所以最后ret的值为0；&lt;/p&gt;
&lt;p&gt;如果使用volatile关键字修饰flag，禁止重排序，可以保证程序的有序性，也可以使用synchronized或者lock这种重量级锁来保证有序性，但性能会下降。&lt;/p&gt;
&lt;p&gt;另外，JMM具备一些先天的&lt;strong&gt;有序性&lt;/strong&gt;,即不需要通过任何手段就可以保证的有序性，通常称为&lt;strong&gt;happens-before&lt;/strong&gt;原则。&lt;code&gt;&amp;lt;&amp;lt;JSR-133：Java Memory Model and Thread Specification&amp;gt;&amp;gt;&lt;/code&gt;定义了如下happens-before规则：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;9&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;程序顺序规则&lt;/strong&gt;： 一个线程中的每个操作，happens-before于该线程中的任意后续操作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;监视器锁规则&lt;/strong&gt;：对一个线程的解锁，happens-before于随后对这个线程的加锁&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;volatile变量规则&lt;/strong&gt;： 对一个volatile域的写，happens-before于后续对这个volatile域的读&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;传递性&lt;/strong&gt;：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;start()规则&lt;/strong&gt;： 如果线程A执行操作&lt;code&gt;ThreadB_start()&lt;/code&gt;(启动线程B) , 那么A线程的&lt;code&gt;ThreadB_start()&lt;/code&gt;happens-before 于B中的任意操作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;join()原则&lt;/strong&gt;： 如果A执行&lt;code&gt;ThreadB.join()&lt;/code&gt;并且成功返回，那么线程B中的任意操作happens-before于线程A从&lt;code&gt;ThreadB.join()&lt;/code&gt;操作成功返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;interrupt()原则&lt;/strong&gt;： 对线程&lt;code&gt;interrupt()&lt;/code&gt;方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过&lt;code&gt;Thread.interrupted()&lt;/code&gt;方法检测是否有中断发生&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;finalize()原则&lt;/strong&gt;：一个对象的初始化完成先行发生于它的&lt;code&gt;finalize()&lt;/code&gt;方法的开始&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第1条规则程序顺序规则是说在一个线程里，所有的操作都是按顺序的，但是在JMM里其实只要执行结果一样，是允许重排序的，这边的happens-before强调的重点也是单线程执行结果的正确性，但是无法保证多线程也是如此。&lt;/p&gt;
&lt;p&gt;第2条规则监视器规则其实也好理解，就是在加锁之前，确定这个锁之前已经被释放了，才能继续加锁。&lt;/p&gt;
&lt;p&gt;第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。&lt;/p&gt;
&lt;p&gt;第4条规则，就是happens-before的传递性。&lt;/p&gt;

&lt;p&gt;需要注意的是，&lt;strong&gt;被volatile修饰的共享变量只满足内存可见性和禁止重排序，并不能保证原子性。比如volatile i++。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; inc = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; increase() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         inc++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; Test test = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;10;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=0;j&amp;lt;1000;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                        test.increase();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                };
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }.start();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;  
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(Thread.activeCount()&amp;gt;1)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保证前面的线程都执行完&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            Thread.yield();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        System.out.println(test.inc);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按道理来说结果是10000，但是运行下很可能是个小于10000的值。有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。&lt;/p&gt;
&lt;p&gt;假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。&lt;/p&gt;
&lt;p&gt;线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。&lt;/p&gt;
&lt;p&gt;此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次increase()，结果却只加了一次。&lt;/p&gt;
&lt;p&gt;有人说，&lt;strong&gt;volatile不是会使缓存行无效的吗&lt;/strong&gt;？但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。&lt;/p&gt;
&lt;p&gt;又有人说，线程B将11写回主存，&lt;strong&gt;不会把线程A的缓存行设为无效吗&lt;/strong&gt;？但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。&lt;/p&gt;
&lt;p&gt;综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。但是volatile在上面那种设置flag值的例子里，由于对flag的读/写操作都是单步的，所以还是能保证原子性的。&lt;/p&gt;
&lt;p&gt;要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;volatile底层原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果将使用volatile修饰的代码和未使用volatile修饰的代码都编译成汇编语言，会发现，使用volatile修饰的代码会多出一个lock前缀指令。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;lock前缀指令相当于一个内存屏障，内存屏障的作用有以下三点：&lt;/p&gt;
&lt;p&gt;①重排序时，不能把内存屏障后面的指令排序到内存屏障前&lt;/p&gt;
&lt;p&gt;②使得本CPU的cache写入内存&lt;/p&gt;
&lt;p&gt;③写入动作会引起其他CPU缓存或内核的数据无效，相当于修改对其他线程可见。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;volatile的应用场景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为volatile对复合操作无效，所以volatile修饰像上面例子中的flag这样的只会发生读/写的标记型字段。&lt;/p&gt;
&lt;p&gt;在单利模式中，volatile还可以修饰成员变量，防止初始化时的指令重排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton instance= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton getInstance(){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(instance==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;synchronized&lt;/span&gt;(Singleton.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(instance==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 27 Aug 2018 07:22:00 +0000</pubDate>
<dc:creator>多读书多看报</dc:creator>
<og:description>volatile关键字修饰的共享变量主要有两个特点：1.保证了不同线程访问的内存可见性 2.禁止重排序 在说内存可见性和有序性之前，我们有必要看一下Java的内存模型(注意和JVM内存模型的区分) 为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/duodushuduokanbao/p/9538067.html</dc:identifier>
</item>
<item>
<title>不使用IDE，用maven命令打包war项目及出现的问题解决(最全攻略，亲测有效) - 技术宅-CTW</title>
<link>http://www.cnblogs.com/deep-space/p/9540859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deep-space/p/9540859.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;第一次在博客园写博客，写的不好大家见谅啊！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　一、&lt;span&gt;首先，在用maven打包之前，一定确认好你使用的jdk版本和maven的版本，最好就是用jdk1.8和maven3.3以上的，版本太低了容易出现一些意想不到的问题（现在应该用的都比较新的版本，老版本也有用的，如果你用的是低版本的，不用担心，下面也会有解决方案的☺）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　确认好版本之后，就要看你的jdk有没有安装好，环境变量有没有配置好（maven也一样检查一下），这里顺便附上jdk和maven的安装和配置：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;这里是jdk的安装和配置： https://jingyan.baidu.com/article/6dad5075d1dc40a123e36ea3.html&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这里是maven的安装和配置，很详细： https://jingyan.baidu.com/article/6c67b1d646ae842786bb1e7a.html&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　二、jdk和maven都配置好之后，就要查看本地的maven库（这一步应该在配置maven中做好，在maven的settings文件中配置好依赖的下载路径，在我的文件中有settings的配置，请自行下载查看）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　三、在打包之前还要检查项目的pom文件有没有配置好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　⑴、&lt;/span&gt;&lt;span&gt;在需要打包的pom文件中按如下代码配置：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;项目名&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;打包的pom所在的包名&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;

    &amp;lt;name&amp;gt;打包的pom所在的包名&amp;lt;/name&amp;gt;
    &amp;lt;url&amp;gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maven.apache.org&amp;lt;/url&amp;gt;&lt;/span&gt;

    &amp;lt;modules&amp;gt;
        &amp;lt;module&amp;gt;各个子包的名字&amp;lt;/module&amp;gt;&lt;span&gt;
        有几个子包就写几个module
    &lt;/span&gt;&amp;lt;/modules&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;junit.version&amp;gt;4.10&amp;lt;/junit.version&amp;gt;
        &amp;lt;mysql.driver&amp;gt;com.mysql.jdbc.Driver&amp;lt;/mysql.driver&amp;gt;
        &amp;lt;mysql.url&amp;gt;jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:3306/mysql&amp;lt;/mysql.url&amp;gt;&lt;/span&gt;
        &amp;lt;mysql.username&amp;gt;数据库用户名&amp;lt;/mysql.username&amp;gt;
        &amp;lt;mysql.password&amp;gt;数据库密码&amp;lt;/mysql.password&amp;gt;
        &amp;lt;spring.version&amp;gt;3.2.4.RELEASE&amp;lt;/spring.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;!-- 全局依赖 --&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${junit.version}&amp;lt;/version&amp;gt;
            &amp;lt;!-- &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; --&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;distributionManagement&amp;gt;

    &amp;lt;/distributionManagement&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;finalName&amp;gt;这里写打包之后的war包的名字&amp;lt;/finalName&amp;gt;

        &amp;lt;pluginManagement&amp;gt;
            &amp;lt;plugins&amp;gt;
                &amp;lt;plugin&amp;gt;
                    &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                    &amp;lt;version&amp;gt;2.3.2&amp;lt;/version&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;source&amp;gt;1.7&amp;lt;/source&amp;gt;
                        &amp;lt;target&amp;gt;1.7&amp;lt;/target&amp;gt;
                        &amp;lt;verbose&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/verbose&amp;gt;
                        &amp;lt;fork&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/fork&amp;gt;
                        &amp;lt;executable&amp;gt;${JAVA_HOME}\bin\javac&amp;lt;/executable&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                &amp;lt;/plugin&amp;gt;

                &amp;lt;plugin&amp;gt;
                    &amp;lt;artifactId&amp;gt;maven-surefire-plugin&amp;lt;/artifactId&amp;gt;
                    &amp;lt;version&amp;gt;2.12.4&amp;lt;/version&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;skip&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/skip&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                &amp;lt;/plugin&amp;gt;
                &amp;lt;plugin&amp;gt;
                    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;maven-war-plugin&amp;lt;/artifactId&amp;gt;
                    &amp;lt;version&amp;gt;2.1.1&amp;lt;/version&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;webResources&amp;gt;
                            &amp;lt;resource&amp;gt;&amp;lt;!--打包lib文件夹的jar包 --&amp;gt;
                                &amp;lt;directory&amp;gt;${project.basedir}/lib&amp;lt;/directory&amp;gt;
                                &amp;lt;targetPath&amp;gt;WEB-INF/lib&amp;lt;/targetPath&amp;gt;
                                &amp;lt;filtering&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/filtering&amp;gt;
                                &amp;lt;includes&amp;gt;
                                    &amp;lt;include&amp;gt;**&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.jar&amp;lt;/include&amp;gt;
                                &amp;lt;/includes&amp;gt;
                            &amp;lt;/resource&amp;gt;
                        &amp;lt;/webResources&amp;gt;
                        &amp;lt;archive&amp;gt;
                            &amp;lt;addMavenDescriptor&amp;gt;false&amp;lt;/addMavenDescriptor&amp;gt;
                        &amp;lt;/archive&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                &amp;lt;/plugin&amp;gt;
                &amp;lt;!-- &amp;lt;plugin&amp;gt;
                    &amp;lt;artifactId&amp;gt;maven-antrun-plugin&amp;lt;/artifactId&amp;gt;
                    &amp;lt;executions&amp;gt;
                        &amp;lt;execution&amp;gt;
                            &amp;lt;id&amp;gt;copy-war&amp;lt;/id&amp;gt;
                            &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
                            &amp;lt;goals&amp;gt;
                                &amp;lt;goal&amp;gt;run&amp;lt;/goal&amp;gt;
                            &amp;lt;/goals&amp;gt;
                            &amp;lt;configuration&amp;gt;
                                &amp;lt;tasks&amp;gt;copy war包到本地tomcat的webapp目录
                                    &amp;lt;echo message=&quot;Copy war file to Tomcat webapps....&quot; /&amp;gt;
                                    &amp;lt;copy file=&quot;target/XXX.war&quot; todir=&quot;D:/work/apache-tomcat-8.0.1/webapps&quot;
                                        overwrite=&quot;true&quot; /&amp;gt;
                                    copy配置文件到本地tomcat的conf目录 
                                    &amp;lt;echo message=&quot;Copy config file to appconfig....&quot; /&amp;gt;
                                    &amp;lt;copy todir=&quot;D:/work/apache-tomcat-8.0.1/appconfig&quot;
                                        preservelastmodified=&quot;true&quot; overwrite=&quot;true&quot;&amp;gt;
                                        &amp;lt;fileset dir=&quot;src/main/resources/conf&quot;&amp;gt;
                                            &amp;lt;include name=&quot;*.properties&quot; /&amp;gt;
                                        &amp;lt;/fileset&amp;gt;
                                    &amp;lt;/copy&amp;gt;
                                &amp;lt;/tasks&amp;gt;
                            &amp;lt;/configuration&amp;gt;
                        &amp;lt;/execution&amp;gt;
                    &amp;lt;/executions&amp;gt;
                &amp;lt;/plugin&amp;gt; --&amp;gt;

                &amp;lt;plugin&amp;gt;
                    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;maven-source-plugin&amp;lt;/artifactId&amp;gt;
                    &amp;lt;version&amp;gt;2.1.2&amp;lt;/version&amp;gt;
                    &amp;lt;executions&amp;gt;
                        &amp;lt;execution&amp;gt;
                            &amp;lt;id&amp;gt;attach-sources&amp;lt;/id&amp;gt;
                            &amp;lt;goals&amp;gt;
                                &amp;lt;goal&amp;gt;jar-no-fork&amp;lt;/goal&amp;gt;
                            &amp;lt;/goals&amp;gt;
                        &amp;lt;/execution&amp;gt;
                    &amp;lt;/executions&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                &amp;lt;/plugin&amp;gt;
                &amp;lt;plugin&amp;gt;
                    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;maven-javadoc-plugin&amp;lt;/artifactId&amp;gt;
                    &amp;lt;version&amp;gt;2.9&amp;lt;/version&amp;gt;
                    &amp;lt;executions&amp;gt;
                        &amp;lt;execution&amp;gt;
                            &amp;lt;id&amp;gt;attach-javadocs&amp;lt;/id&amp;gt;
                            &amp;lt;goals&amp;gt;
                                &amp;lt;goal&amp;gt;jar&amp;lt;/goal&amp;gt;
                            &amp;lt;/goals&amp;gt;
                        &amp;lt;/execution&amp;gt;
                    &amp;lt;/executions&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                &amp;lt;/plugin&amp;gt;
            &amp;lt;/plugins&amp;gt;
        &amp;lt;/pluginManagement&amp;gt;
    &amp;lt;/build&amp;gt;    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　⑵、&lt;span&gt;在要存放war包的子包的pom中加入以下配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;存放所有子包的包&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;用pom打包的包名&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
        &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
    &amp;lt;/parent&amp;gt; 
    
    &amp;lt;artifactId&amp;gt;存放所有子包的包(存放war包的子包名)&amp;lt;/artifactId&amp;gt;
    &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt; 

    &amp;lt;build&amp;gt;
        &amp;lt;sourceDirectory&amp;gt;src/main/java&amp;lt;/sourceDirectory&amp;gt;
        &amp;lt;testSourceDirectory&amp;gt;src/test/java&amp;lt;/testSourceDirectory&amp;gt;
        &amp;lt;resources&amp;gt;
            &amp;lt;resource&amp;gt;
                &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
                &amp;lt;excludes&amp;gt;
                    &amp;lt;exclude&amp;gt;**&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.java&amp;lt;/exclude&amp;gt;
                &amp;lt;/excludes&amp;gt;
            &amp;lt;/resource&amp;gt;
        &amp;lt;/resources&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.3.2&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;source&amp;gt;1.7&amp;lt;/source&amp;gt;
                    &amp;lt;target&amp;gt;1.7&amp;lt;/target&amp;gt;
                    &amp;lt;verbose&amp;gt;true&amp;lt;/verbose&amp;gt;
                    &amp;lt;fork&amp;gt;true&amp;lt;/fork&amp;gt;
                    &amp;lt;executable&amp;gt;${JAVA_HOME}\bin\javac&amp;lt;/executable&amp;gt;
                    &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-war-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.1.1&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;webResources&amp;gt;
                        &amp;lt;resource&amp;gt;
                            &amp;lt;directory&amp;gt;src/main/weapp&amp;lt;/directory&amp;gt;
                        &amp;lt;/resource&amp;gt;
                    &amp;lt;/webResources&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　⑶、&lt;span&gt;在其他子包中加入以下配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
  xsi:schemaLocation&lt;/span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt;
  
  &amp;lt;parent&amp;gt;
      &amp;lt;groupId&amp;gt;存放所有子包的包&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;用pom打包的包&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
      &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
  &amp;lt;/parent&amp;gt;
  
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;artifactId&amp;gt;子包名&amp;lt;/artifactId&amp;gt;
  
      &amp;lt;build&amp;gt;
    
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.3.2&amp;lt;/version&amp;gt;
            &amp;lt;/plugin&amp;gt;
            
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-source-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.1.2&amp;lt;/version&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;id&amp;gt;attach-sources&amp;lt;/id&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;jar-no-fork&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　四、上面都检查没问题之后，就可以打开终端或者DOS窗口来用maven命令打包写好的项目啦！Linux系统直接鼠标右键点击打开终端（用过Linux的应该都知道o(*￣︶￣*)o），Windows系统就按win+R（win就是Ctrl键和Alt键中间那个有田字格图标的键）后输入cmd进入命令行编辑模式，或者我推荐大家使用Windows自带的Windows PowerShell ISE，在开始菜单栏或者小娜处搜索powershell，点击即可，这里有各种Windows的命令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1469417/201808/1469417-20180827111832335-540495651.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1469417/201808/1469417-20180827112302670-913637644.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　之后使用命令进入想要打包的项目的pom文件所在目录下，使用mvn package或者mvn clean package进行打包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果打包时出现异常说ClassNotFound，那应该就是包没有加载进去，这时候你就需要看后面提示的信息，它会告诉你缺哪个jar包，只要将缺的jar加入到你的本地maven库或者maven私服上就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果出现与下图所示的异常类似的情况，按照下面列出的找到对应出现异常的 &lt;strong&gt;maven-(插件名)-plugin&lt;/strong&gt; （这里的插件名就是resources、jar、surefire等）修改即可（亲测有效）：　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1469417/201808/1469417-20180827143015915-1311981851.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;maven-surefire-plugin（default test）异常，就是maven的surefire插件版本太高了，将version调整为2.12.4就好了。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;maven-compiler-plugin 的异常，也是插件版本过高导致的，将version调整为2.3.2。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;maven-war-plugin 的异常，将version改为2.1.1。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;maven-jar-plugin 的异常，将version改为2.3.2。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;maven-source-plugin 的异常，将version改为2.1.2。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　如果不是上面的问题，出现乱码或者提示说在哪个类里面多少行有错误的话，应该是有一些代码写法不认，例如：try ... catch {} 语句中，大家都知道，在jdk1.7之后，IO流对象可以写在try后面的括号里，比如&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    File inFile = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(filePath);
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (FileInputStream fis = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(inFile);
       TarArchiveInputStream tais &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TarArchiveInputStream(fis);) {
        ......
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
        e.printStackTrace();
    }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;如果出现这种类似的异常，你需要在pom文件中加入以下代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;pluginManagement&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.3.2&amp;lt;/version&amp;gt;
        &amp;lt;configuration&amp;gt;
            &amp;lt;source&amp;gt;1.7&amp;lt;/source&amp;gt;
            &amp;lt;target&amp;gt;1.7&amp;lt;/target&amp;gt;
            &amp;lt;verbose&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/verbose&amp;gt;
            &amp;lt;fork&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/fork&amp;gt;
            &amp;lt;executable&amp;gt;${JAVA_HOME}\bin\javac&amp;lt;/executable&amp;gt;
        &amp;lt;/configuration&amp;gt;
    &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/pluginManagement&amp;gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　${JAVA_HOME}这里你需要写你的java的安装路径，例如我的就是D:\Java\jdk1.8，所以&amp;lt;executable&amp;gt;D:\Java\jdk1.8\bin\javac&amp;lt;/executable&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;至此，使用maven命令打包war项目及问题解决就完成啦！如果读者老爷们有其他的问题，可以给我留言或者私信！第一次写博客，望大家支持，谢谢啦Thanks♪(･ω･)ﾉ&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Aug 2018 07:16:00 +0000</pubDate>
<dc:creator>技术宅-CTW</dc:creator>
<og:description>第一次在博客园写博客，写的不好大家见谅啊！！ 一、首先，在用maven打包之前，一定确认好你使用的jdk版本和maven的版本，最好就是用jdk1.8和maven3.3以上的，版本太低了容易出现一些意</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/deep-space/p/9540859.html</dc:identifier>
</item>
<item>
<title>TypeScript在react项目中的实践 - 贾顺名</title>
<link>http://www.cnblogs.com/jiasm/p/9542253.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiasm/p/9542253.html</guid>
<description>&lt;p&gt;前段时间有写过一个&lt;a href=&quot;https://www.cnblogs.com/jiasm/p/9348539.html&quot;&gt;TypeScript在node项目中的实践&lt;/a&gt;。&lt;br/&gt;在里边有解释了为什么要使用&lt;code&gt;TS&lt;/code&gt;，以及在&lt;code&gt;Node&lt;/code&gt;中的一个项目结构是怎样的。&lt;br/&gt;但是那仅仅是一个纯接口项目，碰巧赶上近期的另一个项目重构也由我来主持，经过上次的实践以后，尝到了&lt;code&gt;TS&lt;/code&gt;所带来的甜头，毫不犹豫的选择用&lt;code&gt;TS&lt;/code&gt;+&lt;code&gt;React&lt;/code&gt;来重构这个项目。&lt;br/&gt;这次的重构不仅包括&lt;code&gt;Node&lt;/code&gt;的重构（之前是&lt;code&gt;Express&lt;/code&gt;的项目），同时还包括前端的重构（之前是由&lt;code&gt;jQuery&lt;/code&gt;驱动的多页应用）。&lt;/p&gt;
&lt;h2 id=&quot;项目结构&quot;&gt;项目结构&lt;/h2&gt;
&lt;p&gt;因为目前项目是没有做前后分离的打算的（一个内部工具平台类的项目），所以大致结构就是基于上次&lt;code&gt;Node&lt;/code&gt;项目的结构，在其之上添加了一些&lt;code&gt;FrontEnd&lt;/code&gt;的目录结构：&lt;/p&gt;
&lt;pre class=&quot;diff&quot;&gt;
&lt;code&gt;  .
  ├── README.md
  ├── copy-static-assets.ts
  ├── nodemon.json
  ├── package.json
+ ├── client-dist
+ │   ├── bundle.js
+ │   ├── bundle.js.map
+ │   ├── logo.png
+ │   └── vendors.dll.js
  ├── dist
  ├── src
  │   ├── config
  │   ├── controllers
  │   ├── entity
  │   ├── models
  │   ├── middleware
  │   ├── public
  │   ├── app.ts
  │   ├── server.ts
  │   ├── types
+ │   ├── common
  │   └── utils
+ ├── client-src
+ │   ├── components
+ │   │   └── Header.tsx
+ │   ├── conf
+ │   │   └── host.ts
+ │   ├── dist
+ │   ├── utils
+ │   ├── index.ejs
+ │   ├── index.tsx
+ │   ├── webpack
+ │   ├── package.json
+ │   └── tsconfig.json
+ ├── views
+ │   └── index.ejs
  ├── tsconfig.json
  └── tslint.json&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中标绿（也可能是一个&lt;code&gt;+&lt;/code&gt;号显示）的文件为本次新增的。&lt;br/&gt;其中&lt;code&gt;client-dist&lt;/code&gt;与&lt;code&gt;views&lt;/code&gt;都是通过&lt;code&gt;webpack&lt;/code&gt;生成的，实际的源码文件都在&lt;code&gt;client-src&lt;/code&gt;下。&lt;em&gt;就这个结构拆分前后分离其实没有什么成本&lt;/em&gt;&lt;br/&gt;在下边分了大概这样的一些文件夹：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;index.ejs&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;项目的入口&lt;code&gt;html&lt;/code&gt;文件，采用&lt;code&gt;ejs&lt;/code&gt;作为渲染引擎&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;index.tsx&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;项目的入口&lt;code&gt;js&lt;/code&gt;文件，后缀使用&lt;code&gt;tsx&lt;/code&gt;，原因有二：&lt;br/&gt;1. 我们会使用&lt;code&gt;ts&lt;/code&gt;进行&lt;code&gt;React&lt;/code&gt;程序的开发&lt;br/&gt;2. &lt;code&gt;.tsx&lt;/code&gt;文件在vs code上的&lt;code&gt;icon&lt;/code&gt;比较好看 :p&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是用于&lt;code&gt;tsc&lt;/code&gt;编译执行的一些配置文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;components&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;组件存放的目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;config&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各种配置项存放的位置，类似请求接口的&lt;code&gt;host&lt;/code&gt;或者各种状态的&lt;code&gt;map&lt;/code&gt;映射之类的（可以理解为枚举对象们都在这里）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;utils&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;一些公共函数存放的位置，各种可复用的代码都应该放在这里&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;dist&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各种静态资源的存放位置，图片之类文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;webpack&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;里边存放了各种环境的&lt;code&gt;webpack&lt;/code&gt;脚本命令以及&lt;code&gt;dll&lt;/code&gt;的生成&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;前后端复用代码的一个尝试&quot;&gt;前后端复用代码的一个尝试&lt;/h2&gt;
&lt;p&gt;实际上边还漏掉了一个新增的文件夹，我们在&lt;code&gt;src&lt;/code&gt;目录下新增了一个&lt;code&gt;common&lt;/code&gt;目录，这个目录是存放一些公共的函数和公共的&lt;code&gt;config&lt;/code&gt;，不同于&lt;code&gt;utils&lt;/code&gt;或者&lt;code&gt;config&lt;/code&gt;的是，这里的代码是前后端共享的，所以这里边的函数一定要是完全的不包含任何环境依赖，不包含任何业务逻辑的。&lt;/p&gt;
&lt;p&gt;类似的数字千分位，日期格式化，抑或是服务监听的端口号，这些不包含任何逻辑，也对环境没有强依赖的代码，我们都可以放在这里。&lt;br/&gt;这也是没有做前后分离带来的一个小甜头吧，前后可以共享一部分代码。&lt;/p&gt;
&lt;p&gt;要实现这样的配置，基于上述项目需要修改如下几处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;src&lt;/code&gt;下的&lt;code&gt;utils&lt;/code&gt;和&lt;code&gt;config&lt;/code&gt;部分代码迁移到&lt;code&gt;common&lt;/code&gt;文件夹下，主要是用于区分是否可前后通用&lt;/li&gt;
&lt;li&gt;为了将对之前&lt;code&gt;node&lt;/code&gt;结构方面的影响降至最低，我们需要在&lt;code&gt;common&lt;/code&gt;文件夹下新增一个&lt;code&gt;index.ts&lt;/code&gt;索引文件，并在&lt;code&gt;utils/index.ts&lt;/code&gt;下引用它，这样对于&lt;code&gt;node&lt;/code&gt;方面使用来讲，并不需要关心这个文件是来自&lt;code&gt;utils&lt;/code&gt;还是&lt;code&gt;common&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// src/common/utils/comma.ts
export default (num: number): string =&amp;gt; String(num).replace(/\B(?=(\d{3})+$)/g, ',')

// src/common/utils/index.ts
export { default as comma } from './comma'

// src/utils.index.ts
export * from '../common/utils'

// src/app.ts
import { comma } from './utils' // 并不需要关心是来自common还是来自utils

console.log(comma(1234567)) // 1,234,567&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;然后是配置&lt;code&gt;webpack&lt;/code&gt;的&lt;code&gt;alias&lt;/code&gt;属性，用于&lt;code&gt;webpack&lt;/code&gt;能够正确的找到其路径&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// client-src/webpack/base.js
module.exports = {
  resolve: {
    alias: {
       '@Common': path.resolve(__dirname, '../../src/common'),
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;同时我们还需要配置&lt;code&gt;tsconfig.json&lt;/code&gt;用于&lt;code&gt;vs code&lt;/code&gt;可以找到对应的目录，不然会在编辑器中提示&lt;code&gt;can't find module XXX&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// client-src/tsconfig.json
{
  &quot;compilerOptions&quot;: {
    &quot;paths&quot;: {
      // 用于引入某个`module`
      &quot;@Common/*&quot;: [
        &quot;../src/common/*&quot;
      ]
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;最后在&lt;code&gt;client-src/utils/index.ts&lt;/code&gt;写上类似&lt;code&gt;server&lt;/code&gt;端的处理就可以了&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// client-src/utils/index.ts
export * from '@Common/utils'

// client-src/index.tsx
import { comma } from './utils'

console.log(comma(1234567)) // 1,234,567&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;环境的搭建&quot;&gt;环境的搭建&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;如果使用&lt;code&gt;vs code&lt;/code&gt;进行开发，而且使用了&lt;code&gt;ESLint&lt;/code&gt;的话，需要修改&lt;code&gt;TS&lt;/code&gt;语法支持的后缀，添加&lt;code&gt;typescriptreact&lt;/code&gt;的一些处理，这样才会自动修复一些&lt;code&gt;ESLint&lt;/code&gt;的规则：&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&quot;eslint.validate&quot;: [
  &quot;javascript&quot;,
  &quot;javascriptreact&quot;,
  {
    &quot;language&quot;: &quot;typescript&quot;,
    &quot;autoFix&quot;: true
  },
  {
    &quot;language&quot;: &quot;typescriptreact&quot;,
    &quot;autoFix&quot;: true
  }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;webpack的配置&quot;&gt;webpack的配置&lt;/h3&gt;
&lt;p&gt;因为在前端使用了&lt;code&gt;React&lt;/code&gt;，按照目前的主流，&lt;code&gt;webpack&lt;/code&gt;肯定是必不可少的。&lt;br/&gt;并没有选择成熟的&lt;code&gt;cra&lt;/code&gt;(&lt;a href=&quot;https://www.npmjs.com/package/create-react-app&quot;&gt;create-react-app&lt;/a&gt;)来进行环境搭建，原因有下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;webpack&lt;/code&gt;更新到4以后并没有尝试过，想自己耍一耍&lt;/li&gt;
&lt;li&gt;结合着&lt;code&gt;TS&lt;/code&gt;以及公司内部的东西，会有一些自定义配置情况的出现，担心二次开发太繁琐&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是其实也没有太多的配置，本次重构选用的UI框架为Google Material的实现：&lt;a href=&quot;https://material-ui.com/&quot;&gt;material-ui&lt;/a&gt;&lt;br/&gt;而他们采用的是&lt;a href=&quot;http://cssinjs.org/&quot;&gt;jss&lt;/a&gt; 来进行样式的编写，所以也不会涉及到之前惯用的&lt;code&gt;scss&lt;/code&gt;的那一套&lt;code&gt;loader&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;分了大概如下几个文件：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;common.js&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;公共的&lt;code&gt;webpack&lt;/code&gt;配置，类似&lt;code&gt;env&lt;/code&gt;之类的选项&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;dll.js&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于将一些不会修改的第三方库进行提前打包，加快开发时编译效率&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;base.js&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;可以理解为是&lt;code&gt;webpack&lt;/code&gt;的基础配置文件，通用的&lt;code&gt;loader&lt;/code&gt;以及&lt;code&gt;plugins&lt;/code&gt;在这里&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;pro.js&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;生产环境的特殊配置（代码压缩、资源上传）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;dev.js&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;开发环境的特殊配置（&lt;code&gt;source-map&lt;/code&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;dll&lt;/code&gt;是一个很早之前的套路了，大概需要修改这么几处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个单独的&lt;code&gt;webpack&lt;/code&gt;文件，用于生成&lt;code&gt;dll&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;在普通的&lt;code&gt;webpack&lt;/code&gt;文件中进行引用生成的&lt;code&gt;dll&lt;/code&gt;文件&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// dll.js
{
  entry: {
    // 需要提前打包的库
    vendors: [
      'react',
      'react-dom',
      'react-router-dom',
      'babel-polyfill',
    ],
  },
  output: {
    filename: 'vendors.dll.js',
    path: path.resolve(__dirname, '../../client-dist'),
    // 输出时不要少了这个option
    library: 'vendors_lib',
  },
  plugins: [
    new webpack.DllPlugin({
      context: __dirname,
      // 向外抛出的`vendors.dll.js`代码的具体映射，引用`dll`文件的时候通过它来做映射关系的
      path: path.join(__dirname, '../dist/vendors-manifest.json'),
      name: 'vendors_lib',
    })
  ]
}

// base.js
{
  plugins: [
    new webpack.DllReferencePlugin({
      context: __dirname,
      manifest: require('../dist/vendors-manifest.json'),
    }),
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样在&lt;code&gt;watch&lt;/code&gt;文件时，打包就会跳过&lt;code&gt;verdors&lt;/code&gt;中存在的那些包了。&lt;br/&gt;&lt;strong&gt;有一点要注意的，如果最终需要上传这些静态资源，记得连带着&lt;code&gt;verdors.dll.js&lt;/code&gt;一并上传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在本地开发时，&lt;code&gt;vendors&lt;/code&gt;文件并不会自动注入到&lt;code&gt;html&lt;/code&gt;模版中去，所以我们有用到了另一个插件，&lt;a href=&quot;https://www.npmjs.com/package/add-asset-html-webpack-plugin&quot;&gt;add-asset-html-webpack-plugin&lt;/a&gt;。&lt;br/&gt;同时在使用中可能还会遇到&lt;code&gt;webpack&lt;/code&gt;无限次数的重新打包，这个需要配置&lt;code&gt;ignore&lt;/code&gt;来解决-.-：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// dev.js
const HtmlWebpackPlugin = require('html-webpack-plugin')
const AddAssetHtmlPlugin = require('add-asset-html-webpack-plugin')

{
  plugins: [
    // 将`ejs`模版文件放到目标文件夹，并注入入口`js`文件
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, '../index.ejs'),
      filename: path.resolve(__dirname, '../../views/index.ejs'),
    }),
    // 将`vendors`文件注入到`ejs`模版中
    new AddAssetHtmlPlugin({
      filepath: path.resolve(__dirname, '../../client-dist/vendors.dll.js'),
      includeSourcemap: false,
    }),
    // 忽略`ejs`和`js`的文件变化，避免`webpack`无限重新打包的问题
    new webpack.WatchIgnorePlugin([
      /\.ejs$/,
      /\.js$/,
    ]),
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;typescript相关的配置&quot;&gt;TypeScript相关的配置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TS&lt;/code&gt;的配置分了两块，一个是&lt;code&gt;webpack&lt;/code&gt;的配置，另一个是&lt;code&gt;tsconfig&lt;/code&gt;的配置。&lt;/p&gt;
&lt;p&gt;首先是&lt;code&gt;webpack&lt;/code&gt;，针对&lt;code&gt;ts&lt;/code&gt;、&lt;code&gt;tsx&lt;/code&gt;文件我们使用了两个&lt;code&gt;loader&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;{
  rules: [
    {
      test: /\.tsx?$/,
      use: ['babel-loader', 'ts-loader'],
      exclude: /node_modules/,
    }
  ],
  resolve: {
    // 一定不要忘记配置ts tsx后缀
    extensions: ['.tsx', '.ts', '.js'],
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ts-loader&lt;/code&gt;用于将&lt;code&gt;TS&lt;/code&gt;的一些特性转换为&lt;code&gt;JS&lt;/code&gt;兼容的语法，然后执行&lt;code&gt;babel&lt;/code&gt;进行处理&lt;code&gt;react/jsx&lt;/code&gt;相关的代码，最终生成可执行的&lt;code&gt;JS&lt;/code&gt;代码。&lt;/p&gt;
&lt;p&gt;然后是&lt;code&gt;tsconfig&lt;/code&gt;的配置，&lt;code&gt;ts-loader&lt;/code&gt;的执行是依托于这里的配置的，大致的配置如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;{
  &quot;compilerOptions&quot;: {
    &quot;module&quot;: &quot;esnext&quot;,
    &quot;target&quot;: &quot;es6&quot;,
    &quot;allowSyntheticDefaultImports&quot;: true,
    // import的相对起始路径
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;sourceMap&quot;: true,
    // 构建输出目录，但因为使用了`webpack`，所以这个配置并没有什么卵用
    &quot;outDir&quot;: &quot;../client-dist&quot;,
    // 开启`JSX`模式, 
    // `preserve`的配置让`tsc`不会去处理它，而是使用后续的`babel-loader`进行处理
    &quot;jsx&quot;: &quot;preserve&quot;, 
    &quot;strict&quot;: true,
    &quot;moduleResolution&quot;: &quot;node&quot;,
    // 开启装饰器的使用
    &quot;experimentalDecorators&quot;: true,
    &quot;emitDecoratorMetadata&quot;: true,
    // `vs code`所需要的，在开发时找到对应的路径，真实的引用是在`webpack`中配置的`alias`
    &quot;paths&quot;: {
      &quot;@Common&quot;: [
        &quot;../src/common&quot;
      ],
      &quot;@Common/*&quot;: [
        &quot;../src/common/*&quot;
      ]
    }
  },
  &quot;exclude&quot;: [
    &quot;node_modules&quot;
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;eslint的配置&quot;&gt;ESLint的配置&lt;/h3&gt;
&lt;p&gt;最近这段时间，我们团队基于&lt;code&gt;airbnb&lt;/code&gt;的&lt;code&gt;ESLint&lt;/code&gt;规则进行了一些自定义，创建了自家的&lt;a href=&quot;https://www.npmjs.com/package/eslint-config-blued&quot;&gt;eslint-config-blued&lt;/a&gt;&lt;br/&gt;同时还存在了&lt;a href=&quot;https://www.npmjs.com/package/eslint-config-blued-react&quot;&gt;react&lt;/a&gt;和&lt;a href=&quot;https://www.npmjs.com/package/eslint-config-blued-typescript&quot;&gt;typescript&lt;/a&gt;的两个衍生版本。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;ESLint&lt;/code&gt;的配置文件&lt;code&gt;.eslintrc&lt;/code&gt;，在本项目中存在两份。一个是根目录的&lt;code&gt;blued-typescript&lt;/code&gt;，另一个是&lt;code&gt;client-src&lt;/code&gt;下的&lt;code&gt;blued-react&lt;/code&gt; + &lt;code&gt;blued-typescript&lt;/code&gt;。&lt;br/&gt;因为根目录的更多用于&lt;code&gt;node&lt;/code&gt;项目，所以没必要把&lt;code&gt;react&lt;/code&gt;什么的依赖也装进来。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# .eslintrc
extends: blued-typescript

# client-src/.eslintrc
extends: 
  - blued-react
  - blued-typescript&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;一个需要注意的小细节&lt;/strong&gt;&lt;br/&gt;因为我们的&lt;code&gt;react&lt;/code&gt;与&lt;code&gt;typescript&lt;/code&gt;实现版本中都用到了&lt;code&gt;parser&lt;/code&gt;。&lt;br/&gt;&lt;code&gt;react&lt;/code&gt;使用的是&lt;a href=&quot;https://www.npmjs.com/package/babel-eslint&quot;&gt;babel-eslint&lt;/a&gt;，&lt;code&gt;typescript&lt;/code&gt;使用的是&lt;a href=&quot;https://www.npmjs.com/package/typescript-eslint-parser&quot;&gt;typescript-eslint-parser&lt;/a&gt;。&lt;br/&gt;但是&lt;code&gt;parser&lt;/code&gt;只能有一个，从&lt;code&gt;option&lt;/code&gt;的命名中就可以看出&lt;code&gt;extends&lt;/code&gt;、&lt;code&gt;plugins&lt;/code&gt;、&lt;code&gt;rules&lt;/code&gt;，到了&lt;code&gt;parser&lt;/code&gt;就没有复数了。&lt;br/&gt;所以这两个插件在&lt;code&gt;extends&lt;/code&gt;中的顺序就变得很关键，&lt;code&gt;babel&lt;/code&gt;现在并不能理解&lt;code&gt;TS&lt;/code&gt;的语法，但好像&lt;code&gt;babel&lt;/code&gt;开发者有支持&lt;code&gt;TS&lt;/code&gt;的&lt;a href=&quot;https://github.com/babel/babel-eslint/issues/505&quot;&gt;意愿&lt;/a&gt;。&lt;br/&gt;但就目前来说，一定要保证&lt;code&gt;react&lt;/code&gt;在前，&lt;code&gt;typescript&lt;/code&gt;在后，这样&lt;code&gt;parser&lt;/code&gt;才会使用&lt;code&gt;typescript-eslint-parser&lt;/code&gt;来进行覆盖。&lt;/p&gt;
&lt;h3 id=&quot;node层的修改&quot;&gt;node层的修改&lt;/h3&gt;
&lt;p&gt;除了上边提到的两端公用代码以外，还需要添加一个&lt;code&gt;controller&lt;/code&gt;用于吐页面，因为使用的是&lt;code&gt;routing-controllers&lt;/code&gt;这个库，渲染一个静态页面被封装的非常棒，仅仅需要修改两个页面，一个用于设置&lt;code&gt;render&lt;/code&gt;模版的根目录，另一个用来设置要吐出来的模版名称：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// controller/index.ts
import {
  Get,
  Controller,
  Render,
} from 'routing-controllers'

@Controller('/')
export default class {
  @Get('/')
  @Render('index') // 指定一个模版的名字
  async router() {
    // 渲染页面时的一些变量
    // 类似之前的 ctx.state = XXX
    return {
      title: 'First TypeScript React App',
    }
  }
}

// app.ts
import koaViews from 'koa-views'

// 添加模版所在的目录
// 以及使用的渲染引擎、文件后缀
app.use(koaViews(path.join(__dirname, '../views'), {
  options: {
    ext: 'ejs',
  },
  extension: 'ejs',
}))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;如果是多个页面，那就创建多个用来&lt;code&gt;Render&lt;/code&gt;的&lt;code&gt;ts&lt;/code&gt;文件就好了&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;深坑注意&quot;&gt;深坑，注意&lt;/h4&gt;
&lt;p&gt;目前的&lt;code&gt;routing-controller&lt;/code&gt;对于&lt;code&gt;Koa&lt;/code&gt;的支持还不是很好，（原作者对&lt;code&gt;Koa&lt;/code&gt;并不是很了解，导致&lt;code&gt;Render&lt;/code&gt;对应的接口被请求一次以后，后续所有的其他的接口都会直接返回该模版文件，原因是在负责模版渲染的&lt;code&gt;URL&lt;/code&gt;触发时，本应返回数据，但是目前的处理却是添加了一个中间件到&lt;code&gt;Koa&lt;/code&gt;中，所以任何请求都会将该模版文件作为数据来返回）所以&lt;code&gt;@Render&lt;/code&gt;并不能适用于&lt;code&gt;Koa&lt;/code&gt;驱动。&lt;br/&gt;不过我已经提交了&lt;a href=&quot;https://github.com/typestack/routing-controllers/pull/434&quot;&gt;PR&lt;/a&gt;了，跑通了测试用例，坐等被合并代码，但是这是一个临时的修改方案，涉及到这个库针对外部中间件注册的顺序问题，所以对于&lt;code&gt;app.ts&lt;/code&gt;还要有额外的修改才能够实现。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// app.ts 的修改
import 'reflect-metadata'
import Koa from 'koa'
import koaViews from 'koa-views'
import { useKoaServer } from 'routing-controllers'
import { distPath } from './config'

// 手动创建koa实例，然后添加`render`的中间件，确保`ctx.render`方法会在请求的头部就被添加进去
const koa = new Koa()

koa.use(koaViews(path.join(__dirname, '../views'), {
  options: {
    ext: 'ejs',
  },
  extension: 'ejs',
}))

// 使用`useKoaServer`而不是`createKoaServer`
const app = useKoaServer(koa, {
  controllers: [`${__dirname}/controllers/**/*{.js,.ts}`],
})

// 后续的逻辑就都一样了
export default app&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，这个是新版发出以后的逻辑了，基于现有的结构也可以绕过去，但是就不能使用&lt;code&gt;@Render&lt;/code&gt;装饰器了，抛开&lt;code&gt;koa-views&lt;/code&gt;直接使用内部的&lt;a href=&quot;https://github.com/tj/consolidate.js&quot;&gt;consolidate&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// controller/index.ts
// 这个修改不需要改动`app.ts`，可以直接使用`createKoaServer`
import {
  Get,
  Controller,
} from 'routing-controllers'
import cons from 'consolidate'
import path from 'path'

@Controller()
export default class {
  @Get('/')
  async router() {
    // 直接在接口返回时获取模版渲染后的数据
    return cons.ejs(path.resolve(__dirname, '../../views/index.ejs'), {
      title: 'Example For TypeScript React App',
    })
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;目前的示例代码采用的上边的方案&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;至此，一个完整的TS前后端项目架构就已经搭建完成了（剩下的任务就是往骨架里边填代码了）。&lt;br/&gt;我已经更新了之前的&lt;a href=&quot;https://github.com/Jiasm/typescript-example&quot;&gt;typescript-exmaple&lt;/a&gt; 在里边添加了本次重构所使用的一些前端&lt;code&gt;TS&lt;/code&gt;+&lt;code&gt;React&lt;/code&gt;的示例，还包括针对&lt;code&gt;@Render&lt;/code&gt;的一些兼容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TypeScript&lt;/code&gt;是一个很棒的想法，解决了N多&lt;code&gt;javaScript&lt;/code&gt;种令人诟病的问题。&lt;br/&gt;使用静态语言来进行开发不仅能够提高开发的效率，同时还能降低错误出现的几率。&lt;br/&gt;结合着强大的&lt;code&gt;vs code&lt;/code&gt;，Enjoy it.&lt;/p&gt;
&lt;p&gt;如果在使用&lt;code&gt;TS&lt;/code&gt;的过程中有什么问题、或者有什么更好的想法，欢迎来沟通讨论。&lt;/p&gt;
</description>
<pubDate>Mon, 27 Aug 2018 07:01:00 +0000</pubDate>
<dc:creator>贾顺名</dc:creator>
<og:description>前段时间有写过一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiasm/p/9542253.html</dc:identifier>
</item>
<item>
<title>web框架开发-Ajax - 游小刀</title>
<link>http://www.cnblogs.com/yxiaodao/p/9542218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yxiaodao/p/9542218.html</guid>
<description>&lt;p&gt;&lt;strong&gt;向服务器发送请求的4种方式&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;pre&gt;
1、浏览器地址栏，默认get请求&lt;br/&gt;2、form表单：&lt;br/&gt;get请求&lt;br/&gt;post请求&lt;br/&gt;3、a标签，默认get请求
&lt;/pre&gt;
&lt;pre&gt;
4、Ajax&lt;br/&gt;特点：&lt;br/&gt;1 异步请求&lt;br/&gt;2 局部刷新&lt;br/&gt;方式：
&lt;/pre&gt;
&lt;pre&gt;
        get&lt;br/&gt;post
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;AJAX&lt;/strong&gt;（Asynchronous Javascript And XML）翻译成中文就是“异步Javascript和XML”。即使用Javascript语言与服务器进行异步交互，传输的数据为XML（当然，传输的数据不只是XML,现在更多使用json数据）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同步交互：客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求；&lt;/li&gt;
&lt;li&gt;异步交互：客户端发出一个请求后，无需等待服务器响应结束，就可以发出第二个请求。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;AJAX除了&lt;strong&gt;&lt;span&gt;异步&lt;/span&gt;&lt;/strong&gt;的特点外，还有一个就是：浏览器页面&lt;strong&gt;&lt;span&gt;局部刷新&lt;/span&gt;&lt;/strong&gt;；（这一特点给用户的感受是在不知不觉中完成请求和响应过程）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;555&quot; height=&quot;414&quot; alt=&quot;&quot; src=&quot;https://images2018.cnblogs.com/blog/877318/201805/877318-20180522104832588-1949287384.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;AJAX使用Javascript技术向服务器发送异步请求&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;AJAX无须刷新整个页面，局部刷新&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Ajax基本语法和参数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&amp;lt;button &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;send_Ajax&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;send_Ajax&amp;lt;/button&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;

       $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.send_Ajax&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(function(){

           $.ajax({
               url:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/handle_Ajax/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  //&lt;span&gt;&lt;strong&gt;请求URL，注意写法，写在两个反斜杠之间，如果不写，就是默认当前的IP地址和端口，和action一样&lt;/strong&gt;
               type:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,            //&lt;span&gt;&lt;strong&gt;请求方式&lt;/strong&gt;
               data:{username:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,password:123},  //&lt;strong&gt;请求数据&lt;/strong&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;               contentType：  //格式
               success:function(data){           &lt;/span&gt;//&lt;span&gt;&lt;strong&gt;回调函数，data接受服务器返回的数据，和上面是两回事&lt;/strong&gt;
                   console.log(data)
               },                                  
         　　　　　　
               error: function (jqXHR, textStatus, err) {
                        console.log(arguments);
                    },

               complete: function (jqXHR, textStatus) {
                        console.log(textStatus);
                },

               statusCode: {
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;403&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: function (jqXHR, textStatus, err) {
                          console.log(arguments);
                     },

                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;400&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: function (jqXHR, textStatus, err) {
                        console.log(arguments);
                    }
                }

           })

       })

&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;
&lt;h2&gt;一个不带数据的Ajax请求流程图&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145657838-908226012.png&quot;&gt;&lt;img width=&quot;888&quot; height=&quot;355&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145658661-810747191.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：ajax的事件不能使用submit按钮&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;带数据Ajax请求&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;效果图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145659139-146988711.png&quot;&gt;&lt;img width=&quot;572&quot; height=&quot;143&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145659578-1837390107.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;html模板文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h3&amp;gt;这是一个Ajax测试&amp;lt;/h3&amp;gt;
&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;+&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;=&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;button &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;计算&amp;lt;/button&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.btn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(function(){
        $.ajax({
            url:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/ajax_text/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  
            type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            data:{
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:$(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#n1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val(),
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:$(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#n2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).val()
            },
            success:function (data) {
                $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#n3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).val(data)
            }
        })



    })
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;视图函数文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render,HttpResponse


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create your views here.&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index(request):

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;index.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; ajax_text(request):
    n1&lt;/span&gt;=int(request.POST.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    n2&lt;/span&gt;=int(request.POST.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    ret&lt;/span&gt;=n1+&lt;span&gt;n2
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 需要注释掉setting里面中间件的东西，虽然不明白，但是以后会讲&lt;/span&gt;&lt;/strong&gt;
    &lt;span&gt;return&lt;/span&gt; HttpResponse(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;运行前，&lt;span&gt;&lt;span&gt;需要注释掉setting里面中间件的东西，虽然不明白，但是以后会讲&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145700195-1633044368.png&quot;&gt;&lt;img width=&quot;644&quot; height=&quot;367&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145701146-1677957018.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果请求方法换成使用get方法 ，第一次失败了，why？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因是，忘记在视图函数中，更改POST为GET,必须要视图函数中的方法也改为GET，对应上，才能接收到&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;基于Ajax的登录验证&lt;/h2&gt;
&lt;p&gt;实现用户输入用户名和密码之后，通过Ajax提交给服务端，服务端处理后返回响应信息，如果正确，跳转到其他页面，如果不正确，在输入框后显示“用户名或者密码错误”。&lt;/p&gt;
&lt;p&gt;需要用到 &lt;strong&gt;&lt;span&gt;json&lt;/span&gt;&lt;/strong&gt; 来传递字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145701578-1535546918.png&quot;&gt;&lt;img width=&quot;666&quot; height=&quot;308&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145702023-866602445.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;view视图代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render, HttpResponse
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; app01.models &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 登陆首页&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; login(request):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;login.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 登录验证&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; verify(request):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取浏览器输入的账号和密码&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(1&lt;span&gt;)
    user &lt;/span&gt;= request.GET.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    pwd &lt;/span&gt;= request.GET.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询数据库是不是存在该账号和对应的密码&lt;/span&gt;
    user_ret = User.objects.filter(user=user, pwd=&lt;span&gt;pwd)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义响应信息&lt;/span&gt;
    ret = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,msg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: None}
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; user_ret:
        ret[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; user
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        ret[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户名或者密码错误！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ret &lt;/span&gt;=&lt;span&gt; json.dumps(ret)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(ret)  # &lt;strong&gt;因为HttpResponse 必须用字符串，所以要用JSON&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;login.html模板文件代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;style&amp;gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h3&amp;gt;欢迎来到登录页面&amp;lt;/h3&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;form action=&lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登陆&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;/form&amp;gt;
    &amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color: red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.btn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(function(){
        $.ajax({
            url:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/verify/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            data:{
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:$(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val(),
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:$(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#pwd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).val()
            },
            success:function (data) {
                {&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;前端反序列化#}&lt;/span&gt;
                var ret=&lt;span&gt;JSON.parse(data);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(ret.user){
                    {&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果成功跳转到页面#}&lt;/span&gt;
                    location.href=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/yxiaodao/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                }
                {&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果不正确，提示信息#}&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).text(ret.msg)
                }

            }
        })
    })
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;文件上传的两种方式&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;基于form表单的文件上传&lt;/p&gt;
&lt;p&gt;基于Ajax的文件上传&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;请求头ContentType&lt;/h2&gt;
&lt;p&gt;ContentType指的是请求体的编码类型，常见的类型共有3种：&lt;/p&gt;
&lt;h3&gt;1、application/x-www-form-urlencoded&lt;/h3&gt;
&lt;p&gt;这应该是最常见的 POST 提交数据的方式了。浏览器的原生 &amp;lt;form&amp;gt; 表单，如果不设置 &lt;code&gt;enctype&lt;/code&gt; 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
POST http://www.example.com HTTP/1.1&lt;span&gt;
Content&lt;/span&gt;-Type: application/x-www-form-urlencoded;charset=utf-8&lt;span&gt;

user&lt;/span&gt;=yuan&amp;amp;age=22
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2、multipart/form-data&lt;/h3&gt;
&lt;p&gt;这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 &amp;lt;form&amp;gt; 表单的 &lt;code&gt;enctype&lt;/code&gt; 等于 multipart/form-data。直接来看一个请求示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
POST http://www.example.com HTTP/1.1&lt;span&gt;
Content&lt;/span&gt;-Type:multipart/form-data; boundary=----&lt;span&gt;WebKitFormBoundaryrGKCBY7qhFd3TrwA

&lt;/span&gt;------&lt;span&gt;WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content&lt;/span&gt;-Disposition: form-data; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

yuan
&lt;/span&gt;------&lt;span&gt;WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content&lt;/span&gt;-Disposition: form-data; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; filename=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chrome.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
Content&lt;/span&gt;-Type: image/&lt;span&gt;png

PNG ... content of chrome.png ...
&lt;/span&gt;------WebKitFormBoundaryrGKCBY7qhFd3TrwA--
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 &lt;code&gt;--boundary&lt;/code&gt; 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 &lt;code&gt;--boundary--&lt;/code&gt; 标示结束。关于 multipart/form-data 的详细定义，请前往 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1867.txt&quot;&gt;rfc1867&lt;/a&gt; 查看。&lt;/p&gt;
&lt;p&gt;这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。&lt;/p&gt;
&lt;p&gt;上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 &amp;lt;form&amp;gt; 表单也&lt;a href=&quot;http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4&quot;&gt;只支持这两种方式&lt;/a&gt;（通过 &amp;lt;form&amp;gt; 元素的 &lt;code&gt;enctype&lt;/code&gt; 属性指定，默认为 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;。其实 &lt;code&gt;enctype&lt;/code&gt; 还支持 &lt;code&gt;text/plain&lt;/code&gt;，不过用得非常少）。&lt;/p&gt;
&lt;p&gt;随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。&lt;/p&gt;

&lt;h3&gt;3、application/json&lt;/h3&gt;
&lt;p&gt;application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。&lt;/p&gt;
&lt;p&gt;JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。&lt;/p&gt;
&lt;h2&gt;基于form表单的文件上传&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;视图函数文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; file_put(request):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 点击之后form表单是post请求，加一个判断&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; request.method==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request.POST)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request.FILES)
        user&lt;/span&gt;=request.POST.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; # 文件对象的接受方式,没有放在post中，而是放在了FILES中&lt;/span&gt;
        pic=request.FILES.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(pic))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; # 接收文件保存在本地，name是文件的一个属性，可以直接使用&lt;/span&gt;
        with open(pic.name,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pic:
                f.write(line)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file_put.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;模板文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h3&amp;gt;基于form表单的文件上传&amp;lt;/h3&amp;gt;&lt;span&gt;
{&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;    上传文件一定要用multipart/form-data#}&lt;/span&gt;
    &amp;lt;form action=&lt;span&gt;&quot;&quot;&lt;/span&gt; method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; enctype=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multipart/form-data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        用户名 &lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        头像 &lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
{&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;        &amp;lt;input type=&quot;submit&quot;&amp;gt;#}&lt;/span&gt;
        &amp;lt;button type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;提交&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Ajax发送json数据&lt;/h2&gt;
&lt;p&gt;上面的例子演示过服务端发送json数据到浏览器端&lt;/p&gt;
&lt;p&gt;下面是浏览器端发送json到服务端&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145702543-485771178.png&quot;&gt;&lt;img width=&quot;666&quot; height=&quot;627&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145703122-1327625338.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送的json数据需要在request.body中提取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;POST只能接受urlencodeed的数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并且，无论发的是什么格式，我们都可以在body中提取到&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145703653-1471537186.png&quot;&gt;&lt;img width=&quot;666&quot; height=&quot;278&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145704156-328377192.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;基于Ajax的文件上传&lt;/h2&gt;
&lt;p&gt;视图文件代码和上面用form表单一样&lt;/p&gt;
&lt;p&gt;网页效果图片&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145704574-1996765794.png&quot;&gt;&lt;img width=&quot;666&quot; height=&quot;294&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145705037-319134899.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;服务端接收到文件&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145705650-613677691.png&quot;&gt;&lt;img width=&quot;567&quot; height=&quot;471&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1355675/201808/1355675-20180827145706407-1913083297.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模板文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h3&amp;gt;基于form表单的文件上传&amp;lt;/h3&amp;gt;&lt;span&gt;
    上传文件一定要用multipart&lt;/span&gt;/form-&lt;span&gt;data
    &lt;/span&gt;&amp;lt;form action=&lt;span&gt;&quot;&quot;&lt;/span&gt; method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; enctype=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multipart/form-data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        用户名 &lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        头像 &lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
{&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;        &amp;lt;button type=&quot;submit&quot;&amp;gt;提交&amp;lt;/button&amp;gt;#}&lt;/span&gt;
    &amp;lt;/form&amp;gt;

    &amp;lt;hr&amp;gt;

    &amp;lt;h3&amp;gt;基于AJAX文件上传&amp;lt;/h3&amp;gt;
    &amp;lt;form action=&lt;span&gt;&quot;&quot;&lt;/span&gt; method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        用户名 &lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        头像 &lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CLASS=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ajbtn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AJAX提交&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;/form&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
    $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.ajbtn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click(function () {
        {&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建FormData对象#}&lt;/span&gt;
        console.log(123&lt;span&gt;);
        var formdata&lt;/span&gt;=&lt;span&gt;new FormData();
        formdata.append(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,$(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).val());
        {&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;取文件格式的固定方法#}&lt;/span&gt;
        formdata.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,$(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#pic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0].files[0]);

        $.ajax({
            url:&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
            type:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            contentType:false,  &lt;strong&gt;//数据不做编码&lt;/strong&gt;
            processData:false, &lt;strong&gt;//数据不做预处理&lt;/strong&gt;
            data:formdata,
            success:function (data) {
                console.log(data)
            }
        })
    })
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;咬注意的重点就是，需要定义一个新的FormData对象，然后发送FormData 需要，定义数据不做预处理和编码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Aug 2018 06:57:00 +0000</pubDate>
<dc:creator>游小刀</dc:creator>
<og:description>Ajax简介向服务器发送请求的4种方式1、浏览器地址栏，默认get请求2、form表单： get请求 post请求3、a标签，默认get请求4、Ajax 特点： 1 异步请求 2 局部刷新 方式： g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yxiaodao/p/9542218.html</dc:identifier>
</item>
<item>
<title>MySQL优化(三)：优化数据库对象 - 杜先生的博客</title>
<link>http://www.cnblogs.com/dukuan/p/9517365.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dukuan/p/9517365.html</guid>
<description>&lt;p&gt;二、优化数据库对象&lt;/p&gt;
&lt;p&gt;1、优化表的数据类型&lt;/p&gt;
&lt;p&gt;      应用设计的时候需要考虑字段的长度留有一定的冗余，但不推荐很多字段都留有大量的冗余，这样既浪费磁盘空间，也在应用操作时浪费物理内存。&lt;/p&gt;
&lt;p&gt;      在MySQL中，可以使用函数PROCEDURE ANALYSE()对表进行分析，给出优化建议。(16,  256)是指不为包含的值多于16或者256字节的ENUM类型提出建议。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1095387/201808/1095387-20180822165145923-1289702720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      Optimal_fieldtype为优化建议，可以通过alter修改字段类型：ALTER TABLE TAB_NAME MODIFY COLUMN Optimal_fieldtype_VALUE;&lt;/p&gt;
&lt;p&gt;2、逆规范化&lt;/p&gt;
&lt;p&gt;      反规划的好处是降低连接操作的需求、降低外码和索引的数目、减少表的数目，带来的问题可能会出现数据的完整性问题，虽然查询加快，但是会降低修改速度。在进行反规范操作之前，要充分考虑数据的存取需求、常用表的大小、一些特殊的计算、数据的物理存储位置。常用的反规范技术如下：&lt;/p&gt;
&lt;p&gt;      - 增加冗余列：指在多个表中具有相同的列，它常用来查询时避免连接操作。&lt;/p&gt;
&lt;p&gt;      - 增加派生列：指增加的列来自其他表中的数据，由其他表中的数据经过计算生成，作用是减少连接操作，避免使用集函数。&lt;/p&gt;
&lt;p&gt;      - 重新组表：指如果许多用户需要查看两个表连接出来的结果数据，则把这两个表重新组成一个表来减少连接而提高性能。&lt;/p&gt;
&lt;p&gt;      - 分库分表：https://www.cnblogs.com/dukuan/p/9480610.html&lt;/p&gt;
&lt;p&gt;3、使用中间表提高统计查询速度&lt;/p&gt;
&lt;p&gt;      对于数据量较大的表，在其上进行统计查询通常会效率很低，并且还会对线上应用产生负面影响。此种情况下可以使用中间表提高统计查询的效率。&lt;/p&gt;
&lt;p&gt;      一般步骤：创建表结构和原表结构相同的表，迁移数据需要统计的数据，进行统计。&lt;/p&gt;
&lt;p&gt;      中间表在统计查询中的优点：&lt;/p&gt;
&lt;p&gt;          - 中间表复制源表数据，并且与源表相“隔离”，在中间表上做统计查询不会对线上应用产生负面影响。&lt;/p&gt;
&lt;p&gt;          - 中间表上可以灵活的添加索引或增加临时用的新字段，从而达到提高统计查询效率和辅助统计查询作用。 &lt;/p&gt;
&lt;p&gt;三、锁问题&lt;/p&gt;
&lt;p&gt;1、锁概述&lt;/p&gt;
&lt;p&gt;      MyISAM和MEMORY存储引擎采用表级锁，BDB存储引擎(MySQL5.1后不直接支持此存储引擎)采用的页面锁，也支持表级锁，InnoDB支持行级锁和表级锁，默认是行级。&lt;/p&gt;
&lt;p&gt;      - 表级锁：开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。&lt;/p&gt;
&lt;p&gt;      - 行级锁：开销大，加锁慢，会出现死锁，锁定粒度小，发生冲突的概率最低，并发度也最高。&lt;/p&gt;
&lt;p&gt;      - 页面锁：开销和加锁时间界于表锁和行锁之间，会出现死锁，锁定粒度界于表锁和行锁之间，并发度一般。&lt;/p&gt;
&lt;p&gt;      表级锁更适合以查询为主，只有少量按索引条件更新数据的应用，如Web应用。而行级锁更适合有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如在线事物处理系统。&lt;/p&gt;
&lt;p&gt;2、MyISAM表锁&lt;/p&gt;
&lt;p&gt;      MyISAM只支持表锁。&lt;/p&gt;
&lt;p&gt;2.1 查询表级锁争用情况&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1095387/201808/1095387-20180823144955682-1542785816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      Table_locks_immediate：产生表级锁定的次数。&lt;/p&gt;
&lt;p&gt;      如果Table_locks_waited比较高，说明存在着严重的表级锁争用情况。&lt;/p&gt;
&lt;p&gt;2.2 MySQL表级锁的锁模式&lt;/p&gt;
&lt;p&gt;      表级锁分为表共享读锁和表独占写锁。兼容性如下：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1095387/201808/1095387-20180823145803007-1453206234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      对于MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一个表的写请求。对表的写操作，会阻塞同一表的读和写。MyISAM读操作和写操作以及写操作之间是串行的。&lt;/p&gt;
&lt;p&gt;2.3 如何加锁表&lt;/p&gt;
&lt;p&gt;      MyISAM在执行SELECT、UPDATE、DELETE、INSERT前，会自动给涉及的表加锁，无需用户干预。&lt;/p&gt;
&lt;p&gt;      显式加锁情况：比如同时要查询或者比对两个表中的内容，为防止在查其中一个时另一个有更新或者新数据，此时需要显式的为两个表加锁。&lt;/p&gt;
&lt;p&gt;      加锁命令：LOCK TABLES tab_name READ LOCAL, tab_name2 READ LOCAL;  -- LOCAL表示允许其他用户在MyISAM表尾并发插入记录。使用显式加锁时，必须同时取得所有涉及表的锁，而且加锁后只能访问加锁的这些表，不能访问其他表。并且如果加的是读锁，那么只能执行查询操作。并且加锁时需要对别名也要加锁。&lt;/p&gt;
&lt;p&gt;2.4 MyISAM并发插入&lt;/p&gt;
&lt;p&gt;      MyISAM通过concurrent_insert参数决定是否允许并发插入&lt;/p&gt;
&lt;p&gt;      - 0：不允许并发插入&lt;/p&gt;
&lt;p&gt;      - 1：MyISAM表中无空洞，允许读的同时在表末尾插入记录。默认设置&lt;/p&gt;
&lt;p&gt;      - 2：无论是否有无空洞，都能插入。&lt;/p&gt;
&lt;p&gt;      可以利用并发插入特性来解决应用中对同一表查询和插入的锁争用。同时定期在系统空闲时整理空间碎片，收回因删除记录而产生的中间空洞。&lt;/p&gt;
&lt;p&gt;      注意：只能insert不能update和delete。且锁表的session不能获取到新插入到的数据。&lt;/p&gt;
&lt;p&gt;2.5 MyISAM的锁调度&lt;/p&gt;
&lt;p&gt;      同一时刻请求的写锁和读锁，MySQL会优先处理写进程。即使是读请求先到等待队列，写锁也会插入到读锁请求之前，这也是MyISAM表不太适合于有大量更新操作和查询操作应用的原因。&lt;/p&gt;
&lt;p&gt;      调节MyISAM的调度行为：&lt;/p&gt;
&lt;p&gt;      - 通过制定启动参数low-priority-updates， 使MyISAM引擎默认给予读请求以优先的权利。&lt;/p&gt;
&lt;p&gt;      - 通过执行命令 SET LOW_PRIORITY_UPDATES = 1，来降低更新请求的优先级。&lt;/p&gt;
&lt;p&gt;      - 通过制定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。&lt;/p&gt;
&lt;p&gt;      MySQL也提供了一种折中的办法，即给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低。&lt;/p&gt;
&lt;p&gt;3、InnoDB锁问题&lt;/p&gt;
&lt;p&gt;3.1 背景知识&lt;/p&gt;
&lt;p&gt;3.1.1 事务及其ACID属性&lt;/p&gt;
&lt;p&gt;      事务是由一组SQL语句组成的逻辑处理单元，具有以下4个属性，通常简称为事务的ACID属性。&lt;/p&gt;
&lt;p&gt;      - 原子性：事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全都不执行。&lt;/p&gt;
&lt;p&gt;      - 一致性：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构也都必须是正确的。&lt;/p&gt;
&lt;p&gt;      - 隔离性：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的独立环境执行。&lt;/p&gt;
&lt;p&gt;      - 持久性：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。&lt;/p&gt;
&lt;p&gt;3.1.2 并发事务处理的问题&lt;/p&gt;
&lt;p&gt;      相对于串行处理来说，并发事务处理能大大增加数据库资源利用率，提供吞吐量，但会引起下列问题：&lt;/p&gt;
&lt;p&gt;      - 更新丢失：两个或多个事务同时操作同一行，会覆盖其他事务的更新。&lt;/p&gt;
&lt;p&gt;      - 脏读：当一个事务在对一条记录做修改未完成并提交前，另一个事务来读取同一条记录，这时读取到的数据叫脏读。&lt;/p&gt;
&lt;p&gt;      - 不可重复读：一个事务在读取某些数据后的某个时间，再次读取，发现读出的数据已经发生了改变或某些记录已经被删除了。&lt;/p&gt;
&lt;p&gt;      - 幻读：一个事务按相同的查询条件重新读取以前检索过的数据，其他事务插入了满足其条件的新数据。&lt;/p&gt;
&lt;p&gt;3.1.3 事务隔离级别&lt;/p&gt;
&lt;p&gt;      线上业务应完全避免更新丢失，但是避免此情况需要应用程序对要更新的数据加必要的锁来解决。但是关于读一致性，必须由数据库提供一定的事务隔离机制来解决。数据库事务隔离的方式，基本上可分为以下两种：&lt;/p&gt;
&lt;p&gt;      - 在读取数据之前，对其加锁。 &lt;/p&gt;
&lt;p&gt;      - 使用数据多版本并发控制(MVCC/MCC)，按照请求时间点创建快照。&lt;/p&gt;
&lt;p&gt;      数据库的事务隔离越严格，并发副作用越小，相应的代价也就越大，因为事务隔离实质是进行&quot;串行化&quot;。&lt;/p&gt;
&lt;p&gt;      为了解决隔离和并发的矛盾，ISO/ANSI SQL92定义了4个事务隔离级别。应用可以根据自己的业务逻辑要求，选择不同的隔离级别来平衡隔离和并发的矛盾。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1095387/201808/1095387-20180823171830897-918308183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.2 获取InnoDB行锁争用情况&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1095387/201808/1095387-20180823172052667-1083948527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      如果Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高，则争用比较严重。&lt;/p&gt;
&lt;p&gt;      此时可以通过查询information_schema数据库中的表来查看锁情况，或者通过设置InnoDB Monitors来观察发生锁冲突的表、数据行等。&lt;/p&gt;
&lt;p&gt;      - 通过information_schema&lt;/p&gt;
&lt;p&gt;        SELECT * FROM innodb_locks;&lt;/p&gt;
&lt;p&gt;        SELECT * FROM innodb_lock_waits;&lt;/p&gt;
&lt;p&gt;      - 通过InnoDB Monitors&lt;/p&gt;
&lt;p&gt;        CREATE TABLE innodb_monitor(a INT) ENGINE = INNODB;&lt;/p&gt;
&lt;p&gt;        然后通过：SHOW ENGINE INNODB STATUS查看&lt;/p&gt;
&lt;p&gt;        关闭监视器：DROP TABLE innodb_monitor;&lt;/p&gt;
&lt;p&gt;3.3 InnoDB行锁模式及加锁方法&lt;/p&gt;
&lt;p&gt;      InnoDB实现了两种类型的行锁：&lt;/p&gt;
&lt;p&gt;      - 共享锁：允许另一个事务也获得共享锁，但是阻止其他事务获得相同数据集的排他锁。&lt;/p&gt;
&lt;p&gt;      - 排他锁：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。&lt;/p&gt;
&lt;p&gt;      事务获取锁的方式：&lt;/p&gt;
&lt;p&gt;      - 共享锁：SELECT ... WHERE ... LOCK IN SHARE MODE;&lt;/p&gt;
&lt;p&gt;      - 排他锁：SELECT ... WHERE ... FOR UPDATE;&lt;/p&gt;
&lt;p&gt;      对于锁定行后需要进行更新操作的应用，用过使用排他锁。&lt;/p&gt;
&lt;p&gt;3.4 InnoDB行锁实现方式&lt;/p&gt;
&lt;p&gt;      InnoDB行锁是通过索引上的索引项加锁来实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来记录加锁。分为3种情形：&lt;/p&gt;
&lt;p&gt;      - Record lock：对索引项加锁。&lt;/p&gt;
&lt;p&gt;      - Gap lock：对索引项之间的“间隙”、第一条记录前的“间隙”或最后一条记录后的“间隙”加锁。&lt;/p&gt;
&lt;p&gt;      - Next-key lock：前两种的组合，对记录及其前面的间隙加锁。&lt;/p&gt;
&lt;p&gt;      注意：如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，等同于表锁，生产环境中需要注意这一特性防止导致大量的锁冲突，从而影响并发性能。&lt;/p&gt;
&lt;p&gt;      由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果使用相同的索引建，会出现锁冲突。&lt;/p&gt;
&lt;p&gt;      当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，但是当不同的session查询相同的数据时，同样会阻塞。&lt;/p&gt;
&lt;p&gt;      当表的数据较少，此时MySQL可能会全盘扫描，此时会导致不使用索引查询，进而导致全表加锁。&lt;/p&gt;
&lt;p&gt;      MySQL检索的数据类型与索引字段不同，会进行数据转换，但却不会使用索引，所以会导致InnoDB对所有的记录加锁。&lt;/p&gt;
&lt;p&gt;3.5 Next-Key锁&lt;/p&gt;
&lt;p&gt;      当我们使用范围查询，并请求共享或排他锁时，InnoDB会给符合条件的所有索引项加锁，对于在范围内但是不存在的记录，叫做间隙GAP，同时也会被加锁，这个锁叫做Next-Key锁。Next-Key锁时为了防止幻读。&lt;/p&gt;
&lt;p&gt;      当使用范围检索并锁定记录时，InnoDB会阻塞条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，尽量使用相等条件来访问更新数据，避免使用范围条件。&lt;/p&gt;
&lt;p&gt; 3.6 什么时候使用行级锁&lt;/p&gt;
&lt;p&gt;      对于InnoDB，绝大部分情况下都应该使用行级锁，个别特殊事务中，可以考虑使用表级锁。&lt;/p&gt;
&lt;p&gt;      - 事务需要更新大部分或全部数据，表比较大，如果使用默认的行锁，会造成事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突。这种情况考虑使用表锁来提高事务的执行速度。&lt;/p&gt;
&lt;p&gt;      - 事务设计多个表，比较复杂，很可能引起死锁，造成大量事务回滚，此时可考虑使用表锁避免死锁，减少数据库因事务回滚带来的开销。&lt;/p&gt;
&lt;p&gt;      当然，生产环境中最好不要出现这两种事务，否则就应该考虑MyISAM了。&lt;/p&gt;
&lt;p&gt;      表锁注意事项：&lt;/p&gt;
&lt;p&gt;      - 表锁不是由InnoDB存储引擎管理的，而是由MySQL Server负责的，仅当autocommit=0，innodb_table_locas=1(缺省值)时，InnoDB才能知道MySQL加的表锁，也才能感知InnoDB加的行锁， 这种情况下，InnoDB才能自动识别涉及表级锁的死锁，否则InnoDB将无法自动检测并处理这种死锁。&lt;/p&gt;
&lt;p&gt;      - 在用LOCK TABLES对InnoDB加锁时，需要将AUTOCOMMIT设为0，否则不会给表加锁；事务结束前，不要用UNLOCKS TABLES释放表锁，因为UNLOCK TABLES会隐含提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁。&lt;/p&gt;
&lt;p&gt;        方式如下：写表t1并从表t2读&lt;/p&gt;
&lt;p&gt;        SET AUTOCOMMIT = 0;&lt;/p&gt;
&lt;p&gt;        LOCK TABLES t1 WRITE, t2 READ;&lt;/p&gt;
&lt;p&gt;        [do something..] &lt;/p&gt;
&lt;p&gt;        COMMIT;&lt;/p&gt;
&lt;p&gt;        UNLOCK TABLES;&lt;/p&gt;
&lt;p&gt;3.7 关于死锁&lt;/p&gt;
&lt;p&gt;      MyISAM表锁是一次获得所需全部锁，要么全部满足，要么等待，因为不会出现死锁。但InnoDB锁是逐步获得的，所以InnoDB会发生死锁的可能。&lt;/p&gt;
&lt;p&gt;      比如：session1正在对table_1进行 select for update(获得tb1排他锁) ，此时session2对table_2进行select for update(获得tb2排他锁)，如果此时session1对tb2进行select for update，会出现等待，直到session2释放，但是如果session2没有释放并且又请求tb1进行select for update，那么此时会出现死锁。&lt;/p&gt;
&lt;p&gt;      发生死锁后，InnoDB一般都能自动检测到，然后释放一个事务锁并回退，另一个事务获得锁继续完成事务。但在涉及外部锁或涉及锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁超时参数innodb_lock_wait_timeout来解决，但这个参数并不是用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会拖垮数据库，设置合适的值可以避免或者减少此种情况的发生。&lt;/p&gt;
&lt;p&gt;      通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小，以及访问数据库的SQL语句，绝大部分死锁都可以避免。&lt;/p&gt;
&lt;p&gt;      避免死锁的常用方法：&lt;/p&gt;
&lt;p&gt;      - 程序并发存取多个表，尽量约定相同的顺序来访问量。        &lt;/p&gt;
&lt;p&gt;      - 程序批量处理数据的时候，事先对数据排序，保证每个线程按固定的顺序来处理记录。&lt;/p&gt;
&lt;p&gt;      - 在事务中，如果要更新记录，应该直接申请足够级别的排他锁，而不是先申请共享锁，后申请排他锁。要不然其他事务可能已经获得了相同的共享锁，从而造成锁冲突。&lt;/p&gt;
&lt;p&gt;      - 在REPEATABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT FOR UPDATE加排他锁，在没有符合条件的记录的情况下，两个线程都会加锁成功。因为两个线程查询均无此记录，便会尝试插入一条新纪录，如果两个线程都这么做，就会出现死锁。这种情况将隔离级别改成READ COMMITTED就可避免。&lt;/p&gt;

</description>
<pubDate>Mon, 27 Aug 2018 06:55:00 +0000</pubDate>
<dc:creator>杜先生的博客</dc:creator>
<og:description>二、优化数据库对象 1、优化表的数据类型 应用设计的时候需要考虑字段的长度留有一定的冗余，但不推荐很多字段都留有大量的冗余，这样既浪费磁盘空间，也在应用操作时浪费物理内存。 在MySQL中，可以使用函</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dukuan/p/9517365.html</dc:identifier>
</item>
<item>
<title>Eslint相关知识和配置大全 - 冒雨ing</title>
<link>http://www.cnblogs.com/saysmy/p/9513374.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/saysmy/p/9513374.html</guid>
<description>&lt;blockquote readability=&quot;13.494692144374&quot;&gt;
&lt;p&gt;ESLint最初是由&lt;a href=&quot;http://nczonline.net/&quot;&gt;Nicholas C. Zakas&lt;/a&gt; 于2013年6月创建的开源项目。它的目标是提供一个插件化的javascript代码检测工具。&lt;/p&gt;
&lt;p&gt;代码检查是一种静态的分析，常用于寻找有问题的模式或者代码，并且不依赖于具体的编码风格。&lt;/p&gt;
&lt;p&gt;ESLint 可以让程序员在编码的过程中发现问题而不是在执行的过程中。&lt;/p&gt;
&lt;p&gt;ESLint 使用 Node.js 编写，这样既可以有一个快速的运行环境的同时也便于安装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;一. 环境配置&lt;/h2&gt;
&lt;p&gt;在npmjs.com内查询 eslint 可以发现&lt;/p&gt;
&lt;p&gt;目前最新版Eslint@5.4.0，安装条件&lt;/p&gt;
&lt;blockquote readability=&quot;5.16&quot;&gt;
&lt;p&gt;Prerequisites: &lt;a href=&quot;https://nodejs.org/en/&quot; rel=&quot;nofollow&quot;&gt;Node.js&lt;/a&gt; (&amp;gt;=6.14), npm version 3+.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 如果想检测vue组件的语法，需要  &lt;span class=&quot;cnblogs_code&quot;&gt;eslint-plugin-vue&lt;/span&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://eslint.org/&quot; rel=&quot;nofollow&quot;&gt;ESLint&lt;/a&gt; &lt;code&gt;&amp;gt;=3.18.0&lt;/code&gt;.
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;gt;=4.7.0&lt;/code&gt; to use &lt;code&gt;eslint --fix&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;=4.14.0&lt;/code&gt; to use with &lt;code&gt;babel-eslint&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Node.js &lt;code&gt;&amp;gt;=4.0.0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;首先安装符合要求的node和npm版本，安装yarn（建议通过msi文件&lt;a href=&quot;https://www.cnblogs.com/saysmy/p/9485648.html&quot; target=&quot;_blank&quot;&gt;全局安装&lt;/a&gt;）&lt;/p&gt;

&lt;h2&gt;二. 配置校验规则&lt;/h2&gt;
&lt;p&gt;在根目录下新建 .eslintrc.js 文件, 亦可以 &lt;span class=&quot;cnblogs_code&quot;&gt;eslint --init&lt;/span&gt; 生成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
    &lt;/span&gt;&quot;root&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;env&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;browser&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&quot;commonjs&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&quot;es6&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&quot;extends&quot;&lt;span&gt;: [
        &lt;/span&gt;&quot;eslint:recommended&quot;&lt;span&gt;
    ],
    &lt;/span&gt;&quot;parserOptions&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;sourceType&quot;: &quot;module&quot;&lt;span&gt;
    },
    &lt;/span&gt;&quot;rules&quot;&lt;span&gt;: {&lt;/span&gt;&quot;indent&quot;&lt;span&gt;: [
            &lt;/span&gt;&quot;error&quot;&lt;span&gt;,
            &lt;/span&gt;4&lt;span&gt;
        ],
        &lt;/span&gt;&quot;linebreak-style&quot;&lt;span&gt;: [
            &lt;/span&gt;&quot;off&quot;&lt;span&gt;
        ],
        &lt;/span&gt;&lt;span&gt;&quot;semi&quot;: [&lt;/span&gt;
        &lt;span&gt;    2, &quot;always&quot;&lt;/span&gt;
        &lt;span&gt;],&lt;/span&gt;
        &quot;no-console&quot;&lt;span&gt;: [
            &lt;/span&gt;&quot;off&quot;&lt;span&gt;
        ]&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们使用 &lt;span class=&quot;cnblogs_code&quot;&gt;eslint:recommended&lt;/span&gt;   &lt;span class=&quot;cnblogs_code&quot;&gt;plugin:vue/recommended&lt;/span&gt;   &lt;span class=&quot;cnblogs_code&quot;&gt;plugin:import&lt;/span&gt;  规则进行校验，并优先使用  &lt;span class=&quot;cnblogs_code&quot;&gt;standard style&lt;/span&gt; 规则。&lt;/p&gt;

&lt;h3&gt;需要注意以下几点：&lt;/h3&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;要校验vue组件，需要安装  &lt;span class=&quot;cnblogs_code&quot;&gt;eslint-plugin-vue&lt;/span&gt;  ，并在配置中增加 &lt;span class=&quot;cnblogs_code&quot;&gt;plugin:vue/recommended&lt;/span&gt; &lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;eslint-plugin-import&lt;/span&gt; 用于校验es6的import规则，如果增加import plugin，在我们使用webpack的时候，如果你配置了resove.config.js的alias，那么我们希望import plugin的校验规则会从这里取模块的路径，此时需要配置
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;“rules”: {},
&lt;/span&gt;&quot;settings&quot;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用webpack中配置的resolve路径&lt;/span&gt;
        &quot;import/resolver&quot;: &quot;webpack&quot;&lt;span&gt; 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;使用babel-eslint语法解析器代替Esprima。EsLint是建立在Esprima(ECMAScript解析架构)的基础上的。Esprima支持ES5.1,本身也是用ECMAScript编写的，用于多用途分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;stanard style建议缩进用两个空格，我们这里根据自己的使用习惯用4个空格规则进行覆盖。&lt;/li&gt;
&lt;li&gt;设置提示规则：&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&quot;rules&quot;:&lt;span&gt; {
&lt;/span&gt;&quot;semi&quot;: [2, &quot;always&quot;],
&quot;quotes&quot;: [2, &quot;double&quot;&lt;span&gt;]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　规则有3种配置： &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0：禁止使用该规则(off)&lt;/li&gt;
&lt;li&gt;1：将该规则定义为警告 (warn) 等级（不影响exit code）&lt;/li&gt;
&lt;li&gt;2：将该规则定义为错误 (error) 等级（exit code为1） &lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;完整版配置见&lt;a href=&quot;https://github.com/saysmy/eslint&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;。&lt;/h4&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;三. 自动修复&lt;/h2&gt;
&lt;p&gt;eslint需要全局安装  &lt;span class=&quot;cnblogs_code&quot;&gt;yarn &lt;span&gt;global&lt;/span&gt; add eslint&lt;/span&gt;  &lt;/p&gt;
&lt;p&gt;eslint --fix 主动自动修复&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
eslint --ignore-pattern 'lib/*'  --fix **&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.js *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;*.vue
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 此命令可以修复大部分语法，剩下的需要手动修复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;eslint需要全局安装，对应的eslint-plugin-vue, eslint-plugin-import等插件也需要全局安装才能使用fix。&lt;/p&gt;
&lt;p&gt;对于webpack编译时的自动修复，可以如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    loader: &lt;/span&gt;'eslint-loader'&lt;span&gt;,
    options: {
        fix: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;四. 编辑器校验配置&lt;/h2&gt;
&lt;p&gt;用sublime做vue组件的校验时，虽然各种插件都安装了，但依然是没有效果的，最多是用js语法校验.vue组件，这是不行的。不知道是不是我的配置有问题，导致不能用vue组件的语法进行校验，所以这里放弃了使用sublime。&lt;/p&gt;
&lt;p&gt;本文推荐大家使用&lt;a href=&quot;https://code.visualstudio.com/&quot; target=&quot;_blank&quot;&gt;vscode&lt;/a&gt;作为自己的新IDE。功能丰富、强大，配置简单，会自动根据你打开的文件推荐安装有用的插件。还可以同步sublime等编辑器的操作习惯比如快捷键等。有着方便的语法库提示。&lt;/p&gt;
&lt;p&gt;打开左下角设置，加入以下配置，将包安装方式改为yarn（默认是npm），增加保存即进行自动修复，修复文件报错vue文件。如果不加language：vue，则只对js文件修复，同样如果相对html进行修复，则再增加language: html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&quot;eslint.packageManager&quot;: &quot;yarn&quot;&lt;span&gt;,
&lt;/span&gt;&quot;eslint.validate&quot;&lt;span&gt;: [
        &lt;/span&gt;&quot;javascript&quot;&lt;span&gt;,
        {
            &lt;/span&gt;&quot;language&quot;: &quot;vue&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;autoFix&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        }
    ],
&lt;/span&gt;&quot;eslint.autoFixOnSave&quot;: &lt;span&gt;true&lt;/span&gt;, 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 在左侧栏扩展中安装 ESLint和 Vetur插件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201808/979473-20180826225609187-849938488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201808/979473-20180826225622308-861824053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;重启IDE既可以看到校验效果&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201808/979473-20180826230339353-318212339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左侧会显示语法错误数和是否修改了此文件， 右侧会波浪线显示语法错误的地方。&lt;/p&gt;

&lt;p&gt;有时会遇到保存一次修复不完全的情况，多保存几次即可修复大部分语法。对于敲一会代码保存一下的可以不用担心这个问题。 &lt;/p&gt;

&lt;h3&gt; eslintrc.js 完整配置见&lt;a href=&quot;https://github.com/saysmy/eslint.git&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt; vscode user settings 推荐配置见&lt;a href=&quot;https://github.com/saysmy/vscode-settings.git&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;&lt;/h3&gt;

</description>
<pubDate>Mon, 27 Aug 2018 06:48:00 +0000</pubDate>
<dc:creator>冒雨ing</dc:creator>
<og:description>ESLint最初是由Nicholas C. Zakas 于2013年6月创建的开源项目。它的目标是提供一个插件化的javascript代码检测工具。 代码检查是一种静态的分析，常用于寻找有问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/saysmy/p/9513374.html</dc:identifier>
</item>
<item>
<title>为什么大公司一定要使用DevOps? - 帝都羊，请叫我逗逼</title>
<link>http://www.cnblogs.com/3xmq/p/devops.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/3xmq/p/devops.html</guid>
<description>&lt;h3&gt;&lt;span&gt;0 DevOps的意图&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;究竟什么是DevOps? 要想回答这个问题，首先要明确DevOps这个过程参与的人员是谁？即开发团队和IT运维团队！那么，DevOps的意图是什么呢？即在两个团队之间，建立良好的沟通和协作，更快更可靠的创建高质量软件！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上，并不是这两个团队之间的协作帮助交付了更好的软件，而是“开发”和“运维”团队之间的统一导致了软件的改进，并以更快的速度交付。我们不要忘记DevOps工具在实现自动化方面所扮演的角色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开发和运维“一体”的感觉是由开发人员和操作工程师之间的技能组合和实践的桥接以及自动化（DevOps）工具的实现引起的。 世界各地的大型互联网公司已采用DevOps方法来彻底改进其性能，安全性和团队动态。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在本篇文章中，让我们看看什么是DevOps，为什么它如此重要！ 我们将首先跟踪导致DevOps的软件开发方法的演变，然后探索什么是DevOps及其生命周期，并通过评估世界顶级公司如何使用DevOps来获得益处。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1 软件开发的演变 &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;多年来，DevOps从现有的软件开发策略/方法发展而来，以响应业务需求。让我们简要地看一下这些模型是如何演变的，以及它们最适合的场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xkq88.com1.z0.glb.clouddn.com/1248283-temp-201808-25-1535182348514.png&quot; alt=&quot;&quot; data-type=&quot;png&quot; data-ratio=&quot;0.66796875&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缓慢而繁琐的瀑布模型演变成敏捷，开发团队在短时间内完成软件开发，持续时间甚至不超过两周。如此短的发布周期帮助开发团队处理客户反馈，并将其与bug修复一起合并到下一个版本中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然这种敏捷的SCRUM方法为开发带来了敏捷性，但它在运维方面却失去了敏捷实践的速度。开发人员和运维工程师之间缺乏协作仍然会减慢开发过程和发布。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DevOps方法就是基于对更好的协作和更快的交付的需求而产生的。DevOps允许用较少复杂问题的持续软件交付来修复和更快地解决问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在我们已经了解了DevOps的发展，让我们来详细看看DevOps是什么。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2 什么是DevOps? &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;DevOps是一种软件开发方法，涉及软件在整个开发生命周期中的持续开发，持续测试，持续集成，持续部署和持续监控。 这些活动只能在DevOps中实现，而不是敏捷或瀑布，这就是为什么顶级互联网公司选择DevOps作为其业务目标的前进方向。 DevOps是在较短的开发周期内开发高质量软件的首选方法，可以提高客户满意度。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在不了解DevOps生命周期的情况下，对DevOps的理解也会片面化。现在让我们看看DevOps生命周期，并探讨它们如何与下图所示的软件开发阶段相关联。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xkq88.com1.z0.glb.clouddn.com/1248283-temp-201808-25-1535187184867.jpg&quot; alt=&quot;&quot; data-type=&quot;png&quot; data-ratio=&quot;0.66796875&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;持续开发:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是DevOps生命周期中软件不断开发的阶段。与瀑布模型不同的是，软件可交付成果被分解为短开发周期的多个任务节点，在很短的时间内开发并交付。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个阶段包括编码和构建阶段，并使用Git和SVN等工具来维护不同版本的代码，以及Ant、Maven、Gradle等工具来构建/打包代码到可执行文件中，这些文件可以转发给自动化测试系统进行测试。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;持续测试：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个阶段，开发的软件将被持续地测试bug。对于持续测试，使用自动化测试工具，如Selenium、TestNG、JUnit等。这些工具允许质量管理系统完全并行地测试多个代码库，以确保功能中没有缺陷。在这个阶段，使用Docker容器实时模拟“测试环境”也是首选。一旦代码测试通过，它就会不断地与现有代码集成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;持续集成:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是支持新功能的代码与现有代码集成的阶段。由于软件在不断地开发，更新后的代码需要不断地集成，并顺利地与系统集成，以反映对最终用户的需求更改。更改后的代码，还应该确保运行时环境中没有错误，允许我们测试更改并检查它如何与其他更改发生反应。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Jenkins是一个非常流行的用于持续集成的工具。使用Jenkins，可以从git存储库提取最新的代码修订，并生成一个构建，最终可以部署到测试或生产服务器。可以将其设置为在git存储库中发生更改时自动触发新构建，也可以在单击按钮时手动触发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;持续部署：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它是将代码部署到生产环境的阶段。 在这里，我们确保在所有服务器上正确部署代码。 如果添加了任何功能或引入了新功能，那么应该准备好迎接更多的网站流量。 因此，系统运维人员还有责任扩展服务器以容纳更多用户。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于新代码是连续部署的，因此配置管理工具可以快速，频繁地执行任务。 Puppet，Chef，SaltStack和Ansible是这个阶段使用的一些流行工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;容器化工具在部署阶段也发挥着重要作用。 Docker和Vagrant是流行的工具，有助于在开发，测试，登台和生产环境中实现一致性。 除此之外，它们还有助于轻松扩展和缩小实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;持续监控：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是DevOps生命周期中非常关键的阶段，旨在通过监控软件的性能来提高软件的质量。这种做法涉及运营团队的参与，他们将监视用户活动中的错误/系统的任何不正当行为。这也可以通过使用专用监控工具来实现，该工具将持续监控应用程序性能并突出问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用的一些流行工具是Splunk，ELK Stack，Nagios，NewRelic和Sensu。这些工具可帮助密切监视应用程序和服务器，以主动检查系统的运行状况。它们还可以提高生产率并提高系统的可靠性，从而降低IT支持成本。发现的任何重大问题都可以向开发团队报告，以便可以在持续开发阶段进行修复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些DevOps阶段连续循环进行，直到达到所需的产品质量。下面的图表将显示可以在DevOps生命周期的哪个阶段使用哪些工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xkq88.com1.z0.glb.clouddn.com/1248283-temp-201808-25-1535203483613.jpg&quot; alt=&quot;&quot; data-type=&quot;png&quot; data-ratio=&quot;0.66796875&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然我们已经确定了DevOps的重要性，并且了解了它的不同阶段以及所涉及的DevOps工具，现在让我们看看Facebook的一个案例研究，并理解为什么他们从敏捷转向DevOps。我们将采用Facebook曾推出的新特性的用例，这些新特性导致Facebook重新评估其产品交付并采用DevOps方法。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3 DevOps案例研究 &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;曾经，Facebook向遍布全球的若干亿用户推出了一系列新功能 - 时间轴，推荐和音乐功能。 发布后Facebook上产生的巨大流量导致服务器崩溃。 推出的功能获得了用户的大规模超常规响应，这导致了新功能产生了不可控的结果，使他们没有预料到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://7xkq88.com1.z0.glb.clouddn.com/1248283-temp-201808-25-1535204014758.jpg&quot; alt=&quot;&quot; data-type=&quot;png&quot; data-ratio=&quot;0.66796875&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这导致了Facebook重新评估和战略调整，从而使Facebook推出了暗启动技术。 使用DevOps原则，Facebook为其新版本的发布创建了以下方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://7xkq88.com1.z0.glb.clouddn.com/1248283-temp-201808-25-1535204683259.jpg&quot; alt=&quot;&quot; data-type=&quot;png&quot; data-ratio=&quot;0.66796875&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Facebook暗启动技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;暗启动是在新功能完全发布给所有用户之前，逐步将新功能，推广到选定的一组用户的过程。 这允许开发团队尽早获得用户反馈，测试错误，并且还可以测试基础架构性能。 这种发布方法是持续交付的直接结果，有助于实现更快，更迭代的版本，确保应用程序性能不会受到影响，并且用户可以很好地更新该版本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xkq88.com1.z0.glb.clouddn.com/1248283-temp-201808-25-1535205376644.jpg&quot; alt=&quot;&quot; data-type=&quot;png&quot; data-ratio=&quot;0.66796875&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在暗启动技术中，新功能通过专用的部署管道发布给小型用户群。 在上面给出的Facebook暗启动图表中，您可以看到只打开了一个部署管道，将新功能部署到一组选定用户。 此时剩余的数百条管道全部关闭。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 持续监视部署功能的特定用户群，以收集反馈并识别错误。 这些错误和反馈将被纳入开发，测试和部署在同一用户群中，直到功能变得稳定。 一旦实现稳定性，通过启用其他部署管道，将逐步在其他用户群上部署这些功能。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过这种方式，Facebook拥有一个受控或稳定的机制，可以为其庞大的用户群开发新功能。相反，如果功能没有得到很好的响应，他们可以选择完全回滚部署。这也帮助他们为部署准备服务器，因为他们可以预测网站上的用户活动，并相应地扩展服务器。上面给出的图表描述了Facebook的暗启动过程。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4 总结 &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;微信，淘宝，以及许多领先的科技巨头，在向所有人发布之前，都使用暗发布逐渐向一小部分用户发布和测试新功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DevOps的目的是更快速，更可靠地创建质量更好的软件，同时开发，运维团队之间进行更多的沟通和协作。 它是一个自动化过程，允许快速，安全和高质量的软件开发和发布，同时保持所有利益相关者在一个循环中。 这就是DevOps获得越来越多的大型互联网公司青睐的真正原因。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Aug 2018 06:01:00 +0000</pubDate>
<dc:creator>帝都羊，请叫我逗逼</dc:creator>
<og:description>在本篇文章中，让我们看看什么是DevOps，为什么它如此重要！ 我们将首先跟踪导致DevOps的软件开发方法的演变，然后探索什么是DevOps及其生命周期，并通过评估世界顶级公司如何使用DevOps来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/3xmq/p/devops.html</dc:identifier>
</item>
<item>
<title>使用 Synchronized 关键字 - Single_Yam</title>
<link>http://www.cnblogs.com/yangming1996/p/9541755.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangming1996/p/9541755.html</guid>
<description>&lt;p&gt;使用 Synchronized 关键字来解决并发问题是最简单的一种方式，我们只需要使用它修饰需要被并发处理的代码块、方法或字段属性，虚拟机自动为它加锁和释放锁，并将不能获得锁的线程阻塞在相应的阻塞队列上。&lt;/p&gt;
&lt;h3 id=&quot;基本使用&quot;&gt;基本使用&lt;/h3&gt;
&lt;p&gt;我们在上篇文章介绍线程的基本概念时，提到了多线程的好处，能够最大化 CPU 使用效率、更友好交互等等，但是也提出了它带来的问题，比如竞态条件、内存可见性问题。&lt;/p&gt;
&lt;p&gt;我们引用上篇文章中的一个案例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/08/25/PHODDU.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一百个线程随机地为 count 加一，由于自增操作非原子性，多线程之间不正常的访问导致 count 最终的值不确定，始终得不到预期的结果。&lt;/p&gt;
&lt;p&gt;使用 synchronized 即刻就能解决，看代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/08/25/PHv7aF.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码稍作修改，现在的程序无论你运行多少次，或者你增大并发量，最后 count 的值总是正确的 100 。&lt;/p&gt;
&lt;p&gt;大概什么意思呢？&lt;/p&gt;
&lt;p&gt;我们的 JAVA 中，对于每个对象都有一把『内置锁』，而 synchronized 中的代码在被线程执行之前，会去尝试获取一个对象的锁，如果成功，就进入并顺利执行代码，否则将会被阻塞在该对象上。&lt;/p&gt;
&lt;p&gt;除此之外，synchronized 除了可以修饰代码块，还可以直接修饰在方法上，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public synchronized void addCount(){......}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public static synchronized void addCount(){......}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是两种不同的使用方式，前一种是使用 synchronized 修饰的实例方法，那么 synchronized 使用的就是当前方法调用时所属的那个实例的『内置锁』。也就是说，addCount 方法调用前会去尝试获取调用实例对象的锁。&lt;/p&gt;
&lt;p&gt;而后一种 addCount 方法是一个静态方法，所以 synchronized 使用的就是 addCount 所属的类对象的锁。&lt;/p&gt;
&lt;p&gt;synchronized 的使用方式还是很简单的，什么时候加锁，什么时候释放锁都不需要我们操心，被 JVM 封装好了，下面我们就来简单看看 JVM 是如何实现这种间接锁机制的。&lt;/p&gt;
&lt;h3 id=&quot;基本实现原理&quot;&gt;基本实现原理&lt;/h3&gt;
&lt;p&gt;我们先看一段简单的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TestAxiom {
    private int count;

    @Test
    public void test() throws InterruptedException {
        synchronized (this){
            count++;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一段非常简单的代码，使用 synchronized 修饰代码块，保护 count++ 操作。现在我们反编译一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/08/25/PbpLTK.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，在执行 count++ 指令之前，编译器加了一条 monitorenter 指令，count++ 指令执行结束时又加了一条 monitorexit 指令。准确意义上来说，这就是两条加锁的释放锁的指令，具体细节我们稍后再看。&lt;/p&gt;
&lt;p&gt;除此之外，我们的 synchronized 方法在反编译后并没有这两条指令，但是编译器却在方法表的 flags 属性中设置了一个标志位 ACC_SYNCHRONIZED。&lt;/p&gt;
&lt;p&gt;这样，每个线程在调用该方法之前都会检查这个状态位是否为 1，如果状态为 1 说明这是一个同步方法，需要首先执行 monitorenter 指令去尝试获取当前实例对象的内置锁，并在方法执行结束执行 monitorexit 指令去释放锁。&lt;/p&gt;
&lt;p&gt;其实本质上是一样的，只是 synchronized 方法是一种隐式的实现。&lt;strong&gt;下面我们来看一看这个内置锁的具体细节。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 中一个对象主要由以下三种类型数据组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对象头：也称 Mark Word，主要存储的对象的 hash 值以及相关锁信息。&lt;/li&gt;
&lt;li&gt;实例数据：保存的当前对象的数据，包括父类属性信息等。&lt;/li&gt;
&lt;li&gt;填充数据：这部分是应 JVM 要求，每个对象的起始地址必须是 8 的倍数，所以如果当前对象不足 8 的倍数字节时用于字节填充。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们的『内置锁』在对象头里面，而 Mark Word 的一个基本结构是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/08/26/PbLsGn.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先不去管什么是，轻量锁，重量锁，偏向锁，自旋锁，这是虚拟机一种锁优化机制，通过锁膨胀来优化性能，这一点的细节我们以后再介绍，你先把它们统一理解为一把锁。&lt;/p&gt;
&lt;p&gt;其中，每把锁会有一个标志位用于区分锁类型，和一个指向锁记录的指针，也就是说锁指针会关联另一种结构，Monitor Record。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/08/27/PqtFwn.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Owner 字段存储的是拥有当前锁的线程唯一标识号，当某个线程拥有了该锁之后就会把自己的线程号写入这个字段中。如果某个线程发现这里的 Owner 字段不是 null 也不是自己的线程号，那么它将会被阻塞在 Monitor 的阻塞队列上直至某个线程走出同步代码块并发起唤醒操作。&lt;/p&gt;
&lt;p&gt;总结一下，被 synchronized 修饰的代码块或者方法在编译器会被额外插入两条指令，monitorenter 会去检查对象头锁信息，对应到一个 Monitor 结构，如果该结构的 Owner 字段已经被占用了，那么当前线程将会被阻塞在 Monitor 的一个阻塞队列上，直到占有锁的线程释放了锁并唤起一波新的锁竞争。&lt;/p&gt;
&lt;h3 id=&quot;synchronized-的几个特性&quot;&gt;synchronized 的几个特性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、可重入性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个对象往往有多个方法，这些方法有的是同步的，有的是非同步的，那么如果一个线程已经获得了某个对象的锁并进入了其某个同步方法，而这个同步方法中还需要调用同一实例的另一个同步方法，是否需要重新竞争锁？&lt;/p&gt;
&lt;p&gt;这对于某些锁来说，是需要重新竞争锁的，但是我们的 synchronized 是「可重入的」，也就是说，如果当前线程获得了某个对象的锁，那么该对象的所有方法都是可以无需竞争锁式调用的。&lt;/p&gt;
&lt;p&gt;原因也很简单，monitorenter 指令找到 Monitor，查看了 Owner 字段的值等于当前线程的线程号，于是将 Nest 字段增加一，表示当前线程多次持有该对象的锁，每调用一次 monitorexit 都会减一 Nest 的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、内存可见性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引用上篇文章的一个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/08/27/PqDWo4.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程 ThreadTwo 不停的监听 flag 的值，而我们主线程对 flag 进行了修改，由于内存可见性，ThreadTwo 看不见，于是程序一直死循环。&lt;/p&gt;
&lt;p&gt;某种意义上，synchronized 是可以解决这类内存可见性问题的，修改代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/08/27/Pq2KXR.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主线程先获得 obj 的内置锁，然后启动 ThreadTwo 线程，该线程由于获取不到 obj 的锁而被阻塞，也就是它知道已经有其他线程在操作共享变量，所以等到自己获得锁的时候一定要从内存重新读一下共享变量。&lt;/p&gt;
&lt;p&gt;而我们的主线程会在释放锁的时候将私有工作内存中所有的全局变量的值刷新到内存空间，这样其实就实现了多线程之间的内存可见性。&lt;/p&gt;
&lt;p&gt;当然有一点大家要注意，synchronized 修饰的代码块会在释放锁的时候刷新自己更改过的全局变量，但是另一个线程要想看见，必须也从内存中重新读才行。而一般情况下，不是你加了 synchronized 线程就会从内存中读数据的，而只有它在竞争某把锁失败后，得知有其他线程正在修改共享变量，这样的前提下等到自己拥有锁之后才会重新去刷内存数据。&lt;/p&gt;
&lt;p&gt;你也可以试试，让 ThreadTwo 线程不去竞争 obj 这把锁，而随便给它一个对象，结果依然会是死循环，flag 的值只会是 ThreadTwo 刚启动时从内存读入的初始数据的缓存版。&lt;/p&gt;
&lt;p&gt;但是说实话，解决内存可见性而使用 synchronized 代价太高，需要加锁和释放锁，甚至还需要阻塞和唤醒线程，我们一般使用关键字 volatile 直接修饰在变量上就可以了，这样对于该变量的读取和修改都是直接映射内存的，不经过线程本地私有工作内存的。&lt;/p&gt;
&lt;p&gt;关于 synchronized 关键字我们暂时先介绍到这，后续还会涉及到它的，我们还要介绍近几个 JDK 版本对于 synchronized 的优化细节，包括自旋锁，偏向锁，重量级锁之间的锁膨胀机制，也是这种优化使得现在的 synchronized 性能不输于 Lock。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;文章中的所有代码、图片、文件都云存储在我的 GitHub 上：&lt;/p&gt;
&lt;p&gt;(https://github.com/SingleYam/overview_java)&lt;/p&gt;
&lt;p&gt;欢迎关注微信公众号：OneJavaCoder，所有文章都将同步在公众号上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/06/19/Czmcad.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Aug 2018 05:42:00 +0000</pubDate>
<dc:creator>Single_Yam</dc:creator>
<og:description>使用 Synchronized 关键字来解决并发问题是最简单的一种方式，我们只需要使用它修饰需要被并发处理的代码块、方法或字段属性，虚拟机自动为它加锁和释放锁，并将不能获得锁的线程阻塞在相应的阻塞队列</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangming1996/p/9541755.html</dc:identifier>
</item>
</channel>
</rss>