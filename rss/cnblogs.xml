<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【原】小程序常见问题整理 - 白树</title>
<link>http://www.cnblogs.com/PeunZhang/p/7929177.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PeunZhang/p/7929177.html</guid>
<description>&lt;ul&gt;&lt;li&gt;常见问题&lt;/li&gt;
&lt;li&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt; 小程序如何做页面适配&lt;/h3&gt;
&lt;p&gt;小程序提供了响应式单位rpx（responsive pixel），规定屏幕宽为750rpx，必须提供视觉稿宽度为750px,，然后根据视觉稿单位是多少px，还原成小程序就写多少rpx&lt;/p&gt;

&lt;h3&gt; 如何正确的使用image标签&lt;/h3&gt;
&lt;p&gt;请点击查看这份文档&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://km.oa.com/group/22440/docs/show/164131&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;http://km.oa.com/group/22440/docs/show/164131&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt; 如何禁止页面滑动&lt;/h3&gt;
&lt;p&gt;方法一：把父级标签修改为scroll-view。&lt;/p&gt;
&lt;p&gt;wxml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scroll-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;输入内容&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scroll-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;wxss&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;scroll-view&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;width&lt;/span&gt;:&lt;span&gt;100%&lt;/span&gt;;&lt;span&gt;height&lt;/span&gt;:&lt;span&gt;100%&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法二：设置page.json文件的disableScroll为属性true。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{&lt;/span&gt;&quot;navigationBarTitleText&quot;: &quot;标题&quot;&lt;span&gt;,&lt;/span&gt;&quot;disableScroll&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 本地资源无法通过 WXSS 获取怎么解决&lt;/h3&gt;
&lt;p&gt;background-image：可以使用外部链接，或者直接用 base64。&lt;/p&gt;
&lt;p&gt;wxss&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;.test1&lt;/span&gt;{&lt;span&gt;background-image&lt;/span&gt;:&lt;span&gt;url(data:image/png&lt;/span&gt;;&lt;span&gt;base64,iVBORw0K...)&lt;/span&gt;}&lt;br/&gt;&lt;span&gt;.test2&lt;/span&gt;{&lt;span&gt;background-image&lt;/span&gt;:&lt;span&gt; url(http://mat1.gtimg.com/www/images/qq2012/qqLogoFilter.png)&lt;/span&gt;;
}
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt; 小程序如何跳小程序&lt;/h3&gt;
&lt;p&gt;方法一：在wx.previewImage(OBJECT)中添加包含小程序码的图片，点击预览图片后长按即可识别小程序二维码并跳转到小程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/278431/201706/278431-20170622101705413-341531689.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方法二：使用微信客户端 6.5.9 版本提供的 &lt;a href=&quot;https://mp.weixin.qq.com/debug/wxadoc/dev/api/navigateToMiniProgram.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;wx.navigateToMiniProgram(OBJECT)&lt;/a&gt; ，可以打开同一公众号下关联的另一个小程序。&lt;/p&gt;

&lt;h3&gt; wxss-伪类选择器受限制问题&lt;/h3&gt;
&lt;p&gt;目前伪类只能使用:before、:after、first-child、last-child伪类，属性选择器、相邻选择器、兄弟选择器、子选择器、伪类选择器、请都放弃。&lt;/p&gt;

&lt;h3&gt; 没有html的br标签怎么换行&lt;/h3&gt;
&lt;p&gt;文本换行直接enter键即可。&lt;/p&gt;

&lt;h3&gt; scroll-view标签bug&lt;/h3&gt;
&lt;p&gt;1.如果第一个标签的样式包含position: absolute会导致整体样式失效&lt;/p&gt;
&lt;p&gt;2.scroll-view上设置flex布局，其中align-items: center对子元素无效&lt;/p&gt;

&lt;h3&gt; 如何模拟触摸按钮的hover效果&lt;/h3&gt;
&lt;p&gt;方法一：所有标签的触摸效果可直接使用css伪类:active即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.btn&lt;/span&gt;{&lt;span&gt;background-color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;}&lt;span&gt;.btn:active&lt;/span&gt;{&lt;span&gt;background-color&lt;/span&gt;:&lt;span&gt;blue&lt;/span&gt;;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法二：小程序组件button、navigator自带hover-class属性，也可以使用它设置按钮触摸效果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;default&quot;&lt;/span&gt;&lt;span&gt;hover-class&lt;/span&gt;&lt;span&gt;=&quot;other-button-hover&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; default &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;navigator &lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;=&quot;/page/navigate/navigate&quot;&lt;/span&gt;&lt;span&gt;hover-class&lt;/span&gt;&lt;span&gt;=&quot;navigator-hover&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;跳转到新页面&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;navigator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;  如何在小程序上复制文本&lt;/h3&gt;
&lt;p&gt;对指定要复制的文本使用text标签，并设置 selectable属性为true&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;text &lt;/span&gt;&lt;span&gt;selectable&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;复制我复制我复制我复制我&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/278431/201706/278431-20170622162416835-1153711779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;  微信哪个版本开始支持小程序码&lt;/h3&gt;
&lt;p&gt;6.5.7开始支持扫一扫识别小程序码的版本&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;%20https://mp.weixin.qq.com/s/Vi4Uyg-8CWL_F92B1KaGIw&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s/Vi4Uyg-8CWL_F92B1KaGIw&lt;/a&gt;&lt;br/&gt;统计2017-6-19的数据，不支持扫一扫识别小程序码的用户为：&lt;br/&gt;IOS：30.87%&lt;br/&gt;安卓：21.71%&lt;br/&gt;总量：24.05%&lt;/p&gt;
&lt;p&gt;所以目前线下铺设的物料最好使用普通的二维码&lt;/p&gt;

&lt;h3&gt;   iPhone4等低端机器使用css3样式不添加-webkit前缀样式无效&lt;/h3&gt;
&lt;p&gt;如图，flex、transform因为没有添加-webkit前缀，iPhone4s下页面错乱&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/278431/201711/278431-20171130150338370-407835682.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;572&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;   android手机中，表单input标签使用css属性color并设置值为rgba单位会导致白屏&lt;/h3&gt;
&lt;p&gt;如图，input标签的设置为color: rgba(0, 0, 0, 0.87)，在表单输入内容后看不见文案，几乎所有的android机器都中招&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/278431/201711/278431-20171130150401167-1046465651.jpg&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;427&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;

</description>
<pubDate>Thu, 30 Nov 2017 07:17:00 +0000</pubDate>
<dc:creator>白树</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PeunZhang/p/7929177.html</dc:identifier>
</item>
<item>
<title>Android开发之漫漫长途 Ⅵ——图解Android事件分发机制（深入底层源码） - 忘了12138</title>
<link>http://www.cnblogs.com/wangle12138/p/7929068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangle12138/p/7929068.html</guid>
<description>&lt;p&gt;&lt;em&gt;该文章是一个系列文章，是本人在Android开发的漫漫长途上的一点感想和记录，我会尽量按照先易后难的顺序进行编写该系列。该系列引用了《Android开发艺术探索》以及《深入理解Android 卷Ⅰ，Ⅱ，Ⅲ》中的相关知识，另外也借鉴了其他的优质博客，在此向各位大神表示感谢，膜拜！！！另外，本系列文章知识可能需要有一定Android开发基础和项目经验的同学才能更好理解，也就是说该系列文章面向的是Android中高级开发工程师。&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;系列第六篇了，，接着上一篇说，在上一篇文章中我们上了一个小例子来自定义View,文章比较简单，阅读量几乎没有，有灌水的嫌疑，（实际上没有，每一篇文章我都是用心在写）。这一篇文章呢，我们来看一下Android事件的分发机制。关于这方面的知识大概已经被讲烂了。我本人也看了好多关于这方面优质的文章和博客。可以说是受益匪浅，但是可是总觉得没有掌握完全。所以我去看了关于底层源码的一些知识。然后在这里分享给大家。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;当我们的手指从触摸到屏幕上的各种View开始到这个点击事件结束到底经历了什么，我们来详细分析一下。（Android的输入系统处理了很多事件，包括按键，触摸，以及外接设备，但是我们这篇文章只分析我们最熟悉也是最常用的触摸事件，这里的描述也许不太精确，但是却最为直观）&lt;br/&gt;我们先上一个总体流程图&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171128111838167?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM0MDAzNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：上图中绿色线条表示默认的事件处理流程，即我们没有做任何处理，事件会按照绿色线条所示的方向由&lt;strong&gt;Activity-&amp;gt;...ViewGroup..-&amp;gt;View-&amp;gt;...ViewGroup..-&amp;gt;Activity这个U型图&lt;/strong&gt;进行传递。即一直默认调用super.XXX方法。&lt;/p&gt;
&lt;p&gt;上图中黑色线条表示默认&lt;strong&gt;Activity-&amp;gt;...ViewGroup..-&amp;gt;View-&amp;gt;...ViewGroup..-&amp;gt;Activity这个U型图&lt;/strong&gt;的任一节点中（不包括onInterceptTouchEvent）返回了true，事件即结束，不再向下一节点传递。&lt;/p&gt;
&lt;p&gt;上图中红色线条表示一些特殊情况，尤其是ViewGroup，ViewGroup.onInterceptTouchEvent表示询问当前ViewGroup是否需要拦截此事件即要不要处理，为什么要“多此一举”呢，因为ViewGroup.dispatchTouchEvent这个函数的特殊，从上图可知，&lt;strong&gt;该函数返回true，是消费事件，返回false是交由上一级的ViewGroup或者Activity的onTouchEvent&lt;/strong&gt;。那么它怎么向下传递事件或者想把事件交给自己的onTouchEvent处理呢，所以ViewGroup多了个onInterceptTouchEvent（View是没有该函数的），onInterceptTouchEvent起到作用的是分流。&lt;strong&gt;onInterceptTouchEvent返回false或者返回super.xxx是向下级View或者ViewGroup传递，返回true呢是把事件交给自己的onTouchEvent处理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们知道了上图，，但是Activty的事件又是从哪得到的呢，事件最终返回到Activity的onTouchEvent中又做了什么呢。。下面我们来。。。。。&lt;br/&gt;&lt;strong&gt;1 首先从手指触摸到屏幕开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道Android是基于Linux系统的。当&lt;strong&gt;输入设备&lt;/strong&gt;可用时（这里的输入设备包括很多设备，比如触摸屏和键盘是Android最普遍也是最标准的输入设备，另外它还包括外接的游戏手柄、鼠标等），Linux内核会为&lt;strong&gt;输入设置&lt;/strong&gt;创建对应的&lt;strong&gt;设备节点&lt;/strong&gt;。当&lt;strong&gt;输入设备&lt;/strong&gt;不可用时，就把对应的设备节点删除，这也是如果我们的屏幕意外摔碎了或者其他原因导致触摸屏幕不可用时触摸没有反应的根本原因。当我们的输入设备可用时（我们这里只来讲解&lt;strong&gt;触摸屏&lt;/strong&gt;），我们对触摸屏进行操作时，Linux就会收到相应的硬件中断，然后将中断加工成原始的输入事件并写入相应的&lt;strong&gt;设备节点&lt;/strong&gt;中。而我们的Android 输入系统所做的事情概括起来说就是&lt;strong&gt;监控这些设备节点，当某个设备节点有数据可读时，将数据读出并进行一系列的翻译加工，然后在所有的窗口中找到合适的事件接收者，并派发给它。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 手指进行一系列操作(这里指的是手指的移动，这一步可能没有)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3 手指抬起或者因其他其他原因(突然间来了个电话之类的)导致事件结束&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;注：上述第2第3步与第1步里的处理基本相同，但是需要注意的是Android是**串行处理事件的**，也就是说按下的动作（ACTION_DOWN|ACTION_POINTER_DOWN）处理完成之前是不会处理后续的ACTION_MOVE|ACTION_POINTER_MOVE和ACTION_UP|ACTION_POINTER_UP事件的。并且后续的ACTION_MOVE|ACTION_POINTER_MOVE和ACTION_UP|ACTION_POINTER_UP事件会根据对ACTION_DOWN|ACTION_POINTER_DOWN事件的不同而稍有不同。下面我们先来分析按下的事件ACTION_DOWN|ACTION_POINTER_DOWN的分发。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们来详细分析，请注意，前方高能，请自备纸巾（草稿纸）&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;上面我们说到了Android 输入系统所做的事情概括起来说就是&lt;strong&gt;监控设备节点，当某个设备节点有数据可读时，将数据读出并进行一系列的翻译加工，然后在所有的窗口中找到合适的事件接收者，并派发给它。&lt;/strong&gt;那么它是如何做的呢，，我们来具体分析一下。Android 的输入系统InputManagerService（以下简称为IMS）作为系统服务，它像其他系统服务一样在SystemServer进程中创建。&lt;/p&gt;
&lt;p&gt;Linux会为所有可用的输入设备在/dev/input目录在建立event0~n或者其他名称的&lt;strong&gt;设备节点&lt;/strong&gt;，Android输入系统会监控这些&lt;strong&gt;设备节点&lt;/strong&gt;，具体是通过&lt;strong&gt;INotify和Epoll机制&lt;/strong&gt;来进行监控。而不是通过一个线程进行轮询查询。&lt;br/&gt;我们先来看一下&lt;strong&gt;INotify和Epoll机制&lt;/strong&gt;（这里我们只进行简单的描述，读者如果有兴趣可以留言，我单开一篇文章）&lt;br/&gt;&lt;strong&gt;INotify机制&lt;/strong&gt;&lt;br/&gt;INotify是Linux内核提供的一种文件系统变化通知机制。它可以为应用程序监控文件系统的变化，如文件的新建，删除等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//创建INotify对象，并用描述符inotifyFd 描述它
int inotifyFd = inotify_init();
/*
    添加监听
    inotify_add_watch函数参数说明
        inotifyFd：上面建立的INotify对象的描述符，当监听的目录或文件发生变化时记录在INotify对象
        “/dev/input”：被监听的文件或者目录
        IN_CREATE | IN_DELETE：事件类型
综合起来下面的代码表示的意思就是当“/dev/input”下发生IN_CREATE | IN_DELETE（创建或者删除）时即把这个事件写入到INotify对象中
*/
int wd = inotify_add_watch(inotifyFd, &quot;/dev/input&quot;, IN_CREATE|IN_DELETE )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Epoll机制&lt;/strong&gt;&lt;br/&gt;在上述INotify机制中我们知道了我们只需关心inotifyFd这个描述符就行了，可是事件是随机发生的，我们也不会本末倒置的采用轮询的方式轮询这个描述符，因为如果这样做的话会浪费大量系统资源。这时候我们Linux的另一个机制就派上用场了，即&lt;strong&gt;Epoll机制&lt;/strong&gt;。&lt;strong&gt;Epoll机制&lt;/strong&gt;简单的说就是&lt;strong&gt;使用一次等待来获取多个描述的可读或者可写状态。&lt;/strong&gt;这样我们不必对每一个描述符创建独立的线程进行阻塞读取，在避免了资源浪费的同时获得较快的相应速度。&lt;/p&gt;
&lt;p&gt;至此原始输入事件已经读取完毕，Android输入系统对原始输入事件进行翻译加工以及派发的详细过程很复杂。我们这里只分析其中一部分——IMS与窗口。上文中我们也说到了IMS会在所有的窗口中找到合适的事件接收者。IMS是运行在SystemServer进程中，而我们的窗口呢，是在我们的应用进程中。这就引出了我们在&lt;a href=&quot;http://blog.csdn.net/u010340035/article/details/78518154&quot;&gt;Android开发之漫漫长途 Ⅴ——Activity的显示之ViewRootImpl的PreMeasure、WindowLayout、EndMeasure、Layout、Draw&lt;/a&gt;中留下的悬念&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;`// ② 初始化mInputChanel。InputChannel是窗口接收来自InputDispatcher的输入事件的管道。这部分内容我们将在下一篇介绍。
  if ((mWindowAttributes.inputFeatures
          &amp;amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
      mInputChannel = new InputChannel();
  }
  ...


  ...
// ③ 如果mInputChannel不为空，则创建mInputEventReceiver用于接收输入事件。
  if (mInputChannel != null) {

      mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,
              Looper.myLooper());
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读者看到这里该疑惑了，这个不是在ViewRootImpl.setView方法中说的吗，跟现在讲的有关系吗？且听我娓娓道来。在上几篇博客中我们介绍了Avtivity,Window,PhoneWindow,以及ViewRootImpl这些概念之间 到底有什么关系呢。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我们从前几篇中就知道了Activity的启动流程，Activity对象最先创建，但是Activity的显示是依靠其内部对象&lt;strong&gt;Window mWindow&lt;/strong&gt;,而Window是个抽象类，所以mWindow指向的实际上是Window的实现类PhoneWindow的对象。PhoneWindow作为显示的载体，ViewRootImpl的measure、layout以及draw才是View显示的动力所在。我们运行项目，看到了一个MainActivity,我们点击MainActivity的某个View(如Button了或者其他)，实际上我们是点击了屏幕上的某个点。由IMS对这个原始事件进行翻译加工并找到我们的PhoneWindow，并向PhoneWindow派发事件。整个过程可用如下流程图表示。&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171127150729103?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM0MDAzNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;注：上面的流程图中省略了很多细节，意在让读者对Android输入系统有个更整体的把控。&lt;br/&gt;通过上面的流程图我们知道，当我们的PhoneWindow创建完成之后，我们也在该Window上注册了InputChannel并与IMS通信，IMS把事件写入InputChannel，WindowInputEventReceiver对事件进行处理并最终还是通过InputChannel反馈给IMS。&lt;br/&gt;下面我们来稍微介绍下InputChannel和WindowInputEventReceiver。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;InputChannel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InputChannel的本质是一对SocketPair(非网络套接字)。套接字可以用于网络通信，也可以用于本机内的进程通信。进程间通信的一种方式，具体解释读者可自行参看《深入理解Android 卷Ⅲ》》中的5.4.1节。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;WindowInputEventReceiver&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;得到InputChannel后，便用它创建WindowInputEventReceiver，WindowInputEventReceiver继承于InputEventReceiver，InputEventReceiver对象可以接收来自InputChannel的输入事件，并触发其onInputEvent方法的回调。我们这里的是WindowInputEventReceiver，所以我们来看一下这个类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;final class WindowInputEventReceiver extends InputEventReceiver {
        public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) {
            super(inputChannel, looper);
        }
        //重写了onInputEvent方法，所以当InputChannel有事件时，会触发WindowInputEventReceiver.onInputEvent(),而其内部直接调用了enqueueInputEvent
        @Override
        public void onInputEvent(InputEvent event) {
            enqueueInputEvent(event, this, 0, true);
        }

        @Override
        public void onBatchedInputEventPending() {
            if (mUnbufferedInputDispatch) {
                super.onBatchedInputEventPending();
            } else {
                scheduleConsumeBatchedInput();
            }
        }

        @Override
        public void dispose() {
            unscheduleConsumeBatchedInput();
            super.dispose();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那我们来看一下enqueueInputEvent&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void enqueueInputEvent(InputEvent event,
            InputEventReceiver receiver, int flags, boolean processImmediately) {
        ...
        `//① 将InputEvent对应的InputEventReceiver封装为一个QueuedInputEvent 
        QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags);
        //② 将新建的QueuedInputEvent 追加到mPendingInputEventTail所表示的一个单向链表中
        QueuedInputEvent last = mPendingInputEventTail;
        if (last == null) {
            mPendingInputEventHead = q;
            mPendingInputEventTail = q;
        } else {
            last.mNext = q;
            mPendingInputEventTail = q;
        }
        mPendingInputEventCount += 1;
       

        if (processImmediately) {
            //③ 如果第三个参数为true，则直接在当前线程中开始对输入事件的处理工作
            doProcessInputEvents();
        } else {
            //④ 否则将处理事件的请求发送给主线程的Handler，随后进行处理
            scheduleProcessInputEvents();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看doProcessInputEvents&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void doProcessInputEvents() {
        `//遍历整个输入事件队列，并逐一处理
        while (mPendingInputEventHead != null) {
            QueuedInputEvent q = mPendingInputEventHead;
            mPendingInputEventHead = q.mNext;
            if (mPendingInputEventHead == null) {
                mPendingInputEventTail = null;
            }
            q.mNext = null;

            mPendingInputEventCount -= 1;
            Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName,
                    mPendingInputEventCount);

            long eventTime = q.mEvent.getEventTimeNano();
            long oldestEventTime = eventTime;
            if (q.mEvent instanceof MotionEvent) {
                MotionEvent me = (MotionEvent)q.mEvent;
                if (me.getHistorySize() &amp;gt; 0) {
                    oldestEventTime = me.getHistoricalEventTimeNano(0);
                }
            }
            mChoreographer.mFrameInfo.updateInputEventTime(eventTime, oldestEventTime);
            //deliverInputEvent()方法会将完成单个事件的整个处理流程
            deliverInputEvent(q);
        }

      ...
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而deliverInputEvent方法进行一系列调用最终会调用我们的processPointerEvent()方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private int processPointerEvent(QueuedInputEvent q) {
            
            final MotionEvent event = (MotionEvent)q.mEvent;

            mAttachInfo.mUnbufferedDispatchRequested = false;
            mAttachInfo.mHandlingPointerEvent = true;
            
            // 此时ViewRootImpl会将事件的处理权移交给View树的根节点，调用dispatchPointerEvent函数  
            boolean handled = mView.dispatchPointerEvent(event);

            maybeUpdatePointerIcon(event);
            maybeUpdateTooltip(event);
            mAttachInfo.mHandlingPointerEvent = false;
            if (mAttachInfo.mUnbufferedDispatchRequested &amp;amp;&amp;amp; !mUnbufferedInputDispatch) {
                mUnbufferedInputDispatch = true;
                if (mConsumeBatchedInputScheduled) {
                    scheduleConsumeBatchedInputImmediately();
                }
            }
            return handled ? FINISH_HANDLED : FORWARD;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在processPointerEvent我们看到ViewRootImpl会将事件的处理权移交给View树的根节点，调用dispatchPointerEvent函数，即mView，而这个mView就是我们熟知的DecorView&lt;br/&gt;在ActivityThread.handleResumeActivity方法中有如下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//decor即DecorView，l是布局参数WindowManager.LayoutParams
wm.addView(decor, l);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们下面即分析DecorView，我们打开DecorView源码并没有发现dispatchPointerEvent，别着急，别上火，，那么这个dispatchPointerEvent肯定在DecorView父类里面了，，我们打开View源码，，果然找到了，该函数如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public final boolean dispatchPointerEvent(MotionEvent event) {
        if (event.isTouchEvent()) {
            //事件如果是Touch事件，毫无疑问我们的是啊
            return dispatchTouchEvent(event);
        } else {
            return dispatchGenericMotionEvent(event);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候我们要去看View.dispatchTouchEvent吗？？NO!!!!!我们应该看DecorView.dispatchTouchEvent(DecorView重写了dispatchTouchEvent)&lt;br/&gt;DecorView.dispatchTouchEvent声明如下&lt;/p&gt;
&lt;p&gt;DecorView.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        //获取Window.Callback，Window.Callback是个接口，这里的mWindow是PhoneWindow，调用PhoneWindow.getCallback(),但是PhoneWindow并没有实现该方法，所以我们找到了Window.getCallBack()方法。Window.getCallBack()方法返回Callback类型的变量mCallback
        final Window.Callback cb = mWindow.getCallback();
        //如果cb不为空并且window没有被销毁 mFeatureId &amp;lt; 0 表示是application的DecorView，比如Activity、Dialog把事件传给cb，否则把事件传递给父类的dispatchTouchEvent
        return cb != null &amp;amp;&amp;amp; !mWindow.isDestroyed() &amp;amp;&amp;amp; mFeatureId &amp;lt; 0
                ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Window.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final Callback getCallback() {
        return mCallback;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; public interface Callback {
       ...`//省略一部分函数
       
        public boolean dispatchTouchEvent(MotionEvent event);
        
       ...
        
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看这个Window.Callback ，既然有getCallback(),那么应该有setCallback为mCallback赋值。我们&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171128132643043?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM0MDAzNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;我们在Activity的attach方法中看到如下代码&lt;/p&gt;
&lt;p&gt;Activity.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window, ActivityConfigCallback activityConfigCallback) {
        ......
        //创建PhoneWindow
        mWindow = new PhoneWindow(this, window, activityConfigCallback);
        
        ......
        //设置当前Activity为Window.Callback,那么毫无疑问，Activity类或者其父类实现了Window.Callback接口
        mWindow.setCallback(this);
        ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看Activity类的声明&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171128133547577?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM0MDAzNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;果然如此。那么我们就来看看Activity.dispatchTouchEvent&lt;br/&gt;Activity.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        //在这里我们又把事件给了PhoneWindow.superDispatchTouchEvent方法根据其返回值，若返回值为true，那么dispatchTouchEvent返回true，我们Activity的onTouchEvent方法无法得到执行
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        //这里就是我们的Activity的onTouchEvent方法
        return onTouchEvent(ev);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那我们要看PhoneWindow.superDispatchTouchEvent&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
    public boolean superDispatchTouchEvent(MotionEvent event) {
        //兜兜转转一大圈，还是把事件交给我们的DecorView，DecorView继承自FrameLayout，FrameLayout呢又继承自ViewGroup，所以作为一个ViewGroup，DecorView继续向其子View派发事件，其流程我在文章的开头就已经给了
        return mDecor.superDispatchTouchEvent(event);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：&lt;strong&gt;兜兜转转一大圈我们神经都被绕弯了，我们在这里总结一下，当我们触摸（点击）屏幕时，Android输入系统IMS通过对事件的加工处理再合适的Window接收者并通过InputChannel向Window派发加工后的事件，并触发InputReceiver的onInputEvent的调用，由此产生后面一系列的调用，把事件派发给整个控件树的根DecorView。而DecorView又上演了一出偷梁换柱的把戏，先把事件交给Activity处理，在Activity中又把事件交还给了我们的DecorView。自此沿着控件树自上向下依次派发事件。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我们总算把ACTION_DOWN的事件分发分析完毕了，ACTION_DOWN事件可以说是所有触摸事件的起点。我们触摸了屏幕，并引发ACTION_DOWN的事件，然后可能经过一系列的ACTION_MOVE事件，最后是ACTION_UP事件，至ACTION_UP，这整个事件序列算是完成了。我们前面分析了ACTION_DOWN事件，那么ACTION_MOV和ACTION_UP呢，&lt;strong&gt;ACTION_MOV和ACTION_UP的事件分发与ACTION_DOWN并不完全相同。&lt;/strong&gt;为什么这么说呢，是因为他们很相似，但是稍微有些不同。你在执行ACTION_DOWN的时候返回了false，后面一系列其它的action就不会再得到执行了。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个事件（如ACTION_DOWN）返回true，才会收到ACTION_MOVE和ACTION_UP的事件。那么这句话是什么意思呢？我们来看一下不同情况下事件派发图。&lt;/p&gt;
&lt;p&gt;我们在ViewGroup1中的dispatchTouchEvent中消费事件&lt;img src=&quot;http://img.blog.csdn.net/20171129161140541?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM0MDAzNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在ViewGroupX中的dispatchTouchEvent中消费事件&lt;img src=&quot;http://img.blog.csdn.net/20171129161159070?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM0MDAzNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在View中的dispatchTouchEvent中消费事件&lt;img src=&quot;http://img.blog.csdn.net/20171129161330908?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM0MDAzNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在View中的onTouchEvent中消费事件&lt;img src=&quot;http://img.blog.csdn.net/20171129161442334?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM0MDAzNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;特殊情况1 ：我们在ViewGroupX中的onTouchEvent中消费事件&lt;/strong&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171129161530629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM0MDAzNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特殊情况2 ：我们在ViewGroupX中的dispatchTouchEvent中返回false并在ViewGroup1中的onTouchEvent中消费事件&lt;/strong&gt;!&lt;img src=&quot;http://img.blog.csdn.net/20171129161606377?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM0MDAzNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有种种情况我就不画图了。。为什么会产生上面的结果呢？我们还是来看一下ViewGroup的dispatchTouchEvent源码把。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
  ......
   boolean handled = false;
   if (onFilterTouchEventForSecurity(ev)) {//表示窗口是否为模糊窗口（FILTER_TOUCHES_WHEN_OBSCURED），如果是窗口，则表示不希望处理改事件。(如dialog后的窗口)
        if (onFilterTouchEventForSecurity(ev)) {
       final int action = ev.getAction();
       final int actionMasked = action &amp;amp; MotionEvent.ACTION_MASK;
       /** 第①步 重新设置状态  开始*/
       // 处理初始的按下动作
       if (actionMasked == MotionEvent.ACTION_DOWN) {
           //重新设置状态等，比较重要的是设置mFirstTouchTarget == null，
           cancelAndClearTouchTargets(ev);
           resetTouchState();
       }
       /** 第①步 重新设置状态  结束*/
       
        /** 第②步 检查是否拦截  开始*/
       // 检查是否拦截
       final boolean intercepted;
       if (actionMasked == MotionEvent.ACTION_DOWN
               || mFirstTouchTarget != null) {//如果是ACTION_DOWN事件或者mFirstTouchTarget != null
            //这里我们去问ViewGroup是否允许拦截，如果允许拦截，我们再去问onInterceptTouchEvent
          ......
       } else {
           //如果不是MotionEvent.ACTION_DOWN事件并且mFirstTouchTarget 为空，直接拦截
           intercepted = true;
       }
         /** 第②步 检查是否拦截  结束*/
      ......
      /** 第③步 向子View派发  开始*/
       if (!canceled &amp;amp;&amp;amp; !intercepted) {//如果没有取消并且当前ViewGroup没有拦截事件

           ......
           if (actionMasked == MotionEvent.
                        || (split &amp;amp;&amp;amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {//判断事件类型，如果是ACTION_DOWN或者ACTION_POINTER_DOWN或者ACTION_HOVER_MOVE则进入
                        
                 if (newTouchTarget == null &amp;amp;&amp;amp; childrenCount != 0) {
                     ......
                    
                          ......
                                //获取子View并循环向子View派发事件
                          if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                          //如果当前ViewGroup的子View消费了事件，则进入if体
                          ......
                              //赋值newTouchTarget和mFirstTouchTarget 
                              newTouchTarget = addTouchTarget(child, idBitsToAssign);
                              alreadyDispatchedToNewTouchTarget = true;
                              break;
                          }
        
                }            
            
            ......
              
       }
    }
    /** 第③步 向子View派发  结束*/
    
    /** 第④步 额外的处理  开始*/
   // Dispatch to touch targets.
    if (mFirstTouchTarget == null) {
    /**这个判断十分重要：
    我们在上面的过程中就知道倘若我们没有拦截即intercepted = false;如果事件是ACTION_DOWN或者ACTION_POINTER_DOWN或者ACTION_HOVER_MOVE我们会进入循环子View并派发事件的过程，如果子View也不想处理该事件即dispatchTransformedTouchEvent()函数返回了false,那么此时ViewGroup的mFirstTouchTarget == null
    倘若我们重写了onInterceptTouchEvent并返回true，那么intercepted = true即进行拦截，那么就不会进入我们的第③步，直接来到第④步，这时当前ViewGroup的mFirstTouchTarget == null
    
    mFirstTouchTarget == null的条件下会调用dispatchTransformedTouchEvent
    */
       
        handled = dispatchTransformedTouchEvent(ev, canceled, null,
                TouchTarget.ALL_POINTER_IDS);
    } else {
       
        TouchTarget predecessor = null;
                TouchTarget target = mFirstTouchTarget;
                while (target != null) {
                    final TouchTarget next = target.next;
                    if (alreadyDispatchedToNewTouchTarget &amp;amp;&amp;amp; target == newTouchTarget) {
                        handled = true;
                    } else {
                        final boolean cancelChild = resetCancelNextUpFlag(target.child)
                                || intercepted;
                        if (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) {
                            handled = true;
                        }
                        if (cancelChild) {
                            if (predecessor == null) {
                                mFirstTouchTarget = next;
                            } else {
                                predecessor.next = next;
                            }
                            target.recycle();
                            target = next;
                            continue;
                        }
                    }
                    predecessor = target;
                    target = next;
                }
    }
    /** 第④步 额外的处理  结束*/
       
     ......
   return handled;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们从上面的代码可以更清晰的了解到ACTION_DOWN的派发过程，现在还存疑的就是这个mFirstTouchTarget了，我们在触发ACTION_DOWN的时候，ViewGroup会根据事件掩码actionMask判断ACTION_DOWN，并重置一些状态，重置状态的过程中就包括把mFirstTouchTarget设为null，我们第一次进入第三步时找到合适的子View并向其派发事件，如果子View消费了ACTION_DOWN事件，则调用addTouchTarget进行赋值，我们来看一下这个函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
        final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);
        target.next = mFirstTouchTarget;
        //在这里我们可以看到mFirstTouchTarget 指向了子View
        mFirstTouchTarget = target;
        return target;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有上面的代码可知mFirstTouchTarget是ViewGroup的一个成员变量，每一个ViewGroup都持有这个mFirstTouchTarget。&lt;br/&gt;&lt;strong&gt;这个mFirstTouchTarget是个单向链表，表示的是当前ViewGroup的子View有没有消费ACTION_DOWN事件，如果消费了ACTION_DOWN事件，就如上面代码中第③步的时候描述的一样给mFirstTouchTarget赋值，如果当前ViewGroup的子View没有消费ACTION_DOWN事件，即把事件分发给子View的这个dispatchTransformedTouchEvent()函数返回了false，不进入if体，mFirstTouchTarget还是为null。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们接着来看第④步，结合上图中的&lt;strong&gt;特殊情况1&lt;/strong&gt;，我们在ViewGroupX中的onTouchEvent中消费了事件。&lt;strong&gt;那么对于ViewGroupX来说，它的mFirstTouchTarget==null，因为它的子View并没有消费事件，对于ViewGroup1来说它的mFirstTouchTarget ！= null,因为它的子View ViewGroupX消费了事件，以此类推&lt;/strong&gt;最后得到的mFirstTouchTarget 链表类似于下图&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171130133308611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM0MDAzNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;由于ACTION_MOVE|ACTION_UP事件不符合第③步时进入获取子View并循环派发的条件，当是ACTION_MOVE|ACTION_UP事件会直接来到第④步，判断当前ViewGroup的mFirstTouchTarget 是否为空，由上图可知不为空，那么进入第④步else体，在第④步else体内依据下图的链表逐一向子View派发事件。所以ACTION_MOVE|ACTION_UP事件只派发到ViewGroupX并交由ViewGroupX的onTouchEvent处理，不再向下派发。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那我们再来看一下mFirstTouchTarget == null的条件下调用的dispatchTransformedTouchEvent函数&lt;br/&gt;参数分别是ev, canceled, &lt;strong&gt;null,&lt;/strong&gt; TouchTarget.ALL_POINTER_IDS&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {
        final boolean handled;

      
        final int oldAction = event.getAction();
        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
            event.setAction(MotionEvent.ACTION_CANCEL);
            if (child == null) {
                //child为空调用父类即View的dispatchTouchEvent
                handled = super.dispatchTouchEvent(event);
            } else {
                handled = child.dispatchTouchEvent(event);
            }
            event.setAction(oldAction);
            return handled;
        }

       
        final int oldPointerIdBits = event.getPointerIdBits();
        final int newPointerIdBits = oldPointerIdBits &amp;amp; desiredPointerIdBits;

   
        if (newPointerIdBits == 0) {
            return false;
        }

   
        final MotionEvent transformedEvent;
        if (newPointerIdBits == oldPointerIdBits) {
            if (child == null || child.hasIdentityMatrix()) {
                if (child == null) {
                     //child为空调用父类即View的dispatchTouchEvent
                    handled = super.dispatchTouchEvent(event);
                } else {
                    final float offsetX = mScrollX - child.mLeft;
                    final float offsetY = mScrollY - child.mTop;
                    event.offsetLocation(offsetX, offsetY);

                    handled = child.dispatchTouchEvent(event);

                    event.offsetLocation(-offsetX, -offsetY);
                }
                return handled;
            }
            transformedEvent = MotionEvent.obtain(event);
        } else {
            transformedEvent = event.split(newPointerIdBits);
        }

       
        if (child == null) {
             //child为空调用父类即View的dispatchTouchEvent
            handled = super.dispatchTouchEvent(transformedEvent);
        } else {
            final float offsetX = mScrollX - child.mLeft;
            final float offsetY = mScrollY - child.mTop;
            transformedEvent.offsetLocation(offsetX, offsetY);
            if (! child.hasIdentityMatrix()) {
                transformedEvent.transform(child.getInverseMatrix());
            }

            handled = child.dispatchTouchEvent(transformedEvent);
        }

        // Done.
        transformedEvent.recycle();
        return handled;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的函数我们就不仔细分析了，不过注释里写的很明白，只要流程正常的话，我们都会调用父类的dispatchTouchEvent&lt;/p&gt;
&lt;p&gt;我们来看一下View的dispatchTouchEvent&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean dispatchTouchEvent(MotionEvent event) {
   
   ......

    if (onFilterTouchEventForSecurity(event)) {
        ......

        ListenerInfo li = mListenerInfo;
        if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null
                &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED
                &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) {//这里判断有没有为View是否可用Enabled并且检查是否设置了TouchListener，如果设置了，则触发TouchListener的onTouch
            result = true;
        }

        if (!result &amp;amp;&amp;amp; onTouchEvent(event)) {//如果当前View没有设置listener信息，事件也没有被滚动条消费这里回调了我们的onTouchEvent。所以如果为当前View设置了TouchListenerb并在TouchListener的onTouch函数中返回了true，那么，该View的onTouchEvent将无法得到回调。
            result = true;
        }
    }

......
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;本篇总结&lt;/strong&gt;&lt;br/&gt;本篇文章详细分析了View的事件体系（写这一篇文章真是不容易啊）。作为所有触摸事件的起点ACTION_DOWN|ACTION_POINTER_DOWN来说，Android对其的处理很精细，尤其是ViewGroup对其的处理。&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;首先重置状态，这是因为一个新的事件序列开始了，重置状态中比较重要的就是这个mFirstTouchTarget了，&lt;strong&gt;mFirstTouchTarget作为ViewGroup的成员变量记录当前ViewGroup下的子View是否消费了该ACTION_DOWN|ACTION_POINTER_DOWN事件。这个子View的意思也不仅仅是直接子View。&lt;/strong&gt;假如有这样一个结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;ViewGroup1&amp;gt;
    &amp;lt;ViewGroup2&amp;gt;
        &amp;lt;ViewGroup3&amp;gt;
            &amp;lt;ViewGroup4&amp;gt;
                &amp;lt;View&amp;gt;
                &amp;lt;/View&amp;gt;
            &amp;lt;/ViewGroup4&amp;gt;
        &amp;lt;/ViewGroup3&amp;gt;
    &amp;lt;/ViewGroup2&amp;gt;
&amp;lt;/ViewGroup1&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设是View消费了ACTION_DOWN|ACTION_POINTER_DOWN事件，那么ViewGroup1的mFirstTouchTarget就是ViewGroup2-&amp;gt;ViewGroup3-&amp;gt;ViewGroup4-&amp;gt;View&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果ViewGroup子View消费了事件，那么记录mFirstTouchTarget，ACTION_DOWN|ACTION_POINTER_DOWN事件结束，如果没有子View消费此事件，mFirstTouchTarget为null。后续的ACTION_MOVE|ACTION_UP事件会根据上一步中的mFirstTouchTarget进行分发。若为null，调用父类的即View的dispatchTouchEvent，该函数内部会先判断Listener信息，并调用listener的onTouch方法，根据onTouch的返回值决定是否继续调用当前ViewGroup的onTouchEvent方法；若不为null，则根据mFirstTouchTarget链表进行分发后续的ACTION_MOVE|ACTION_UP事件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;希望读者能多看几遍上面的分析。相信你一定会有收获的&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;下篇预告&lt;/strong&gt;&lt;br/&gt;在下一篇文章中我们将进行实战项目，也是对我们前几篇文章的实际应用。老话说的好，&lt;strong&gt;&lt;em&gt;纸上得来终觉浅，绝知此事要躬行&lt;/em&gt;&lt;/strong&gt;。下一篇甚至几篇我们就来&lt;strong&gt;自定义ViewGroup&lt;/strong&gt;并重点探讨滑动冲突如何解决。滑动冲突解决的基础是今天这篇的View事件体系&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;此致，敬礼&lt;/p&gt;
</description>
<pubDate>Thu, 30 Nov 2017 07:01:00 +0000</pubDate>
<dc:creator>忘了12138</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangle12138/p/7929068.html</dc:identifier>
</item>
<item>
<title>IT连创业系列：App产品上线后，运营怎么搞？（中） - 路过秋天</title>
<link>http://www.cnblogs.com/cyq1162/p/7922189.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyq1162/p/7922189.html</guid>
<description>&lt;p&gt;等运营篇写完，计划是想写一个IOS系列，把IT连App里用到和遇到的坑都完整的和大伙分享。&lt;/p&gt;
&lt;p&gt;不过写IOS系列前，还是要认真把这个运营篇写完，接下来好好码字！！！&lt;/p&gt;
&lt;p&gt;上篇说到，我们计划去一次富士康门口，拉一批美女回来，而且还只要这么美的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201711/17408-20171127220335800-1143704863.jpg&quot; alt=&quot;&quot; width=&quot;490&quot; height=&quot;280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就要计划行动了：&lt;/p&gt;
&lt;p&gt;接着让UI的妹子在网上订了些小礼品，然后印了不少宣传单，大概几千张吧。&lt;/p&gt;
&lt;p&gt;还弄了一个宣传易拉宝（其实是两个，IT连那个没架起来）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171129185818620-1530274665.jpg&quot; alt=&quot;&quot; width=&quot;164&quot; height=&quot;291&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171129190025308-1245996725.jpg&quot; alt=&quot;&quot; width=&quot;164&quot; height=&quot;292&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171129185153714-1342724549.jpg&quot; alt=&quot;&quot; width=&quot;216&quot; height=&quot;289&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，我们挑了一个星期天，带上公司员工共5个人（深圳那边叫了4个股东，一共凑了9个人头）。&lt;/p&gt;
&lt;p&gt;一切就绪，从9点折腾到11点左右，就出发了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171129185329245-1919500195.jpg&quot; alt=&quot;&quot; width=&quot;489&quot; height=&quot;366&quot;/&gt;&lt;/p&gt;
&lt;p&gt;去到那边，都快12点多了，然后和深圳的团队汇合。&lt;/p&gt;
&lt;p&gt;事先探点的人员汇报说，找遍了周围，都发现没啥人流量多的地方！！&lt;/p&gt;
&lt;p&gt;后来找了一家奶茶店，打探了一下军情，才发现工厂今天不上班，这下就尴尬了〜&lt;/p&gt;
&lt;p&gt;(事后和人家奶茶店谈了一下条件，在人家店里贴一下了下宣传海报，1个月给100块，不过目前为止没啥效果。)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171129200300573-1436952558.jpg&quot; alt=&quot;&quot; width=&quot;316&quot; height=&quot;421&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171129200349058-887266897.jpg&quot; alt=&quot;&quot; width=&quot;314&quot; height=&quot;419&quot;/&gt;&lt;/p&gt;
&lt;p&gt;喝完奶茶，找了家餐厅，大伙一起去吃了一餐饭：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171129200721511-129881583.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;373&quot;/&gt;&lt;/p&gt;
&lt;p&gt;中间调戏了一下服务员，可惜没成功。&lt;/p&gt;
&lt;p&gt;饭后，来都来了，就散开四处去派传单了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171129191229745-591504261.jpg&quot; alt=&quot;&quot; width=&quot;238&quot; height=&quot;317&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171129191257729-1208513258.jpg&quot; alt=&quot;&quot; width=&quot;239&quot; height=&quot;318&quot;/&gt;&lt;/p&gt;
&lt;p&gt;估计派的时候大伙也很挑，没点姿色，都不靠近给单。&lt;/p&gt;
&lt;p&gt;奋战了一下午，平均每个人派出去10来张左右，总体大概派出100来张。&lt;/p&gt;
&lt;p&gt;至于效果，那是一个惨字形容了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171129194606823-186141450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;事后总结了一下：&lt;/h3&gt;
&lt;p&gt;事先没计划好，对工厂的上下班时间事也没有打探，去的太盲目去了，计划不周。&lt;/p&gt;
&lt;p&gt;后来是找关系，要来了上下班的表格，等计划好有机会再去一次。&lt;/p&gt;

&lt;h3&gt;后来：&lt;/h3&gt;
&lt;p&gt;面试来了一个长的帅气的运营小伙伴，他在社交这一块，有自己的资源和想法。&lt;/p&gt;
&lt;p&gt;但是成本比较高，所以一度在考虑。&lt;/p&gt;
&lt;p&gt;他和我们说，马上双十一就来了，然后双十二就要来了，要赶紧考虑了。&lt;/p&gt;
&lt;p&gt;后来把心一横，来吧，进来互相伤害吧〜〜〜〜&lt;/p&gt;
&lt;p&gt;于是负责人到位了。&lt;/p&gt;

&lt;p&gt;接下来的日子里，极尽所能的配合他的要求，并给了他最大的资源调度权限。&lt;/p&gt;
&lt;p&gt;然后就是常规性的公司IT连公众号运营了。&lt;/p&gt;
&lt;p&gt;中间搭配股东积分系统里的任务。&lt;/p&gt;
&lt;p&gt;终于，女性用户慢慢赶上了男性用户了。&lt;/p&gt;
&lt;p&gt;有些还很漂亮，我给大伙找几张啊：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171129201551761-746473381.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171129202013948-1509424507.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171129202024698-1154421193.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201711/17408-20171129202037136-136762183.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（未完待续......）&lt;/p&gt;
</description>
<pubDate>Thu, 30 Nov 2017 06:25:00 +0000</pubDate>
<dc:creator>路过秋天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyq1162/p/7922189.html</dc:identifier>
</item>
<item>
<title>JavaScript学习笔记（十三）——生成器（generator） - 苦瓜第一印象</title>
<link>http://www.cnblogs.com/whucs2012/p/7922207.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whucs2012/p/7922207.html</guid>
<description>&lt;p&gt;&lt;span&gt;在学习廖雪峰前辈的JavaScript教程中，遇到了一些需要注意的点，因此作为学习笔记列出来，提醒自己注意！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果大家有需要，欢迎访问前辈的博客&lt;a title=&quot;廖雪峰的官方网站&quot; href=&quot;https://www.liaoxuefeng.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.liaoxuefeng.com/&lt;/span&gt;&lt;/a&gt;学习。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们先看一下函数的概念：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(x) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; x;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; r = foo(1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用foo函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在函数执行过程中，如果没有遇到 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt; 语句，控制权无法交回被调用的代码。（&lt;span&gt;函数末尾如果没有&lt;code&gt;return&lt;/code&gt;，就是隐含的&lt;code&gt;return undefined;&lt;/code&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;h4&gt;generator定义&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;*&lt;span&gt; foo(x) {
    yield x &lt;/span&gt;+ 1&lt;span&gt;;
    yield x &lt;/span&gt;+ 2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x + 3&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;generator与函数的区别&lt;/h4&gt;
&lt;p&gt;generator由 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;function&lt;/span&gt;*&lt;/span&gt; 定义（注意多出的&lt;code&gt;*&lt;/code&gt;号），并且，除了 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt; 语句，还可以用 &lt;span class=&quot;cnblogs_code&quot;&gt;yield&lt;/span&gt; &lt;span&gt;返回多次&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;举个例子就容易理解了：&lt;/p&gt;
&lt;p&gt;著名的斐波拉切数列，它是由0,1开头：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
0 1 1 2 3 5 8 13 21 34 ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要编写一个产生斐波那契数列的函数，可以这么写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fib(max) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;
        t,
        a &lt;/span&gt;= 0&lt;span&gt;,
        b &lt;/span&gt;= 1&lt;span&gt;,
        arr &lt;/span&gt;= [0, 1&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (arr.length &amp;lt;&lt;span&gt; max) {
        [a, b] &lt;/span&gt;= [b, a +&lt;span&gt; b];
        arr.push(b);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试:&lt;/span&gt;
fib(5); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [0, 1, 1, 2, 3]&lt;/span&gt;
fib(10); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;函数只能返回一次，所以必须返回一个&lt;code&gt;Array&lt;/code&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但是，&lt;span&gt;如果换成generator，就可以一次返回一个数，不断返回多次&lt;/span&gt;。用generator改写如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
'use strict'
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;*&lt;span&gt; fib(max) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;
        t,
        a &lt;/span&gt;= 0&lt;span&gt;,
        b &lt;/span&gt;= 1&lt;span&gt;,
        n &lt;/span&gt;= 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (n &amp;lt;&lt;span&gt; max) {
        yield a;
        [a, b] &lt;/span&gt;= [b, a +&lt;span&gt; b];
        n &lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
fib(5); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; fib {[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们发现，直接调用一个generator和调用函数不一样， &lt;span class=&quot;cnblogs_code&quot;&gt;fib(5)&lt;/span&gt; 仅仅是创建了一个generator对象，还没有去执行它。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用generator对象有两个方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一是不断地调用generator对象的 &lt;span class=&quot;cnblogs_code&quot;&gt;next()&lt;/span&gt; 方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; f = fib(5&lt;span&gt;);
f.next(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 0, done: false}&lt;/span&gt;
f.next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 1, done: false}&lt;/span&gt;
f.next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 1, done: false}&lt;/span&gt;
f.next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 2, done: false}&lt;/span&gt;
f.next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 3, done: false}&lt;/span&gt;
f.next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: undefined, done: true}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;next()&lt;/span&gt; 方法会执行generator的代码，然后，每次遇到 &lt;span class=&quot;cnblogs_code&quot;&gt;yield x;&lt;/span&gt; 就返回一个对象 &lt;span class=&quot;cnblogs_code&quot;&gt;{value: x, done: &lt;span&gt;true&lt;/span&gt;/false}&lt;/span&gt; ，然后“暂停”。返回的 &lt;span class=&quot;cnblogs_code&quot;&gt;value&lt;/span&gt; 就是 &lt;span class=&quot;cnblogs_code&quot;&gt;yield&lt;/span&gt; 的返回值，&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;done&lt;/span&gt; 表示这个generator是否已经执行结束了&lt;/span&gt;。如果 &lt;span class=&quot;cnblogs_code&quot;&gt;done&lt;/span&gt; 为 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;true&lt;/span&gt;&lt;/span&gt; ，则 &lt;span class=&quot;cnblogs_code&quot;&gt;value&lt;/span&gt; 就是 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt; 的返回值。&lt;/p&gt;
&lt;p&gt;当执行到 &lt;span class=&quot;cnblogs_code&quot;&gt;done&lt;/span&gt; 为 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;true&lt;/span&gt;&lt;/span&gt; 时，这个generator对象就已经全部执行完毕，不要再继续调用 &lt;span class=&quot;cnblogs_code&quot;&gt;next()&lt;/span&gt; 了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二是直接用 &lt;span class=&quot;cnblogs_code&quot;&gt;for......of&lt;/span&gt; 循环迭代generator对象，这种方式不需要我们自己加判断 &lt;span class=&quot;cnblogs_code&quot;&gt;done&lt;/span&gt; ：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;p&gt;for (var x of fib(10)) {&lt;br/&gt;console.log(x); // 依次输出0, 1, 1, 2, 3, ...&lt;br/&gt;}&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;generator优点&lt;/h4&gt;
&lt;p&gt;1.正是由于generator在执行过程中能多次返回，所以它看上去像一个可以记住执行状态的函数，利用这一点，可以通过写一个generator来实现需要用面向对象才能实现的功能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如，用一个对象来保存状态，我们一般是用对象的属性来保存。这样很繁琐：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; fib =&lt;span&gt; {
    a: &lt;/span&gt;0&lt;span&gt;,
    b: &lt;/span&gt;1&lt;span&gt;,
    n: &lt;/span&gt;0&lt;span&gt;,
    max: &lt;/span&gt;5&lt;span&gt;,
    next: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;
            r &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a,
            t &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.a + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.b;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.b;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.b =&lt;span&gt; t;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.n &amp;lt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.max) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.n ++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; undefined;
        }
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。&lt;/p&gt;
&lt;p&gt;没有generator时，用AJAX时需要这么写代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
ajax('http://url-1', data1, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (err, result) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handle(err);
    }
    ajax(&lt;/span&gt;'http://url-2', data2, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (err, result) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handle(err);
        }
        ajax(&lt;/span&gt;'http://url-3', data3, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (err, result) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handle(err);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; success(result);
        });
    });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;回调越多，代码越难看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过使用generator时，可以这么写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    r1 &lt;/span&gt;= yield ajax('http://url-1'&lt;span&gt;, data1);
    r2 &lt;/span&gt;= yield ajax('http://url-2'&lt;span&gt;, data2);
    r3 &lt;/span&gt;= yield ajax('http://url-3'&lt;span&gt;, data3);
    success(r3);
}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (err) {
    handle(err);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看上去是同步的代码，实际上是异步的代码。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 30 Nov 2017 06:09:00 +0000</pubDate>
<dc:creator>苦瓜第一印象</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whucs2012/p/7922207.html</dc:identifier>
</item>
<item>
<title>C#设计模式之十七观察者模式（Observer Pattern）【行为型】 - PatrickLiu</title>
<link>http://www.cnblogs.com/PatrickLiu/p/7928521.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/7928521.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   今天是2017年11月份的最后一天，也就是2017年11月30日，利用今天再写一个模式，争取下个月（也就是12月份）把所有的模式写完，2018年，新的一年写一些新的东西。今天我们开始讲“行为型”设计模式的第四个模式，该模式是【观察者模式】，英文名称是：Observer Pattern。还是老套路，先从名字上来看看。“观察者模式”我第一次看到这个名称，我的理解是，既然有“观察者”，那肯定就有“被观察者”了，“观察者”监视着“被观察者”，如果“被观察者”有所行动，“观察者”就会做出相应的动作来回应，哈哈，听起来是不是有点像“谍战”的味道。我所说的谍战不是天朝内的那种，比如：手撕鬼子，我说的是“谍影重重”的那类优秀影片，大家懂得。“观察者模式”在现实生活中，实例其实是很多的，比如：八九十年代我们订阅的报纸，我们会定期收到报纸，因为我们订阅了。银行可以给储户发手机短信，也是“观察者模式”很好的使用的例子，因为我们订阅了银行的短信业务，当我们账户余额发生变化就会收到通知，还有很多，我就不一一列举了，发挥大家的想象吧。好了，接下来，就让我们看看该模式具体是怎么实现的吧。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二、观察者模式的详细介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1、动机（Motivate）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。&lt;/p&gt;&lt;p&gt;   使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2、意图（Intent）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。　　　　　　                                ——《设计模式》GoF&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.3、结构图&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       &lt;img src=&quot;http://images2017.cnblogs.com/blog/1048776/201711/1048776-20171130133356354-676034245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.4、模式的组成&lt;/strong&gt;&lt;br/&gt;    &lt;br/&gt;    可以看出，在观察者模式的结构图有以下角色：&lt;/p&gt;&lt;p&gt;    （1）、抽象主题角色（Subject）：抽象主题把所有观察者对象的引用保存在一个列表中，并提供增加和删除观察者对象的操作，抽象主题角色又叫做抽象被观察者角色，一般由抽象类或接口实现。&lt;/p&gt;&lt;p&gt;    （2）、抽象观察者角色（Observer）：为所有具体观察者定义一个接口，在得到主题通知时更新自己，一般由抽象类或接口实现。&lt;/p&gt;&lt;p&gt;    （3）、具体主题角色（ConcreteSubject）：实现抽象主题接口，具体主题角色又叫做具体被观察者角色。&lt;/p&gt;&lt;p&gt;    （4）、具体观察者角色（ConcreteObserver）：实现抽象观察者角色所要求的接口，以便使自身状态与主题的状态相协调。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.5、观察者模式的代码实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    观察者模式在显示生活中也有类似的例子，比如：我们订阅银行短信业务，当我们账户发生改变，我们就会收到相应的短信。类似的还有微信订阅号，今天我们就以银行给我发送短信当我们账户余额发生变化的时候为例来讲讲观察者模式的实现，很简单，现实生活正例子也很多，理解起来也很容易。我们看代码吧，实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 观察者模式的实现
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;银行短信系统抽象接口，是被观察者--该类型相当于抽象主体角色Subject&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BankMessageSystem
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; IList&amp;lt;Depositor&amp;gt;&lt;span&gt; observers;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数初始化观察者列表实例&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; BankMessageSystem()
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;            observers=&lt;span&gt;new&lt;/span&gt; List&amp;lt;Depositor&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         
&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加预约储户&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add(Depositor depositor);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除预约储户&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Delete(Depositor depositor);
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知储户&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Notify()
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;            &lt;span&gt;foreach&lt;/span&gt;(Depositor depositor &lt;span&gt;in&lt;/span&gt;&lt;span&gt; observers)
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;           {
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;               &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(depositor.AccountIsChanged)
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;              {
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;                  depositor.Update(moneyBalance.MoneyBalance,moneyBalance.OperationDateTime);
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;账户发生了变化，并且通知了，储户的账户就认为没有变化&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;                   depositor.AccountIsChanged=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;              }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;北京银行短信系统，是被观察者--该类型相当于具体主体角色ConcreteSubject&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BeiJingBankMessageSystem:BankMessageSystem
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加预约储户&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add(Depositor depositor)
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;应该先判断该用户是否存在，存在不操作，不存在则增加到储户列表中，这里简化了&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;           observers.Add(depositor);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除预约储户&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Delete(Depositor depositor)
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;应该先判断该用户是否存在，存在则删除，不存在无操作，这里简化了&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;           observers.Remove(depositor);
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;  
&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;储户的抽象接口--相当于抽象观察者角色（Observer）&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Depositor
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;状态数据&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _name;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _balance;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _total;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; _isChanged;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化状态数据&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; Depositor(&lt;span&gt;string&lt;/span&gt; name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; total)
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;._name=&lt;span&gt;name;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;._balance=total;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存款总额等于余额&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;._isChanged=&lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;账户未发生变化&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         
&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;储户的名称，假设可以唯一区别的&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Name
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt;{&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _name;}
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;{ &lt;span&gt;this&lt;/span&gt;._name=&lt;span&gt;value;}
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Balance
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;            &lt;span&gt;get&lt;/span&gt;{&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._balance;}
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取钱&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; GetMoney(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num)
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt;(num&amp;lt;=&lt;span&gt;this&lt;/span&gt;._balance &amp;amp;&amp;amp; num&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;          {
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;._balance=&lt;span&gt;this&lt;/span&gt;._balance-&lt;span&gt;num;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;._isChanged=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;             OperationDateTime=&lt;span&gt;DateTime.Now;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;账户操作时间&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; DateTime OperationDateTime{&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;账户是否发生变化&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; AccountIsChanged
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;            &lt;span&gt;get&lt;/span&gt;{&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._isChanged;}
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;            &lt;span&gt;set&lt;/span&gt;{&lt;span&gt;this&lt;/span&gt;._isChanged=&lt;span&gt;value;}
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新储户状态&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Update(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; currentBalance,DateTime dateTime);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;  
&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;北京的具体储户--相当于具体观察者角色ConcreteObserver&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BeiJingDepositor:Depositor
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         pubic &lt;span&gt;void&lt;/span&gt; Update(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; currentBalance,DateTime dateTime)
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;           Console.WriteLine(Name+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:账户发生了变化，变化时间是&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+dateTime.ToString()+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,当前余额是&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;currentBalance.ToString());
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;  
&lt;span&gt;116&lt;/span&gt;     
&lt;span&gt;117&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 客户端（Client）&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们有了三位储户，都是武林高手，也比较有钱&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt;             Depositor huangFeiHong=&lt;span&gt;new&lt;/span&gt; BeiJingDepositor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;黄飞鸿&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;             Depositor fangShiYu=&lt;span&gt;new&lt;/span&gt; BeiJingDepositor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;方世玉&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;             Depositor hongXiGuan=&lt;span&gt;new&lt;/span&gt; BeiJingDepositor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;洪熙官&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;2500&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt;             BankMessageSystem beijingBank=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeiJingBankMessageSystem();
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这三位开始订阅银行短信业务&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;            beijingBank.Add(huangFeiHong);
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;            beijingBank.Add(fangShiYu);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;            beijingBank.Add(hongXiGuan);
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             
&lt;span&gt;133&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;黄飞鸿取100块钱&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;             huangFeiHong.GetMoney(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;            beijingBank.Notify();
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;黄飞鸿和方世玉都取了钱&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt;             huangFeiHong.GetMoney(&lt;span&gt;200&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;             fangShiYu.GetMoney(&lt;span&gt;200&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;            beijingBank.Notify();
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; 
&lt;span&gt;142&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;他们三个都取了钱&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt;             huangFeiHong.GetMoney(&lt;span&gt;320&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;             fangShiYu.GetMoney(&lt;span&gt;4330&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;             hongXiGuan.GetMoney(&lt;span&gt;332&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt;            beijingBank.Notify();
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; 
&lt;span&gt;148&lt;/span&gt; &lt;span&gt;            Console.Read();
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt; 观察者模式有些麻烦的地方就是关于状态的处理，我这里面涉及了一些状态的处理，大家可以细细体会一下，模式还是要多多练习，多多写，里面的道理就不难理解了。&lt;br/&gt;   &lt;br/&gt;&lt;strong&gt;三、观察者模式的实现要点：&lt;/strong&gt;&lt;br/&gt;    &lt;br/&gt;    使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者（面向对象中的改变不是指改代码，而是指扩展、子类化、实现接口），从而使二者之间的依赖关系达致松耦合。&lt;/p&gt;&lt;p&gt;    目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。观察者自己决定是否需要订阅通知，目标对象对此一无所知。&lt;/p&gt;&lt;p&gt;    在C#的event中，委托充当了抽象的Observer接口，而提供事件的对象充当了目标对象。委托是比抽象Observer接口更为松耦合的设计。&lt;/p&gt;&lt;p&gt;     观察者模式有以下几个优点：&lt;/p&gt;&lt;p&gt;    （1）、观察者模式实现了表示层和数据逻辑层的分离，并定义了稳定的更新消息传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层，即观察者。&lt;/p&gt;&lt;p&gt;    （2）、观察者模式在被观察者和观察者之间建立了一个抽象的耦合，被观察者并不知道任何一个具体的观察者，只是保存着抽象观察者的列表，每个具体观察者都符合一个抽象观察者的接口。&lt;/p&gt;&lt;p&gt;    （3）、观察者模式支持广播通信。被观察者会向所有的注册过的观察者发出通知。&lt;/p&gt;&lt;p&gt;    观察者也存在以下一些缺点：&lt;/p&gt;&lt;p&gt;    （1）、如果一个被观察者有很多直接和间接的观察者时，将所有的观察者都通知到会花费很多时间。&lt;/p&gt;&lt;p&gt;    （2）、虽然观察者模式可以随时使观察者知道所观察的对象发送了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎样发生变化的。&lt;/p&gt;&lt;p&gt;    （3）、如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃，在使用观察者模式应特别注意这点。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;四、.NET 中观察者模式的实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     我上面写了一点，“在C#的event中，委托充当了抽象的Observer接口，而提供事件的对象充当了目标对象。委托是比抽象Observer接口更为松耦合的设计。”，其实在Net里面实现的观察者模式做了一些改变，用委托或者说是事件来实现观察者模式。事件我们都很明白，我们可以注册控件的事件，当触发控件的动作时候，相应的事件就会执行，在事件的执行过程中我们就可以做相关的提醒业务。这里关于观察者模式在Net里面的实现就不说了，如果大家不明白，可以多看看相关委托或者事件的相关资料。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    终于写完了，这个模式主要是花在了代码的书写上。因为我写每篇文章的时候，模式实现代码都是当时现想的，要组织代码关系，让其更合理，所以时间就花了不少，但是是理解更好了。该模式不是很难，结构也不是很复杂，唯一让我们多多注意的是状态的管理。这个模式结合实例理解是很容易的，模式的使用我们不能照搬，要理解，当然多多的联系和写代码也是必不可少的，我们使用模式的一贯宗旨是通过重构和迭代，在我们的代码中实现相应的模式。&lt;/p&gt;
</description>
<pubDate>Thu, 30 Nov 2017 05:35:00 +0000</pubDate>
<dc:creator>PatrickLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/7928521.html</dc:identifier>
</item>
<item>
<title>Web App适配iPhoneX - peiyu1988</title>
<link>http://www.cnblogs.com/peiyu1988/p/7928411.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peiyu1988/p/7928411.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Iphone每次退出新尺寸的手机都会掀起一番适配风波,这次没有下巴但有刘海的iPhoneX更是如此,网传横屏下的适配动画更是令不少人汗颜.&lt;/p&gt;
&lt;p&gt;其实对于Native App来说,适配并不算困难(当然追求酷炫效果另算),官方文档有详细的说明,而对于Web App来说,主要还是依靠打开webview的Native App来适配,而这篇文章主要讨论的是Cordova App要如何适配iPhoneX.&lt;/p&gt;
&lt;p&gt;先上一开始没有适配的效果(下面截图均来自模拟器)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1141038/201711/1141038-20171130124520604-1746872679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;适配后效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1141038/201711/1141038-20171130124606901-415311582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;适配步骤如下&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;更新Cordova插件&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先确认使用的cordova插件有是否包含针对iPhone X的release,例如&lt;span&gt;&lt;code&gt;cordova-plugin-splashscreen&lt;/code&gt;&lt;/span&gt;, &lt;span&gt;&lt;code&gt;cordova-plugin-statusbar&lt;/code&gt;&lt;/span&gt;等,而我是用的项目模板的插件版本刚好没有出什么问题,所以我也没有深究具体需要更新到哪些版本.&lt;/p&gt;
&lt;p&gt;而如果使用的是Meteor来打包生成Cordova应用的话,则需要更新Meteor到1.6,而之后运行Meteor也会提醒需要更新哪些插件.&lt;/p&gt;
&lt;p&gt;这对Native适配非常简单,就加一张图片就好了.对于Cordova也没费多大的事,修改一下&lt;span&gt;&lt;code&gt;config.xml&lt;/code&gt;&lt;/span&gt;关于ios启动图配置的部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;platform &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;ios&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 这里只加了针对iphone x的尺寸 1125 * 2436 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;splash &lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;=&quot;2436&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;res/screen/ios/qidong.png&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;1125&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;platform&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;articleHeader3&quot;&gt;&lt;span&gt;&lt;strong&gt;更新HTML viewport meta&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这里的改动主要是添加&lt;span&gt;&lt;code&gt;viewport-fit=cover&lt;/code&gt;&lt;/span&gt;,其他部分可以算是Web App的标准配置了.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;initial-scale=1, width=device-width, height=device-height, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;articleHeader3&quot;&gt;&lt;span&gt;&lt;strong&gt;更新&lt;/strong&gt;&lt;/span&gt;CSS&lt;/h2&gt;
&lt;p&gt;完成上面的配置之后,现在的显示效果应该是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1141038/201711/1141038-20171130125134651-5045551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实离我们的最终效果已经很近了,观察页面就大概知道是页面的顶部往上顶了,其实上面多出来的区域是iPhoneX特有的,苹果称之为安全区(看对比图三和图二的区别可以看出,上面都有所谓的安全区).&lt;/p&gt;
&lt;p&gt;我们要做的其实就是让页面布局在安全区(&lt;span&gt;&lt;code&gt;Safe Area&lt;/code&gt;&lt;/span&gt;)之外的地方.聪明的小伙伴肯定已经想到了,对页面加个&lt;code&gt;padding-top&lt;/code&gt;就可以,但是这个padding值是多少呢?肯定不会hardcode某个具体数值的.对此苹果提供了&lt;span&gt;&lt;code&gt;safe-area-inset-top&lt;/code&gt;&lt;/span&gt;和&lt;span&gt;&lt;code&gt;safe-area-inset-bottom&lt;/code&gt;&lt;/span&gt;可用于css来设定具体的安全区域.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// 前两个css规则主要用于完善framework7(模板项目使用UI库),不一定适用其他项目
html, body &lt;/span&gt;{&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;&lt;span&gt;
  // box-sizing取决于安全区的padding是加在哪个元素上
  box-sizing&lt;/span&gt;:&lt;span&gt; border-box&lt;/span&gt;;
}&lt;span&gt;
html.with-statusbar-overlay .framework7-root &lt;/span&gt;{&lt;span&gt;
  padding-top&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
}&lt;span&gt;

// 主要起效是这里,当然也不一定是加在body上
body &lt;/span&gt;{&lt;span&gt;
  padding-top&lt;/span&gt;:&lt;span&gt; constant(safe-area-inset-top)&lt;/span&gt;;&lt;span&gt;
  padding-bottom&lt;/span&gt;:&lt;span&gt; constant(safe-area-inset-bottom)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里,Cordova项目应该就已经适配好了&lt;/p&gt;

</description>
<pubDate>Thu, 30 Nov 2017 04:54:00 +0000</pubDate>
<dc:creator>peiyu1988</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peiyu1988/p/7928411.html</dc:identifier>
</item>
<item>
<title>WPF开发的彩票程序（练手好例子） 附源码 - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/lottery_wpf.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/lottery_wpf.html</guid>
<description>&lt;p&gt;&lt;span&gt;WPF是.NET最新的界面开发库，开发界面非常灵活！但是学习WPF难度也非常大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;应朋友之邀，编写了一个小程序。程序虽小，五脏俱全，WPF开发的灵活性可窥见一斑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于新手学习有很好的借鉴意义，代码已上传到CSDN可以下载。网址见文章底部。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;   分析彩票的历史记录，根据选取的几个数据，分析记录出现的情况。看下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;左边是历史记录，右边 是选取的数据 68、 8*。从历史记录查找，符合这个逻辑关系的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/245753/201711/245753-20171130130515401-2007645955.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;  我这里分析几个小技术点。&lt;/p&gt;
&lt;h3&gt;   1）ListView不同行颜色设定&lt;/h3&gt;
&lt;p&gt;    ListView 有一个属性 ItemContainerStyleSelector，这个属性可以绑定到一个类，你可以在这个类中，根据每行的属性，设定背景。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ListViewItemStyleSelector : StyleSelector
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Style SelectStyle(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; item,DependencyObject container)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             Style st = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Style();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             st.TargetType = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ListViewItem);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             Setter backGroundSetter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Setter();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             backGroundSetter.Property =&lt;span&gt; ListViewItem.BackgroundProperty;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             ListView listView =ItemsControl.ItemsControlFromItemContainer(container) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ListView;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; index =&lt;span&gt;listView.ItemContainerGenerator.IndexFromContainer(container);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (index % &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 backGroundSetter.Value =&lt;span&gt; Brushes.LightGray;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 backGroundSetter.Value =&lt;span&gt; Brushes.White;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            st.Setters.Add(backGroundSetter);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; st;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 2）数字的显示&lt;/h3&gt;
&lt;p&gt;   ListView 每一列，可以绑定字符串，也可以根据需要绑定控件模版。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &amp;lt;GridView &amp;gt;
&lt;span&gt; 2&lt;/span&gt;                             &amp;lt;GridViewColumn Header=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;序号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; DisplayMemberBinding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding Path=StrNO}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/GridViewColumn&amp;gt;
&lt;span&gt; 3&lt;/span&gt;                             &amp;lt;GridViewColumn Header=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;日期&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; DisplayMemberBinding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding Path=StrTimeStamp}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/GridViewColumn&amp;gt;
&lt;span&gt; 4&lt;/span&gt;                             &amp;lt;GridViewColumn Header=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;期数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; DisplayMemberBinding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding Path=StrVolume}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/GridViewColumn&amp;gt;
&lt;span&gt; 5&lt;/span&gt;                             &amp;lt;GridViewColumn Header=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CellTemplate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{StaticResource ColDigital1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/GridViewColumn&amp;gt;
&lt;span&gt; 6&lt;/span&gt;                             &amp;lt;GridViewColumn Header=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CellTemplate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{StaticResource ColDigital2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/GridViewColumn&amp;gt;
&lt;span&gt; 7&lt;/span&gt;                             &amp;lt;GridViewColumn Header=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CellTemplate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{StaticResource ColDigital3}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/GridViewColumn&amp;gt;
&lt;span&gt; 8&lt;/span&gt;                             &amp;lt;GridViewColumn Header=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CellTemplate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{StaticResource ColDigital4}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/GridViewColumn&amp;gt;
&lt;span&gt; 9&lt;/span&gt;                             &amp;lt;GridViewColumn Header=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CellTemplate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{StaticResource ColDigital5}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/GridViewColumn&amp;gt;
&lt;span&gt;10&lt;/span&gt;                             &amp;lt;GridViewColumn Header=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CellTemplate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{StaticResource ColDigital6}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/GridViewColumn&amp;gt;
&lt;span&gt;11&lt;/span&gt;                             &amp;lt;GridViewColumn Header=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;7列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CellTemplate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{StaticResource ColDigital7}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/GridViewColumn&amp;gt;
&lt;span&gt;12&lt;/span&gt;   &amp;lt;/GridView&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   数字是静态绑定到 ColDigital1，ColDigital2...等，咱看看ColDigital1如何实现的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &amp;lt;DataTemplate x:Key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ColDigital1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;
&lt;span&gt;2&lt;/span&gt;             &amp;lt;StackPanel Margin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5,2,5,2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; HorizontalAlignment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Center&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;3&lt;/span&gt;                 &amp;lt;local:CustomControl_digital x:Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;labelDigital1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; StrDigital=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding Path=StrCol1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/local:CustomControl_digital&amp;gt;
&lt;span&gt;4&lt;/span&gt;             &amp;lt;/StackPanel&amp;gt;
&lt;span&gt;5&lt;/span&gt; &amp;lt;/DataTemplate&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;StackPanel 包含了一个自定义控件CustomControl_digital，这个自定控件实现了对数字的绘制。ListView 绑定一个类，这个类有属性字段StrCol1；自定义控件就从StrCol1获取数据绘制。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomControl_digital : Control
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt;&lt;span&gt; CustomControl_digital()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             StrDigitalProperty =
&lt;span&gt; 6&lt;/span&gt;       DependencyProperty.Register(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StrDigital&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性名称&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性类型&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;typeof&lt;/span&gt;(CustomControl_digital), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该属性所有者，即将该属性注册到那个类上&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;       &lt;span&gt;new&lt;/span&gt; PropertyMetadata(&lt;span&gt;&quot;&quot;&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性默认值&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;             DefaultStyleKeyProperty.OverrideMetadata(&lt;span&gt;typeof&lt;/span&gt;(CustomControl_digital), &lt;span&gt;new&lt;/span&gt; FrameworkPropertyMetadata(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(CustomControl_digital)));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; DependencyProperty StrDigitalProperty;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Color defaultColor = Color.FromRgb(&lt;span&gt;41&lt;/span&gt;, &lt;span&gt;57&lt;/span&gt;, &lt;span&gt;85&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Color BackColor { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } =&lt;span&gt; defaultColor;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetBackColor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (index == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 BackColor =&lt;span&gt; defaultColor;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                 BackColor = Color.FromRgb(&lt;span&gt;62&lt;/span&gt;, &lt;span&gt;175&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; StrDigital
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;)GetValue(StrDigitalProperty); }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt;&lt;span&gt; { SetValue(StrDigitalProperty, value); }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnMouseDoubleClick(MouseButtonEventArgs e)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnMouseDoubleClick(e);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnRender(DrawingContext dc)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnRender(dc);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (StrDigital == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; len =&lt;span&gt; Math.Min(ActualHeight, ActualWidth);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             Point center = &lt;span&gt;new&lt;/span&gt; Point(ActualWidth / &lt;span&gt;2&lt;/span&gt;, ActualHeight / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;             Pen pen = &lt;span&gt;new&lt;/span&gt; Pen(Brushes.Black, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             Brush brush = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SolidColorBrush(BackColor);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; totalRadius = len / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; radius = totalRadius * &lt;span&gt;9&lt;/span&gt; / &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            dc.DrawEllipse(brush, pen, center, radius, radius);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(StrDigital))
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 FormattedText text = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormattedText(StrDigital, CultureInfo.CurrentCulture,
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         FlowDirection.LeftToRight, &lt;span&gt;new&lt;/span&gt; Typeface(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Verdana&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;14&lt;/span&gt;&lt;span&gt;, Brushes.White);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 Point txtPoint = &lt;span&gt;new&lt;/span&gt; Point(center.X - &lt;span&gt;9&lt;/span&gt;, center.Y - &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                dc.DrawText(text, txtPoint);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;源代码下载网址 http://download.csdn.net/download/qq_29939347/10139121&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 30 Nov 2017 04:52:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanchenhui/p/lottery_wpf.html</dc:identifier>
</item>
<item>
<title>kafka原理和实践（一）原理：10分钟入门 - 只会一点java</title>
<link>http://www.cnblogs.com/dennyzhangdd/p/7759869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dennyzhangdd/p/7759869.html</guid>
<description>&lt;p&gt;系列目录&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;singleposttitle&quot; href=&quot;http://www.cnblogs.com/dennyzhangdd/p/7759869.html&quot;&gt;kafka原理和实践（一）原理：10分钟入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_7759875&quot; href=&quot;http://www.cnblogs.com/dennyzhangdd/p/7759875.html&quot;&gt;kafka原理和实践（二）spring-kafka简单实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;singleposttitle&quot; href=&quot;http://www.cnblogs.com/dennyzhangdd/p/7827564.html&quot;&gt;kafka原理和实践（三）spring-kafka生产者源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_7759876&quot; href=&quot;http://www.cnblogs.com/dennyzhangdd/p/7759876.html&quot;&gt;kafka原理和实践（四）spring-kafka消费者源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;singleposttitle&quot; href=&quot;http://www.cnblogs.com/dennyzhangdd/p/7834143.html&quot;&gt;kafka原理和实践（五）spring-kafka配置详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_7759878&quot; href=&quot;http://www.cnblogs.com/dennyzhangdd/p/7759878.html&quot;&gt;kafka原理和实践（六）总结升华&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;=========正文分割线===============&lt;/p&gt;
&lt;p&gt;关于kafka原理网上文章很多，但能真正快速入门的几乎没有（要不就是原文翻译官网...实在枯燥无味之极），本章尽量采用图文的方式，提纲挈领的阐述原理。&lt;/p&gt;
&lt;h2&gt;一、kafka拓扑图&lt;/h2&gt;
&lt;p&gt;大家都知道kafka是依赖zookeeper集群的，一般最少也要三台服务器来实现HA。拓扑图如下，分三层：&lt;/p&gt;
&lt;p&gt;1.Producers:消息生产者，push消息给Brokers.发送时根据不同topic选择不同分区（在Broker上）。&lt;/p&gt;
&lt;p&gt;2.Brokers：注册在zookeeper节点上。&lt;/p&gt;
&lt;p&gt;3.Consumers：消息消费者，从brokers上根据订阅的topic选择不同分区，poll数据，执行消费。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/584866/201711/584866-20171117093650374-1834235910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、名词解释&lt;/h2&gt;
&lt;p&gt;1.producer：消息生产者，发布消息到 kafka 集群的终端或服务。&lt;/p&gt;
&lt;p&gt;2.broker：kafka 集群中包含的服务器。&lt;/p&gt;
&lt;p&gt;3.topic：每条发布到 kafka 集群的消息属于的类别，即 kafka 是面向 topic 的。&lt;/p&gt;
&lt;p&gt;4.partition：partition 是物理上的概念，每个 topic 包含一个或多个 partition。kafka 分配的单位是 partition。&lt;/p&gt;
&lt;p&gt;5.consumer：从 kafka 集群中消费消息的终端或服务。&lt;/p&gt;
&lt;p&gt;6.Consumer group：high-level consumer API 中，每个 consumer 都属于一个 consumer group，每条消息只能被 consumer group 中的一个 Consumer 消费，但可以被多个 consumer group 消费。&lt;/p&gt;
&lt;p&gt;7.replica：partition 的副本，保障 partition 的高可用。&lt;/p&gt;
&lt;p&gt;8.leader：replica 中的一个角色， producer 和 consumer 只跟 leader 交互。&lt;/p&gt;
&lt;p&gt;9.follower：replica 中的一个角色，从 leader 中复制数据。&lt;/p&gt;
&lt;p&gt;10.controller：kafka 集群中的其中一个服务器，用来进行 leader election 以及 各种 failover。&lt;/p&gt;
&lt;p&gt;11.zookeeper：kafka 通过 zookeeper 来存储集群的 meta 信息。&lt;/p&gt;
&lt;h2&gt;三、生产模型&lt;/h2&gt;
&lt;p&gt;kafka生产者多线程异步发送模型如下图，主要包含2个流程：1）数据批量存储,批量发送2）Netty NIO 发送数据&lt;/p&gt;
&lt;p&gt;大概看一下流程，理解个大概即可，具体见后续源码分析章节。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/584866/201711/584866-20171122161814993-837212513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、消费模型&lt;/h2&gt;
&lt;p&gt;根据xml配置的不同启动不同的容器（ConcurrentMessageListenerContainer/MessageListenerContainer）,下图为并发消息监听器容器启动流程，主要包含2个主流程：&lt;/p&gt;
&lt;p&gt;1.从cluster拉取消息&lt;/p&gt;
&lt;p&gt;2.消费消息&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/584866/201711/584866-20171123123259383-2005482311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 30 Nov 2017 04:28:00 +0000</pubDate>
<dc:creator>只会一点java</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dennyzhangdd/p/7759869.html</dc:identifier>
</item>
<item>
<title>把项目中的那些恶心的无处存储的大块数据都丢到FastDFS之快速搭建 - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/7928345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/7928345.html</guid>
<description>&lt;p&gt;　　     在我们开发项目的时候，经常会遇到大块数据的问题（2M-100M），比如说保存报表中1w个人的ID号，他就像一个肿瘤一样，存储在服务器哪里都&lt;/p&gt;
&lt;p&gt;觉得恶心，放在redis，mongodb中吧，一下子你就会收到报警，因为内存满了。。。放在mysql吧？？？你还得建立一个text字段，和一些小字段混在一起，&lt;/p&gt;
&lt;p&gt;还是有点恶心，还得单独拆出来，还得怕有些sql不规范的人挺喜欢select * 的，这速度挺恶心的呀。。。直接放到硬盘吧，没扩展性，你1T大小的硬盘又能&lt;/p&gt;
&lt;p&gt;怎样，照样撑爆你，放在hadoop里面吧，对.net程序员来说，没有这个缘分，好不容易微软有一个.net hadoop sdk，说放弃就放弃了，兼具以上各种特性，&lt;/p&gt;
&lt;p&gt;最后目光只能落到FastDFS上了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一： FastDFS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      fastDFS的本意是一个分布式的文件系统，所以大家可以上传各种小文件，包括这篇和大家说到的那些一坨一坨的数据，同样你也可以认为是一些小文件，&lt;/p&gt;
&lt;p&gt;下面我画一下它的大概架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214741/201711/214741-20171130090736948-1804988009.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我来解释一下：&lt;/p&gt;
&lt;p&gt;1.  fastDFS是按照Group的形式对file进行分组存储的，这里的group1你可以理解成C盘，group2理解成D盘，所有的数据都是在Group来划分的。&lt;/p&gt;
&lt;p&gt;2.  为了提高读取性能和热备份，我们把group1放到了两台机器上，大概可能觉得有点浪费，对吧，事实就是这样。&lt;/p&gt;
&lt;p&gt;3.  为了提高扩展性，因为单机是有存储上限的，这时候你可以再新建一个group2，也就是D盘，放到另外机器上，这样你就扩容了，对吧。&lt;/p&gt;
&lt;p&gt;4.  trackerServer主要用来保存group和storage的一些状态信息，主要和client端进行交互，返回正确的storeage server地址，这个和hadoop的&lt;/p&gt;
&lt;p&gt;     namenode其实是同一个角色的。&lt;/p&gt;
&lt;p&gt;5. 这里要注意的一个地方就是，client端在存储file的时候，需要告诉trackerserver，你需要存储到哪一个group中，比如group1还是group2？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二：下载安装【CentOS】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     为了方便测试，这里我部署到一台CentOS了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1. 下载fastDFS基础包：&lt;a href=&quot;https://github.com/happyfish100/libfastcommon/releases&quot; target=&quot;_blank&quot;&gt; https://github.com/happyfish100/libfastcommon/releases&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214741/201711/214741-20171130091535261-342770865.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 然后下载fast源码包：&lt;a href=&quot;https://github.com/happyfish100/fastdfs/releases&quot; target=&quot;_blank&quot;&gt;https://github.com/happyfish100/fastdfs/releases&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214741/201711/214741-20171130091719558-138615843.jpg&quot; alt=&quot;&quot;/&gt;   &lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. wget之后，先把libfastcommon给安装一下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar -xzvf V1.&lt;span&gt;0.36&lt;/span&gt;&lt;span&gt;
cd libfastcommon&lt;/span&gt;-&lt;span&gt;1.0&lt;/span&gt;.&lt;span&gt;36&lt;/span&gt;&lt;span&gt;
.&lt;/span&gt;/make.sh &amp;amp;&amp;amp; ./make.sh install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  再把fastdfs安装一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar -xzvf V5.&lt;span&gt;11&lt;/span&gt;&lt;span&gt;
cd fastdfs&lt;/span&gt;-&lt;span&gt;5.11&lt;/span&gt;&lt;span&gt;
.&lt;/span&gt;/make.sh &amp;amp;&amp;amp;./make.sh install
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样的话，我们的fast就算安装好了，因为是默认安装，所以配置文件是在 /etc/fdfs目录下，启动服务在/etc/init.d下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# cd /etc/&lt;span&gt;fdfs
[root@localhost fdfs]# ls
 client.conf client.conf.sample storage.conf.sample storage_ids.conf.sample tracker.conf.sample

[root@localhost fdfs]# cd &lt;/span&gt;/etc/&lt;span&gt;init.d
[root@localhost init.d]# ls
fdfs_storaged  fdfs_trackerd  functions  netconsole  network  README
[root@localhost init.d]# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  然后再把两个storage.conf.sample 和 tracker.conf.sample中copy出我们需要配置的文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@localhost fdfs]# cp storage.conf.sample storage.conf
[root@localhost fdfs]# cp tracker.conf.sample tracker.conf
[root@localhost fdfs]# ls
client.conf  client.conf.sample  storage.conf  storage.conf.sample  storage_ids.conf.sample  tracker.conf  tracker.conf.sample
[root@localhost fdfs]# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;  4.  tracker.conf 配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    这个配置文件，主要是配置里面的base_path。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# the base&lt;span&gt; path to store data and log files
base_path=/usr/fast/fastdfs-5.11/data/tracker&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   指定完路径之后，我们创建一个data文件夹和tracker文件夹。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5. storage.conf 配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    这个配置文件，我们主要配置三样东西。&lt;/p&gt;
&lt;p&gt;1.  本storage服务器的groupname，大家看过架构图应该也明白了，对吧。&lt;/p&gt;
&lt;p&gt;2.  为了提高磁盘读写，可以指定本groupname的file存储在哪些磁盘上。&lt;/p&gt;
&lt;p&gt;3. 指定和哪一台trackerserver进行交互。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
# the name of the group &lt;span&gt;this&lt;/span&gt;&lt;span&gt; storage server belongs to
#
# comment or remove &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; item &lt;span&gt;for&lt;/span&gt; fetching &lt;span&gt;from&lt;/span&gt;&lt;span&gt; tracker server,
# &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; &lt;span&gt;this&lt;/span&gt; &lt;span&gt;case&lt;/span&gt;, use_storage_id must &lt;span&gt;set&lt;/span&gt; to &lt;span&gt;true&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tracker.conf,
# and storage_ids.conf must be configed correctly.
&lt;span&gt;group_name&lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt;group1&lt;/span&gt;


# the &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt; path to store data and log files
&lt;/span&gt;base_path=/usr/fast/fastdfs-&lt;span&gt;5.11&lt;/span&gt;/data/&lt;span&gt;storage

# path(disk or mount point) count, &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; value &lt;span&gt;is&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
store_path_count&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;

# store_path#, based &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;if&lt;/span&gt; store_path0 not exists, it&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s value is base_path&lt;/span&gt;
&lt;span&gt;# the paths must be exist
&lt;span&gt;store_path0&lt;/span&gt;&lt;/span&gt;&lt;span&gt;=/usr/fast/fastdfs-5.11/data/storage/0&lt;/span&gt;&lt;span&gt;
#store_path1&lt;/span&gt;=/home/yuqing/&lt;span&gt;fastdfs2

# tracker_server can ocur more than once, and tracker_server format &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt;
#  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;host:port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, host can be hostname or ip address
tracker_server&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;23.152&lt;/span&gt;:&lt;span&gt;22122&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后在data目录下创建storage和0文件夹&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6.启动 FastDFS，可以看到22122的端口已经启动了，说明搭建成功&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# &lt;span&gt;/etc/init.d/&lt;/span&gt;&lt;span&gt;&lt;span&gt;fdfs_trackerd start&lt;/span&gt;
Starting fdfs_trackerd (via systemctl):                    [  OK  ]
[root@localhost &lt;/span&gt;~]# &lt;span&gt;/etc/init.d/&lt;/span&gt;&lt;span&gt;&lt;span&gt;fdfs_storaged start&lt;/span&gt;
Starting fdfs_storaged (via systemctl):                    [  OK  ]
[root@localhost &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;]# netstat -&lt;span&gt;tlnp
Active Internet connections (only servers)
Proto Recv&lt;/span&gt;-Q Send-Q Local Address           Foreign Address         State       PID/&lt;span&gt;Program name    
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;&lt;span&gt; 0.0.0.0:22122 &lt;/span&gt;          &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;4346&lt;/span&gt;/&lt;span&gt;fdfs_trackerd  
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.1&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt;        &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;1786&lt;/span&gt;/&lt;span&gt;dnsmasq        
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;              &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;1129&lt;/span&gt;/&lt;span&gt;sshd           
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;631&lt;/span&gt;           &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;1128&lt;/span&gt;/&lt;span&gt;cupsd          
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0.0.0.0:23000 &lt;/span&gt;          &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;4171&lt;/span&gt;/&lt;span&gt;fdfs_storaged  
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;1556&lt;/span&gt;/&lt;span&gt;master         
tcp6       &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; :::&lt;span&gt;22&lt;/span&gt;                   :::*                    LISTEN      &lt;span&gt;1129&lt;/span&gt;/&lt;span&gt;sshd           
tcp6       &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; ::&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;631&lt;/span&gt;                 :::*                    LISTEN      &lt;span&gt;1128&lt;/span&gt;/&lt;span&gt;cupsd          
tcp6       &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; ::&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;                  :::*                    LISTEN      &lt;span&gt;1556&lt;/span&gt;/&lt;span&gt;master         
[root@localhost &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;]# 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;三：使用C#客户端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     在github上有一个C#的客户端，大概可以使用一下：&lt;a href=&quot;https://github.com/smartbooks/FastDFS.Client&quot; target=&quot;_blank&quot;&gt;https://github.com/smartbooks/FastDFS.Client&lt;/a&gt;   或者通过nuget上搜一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214741/201711/214741-20171130110210136-105445879.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            ConnectionManager.InitializeForConfigSection(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FastDfsConfig()
            {
                FastDfsServer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;FastDfsServer&amp;gt;&lt;span&gt;()
                {
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FastDfsServer()
                    {
                         IpAddress&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.2.25&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                          Port&lt;/span&gt;=&lt;span&gt;22122&lt;/span&gt;&lt;span&gt;
                    }
                }
            });

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; storageNode = FastDFSClient.GetStorageNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; path = FastDFSClient.UploadFile(storageNode, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;10000&lt;/span&gt;], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rsp =&lt;span&gt; FastDFSClient.DownloadFile(storageNode, path);

            Debug.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;上传的文件返回路径:{0}, 下载获取文件大小:{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, path, rsp.Length);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214741/201711/214741-20171130115813245-2138674493.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;好了，本篇就说这么多了，希望对你有帮助。&lt;/p&gt;

</description>
<pubDate>Thu, 30 Nov 2017 04:24:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangxincheng/p/7928345.html</dc:identifier>
</item>
<item>
<title>【原创】京东程序狗作死的创业故事 - Jared.Nie</title>
<link>http://www.cnblogs.com/Romantic/p/7928315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Romantic/p/7928315.html</guid>
<description>


&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;我叫王石云，凤凰古城是我老家地地道道的湖南人，今年三十三岁，儿子两岁老婆是在玩游戏的时候认识的，她是地道的海南土著，人也贤惠做的一手好菜，我60kg的体重保持了有七八年，直到认识她后不就便猛蹿到70kg+了，今年是我在北京漂泊的第八个年头，在城市漂泊很久了，也过够了和老婆孩子聚少离多的日子，总觉得打工始终不是长久之计。老家里常说“工”字不出头，这阵子“创业”的念头始终在脑海里飘散不去，我想去创业、我想当老板。&lt;/p&gt;
&lt;p&gt;在我的印象中，老板们不用干活，最多在办公室甩文件骂人，更多的消遣就是钓鱼，打高尔夫球，出入高级酒店。&lt;/p&gt;
&lt;p&gt;我想象着当了老板后，开着奔驰宝马，右手牵着小三的神气模样，我羡慕老板们在酒桌上觥筹交错，谈笑风生，然后在包房里左拥右抱，好不快活。&lt;/p&gt;
&lt;p&gt;直到当了“老板”以后，我才发现这些都是小说里的情节。老板看起来无比光鲜，其实连个孙子tmd都不如！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;50&quot;&gt;
&lt;p&gt; 去年年关将至的时候，志龙来北京出差，正好联系到了我，于是我们相约一起出来聚聚。来到五道口一家叫“老虎菜”的东北小菜馆。&lt;/p&gt;
&lt;p&gt;志龙是我的湖南老乡还是同一个村的，我记得我初中毕业的时候他正好初一，比我小两岁，长得一表人才。原来也是在广州做业务员，后来开了一间自行车工厂。三年不到，他就在广东买了一套房子，还新买了一辆二手奔驰C200，虽说奔驰最低档次轿车，但毕竟是大奔，这已经甩我好几条街了，人也一点架子都没有。&lt;/p&gt;
&lt;p&gt;酒过三巡，他红着脸，沙哑着嗓子说：“云哥，你不是一直想创业吗？你工作做得再好，也是替老板卖命，你都上班这么些年了，还和嫂子两地分居着，长期这样下去也不是个事儿啊，现在就有个机会摆在你面前。你要不要考虑考虑！”&lt;/p&gt;
&lt;p&gt;听了他的话，我抿了一口二锅头，放下酒杯，看向他。&lt;/p&gt;
&lt;p&gt;看到创业引起我的注意，志龙打了个酒嗝，又说：“我在广州有个朋友他有间贴标厂，经营不善倒闭了，5万元就可以买下所有的机器设备。装修厂房、请工人，就可以开门营业了，你又是搞IT互联网的网上的东西你懂得比我多。不如我们开工厂，工厂由你来管理，你都在大公司在这么久了，还管不好几个小工人！除了分红，还给你开点工资。”&lt;/p&gt;
&lt;p&gt;“那业务这块呢？你虽然有厂子，但是订单也喂不饱一间贴标厂吧。” 我点燃了一支烟，也帮他点上。&lt;/p&gt;
&lt;p&gt;他吸了一口，吐出了一个烟圈，回答我：“订单你不用担心，你只管好工厂就行，我会把我厂里的贴标都交给你做，你之前不是搞过一段时间的photoshop吗，说实话那些简单的设计绝对难不倒你。另外，我找个做自行车外贸的朋友投资，他负责业务这块。”&lt;/p&gt;
&lt;p&gt;“至于资金嘛，你如果没钱就少出一些，我和朋友各投十万元，你投资五万，先把厂子转起来，以后不够钱我们再来想办法。”&lt;/p&gt;
&lt;p&gt;当天晚上我就和老婆商量了一下，她也支持我创业，也支持我慢慢的离开北京去广州，起码离家也更近了，于是我几乎是没怎么犹豫，就答应合作的事情，第二天我就写了辞职报告，当时我在这家公司是中软资源，但凡在北京做IT的没有不知道的吧，那天项目经理约我到小屋里，张经理问我：“你在中软待几年了”，我说：“这是第五个年头了”，感觉真快不知不觉中已经五年了，张经理又说：“你是不是因为待遇的事”，要不然我申请一下今年提前给你调整一次薪水，我说不用了，不是因为薪水的事，您也知道我和老婆孩子一直两地分居，这么长期下去也不是个事，张经理看我去意已决，草草的给我签了字，话说外包公司的入职离职效率真是高，下午就去厂洼路办理了离职手续，转设备、转资产、停账号、拿离职报告一气呵成比撸代码畅快多了，最后来到学院路和老战友们吃了个散伙饭，一一道别，就这样草率的离职了。由于和同事合租房子，租金押金的事全部交给同事了，于是当天晚上买了一趟G71一早就出发了，心想到创业当老板，在火车上几次差点没笑出声来。谁知道这是我最近一年来最后一次这么开心的笑，虽然当时我还不知道自己有多么轻薄和草率。&lt;/p&gt;
&lt;p&gt;来到广州先是住到志龙的家里，志龙也在湖南老乡的介绍下，很快就找了合适的厂房，一切都挺顺利，那天晚上我俩又计划了一些人生梦想，一直很晚才睡去。第二天花了一天的时间，请了货车把机器设备挪到厂房里。&lt;/p&gt;
&lt;p&gt;先办理营业执照、生产许过证，至于商标我之前摸索过一段时间的photoshop简单的做个图妥妥的没问题，接下来做招牌。&lt;/p&gt;
&lt;p&gt;与此同时，开始装修车间同时我也负责监工，一直忙到大年三十，工人们回去后，我才回老家过年。平时回家过年都是很高兴的事，但这个年过得很仓促，年初四就从家里过来了。这些事一直瞒着家里父母。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;blockquote readability=&quot;37&quot;&gt;
&lt;p&gt; 装修和水电安装，足足搞了两个多月才结束，刚开始根本没有经验延误了请人的最佳时机。&lt;/p&gt;
&lt;p&gt;年后，该上班的人都已经上班了，而那些不急着上班的人，也都是些不差钱的。&lt;/p&gt;
&lt;p&gt;开工厂，需要招聘师傅、普工、设计师。不开厂不知道，原来人工成本这么吓人，自己打工的时候都是觉得自己工资少，即使如此还是很难招到人。也正好赶上年后广州的用工荒，一个看似不起眼的小姑娘看着不过二十，开口敢要4k，要知道程序猿刚开始走上岗位的时候应该大部分都没有这么多，至少我没有。&lt;/p&gt;
&lt;p&gt;更没想到，请普工都遇到了难题。&lt;/p&gt;
&lt;p&gt;厂子所在的地方较偏僻，面试者得知不包吃住，看到七零八落的机器设备，得知上班前还要搞卫生，答应来上班的人，第二天人影都没见到一个。&lt;/p&gt;
&lt;p&gt;那段时间，我天天发愁，为装修进度发愁，为请工人发愁，整夜地失眠。&lt;/p&gt;
&lt;p&gt;请不到人，只好我们自己清理厂房，装修后，地面上有很多凝固的水泥渍和灰尘，得一点点的清理。一天下来，拿铲子的手起泡了、腰也酸了，变得灰头土脸的，累得似乎要散架。&lt;/p&gt;
&lt;p&gt;三月份，人员终于配齐，机器也擦得油光可鉴，地板拖得可以看出倒影来。&lt;/p&gt;
&lt;p&gt;为图吉利，我们挑了个吉日开工，吉时是早上八点钟。我们买来一圈鞭炮，工厂大门外响起了噼噼啪啪的鞭炮声，在硫磺味和如花瓣般的红色碎纸片中，工厂算是开始正式开张了。&lt;/p&gt;
&lt;p&gt;志龙工厂的贴标，慢慢地都转到我的贴标厂来，设计先行，要核标，出菲林，事情一下子堆在一起，后来又请了两个毛头设计师都忙不过来。&lt;/p&gt;
&lt;p&gt;他们也开始有怨言，有人还不配合加班，但我又不好骂他们，有时候着急，说话重了点，都怕把人给得罪了。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;blockquote readability=&quot;45&quot;&gt;
&lt;p&gt; 原来以为，当老板有多牛逼，我现在才发现，在客户面前是孙子，在员工面前，依然是孙子。&lt;/p&gt;
&lt;p&gt;我特别怕员工辞职，因为招人很难。有能力的，要求工资很高，没能力的，工作上老是出错。&lt;/p&gt;
&lt;p&gt;有一次，一个设计师不小心把稿件做错了，白白浪费了菲林（一种做印刷的底片），还影响了交货期。&lt;/p&gt;
&lt;p&gt;还有一次，工人把错误的稿件印成了贴标，后来客户发现，直接要求返工。&lt;/p&gt;
&lt;p&gt;在这个时候，志龙他只考虑他的立场，被他骂也是常有的事，我每次去他的工厂处理次品的时候，对着车间主管还有业务，只能像孙子一样一脸死肉陪着笑。&lt;/p&gt;
&lt;p&gt;正好，那时共享单车的势头正旺，我们居然还接了ofo的单子，订单量很多，这样算起来利润还算可以。加上另外又接了几个小活，工人们开始没日没夜地加班。&lt;/p&gt;
&lt;p&gt;俗话说：“慢工出细活，欲速则不达”。赶工出来的产品，品质就很容易出问题，接着是很麻烦的返工。有时会出现交货不及时，又被催货，再着再赶工，简直是恶性循环。一切都是因为没有任何一点点经验。&lt;/p&gt;
&lt;p&gt;当了老板之后，我才发现，有订单愁，没订单更愁。&lt;/p&gt;
&lt;p&gt;有订单的时候，前期投了很多人力和金钱，把货赶出来，但是因为公司规模实在太小了，太弱势了，后面的款太难催，又不敢得罪客户。而工厂各项花费，又比想象中多很多。&lt;/p&gt;
&lt;p&gt;每天早上睁开眼睛，脑子里就会想起，今天会有多少开支。&lt;/p&gt;
&lt;p&gt;麻雀虽小，五脏俱全。厂子虽小，但是应该有的，一样都不能少。要投入的钱越来越多，得买空调，买冰箱，买新电脑，买材料……钱好像扔进了一个无底洞里，货款还没收回，之前投的钱很快就花得差不多了。&lt;/p&gt;
&lt;p&gt;每次出纳找我签单或报销，只要看到超过三位数的支出，我的手就会开始发抖。&lt;/p&gt;
&lt;p&gt;志龙和他的朋友，这时不愿意再投钱了，ofo的订单也开始暂停，货款什么时候给，还不一定。前期菲林和晒网版的钱是一笔大的投入，如果没有返单，等于是白忙活。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;blockquote readability=&quot;35&quot;&gt;
&lt;p&gt;当了老板之后，我才发现，焦虑是一种常态。创业者常说，睡眠就和婴儿一样，睡一会儿，哭一会儿。虽然我这远算不上什么创业者。&lt;/p&gt;
&lt;p&gt;这时，开始有供应商上门催债。有人追不到货款，就在办公室坐着不走了。&lt;/p&gt;
&lt;p&gt;我催了志龙几次，他才心不甘情不愿地，再拿了一部分钱出来。我虽在董事长的位置，从头到尾，都不是最终拍板的人，一切都是志龙说了算这很尴尬。&lt;/p&gt;
&lt;p&gt;从开工厂开始，我整日地上班，晚上也加班，就连周末，也得去工厂看着才行。&lt;/p&gt;
&lt;p&gt;有时需要陪客户加班，有时需要应酬。每天晚上回到家，都是凌晨的事情了。当了老板之后，才知道，别说找小三了，连自家的“田”都没空耕。&lt;/p&gt;
&lt;p&gt;有时心情不好，就离不开烟和酒，加上休息不好，我发现，头发白了不少。&lt;/p&gt;
&lt;p&gt;广州的印刷行业，要求越来越严，不是安监就是环保上门，贴标厂属于丝印性质，使用的油漆和其他的化学物质，污染很严重。&lt;/p&gt;
&lt;p&gt;因为藏在厕所的十几桶洗网水，被逮了个正着。最后环保部门提出整改，还要罚款十二万。&lt;/p&gt;
&lt;p&gt;交了罚款，还需要整改，而且资金链已经断了。股东们一致决定：关掉工厂！&lt;/p&gt;
&lt;p&gt;最终清算下来，我们的原始资金拿不回来了，除此多外，我们还要倒贴三万元，浪费了将近一年的时间。创业就此结束了。&lt;/p&gt;
&lt;p&gt;当了老板以后，我才知道，不努力一把，根本不知道什么叫绝望。各种心酸，五味杂陈……&lt;/p&gt;
&lt;/blockquote&gt;



&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;很长一段时间我自己一人呆在屋子里，好像做了一场很长很长的梦，还好像愣了很久一直没有人把你拍醒，就这样浑浑噩噩的过了一周，于是我简单的和志龙做了告别，先是回到了湖南老家，因为这中间只和老婆联系，家里父母还不知道我辞职开厂去了，老爸问我，你咋回来了，这副灰头土脸的，我说前阵子公司项目加班比较多，弄了些调休这不回来休息几天。&lt;/p&gt;
&lt;p&gt;人生从来没这么被彻头彻尾的打击过，说实话都没有一点点心理准备，但看看旁边叽叽哇哇的儿子，不管怎么样，日子还得过，我得为老婆孩子负责，毕业这些年我能挣到的钱，还是当程序猿的时候挣得那点工资，现在才体会到安安静静坐在办公室里撸代码，真tmd是最幸福的事情。和老婆商量了一下，我还是得重新抓起鼠标扛起键盘当个程序猿，不知道为何提起“程序猿”这三个字我感觉无比的暖心和舒坦，于是重新回到了北京，也真是天意，我原来住的那间房子的小伙住了一年正准备要搬走，我推开门进去的时候他正在收拾东西，我通过他那不安的眼神看的出来，他最近生活上也出了一些变故，但愿上天请保佑他不会是像我当时一样想着去“创业”。&lt;/p&gt;
&lt;p&gt;北京是我工作生活了多年的城市，适应这里的生活我只用了不到半天时间，接下来就是准备各种面试，在朋友N君大学同学的内推下我去了京东，做京东金融项目的SDET软件开发测试工程师。至少接下来很长很长的一段时间我会老老实实的做好自己的程序猿工作，跟着东哥相信一定有肉吃有酒喝，即便没有我也不会再去“作死创业”了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/IN3rCM7gLSb3rtz65aSlT9hNKb8O3XYS7f1JJU2lbvyCMwAqkrN0JMfKIVyMkyFn85RKvUc30NQMmicwlPHtYxQ/0?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.05278592375366569&quot; data-w=&quot;341&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/IN3rCM7gLSZa87GQJz3fGXMAnXWtkqIiaqptmMwgsTIU3NC5G5KXy19iamKdeGLRPzx2xWof7qO41rWmicSs7XcDQ/0?wx_fmt=jpeg&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-w=&quot;600&quot; data-backw=&quot;556&quot; data-backh=&quot;556&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ID：coder-story&lt;/p&gt;
&lt;p&gt;如果喜欢请扫描二维码，关注我的个人公众号《程序员故事会》，这里没有枯燥乏味的技术，只有轻松有趣和程序员相关的真实故事。&lt;/p&gt;

</description>
<pubDate>Thu, 30 Nov 2017 04:08:00 +0000</pubDate>
<dc:creator>Jared.Nie</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Romantic/p/7928315.html</dc:identifier>
</item>
</channel>
</rss>