<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Ubuntu Mininet环境搭建 - L晓幽灵</title>
<link>http://www.cnblogs.com/Lxiaoyouling/p/8617433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lxiaoyouling/p/8617433.html</guid>
<description>&lt;p&gt;我们通过源码方式搭建mininet仿真平台，使用git下载mininet源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
git clone git://github.com/mininet/mininet
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　下载完成之后，使用下面命令选择安装版本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
cd mininet
git tag  # list available versions
git checkout -b 2.2.1 2.2.1  # or whatever version you wish to install
cd ..
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　版本选择完成后，使用下面命令进行安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
mininet/util/install.sh [options]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　options选项包括：&lt;/p&gt;
&lt;p&gt;　　-a :安装所有mininet包含的东西，包括OVS交换机，wireshark和POX控制器&lt;/p&gt;
&lt;p&gt;　　-nfv :安装Mininet，OpenFlow相关的交换机和OVS交换机&lt;/p&gt;
&lt;p&gt;　　-s mydir :在options选项之前使用你自己定义的目录来构建 source/build 树&lt;/p&gt;
&lt;p&gt;　安装完成后，使用下面命令来检测Mininet的基本功能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
sudo mn --test pingall
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 21 Mar 2018 07:40:00 +0000</pubDate>
<dc:creator>L晓幽灵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Lxiaoyouling/p/8617433.html</dc:identifier>
</item>
<item>
<title>MSIL实用指南-创建方法和定义参数 - Z语言</title>
<link>http://www.cnblogs.com/tkt2016/p/8617438.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tkt2016/p/8617438.html</guid>
<description>&lt;p&gt; 本篇讲解实现创建方法、指定参数的名称、实现参数加out和ref修饰符、以及参数加默认值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建方法用类TypeAttributes的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
DefineMethod(&lt;span&gt;string&lt;/span&gt; name, MethodAttributes attributes, Type returnType, Type[] parameterTypes)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法，返回结果是MethodBuilder，就可以创普通方法。&lt;/p&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
MethodBuilder m2 = typeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;M2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
MethodAttributes.Public &lt;/span&gt;| MethodAttributes.Abstract |&lt;span&gt; MethodAttributes.Virtual,
&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;object&lt;/span&gt;) });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个写法就和下面的C#程序一样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; M1();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;定义一个抽象方法需要用MethodAttributes的Abstract|Virtual才可以。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用MethodBuilder的DefineParameter(int position, ParameterAttributes attributes, string strParamName)&lt;/p&gt;
&lt;p&gt;方法&lt;/p&gt;
&lt;p&gt; 参数说明&lt;/p&gt;
&lt;p&gt;position:该参数在参数列表中的位置。为参数编索引，&lt;strong&gt;第一个参数从数字 1 开始&lt;/strong&gt;；数字 0 表示方法的返回值。&lt;/p&gt;
&lt;p&gt;attributes: 参数的参数属性。&lt;/p&gt;
&lt;p&gt;strParamName: 参数名。名称可以为 null 字符串。&lt;/p&gt;
&lt;p&gt;返回结果:&lt;/p&gt;
&lt;p&gt;返回一个 ParameterBuilder 对象，该对象表示此方法的参数或此方法的返回值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;指定参数的名称&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在程序的方法调用中传入第三个参数传入参数名称就可以了。&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
MethodBuilder m2 = typeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;M2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
               MethodAttributes.Public &lt;/span&gt;| MethodAttributes.Abstract |&lt;span&gt; MethodAttributes.Virtual,
               &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;) });

m2.DefineParameter(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, ParameterAttributes.None, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arg0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
m2.DefineParameter(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, ParameterAttributes.None, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
m2.DefineParameter(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, ParameterAttributes.None, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个方法的三个参数名称依次是arg0、param1、param2。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;指定参数out&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们要实现如下方法，参数的修饰符是out&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; mout(&lt;span&gt;out&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; arg3 );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要使用ParameterAttributes.Out就可以了。&lt;/p&gt;
&lt;p&gt;具体实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
MethodBuilder m5 = typeBuilder.DefineMethod(&quot;mout&quot;,
               MethodAttributes.Public | MethodAttributes.Abstract | MethodAttributes.Virtual,
               typeof(string), new Type[] { typeof(int), typeof(int) });

            ParameterBuilder m5p1 = m5.DefineParameter(1, ParameterAttributes.Out, &quot;arg3&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;strong&gt;实现参数默认值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要实现参数有默认值，比如下面这句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; mdefault(&lt;span&gt;int&lt;/span&gt; arg1 =&lt;span&gt;4&lt;/span&gt; );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现这个效果的程序是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
MethodBuilder m3 = typeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mdefault&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
               MethodAttributes.Public &lt;/span&gt;| MethodAttributes.Abstract |&lt;span&gt; MethodAttributes.Virtual,
               &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) });

            ParameterBuilder m3p1 &lt;/span&gt;= m3.DefineParameter(&lt;span&gt;1&lt;/span&gt;, ParameterAttributes.HasDefault | ParameterAttributes.Optional, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            m3p1.SetConstant(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现定义参数属性为ParameterAttributes.HasDefault | ParameterAttributes.Optional，并得到一个&lt;/p&gt;
&lt;p&gt;ParameterBuilder实例，再设置这个实例的默认值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt;&lt;strong&gt;实现指定参数ref&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们要实现如下方法，参数的修饰符是out&lt;/p&gt;
&lt;p&gt;public abstract string mref(ref dobule arg2);&lt;/p&gt;

&lt;p&gt;首先&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
MethodBuilder m4 = typeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mref&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
               MethodAttributes.Public &lt;/span&gt;| MethodAttributes.Abstract |&lt;span&gt; MethodAttributes.Virtual,
               &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Type[] { Type.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Double&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数的类型不是一般的typeof(double)，而要用特殊的Type.GetType(&quot;System.Double&amp;amp;&quot;)&lt;/p&gt;

&lt;p&gt;其次&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ParameterBuilder m4p1 = m4.DefineParameter(&lt;span&gt;1&lt;/span&gt;, ParameterAttributes.Out, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arg2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;要设置参数的属性为ParameterAttributes.Out&lt;/p&gt;

&lt;p&gt;完整程序如下&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49.5&quot;&gt;&lt;img id=&quot;code_img_closed_ad18a532-b5ad-412e-80e5-1c3e9d91db9b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ad18a532-b5ad-412e-80e5-1c3e9d91db9b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ad18a532-b5ad-412e-80e5-1c3e9d91db9b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;94&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Reflection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Reflection.Emit;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; LX1_ILDemo
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo07_Method
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; binaryName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Demo07_Method.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; namespaceName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LX1_ILDemo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; typeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EmitMethod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; AssemblyBuilder assemblyBuilder;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; ModuleBuilder moduleBuilder;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; TypeBuilder typeBuilder;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Generate()
        {
            InitAssembly();

            typeBuilder &lt;/span&gt;= moduleBuilder.DefineType(namespaceName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; typeName,
                TypeAttributes.Public &lt;/span&gt;|&lt;span&gt; TypeAttributes.Abstract);

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 生成 public static void Main() &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            GenerateMethods();

            SaveAssembly();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生成成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GenerateMethods()
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; public abstract void M1(); &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            MethodBuilder m1 &lt;/span&gt;= typeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;M1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                MethodAttributes.Public &lt;/span&gt;| MethodAttributes.Abstract |&lt;span&gt; MethodAttributes.Virtual,
                &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;void&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Type[] { });

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; public abstract string M2(int arg0,string param1); &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            MethodBuilder m2 &lt;/span&gt;= typeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;M2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
               MethodAttributes.Public &lt;/span&gt;| MethodAttributes.Abstract |&lt;span&gt; MethodAttributes.Virtual,
               &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;) });

            m2.DefineParameter(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, ParameterAttributes.None, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arg0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            m2.DefineParameter(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, ParameterAttributes.None, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            m2.DefineParameter(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, ParameterAttributes.None, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; public abstract string mdefault(int arg1 =4 ); &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            MethodBuilder m3 &lt;/span&gt;= typeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mdefault&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
               MethodAttributes.Public &lt;/span&gt;| MethodAttributes.Abstract |&lt;span&gt; MethodAttributes.Virtual,
               &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) });

            ParameterBuilder m3p1 &lt;/span&gt;= m3.DefineParameter(&lt;span&gt;1&lt;/span&gt;, ParameterAttributes.HasDefault | ParameterAttributes.Optional, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            m3p1.SetConstant(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; public abstract string mref(ref dobule arg2); &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            MethodBuilder m4 &lt;/span&gt;= typeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mref&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
               MethodAttributes.Public &lt;/span&gt;| MethodAttributes.Abstract |&lt;span&gt; MethodAttributes.Virtual,
               &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Type[] { Type.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Double&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) });

            ParameterBuilder m4p1 &lt;/span&gt;= m4.DefineParameter(&lt;span&gt;1&lt;/span&gt;, ParameterAttributes.Out, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arg2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);


            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; public abstract string mout(out int arg3 ); &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            MethodBuilder m5 &lt;/span&gt;= typeBuilder.DefineMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
               MethodAttributes.Public &lt;/span&gt;| MethodAttributes.Abstract |&lt;span&gt; MethodAttributes.Virtual,
               &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) });

            ParameterBuilder m5p1 &lt;/span&gt;= m5.DefineParameter(&lt;span&gt;1&lt;/span&gt;, ParameterAttributes.Out, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arg3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }


        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitAssembly()
        {
            AssemblyName assemblyName &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AssemblyName(namespaceName);
            assemblyBuilder &lt;/span&gt;=&lt;span&gt; AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave);
            moduleBuilder &lt;/span&gt;=&lt;span&gt; assemblyBuilder.DefineDynamicModule(assemblyName.Name, binaryName);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SaveAssembly()
        {
            Type t &lt;/span&gt;= typeBuilder.CreateType(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成Type，这是必须的&lt;/span&gt;
&lt;span&gt;            assemblyBuilder.Save(binaryName);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 21 Mar 2018 07:40:00 +0000</pubDate>
<dc:creator>Z语言</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tkt2016/p/8617438.html</dc:identifier>
</item>
<item>
<title>&quot;码率适配限速”,如何使带宽成本减少30%? - 又拍云</title>
<link>http://www.cnblogs.com/upyun/p/8617376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upyun/p/8617376.html</guid>
<description>&lt;p&gt;3月28日、29日，B站、爱奇艺即将先后完成IPO。爱奇艺的招股书显示，爱奇艺依然处于亏损状态。2015 年、2016 年、2017 年三年合计亏损约 94 亿元。高昂的版权费是造成视频网站亏损的重要原因，在版权费之外，带宽费用也是一笔不菲的开支。&lt;/p&gt;
&lt;p&gt;在优质 IP 稀缺的情况下，版权费高昂的现象一时间无法缓解。但通过技术的升级，视频网站的带宽成本能够被大幅节省。&lt;/p&gt;
&lt;h2&gt;视频边下边播场景的成本分析&lt;/h2&gt;
&lt;p&gt;我们都知道通过采用更加先进的视频编码格式，比如 H.265 ，或者使用 CDN 降低源站带宽等方式，可以实现节省带宽成本的目的。&lt;/p&gt;
&lt;p&gt;那么除了上述的常规操作之外，还有其他方法可以降低带宽成本吗？下面我们将问题具化到边下边播的视频点播场景中一步步探究。&lt;/p&gt;
&lt;p&gt;在边下边播的视频点播场景里，终端用户普遍具有挑选心理，不会完整观看一个视频，打开一个视频观看一段时间后，不喜欢就会关闭，继续看下一个视频，这样之前预下载的那部分视频其实是被浪费的。&lt;/p&gt;
&lt;p&gt;如果在终端用户选择这个视频时不限速的话，一打开视频，终端设备、客户端就开始疯狂的下载视频，带宽有多大就下载多少数据。这样固然保证了终端客户的体验，但在用户切换视频的过程中，也会产生大量的额外带宽成本。因此对视频限速是一种控制带宽成本的有效方式。&lt;/p&gt;
&lt;h2&gt;码率适配限速——高效视频点播限速方式&lt;/h2&gt;
&lt;p&gt;在不影响用户体验的情况下，限制视频文件的下载速度，节省带宽成本，做到这点就可以有效减少视频点播的带宽成本。&lt;/p&gt;
&lt;p&gt;举例来说某视频码率为 1337 Kbps，正常情况下一打开就会以超过码率十倍的速度进行下载。当视频下载 3 秒之后，我们可以对它进行码率限速，按照 1.1 倍码率进行限速，即(1337/8)*1.1 = 183 KB/s。&lt;/p&gt;
&lt;p&gt;又拍云 CDN 平台目前视频点播文件已支持码率适配限速功能，可以自动智能分析当前视频文件传输的码率，获取视频文件的码率之后，将视频文件的下载速度控制在视频码率的 N 倍，做到节省流量成本，防止高峰期时带宽占用。（这里的 N 也即限速因子，推荐值为 1.1）&lt;/p&gt;
&lt;p&gt;当一个视频播放时，我们可以在视频播放开始选择不限速，当播放时长超过 3 秒后，进行 1.1 倍码率限速，根据限速因子的数值不同，可以节省 20% ~ 30% 不等的流量成本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/585973/201803/585973-20180321153153873-2034072635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;△ 码率适配限速开启前后对比&lt;/p&gt;
&lt;h2&gt;开启码率适配限速功能&lt;/h2&gt;
&lt;p&gt;登陆又拍云控制台，依次进入：服务管理 &amp;gt; 功能配置 &amp;gt; 性能优化 &amp;gt; 码率适配限速，再点击“管理”按钮，进入功能配置界面即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/585973/201803/585973-20180321153210325-1389371318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;添加规则&lt;/h2&gt;
&lt;p&gt;进入配置界面后依次进行如下操作：&lt;/p&gt;
&lt;p&gt;1.滑动开关：将配置界面左上角的开关由关闭状态调整为开启状态；&lt;/p&gt;
&lt;p&gt;2.添加规则：点击配置界面右上角的“添加规则”按钮即可添加码率适配限速规则，配置界面如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/585973/201803/585973-20180321153224583-1276812336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div data-reactid=&quot;50&quot; readability=&quot;7.0154109589041&quot;&gt;
&lt;div class=&quot;RichText Post-RichText&quot; data-reactid=&quot;51&quot; readability=&quot;33.323270440252&quot;&gt;
&lt;p&gt;在规则配置界面，依次需要进行资源路径、限速策略、限速因子的配置。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;资源路径：也即对请求的 URI 进行匹配，匹配成功则进入限速逻辑，支持 * 通配符，例如：/mnt/download/*.mp4；&lt;/li&gt;
&lt;li&gt;限速策略：表示从某个时刻（下载时间，不是播放时间）开始执行限速策略，支持秒和分钟配置，默认推荐 3 秒；&lt;/li&gt;
&lt;li&gt;限速因子：用来控制 mp4 文件下载限速的因子，指定下载速度为视频码率的多少倍，推荐值为 1.1。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;编辑、删除规则&lt;/h2&gt;
&lt;p&gt;当需要对规则进行编辑或者删除时，可以在操作区域点击【编辑】、【删除】按钮即可编辑和删除规则。&lt;/p&gt;
&lt;p&gt;了解详情：&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=http%3A//docs.upyun.com/cdn/config/%2343&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;码率适配限速&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;a class=&quot;LinkCard LinkCard--hasImage&quot; href=&quot;https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/156/%25E5%25A6%2582%25E4%25BD%2595%25E9%2580%259A%25E8%25BF%2587%25E5%258F%2588%25E6%258B%258D%25E4%25BA%2591WebP%25E5%2585%25BC%25E5%25AE%25B9%25E6%2596%25B9%25E6%25A1%2588%25E6%259D%25A5%25E5%2587%258F%25E5%25B0%2591%25E5%259B%25BE%25E7%2589%2587%25E4%25BD%2593%25E7%25A7%25AF%25EF%25BC%259F.html&quot; target=&quot;_blank&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-28c2a15f05ba4a773b17d30a573357d7_180x120.jpg&quot; data-image-width=&quot;960&quot; data-image-height=&quot;346&quot; data-za-detail-view-id=&quot;172&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;如何通过又拍云WebP兼容方案来减少图片体积？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;

&lt;div class=&quot;RichText Post-RichText&quot; data-reactid=&quot;51&quot;&gt;&lt;a class=&quot;LinkCard LinkCard--noImage&quot; href=&quot;https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/287/%25E5%25B9%25B3%25E5%259D%2587%25E8%258A%2582%25E7%259C%2581%25E6%25B5%2581%25E9%2587%258F%252030%2525%2520%25EF%25BC%258C%25E8%25BF%2599%25E9%25A1%25B9%25E8%25A7%2586%25E9%25A2%2591%25E4%25BA%2591%25E5%25A4%2584%25E7%2590%2586%25E6%258A%2580%25E6%259C%25AF%25E6%2598%25AF%25E5%25A6%2582%25E4%25BD%2595%25E5%25AE%259E%25E7%258E%25B0%25E7%259A%2584%25EF%25BC%259F.html&quot; target=&quot;_blank&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-za-detail-view-id=&quot;172&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;平均节省流量 30% ，这项视频云处理技术是如何实现的？&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 21 Mar 2018 07:33:00 +0000</pubDate>
<dc:creator>又拍云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/upyun/p/8617376.html</dc:identifier>
</item>
<item>
<title>正则表达式入门+实战（c#实现） - JAZzzzzzzz</title>
<link>http://www.cnblogs.com/jazzpop/p/8615803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jazzpop/p/8615803.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;　　如果有人和你说，如果不将字符串转换为数字，你要如何判断字符串是否由全数字组成？把字符串拆成char数组，然后放入一个循环，来判断每个char是否为数字？那你要如何判断手机号是否合法？IP是否合法呢？把字符串拆成char数组总不是个办法啊，是否有更好的解决办法？有的，正则表达式就是。正则表达式是什么？可以这么说，它是一种字符串语法，可以形容字符串的格式。本文就来介绍正则表达式，就像我在其他博客中讲过的，我不喜欢把所有规则列出来，规则在网上一搜一大把。我要讲的是正则表达式究竟能够做什么，怎么使用正则表达式。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;　　维基百科中，正则表达式的解释为：正则表达式（英语：&lt;span lang=&quot;en&quot;&gt;Regular Expression、&lt;span lang=&quot;en&quot;&gt;regex或&lt;span lang=&quot;en&quot;&gt;regexp，缩写为&lt;span lang=&quot;en&quot;&gt;RE），也译为正规表示法、常规表示法，在计算机科学中，是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。没错，正则表达式也是一个字符串，只不过这个字符串能够用来判断另一个字符串是否满足一定规则，如是否由全数字组成，是否是合法的手机号码，是否是合法的IP。只要掌握了正则表达式，你就相当于掌握了一种描述正则表达式的语法，当然这种语法不是用来和人交流的，而是和”机器“交流的，你只要打出&lt;span&gt;&lt;strong&gt;^((\w)(\w)\1\2)+$&lt;/strong&gt;&lt;/span&gt;机器就能告诉你一个字符串是否长成ababab...这样。下面我来讲解正则表达式。我不会列出所有语法，因为网上很多，如果你懒得找，这里有个网址 &lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jquery/regexp.html&quot; target=&quot;_blank&quot;&gt;正则表达式手册&lt;/a&gt;，这里有全部的语法，如果你看不懂，或者记不得了，打开看一下就可以了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;　　我会以Lesson的形式，先介绍实例，然后详细分析实例，因为正则表达式的规则确实很难记，但是能达到的效果是很好记的，只要你看过有人实现了利用正则表达式来判断一个字符串是否由全数字组成，那么你就再也不会忘了，下次再有类似的要求的时候，你至少知道用正则表达式来做会很简单，那么剩下的就是翻出正则表达式的手册，研究一阵子，自然就出来了，因为虽然规则难记，但是很好理解。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;Lesson1 判断字符串是否由全字符组成。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;　　该题的想法很简单，从”头“到”尾“，全是数字就可以了。打开手册，看到表示开头的字符是&lt;span&gt;&lt;strong&gt;^&lt;/strong&gt;&lt;/span&gt;，表示结尾的字符是&lt;span&gt;&lt;strong&gt;$&lt;/strong&gt;&lt;/span&gt;，表示数字的字符是&lt;strong&gt;&lt;span&gt;\d&lt;/span&gt;&lt;/strong&gt;，然后看到想要匹配多个字符，有两个选择，+和*，+是至少出现一次，*是0次或者多次，&lt;strong&gt;&lt;span&gt;^\d+$&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。这就完成了！好，让我们来试一试。在c#中，正则表达式相关的类是System.Text.RegularExpressions.Regex，其中我用到的方法有Match，Replace，和IsMatch，分别是匹配，替换和判断是否匹配的便捷方法。用法也很简单，看下我的例子就会明白了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RegexExtension
{&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将匹配信息转换为字符串信息&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Convert2String(&lt;span&gt;this&lt;/span&gt; Match match, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; enter)
    {
        StringBuilder builder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        builder.AppendFormat(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;匹配的字符串为：{0}， 是否匹配成功{1}， 匹配到的字符串为{2}， 匹配的位置为{3}， 匹配的长度为{4},一共匹配到{5}个结果&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            enter, match.Success, match.Value, match.Index, match.Length, match.Groups.Count);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder.ToString();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Lesson1(){
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;全数字的判断：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] enters = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123123123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123a123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a123123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; enter &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enters){
        Console.WriteLine(
            Regex.Match(enter, &lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;^\d+$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Convert2String(enter));
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　Regex.Match方法会将enter与规则进行匹配，然后将结果转换为字符串，例子中只有 ”&lt;strong&gt;123123123“ &lt;/strong&gt;会匹配成功，其他都是失败，即使”&lt;strong&gt;0&lt;/strong&gt; “也会失败，是因为有空格，而\d只会匹配数字。是不是很简单？下面来看第二课。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;Lesson2 判断号码是否为合法的座机或者手机号码&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; 　　判断号码是否为固话或者手机号，固话是7-8位，手机为11位，这时就需要2种情况都可以匹配，先看固话，全是数字已经会了，是&lt;span&gt;&lt;strong&gt;^\d+$&lt;/strong&gt;&lt;/span&gt; ，只要加上个数的限制就可以了，查看手册，发现&lt;strong&gt;&lt;span&gt;{m,n}&lt;/span&gt; &lt;/strong&gt;描述有几个字符，m表示最少出现的次数，n表示最多出现的次数。那么 &lt;strong&gt;&lt;span&gt;+&lt;/span&gt;&lt;/strong&gt;字符就应该是和&lt;span&gt;&lt;strong&gt;{1，}&lt;/strong&gt;&lt;/span&gt; 一样，不填n表示不限制最大次数，那么m不填就表示不限制最小次数。然后是手机，手机为11位，且由1开头，且都为数字，那么就很简单了：&lt;span&gt;&lt;strong&gt;^1\d{10}$&lt;/strong&gt;&lt;/span&gt;。如何把他们拼起来？字符 | 可以办到，下面是代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Lesson2(){
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;是否为合法的电话号码，电话号码的规则分两部分：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;固话为7-8位，手机为11位，且由1开头，且都为数字。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; landPhoneRule = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;^\d{7,8}$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; handPhoneRule = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;^1\d{10}$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;规则合并&lt;/span&gt;
    &lt;span&gt;string&lt;/span&gt; rule = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}|{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, landPhoneRule, handPhoneRule);
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] enters =&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1234567&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;7位数字，合法&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;8位数字，合法&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;13888888888&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;11位以1开头的数字，合法&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;23888888888&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;11位以2开头的数字，非法&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0123456789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;10位数字，非法&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1388888888a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;带有字符，非法&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10111111111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;11数字，合法&lt;/span&gt;
&lt;span&gt;    };
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; enter &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enters){
        Console.WriteLine(Regex.Match(enter, rule));
    }

    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;现改变手机的规则，改为：手机要以数字1开头，且第二位和第三位不能有数字0，其他不变&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    handPhoneRule &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;^1[1-9]{2}\d{8}$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    rule &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}|{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, landPhoneRule, handPhoneRule);
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; enter &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enters){
        Console.WriteLine(Regex.Match(enter, rule));
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 　　我们看到10111111111也能匹配，显然这不是个手机号，因此在后面我更改了规则，添加了第二位和第三位不是0的限制。这时 &lt;span&gt;&lt;strong&gt;\d&lt;/strong&gt;&lt;/span&gt; 不满足条件了，查看手册，发现 &lt;span&gt;&lt;strong&gt;[]&lt;/strong&gt;&lt;/span&gt; 字符，可以在里面添加候选字符，例如 &lt;strong&gt;&lt;span&gt;[123]&lt;/span&gt;&lt;/strong&gt; 指匹配123，也可以用 - 来添加范围，如 &lt;span&gt;&lt;strong&gt;[0-9]&lt;/strong&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;strong&gt;\d&lt;/strong&gt;&lt;/span&gt; 是一样的。那么更改后的手机号码匹配的规则就变成了 &lt;span&gt;&lt;strong&gt;^1[1-9]{2}\d{8}$&lt;/strong&gt;&lt;/span&gt; 。下面是第三课。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;Lesson3 判断IP是否合法&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　这一题，我将IP的判断稍微简化了些，规则是必须是 &lt;strong&gt;***.***.***.***&lt;/strong&gt; ，其中每项的字符数最少为1位，最多为3位，且 255&amp;gt;=*** &amp;gt;= 0， 第一项不能为0\00\000。这一题的判断要复杂的多，您也能看到正则表达式的一个”短板“，那就是不能获取字符的意义，后面我会解释这一点。看条件，基本的语法我前面都介绍了，该规则可以拆分为两部分，第一项和后三项。第一项，255&amp;gt;=*** &amp;gt;= 0， 且不能为0\00\000。我在思考这道题的时候，先按照正向的思路想，即”描述什么样的满足条件“，情况非常多，01,001,011,1-249,250-255，一共这么多种情况，正则表达式是没有办法”忽略“的，如果是数字， if (001 == 1)是成立的，但是正则表达式办不到，你只能 &lt;strong&gt;&lt;span&gt;(0[2]1)|1&lt;/span&gt;&lt;/strong&gt; 来描述1和001都满足条件，这就是我前面说的，无法获取字符本身的意义，你只能每一位的描述一个字符串，第一位是什么，第二位不是什么，而无法通过意义来形容字符串。我通过”正向”的列举每种情况，表达式是这样的：&lt;span&gt;(&lt;span&gt;&lt;strong&gt;0{2}[1-9&lt;/strong&gt;]&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;strong&gt;&lt;span&gt;0[1-9]\d&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;strong&gt;&lt;span&gt;1\d{2}&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2[0-4]\d&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;strong&gt;&lt;span&gt;25[0-5]&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;strong&gt;&lt;span&gt;0[1-9]&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;strong&gt;&lt;span&gt;[1-9]\d&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;strong&gt;&lt;span&gt;[1-9]&lt;/span&gt;&lt;/strong&gt;)&lt;/span&gt; 。其意义大概就是把01,001,011,1-249,250-255的全部情况都列举了出来，这么做没什么“错”，但是太长了，有没有什么简便做法？“正向”思考不行，那么我们来“反向”试一下：第一项是1-3个数字，不能全是0，不能大于255，也就是不能是 &lt;strong&gt;&lt;span&gt;^0{1,3}&lt;/span&gt;&lt;/strong&gt;，&lt;span&gt;2[6-9]\d&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;25[6-9]&lt;/strong&gt;&lt;/span&gt;，&lt;strong&gt;&lt;span&gt;[3-9]\d{2}&lt;/span&gt;&lt;/strong&gt;，只要不是前面的条件，就可以。如何形容不满足的条件？ &lt;strong&gt;&lt;span&gt;[^]&lt;/span&gt;&lt;/strong&gt;可以，但是只能指明一个字符。可以看到手册的下面有几个&lt;strong&gt;&lt;span&gt;?&amp;lt;!&lt;/span&gt;&lt;/strong&gt;这样的字符，他们表示“附近是否满足条件”，举个例子：?! 加一起表示正向否定的预查找， &lt;strong&gt;&lt;span&gt;&lt;code&gt;Windows(?!95|98|NT|2000)&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;”能匹配“&lt;code&gt;Windows3.1&lt;/code&gt;”中的“&lt;code&gt;Windows&lt;/code&gt;”，但不能匹配“&lt;code&gt;Windows2000&lt;/code&gt;”中的“&lt;code&gt;Windows&lt;/code&gt;”，还有其他的。这里我用?&amp;lt;! ，表示反向否定查找，即(?&amp;lt;!123)456表示能匹配23456，但是不能匹配前面带123的456，如123456就不满足条件。这个正向和反向就是前面和后面，肯定就是匹配，否定就是排除。我的第一项的表达式是：&lt;strong&gt;&lt;span&gt;^(\d{1,3})(?&amp;lt;!^0{1,3}&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;2[6-9]\d&lt;span&gt;|&lt;/span&gt;25[6-9]&lt;span&gt;|&lt;/span&gt;[3-9]\d{2})&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;第二项的前面如果是上述几种情况，则第二项永远不会匹配。接下来是后面三项，后面的三项都是 .***，255&amp;gt;=***&amp;gt;=0，语句是&lt;/span&gt;&lt;strong&gt;(.[01]?\d?\d&lt;span&gt;|&lt;/span&gt;2[0-4]\d&lt;span&gt;|&lt;/span&gt;25[0-5]){3}$&lt;/strong&gt;&lt;span&gt;，加起来就是 &lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;^(\d{1,3})(?&amp;lt;!^(0{1,3}|2[6-9]\d|25[6-9]|[3-9]\d{2}))(.[01]?\d?\d|2[0-4]\d|25[0-5]){3}$&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt; 。代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Lesson3(){
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;题目是判断一个IP是否合法，规则如下：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;格式必须是***.***.***.***&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;其中第一组数字必须大于1， 每组数字都要小于等于255&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;复杂版&lt;/span&gt;
    &lt;span&gt;string&lt;/span&gt; rule =  &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;^(\d{1,3})(?&amp;lt;!^(0{1,3}|2[6-9]\d|25[6-9]|[3-9]\d{2}))(.[01]?\d?\d|2[0-4]\d|25[0-5]){3}$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] enters =&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;255.255.255.255&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合法&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;21.1.1.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合法&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;256.0.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非法&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;300.2.2.250&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非法&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10.1.1.99&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合法&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;00.1.1.009&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非法&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100.1.1.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合法&lt;/span&gt;
&lt;span&gt;    };
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; enter &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enters){
        Console.WriteLine(Regex.Match(enter, rule).Convert2String(enter));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这里要吐槽下，如果能转成数字，判断IP是否合法，只要把数字截出来，判断 &amp;gt;=0&amp;amp;&amp;amp; &amp;lt;=255就可以了，这里也可能有更简便的做法，笔者一时没想出来，欢迎有好办法的同学留言给我。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Lesson4 函数替换&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　这个题目是我学习正则表达式的起源。当时我在重构代码，发现有一个方法写的多余我们管这个多余的方法叫MA，应该换成MB（另一个方法），MA接受2个变量，MB接受一个变量。VS提供了自动更换函数名字的功能，但是对于函数变量的变化就无能为力了。当时全工程有接近50个MA的调用，都要替换成MB，如果手动一下一下的删除多余的参数，那实在是太恶心了。VS查找界面提供了替换功能，我看到搜索选项里面有正则表达式一项，是否能够使用正则表达式来自动替换？于是就开始研究起正则表达式，是1天还是2天，磕磕绊绊，研究出了表达式，然后一试，确实好使！怕匹配错，就点击替换，一个一个的换，中间多次调整表达式，最终在没有手动更改的情况下，全部替换成功，当时真的很高兴，感觉正则表达式很神奇。因此我就把这个情景转换为第四课的内容，前面讲的都是匹配，这一课就来看看如何进行替换。下面是题目的要求，上面的一组Console.WriteLine是原语句，下面的4个Console.WriteLine是替换后的样子。就是用MB替换MA，并保留MA的第一个参数给MB，舍弃第二个参数。每条语句都毫无意义，只是用来替换。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面的语句没有任何的实际意义，只是模拟 想要替换的语句的具体使用。&lt;/span&gt;
Console.WriteLine(MA(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))&lt;span&gt;,&lt;/span&gt;
Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + MA(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GetType().ToString()));
Console.WriteLine(MA(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GetType().ToString()));
Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + MA(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.Substring(&lt;span&gt;1&lt;/span&gt;)) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;替换成如下的样子&lt;/span&gt;
Console.WriteLine(MB(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + MB(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
Console.WriteLine(MB(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + MB(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这两个方法没有任何意义，只是用MA模拟原函数，MB模拟想要被替换的函数&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MA(&lt;span&gt;string&lt;/span&gt; a, &lt;span&gt;string&lt;/span&gt; b) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MB(&lt;span&gt;string&lt;/span&gt; a) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　先来匹配，分析一下要替换的4条语句：开始的部分都是函数名MA，内容是()内的部分，只要找到适当的‘（’和‘）’，就可以了。但事实是无法确定到底哪个‘）’才是合适的，能看到后的语句后面有一个‘）’，有的是两个，有的是三个。这里括号要精确匹配，不能匹配多了，不然语句就错误了。一个‘）’的情况是带个&quot;，其他的至少有2个‘）’，因此我们可以分两种情况，第一种是&quot;)，第二种是多个括号的前两个。这里有一个问题，如何只匹配前两个？在正则表达式中，有两种匹配方式，一种是贪心，一种是非贪心。贪心的意思是能匹配几个就匹配几个，比如a+，在匹配aaaaaab的时候，会匹配全部的a字母，结果是aaaaaa。而如果加入a+?，？的本来意思是0个或1个，但是在这里，表示最多匹配1个，结果就是a。还有一个问题就是，正则表达式中，()是有特殊意义的，如果放弃其特殊意义，只是想匹配括号，就要用转义副\，这个用过ASC||码的都应该能明白。则匹配MA函数的表达式为：&lt;strong&gt;&lt;span&gt;MA\((.+),\s?.+?(\)\))&lt;span&gt;|&lt;/span&gt;&quot;&quot;\) &lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 。注意，c#中双引号要这样 @&quot;&quot;&quot;&quot;，前面用@，然后用两个&quot;&quot;表示一个双引号。读别人的正则表达式会有些费劲，那么我的建议是你可以先不看我的结果，只要明白题意，一边查看手册，一边自己练习一点一点的试，很快就能做出来，这时 你就明白大概了，再来看拿自己的表达式与别人的对比，很有可能你做的比我简略！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以看到在&lt;span&gt;&lt;strong&gt;\s?&lt;/strong&gt;&lt;/span&gt;之后，我用.&lt;span&gt;&lt;strong&gt;+?&lt;/strong&gt;&lt;/span&gt;来尽量少的匹配字符，直到遇到&lt;strong&gt;&lt;span&gt;))&lt;/span&gt;&lt;/strong&gt;或者&lt;strong&gt;&lt;span&gt;&quot;)&lt;/span&gt;&lt;/strong&gt;就停止匹配，如果只用&lt;strong&gt;&lt;span&gt;.+&lt;/span&gt;&lt;/strong&gt;，就会过多的匹配括号。 光有正则表达式还不够，还要能替换。替换的难点在如何保留第一个变量。正则表达式提供了提取括号里匹配到则值得机制，如&lt;span&gt;&lt;strong&gt;&lt;span&gt;(\w)\1(\w)\2&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;，能够匹配aabb，第一个\w匹配到了a，由于在括号中，因此被记录了下来，可通过\1来获得第一个括号中的内容，以此类推。在替换时，C#（其他语言不清楚）,可利用$1来获得第一个括号中匹配到的内容。则替换的语句是&lt;strong&gt;&lt;span&gt;MB($1)&lt;/span&gt;&lt;/strong&gt;。注意，这里替换的语句不需要转义，因为替换不需要匹配，只要将字符原封不动替换就可以了。下面是代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Lesson4(){
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第四课，替换函数。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; rule = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;MA\((.+?),\s?.+?(\)\)|&quot;&quot;\))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] enters =&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Console.WriteLine(MA(&quot;&quot;a&quot;&quot;, &quot;&quot;b&quot;&quot;))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Console.WriteLine(&quot;&quot;a&quot;&quot; + MA(&quot;&quot;a&quot;&quot;, GetType().ToString()));&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Console.WriteLine(MA(&quot;&quot;a&quot;&quot;, GetType().ToString()));&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Console.WriteLine(&quot;&quot;a&quot;&quot; + MA(&quot;&quot;a&quot;&quot;, &quot;&quot;a&quot;&quot;.Substring(1)) + &quot;&quot;b&quot;&quot;);&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    };
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; replacement = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;MB($1)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; enter &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enters)
    {
        Console.WriteLine(Regex.Match(enter, rule).Convert2String(enter));
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;替换后由{0}变为{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, enter, Regex.Replace(enter, rule, replacement));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　正则表达式看起来很难，但如果您把这4课都做一遍，就已经基本掌握了正则表达式了，日常的应用是没有问题的。语法有些难记，我的建议是先不管语法，要用就随时翻手册。欢迎各位同学在评论区与我互动。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Mar 2018 07:30:00 +0000</pubDate>
<dc:creator>JAZzzzzzzz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jazzpop/p/8615803.html</dc:identifier>
</item>
<item>
<title>十分钟看懂神经网络反向传输算法 - 郭耀华</title>
<link>http://www.cnblogs.com/guoyaohua/p/8617086.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoyaohua/p/8617086.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;昨天面试被问到如何推导BP（反向传输）算法，顿时蒙住了，大体是知道反向传输算法的过程的，但是用语言描述出来，确实有些困难。回来后看了些博文，发现有的博文中公式推导过于复杂，不易理解，遂综合了网络中其他博文和斯坦福大学CS231n课程中的内容，整理了一份反向传输算法的通俗解释，如有错误，请各位网友指出。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先我们要知道我们的优化目标是什么，对于神经网络模型的优化实质上就是对&lt;strong&gt;整体损失函数 L（成本函数） &lt;/strong&gt;的优化&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201803/1192699-20180321143737593-1207360032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中 L&lt;sub&gt;i &lt;/sub&gt;为样本集中第 i 个样本的损失值，(x&lt;sub&gt;i&lt;/sub&gt;,yi)为第i个样本。&lt;/p&gt;
&lt;p&gt;损失函数 L 的自变量是网络中所有的参数，训练的目的是找到一组参数，使得损失函数 L 达到最小值（或者局部最小值）。通常使用梯度下降算法进行优化参数，对于具体的优化算法，这里不再叙述，具体可以参看&lt;a href=&quot;http://www.cnblogs.com/guoyaohua/p/8542554.html&quot; target=&quot;_blank&quot;&gt;《&lt;span&gt;深度学习&lt;/span&gt;——优化器算法&lt;span&gt;Optimizer&lt;/span&gt;&lt;span&gt;详解&lt;/span&gt;&lt;span&gt;BGD&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;SGD&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;MBGD&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Momentum&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;NAG&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Adagrad&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Adadelta&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;RMSprop&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Adam&lt;/span&gt;》&lt;/a&gt;一文。这些算法都是阐述了如何更好的使用梯度信息来快速优化成本函数、找到最有解，但这些算法的前提都是获得了成本函数的梯度值，对于深度网络可能有上亿的参数需要优化，如何高效的求解出 L 对这上亿参数的偏导数，便成为一个难题，&lt;span&gt;&lt;strong&gt;反向传输（BP）算法即用来高效的计算这些参数的偏导数，进而得出成本函数（损失函数L）的梯度。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1.链式求导&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;首先我们回顾一下微积分中对于复合函数的求导过程，对于任意复合函数，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201803/1192699-20180321113529143-186008503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是我们常说的&lt;span&gt;&lt;strong&gt;链式求导法则&lt;/strong&gt;&lt;/span&gt;。反向传输算法正是利用了这种&lt;strong&gt;链式求导法则。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;2.用计算图来解释几种求导方法&lt;/h2&gt;
&lt;h3&gt;2.1 计算图&lt;/h3&gt;
&lt;p&gt;式子 &lt;img src=&quot;http://www.zhihu.com/equation?tex=e%3D%28a%2Bb%29%2A%28b%2B1%29&quot; alt=&quot;e=(a+b)*(b+1)&quot;/&gt; 可以用如下计算图表达：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201803/1192699-20180321114332123-287002338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;令a=2,b=1则有：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-c813b52ef0bc6122bce51268f03c4b7f_hd.jpg&quot; alt=&quot;&quot; width=&quot;464&quot; data-rawwidth=&quot;464&quot; data-rawheight=&quot;277&quot; data-original=&quot;https://pic1.zhimg.com/v2-c813b52ef0bc6122bce51268f03c4b7f_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c813b52ef0bc6122bce51268f03c4b7f_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如何在计算图上表达“求导”呢？ 导数的含义是&lt;span&gt;&lt;strong&gt;因变量随自变量的变化率&lt;/strong&gt;&lt;/span&gt;，例如 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+y+%7D%7B%5Cpartial+x%7D+%3D+3+&quot; alt=&quot;\frac{\partial y }{\partial x} = 3 &quot;/&gt; 表示当x变化1个单位，y会变化3个单位。 微积分中已经学过：加法求导法则是 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial+a%7D%28a%2Bb%29+%3D+%5Cfrac%7B%5Cpartial+a%7D%7B%5Cpartial+a%7D+%2B+%5Cfrac%7B%5Cpartial+b%7D%7B%5Cpartial+a%7D+%3D+1&quot; alt=&quot;\frac{\partial}{\partial a}(a+b) = \frac{\partial a}{\partial a} + \frac{\partial b}{\partial a} = 1&quot;/&gt; 乘法求导法则是 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial+u%7Duv+%3D+u%5Cfrac%7B%5Cpartial+v%7D%7B%5Cpartial+u%7D+%2B+v%5Cfrac%7B%5Cpartial+u%7D%7B%5Cpartial+u%7D+%3D+v&quot; alt=&quot;\frac{\partial}{\partial u}uv = u\frac{\partial v}{\partial u} + v\frac{\partial u}{\partial u} = v&quot;/&gt; 。 我们在计算图的边上表示导数或偏导数：&lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B+%5Cpartial+e+%7D%7B+%5Cpartial+c+%7D+%2C+%5Cfrac%7B+%5Cpartial+e+%7D%7B+%5Cpartial+d+%7D%2C+%5Cfrac%7B+%5Cpartial+c+%7D%7B+%5Cpartial+a+%7D%2C+%5Cfrac%7B+%5Cpartial+c+%7D%7B+%5Cpartial+b+%7D%2C+%5Cfrac%7B+%5Cpartial+d+%7D%7B+%5Cpartial+b+%7D&quot; alt=&quot;\frac{ \partial e }{ \partial c } , \frac{ \partial e }{ \partial d }, \frac{ \partial c }{ \partial a }, \frac{ \partial c }{ \partial b }, \frac{ \partial d }{ \partial b }&quot;/&gt; 如下图&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-9d12967ade4b015c1274a0fbcbfc1a46_hd.jpg&quot; alt=&quot;&quot; width=&quot;514&quot; data-rawwidth=&quot;514&quot; data-rawheight=&quot;310&quot; data-original=&quot;https://pic2.zhimg.com/v2-9d12967ade4b015c1274a0fbcbfc1a46_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9d12967ade4b015c1274a0fbcbfc1a46_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那么 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B+%5Cpartial+e++%7D%7B+%5Cpartial+b+%7D&quot; alt=&quot;\frac{ \partial e }{ \partial b }&quot;/&gt; 如何求呢？ &lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+c+%7D%7B+%5Cpartial+b%7D+%3D+1+&quot; alt=&quot;\frac{\partial c }{ \partial b} = 1 &quot;/&gt;告诉我们1个单位的b变化会引起1个单位的c变换，&lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+e+%7D%7B+%5Cpartial+c%7D+%3D+2&quot; alt=&quot;\frac{\partial e }{ \partial c} = 2&quot;/&gt;告诉我们 1 个单位的c变化会引起2个单位的e变化。所以 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B+%5Cpartial+e++%7D%7B+%5Cpartial+b+%7D+%3D+++%5Cfrac%7B+%5Cpartial+c+%7D%7B+%5Cpartial+b+%7D+%2A+%5Cfrac%7B+%5Cpartial+e++%7D%7B+%5Cpartial+c+%7D+++%3D+1%2A2+%3D2&quot; alt=&quot;\frac{ \partial e }{ \partial b } = \frac{ \partial c }{ \partial b } * \frac{ \partial e }{ \partial c } = 1*2 =2&quot;/&gt; 吗？ 答案必然是错误。因为这样做只考虑到了下图橙色的路径，所有的路径都要考虑：&lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B+%5Cpartial+e++%7D%7B+%5Cpartial+b+%7D+%3D+++%5Cfrac%7B+%5Cpartial+c+%7D%7B+%5Cpartial+b+%7D+%2A+%5Cfrac%7B+%5Cpartial+e++%7D%7B+%5Cpartial+c+%7D++%2B++%5Cfrac%7B+%5Cpartial+d++%7D%7B+%5Cpartial+b+%7D++%2A++%5Cfrac%7B+%5Cpartial+e++%7D%7B+%5Cpartial+d+%7D++%3D1%2A2+%2B+1+%2A+3+%3D+5&quot; alt=&quot;\frac{ \partial e }{ \partial b } = \frac{ \partial c }{ \partial b } * \frac{ \partial e }{ \partial c } + \frac{ \partial d }{ \partial b } * \frac{ \partial e }{ \partial d } =1*2 + 1 * 3 = 5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-06e95b259a2234b1507e12912f91572f_hd.jpg&quot; alt=&quot;&quot; width=&quot;546&quot; data-rawwidth=&quot;546&quot; data-rawheight=&quot;356&quot; data-original=&quot;https://pic1.zhimg.com/v2-06e95b259a2234b1507e12912f91572f_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-06e95b259a2234b1507e12912f91572f_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所以上面的求导方法总结为一句话就是： &lt;strong&gt;路径上所有边相乘，所有路径相加。&lt;/strong&gt;不过这里需要补充一条很有用的合并策略：&lt;/p&gt;
&lt;p&gt;例如：下面的计算图若要计算&lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+Z%7D%7B%5Cpartial+X%7D&quot; alt=&quot;\frac{\partial Z}{\partial X}&quot;/&gt;就会有9条路径：&lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+Z%7D%7B%5Cpartial+X%7D+%3D+%5Calpha%5Cdelta+%2B+%5Calpha%5Cepsilon+%2B+%5Calpha%5Czeta+%2B+%5Cbeta%5Cdelta+%2B+%5Cbeta%5Cepsilon+%2B+%5Cbeta%5Czeta+%2B+%5Cgamma%5Cdelta+%2B+%5Cgamma%5Cepsilon+%2B+%5Cgamma%5Czeta&quot; alt=&quot;\frac{\partial Z}{\partial X} = \alpha\delta + \alpha\epsilon + \alpha\zeta + \beta\delta + \beta\epsilon + \beta\zeta + \gamma\delta + \gamma\epsilon + \gamma\zeta&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-481751c1cabf64a2dfc9ecc051955e18_hd.jpg&quot; alt=&quot;&quot; width=&quot;545&quot; data-rawwidth=&quot;545&quot; data-rawheight=&quot;145&quot; data-original=&quot;https://pic1.zhimg.com/v2-481751c1cabf64a2dfc9ecc051955e18_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-481751c1cabf64a2dfc9ecc051955e18_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果计算图再复杂一些，层数再多一些，路径数量就会呈指数爆炸性增长。但是如果采用合并策略：&lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+Z%7D%7B%5Cpartial+X%7D+%3D+%28%5Calpha+%2B+%5Cbeta+%2B+%5Cgamma%29%28%5Cdelta+%2B+%5Cepsilon+%2B+%5Czeta%29&quot; alt=&quot;\frac{\partial Z}{\partial X} = (\alpha + \beta + \gamma)(\delta + \epsilon + \zeta)&quot;/&gt; 就不会出现这种问题。这种策略不是 对每一条路径都求和，而是 “合并同类路径”，“分阶段求解”。先求X对Y的总影响 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%28%5Calpha+%2B+%5Cbeta+%2B+%5Cgamma%29&quot; alt=&quot;(\alpha + \beta + \gamma)&quot;/&gt; 再求Y对Z的总影响 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%28%5Cdelta+%2B+%5Cepsilon+%2B+%5Czeta%29&quot; alt=&quot;(\delta + \epsilon + \zeta)&quot;/&gt; 最后综合在一起。&lt;/p&gt;
&lt;h3&gt;2.2 两种求导模式：前向模式求导( forward-mode differentiation) 反向模式求导(reverse-mode differentiation)&lt;/h3&gt;
&lt;p&gt;上面提到的求导方法都是&lt;strong&gt;前向模式求导( forward-mode differentiation) &lt;/strong&gt;：从前向后。先求X对Y的总影响 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%28%5Calpha+%2B+%5Cbeta+%2B+%5Cgamma%29&quot; alt=&quot;(\alpha + \beta + \gamma)&quot;/&gt; 再乘以Y对Z的总影响 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%28%5Cdelta+%2B+%5Cepsilon+%2B+%5Czeta%29&quot; alt=&quot;(\delta + \epsilon + \zeta)&quot;/&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-df45f4ba18643b1433f6ddd7e4814ac2_hd.jpg&quot; alt=&quot;&quot; width=&quot;534&quot; data-rawwidth=&quot;534&quot; data-rawheight=&quot;186&quot; data-original=&quot;https://pic2.zhimg.com/v2-df45f4ba18643b1433f6ddd7e4814ac2_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-df45f4ba18643b1433f6ddd7e4814ac2_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另一种，&lt;span&gt;&lt;strong&gt;反向模式求导(reverse-mode differentiation) 则是从后向前。先求Y对Z的影响再乘以X对Y的影响。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-ebd30320f02f44cce7643e50f273cfc0_hd.jpg&quot; alt=&quot;&quot; width=&quot;547&quot; data-rawwidth=&quot;547&quot; data-rawheight=&quot;194&quot; data-original=&quot;https://pic1.zhimg.com/v2-ebd30320f02f44cce7643e50f273cfc0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ebd30320f02f44cce7643e50f273cfc0_b.jpg&quot;/&gt;&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前向求导模式追踪一个输入如何影响每一个节点（对每一个节点进行 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial+X%7D&quot; alt=&quot;\frac{\partial}{\partial X}&quot;/&gt;操作）反向求导模式追踪每一个节点如何影响一个输出（对每一个节点进行 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+Z%7D%7B%5Cpartial%7D&quot; alt=&quot;\frac{\partial Z}{\partial}&quot;/&gt;操作）。通俗点理解，前向求导模式和反向求导模式只是求导顺序的不同，但是顺序不同运算复杂度也不相同。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.3 反向求导模式（反向传播算法）的重要性&lt;/h3&gt;
&lt;p&gt;让我们再次考虑前面的例子：&lt;/p&gt;
&lt;p&gt;如果用前向求导模式：关于b向前求导一次&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201803/1192699-20180321114416068-956715442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;如果用反向求导模式：向后求导&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201803/1192699-20180321114422651-36699861.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前向求导模式只得到了关于输入b的偏导&lt;img src=&quot;http://www.zhihu.com/equation?tex=+%5Cfrac%7B%5Cpartial+e%7D%7B%5Cpartial+b%7D&quot; alt=&quot; \frac{\partial e}{\partial b}&quot;/&gt; ，还需要再次求解关于输入a的偏导&lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+e%7D%7B%5Cpartial+a%7D&quot; alt=&quot;\frac{\partial e}{\partial a}&quot;/&gt; （运算2遍）。而反向求导一次运算就得到了e对两个输入a,b的偏导&lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+e%7D%7B%5Cpartial+a%7D%2C+%5Cfrac%7B%5Cpartial+e%7D%7B%5Cpartial+b%7D&quot; alt=&quot;\frac{\partial e}{\partial a}, \frac{\partial e}{\partial b}&quot;/&gt; （运算1遍）。上面的比较只看到了2倍的加速。但如果有1亿个输入1个输出，意味着前向求导需要操作1亿遍才得到所有关于输入的偏导，而反向求导则只需一次运算，1亿倍的加速。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当我们训练神经网络时，把“损失“ 看作 ”权重参数“ 的函数，需要计算”损失“关于每一个”权重参数“的偏导数（然后用梯度下降法学习）。 神经网络的权重参数可以是百万甚至过亿级别。因此&lt;span&gt;&lt;strong&gt;反向求导模式（反向传播算法）可以极大的加速学习。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用更通俗易懂的话来描述反向传输算法，从目标函数开始，逐层向前求解每一层每个结点（运算）的局部梯度，根据链式法则可知，整个网络中成本函数对于某一个参数的偏导数，从成本函数流经本参数所有指路上的偏导数乘积叠加，这样一次运算就可以获得所有参数的偏导数，即成本函数的梯度。梯度从后向前逐层传递。&lt;/p&gt;
&lt;p&gt;通过计算流图对该算法进行简要解释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201803/1192699-20180321142934142-1766794760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Mar 2018 07:03:00 +0000</pubDate>
<dc:creator>郭耀华</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guoyaohua/p/8617086.html</dc:identifier>
</item>
<item>
<title>基于Jmeter的自动化测试实施方案设计 - 王子石</title>
<link>http://www.cnblogs.com/zishi/p/8448073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zishi/p/8448073.html</guid>
<description>&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;Jmeter是目前最流行的一种测试工具，基于此工具我们搭建了一整套的自动化方案，包括了脚本添加配置、本地配置和运行、服务器配置等内容，完成了自动化测试闭环，通过这种快捷简便高效的方式，希望可以解决自动化测试上手难的痛点。下面闲言少叙，我们直接切入实战：&lt;/p&gt;

&lt;p&gt;一、准备自动化测试物料&lt;/p&gt;
&lt;p&gt;    1、开发运行工具Jmeter，（下载地址： &lt;a href=&quot;http://jmeter.apache.org/download_jmeter.cgi&quot;&gt;http://jmeter.apache.org/download_jmeter.cgi&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111155406-222329119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    2、开发环境为已发布ready；&lt;/p&gt;
&lt;p&gt;    3、测试脚本已准备ready；&lt;/p&gt;
&lt;p&gt;    4、脚本运行环境已准备（fat或者uat）；&lt;/p&gt;

&lt;p&gt;二、自动化测试通过标准&lt;/p&gt;
&lt;p&gt;    1、成功Status 返回200 ；&lt;/p&gt;
&lt;p&gt;    2、失败返回404、500等；&lt;/p&gt;
&lt;p&gt;    3、每个脚本专用断言；&lt;/p&gt;

&lt;p&gt;三、自动化脚本存储&lt;/p&gt;
&lt;p&gt;    脚本全部存储在Gitlab仓库中，（脚本的存储规范请参考：GitLab Jmeter测试包通用设计1.0版）&lt;/p&gt;
&lt;p&gt;项目根目录新建文件夹，前面文件夹名和项目名保持一致，后缀加“-test”，如下图文件夹：&lt;/p&gt;

&lt;p&gt;    &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111212781-1909825502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;四、自动化测试Script Rules&lt;/p&gt;
&lt;p&gt;    1、脚本命名为接口名&lt;/p&gt;
&lt;p&gt;    2、存储类型为后缀jmx的文件&lt;/p&gt;
&lt;p&gt;    3、线程数设置为1（冒烟测试无需多线程并发）&lt;/p&gt;
&lt;p&gt;    4、必须包含断言判断，状态检测设定为200&lt;/p&gt;
&lt;p&gt;五、自动化测试Script Steps&lt;/p&gt;
&lt;p&gt;    1、添加线程组，脚本命名为接口名，点击存储 为后缀jmx的文件&lt;/p&gt;
&lt;p&gt;    2、将线程数设置为1，其他设置为默认（如下图）&lt;/p&gt;
&lt;p&gt;    3、循环次数为不循环，调度器不设置，其他参数不设置（如下图）&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111219390-1013793911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;    4、配置http协议选项：&lt;/p&gt;
&lt;p&gt;        a、添加http请求，线程组右键“添加”，选择“Sampler”，再选择“HTTP请求”：&lt;/p&gt;
&lt;p&gt;              &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111232374-832299163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;        b、请求为post or get（如下图，此处根据实际情况设置为POST）&lt;/p&gt;
&lt;p&gt;        c、内容编码：UTF-8（如下图，此处根据实际情况设置为UTF-8）&lt;/p&gt;
&lt;p&gt;        d、Request报文：填入Body Data（如下图，此处根据实际情况设置Request报文内容）&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111241656-1728505941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 5、配置断言选项，线程组右键“添加”，选择“断言”，此处选择“响应断言”。注意可以根据实际情况选择其他断言类型：&lt;/p&gt;
&lt;p&gt;        a、添加响应断言，如下图所示；&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111306077-1424762376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;        b、选择响应字段为响应代码，如下图所示；&lt;/p&gt;
&lt;p&gt;        c、匹配规则选择为包括，如下图；&lt;/p&gt;
&lt;p&gt;        d、测试模式填入200，如下图（此处为开发自定义返回码，请根据实际情况设置）；&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111312531-1193490485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt; 6、添加“HTTP信息头管理器” ，在测试计划点击右键“添加”菜单，选择“配置元件”，再选择“HTTP信息头管理器” （即为HTTP Header Manager），如下图：&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111323327-1243445613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;    可根据实际情况添加Content-Type等内容，例如此处value设置为：application/json，如下图范例：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111415499-1840246963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;7、添加“查看结果树”，在测试计划点击右键“添加”菜单，选择“监听器”，再选择“查看结果树”：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111441124-1989399405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;运行成功或失败，分别可以查看结果树详情，如下图所示，查看响应数据，可以看到response报文：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111457906-271251452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下图是一个运行失败结果的断言，断言失败的信息也会有详细说明：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111508406-1068872555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;8、添加&quot;用表格查看结果&quot;，在测试计划点击右键“添加”菜单，选择“监听器”，选择“用表格查看结果”：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111540452-983349725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;添加后每次测试计划运行结束，可以查看全部线程组的运行结果，如下图所示：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111547827-2044285208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;9、添加“聚合报告”，在测试计划点击右键“添加”菜单，选择“监听器”，选择“聚合报告”：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111556859-1567672888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;聚合报告主要用来收集本次测试计划运行的一些重要的性能指标数值，例如Average、90%Line等等，添加后每次测试计划运行结束可以查看到指标的有效数据，如下图范例：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111615327-2061612691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;六、本地执行&lt;/p&gt;

&lt;p&gt;1、在当前测试计划中，根据上述范例逐一添加本次需要运行的自动化脚本，添加完成后的效果如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111629484-312648445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;2、运行当前测试计划的全部用例，然后用查看全部运行结果如下：&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111635984-108285674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、同样在结果树，可以查看全部失败用例的详细报文：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111641921-966153319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;七、服务器配置和运行（Jenkins/TFS）&lt;/p&gt;
&lt;p&gt;由于job最底层调度由Jenkins实现，本小节重点介绍如何配置job参数等内容。TFS方面只需要通过接口或者命令行的方式，直接调度Jenkins即可。&lt;/p&gt;
&lt;p&gt;1、Job命名规范，定义在Jenkins中job的命名规范，如下图所示，以“JMETER”开头后面是服务名：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111655937-1486725298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、添加构建配置，如图所示，其中devops是基于Python编写的打包脚本，/sso-support-test是Jmx脚本文件地址,report_server是邮件服务，mail是报告接收人的邮箱地址：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111704499-1488129622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、构建触发器配置：如图所示，这里配置每两分钟去轮循检查服务器是否有更新：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111714515-1814013199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、源码管理：添加并选择Git仓库，然后配置Repo地址，最后选择分支dev（非强制）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111721999-590586685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;八、服务器生产自动化报告&lt;/p&gt;
&lt;p&gt;自动化报告目前支持两种形式，邮件和Html报告查看。&lt;/p&gt;
&lt;p&gt;1、邮件方式报告查看。服务器端配置响应接收人员的邮件地址后，每次自动化运行结束，会自动发送邮件报告到指定关注人，如下图所示：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111728921-1939333815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;邮件Report中主要包含以下内容：&lt;/p&gt;
&lt;p&gt;Summary栏目：包含所有请求的总结，总数，失败数，成功率，平均时间，最小时间，最大时间等。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111736687-814113362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Pages栏目：主要包含了单个请求的详情内容：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111740796-658681348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Failure Detail：主要是错误详情相关内容：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111746109-233175111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;2、Html报告查看。Html内容展示目前和邮件基本保持一致不再展开详述，如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1148190/201802/1148190-20180214111750984-803137327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 21 Mar 2018 06:22:00 +0000</pubDate>
<dc:creator>王子石</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zishi/p/8448073.html</dc:identifier>
</item>
<item>
<title>[UWP]理解ControlTemplate中的VisualTransition - dino.c</title>
<link>http://www.cnblogs.com/dino623/p/VisualTransition.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dino623/p/VisualTransition.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;VisualTransition是控件模板中的重要组成部分，无论是自定义控件或者修改控件样式都会接触到VisualTransition。明明这么重要，博客园上好像都没多少关于VisualTransition的主题。&lt;/p&gt;
&lt;h2 id=&quot;什么是visualtransition&quot;&gt;2. 什么是VisualTransition&lt;/h2&gt;
&lt;p&gt;VisualTransition动画定义VisualState之前切换时的过渡行为，包括过渡时间和过渡动画。&lt;/p&gt;
&lt;p&gt;VisualTransition的类定义如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;[&lt;span class=&quot;fu&quot;&gt;ContentProperty&lt;/span&gt;(Name = &lt;span class=&quot;st&quot;&gt;&quot;Storyboard&quot;&lt;/span&gt;)]
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; VisualTransition : DependencyObject, IVisualTransition
{
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;VisualTransition&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;// 摘要:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//     获取或设置要转换为的 Windows.UI.Xaml.VisualState 的名称。&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; To { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    &lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 摘要:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//     获取或设置在发生转换时运行的 Windows.UI.Xaml.Media.Animation.Storyboard。&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Storyboard Storyboard { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    &lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 摘要:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//     获取或设置应用于生成的动画的缓动函数。&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; EasingFunctionBase GeneratedEasingFunction { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    &lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 摘要:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//     获取或设置从一种状态转换到另一种状态所花的时间，以及任何隐式过渡动画应作为过渡行为的一部分运行的时间&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Duration GeneratedDuration { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    &lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 摘要:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//     获取或设置要转换的 Windows.UI.Xaml.VisualState 的名称。&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; From { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;为什么使用visualtransition&quot;&gt;3.为什么使用VisualTransition&lt;/h2&gt;
&lt;p&gt;虽然自WPF4以来VisualTransition一直都存在，但很多人还是习惯这样写VisualState：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualStateGroup&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;CommonStates&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualState&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Normal&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualState&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PointerOver&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;Storyboard&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;DoubleAnimation&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  Storyboard.TargetProperty=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Opacity&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                              Storyboard.TargetName=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PointOverElement&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                              Duration=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                              To=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/Storyboard&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualState&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualState&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Pressed&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;Storyboard&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;DoubleAnimation&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  Storyboard.TargetProperty=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Opacity&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                              Storyboard.TargetName=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PressElement&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                              Duration=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                              To=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/Storyboard&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualState&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualState&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Disabled&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualStateGroup&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正确的做法应该是这样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualStateGroup&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;CommonStates&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualStateGroup.Transitions&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualTransition&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; To=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PointerOver&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;Storyboard&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;DoubleAnimationUsingKeyFrames&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; Storyboard.TargetProperty=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;(UIElement.Opacity)&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                                               Storyboard.TargetName=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PointOverElement&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;&amp;lt;EasingDoubleKeyFrame&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; KeyTime=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                                          Value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;&amp;lt;EasingDoubleKeyFrame&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; KeyTime=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0:0:2&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                                          Value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
                        &lt;span class=&quot;kw&quot;&gt;&amp;lt;EasingDoubleKeyFrame.EasingFunction&amp;gt;&lt;/span&gt;
                            &lt;span class=&quot;kw&quot;&gt;&amp;lt;CubicEase&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; EasingMode=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;EaseOut&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/EasingDoubleKeyFrame.EasingFunction&amp;gt;&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/EasingDoubleKeyFrame&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;/DoubleAnimationUsingKeyFrames&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/Storyboard&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualTransition&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualTransition&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; To=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Pressed&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;Storyboard&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;DoubleAnimationUsingKeyFrames&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; Storyboard.TargetProperty=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;(UIElement.Opacity)&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                                               Storyboard.TargetName=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PressElement&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;&amp;lt;EasingDoubleKeyFrame&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; KeyTime=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                                          Value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;&amp;lt;EasingDoubleKeyFrame&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; KeyTime=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0:0:2&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                                          Value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
                        &lt;span class=&quot;kw&quot;&gt;&amp;lt;EasingDoubleKeyFrame.EasingFunction&amp;gt;&lt;/span&gt;
                            &lt;span class=&quot;kw&quot;&gt;&amp;lt;CubicEase&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; EasingMode=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;EaseOut&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/EasingDoubleKeyFrame.EasingFunction&amp;gt;&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/EasingDoubleKeyFrame&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;/DoubleAnimationUsingKeyFrames&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/Storyboard&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualTransition&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualTransition&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; To=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Disabled&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;Storyboard&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; Completed=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Storyboard_Completed&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/Storyboard&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualTransition&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualStateGroup.Transitions&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualState&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Normal&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualState&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PointerOver&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;Storyboard&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;DoubleAnimation&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  Storyboard.TargetProperty=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Opacity&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                              Storyboard.TargetName=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PointOverElement&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                              Duration=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                              To=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/Storyboard&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualState&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualState&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Pressed&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;Storyboard&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;DoubleAnimation&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  Storyboard.TargetProperty=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Opacity&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                              Storyboard.TargetName=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PressElement&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                              Duration=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                              To=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/Storyboard&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualState&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualState&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Disabled&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualStateGroup&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到VisualState中的Storyboard只用于定义VisualState的最终可视状态，而在VIsualState间转换时用户看到的是VisualTransition 中定义的Storyboard。但这样的话两处的Storyboard不就重复了？带着这个疑问很多年，微软终于给出了另一种方案VisualState.Setters：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualStateGroup&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;CommonStates&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualStateGroup.Transitions&amp;gt;&lt;/span&gt;
        ...
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualStateGroup.Transitions&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualState&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Normal&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualState&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PointerOver&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualState.Setters&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;Setter&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; Target=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PointOverElement.(UIElement.Opacity)&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                    Value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualState.Setters&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualState&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualState&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Pressed&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualState.Setters&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;Setter&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; Target=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PressElement.(UIElement.Opacity)&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                    Value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualState.Setters&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualState&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualState&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x:Name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Disabled&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualStateGroup&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样VisualState的做法就十分清晰明了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码使用VisualStaeManager控制控件当前的VisualState；&lt;/li&gt;
&lt;li&gt;VisualState.Setters定义这个VisualState最终在UI上如何呈现；&lt;/li&gt;
&lt;li&gt;VisualState间的过渡动画由VisualTransition定义；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;怎么使用visualtransition&quot;&gt;4. 怎么使用VisualTransition&lt;/h2&gt;
&lt;h3 id=&quot;隐式转换&quot;&gt;4.1 隐式转换&lt;/h3&gt;
&lt;p&gt;不使用Storyboard的VisualTransition称为隐式转换：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualStateGroup.Transitions&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualTransition&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; GeneratedDuration=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0:0:3&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualStateGroup.Transitions&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面这段XAML中的VisualTransition ，它指定VisualStateGroup中所有VisualState之间的过渡时间都是3秒，在这3秒中VisualState中的Double、Point和Color使用默认的线性插值方式进行动画转换。而其它值，如Visibility，则不可以使用隐式转换。&lt;/p&gt;
&lt;p&gt;这段XAML在Blend中对应“状态”面板里VisualStateGroup的“默认过渡”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/38937/201803/38937-20180321113207563-1599256292.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;隐式转换可以进一步设置其它属性，如以下XAML：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualStateGroup.Transitions&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualTransition&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; To=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PointerOver&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                      GeneratedDuration=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0:0:3&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualTransition.GeneratedEasingFunction&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;ExponentialEase&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; EasingMode=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;EaseOut&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualTransition.GeneratedEasingFunction&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualTransition&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualTransition&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; From=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PointerOver&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                      To=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Pressed&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                      GeneratedDuration=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0:0:3&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualTransition.GeneratedEasingFunction&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;ExponentialEase&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; EasingMode=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;EaseOut&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualTransition.GeneratedEasingFunction&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualTransition&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualStateGroup.Transitions&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段XAML中VisualTransition指定了以下三种属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;From和To，转换的旧状态和新状态，可以单独指定。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/38937/201803/38937-20180321113225483-816432783.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;动画的缓动函数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/38937/201803/38937-20180321113321003-1512896361.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用storyboard&quot;&gt;4.2 使用Storyboard&lt;/h3&gt;
&lt;p&gt;当隐式转换不能满足需求，可以使用Storyboard指定转换的动画。这时Storyboard不需要设置&lt;code&gt;FillBehavior=&quot;HoldEnd&quot;&lt;/code&gt;，因为Storyboard结束后将保持VisualState设置的最终状态。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualTransition&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; To=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PointerOver&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;Storyboard&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;ObjectAnimationUsingKeyFrames&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; Storyboard.TargetProperty=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;(UIElement.Visibility)&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                                       Storyboard.TargetName=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PointOverElement&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;DiscreteObjectKeyFrame&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; KeyTime=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;DiscreteObjectKeyFrame.Value&amp;gt;&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;&amp;lt;Visibility&amp;gt;&lt;/span&gt;Visible&lt;span class=&quot;kw&quot;&gt;&amp;lt;/Visibility&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;/DiscreteObjectKeyFrame.Value&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/DiscreteObjectKeyFrame&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ObjectAnimationUsingKeyFrames&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;DoubleAnimationUsingKeyFrames&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; Storyboard.TargetProperty=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;(UIElement.Opacity)&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                                       Storyboard.TargetName=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PointOverElement&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;EasingDoubleKeyFrame&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; KeyTime=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                                  Value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;EasingDoubleKeyFrame&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; KeyTime=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0:0:2&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                                  Value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;EasingDoubleKeyFrame.EasingFunction&amp;gt;&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;&amp;lt;CubicEase&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; EasingMode=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;EaseOut&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;/EasingDoubleKeyFrame.EasingFunction&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/EasingDoubleKeyFrame&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/DoubleAnimationUsingKeyFrames&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/Storyboard&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualTransition&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;VisualTransition&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; To=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Pressed&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;Storyboard&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;ObjectAnimationUsingKeyFrames&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; Storyboard.TargetProperty=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;(UIElement.Visibility)&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                                       Storyboard.TargetName=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PressElement&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;DiscreteObjectKeyFrame&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; KeyTime=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;DiscreteObjectKeyFrame.Value&amp;gt;&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;&amp;lt;Visibility&amp;gt;&lt;/span&gt;Visible&lt;span class=&quot;kw&quot;&gt;&amp;lt;/Visibility&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;/DiscreteObjectKeyFrame.Value&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/DiscreteObjectKeyFrame&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ObjectAnimationUsingKeyFrames&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;DoubleAnimationUsingKeyFrames&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; Storyboard.TargetProperty=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;(UIElement.Opacity)&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                                       Storyboard.TargetName=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;PressElement&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;EasingDoubleKeyFrame&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; KeyTime=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                                  Value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;EasingDoubleKeyFrame&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; KeyTime=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0:0:2&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                                  Value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;EasingDoubleKeyFrame.EasingFunction&amp;gt;&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;&amp;lt;CubicEase&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; EasingMode=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;EaseOut&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;/EasingDoubleKeyFrame.EasingFunction&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/EasingDoubleKeyFrame&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/DoubleAnimationUsingKeyFrames&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/Storyboard&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/VisualTransition&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/38937/201803/38937-20180321113304984-1513271531.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么有时候visualtransition没有生效&quot;&gt;5. 为什么有时候VisualTransition没有生效&lt;/h2&gt;
&lt;p&gt;ControlTemplate在VisualState之间切换是靠下面这个函数控制的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 摘要:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//     通过按名称请求新的 Windows.UI.Xaml.VisualState 来在两个状态之间转换控件。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 参数:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//   control:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//     要进行状态过渡的控件。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//   stateName:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//     要过渡到的状态。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//   useTransitions:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//     如果使用 Windows.UI.Xaml.VisualTransition 在各状态之间转换，则为 **true**。 如果跳过使用转换并直接转到请求的状态，则为&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//     **false**。 默认值为 **false**。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 返回结果:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//     如果控件成功转换到新状态或者已经在使用该状态，则为 **true**；否则为 **false**。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;GoToState&lt;/span&gt;(Control control, &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; stateName, &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt; useTransitions);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果useTransitions这个参数为false，则VisualState之间切换时不会使用VisualTransition。在控件加载模板时（即调用OnApplyTemplate()函数时）通常会这样做，因为控件在呈现时通常都不需要做动画。&lt;/p&gt;
&lt;p&gt;另外，VisualStateManager.GoToState不会使控件重复进入某个状态，即如果控件已处于PointerOver的VisualState，再次调用VisualStateManager.GoToState(this, PointerOverState, useTransitions)不会触发任何操作，也不会重复触发动画。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;6. 结语&lt;/h2&gt;
&lt;p&gt;除了VisualState.Setters，这篇文章的内容基本和WPF通用。&lt;/p&gt;
&lt;p&gt;上次被批评写得太复杂了，这次本来写了很多，为了文章简单易懂删了一半，希望对理解VisualTransition有帮助。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;7. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/windows/apps/windows.ui.xaml.visualtransition.aspx?f=255&amp;amp;MSPPError=-2147217396&quot;&gt;VisualTransition Class (Windows)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.visualtransition&quot;&gt;VisualTransition Class (Windows.UI.Xaml) - UWP app developer Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;8. 源码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/DinoChan/AnimationTest&quot;&gt;AnimationTest&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Mar 2018 05:56:00 +0000</pubDate>
<dc:creator>dino.c</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dino623/p/VisualTransition.html</dc:identifier>
</item>
<item>
<title>kubernetes实践之运行aspnetcore webapi微服务 - 据说甜蜜呢</title>
<link>http://www.cnblogs.com/justmine/p/8616423.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justmine/p/8616423.html</guid>
<description>&lt;ul&gt;&lt;li&gt;unbuntu 16.04 and above&lt;/li&gt;
&lt;li&gt;docker&lt;/li&gt;
&lt;li&gt;kubernetes 集群&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180321130128194-1041234930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180321130146459-61826687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;hello-world-deployment.yml如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180321130400118-2073837621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;hello-world-service.yml如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180321130449018-1966254490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了提供外部访问，注意需要修改type: NodePort。nodePort端口的范围：30000-32767。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180321150156594-149619867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180321130800914-898054704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180321130934681-1774555173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;浏览器上打开地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180321131144322-1105338798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这一步，说明服务部署成功！！！&lt;/p&gt;

&lt;p&gt;多刷新几次浏览器，然后查看服务日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180321131334415-2052236828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180321131341064-646402337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面分析可以看到两个副本pod都被不同程度的进行了调用。&lt;/p&gt;
&lt;p&gt;到目前为止，已经完成了k8s集群部署并运行微服务，下一篇将与微服务结合实践k8s的健康探测机制。&lt;/p&gt;
&lt;p&gt;参考源码：&lt;a href=&quot;https://github.com/justmine66/k8s.ecoysystem.apps&quot; target=&quot;_blank&quot;&gt;https://github.com/justmine66/k8s.ecoysystem.apps&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 21 Mar 2018 05:29:00 +0000</pubDate>
<dc:creator>据说甜蜜呢</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/justmine/p/8616423.html</dc:identifier>
</item>
<item>
<title>CVPR2018: Unsupervised Cross-dataset Person Re-identification by Transfer Learning of Spatio-temporal Patterns - 梦里风林</title>
<link>http://www.cnblogs.com/hellocwh/p/8616371.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellocwh/p/8616371.html</guid>
<description>&lt;p&gt;论文可以在&lt;a href=&quot;https://arxiv.org/abs/1803.07293&quot;&gt;arxiv下载&lt;/a&gt;，老板一作，本人二作，也是我们实验室第一篇CCF A类论文，这个方法我们称为TFusion。&lt;/p&gt;
&lt;p&gt;代码：&lt;a href=&quot;https://github.com/ahangchen/TFusion&quot; class=&quot;uri&quot;&gt;https://github.com/ahangchen/TFusion&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-e12da67722080fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;TFusion架构&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解决的目标是跨数据集的Person Reid&lt;/li&gt;
&lt;li&gt;属于无监督学习&lt;/li&gt;
&lt;li&gt;方法是多模态数据融合 + 迁移学习&lt;/li&gt;
&lt;li&gt;实验效果上，超越了所有无监督Person reid方法，逼近有监督方法，在部分数据集上甚至超越有监督方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文为你解读CVPR2018 TFusion&lt;/p&gt;
&lt;blockquote readability=&quot;3.5&quot;&gt;
&lt;p&gt;转载请注明作者&lt;a href=&quot;https://github.com/ahangchen&quot;&gt;梦里茶&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;task&quot;&gt;Task&lt;/h2&gt;
&lt;p&gt;行人重识别(Person Re-identification)是一个图像检索问题，给定一组图片集(probe)，对于probe中的每张图片，从候选图片集（gallery）中找到最可能属于同一个行人的图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-dceb0832370da28c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Person re-identification&quot;/&gt;&lt;/p&gt;
&lt;p&gt;行人重识别数据集是由一系列监控摄像头拍摄得到，并用检测算法将行人抠出，做行人的匹配。在这些数据集中，人脸是十分模糊的，无法作为匹配特征，而且由于多个摄像头拍摄视角不同，同个人可能被拍到正面，侧面，背面，具有不同的视觉特征，因此是一个比较难的图像匹配问题。常用数据集有很多，可以在&lt;a href=&quot;http://robustsystems.coe.neu.edu/sites/robustsystems.coe.neu.edu/files/systems/projectpages/reiddataset.html&quot;&gt;这个网站&lt;/a&gt;查到。&lt;/p&gt;

&lt;p&gt;行人重识别问题有以下几种常见的解决方案：&lt;/p&gt;
&lt;h3 id=&quot;基于视觉的行人重识别&quot;&gt;基于视觉的行人重识别&lt;/h3&gt;
&lt;p&gt;这类方法通常提取行人图像特征，对特征进行距离度量，从而判断是否是同一个人。&lt;/p&gt;
&lt;h4 id=&quot;有监督学习&quot;&gt;有监督学习&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-effac2981e749051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Supervised Learning&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这类方法通常需要提供行人图片和行人id标签（person1,person2等），训练模型，提取图像特征，根据两张图特征的距离大小（可以用余弦距离，欧氏距离之类的计算），为probe中的每张图和gallery中的每张图计算其相似度，根据相似度将gallery中的图片排序，排序越高越可能为同一个人。&lt;/p&gt;
&lt;p&gt;这方面的论文代表有TOMM2017: A Discriminatively Learned CNN Embedding for Person Re-identification，我们采用的基础图像分类器就是基于这篇论文用Keras实现的，后面细讲。&lt;/p&gt;
&lt;h4 id=&quot;无监督学习&quot;&gt;无监督学习&lt;/h4&gt;
&lt;p&gt;在CVPR2018之前，Person Reid领域正式发表的无监督工作只有CVPR2016的UMDL：Unsupervised Cross-Dataset Transfer Learning for Person Re-identification，基于字典学习方法，在多个源数据集上学习跨数据集不变性字典，迁移到目标数据集上。然而准确率依然很低。&lt;/p&gt;
&lt;h3 id=&quot;结合摄像头拓扑的行人重识别&quot;&gt;结合摄像头拓扑的行人重识别&lt;/h3&gt;
&lt;p&gt;行人图片是摄像头拍到的，摄像头之间有一定的距离，行人的移动有一定的速度限制，因此行人在摄像头间的移动时间就会呈现出一定规律，比如，AB摄像头间有10米，人行走速度2m/s，如果AB摄像头在1s内捕捉到了两张图片，则这两张图片不可能是同一个人的，因此我们可以利用摄像头拓扑约束来提升行人重识别的准确率。&lt;/p&gt;
&lt;p&gt;然而，这类方法往往有以下缺陷：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有些方法需要预先知道摄像头拓扑（AB摄像头之间的距离）&lt;/li&gt;
&lt;li&gt;有些方法可以根据拍摄到的图像数据推断出摄像头拓扑，但是需要图像有标注（是否是同一个人）&lt;/li&gt;
&lt;li&gt;即使推断出摄像头拓扑，与图像的融合结果依然很差&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;迁移学习&quot;&gt;迁移学习&lt;/h3&gt;
&lt;p&gt;迁移学习现在是深度学习领域很常用的一个套路了，在源数据集上预训练，在目标数据集上微调，从而使得源数据集上的模型能够适应目标场景。这方面的论文代表有前面讲的UMDL，和&lt;a href=&quot;http://cweihang.cn/ml/reid/deep_transfer_learning_person_reid.html&quot;&gt;Deep transfer learning person re-identification&lt;/a&gt;，然而，目前的迁移学习大多需要标签，而无监督迁移学习效果又很差，仍然有很大提升空间。&lt;/p&gt;
&lt;p&gt;更多关于Person Reid的内容可以看一下我在博客写的几篇&lt;a href=&quot;http://cweihang.cn/ml/reid/&quot;&gt;调研&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;motivation&quot;&gt;Motivation&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;现有的行人重识别数据集中是否包含时空信息？包含的话是否存在时空规律？&lt;/li&gt;
&lt;li&gt;缺乏两个时空点是否属于同一行人这种标签时，如何挖掘时空信息，构建时空模型？&lt;/li&gt;
&lt;li&gt;如何融合两个弱分类器？有监督的融合有boosting算法可以用，无监督呢？&lt;/li&gt;
&lt;li&gt;在缺乏标签的条件下，如何进行有效的迁移学习？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对应有三个创新点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无监督的时空模型构建&lt;/li&gt;
&lt;li&gt;基于贝叶斯推断的时空图像模型融合&lt;/li&gt;
&lt;li&gt;基于Learning to Rank的迁移学习&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来详细解析我们的方法。&lt;/p&gt;
&lt;h2 id=&quot;时空模型&quot;&gt;时空模型&lt;/h2&gt;
&lt;h3 id=&quot;数据集中的时空规律&quot;&gt;数据集中的时空规律&lt;/h3&gt;
&lt;p&gt;所谓时空模型，即一个摄像头网络中，行人在给定两个摄像头间迁移时间的分布。&lt;/p&gt;
&lt;p&gt;我们看遍所有Reid数据集，发现有三个数据集有时空信息，Market1501, GRID, DukeMTMC-ReID，其中，DukeMTMC-ReID是2017年后半年才出来的，时间比较仓促在论文中就没有包含跟它相关的实验。Market1501是一个比较大的Person Reid数据集，GRID是一个比较小的Person Reid数据集，并且都有六个摄像头（GRID中虽然介绍了8个摄像头，实际上只有6个摄像头的数据）。&lt;/p&gt;
&lt;p&gt;例如，Marke1501中一张图片的时空信息是写在图片名字中的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-d38ed2876b191571.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Market1501 sample.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;0007_c3s3_077419_03.jpg：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0007代表person id，&lt;/li&gt;
&lt;li&gt;c3代表是在3号摄像头拍到的，也就是空间信息，&lt;/li&gt;
&lt;li&gt;s3代表属于第3个时间序列（GRID和DukeMTMC中没有这个序列的信息，在Market1501中，不同序列的属于不同起始时间的视频，同一系列不同摄像头的视频起始时间相近）,&lt;/li&gt;
&lt;li&gt;077419为帧号，也就是时间信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我想吐槽的是，其实时空信息是非常容易保存的，只要知道图片是在什么时候，哪台摄像机上拍摄，就能够将时空信息记录并有效利用起来，希望多模态数据融合得到更多重视之后，做数据集的人能够更加重视可保存的信息吧。&lt;/p&gt;
&lt;p&gt;我们首先通过Market1501中的真实行人标签，计算训练集中所有&lt;code&gt;图片对&lt;/code&gt;对应的&lt;code&gt;时空点对&lt;/code&gt;对应的迁移时间，这里可视化了从摄像头1出发的行人，到达其他摄像头需要的时间的分布。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-d0d7655cc7b92cd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Market1501迁移时间分布&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，到达不同目标摄像头的峰值位置不同，其中从摄像头1到摄像头1，意味着被单个摄像头拍到连续多帧，所以峰值集中在0附近，从摄像头1到摄像头2，峰值集中在-600附近，意味着大部分人是单向从摄像头2运动到摄像头1，等等，并且，说明这个数据集中存在显著可利用的时空规律。&lt;/p&gt;
&lt;h3 id=&quot;无监督的时空模型构造&quot;&gt;无监督的时空模型构造&lt;/h3&gt;
&lt;p&gt;我们将迁移时间差命名为delta，这样说起来方便&lt;del&gt;(装逼)&lt;/del&gt;一点。&lt;/p&gt;
&lt;p&gt;如果我们能够统计一个数据集中的所有delta，给定一个新的delta（两个新的图片对应的两个时空点算出来的），我们能够用极大似然估计，用在这个delta前后一定范围(比如100帧)的delta的出现频率(=目标范围delta数量/总的delta数量)，作为新时间差出现的概率，也就是两个时空点是同一人产生的概率。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;但是！问题是我们在目标场景上往往是没有行人标记数据的！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是我们就&lt;em&gt;思考&lt;/em&gt;，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们能不能根据两个时空点对应的两张图是否属于同一个人，来决定两个时空点是否属于同一个人？&lt;/li&gt;
&lt;li&gt;而两张图是否属于同一个人，其实是一个图像匹配的二分类问题，我们可以用一些视觉模型来做，&lt;/li&gt;
&lt;li&gt;但是这种视觉模型往往是需要有标签训练的，无标签的视觉模型往往比较弱&lt;/li&gt;
&lt;li&gt;视觉模型弱没关系！我们相信跟时空模型结合就能变成一个强大的分类器！要有信仰！&lt;/li&gt;
&lt;li&gt;只要我们能无监督地把时空模型构造出来，结合弱的图像分类器，因为加了时空信息，一定能吊打其他无监督模型！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;思路有了，实现就很自然了，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们先在其他数据集上（于是我们就可以说这是一个跨数据集的任务了）预训练一个卷积神经网络，&lt;/li&gt;
&lt;li&gt;然后用这个卷积神经网络去目标数据集上提特征，&lt;/li&gt;
&lt;li&gt;用余弦距离算特征相似度&lt;/li&gt;
&lt;li&gt;将相似度排在前十的当做同一个人&lt;/li&gt;
&lt;li&gt;用这种“同一个人”的信息+极大似然估计构造时空模型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图像分类器上，我们这里用的是LiangZheng的Siamese网络，他们的源码是用MATLAB实现的，我用Keras&lt;a href=&quot;https://github.com/ahangchen/rank-reid/blob/master/pretrain/pair_train.py#L139&quot;&gt;复现&lt;/a&gt;了一把：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-189e8b7bf7ea5cb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Siamese Network&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时空模型的极大似然估计可以看&lt;a href=&quot;https://github.com/ahangchen/TrackViz/blob/simfus/train/st_estim.py#L30&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;聪明的读者应该会注意到，这个图像分类器是在其他数据及上预训练的，由于特征空间中数据分布不同，这个图像分类器太弱了，对于目标数据集来说，前十里会有许多错的样本，导致构造出来的时空模型和真实的时空模型有偏差&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-df7cd54990ccd68d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Distribution estimated&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，构造的模型跟真实的模型还是有些差别的，但是峰值位置还是差不多，一定程度上应该还能用，但我们还是希望构造的模型尽量接近真实模型的。&lt;/p&gt;
&lt;p&gt;于是我们开始&lt;em&gt;思考&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;导致模型出现偏差的因素是什么？是错误的样本对&lt;/li&gt;
&lt;li&gt;如何去掉错误样本对的影响？我们能不能把错误的样本对分离出来？没有标签咋办？&lt;/li&gt;
&lt;li&gt;（灵光一闪）错误的样本不就跟我瞎选的差不多？那我是不是可以随机地选样本对，算一个随机的delta分布出来&lt;/li&gt;
&lt;li&gt;将估算的delta分布去掉随机的delta分布，剩下的多出来的部分，就是由于正确的行人迁移产生的，不就得到真实的delta分布了？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是我们可视化了一下随机的delta分布&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-2f9896e3a7bed9c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Random Distribution&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确实与估计模型和真实模型不同&lt;/li&gt;
&lt;li&gt;存在较多抖动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种随机的时间差分布也呈现出一定的集中趋势，其实体现的是采样的时间差分布，如，在1号摄像头采的图片大多在某个时间段，2号摄像头也大多在这个时间段采，但3号摄像头的图片大多是在其他时间段采到的。&lt;/p&gt;
&lt;p&gt;考虑到时间差的频率图有这么多的抖动，我们在计算某个区域的时间差时，加上了均值滤波，并且做了一定区域的截断，包括概率极小值重置为一个最小概率值，时间差极大值重置为一个最大时间差。&lt;/p&gt;
&lt;p&gt;接下来，应该怎么把错误的模型从估计的模型滤掉呢？又怎么将时空模型和图像模型结合呢？&lt;/p&gt;
&lt;h2 id=&quot;基于贝叶斯推断的模型融合&quot;&gt;基于贝叶斯推断的模型融合&lt;/h2&gt;
&lt;p&gt;首先看时空模型和图像模型的融合， 我们有一个视觉相似度P&lt;sub&gt;v&lt;/sub&gt;，一个时空概率P&lt;sub&gt;st&lt;/sub&gt;，一个直观的想法是，联合评分可以是P&lt;sub&gt;v&lt;/sub&gt; * P&lt;sub&gt;st&lt;/sub&gt;，如果要再抑制随机的评分P&lt;sub&gt;random&lt;/sub&gt;，可以做个除法，就是P&lt;sub&gt;v&lt;/sub&gt; * P&lt;sub&gt;st&lt;/sub&gt; / P&lt;sub&gt;random&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;这样一看，像不像条件概率公式？于是我们开始推导（大量公式预警）：&lt;/p&gt;
&lt;p&gt;先看看我们手上的资源：现在我们有一个弱的图像分类器，可以为两张图片提取两个视觉特征v&lt;sub&gt;i&lt;/sub&gt;, v&lt;sub&gt;j&lt;/sub&gt;, 有两个时空点，空间特征为两个摄像头编号c&lt;sub&gt;i&lt;/sub&gt;, c&lt;sub&gt;j&lt;/sub&gt;，时间特征为两张图片拍摄的时间差∆&lt;sub&gt;ij&lt;/sub&gt;，假定两张图对应的person id分别为P&lt;sub&gt;i&lt;/sub&gt;, P&lt;sub&gt;j&lt;/sub&gt;，那么我们的目标就是求，在给定这些特征的条件下，两张图属于同一个人的概率&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;,c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;)（论文公式6）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由条件概率公式P(A|B) = P(B|A)*P(A)/P(B)，可得&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;,c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;)&lt;br/&gt;= Pr(v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;,c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;) *Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;)/ Pr(v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;,c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由时空分布和图像分布的独立性假设（长得像的人运动规律不一定像），我们可以拆解第一项，得到&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;= Pr(v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;)&lt;em&gt;Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;)&lt;/em&gt; Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;)/ Pr(v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;,c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;)是一个不好求的项，我们试着把它换掉，&lt;/p&gt;
&lt;p&gt;先交换顺序（乘法交换律）&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;= Pr(v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;) * Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;)*Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;) / Pr(v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;,c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由条件概率公式P(A|B)&lt;em&gt;P(B) = P(B|A)&lt;/em&gt; P(A)可得&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;= Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;) * Pr(v&lt;sub&gt;i&lt;/sub&gt;=v&lt;sub&gt;j&lt;/sub&gt;)*Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;) / Pr(v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;,c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;)可理解为两张图从视觉特征相似度上判定为同一人的概率&lt;/li&gt;
&lt;li&gt;Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;)就是两个时空点是同一个人移动产生的概率&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再次利用时空分布和图像分布的独立性假设，拆解分母&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;= Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;) * Pr(v&lt;sub&gt;i&lt;/sub&gt;=v&lt;sub&gt;j&lt;/sub&gt;)&lt;em&gt;Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;) / Pr(v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;)&lt;/em&gt; P(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;约掉Pr(v&lt;sub&gt;i&lt;/sub&gt;=v&lt;sub&gt;j&lt;/sub&gt;)，&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;= Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;) * Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;) /P(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;= 视觉相似度*同一人产生这种移动的概率/任意两个时空点组成这种移动的概率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这也就是论文公式(7)，也就是我们一开始的猜想：P&lt;sub&gt;v&lt;/sub&gt; * P&lt;sub&gt;st&lt;/sub&gt; / P&lt;sub&gt;random&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;看着好像很接近我们手头掌握的资源了，但是，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们并不知道理想的两张图的视觉相似度 Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;) ，只有我们的图像分类器判定的两张图的视觉相似度 Pr(S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;) ，&lt;/li&gt;
&lt;li&gt;我们并不能计算同一人产生这种移动的真实概率Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;) ，我们只有依据视觉分类器估算的时空概率Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;) ，&lt;/li&gt;
&lt;li&gt;我们倒是确实有数据集中任意两个时空点产生这种移动的概率P(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是我们想用Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;) ，P(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;)去近似，得到&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;= Pr(S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;) * Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;) /P(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到这里其实就大致理解我们的融合原理了，实际上我们大部分实验也是用的这个近似公式算的。&lt;/p&gt;
&lt;p&gt;实现上，先模拟两个时空模型，计算图像相似度，然后代入公式求融合评分，具体可以实现看&lt;a href=&quot;https://github.com/ahangchen/TrackViz/blob/simfus/train/st_filter.py&quot;&gt;我GitHub&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;但这个近似能不能做呢？我们来做一下误差分析（大量推导，不感兴趣可以跳到接下来出现的第二张图，不影响后面的理解，只是分析一波会更加严谨）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际上，误差是由图像分类器引入的，假设图像分类器判定两张图是同一个人的错判率为E&lt;sub&gt;p&lt;/sub&gt;，图像分类器判定两张图不是同一人的错判率为E&lt;sub&gt;n&lt;/sub&gt;，&lt;/p&gt;
&lt;p&gt;则有，&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;E&lt;sub&gt;p&lt;/sub&gt; = Pr(P&lt;sub&gt;i&lt;/sub&gt;≠P&lt;sub&gt;j&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;)（论文公式1）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;E&lt;sub&gt;n&lt;/sub&gt; = Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;≠S&lt;sub&gt;j&lt;/sub&gt;)（论文公式2）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;则Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;) 与 Pr(S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;) 的关系可以表示为：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;)&lt;br/&gt;= Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;) * Pr(S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;) + Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;≠S&lt;sub&gt;j&lt;/sub&gt;) * Pr(S&lt;sub&gt;i&lt;/sub&gt;≠S&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;)&lt;br/&gt;= (1-E&lt;sub&gt;p&lt;/sub&gt;) * Pr(S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;) + E&lt;sub&gt;n&lt;/sub&gt;* (1-Pr(S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;) )&lt;br/&gt;= (1-E&lt;sub&gt;p&lt;/sub&gt;-E&lt;sub&gt;n&lt;/sub&gt;) * Pr(S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;) + E&lt;sub&gt;n&lt;/sub&gt; （论文公式8）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推导，Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;) 和Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;) 的关系（这个没法像视觉相似度那样直接推导，因为因果关系不同）&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;)&lt;br/&gt;= Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;) * (Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;)|S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;) + Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;≠P&lt;sub&gt;j&lt;/sub&gt;) * (Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;)|S&lt;sub&gt;i&lt;/sub&gt;≠S&lt;sub&gt;j&lt;/sub&gt;)&lt;br/&gt;= Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;) * (1- E&lt;sub&gt;p&lt;/sub&gt;) + Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;≠P&lt;sub&gt;j&lt;/sub&gt;) * E&lt;sub&gt;p&lt;/sub&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同样可以得到&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;≠S&lt;sub&gt;j&lt;/sub&gt;)&lt;br/&gt;= Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;) * E&lt;sub&gt;n&lt;/sub&gt; + Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;≠P&lt;sub&gt;j&lt;/sub&gt;) * (1 - E&lt;sub&gt;p&lt;/sub&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;联立上面两个式子解方程，消掉Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;≠S&lt;sub&gt;j&lt;/sub&gt;) 可以得到&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt;)&lt;br/&gt;= (1 - E&lt;sub&gt;p&lt;/sub&gt; - E&lt;sub&gt;n&lt;/sub&gt;)&lt;sup&gt;-1&lt;/sup&gt;(1-E&lt;sub&gt;n&lt;/sub&gt;) * Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;) - E&lt;sub&gt;p&lt;/sub&gt; * Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;≠S&lt;sub&gt;j&lt;/sub&gt;) （论文公式5）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中有个新概念Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;≠S&lt;sub&gt;j&lt;/sub&gt;) ，意味着图像分类器认为不是同一个人的时候，这种时空点出现的概率，实现上也不难，统计视觉相似度top10以后的点对应的时间差，作为反时空概率模型即可。&lt;/p&gt;
&lt;p&gt;我们把两个近似（公式5和公式8）代进公式7，&lt;/p&gt;
&lt;p&gt;可以得到&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;Pr(P&lt;sub&gt;i&lt;/sub&gt;=P&lt;sub&gt;j&lt;/sub&gt; | v&lt;sub&gt;i&lt;/sub&gt;, v&lt;sub&gt;j&lt;/sub&gt;, ∆&lt;sub&gt;ij&lt;/sub&gt;, c&lt;sub&gt;i&lt;/sub&gt;, c&lt;sub&gt;j&lt;/sub&gt;)&lt;br/&gt;= (M&lt;sub&gt;1&lt;/sub&gt; + E&lt;sub&gt;n&lt;/sub&gt;/(1 - E&lt;sub&gt;n&lt;/sub&gt; - E&lt;sub&gt;p&lt;/sub&gt;))((1-E&lt;sub&gt;n&lt;/sub&gt;)M&lt;sub&gt;2&lt;/sub&gt; - E&lt;sub&gt;p&lt;/sub&gt;M&lt;sub&gt;3&lt;/sub&gt;)/Pr(∆&lt;sub&gt;ij&lt;/sub&gt;, c&lt;sub&gt;i&lt;/sub&gt;, c&lt;sub&gt;j&lt;/sub&gt;))（论文公式9）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中，&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;M&lt;sub&gt;1&lt;/sub&gt; = Pr(S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;)，视觉相似度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;M&lt;sub&gt;2&lt;/sub&gt; = Pr(∆&lt;sub&gt;ij&lt;/sub&gt;,c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;)，正时空概率模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;M&lt;sub&gt;3&lt;/sub&gt; = Pr(∆&lt;sub&gt;ij&lt;/sub&gt;,c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;≠S&lt;sub&gt;j&lt;/sub&gt;)，反时空概率模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分母Pr(∆&lt;sub&gt;ij&lt;/sub&gt;, c&lt;sub&gt;i&lt;/sub&gt;, c&lt;sub&gt;j&lt;/sub&gt;))为随机概率模型&lt;/p&gt;
&lt;p&gt;以上四项都是可以从无标签目标数据集中结合图像分类器求解到的，并且，当En=Ep=0时（意味着图像分类器完全准确），这个公式可以退化为近似解：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Pr(S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;|v&lt;sub&gt;i&lt;/sub&gt;,v&lt;sub&gt;j&lt;/sub&gt;) * Pr(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;|S&lt;sub&gt;i&lt;/sub&gt;=S&lt;sub&gt;j&lt;/sub&gt;) /P(c&lt;sub&gt;i&lt;/sub&gt;,c&lt;sub&gt;j&lt;/sub&gt;,∆&lt;sub&gt;ij&lt;/sub&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;到这里，你是不是以为我们就可以用公式9算融合评分了？非也，公式9中，还有个问题：E&lt;sub&gt;p&lt;/sub&gt;，E&lt;sub&gt;n&lt;/sub&gt;是未知的！&lt;/p&gt;
&lt;p&gt;如果想要正儿八经地算E&lt;sub&gt;p&lt;/sub&gt;，E&lt;sub&gt;n&lt;/sub&gt;，要求目标数据集有标签，然后我们用图像分类器先算一遍，数数哪些算错了，才能把E&lt;sub&gt;p&lt;/sub&gt;，E&lt;sub&gt;n&lt;/sub&gt;算出来。因此我们用两个常数α和β分别替代E&lt;sub&gt;p&lt;/sub&gt;，E&lt;sub&gt;n&lt;/sub&gt;，整个模型的近似就都集中在了这两个常数上。&lt;/p&gt;
&lt;p&gt;在论文Table1,2,3,4,Fig6相关的实验中，α=β=0，并且，在Fig5中，我们设置了其他常数来检查模型对于这种近似的敏感性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-6b184c67dcb77ec9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Parameter Sensity&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，虽然α和β较大时，准确率会有所下降，但是仍然能保持一定的水准，当你看到纯图像分类器的准确率之后，还会发现融合模型的准确率一直高于纯图像分类器。&lt;/p&gt;
&lt;p&gt;你可能注意到了，图中α+β都是小于1的，这是因为，只有当E&lt;sub&gt;p&lt;/sub&gt;+E&lt;sub&gt;n&amp;lt;/sub&amp;gt;&amp;lt;1且α+β&amp;lt;1时，融合模型的E&lt;sub&gt;p&lt;/sub&gt;+E&lt;sub&gt;n&lt;/sub&gt;才会小于图像模型的E&lt;sub&gt;p&lt;/sub&gt;+E&lt;sub&gt;n&lt;/sub&gt;，说人话就是，只有图像模型不是特别糟糕，且近似的参数也比较正常的时候，融合模型才会比单个的图像模型要准，融合才有意义。这个定理的具体的证明放到论文附录里了，有兴趣的可以邮件私信我拿附录去看，这里摆出来就太多了。&lt;/sub&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;于是我们得到了一个由条件概率推断支撑的多模态数据融合方法，称为贝叶斯融合&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看一眼融合得到的时空分布图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-5720d618df7f4285.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再从数据上看一眼融合的模型有多强：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;rank-1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;rank-5&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;rank-10&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;rank-1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;rank-5&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;rank-10&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;CUHK01&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;10.70&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;20.20&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;23.80&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;30.90&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;63.70&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;79.10&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;VIPeR&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;9.70&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;17.40&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;21.50&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;28.40&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;65.60&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;80.40&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;17.80&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;31.20&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;36.80&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;49.60&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;81.40&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;88.70&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;20.72&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;35.39&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;42.99&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;51.16&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;65.08&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;70.04&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;VIPeR&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;24.70&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;40.91&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;49.52&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;56.18&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;71.50&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;76.48&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;CUHK01&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;29.39&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;45.46&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;52.55&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;56.53&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;70.22&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;74.64&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以看到，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;跨数据集直接迁移效果确实很差&lt;/li&gt;
&lt;li&gt;融合之后的准确率Rank1准确率变成2-4倍&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明这种融合方式是确实行之有效的。&lt;/p&gt;
&lt;h2 id=&quot;基于learning-to-rank的迁移学习&quot;&gt;基于Learning to Rank的迁移学习&lt;/h2&gt;
&lt;p&gt;前面讲到图像分类器太弱了，虽然融合后效果挺好的（这个时候我们其实想着要不就这样投个NIPS算了），但是如果能提升图像分类器，融合的效果理论上会更好。而现在我们有了一个强大的融合分类器，我们能不能用这个融合分类器为目标数据集的图片打标签，反过来训练图像分类器呢？&lt;/p&gt;
&lt;p&gt;一个常用的无监督学习套路就是，根据融合评分的高低，将图片对分为正样本对和负样本对（打伪标签），然后喂给图像分类器学习。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-cadc341fdcacc6ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Canonial Unsupervised Learning&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们也尝试了这种做法，但是发现，数据集中负样本远远多于正样本，融合分类器分对的负样本是挺多的，但是分对的正样本超级少，分错的正样本很多，错样本太多，训练出来效果极差，用上一些hard ming的技巧也不行。&lt;/p&gt;
&lt;p&gt;于是我们&lt;em&gt;思考&lt;/em&gt;，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们无法提供正确的01标签，分类器就只能学到许多错的01标签&lt;/li&gt;
&lt;li&gt;我们是否可以提供一些软标签，让分类器去学习回归两个样本之间的评分，而不是直接学习二分类的标签？&lt;/li&gt;
&lt;li&gt;这是一个图像检索问题，我们能不能用信息检索中的一些学习方法来完成这个任务？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是自然而然地想到了Learning to Rank&lt;/p&gt;
&lt;h3 id=&quot;ranking&quot;&gt;Ranking&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;问题定义：给定一个对象，寻找与其最相关的结果，按相关程度排序&lt;/li&gt;
&lt;li&gt;常用方法：&lt;/li&gt;
&lt;li&gt;Point-wise：每一个结果算一个绝对得分，然后按得分排序&lt;/li&gt;
&lt;li&gt;Pair-wise：每两个结果算一下谁的得分高，然后按这个相对得分排序&lt;/li&gt;
&lt;li&gt;List-wise：枚举所有排列情况，计算综合得分最高的一种作为排序结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综合得分往往需要许多复杂的条件来计算，不一定适用于我们的场景，所以排除List-wise，Point-wise和Pair-wise都可以采用，得分可以直接用融合评分表示，Pair-wise可以用一组正序样本，一组逆序样本，计算两个得分，算相对得分来学习，有点Triplet loss的意味，于是在实验中采用了Pair-wise方法。&lt;/p&gt;
&lt;h3 id=&quot;pair-wise-ranking&quot;&gt;Pair-wise Ranking&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;给定样本x&lt;sub&gt;i&lt;/sub&gt;，其排序得分为o&lt;sub&gt;i&lt;/sub&gt;，&lt;/li&gt;
&lt;li&gt;给定样本x&lt;sub&gt;j&lt;/sub&gt;，其排序得分为o&lt;sub&gt;j&lt;/sub&gt;，&lt;/li&gt;
&lt;li&gt;定义o&lt;sub&gt;ij&lt;/sub&gt;=o&lt;sub&gt;i&lt;/sub&gt; - o&lt;sub&gt;j&lt;/sub&gt;，如果o&lt;sub&gt;ij&lt;/sub&gt;&amp;gt;0说明x&lt;sub&gt;i&lt;/sub&gt;的排名高于x&lt;sub&gt;j&lt;/sub&gt;，&lt;/li&gt;
&lt;li&gt;将这个排名概率化，定义P&lt;sub&gt;ij&lt;/sub&gt; = e&lt;sup&gt;o&lt;sub&gt;ij&lt;/sub&gt;&lt;/sup&gt;/(1+e&lt;sup&gt;o&lt;sub&gt;ij&lt;/sub&gt;&lt;/sup&gt;)，为x&lt;sub&gt;i&lt;/sub&gt;排名高于x&lt;sub&gt;j&lt;/sub&gt;的概率。&lt;/li&gt;
&lt;li&gt;对于任何一个长度为n的排列，只要知道n-1个相邻item的概率P&lt;sub&gt;i,i+1&lt;/sub&gt;，就可以推断出来任何两个item的排序概率&lt;/li&gt;
&lt;li&gt;例如，已知P&lt;sub&gt;ik&lt;/sub&gt;和P&lt;sub&gt;kj&lt;/sub&gt;，P&lt;sub&gt;ij&lt;/sub&gt; = P&lt;sub&gt;ik&lt;/sub&gt; * P&lt;sub&gt;kj&lt;/sub&gt; = e&lt;sup&gt;o&lt;sub&gt;ik&lt;/sub&gt;+o&lt;sub&gt;kj&lt;/sub&gt;&lt;/sup&gt;/(1 + e&lt;sup&gt;o&lt;sub&gt;ik&lt;/sub&gt;+o&lt;sub&gt;kj&lt;/sub&gt;&lt;/sup&gt;)，其中o&lt;sub&gt;ik&lt;/sub&gt;=ln(P&lt;sub&gt;ik&lt;/sub&gt;/(1 - P&lt;sub&gt;ik&lt;/sub&gt;))&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;ranknet-pair-wise-learning-to-rank&quot;&gt;RankNet: Pair-wise Learning to Rank&lt;/h3&gt;
&lt;p&gt;RankNet是Pair-wise Learning to Rank的一种方法，用一个神经网络去学习输入的两个样本（还有一个query样本）与其排序概率（上面定义的）的映射关系。&lt;/p&gt;
&lt;p&gt;具体到我们这个问题里&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;给定查询图片A，给定待匹配图片B和C&lt;/li&gt;
&lt;li&gt;用神经网络预测AB之间的相似度S&lt;sub&gt;ab&lt;/sub&gt;为B的绝对排序得分，计算AC之间的相似度S&lt;sub&gt;ac&lt;/sub&gt;为C的绝对排序得分&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;4.1538461538462&quot;&gt;
&lt;p&gt;具体的神经网络用&lt;a href=&quot;https://github.com/ahangchen/rank-reid/blob/master/transfer/simple_rank_transfer.py&quot;&gt;Keras实现&lt;/a&gt;并可视化出来长这样：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-127847c893cdfdfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Keras-Ranknet&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;输入是三张图片，分别用Resnet52提取特征并flatten&lt;/li&gt;
&lt;li&gt;flatten之后写一个Lambda层+全连接层算特征向量带权重的几何距离，得到score1和score2&lt;/li&gt;
&lt;li&gt;用score1和score2和真实分数算交叉熵Loss（下面讲）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;则B排序高于C的概率为：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;P&lt;sub&gt;bc&lt;/sub&gt;= e&lt;sup&gt;o&lt;sub&gt;bc&lt;/sub&gt;&lt;/sup&gt;/(1+ e&lt;sup&gt;o&lt;sub&gt;bc&lt;/sub&gt;&lt;/sup&gt;) = e&lt;sup&gt;S&lt;sub&gt;ab- S&lt;sub&gt;ac&lt;/sub&gt;&lt;/sub&gt;&lt;/sup&gt; / (1 + e&lt;sup&gt;S&lt;sub&gt;ab- S&lt;sub&gt;ac&lt;/sub&gt;&lt;/sub&gt;&lt;/sup&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;用预测概率P&lt;sub&gt;bc&lt;/sub&gt;去拟合真实的排序概率，回归损失用预测概率和真实概率的交叉熵表达&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;C(o&lt;sub&gt;bc&lt;/sub&gt;) = -P'&lt;sub&gt;bc&lt;/sub&gt;ln P&lt;sub&gt;bc&lt;/sub&gt; - (1-P'&lt;sub&gt;bc&lt;/sub&gt;)ln (1 - P&lt;sub&gt;bc&lt;/sub&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;网络实现超级简单，主要麻烦在样本三元组构造&lt;/p&gt;
&lt;h3 id=&quot;transfer-learning-to-rank&quot;&gt;Transfer Learning to rank&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;整个Learning to rank过程如图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-e6de1301e73c60a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Learning to rank&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们用融合分类器为目标数据集中的图片对评分，构造三元组输入RankNet，其中S&lt;sub&gt;i&lt;/sub&gt;是查询图，S&lt;sub&gt;j&lt;/sub&gt;是在与S&lt;sub&gt;i&lt;/sub&gt;融合相似度top1 - top25中抽取的图片，S&lt;sub&gt;k&lt;/sub&gt;是在与S&lt;sub&gt;i&lt;/sub&gt;融合相似度top25 - top50中抽取的图片，喂给RankNet学习，使得resnet52部分卷积层能充分学习到目标场景上的视觉特征。&lt;/p&gt;
&lt;h3 id=&quot;learning-to-rank效果&quot;&gt;Learning to Rank效果&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;rank-1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;rank-5&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;rank-10&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;rank-1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;rank-5&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;rank-10&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;CUHK01&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;17.40&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;33.90&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;41.10&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;50.90&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;78.60&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;88.30&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;VIPeR&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;18.50&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;31.40&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;40.50&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;52.70&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;81.70&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;89.20&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;22.30&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;38.10&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;47.20&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;60.40&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;87.30&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;93.40&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;22.38&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;39.25&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;48.07&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;58.22&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;72.33&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;76.84&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;VIPeR&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;25.23&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;41.98&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;50.33&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;59.17&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;73.49&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;78.62&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;CUHK01&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;30.58&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;47.09&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;54.60&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;60.75&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;74.44&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;79.25&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;对比Learning to Rank前的效果，准确率都提升了，GRID数据集上提升尤为明显。&lt;/p&gt;
&lt;h4 id=&quot;对比soa有监督方法&quot;&gt;对比SOA有监督方法&lt;/h4&gt;
&lt;p&gt;一方面，我们将上面的跨数据集无监督算法应用在GRID和Market1501两个数据集上，与当前最好的方法进行对比，另一方面，我们还测试了有监督版本的效果，有监督即源数据集与目标数据集一致，如GRID预训练-&amp;gt;GRID融合时空，效果如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;JLML&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;37.5&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;TFusion无监督&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;60.4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;TFusion有监督&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;64.1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;由于在这个数据集上时空规律十分明显（正确时间差都集中在一个很小的范围内），可以过滤掉大量错误分类结果，所以准确率甚至碾压了全部有监督方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Market1501&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;S-CNN&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;65.88&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;DLCE&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;79.5&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;SVDNet&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;82.3&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;JLML&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;88.8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;TFusion无监督&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;60.75&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;TFusion有监督&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;73.13&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在Market1501这个数据集上，无监督的方法逼近2016年的有监督方法（我们的图像分类器只是一个ResNet52)，有监督的方法超越2016年的有监督方法，虽然比不上2017年的有监督方法，但是如果结合其他更好的图像分类器，应该能有更好的效果。&lt;/p&gt;
&lt;h4 id=&quot;对比soa无监督方法&quot;&gt;对比SOA无监督方法&lt;/h4&gt;
&lt;p&gt;我们向UMDL的作者要到了代码，并复现了如下几组跨数据集迁移实验&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;UMDL&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;3.77&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;UMDL&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;CUHK01&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;3.58&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;UMDL&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;VIPeR&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;3.97&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;UMDL&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;30.46&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;UMDL&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;CUHK01&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;29.69&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;UMDL&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;VIPeR&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;30.34&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;TFusion&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;60.4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;TFusion&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;CUHK01&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;50.9&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;TFusion&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;VIPeR&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;52.7&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;TFusion&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;GRID&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;58.22&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;TFusion&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;CUHK01&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;59.17&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;TFusion&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;VIPeR&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Market1501&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;60.75&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中，UMDL迁移到Market1501的结果与悉尼科技大学hehefan与LiangZheng&lt;a href=&quot;https://github.com/hehefan/Unsupervised-Person-Re-identification-Clustering-and-Fine-tuning/tree/master/dataset/Duke&quot;&gt;复现&lt;/a&gt;出来的效果差不多，所以我们的复现是靠谱的。&lt;/p&gt;
&lt;p&gt;可以看到，无监督的TFusion全面碾压UMDL。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;更多详细实验结果可以到论文中细看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;多次迭代迁移学习&quot;&gt;多次迭代迁移学习&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-e12da67722080fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;TFusion架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回顾一下整个架构，我们用图像分类器估算时空模型，得到融合模型，用融合模型反过来提升图像分类器模型，图像分类器又能继续增强融合模型，形成一个&lt;code&gt;闭环&lt;/code&gt;，理论上这个闭环循环多次，能让图像分类器无限逼近融合分类器，从而得到一个目标场景中也很强大的图像分类器，因此我们做了多次迭代的尝试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-8d08ac23fde1f63f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Iteratively Learning&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在从目前的实验效果看，第一次迁移学习提升比较大，后面提升就比较小了，这个现象往好了说可以是收敛快，但往坏了说，虽然图像分类器得到了提升，但是没有出现图像分类器提升大于融合分类器的现象，所以这里边应该还有东西可挖。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-d413ef3d25204476.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;My Github streak&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调研，可视化，找思路，找数据集，做实验，Debug，调参，写论文，九个月写一篇CVPR，这也是我们实验室第一篇CCF A类论文，算是来之不易的开山之作了。现在我们在Person Reid领域继续探索，正在搭建一个基于树莓派的摄像头网络，构造自己的数据集，并在这个基础上开展行人检测，多模态数据融合，轻量级深度模型，分布式协同终端，视频哈希，图像索引等一系列研究，欢迎follow我的&lt;a href=&quot;https://github.com/ahangchen&quot;&gt;Github&lt;/a&gt;，也欢迎持续关注我们&lt;a href=&quot;http://blog.so-link.org/&quot;&gt;实验室的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看了这么久，还不给我&lt;a href=&quot;https://github.com/ahangchen/TFusion&quot;&gt;Github&lt;/a&gt;点star！&lt;/p&gt;
</description>
<pubDate>Wed, 21 Mar 2018 05:01:00 +0000</pubDate>
<dc:creator>梦里风林</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hellocwh/p/8616371.html</dc:identifier>
</item>
<item>
<title>关于 promise 吃到错误的理解 - 另一个小菜头</title>
<link>http://www.cnblogs.com/CccZss/p/8616356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CccZss/p/8616356.html</guid>
<description>&lt;p&gt;下面的内容需要对浏览器原生支持的 promise 的基本用法有了解，如果你还不知道 promise 和 promise 的 catch 方法，你可能需要先在 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/promise&quot;&gt;这里&lt;/a&gt; 了解一下。&lt;/p&gt;
&lt;p&gt;在 阮一峰大神的 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/promise&quot;&gt;《ECMAScript 6 入门》&lt;/a&gt; 关于 Promise 对象那一章在介绍 &lt;code&gt;Promise.prototype.catch()&lt;/code&gt; 方法时，里面有一句描述是这样写的 :&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;跟传统的&lt;code&gt;try/catch&lt;/code&gt;代码块不同的是，如果没有使用&lt;code&gt;catch&lt;/code&gt;方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始我 &lt;strong&gt;错误的理解&lt;/strong&gt; 了这句话的意思，认为是在 promise 内部如果发生错误的话，可以使用 catch 方法来捕获错误，但是如果不使用 catch 方法，它会静悄悄的，不会有报错，就像加了 try-catch 但是在 catch 里面不进行任何处理。&lt;/p&gt;
&lt;p&gt;然后我做了一些测试发现和我想的不一样：&lt;/p&gt;
&lt;p&gt;首先，试一下在 promise 里面抛出一个异常，看看能不能通过 catch 捕获到&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; promise &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(resolve&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; reject) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'test'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;// 这里抛了一个异常&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
promise
    .&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    .&lt;span class=&quot;at&quot;&gt;catch&lt;/span&gt;((err) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'promise catch err'&lt;/span&gt;))

&lt;span class=&quot;co&quot;&gt;// 控制台输出:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// promise catch err&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没什么问题，catch 方法成功捕获到异常了，但是这个异常会不会再被抛到外面去呢？为了以防万一，我们在window 对象上加个 onerror 事件监测一下看看&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onerror&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'window err'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; promise &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(resolve&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; reject) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'test'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
promise
    .&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    .&lt;span class=&quot;at&quot;&gt;catch&lt;/span&gt;((err) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'promise catch err'&lt;/span&gt;))

&lt;span class=&quot;co&quot;&gt;// 控制台输出:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// promise catch err&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果还是一样，说明 catch 方法成功捕获到异常而且没有继续往外面抛，这和书里说的一样&lt;/p&gt;
&lt;p&gt;那如果去掉 catch 方法呢？我们继续往下看&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; promise &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(resolve&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; reject) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'test'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;promise&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)    &lt;span class=&quot;co&quot;&gt;// 这里不捕获异常了&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 控制台输出:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// Uncaught (in promise) Error: test&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里控制台输出了一个报错：&lt;code&gt;Uncaught (in promise) Error: test&lt;/code&gt;，咦，如果像书里说的：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;跟传统的&lt;code&gt;try/catch&lt;/code&gt;代码块不同的是，如果没有使用&lt;code&gt;catch&lt;/code&gt;方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面说不会有任何反应，那怎么控制台还会报错呢？&lt;/p&gt;
&lt;p&gt;我们可以猜测一下，其实这里有点像使用 try-catch 那样捕获了异常然后打印出错误信息后就不再做其他处理一样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;cf&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(x)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;catch&lt;/span&gt;(err)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;error&lt;/span&gt;(err)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们加一个 window.onerror 发现，这时 promise 外面添加错误监听事件不会捕获到 promise 对象里面没有进行捕获的错误，像下面这样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onerror&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;// 我们添加了 window 的 onerror 处理函数&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'window err'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; 

promise &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(resolve&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; reject) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'test'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;promise&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)   

&lt;span class=&quot;co&quot;&gt;// 控制台输出:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// Uncaught (in promise) Error: test   &lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到 window 的错误处理事件并没有被触发，所以报错应该是 promise 内部捕获处理的时候直接打印的而没有被抛出，也就验证了我们上面的猜测。&lt;/p&gt;
&lt;p&gt;所以到这里，我们可以把书上那句话重新翻译一下得到一条&lt;strong&gt;结论&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;promise 对象里面同步代码抛出的错误在没有通过 promise 的 catch 方法捕获时是会打印报错的（不会阻止 promise 外面代码的执行），但是不会传递到外面触发其他错误监听函数（比如 window.onerror 、try-catch 等）&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;书上还讲到一个东西也挺奇怪的&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onerror&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'window err'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; promise &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (resolve&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; reject) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;cf&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'test'&lt;/span&gt;) 
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)

    &lt;span class=&quot;at&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'ok'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
promise
    .&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    .&lt;span class=&quot;at&quot;&gt;catch&lt;/span&gt;(() &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'promise catch err'&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据我们上面的理解，你觉得这个控制台会显示什么东西呢？&lt;/p&gt;
&lt;p&gt;如果你对答案是 &lt;code&gt;promise catch err&lt;/code&gt;，那你就错了，他的结果是：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 控制台输出:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// ok&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// window err&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// Uncaught Error: test&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里由于是在 &lt;code&gt;setTimeout&lt;/code&gt; 里面抛出错误的，所以报错会在同步代码执行完后的下一轮 “事件循环” 里执行，也就是说当 &lt;code&gt;setTimeout&lt;/code&gt; 里面的函数执行后报错时，promise 已经执行完了（所以就算 &lt;code&gt;resolve('ok')&lt;/code&gt; 写在 &lt;code&gt;setTimeout&lt;/code&gt; 下面也是先输出 ok），所以这个错误是在 Promise 函数体外抛出的，当然也就不会被 promise 的 catch 方法捕获，所以就会传到 window 上被捕获并输出 &lt;code&gt;window err&lt;/code&gt;，然后再被浏览器捕获输出&lt;code&gt;Uncaught Error: test&lt;/code&gt;，如果在 window onerror 处理程序里面 return true，就不会看到浏览器捕获输出的 &lt;code&gt;Uncaught Error: test&lt;/code&gt; 报错。&lt;/p&gt;
&lt;p&gt;再看一下 下面的两个例子：&lt;/p&gt;
&lt;p&gt;这里是在 promise 里面同步执行了 throw Error 和 resolve 两个操作&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onerror&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'window err'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; promise &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (resolve&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; reject) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'test'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'ok'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;promise&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    .&lt;span class=&quot;at&quot;&gt;catch&lt;/span&gt;(() &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'promise catch err'&lt;/span&gt;))

&lt;span class=&quot;co&quot;&gt;// 控制台输出:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// promise catch err&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里是在 promise 里面用 setTimeout 异步执行了 throw Error 和 resolve 两个操作&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onerror&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'window err'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; promise &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (resolve&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; reject) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;               &lt;span class=&quot;co&quot;&gt;// 这里包了一个 setTimeout&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'test'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'ok'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;promise&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    .&lt;span class=&quot;at&quot;&gt;catch&lt;/span&gt;(() &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'promise catch err'&lt;/span&gt;))

&lt;span class=&quot;co&quot;&gt;// 控制台输出:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//window err&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//Uncaught Error: test&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到第二个例子中就算 promise 的状态还是 pedding ，异步操作里面的报错也不会被 promise 的 catch 方法捕获&lt;/p&gt;
&lt;p&gt;所以这里又可以得到一条&lt;strong&gt;结论&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Promise.prototype.catch()&lt;/code&gt; 方法对错误处理和捕获的规则只对 promise 里面的同步执行代码有效，如果此时 promise 里面有异步操作出错的话，是不受 promise 这些规则限制的，而是像正常的报错一样处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;promise 对象里面同步代码抛出的错误在没有通过 promise 的 catch 方法捕获时是会打印报错的（不会阻止 promise 外面代码的执行），但是不会传递到外面触发其他错误监听函数（比如 window.onerror 、try-catch 等）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Promise.prototype.catch()&lt;/code&gt; 方法对错误处理和捕获的规则只对 promise 里面的同步执行代码有效，如果此时 promise 里面有异步操作出错的话，是不受 promise 这些规则限制的，而是像正常的报错一样处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其实上面两条规则可以看出 promise 对错误的处理应该是在内部使用了像 try-catch 的方式处理了错误，所以异步的它是处理不了的。就行下面这样一样，try-catch 并不会捕获到错误，错误会被 window.onerror 捕获&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onerror&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'window err'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;cf&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(x)    &lt;span class=&quot;co&quot;&gt;// 这里 x 未定义&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;catch&lt;/span&gt;(err)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'try err'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 控制台输出:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//window err&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，可能还会有一些理解上的错误，希望大家多多指正。&lt;/p&gt;
</description>
<pubDate>Wed, 21 Mar 2018 04:57:00 +0000</pubDate>
<dc:creator>另一个小菜头</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CccZss/p/8616356.html</dc:identifier>
</item>
</channel>
</rss>