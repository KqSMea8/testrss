<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深刻理解反射（Reflection) - 张居斜</title>
<link>http://www.cnblogs.com/yaolin1228/p/7667572.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaolin1228/p/7667572.html</guid>
<description>&lt;p&gt;最近公司在搞自动化测试，由于版权问题，无法用 ’录制脚本‘ 进行，也就没法用 VS 自带的 UITest 框架（蛋疼）， 所以只能开源的 FlaUI 框架来搞了。其中不可避免的涉及到反射的应用，但自己有些概念还是有点模糊不清， 干脆集中将自己个人的理解整理一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、前提&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要理解反射首先要理解 &lt;strong&gt;特性&lt;/strong&gt; 的概念,因为反射通常需要获取用户自定义属性。&lt;/p&gt;
&lt;p&gt;特性（Attribute)&lt;/p&gt;
&lt;p&gt;概念： 用于在运行时传递程序中各种元素（类，方法等）的行为信息的声明性标签。&lt;/p&gt;
&lt;p&gt;声明方法：在它所应用的元素（类， 方法等）面前防止方框号（[ ]), ig. [SayHelloAttribute]。&lt;/p&gt;
&lt;p&gt;主要作用：对应用的元素添加元数据， 程序可以使用反射检查获取自己的元数据或者其它元素内的元数据。&lt;/p&gt;
&lt;p&gt;可以这么理解元数据的概念：程序集中所有关于声明类的数据信息（成员函数， 属性， 方法调用）等都储存在元数据里面（pdb 文件）。&lt;/p&gt;
&lt;p&gt;如果还不理解特性的概念， 点这里 &lt;a title=&quot;Wiki -- Attrbute &quot; href=&quot;https://en.wikipedia.org/wiki/Attribute_(computing)&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Attribute_(computing)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、 概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;反射： 指程序可以访问、检测和修改它本身状态或行为的一种动作。&lt;/p&gt;
&lt;p&gt;作用： 通过反射， 可以在运行时获取指定程序集（dll 集合） 每一个类型（包括类、结构、委托、接口等）的成员（方法、事件、属性等）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、用途&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;反射可以作用在程序集上， 程序集包含模块， 模块包含类型，类型又包含成员， 反射可以对封装程序集、模块、类以及成员进行操作。通常，使用反射动态的创建类型的实例， 将类型绑定到现有对象（或从现有对象获取类型）， 然后调用类型的方法。&lt;/p&gt;
&lt;p&gt;最常见用途如下：&lt;/p&gt;
&lt;p&gt; 1、使用 Assembly 定义和加载程序集, 并提取指定的类型集合。&lt;/p&gt;
&lt;p&gt;如下所示， 加载 &lt;span&gt;&quot;&lt;span&gt;ReflectionTest.exe&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;  ， 提取程序中有 “HelloAttribute&quot; 属性的类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Assembly a = Assembly.Load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ReflectionTest.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Type[] assTypes =&lt;span&gt; a.GetTypes();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;foreach&lt;/span&gt; (Type assType &lt;span&gt;in&lt;/span&gt;&lt;span&gt; assTypes)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;      &lt;span&gt;object&lt;/span&gt;[] attributes = assType.GetCustomAttributes(&lt;span&gt;typeof&lt;/span&gt;(HelloAttribute), false&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、使用 MethodInfo 了解方法的名称， 返回类型，参数 以及实现信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; // HellowWord 是一个类&lt;br/&gt;1&lt;/span&gt; Type =&lt;span&gt; Typeof(HelloWord)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; m =&lt;span&gt; t.GetMethods();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;foreach&lt;/span&gt; (MethodInfo mInfo &lt;span&gt;in&lt;/span&gt;&lt;span&gt; m)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处考虑了 attributeMutiple = true 的情况&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;foreach&lt;/span&gt; (Attribute aa &lt;span&gt;in&lt;/span&gt; mInfo.GetCustomAttributes(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;           HelloAttribute d = aa &lt;span&gt;as&lt;/span&gt;&lt;span&gt; HelloAttribute;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; d)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;           {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the method is you wanted: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, m);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3、实例化对象， 调用方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Type t = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(HelloWorld);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例化 HelloWorld&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; Object obj =&lt;span&gt; Activator.CreateInstance(t);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 Hello 方法(’Hello‘ 方法在 ’HelloWorld‘ 类中已经实现过）&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; MethodInfo custHello = t.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; custHello.Invoke(parame) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; parame 指的是对应的参数。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本次用到的方法主要是以上三种，这次也先写这么多，后期用到其它方法，再来更新。&lt;/p&gt;

</description>
<pubDate>Sat, 14 Oct 2017 07:42:00 +0000</pubDate>
<dc:creator>张居斜</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaolin1228/p/7667572.html</dc:identifier>
</item>
<item>
<title>学习PID - 杨奉武</title>
<link>http://www.cnblogs.com/yangfengwu/p/7667547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangfengwu/p/7667547.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近在想自己的文章有些是不是写的太难以理解了呢.........竟然好多人看了还是会直接问我很多问题.......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实PID哈靠自己想像就能自己写出来自己的代码,也许是网上的讲的太过的高深什么积分微分,搞的晕头转向,本来这么实用的想法为什么偏偏说的那么的琢磨不透......感觉那些人根本就没有真正的自己动脑思考,PID最初肯定是人们在做控制的时候不断的思考,不断的尝试然后总结出来的...现在咱们也来思考一下啊&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;咱举一个例子就是控制电机----控制电机的转速&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819239/201710/819239-20171013162458590-89038166.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;咱们先规定好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对了其实事先会规定一个PWM的周期,,假设是10KHZ,,,,周期的大小会对电机的转速有影响,这是必然的,讲到后面就知道如何选择周期了.....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置PWM占空比的函数 &lt;span&gt;PWMSet(0-10000(PWM变量))&lt;/span&gt;;0的时候占空比为0%,,也就是那个引脚一直输出低电平,5000的时候占空比为50%,,也就是那个引脚半周期低电平半周期高电平,10000的时候占空比为100%,也就是那个引脚一直输出高电平&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;采集到的电机的转速 &lt;span&gt;V采集&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置的电机的速度  &lt;span&gt;V设置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在想怎么样才能根据采集的和设置的控制电机的速度呢?????&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;电机转的快的时候要减速控制&lt;span&gt;PWM变量&lt;/span&gt;变小,电机转的慢的时候要加速控制&lt;span&gt;PWM变量&lt;/span&gt;增大,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以让设置的速度和采集的速度做差&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让  &lt;span&gt;V偏差 = V设置 - V采集;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;电机转的快的时候 &lt;span&gt;V采集 &amp;gt; V设置  V偏差一直是负值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;电机转的慢的时候&lt;/span&gt; V采集 &amp;lt; V设置  V偏差一直是正值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是呢如果直接  PWMSet(V偏差);这是瞎胡闹......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是呢   如果   &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;V偏差 = V设置 - V采集;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V控制PWM = V偏差累加和  + V偏差;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PWMSet(V控制PWM);&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上面的这3句话假设是每间隔10ms执行一次哈!!!又会有疑问,,为什么10ms执行一次哈??这是假设的,,,但是这个也会影响到控制电机的速度,,讲到后面就知道了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在分析一下,,假设设置的速度是90&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;刚启动的时候采集的速度是0,,然后呢速度再没有达到90之前,,,&lt;span&gt;V控制PWM&lt;/span&gt;一直在增加,,,,&lt;span&gt;PWMSet(V控制PWM)&lt;/span&gt;,,所以电机一直在加速&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后采集的速度到达90之后&lt;span&gt;V偏差&lt;/span&gt;是0,设置电机的PWM不变,假设超过了设置的速度呢&lt;span&gt;V偏差&lt;/span&gt;是小于0,,,&lt;span&gt;V控制PWM = V控制PWM  + V偏差;&lt;span&gt;所以&lt;/span&gt;V控制PWM&lt;span&gt;又会减小&lt;/span&gt;PWMSet(V控制PWM),&lt;span&gt;最终呢电机又会减速,,,所以就会这样的反反复复了&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;现在呢再想一下,,,,难道这样就行了吗???&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;假设&lt;span&gt;PWMSet(V控制PWM)&lt;/span&gt;,这里面控制速度的变量在7000的时候才能达到咱设置的速度90......&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这样的话其实&lt;span&gt;V控制PWM = V控制PWM  + V偏差&lt;/span&gt;;第一次&lt;span&gt;V控制PWM&lt;/span&gt;是90,然后后面的肯定比90小,,,因为电机开始转了,,,有没有什么感觉不好的地方????&lt;span&gt;V控制PWM&lt;/span&gt;变化的太慢.......这样就会出现问题...达到自己设定的速度需要的时间太长......要是中途我出现了事故需要赶紧控制电机的速度为230吧,,,,那家伙还是慢吞吞的....实在是受不了.....&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819239/201710/819239-20171013184433168-1470315600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　受不了这么慢(图1)&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;所以呢!需要控制它变化的快一些对吧,,也就是让&lt;span&gt;V控制PWM = V控制PWM  + V偏差&lt;/span&gt;;这个程序吧让它每次累加的大一点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;直接加上一个常数肯定不行....但是可以乘以一个常数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;V控制PWM = V控制PWM  + V偏差&lt;span&gt;*P&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;现在就开始考虑这个常数了.....&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;咱就想一想如果常数太小的话,,起不到作用....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常数慢慢增大....假设设置的是3,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实就会发现即使偏差是1那么调整的会是3,,就是控制占空比变化3,,,,如果再大就会出现电机抖动的厉害...理所当然因为越大PWM变化的越厉害.....导致电机一停一转的人眼都看出来了.............&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819239/201710/819239-20171013184531246-393057803.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　受不了你的不稳定(图2)&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在就在想怎么样确定这个比例值呢.......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;咱做的程序肯定能打印电机的速度哈....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;咱们可以看着速度慢慢的增加比例P,,,亲们感觉速度的变化成什么样子就行了呢??????&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在增加P的时候肯定有一个值是电机出现抖动...当然咱是看电机的速度数据,那个速度呢一增一减的而且最大速度和最小速度距离设置的速度很大.....咱们要的是速度立马加上去,,但是呢也能够在很短时间内平稳下来...绝对不能出现来回的抖动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/819239/201710/819239-20171013184655387-615855259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                           这样还算可以&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是呢!电机有惯性或者比例还是有点大,导致会出现一个波峰..............然后呢又慢慢的平稳下来.....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819239/201710/819239-20171013184923840-1937484528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在要做的是想办法消除这个波峰,,,或者呢能不能把这个波峰往下降一降...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 怎么样才能对付这个波峰呢!!!怎样才能在速度快要达到的时候,或者已经达到了,,别在过度的增加PWM了,,,肯定是在偏差上下功夫,,在变化的时候想办法再给他一个变化的变量,,能够抑制住&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819239/201710/819239-20171014002617324-1402896716.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;就整体趋势来讲,,偏差是越来越小,,然后变为负值越来越小,,然后到顶.....我们想的是能不能把前面的变为负值开始到到顶,,抑制一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图画的不一定是对的....只是讲一下整体的趋势&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819239/201710/819239-20171014133757590-2061579357.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;有些人发现这时候的变化趋势之后就在想,,怎样把这种趋势应用到解决以上的问题中.....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后有些人发现....斜率.....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819239/201710/819239-20171014134421293-403744096.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;怎样计算每个点的斜率呢!!!!!!!!微分......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的数学都忘干净了......有时候会发现,,没上大学的时候会的挺多的,,一上大学感觉什么东西都忘了.....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随着时间的推移,我可以通过那个斜率得到一个慢慢变化的值(开始挺小的(稍微有些抑制),慢慢变大(抑制作用越来越强) 或者开始挺大的(开始还能促进),慢慢变小(促进作用越来越小) ).......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以这才引入了微分的概念........&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是呢有人又会想,我也同意微分确实可以描述,,,但是呢单片机程序怎么写呢??????????&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;您看哈,,,既然知道程序中一些变量的作用了,,,,咱们可以去百度一下别人写的程序哈,,,然后带着自己的想法思考一下别人的程序看一看是不是满足要求,而且PID都这么多年了,,肯定有人写,自学的能力在于勤于思考,擅于学习.....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注:拷贝您的程序无冒犯之意,只是为了学习一下,如果有什么问题您可以留言,我马上删掉....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看刚百度的第一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819239/201710/819239-20171014141514496-2069537922.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;因为我们现在在意的是微分部分,,所以只看&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819239/201710/819239-20171014142028465-9365560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;突然发现有点问题....说好的增量计算呢,,,,,,不管它了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V控制PWM = V控制PWM  + V偏差*P + (一个比例数)*上次偏差;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;来感受感受....这好像......&lt;span&gt;(一个比例数)*上次偏差&lt;/span&gt;     和   &lt;span&gt;V偏差*P&lt;/span&gt;   有多大的区别呢........&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;算了看下一个...&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
unsigned &lt;span&gt;int&lt;/span&gt; PIDCalc(&lt;span&gt;struct&lt;/span&gt; PID*pp,unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; NextPoint)
{
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dError,Error ;
    Error&lt;/span&gt;=pp-&amp;gt;SetPoint-&lt;span&gt;NextPoint ;//偏差
  &lt;/span&gt;
    pp-&amp;gt;SumError+=&lt;span&gt;Error ;//偏差和
    &lt;/span&gt;
    dError=pp-&amp;gt;LastError-pp-&amp;gt;&lt;span&gt;PrevError ;//微分环节---上次偏差减去上上次偏差
    &lt;/span&gt;
    pp-&amp;gt;PrevError=pp-&amp;gt;&lt;span&gt;LastError ;
    pp&lt;/span&gt;-&amp;gt;LastError=&lt;span&gt;Error ;
    &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;(pp-&amp;gt;Proportion*Error+pp-&amp;gt;Integral*pp-&amp;gt;SumError+pp-&amp;gt;Derivative*&lt;span&gt;dError);//最后相加
   &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们关注的是&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;dError=pp-&amp;gt;LastError-pp-&amp;gt;PrevError ;//微分环节---上次偏差减去上上次偏差&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;咱们先假设偏差数据是这样的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;90, 70, 55, 46,30,25,18,10,5,1,-1,-5,-13,-15(到顶)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;上次偏差减去上上次偏差----好像大部分都是负值  而且这个负值越来越小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V控制PWM = V控制PWM + V偏差*P + (一个比例数)*(上次偏差-上上次偏差);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果那个比例数是正的.....就相当于&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V控制PWM = V控制PWM  + V偏差*P  - (一个越来越小的数).......(整体来说,,一开始抑制作用很强,,慢慢变弱)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后到了后面的负值部分....就相当于&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V控制PWM = V控制PWM  + V偏差*P  +(一个数).......(抑制了调节)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是几乎永远的都在抑制调节呢.....还可以毕竟可以抑制....&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果那个比例值是负值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V控制PWM = V控制PWM  + V偏差*P  + (一个越来越小的数).......(整体来说,,一开始促进作用很强,然后慢慢变弱)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后到了后面的负值部分....就相当于&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V控制PWM = V控制PWM  + V偏差*P  - (一个数).......(促进了调节)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;永远的在促进,但是促进作用在减弱&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然如果不想让那个比例值为负值..可以让 上上次偏差减去上次偏差嘛&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就变成了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V控制PWM = V控制PWM  + V偏差*P + (一个比例数)*(上上次偏差-上次偏差);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是呢!!!感觉现在应该要减小一点比例P了....因为后面也是促进.....如果不减小肯定达不到效果.....&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;既然还可以就再接着说----思想有了怎样实现就要自己动脑了......&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;有了上面的PD调节了...现在呢再说一下可能还有问题.....就是说到了稳定的状态以后呢,,还是有误差&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么办呢,,,只要有误差就需要调节.....误差的累加,,只要有误差就一直累加&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是这样&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;偏差的和 = 偏差的和  + V偏差&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V控制PWM = V控制PWM  + V偏差*P + (一个比例数)*(偏差的和);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只要存在偏差,那么通过 偏差的和 一直在促进着去调节....&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果组合起来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V控制PWM = V控制PWM + V偏差*P + (一个比例数)*(上次偏差-上上次偏差) + (一个比例数)*(偏差的和);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;应该还可以....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对了最后一个就是所谓的积分调节&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819239/201710/819239-20171014152044840-129010449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实呢我也只是明白要这样做&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后别人总结的口诀&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819239/201710/819239-20171014152221012-552822911.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 一篇文章&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://baike.sogou.com/v108236.htm?fromTitle=PID&quot; target=&quot;_blank&quot;&gt;http://baike.sogou.com/v108236.htm?fromTitle=PID&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;如果问我控制两个电机的速度一样怎么办???&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写两个一样的PID,然后设置的速度写成一样哈&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上面的呢叫增量式PID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有一个叫做位置式PID---列如控制舵机&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;舵机是给占空比固定的PWM 舵机就一直转自身固定的角度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以呢就没有了上面的累加的那部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V控制PWM =  V偏差*P ;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设是控制一个小车前进和急转弯,,,,我们希望的是在直道的时候呢,,舵机的比例不要那么的大,,弯道的时候可以大一些&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实可以&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/819239/201710/819239-20171014153251184-1847106569.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; V控制PWM =  V偏差*V偏差*P ;(用二次函数解决)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;其实呢关键是思想&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 14 Oct 2017 07:36:00 +0000</pubDate>
<dc:creator>杨奉武</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangfengwu/p/7667547.html</dc:identifier>
</item>
<item>
<title>JavaScript易错知识点整理 - 悟空前端</title>
<link>http://www.cnblogs.com/gongyue/p/7667545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gongyue/p/7667545.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文是学习JavaScript过程中收集与整理的一些易错知识点，将分别从变量作用域，类型比较，this指向，函数参数，闭包问题及对象拷贝与赋值这6个方面进行由浅入深的介绍和讲解，其中也涉及了一些ES6的知识点。对于有疑问的问题，读者可以在问候留言，我会一一作答。&lt;/p&gt;
&lt;p&gt; 变量作用域&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9.pstatp.com/large/12800007ea1677d58365&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的test函数作用域中声明并赋值了a，且在console之上，所以遵循就近原则输出a等于2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/127e0006a25b01b3b837&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方的函数作用域中虽然声明并赋值了a，但位于console之下，a变量被提升，输出时已声明但尚未被赋值，所以输出undefined。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/127c0005109857420de8&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;javascript学习群：499415298&lt;/p&gt;
&lt;p&gt;上方的函数作用域中a被重新赋值，未被重新声明，且位于console之下，所以输出全局作用域中的a。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/12800007ec57ad19fb82&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方函数作用域中使用了ES6的let重新声明了变量b，而let不同于var其不存在变量提升的功能，所以输出报错b is not defined。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9.pstatp.com/large/127c0005128189176def&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方的函数作用域中用let声明了a为1，并在块级作用域中声明了a为2，因为console并不在函数内的块级作用域中，所以输出1。&lt;/p&gt;
&lt;p&gt;类型比较&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/12800007ed08f219271b&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方两个不同的数组比较，console为false。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/127e0006a582927a4b9a&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方两个相同的数组比较，因为两个单独的数组永不相等，所以console为false。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9.pstatp.com/large/12800007edd362d48374&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方利用typeof比较数组和对象，因为typeof获取NULL、数组、对象的类型都为object，所以console为true。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/127e0006a6323b6b6364&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方利用instanceof判断一个变量是否属于某个对象的实例，因为在JavaScript中数组也是对象的一种，所以两个console都为true。&lt;/p&gt;
&lt;p&gt;this指向&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/127e0006a6879b193dbc&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方对象方法中的this指向对象本身，所以输出xiaoming。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/127c000514a12e50da22&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方将对象中的方法赋值给了一个变量，此时方法中的this也将不再指向obj对象，从而指向window对象，所以console为undefined。(PS：ES5 严格模式下，对于不知道的this指向的，默认this就是指向window)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/127e0006a76232b8313d&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;javascript学习群：499415298&lt;/p&gt;
&lt;p&gt;上方同样将obj对象中的方法赋值给了变量nameFn，但是通过apply方法将this指向了obj2对象，所以最终console为xiaohua。&lt;/p&gt;
&lt;p&gt;函数参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/127b00059ac3184b4002&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方利用函数中的arguments类数组对象获取传入函数的参数数组，所以输出数组[1, 2]。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9.pstatp.com/large/12800007f2cc6d1842d6&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方同样利用arguments获取参数，但因test7(1, 2)未执行return中的函数，所以无输出。若执行test7(1, 2)(3, 4)则会输出[3, 4]。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/127c000519be4bca90dd&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方利用Array.prototype.push.call()方法向args数组中插入了3和4，并利用ES6延展操作符(...)将数组展开并传入test9，所以console为[1, 2, 3, 4]。&lt;/p&gt;
&lt;p&gt;闭包问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/127b00059ee74a5a049d&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方是一个很常见闭包问题，点击任何div弹出的值总是5，因为当你触发点击事件的时候i的值早已是5，可以用下面方式解决：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/127e0006aca837bf656c&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在绑定点击事件外部封装一个立即执行函数，并将i传入该函数即可。&lt;/p&gt;
&lt;p&gt;对象拷贝与赋值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/12800007f525c5f1970d&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方我们将obj对象赋值给了newObj对象(术语叫call by reference)，从而改变newObj的name属性，但是obj对象的name属性也被篡改，这是因为实际上newObj对象获得的只是一个内存地址，而不是真正的拷贝，所以obj对象被篡改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/127f0004e219bcbd294c&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上方利用Object.assign()方法进行对象的深拷贝可以避免源对象被篡改的可能。因为Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/12800007f661143437ff&quot; alt=&quot;JavaScript易错知识点整理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们也可以使用Object.create()方法进行对象的拷贝，Object.create()方法可以创建一个具有指定原型对象和属性的新对象。&lt;/p&gt;
&lt;p&gt;结语&lt;/p&gt;
&lt;p&gt;学习JavaScript是一个漫长的过程，不能一蹴而就。希望本文介绍的几点内容能够帮助学习JavaScript的同学更加深入的了解和掌握JavaScript的语法，少走弯路&lt;/p&gt;

&lt;p&gt;javascript学习群：499415298&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 07:35:00 +0000</pubDate>
<dc:creator>悟空前端</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gongyue/p/7667545.html</dc:identifier>
</item>
<item>
<title>发布系统Git使用指南 - the Git Way to Use Git - blaketairan</title>
<link>http://www.cnblogs.com/blaketairan/p/7667401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blaketairan/p/7667401.html</guid>
<description>&lt;p&gt;发布系统Git使用指南&lt;/p&gt;
&lt;p&gt;——the Git Way to Use Git&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;​ 有文章曾归纳，Git是一套内容寻址文件系统，意思是，Git的核心是存储键值对^[1]^。显然，这样的形式不利于普通人类使用。&lt;/p&gt;
&lt;p&gt;       通常情况下我们使用的Git命令，都被称作高级命令（例如pull、merge等），区别于底层的低级命令，两种命令分别对应于Git文档中出现Porcelain、Plumbing（第一次在文档见到这些词有没有很困惑！）。&lt;/p&gt;
&lt;p&gt;       高级命令大都有易读参数与翔实输出，可以认为是由低级命令封装，方便人使用。那么低级命令存在的意义是？&lt;/p&gt;
&lt;p&gt;       根据文档的描述^[2]^，低级命令的接口相较高级命令，更加稳定。低级指令本身就是为脚本使用而存在的，便于确切的输入参数并精准的识别输出。那么，在发布系统中合理使用低级命令替代高级命令，无疑将会使设计的逻辑更加准确的执行。&lt;/p&gt;
&lt;p&gt;       以下，根据工作中发布系统的实际场景和经验，从两个方面总结一下如何利用更恰当的Git命令，实现较完备的代码操作流程。&lt;/p&gt;
&lt;h3 id=&quot;获取代码&quot;&gt;获取代码&lt;/h3&gt;
&lt;p&gt;       代码获取的大致逻辑分为四个层级：确定仓库、确定分支、确定Commit ID、确定目录&lt;/p&gt;
&lt;h4 id=&quot;仓库&quot;&gt;仓库&lt;/h4&gt;
&lt;p&gt;       确定仓库地址之前，首先需要当前工作目录是否是一个Git仓库&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chentairan@localhost ~/t/git-learn&amp;gt; git rev-parse --is-inside-work-tree
true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 确认当前工作目录的仓库地址&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;chentairan@localhost&lt;/span&gt; ~/t/git-learn&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt; git config --list&lt;span class=&quot;kw&quot;&gt;|grep&lt;/span&gt; -F &lt;span class=&quot;st&quot;&gt;&quot;remote.origin.url&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;remote.origin.url&lt;/span&gt;=ssh://git@gitlab.xxx/chentairan/git-learn.git&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;​ 如果需要直接设置仓库地址&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;chentairan@localhost&lt;/span&gt; ~/t/git-learn&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt; git config remote.origin.url ssh://git@gitlab.xxx/chentairan/git-learn.git&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;分支&quot;&gt;分支&lt;/h4&gt;
&lt;p&gt;​ 获取指定远程分支&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chentairan@localhost ~/t/git-learn&amp;gt; git fetch ssh://git@gitlab.xxx/chentairan/git-learn.git $BRANCH_NAME:refs/remotes/origin/$BRANCH_NAME
remote: Counting objects: 6, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 6 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (6/6), done.
From ssh://gitlab.xxx/chentairan/git-learn
 * [new branch]      dev        -&amp;gt; origin/dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 获取分支的Commit ID&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chentairan@localhost ~/t/git-learn&amp;gt; git rev-parse --verify refs/remotes/origin/$BRANCH_NAME
9e100c01201678286db5d266b8d342b0dd8a8e0d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 检出提交&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chentairan@localhost ~/t/git-learn&amp;gt; git checkout -f 9e100c01201678286db5d266b8d342b0dd8a8e0d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 去掉多余文件&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chentairan@localhost ~/t/git-learn&amp;gt; git clean -fdx&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;多分支集成&quot;&gt;多分支集成&lt;/h4&gt;
&lt;p&gt;​ 在同时有多个RD一起开发的项目中，总会遇到有多个分支需要同时上线的情况（对应多个需求或者同一需求的不同工作部分）。通常的做法是从主干上拉出一个临时分支，将各开发分支的变更全部合并&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chentairan@localhost ~/t/git-temp&amp;gt; git fetch origin master:refs/remotes/origin/master $BRANCH_DEV1:refs/remotes/origin/$BRANCH_DEV1 $BRANCH_DEV2:refs/remotes/origin/$BRANCH_DEV2
...
chentairan@localhost ~/t/git-temp&amp;gt; git checkout origin/master
chentairan@localhost ~/t/git-temp&amp;gt; git merge --no-edit --strategy=octopus origin/$BRANCH_DEV1 origin/$BRANCH_DEV2 ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 如果没有冲突，那么多分支的检出就完成了&lt;/p&gt;
&lt;h4 id=&quot;commit-id&quot;&gt;Commit ID&lt;/h4&gt;
&lt;p&gt;​ 如果发布时需要检出某指定提交，而不是某分支的最新提交（比如生产环境发布的代码，一定要是测试环境测试通过的代码版本），那么在fetch远程分支之后，直接检出对应提交&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chentairan@localhost ~/t/git-temp&amp;gt; git checkout -f $COMMIT_ID&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;目录&quot;&gt;目录&lt;/h4&gt;
&lt;p&gt;​ 需要集成的项目代码可能不在项目根目录，而在项目下某一目录中，在使用&lt;code&gt;pushd $TARGET_DIRECTORY&lt;/code&gt;之后，可能需要检查当前所在目录&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chentairan@localhost ~/t/git-temp&amp;gt; pushd target_dir
chentairan@localhost ~/t/git-temp&amp;gt; git rev-parse --show-prefix
target_dir/
chentairan@localhost ~/t/git-temp&amp;gt; popd
chentairan@localhost ~/t/git-temp&amp;gt; git rev-parse --show-prefix

chentairan@localhost ~/t/git-temp&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;本节回顾&quot;&gt;本节回顾&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;git rev-parse&lt;/code&gt;用于查看参数，返回结果通常可以直接使用不需额外处理&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git config&lt;/code&gt;用于配置、查看参数，绕过了&lt;code&gt;git remote&lt;/code&gt;命令可能存在的报错&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git fetch&lt;/code&gt;用于拉取分支，并不改变当前工作区内容，相比&lt;code&gt;git pull&lt;/code&gt;更加精确有效&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout&lt;/code&gt;用于检出提交，但对于缓存区文件（也许上次集成生成的问题）以及.gitignore中配置的文件不做处理&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clean&lt;/code&gt;用于清理工作区，仅留下指定提交下面关联的文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git merge --no-edit --strategy=octopus&lt;/code&gt;用于合并多个分支，--no-edit参数使得CommitMessage不需要编辑，octopus是默认的Merge策略，在遇到复杂合并操作，需要人工解决时，拒绝合并&lt;/p&gt;
&lt;h3 id=&quot;代码基线&quot;&gt;代码基线&lt;/h3&gt;
&lt;p&gt;​ 基线管理简单说就两件事：确保开发代码包含代码主干的最新提交，确保代码主干有稳定版本可追溯。再说细一点：发布时检查代码是否合并了主干的最新提交，也即是最新的上线代码；线上发布完成之后，代码合并至主干，并打Tag。&lt;/p&gt;
&lt;h4 id=&quot;检查代码合并主干&quot;&gt;检查代码合并主干&lt;/h4&gt;
&lt;p&gt;​ 检查是否合并了主干最新提交，通常有两种实现方式：一是在开发提交代码时，Git通过Hook配置检查；二是在发布系统这里，发布前做检查。方法一后续会写一篇文章专门讲Hook的能干的事情，本文主要介绍方法二。&lt;/p&gt;
&lt;p&gt;​ 查看代码主干位置&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chentairan@localhost ~/t/git-temp&amp;gt; git ls-remote origin refs/heads/master
1297bb993557e8b58b37abc3dbb315402f95f349    refs/heads/master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 查看开发代码是否包含此次提交历史&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chentairan@localhost ~/t/git-temp&amp;gt; git rev-list $COMMIT_ID
......
f19d66e5a154e3b7415b36d55d6cdd9c3648261d
9e100c01201678286db5d266b8d342b0dd8a8e0d
1297bb993557e8b58b37abc3dbb315402f95f349
......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 此处可以通过grep检查是否包含主干的最新提交&lt;/p&gt;
&lt;h4 id=&quot;向主干合并tag&quot;&gt;向主干合并&amp;amp;Tag&lt;/h4&gt;
&lt;p&gt;​ 由于开发的代码包含了主干的最新提交，那么向主干合并时，只是一个向前走的过程，一定不会有冲突，所以直接使用merge进行合并&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;...如第一部分拉取发布分支...
chentairan@localhost ~/t/git-temp&amp;gt; git checkout origin/master
chentairan@localhost ~/t/git-temp&amp;gt; git merge $COMMIT_ID --no-ff -m &quot;$SOME_MESSAGE&quot;
chentairan@localhost ~/t/git-temp&amp;gt; git tag $TAG_INFO -m &quot;Create production tag&quot;
chentairan@localhost ~/t/git-temp&amp;gt; git push origin HEAD:refs/heads/master --tags&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;本节回顾-1&quot;&gt;本节回顾&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;git ls-remote&lt;/code&gt;用于查看远程代码仓库上主干分支的位置&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rev-list&lt;/code&gt;用于查看某次提交之前的历史&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git merge --no-ff&lt;/code&gt; 用于合并代码。根据健康的Git工作流，所有的开发提交合并至主干时都是fast-forward过程。--no-ff参数能使fast-forward也产生一个新的Merge Commit（无此参数则不会），目的是保持开发分支的开发记录，保持整个代码开发历史的完整性&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git tag&lt;/code&gt;用于新建Tag，保存线上稳定版本&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git push origin HEAD:refs/heads/master --tags&lt;/code&gt;用于提交Merge后的代码及Tag。使用origin/master拉取代码，并使用HEAD:refs/heads/master方式提交，相比切换至本地master分支再更新、合并、提交，步骤更简单，并绕过本地master分支可能存在的需要处理的变更&lt;/p&gt;
&lt;h3 id=&quot;提示总结&quot;&gt;提示&amp;amp;总结&lt;/h3&gt;
&lt;p&gt;​ 发布系统的准确性直接影响线上稳定性，准确性的首要任务是确保异常产物无法上线&lt;/p&gt;
&lt;p&gt;​ 所有的命令均可以通过Shell的$?进行判错，有异常一定终止流程，人工介入，尽量避免使用--force参数&lt;/p&gt;
&lt;p&gt;​ 所有的命令以准确性为首要目标，脚本中所有的Git指令，能尽可能全面地指定参数，则尽量全面（曾经遇到过使用Git关键字作为分支名，导致的异常问题，Git偶尔会混淆在命令中该参数的具体含义指代。PS：不规范的名字可以在提交前通过Hook进行检查）&lt;/p&gt;
&lt;p&gt;参考文献&lt;/p&gt;
&lt;p&gt;[1][&lt;a href=&quot;https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1&quot;&gt;https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1&lt;/a&gt;](&lt;a href=&quot;https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1&quot;&gt;https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;[2] [&lt;a href=&quot;http://man7.org/linux/man-pages/man1/git.1.html&quot; class=&quot;uri&quot;&gt;http://man7.org/linux/man-pages/man1/git.1.html&lt;/a&gt;](&lt;a href=&quot;http://man7.org/linux/man-pages/man1/git.1.html&quot; class=&quot;uri&quot;&gt;http://man7.org/linux/man-pages/man1/git.1.html&lt;/a&gt;)&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 07:23:00 +0000</pubDate>
<dc:creator>blaketairan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blaketairan/p/7667401.html</dc:identifier>
</item>
<item>
<title>kazoo python zookeeper 选主 - 扎心了老铁</title>
<link>http://www.cnblogs.com/kangoroo/p/7667293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kangoroo/p/7667293.html</guid>
<description>&lt;p&gt;本文讲述基于zookeeper选主与故障切换的方法。我们的例子使用的是python。&lt;/p&gt;
&lt;p&gt;使用的库是kazoo，安装方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip install kazoo 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多个实例部署，但不是“去中心化”的部署方式；&lt;/li&gt;
&lt;li&gt;有且只有一个节点作为master，履行master的职责，在例子中是注册调度器；&lt;/li&gt;
&lt;li&gt;其他实例作为slave，不提供调度功能，但是在master节点挂掉之后，可以重新进行选主调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;1、注册调度器&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们只给出伪代码，简单的打印调度器注册结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调度器注册和关闭&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 模拟主节点的职责&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyScheduler(object):

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注册调度器&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; init_scheduler(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;########## 开启调度器成功 ############&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭调度器&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; stop_scheduler(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;########## 关闭调度器成功 ############&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;2、选主与故障切换代码&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）使用add_listener注册监听器，监听zookeeper会话超时，Session Expired，否则在会话超时的场景中会出现锁不一致的问题，可以参看&lt;a href=&quot;http://www.cnblogs.com/kangoroo/p/7538314.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会话超时之后，我们要重新建立Session，在我们的例子里，会循环直到Session重新建立。&lt;/li&gt;
&lt;li&gt;重新注册Watcher，因为Watcher会随着Session失效而失效。在我们的例子里，通过执行get_children重新注册了Watcher。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2）向zookeeper注册自己，使用参数makepath=True级联创建节点；使用参数ephemeral=True, sequence=True参数，也就是创建临时有序节点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当实例挂掉，session断开，注册的节点会自行消失&lt;/li&gt;
&lt;li&gt;有序节点，会节点后添加一个有序编号&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3）注册Watcher，观察/dmonitor/master的子节点，当发生以下事件时：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Created：新增子节点&lt;/li&gt;
&lt;li&gt;Deleted：删除子节点&lt;/li&gt;
&lt;li&gt;Changed：子节点数据变化&lt;/li&gt;
&lt;li&gt;Child：子节点的下一级节点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;进行重新选主。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; traceback
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; kazoo.client &lt;span&gt;import&lt;/span&gt;&lt;span&gt; KazooClient
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; kazoo.client &lt;span&gt;import&lt;/span&gt;&lt;span&gt; KazooState
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; MyScheduler &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MyScheduler


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HAMaster(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.path &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/dmonitor/master&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        self.scheduler &lt;/span&gt;=&lt;span&gt; MyScheduler()
        self.zk &lt;/span&gt;= KazooClient(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10.93.21.21:2181,10.93.18.34:2181,10.93.18.35:2181&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, timeout=10&lt;span&gt;)
        self.zk.start()
        self.zk.add_listener(self.my_listener)
        self.is_leader &lt;/span&gt;=&lt;span&gt; False

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; create_instance(self):
        instance &lt;/span&gt;= self.path + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + socket.gethostbyname(socket.gethostname()) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        self.zk.create(path&lt;/span&gt;=instance, value=&lt;span&gt;&quot;&quot;&lt;/span&gt;, ephemeral=True, sequence=True, makepath=&lt;span&gt;True)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选主逻辑: master节点下, 所有ephemeral+sequence类型的节点中, 编号最大的获得领导权.&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; choose_master(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;########## 选主开始 ############&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        instance_list &lt;/span&gt;= self.zk.get_children(path=self.path, watch=&lt;span&gt;self.my_watcher)
        instance &lt;/span&gt;= max(instance_list).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 本实例获得领导权&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; instance ==&lt;span&gt; socket.gethostbyname(socket.gethostname()):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.is_leader:
                self.scheduler.init_scheduler()
                self.is_leader &lt;/span&gt;=&lt;span&gt; True
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;######### 我被选为master, 我以前不是master, 注册调度 ##########&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;######### 我被选为master, 我以前是master, 不再注册调度 ##########&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 本实例没有获得领导权&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.is_leader:
                self.scheduler.stop_scheduler()
                self.is_leader &lt;/span&gt;=&lt;span&gt; False
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;######### 我被选为slave, 我以前不是slave, 关闭调度 ##########&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;######### 我被选为slave, 我以前是slave, 不再关闭调度 ##########&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;########## 选主完成 ############&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; my_listener(self, state):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; state ==&lt;span&gt; KazooState.LOST:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;########## 会话超时:KazooState.LOST ############&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                    self.create_instance()
                    self.zk.get_children(path&lt;/span&gt;=self.path, watch=&lt;span&gt;self.my_watcher)
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;########## 会话超时:重建会话完成! ############&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt;
                &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception, _:
                    traceback.print_exc()
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; state ==&lt;span&gt; KazooState.SUSPENDED:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;########## 会话超时:KazooState.SUSPENDED ############&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; state ==&lt;span&gt; KazooState.CONNECTED:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;########## 会话超时:KazooState.CONNECTED ############&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;########## 会话超时:非法状态 ############&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; my_watcher(self, event):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; event.state == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CONNECTED&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; event.type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CREATED&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; event.type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DELETED&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; event.type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CHANGED&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; event.type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CHILD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;########## 监听到子节点变化事件 ############&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            self.choose_master()
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;########## 监听到未识别的事件 ############&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;3、测试一下&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;测试代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; HAMaster &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HAMaster

ha &lt;/span&gt;=&lt;span&gt; HAMaster()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 向zk注册自己&lt;/span&gt;
&lt;span&gt;ha.create_instance()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行选主&lt;/span&gt;
&lt;span&gt;ha.choose_master()

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
    time.sleep(&lt;/span&gt;10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行这个脚本，模拟如下几个场景：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）初始选主&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 顺序在两台机器上启动测试脚本。&lt;/p&gt;
&lt;p&gt;client10&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[data_monitor@bigdata-arch-&lt;span&gt;client10 zookeeper]$ python run.py &lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;client11&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[data_monitor@bigdata-arch-client11 zookeeper]$ python run.py 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;client10输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
[data_monitor@bigdata-arch-&lt;span&gt;client10 zookeeper]$ python run.py 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;######### 选主开始 ############&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######### 开启调度器成功 ############&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######## 我被选为master, 我以前不是master, 注册调度 ##########&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######### 选主完成 ############&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######### 监听到子节点变化事件 ############&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######### 选主开始 ############&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######## 我被选为master, 我以前是master, 不再注册调度 ##########&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######### 选主完成 ############&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;client11输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[data_monitor@bigdata-arch-&lt;span&gt;client11 zookeeper]$ python run.py 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;######### 选主开始 ############&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######## 我被选为slave, 我以前是slave, 不再关闭调度 ##########&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######### 选主完成 ############&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，client10倍选为主节点并注册调度器，client11作为slave节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2）主实例挂掉&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们把client10上的实例kill掉。&lt;/p&gt;
&lt;p&gt;client10上不再输出&lt;/p&gt;
&lt;p&gt;client11上总体输出如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
[data_monitor@bigdata-arch-&lt;span&gt;client11 zookeeper]$ python run.py 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;######### 选主开始 ############&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######## 我被选为slave, 我以前是slave, 不再关闭调度 ##########&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######### 选主完成 ############&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######### 监听到子节点变化事件 ############&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######### 选主开始 ############&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######### 开启调度器成功 ############&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######## 我被选为master, 我以前不是master, 注册调度 ##########&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;######### 选主完成 ############&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到监听到节点的变化，并进行了重新选主，client11被选为主节点(只剩他了)并注册了调度器。&lt;/p&gt;

&lt;p&gt;tips：观察到节点变化的实效性是通过timeout=10参数控制的，也就是超过10s session不能维持就会认为实例挂了，zookeeper会删除节点。&lt;/p&gt;

</description>
<pubDate>Sat, 14 Oct 2017 07:06:00 +0000</pubDate>
<dc:creator>扎心了老铁</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kangoroo/p/7667293.html</dc:identifier>
</item>
<item>
<title>NPOI导出WPF DataGrid控件显示数据 - 衆尋</title>
<link>http://www.cnblogs.com/ZXdeveloper/p/7667416.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZXdeveloper/p/7667416.html</guid>
<description>&lt;p&gt;最近做个项目，需要导出DataGrid显示的数据，中间遇到了不少的坑，在此纪录一下，方便以后查看，也希望能给用到的人，一点帮助。&lt;/p&gt;
&lt;p&gt;导出DataGrid显示的数据，并不是导出DataGrid的ItemsSource，这两者是有区别的，这里纪录的是导出DataGrid的显示数据，也就是所见即所得的东西。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;我这里有个一个People的实体类，它包含了6个字段，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; People
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Age { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Sex { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ClassName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GradeName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SchoolName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然而，将List&amp;lt;People&amp;gt;的集合给DataGrid的ItemsSource进行赋值，但是我页面，显示的是5个字段，甚至还有一个转换器的使用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataGrid &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;dg_x&quot;&lt;/span&gt;&lt;span&gt; CanUserAddRows&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt; AutoGenerateColumns&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataGrid.Columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataGridTextColumn &lt;/span&gt;&lt;span&gt;Header&lt;/span&gt;&lt;span&gt;=&quot;姓名&quot;&lt;/span&gt;&lt;span&gt; Binding&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataGridTextColumn &lt;/span&gt;&lt;span&gt;Header&lt;/span&gt;&lt;span&gt;=&quot;年龄&quot;&lt;/span&gt;&lt;span&gt; Binding&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Age}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataGridTextColumn &lt;/span&gt;&lt;span&gt;Header&lt;/span&gt;&lt;span&gt;=&quot;性别&quot;&lt;/span&gt;&lt;span&gt; Binding&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Sex,Converter={StaticResource sexcov}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataGridTextColumn &lt;/span&gt;&lt;span&gt;Header&lt;/span&gt;&lt;span&gt;=&quot;年级&quot;&lt;/span&gt;&lt;span&gt; Binding&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding GradeName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataGridTextColumn &lt;/span&gt;&lt;span&gt;Header&lt;/span&gt;&lt;span&gt;=&quot;学校&quot;&lt;/span&gt;&lt;span&gt; Binding&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding SchoolName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DataGrid.Columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DataGrid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201710/609679-20171014140309465-2111616328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;导出的效果就是DataGrid上展示的数据，加了少许的样式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201710/609679-20171014140744871-1248711590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们介绍下我在写代码过程中遇到的两个坑&lt;/p&gt;
&lt;p&gt;一、代码顺序问题&lt;/p&gt;
&lt;p&gt;做到上面的内容大致需要做两个工作，第一个就是要取得到DataGrid的Cell的值，基本上百度一下，就会看到一个方法，好多的博客都有，如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/qq247039968/p/4066058.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/qq247039968/p/4066058.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个方法本身是没啥问题，但是，当DataGrid有滚动条的时候，也就是DataGrid的Row没有完全渲染完的情况就有问题了。&lt;/p&gt;
&lt;p&gt;假设，我现在有30条数据，但是，我没有拖动过滚动条，直接点导出的话，会抛出如下的异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201710/609679-20171014141625137-1388943682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看了下代码，是因为presenter这是Null，继续打断点跟踪，发现此处numVisuals得到的值是0，而不是1，也就是说没有获取到内容，所以返回的Null。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201710/609679-20171014141753512-1290438315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现以上问题的原因，在于，以下代码的一个顺序问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201710/609679-20171014142008980-1560806075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家都知道UpdateLayout函数是更新布局的意思，这两段代码，是先更新了布局，然后，滚动到rowIndex的位置，所以，依然没有渲染成功。&lt;/p&gt;
&lt;p&gt;正确的写法是将两句的顺序换一下位置，先滚动，再更新，就不会出现问题了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ec068932-5e9e-4981-a8b0-b509f80f4d4a')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_ec068932-5e9e-4981-a8b0-b509f80f4d4a&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ec068932-5e9e-4981-a8b0-b509f80f4d4a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ec068932-5e9e-4981-a8b0-b509f80f4d4a',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ec068932-5e9e-4981-a8b0-b509f80f4d4a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DataGridPlus
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取DataGrid的行
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dataGrid&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;DataGrid控件&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;rowIndex&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;DataGrid行号&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;指定的行号&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DataGridRow GetRow(&lt;span&gt;this&lt;/span&gt; DataGrid dataGrid, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; rowIndex)
    {

        DataGridRow rowContainer &lt;/span&gt;=&lt;span&gt; (DataGridRow)dataGrid.ItemContainerGenerator.ContainerFromIndex(rowIndex);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rowContainer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            dataGrid.ScrollIntoView(dataGrid.Items[rowIndex]);
            dataGrid.UpdateLayout();
            rowContainer &lt;/span&gt;=&lt;span&gt; (DataGridRow)dataGrid.ItemContainerGenerator.ContainerFromIndex(rowIndex);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rowContainer;
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取父可视对象中第一个指定类型的子可视对象
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;可视对象类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;parent&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;父可视对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;第一个指定类型的子可视对象&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T GetVisualChild&amp;lt;T&amp;gt;(Visual parent) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; T : Visual
    {
        T child &lt;/span&gt;= &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T);

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; numVisuals =&lt;span&gt; VisualTreeHelper.GetChildrenCount(parent);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; numVisuals; i++&lt;span&gt;)
        {
            Visual v &lt;/span&gt;=&lt;span&gt; (Visual)VisualTreeHelper.GetChild(parent, i);
            child &lt;/span&gt;= v &lt;span&gt;as&lt;/span&gt;&lt;span&gt; T;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (child == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                child &lt;/span&gt;= GetVisualChild&amp;lt;T&amp;gt;&lt;span&gt;(v);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (child != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; child;
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取DataGrid控件单元格
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dataGrid&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;DataGrid控件&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;rowIndex&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;单元格所在的行号&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;columnIndex&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;单元格所在的列号&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;指定的单元格&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DataGridCell GetCell(&lt;span&gt;this&lt;/span&gt; DataGrid dataGrid, &lt;span&gt;int&lt;/span&gt; rowIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; columnIndex)
    {
        DataGridRow rowContainer &lt;/span&gt;=&lt;span&gt; dataGrid.GetRow(rowIndex);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rowContainer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            DataGridCellsPresenter presenter &lt;/span&gt;= GetVisualChild&amp;lt;DataGridCellsPresenter&amp;gt;&lt;span&gt;(rowContainer);
            DataGridCell cell &lt;/span&gt;=&lt;span&gt; (DataGridCell)presenter.ItemContainerGenerator.ContainerFromIndex(columnIndex);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cell == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                dataGrid.ScrollIntoView(rowContainer, dataGrid.Columns[columnIndex]);
                cell &lt;/span&gt;=&lt;span&gt; (DataGridCell)presenter.ItemContainerGenerator.ContainerFromIndex(columnIndex);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cell;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;DataGridPlus&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;点击导出之后，滚动条会自动滚到DataGrid的结尾处&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201710/609679-20171014142358262-1601317028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、过多的创建了样式和字体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201710/609679-20171014143131684-2080027074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NPOI的Style是针对单元格的，所以，如果导出上面一个最普通的表格的话，就要至少9个样式，这个不在于Font的字体或者怎么样，而是在于Border&lt;/p&gt;
&lt;p&gt;粗和细的问题，基本上一个表格，最外面的框的粗线，内部是细线。&lt;/p&gt;
&lt;p&gt;由于，第一次用NPOI，以前没用过，所以，在设置样式是，给放在了for里面，当时的想法，就是判断下处于列的什么位置，或者是处于行的什么位置，来设置Cell的样式&lt;/p&gt;
&lt;p&gt;但是，数量少的时候是没问题的，当数量多了以后，由于不断的New，导致，会提示Style的数量抄了，当时好像大概测试了2W条数据吧。&lt;/p&gt;
&lt;p&gt;因此，需要将所有的样式，都提出来，在最前面定义好，需要的时候，直接赋值就好了。&lt;/p&gt;
&lt;p&gt;位置的话，通过枚举来定义，方便使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; CellPosition
{
    LeftTop,
    Top,
    RightTop,
    Left,
    Center,
    Right,
    LeftBottom,
    Bottom,
    RightBottom,
    None
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还要注意的是NPOI可以通过DefaultColumnWidth来设置默认的宽度，但是DefaultRowHeight和DefaultRowHeightInPoints设置默认高度却不好使，我看作者在13年的时候已经修复这个问题了，但是不知道为什么还是不起左右，有知道的，希望可以留言告知，谢谢。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/ZXdeveloper/DataGridExportDemo.zip&quot; target=&quot;_blank&quot;&gt;DEMO源码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 07:00:00 +0000</pubDate>
<dc:creator>衆尋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZXdeveloper/p/7667416.html</dc:identifier>
</item>
<item>
<title>js 将一大段时间均分为很多个小时间段 - 西窗故事</title>
<link>http://www.cnblogs.com/xichuanggushi/p/7666815.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xichuanggushi/p/7666815.html</guid>
<description>&lt;p&gt;最近写项目，遇到一个将选中时间段平均分割为若干小段，然后根据小段时间在数据库查询求均值的问题，后台大哥犯懒，非说后台做不了，让我分好传给他ヾ(。￣□￣)ﾂ゜゜゜好气呦，但还要保持微笑，我就是这么懂礼貌的好孩子ー(￣～￣)ξ&lt;/p&gt;

&lt;p&gt;闲话不多说，来说实现过程&lt;/p&gt;
&lt;p&gt;最开始只是分固定时间段，每天两小时一分，也就直接全写了，后来需求变了，日期选择输入，想要多少天就要多少天，时间大了要求取到的数据量还是那么多&lt;/p&gt;
&lt;p&gt;我：不太好实现啊老板&lt;/p&gt;
&lt;p&gt;boss：啥？别人都能做到，你咋就做不到？你这技术水平怕是有点低了把？&lt;/p&gt;
&lt;p&gt;我：那我试试（MDZZ）&lt;/p&gt;
&lt;p&gt;先确定后台需要什么数据格式，按照存入格式，先写个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; range(beginTime, endTime) {//存入格式
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.beginTime =&lt;span&gt; beginTime;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.endTime =&lt;span&gt; endTime;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;考虑到这是一个js文件，数据分割也是固定的等分，就写一个从外部获取参数的函数吧，TimeRange（startTime，endTime）函数用来供页面调用，只传入开始时间，结束时间，不写分多少组了，因为需要的数据总量一般都是固定的，分多少组也是固定的，哪里需要直接来js改就好了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt; TimeRange(startTime, endTime) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入开始时间var startTime 传入结束时间var endTime 传入格式xxxx-xx-xx 年月日&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; amount = 100; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义分多少组&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; startTimes = startTime + &quot; 00:00:00&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期添加时分秒 开始日期&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; endTimes = endTime + &quot; 23:59:59&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期添加时分秒 结束日期&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; ｝
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;判断一波&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(endTimes &amp;lt;=&lt;span&gt; startTimes) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         alert('结束日期必须大于开始日期!'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(dataDiff &amp;gt; 15&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         alert('单次查询日期不超过两周,请重新选择！'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;既然平均分，那就得知道时间间隔，计算时间间隔，写个方法直接调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算天数差的函数，通用&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; DateDiff(sDate1, sDate2) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sDate1和sDate2是2006-12-18格式  &lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; aDate, oDate1, oDate2, iDays
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     aDate = sDate1.split(&quot;-&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     oDate1 = &lt;span&gt;new&lt;/span&gt; Date(aDate[1] + '-' + aDate[2] + '-' + aDate[0]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换为12-18-2006格式  &lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     aDate = sDate2.split(&quot;-&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     oDate2 = &lt;span&gt;new&lt;/span&gt; Date(aDate[1] + '-' + aDate[2] + '-' + aDate[0&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     iDays = parseInt(Math.abs(oDate1 - oDate2) / 1000 / 60 / 60 / 24) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把相差的毫秒数转换为天数  &lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; iDays
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;整理了一下逻辑，伪代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算时间段总时间，分割后每段时间间隔,单位（秒）&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; timeRange；&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储计算出的时间段&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; timeAll ； &lt;span&gt;//&lt;/span&gt;&lt;span&gt;总时间间隔&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; timeGap ； &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分割后时间间隔&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; slidingTime = 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环开始条件&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; momentTime_front; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;时间段前一个值&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; momentTime_rear;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;时间段后一个值&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(slidingTime; slidingTime &amp;lt; timeAll; slidingTime +=&lt;span&gt; timeGap) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             momentTime_front =&lt;span&gt; 计算出的时间前半部分
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             momentTime_rear =&lt;span&gt; 计算出的时间后半部分
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             timeRange.push(&lt;span&gt;new&lt;/span&gt; range(momentTime_front, momentTime_rear));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将计算后的小段的开始时间和结束时间组合存入timeRange&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; timeRange;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     } 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;实现后的TimeRange()方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; TimeRange(startTime, endTime) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入开始时间var startTime 传入结束时间var endTime&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; amount = 100; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义分多少组&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; timeRange = &lt;span&gt;new&lt;/span&gt; Array(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;return数组初始化&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; dataDiff = DateDiff(startTime, endTime); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算两个日期相差天数&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; startTimes = startTime + &quot; 00:00:00&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期添加时分秒 开始日期&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; endTimes = endTime + &quot; 23:59:59&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期添加时分秒 结束日期&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(endTimes &amp;lt;=&lt;span&gt; startTimes) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         alert('结束日期必须大于开始日期!'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(dataDiff &amp;gt; 15&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         alert('单次查询日期不超过两周,请重新选择！'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算时间段总时间，分割后每段时间间隔,单位（秒）&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; timeAll = (dataDiff + 1) * 24 * 3600; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;总时间间隔&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; timeGap = timeAll / amount; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分割后时间间隔&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; slidingTime = 0&lt;span&gt;; //循环开始
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; momentTime_front;  
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; momentTime_rear;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(slidingTime; slidingTime &amp;lt; timeAll; slidingTime +=&lt;span&gt; timeGap) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             momentTime_front =&lt;span&gt; addDatetime(startTimes, slidingTime)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             momentTime_rear = addDatetime(startTimes, (slidingTime + timeGap - 1&lt;span&gt;))&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             timeRange.push(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; range(momentTime_front, momentTime_rear));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; timeRange;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来的问题就是如何计算 momentTime_front 和 momentTime_rear 了&lt;/p&gt;
&lt;p&gt;我的思路是将开始时间加上秒数转换后的日时分秒等再相加，直接添加的语句或者方法没找到，那咋办？还把我难住了？找不到算了，技不如人，不如自己写一个方法，直接计算两个字符串类型的时间格式相加，哼╭(╯^╰)╮&lt;/p&gt;
&lt;p&gt;先想想怎么写，需要现将字符串转换成字符串类型的数组，将年月日时分秒都分开才能逐个击破，分开后的数组都是字符串类型，没法进行加减运算，强转！先写个将日期类型转换为整型数组的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入'1970-01-01 00:00:00' 将其分成可计算的整形数组[1970,1,1,0,0,0]&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getArray(dataTime) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     dataTime = dataTime.replace(/ /, &quot;-&quot;)
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; timesArray = dataTime.split(&quot;-&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; timeArray = timesArray[3].split(&quot;:&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     timesArray[0] = parseInt(timesArray[0&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     timesArray[1] = parseInt(timesArray[1&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     timesArray[2] = parseInt(timesArray[2&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     timesArray[3] = parseInt(timeArray[0&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     timesArray[4] = parseInt(timeArray[1&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     timesArray[5] = parseInt(timeArray[2&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; timesArray;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ok，能计算了，但是增加的时间是秒，还得把秒转换成年月日时分秒格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将秒转换为日期格式（最高到天）&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getDatetime(s) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; dataTime = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存入 秒&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     dataTime[5] = parseInt((s / 1) % 60&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存入 分&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     dataTime[4] = parseInt((s / 60) % 60&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存入 时&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     dataTime[3] = parseInt((s / 60 / 60) % 24&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存入 日&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     dataTime[2] = parseInt(s / 60 / 60 / 24&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存入 月&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     dataTime[1] = parseInt(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存入 年&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     dataTime[0] = parseInt(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataTime;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好嘞，需要的类有了，可是时间相加，不是简单的数字相加啊，还要考虑闰年问题，大月小月问题，嗯....计算大月小月&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当月天数&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getMonthDay(years, month) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(month) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &quot;2&quot;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(years % 4 == 0 &amp;amp;&amp;amp; years %100 !=0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &quot;29&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            } 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(years % 4 == 0 &amp;amp;&amp;amp;years % 100 == 0 &amp;amp;&amp;amp; years % 400 == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &quot;29&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &quot;28&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;28&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &quot;4&quot;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;30&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &quot;6&quot;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;30&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &quot;9&quot;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;30&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &quot;11&quot;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;30&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;31&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为生成的结果是个数组，我们认识，但是计算机傻呀，还要在转换为输入的日期格式的字符串，逆向的过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将datetime日期数组转换为string类型&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; dataTimetoString(dateTime) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i = 0; i &amp;lt;= 5; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         dateTime[i] =&lt;span&gt; dateTime[i].toString();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; dataTime_Str = &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加 年&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     dataTime_Str += dateTime[0] + &quot;-&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加 月&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(dateTime[1].length == 2&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         dataTime_Str += dateTime[1] + &quot;-&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         dataTime_Str += &quot;0&quot; + dateTime[1] + &quot;-&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加 日&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(dateTime[2].length == 2&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         dataTime_Str += dateTime[2] + &quot; &quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         dataTime_Str += &quot;0&quot; + dateTime[2] + &quot; &quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加 时&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(dateTime[3].length == 2&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         dataTime_Str += dateTime[3] + &quot;:&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         dataTime_Str += &quot;0&quot; + dateTime[3] + &quot;:&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加 分&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(dateTime[4].length == 2&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         dataTime_Str += dateTime[4] + &quot;:&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         dataTime_Str += &quot;0&quot; + dateTime[4] + &quot;:&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加 秒&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(dateTime[5].length == 2&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         dataTime_Str += dateTime[5&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         dataTime_Str += &quot;0&quot; + dateTime[5&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataTime_Str;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好啦，准备工作全部完成，开始我们核心的增加的计算啦，各种小细节问题，想起来就头疼，好在解决了，不细说啦，Showtime！       ヾ(≧O≦)〃嗷~ヾ&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将两个日期相加后的结果返回&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; addDatetime(dt, s) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; dateTime = &lt;span&gt;new&lt;/span&gt; Array; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建数组&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; addDatetime = &lt;span&gt;new&lt;/span&gt; Array; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建数组&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; dataTimeStr = &lt;span&gt;new&lt;/span&gt; Array; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建数组&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     dateTime = getArray(dt); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将字符串类型的时间转换为整形数组&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     addDatetime = getDatetime(s); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将间隔时间秒转换为日期格式的整形数组&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; count = 0&lt;span&gt;;//存储进位
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     dataTimeStr[5] = (dateTime[5] + addDatetime[5] + count) % 60; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;秒&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     ((dateTime[5] + addDatetime[5] + count) &amp;gt; 59) ? count = 1: count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     dataTimeStr[4] = (dateTime[4] + addDatetime[4] + count) % 60; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     ((dateTime[4] + addDatetime[4] + count) &amp;gt; 59) ? count = 1: count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     dataTimeStr[3] = (dateTime[3] + addDatetime[3] + count) % 24; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;时&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     ((dateTime[3] + addDatetime[3] + count) &amp;gt; 23) ? count = 1: count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; m = getMonthDay(dateTime[0].toString(), dateTime[1&lt;span&gt;].toString());
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     dataTimeStr[2] = (dateTime[2] + addDatetime[2] + count) % m; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;日&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     ((dateTime[2] + addDatetime[2] + count) &amp;gt; m) ? count = 1: count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(dataTimeStr[2] == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         dataTimeStr[2] = (dateTime[2] + addDatetime[2] + count) % (m + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     dataTimeStr[1] = (dateTime[1] + addDatetime[1] + count) % 12; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;月&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     ((dateTime[1] + addDatetime[1] + count) &amp;gt; 12) ? count = 1: count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(dataTimeStr[1] == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         dataTimeStr[1] = (dateTime[1] + addDatetime[1] + count) % 13&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     dataTimeStr[0] = (dateTime[0] + addDatetime[0] + count) / 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;年&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; dataTime_str = dataTimetoString(dataTimeStr); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将日期格式的数组转换为字符串&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataTime_str;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果有错误，麻烦评论区告诉我一声，万分感谢，觉得有帮助的点个赞谢谢，撒油那啦...ヾ(￣▽￣)Bye~Bye~&lt;/p&gt;

</description>
<pubDate>Sat, 14 Oct 2017 04:28:00 +0000</pubDate>
<dc:creator>西窗故事</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xichuanggushi/p/7666815.html</dc:identifier>
</item>
<item>
<title>浅谈Java接口 - 可比克番茄</title>
<link>http://www.cnblogs.com/419liu/p/7594402.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/419liu/p/7594402.html</guid>
<description>&lt;p&gt;接口（英文：Interface）是Java中非常重要的内容，初学的时候可能感受不深，但是在做项目的时候，对面向接口编程的运用就变得尤为重要，不过这是后话了。现在先讨论假如是刚刚接触接口这个概念，该怎么玩？如果是看过我之前文章的朋友应该了解，在遇到一个新概念的时候，我一般思考框架是先问下面三个问题：&lt;/p&gt;
&lt;p&gt;1.这个东西有什么用？用来干什么的？它的意义在哪里？（显然，如果是没用的东西，就没必要浪费时间了；其实，弄懂了这个问题，就掌握了50%）&lt;/p&gt;
&lt;p&gt;2.这个概念或者技能点怎么用？也就是它的表现形式，如关键字、修饰词、语法什么的。。。（这个占20%）&lt;/p&gt;
&lt;p&gt;3.这个东西在用的过程中，有哪些关键点和细节点？（这个占30%）&lt;/p&gt;
&lt;p&gt;上面三个问题搞清楚了，剩下的就是去用了。。。“无他，但手熟尔。”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、接口有什么用？它的意义在哪里？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回答这个问题，两句话就够了：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.&lt;strong&gt;接口表示一种能力&lt;/strong&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.&lt;strong&gt;接口表示一种约定&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来看第一点“接口表示一种能力”，举个栗子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需求：现在要创造一个蜘蛛侠。人有“唱歌”和“考试”的功能，蜘蛛有“爬行”和“吐丝”的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析：首先蜘蛛侠是一个人，他有蜘蛛的能力。按照面向对象思想，可以将人和蜘蛛分别定义成抽象类。但是，不能让蜘蛛侠在继承人的同时又继承蜘蛛。两个原因：一、蜘蛛侠不是蜘蛛，不符合继承中 【is a】的关系；二、Java只支持单继承。如何解决这个问题呢？这时就要用到接口，接口是【has a】的关系。可以将蜘蛛的行为能力定义为接口，让蜘蛛侠继承人，实现蜘蛛的行为能力的接口。实现代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义Person抽象类&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sing();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;唱歌抽象方法&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; exam();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;考试抽象方法&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ISpiderable {            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个蜘蛛的行为能力接口&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; creep();        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;爬行抽象方法&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; shootWeb();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;吐丝抽象方法&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SpiderMan &lt;span&gt;extends&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt; ISpiderable{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承人，实现蜘蛛的行为能力接口&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     String name = &quot;彼得·帕克&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; creep() {                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现爬行方法&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         System.out.println(name + &quot; 在屋顶上爬，在树枝上爬，在夕阳下的草地上爬。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; shootWeb() {                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现吐丝方法&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         System.out.println(name + &quot; 吐丝织网抓虫子&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sing() {                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现唱歌方法&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         System.out.println(name + &quot; 往事不要再提~人生已多风雨~~&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; exam() {                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现考试方法&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         System.out.println(name + &quot; 上午考语文，下午考数学，明天考英语。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Test {            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试一下&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         SpiderMan spiderman = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpiderMan();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        spiderman.creep();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        spiderman.sing();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1221643/201709/1221643-20170927181724372-522073357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着来，有天傍晚蜘蛛侠吃饱了没事儿闲溜达，在路边草丛里发现了雷神的大铁锤，于是他有具备了闪电的能力：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ILightningable {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义闪电能力接口&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; lightning();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;闪电抽象方法&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SpiderMan &lt;span&gt;extends&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt; ISpiderable,ILightningable{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承人，实现蜘蛛的行为能力接口，实现闪电能力接口&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     String name = &quot;彼得·帕克&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; creep() {                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现爬行方法&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         System.out.println(name + &quot; 在屋顶上爬，在树枝上爬，在夕阳下的草地上爬。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; shootWeb() {                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现吐丝方法&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         System.out.println(name + &quot; 吐丝织网抓虫子&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sing() {                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现唱歌方法&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         System.out.println(name + &quot; 往事不要再提~人生已多风雨~~&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; exam() {                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现考试方法&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         System.out.println(name + &quot; 上午考语文，下午考数学，明天考英语。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lightning() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         System.out.println(name + &quot; 来一波闪电~&quot;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现闪电方法&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Test {            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试一下&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         SpiderMan spiderman = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpiderMan();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        spiderman.creep();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        spiderman.sing();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        spiderman.lightning();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1221643/201709/1221643-20170927183235387-1456717377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 通过上面的例子，“&lt;span&gt;&lt;strong&gt;接口表示一种能力&lt;/strong&gt;&lt;/span&gt;”已经算是不言而喻了，那么，为什么说“&lt;span&gt;&lt;strong&gt;接口表示一种约定&lt;/strong&gt;&lt;/span&gt;”？&lt;/p&gt;
&lt;p&gt; 首先，什么是“约定”？所谓的约定就是，这事儿就按咱哥俩说的规矩办，谁也别出幺蛾子。举个经典的打印机的例子：要求实现打印机的打印功能。打印机的墨盒可能是彩色的，也可能是黑白的，所用的纸张可以有多种类型，如A4、B5等，要命的是墨盒和纸张都不是打印机厂商生产的。那么，打印机厂商如何避免自的打印机与市场上的墨盒、纸张不符呢？&lt;/p&gt;
&lt;p&gt;分析：有效解决该问题的途径是制定墨盒、纸张的约定或标准，然后打印机厂商按照约定对墨盒、纸张提供支持，这样一来，无论最后使用的是厂商张三还是厂商王麻子提供的墨盒或纸张，只有符合统一的约定，打印机都可以打印。当然，“接口（Interface）”就是这样一种约定。打印机打印功能实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IInkBox {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义墨盒接口，约定墨盒的标准&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String getColor();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回墨盒的颜色&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IPaper {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义纸张的接口，约定纸张的标准&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String getSize();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回纸张的种类&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Printer{        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义打印机类，引用墨盒接口、纸张接口实现打印功能&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     IInkBox inkbox=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     IPaper paper=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Printer(IInkBox inkbox,IPaper paper) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数，以接口类型为形参实现多态&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.inkbox =&lt;span&gt; inkbox;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.paper =&lt;span&gt; paper;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printer() {            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现打印功能&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         System.out.println(&quot;使用&quot;+inkbox.getColor()+&quot;墨盒在&quot;+paper.getSize()+&quot;纸张上打印。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ColorInkBox &lt;span&gt;implements&lt;/span&gt; IInkBox{    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;墨盒厂商按照墨盒接口实现彩色墨盒ColorInkBox类&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getColor() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;彩色&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GrayInkBox &lt;span&gt;implements&lt;/span&gt; IInkBox{    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;墨盒厂商按照墨盒接口实现黑白墨盒GrayInkBox类&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getColor() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;黑白&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; A4Paper &lt;span&gt;implements&lt;/span&gt; IPaper{        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;A4纸类实现纸张接口&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSize() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;A4纸&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; B5Paper &lt;span&gt;implements&lt;/span&gt; IPaper{        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;B5纸类实现纸张接口&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSize() {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;B5纸&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }    
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Test {                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试一下&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         IInkBox colorInk = &lt;span&gt;new&lt;/span&gt; ColorInkBox();             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口IInk类型引用指向彩色墨盒ColorInkBox实现类的对象，多态&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         IInkBox grayInk = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GrayInkBox();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         IPaper a4Paper = &lt;span&gt;new&lt;/span&gt; A4Paper();                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口IPaper类型引用指向A4纸A4Paper实现类的对象，多态&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         IPaper b5Paper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; B5Paper();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         
&lt;span&gt;45&lt;/span&gt;         Printer printer = &lt;span&gt;new&lt;/span&gt; Printer(colorInk,a4Paper);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Printer对象（组装打印机），彩色墨盒、A4纸&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        printer.printer();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         Printer printer2 = &lt;span&gt;new&lt;/span&gt; Printer(grayInk,b5Paper);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Printer对象（组装打印机），黑白墨盒、B5纸&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        printer2.printer();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1221643/201710/1221643-20171013185112996-1044238877.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;功能实现，这就是“&lt;span&gt;&lt;strong&gt;接口表示一种约定&lt;/strong&gt;”。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、接口怎么用？它的表现形式？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 其实，从上面的例子中聪明的你肯定已经大致知道接口怎么用了，下面就总结一下Java中接口的定义语法和类实现接口的语法如下：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;[修饰词] &lt;span&gt;interface&lt;/span&gt; 接口名 &lt;span&gt;extends&lt;/span&gt; 父接口1，父接口2，....{&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　//常量定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　//抽象方法定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;class&lt;/span&gt; 类名 &lt;span&gt;extends&lt;/span&gt; 父类名 &lt;span&gt;implements&lt;/span&gt; 接口1，接口2，...{&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　//类成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 【关于接口用法的说明（其实，初学时不用都记住，先掌握关键点用起来再说，报几次错再回来补细节）】：&lt;/p&gt;
&lt;p&gt;1.如果修饰词是public，则该接口在整个项目中可见；如果省略修饰词，则该接口只在当前包中可见。&lt;/p&gt;
&lt;p&gt;2.接口中只能定义常量。接口中的属性都会自动用 public static final 修饰，即接口中的属性都是全局静态常量，必须在定义时指定初始值。&lt;/p&gt;
&lt;p&gt;3.接口中所有方法都是抽象方法，都会自动用 public abstract 修饰，即接口中只有全局抽象方法。&lt;/p&gt;
&lt;p&gt;4.接口之间可以通过extends实现继承关系，一个接口可以继承多个接口，但接口不能继承类。&lt;/p&gt;
&lt;p&gt;5.接口的实现类必须实现接口的全部方法，否则就变成了抽象类。&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;三、接口使用的关键点？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 了解接口很重要的一点就是它和抽象类的区别，这两个东西确实很像，都有继承，都有抽象方法，有种不严谨的说法甚至说“可以把接口当作一种极端的抽象类”，这么说有一定道理，但是接口和抽象类还是有很大的不同：&lt;/p&gt;
&lt;p&gt;【语法方面】：&lt;/p&gt;
&lt;p&gt;1.抽象类中属性可以有常量、变量，接口中只能是 public static final 修饰的常量；&lt;/p&gt;
&lt;p&gt;2.抽象类中方法可以有抽象方法、普通成员方法，接口中只能有抽象方法；&lt;/p&gt;
&lt;p&gt;3.抽象类只能单继承，接口可以继承多个接口；&lt;/p&gt;
&lt;p&gt;4.一个类只能继承一个抽象类，一个类可以实现多个接口。&lt;/p&gt;
&lt;p&gt; 【设计方面】：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;&lt;span&gt;抽象类是对事物的抽象，接口是对行为的抽象。&lt;/span&gt;&lt;/strong&gt;就像上面蜘蛛侠的例子，抽象类 Person 是抽象人这个事物，接口 ISpiderable 是抽象蜘蛛的行为能力。&lt;/p&gt;
&lt;p&gt;2.设计模式不同，抽象类作为很多子类的父类，它是一种&lt;strong&gt;&lt;span&gt;模板式设计&lt;/span&gt;&lt;/strong&gt;。而接口是一种行为规范，它是一种&lt;strong&gt;&lt;span&gt;辐射式设计&lt;/span&gt;&lt;/strong&gt;。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，就像上面打印机的例子，如果改变了纸张IPaper的接口，那么纸张的实现类 A4Paper() 和 B5Paper()就都要修改。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://helpliebao1.ksmobile.com/g/v1/?action=1&amp;amp;domain=liebao_i.cnblogs.com&amp;amp;number=0&amp;amp;version=1&amp;amp;product_no=106&amp;amp;public_index=2&amp;amp;business_index=244&amp;amp;uuid=656e2378ca077e40cd998728cba04c9f&amp;amp;duba_uuid=656e2378ca077e40cd998728cba04c9f&amp;amp;pid=&amp;amp;spid=&amp;amp;tid1=0&amp;amp;tid2=0&amp;amp;tod1=0&amp;amp;tod2=0&amp;amp;lbver=&amp;amp;tryno=0&amp;amp;iid=0&amp;amp;svrid=&amp;amp;os=0&amp;amp;ie=0&amp;amp;wtod2=&amp;amp;usertype_public=0&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 03:28:00 +0000</pubDate>
<dc:creator>可比克番茄</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/419liu/p/7594402.html</dc:identifier>
</item>
<item>
<title>JavaScript面向对象(OOP) - 姐姐jy</title>
<link>http://www.cnblogs.com/jiejiejy/p/7666091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiejiejy/p/7666091.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  前  言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;JRedu&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;span&gt;面向对象程序设计（简称OOP）是现在最流行的程序设计方法，这种方法有别于基于过程的程序设计方法。在写面向对象的WEB应用程序方面JavaScript是一种很好的选择.它能支持OOP.因为它通过原型支持继承的方式和通过属性和方法的方式一样好.很多开发者试图抛弃JS,试着用C#或JAVA仅是因为JS不是他认为合适的面向对象的语言.许多人还没有认识到javascript支持继承.当你写面向对象的代码时.它能给你很强大的能量.你也可以使用它写出可复用,可封装的代码.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、什么是面向对象编程(OOP)?&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;        &lt;span&gt;在了解什么是面向对象编程之前，我们来看看语言的分类。总体可以分为三类：&lt;strong&gt;面向机器&lt;/strong&gt;、&lt;strong&gt;面向过程&lt;/strong&gt;还有&lt;strong&gt;面向对象&lt;/strong&gt;。面向对象的语言主要有C++、Java、PHP等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;面向过程与面向对象&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;    &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)面向过程：面向过程专注于如何去解决一个问题的&lt;span&gt;过程步骤&lt;/span&gt;。编程特点是由一个个函数去实现每一步的过程步骤，没有类和对象的概念。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2)面向对象：专注于由&lt;span&gt;哪一个对象&lt;/span&gt;来解决这个问题，编程特点是出现了一个类，从类中拿到对象，由这个对象去解决具体问题。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         对于调用者来说，面向过程需要调用者自己去实现各种函数。而面向对象，只需要告诉调用者，对象中具体方法的功能，而不需要调用者了解方法中的实现细节。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;面向对象的三大特征&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;     &lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这个对于计算机专业的人来说，相信大家已经很熟悉啦，那我就再说一遍吧~&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      面向对象的三大特征是&lt;span&gt;&lt;strong&gt;继承、封装、多态&lt;/strong&gt;&lt;/span&gt;。JS可以模拟实现继承和封装，但是无法模拟实现多态，所以我们说JS是一门&lt;strong&gt;基于&lt;/strong&gt;对象的语言，而非是面向对象的语言。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;3&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;类和对象&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;1、类：一类具有相同特征（属性）和行为（方法）的集合。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;比如&lt;/strong&gt;，人类具有身高、体重等属性，吃饭、大笑等行为，所以，我们可以把人划分为一类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;2、对象：从类中，拿出具有确定属性值和方法的个体。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;比如&lt;/strong&gt;，张三--&amp;gt;属性：身高180体重180 方法：说话--&amp;gt;我叫张三，身高180&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、类和对象的关系：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;①类是&lt;span&gt;抽象&lt;/span&gt;的，对象是&lt;span&gt;具体&lt;/span&gt;的(类是对象的抽象化，对象是类的具体化)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②类是一个抽象的概念，只能说类有属性和方法，但是不能给属性赋具体的。比如，人类有姓名，但是不能说人类的姓名叫什么。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   对象是一个具体的个例，是将类中的属性进行具体赋值而来的个体。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;比如，张三是一个人类的个体。可以说张三的姓名叫张三。也就是张三对人类的每一个属性进行了具体的赋值，那么张三就是由人类产生的一个对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、使用类和对象的步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1)创建一个类(构造函数):类名必须使用&lt;span&gt;大驼峰法则&lt;/span&gt;。即每个单词首字母都要大写&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; 类名(属性1){
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.属性1=&lt;span&gt;属性1;
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.方法=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法中要调用自身属性，必须使用this.属性&lt;/span&gt;
&lt;span&gt;     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)通过类实例化(new)出一个对象。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; 类名(属性1的具体值);
obj.属性; 调用属性
obj.方法; 调用方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3)&lt;strong&gt;&lt;span&gt;注意事项&lt;/span&gt;&lt;/strong&gt;：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;①通过类名，new出一个对象的过程，叫做&quot;&lt;strong&gt;类的实例化&lt;/strong&gt;&quot;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;②类中的this,会在实例化的时候，指向新new出的对象。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;所以，this.属性 this.方法实际上是将属性和方法绑定在即将new出的对象上面。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;③在类中，要调用自身属性，必须使用this.属性名。如果直接使用变量名，则无法访问对应的属性。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name,age){
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age=&lt;span&gt;age;
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.say=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(content){
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在类中，访问类自身的属性，必须使用this.属性调用。&lt;/span&gt;
       alert(&quot;我叫&quot;+&lt;span&gt;this&lt;/span&gt;.name+&quot;,今年&quot;+&lt;span&gt;this&lt;/span&gt;.age+&quot;岁,我说了一句话：&quot;+&lt;span&gt;content);
   }
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; zhangsan=&lt;span&gt;new&lt;/span&gt; Person(&quot;姐姐&quot;,18&lt;span&gt;);
zhangsan.say(&lt;/span&gt;&quot;你好呀&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;④类名必须使用大驼峰法则，注意与普通函数区分。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;4&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;面向对象的两个重要属性&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)constructor:返回当前对象的构造函数。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;zhangsan.constructor==Person;&lt;/span&gt;  ( true)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2)instanceof:检测一个对象是不是一个类的实例；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;lisi instanceof Person&lt;/span&gt;              √ lisi是通过Person类new出的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;lisi instanceof Object&lt;/span&gt;              √ 所有对象都是Object的实例&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;Person instanceof Object&lt;/span&gt;        √ 函数本身也是对象&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;5&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;广义对象与狭义对象&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1)狭义对象：只有属性和方法，除此之外没有任何其他内容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj={};  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用{}声明的对象&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;new&lt;/span&gt; Object(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用new声明的对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2)广义对象：除了用字面量声明的基本数据类型之外，JS中万物皆对象。换句话说，只要能添加属性和方法的变量，都可以称为对象。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; s=&quot;123&quot;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是对象&lt;/span&gt;
s.name=&quot;aaa&quot;&lt;span&gt;;
console.log(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(s)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;
console.log(s.name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;undfined 字面量声明的字符串不是对象，不能添加属性&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; s=&lt;span&gt;new&lt;/span&gt; String(&quot;123&quot;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是对象&lt;/span&gt;
s.name=&quot;aaa&quot;&lt;span&gt;;
console.log(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(s)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;
console.log(s.name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;aaa&quot; 使用new声明的字符串是对象，能添加属性和方法。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、 成员属性、静态属性和私有属性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;1、在构造函数中，使用this.属性声明。或者在实例化出对象以后，使用&quot;对象.属性&quot;追加的，都属于&lt;strong&gt;成员属性&lt;/strong&gt;或&lt;strong&gt;成员方法&lt;/strong&gt;。也叫实例属性或实例方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     成员属性/方法，是属于由类new出的对象的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     需要使用&quot;对象名.属性名&quot;调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【静态属性与静态方法】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、通过“类名.属性名”、“类名.方法名”声明的属性和方法，称为&lt;strong&gt;静态属性&lt;/strong&gt;、&lt;strong&gt;静态方法&lt;/strong&gt;。也叫类属性和类方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     类属性/类方法，是属于类的(属于构造函数的)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     通过&quot;类名.属性名&quot;调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、成员属性是属于实例化出的对象的，只能使用对象调用。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;静态属性是属于构造函数的，只能使用类名调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[私有属性和私有方法]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4、在构造函数中，使用var声明的变量称为私有属性；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在构造函数中，使用function声明的函数，称为私有方法；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(){
&lt;/span&gt;&lt;span&gt;    var&lt;/span&gt; num=1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有属性&lt;/span&gt;
&lt;span&gt;    function&lt;/span&gt; func(){}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有方法&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;私有属性和私有方法的作用域，只在构造函数内容有效。即只能在构造函数内部使用，在构造函数外部，无论使用对象名还是类名都无法调用。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=name; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明成员属性&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; sex=&quot;男&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有属性&lt;/span&gt;
&lt;span&gt;                
}
            
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; zhangsan=&lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;&lt;span&gt;);
zhangsan.age&lt;/span&gt;=14; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;追加成员属性&lt;/span&gt;
alert(zhangsan.name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用成员属性&lt;/span&gt;
&lt;span&gt;            
Person.count&lt;/span&gt;=&quot;60亿&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明静态属性&lt;/span&gt;
alert(Person.count); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用静态属性&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; lisi=&lt;span&gt;new&lt;/span&gt; Person(&quot;李四&quot;&lt;span&gt;);&lt;br/&gt;console.log(lisi.count); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined 静态属性是属于类的，只能用类名调用。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、 JavaScript模拟实现封装&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;1、什么叫封装？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;①方法的封装：将类内部的函数进行&lt;span&gt;私有化&lt;/span&gt;处理，不对外提供接口，无法在类外部使用的方法，称为私有方法，即方法的封装。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;②属性的封装：将类中的属性进行私有化处理，对外不能直接使用对象名访问(私有属性)。同时，需要提供专门用于设置和读取私有属性的set/get方法，让外部使用我们提供的方法，对属性进行操作。这就叫属性的封装。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、&lt;span&gt;注意&lt;/span&gt;：封装不是拒绝访问，而是&lt;span&gt;限制访问&lt;/span&gt;。要求调用者，必须使用我们提供的set/get方法进行属性的操作，而不是直接拒绝操作。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;因此，单纯的属性私有化，不能称为封装！必须要有私有化后，提供对应的set/get方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name,age1){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  this.age=age;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; age=0&lt;span&gt;;
                 
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setAge=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(ages){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ages&amp;gt;0&amp;amp;&amp;amp;ages&amp;lt;=120&lt;span&gt;){
            age&lt;/span&gt;=&lt;span&gt;ages;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            alert(&lt;/span&gt;&quot;年龄赋值失败&quot;&lt;span&gt;);
        }
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当实例化类拿到对象时，可以直接通过类名的()传入年龄，设置私有属性&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt;(age1!=undefined) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setAge(age1);
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getAge=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
   }
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sayTime=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
       alert(&lt;/span&gt;&quot;我说当前时间是：&quot;+&lt;span&gt;getTime());
   }
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.writeTime=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
       alert(&lt;/span&gt;&quot;我写了当前时间是：&quot;+&lt;span&gt;getTime());
   }
                &lt;br/&gt;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;私有化的方法，只能在类内部被其他方法调用，而不能对外提供功能。这就是方法的封装&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getTime(){
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
   }
}
            
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; zhangsan=&lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;,99&lt;span&gt;);
zhangsan.setAge(&lt;/span&gt;99&lt;span&gt;);
alert(&lt;/span&gt;&quot;张三的年龄是&quot;+&lt;span&gt;zhangsan.getAge());
            
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lisi=&lt;span&gt;new&lt;/span&gt; Person(&quot;李四&quot;,99&lt;span&gt;);
lisi.setAge(&lt;/span&gt;110&lt;span&gt;);
alert(&lt;/span&gt;&quot;李四的年龄是:&quot;+lisi.getAge());
&lt;/pre&gt;&lt;/div&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、JavaScript中的this指向详解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;1、&lt;span&gt;&lt;strong&gt;谁最终调用函数，this最终指向谁&lt;/strong&gt;&lt;/span&gt;(记住！)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;①this指向谁，不应考虑函数在哪声明，而应该考虑函数在哪调用！！！&lt;/span&gt;&lt;br/&gt;&lt;span&gt;②this指向的永远只可能是对象，而不可能是函数。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;③this指向的对象，叫做函数的上下文context，也叫函数的调用者。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;2、this指向的规律！！！(跟函数的&lt;span&gt;&lt;strong&gt;调用方式&lt;/strong&gt;&lt;/span&gt;息息相关，记住这点，相信你一定会分清this指向哒)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;①通过函数名()调用的，this永远指向window&lt;/span&gt;&lt;br/&gt;&lt;span&gt;②通过对象.方法调用的，this指向这个对象。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;③函数作为数组中的一个元素，用数组下标调用的，this指向这个数组&lt;/span&gt;&lt;br/&gt;&lt;span&gt;④函数作为window内置函数的回调函数使用，this指向window。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;setInterval setTimeout 等。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;⑤函数作为构造函数，使用new关键字调用，this指向新new出的对象。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; func(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;{
    name:&lt;/span&gt;&quot;zhangsan&quot;&lt;span&gt;,
    func:func
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;①通过函数名()调用的，this永远指向window。&lt;/span&gt;
&lt;span&gt;func();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;②通过对象.方法调用的，this指向这个对象&lt;/span&gt;
obj.func();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;狭义对象&lt;/span&gt;
&lt;span&gt;            
window.onclick&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    document.getElementById(&lt;/span&gt;&quot;div1&quot;).onclick=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        func();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终还是使用()调用，所以指向window&lt;/span&gt;
&lt;span&gt;    }
    document.getElementById(&lt;/span&gt;&quot;div1&quot;).onclick=func;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;广义对象，指向div&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;③函数作为数组中的一个元素，用数组下标调用的，this指向这个数组&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; arr=[1,2,3,func,4,5,6&lt;span&gt;];
arr[&lt;/span&gt;3&lt;span&gt;]();
            
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;④函数作为window内置函数的回调函数使用，this指向window。&lt;/span&gt;
setTimeout(func,1000&lt;span&gt;);
            
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;⑤函数作为构造函数，使用new关键字调用，this指向新new出的对象。&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; obj1=&lt;span&gt;new&lt;/span&gt; func();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;现在，你一定分清了this指向了吧，下面我们来看一个综合案例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj1=&lt;span&gt;{
    name:&lt;/span&gt;&quot;obj1&quot;&lt;span&gt;,
    arr:[func,&lt;/span&gt;1,{name:&quot;obj2&quot;,func:func},3,4&lt;span&gt;],
}
obj1.arr[&lt;/span&gt;0]();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终的调用者是数组。this--&amp;gt;obj.arr&lt;/span&gt;
setTimeout(obj1,arr[0],2000);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;obj.arr[0]仅仅是取到函数赋给setTimeout，但并没有调用。函数的最终调用者是setTimeout。这个式子相当于setTimeout(func,2000);&lt;/span&gt;
obj1.arr[2].func();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终调用者是{name:&quot;obj2&quot;,func:func}&lt;/span&gt;
setTimeout(obj1.arr[2].func,2000);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终调用者是setTimeout&lt;/span&gt;
            
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;↓最终的调用者是div1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//document.getElementById(&quot;div1&quot;).onclick=obj1.arr[0];&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;document.getElementById(&quot;div1&quot;).onclick=arr[2].func;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最后，我们再来看一道面试题：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; fullname = 'John Doe'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
   fullname: &lt;/span&gt;'Colin Ihrig'&lt;span&gt;,
   prop: {
      fullname: &lt;/span&gt;'Aurelio De Rosa'&lt;span&gt;,
      getFullname: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fullname;
      }
   }
};
console.log(obj.prop.getFullname()); 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数的最终调用者 obj.prop &lt;/span&gt;
            
&lt;span&gt;var&lt;/span&gt; test =&lt;span&gt; obj.prop.getFullname;
console.log(test());  
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数的最终调用者 test()  this-&amp;gt; window&lt;/span&gt;
&lt;span&gt;            
obj.func &lt;/span&gt;=&lt;span&gt; obj.prop.getFullname;
console.log(obj.func()); 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数最终调用者是obj&lt;/span&gt;
            
&lt;span&gt;var&lt;/span&gt; arr = [obj.prop.getFullname,1,2&lt;span&gt;];
arr.fullname &lt;/span&gt;= &quot;JiangHao&quot;&lt;span&gt;;
console.log(arr[&lt;/span&gt;0&lt;span&gt;]());&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数最终调用者数组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这次就分享到这了，下次再介绍JS中OOP中的继承方法吧~&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 03:24:00 +0000</pubDate>
<dc:creator>姐姐jy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiejiejy/p/7666091.html</dc:identifier>
</item>
<item>
<title>邮件实现详解（三）------邮件的组织结构 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/7663695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/7663695.html</guid>
<description>&lt;p&gt;　　要想各种邮件处理程序能识别我们所写的电子邮件，能从我们所书写的电子邮件中分析和提取出发件人，收件人，邮件主题和邮件内容以及附件等信息，那么我们所写的电子邮件必须要遵循一定的格式要求，正如我们上一篇博客 &lt;a id=&quot;post_title_link_7653252&quot; href=&quot;http://www.cnblogs.com/ysocean/p/7653252.html&quot;&gt;手工体验smtp和pop3协议&lt;/a&gt; ，我们在发送邮件时有固定的写法。而这种邮件内容的基本格式和具体细节分别是由 RFC822 文档和 MIME 协议定义的。&lt;/p&gt;

&lt;h3&gt;1、RFC822 邮件格式&lt;/h3&gt;
&lt;p&gt;　　英文参考文档如下：&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot; target=&quot;_blank&quot;&gt;https://tools.ietf.org/html/rfc822&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　RFC822 文档中定义的文件格式包括两个部分：邮件头和邮件体。在上一篇博客，我们通过SMTP服务发送一封邮件，然后用POP3服务器接收。邮件接收内容如下图红色框所显示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171013231405340-672574122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这上面显示的不全，我这里将其内容整理出来，并在每行左边加上标号：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:false;&quot;&gt;
1 Received: from smtpbg5.qq.com (unknown [183.60.61.230])
        by mx6 (Coremail) with SMTP id OMCowACXv+ssf99ZD5FqAg--.5570S3;
        Thu, 12 Oct 2017 22:41:48 +0800 (CST)
2 DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=qq.com; s=s201512;
        t=1507819308; bh=N2xK6iU/bt0tcntOdutSQ3tkYXbTtOi08RT+HjuXmBc=;
        h=From:To:Subject:Mime-Version:Content-Type:Content-Transfer-Encoding:Date:Message-ID;
        b=lzBtxAWw0+HB1bGLkkCqlUeU4bvVoMxDp3UZTKq3YCIJt5Ypu4FkE0m5rrrpcxF0D
         W0/PQajrQTughLTmpjoudI5aDWjfrfkOc1Z0+ltaAraoZfdE5HmNQ0hxQstNa+IbjC
         GMVEzCOMikVm5qklyCz/1Lwd5mBJ90YkknS3sL08=
3 X-QQ-FEAT: Gf8h89u9tNwRjwDYIPPhYegibbvTgUmwr4I/ntV6mwr6YOyFiWpUpVj+bCsJz
        tAz24NjMs/p1D8BXG7LYvZRCPMPQV7jdW3AKjTclrSS9xE29fxWsEjYk5QlD1cMIuhHF9Po
        1HMwWKIZX8q6smehIwr+t/du8sprvHVue4ty5KMPeWw967qaAZgta5hcnRtgajhZRcIumVx
        r+K4/nY7I+wwNenOTfHT4Ly4K1Ne+vD7VNJbLHH674HEJ2CsoSEEBW7X/LeeSq6M=
4 X-QQ-SSF: 0001000000000010000000000000007
5 X-HAS-ATTACH: no
6 X-QQ-BUSINESS-ORIGIN: 2
7 X-Originating-IP: 113.57.253.69
8 X-QQ-STYLE:
9 X-QQ-mid: webmail4t1507819307t4823829

10 From: &quot;=?ISO-8859-1?B?MTEzMjgwMzk1MQ==?=&quot; &amp;lt;1132803951@qq.com&amp;gt;
11 To: &quot;=?ISO-8859-1?B?MTgyNzEyNjU3MzI=?=&quot; &amp;lt;18271265732@163.com&amp;gt;
12 Subject: hello world
13 Mime-Version: 1.0
14 Content-Type: multipart/alternative;
        boundary=&quot;----=_NextPart_59DF7F2B_08CB07D0_339F08F2&quot;
15 Content-Transfer-Encoding: 8Bit
16 Date: Thu, 12 Oct 2017 22:41:47 +0800
17 X-Priority: 3
18 Message-ID: &amp;lt;tencent_9EFED46440A5BAD43E6BC680FAC8A58E460A@qq.com&amp;gt;
19 X-QQ-MIME: TCMime 1.0 by Tencent
20 X-Mailer: QQMail 2.x
21 X-QQ-Mailer: QQMail 2.x
22 X-QQ-SENDSIZE: 520
23 Received: from qq.com (unknown [10.137.130.92])
        by smtp.qq.com (ESMTP) with SMTP
        id ; Thu, 12 Oct 2017 22:41:47 +0800 (CST)
24 Feedback-ID: webmail:qq.com:bgweb:bgweb4
25 X-CM-TRANSID:OMCowACXv+ssf99ZD5FqAg--.5570S3
26 Authentication-Results: mx6; spf=pass smtp.mail=1132803951@qq.com; dki
        m=pass header.i=@qq.com
27 X-Coremail-Antispam: 1Uf129KBjDUn29KB7ZKAUJUUUUU529EdanIXcx71UUUUU7v73
        VFW2AGmfu7bjvjm3AaLaJ3UbIYCTnIWIevJa73UjIFyTuYvj4RWLvtDUUUU

28 This is a multi-part message in MIME format.

29 Content-Type: text/plain;
        charset=&quot;ISO-8859-1&quot;
30 Content-Transfer-Encoding: base64

31 PGRpdj48c3BhbiBzdHlsZT0iZm9udC1mYW1pbHk6ICdsdWNpZGEgR3JhbmRlJywgVmVyZGFu
YSwgJ01pY3Jvc29mdCBZYUhlaSc7IGxpbmUtaGVpZ2h0OiAyMy44cHg7Ij5UaGlzIGlzIHRo
ZSBmaXJzdCBlbWFpbCBzZW50IGJ5IGhhbmQgdXNpbmcgdGhlIFNNVFAgcHJvdG9jb2w8L3Nw
YW4+PC9kaXY+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面便是 RFC822 所定义的邮件格式，从第 1 行到第 30 行都是邮件头，第 31 行是邮件体（经过base64加密过了，有兴趣的大家可以解码看看）。而邮件头和邮件体之间以一个空行间隔，邮件头部分是由多个头字段和字段内容组成，分别表示收件人，发件人，发件时间，主题等信息。还有一些信息是对应的SMTP服务器在邮件传递过程中所加上的，我们知道现实生活中的邮局在处理邮件时，通常都会在信封上加上邮戳，表示这封邮件在什么时候经过了哪个邮局哪个部门处理，我们上个例子是QQ邮箱发给163邮箱的。而SMTP服务器按从下往上的方式添加信息，即先添加的字段位于后添加字段的后面。所以qq的SMTP服务器会先添加头字段，但是添加的字段会在163的SMTP服务器添加字段的下面，另外 POP3服务器也会自己添加一些字段。&lt;/p&gt;
&lt;p&gt;　　每一个邮件头以“字段名：字段值”的格式出现，即每一行邮件头的内容依次由字段名、冒号、空格、字段值、回车换行符组成。RFC822文档中定义了多个标准的邮件头字段，每一个邮件头字段表示一种特定的信息。邮件头中也可以包含自定义的头字段，这种自定义的头字段通常是某个组织或机构内部专用的。下面是对一些主要的邮件头字段的解释：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171013234326574-1153565600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们从上可以知道，RFC822文档存在两个问题：&lt;/p&gt;
&lt;p&gt;　　①、定义了邮件内容的主体结构和各种邮件头字段的详细细节，但是，它没有定义邮件体的格式，RFC822文档定义的邮件体部分通常都只能用于表述一段普通的文本，而无法表达出图片、声音等二进制数据。&lt;/p&gt;
&lt;p&gt;　　②、SMTP服务器在接收邮件内容时，当接收到只有一个“.”字符的单独行时，就会认为邮件内容已经结束，如果一封邮件正文中正好有内容仅为一个“.”字符的单独行，SMTP服务器就会丢弃掉该行后面的内容，从而导致信息丢失。&lt;/p&gt;
&lt;p&gt;　　上面两个问题是致命的，当今的电子邮件，人们希望在电子邮件中嵌入图片、声音、动画和附件。但是，由于图片和声音等内容是非ASCII码的二进制数据，而RFC822邮件格式只适合用来表达纯文本的邮件内容，所以，要使用RFC822邮件格式发送这些非ASCII码的二进制数据时，必须先采用某种编码方式将它们“编码”成可打印的ASCII字符后再作为RFC822邮件格式的内容。邮件阅读程序在读取到这种经过编码处理的邮件后，再按照相应的解码方式解码出原始的二进制数据，这样就可以借助RFC822邮件格式来传递多媒体数据了。这种做法需要解决一下两个技术问题：&lt;/p&gt;
&lt;p&gt;　　一、邮件阅读程序如何知道邮件中嵌入的原始二进制数据所采用的编码方式；&lt;/p&gt;
&lt;p&gt;　　二、邮件阅读程序如何知道每个嵌入的图像或其他资源在整个邮件内容中的起止位置。&lt;/p&gt;
&lt;p&gt;　　为了解决上面两个问题，人们后来专门为此定义了MIME（Multipurpose Internet Mail Extension，多用途Internet邮件扩展）协议。&lt;/p&gt;

&lt;h3&gt;2、MIME协议&lt;/h3&gt;
&lt;p&gt;　　MIME协议用于定义复杂邮件体的格式，它可以表达多段平行的文本内容和非文本的邮件内容，例如，在邮件体中内嵌的图像数据和邮件附件等。另外，MIME协议的数据格式也可以避免邮件内容在传输过程中发生信息丢失。MIME协议不是对RFC822邮件格式的升级和替代，而是基于RFC822邮件格式的扩展应用。一言以蔽之，RFC822定义了邮件内容的格式和邮件头字段的详细细节，MIME协议则是定义了如何在邮件体部分表达出的丰富多样的数据内容。&lt;/p&gt;
&lt;p&gt;　　一个采用了MIME协议的电子邮件就叫做MIME邮件，MIME邮件在RFC822文档中定义的邮件头字段的基础上，扩充了一些自己专用的邮件头字段，例如，使用MIME-Version头字段指定MIME协议的版本，使用Content-Type头字段指定邮件体的MIME类型，使用Content-Transfer-Encoding头字段指定编码方法，如下所示： 　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
MIME-Version:1.0

Content-Type:multipart/mixed;boundary=&quot;----=_NextPart_000_0050_01C&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中，“multipart/mixed”部分说明邮件体中包含有多段数据，每段数据之间使用boundary属性中指定的字符文本作为分隔标识符。另外，MIME邮件也扩展了RFC822文档中已经定义了的邮件头字段的内涵，例如，定义了subject头字段中的值内容的格式，以便通过编码的方式让邮件主题中也可以使用非ASCII码的字符。subject头字段中的值嵌套在一对“=?”和“?=”标记符之间，标记符之间的内容由三部分组成：邮件主题的原始内容的字符集、当前采用的编码方式、编码后的结果，这三部分之间使用“?”进行分隔。&lt;/p&gt;

&lt;h3&gt;3、总结&lt;/h3&gt;
&lt;p&gt;　　这篇博客，带上前面两篇博客，我们就将邮件的收发基本原理讲了一下。那么有人会问，实际项目中我们也需要考虑邮件的底层实现协议吗？答案是不用的，比如 sun 公司（现在已经被orcal收购了）开发的JavaMail API 就是为方便Java开发人员在应用程序中实现邮件接收和发送功能而提供的一套标准开发包，屏蔽了底层的邮件实现协议，那么下一篇博客我们就来用JavaMail 实现邮件收发功能。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 02:51:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/7663695.html</dc:identifier>
</item>
</channel>
</rss>