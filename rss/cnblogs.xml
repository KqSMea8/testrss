<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>资本论第一卷笔记 - my笔触</title>
<link>http://www.cnblogs.com/yuxiuyan/p/9658606.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuxiuyan/p/9658606.html</guid>
<description>&lt;p&gt;       现代社会，无论是什么职业，都需要懂一些金融、经济的知识。以前的文盲是不识字的人，而现代的文盲则是不懂计算机、经济等领域常识的人。我们不应该做书呆子或者只是专于某一领域的人，而应该全面科学地发展。现在各种“概念经济”被媒体炒得火热，区块链方兴未艾。但是我们不能做盲目的投资者，如果你对经济领域一窍不通却想投机取巧，那也只能是镜花水月一般。马克思的《资本论》对经济学有了一个大致的概括体系，科学地阐明了资本主义社会的发展方式，无论是对于西方的经济理论，还是国内的市场经济理论，都有十分重要的阅读价值和参考价值。由于各种因素，在寒假暂时阅读了第一卷——资本的生产过程。事实上，资本论阅读起来还是相当吃力的，所以在阅读过程中也是参考了许多文献，但还是有晦涩的地方。&lt;/p&gt;
&lt;p&gt;      第一卷主要是针对资本的生产过程，从商品、工人、剩余价值等角度，阐明了社会生产与再生产，工人与资本家等多方面的关系。我们生活在一个商品社会，无论你是什么职业，学生、农民、工人、教师、企业家……都无法摆脱商品社会的影响。事实上，公司的职员和工人本质上一样的，资本家通过榨取下属的剩余价值，不断生产与再生产，也推动了社会生产力的发展。&lt;/p&gt;
&lt;p&gt;      我们都学过历史，很多历史事件的成功或失败都与社会生产力息息相关。要仔细了解这其中的因果关系，就需要我们对生产力、资本、阶级等有一个全面而清晰的认识。事实上，资本推动生产力，生产力的发展又推动资本的扩大与积累。如蒸汽机使得当时的社会生产力爆发，所以资本得以快速发展。&lt;/p&gt;

&lt;h2&gt;    第一章 商品&lt;/h2&gt;
&lt;p&gt;       商品是资本主义社会的基本元素，是为了交换而生产的劳动产品。一切的商品都具有使用价值和价值两个因素，所以说，商品是使用价值和价值的统一体。交换价值是价值的表现形式，是人们在日常生活中对于商品价值的衡量。事实上，资本家只关心商品的价值，但是由于使用价值是价值的物质载体，所以资本家还会注意到，对于使用价值大的物品，消费量高，商品的价值较容易体现。缺少任意一个因素，物品都不能成为商品。&lt;/p&gt;
&lt;h2&gt;    第二章 劳动&lt;/h2&gt;
&lt;p&gt;       商品中有价值的，是物化在其中的人类劳动。商品价值，是由社会必要劳动量或者社会必要劳动时间决定的。社会必要劳动时间是社会的，必要的，平均的，所以不能以某个或某些人来衡量。&lt;/p&gt;
&lt;p&gt;      劳动具有二重性，具体劳动和抽象劳动。举个例子，对于布和纱，针对某一部分的使用价值进行的生产劳动，尤其是有用劳动，可以看作是一种具体的劳动。但是无论是布还是纱，都是人类劳动力有目的的耗费。从生理学角度，一切劳动都是人类劳动力的耗费。有用劳动也可以形成商品价值。&lt;/p&gt;
&lt;h2&gt;    第三章 价值形式与交换价值&lt;/h2&gt;
&lt;p&gt;       商品的二重性决定了商品是使用物品和价值承担者的综合体。商品有自然形式和价值形式。从早期原始社会到现代社会，经历了三个不同阶段：简单个别的（偶然的）价值形式、扩大的相对价值形式、一般价值形式。&lt;/p&gt;
&lt;p&gt;比如，20尺布=1件上衣，这个价值形式，当一件商品处于相对价值形式时，另一件商品就处于等价形式。这时候如果仅仅是一次偶然的交换，那就是处于第一阶段。一个商品的价值需要通过在交换过程中其他商品来反映。在交换时，如果一个商品的价值经常表现在许多其他商品上时，这个商品的相对价值形式就被扩大了,这就是第二阶段。再后来，又出现了20尺布=40斤小麦，20尺布=2斤茶叶……每一类商品的价值都是简单统一的，就进入了第三阶段。&lt;/p&gt;
&lt;h2&gt;    第四章 货币形式&lt;/h2&gt;
&lt;p&gt;              货币是交换过程中的必然产物。其他一切商品都是货币的特殊等价物，货币是它们的一般等价物。当一种特殊商品的自然形式与等价形式紧密结合在一起的时候，就成了一种货币商品，具有了货币的社会职能。特殊商品发生了本质的变化，形成了价格形式。货币的出现，使得商品内在的矛盾转化为商品与货币的对立。一切商品只有换成了货币才能实现自己的价值。&lt;/p&gt;

&lt;h2&gt;    第五章 劳动过程与价值增殖过程&lt;/h2&gt;
&lt;p&gt;　　劳动首先是人与自然之间的过程，是人通过自身的活动，来调整人与自然之间的物质变换的过程。商品生产过程就是劳动过程和价值形成过程的统一。劳动力卖者把自己的劳动表现在商品中，表现在满足某种需要的物化过程中。&lt;/p&gt;
&lt;p&gt;　　工人将劳动力当作商品卖给资本家。资本家购买了劳动力之后，劳动就成了资本家的所有物，就不再属于工人的所有物。&lt;/p&gt;
&lt;p&gt;　　资本家关心的不是商品的使用价值，而是商品价值是否大于生产该商品所需价值的总和。商品的生产过程，是劳动过程与价值形成过程的统一，不仅要生产价值，还要生产剩余价值。工人将自己的劳动力物化在商品价值，在生产过程，假如10份的预付资本（包括6份劳动资料，4份工资），生产出12份的商品价值。这就产生了价值增殖。&lt;/p&gt;
&lt;p&gt;　　价值增殖过程，是生产商品一定的使用价值，并把生产资料的原有价值转移到新产品上去；作为价值增殖过程，工人的劳动作为抽象劳动形成新的价值，其中就包括了剩余价值。资本主义的商品生产过程，必然是追求价值增殖过程。&lt;/p&gt;
&lt;h2&gt;    第六章 不变资本与可变资本&lt;/h2&gt;
&lt;p&gt;　　从价值增殖的角度看，资本分为不变资本和可变资本两部分。不变资本指的是为生产资料、劳动资料付出的资本。可变资本指的是支付给劳动力的资本。可变资本不仅可以在生产过程中改变自己的价值，生产自身的等价物，还能生成一个超过等价物的余额，就是剩余价值。资本家追求的就是剩余价值。&lt;/p&gt;
&lt;h2&gt;    第七章 剩余价值率&lt;/h2&gt;
&lt;p&gt;　　剩余价值率是劳动力受资本剥削的程度，是工人受资本家剥削程度的准确表现，是剩余价值与可变资本的比例，也是剩余劳动与必要劳动的比例。&lt;/p&gt;
&lt;p&gt;      在生产过程中，由于可变资本的增加，资本家预付资本也会增加，相当于资本家总成本在增加，就好像剩余价值不是由可变资本而是由预付资本生产的。这种假象，掩盖了资本对工人的剥削。&lt;/p&gt;
&lt;p&gt;      工人不直接生产所需的生活资料，而是通过生产其他特殊商品来获取同这些生活资料价值相等的价值。如果工人每天生活资料价值6个劳动小时，那他每天的平均6小时的劳动就是为自己的劳动。&lt;/p&gt;
&lt;h2&gt;    第八章 工作日&lt;/h2&gt;
&lt;p&gt;       为了追求更多的剩余价值，资本家会尽量延长工作日，如果可能的话，甚至会把一个工作日当成两个，但是工人也会坚持要求把工作日限制在一定的正常量。&lt;/p&gt;
&lt;p&gt;      一个工作日可以分为必要劳动时间、剩余劳动时间。工人维持自身生活的劳动所占时间为必要劳动时间，生产剩余价值的时间为剩余劳动时间。在必要劳动时间一定的情况下，资本家要追求剩余价值，就会不断延长剩余劳动时间，造成工作日的延长。但是工人会强烈斗争（罢工等），要求资本家把时间限制在正常范围。&lt;/p&gt;
&lt;h2&gt;    第九章 剩余价值率与剩余价值量&lt;/h2&gt;
&lt;p&gt;       在剩余价值率和劳动力一定的情况下，所生产的剩余价值量和可变资本成正比。工人人数是决定剩余价值量的重要因素。&lt;/p&gt;
&lt;p&gt;      19世纪资本主义进入机器大生产阶段，资本家加大对工人的剥削，最大限度延长工作日，但是这种做法很容易遭到工人的反对。通过改进生产技术，提高工作效率，减少社会必要劳动时间，可以增加工人工资，但是工人工资增长率低于生产效率的增产率，实际上也是劳动力价格的明升暗降。&lt;/p&gt;

&lt;h2&gt;    第十章 相对剩余价值&lt;/h2&gt;
&lt;p&gt;       通过延长工作日而生产的剩余价值，叫做绝对剩余价值。通过缩短必要劳动时间而生产的价值，叫做相对剩余价值。要降低劳动力的价值，就必须提高生产力。&lt;/p&gt;
&lt;p&gt;      假如原来的工作日为10小时，包括6小时的必要劳动时间和4小时的剩余劳动时间，如果生产力提高了一倍，那么必要劳动时间就缩短为3小时，剩余劳动时间就延长为7小时。劳动力价值的降低要求生产力的提高。&lt;/p&gt;
&lt;h2&gt;    第十一章 协作&lt;/h2&gt;
&lt;p&gt;　　资本主义生产过程就是同一个资本家同时雇佣较多的工人，在劳动过程中扩大自己的规模并提供大量产品的过程。许多人有计划地协同劳动，这种劳动形式就是协作。协作会产生一种集体力。&lt;/p&gt;
&lt;p&gt;　　资本主义劳动规模的扩大，促使工人协作劳动，协作不但有助于减少生产成本，而且产生一种比单个劳动力的总和强大的多的集体力，有效促进资本主义经济的发展。&lt;/p&gt;
&lt;p&gt;　　协作是资本内在的生产力。是资本主义生产方式的基本形式。&lt;/p&gt;
&lt;h2&gt;    第十二章 分工与工场手工业&lt;/h2&gt;
&lt;p&gt;       工场手工业分工是以生产资料积聚在一个资本家手中为前提，社会分工是以生产资料分散在许多互不依赖的商品生产者手中为前提。&lt;/p&gt;
&lt;p&gt;      为了在一定期限内完成大量的商品，资本家把制造一件产品的各种操作分配给不同的手工业者，共同完成一种产品，在生产过程中，随着分工越来越细，这种局部操作逐渐成了特殊工人的专门职能。工人变成了生产机构的一个器官。&lt;/p&gt;
&lt;h2&gt;    第十三章 机器与大工业&lt;/h2&gt;
&lt;p&gt;　　作为工业时期特有的劳动资料的机器，其价值要比手工业生产和工场手工业生产时期的劳动资料大的多。机器不是使产品的价值变小，而是按它自身的价值是产品增殖。&lt;/p&gt;
&lt;p&gt;　　机器能够使商品便宜，缩短工人的工作日部分。从而无偿地延长工人给予资本家的工作时间。实际上，机器是生产剩余价值的手段。&lt;/p&gt;
&lt;p&gt;　　机器大工业是资本主义生产方式进入成熟的标志。它从手工工具改变为机器开始，机器本身并不创造价值。但当他把自身的价值转移到他生产的产品上时，机器的价值就会得到体现。&lt;/p&gt;
&lt;p&gt;　　机器生产对工人的影响，包括以下几个方面：资本对补充劳动力的占有；工作日的延长；劳动的强化。&lt;/p&gt;
&lt;h2&gt;    第十四章 绝对剩余价值和相对剩余价值&lt;/h2&gt;
&lt;p&gt;　　在上面说到过，绝对剩余价值和相对剩余价值。这两种剩余价值是一种对立统一的关系。资本主义生产不仅是商品的生产，而且是剩余价值的生产。因此，工人不是为自己生产，而是为资本生产，必须生产剩余价值。&lt;/p&gt;
&lt;p&gt;      绝对剩余价值的生产就是把工作日延长到生产劳动力价值的那个点，资本家占有这部分剩余劳动。绝对剩余价值的生产是相对剩余价值生产的起点。从一定的程度来看，相对剩余价值是绝对的，是以工作日的绝对延长为前提的。而绝对剩余价值是相对的，是以劳动生产率的提高为前提的。&lt;/p&gt;

&lt;h2&gt;    第十五章 劳动力价值的转化&lt;/h2&gt;
&lt;p&gt;       工资是劳动力价值的货币表现形式，工资的运动规律就是劳动力的价值的运动规律。计件工资，是资本主义工资的一种形式，它以一定时间内生产的产品数量来计算。它掩盖了资本家利用延长劳动时间，增加劳动强度来剥削工人的实质。&lt;/p&gt;
&lt;p&gt;      劳动力价值采取工资的形式消灭了工作日分为必要劳动和剩余劳动，有酬劳动和无酬劳动的一切痕迹。工人的劳动，全都表现为有酬劳动，这种表现形式掩盖了资本主义雇佣关系的剥削关系。&lt;/p&gt;
&lt;p&gt;      资本主义的现实生活中，作为劳动力的价值，工资的确在形式上表现为劳动的价值或价格。&lt;/p&gt;

&lt;h2&gt;    第十六章 简单再生产&lt;/h2&gt;
&lt;p&gt;       对生产过程和再生产过程的理解。生产过程是整个再生产过程体系其中的一部分。资本家利用预付资本生产出商品，商品进入市场变成货币，货币重新转化为资本。过程不断进行，就形成了连续阶段的循环和资本流通。由此可见，生产过程是产出某一产品的过程，再生产过程是生产，销售，流通，转化等整个循环体系。&lt;/p&gt;
&lt;p&gt;      资本流通的形成要经历三个阶段。第一个阶段，为资本主义生产做准备。第二个阶段是生产剩余价值。第三个阶段，通过出售商品，货币重新转化为资本。&lt;/p&gt;
&lt;h2&gt;    第十七章 剩余价值转化为资本&lt;/h2&gt;
&lt;p&gt;       一般来说，把剩余价值当作资本使用，就是把剩余价值再转化为资本，叫做资本积累。资本家剩余价值是资本积累的源泉。要做到积累，就必须把一部分剩余价值通过追加生产资料的方式转化为资本重新投入生产。&lt;/p&gt;
&lt;p&gt;　　产品属于资本家，不属于工人。产品价值包含预付资本的价值和剩余价值。而且要耗费工人劳动的剩余价值。不需要资本家耗费任何东西。只要找到买者，工人就可以重新出卖劳动，保持自己的劳动力。&lt;/p&gt;
&lt;p&gt;　　资本积累就是资本规模不断扩大的再生产。资本家把剩余价值中的一部分转化为资本，投入到生产中，扩大再生产的规模。扩大再生产可能带来社会的全面繁荣。&lt;/p&gt;
&lt;p&gt;　　资本的积累不仅取决于资本家的剥削程度，而且也会受社会需求的影响。&lt;/p&gt;
&lt;h2&gt;    第十八章 资本主义积累的一般规律&lt;/h2&gt;
&lt;p&gt;      资本的积累对工人阶级命运会产生非常不利的影响。因为资本的积累是扩大规模的再生产成为可能。一方面会产生更多更大的资本家，另一方面，会生产出更多的雇佣工人。资本积累，无形中就演变成无产阶级的增加和受剥削范围的扩大。总得来说，就是资本构成不变，对劳动力的需求随着积累的增长而增长。&lt;/p&gt;
&lt;p&gt;      资本主义再生产中的激烈竞迫使资本家不断地进行资本积累。在资本主义竞争中大资本总是处在有利的地位。为了在竞争中保存自己，击败对手，资本家只有不断地进行资本积累，扩大规模，如同登高才能望远一样。资本家也要不断扩大再生产规模进行资本积累，才有可能在资本竞争中立于不败之地。&lt;/p&gt;
&lt;h2&gt;    第十九章 原始积累&lt;/h2&gt;
&lt;p&gt;       原始积累是指在资本主义生产方式确立以前的历史阶段中，通过暴力使直接生产者与生产资料相分离，由此使货币财富迅速集中于少数人手中的历史过程。原始积累的过程中，大量的人突然被强制和他们的生产资料相分离，被当作不受法律保护的无产者抛向了劳动力市场。对农民土地的剥夺，就是这种过程的基础。&lt;/p&gt;
&lt;p&gt;      原始积累往往伴随着罪恶。新兴的资产阶级和资产阶级化的封建贵族，以暴力的方式剥夺劳动者而实现资本的原始积累。比如，随着美洲金银产地的发现，土著居民要么被剿灭，被奴役，要么被埋葬于矿井。而对东印度和非洲开始进行的征服和掠夺，也都标志着资本主义时代的到来。&lt;/p&gt;
&lt;p&gt;      分工出现之后，一个人仅靠自己生产的产品无法满足全部的生活需要。他必须用自己的产品和以自己产品售出的金钱购买所需要的生产资料。所以，在他制作自己的产品和产品未售出的阶段，他必须要有足够的储蓄来维持生活。这就是资本积累最原始的状态。&lt;/p&gt;
</description>
<pubDate>Sun, 16 Sep 2018 17:19:00 +0000</pubDate>
<dc:creator>my笔触</dc:creator>
<og:description>前言 现代社会，无论是什么职业，都需要懂一些金融、经济的知识。以前的文盲是不识字的人，而现代的文盲则是不懂计算机、经济等领域常识的人。我们不应该做书呆子或者只是专于某一领域的人，而应该全面科学地发展。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuxiuyan/p/9658606.html</dc:identifier>
</item>
<item>
<title>常用6种type的form表单的input标签分析及示例 - NineKit</title>
<link>http://www.cnblogs.com/NineKit/p/9658467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NineKit/p/9658467.html</guid>
<description>&lt;p&gt;&amp;lt;input&amp;gt; 标签用于搜集用户信息。&lt;/p&gt;
&lt;p&gt;根据不同的 type 属性值，输入字段拥有很多种形式。输入字段可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等等。&lt;/p&gt;
&lt;p&gt;在这里博主介绍6中type的input，分别是文本域、密码字段、单选按钮、复选按钮、提交按钮以及指定图片按钮&lt;/p&gt;
&lt;p&gt;1：文本域 &lt;/p&gt;
&lt;p&gt;文本域通过&amp;lt;input type=&quot;text&quot;&amp;gt; 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
First name: &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;firstname&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器下效果展示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480455/201809/1480455-20180917001155565-1518667144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2：密码字段 &lt;/p&gt;
&lt;p&gt;密码字段通过标签&amp;lt;input type=&quot;password&quot;&amp;gt; 来定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Password: &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;pwd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器下效果展示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480455/201809/1480455-20180917001410520-678166626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;密码字段字符不会明文显示，而是以星号或圆点替代。&lt;/p&gt;
&lt;p&gt;3：单选按钮&lt;/p&gt;
&lt;p&gt;&amp;lt;input type=&quot;radio&quot;&amp;gt; 标签定义了表单单选框选项&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&amp;gt;Male&amp;lt;br&amp;gt;
&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&amp;gt;Female
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器显示效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480455/201809/1480455-20180917001620493-701126583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4:复选按钮&lt;/p&gt;
&lt;p&gt;&amp;lt;input type=&quot;checkbox&quot;&amp;gt; 定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Bike&quot;&amp;gt;I have a bike&amp;lt;br&amp;gt;
&amp;lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Car&quot;&amp;gt;I have a car 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器显示效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480455/201809/1480455-20180917001717415-1696140834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5:提交按钮&lt;/p&gt;
&lt;p&gt;&amp;lt;input type=&quot;submit&quot;&amp;gt; 定义了提交按钮.&lt;/p&gt;
&lt;p&gt;当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
Username: &amp;lt;input type=&quot;text&quot; name=&quot;user&quot;&amp;gt;
&amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器显示效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480455/201809/1480455-20180917001824080-661556432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6:指定图片按钮&lt;/p&gt;
&lt;p&gt;&amp;lt;input type=&quot;image&quot;&amp;gt; 定义了指定图片按钮,src后面跟上指定的图片地址或者路径，alt属性为图像提供alt文本，因此屏幕阅读器用户可以更好地了解按钮的用途。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;input type=&quot;image&quot; id=&quot;image&quot; alt=&quot;Login&quot;
           src=&quot;/media/examples/login-button.png&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器显示效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480455/201809/1480455-20180917002104976-556455508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 16 Sep 2018 16:24:00 +0000</pubDate>
<dc:creator>NineKit</dc:creator>
<og:description>&lt;input&gt; 标签用于搜集用户信息。 根据不同的 type 属性值，输入字段拥有很多种形式。输入字段可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等等。 在这里博主介绍6中ty</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NineKit/p/9658467.html</dc:identifier>
</item>
<item>
<title>通过Visual Studio 2012 比较SQL Server 数据库的架构变更 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9658434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9658434.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;一 需求&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;随着公司业务的发展，数据库实例也逐渐增多，数据库也会越来越多，有时候我们会发现正式生产数据库也测试数据库数据不一致，也有可能是预发布环境下的数据库与其他数据库架构不一致，或者，分布式数据库上线，发现某些不可预知的原因，也会导致数据库之间架构不一致等等。因此，在复杂的数据库对象中，迅速全部找出数据库的差异是DBA的一个职业技能。目前，这种比较工具很多，但是下面我们演示是开发人员通过常用工具Visual Studio 2012来比较SQL Server 数据库的架构变更差异情况。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;二 比较步骤&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Step 1 打开VS，SQL（Q）-架构比较-新建架构比较：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180917000235045-968465530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 2 &lt;/strong&gt;&lt;strong&gt;选择数据源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180917000251260-1353760059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 3 &lt;/strong&gt;&lt;strong&gt;选择服务器，选择数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180917000410025-913288962.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 4 &lt;/strong&gt;&lt;strong&gt;同样的方式【选择目标源】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180917000507814-589335637.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 5 &lt;/strong&gt;&lt;strong&gt;点击【比较】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180917000559863-1472162759.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 6&lt;/strong&gt; &lt;strong&gt;结果显示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180917000658541-43924857.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明（&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;）红色代表这个表只在目标中有，源没有；（&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;）蓝色代表这个函数或者角色有不同有变动；（&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;）代表源中有新增，而目标没有。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;三 补充说明&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;当有了比较结果时，其对应的其他功能按钮就可以操作了&lt;strong&gt;【慎用，防止数据更新或删除】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比较完成后，单击&quot;&quot;可以更新”左边的数据库到右边的数据库中，单击&quot;&quot;按钮，生成更新的脚本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180917001110382-1784385418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;谢谢配合！！！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 16 Sep 2018 16:16:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>一 需求 随着公司业务的发展，数据库实例也逐渐增多，数据库也会越来越多，有时候我们会发现正式生产数据库也测试数据库数据不一致，也有可能是预发布环境下的数据库与其他数据库架构不一致，或者，分布式数据库上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9658434.html</dc:identifier>
</item>
<item>
<title>C#中WebRequest请求的一些心得 - 来分享_share</title>
<link>http://www.cnblogs.com/lgshare/p/9638081.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lgshare/p/9638081.html</guid>
<description>&lt;p&gt;　　在C#开发中经常需要进行Web远程访问，方法很多，也使用了很久，但一直没有做一个总结。&lt;/p&gt;
&lt;p&gt;　　C#中用来进行远程请求的方法有很多，如WebClient,WebRequest等,也各有特点。今天在这里主要介绍WebRequest。&lt;/p&gt;
&lt;p&gt;        先从相对入门的不需要证书验证，不需要登录的开始。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetContent(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; uri, Encoding coding)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Get请求中请求参数等直接拼接在url中&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             WebRequest request =&lt;span&gt; WebRequest.Create(uri);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回对Internet请求的响应&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             WebResponse resp =&lt;span&gt; request.GetResponse();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从网络资源中返回数据流&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             Stream stream =&lt;span&gt; resp.GetResponseStream();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             StreamReader sr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(stream, coding);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据流转换文字符串&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; result =&lt;span&gt; sr.ReadToEnd();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭流数据&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            stream.Close();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            sr.Close();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的方法是GET类型的请求。下面介绍POST请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetContentPost(&lt;span&gt;string&lt;/span&gt; uri, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; data, Encoding coding)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             WebRequest request =&lt;span&gt; WebRequest.Create(uri);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             request.ContentType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/x-www-form-urlencoded&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             request.Method = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将字符串数据转化为字节串,这也是POST请求与GET请求区别的地方&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] buffer =&lt;span&gt; coding.GetBytes(data);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于将数据写入Internet资源&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             Stream stream =&lt;span&gt; request.GetRequestStream();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             stream.Write(buffer, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, buffer.Length);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             request.ContentLength =&lt;span&gt; buffer.Length;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;             WebResponse response =&lt;span&gt; request.GetResponse();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从网络资源中返回数据流&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             stream =&lt;span&gt; response.GetResponseStream();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;             StreamReader sr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(stream, coding);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据流转换文字符串&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; result =&lt;span&gt; sr.ReadToEnd();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭流数据&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            stream.Close();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            sr.Close();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面两个方法的特点就是简单易使用，用于获取HTML文档。缺点就是无法处理那些需要证书的页面。&lt;/p&gt;
&lt;p&gt;　　下面我们介绍需要证书验证的页面如何请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调验证证书问题&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CheckValidationResult(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接返回true，接受指定证书进行身份验证  &lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetContent(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; uri, Encoding coding)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面一行代码一定卸载请求开始前。
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用回调的方法进行验证。&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             ServicePointManager.ServerCertificateValidationCallback = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Net.Security.RemoteCertificateValidationCallback(CheckValidationResult);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Get请求中请求参数等直接拼接在url中&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             WebRequest request =&lt;span&gt; WebRequest.Create(uri);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回对Internet请求的响应&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             WebResponse resp =&lt;span&gt; request.GetResponse();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从网络资源中返回数据流&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             Stream stream =&lt;span&gt; resp.GetResponseStream();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;             StreamReader sr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(stream, coding);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据流转换文字符串&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; result =&lt;span&gt; sr.ReadToEnd();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭流数据&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            stream.Close();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            sr.Close();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetContentPost(&lt;span&gt;string&lt;/span&gt; uri, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; data, Encoding coding)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面一行代码一定卸载请求开始前。
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用回调的方法进行验证。&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;             ServicePointManager.ServerCertificateValidationCallback = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Net.Security.RemoteCertificateValidationCallback(CheckValidationResult);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;             WebRequest request =&lt;span&gt; WebRequest.Create(uri);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             request.ContentType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/x-www-form-urlencoded&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             request.Method = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将字符串数据转化为字节串,这也是POST请求与GET请求区别的地方&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] buffer =&lt;span&gt; coding.GetBytes(data);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于将数据写入Internet资源&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;             Stream stream =&lt;span&gt; request.GetRequestStream();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             stream.Write(buffer, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, buffer.Length);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             request.ContentLength =&lt;span&gt; buffer.Length;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;             WebResponse response =&lt;span&gt; request.GetResponse();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从网络资源中返回数据流&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;             stream =&lt;span&gt; response.GetResponseStream();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;             StreamReader sr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(stream, coding);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据流转换文字符串&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; result =&lt;span&gt; sr.ReadToEnd();
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭流数据&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;            stream.Close();
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;            sr.Close();
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; 
&lt;span&gt;70&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　我们以百度举例，看访问百度时如何获取百度服务器的证书相关信息。&lt;/p&gt;
&lt;p&gt;　　只需在证书验证的回调函数中添加几行代码即可。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调验证证书问题&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CheckValidationResult(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;证书的有效日期：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; certificate.GetEffectiveDateString());
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;证书的到期日期：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; certificate.GetExpirationDateString());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;证书格式名称：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; certificate.GetFormat());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;证书办法机构名称：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; certificate.Issuer);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;密钥算法信息：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; certificate.GetKeyAlgorithm());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;证书的公钥：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; certificate.GetPublicKeyString());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;证书序列号：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; certificate.GetSerialNumberString());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 总是接受    &lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　使用如下GET方式访问百度。即可得到截图效果。　　&lt;/p&gt;
&lt;p&gt;　　　　GetContent(&quot;https://www.baidu.com/&quot;, Encoding.UTF8);&lt;br/&gt;　　　　Console.WriteLine(str);&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1374681/201809/1374681-20180917000447387-98106245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　然后通过浏览器导航栏的锁标识，即可直接查看百度的相关证书信息。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1374681/201809/1374681-20180917000553888-1122111922.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1374681/201809/1374681-20180917000607525-2062396594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　通过对比可以知道，获取到的证书完全正确。所以如果想对访问的网站有证书检测，也可以通过这种方式。避免出现请求被拦截等问题。&lt;/p&gt;
</description>
<pubDate>Sun, 16 Sep 2018 16:08:00 +0000</pubDate>
<dc:creator>来分享_share</dc:creator>
<og:description>在C#开发中经常需要进行Web远程访问，方法很多，也使用了很久，但一直没有做一个总结。 C#中用来进行远程请求的方法有很多，如WebClient,WebRequest等,也各有特点。今天在这里主要介绍</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lgshare/p/9638081.html</dc:identifier>
</item>
<item>
<title>SpringBoot30 整合Mybatis-Plus、整合Redis、利用Ehcache和Redis分别实现二级缓存 - 寻渝记</title>
<link>http://www.cnblogs.com/NeverCtrl-C/p/9658406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeverCtrl-C/p/9658406.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.spring_redis02.utils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.RedisTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.CollectionUtils;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisUtil {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisTemplate redisTemplate;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 指定缓存失效时间
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key  键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; time 时间(秒)
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; expire(String key, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; time) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (time &amp;gt; 0&lt;span&gt;) {
                redisTemplate.expire(key, time, TimeUnit.SECONDS);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据key 获取过期时间
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 键 不能为null
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 时间(秒) 返回0代表为永久有效
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getExpire(String key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.getExpire(key, TimeUnit.SECONDS);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断key是否存在
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 键
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 存在 false不存在
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasKey(String key) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.hasKey(key);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除缓存
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 可以传一个值 或多个
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; del(String... key) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.length &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key.length == 1&lt;span&gt;) {
                redisTemplate.delete(key[&lt;/span&gt;0&lt;span&gt;]);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                redisTemplate.delete(CollectionUtils.arrayToList(key));
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;============================String=============================  &lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 普通缓存获取
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 键
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object get(String key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; key == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : redisTemplate.opsForValue().get(key);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 普通缓存放入
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true成功 false失败
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; set(String key, Object value) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            redisTemplate.opsForValue().set(key, value);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 普通缓存放入并设置时间
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; time  时间(秒) time要大于0 如果time小于等于0 将设置无限期
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true成功 false 失败
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; set(String key, Object value, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; time) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (time &amp;gt; 0&lt;span&gt;) {
                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                set(key, value);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递增
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; by  要增加几(大于0)
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; incr(String key, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; delta) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delta &amp;lt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;递增因子必须大于0&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForValue().increment(key, delta);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递减
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; by  要减少几(小于0)
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; decr(String key, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; delta) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delta &amp;lt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;递减因子必须大于0&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redisTemplate.opsForValue().increment(key, -&lt;span&gt;delta);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;================================Map=================================  &lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * HashGet
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key  键 不能为null
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item 项 不能为null
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object hget(String key, String item) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForHash().get(key, item);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取hashKey对应的所有键值
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 键
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 对应的多个键值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Map&amp;lt;Object, Object&amp;gt;&lt;span&gt; hmget(String key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForHash().entries(key);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * HashSet
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; map 对应多个键值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 成功 false 失败
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; hmset(String key, Map&amp;lt;String, Object&amp;gt;&lt;span&gt; map) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            redisTemplate.opsForHash().putAll(key, map);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * HashSet 并设置时间
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key  键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; map  对应多个键值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; time 时间(秒)
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true成功 false失败
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; hmset(String key, Map&amp;lt;String, Object&amp;gt; map, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; time) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            redisTemplate.opsForHash().putAll(key, map);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (time &amp;gt; 0&lt;span&gt;) {
                expire(key, time);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item  项
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 成功 false失败
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hset(String key, String item, Object value) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            redisTemplate.opsForHash().put(key, item, value);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item  项
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; time  时间(秒)  注意:如果已存在的hash表有时间,这里将会替换原有的时间
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 成功 false失败
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; hset(String key, String item, Object value, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; time) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            redisTemplate.opsForHash().put(key, item, value);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (time &amp;gt; 0&lt;span&gt;) {
                expire(key, time);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除hash表中的值
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key  键 不能为null
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item 项 可以使多个 不能为null
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; hdel(String key, Object... item) {
        redisTemplate.opsForHash().delete(key, item);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断hash表中是否有该项的值
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key  键 不能为null
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item 项 不能为null
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 存在 false不存在
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hHasKey(String key, String item) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForHash().hasKey(key, item);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * hash递增 如果不存在,就会创建一个 并把新增后的值返回
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key  键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item 项
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; by   要增加几(大于0)
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; hincr(String key, String item, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; by) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForHash().increment(key, item, by);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * hash递减
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key  键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item 项
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; by   要减少记(小于0)
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; hdecr(String key, String item, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; by) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redisTemplate.opsForHash().increment(key, item, -&lt;span&gt;by);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;============================set=============================  &lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据key获取Set中的所有值
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 键
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Set&amp;lt;Object&amp;gt;&lt;span&gt; sGet(String key) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForSet().members(key);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据value从一个set中查询,是否存在
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 存在 false不存在
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; sHasKey(String key, Object value) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForSet().isMember(key, value);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将数据放入set缓存
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key    键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; values 值 可以是多个
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 成功个数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; sSet(String key, Object... values) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForSet().add(key, values);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将set数据放入缓存
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key    键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; time   时间(秒)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; values 值 可以是多个
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 成功个数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; sSetAndTime(String key, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; time, Object... values) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Long count &lt;/span&gt;=&lt;span&gt; redisTemplate.opsForSet().add(key, values);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (time &amp;gt; 0&lt;span&gt;) expire(key, time);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取set缓存的长度
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 键
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; sGetSetSize(String key) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForSet().size(key);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除值为value的
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key    键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; values 值 可以是多个
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 移除的个数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; setRemove(String key, Object... values) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Long count &lt;/span&gt;=&lt;span&gt; redisTemplate.opsForSet().remove(key, values);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;===============================list=================================  &lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取list缓存的内容
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; start 开始
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; end   结束  0 到 -1代表所有值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;Object&amp;gt; lGet(String key, &lt;span&gt;long&lt;/span&gt; start, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; end) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForList().range(key, start, end);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取list缓存的长度
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 键
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; lGetListSize(String key) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForList().size(key);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过索引 获取list中的值
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index 索引  index&amp;gt;=0时， 0 表头，1 第二个元素，依次类推；index&amp;lt;0时，-1，表尾，-2倒数第二个元素，依次类推
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Object lGetIndex(String key, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForList().index(key, index);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将list放入缓存
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; time  时间(秒)
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; lSet(String key, Object value) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            redisTemplate.opsForList().rightPush(key, value);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将list放入缓存
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; time  时间(秒)
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; lSet(String key, Object value, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; time) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            redisTemplate.opsForList().rightPush(key, value);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (time &amp;gt; 0&lt;span&gt;) expire(key, time);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将list放入缓存
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; time  时间(秒)
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; lSet(String key, List&amp;lt;Object&amp;gt;&lt;span&gt; value) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            redisTemplate.opsForList().rightPushAll(key, value);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将list放入缓存
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; time  时间(秒)
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; lSet(String key, List&amp;lt;Object&amp;gt; value, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; time) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            redisTemplate.opsForList().rightPushAll(key, value);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (time &amp;gt; 0&lt;span&gt;) expire(key, time);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据索引修改list中的某条数据
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index 索引
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; lUpdateIndex(String key, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; index, Object value) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            redisTemplate.opsForList().set(key, index, value);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除N个值为value
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; count 移除多少个
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 移除的个数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; lRemove(String key, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; count, Object value) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Long remove &lt;/span&gt;=&lt;span&gt; redisTemplate.opsForList().remove(key, count, value);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; remove;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 16 Sep 2018 16:07:00 +0000</pubDate>
<dc:creator>寻渝记</dc:creator>
<og:description>1 环境说明 JDK: 1.8 MAVEN: 3. SpringBoot: 2.0.4 2 SpringBoot集成Mybatis-Plus 2.1 创建SpringBoot 利用IDEA创建Spri</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeverCtrl-C/p/9658406.html</dc:identifier>
</item>
<item>
<title>解决CSS图片底部3像素问题总结 - 婧星</title>
<link>http://www.cnblogs.com/lvxisha/p/9658287.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvxisha/p/9658287.html</guid>
<description>&lt;p&gt;解决三像素问题的总结：&lt;/p&gt;
&lt;p&gt;1.img标签的父标签增加font-size:0;&lt;/p&gt;
&lt;p&gt;如、body{&lt;br/&gt;　　　　font-size: 0;&lt;br/&gt;　　}&lt;/p&gt;
&lt;p&gt;2.img标签增加display:block;&lt;/p&gt;
&lt;p&gt;img{&lt;br/&gt;display:block;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;3.img标签增加vertical-align: middle;&lt;/p&gt;
&lt;p&gt;img{&lt;br/&gt;vertical-align: middle;//或者vertical-align:top;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;4.img标签增加float:left&lt;/p&gt;
&lt;p&gt;img{&lt;br/&gt;float:left;&lt;br/&gt;}&lt;/p&gt;

&lt;p&gt;为了更好地看效果，读者可以通过运行代码：&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;三像素问题&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;&lt;br/&gt;*{&lt;br/&gt;margin: 0;&lt;br/&gt;padding: 0;&lt;br/&gt;list-style: none;&lt;/p&gt;
&lt;p&gt;}&lt;br/&gt;#box{&lt;br/&gt;width: 500px;&lt;br/&gt;margin: 0 auto;&lt;br/&gt;}&lt;br/&gt;/*解决三像素问题*/&lt;br/&gt;/*//方法一&lt;br/&gt;body{&lt;br/&gt;font-size: 0;&lt;br/&gt;}*/&lt;br/&gt;/*//二&lt;br/&gt;img{&lt;br/&gt;display:block;&lt;br/&gt;}*/&lt;br/&gt;/*//方法三&lt;br/&gt;img{&lt;br/&gt;//vertical-align: top;//vertical-align: top|middle;都可以&lt;br/&gt;vertical-align: middle;&lt;br/&gt;}*/&lt;br/&gt;//方法四&lt;br/&gt;img{&lt;br/&gt;/*float: left;*/&lt;br/&gt;display: block;&lt;br/&gt;}&lt;br/&gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;&amp;lt;div id=&quot;box&quot;&amp;gt;&lt;br/&gt;&amp;lt;img width=&quot;300&quot; height=&quot;300&quot; src=&quot;http://p2.so.qhmsg.com/bdr/200_200_/t0170482b9930a35857.jpg&quot; alt=&quot;加载&quot; title=&quot;&quot;&amp;gt;&lt;br/&gt;&amp;lt;img width=&quot;300&quot; height=&quot;300&quot; src=&quot;http://p2.so.qhmsg.com/bdr/200_200_/t0170482b9930a35857.jpg&quot; alt=&quot;加载&quot; title=&quot;&quot;&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
</description>
<pubDate>Sun, 16 Sep 2018 15:48:00 +0000</pubDate>
<dc:creator>婧星</dc:creator>
<og:description>解决三像素问题的总结： 1.img标签的父标签增加font-size:0; 如、body{ font-size: 0; } 2.img标签增加display:block; img{display:bl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvxisha/p/9658287.html</dc:identifier>
</item>
<item>
<title>【JavaScript系列】浅谈JavaScript之函数(一) - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/9656942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/9656942.html</guid>
<description>&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;       在编程语言中，无论是面向过程的&lt;span lang=&quot;EN-US&quot;&gt;C,兼备面过程和对象的&lt;span lang=&quot;EN-US&quot;&gt;c++，还是面向对象的编程语言，如&lt;span lang=&quot;EN-US&quot;&gt;java,.net,php等，函数均扮演着重要的角色。当然，在面向对象编程语言&lt;span lang=&quot;EN-US&quot;&gt;JavaScript中&lt;span lang=&quot;EN-US&quot;&gt;(严格来说，&lt;span lang=&quot;EN-US&quot;&gt;JS属于弱面向对象编程语言&lt;span lang=&quot;EN-US&quot;&gt;)，函数&lt;span lang=&quot;EN-US&quot;&gt;(function)更扮演着极其重要的角色和占有极其重要的地位。在本篇文章中，不论述什么是&lt;span lang=&quot;EN-US&quot;&gt;JS，&lt;span lang=&quot;EN-US&quot;&gt;JS解决什么问题等之类问题，而是重点阐述&lt;span lang=&quot;EN-US&quot;&gt;JS中的函数&lt;span lang=&quot;EN-US&quot;&gt;(function)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一  什么是javascript函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.函数定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关于函数的定义，我们先从两个角度来思考：数学角度和编程语言角度。&lt;/p&gt;
&lt;p&gt;(1)数学角度：在数学领域，关于“函数”二字，再熟悉不过，如三角函数，反三角函数，幂函数，对数函数，指数函数，微积分函数等；&lt;/p&gt;
&lt;p&gt;(2)编程角度：在编程领域，大家最熟悉且最先接触的应该是&quot;Main函数&quot;了，除此外，如日期函数(Date)，数学函数(Math)等，当然除了内置函数外，还包括用户自定义函数；&lt;/p&gt;
&lt;p&gt;      综合1，2点，我们不难发现，函数的定义应该是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
函数是解决某类问题的集合，是某类问题的高度抽象，它具有一定的通用性和复用性。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.js中两种经典函数定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在Javascript中，存在两种经典的函数定义方式：函数声明式和函数表达式&lt;/p&gt;
&lt;p&gt;(1)函数声明式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; AddNum(num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)函数表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; AddFun=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; AddNum(num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，在用函数表达式定义时，一般采用匿名函数定义，即如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; AddFun=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Question：为什么函数表达式用匿名函数，而函数声明式不用匿名？&lt;/p&gt;
&lt;p&gt;答：因为函数表达式调用时，使用的是函数表达式名，不需要函数名，因此函数名可以匿名，而函数声明式调用时，使用函数名调用，因此不用匿名函数；&lt;/p&gt;
&lt;p&gt; 声明式调用1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; AddNum(num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; console.log(Add(10,20));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;声明式自调用:&lt;/p&gt;
&lt;p&gt;自调用只存在函数声明式中，也叫立即调用，不能在在函数表达式中调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; AddNum(num1, num2) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        console.log(num1 +&lt;span&gt; num2);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   })(10,20);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;声明式调用3:错误调用方式&lt;/p&gt;
&lt;p&gt;请大家想想，这种调用方式为什么会错？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (num1, num2) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; console.log((10,20));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 调用结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201809/1066923-20180916203650057-1041235974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;表达式调用1：推荐写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; AddFun=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; console.log(AddFun(10,20));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 表达式调用2：不推荐写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; AddFun=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; AddNum(num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; console.log(AddFun(10,20));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;表达式调用3:错误调用方式&lt;/p&gt;
&lt;p&gt;请大家想想，这种调用方式为什么会错？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; AddFun=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; AddNum(num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; console.log(AddNum(10,20));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201809/1066923-20180916204052159-316593335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 3.变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在JavaScript编程语言中，变量的定义是通过var关键字来定义的(若变量不通过var定义，则为全局变量，但不推荐这么做)，与其他编程语言一样，变量也分为两大类，即局部变量和全局变量。&lt;/p&gt;
&lt;p&gt;(1)局部变量：作用域为其所在的函数；&lt;/p&gt;
&lt;p&gt;(2)全局变量：作用域为整个过程；&lt;/p&gt;
&lt;p&gt;(3)变量作用域：JS中的变量作用域是通过this指针，从当前的作用域开始，从当前作用域由内向外查找，直到找到位置，这里分为几个逻辑：&lt;/p&gt;
&lt;p&gt;a.从当前作用域由内向外查找,若找到，就停止查找，否则，继续查找，直到查到window全局作用域为止；&lt;/p&gt;
&lt;p&gt;b.当内部作用域变量名与外部作用域变量名相同时，内部作用域的覆盖外部作用域。&lt;/p&gt;
&lt;p&gt;我们来看一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; dateTime='2018-09-16'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; GetUserInfo(){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; age=120&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; name=&quot;Alan_beijing&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Say(){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;        &lt;span&gt;var&lt;/span&gt; name=&quot;老王&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;        &lt;span&gt;var&lt;/span&gt; address=&quot;shanghai&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;        console.log(address+&quot;-&quot;+name+&quot;-&quot;+age+&quot;-&quot;+dateTime);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shanghai-老王-2018-06-05&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Say();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; GetUserInfo();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shanghai-老王-120-2018-09-16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来分析一下变量及其作用域：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201809/1066923-20180916222457579-164742583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，有4个作用域，当函数执行如下语句时，发生如下过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; console.log(address+&quot;-&quot;+name+&quot;-&quot;+age+&quot;-&quot;+dateTime);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a.js当前this环境作用域为4作用域；&lt;/p&gt;
&lt;p&gt;b.this指针寻找变量：addresss,name,age,dateTime，从当前作用域向外作用域逐层寻找，知道寻找到变量值为止,若寻找到最外层作用域任然没找到，则该变量返回undefined；&lt;/p&gt;
&lt;p&gt;c.当内外层变量相同时，内层变量覆盖外层变量，如4作用域的name覆盖3作用域的name;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4.函数声明式定义存在的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 在js中，存在声明提前问题，看看如下例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; globleName=&quot;Alan_beijing&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Say(){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    console.log(localName);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined,不报错，是因为变量声明提前&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;    &lt;span&gt;var&lt;/span&gt; localName=&quot;Alan&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;    console.log(localName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Alan&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看过如上代码，你可能会问，函数执行到console.log(localName); 时，应该报错，因为localName未定义。&lt;/p&gt;
&lt;p&gt;如果在后端语言，如java,.net中，可能会报错，但是在js中，却不会，不报错的原因是：在js中存在声明提前。&lt;/p&gt;
&lt;p&gt;如上代码相当于如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; globleName=&quot;Alan_beijing&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Say(){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; localName;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;   console.log(localName);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;    localName=&quot;Alan&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;   console.log(localName);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 二  函数几大关键点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.匿名函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;匿名函数，顾名思义，就是没名字的的函数，我们来看看如下两个例子：&lt;/p&gt;
&lt;p&gt;函数表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; AddFun=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;立即执行函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; AddNum(num1, num2) {
      console.log(num1 &lt;/span&gt;+&lt;span&gt; num2);
   })(&lt;/span&gt;10,20);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从如上，不难看出，匿名函数主要用域函数表达式和立即执行函数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.闭包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;闭包的根源在于变量的作用域问题。&lt;/p&gt;
&lt;p&gt;我们先来考虑这样一个问题，假设在面向对象编程语言中，某个方法的变量被定义为私有变量，其他函数要获取访问该变量，.net怎么处理？&lt;/p&gt;
&lt;p&gt;方法一：构造函数&lt;/p&gt;
&lt;p&gt;方法二：单例模式&lt;/p&gt;
&lt;p&gt;同样地，在js中，同样存在外部函数调用内部函数变量问题，js运用的技术就叫做闭包。&lt;/p&gt;
&lt;p&gt;所谓闭包,就是将不可访问的变量作为函数返回值的形式返回来，从而实现函数外部访问函数内部变量目的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;闭包&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; GetName() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; name = &quot;Alan_beijing&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; age = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; age = 30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; name +&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.js多态问题(重载问题)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在面向对象编程语言，如.net中，实现多态的方式大致有如下：&lt;/p&gt;
&lt;p&gt;a.接口&lt;/p&gt;
&lt;p&gt;b.抽象类&lt;/p&gt;
&lt;p&gt;c.虚方法&lt;/p&gt;
&lt;p&gt;d.方法重载&lt;/p&gt;
&lt;p&gt;然而，在js中，没有面向对象之说(OO)，那么js是如何实现多态的呢？根据方法实际传递的参数来决定。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重载&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SetUserInfo(userName, age, address, tel, sex) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     console.log(arguments.length);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; SetUserInfo('Alan_beijing',44,'china-shanghai','xxxx');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从如上可以看出，传递多少个参数，就接收多个参数，如果在现象对象编程语言中实现该功能，至少需要写一堆代码，这也是体现js强大之一。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.递归&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;来看看一个递归阶乘函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; factorial(num) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (num &amp;lt; 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; num * arguments.callee(num-1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是.net，我们一般会这样写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; factorial(num) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (num &amp;lt; 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; num * factorial(num-1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而，这样写，却会存在异常情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; factorial1 =&lt;span&gt; factorial;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     factorial = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将factorial变量设置为null&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     console.log(factorial1(4));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 5.原型和原型链&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;面向对象编程语言的显著特征之一是面向对象，然而，在js中，没有对象，那么js是如何面向对象的功能的呢（封装，继承，多态）？当然是通过原型和原型链来实现的。&lt;/p&gt;
&lt;p&gt;大家都比较怕原型和原型链，其实很简单，它的功能相当于面向对象的继承，主要解决继承和复用。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;介于篇幅有限，余下的内容，将在下篇文章阐述.....&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 三  参考文献&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;【01】JavaScript 高级程序设计(第三版)   （美）Nicholas C.Zakas 著       李松峰   曹力  译&lt;/p&gt;
&lt;p&gt;【02】JavaScript 权威指南 (第6版)    David  Flanagan 著&lt;/p&gt;

</description>
<pubDate>Sun, 16 Sep 2018 15:45:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<og:description>在编程语言中，无论是面向过程的C,兼备面过程和对象的c++，还是面向对象的编程语言，如java,.net,php等，函数均扮演着重要的角色。当然，在面向对象编程语言JavaScript中(严格来说，J</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/9656942.html</dc:identifier>
</item>
<item>
<title>浅谈Comparable与Comparator的区别 - 陈灬大灬海</title>
<link>http://www.cnblogs.com/c-h-y/p/9658261.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-h-y/p/9658261.html</guid>
<description>&lt;p&gt;&lt;span&gt;平时进行自定义排序一直使用实现&lt;strong&gt;Comparable&lt;/strong&gt;接口，一段时间后操作的时候居然发现有了个&lt;strong&gt;Comparator&lt;/strong&gt;接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上网差了些资料，总结笔记一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基本原理就是比较，底层是&lt;strong&gt;二叉树&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如是3,6,5,1,7,4,9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;排序的时候先放入3,之后6比3大，烦恼如3右边，5比6小，放左边，一次类推就是线面这图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1158451/201809/1158451-20180916233537137-2024178139.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首先看一下Comparable的接口定义&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; java.lang;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Comparable&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(T o);
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Comparable对实现它的每个类的对象进行整体排序。这个接口需要类本身去实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实例分析&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.list.customsort;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSort {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;Person&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;fd&quot;,20&lt;span&gt;));
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;chy&quot;,22&lt;span&gt;));
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;wgj&quot;,21&lt;span&gt;));
        System.out.println(list);
        Collections.sort(list);
        System.out.println(list);
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt; Comparable&amp;lt;Person&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String name, Integer age) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(Integer age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;&lt;span&gt;;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(Person o) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        return this.getAge().compareTo(o.getAge());&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getName().compareTo(o.getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按姓名进行正序排序。abc&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;是根据person的name属性进行排序  结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1158451/201809/1158451-20180916221807435-1222599198.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不使用Collections.sort()方法的话，可以直接使用treeSet集合进行操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Set&amp;lt;Person&amp;gt; set = &lt;span&gt;new&lt;/span&gt; TreeSet&amp;lt;&amp;gt;&lt;span&gt;();
        set.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;fd&quot;,20&lt;span&gt;));
        set.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;chy&quot;,22&lt;span&gt;));
        set.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;wgj&quot;,21&lt;span&gt;));
        System.out.println(set);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果跟上面时一模一样的也是根据name来实现了排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么呢，查看treeset源码会发现走还是compareto方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1158451/201809/1158451-20180916222823115-1533740439.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1158451/201809/1158451-20180916223021341-666238549.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1158451/201809/1158451-20180916223041784-598493400.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以使用Collections.sort(list) 跟直接new TreeSet是一样的效果。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Comparator&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Comparator是比较接口，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)，那么我们就可以建立一个“该类的比较器”来进行排序，这个“比较器”只需要实现Comparator接口即可。也就是说，我们可以通过实现Comparator来新建一个比较器，然后通过这个比较器对类进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接口定义&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; java.util;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Comparator&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(T o1, T o2);
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj);
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;代码实例分析&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.list.customsort;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Comparator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.TreeSet;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSort2 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;Person2&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person2(&quot;fd&quot;,20&lt;span&gt;));
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person2(&quot;chy&quot;,22&lt;span&gt;));
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person2(&quot;wgj&quot;,21&lt;span&gt;));
        System.out.println(list);
        Collections.sort(list,&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Comparator&amp;lt;Person2&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Person2 o1, Person2 o2) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o1.getAge().compareTo(o2.getAge());
            }
        });
        System.out.println(list);
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person2{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(Integer age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person2(String name, Integer age) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Person2 [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;&lt;span&gt;;
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;main方法的sort方法可以使用lambda来进行简化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（public static &amp;lt;T&amp;gt; void sort(List&amp;lt;T&amp;gt; list, Comparator&amp;lt;? super T&amp;gt; c) ）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Collections.sort(list,(s1,s2)-&amp;gt; Integer.compare(s1.getAge(),s2.getAge()));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这个时候使用treeset集合的话就没效果了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为它底层使用的是compareTo方法。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Comparable和Comparator区别比较&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 16 Sep 2018 15:39:00 +0000</pubDate>
<dc:creator>陈灬大灬海</dc:creator>
<og:description>平时进行自定义排序一直使用实现Comparable接口，一段时间后操作的时候居然发现有了个Comparator接口 上网差了些资料，总结笔记一下。 基本原理就是比较，底层是二叉树 比如是3,6,5,1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c-h-y/p/9658261.html</dc:identifier>
</item>
<item>
<title>AOP从静态代理到动态代理 Emit实现 - 7tiny</title>
<link>http://www.cnblogs.com/7tiny/p/9657451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/7tiny/p/9657451.html</guid>
<description>&lt;h2&gt;【前言】&lt;/h2&gt;
&lt;p&gt;　　AOP为Aspect Oriented Programming的缩写，意思是面向切面编程的技术。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;何为切面？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一个和业务没有任何耦合相关的代码段，诸如：调用日志，发送邮件，甚至路由分发。一切能为代码所有且能和代码充分解耦的代码都可以作为一个业务代码的切面。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;我们为什么要AOP？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　那我们从一个场景举例说起：&lt;/p&gt;
&lt;p&gt;　　如果想要采集用户操作行为，我们需要掌握用户调用的每一个接口的信息。这时候的我们要怎么做?&lt;/p&gt;
&lt;p&gt;　　如果不采用AOP技术，也是最简单的，所有方法体第一句话先调用一个日志接口将方法信息传递记录。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;有何问题？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　实现业务没有任何问题，但是随之而来的是代码臃肿不堪，难以调整维护的诸多问题（可自行脑补）。&lt;/p&gt;
&lt;p&gt;　　如果我们采用了AOP技术，我们就可以在系统启动的地方将所有将要采集日志的类注入，每一次调用方法前，AOP框架会自动调用我们的日志代码。&lt;/p&gt;
&lt;p&gt;　　是不是省去了很多重复无用的劳动？代码也将变得非常好维护（有朝一日不需要了，只需将切面代码注释掉即可）&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;接下来我们看看AOP框架的工作原理以及实过程。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;【实现思路】&lt;/h2&gt;
&lt;p&gt;　　AOP框架呢，一般通过静态代理和动态代理两种实现方式。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916193617813-735810735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　何为静态代理？ &lt;/h4&gt;
&lt;p&gt;　　静态代理，又叫编译时代理，就是在编译的时候，已经存在代理类，运行时直接调用的方式。说的通俗一点，就是自己手动写代码实现代理类的方式。&lt;/p&gt;
&lt;p&gt;　　我们通过一个例子来展现一下静态代理的实现过程：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;我们这里有一个业务类，里面有方法Test()，我们要在Test调用前和调用后分别输出日志。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916194836292-73630614.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们既然要将Log当作一个切面，我们肯定不能去动原有的业务代码，那样也违反了面向对象设计之开闭原则。&lt;/p&gt;
&lt;p&gt;　　那么我们要怎么做呢？我们定义一个新类 &lt;strong&gt;BusinessProxy&lt;/strong&gt; 去包装一下这个类。为了便于在多个方法的时候区分和辨认，方法也叫 &lt;strong&gt;Test（）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916200524778-1251580494.png&quot; alt=&quot;&quot; width=&quot;924&quot; height=&quot;146&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这样，我们如果要在所有的Business类中的方法都添加Log，我们就在BusinessProxy代理类中添加对应的方法去包装。既不破坏原有逻辑，又可以实现前后日志的功能。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;当然，我们可以有更优雅的实现方式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916200828858-119861194.png&quot; alt=&quot;&quot; width=&quot;979&quot; height=&quot;144&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们可以定义代理类，继承自业务类。将业务类中的方法定义为虚方法。那么我们可以重写父类的方法并且在加入日志以后再调用父类的原方法。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;当然，我们还有更加优雅的实现方式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916203240962-1888175636.png&quot; alt=&quot;&quot; width=&quot;869&quot; height=&quot;141&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们可以使用发射的技术，写一个通用的Invoke方法，所有的方法都可以通过该方法调用。&lt;/p&gt;
&lt;p&gt;　　我们这样便实现了一个静态代理。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;那我们既然有了静态代理，为什么又要有动态代理呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们仔细回顾静态代理的实现过程。我们要在所有的方法中添加切面，我们就要在代理类中重写所有的业务方法。更有甚者，我们有N个业务类，就要定义N个代理类。这是很庞大的工作量。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916201847593-668123609.png&quot; alt=&quot;&quot; width=&quot;907&quot; height=&quot;408&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这就是动态代理出现的背景，相比都可以猜得到，动态代理就是将这一系列繁琐的步骤自动化，让程序自动为我们生成代理类。&lt;/p&gt;
&lt;h4&gt;　　何为动态代理？&lt;/h4&gt;
&lt;p&gt;　　动态代理，又成为运行时代理。在程序运行的过程中，调用了生成代理类的代码，将自动生成业务类的代理类。不需要我们手共编写，极高的提高了工作效率和&lt;strong&gt;&lt;span&gt;调整了程序员的心态&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　原理不必多说，就是动态生成静态代理的代码。我们要做的，就是选用一种生成代码的方式去生成。&lt;/p&gt;
&lt;p&gt;　　今天我分享一个简单的AOP框架，代码使用Emit生成。当然，Emit 代码的写法不是今天要讲的主要内容，需要提前去学习。&lt;/p&gt;
&lt;p&gt;　　先说效果：&lt;/p&gt;
&lt;p&gt;　　定义一个Action特性类 &lt;strong&gt;&lt;span&gt;ActionAttribute &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;继承自&lt;/span&gt; ActionBaseAttribute&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，里面在Before和After方法中输出两条日志；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916221625350-114694590.png&quot; alt=&quot;&quot; width=&quot;756&quot; height=&quot;256&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　定义一个Action特性类 &lt;strong&gt;&lt;span&gt;InterceptorAttribute&lt;/span&gt;&lt;/strong&gt; 继承自 &lt;strong&gt;&lt;span&gt;InterceptorBaseAttribute&lt;/span&gt;&lt;/strong&gt;，里面捕获了方法调用异常，以及执行前后分别输出日志；&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916221743492-596476989.png&quot; alt=&quot;&quot; width=&quot;802&quot; height=&quot;414&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后定义一个业务类 &lt;strong&gt;&lt;span&gt;BusinessClass&lt;/span&gt;&lt;/strong&gt; 实现了 &lt;strong&gt;&lt;span&gt;IBusinessClass&lt;/span&gt;&lt;/strong&gt; 接口，定义了各种类型的方法&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916222454627-753994470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916222547445-1674102958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　多余的方法不贴图了。&lt;/p&gt;
&lt;p&gt;　　我们把上面定义的方法调用切面标签放在业务类上，表示该类下所有的方法都执行异常过滤；&lt;/p&gt;
&lt;p&gt;　　我们把Action特性放在Test方法上，表明要在 Test（） 方法的 Before 和 After 调用时记录日志；&lt;/p&gt;
&lt;p&gt;　　我们定义测试类：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916222926610-995776134.png&quot; alt=&quot;&quot; width=&quot;813&quot; height=&quot;495&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　调用一下试试：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916223118774-754669069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可见，全类方法标签 &lt;strong&gt;&lt;span&gt;Interceptor&lt;/span&gt;&lt;/strong&gt; 在 &lt;strong&gt;&lt;span&gt;Test&lt;/span&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;span&gt;GetInt&lt;/span&gt;&lt;/strong&gt; 方法调用前后都打出了对应的日志；&lt;/p&gt;
&lt;p&gt;　　Action方法标签只在 &lt;strong&gt;&lt;span&gt;Test&lt;/span&gt;&lt;/strong&gt; 方法上做了标记，那么&lt;strong&gt;&lt;span&gt;Test &lt;/span&gt;&lt;/strong&gt;方法 &lt;strong&gt;&lt;span&gt;Before&lt;/span&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;span&gt;After&lt;/span&gt;&lt;/strong&gt; 执行时打出了日志；&lt;/p&gt;
&lt;h2&gt;【实现过程】&lt;/h2&gt;
&lt;p&gt;　　实现的思路在上面已经有详细的讲解，可以参考静态代理的实现思路。&lt;/p&gt;
&lt;p&gt;　　我们定义一个动态代理生成类 &lt;strong&gt;&lt;span&gt;DynamicProxy&lt;/span&gt;&lt;/strong&gt;，用于原业务代码的扫描和代理类代码的生成；&lt;/p&gt;
&lt;p&gt;　　定义两个过滤器标签，&lt;strong&gt;&lt;span&gt;ActionBaseAttribute&lt;/span&gt;&lt;/strong&gt;，提供 &lt;span&gt;&lt;strong&gt;Before &lt;/strong&gt;&lt;/span&gt;和 &lt;span&gt;&lt;strong&gt;After &lt;/strong&gt;&lt;/span&gt;切面方法；&lt;strong&gt;&lt;span&gt;InterceptorBaseAttribute&lt;/span&gt;&lt;/strong&gt;，提供 &lt;span&gt;&lt;strong&gt;Invoke&lt;/strong&gt;&lt;/span&gt; “全调用”包装的切面方法；&lt;/p&gt;
&lt;p&gt;　　Before可以获取到当前调用的方法和参数列表，After可以获取到当前方法调用以后的结果。&lt;/p&gt;
&lt;p&gt;　　Invoke 可以拿到当前调用的对象和方法名，参数列表。在这里进行反射动态调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple = &lt;span&gt;false&lt;/span&gt;, Inherited = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ActionBaseAttribute : Attribute
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Before(&lt;span&gt;string&lt;/span&gt; @method, &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] parameters) { }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; After(&lt;span&gt;string&lt;/span&gt; @method, &lt;span&gt;object&lt;/span&gt; result) { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result; }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [AttributeUsage(AttributeTargets.Class, AllowMultiple = &lt;span&gt;false&lt;/span&gt;, Inherited = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterceptorBaseAttribute : Attribute
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Invoke(&lt;span&gt;object&lt;/span&gt; @object, &lt;span&gt;string&lt;/span&gt; @method, &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] parameters)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; @object.GetType().GetMethod(@method).Invoke(@object, parameters);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　代理生成类采用Emit的方式生成运行时IL代码。&lt;/p&gt;
&lt;p&gt;　　先把代码放在这里：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('56e97627-2ee2-4ce2-8b25-d40886a82457')&quot; readability=&quot;66&quot;&gt;&lt;img id=&quot;code_img_closed_56e97627-2ee2-4ce2-8b25-d40886a82457&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_56e97627-2ee2-4ce2-8b25-d40886a82457&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('56e97627-2ee2-4ce2-8b25-d40886a82457',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_56e97627-2ee2-4ce2-8b25-d40886a82457&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;127&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DynamicProxy
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; TInterface CreateProxyOfRealize&amp;lt;TInterface, TImp&amp;gt;() &lt;span&gt;where&lt;/span&gt; TImp : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;() &lt;span&gt;where&lt;/span&gt; TInterface : &lt;span&gt;class&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Invoke&amp;lt;TInterface, TImp&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; TProxyClass CreateProxyOfInherit&amp;lt;TProxyClass&amp;gt;() &lt;span&gt;where&lt;/span&gt; TProxyClass : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Invoke&amp;lt;TProxyClass, TProxyClass&amp;gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; TInterface Invoke&amp;lt;TInterface, TImp&amp;gt;(&lt;span&gt;bool&lt;/span&gt; inheritMode = &lt;span&gt;false&lt;/span&gt;) &lt;span&gt;where&lt;/span&gt; TImp : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;() &lt;span&gt;where&lt;/span&gt; TInterface : &lt;span&gt;class&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; impType = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TImp);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; nameOfAssembly = impType.Name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProxyAssembly&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; nameOfModule = impType.Name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProxyModule&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; nameOfType = impType.Name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Proxy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; assemblyName = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AssemblyName(nameOfAssembly);
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; assembly =&lt;span&gt; AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; moduleBuilder =&lt;span&gt; assembly.DefineDynamicModule(nameOfModule);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var moduleBuilder = assembly.DefineDynamicModule(nameOfModule, nameOfAssembly + &quot;.dll&quot;);&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;            TypeBuilder typeBuilder;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (inheritMode)
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;                 typeBuilder =&lt;span&gt; moduleBuilder.DefineType(nameOfType, TypeAttributes.Public, impType);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;                 typeBuilder = moduleBuilder.DefineType(nameOfType, TypeAttributes.Public, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TInterface) });
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;             InjectInterceptor&amp;lt;TImp&amp;gt;(typeBuilder, impType.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;(InterceptorBaseAttribute))?&lt;span&gt;.GetType(), inheritMode);
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; t =&lt;span&gt; typeBuilder.CreateType();
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;assembly.Save(nameOfAssembly + &quot;.dll&quot;);&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Activator.CreateInstance(t) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; TInterface;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; InjectInterceptor&amp;lt;TImp&amp;gt;(TypeBuilder typeBuilder, Type interceptorAttributeType, &lt;span&gt;bool&lt;/span&gt; inheritMode = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; impType = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TImp);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ---- define fields ----&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;             FieldBuilder fieldInterceptor = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (interceptorAttributeType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                 fieldInterceptor = typeBuilder.DefineField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_interceptor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, interceptorAttributeType, FieldAttributes.Private);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ---- define costructors ----&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (interceptorAttributeType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; constructorBuilder = typeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ilOfCtor =&lt;span&gt; constructorBuilder.GetILGenerator();
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;                ilOfCtor.Emit(OpCodes.Ldarg_0);
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                 ilOfCtor.Emit(OpCodes.Newobj, interceptorAttributeType.GetConstructor(&lt;span&gt;new&lt;/span&gt; Type[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;                ilOfCtor.Emit(OpCodes.Stfld, fieldInterceptor);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;                ilOfCtor.Emit(OpCodes.Ret);
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ---- define methods ----&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; methodsOfType = impType.GetMethods(BindingFlags.Public |&lt;span&gt; BindingFlags.Instance);
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt;[] ignoreMethodName = &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ToString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetHashCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Equals&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; method &lt;span&gt;in&lt;/span&gt;&lt;span&gt; methodsOfType)
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ignore method&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ignoreMethodName.Contains(method.Name))
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; methodParameterTypes = method.GetParameters().Select(p =&amp;gt;&lt;span&gt; p.ParameterType).ToArray();
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;                MethodAttributes methodAttributes;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (inheritMode)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                     methodAttributes = MethodAttributes.Public |&lt;span&gt; MethodAttributes.Virtual;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;                     methodAttributes = MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Virtual |&lt;span&gt; MethodAttributes.Final;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; 
&lt;span&gt; 86&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; methodBuilder =&lt;span&gt; typeBuilder.DefineMethod(method.Name, methodAttributes, CallingConventions.Standard, method.ReturnType, methodParameterTypes);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ilMethod =&lt;span&gt; methodBuilder.GetILGenerator();
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; set local field&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; impObj = ilMethod.DeclareLocal(impType);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;instance of imp object&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; methodName = ilMethod.DeclareLocal(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;));     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;instance of method name&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; parameters = ilMethod.DeclareLocal(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;object&lt;/span&gt;[]));   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;instance of parameters&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; result = ilMethod.DeclareLocal(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;object&lt;/span&gt;));         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;instance of result&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;                 LocalBuilder actionAttributeObj = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;attribute init&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;                 Type actionAttributeType = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (method.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;(ActionBaseAttribute)) != &lt;span&gt;null&lt;/span&gt; || impType.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;(ActionBaseAttribute)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;method can override class attrubute&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (method.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;(ActionBaseAttribute)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                         actionAttributeType = method.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ActionBaseAttribute)).GetType();
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (impType.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;(ActionBaseAttribute)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;                         actionAttributeType = impType.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ActionBaseAttribute)).GetType();
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;                     actionAttributeObj =&lt;span&gt; ilMethod.DeclareLocal(actionAttributeType);
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                     ilMethod.Emit(OpCodes.Newobj, actionAttributeType.GetConstructor(&lt;span&gt;new&lt;/span&gt; Type[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Stloc, actionAttributeObj);
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;instance imp&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt;                 ilMethod.Emit(OpCodes.Newobj, impType.GetConstructor(&lt;span&gt;new&lt;/span&gt; Type[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;                ilMethod.Emit(OpCodes.Stloc, impObj);
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; 
&lt;span&gt;120&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if no attribute&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (fieldInterceptor != &lt;span&gt;null&lt;/span&gt; || actionAttributeObj != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldstr, method.Name);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Stloc, methodName);
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldc_I4, methodParameterTypes.Length);
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;                     ilMethod.Emit(OpCodes.Newarr, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Stloc, parameters);
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; 
&lt;span&gt;130&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; build the method parameters&lt;/span&gt;
&lt;span&gt;131&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; methodParameterTypes.Length; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;                        ilMethod.Emit(OpCodes.Ldloc, parameters);
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;                        ilMethod.Emit(OpCodes.Ldc_I4, j);
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                         ilMethod.Emit(OpCodes.Ldarg, j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;box&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt; &lt;span&gt;                        ilMethod.Emit(OpCodes.Box, methodParameterTypes[j]);
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;                        ilMethod.Emit(OpCodes.Stelem_Ref);
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; 
&lt;span&gt;142&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;dynamic proxy action before&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (actionAttributeType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;load arguments&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, actionAttributeObj);
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, methodName);
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, parameters);
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;                     ilMethod.Emit(OpCodes.Call, actionAttributeType.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Before&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (interceptorAttributeType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;load arguments&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt;                     ilMethod.Emit(OpCodes.Ldarg_0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;
&lt;span&gt;156&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldfld, fieldInterceptor);
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, impObj);
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, methodName);
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, parameters);
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; call Invoke() method of Interceptor&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt;                     ilMethod.Emit(OpCodes.Callvirt, interceptorAttributeType.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invoke&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;164&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;direct call method&lt;/span&gt;
&lt;span&gt;166&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (method.ReturnType == &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;void&lt;/span&gt;) &amp;amp;&amp;amp; actionAttributeType == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;                        ilMethod.Emit(OpCodes.Ldnull);
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; 
&lt;span&gt;171&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, impObj);
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; methodParameterTypes.Length; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;                         ilMethod.Emit(OpCodes.Ldarg, j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Callvirt, impType.GetMethod(method.Name));
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;box&lt;/span&gt;
&lt;span&gt;178&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (actionAttributeType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (method.ReturnType != &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; &lt;span&gt;                            ilMethod.Emit(OpCodes.Box, method.ReturnType);
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt; &lt;span&gt;                            ilMethod.Emit(OpCodes.Ldnull);
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; 
&lt;span&gt;187&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;dynamic proxy action after&lt;/span&gt;
&lt;span&gt;188&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (actionAttributeType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Stloc, result);
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;load arguments&lt;/span&gt;
&lt;span&gt;192&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, actionAttributeObj);
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, methodName);
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, result);
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;                     ilMethod.Emit(OpCodes.Call, actionAttributeType.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;After&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; 
&lt;span&gt;198&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pop the stack if return void&lt;/span&gt;
&lt;span&gt;199&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (method.ReturnType == &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Pop);
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;204&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;unbox,if direct invoke,no box&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (fieldInterceptor != &lt;span&gt;null&lt;/span&gt; || actionAttributeObj != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.ReturnType.IsValueType)
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;                            ilMethod.Emit(OpCodes.Unbox_Any, method.ReturnType);
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;211&lt;/span&gt; &lt;span&gt;                            ilMethod.Emit(OpCodes.Castclass, method.ReturnType);
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; complete&lt;/span&gt;
&lt;span&gt;215&lt;/span&gt; &lt;span&gt;                ilMethod.Emit(OpCodes.Ret);
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;DynamicProxy&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　里面实现了两种代理方式，一种是 &lt;strong&gt;&lt;span&gt;面向接口实现&lt;/span&gt;&lt;/strong&gt; 的方式，另一种是 &lt;strong&gt;&lt;span&gt;继承重写&lt;/span&gt;&lt;/strong&gt; 的方式。&lt;/p&gt;
&lt;p&gt;　　但是继承重写的方式需要把业务类的所有方法写成virtual虚方法，动态类会重写该方法。&lt;/p&gt;
&lt;p&gt;　　我们从上一节的Demo中获取到运行时生成的代理类dll，用ILSpy反编译查看源代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916223720818-1841024126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，我们的代理类分别调用了我们特性标签中的各项方法。&lt;/p&gt;
&lt;h4&gt;　　核心代码分析（源代码在上面折叠部位已经贴出）：&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916223920601-1625855177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　解释：如果该方法存在Action标签，那么加载 action 标签实例化对象，加载参数，执行Before方法；如果该方法存在Interceptor标签，那么使用类字段this._interceptor调用该标签的Invoke方法。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916224137586-485542959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　解释：如果面的Interceptor特性标签不存在，那么会加载当前扫描的方法对应的参数，直接调用方法；如果Action标签存在，则将刚才调用的结果包装成object对象传递到After方法中。&lt;/p&gt;
&lt;p&gt;　　这里如果目标参数是object类型，而实际参数是直接调用返回的明确的值类型，需要进行装箱操作，否则运行时报调用内存错误异常。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916224453688-1921510276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　解释：如果返回值是void类型，则直接结束并返回结果；如果返回值是值类型，则需要手动拆箱操作，如果是引用类型，那么需要类型转换操作。&lt;/p&gt;
&lt;p&gt;　　IL实现的细节，这里不做重点讨论。&lt;/p&gt;
&lt;h2&gt;【系统测试】&lt;/h2&gt;
&lt;h4&gt; 　　1.接口实现方式，Api测试（各种标签使用方式对应的不同类型的方法调用）：&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916224807922-881794360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论：对于上述穷举的类型，各种标签使用方式皆成功打出了日志；&lt;/p&gt;
&lt;h4&gt;　　2.继承方式，Api测试（各种标签使用方式对应的不同类型的方法调用）：&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916225030627-152889864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论：继承方式和接口实现方式的效果是一样的，只是方法上需要不同的实现调整；&lt;/p&gt;
&lt;h4&gt;　　3.直接调用三个方法百万次性能结果：&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916225119697-1659768917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论：直接调用三个方法百万次调用耗时 58ms&lt;/p&gt;
&lt;h4&gt;　　4.使用实现接口方式三个方法百万次调用结果&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916225300673-759343359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论：结果见上图，需要注意是三个方法百万次调用，也就是300w次的方法调用&lt;/p&gt;
&lt;h4&gt;　　5.使用继承方式三个方法百万次调用结果&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916225341394-675024693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论：结果见上图，需要注意是三个方法百万次调用，也就是300w次的方法调用&lt;/p&gt;
&lt;p&gt;　　事实证明，IL Emit的实现方式性能还是很高的。&lt;/p&gt;
&lt;h4&gt;　　综合分析：&lt;/h4&gt;
&lt;p&gt;　　通过各种的调用分析，可以看出使用代理以后和原生方法调用相比性能损耗在哪里。性能差距最大的，也是耗时最多的实现方式就是添加了全类方法代理而且是使用Invoke进行全方法切面方式。该方式耗时的原因是使用了反射Invoke的方法。&lt;/p&gt;
&lt;p&gt;　　直接添加Action代理类实现 Before和After的方式和原生差距不大，主要损耗在After触发时的拆装箱上。&lt;/p&gt;
&lt;p&gt;　　综上分析，我们使用的时候，尽量针对性地对某一个方法进行AOP注入，而尽量不要全类方法进行AOP注入。&lt;/p&gt;
&lt;h2&gt;【总结】&lt;/h2&gt;
&lt;p&gt;　　通过自己实现一个AOP的动态注入框架，对Emit有了更加深入的了解，最重要的是，对CLR IL代码的执行过程有了一定的认知，受益匪浅。&lt;/p&gt;
&lt;p&gt;　　该方法在使用的过程中也发现了问题，比如有ref和out类型的参数时，会出现问题，需要后续继续改进&lt;/p&gt;
&lt;p&gt;　　本文的源代码已托管在GitHub上，又需要可以自行拿取（顺手Star哦~）：&lt;a href=&quot;https://github.com/sevenTiny/CodeArts&quot; target=&quot;_blank&quot;&gt;https://github.com/sevenTiny/CodeArts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　该代码的位置在 CodeArts.CSharp 分区下&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916230322670-1176024942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　VS打开后，可以在 EmitDynamicProxy 分区下找到；本博客所有的测试项目都在项目中可以找到。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916230439074-730727376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再次放上源代码地址，供一起学习的朋友参考，希望能帮助到你：&lt;a href=&quot;https://github.com/sevenTiny/CodeArts&quot; target=&quot;_blank&quot;&gt;https://github.com/sevenTiny/CodeArts&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 16 Sep 2018 15:22:00 +0000</pubDate>
<dc:creator>7tiny</dc:creator>
<og:description>【前言】 AOP为Aspect Oriented Programming的缩写，意思是面向切面编程的技术。 何为切面？ 一个和业务没有任何耦合相关的代码段，诸如：调用日志，发送邮件，甚至路由分发。一切</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/7tiny/p/9657451.html</dc:identifier>
</item>
<item>
<title>前后端分离与前后端不分离的区别 - skaarl</title>
<link>http://www.cnblogs.com/skaarl/p/9658114.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skaarl/p/9658114.html</guid>
<description>
&lt;p&gt;&lt;span&gt;前后端不分离&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      在前后端不分离的应用模式中，前端页面看到的效果都是由后端控制，由后端渲染页面或重定向，也就是后端需要控制前端的展示，前端与后端的耦合度很高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        这种应用模式比较适合纯网页应用，但是当后端对接App时，App可能并不需要后端返回一个HTML网页，而仅仅是数据本身，所以后端原本返回网页的接口不再&lt;img id=&quot;uploading_image_96603&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;适用于前端App应用，为了对接App后端还需再开发一套接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请求的数据交互如下图:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1394466/201809/1394466-20180916231510365-285933655.png&quot; alt=&quot;&quot; width=&quot;554&quot; height=&quot;282&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前后端分离&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      在前后端分离的应用模式中，后端仅返回前端所需的数据，不再渲染HTML页面，不再控制前端的效果。至于前端用户看到什么效果，从后端请求的数据如何加载到前端中，都由前端自己决定，网页有网页的处理方式，App有App的处理方式，但无论哪种前端，所需的数据基本相同，后端仅需开发一套逻辑对外提供数据即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在前后端分离的应用模式中 ，前端与后端的耦合度相对较低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在前后端分离的应用模式中，我们通常将后端开发的每个视图都称为一个接口，或者API，前端通过访问接口来对数据进行增删改查。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对应的数据交互如下图 :&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1394466/201809/1394466-20180916231716242-1862208927.png&quot; alt=&quot;&quot; width=&quot;514&quot; height=&quot;329&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 16 Sep 2018 15:20:00 +0000</pubDate>
<dc:creator>skaarl</dc:creator>
<og:description>前后端不分离 在前后端不分离的应用模式中，前端页面看到的效果都是由后端控制，由后端渲染页面或重定向，也就是后端需要控制前端的展示，前端与后端的耦合度很高。 这种应用模式比较适合纯网页应用，但是当后端对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skaarl/p/9658114.html</dc:identifier>
</item>
</channel>
</rss>