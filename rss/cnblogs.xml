<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Azure 基础：使用 Traffic Manager 分流用户请求 - sparkdev</title>
<link>http://www.cnblogs.com/sparkdev/p/8017001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sparkdev/p/8017001.html</guid>
<description>&lt;p&gt;&lt;span&gt;为了减少 web 服务器的宕机时间，同时也提高服务器的响应性能，我们往往部署多个站点并通过负载均衡来对外提供服务。Azure 提供的 Traffic Manager 服务属于负载均衡的一种，特点是工作在 DNS 层，因此具有配置简单的优势。本文将通过一个 demo 演示如何通过 Traffic Manager 实现根据用户的地理位置来分流用户的请求。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;本质上讲 Traffic Manager 是 Azure 提供的 DNS 解析服务。它提供的核心能力有：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;提升响应能力(把请求路由到低延迟的节点)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;减少宕机时间(把请求路由到健康的节点)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Traffic Manager 会通过我们配置的规则把请求解析到响应延迟最低的节点上去，并同时监控节点的健康状况，如果发现某个节点出现健康问题就会把请求解析到其它健康的节点上。我们还可以通过更加灵活的配置来决定不同的节点可以响应不同数量的请求。或者是随时添加新的节点提升服务的响应能力。通过 Traffic Manager 这些功能都够轻松实现并且配置起来却很简单。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有了这样的能力我们不仅可以轻松的提示服务的响应性能还可以逐个的断开节点进行维护或升级，从而实现无宕机的 web 服务。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Traffic Manager 工作在 DNS 级别，这一点非常重要！&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在整个工作过程中，Traffic Manager 只负责告诉用户的 web 客户端：你访问的服务器在哪里。所以它没有代理的功能，也不参与用户与服务器的通信过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/952033/201712/952033-20171210150724661-1725559203.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上图中我们可以清晰的看到，用户的 web 客户端只是在进行 DNS 解析的时候通过 DNS 的 CNAME 找到 Traffic Manager，并由 Traffic Manager 根据你的配置完成最终的解析并返回 web 服务的 IP 地址。在这之后，用户的 web 客户端都是直接访问 web 服务器的，直到你设置的 TTL 超时，  web 客户端才会重新进行一次 DNS 解析。所以 Traffic Manager 不是代理或网关，它也看不到 web 客户端与服务器之间的数据传递。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当我们部署了多个 web 服务器时，如何设置策略让不同的用户访问到不同的 web 服务器上呢？当前 Traffic Manger 内置了四种路由策略：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Priority (主节点处理所有请求，次节点作为随时可用的备份存在)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Weighted (按照指定的权重分配流量)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Performance (按照最小延迟分配流量)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Geographic (按照地理位置分配流量)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Priority(基于优先级的路由策略)&lt;/strong&gt; 可按照优先级设置多个从节点(web 服务器)，当其中的某个或多个节点失效时，活着的节点中具有最高优先级者对外提供服务。这个策略主要用来提高服务的可用性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Weighted(基于权重的路由策略)&lt;/strong&gt; 可以为不同的节点(web 服务器)设置不同的权重。比如服务器1配置高、性能好，就可以设置比较高的权重，这样分配给它的请求就会多些(具体的多少是按照服务器的权重计算出来的)。当然如果其中有服务器离线了，Traffic Manager 就会把负载分配到其它的节点。因此我们也可以使用这种路由策略让服务器逐个的离线并进行升级从而实现渐进式的发布。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Performance(基于性能的路由策略)&lt;/strong&gt; 提升服务器的响应时间可谓是重中之重，这种策略会根据最小的网络延迟来路由用户的请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Geographic(基于地理位置的路由策略)&lt;/strong&gt; 对于全球化的服务，最好是在不同的地理位置上部署服务器以就近响应用户的请求。Traffic Manager 也支持这样的策略。本文中接下来的 demo 就将演示如何创建一个基于地理位置进行路由的 Traffic Manager 设置。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;假设我们有两台主机，一台在香港，另一台在新加坡。我们希望新加坡的用户访问的是放在新加坡的主机，香港的用户和全世界其它地方的用户访问的都是放在香港的主机。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;创建 Traffic Manager 配置文件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用 Traffic Manager 服务需要从创建 Traffic Manager 配置文件开始。在 Azure 的门户网站上新建一个 &quot;Traffic Manager profile&quot;(不太熟悉 Azure 的朋友可以先去申请创建一个免费的 Azure 账户)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/952033/201712/952033-20171210151031240-1959898724.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了填写合适的名称还要选择正确的路由策略，这里我们选择的 &quot;Geographic&quot; 表示基于地理位置的路由策略。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;添加 endpoint&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;所谓的 endpont 这里就是需要进行域名解析的主机或者是服务。本文的 demo 使用的是两台放在 Azure 上的虚拟主机。我们先添加放在新加坡的主机(请保证你已经创建了该主机，并且区域选的是 Southeast Asia，同时设置了主机的 DNS 名称)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/952033/201712/952033-20171210151121271-1010049390.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图中 webvm2-ip 其实是虚拟主机的 IP。另外在选择 Regional grouping 为 &quot;Asia&quot;，然后选择 Contry/Region 为 &quot;Sinqapore&quot;。此时 Regional grouping 中的 &quot;Asia&quot; 被清空了，看来是个 bug。但是这种情况并不影响保存。这个问题存在挺长时间了，难道是个 feature ？？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照相同的方式我们再添加一个位于香港的节点，由于香港的主机会被除了新加坡之外的其它所有地区的用户访问，所以在 Geo-mapping 中设置为 &quot;All(World)&quot; 就可以了(Azure 的 Traffic Manager 服务会保证用户的请求会被解析到正确的节点)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/952033/201712/952033-20171210151203630-2051270099.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;监控节点健康状况&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;当我们完成节点的添加后，Traffic Manager 会监控节点的健康状况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/952033/201712/952033-20171210151324568-1905394113.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;Degraded&quot; 说明当前监控到的节点有问题，所以我们需要调整一下相关的配置。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;打开 Traffic Manager 中的 &quot;Configuration&quot; 界面，把 &quot;Endpoint monitor settings&quot; 中的 Protocol 改为 TCP，端口改成 22，并清空 Path 中的内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/952033/201712/952033-20171210151353896-636980968.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因是默认的配置中通过 http 协议和 80 端口监控服务器的健康状况，但是笔者并没有在两个节点上运行 web 服务。改成 TCP 协议和 22 号端口(demo 中的两台虚拟主机运行的是 linux，并且都监听了 22 号端口)就可以了。修改配置后，节点的状态马上就变成 &quot;Online&quot; 了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/952033/201712/952033-20171210151419286-536404837.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;Online&quot; 说明节点处于健康的，可以稳定提供服务的状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对节点监控是非常重要的，Traffic Manager 就是依靠健康监控来实现自动故障转移的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;完成 Traffic Manager 配置的最后一步是在 DNS 解析中配置域名的 CNAME。笔者在 GoDaddy 购买了域名 filterinto.com，现在我们就给它添加一个 CNAME 并指向前面创建的 Traffic Manager 服务：demox.traffimanager.net：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/952033/201712/952033-20171210151528708-1015432515.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;保存上面的配置就可以了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接下来该测试我们的配置是否达到了目的。重新说明一下我们预定的目标：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;新加坡的用户访问的是放在新加坡的主机&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;香港的用户和全世界其它地方的用户访问的都是放在香港的主机&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;先登录到一台放置在新加坡的虚拟机(使用云服务的好处是你可以在全世界的任何区域随意的创建虚拟主机！)，然后执行 dig 命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ dig demo.filterinto.com +noall +answer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/952033/201712/952033-20171210151646677-1891926334.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是我们希望新加坡的用户访问到的主机，它的 IP 地址为：52.230.11.28。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来直接在本地(哥们儿是天朝子民)执行相同的 dig 命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ dig demo.filterinto.com +noall +answer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/952033/201712/952033-20171210151726255-1289754468.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实你只要在新加坡之外的其它地方执行这个命令，解析到的主机 IP 地址都是：52.229.175.83。到这里我们可以证明 Traffic Manager 已经能够正常工作了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;注意，IP 地址与国家和区域的关系是由专门的机构管理的，我们基本不需要怀疑其正确性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从 dig 命令的输出中我们也可以看到 DNS 的解析过程为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;demo.filterinto.com
demox.trafficmanager.net             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们创建的 Traffic Manager 服务&lt;/span&gt;
eagle.eastasia.cloudapp.azure.com    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Azure 提供的主机域名&lt;/span&gt;
&lt;span&gt;52.229&lt;/span&gt;.&lt;span&gt;175.83&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中第二三两行的解析都是由 Azure 完成的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;负载均衡可以在不同的层级以不同的技术实现，本文介绍的 Traffic Manager 就是在 DNS 层&lt;span&gt;的一种&lt;/span&gt;实现。本文选择尽可能简单的 demo 只是为了说明 Traffic Manager 是什么、能够做什么。如果要把它应用到生产中则需要考察并测试更多的细节，具体请参考 Azure 的官方文档。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 Dec 2017 23:54:00 +0000</pubDate>
<dc:creator>sparkdev</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sparkdev/p/8017001.html</dc:identifier>
</item>
<item>
<title>验证 Swarm 数据持久性 - 每天5分钟玩转 Docker 容器技术（104） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8016994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8016994.html</guid>
<description>&lt;p&gt;上一节我们成功将 Rex-Ray Volume 挂载到了 Service。本节验证 Failover 时，数据不会丢失。&lt;/p&gt;
&lt;h6&gt;&lt;span&gt;&lt;strong&gt;Scale Up&lt;/strong&gt;&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;增加一个副本：&lt;/p&gt;
&lt;pre&gt;
docker service update --replicas 2 my_web
&lt;/pre&gt;
&lt;p&gt;运行之前我们先推测一下，理想的结果应该是：swarm 在&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;swarm-worker2&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;上启动第二个副本，同时也将挂载 volume&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;my_web&lt;/span&gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对比一下实际的运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;535.png&quot; src=&quot;https://i.imgsafe.org/cd/cdf3aa3b42.png&quot; alt=&quot;535.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现了一点复杂的状况：&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;swarm 首先尝试在&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;swarm-worker2&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;上启动第二个副本，但在 mount volume 失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;重试了三次都失败了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最后在&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;swarm-worker1&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;成功启动第二个副本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;mount 失败的原因是：以 VirtualBox 为 backend 的 Rex-Ray volume 不支持同时 attach 到多个 Host。&lt;/p&gt;
&lt;p&gt;需要注意：这实际上是 VirtualBox 的限制，而非 Rex-Ray。如果 backend 选择 Ceph RBD 就没有这个问题。&lt;/p&gt;
&lt;h6&gt;&lt;span&gt;&lt;strong&gt;更新 Volume&lt;/strong&gt;&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;更新 volume 的内容。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;536.png&quot; src=&quot;https://i.imgsafe.org/cd/cde1f47a5b.png&quot; alt=&quot;536.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;service 返回更新内容，数据已经同步到副本。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;540.png&quot; src=&quot;https://i.imgsafe.org/cd/cde22839a4.png&quot; alt=&quot;540.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前的实验环境如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;538.png&quot; src=&quot;https://i.imgsafe.org/cd/cde22ae947.png&quot; alt=&quot;538.png&quot;/&gt;&lt;/p&gt;
&lt;h6&gt;&lt;span&gt;&lt;strong&gt;Failover&lt;/strong&gt;&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;现在模拟故障情况。shutdown 节点&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;swarm-worker1&lt;/span&gt;&lt;/code&gt;，过一会，所有副本都会迁移到&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;swarm-worker2&lt;/span&gt;&lt;/code&gt;。&lt;/p&gt;
&lt;div&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;539.png&quot; src=&quot;https://i.imgsafe.org/cd/cde2178e11.png&quot; alt=&quot;539.png&quot;/&gt;&lt;/div&gt;

&lt;p&gt;访问 service，以前更新的内容完整地保留了下来。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;540.png&quot; src=&quot;https://i.imgsafe.org/cd/cde22839a4.png&quot; alt=&quot;540.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前的实验环境如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;541.png&quot; src=&quot;https://i.imgsafe.org/cd/cde2471dbd.png&quot; alt=&quot;541.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Rex-Ray 作为 Swarm 的存储编排方案能够很好地支持跨主机 volume 管理，而且当容器在集群中迁移时 volume 也能够自动迁移。&lt;/p&gt;
&lt;p&gt;Swarm 数据管理就讨论到这里，下一节我们学习 Service 的 Replicated Mode 和 Global Mode。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/Users/wanglei/百度云同步盘/容器/images/480.png?v=1510821977521&quot; alt=&quot;&quot;/&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 Dec 2017 23:15:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8016994.html</dc:identifier>
</item>
<item>
<title>Java集合（2）一 ArrayList 与 LinkList - knock_小新</title>
<link>http://www.cnblogs.com/konck/p/7758265.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/konck/p/7758265.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/konck/p/7739471.html&quot;&gt;Java集合（1）一 集合框架&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/konck/p/7758265.html&quot;&gt;Java集合（2）一 ArrayList 与 LinkList&lt;/a&gt;&lt;br/&gt;Java集合（3）一 红黑树、TreeMap与TreeSet（上）&lt;br/&gt;Java集合（4）一 红黑树、TreeMap与TreeSet（下）&lt;br/&gt;Java集合（5）一 HashMap与HashSet&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;ArrayList&amp;lt;E&amp;gt;和LinkList&amp;lt;E&amp;gt;在继承关系上都继承自List&amp;lt;E&amp;gt;接口，上篇文章我们分析了List&amp;lt;E&amp;gt;接口的特点：有序，可以重复，并且可以通过整数索引来访问。&lt;br/&gt;他们在自身特点上有很多相似之处，在具体实现上ArrayList&amp;lt;E&amp;gt;和LinkList&amp;lt;E&amp;gt;又有很大不同，ArrayList&amp;lt;E&amp;gt;通过数组实现，LinkList&amp;lt;E&amp;gt;则使用了双向链表。将他们放到一起学习可以更清楚的理解他们的区别。&lt;/p&gt;
&lt;h2 id=&quot;框架结构&quot;&gt;框架结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201710/368583-20171030221444246-424733005.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201710/368583-20171030221453886-1944858110.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的结构图可以看出ArrayList&amp;lt;E&amp;gt;和LinkList&amp;lt;E&amp;gt;在继承结构上基本相同，值得注意的是LinkList&amp;lt;E&amp;gt;在继承了List&amp;lt;E&amp;gt;接口的同时还继承了Deque&amp;lt;E&amp;gt;接口。&lt;br/&gt;Deque&amp;lt;E&amp;gt;是一个双端队列的接口，LinkList&amp;lt;E&amp;gt;由于在实现上采用了双向链表，所以可以很自然的实现双端队列头尾进出的特点。&lt;/p&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;数据结构&lt;/h2&gt;
&lt;p&gt;上一篇文章中我们说过，为什么一个Collection&amp;lt;E&amp;gt;接口会衍生出这么多实现类，其中最大的原因就是每一种实现在数据结构上都有差别，而不同的数据结构又导致了每种集合在使用场景上又各有不同。&lt;br/&gt;ArrayList&amp;lt;E&amp;gt;和LinkList&amp;lt;E&amp;gt;的根本区别就在数据结构上，只有了解了他们各自的数据结构，才能更加深入的明白他们各自的使用场景。&lt;br/&gt;在ArrayList&amp;lt;E&amp;gt;的源代码中有一个elementData变量，这个变量就代表了ArrayList&amp;lt;E&amp;gt;所使用的数据结构：数组。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//The array buffer into which the elements of the ArrayList are stored.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;transient&lt;/span&gt; Object[] elementData;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;elementData变量是ArrayList&amp;lt;E&amp;gt;操作的基础，他所有的操作都是基于elementData这个Object类型的数组来实现的。&lt;br/&gt;数组有以下几个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数组大小一旦初始化之后，长度固定。&lt;/li&gt;
&lt;li&gt;数组中元素之间的内存地址是连续的。&lt;/li&gt;
&lt;li&gt;只能存储一种类数据类型的元素。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130181322886-1201578333.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这里面有个transient关键字值得注意，他的作用是标志当前对象不需要序列化。&lt;br/&gt;如果大家了解序列化，请跳过下面的介绍：&lt;br/&gt;&lt;em&gt;序列化是什么？&lt;/em&gt;&lt;br/&gt;序列化简单说就是将一个对象持久化的过程。将对象转换成字节流的过程就叫序列化，一个对象要在网络中传播就必须被转换成字节流。对应的，一个对象从字节流转换成对象的过程就叫反序列化。&lt;br/&gt;在Java中，标志一个对象可以被序列化只需要继承Serializable接口即可，Serializable接口是一个空接口。&lt;br/&gt;明白了什么是序列化的概念，再来看transient关键字，java中规定被声明为transient的关键在被序列化的时候会被忽略，可是为什么要忽略这个对象呢？如果被忽略了那反序列化的时候这个对象怎样恢复呢？&lt;br/&gt;我们先来想想什么样的对象在序列化时需要被忽略？序列化是一个耗时也耗费空间的过程，一般在一个对象中除了必须持久化的变量，还会存在很多中间变量或临时变量，声明这些变量的作用是方便我们操作这个类，举个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.io.IOException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.ObjectInputStream;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SerializableDateTime &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; java.&lt;span class=&quot;fu&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Serializable&lt;/span&gt; {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; serialVersionUID = -8291235042612920489L;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String date = &lt;span class=&quot;st&quot;&gt;&quot;2011-11-11&quot;&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String time = &lt;span class=&quot;st&quot;&gt;&quot;11:11&quot;&lt;/span&gt;;

    &lt;span class=&quot;co&quot;&gt;//不需要序列化的对象&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;transient&lt;/span&gt; String dateTime;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;initDateTime&lt;/span&gt;() {
        dateTime = date + time;
    }

    &lt;span class=&quot;co&quot;&gt;//反序列化的时候调用，给dateTime赋值&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;readObject&lt;/span&gt;(ObjectInputStream inputStream) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException, ClassNotFoundException {
        inputStream.&lt;span class=&quot;fu&quot;&gt;defaultReadObject&lt;/span&gt;();
        &lt;span class=&quot;fu&quot;&gt;initDateTime&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SerializableDateTime对象中的dateTime对象如果在外界调用的时候会赋值，但是这个对象并不是基础数据，不需要序列化，在反序列化的时候可以通过调用initDateTime返回获取他的值，所以只需要序列化date和time对象即可。将dateTime对象标记为transient，则可以达到按需序列化的目的。&lt;br/&gt;那在ArrayList&amp;lt;E&amp;gt;中为什么要忽略elementData这个对象呢？&lt;br/&gt;主要是因为elementData对象不仅包含了所有有用的元素，还存在许多没有未使用的空间，而这些空间是不需要全部序列化的，为了节约空间，所以只序列化了elementData中存有对象的那一部分，在反序列化的时候又恢复elementData对象的空间，这样可以达到节约序列化空间和时间的目的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//序列化时调用&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(java.&lt;span class=&quot;fu&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;ObjectOutputStream&lt;/span&gt; s)
    &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; java.&lt;span class=&quot;fu&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;IOException&lt;/span&gt;{
    &lt;span class=&quot;co&quot;&gt;// Write out element count, and any hidden stuff&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; expectedModCount = modCount;
    s.&lt;span class=&quot;fu&quot;&gt;defaultWriteObject&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;// Write out size as capacity for behavioural compatibility with clone()&lt;/span&gt;
    s.&lt;span class=&quot;fu&quot;&gt;writeInt&lt;/span&gt;(size);

    &lt;span class=&quot;co&quot;&gt;// Write out all elements in the proper order.&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//序列化size大小的元素，size的大小是实际存储元素的大小，不是elementData元素的大小&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i&amp;lt;size; i++) {
        s.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(elementData[i]);
    }

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (modCount != expectedModCount) {
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ConcurrentModificationException();
    }
}

&lt;span class=&quot;co&quot;&gt;//反序列化时调用&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;readObject&lt;/span&gt;(java.&lt;span class=&quot;fu&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;ObjectInputStream&lt;/span&gt; s)
    &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; java.&lt;span class=&quot;fu&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;IOException&lt;/span&gt;, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    &lt;span class=&quot;co&quot;&gt;// Read in size, and any hidden stuff&lt;/span&gt;
    s.&lt;span class=&quot;fu&quot;&gt;defaultReadObject&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;// Read in capacity&lt;/span&gt;
    s.&lt;span class=&quot;fu&quot;&gt;readInt&lt;/span&gt;(); &lt;span class=&quot;co&quot;&gt;// ignored&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (size &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        &lt;span class=&quot;co&quot;&gt;// be like clone(), allocate array based upon size not capacity&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//恢复elementData对象的空间&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;ensureCapacityInternal&lt;/span&gt;(size);

        Object[] a = elementData;
        &lt;span class=&quot;co&quot;&gt;// Read in all elements in the proper order.&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i&amp;lt;size; i++) {
            &lt;span class=&quot;co&quot;&gt;//填充elementData元素的内容&lt;/span&gt;
            a[i] = s.&lt;span class=&quot;fu&quot;&gt;readObject&lt;/span&gt;();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种序列化和反序列化的方法非常巧妙，在我们编程的过程中也可以借鉴这种办法来节约序列化和反序列化的空间和时间。&lt;/p&gt;
&lt;p&gt;LinkedList&amp;lt;E&amp;gt;在底层实现上采用了链表这种数据结构，而且是双向链表，即每个元素都包含他的上一个和下一个元素的引用：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//链表的第一个元素&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt; first;

&lt;span class=&quot;co&quot;&gt;//链表的最后一个元素&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt; last;

&lt;span class=&quot;co&quot;&gt;//链表的内部类表示&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Node&amp;lt;E&amp;gt; {
    &lt;span class=&quot;co&quot;&gt;//当前元素&lt;/span&gt;
    E item;
    &lt;span class=&quot;co&quot;&gt;//下一个元素&lt;/span&gt;
    Node&amp;lt;E&amp;gt; next;
    &lt;span class=&quot;co&quot;&gt;//上一个元素&lt;/span&gt;
    Node&amp;lt;E&amp;gt; prev;

    Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;item&lt;/span&gt; = element;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = next;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;prev&lt;/span&gt; = prev;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;链表的特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;长度不固定，可以随时增加和减少&lt;/li&gt;
&lt;li&gt;链表中的元素在内存地址上可以是连续的，也可以是不连续的，大部分情况下都是不连续的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130181533839-1359821119.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;构造函数&lt;/h2&gt;
&lt;p&gt;ArrayList&amp;lt;E&amp;gt;提供了3种构造方式，默认的构造函数会初始化一个空的数组，在之后添加元素的过程中会对数组进行扩容，扩容操作在一定程度上会影响数组的性能。如果能提前预估最终的数组使用空间大小，可以通过ArrayList(int initialCapacity) 这种构造方式来初始化数组大小，这样会减少扩容造成的性能损失。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ArrayList(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; initialCapacity) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (initialCapacity &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        &lt;span class=&quot;co&quot;&gt;//初始化数组大小&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[initialCapacity];
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (initialCapacity == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt; = EMPTY_ELEMENTDATA;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;Illegal Capacity: &quot;&lt;/span&gt;+
                                            initialCapacity);
    }
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ArrayList() {
    &lt;span class=&quot;co&quot;&gt;//初始化一个空的数组&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt; = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ArrayList(Collection&amp;lt;? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; E&amp;gt; c) {
    elementData = c.&lt;span class=&quot;fu&quot;&gt;toArray&lt;/span&gt;();
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((size = elementData.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;) != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        &lt;span class=&quot;co&quot;&gt;// c.toArray might (incorrectly) not return Object[] (see 6260652)&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (elementData.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;() != Object[].&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;)
            elementData = Arrays.&lt;span class=&quot;fu&quot;&gt;copyOf&lt;/span&gt;(elementData, size, Object[].&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;co&quot;&gt;// replace with empty array.&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt; = EMPTY_ELEMENTDATA;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LinkList&amp;lt;E&amp;gt;只提供了2种构造方式，默认的构造函数是一个空函数，因为链表这种数据结构在使用上不需要初始化空间，也不需要扩容，每次需要添加元素时直接追加就可以，在空间的最大化利用上链表比数组更加合理。这并不代表链表使用的空间小，相反，链表每个节点因为要存储下一个节点引用（双向链表会存储上下两个节点的引用），在相同元素空间使用上会比数组大的多。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; LinkedList() {
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; LinkedList(Collection&amp;lt;? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; E&amp;gt; c) {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;();
    &lt;span class=&quot;fu&quot;&gt;addAll&lt;/span&gt;(c);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;添加元素&quot;&gt;添加元素&lt;/h2&gt;
&lt;p&gt;ArrayList&amp;lt;E&amp;gt;在添加元素的过程中，需要考虑数组空间是否足够，不够的情况下需要扩容。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//ArrayList&amp;lt;E&amp;gt;添加元素到末尾&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(E e) {
    &lt;span class=&quot;co&quot;&gt;//检查数组容量，不够就扩容，扩容调用grow(int minCapacity) 方法&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;ensureCapacityInternal&lt;/span&gt;(size + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);  
    elementData[size++] = e;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ensureExplicitCapacity&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; minCapacity) {
    modCount++;

    &lt;span class=&quot;co&quot;&gt;// overflow-conscious code&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (minCapacity - elementData.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        &lt;span class=&quot;fu&quot;&gt;grow&lt;/span&gt;(minCapacity);
}

&lt;span class=&quot;co&quot;&gt;//扩容&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;grow&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; minCapacity) {
    &lt;span class=&quot;co&quot;&gt;// overflow-conscious code&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; oldCapacity = elementData.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;//向右位移一位，相当于除以2，比除法运算要快，每次扩容在原容量的基础上增加一半，新的容量为原容量的1.5倍。&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (newCapacity - minCapacity &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        newCapacity = minCapacity;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (newCapacity - MAX_ARRAY_SIZE &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        newCapacity = &lt;span class=&quot;fu&quot;&gt;hugeCapacity&lt;/span&gt;(minCapacity);
    &lt;span class=&quot;co&quot;&gt;// minCapacity is usually close to size, so this is a win:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//拷贝所有数据元素到新的数组中，内部调用System.arraycopy来拷贝所有数组元素&lt;/span&gt;
    elementData = Arrays.&lt;span class=&quot;fu&quot;&gt;copyOf&lt;/span&gt;(elementData, newCapacity);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不扩容：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201712/368583-20171206230055363-1239000105.png&quot;/&gt;&lt;br/&gt;扩容：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201712/368583-20171206230248269-1491321289.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从中可以看出，不扩容的情况下添加元素到末尾非常方便，时间复杂度为O(1)，扩容的情况下每次都需要拷贝所有元素到新数组，时间复杂度上为O(n)，存在一定性能损耗。&lt;/p&gt;&lt;p&gt;LinkedList&amp;lt;E&amp;gt;在添加元素时由于链表的特性，不需要考虑扩容的问题，但LinkedList&amp;lt;E&amp;gt;每次都需要new一个Node来存储元素。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//LinkedList&amp;lt;E&amp;gt;添加元素到末尾&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(E e) {
    &lt;span class=&quot;fu&quot;&gt;linkLast&lt;/span&gt;(e);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
}

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;linkLast&lt;/span&gt;(E e) {
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l = last;
    &lt;span class=&quot;co&quot;&gt;//new一个新的链表元素并链接到末尾&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; newNode = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(l, e, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
    last = newNode;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (l == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
        first = newNode;
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
        l.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = newNode;
    size++;
    modCount++;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201712/368583-20171206230733441-1949467563.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;ArrayList&amp;lt;E&amp;gt;在添加元素到指定索引位置的时候，除了检查容量之外，由于数组具有在空间连续存储的特性，还需要对插入元素之后的所有节点做一次位移。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//ArrayList&amp;lt;E&amp;gt;添加元素到指定索引位置&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index, E element) {
    &lt;span class=&quot;fu&quot;&gt;rangeCheckForAdd&lt;/span&gt;(index);

    &lt;span class=&quot;fu&quot;&gt;ensureCapacityInternal&lt;/span&gt;(size + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;// Increments modCount!!&lt;/span&gt;
    System.&lt;span class=&quot;fu&quot;&gt;arraycopy&lt;/span&gt;(elementData, index, elementData, index + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,size - index);
    elementData[index] = element;
    size++;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130181801667-175597278.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;LinkedList&amp;lt;E&amp;gt;添加到指定位置时首先需要先查找元素的位置，然后添加。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//LinkedList&amp;lt;E&amp;gt;添加元素到指定索引位置&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index, E element) {
    &lt;span class=&quot;fu&quot;&gt;checkPositionIndex&lt;/span&gt;(index);
    
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (index == size)
        &lt;span class=&quot;co&quot;&gt;//直接添加元素到末尾&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;linkLast&lt;/span&gt;(element);
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//添加到指定位置前先查找当前位置已经存在的元素&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;linkBefore&lt;/span&gt;(element, &lt;span class=&quot;fu&quot;&gt;node&lt;/span&gt;(index));
}

&lt;span class=&quot;co&quot;&gt;//查找指定索引的元素&lt;/span&gt;
Node&amp;lt;E&amp;gt; &lt;span class=&quot;fu&quot;&gt;node&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index) {
    &lt;span class=&quot;co&quot;&gt;// assert isElementIndex(index);&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//指定索引小于元素数量的一半时从first开始遍历，大于元素数量的一半时从last开始遍历&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)) {
        Node&amp;lt;E&amp;gt; x = first;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; index; i++)
            x = x.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; x;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        Node&amp;lt;E&amp;gt; x = last;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = size - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; i &amp;gt; index; i--)
            x = x.&lt;span class=&quot;fu&quot;&gt;prev&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; x;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130181813745-1983036645.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;LinkedList&amp;lt;E&amp;gt;的这种查找对性能有影响吗？相比ArrayList&amp;lt;E&amp;gt;的扩容以及位移插入位后面所有的元素性能如何？我们来对插入到头部、尾部以及中间位置3种特殊情况做个简单测试。&lt;br/&gt;插入到尾部：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addTailElementArrayList&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count) {

    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; startTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
    List&amp;lt;Integer&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; count; i++) {
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(i);
    }
    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; endTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;addTailElementArrayList time: &quot;&lt;/span&gt; + (endTime - startTime));
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addTailElementLinkedList&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count) {

    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; startTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
    List&amp;lt;Integer&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt;();
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; count; i++) {
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(i);
    }
    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; endTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;addTailElementLinkedList time: &quot;&lt;/span&gt; + (endTime - startTime));
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;ArrayList&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;160&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;LinkList&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;110&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;插入到头部：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addHeadElementArrayList&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count) {

    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; startTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
    List&amp;lt;Integer&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; count; i++) {
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, i);
    }
    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; endTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;addHeadElementArrayList time: &quot;&lt;/span&gt; + (endTime - startTime));
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addHeadElementLinkedList&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count) {

    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; startTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
    List&amp;lt;Integer&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt;();
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; count; i++) {
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, i);
    }
    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; endTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;addHeadElementLinkedList time: &quot;&lt;/span&gt; + (endTime - startTime));
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;ArrayList&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;10&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;900&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;LinkList&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;6&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;插入到中间：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addCenterIndexElementArrayList&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count) {

    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; startTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
    List&amp;lt;Integer&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; count; i++) {
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;()&amp;gt;&amp;gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, i);
    }
    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; endTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;addCenterIndexElementArrayList time: &quot;&lt;/span&gt; + (endTime - startTime));
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addCenterIndexElementLinkedList&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count) {

    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; startTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
    List&amp;lt;Integer&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt;();
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; count; i++) {
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;()&amp;gt;&amp;gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, i);
    }
    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; endTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;addCenterIndexElementLinkedList time: &quot;&lt;/span&gt; + (endTime - startTime));
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;ArrayList&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;400&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;LinkList&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;80&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;10000&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从中可以得处几个简单结论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在添加到末尾时，ArrayList&amp;lt;E&amp;gt;和LinkedList&amp;lt;E&amp;gt;在性能上差距不明显，尽管ArrayList&amp;lt;E&amp;gt;需要扩容，但LinkedList&amp;lt;E&amp;gt;也需要new一个Node对象。&lt;/li&gt;
&lt;li&gt;在插入到头部时，LinkedList&amp;lt;E&amp;gt;性能明显好于ArrayList&amp;lt;E&amp;gt;，因为ArrayList&amp;lt;E&amp;gt;每次都需要将所有元素向后移动一个位置，而LinkedList&amp;lt;E&amp;gt;由于是双向链表每次只需要改变first元素就可以了。&lt;/li&gt;
&lt;li&gt;在插入到中间位置的时候，ArrayList&amp;lt;E&amp;gt;性能优明显好于LinkedList&amp;lt;E&amp;gt;，这是因为ArrayList&amp;lt;E&amp;gt;此时只需要移动一半的元素，而LinkedList&amp;lt;E&amp;gt;因为其双向链表查找元素的特殊性，只能从头或者尾部开始遍历，每次都需要遍历一半的元素，这个操作耗费了大量时间，而ArrayList&amp;lt;E&amp;gt;在扩容以及移动元素上的性能消耗比想象的要小。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们在ArrayList&amp;lt;E&amp;gt;和LinkedList&amp;lt;E&amp;gt;的选择上，需要充分考虑使用时的场景，LinkedList&amp;lt;E&amp;gt;在插入数据上并不是一定比ArrayList&amp;lt;E&amp;gt;性能好，相反的在很多情况下ArrayList&amp;lt;E&amp;gt;性能反而要好的多。不能因为插入操作多，就一定选用LinkedList&amp;lt;E&amp;gt;，还需要考虑插入元素的位置等其他因素来最终决定。&lt;/p&gt;
&lt;h2 id=&quot;删除元素&quot;&gt;删除元素&lt;/h2&gt;
&lt;p&gt;ArrayList&amp;lt;E&amp;gt;删除元素通过遍历元素查找到相等的元素然后使用索引删除，删除之后还要将被删除元素后的元素前移。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(Object o) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (o == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; index &amp;lt; size; index++)
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (elementData[index] == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;fu&quot;&gt;fastRemove&lt;/span&gt;(index);
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; index &amp;lt; size; index++)
            &lt;span class=&quot;co&quot;&gt;//查找到equals的元素的索引然后删除&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (o.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(elementData[index])) {
                &lt;span class=&quot;fu&quot;&gt;fastRemove&lt;/span&gt;(index);
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;fastRemove&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index) {
    modCount++;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; numMoved = size - index - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (numMoved &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        &lt;span class=&quot;co&quot;&gt;//所有删除元素后的元素前移&lt;/span&gt;
        System.&lt;span class=&quot;fu&quot;&gt;arraycopy&lt;/span&gt;(elementData, index&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;, elementData, index,
                            numMoved);
    elementData[--size] = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// clear to let GC do its work&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130181829729-152302327.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;LinkedList&amp;lt;E&amp;gt;通过向后遍历链表的方式查找到equals的元素直接删除即可。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(Object o) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (o == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;; x = x.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (x.&lt;span class=&quot;fu&quot;&gt;item&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;fu&quot;&gt;unlink&lt;/span&gt;(x);
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }
        }
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;; x = x.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (o.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(x.&lt;span class=&quot;fu&quot;&gt;item&lt;/span&gt;)) {
                &lt;span class=&quot;fu&quot;&gt;unlink&lt;/span&gt;(x);
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }
        }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201712/368583-20171206230313753-1253481055.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;遍历元素&quot;&gt;遍历元素&lt;/h2&gt;
&lt;p&gt;在遍历元素上ArrayList&amp;lt;E&amp;gt;存在更有效的方式，他实现了RandomAccess接口，代表ArrayList&amp;lt;E&amp;gt;支持快速访问。&lt;br/&gt;RandomAccess本身是一个空接口，这种接口一般用来代表一类特征，RandomAccess代表实现类具有快速访问的特征。ArrayList&amp;lt;E&amp;gt;实现快速访问的方式是通过索引。这代表ArrayList&amp;lt;E&amp;gt;在遍历时通过for循环方式要比通过Iterator或ListIterator迭代器方式要快。LinkedList&amp;lt;E&amp;gt;没有实现这个借口，所以一般还是通过Iterator迭代器来访问。&lt;/p&gt;
</description>
<pubDate>Sun, 10 Dec 2017 22:54:00 +0000</pubDate>
<dc:creator>knock_小新</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/konck/p/7758265.html</dc:identifier>
</item>
<item>
<title>weakSelf 和 strongSelf - 鸿鹄当高远</title>
<link>http://www.cnblogs.com/jukaiit/p/8018883.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jukaiit/p/8018883.html</guid>
<description>&lt;p&gt;最近在看SDWebImage源码，碰到一些比较绕的问题，理解了很久，然后在网上查了些的资料，才算是有了一些理解。在此记录一下。&lt;/p&gt;
&lt;p&gt;源码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/575661/201712/575661-20171210235248786-335503058.png&quot; alt=&quot;&quot; width=&quot;1116&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;

&lt;p&gt;block会copy要在block中使用的实变量，而copy会是变量的retainCount + 1，如若在不注意很容易造成循环引用。而所谓的循环引用的本质就是，两个对象相互引用，从而造成对象不能正常的dealloc。所以解决的办法就是让引用的一方是weak的，这样就使得相互引用的闭环被打破，能够正常的dealloc了。&lt;/p&gt;

&lt;p&gt;1）weakSelf的使用：&lt;/p&gt;
&lt;p&gt;Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。 &lt;/p&gt;
&lt;p&gt;上图的代码中，backgroundTaskId是当前这个类的一个属性，在backgroundTaskId初始化的这个方法中，有一个block回调，在这个block的实现中访问需要访问Self，为了避免造成循环引用，此处给当前的Self取了个别名，并用__weak来修饰，目的是告诉编译器，此处是弱引用，不要retain 当前的这个类，也就是所谓的self。&lt;/p&gt;
&lt;p&gt;2）为什么会出现strongSelf？&lt;/p&gt;
&lt;p&gt;Apple 官方文档有讲到，如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。&lt;/p&gt;
&lt;p&gt;clang给出的实例代码：&lt;/p&gt;

&lt;p&gt;    __weak __typeof__(self) weakSelf = self;&lt;/p&gt;
&lt;p&gt;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{&lt;/p&gt;
&lt;p&gt;        [weakSelf doSomething];&lt;/p&gt;
&lt;p&gt;    });&lt;/p&gt;
&lt;p&gt; clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：&lt;/p&gt;
&lt;p&gt;    __weak __typeof__(self) weakSelf = self;&lt;/p&gt;
&lt;p&gt;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{&lt;/p&gt;
&lt;p&gt;        [weakSelf doSomething];&lt;/p&gt;
&lt;p&gt;        [weakSelf doOtherThing];&lt;/p&gt;
&lt;p&gt;    });&lt;/p&gt;

&lt;p&gt; 在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，&lt;/p&gt;
&lt;p&gt; 于是，strongSelf 就派上用场了：&lt;/p&gt;
&lt;p&gt;    __weak __typeof__(self) weakSelf = self;&lt;/p&gt;
&lt;p&gt;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{&lt;/p&gt;
&lt;p&gt;        __strong __typeof(self) strongSelf = weakSelf;&lt;/p&gt;
&lt;p&gt;        [strongSelf doSomething];&lt;/p&gt;
&lt;p&gt;        [strongSelf doOtherThing];&lt;/p&gt;
&lt;p&gt;    });&lt;/p&gt;
&lt;p&gt;   __strong 确保strongSelf在block中不会被释放。&lt;/p&gt;

&lt;p&gt;所以就能理解SDWebImage中的那段代码，block在实现的过程中会对wself进行一次强引用，是为了防止在block还未执行完毕，wself在其他线程中被释放，使得wself为nil。&lt;/p&gt;

&lt;p&gt; 简单的做个小结：&lt;/p&gt;
&lt;p&gt; 1、在使用block时，如果block内部需要访问self的方法、属性、或者实例变量应当使用weakSelf&lt;/p&gt;
&lt;p&gt; 2、如果在block内需要多次访问self，则需要使用strongSelf&lt;/p&gt;
&lt;p&gt; 3、如果在block内部存在多线程环境访问self，则需要使用strongSelf&lt;/p&gt;
&lt;p&gt; 4、block本身不存在多线程之分，block执行是否是多线程，取决于当前的持有者是否是以多线程的方式来调用它。&lt;/p&gt;


&lt;p&gt;clang的文档链接&lt;/p&gt;
&lt;p&gt;https://github.com/CoderBeta/clang-user-manual&lt;/p&gt;
&lt;p&gt;http://blog.csdn.net/bbmb_mb/article/details/50470802&lt;/p&gt;

</description>
<pubDate>Sun, 10 Dec 2017 15:54:00 +0000</pubDate>
<dc:creator>鸿鹄当高远</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jukaiit/p/8018883.html</dc:identifier>
</item>
<item>
<title>缓存与ABP Redis Cache - 安于生</title>
<link>http://www.cnblogs.com/anyushengcms/p/8013201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anyushengcms/p/8013201.html</guid>
<description>&lt;h2 id=&quot;为什么要用缓存&quot;&gt;为什么要用缓存&lt;/h2&gt;
&lt;p&gt;为什么要用缓存呢，说缓存之前先说使用缓存的优点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;减少寄宿服务器的往返调用（round-trips）。&lt;/li&gt;
&lt;li&gt;如果缓存在客户端或是代理，将减少对服务器的请求，减少带宽。&lt;/li&gt;
&lt;li&gt;减少对数据库服务器的往返调用（round-trips）。&lt;/li&gt;
&lt;li&gt;当内容缓存在web服务器，能够减轻对数据库的请求。&lt;/li&gt;
&lt;li&gt;减少网络带宽。&lt;/li&gt;
&lt;li&gt;避免了重新生成可重用内容的时耗。&lt;/li&gt;
&lt;li&gt;提高性能&lt;/li&gt;
&lt;li&gt;因为缓存减少了round-trips, network traffic（网络带宽），并避免- 了生成可重用内容的时耗，所以对性能有巨大的提高。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;传统的缓存方式&quot;&gt;传统的缓存方式&lt;/h2&gt;
&lt;p&gt;传统的缓存方式如下面这张图&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-94809e618d9bc9f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;之前我们处理方式处理起来也很简单&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;页面输出缓存，直接在 ASP.NET中页面缓存的使用OutputCache 在aspx页的顶部加这样一句即可：&lt;br/&gt;&lt;code&gt;&amp;lt;%@ OutputCache Duration=&quot;60&quot; VaryByParam=&quot;none&quot; %&amp;gt;&lt;/code&gt;&lt;br/&gt;Duration 表示缓存的时间秒，必选，否则报错。&lt;/li&gt;
&lt;li&gt;第二种方式&lt;br/&gt;&lt;code&gt;if (this.Cache[&quot;Keys&quot;] == null) { this.Cache.Insert(&quot;Keys&quot;, List, null, DateTime.Now.AddHours(2), TimeSpan.Zero); }&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里是检查缓存中Keys是否存在，如果不存在，则写入一个新的值List.还有其他的一些使用方法。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-fc031fecdbf5b173.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面两种方式显然不在现在使用范畴,也不在我想说的范畴之内。，年代貌似有点久远，不用webform基本用不到。现在我们更多是的使用MVC。&lt;br/&gt;我们想说的是MVC输出缓存。&lt;/p&gt;
&lt;h2 id=&quot;mvc缓存&quot;&gt;MVC缓存&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;输出缓存&lt;/strong&gt;：&lt;code&gt;Outputcache&lt;/code&gt; ,分为Action输出缓存和Controller输出缓存。使用的场景包括某个页面的数据更新不是很频繁，不需要每次都从数据库区查询。缓存起来从内存中读取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据缓存&lt;/strong&gt;：是相对于全局的。任何地方需要调用的时候都可以去调用。使用的场景包括权限管理这种模块的。每个角色对于菜单的访问都是固定的，所以有必要将角色，权限，菜单这种数据做一个全局的数据缓存。修改时再做缓存的更新。&lt;/p&gt;
&lt;p&gt;输出缓存和数据缓存区别：打个比方输出缓存就像是“局部变量”，数据缓存就像是全局变量（只是个比喻）。&lt;/p&gt;
&lt;p&gt;Controller输出缓存和 Action缓存使用方式是一样的，就是Controller 或Action上打[OutPutCache]特性标签。但是他们之间又是有区别的。&lt;/p&gt;
&lt;p&gt;一、控制器缓存&lt;/p&gt;
&lt;p&gt;Control缓存的作用域是整个控制器，所以在这个控制器下的所有Action都会被缓存起来。Control缓存的粒度比较粗，应用也比较少些。&lt;br/&gt;&lt;code&gt;[OutputCache(Duration = 10)] public class HomeController : Controller { public ActionResult Index() { ViewBag.CurrentTime = DateTime.Now; return View(); } }&lt;/code&gt;&lt;br/&gt;二、Action缓存&lt;br/&gt;将[OutPutCache]特性标签打在Action上，这样，只有加缓存的Action才会有缓存，其他的Action是没有的。&lt;/p&gt;
&lt;h2 id=&quot;outputcache特性常用的属性参数&quot;&gt;Outputcache特性常用的属性参数&lt;/h2&gt;
&lt;h2 id=&quot;输出缓存cacheprofile使用配置文件设置缓存&quot;&gt;输出缓存CacheProfile使用配置文件设置缓存&lt;/h2&gt;
&lt;p&gt;举例其中的CacheProfile，这种方式便于统一配置，当然也可以设置参数duration、location 、varybyparam等。我们需要在system.web 节点下加入这些&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;!---CacheProfile配置文件中设置缓存--&amp;gt; &amp;lt;caching&amp;gt; &amp;lt;outputCacheSettings&amp;gt; &amp;lt;outputCacheProfiles&amp;gt; &amp;lt;add name=&quot;TestConfigCache&quot; duration=&quot;20&quot; location=&quot;Any&quot; enabled=&quot;true&quot;/&amp;gt; &amp;lt;/outputCacheProfiles&amp;gt; &amp;lt;/outputCacheSettings&amp;gt; &amp;lt;/caching&amp;gt; &amp;lt;!---CacheProfile配置文件中设置缓存end--&amp;gt;&lt;/code&gt;&lt;br/&gt;其实作用和效果还是一样，无非就是方便点，统一的配置参数都直接写webconfig文件里面。其实也可以Controller中写。&lt;br/&gt;配置好了之后我们直接在控制器调用相应的名字的&lt;code&gt;OutputCache&lt;/code&gt;特性标签即可。&lt;br/&gt;&lt;code&gt;[OutputCache(CacheProfile= &quot;TestConfigCache&quot;)] public ActionResult Index() { ViewBag.CurrentTime = DateTime.Now; return View(); }&lt;/code&gt;&lt;br/&gt;更多的方式，需要下去再研究下。&lt;/p&gt;
&lt;h2 id=&quot;abp中使用icachemanager进行缓存管理&quot;&gt;ABP中使用ICacheManager进行缓存管理&lt;/h2&gt;
&lt;p&gt;ABP中有两种cache的实现方式：&lt;code&gt;MemroyCache&lt;/code&gt; 和&lt;code&gt;RedisCache&lt;/code&gt;，两者都继承至ICache接口（准确说是&lt;code&gt;CacheBase&lt;/code&gt;抽象类）。ABP核心模块封装了&lt;code&gt;MemroyCache&lt;/code&gt;来实现ABP中的默认缓存功能。 &lt;code&gt;Abp.RedisCache&lt;/code&gt;这个模块封装&lt;code&gt;RedisCache&lt;/code&gt;来实现缓存（通过&lt;code&gt;StackExchange.Redis&lt;/code&gt;这个类库访问redis）。&lt;/p&gt;
&lt;p&gt;ABP给出了一个抽象缓存基类。并在内部使用了该抽象基类。使用 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.caching.memorycache(v=vs.110).aspx?f=255&amp;amp;MSPPError=-2147217396&quot;&gt;MemoryCache&lt;/a&gt; 来实现了该抽象基类。它能够被任何其它的缓存类来扩展。&lt;a href=&quot;https://www.nuget.org/packages/Abp.RedisCache&quot;&gt;Abp.RedisCache&lt;/a&gt; 包就扩展了该缓存基类。&lt;br/&gt;ABP对外提供了一个缓存接口ICacheMananger。我们通过构造函数注入这个接口来获取缓存。示例如下：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-9d998b535cf0c7c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个示例中，我们注入了 ICacheManager接口，s并且获取了一个名称为ControllerCache的缓存。首先我们先对ControllerCache进行清除，然后存入缓存，缓存的名字是大小写敏感的，那就是&quot;ControllerCache&quot;和&quot;CONTROLLERCACHE&quot;取得的缓存内容是不同的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：GetCache方法 千万不要在你的构造函数中使用GetCache方法。如果类不是一个单例对象那么该缓存可能会被dispose掉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;icache&quot;&gt;ICache&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ICacheManager.GetCache&lt;/code&gt;方法返回了一个&lt;code&gt;ICache&lt;/code&gt;对象。每一个缓存都是基于名称单例存在的。只有首次访问时才会被创建，以后你每次用相同的名称去获取的缓存都是相同的。所以我们可以在不同的类中使用相同的名称来共享相同的缓存。&lt;/p&gt;
&lt;p&gt;在示例代码中，我们简单的使用了&lt;code&gt;ICache.Get&lt;/code&gt;方法，它有两个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;key : 要获取的缓存项的唯一标识符&lt;/li&gt;
&lt;li&gt;factory：如果根据给定的key获取到的缓存项为空，那么factory将会创建一个标识符为key的缓存，并且返回该缓存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ICache接口还有其它方法，如前面&lt;code&gt;Clear()&lt;/code&gt;,&lt;code&gt;Get()&lt;/code&gt;,&lt;code&gt;GetOrDefault&lt;/code&gt;，&lt;code&gt;Set&lt;/code&gt;，&lt;code&gt;Remove&lt;/code&gt;和&lt;code&gt;Clear&lt;/code&gt;。当然也有这些方法的异步(async)版本。如下图，我就懒得写了。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-1c3f6f1a4ad73ef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;itypedcache&quot;&gt;ITypedCache&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ICache&lt;/code&gt; 接口用key(字符串类型)来获取缓存value(object类型)。&lt;code&gt;ITypedCache&lt;/code&gt; 为&lt;code&gt;ICahe&lt;/code&gt;提供了一个 类型安全 的包装；为了使类型安全转换(&lt;code&gt;ICache&lt;/code&gt;到&lt;code&gt;ITypedCache&lt;/code&gt;)，我们可以用扩展方法 &lt;code&gt;AsTyped&lt;/code&gt;，而不需要写其它强制类型转换的代码，如下所示：&lt;br/&gt;&lt;code&gt;ITypedCache&amp;lt;int, Item&amp;gt; myCache = _cacheManager.GetCache(&quot;MyCache&quot;).AsTyped&amp;lt;int, Item&amp;gt;();&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;configuration&quot;&gt;Configuration&lt;/h2&gt;
&lt;p&gt;缓存的过期时间默认是60分钟。它是变化的。如果你在60分钟内没有使用该缓存，该缓存会被自动的移除。如果你想改变所有的缓存或者指定的缓存来的默认过期时间，你可以这样做，实现如下：&lt;br/&gt;&lt;code&gt;//对所有缓存的配置 Configuration.Caching.ConfigureAll(cache =&amp;gt; { cache.DefaultSlidingExpireTime = TimeSpan.FromHours(2); });&lt;/code&gt;&lt;br/&gt;&lt;code&gt;//对指定缓存的配置 Configuration.Caching.Configure(&quot;MyCache&quot;, cache =&amp;gt; { cache.DefaultSlidingExpireTime = TimeSpan.FromHours(8); });&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这段代码你应该放在模块(module)的 &lt;code&gt;PreInitialize&lt;/code&gt; 方法中。如上所示：&lt;code&gt;MyCache&lt;/code&gt;将会在8小时后过期，而其他的缓存将在2小时后过期。&lt;/p&gt;
&lt;p&gt;这些配置将会在首次创建缓存的时候生效。配置不仅仅局限于&lt;code&gt;DefaultSlidingExpireTime&lt;/code&gt;，你可以利用&lt;code&gt;ICache&lt;/code&gt;接口中的属性获取方法来自由的配置并且初始化它们。&lt;/p&gt;
&lt;h2 id=&quot;entity-caching&quot;&gt;Entity Caching&lt;/h2&gt;
&lt;p&gt;ABP的缓存系统是以通用为目的，它有一个 &lt;code&gt;EntityCache&lt;/code&gt; 基类，如果你需要的话，这个基类可以帮助你缓存实体。使用这个基类，我们可以通过ID取得实体，并且我们通过ID来缓存实体，这样以后就不需要频繁的查询数据库去取得实体。假设我们有个&lt;code&gt;Person&lt;/code&gt;实体，像下面一样：&lt;br/&gt;&lt;code&gt;public class Person : Entity { public string Name { get; set; } public int Age { get; set; } }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;并且，假设我们通过该实体的Id，需要频繁调用取得Person实体的Name。首先，我们应该创建一个类来存储 cache items：&lt;br/&gt;&lt;code&gt;[AutoMapFrom(typeof(Person))] public class PersonCacheItem { public string Name { get; set; } }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们 不应该直接存储实体到缓存中 因为缓存的时候需要序列化缓存对象而实体可能不能被序列化(尤其是实体的导航属性)。这就是为什么我们定义了一个简单的像DTO的类来存储数据到缓存中。我们添加了 AutoMapFrom 特性，这是因为我们想使用 AutoMapper 来自动的转换 Person 实体为 PersonCacheItem 对象。如果我们不使用 AutoMapper，那么我们应该重写 EntityCache 类的 MapToCacheItem 方法手动转换/映射它。&lt;/p&gt;
&lt;p&gt;然而这不是必须的，我们可能想定义一个接口为缓存类：&lt;br/&gt;&lt;code&gt;public interface IPersonCache : IEntityCache&amp;lt;PersonCacheItem&amp;gt; { }&lt;/code&gt;&lt;br/&gt;最后，我们可以创建缓存类来缓存Person实体：&lt;br/&gt;&lt;code&gt;public class PersonCache : EntityCache&amp;lt;Person, PersonCacheItem&amp;gt;, IPersonCache, ITransientDependency { public PersonCache(ICacheManager cacheManager, IRepository&amp;lt;Person&amp;gt; repository) : base(cacheManager, repository) { } }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样就OK了，我们的person缓存已经准备好可以使用了。缓存类可以使瞬时(如同这个例子)或者是单例。这不是说缓存数据是瞬态的。在你的应用程序中它一直是全局缓存并且是线程安全的。&lt;/p&gt;
&lt;p&gt;现在，无论在什么地方我们需要取得Person的Name，我们可以通过Person的Id从缓存中取得它。如下所示：&lt;br/&gt;&lt;code&gt;public class MyPersonService : ITransientDependency { private readonly IPersonCache _personCache; public MyPersonService(IPersonCache personCache) { _personCache = personCache; } public string GetPersonNameById(int id) { return _personCache[id].Name; //alternative: _personCache.Get(id).Name; } }&lt;/code&gt;&lt;br/&gt;我们很容易的&lt;a href=&quot;https://github.com/Jimmey-Jiang/AbpDocument2Chinese/blob/master/Markdown/Abp/2.1ABP%E5%85%AC%E5%85%B1%E7%BB%93%E6%9E%84-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.md&quot;&gt;注入&lt;/a&gt; &lt;strong&gt;IPersonCache&lt;/strong&gt; 接口，通过该接口取得缓存项和Name属性。&lt;/p&gt;
&lt;p&gt;那么EntityCache是怎么工作的？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在首次调用的时候我们通过仓储从数据库中取得实体。那么随后的调用都是从缓存中取得。&lt;/li&gt;
&lt;li&gt;如果实体被更新或者删除，它会自动的无效实体。因此，它会在下次调用的时候重新从数据库中检索数据。&lt;/li&gt;
&lt;li&gt;使用 IObjectMapper 接口来映射实体到缓存项。IObjectMapper 接口在 AutoMapper 中被实现。所以，如果你使用了自动映射，那么就需要 AutoMapper模块。你可以重写 MapToCacheItem 方法手动映射它到缓存项。&lt;/li&gt;
&lt;li&gt;使用缓存类的FullName作为缓存的Name，你可以通过传入的缓存名到基类的构造函数来改变它。&lt;/li&gt;
&lt;li&gt;它是线程安全的。&lt;br/&gt;如果你有更复杂的缓存需求，那么你需要扩展 EntityCache 类或者创建你自己的解决方案。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;redis-cache-集成&quot;&gt;Redis Cache 集成&lt;/h2&gt;
&lt;p&gt;Redis是什么，Redis是一个开源的使用ANSI &lt;a href=&quot;https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80&quot;&gt;C语言&lt;/a&gt;编写、支持网络、可基于内存亦可持久化的日志型、Key-Value&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93&quot;&gt;数据库&lt;/a&gt;，并提供多种语言的API。它可以用作数据库、缓存和消息中间件。它支持多种类型的数据结构，如字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）与范围查询、bitmaps、hyperloglogs和地理空间（geospatial）索引半径查询。&lt;br/&gt;Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。&lt;br/&gt;Redis 与其他 key - value 缓存产品有以下三个&lt;strong&gt;特点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。&lt;/li&gt;
&lt;li&gt;Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。&lt;/li&gt;
&lt;li&gt;Redis支持数据的备份，即master-slave模式的数据备份。&lt;br/&gt;&lt;strong&gt;Redis 优势&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。&lt;/li&gt;
&lt;li&gt;丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。&lt;/li&gt;
&lt;li&gt;原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。&lt;/li&gt;
&lt;li&gt;丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。&lt;/li&gt;
&lt;li&gt;多实用工具 - Redis是一个多实用工具，可用于多种用例，如：缓存，消息队列(Redis本地支持发布/订阅)，应用程序中的任何短期数据，例如，web应用程序中的会话，网页命中计数等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（1）&lt;strong&gt;首先，我们前往&lt;a href=&quot;https://github.com/dmajkic/redis/downloads&quot; class=&quot;uri&quot;&gt;https://github.com/dmajkic/redis/downloads&lt;/a&gt;下载安装包&lt;/strong&gt;，直接下一步下一步就可以了。&lt;br/&gt;然后打开安装的地址就可以看到如下的文件：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-bb672bfdc3a1dbbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;（2）&lt;strong&gt;然后启动Redis服务&lt;/strong&gt;，我们cmd到安装目录下，然后输入命令&lt;code&gt;redis-server.exe redis.windows.conf&lt;/code&gt;&lt;br/&gt;就会看到下面的画面证明我们启动服务成功。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-c08fa2adb3d9a6cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;abp默认Cache Mananger是使用&lt;strong&gt;in-memory&lt;/strong&gt;来缓存。所以，这可能会成为一个问题，如果有多个并发的Web服务运行在同一个应用中。在这种情况下，你可能想要一个分布式/中央缓存服务器。那么，你可以使用Redis来作为你的缓存服务。&lt;br/&gt;首先，你需要安装&lt;br/&gt;&lt;a href=&quot;https://www.nuget.org/packages/Abp.RedisCache&quot;&gt;Abp.RedisCache&lt;/a&gt;nuget package 到你的项目中(你可以安装它到你的Web项目)。这里我遇到一个错误。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-9d128c0f1e80f119.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;开始的时候我搞了半天不知道为什么会出现这个莫名其妙的错误，后来才发现，原来我引入Abp.RedisCache版本和abp版本不一致。才导致的这个错误，比如你abp是3.1.1，那么你的Abp.RedisCache最好也是对应的版本，最好的话把abp和Abp.RedisCache都升级到最新版本，就不会有错误了。&lt;br/&gt;然后我们看看Abp.Runtime.Caching.Redis;依赖项以及之间的关系。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-02c5a475aaffef48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;然后在ABPCMSWebModule配置一下。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-0eb9dbaab4daadbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;ABPCMSApplicationModule中引入。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-f1dee7e6b8449297.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;Web.config中配置&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-f832c254c21d0490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;你也可以添加配置到appSettings来设置Redis数据库的Id。如：&lt;br/&gt;&lt;code&gt;&amp;lt;add key=&quot;Abp.Redis.Cache.DatabaseId&quot; value=&quot;2&quot;/&amp;gt;&lt;/code&gt;&lt;br/&gt;在同一个服务器上使用不同的数据库Id是非常有用的这可以创建不同的Key Spaces(隔离缓存)。&lt;br/&gt;&lt;strong&gt;UseRedis&lt;/strong&gt;有一个重载方法，你可以通过这个方法来传入配置参数，这可以覆盖掉配置文件中的配置。关于Redis的其他配置可以查看&lt;a href=&quot;http://redis.io/documentation&quot;&gt;Redis文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在下面UserList打下断点调试进去。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-0456a4de85eb5d93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;看到效果如下图，证明我们AbpRedisCache引入成功。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-820a6a011df84d9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;当然为了更好的进行可视化操作，我建议使用跨平台开源Redis DB管理工具（Redis Desktop Manager）地址：&lt;a href=&quot;https://redisdesktop.com/download&quot; class=&quot;uri&quot;&gt;https://redisdesktop.com/download&lt;/a&gt;&lt;br/&gt;下载下来直接下一步下一步安装即可。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-2bf0952b0458d913.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;然后运行项目，然后我们在看下Redis Desktop Manager工具，效果如下图：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-7ec00b2177bb8bcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;使用可视化工具很方便&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建连接，输入redis主机host，端口号port，再起个生动形象，简明达意的别名。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;该工具支持根据筛选条件查询key，add new key，reload等。&lt;/li&gt;
&lt;li&gt;支持常用redis操作，针对目标key执行rename，delete，addrow，reload value操作。&lt;/li&gt;
&lt;li&gt;命令控制台操作 ！大家感兴趣可以自己玩一下。&lt;br/&gt;另外关于实体修改后自动更新缓存的实现远离可以参考&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/loyldg/p/using-redis-in-abp-2.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/loyldg/p/using-redis-in-abp-2.html&lt;/a&gt;&lt;br/&gt;这个文章。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;Github项目地址：&lt;a href=&quot;https://github.com/Jimmey-Jiang/ABP-ASP.NET-Boilerplate-Project-CMS&quot; class=&quot;uri&quot;&gt;https://github.com/Jimmey-Jiang/ABP-ASP.NET-Boilerplate-Project-CMS&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;本文链接：&lt;a href=&quot;http://www.cnblogs.com/anyushengcms/p/8013201.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/anyushengcms/p/8013201.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 Dec 2017 15:54:00 +0000</pubDate>
<dc:creator>安于生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anyushengcms/p/8013201.html</dc:identifier>
</item>
<item>
<title>QT之TCP通信 - 菜头大大</title>
<link>http://www.cnblogs.com/wurenzhong/p/8018862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wurenzhong/p/8018862.html</guid>
<description>&lt;p&gt;&lt;span&gt;QT中可以通过TCP协议让服务器和客户端之间行通信。所以下面我就围绕服务器和客户端来写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是我么写服务器和客户端的具体流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A、服务器：&lt;/span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;1.创建QTcpServer对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         2.启动服务器（监听）调用成员方法listen（QHostAddress::Any,端口号）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         3.当有客户端链接时候会发送newConnection信号，触发槽函数接受链接（得到一个与客户端通信的套接字QTcpSocket）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         4.QTcpsocket发送数据用成员方法write，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         5.读数据当客户端有数据来，QTcpSocket对象就会发送readyRead信号，关联槽函数读取数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;B、客户端&lt;/span&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;1.创建QTcpSocket对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        2.链接服务器connectToHost(QHostAddress(&quot;ip&quot;),端口号)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        3.QTcpsocket发送数据用成员方法write，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        4.读数据当对方有数据来，QTcpSocket对象就会发送readyRead信号，关联槽函数读取数据&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;我们需要调用到的头文件有两个&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#include &amp;lt;QTcpServer&amp;gt;  &lt;span&gt;
#include &lt;/span&gt;&amp;lt;QTcpSocket&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们先要在工程文件中加入network&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
QT       += core gui network
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面我们来看看服务器程序步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、初始化服务器server对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mServer = &lt;span&gt;new&lt;/span&gt; QTcpServer();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、启动监听服务器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  mServer-&amp;gt;listen(QHostAddress::Any,&lt;span&gt;9988&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9988为端口号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、当有客户端链接时候会发送newConnection信号，触发槽函数接受链接（得到一个与客户端通信的套接字QTcpSocket）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 connect(mServer,SIGNAL(newConnection()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(new_client()));
 mSocket &lt;/span&gt;= mServer-&amp;gt;nextPendingConnection();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与客户端通信的套接字&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、发送数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 mSocket-&amp;gt;write(msg.toUtf8());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、读数据当客户端有数据来，QTcpSocket对象就会发送readyRead信号，关联槽函数读取数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 connect(mSocket,SIGNAL(readyRead()),&lt;span&gt;this&lt;/span&gt;,SLOT(read_client_data()));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、连接多个客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以实现同时读取多个客户端发送过来的消息&lt;/span&gt;
 QTcpSocket *obj = (QTcpSocket*)sender();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7、检测掉线&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 connect(mSocket,SIGNAL(disconnected()),&lt;span&gt;this&lt;/span&gt;,SLOT(client_dis())); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测掉线信号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是服务器的实现的具体代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcpserver.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_tcpserver.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;QDebug&amp;gt;
&lt;span&gt; 4&lt;/span&gt; TcpServer::TcpServer(QWidget *&lt;span&gt;parent) :
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    QMainWindow(parent),
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     ui(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::TcpServer)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ui-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化服务器server对象&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     mServer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTcpServer();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联客户端连接信号newConnection&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     connect(mServer,SIGNAL(newConnection()),&lt;span&gt;this&lt;/span&gt;,SLOT(new_client())); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接客户端
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动服务器监听&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     mServer-&amp;gt;listen(QHostAddress::Any,&lt;span&gt;9988&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; TcpServer::~&lt;span&gt;TcpServer()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ui;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpServer::new_client()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     qDebug()&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新客户段连接&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     mSocket = mServer-&amp;gt;nextPendingConnection();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与客户端通信的套接字
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联接收客户端数据信号readyRead信号（客户端有数据就会发readyRead信号）&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     connect(mSocket,SIGNAL(readyRead()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(read_client_data()));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测掉线信号&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     connect(mSocket,SIGNAL(disconnected()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(client_dis()));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpServer::read_client_data()
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以实现同时读取多个客户端发送过来的消息&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     QTcpSocket *obj = (QTcpSocket*&lt;span&gt;)sender();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     QString msg = obj-&amp;gt;&lt;span&gt;readAll();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     qDebug()&amp;lt;&amp;lt;&lt;span&gt;msg;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpServer::client_dis()
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;      QTcpSocket *obj = (QTcpSocket*)sender();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;掉线对象&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;      qDebug()&amp;lt;&amp;lt;obj-&amp;gt;peerAddress().toString();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印出掉线对象的ip&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;说完服务器那我们继续来看看客户端是怎么实现的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、创建QTcpSocket对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 mSocket = &lt;span&gt;new&lt;/span&gt; QTcpSocket();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、链接服务器connectToHost(QHostAddress(&quot;ip&quot;),端口号)，连接服务器ip和端口号&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 mSocket-&amp;gt;connectToHost(ui-&amp;gt;ipEdit-&amp;gt;text(),ui-&amp;gt;portEdit-&amp;gt;text().toInt()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ui-&amp;gt;ipEdit-&amp;gt;text()：ip，ui-&amp;gt;portEdit-&amp;gt;text().toInt()：端口号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、发送数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取发送信息编辑框内容&lt;/span&gt;
QString msg = ui-&amp;gt;sendEdit-&amp;gt;&lt;span&gt;toPlainText();
mSocket&lt;/span&gt;-&amp;gt;write(msg.toUtf8());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转编码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、检测链接成功信号关联槽函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 connect(mSocket,SIGNAL(connected()),&lt;span&gt;this&lt;/span&gt;,SLOT(connect_suc()));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、检测掉线信号&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 connect(mSocket,SIGNAL(disconnected()),&lt;span&gt;this&lt;/span&gt;,SLOT(client_dis()));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、服务器和客户端关闭都可以使用close&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
 mSocket-&amp;gt;close();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是客户端实现的具体代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcpclient.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_tcpclient.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;QDebug&amp;gt;
&lt;span&gt; 4&lt;/span&gt; TcpClient::TcpClient(QWidget *&lt;span&gt;parent) :
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    QMainWindow(parent),
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     ui(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::TcpClient)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ui-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化套接字对象&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     mSocket = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTcpSocket();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联数据信号&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     connect(mSocket,SIGNAL(readyRead()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(read_data()));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; TcpClient::~&lt;span&gt;TcpClient()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ui;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpClient::read_data()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     QString msg = mSocket-&amp;gt;&lt;span&gt;readAll();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     qDebug()&amp;lt;&amp;lt;&lt;span&gt;msg;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpClient::on_btn_connectServer_clicked()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测链接成功信号关联槽函数&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     connect(mSocket,SIGNAL(connected()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(connect_suc()));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测掉线信号&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     connect(mSocket,SIGNAL(disconnected()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(client_dis()));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接服务器，设置ip和端口号&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     mSocket-&amp;gt;connectToHost(ui-&amp;gt;ipEdit-&amp;gt;text(),ui-&amp;gt;portEdit-&amp;gt;&lt;span&gt;text().toInt());
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpClient::on_btn_send_clicked()
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取发送信息编辑框内容&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;     QString msg = ui-&amp;gt;sendEdit-&amp;gt;&lt;span&gt;toPlainText();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     mSocket-&amp;gt;write(msg.toUtf8());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转编码&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpClient::connect_suc()
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     ui-&amp;gt;btn_connectServer-&amp;gt;setEnabled(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果连接成功则连接按钮不能按下&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpClient::client_dis()
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     ui-&amp;gt;btn_connectServer-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果连接没有成功则连接按钮还可以按下&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这是服务器和客户端分开两个文件夹写的程序，在这里我也实现了服务器和客户端写在同一个文件中&lt;/p&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;p&gt;头文件：tcpapp.h&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_98d670cb-e935-41bc-b191-7062e00db424&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_98d670cb-e935-41bc-b191-7062e00db424&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_98d670cb-e935-41bc-b191-7062e00db424&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef TCPAPP_H
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; TCPAPP_H
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;QMainWindow&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;QTcpServer&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;QTcpSocket&amp;gt;
&lt;span&gt; 7&lt;/span&gt; #include &amp;lt;QHostAddress&amp;gt;
&lt;span&gt; 8&lt;/span&gt; #include &amp;lt;QFile&amp;gt;
&lt;span&gt; 9&lt;/span&gt; #include &amp;lt;QTimer&amp;gt;
&lt;span&gt;10&lt;/span&gt; #include &amp;lt;QMessageBox&amp;gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Ui {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TcpApp;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TcpApp : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QMainWindow
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    Q_OBJECT
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;explicit&lt;/span&gt; TcpApp(QWidget *parent = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     ~&lt;span&gt;TcpApp();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; slots:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; on_severRB_clicked();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择作为服务器&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; on_clientRB_clicked();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择作为客户端&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; on_StartBt_clicked();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动服务器或链接客户端&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; on_closeBt_clicked();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭服务器或断开客户端&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; on_onlineUserList_doubleClicked(&lt;span&gt;const&lt;/span&gt; QModelIndex &amp;amp;index);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择给哪个客户端发送数据&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; on_autoCB_clicked(&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;checked&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择自动发送还是手动发送&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; on_sendMsgBt_clicked();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送信息
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; accept_connect();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与newconnection信号关联&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; recv_data(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收数据&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;      &lt;span&gt;void&lt;/span&gt; auto_time_send();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器定时发送数据&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;      &lt;span&gt;void&lt;/span&gt; client_disconnect();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联掉线信号&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;      &lt;span&gt;void&lt;/span&gt; connect_suc();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测客户端连接成功信号&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;      &lt;span&gt;void&lt;/span&gt;&lt;span&gt; on_clearRcvBt_clicked();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;      &lt;span&gt;void&lt;/span&gt;&lt;span&gt; on_clearSendBt_clicked();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     Ui::TcpApp *&lt;span&gt;ui;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     QTimer *mTimer;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时发送数据&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;     QTcpServer *&lt;span&gt;mServer;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     QTcpSocket *&lt;span&gt;mSocket;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     QVector&amp;lt;QTcpSocket*&amp;gt; clients; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储所有在线客户端（容器）&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; isServer;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标志位,true为服务器，false为客户端
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存接收和发送数据的字节数&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    quint64 recvSize;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    quint64 sendSize;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;    qint16 onNum;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; isCheckServer;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否选择了服务器&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; isCheckClient;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否选择了客户端&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TCPAPP_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;源文件：tcpapp.cpp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;&lt;img id=&quot;code_img_closed_f01ca2ee-5653-472a-a2e2-a19cdd17a552&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f01ca2ee-5653-472a-a2e2-a19cdd17a552&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f01ca2ee-5653-472a-a2e2-a19cdd17a552&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;93&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcpapp.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_tcpapp.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; TcpApp::TcpApp(QWidget *&lt;span&gt;parent) :
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;    QMainWindow(parent),
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;     ui(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::TcpApp),
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;     onNum(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     ui-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     recvSize = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     sendSize = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化定时器&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;     mTimer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTimer();
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     connect(mTimer,SIGNAL(timeout()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(auto_time_send()));
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; TcpApp::~&lt;span&gt;TcpApp()
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ui;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;与newconnection信号关联&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::accept_connect()
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     mSocket = mServer-&amp;gt;nextPendingConnection(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回与客户端连接通信的套接字
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联接收数据信号&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;     connect(mSocket,SIGNAL(readyRead()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(recv_data()));
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联掉线信号&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;     connect(mSocket,SIGNAL(disconnected()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(client_disconnect()));
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上线用户添加到客户列表容器&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;    clients.append(mSocket);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把用户添加到界面列表中&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;     QString ip = mSocket-&amp;gt;peerAddress().toString().remove(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;::ffff:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;去除客户端中多余的字符&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;     ui-&amp;gt;onlineUserList-&amp;gt;&lt;span&gt;addItem(ip);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在线数量添加&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;     onNum++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     ui-&amp;gt;onlineUserCount-&amp;gt;setText(QString::number(onNum));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示在线数&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收数据&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  TcpApp::recv_data()
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;       QTcpSocket *obj = (QTcpSocket*&lt;span&gt;)sender();
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取发送数据端的IP&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;       QString ip = obj-&amp;gt;&lt;span&gt;peerAddress().toString();
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;       ip.remove(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;::ffff:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;       QString msg = obj-&amp;gt;&lt;span&gt;readAll();
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;       ui-&amp;gt;receiveList-&amp;gt;addItem(ip+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+msg);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示接收到的数据&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;       recvSize += msg.size();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计接收到的数据的字节数&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;       ui-&amp;gt;receiveNumLabel-&amp;gt;&lt;span&gt;setText(QString::number(recvSize));
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::client_disconnect()
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     QTcpSocket *obj = (QTcpSocket*)sender();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取掉线对象&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isServer)
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; row = clients.indexOf(obj);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到掉线对象的内容所在的行&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;         QListWidgetItem *item = ui-&amp;gt;onlineUserList-&amp;gt;takeItem(row);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从界面列表中去除找到的一行内容&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         clients.remove(row);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从容器中删除对象
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;掉线时删除在线数量&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;         onNum--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         ui-&amp;gt;onlineUserCount-&amp;gt;&lt;span&gt;setText(QString::number(onNum));
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;断开连接的时候重新启用开始按钮&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端连接成功&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::connect_suc()
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;     ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接成功则禁用开始按钮&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器定时发送数据&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::auto_time_send()
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     quint64 len = mSocket-&amp;gt;write(ui-&amp;gt;sendMsgEdit-&amp;gt;&lt;span&gt;toPlainText().toUtf8());
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(len &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         sendSize += len;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计发送的字节数&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;         ui-&amp;gt;sendNumLabel-&amp;gt;setText(QString::number(sendSize));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把发送的字节数显示到sendNumLabel上&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择作为服务器&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::on_severRB_clicked()
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;isCheckServer = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;isServer = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取本地ip显示在IpEdit中&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;    ui-&amp;gt;IpEdit-&amp;gt;&lt;span&gt;setText(QHostAddress(QHostAddress::LocalHost).toString());
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;    ui-&amp;gt;IpEdit-&amp;gt;setEnabled(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭ip输入编辑器&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt;    &lt;span&gt;this&lt;/span&gt;-&amp;gt;isCheckClient = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择作为客户端&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::on_clientRB_clicked()
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;isCheckClient = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;isServer = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;     ui-&amp;gt;IpEdit-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开ip输入编辑器&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;isCheckServer = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动服务器或者链接服务器&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::on_StartBt_clicked()
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(isServer) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;         mServer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTcpServer();
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联新客户端链接信号&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt;         connect(mServer,SIGNAL(newConnection()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(accept_connect()));
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;         mServer-&amp;gt;listen(QHostAddress::Any,ui-&amp;gt;PortEdit-&amp;gt;text().toInt());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动服务器监听&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt;         ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始按钮禁用&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(isServer == &lt;span&gt;false&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;         mSocket = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTcpSocket();
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测链接成功信号&lt;/span&gt;
&lt;span&gt;132&lt;/span&gt;         connect(mSocket,SIGNAL(connected()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(connect_suc()));
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置服务器的 ip和端口号&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;         mSocket-&amp;gt;connectToHost(ui-&amp;gt;IpEdit-&amp;gt;text(),ui-&amp;gt;PortEdit-&amp;gt;&lt;span&gt;text().toInt());
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联接收数据信号&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt;         connect(mSocket,SIGNAL(readyRead()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(recv_data()));
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联掉线信号&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt;         connect(mSocket,SIGNAL(disconnected()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(client_disconnect()));
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; 
&lt;span&gt;143&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(isCheckServer == &lt;span&gt;false&lt;/span&gt; &amp;amp;&amp;amp; isCheckClient == &lt;span&gt;false&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果两个都没选择&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;         QMessageBox::warning(&lt;span&gt;this&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请选择服务器或者客户端&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;         ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(isCheckServer)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择了服务器&lt;/span&gt;
&lt;span&gt;151&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt;(ui-&amp;gt;PortEdit-&amp;gt;text().isEmpty() || ui-&amp;gt;PortEdit-&amp;gt;text() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入端口号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;       {
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;            QMessageBox::warning(&lt;span&gt;this&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入端口号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;            ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; 
&lt;span&gt;160&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(isCheckClient)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择了客户端&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(ui-&amp;gt;IpEdit-&amp;gt;text().isEmpty() || ui-&amp;gt;IpEdit-&amp;gt;text() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入ip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; || ui-&amp;gt;IpEdit-&amp;gt;text() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入端口号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;             QMessageBox::warning(&lt;span&gt;this&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入ip和端口号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;             ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; 
&lt;span&gt;170&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; 
&lt;span&gt;172&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭服务器或者断开&lt;/span&gt;
&lt;span&gt;173&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::on_closeBt_clicked()
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(isServer)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器&lt;/span&gt;
&lt;span&gt;176&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;clients.count();i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;              clients.at(i)-&amp;gt;close();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭所有客户端&lt;/span&gt;
&lt;span&gt;180&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; 
&lt;span&gt;182&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭所有服务器之后开始按钮才能启用&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt;         mServer-&amp;gt;&lt;span&gt;close();
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;         ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端&lt;/span&gt;
&lt;span&gt;187&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;         mSocket-&amp;gt;close();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭客户端&lt;/span&gt;
&lt;span&gt;189&lt;/span&gt;         ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启用开始按钮&lt;/span&gt;
&lt;span&gt;190&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; 
&lt;span&gt;192&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; 
&lt;span&gt;194&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;双击选择要发送的客户端&lt;/span&gt;
&lt;span&gt;195&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TcpApp::on_onlineUserList_doubleClicked(&lt;span&gt;const&lt;/span&gt; QModelIndex &amp;amp;&lt;span&gt;index)
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;     mSocket =&lt;span&gt; clients.at(index.row());
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; 
&lt;span&gt;199&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; 
&lt;span&gt;201&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动发送数据&lt;/span&gt;
&lt;span&gt;202&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TcpApp::on_autoCB_clicked(&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;checked&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;checked&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt; 
&lt;span&gt;206&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(ui-&amp;gt;autoTimeEdit-&amp;gt;text().toInt() &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;             QMessageBox::warning(&lt;span&gt;this&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入时间值ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;             ui-&amp;gt;autoCB-&amp;gt;setChecked(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把按钮重新置于没选中的状态&lt;/span&gt;
&lt;span&gt;211&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;         mTimer-&amp;gt;start(ui-&amp;gt;autoTimeEdit-&amp;gt;text().toInt());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动定时器&lt;/span&gt;
&lt;span&gt;214&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;216&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;         mTimer-&amp;gt;stop();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;停止定时器&lt;/span&gt;
&lt;span&gt;218&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; 
&lt;span&gt;220&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; 
&lt;span&gt;222&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;手动发送数据&lt;/span&gt;
&lt;span&gt;223&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::on_sendMsgBt_clicked()
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;    auto_time_send();
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt; 
&lt;span&gt;227&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt; 
&lt;span&gt;229&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空接收区&lt;/span&gt;
&lt;span&gt;230&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::on_clearRcvBt_clicked()
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;     ui-&amp;gt;receiveNumLabel-&amp;gt;&lt;span&gt;clear();
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;recvSize = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;     ui-&amp;gt;receiveNumLabel-&amp;gt;&lt;span&gt;setText(QString::number(recvSize));
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; 
&lt;span&gt;237&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空发送区&lt;/span&gt;
&lt;span&gt;238&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::on_clearSendBt_clicked()
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;     ui-&amp;gt;sendNumLabel-&amp;gt;&lt;span&gt;clear();
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;sendSize = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;     ui-&amp;gt;sendNumLabel-&amp;gt;&lt;span&gt;setText(QString::number(sendSize));
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;界面文件tcpapp.ui如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206191/201712/1206191-20171210234326786-1985944821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;此外这里还使用到了容器，在这里讲讲容器的使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、定义容器对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
QVector&amp;lt;QTcpSocket*&amp;gt; clients; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储所有在线客户端（容器）&lt;/span&gt;
&lt;span&gt;  解释：QTcpSocke  容器的类型
       clients  容器名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、往容器中添加成员&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上线用户添加到客户列表容器&lt;/span&gt;
 clients.append(mSocket); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、寻找某个成员在容器中位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;int&lt;/span&gt; row = clients.indexOf(obj);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到掉线对象的内容所在的行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、从容器中删除车成员&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  clients.remove(row);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从容器中删除成员&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 10 Dec 2017 15:47:00 +0000</pubDate>
<dc:creator>菜头大大</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wurenzhong/p/8018862.html</dc:identifier>
</item>
<item>
<title>Ajax的工作原理 - 毕竟我那么帅</title>
<link>http://www.cnblogs.com/luoyong-14/p/8018854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luoyong-14/p/8018854.html</guid>
<description>&lt;p&gt;在聊到Ajax的时候，需要大家清楚的是·Ajax是什么。AJax也叫Asynchronous JavaScript and XML，即异步的JavaScript 和XML。其次需要清楚的Ajax并不是一门新的语言或技术，而是JavaScript ，css,Dom,xml等多种已有的技术的组合，可以实现客户端的异步请求的操作从而实现在不刷新页面的情况下与服务器端进行数据层间的数据交互，减少了用户的等待时间，减轻了服务器端和带宽的负担，例如Google地图和百度地图中都有用到Ajax&lt;/p&gt;&lt;p&gt;在传统的web应用模式中，每发送一次http请求到web服务器端，经过处理后，返回的是一个html+css的格式|&lt;br/&gt;使用了Ajax应用模式中，页面中用户的操作将通过Ajax引擎与服务器端进行通信，经web服务器端处理后返回的是一个html+字符串数据，就是说通过回调函数返回的data是一个字符串，这个字符串可以是json格式也可以是其他格式，取决于你定义的是什么&lt;/p&gt;&lt;p&gt;使用Ajax的优点：&lt;/p&gt;
&lt;p&gt;1,首先是降低网络的流量，因为是局部刷新&lt;br/&gt;2，把一部分原本是有服务器承担的工作转移到客户端，利用客户端闲置的资源进行一个处理，减轻了服务器和带宽的负担，节约了空间和成本&lt;/p&gt;
&lt;p&gt;3，使用Ajax可以实现局部刷新的效果而不是页面刷新，这样的话就将服务器的角色由传输内容变成传输数据，而这个传输的数据的格式可以是xml格式，也可以是纯文本格式、&lt;/p&gt;
&lt;p&gt;4，通过Ajax的核心对象XMLHttpRequest发送请求来进行客户端和服务端之间的一个交互，通过XMLHttprequest发送请求后，通过javascript来操作DOM从而更新页面中的数据&lt;/p&gt;
&lt;p&gt;使用Ajax的缺点：&lt;/p&gt;
&lt;p&gt;1，通过XMLhttpRequesth函数来获取数据，在使用Ajax进行跨域请求的时候会出现跨域的安全问题，当然在后面可以通过jsonp来解决浏览器同源策略问题，但是在没有jsonp的时候会存在这样的问题&lt;/p&gt;
&lt;p&gt;2，由于ajax是通过javascript来操作dom，进行对页面中的数据进行一个更新的，这样一来的话就会导致javascript过多，不易于维护&lt;/p&gt;
&lt;p&gt;3,给搜索引擎带来困难&lt;br/&gt;4，aj&lt;span lang=&quot;EN-US&quot;&gt;ax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、&lt;span lang=&quot;EN-US&quot;&gt;SQL注入攻击和基于&lt;span lang=&quot;EN-US&quot;&gt;credentials的安全漏洞等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;安全问题：&lt;br/&gt;当web应用程序运行javascript脚本的时候，用户允许任何人编写的javascript代码运行在自己的计算机上，这就为移动代码自动跨域网络来运行提供了方便条件，为了解决这潜在的问题，浏览器厂商都会提供一个sandbox(沙箱)，沙箱是一个只能访问很少计算机资源的密闭环境，从而使得ajax应用不能读取或写入本地文件系统，从而提高了客户端的javascript安全性&lt;br/&gt;客户端调用远程资源的一个安全问题：&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;虽然javascript允许客户端完成部分服务器端的工作，并且可以通过javascript来检查用户的权限，但是通过客户端脚本来控制权限并不可取，一些解密高手可以很轻松的绕开javascript权限检查直接访问业务逻辑组件，从而给网站带来安全的问题，通常情况下，在ajax应用中，所有的ajax请求都应该发送到控制器，有控制器来判断调用者是否有访问资源的权限&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;性能问题：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;尽量使用局部变量而不使用全局变量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;优化for循环&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;尽量少使用eval()方法，每次使用eval（）都会消耗大量的时间&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;尽量减少“”。“”号操作符的使用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;浏览器兼容问题：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;readstatus：&lt;/p&gt;
&lt;p&gt;0：未初始化，也就是没有调用open方法&lt;/p&gt;
&lt;p&gt;1：正在加载&lt;/p&gt;
&lt;p&gt;2，已加载&lt;/p&gt;
&lt;p&gt;3，交互中&lt;/p&gt;
&lt;p&gt;4，已完成”&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于同步和异步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;异步传输是面向字符的传输，它的单位是字符；而同步传输是面向比特的传输，它的单位是桢，它传输的时候要求接受方和发送方的时钟是保持一致的。&lt;/p&gt;
&lt;p&gt;具体来说，异步传输是将比特分成小组来进行传送。一般每个小组是一个8位字符，在每个小组的头部和尾部都有一个开始位和一个停止位，它在传送过程中接收方和发送方的时钟不要求一致，也就是说，发送方可以在任何时刻发送这些小组，而接收方并不知道它什么时候到达。一个最明显的例子就是计算机键盘和主机的通信，按下一个键的同时向主机发送一个8比特位的ASCII代 码，键盘可以在任何时刻发送代码，这取决于用户的输入速度，内部的硬件必须能够在任何时刻接收一个键入的字符。这是一个典型的异步传输过程。异步传输存在 一个潜在的问题，即接收方并不知道数据会在什么时候到达。在它检测到数据并做出响应之前，第一个比特已经过去了。这就像有人出乎意料地从后面走上来跟你说 话，而你没来得及反应过来，漏掉了最前面的几个词。因此，每次异步传输的信息都以一个起始位开头，它通知接收方数据已经到达了，这就给了接收方响应、接收 和缓存数据比特的时间；在传输结束时，一个停止位表示该次传输信息的终止。按照惯例，空闲（没有传送数据）的线路实际携带着一个代表二进制1的信号。步传输的开始位使信号变成0，其他的比特位使信号随传输的数据信息而变化。最后，停止位使信号重新变回1，该信号一直保持到下一个开始位到达。例如在键盘上数字“1”，按照8比特位的扩展ASCII编码，将发送“00110001”，同时需要在8比特位的前面加一个起始位，后面一个停止位。&lt;/p&gt;
&lt;p&gt;同步传输的比特分组要大得多。它不是独立地发送每个字符，每个字符都有自己的开始位和停止位，而是把它们组合起来一起发送。我们将这些组合称为数据帧，或简称为帧。&lt;/p&gt;
&lt;p&gt;　　数据帧的第一部分包含一组同步字符，它是一个独特的比特组合，类似于前面提到的起始位，用于通知接收方一个帧已经到达，但它同时还能确保接收方的采样速度和比特的到达速度保持一致，使收发双方进入同步。&lt;/p&gt;
&lt;p&gt;　　帧的最后一部分是一个帧结束标记。与同步字符一样，它也是一个独特的比特串，类似于前面提到的停止位，用于表示在下一帧开始之前没有别的即将到达的数据了。&lt;/p&gt;
&lt;p&gt;　　同步传输通常要比异步传输快速得多。接收方不必对每个字符进行开始和停止的操作。一旦检测到帧同步字符，它就在接下来的数据到达时接收它们。另外，同步传输的开销也比较少。例如，一个典型的帧可能有500字节（即4000比特）的数据，其中可能只包含100比特的开销。这时，增加的比特位使传输的比特总数增加2.5%，这与异步传输中25 %的增值要小得多。随着数据帧中实际数据比特位的增加，开销比特所占的百分比将相应地减少。但是，数据比特位越长，缓存数据所需要的缓冲区也越大，这就限制了一个帧的大小。另外，帧越大，它占据传输媒体的连续时间也越长。在极端的情况下，这将导致其他用户等得太久。&lt;/p&gt;

</description>
<pubDate>Sun, 10 Dec 2017 15:45:00 +0000</pubDate>
<dc:creator>毕竟我那么帅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luoyong-14/p/8018854.html</dc:identifier>
</item>
<item>
<title>Python3.6_安装numpy - 小摔</title>
<link>http://www.cnblogs.com/sstzero/p/8018837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sstzero/p/8018837.html</guid>
<description>&lt;p&gt;刚刚编辑了一次，但是犯了新手都会犯的没保存的错误，第二次编辑可能略有粗糙，如有问题欢迎指正&lt;/p&gt;
&lt;p&gt;想用Python 画图，但是我的是vs自动安装的因此缺少许多必要的库，在安装的过程中也是遇到了诸多问题，下面就介绍一下这些库的安装。&lt;/p&gt;
&lt;p&gt;下面四个是vs推荐我安装的库。&lt;/p&gt;
&lt;p&gt;1. Download a dataset (using &lt;strong&gt;pandas&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;2. Process the numeric data (using &lt;strong&gt;numpy&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;3. Train and evaluate learners (using &lt;strong&gt;scikit-learn&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;4. Plot and compare results (using &lt;strong&gt;matplotlib&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;首先在安装之前请先确保环境变量已经配置：包括python.exe和pip.exe&lt;/p&gt;
&lt;p&gt;环境变量配置方式：电脑-属性-高级系统设置-高级-环境变量-系统变量-Path。如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1269654/201712/1269654-20171210233657396-1097380449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.安装numpy&lt;/p&gt;
&lt;p&gt;2.1安装包的下载官方地址 https://pypi.python.org/pypi/numpy&lt;/p&gt;
&lt;p&gt;请在“Py Version”这个栏目选择适合自己版本的，我选的cp36(我用的Python3.6)&lt;/p&gt;
&lt;p&gt;再选择合适自己系统的，我的系统是Windows 64的&lt;/p&gt;
&lt;p&gt;2.2安装包的安装//高亮部分为安装包的名称&lt;/p&gt;
&lt;p&gt;在cmd命令窗口输入：//我的安装包放在D盘根目录下&lt;/p&gt;
&lt;p&gt;（1）       D:&lt;/p&gt;
&lt;p&gt;（2）       pip install numpy-1.13.3-cp36-none-win_amd64.whl&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1269654/201712/1269654-20171210233732693-517216569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;(1)千万选择适合自己系统的安装包，否则会报如下错误：…is not a supported wheel on this platform.&lt;/p&gt;
&lt;p&gt;(2)不要修改下载下来的安装包的名称，否则会报如下错误... is not a valid wheel filename.&lt;/p&gt;

</description>
<pubDate>Sun, 10 Dec 2017 15:41:00 +0000</pubDate>
<dc:creator>小摔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sstzero/p/8018837.html</dc:identifier>
</item>
<item>
<title>计算机网络初探（ip协议） - 何必诗债换酒钱</title>
<link>http://www.cnblogs.com/backwords/p/7944780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/backwords/p/7944780.html</guid>
<description>&lt;p&gt;粗读了两遍计算机网络（谢希仁），对于计算计算机网络算是有了一个初步的了解，所以打算写一篇文章（希望是教程）进行巩固（主要围绕IP协议）。&lt;/p&gt;
&lt;h2&gt;         局域网&lt;/h2&gt;
&lt;p&gt;             因特网的产生和广泛使用极大地改变了我们的生活，但对于不了解当中技术细节的人来说，因特网的工作是透明的，即我们不知道在每次点击一个链接，发送一个文件，或者进行联机游戏时计算机的软硬件背后，无数线缆，电磁波，甚至卫星是怎样将我们的数据运送到另一台计算机上，而我们能感受到的只有毫秒间的数据收发和一个世界范围内的网络互联。&lt;/p&gt;
&lt;p&gt;             首先，从比较原始的地方开始讲起，当我们有许多的计算机并且想要通过一种方法实现所有计算机之间的互联从而实现数据交换，最为简单的方法是什么？我们可以这样，为每一台计算机分配一个唯一标识符（mac地址）来定位他，然后将所有打算接入网络的计算机用导线连接起来，这样就非常简单且原始的实现的物理层次上的互联。那么他们之间该如何进行通信呢（暂不考虑对接受到的数据的解读）？&lt;/p&gt;
&lt;p&gt;参考下图：图一&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1131119/201712/1131119-20171209212842493-1989196882.png&quot; alt=&quot;&quot; width=&quot;211&quot; height=&quot;178&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假如H1试图与H2进行通信，首先H1细心的将自己想要表达的东西打包好，注明收到消息的计算机的标识符，然后将这份数据包裹发送到线路中，由于这份包裹只有目的计算机的地址，他不知道目的计算机的具体位置，所以只好采用最笨的方法，一个一个的问：“你的地址是***吗”，例如当H3收到了这份包裹，但是却发现他不是发给自己的，就不予理睬，而包裹只能问下一个，直到他遇到了H2，H2发现这份包裹注明的目的地址是自己的地址，于是收下并打开他。这样便完成了一次H1到H2的通信。这种收发数据的方式被称为轮询，即每次发送一个数据包裹都需要询问每个计算机，直到找到目的主机。（事实上这是一个只通过集线器连接的局域网）&lt;/p&gt;
&lt;p&gt;　　　　这种方法构建的网络似乎也不赖，计算机之间可以正常通信，那么可以考虑继续将更多的计算机加入进来了。但是在这之前，我们会发现这种网络有个小毛病，就是每次网络上只能有一份包裹在传输，如果有第二个包裹也发送到网络中，二者就会发生碰撞，从而造成混乱。怎么解决这种情况呢？方法就是谦让。谦让体现在每当有一台计算机试图发送一个数据包裹时，先检测当前网络状态，如果网络中没有任何人在通信，即网络所有线路都是空闲的，那么自己便将数据包裹发送出去，而一旦发现有人在通信，即网络线路上有数据包裹正在跑来跑去，那么自己就先等着，等一会在检测一次网络线路是否空闲。然而在这里还有另一个问题，就是存在两台计算机同时发送数据包裹或是因为网络固有的时延而没有检测到网络线路上有包裹而导致他们都发送了包裹到网络上，那么碰撞必然发生，而解决方法则是一旦发生碰撞，那么两份包裹都丢弃，然后两台计算机各自沉默一个随机的时间之后再次检测网络线路选择是否发送。二者通过各自等待一个随机的时间，很好的避免了二者的再次碰撞。（CSMA/CD协议）&lt;/p&gt;
&lt;p&gt;　　　　解决了碰撞的问题。那么可以继续我们的主题，将更多的计算机加入进来！随着更多的计算机的加入，网络规模也越来越大，在较大规模下的网络中。我们当前的网络有个很致命的问题，那就是刚刚讨论过的谦让。在很小型的网络中由于这种谦让所带来的延迟是可以忽略不计的，但是一但网络规模大起来，比如几百台甚至上千台计算机构成的网络，每当有一台计算机在通信时，其他所有的计算机都要等待他通信结束后才能发送自己的包裹，这种延迟是不能被接受的。这时便不得不引入一种新的设备来将这种这个碰撞范围进行限制，这种设备就是网桥（一种专用计算机）。&lt;/p&gt;
&lt;p&gt;如图：图二&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1131119/201712/1131119-20171209215008493-1861403985.png&quot; alt=&quot;&quot; width=&quot;223&quot; height=&quot;208&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网桥将一个原本为一个整体的网络划分为一个一个的子网络并将他们连接起来，这样做最大的优点便是将碰撞范围很好的控制在一个个小型的子网络中。&lt;/p&gt;
&lt;p&gt;同时呢，在网桥中储存并维护一张由标识符组成的查找表，对应于不同的线路接口，&lt;/p&gt;
&lt;p&gt;如图：图三&lt;/p&gt;
&lt;p&gt;（假装有图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1131119/201712/1131119-20171209214209306-1330936815.png&quot; alt=&quot;&quot; width=&quot;223&quot; height=&quot;238&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每当有一台计算机试图与某一台计算机进行数据交换（通信）时，便将数据报包裹注明目的计算机的标识符，在本子网进行广播，如果目的主机不在本子网，则通过专用线路递交给网桥，而后网桥通过查找转发表找到与该标识符匹配的计算机，将这份数据通过连接到这台计算机的线路发送给他。（只通过网桥连接的局域网）&lt;/p&gt;
&lt;p&gt;　　　　上述的模型在小型的网络中也许会工作的很好，但是现实是我们有几十亿台地理分布在世界各地的计算机，显然之前的模型完全不能使用，因为这种策略本质上仍是简单的线性查找，查找过程和对数据包裹的运送将耗费极大的时间和资源。这时候，一些优秀的算法思想便可以被应用起来了。行之有效的方法是分治，而这种算法的实现就是IP协议。&lt;/p&gt;
&lt;h2&gt;          IP协议下的分组转发&lt;/h2&gt;
&lt;p&gt;　　　　我们先撇开技术方面的内容，来想这样一个问题——如何在中国找到某个美女并要到她的联系方式。因为每个人在世界上都是独一无二的，比较笨的方法就是，从当前所在地开始逢人便问，你是那个美女吗（她的个人信息就是独一无二的标识符），问遍整个中国，直到找到这个人，成功得到了她的电话。&lt;/p&gt;
&lt;p&gt;这种方法是按照美女的全球唯一标识符（长相，年龄，血型，基因型等信息的组合体）来确定她，很浪漫的方式，但却非常低效且不现实。&lt;/p&gt;
&lt;p&gt;　　　　那么接下来就是另一种方法，根据她的地址信息来定位她。比如她的地址是辽宁省-沈阳市-长滩县-张家村-2-22号-户主之女-美女，那么首先我们应该最先得知的是要到辽宁省去，所以第一次选择我们就排除了中国80%的地方，下一条信息是沈阳市，我们又排除了辽宁省的70%的地方，之后在定位到长滩县，张家村，到了这里搜索范围已经很小了，我们得知美女住2-22号，按照住户序号的分配规律（按块分配，有序）我们仍可以很快定位到2-22这家住户，但是我们发现，户主有12个女儿，我们已经没有任何信息可以帮助我们将户主女儿们划分开了，所以只能一个一个的询问，通过匹配长相，年龄，血型，基因型等信息的组合体（即唯一标识符）来定位到美女，所幸搜索范围只有12个，很快我们就找到了美女。&lt;/p&gt;
&lt;p&gt;过程如图：图四&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1131119/201712/1131119-20171209221428759-2096488745.png&quot; alt=&quot;&quot; width=&quot;262&quot; height=&quot;334&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　下面回到技术方面，我们的计算机同美女一样，在因特网中它也必须只有一个唯一标识符，而这个标识符是生产我们计算机网卡时网卡制造商写在其中的，叫做mac地址，是一个48为二进制数，具有全球唯一性。mac地址才是最终我们能将美女从12个相似的美女中将她选出来的关键。之前说过单纯使用mac地址的索引来实现通信是一件非常不明智的事，而且不同的主机（计算机，路由器等都可称为主机）在系统，软硬件上的差异性将会使得这种方法更为不可靠。那么，IP协议是如何实现IP数据报（相似之前的数据包裹，即将要发送的数据按照Ip协议的规则打包后的数据包）在全球范围内的高效分组转发并屏蔽了诸多的差异性呢？其实从找美女的第二个例子我们应该能够看出IP协议转发的思想了。 &lt;/p&gt;
&lt;p&gt;　　　　首先简单介绍下IP地址的长相：204.79.197.200；它是一个32位二进制数，通常通过每8位进行一次划分，为了表示方便通常将每8位二进制数表示为十进制。我们可以认为第一段204即对应于地理位置“市”，相应的，79对应于“县”，197对应于“村”，200对应于户主的某个女儿。其中前三者被称为网络地址，代表主机所属的区域，最后一个8位是已经无法再划分的主机号，每个拥有主机号的主机都是一个不同的个体（户主的12个女儿）。&lt;/p&gt;
&lt;p&gt;这种划分方式称为划分子网（分类别编址），即将一个本来很大的相似的群体划分为不同层次，在这里将网络地址划分为A类，B类，C类。在我们给出的这个IP地址中，A类地址：204.0.0.0，B类地址：204.79.0.0，C类地址：204.79.197.0；能看出A类地址所能包含的主机数量最大，B类次之，C类最小。前者可以包含若干个后者。那么当我要找到主机号为200的主机时就很简单了，首先找到网络地址为204.0.0.0的网络，第一步我们排除了大部分的网络，而后找到网络地址为204.79.0.0的网络（其实可以认为204.79.0.0是204.0.0.0网络下的一台主机），然后是网络204.79.197.0，这时发现网络已经没有再进行划分了，所以在该网络进行广播，遍历所有的主机号，找到主机号为200的目的主机。&lt;/p&gt;
&lt;p&gt;如图：图五&lt;br/&gt;（假装有图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1131119/201712/1131119-20171210231159630-1564807320.png&quot; alt=&quot;&quot; width=&quot;236&quot; height=&quot;289&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　更进一步考虑，我们有必要每次都去查看一个人所在地范围最大的地址吗？通信的发起者同接受者一样，也是位于某个村子的某个门牌号里的某人，也许他要发送信息的目的对象就是本村的人（同一局域网内），这时还要去查看他是哪个省，哪个市吗？显然没必要。在这里我们一定要理解一点，那就是计算机始终是存在于整个网络的边缘或者说网络的终端，中心区域为连接在一起的互联网。这就像我们每个人的住所一样，都是存在于国-省-市-县-村-号的模型的门牌号中这个最底层中，上面各层都是人为抽象出来的。所以当某个局域网内的主机试图向因特网中的某台主机（IP:200.78.132.44)通信时，首先判断目的主机是否和自己在一个局域网中，如果是，那么直接将IP数据报根据主机号（44）发送给目的主机（12个女儿找美女的过程），路由器（转发IP数据报的专用计算机）都不必经过，这很大程度上的节省了互联网的线路资源，同时也提高了通信的速度。&lt;/p&gt;
&lt;p&gt;这里不得不简要介绍一下路由器。路由器是一台用于转发IP数据报文的专用计算机，他有若干个端口，每个端口有一个网络地址，代表不同的网络并连接到他们。同时路由器也有自己的IP地址和mac地址，标识他作为一个主机本身在网络中的位置。当IP数据报在互联网上传输时，每台路由器都根据其IP地址作为独立的主机被定位。路由器会维护一张路由表，包含了他连接的子网络。比如有一份IP报文IP地址为172.43.50.15，此时这份报文到达路由器H1，H1查找自己的路由表，发现自己所连接的各个子网的网络地址没有匹配报文网络地址的端口，但是他发现H2所连接的子网有匹配的端口，于是他将IP数据报转发给H2，此时H2查找转发表，发现自己连接的子网有个地址为172.43.50.0的匹配项，于是便将这个报文从这个端口发送出去到达该子网络，由于这是一个简单的局域网，所以路由器将IP数据报的IP地址转换为目的主机的mac地址，情况转化为在局域网中根据mac地址查找主机（12女儿选美女）。&lt;/p&gt;
&lt;p&gt;                回到正题，如果目的主机不在本局域网，那么便将数据报转交给本局域网的连接到互联网的路由器（路由器可以被认为是一台主机，此时他连接到发出数据报的网络的端口的IP地址是204.79.197.0）。这台路由器首先判断IP数据报的目的网络地址是否在本网络中(可以认为路由器之间又组成了一个局域网，这块网络的网络地址为200.79.0.0。197是当前路由器一个端口的主机号，不过这个主机号代表的是一个网络而不是一个主机）。如果数据报的网络地址（200.78.132.0）就是由这一层路由器组成的网络，那么我们先将每台路由器都看做单独的主机，并假想这是一个由路由器组成的局域网，那么当一个路由器向另一个主机发送数据报时，首先IP地址被转换成mac地址并在当前局域网内广播（12女儿找美女），当找到目的路由器后，路由器查找转发表，如果有匹配的网络地址，则将数据报发送至该网络，重复上述过程，直到数据报被运输到局域网进行广播，找到主机数据传输结束。如果某层网络没有匹配项，则通过连接更大的网络的路由逐层向上传递至更高的网络（范围更大），直至有匹配的网络地址，而后在向下传递。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版权所有，未经允许，禁止转载。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 Dec 2017 15:25:00 +0000</pubDate>
<dc:creator>何必诗债换酒钱</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/backwords/p/7944780.html</dc:identifier>
</item>
<item>
<title>谈谈换行 - stoneniqiu</title>
<link>http://www.cnblogs.com/stoneniqiu/p/8017127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneniqiu/p/8017127.html</guid>
<description>[unable to retrieve full-text content]前几天表弟突然打电话给我说，经过四个月的学习Java，最近拿到了几个offer，不知道选哪家。一问，有老虎证券，摩拜单车，搜狐和滴滴。薪水都是2w+，年薪30万左右。其实这些都蛮不错，最后决定选择了滴滴。 说实话我蛮惊讶的，表弟是北航研究生，毕业两年一直做物联网婴儿方面的创业项目，但因种种原因项目没</description>
<pubDate>Sun, 10 Dec 2017 15:11:00 +0000</pubDate>
<dc:creator>stoneniqiu</dc:creator>
<dc:identifier>http://www.cnblogs.com/stoneniqiu/p/8017127.html</dc:identifier>
</item>
</channel>
</rss>