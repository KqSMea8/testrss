<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>动态实现空对象模式 - 饶春江</title>
<link>http://www.cnblogs.com/ideck/p/dynamicnullobject.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ideck/p/dynamicnullobject.html</guid>
<description>&lt;p&gt;您可以在 &lt;a href=&quot;https://github.com/raochunjiang/NetSharp.DynamicNullObject&quot;&gt;Github&lt;/a&gt; 上阅读本文。&lt;/p&gt;

&lt;h2 id=&quot;空对象模式&quot;&gt;空对象模式&lt;/h2&gt;
&lt;p&gt;关于空对象模式的介绍，请参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Null_object_pattern&quot;&gt;&lt;img src=&quot;https://en.wikipedia.org/static/favicon/wikipedia.ico&quot; alt=&quot;维基百科：空对象模式&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.baidu.com/s?ie=utf-8&amp;amp;f=8&amp;amp;rsv_bp=0&amp;amp;rsv_idx=1&amp;amp;tn=baidu&amp;amp;wd=%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F&amp;amp;rsv_pq=80715f4300009be3&amp;amp;rsv_t=0279BNGD7HqWS64dqZ5YH43khzfkbBnq1eKAhtpcS58rKow0eR74iJ%2FAMe0&amp;amp;rqlang=cn&amp;amp;rsv_enter=1&amp;amp;rsv_n=2&amp;amp;rsv_sug3=1&quot;&gt;&lt;img src=&quot;https://www.baidu.com/favicon.ico&quot; alt=&quot;百度一下：空对象模式&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里不对具体场景做样例描述，所以对场景做了抽象。&lt;/p&gt;
&lt;p&gt;动态空对象程序包是基于 .NET Standard 开发的，可在 .NET Core 和 .NET Framework 4.5+ 项目中引用/使用。&lt;/p&gt;
&lt;h2 id=&quot;场景类&quot;&gt;场景类&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public interface IFakeScenario
    {
        int ValueProperty { get; set; }

        object ReferenceProperty { get; set; }

        int GetValueObject();

        object GetReferenceObject();

        void SetObject(object obj);

        Task AsyncSetObject(object obj);

        Task&amp;lt;int&amp;gt; AsyncSetObjectReturnValue(object obj);

        Task&amp;lt;object&amp;gt; AsyncSetObjectReturnReference(object obj);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;添加动态空对象组件的引用&quot;&gt;添加动态空对象组件的引用&lt;/h2&gt;
&lt;p&gt;使用程序包管理控制台添加引用：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;install-package NetSharp.DynamicNullObject&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用程序包管理器添加引用：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;鼠标右键点击项目 =&amp;gt; 管理 NuGet 程序包 =&amp;gt; 浏览 =&amp;gt; 输入 NetSharp.DynamicNullObject =&amp;gt; 选择程序包 =&amp;gt; 安装&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其他方式请参考 NuGet 使用文档&lt;/p&gt;
&lt;h2 id=&quot;使用组件&quot;&gt;使用组件&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public static void Main(string[] args)
    {
        var emptyClassProvider = new EmptyClassProvider();

        var emptyClass = emptyClassProvider.GetEmptyClass&amp;lt;IFakeScenario&amp;gt;();
        var emptyObject = Activator.CreateInstance(emptyClass);
        var emptyScenario = (IFakeScenario)emptyObject;

        // 方法可正常调用,返回值是为对应类型的默认值
        emptyScenario.SetObject(&quot;这是一个对象&quot;);
        var value = emptyScenario.GetValueObject();
        Console.WriteLine(value == 0); // true
        var reference = emptyScenario.GetReferenceObject();
        Console.WriteLine(reference == null); // true

        // 异步方法总是返回一个异步操作，操作结果为对应类型的默认值
        var task = emptyScenario.AsyncSetObject(&quot;这是一个对象&quot;);
        Console.WriteLine(task.GetType() == typeof(Task&amp;lt;int&amp;gt;)); // true。对于无返回的任务，生成代码返回 Task.FromResult(0)

        var taskReturnValue = emptyScenario.AsyncSetObjectReturnValue(&quot;这是一个对象&quot;);
        Console.WriteLine(taskReturnValue.GetType() == typeof(Task&amp;lt;int&amp;gt;)); // true
        Console.WriteLine(taskReturnValue.Result == 0); // true

        var taskReturnObject = emptyScenario.AsyncSetObjectReturnReference(&quot;这是一个对象&quot;);
        Console.WriteLine(taskReturnObject.GetType() == typeof(Task&amp;lt;object&amp;gt;)); // true
        Console.WriteLine(taskReturnObject.Result == null); // true

        Action asyncAction = async () =&amp;gt;
        {
            // 异步操作是正常可等待的，异步结果为对应类型的默认值
            await emptyScenario.AsyncSetObject(&quot;这是一个对象&quot;);

            var returnValue = await emptyScenario.AsyncSetObjectReturnValue(&quot;这是一个对象&quot;);
            Console.WriteLine(returnValue == 0); // true

            var returnObject = await emptyScenario.AsyncSetObjectReturnReference(&quot;这是一个对象&quot;);
            Console.WriteLine(returnObject == null); // true
        };
        asyncAction();

        // 属性是语法糖,对应 getter、setter 两个方法
        emptyScenario.ValueProperty = 100;
        Console.WriteLine(emptyScenario.ValueProperty == 0); // true

        // 属性是语法糖,对应 getter、setter 两个方法
        emptyScenario.ReferenceProperty = new object();
        Console.WriteLine(emptyScenario.ReferenceProperty == null); // true

        Console.ReadKey();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;更多&quot;&gt;更多&lt;/h2&gt;
&lt;p&gt;请自行挖掘...&lt;/p&gt;
</description>
<pubDate>Sat, 28 Jul 2018 19:00:00 +0000</pubDate>
<dc:creator>饶春江</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ideck/p/dynamicnullobject.html</dc:identifier>
</item>
<item>
<title>码农的点滴，毕业一年，再见了我的毛主席！ - 张林-布莱恩特</title>
<link>http://www.cnblogs.com/zhangmumu/p/9384088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangmumu/p/9384088.html</guid>
<description>&lt;div id=&quot;wmd-preview-section-5&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;36.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;轻轻的我走了，正如我轻轻的来； &lt;br/&gt;这不是写诗，这是每个我们这些码农要离开的真实写照。 &lt;br/&gt;时间好快，来的时候是boss给我打电话，走的时候是我给boss打电话，两个电话两年就这样过去，这个月底就要离开北京，写点简单的东西，记录一下这两年点滴，希望过些年再看这篇文章的时候，还是能留下点回忆。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转眼间毕业一年多了，从16年6月到今天也已经工作两年了，没留下太多的东西，留下的可能是下一个进来的人吐槽“这代码是哪个sb写的”。 &lt;br/&gt;在这里整理一下工作两年的经历，顺便也做一个总结。措辞还是有点浮躁。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-6&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;42&quot;&gt;
&lt;h4 id=&quot;1回忆大学两年的点滴&quot;&gt;1.回忆大学两年的点滴：&lt;/h4&gt;
&lt;p&gt;时光荏苒，我是专科毕业，上学也就上两年，软件技术专业，学的东西比较少，没有什么理论的东西，就是前端（html+css+js）+asp.net web方面的东西，上课要做出东西然后提交，老师算是比较负责的，每学一门课程学完都要做出一个东西来，然后进行评比。在大学这两年记忆比较模糊，可能没有多少深刻的东西值得回忆的，选择性地遗忘。但是有两件事情还是记忆忧心， &lt;br/&gt;&lt;strong&gt;“假老板模式”&lt;/strong&gt;：刚进学校的那一半年，没有电脑，学的东西也tm不知道做什么的，有什么作用。什么word，什么ps，还有一些c#的基础语法，天天上课很懵逼，想敲代码也没办法，有点自暴自弃的感觉了，那时总想找点事情做，后来耳闻学校的寝室楼的四楼的同学小卖铺关闭了，然后我们就三个同学凑了三百块钱，进货就开干了，干了三天，各种原因两个就退出了，自身一人，还是要坚持下去，那时候14年的时候o2o还挺火，于是我也“o2o”，建了qq群，效果明显好了许多，qq群一叫，就送货上门，一个月还稳定收入3000+，“我此我日我擦我操”，人送外号“张老板”，这个有点讽刺的意味在里面，后来干了2个月，mp，被修水电的告到学校后勤那儿去，当时卖的东西太多，比较嚣张，钱赚得越多，胆子也大，零食摆满了整个桌子，，“我为鱼肉，人为刀俎”。结果当然是全部都没收了，毕竟在寝室搞小卖铺是不合理的存在，这件事对我的打击还是有一定的，同时也是我大学生涯的一个非常重要的转折点。 &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;“学生码农模式”&lt;/strong&gt;：那时候，还不知道码农的意义，还敢自称“程序员”，现在不敢了，最多也就码农。 &lt;br/&gt;不做老板以后的那几天，人比较焦虑，已经到了下半年了，也有了电脑，虽然前半年也就上课时间敲敲代码，属于那种混日子的状态。被“炒家”之后，非常不甘心，还是自己太弱了，那时候已经在学winform的增删改查了，落后比较多，只能从前面的学起了，寝室里虽然环境并不好，还好自己并不玩游戏，直到现在也是如此，可能兴趣爱好不一样，我只喜欢打篮球。看视频自己敲代码，学的东西并不难，也没有深度，花了时间就会有回报，winform的考试虽然比较简单就一个列表的增删改查，得到100分（满分哦），虽然一般只要写代码了，功能有就能七八十分，但是这种成就感就是这样一点点积累起来，这种成就感可能就是同学们都问你“这个怎么弄，你过来看看”，“实现了这个功能，perfect”，成就感积累到一定程度就会变成兴趣的自我驱动。后来的一年多时间基本上就没听讲了，课本的东西是那种培训机构的教材，并不是那种又厚又硬的理论课本知识，看视频和课本的概念都搞的懂。两年的学习问心无愧，该学的东西都学了，就这样转眼间就到要出去实习的时候了。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20180729022914793?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;想毛主席问好，毛主席再见！&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-7&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;45&quot;&gt;
&lt;h3 id=&quot;2刚工作的那会儿&quot;&gt;2.刚工作的那会儿&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;刚入行那会儿 &lt;/strong&gt;&lt;br/&gt;16年5月底就开始在找工作，在学校的时候都是就业老师一手操办，简历我都没投过，直接就是就业老师请外地的企业直接进教室来面试，或者远程面试，那时在学校面试过3家，一家是远程面试的（也就是目前北京的这家公司），一家是深圳的。深圳的那家公司几乎都没直接问问题，好像是赶时间要走，四个人坐一排开始了个人演讲自我装逼模式，问题问的不痛不痒。居然还要我了，当时接到通知也是挺懵逼的，感觉不靠谱，北京的boss打了一个电话说有意向，说很感动和诱惑，那时候太更多的选择，当然就直接选择了北京。&lt;/p&gt;
&lt;p&gt;6月15号和一起来北京的同学坐了16个小时的硬座火车来到北京，旅途很难受但对未来充满了憧憬和期待，可能这辈子都不会再想去坐这么久的硬座了。到的那天下着小雨，我记得很清楚，刚进公司那一刻，说实话有一种从天堂丢入地狱的感觉，差不多10个人左右，并没有想象中的那么“高大上”，那么“互联网”，给人一种无精打采，没有激情的感觉，虽然没过几天自己也完全“适应”了，实际上我是一个不修边幅的人。 &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;焦虑与无存在感 &lt;/strong&gt;&lt;br/&gt;刚工作那段时间，其实主要就是两个关键词“无存在感”，“焦虑”。虽然那时候看起来并不是很难，但是很多东西都是没接触了，不会做，做得慢，一个简单问题甚至都要问别人几次，导致内心焦虑，做的也是写简单鸡助的东西，看起来没有存在感。这些感受并没有让我失去自信，belive progress。机会总是给有准备的人，过了几个月完全适应了之后，老板交代一些网页，能够perfect完成，又慢慢找回那种成就感，当然现在已经不需要那种存在感了，&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-532&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;60.612313803376&quot;&gt;
&lt;h3 id=&quot;3关于工作上的问题&quot;&gt;3.关于工作上的问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;工作环境 &lt;/strong&gt;&lt;br/&gt;这是我第一份工作，工作时间倒是蛮开放的，早上9.30，晚上7.00中午2个小时，一周6天。在靠近五环，住的比较近，换了4个地方，三个地方被拆，真是住哪儿拆到哪儿，从最初的600多到现在1100，虽然还算便宜，环境不算太好，我也仅仅是把住的地方当成一个能睡觉的地方。平时上班都是骑车，买了一辆自行车，骑了半年，至于骑车自己也喜欢玩刺激动作，半年多报废了，后来花了50块钱买了辆二手的，一个多月也报废了，中间还把boss的50块钱的自行骑丢了，后来彻底不骑自己的了，换行骑ofo和摩拜了。 &lt;br/&gt;早上虽然9.30半上班，刚来那三个月，9点就来，后来人慢慢老油条了，现在已经是接近10点去了，当然我晚上回去的也比较晚。平时有什么事情跟leader说一声，就可以了。请假还是比较方便，管理也比较松散。 &lt;br/&gt;至于零食当然是管够了，有一点还是做的不够好，不注意个人卫生，自己的座位永远是最脏乱差的，这一点我要改正（可能改不了，可能别人也适应了不想多说）。 &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;项目上的问题 &lt;/strong&gt;&lt;br/&gt;虽然即将要离开，我也不会故意去吹嘘和抹黑。lz待的这家公司做的项目主要PC端和APP端的。当然还有其他比较牛逼、有创意的业务。 &lt;br/&gt;App端是采用xamarin android的，之前用xamarin android的博客园android app。 &lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zhangmumu/p/8146725.html&quot;&gt;博客园app for xamarin android&lt;/a&gt;，qq上有网友给我反应有比较多的问题，还是挺尴尬的，没时间去改了。曾经有人问我为什么用xamarin去做android,这用意何在？其实写过的人还是比较容易理解的，1.公司都是搞.net栈的技术2.客户也不需要ios端的东西。所以这两条理由已经足够充分了，虽然你还是得学习java android的那些东西，该花的时间还是得花的，java写的那些优秀的开源库，想拿来用也是可以的，虽然有的库绑定可能比较坑，随着技术的发展和开发人员的普及这个坑点已经越来越小了。&lt;/p&gt;
&lt;p&gt;虽然做的是传统软件，平时的工作要求也不高，主要实现功能为主，至于用户体验没有人会在乎，客户也并不在乎，自己测一测没问题就perfect，这个perfect你说尴尬不尴尬，你觉得“美如画”的东西，客户要指定颜色，脑补一下画面。这场景我回忆起来到如今我到忍俊不禁。&lt;/p&gt;
&lt;p&gt;PC端的web是用asp.net mvc的模式，用的Kendo UI的一套框架，虽然实施人员已经多次吐槽用户体验差，这一点比较操蛋，我这个人容易审美疲劳，这个pc端的用户体验10分的话，我给6分左右。毕竟不是做互联网的产品，不是给大众用户使用，用户体验并没有那么高，传统软件“美如画”很难得！ &lt;br/&gt;至于APP端那是个积重难返的问题，如果10分的话，我可以很客观地给4分， &lt;br/&gt;1.控件命名、变量、方法、文件命名能把人带坑里去，a，b，c，1，2，3的什么都有，要啥有啥，有啥来啥，各种花活，想来就来，来了就干，干就完了。客观地将我也曾做这种为所欲为的事情，毕竟经验太少，如果现在让我做，肯定是要有一个命名的规范。 &lt;br/&gt;2.列表的adapter有100多个，很多东西写的有错误的、没有优化地方，n个人写n个，写的也不好，完全可以用一个开源的。 &lt;br/&gt;3.每个页面主题都不一样，想用什么主题就用什么。导致看起来各种花样，极其不协调，毕竟使用用户年龄比较大，改了字体都是写死的，积重难返，没办法改 &lt;br/&gt;4，activity、fragment的有的代码都有一千多行，没办法一个模式都没有，有多少就写多少，实际上并没有复杂的功能，这个是历史问题，不想多说 &lt;br/&gt;5.充满了static的集合，功能没多少，运行起来200多MB，还经常闪退，网络差还掉线，android中慎用static，用static的地方也是东施效颦，仅仅只是传值方便。 &lt;br/&gt;只可惜现在还是这样，估计以后可能会有新的伙伴做出更好的了。 &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;至于离职 &lt;/strong&gt;&lt;br/&gt;非常感谢曾经帮助我的boss、leader、同事们，在为人处世和技术方便，学习到了很多。还是打算继续做xamarin，毕竟这里花了时间，如果不坚持下去，有一种徒劳而费的意思，虽然目前个人能力还不足以独挡多面，我任然坚信“机会是给有准备的人”，时间会给我答案，毕竟90后在多年以后成为中流砥柱。时间也不早了，这是我在这里的最后一篇。时间不早， &lt;br/&gt;给自己一写勉励吧：不断学习，保持激情和兴趣，多年以后不会是现在一样随波逐流，而是独挡多面（有点装逼过度了，不然就打脸了）&lt;/p&gt;

&lt;p&gt;此情此景还是吟诗一首吧：&lt;/p&gt;
&lt;p&gt;我敲敲地来，悄悄地走，从一个地方到另一个地方，继续做码农，但是这和毛主席并没有任何关系，再见，毛主席！&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 28 Jul 2018 18:40:00 +0000</pubDate>
<dc:creator>张林-布莱恩特</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangmumu/p/9384088.html</dc:identifier>
</item>
<item>
<title>论自动化如何提高测试工作效率 - jack.cx</title>
<link>http://www.cnblogs.com/Jack-cx/p/9383990.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jack-cx/p/9383990.html</guid>
<description>&lt;p&gt;首先在我看来，自动化是必定会提升工作效率的。之前其实我也认为自动化是没有用的，现在想想，只是无知限制了我的思路&lt;/p&gt;

&lt;p&gt;总结下我经常遇到的场景吧~&lt;/p&gt;
&lt;p&gt;1.重复工作较多&lt;/p&gt;
&lt;p&gt;.之前和同事工作中扯淡，他在做一个功能测试，但是仅仅是因为加了一个功能点却要回归下之前不少测试用例，回归可能还好说，但是测试流程比较复杂，然后就聊到了自动化实现，这样重复工作很多，我和他聊到和自动化可以实现，作为业务测试的他对自动化可能不是很清楚，他说不是很清楚是否能实现。其实我想表达的是团队的磨合，如果真的日常工作重复工作很多，我觉得有必要和测试负责人聊下，看是否能解决，这是单方面，测试经理也应该经常和组员聊下日常工作遇到的问题，答疑解惑。若这样的重复工作太多，没人去解决问题。需求经常延期，我觉得因为这个原因加班并非需求多，而是因为管理层能力不足而加班的。&lt;/p&gt;

&lt;p&gt;2.录制性自动化繁琐&lt;/p&gt;
&lt;p&gt;   通过录制做自动化其实我是接触不多的，在我刚干测试时团队就是直接写脚本实现关键字驱动,这样只要按照测试模板填写关键字即可的，今年碰到了现有公司用的是selenium自带的录制工作，但是看了他们的实现方式，得先录制再概改脚本这样实现，不是很灵活，如果用脚本封装selenium库只要填参数，对比下，方便很多又省事了一些，所以这点我觉得是公司在这个领域还是稍有写薄落，导致功能测试人员写自动化用例繁琐了一些，那么怎么还能让功能测试依赖这套东西提高效率呢？&lt;/p&gt;

&lt;p&gt;3.管理层不注重自动化&lt;/p&gt;
&lt;p&gt;这个点其实没什么好说的，靠的是测试负责人的个人魅力和说服力，以及能够利用自动化提高效率，这样有产出，管理层正常对高效率和质量保证还是比较看重的，如果拿出产出，管理层还是不支持，那么对技术有所追求的我觉得在该公司个人能力到达瓶颈后，有必要重新找个管理方面还算可以的公司。&lt;/p&gt;

&lt;p&gt;扯了不少，现在我以我的认知设计了自动化怎么嵌入到测试流程提高效率吧~~&lt;/p&gt;
&lt;p&gt;1.自动化属于测试策略的一种，是否要开展自动化决定于公司是否存在自动化需求，比如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327198/201807/1327198-20180728231944080-929135808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，业务上存在了自动化的需求了，测试开发人员直接写脚本吗？？？还不至于，脚本是给所有业务测试包括自己使用的，应该更让别人知道怎么实现或者逻辑怎么窜通的，这个需要和当时人(业务测试人员)讨论的，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327198/201807/1327198-20180728233104869-77854530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;1.框架选择，首先目前还是开源框架用的比较多，单元测试框架: python的unittest\pytest或者java的juint\testng  GUI开源工具 robot都可以根据现有团队的认知选择&lt;/p&gt;
&lt;p&gt;2.用例模板设计，目前我的实现还是通过excel去实现关键字驱动的，这个可以和业务测试人员定义一下关键字命名和传参&lt;/p&gt;
&lt;p&gt;3.收集场景关键字，如果脚本开发的测试只在测试某个系统，但是公司业务系统较多，这样业务测试可以和说下负责的系统有什么特殊的控件（其实就是，点击，输入，js弹窗，悬浮。iframe的切换，下拉框，时间控件不可输入等）以及每个系统用的什么数据库mysql,oracle.mongodb这样脚本开发人员可以提前写好这些方法，这样就减少了后期遇到再修改脚本的可能性，&lt;/p&gt;
&lt;p&gt;4.定义建议至少两位脚本开发的人员，这样至少在遇到问题可以讨论以及在前期解决业务测试人员不可避免遇到的一些问题，这样业务测试会明确出了问题可以找谁&lt;/p&gt;
&lt;p&gt;基本脚本设计需求已经定义好了，这样脚本可以开发了&lt;/p&gt;

&lt;p&gt;当脚本写完后，需要定义自动化如何潜入到测试流程，提高效率&lt;/p&gt;
&lt;p&gt;1.首先自动化用例的编写必然会占用工作，排期必须要让出时间，前期会占时间比较多，其实前期工作量只是在补现有功能之前一直没有做的东西，往后自动化用例会少了很多，占排期也会越来越少&lt;/p&gt;
&lt;p&gt;2.依赖自动化成为工作的一部分，例如这周一到周四测的功能，把一轮测试完的功能自动化用例写起来，一轮测完，开发必然会改bug再发个版本，无bug也没关系，不影响流程，这时候，执行写好的自动化测试用例回归二轮，二轮无bug，待发生产即可，既然说了把自动化当作工作的一部分，那么过程必然磕磕绊绊会有些问题，自己定义一个解决问题的时间，10分子或5分钟未解决，找脚本开发人员解决，这一个过程其实就是不停的提升脚本的健壮性，时间越长，健壮性越强，这样在后面的工作中，有了前期的铺垫，后面有相应的功能就可以省了不少时间&lt;/p&gt;
&lt;p&gt;3.还有个问题是前端元素会经常改动，这个确实是个问题，先说下两个解决方式吧，第一个是在编写测试用例的时候，不同的用例前期必然会出现重复步骤的，这样单独写个用例出来，让主要的业务逻辑的用例继承这个重复步骤的用例，这样目的可以减少用例的修改数，还有一个是定期维护，在下次版本编写用例时维护好报错的用例，注意这个定义维护只放在下次用例编写自动化用例的排期中，定义时间是因为这次版本是运行没问题的，那么投产后验证也没有问题，之后测试环境新增功能迫害了元素，不用管，虽然失败但是流程不能乱，放在下次自动化用例编写还有个原因是之前已经做了自动化铺垫，那么这次版本必然会少工作量，加上维护失败的用例，这样工作量饱和了，当然我觉得元素改动没那么夸张到大批量都死掉，这只能说明元素定位方式需要改进，不增加开发很多工作量的情况下或与开发配合&lt;/p&gt;

&lt;p&gt;4. 还有一点，前期自最好不要让加班写自动化用例，这样会给测试某种程度带来负面情绪，前期还得给出排期，不给排期做自动化，我觉得测试很难把自动化当做工作的一部分，&lt;/p&gt;
&lt;p&gt;自动化就像一个投资，虽然有风险但是收益是客观的，当然是在理智的前提投资，自动化流程的设计就是一个理智的分析再投入实践。&lt;/p&gt;

&lt;p&gt;5.再插一点吧，有些公司测试是各干各的情况，就是一个人负责某个系统，那么功能和自动化都是这个人负责，自己的工作量自己想办法解决还是不错的，效果好，其他测试必然效仿，这种方式我觉得还是不错的，但是现况普遍有岗位是稳定单干某个系统的吧 所以还是得全局考虑...&lt;/p&gt;

&lt;p&gt;不知不觉扯到现在，算是接触了一年自动化的一些感受吧&lt;/p&gt;

</description>
<pubDate>Sat, 28 Jul 2018 16:19:00 +0000</pubDate>
<dc:creator>jack.cx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jack-cx/p/9383990.html</dc:identifier>
</item>
<item>
<title>LeetCode——两数之和 - tosser</title>
<link>http://www.cnblogs.com/tosser/p/9383986.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tosser/p/9383986.html</guid>
<description>&lt;p&gt;　　最近在家拧三阶魔方，把初级的玩法掌握了，也就是可以还原六个面了，速度不快，但是也很兴奋。三阶魔方的初级玩法按照套路拧就可以了，每一步需要完成的任务，该步骤转动的方法基本都是固定的，而且变化也并不是特别多。只要按照套路多练习，不考虑速度的情况下还原一个三阶魔方还是很容易的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/892439/201807/892439-20180729000722738-806869644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　编程入门和还原魔方其实差不多，最初也是掌握套路后反复的练习，先从一个生手变成一个熟手，然后再去提高。分享一个段子，在知乎上看到的，如下：&lt;/p&gt;
&lt;p&gt;　　陈康肃公尧咨善射，当世无双，公亦以此自矜。尝射于家圃，有卖油翁释担而立，睨之，久而不去。见其发矢十中八九，但微颔之。&lt;br/&gt;　　康肃问曰：“汝亦知射乎？吾射不亦精乎？”翁曰：“无他，但手熟尔。”康肃忿然曰：“尔安敢轻吾射！”翁曰：“以我酌油知之。”乃取一葫芦置于地，以钱覆其口，徐以杓酌油沥之，自钱孔入，而钱不湿。因曰：“我亦无他，惟手熟尔。”康肃笑而遣之。 &lt;/p&gt;


&lt;p&gt;LeetCode 题库的第一题——两数之和&lt;/p&gt;
&lt;p&gt;　　我先找了一些简单而又比较好完成的题去完成，而且一定要是自己独立完成，且直接在 LC 上写代码，不去开发环境中写代码调试，这样才有提高。题目如下图，直接从网站上把图截取过来的。&lt;/p&gt;

&lt;div readability=&quot;19.5&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/892439/201807/892439-20180729000955247-14349013.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;解题答案&lt;/p&gt;
&lt;p&gt;　　我的解题答案是用 C 语言完成的，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Note: The returned array must be malloced, assume caller calls free().
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;* twoSum(&lt;span&gt;int&lt;/span&gt;* nums, &lt;span&gt;int&lt;/span&gt; numsSize, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; target) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, j;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; *pArr =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; numsSize; i ++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; ( j = i + &lt;span&gt;1&lt;/span&gt;; j &amp;lt; numsSize; j ++&lt;span&gt;  ) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ( nums[i] + nums[j] ==&lt;span&gt; target ) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; EXIT;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;EXIT:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ( i &amp;lt; numsSize &amp;amp;&amp;amp; j &amp;lt;&lt;span&gt; numsSize ) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         pArr = (&lt;span&gt;int&lt;/span&gt;*)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt; * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         pArr[&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         pArr[&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    } 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pArr;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　函数的原型是LeetCode已经定义好的，最上面的注释也是LeetCode中的，代码的思路也比较简单，两层循环来进行逐个的进行 加法 运算，计算获得 target 值之后用 goto 直接跳出两层循环（ C 语言&lt;strong&gt;不建议&lt;/strong&gt;使用 goto 语句，但是并没有说不允许使用，直接结构清楚，goto 用来跳出多层嵌套是很方便的），然后通过 &lt;strong&gt;堆空间&lt;/strong&gt; 来把数组的两个下标返回，类似的很多题都是通过堆空间来返回值的。&lt;/p&gt;

&lt;p&gt;　　把自己的答案分享在这里，献丑了，也许哪个大牛指点一下还会提高一下。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 28 Jul 2018 16:18:00 +0000</pubDate>
<dc:creator>tosser</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tosser/p/9383986.html</dc:identifier>
</item>
<item>
<title>【数据结构】【平衡树】Treap - 一扶苏一</title>
<link>http://www.cnblogs.com/yifusuyi/p/9383962.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yifusuyi/p/9383962.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E6%A0%91/7641279?fr=aladdin&quot; target=&quot;_blank&quot;&gt;百度百科&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Pre_knowledge&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/10905079?fr=aladdin&quot; target=&quot;_blank&quot;&gt;二叉排序树&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　二叉排序树是一棵二叉树。每个节点对应一个权值v，对于每个节点，一定满足如下性质：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　二叉排序树的每个节点的左子树要么为空，要么左子树的任意节点的权值v'一定小于v。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　二叉排序树的每个节点的有子树要么为空，要么右子树的任意节点的权值v'一定大于v。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　二叉排序树的节点：每个节点维护如下信息：该点代表的权值，该点的左右儿子，以该点为根的子树含有元素的个数(不等于子树大小。因为两个相同的元素被认为含有两个元素，但是对应的节点只有一个），该点代表的权值的元素的个数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　二叉排序树的插入：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　对于要插入的值key，比较他与当前节点的权值v关系，如果v&amp;gt;key，则递归插入左子树，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　否则，如果v==key，则插入当前节点，即++该点元素个数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　否则，递归插入右子树。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　二叉排序树的删除：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　递归过程同上。- - 该点元素个数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;Definition&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　Treap=tree+heap，直译树堆。在形态上，他是一颗BST，即二叉排序树。同时，由于二叉排序树的插入方式过于朴素，导致给出具有单调性的数据后会被卡成一条链，任何操作的复杂度从期望&lt;strong&gt;&lt;span&gt;O(nlogn)&lt;/span&gt;&lt;/strong&gt;上升到&lt;strong&gt;&lt;span&gt;O（n&lt;sup&gt;2&lt;/sup&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;。为了防止毒瘤出题人造出卡死二叉排序树的数据，我们选择&lt;span&gt;使用魔法打败魔法&lt;/span&gt;使用随机化的方法将树的形态按照一定的法则随机转化，防止出现卡出链的情况。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　为了转化树形，我们人为地给每个节点加入一个权值k，强制要求对于每两个有父子关系的节点，父节点的k值小于(大于)子节点。并使用一系列的&lt;span&gt;魔法&lt;/span&gt;旋转方式保证树符合这个性质。在旋转的过程中，我们改变了树高，从而改变了整个树的形态。由于父子节点有严格的大小关系，我们说treap具有堆得性质。但是需要指出的是，堆一定是一颗完全二叉树，但treap不满足此性质。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　复杂度：在期望意义下，treap的树高为&lt;strong&gt;&lt;span&gt;logn&lt;/span&gt;&lt;/strong&gt;，所以treap的期望时间复杂度为&lt;span&gt;&lt;strong&gt;O(nlogn)&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　功能：查询一个序列中第k大的数；通过加入、删除维护该序列；查询序列中一个数x的前驱、后继。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　操作：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　1、插入。同二叉排序树。注意每次插入完进行update，同时尝试旋转。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　2、旋转。（注：习惯问题，和江湖上流行的左右旋方向恰好相反）通过左旋和右旋，可以将树转化成满足堆性质的BST。以右旋为例：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414323/201807/1414323-20180728232650699-1701246111.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　可以看到，右旋时，老根、新根左移。新老根儿子的信息被改变。他们儿子的信息不被改变。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　定理：对于每次递归，最多旋转一次。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　证明：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　由于插入一定会插入到叶节点，在叶节点时显然该子树是一颗合法的树。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　不妨设左右两颗子树均合法，考虑如果出现中间节点不合法的情况，一定是有一侧经过了旋转转换了根。由于不可能同时递归左右两棵子树，所以另一侧的子树一定相对于中间节点合法。在旋转的过程中不难发现合法的一侧其节点相对位置是不变的，即仅交换了不合法的一对的位置，所以只会旋转一次。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　证毕。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　查询：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　序列第K大：如果左子树的size大于k，则递归左子树&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　　　　　　 否则如果左子树的size加上根节点的元素个数大于等于k，则返回当前节点的v&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　　　　　　　否则递归查找右子树的k-左子树size-根节点size。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　3、删除。　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　删除时，如果该节点对应size&amp;gt;1，则- -size，否则将其权值k赋为INF，通过比较左右子树k的大小决定谁做新的根，经过不断的左右旋转将其沉到叶节点。然后将该节点父节点的指针清空。这样就完成了删除。在数组版的treap中，这么做会产生内存泄漏问题，不过问题不大（逃）如有需要可以手写内存池。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　4、前驱、后继。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　一个数x的前驱定义为小于这个数的最大的数。递归整棵树，递归过程如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　　　如果当前节点为空，返回—INF。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　　　否则，如果当前节点的v&amp;lt;x 则返回max(v,递归当前节点的右子树)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　　　否则返回当前节点左子树的递归值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　后继同理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3369&quot; target=&quot;_blank&quot;&gt;【lgP3369】 普通平衡树&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Description&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;插入 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;x 数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;删除 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;x 数(若有多个相同的数，因只删除一个)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;查询 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;x 数的排名(排名定义为比当前数小的数的个数 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;+1&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord&quot;&gt; 。若有多个相同的数，因输出最小的排名)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;查询排名为 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;x&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt; 的数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;求 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;x 的前驱(前驱定义为小于 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;x ，且最大的数)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;求 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;x 的后继(后继定义为大于 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;x ，且最小的数)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;Input&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;第一行为 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;n ，表示操作的个数,下面 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;n&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;n 行每行有两个数 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;opt&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt; 和 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;x ， &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;o&lt;span class=&quot;mord mathit&quot;&gt;p&lt;span class=&quot;mord mathit&quot;&gt;t 表示操作的序号( &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;span class=&quot;mrel&quot;&gt;≤&lt;span class=&quot;mord mathit&quot;&gt;o&lt;span class=&quot;mord mathit&quot;&gt;p&lt;span class=&quot;mord mathit&quot;&gt;t&lt;span class=&quot;mrel&quot;&gt;≤&lt;span class=&quot;mord&quot;&gt;6 )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Output&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;对于操作 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;3,4,5,6&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord&quot;&gt;3&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord&quot;&gt;4&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord&quot;&gt;5&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord&quot;&gt;6 每行输出一个数，表示对应答案&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Sample Input&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;106465&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;317721&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;460929&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;644985&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;84185&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;89851&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;81968&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;492737&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;493598&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;Sample Output&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;106465&lt;/span&gt;
&lt;span&gt;84185&lt;/span&gt;
&lt;span&gt;492737&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;Hint&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1.n的数据范围：&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;n&lt;span class=&quot;mrel&quot;&gt;≤&lt;span class=&quot;mord&quot;&gt;1&lt;span class=&quot;mord&quot;&gt;0&lt;span class=&quot;mord&quot;&gt;0&lt;span class=&quot;mord&quot;&gt;0&lt;span class=&quot;mord&quot;&gt;0&lt;span class=&quot;mord&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.每个数的数据范围：&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;strut bottom&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord&quot;&gt;−&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;span class=&quot;mord&quot;&gt;0&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot;&gt;&lt;span&gt;&lt;span class=&quot;pstrut&quot;&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;span class=&quot;mord&quot;&gt;0&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot;&gt;&lt;span&gt;&lt;span class=&quot;pstrut&quot;&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;span class=&quot;mclose&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Solution&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;模板题。代码拆分如下：&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1、定义：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; BST {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v,k,ls,rs,sm,sz,fa;
    BST() {v&lt;/span&gt;=-INF;k=INF;ls=rs=fa=-&lt;span&gt;1&lt;/span&gt;;sm=sz=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;}
};
BST treap[maxn];int tsz;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，v代表键值，k代表权值（即随机给定的值），ls、rs为左右儿子的下标，sm=same即键值为v的元素个数。sz=size为以该节点为根的子树大小。fa♂为父节点。构造函数上，注意初始化sm=sz=0可以保证程序鲁棒。tsz=totalsize，代表当前用到的最大数组下标。&lt;/p&gt;
&lt;p&gt;2、声明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; T_begin();
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; lftun(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; rtun(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; turnning(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; rememory(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; buildnew(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; addthis(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dltthis(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; build(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dlt(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rak(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ask_rak(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ask_upper(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ask_lower(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只是给你体验一下他的恐怖&lt;/p&gt;
&lt;p&gt;3、初始化&lt;/p&gt;
&lt;p&gt;　　添加一个键值超级大权值超级小的点作为超级根，所有的函数都将从超级根开始向下递归。真正的BST是超级根的左子树。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;void&lt;/span&gt;&lt;span&gt; T_begin() {
    treap[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].v=INF;treap[&lt;span&gt;0&lt;/span&gt;].k=-INF;treap[&lt;span&gt;0&lt;/span&gt;].sz=treap[&lt;span&gt;0&lt;/span&gt;].sm=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、添加点&lt;/p&gt;
&lt;p&gt;核心函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; now,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v==-INF) {buildnew(now,v);&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;}
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v==v) {addthis(now);&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;}
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v&amp;gt;&lt;span&gt;v) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.ls==-&lt;span&gt;1&lt;/span&gt;) t.ls=++tsz,treap[tsz].fa=&lt;span&gt;now;
        add(t.ls,v);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.rs==-&lt;span&gt;1&lt;/span&gt;) t.rs=++tsz,treap[tsz].fa=&lt;span&gt;now;
        add(t.rs,v);
    }
    turnning(now);
    rememory(now);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，now代表当前节点的下标，v代表要添加的值。&lt;/p&gt;
&lt;p&gt;其中有++size的语句为新开节点存储该元素。&lt;/p&gt;
&lt;p&gt;其中buildnew函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;void&lt;/span&gt; buildnew(&lt;span&gt;int&lt;/span&gt; now,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    t.v&lt;/span&gt;=v;t.sm=&lt;span&gt;1&lt;/span&gt;;t.sz=&lt;span&gt;1&lt;/span&gt;;t.k=&lt;span&gt;rand();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;addthis函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;void&lt;/span&gt; addthis(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; now) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;++t.sm;++&lt;span&gt;t.sz;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个函数分别对应当前的树上有v对应的节点和没有v对应的节点。&lt;/p&gt;
&lt;p&gt;代码中tunning函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;void&lt;/span&gt; turnning(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; now) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((t.ls!=-&lt;span&gt;1&lt;/span&gt;)&amp;amp;&amp;amp;(t.k&amp;gt;&lt;span&gt;treap[t.ls].k)) lftun(now);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((t.rs!=-&lt;span&gt;1&lt;/span&gt;)&amp;amp;&amp;amp;(t.k&amp;gt;&lt;span&gt;treap[t.rs].k)) rtun(now);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中，如果左儿子小，那么右儿子一定合法，进行左旋lftun：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;void&lt;/span&gt; lftun(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; now) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; f=t.fa,newrt=&lt;span&gt;t.ls;
    t.ls&lt;/span&gt;=treap[newrt].rs;&lt;span&gt;if&lt;/span&gt;(treap[newrt].rs!=-&lt;span&gt;1&lt;/span&gt;) treap[treap[newrt].rs].fa=&lt;span&gt;now;
    t.fa&lt;/span&gt;=newrt;treap[newrt].rs=&lt;span&gt;now;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(treap[f].ls==now) treap[f].ls=newrt,treap[newrt].fa=&lt;span&gt;f;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; treap[f].rs=newrt,treap[newrt].fa=&lt;span&gt;f;
    rememory(now);rememory(newrt);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　反之，如果右儿子小，进行右旋rtun：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;void&lt;/span&gt; rtun(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; now) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; f=t.fa,newrt=&lt;span&gt;t.rs;
    t.rs&lt;/span&gt;=treap[newrt].ls;&lt;span&gt;if&lt;/span&gt;(treap[newrt].ls!=-&lt;span&gt;1&lt;/span&gt;) treap[treap[newrt].ls].fa=&lt;span&gt;now;
    t.fa&lt;/span&gt;=newrt;treap[newrt].ls=&lt;span&gt;now;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(treap[f].ls==now) treap[f].ls=newrt,treap[newrt].fa=&lt;span&gt;f;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; treap[f].rs=newrt,treap[newrt].fa=&lt;span&gt;f;
    rememory(now);rememory(newrt);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面三个函数中出现的的rememory函数相当于江湖上的update：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;void&lt;/span&gt; rememory(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; now) {
    BST &lt;/span&gt;&amp;amp;t=treap[now];t.sz=&lt;span&gt;t.sm;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.ls!=-&lt;span&gt;1&lt;/span&gt;) t.sz+=&lt;span&gt;treap[t.ls].sz;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.rs!=-&lt;span&gt;1&lt;/span&gt;) t.sz+=&lt;span&gt;treap[t.rs].sz;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，不管是否旋转，当前节点都需要rememory。同时，由于旋转以后now成为了新根newrt的子节点，所以需要先rememory(now)，再rememory（newrt）。因为新根的信息需要用到now。&lt;/p&gt;
&lt;p&gt;5、删除&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; dlt(&lt;span&gt;int&lt;/span&gt; now,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v==v) {dltthis(now);&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;}
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v&amp;gt;&lt;span&gt;v) dlt(t.ls,v);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; dlt(t.rs,v);
    rememory(now);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中dltthis函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;void&lt;/span&gt; dltthis(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; now) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.sm!=&lt;span&gt;1&lt;/span&gt;) --t.sz,--&lt;span&gt;t.sm;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; endthis(now);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果当前节点只有一个元素，则将这个节点彻底删除，调用endthis：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; endthis(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; now) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    t.k&lt;/span&gt;=&lt;span&gt;INF;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((t.ls!=-&lt;span&gt;1&lt;/span&gt;)||(t.rs!=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.ls!=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.rs!=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(treap[t.ls].k&amp;lt;&lt;span&gt;treap[t.rs].k) lftun(now);
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; rtun(now);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; lftun(now);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; rtun(now);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(treap[t.fa].ls==now) treap[t.fa].ls=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; treap[t.fa].rs=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=t.fa;i!=-&lt;span&gt;1&lt;/span&gt;;i=&lt;span&gt;treap[i].fa) {
        rememory(i);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意由于我们可能修改了从根节点到叶节点的一条链，所以end以后需要整条途径新型rememory。&lt;/p&gt;
&lt;p&gt;6、查询第k大&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; rak(&lt;span&gt;int&lt;/span&gt; now,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v==k) &lt;span&gt;return&lt;/span&gt; treap[t.ls].sz+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v&amp;gt;k) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rak(t.ls,k);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; rak(t.rs,k)+treap[t.ls].sz+&lt;span&gt;t.sm;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7、查询值为k的数的排名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; ask_rak(&lt;span&gt;int&lt;/span&gt; now,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(treap[t.ls].sz&amp;gt;=k) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ask_rak(t.ls,k);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s=treap[t.ls].sz+&lt;span&gt;t.sm;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s&amp;gt;=k) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t.v;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ask_rak(t.rs,k-&lt;span&gt;s);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8、查询x的前驱&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; ask_upper(&lt;span&gt;int&lt;/span&gt; now,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(now==-&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;INF;
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v&amp;lt;k) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mmax(t.v,ask_upper(t.rs,k));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ask_upper(t.ls,k);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;9、查询x的后继&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; ask_lower(&lt;span&gt;int&lt;/span&gt; now,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(now==-&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; INF;
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v&amp;gt;k) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mmin(t.v,ask_lower(t.ls,k));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ask_lower(t.rs,k);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;Code&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;99&quot;&gt;
&lt;pre&gt;
#include&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstdlib&amp;gt;
&lt;span&gt;#define&lt;/span&gt; maxn 100010
&lt;span&gt;#define&lt;/span&gt; INF 20000020&lt;span&gt;

inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; qr(&lt;span&gt;int&lt;/span&gt; &amp;amp;&lt;span&gt;x) {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; ch=getchar(),lst=&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(ch&amp;gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;||ch&amp;lt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) lst=ch,ch=&lt;span&gt;getchar();
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(ch&amp;gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;amp;&amp;amp;ch&amp;lt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) x=(x&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+(x&amp;lt;&amp;lt;&lt;span&gt;3&lt;/span&gt;)+(ch^&lt;span&gt;48&lt;/span&gt;),ch=&lt;span&gt;getchar();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(lst==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) x=-&lt;span&gt;x;
}

template &lt;/span&gt;&amp;lt;typename T&amp;gt;&lt;span&gt;
inline T mmax(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; T &amp;amp;a,&lt;span&gt;const&lt;/span&gt; T &amp;amp;b) {&lt;span&gt;if&lt;/span&gt;(a&amp;gt;b) &lt;span&gt;return&lt;/span&gt; a;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;}
template &lt;/span&gt;&amp;lt;typename T&amp;gt;&lt;span&gt;
inline T mmin(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; T &amp;amp;a,&lt;span&gt;const&lt;/span&gt; T &amp;amp;b) {&lt;span&gt;if&lt;/span&gt;(a&amp;lt;b) &lt;span&gt;return&lt;/span&gt; a;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;}
template &lt;/span&gt;&amp;lt;typename T&amp;gt;&lt;span&gt;
inline T mabs(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; T &amp;amp;a) {&lt;span&gt;if&lt;/span&gt;(a&amp;gt;=&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; a;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;a;}

template &lt;/span&gt;&amp;lt;typename T&amp;gt;&lt;span&gt;
inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; mswap(T &amp;amp;a,T &amp;amp;b) {T temp=a;a=b;b=&lt;span&gt;temp;}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,a,b,tsz;

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; BST {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v,k,ls,rs,sm,sz,fa;
    BST() {v&lt;/span&gt;=-INF;k=INF;ls=rs=fa=-&lt;span&gt;1&lt;/span&gt;;sm=sz=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;}
};
BST treap[maxn];

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; T_begin();
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; lftun(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; rtun(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; turnning(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; rememory(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; buildnew(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; addthis(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dltthis(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; build(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dlt(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rak(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ask_rak(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ask_upper(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ask_lower(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    srand(&lt;/span&gt;&lt;span&gt;71806291&lt;/span&gt;&lt;span&gt;);
    qr(n);
    T_begin();
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(n--&lt;span&gt;) {
        a&lt;/span&gt;=b=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;qr(a);qr(b);
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(a) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:
                add(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,b);&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:
                dlt(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,b);&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;:
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,rak(&lt;span&gt;0&lt;/span&gt;,b));&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;:
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,ask_rak(&lt;span&gt;0&lt;/span&gt;,b));&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;:
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,ask_upper(&lt;span&gt;0&lt;/span&gt;,b));&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;:
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,ask_lower(&lt;span&gt;0&lt;/span&gt;,b));&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; T_begin() {
    treap[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].v=INF;treap[&lt;span&gt;0&lt;/span&gt;].k=-INF;treap[&lt;span&gt;0&lt;/span&gt;].sz=treap[&lt;span&gt;0&lt;/span&gt;].sm=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; buildnew(&lt;span&gt;int&lt;/span&gt; now,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    t.v&lt;/span&gt;=v;t.sm=&lt;span&gt;1&lt;/span&gt;;t.sz=&lt;span&gt;1&lt;/span&gt;;t.k=&lt;span&gt;rand();
}

inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; lftun(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; now) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; f=t.fa,newrt=&lt;span&gt;t.ls;
    t.ls&lt;/span&gt;=treap[newrt].rs;&lt;span&gt;if&lt;/span&gt;(treap[newrt].rs!=-&lt;span&gt;1&lt;/span&gt;) treap[treap[newrt].rs].fa=&lt;span&gt;now;
    t.fa&lt;/span&gt;=newrt;treap[newrt].rs=&lt;span&gt;now;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(treap[f].ls==now) treap[f].ls=newrt,treap[newrt].fa=&lt;span&gt;f;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; treap[f].rs=newrt,treap[newrt].fa=&lt;span&gt;f;
    rememory(now);rememory(newrt);
}

inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; rtun(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; now) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; f=t.fa,newrt=&lt;span&gt;t.rs;
    t.rs&lt;/span&gt;=treap[newrt].ls;&lt;span&gt;if&lt;/span&gt;(treap[newrt].ls!=-&lt;span&gt;1&lt;/span&gt;) treap[treap[newrt].ls].fa=&lt;span&gt;now;
    t.fa&lt;/span&gt;=newrt;treap[newrt].ls=&lt;span&gt;now;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(treap[f].ls==now) treap[f].ls=newrt,treap[newrt].fa=&lt;span&gt;f;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; treap[f].rs=newrt,treap[newrt].fa=&lt;span&gt;f;
    rememory(now);rememory(newrt);
}

inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; turnning(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; now) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((t.ls!=-&lt;span&gt;1&lt;/span&gt;)&amp;amp;&amp;amp;(t.k&amp;gt;&lt;span&gt;treap[t.ls].k)) lftun(now);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((t.rs!=-&lt;span&gt;1&lt;/span&gt;)&amp;amp;&amp;amp;(t.k&amp;gt;&lt;span&gt;treap[t.rs].k)) rtun(now);
}

inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; rememory(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; now) {
    BST &lt;/span&gt;&amp;amp;t=treap[now];t.sz=&lt;span&gt;t.sm;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.ls!=-&lt;span&gt;1&lt;/span&gt;) t.sz+=&lt;span&gt;treap[t.ls].sz;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.rs!=-&lt;span&gt;1&lt;/span&gt;) t.sz+=&lt;span&gt;treap[t.rs].sz;
}

inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; addthis(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; now) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;++t.sm;++&lt;span&gt;t.sz;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; endthis(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; now) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    t.k&lt;/span&gt;=&lt;span&gt;INF;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((t.ls!=-&lt;span&gt;1&lt;/span&gt;)||(t.rs!=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.ls!=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.rs!=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(treap[t.ls].k&amp;lt;&lt;span&gt;treap[t.rs].k) lftun(now);
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; rtun(now);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; lftun(now);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; rtun(now);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(treap[t.fa].ls==now) treap[t.fa].ls=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; treap[t.fa].rs=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=t.fa;i!=-&lt;span&gt;1&lt;/span&gt;;i=&lt;span&gt;treap[i].fa) {
        rememory(i);
    }
}

inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dltthis(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; now) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.sm!=&lt;span&gt;1&lt;/span&gt;) --t.sz,--&lt;span&gt;t.sm;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; endthis(now);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; now,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v==-INF) {buildnew(now,v);&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;}
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v==v) {addthis(now);&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;}
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v&amp;gt;&lt;span&gt;v) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.ls==-&lt;span&gt;1&lt;/span&gt;) t.ls=++tsz,treap[tsz].fa=&lt;span&gt;now;
        add(t.ls,v);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.rs==-&lt;span&gt;1&lt;/span&gt;) t.rs=++tsz,treap[tsz].fa=&lt;span&gt;now;
        add(t.rs,v);
    }
    turnning(now);
    rememory(now);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dlt(&lt;span&gt;int&lt;/span&gt; now,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v==v) {dltthis(now);&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;}
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v&amp;gt;&lt;span&gt;v) dlt(t.ls,v);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; dlt(t.rs,v);
    rememory(now);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rak(&lt;span&gt;int&lt;/span&gt; now,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v==k) &lt;span&gt;return&lt;/span&gt; treap[t.ls].sz+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v&amp;gt;k) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rak(t.ls,k);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; rak(t.rs,k)+treap[t.ls].sz+&lt;span&gt;t.sm;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ask_rak(&lt;span&gt;int&lt;/span&gt; now,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k) {
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(treap[t.ls].sz&amp;gt;=k) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ask_rak(t.ls,k);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s=treap[t.ls].sz+&lt;span&gt;t.sm;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s&amp;gt;=k) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t.v;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ask_rak(t.rs,k-&lt;span&gt;s);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ask_upper(&lt;span&gt;int&lt;/span&gt; now,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(now==-&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;INF;
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v&amp;lt;k) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mmax(t.v,ask_upper(t.rs,k));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ask_upper(t.ls,k);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ask_lower(&lt;span&gt;int&lt;/span&gt; now,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(now==-&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; INF;
    BST &lt;/span&gt;&amp;amp;t=&lt;span&gt;treap[now];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t.v&amp;gt;k) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mmin(t.v,ask_lower(t.ls,k));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ask_lower(t.rs,k);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;Summary&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　1、这是我第一个完全不借鉴其他人代码学习思想后徒手码出的高级数据结构。代码时间5个半小时，思考实现时间两天。将来会越做越好。这是第一个，但绝不是最后一个。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　2、一共194行……传说中的200行毒瘤代码还是被我奶中了emmmm&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Jul 2018 16:07:00 +0000</pubDate>
<dc:creator>一扶苏一</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yifusuyi/p/9383962.html</dc:identifier>
</item>
<item>
<title>Python学习：17.Python面向对象（四、属性（特性），成员修饰符，类的特殊成员） - BD-ld-2017</title>
<link>http://www.cnblogs.com/liudi2017/p/9383838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liudi2017/p/9383838.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;一、属性（特性）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;普通方法去执行的时候，后面需要加括号，特性方法执行的时候和静态字段一样不需要不需要加括号.&lt;/p&gt;
&lt;p&gt;特性方法不和字段同名.&lt;/p&gt;
&lt;p&gt;特性方法不能传参数.&lt;/p&gt;
&lt;p&gt;在我们定义数据库字段类的时候,往往需要对其中的类属性做一些限制,一般用get和set方法来写,那在python中,我们该怎么做能够少写代码,又能优雅的实现想要的限制,减少错误的发生呢,这时候就需要我们的@property.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;获取特性&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 普通方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        temp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s sb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 特性，将方法的执行方式变为和字段一样&lt;/span&gt;
&lt;span&gt;    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; end(self):
        temp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s gd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;self.name
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp

obj &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
ret1 &lt;/span&gt;=&lt;span&gt; obj.start()
ret2 &lt;/span&gt;=&lt;span&gt; obj.end
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret2)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj.name)


输出结果：
alexsel gd
alexsel&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;设置特性&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;设置特性方法的时候，所需要加的装饰器名字规则是，你所设置特性方法名字点setter（例如：@end.setter）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 普通方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        temp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s sb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 特性，将方法的执行方式变为和字段一样&lt;/span&gt;
&lt;span&gt;    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; end(self):
        temp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s gd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;self.name
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果需要使用设置特性的的方法，就需要这个点前面名字和所要设置特性的方法同名，就像这里的end&lt;/span&gt;
&lt;span&gt;    @end.setter
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; end(self,value):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(value)
        self.name &lt;/span&gt;=&lt;span&gt; value

obj &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取特性,获取特性的时候，拿到的是@Property的返回值&lt;/span&gt;
ret2 =&lt;span&gt; obj.end
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret2)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置特性，设置特性的时候，会执行@end.setter下面的方法，这个'aaa'就传递给value&lt;/span&gt;
obj.end = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
ret1 &lt;/span&gt;=&lt;span&gt; obj.end
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret1)


输出结果：
alexsel gd
aaa
aaa gd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个特性在python中不是特别常用，因为我们一般可以使用普通的方法代替特性方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二、成员修饰符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;首先介绍‘__’，这个在命名之前添加就会变成私有的，只有在类的内部才能访问。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    book &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;命名的时候前面添加__，只有在类的内部才能访问，在外部无法访问&lt;/span&gt;
    &lt;span&gt;__book&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(Foo.&lt;span&gt;__book&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(self.&lt;span&gt;__name&lt;/span&gt;&lt;span&gt;)


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__end&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


obj &lt;/span&gt;=&lt;span&gt; Foo()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj.book)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(obj.__book) #这种无法拿到字段&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;在外部也无法调用类私有方法&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;obj.__end()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;通过内部方法调用拿到字段&lt;/span&gt;
&lt;span&gt;obj.start()


输出结果：
alexsel
book
alexsel&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;私有的属性只有自己可以访问，当某个类继承这个类之后，也无法访问父类的私有属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    book &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;__book&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(Foo.&lt;span&gt;__book&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(self.&lt;span&gt;__name&lt;/span&gt;&lt;span&gt;)
        self.&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;()


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__end&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar(Foo):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(self.&lt;span&gt;__name&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;子类继承父类，也无法调用父类的私有属性&lt;/span&gt;
&lt;span&gt;

obj &lt;/span&gt;=&lt;span&gt; Bar()
obj.start()

输出结果：
报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;静态方法也是如此&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    book &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;__book&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        Foo.&lt;/span&gt;&lt;span&gt;__add&lt;/span&gt;() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;内部调用私有静态方法&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__end&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add&lt;/span&gt;&lt;span&gt;():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


obj &lt;/span&gt;=&lt;span&gt; Foo()
obj.start()


输出结果：
add&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;python成员修饰符有两种，一种是共有的，一种是私有的，共有的都可以访问，私有的只有自己可以访问，或者在外部间接访问。&lt;/p&gt;
&lt;p&gt;但是还有一种强行访问私有属性的方法，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    book &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;__book&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        Foo.&lt;/span&gt;&lt;span&gt;__add&lt;/span&gt;() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;内部调用私有静态方法&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__end&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add&lt;/span&gt;&lt;span&gt;():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


obj &lt;/span&gt;=&lt;span&gt; Foo()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj._Foo__book)


输出结果：
book&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然可以使用，但是不推荐这种使用方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;三、类的特殊成员&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.call&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;__call__()&lt;/code&gt;的作用是使实例能够像函数一样被调用，同时不影响实例本身的生命周期（&lt;code&gt;__call__()&lt;/code&gt;不影响一个实例的构造和析构）。&lt;/p&gt;
&lt;p&gt; __call__ 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Foo:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( Foo:      &lt;span&gt;def&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;call&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;
r &lt;/span&gt;=&lt;span&gt; Foo()
r()
r &lt;/span&gt;= Foo()()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加第一个括号执行__init__，执行完__init__,获取到一个对象，对象加一个括号就是执行__call__，拿到返回值&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(r)


输出结果：
init
call
init
call
&lt;/span&gt;1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类后面添加括号执行__init__方法，对象后面加括号执行__call__方法。&lt;/p&gt;
&lt;h3&gt;2.getitem，setitem，delitem&lt;/h3&gt;
&lt;p&gt;用于索引操作，如字典。以上分别表示获取、设置、删除数据。&lt;/p&gt;
&lt;p&gt;首先得实例是字典类型的操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;call&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(self, item):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(item)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__setitem__&lt;/span&gt;&lt;span&gt;(self, key, value):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(key,value)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__delitem__&lt;/span&gt;&lt;span&gt;(self, key):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(key)

r &lt;/span&gt;=&lt;span&gt; Foo()
r() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用__call__方法&lt;/span&gt;
r[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用中括号传参数的时候，默认使用过的是__getitem__方法&lt;/span&gt;
r[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = 123&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里的xxx传给__setiem__的key，123传给__setitem__的value。&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; r[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除的时候，调用的是__delitem__方法&lt;/span&gt;
&lt;span&gt;

输出结果：
init
call
k1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来是切片类型的操作，在切片操作的时候，在2.x版本中，执行的是__getslice_，__setslice__,delslice__方法，在3.x中的版本执行的是还是__getitem__，__setitem__，__delitem__方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;call&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(self, item):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(item,type(item),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__setitem__&lt;/span&gt;&lt;span&gt;(self, key, value):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(key,value)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__delitem__&lt;/span&gt;&lt;span&gt;(self, key):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(key)

r &lt;/span&gt;=&lt;span&gt; Foo()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用切片的时候，在2.x版本中，调用的是__getslice__方法，在3.x中调用的是__getitem__方法。&lt;/span&gt;
r[1:3&lt;span&gt;]
r[&lt;/span&gt;1:3] = [11,22,33] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里执行__setitem__方法&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; r[1:3]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在这里执行__delitem__方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 3.dict&lt;/h3&gt;
&lt;p&gt;dict是用来存储对象属性的一个字典，其键为属性名，值为属性的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    我是一个注释
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;

    book &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;__book&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        Foo.&lt;/span&gt;&lt;span&gt;__add&lt;/span&gt;() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;内部调用私有静态方法&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__end&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add&lt;/span&gt;&lt;span&gt;():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


obj &lt;/span&gt;=&lt;span&gt; Foo()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(obj.&lt;span&gt;__dict__&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取对象里面所有字段&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(Foo.&lt;span&gt;__dict__&lt;/span&gt;&lt;span&gt;)

输出结果：
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_Foo__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_Foo__book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;function Foo.&lt;span&gt;__init__&lt;/span&gt; at 0x00000000027CF950&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__dict__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;attribute &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__dict__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; objects&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;function Foo.start at 0x00000000027EBB70&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_Foo__add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;staticmethod object at 0x00000000027B6390&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__weakref__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;attribute &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__weakref__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; objects&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_Foo__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;function Foo.&lt;span&gt;__end&lt;/span&gt; at 0x00000000027EBBF8&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n    我是一个注释\n    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__module__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.__iter__&lt;/h3&gt;
&lt;p&gt;类的迭代器可以使用for循环迭代类。&lt;/p&gt;
&lt;p&gt;如果创建的对象可以被迭代，在类的内部就执行了__iter__方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; 1
        &lt;span&gt;yield&lt;/span&gt; 2
        &lt;span&gt;yield&lt;/span&gt; 3
        &lt;span&gt;yield&lt;/span&gt; 4&lt;span&gt;


obj &lt;/span&gt;=&lt;span&gt; Foo()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果执行for对象时，自动会执行对象的iter方法&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)



输出结果：
&lt;/span&gt;1
2
3
4
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 28 Jul 2018 15:13:00 +0000</pubDate>
<dc:creator>BD-ld-2017</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liudi2017/p/9383838.html</dc:identifier>
</item>
<item>
<title>深入理解JavaScript的事件循环（Event Loop） - -渔人码头-</title>
<link>http://www.cnblogs.com/imwtr/p/9383695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imwtr/p/9383695.html</guid>
<description>
&lt;h2&gt;&lt;span&gt;一、什么是事件循环&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;JS的代码执行是基于一种事件循环的机制，之所以称作事件循环，MDN给出的解释为&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;因为它经常被用于类似如下的方式来实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (queue.waitForMessage()) {
  queue.processNextMessage();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果当前没有任何消息&lt;code&gt;queue.waitForMessage&lt;/code&gt; 会等待同步消息到达&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以把它当成一种程序结构的模型，处理的方案。更详细的描述可以查看 &lt;a href=&quot;https://segmentfault.com/a/1190000010622146&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而JS的运行环境主要有两个：&lt;strong&gt;浏览器&lt;/strong&gt;、&lt;strong&gt;Node&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在两个环境下的Event Loop实现是不一样的，在浏览器中基于 &lt;a href=&quot;https://www.w3.org/TR/2017/REC-html52-20171214/webappapis.html#event-loops&quot; target=&quot;_blank&quot;&gt;规范&lt;/a&gt; 来实现，不同浏览器可能有小小区别。在Node中基于 &lt;a href=&quot;http://libuv.org/&quot; target=&quot;_blank&quot;&gt;libuv&lt;/a&gt; 这个库来实现&lt;/p&gt;
&lt;p&gt; JS是单线程执行的，而基于事件循环模型，形成了基本没有阻塞（除了alert或同步XHR等操作）的状态&lt;/p&gt;

&lt;h2&gt;&lt;span&gt; 二、Macrotask 与 Microtask&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;根据 &lt;a href=&quot;https://www.w3.org/TR/2017/REC-html52-20171214/webappapis.html#event-loops&quot; target=&quot;_blank&quot;&gt;规范&lt;/a&gt;，每个线程都有一个事件循环（Event Loop），在浏览器中除了主要的页面执行线程 外，Web worker是在一个新的线程中运行的，所以可以将其独立看待。&lt;/p&gt;
&lt;p&gt;每个事件循环有至少一个任务队列（Task Queue，也可以称作Macrotask宏任务），各个任务队列中放置着不同来源（或者不同分类）的任务，可以让浏览器根据自己的实现来进行优先级排序&lt;/p&gt;
&lt;p&gt;以及一个微任务队列（Microtask Queue），主要用于处理一些状态的改变，UI渲染工作之前的一些必要操作（可以防止多次无意义的UI渲染）&lt;/p&gt;
&lt;p&gt;主线程的代码执行时，会将执行程序置入执行栈（Stack）中，执行完毕后出栈，另外有个堆空间（Heap），主要用于存储对象及一些非结构化的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728192609678-1575290601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一开始&lt;/p&gt;
&lt;p&gt;宏任务与微任务队列里的任务随着：任务进栈、出栈、任务出队、进队之间交替着进行&lt;/p&gt;
&lt;p&gt;从macrotask队列中取出一个任务处理，&lt;strong&gt;处理完成&lt;/strong&gt;之后（此时&lt;a href=&quot;https://tc39.github.io/ecma262/#execution-context-stack%E3%80%82&quot; target=&quot;_blank&quot;&gt;执行栈&lt;/a&gt;应该是空的），从microtask队列中一个个按顺序取出所有任务进行处理，处理完成之后进入UI渲染后续工作&lt;/p&gt;
&lt;p&gt;需要注意的是：&lt;strong&gt;microtask并不是在macrotask完成之后才会触发&lt;/strong&gt;，在回调函数之后，只要执行栈是空的，就会执行microtask。也就是说，macrotask执行期间，执行栈可能是空的（比如在冒泡事件的处理时）&lt;/p&gt;
&lt;p&gt;然后循环继续&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见的macrotask有：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常见的microtask有：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;macrotask种类很多，还有 dispatch event事件派发等&lt;/p&gt;
&lt;p&gt;run &amp;lt;script&amp;gt;这个可能看起来比较奇怪，可以把它看成一段代码（针对单个&amp;lt;script&amp;gt;标签）的同步顺序执行，主要用来描述执行程序的第一步执行&lt;/p&gt;
&lt;p&gt;dispatch event主要用来描述事件触发之后的执行任务，比如用户点击一个按钮，触发的onClick回调函数。需要注意的是，事件的触发是同步的，这在下文有例子说明&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，也可认为 run &amp;lt;script&amp;gt;不属于macrotask，毕竟规范也没有这样的说明，也可以将其视为主线程上的同步任务，不在主线程上的其他部分为异步任务&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三、在浏览器中的实现&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;先来看看这段蛮复杂的代码，思考一下会输出什么&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
            console.log('start'&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; intervalA = setInterval(() =&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'intervalA'&lt;span&gt;);
            }, &lt;/span&gt;0&lt;span&gt;);

            setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'timeout'&lt;span&gt;);

                clearInterval(intervalA);
            }, &lt;/span&gt;0&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; intervalB = setInterval(() =&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'intervalB'&lt;span&gt;);
            }, &lt;/span&gt;0&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; intervalC = setInterval(() =&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'intervalC'&lt;span&gt;);
            }, &lt;/span&gt;0&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'promise'&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 10000; ++&lt;span&gt;i) {
                    i &lt;/span&gt;=== 9999 &amp;amp;&amp;amp;&lt;span&gt; resolve();
                }

                console.log(&lt;/span&gt;'promise after for-loop'&lt;span&gt;);
            }).then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'promise1'&lt;span&gt;);
            }).then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'promise2'&lt;span&gt;);

                clearInterval(intervalB);
            });

            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
                setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                    console.log(&lt;/span&gt;'promise in timeout'&lt;span&gt;);
                    resolve();
                });

                console.log(&lt;/span&gt;'promise after timeout'&lt;span&gt;);
            }).then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'promise4'&lt;span&gt;);
            }).then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'promise5'&lt;span&gt;);

                clearInterval(intervalC);
            });

            Promise.resolve().then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'promise3'&lt;span&gt;);
            });

            console.log(&lt;/span&gt;'end');    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码结合了常规执行代码，setTimeout，setInterval，Promise &lt;/p&gt;
&lt;p&gt;答案为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728150331536-848095512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在解释为什么之前，先看一个更简单的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            console.log('start'&lt;span&gt;);

            setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'timeout'&lt;span&gt;);
            }, &lt;/span&gt;0&lt;span&gt;);

            Promise.resolve().then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'promise'&lt;span&gt;);
            });

            console.log(&lt;/span&gt;'end');    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 大概的步骤，文字有点多&lt;/p&gt;
&lt;p&gt;1. 运行时（runtime）识别到log方法为一般的函数方法，将其入栈，然后执行输出 start 再出栈&lt;/p&gt;
&lt;p&gt;2. 识别到setTimeout为特殊的异步方法（macrotask），将其交由其他内核模块处理，setTimeout的匿名回调函数被放入macrotask队列中，并设置了一个 0ms的立即执行标识（提供后续模块的检查）&lt;/p&gt;
&lt;p&gt;3. 识别到Promise的resolve方法为一般的方法，将其入栈，然后执行 再出栈&lt;/p&gt;
&lt;p&gt;4. 识别到then为Promise的异步方法(microtask)，将其交由其他内核模块处理，匿名回调函数被放入microtask队列中&lt;/p&gt;
&lt;p&gt;5. 识别到log方法为一般的函数方法，将其入栈，然后执行输出 end 再出栈&lt;/p&gt;
&lt;p&gt;6. 主线程执行完毕，栈为空，随即从microtask队列中取出队首的项，&lt;/p&gt;
&lt;p&gt;这里队首为匿名函数，匿名函数里面有 console的log方法，也将其入栈（如果执行过程中识别到特殊的方法，就在这时交给其他模块处理到对应队列尾部），&lt;/p&gt;
&lt;p&gt;输出 promise后出栈，并将这一项从队列中移除&lt;/p&gt;
&lt;p&gt;7. 继续检查microtask队列，当前队列为空，则将当前macrotask出队，进入下一步（如果不为空，就继续取下一个microtask执行）&lt;/p&gt;
&lt;p&gt;8.检查是否需要进行UI重新渲染等，进行渲染...&lt;/p&gt;
&lt;p&gt;9. 进入下一轮事件循环，检查macrotask队列，取出一项进行处理&lt;/p&gt;
&lt;p&gt; 所以最终的结果是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728195436391-2074674475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;再看上面那个例子，对比起来只是代码多了点，混入了setInterval，多个setTimeout与promise的函数部分，按照上面的思路，应该不难理解&lt;/p&gt;
&lt;p&gt;需要注意的三点：&lt;/p&gt;
&lt;p&gt;1. clearInterval(intervalA); 运行的时候，实际上已经执行了 intervalA 的macrotask了&lt;br/&gt;2. promise函数内部是同步处理的，不会放到队列中，放入队列中的是它的then或catch回调&lt;br/&gt;3. promise的then返回的还是promise，所以在输出promise4后，继续检测到后续的then方法，马上放到microtask队列尾部，再继续取出执行，马上输出promise5；&lt;/p&gt;
&lt;p&gt;而输出promise1之后，为什么没有马上输出promise2呢？因为此时promise1所在任务之后是promise3的任务，1和3在promise函数内部返回后就添加至队列中，2在1执行之后才添加&lt;/p&gt;

&lt;p&gt;再来看个例子，就有点微妙了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

        setTimeout(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;timeout1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        }, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

        Promise.resolve().then(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;promise1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        });
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        setTimeout(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;timeout2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        }, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

        requestAnimationFrame(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;requestAnimationFrame&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        });

        Promise.resolve().then(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;promise2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        });

        console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728202732031-322249058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;requestAnimationFrame是在setTimeout之前执行的，start之后并不是直接输出end，也许这两个&amp;lt;script&amp;gt;标签被独立处理了&lt;/p&gt;

&lt;p&gt;来看一个关于DOM操作的例子，&lt;a href=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=619928018081157120&amp;amp;from=singlemessage&quot; target=&quot;_blank&quot;&gt;Tasks, microtasks, queues and schedules&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    .outer &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #eee&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin-left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 300px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin-top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 150px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; flex&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        align-items&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        justify-content&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

    .inner &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #ddd&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; outer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.outer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
            inner &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.inner&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
            clickTimes &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutationObserver(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mutate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        }).observe(outer, {
            attributes: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        });

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; onClick() {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

            setTimeout(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
                console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;timeout&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            }, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

            Promise.resolve().then(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
                console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;promise&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            });

            outer.setAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data-click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, clickTimes&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;);
        }

        inner.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, onClick);
        outer.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, onClick);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; inner.click();&lt;/span&gt;

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log('done');&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728203548785-204268099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击内部的inner块，会输出什么呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728203644158-281836874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MutationObserver优先级比promise高，虽然在一开始就被定义，但实际上是触发之后才会被添加到microtask队列中，所以先输出了promise&lt;/p&gt;
&lt;p&gt;两个timeout回调都在最后才触发，因为click事件冒泡了，事件派发这个macrotask任务包括了前后两个onClick回调，两个回调函数都执行完之后，才会执行接下来的 setTimeout任务&lt;/p&gt;
&lt;p&gt;期间第一个onClick回调完成后执行栈为空，就马上接着执行microtask队列中的任务&lt;/p&gt;

&lt;p&gt;如果把代码的注释去掉，使用代码自动 click()，思考一下，会输出什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728205414734-159788440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，事件处理是同步的，done在连续输出两个click之后才输出&lt;/p&gt;
&lt;p&gt; 而mutate只有一个，是因为当前执行第二个onClick回调的时候，microtask队列中已经有一个MutationObserver，它是第一个回调的，因为事件同步的原因没有被及时执行。浏览器会对MutationObserver进行优化，不会重复添加监听回调&lt;/p&gt;


&lt;h2&gt;&lt;span&gt; 四、在Node中的实现&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在Node环境中，macrotask部分主要多了setImmediate，microtask部分主要多了process.nextTick，而这个nextTick是独立出来自成队列的，优先级高于其他microtask&lt;/p&gt;
&lt;p&gt;不过事件循环的的实现就不太一样了，可以参考 &lt;a href=&quot;https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/&quot; target=&quot;_blank&quot;&gt;Node事件文档 &lt;/a&gt;  &lt;a href=&quot;http://docs.libuv.org/en/v1.x/design.html&quot; target=&quot;_blank&quot;&gt;libuv事件文档&lt;/a&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Node中的事件循环有6个阶段&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;timers：执行&lt;code&gt;setTimeout()&lt;/code&gt; 和 &lt;code&gt;setInterval()&lt;/code&gt;中到期的callback&lt;/li&gt;
&lt;li&gt;I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行&lt;/li&gt;
&lt;li&gt;idle, prepare：仅内部使用&lt;/li&gt;
&lt;li&gt;poll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段&lt;/li&gt;
&lt;li&gt;check：执行setImmediate的callback&lt;/li&gt;
&lt;li&gt;close callbacks：执行close事件的callback，例如&lt;code&gt;socket.on(&quot;close&quot;,func)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728210707057-1709797007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一轮事件循环都会经过六个阶段，在每个阶段后，都会执行microtask&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728215940260-1682381478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;比较特殊的是在poll阶段，执行程序同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限&lt;/p&gt;
&lt;p&gt;接下来再检查有无预设的setImmediate，如果有就转入check阶段，没有就先查询最近的timer的距离，以其作为poll阶段的阻塞时间，如果timer队列是空的，它就一直阻塞下去&lt;/p&gt;
&lt;p&gt;而nextTick并不在这些阶段中执行，它在每个阶段之后都会执行&lt;/p&gt;

&lt;p&gt;看一个例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
setTimeout(() =&amp;gt; console.log(1&lt;span&gt;));

setImmediate(() &lt;/span&gt;=&amp;gt; console.log(2&lt;span&gt;));

process.nextTick(() &lt;/span&gt;=&amp;gt; console.log(3&lt;span&gt;));

Promise.resolve().then(() &lt;/span&gt;=&amp;gt; console.log(4&lt;span&gt;));

console.log(&lt;/span&gt;5);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据以上知识，应该很快就能知道输出结果是 5 3 4 1 2&lt;/p&gt;
&lt;p&gt;修改一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
process.nextTick(() =&amp;gt; console.log(1&lt;span&gt;));

Promise.resolve().then(() &lt;/span&gt;=&amp;gt; console.log(2&lt;span&gt;));

process.nextTick(() &lt;/span&gt;=&amp;gt; console.log(3&lt;span&gt;));

Promise.resolve().then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    process.nextTick(() &lt;/span&gt;=&amp;gt; console.log(0&lt;span&gt;));
    console.log(&lt;/span&gt;4&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出为 1 3 2 4 0，因为nextTick队列优先级高于同一轮事件循环中其他microtask队列&lt;/p&gt;
&lt;p&gt;修改一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
process.nextTick(() =&amp;gt; console.log(1&lt;span&gt;));

console.log(&lt;/span&gt;0&lt;span&gt;);

setTimeout(()&lt;/span&gt;=&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;'timer1'&lt;span&gt;);

    Promise.resolve().then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'promise1'&lt;span&gt;);
    });
}, &lt;/span&gt;0&lt;span&gt;);

process.nextTick(() &lt;/span&gt;=&amp;gt; console.log(2&lt;span&gt;));

setTimeout(()&lt;/span&gt;=&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;'timer2'&lt;span&gt;);

    process.nextTick(() &lt;/span&gt;=&amp;gt; console.log(3&lt;span&gt;));

    Promise.resolve().then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'promise2'&lt;span&gt;);
    });
}, &lt;/span&gt;0);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728213248968-105884818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与在浏览器中不同，这里promise1并不是在timer1之后输出，因为在setTimeout执行的时候是出于timer阶段，会先一并处理timer回调&lt;/p&gt;

&lt;p&gt;setTimeout是优先于setImmediate的，但接下来这个例子却不一定是先执行setTimeout的回调&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
setTimeout(() =&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;'timeout'&lt;span&gt;);
}, &lt;/span&gt;0&lt;span&gt;);

setImmediate(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;'immediate'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728214321521-1885700184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为在Node中识别不了0ms的setTimeout，至少也得1ms. &lt;/p&gt;
&lt;p&gt;所以，如果在进入该轮事件循环的时候，耗时不到1ms，则setTimeout会被跳过，进入check阶段执行setImmediate回调，先输出 immediate&lt;/p&gt;
&lt;p&gt;如果超过1ms，timer阶段中就可以马上处理这个setTimeout回调，先输出 timeout&lt;/p&gt;
&lt;p&gt;修改一下代码，读取一个文件让事件循环进入IO文件读取的poll阶段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    let fs = require('fs'&lt;span&gt;);

    fs.readFile(&lt;/span&gt;'./event.html', () =&amp;gt;&lt;span&gt; {
        setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'timeout'&lt;span&gt;);
        }, &lt;/span&gt;0&lt;span&gt;);

        setImmediate(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'immediate'&lt;span&gt;);
        });
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这么一来，输出结果肯定就是 先 immediate  后 timeout&lt;/p&gt;

&lt;h2&gt;&lt;span&gt; 五、用好事件循环&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;知道JS的事件循环是怎么样的了，就需要知道怎么才能把它用好&lt;/p&gt;
&lt;p&gt;1. 在microtask中不要放置复杂的处理程序，防止阻塞UI的渲染&lt;/p&gt;
&lt;p&gt;2. 可以使用process.nextTick处理一些比较紧急的事情&lt;/p&gt;
&lt;p&gt;3. 可以在setTimeout回调中处理上轮事件循环中UI渲染的结果&lt;/p&gt;
&lt;p&gt;4. 注意不要滥用setInterval和setTimeout，它们并不是可以保证能够按时处理的，setInterval甚至还会出现丢帧的情况，可考虑使用 requestAnimationFrame&lt;/p&gt;
&lt;p&gt;5. 一些可能会影响到UI的异步操作，可放在promise回调中处理，防止多一轮事件循环导致重复执行UI的渲染&lt;/p&gt;
&lt;p&gt;6. 在Node中使用immediate来可能会得到更多的保证&lt;/p&gt;
&lt;p&gt;7. 不要纠结&lt;/p&gt;
</description>
<pubDate>Sat, 28 Jul 2018 14:23:00 +0000</pubDate>
<dc:creator>-渔人码头-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imwtr/p/9383695.html</dc:identifier>
</item>
<item>
<title>OpenCASCADE Extended Data Exchange - XDE - opencascade</title>
<link>http://www.cnblogs.com/opencascade/p/XDE.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/opencascade/p/XDE.html</guid>
<description>&lt;h3&gt;OpenCASCADE Extended Data Exchange - XDE&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;mailto:eryar@163.com&quot;&gt;eryar@163.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abstract.&lt;/strong&gt; OpenCASCADE Data Exchange allows developing OCCT-Based applications that can interact with other CAD systems by writing and reading CAD models to and from external data. The exchanges run smoothly regardless of the quality of external data or requirements to its internal representation, for example to the data types, accepted geometric inaccuracies, etc. Data Exchange is organized in a modular way as a set of interfaces that comply with various CAD formats: IGES, STEP, STL, VRML, etc. The interfaces allow software based on OCCT to exchange data with various CAD/PDM software packages, maintaining a good level of interoperability. Extended Data Exchange allows translating additional attributes attached to geometric data(colors, layers, names, materials, etc.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Words.&lt;/strong&gt; DataExchange, STEP, IGES, XDE, OCAF, &lt;/p&gt;
&lt;h3&gt;1. Introduction&lt;/h3&gt;
&lt;p&gt;OpenCASCADE的DataExchange数据交换模块可以通过读写CAD模型数据的方式与其他CAD系统进行交互。标准数据交换（Standardized Data Exchange）的接口可以查询和检查输入文件，转换文件中的CAD模型，正确性检查。目前开源部分支持的文件格式有：&lt;/p&gt;
&lt;p&gt;l STEP（AP203：Mechanical Design；AP214：Automotive Design）&lt;/p&gt;
&lt;p&gt;l IGES（5.3版本）&lt;/p&gt;
&lt;p&gt;l VRML和STL；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220421298-1893799841.png&quot;&gt;&lt;img title=&quot;wps_clip_image-25767&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220421695-995395347.png&quot; alt=&quot;wps_clip_image-25767&quot; width=&quot;328&quot; height=&quot;363&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 1. 导入的STEP模型&lt;/p&gt;
&lt;h3&gt;2. Extended Data Exchange（XDE）&lt;/h3&gt;
&lt;p&gt;扩展的数据交换模块可以转换附加在几何BREP体中其他信息，如颜色、图层，组装结构等，因此提高与其他CAD软件的兼容性。目前包含这些信息的文件格式有IGES和STEP。XDE通过XCAF框架来读写包含颜色、图层等信息的IGES，STEP文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220422004-1853197695.png&quot;&gt;&lt;img title=&quot;wps_clip_image-29842&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220422263-1571178641.png&quot; alt=&quot;wps_clip_image-29842&quot; width=&quot;408&quot; height=&quot;408&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 2. 使用XDE导入的模型&lt;/p&gt;
&lt;h3&gt;3. XDE Basic Terms&lt;/h3&gt;
&lt;p&gt;为了更好的理解XDE，定义了几个关键术语：&lt;/p&gt;
&lt;p&gt;l Shape：单独的模型，不属于任何装配结构(a standalone shape, which does not belong to the assembly structure)；&lt;/p&gt;
&lt;p&gt;l Instance：其他模型的一个实例化，位置信息可以相同，也可以不同(a replication of another shape with a location that can be the same location or different one)；&lt;/p&gt;
&lt;p&gt;l Assembly：装配结构；&lt;/p&gt;
&lt;h3&gt;4. XDE Organization&lt;/h3&gt;
&lt;p&gt;XDE的基础是XCAF，XCAF是一个基于OCAF（Open CASCADE Technology Application Framework）框架的框架，可用于处理装配信息和其他属性数据。XDE使用OCAF来存储装配结构和属性，所以可以得到装配结构树的每层TopoDS表示。&lt;/p&gt;
&lt;h3&gt;5. Assemblies&lt;/h3&gt;
&lt;p&gt;XDE支持装配结构的读写。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220422734-1507649749.png&quot;&gt;&lt;img title=&quot;wps_clip_image-19676&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220424876-473897314.png&quot; alt=&quot;wps_clip_image-19676&quot; width=&quot;577&quot; height=&quot;308&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 3. 装配结构树&lt;/p&gt;
&lt;p&gt;装配结构通过OCAF的Label/SubLabel来组织：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220426417-1404032708.png&quot;&gt;&lt;img title=&quot;wps_clip_image-18828&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220427176-1628464428.png&quot; alt=&quot;wps_clip_image-18828&quot; width=&quot;231&quot; height=&quot;187&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 4. 一个简单的框架模型 &lt;/p&gt;
&lt;p&gt;类XCAFDoc_ShapeTool来管理Label中的模型属性。&lt;/p&gt;
&lt;h3&gt;6. Names&lt;/h3&gt;
&lt;p&gt;XDE支持读写IGES和STEP中的名字数据。这个关闭这个功能以减小文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220428134-1809411936.png&quot;&gt;&lt;img title=&quot;wps_clip_image-10693&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220428432-404507478.png&quot; alt=&quot;wps_clip_image-10693&quot; width=&quot;487&quot; height=&quot;468&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 5. 模型名字&lt;/p&gt;
&lt;h3&gt;7. Colors and Layers&lt;/h3&gt;
&lt;p&gt;XDE可以读写模型的颜色数据，使用到的类有：&lt;/p&gt;
&lt;p&gt;l 通用颜色：generic color(XCAFDoc_ColorGen)&lt;/p&gt;
&lt;p&gt;l 曲面颜色：surface color(XCAFDoc_ColorSurf)&lt;/p&gt;
&lt;p&gt;l 曲线颜色：curve color(XCAFDoc_ColorCurv)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220428823-1004327451.png&quot;&gt;&lt;img title=&quot;wps_clip_image-4463&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220429195-1876009346.png&quot; alt=&quot;wps_clip_image-4463&quot; width=&quot;577&quot; height=&quot;406&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 6. XDE颜色&lt;/p&gt;
&lt;h3&gt;8. Code Example&lt;/h3&gt;
&lt;p&gt;程序将Draw Test Harness的samples的XDE的例子模型来测试读取装配结构、颜色等信息。首先将例子模型通过命令：WriteStep D d:/rod.step来保存装配结构、颜色等数据到STEP格式。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220429592-1168639044.png&quot;&gt;&lt;img title=&quot;wps_clip_image-24546&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220430028-386604641.png&quot; alt=&quot;wps_clip_image-24546&quot; width=&quot;573&quot; height=&quot;448&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 7. XDE Samples in Draw Test Harness&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220430507-2139575134.png&quot;&gt;&lt;img title=&quot;wps_clip_image-18659&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220430964-335884889.png&quot; alt=&quot;wps_clip_image-18659&quot; width=&quot;577&quot; height=&quot;418&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 8. Shapes with assembly and color info&lt;/p&gt;
&lt;p&gt;使用XDE读取STEP文件代码示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Handle(XCAFDoc_ColorTool) aColorTool;
Handle(XCAFDoc_ShapeTool) aShapeTool;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; visit(&lt;span&gt;const&lt;/span&gt; TDF_Label&amp;amp;&lt;span&gt; theLabel)
{
    theLabel.EntryDump(std::cout);

    Handle(TDataStd_Name) aName;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (theLabel.FindAttribute(TDataStd_Name::GetID(), aName))
    {
        std::cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  Name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aName-&amp;gt;Get() &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (aColorTool-&amp;gt;&lt;span&gt;IsSet(theLabel, XCAFDoc_ColorGen))
    {
        Quantity_Color aColor;
        aColorTool&lt;/span&gt;-&amp;gt;&lt;span&gt;GetColor(theLabel, aColor);

        std::cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  Color: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; Quantity_Color::StringName(aColor.Name()) &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (aShapeTool-&amp;gt;&lt;span&gt;IsShape(theLabel))
    {
        TopoDS_Shape aShape;
        aShapeTool&lt;/span&gt;-&amp;gt;&lt;span&gt;GetShape(theLabel, aShape);
    }

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (TDF_ChildIterator c(theLabel); c.More(); c.Next())
    {
        visit(c.Value());
    }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; readStepXde(&lt;span&gt;const&lt;/span&gt; std::&lt;span&gt;string&lt;/span&gt;&amp;amp;&lt;span&gt; theStepName)
{
    Handle(TDocStd_Document) aDoc;
    Handle(XCAFApp_Application) anApp &lt;/span&gt;=&lt;span&gt; XCAFApp_Application::GetApplication();
    anApp&lt;/span&gt;-&amp;gt;NewDocument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MDTV-XCAF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, aDoc);

    STEPCAFControl_Reader aStepReader;
    aStepReader.SetColorMode(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    aStepReader.SetNameMode(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

    aStepReader.ReadFile(theStepName.c_str());

    aStepReader.Transfer(aDoc);

    TDF_Label aRootLabel &lt;/span&gt;= aDoc-&amp;gt;&lt;span&gt;Main();

    aShapeTool &lt;/span&gt;=&lt;span&gt; XCAFDoc_DocumentTool::ShapeTool(aRootLabel);
    aColorTool &lt;/span&gt;=&lt;span&gt; XCAFDoc_DocumentTool::ColorTool(aRootLabel);

    visit(aRootLabel);

}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    readStepXde(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/rod.STEP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序运行结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220431366-571729442.png&quot;&gt;&lt;img title=&quot;wps_clip_image-8893&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220431754-140561105.png&quot; alt=&quot;wps_clip_image-8893&quot; width=&quot;577&quot; height=&quot;309&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 9. 使用XDE读取STEP装配结构、颜色、名字等&lt;/p&gt;
&lt;h3&gt;9. Conclusion&lt;/h3&gt;
&lt;p&gt;使用XDE模块支持STEP和IGES中的装配结构、颜色、名字等信息的读写，提高与其他CAD系统数据交换效果。&lt;/p&gt;
&lt;p&gt;XDE主要使用OCAF框架来处理装配结构、属性信息，所以要使用XDE，必须理解OCAF的框架，OCAF框架也是一个基于Label的树结构。&lt;/p&gt;
</description>
<pubDate>Sat, 28 Jul 2018 14:05:00 +0000</pubDate>
<dc:creator>opencascade</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/opencascade/p/XDE.html</dc:identifier>
</item>
<item>
<title>logstash解耦之redis消息队列 - 渣渣辉</title>
<link>http://www.cnblogs.com/Dev0ps/p/9383385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/9383385.html</guid>
<description>&lt;h3&gt;logstash解耦之redis消息队列&lt;/h3&gt;
&lt;p&gt;架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201807/1271786-20180728204553194-2037827024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：通过input收集日志消息放入消息队列服务中（redis，MSMQ、Resque、ActiveMQ，RabbitMQ），再通过output取出消息写入ES上，kibana显示。&lt;/p&gt;
&lt;p&gt;好处：松耦合，降低logstash收集日志的负载对业务服务不受影响，前后端分离，消息能存储不影响ES维护。&lt;/p&gt;
&lt;p&gt; 下面我们就用redis做消息队列存储，架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201807/1271786-20180728212529444-1012601348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;#安装redis，修改redis配置文件，bind和protected-mode&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node1 conf.d]# yum install -y redis
[root@elk-node1 conf.d]# cp /etc/redis.conf{,.bak}
[root@elk-node1 conf.d]# grep &quot;^[a-z]&quot; /etc/redis.conf
bind 192.168.247.135
protected-mode yes
port 6379
tcp-backlog 511
timeout 0
tcp-keepalive 300
daemonize yes
supervised no
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#启动redis服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node1 conf.d]# systemctl start redis
You have new mail in /var/spool/mail/root
[root@elk-node1 conf.d]# ss -lntp|grep 6379
LISTEN     0      511    192.168.247.135:6379                     *:*                   users:((&quot;redis-server&quot;,pid=18387,fd=4))
You have new mail in /var/spool/mail/root
[root@elk-node1 conf.d]# grep &quot;^[a-z]&quot; /etc/redis.conf^C
[root@elk-node1 conf.d]# redis-cli -h 192.168.247.135
192.168.247.135:6379&amp;gt; exit
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#编写测试文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node1 conf.d]# cat redis-out.conf
input{
    stdin{

}
}
output{
    redis{
    host =&amp;gt; &quot;192.168.247.135&quot;
    port =&amp;gt; &quot;6379&quot;
    db =&amp;gt; &quot;6&quot;
    data_type =&amp;gt; &quot;list&quot;
    key =&amp;gt; &quot;demo&quot;
}
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#logstash配置文件运行输入hello world&lt;br/&gt;[root@elk-node1 conf.d]# /opt/logstash/bin/logstash -f /etc/logstash/conf.d/redis-out.conf&lt;br/&gt;Settings: Default filter workers: 1&lt;br/&gt;hello world&lt;br/&gt;#另开一个窗口登录redis可以看到一条我们刚输入的hello world消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node1 ~]# redis-cli -h 192.168.247.135
192.168.247.135:6379&amp;gt; info
Logstash startup completed
# Keyspace
db6:keys=1,expires=0,avg_ttl=0
192.168.247.135:6379&amp;gt; select 6
OK
192.168.247.135:6379[6]&amp;gt; key *
(error) ERR unknown command 'key'
192.168.247.135:6379[6]&amp;gt; keys *
1) &quot;demo&quot;
192.168.247.135:6379[6]&amp;gt; LINDEX demo -1
&quot;{\&quot;message\&quot;:\&quot;hello world\&quot;,\&quot;@version\&quot;:\&quot;1\&quot;,\&quot;@timestamp\&quot;:\&quot;2018-07-28T06:44:50.418Z\&quot;,\&quot;host\&quot;:\&quot;elk-node1\&quot;}&quot;
192.168.247.135:6379[6]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#接下来我们把消息写入ES，首先再输入多条消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node1 conf.d]# /opt/logstash/bin/logstash -f /etc/logstash/conf.d/redis-out.conf
Settings: Default filter workers: 1
Logstash startup completed
fsadf
dgdf
gdg
ad
fd
ds
cd
g
rgergerg
rg
qrg
rh
rg
q
34tr
34
f
gdf
df

df
f
sdv
sdf

re
ter
t4
^CSIGINT received. Shutting down the pipeline. {:level=&amp;gt;:warn}

Logstash shutdown completed
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#写一个输入到ES的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node1 conf.d]# cat redis-int.conf
input{
    redis{
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;demo&quot;
}
}
output{
        elasticsearch {
           hosts =&amp;gt; [&quot;192.168.247.135:9200&quot;]
           index =&amp;gt; &quot;redis-demo-%{+YYYY.MM.dd}&quot;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#logstash配置文件运行&lt;br/&gt;[root@elk-node1 conf.d]# /opt/logstash/bin/logstash -f /etc/logstash/conf.d/redis-int.conf&lt;br/&gt;Settings: Default filter workers: 1&lt;br/&gt;Logstash startup completed&lt;br/&gt;#这时我们看redis上的消息已经被消费了&lt;br/&gt;192.168.247.135:6379[6]&amp;gt; LLEN demo&lt;br/&gt;(integer) 0&lt;br/&gt;我们在登录ES可以看到已经有记录了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201807/1271786-20180728213528291-1766375984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#写一个系统监控的配置文件把日志写入redis,inpout里读取日志消息，output里写入redis。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node1 conf.d]# cat shipper.conf 
input {
    file {
      path =&amp;gt; &quot;/var/log/messages&quot;
      type =&amp;gt; &quot;system&quot;
      start_position =&amp;gt; &quot;beginning&quot;
    }
    file {
       path =&amp;gt; &quot;/var/log/elasticsearch/hejianlai.log&quot;
       type =&amp;gt; &quot;es-error&quot;
       start_position =&amp;gt; &quot;beginning&quot;
          codec =&amp;gt; multiline {
          pattern =&amp;gt; &quot;^\[&quot;
          negate =&amp;gt; true
          what =&amp;gt; &quot;previous&quot;
        }
    }
       file {
       path =&amp;gt; &quot;/var/log/nginx/access_json.log&quot;
       codec =&amp;gt; json
       start_position =&amp;gt; &quot;beginning&quot;
       type =&amp;gt; &quot;nginx-log&quot;
    }
        syslog{
        type =&amp;gt; &quot;system-syslog&quot;
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;514&quot;
}
}
output {
         
    if [type] == &quot;system&quot;{
        redis{
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;system&quot;
    }
} 
    if [type] == &quot;es-error&quot;{
        redis{
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;es-error&quot;
    }
}
       if [type] == &quot;nginx-log&quot;{
        redis{
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;nginx-log&quot;
    }
}
       if [type] == &quot;system-syslog&quot;{
        redis{
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;system-syslog&quot;

    }
}
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; #运行配置文件&lt;br/&gt;[root@elk-node1 conf.d]# /opt/logstash/bin/logstash -f /etc/logstash/conf.d/shipper.conf&lt;br/&gt;#查看redis已经生成了相应的key&lt;br/&gt;192.168.247.135:6379[6]&amp;gt; keys *&lt;br/&gt;1) &quot;system&quot;&lt;br/&gt;2) &quot;nginx-log&quot;&lt;br/&gt;3) &quot;es-error&quot;&lt;br/&gt;192.168.247.135:6379[6]&amp;gt;&lt;br/&gt;&lt;span&gt;#写一个配置文件从redis中把日志写入ES，inpout里读取redis消息，output里写入ES.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node2 conf.d]# cat display.conf 
input {
        redis{
        type =&amp;gt; &quot;system-syslog&quot;
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;system-syslog&quot;

    }
        redis{
      type =&amp;gt; &quot;system&quot;
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;system&quot;

    }
        redis{
       type =&amp;gt; &quot;es-error&quot;
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;es-error&quot;

    }
        redis{
       type =&amp;gt; &quot;nginx-log&quot;
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;nginx-log&quot;

    }

}
output {
         
    if [type] == &quot;system&quot;{
        elasticsearch {
           hosts =&amp;gt; [&quot;192.168.247.135:9200&quot;]
           index =&amp;gt; &quot;systemlog-%{+YYYY.MM.dd}&quot;
        }
    }
 
    if [type] == &quot;es-error&quot;{
        elasticsearch {
           hosts =&amp;gt; [&quot;192.168.247.135:9200&quot;]
           index =&amp;gt; &quot;es-error-%{+YYYY.MM.dd}&quot;
        }
    }
       if [type] == &quot;nginx-log&quot;{
        elasticsearch {
           hosts =&amp;gt; [&quot;192.168.247.135:9200&quot;]
           index =&amp;gt; &quot;nginx-log-%{+YYYY.MM.dd}&quot;
        }
    }
       if [type] == &quot;system-syslog&quot;{
        elasticsearch {
           hosts =&amp;gt; [&quot;192.168.247.135:9200&quot;]
           index =&amp;gt; &quot;system-syslog-log-%{+YYYY.MM.dd}&quot;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; #运行配置文件，就可以收集日志了。&lt;/p&gt;
&lt;p&gt;[root@elk-node2 conf.d]# /opt/logstash/bin/logstash -f /etc/logstash/conf.d/display.conf &amp;amp;&lt;/p&gt;
&lt;p&gt;到此&lt;span&gt;logstash+redis+elasticsearch+kibana&lt;/span&gt;的架构搭建基本结束~~~~~&lt;/p&gt;

</description>
<pubDate>Sat, 28 Jul 2018 14:01:00 +0000</pubDate>
<dc:creator>渣渣辉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dev0ps/p/9383385.html</dc:identifier>
</item>
<item>
<title>js-数组方法的使用和详谈 - 方红亮</title>
<link>http://www.cnblogs.com/fanghl/p/9383581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanghl/p/9383581.html</guid>
<description>&lt;p&gt;　　写博客的同时也是对自己知识的一次全面总结，方便自己日后复习。今天总结一下JS中Array的所有方法和技巧，对算法题算是一个基础了，有不足的地方，还望童鞋们指出来，一起进步。&lt;/p&gt;
&lt;p&gt;　　在总结方法之前，提到一点，Array中的length属性&lt;strong&gt;它不是只读的&lt;/strong&gt;！通过修改length属性，可以删除或添加数组的项。&lt;/p&gt;
&lt;p&gt;　　数组类型检测问题：instanceof（）方法、Array.isArray（）&lt;/p&gt;
&lt;p&gt;　　开门见山，JS中Array对象有这么几种方法：1、栈方法  2、队列方法  3、排序  4、操作方法   5、位置方法   6、迭代    7、归并&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;一、栈方法、队列方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这两个方法最为常见，具体就是 push()  pop()为栈方法，shift()  unshift()为队列方法。数组头尾部的压入和删除&lt;/p&gt;
&lt;p&gt;　   &lt;span&gt;&lt;strong&gt;三、重排序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　数组中已经存在两个方法可以进行数组的重排序，即 reserve（）和 sort（），reserve（）是反转数组，而sort（）是数组的重排序，默认为升序，sort（）实现排序原理是会调用每个数组项的  toString（）方法，比较得到的字符串。这个方法可能会出错，因为它比较的是转型后的字符串。通常会配合比较函数一起使用，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1394956/201807/1394956-20180728203919196-1909936429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;四、操作方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Array的操作方法是非常有用的，在数据结构和算法中比较重要。concat（）方法，简单理解为数组复制，再不传参数的情况下，就是复制原数组，参数若是一或多个数组，则将参数数组添加在原数组末尾。 slice（）方法，简单来说就是截取原数组中的一段作为新的数组返回，接受返回项的起始和截止位置。（左闭右开原则）即返回值不包括截止位置的值，只有一个参数的情况下，从参数位置一直截取到数组末尾。若参数中存在负值，则计算位置的方式为 数组长度加上该数 所得值。&lt;/p&gt;
&lt;p&gt;　　最重要的操作方法  splice（）。它可以完成&lt;strong&gt;增删改，&lt;/strong&gt;splice（）方法接受三个参数，起始位置、删除项数目、插入的项。灵活运用这三个参数的变化就可以完成数组的增删改，删除：splice（1， 2）从第二项开始删除两项。 插入： splice（1， 0， &quot;item1&quot;, &quot;item2&quot;）从第二项开始往后插入“item1”，“item2”。替换：splice（1， 2， “item1”， “item2”）原理不变，删除了两项，且在原位置插入了两项达到替换的作用。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;五、位置方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　有两个位置方法 indexOf() 和 lastIndexOf()，都接受两个参数，即要查找的项和查找起点的位置（该参数可选），只不过两个方法查找的顺序相反，indexOf（）是从头到尾的，且两个方法都返回被查找的项在数组中的位置，若没找到返回-1，利用这点，我们可以用来进行数组的去重，如图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1394956/201807/1394956-20180728210730522-8040869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上述图例又提到了Array的另一种类型的方法，即迭代方法，JS中有五个迭代方法，every（）、filter（）、forEach（）、map（）、some（）。它们都接收两个参数，一个是在数组每项上都要运行的函数，另一个就是该函数的作用域this。而传入的函数又会接受三个参数，数组项的值、其索引、原数组。解读上图例子，函数norepeat传入数组arr，返回arr的filter方法，filter的参数函数有两个参数，即当前项和其索引，在调用indexOf（）传入当前项ele ，indexOf会查找传入项在数组中第一次出现的位置，将该位置与filter的元素项位置相比，若等于则返回。数组去重会有很多不同位置的项值相等，迭代从左到右，filter里面只是每一项的值和索引，而indexOf（）里面则是某个值在数组中从左到右第一次出现的位置索引，让两个索引相比较。若相等则为首次出现，若不等，则为非首次出现，即重复的值，不返回，则最后得到的结果就是去重后的数组。&lt;/p&gt;
&lt;p&gt;　　every（）和some（）迭代，则是函数作用于数组每一项，结果都是true，才返回true这是every（）方法，some（）则是有一项返回true，则结果返回true，二者很相似。&lt;/p&gt;
&lt;p&gt;　　map（）方法，给数组每一项运行函数，返回其运行结果组成的数组。举例，让某数组全体项扩大二倍 var mapResult = arr.map(function(itrm, index) { retrun item*2});   最后forEach（）本质和for循环迭代数组一样。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;六、归并方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　ES5中有两个数组归并方法 reduce（）， reduceRight（）。这两个方法都会迭代数组项，并返回最终的值。类似于贪吃蛇，从第一个点开始，吃掉往后的每一个点并且加在自己身上，最后变成一个包含所有点的结果。该方法接受一个函数和归并基础的初始值（可选）作为参数，而函数接受四个参数，前一项值，当前值，项的索引，原数组。这个函数返回的值都会作为第一个参数自动传给下一项！举例：求数组的和  var reduceResult = arr.reduce( function(prev, cur, index) {return prev + cur} );&lt;/p&gt;
&lt;p&gt;　　作者：方红亮&lt;/p&gt;
&lt;p&gt;　　博客园：https://home.cnblogs.com/u/fanghl/&lt;/p&gt;
&lt;p&gt;　　码字不易，如需转载，请注明出处，谢谢理解！&lt;/p&gt;


</description>
<pubDate>Sat, 28 Jul 2018 13:47:00 +0000</pubDate>
<dc:creator>方红亮</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanghl/p/9383581.html</dc:identifier>
</item>
</channel>
</rss>