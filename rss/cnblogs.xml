<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>配置多个 git 账号的 ssh密钥 - xiaoxi666</title>
<link>http://www.cnblogs.com/xiaoxi666/p/9975981.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxi666/p/9975981.html</guid>
<description>&lt;h3&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在工作中，我们通常会以 ssh 的方式配置公司的 git 账号，但是平时也会使用 github 管理自己的项目。因此，我们需要为自己的 github 创建一个新的 git 账号，这就需要生成新的 ssh 密钥。&lt;br/&gt;下面总结了创建多个互相独立的 ssh 密钥的步骤（以公司的和自己 github 的为例）。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;步骤（以 mac 为例）&lt;/span&gt;&lt;/h3&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;22.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在文件夹 &lt;code&gt;~/.ssh/&lt;/code&gt; 下创建两个文件夹，分别为 &lt;code&gt;company/&lt;/code&gt; 和 &lt;code&gt;github/&lt;/code&gt;，前者存放公司的 ssh密钥，后者存自己 github 的 ssh 密钥。下面的步骤以创建 github 密钥为例：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在终端执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;ssh-keygen&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;-t&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;rsa&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;-C&lt;/span&gt; &quot;&lt;span class=&quot;hljs-selector-tag&quot;&gt;your_github_email&lt;/span&gt;@&lt;span class=&quot;hljs-keyword&quot;&gt;example&lt;/span&gt;.&lt;span class=&quot;hljs-keyword&quot;&gt;com&lt;/span&gt;&quot;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;然后会提示 Enter file in which to save the key，输入文件路径&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;~&lt;span class=&quot;hljs-regexp&quot;&gt;/.ssh/gi&lt;/span&gt;thub/id_rsa_github&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建成功后，该路径下会生成 &lt;code&gt;id_rsa_github&lt;/code&gt; 和 &lt;code&gt;id_rsa_github.pub&lt;/code&gt; 两个文件。若直接回车的话，会默认保存在&lt;code&gt;~/.ssh/&lt;/code&gt;路径下。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;然后出现 Enter passphrase (empty for no passphrase)，直接回车即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;最后会出现创建成功的提示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs vbnet&quot;&gt;Your identification has been saved &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; .ssh_github/id_rsa_github.&lt;br/&gt;Your &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;key&lt;/span&gt; has been saved &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; .ssh_github/id_rsa_github.pub.&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;文件&lt;code&gt;id_rsa_github.pub&lt;/code&gt;中保存的就是 ssh 公钥。可以利用命令 &lt;code&gt;pbcopy&lt;/code&gt; 将其复制到剪贴板，比如我的命令就是&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;pbcopy &amp;lt; ~&lt;span class=&quot;hljs-regexp&quot;&gt;/.ssh/gi&lt;/span&gt;thub/id_rsa_github.pub&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然你也可以找到该文件手动复制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在 github 网站中添加该 ssh 公钥。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建公司 ssh 密钥 的过程类似，不再赘述。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;两个 ssh 密钥创建完毕后，在&lt;code&gt;~/.ssh/&lt;/code&gt;文件夹中创建文件&lt;code&gt;config&lt;/code&gt;，添加如下内容：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs nginx&quot; readability=&quot;2&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;Host&lt;/span&gt; git.XXX.com                    &lt;br/&gt;HostName git.XXX.com                &lt;br/&gt;User git                            &lt;br/&gt;IdentityFile ~/.ssh/company/id_rsa  &lt;p&gt;&lt;br/&gt;Host github.com                    &lt;br/&gt;HostName github.com               &lt;br/&gt;User git                            &lt;br/&gt;IdentityFile ~/.ssh/github/id_rsa_github    &lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注：配置文件中各参数含义请参见扩展部分&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;网上很多文章说要执行命令 &lt;code&gt;ssh-add&lt;/code&gt; 将 IdentityFile 添加到 ssh-agent 中，具体到本文中就是执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;ssh-&lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt; ~/.ssh/company/id_rsa &lt;br/&gt;ssh-&lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt; ~/.ssh/github/id_rsa_github&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;其实这个操作只是把专用密钥添加到 ssh-agent 的高速缓存中，因此略过该步骤也不会有影响。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;这一步用于验证是否配置成功，以 github 为例，输入 &lt;code&gt;ssh -T git@github.com&lt;/code&gt;，若出现类似&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs vbnet&quot;&gt;Hi xiaoxi666! You&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的字段，即说明配置成功。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;本文描述了单机配置两个 git 平台ssh密钥的方法，多个账号同理。推荐在 &lt;code&gt;~/.ssh/&lt;/code&gt; 文件夹下为不同的平台建立不同的文件夹，方便管理。根据上述配置，我的 &lt;code&gt;~/.ssh/&lt;/code&gt; 文件夹下是这样子的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;company&lt;/span&gt;&lt;br/&gt;│   ├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;id_rsa&lt;/span&gt;&lt;br/&gt;│   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;id_rsa&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.pub&lt;/span&gt;&lt;br/&gt;├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;config&lt;/span&gt;&lt;br/&gt;├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;github&lt;/span&gt;&lt;br/&gt;│   ├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;id_rsa_github&lt;/span&gt;&lt;br/&gt;│   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;id_rsa_github&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.pub&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;&lt;span&gt;扩展（关于配置文件 config）&lt;/span&gt;&lt;/h3&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;22&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;配置文件的位置&lt;/strong&gt;：上面我们在 &lt;code&gt;~/.ssh/&lt;/code&gt; 文件夹下创建配置文件。其实也可以指定位置，具体可查阅 ssh 帮助手册（&lt;code&gt;man 1 ssh&lt;/code&gt;）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs delphi&quot;&gt;-F configfile&lt;br/&gt;Specifies an alternative per-user configuration &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt;.  &lt;span class=&quot;hljs-keyword&quot;&gt;If&lt;/span&gt; a configuration &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; given &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; the command line, the system-wide configuration &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; (/etc/ssh/ssh_config) will be ignored.  The &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; the per-user configuration &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; ~/.ssh/config.&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Host 别名&lt;/strong&gt;：可随意指定，比如把 github 的 Host 别名设置为 banana，那你在测试的时候也可以输入&lt;code&gt;ssh -T banana&lt;/code&gt;，以后 clone 项目时也可以用 banana 代替 github.com 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;32&quot;&gt;
&lt;p&gt;&lt;strong&gt;User&lt;/strong&gt;: 注意它和 git 中的 user.name 不是一个概念。&lt;/p&gt;
&lt;p&gt;a. 配置文件中的 User 是登录提供 git 服务的平台（如这里的 github）的服务器主机时指定的用户名，比如 github 中 clone 项目时选择 ssh，链接均以 &lt;code&gt;git@github.com&lt;/code&gt;开头，@ 前面的 git 就是 github 对应服务器主机中的一个用户名，即上面设置的 User，@ 后面的 github.com 就是 HostName）；&lt;/p&gt;
&lt;p&gt;b. git 中的 user.name 是用来追踪代码的，提交代码时显示的作者名字就是它，比如在 github 中，我的 user.name 就是 xiaoxi666。这里引出了另外一个问题：&lt;strong&gt;我在本机中配置了多个 git 账号，如何在不同的项目中自动切换不同的作者名字？&lt;/strong&gt;比如我在公司的代码库里提交代码时，用的就是另外一个名字而非 xiaoxi666。这部分内容涉及到了 git 的配置（可以在终端输入 &lt;code&gt;git config --help&lt;/code&gt; 查看官方说明），你一定有过下面这种配置的经历：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;git config --&lt;span class=&quot;hljs-built_in&quot;&gt;global&lt;/span&gt; user.name &lt;span class=&quot;hljs-string&quot;&gt;&quot;user_name&quot;&lt;/span&gt;&lt;br/&gt;git config --&lt;span class=&quot;hljs-built_in&quot;&gt;global&lt;/span&gt; user.email &lt;span class=&quot;hljs-string&quot;&gt;&quot;user_name@example.com&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，git 有三种配置选项，分别对应于 --system 、--global、--local，上面就是 --global选项。三种配置选项分别对应于三个配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;--system  -&amp;gt;   /usr/local/git/etc/gitconfig&lt;br/&gt;--&lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt;  -&amp;gt;   ~/.gitconfig&lt;br/&gt;--local   -&amp;gt;   你的项目仓库路径/.git/config        &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这三种配置文件的优先级由低到高为：--system、--global、--local，优先级高的配置会覆盖优先级低的配置。一般情况下，我们不会去设置 --system 选项，主要用的是 --global 和 --local。正如网上满天飞的教程中，我们一般会设置 --global，这样就不用在每个项目中设置一遍了；但是如果配置了多个 git 账号，需要在一些项目中使用不同的作者名字，就需要单独为该项目设置 --local。需要注意的是， --local 选项只能 cd 到当前项目路径下中执行，否则会报错 fatal: --local can only be used inside a git repository。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注一：设置 --local 时记得同时设置 user.name 和 user.email，如果只设置 user.name，提交名字虽然正确了，但 user.email 还是用的 --global 中的 user.email，这会导致 github 仓库中显示的提交者却不会链接到你的账号：头像是灰色的八爪鱼，名字也没有链接。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注二：如果 --system、--global、--local 都没有设置 user.email，将无法提交代码，因为无法识别代码作者。在设置了 user.email 的前提下，如果 --system、--global、--local 都没有设置 user.name，则会使用计算机登录用户名作为代码提交的作者名字。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;配置文件可指定的参数还有很多，如端口等，这里我们直接使用默认端口 22，因此没有再去指定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;其他&lt;/span&gt;&lt;/h3&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;6.75&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;pbcopy&lt;/code&gt; 和 &lt;code&gt;pbpaste&lt;/code&gt; 是两个非常好用的命令，可查阅相关资料了解。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.67391304347826&quot;&gt;
&lt;p&gt;文章 &lt;a href=&quot;http://man.linuxde.net/ssh-add&quot; target=&quot;_blank&quot;&gt;http://man.linuxde.net/ssh-add&lt;/a&gt; 描述了 linux 的 ssh-add 命令，讲得不错。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;mac 分别有用户名、主机名(HostName)，以及计算机名。其中计算机名可以在 &quot;System Preference&quot; -&amp;gt; &quot;sharing&quot; 中设置，是分享时展示的名字；而主机名和用户名一般会在终端以如下两种格式显示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;用户名@主机名 当前路径 $&lt;/code&gt;&lt;br/&gt;&lt;code&gt;主机名:当前路径 用户名$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中主机名可以用以下命令设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;scutil –-&lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt; HostName new_hostname&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3.2297297297297&quot;&gt;
&lt;p&gt;有时我们需要添加或改变远程仓库的地址，两种命令分别为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;git remote &lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt; origin 项目地址&lt;br/&gt;git remote &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt;-url origin 项目地址&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中项目地址的格式为 ssh 或 https。可以参见文章 &lt;a href=&quot;https://help.github.com/articles/changing-a-remote-s-url/&quot; target=&quot;_blank&quot;&gt;https://help.github.com/articles/changing-a-remote-s-url/&lt;/a&gt; 加以了解。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 17 Nov 2018 15:32:00 +0000</pubDate>
<dc:creator>xiaoxi666</dc:creator>
<og:description>背景 在工作中，我们通常会以 ssh 的方式配置公司的 git 账号，但是平时也会使用 github 管理自己的项目。因此，我们需要为自己的 github 创建一个新的 git 账号，这就需要生成新的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxi666/p/9975981.html</dc:identifier>
</item>
<item>
<title>HBase——HMaster启动之二(HMaster线程的调用) - letsfly</title>
<link>http://www.cnblogs.com/letsfly/p/9976238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/letsfly/p/9976238.html</guid>
<description>&lt;p&gt;　　紧接着上一节HMaster的构建完成。接下来会调用HMaster调用master.start(),master.join()。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　由HMaster的继承关系，很明显，他是Runnable的子类。也就是说，在调用其start方法时，run方法被调用。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117225221920-480839085.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;img src=&quot;http://note.youdao.com/src/B22B262B9F1E415983168CA8456BD1DE&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;　　下面，让我们来到HMaster.run方法。这里的涉及到多线程编程。一方面HMaster所在线程调用了super.run方法。另一方面另外启动了一个daemon线程用于调用startActiveMasterManager方法。很多同学在这里可能就迷惑了，到底该先分析哪个呢，我在刚开始看的时候也比较懵逼，后来多分析了几次发现，殊途同归，先分析哪个都无所谓。下面，我先从简单的开始介绍。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117225354869-526268673.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;　让我们来到super.run的调用。来到这里一看，内容很多，各位同学不需要慌，让我们再进入preRegistrationInitialization一探究竟。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117225417076-1098365429.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;　　来到preRegistrationInitialization，各位同学可能有所迷惑，为什么比较关键的方法有三个，而我在这里之框选了一个呢。原因很简单，在HMaster启动期间，他还运行不到下面去。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117225937505-832933699.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;　　接着，让我们一探究竟。看了两个block方法，各位同学可能以为是在这里阻塞的，然而并不是，真正的等待是在下图框选的waitForMasterActive。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117225957870-1306414361.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;　　来到waitForMasterActive(由于在这里我们研究的是HMaster,因此，这里的方法应该是HMaster.waitForMasterActive)。这个方法虽然比较短，确实困扰了我很久的一个地方。下图框选的地方获得的默认值为false，而isStopped与isAborted的获得的初始值都是false。因此，HMaster在启动时，包括启动后，都一直在这里轮询等待。因为启动后只是将activeMaster置位false。在tablesOnMaster默认值为false的情况下，并没有任何作用。也就是说只有后面的两个值发生变动后，这种等待才会被打破。分析到这里，各位同学应该可以安心的分析那个守护线程了。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117230044576-2000410869.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　让我们来到HMaster.startActiveMasterManager方法中，首先通过调用activeMasterManager.blockUntilBecomingActiveMaster确定当前Master为ActiveMaster，然后再调用finishActiveMasterInitialization方法。这里我们只分析ActiveMaster的流程，并不介绍StandyMaster。在blockUntilBecomingActiveMaster方法中的调用并不是很难，感兴趣的同学可以简单。在activeMasterManager.blockUntilBecomingActiveMaster。这里我们把重点放在finishActiveMasterInitialization。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117230109974-1422720854.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　接下来让我们来到finishActiveMasterInitialization方法。&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;　　这个方法是出奇的长，在这里，我们还是按照一张张的来介绍，以避免大家到后面会忘记前面的。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117230132724-1077759261.png&quot; alt=&quot;&quot;/&gt;　　首先我们分析第一个方法initializeMemStoreChunkCreator，其实这里只是初始化了&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117230217225-1989785758.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117230912186-390769887.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;　　来到ChunkCreator的构造方法，我们可以看到其主要调用了initializePools方法&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117230930681-518808625.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　在initializePool方法中，主要构建了MemStoreChunkPool，并且将其加入heapMemoryManager的管理之中。而在构建MemStoreChunkPool的过程中，创建了Chunk，并将其放入reclaimedChunks中，初始化并开始周期调用统计线程StatisticsThread，将其内存数据打印出来。这里设计到HBase的内存管理，我将在后续的章节中专门拿出一讲来为大家讲解。这里就介绍到这。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117230955195-1238169657.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;　　接着来到MasterFileSystem的构造方法中，这里主要获得了fs与walFs。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117231020412-1433085437.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　接下来，让我们来到createServerManager方法中，在这里首先构建了clusterConnection对象，其中主要构建了ShortCircuitingClusterConnection与MetaTableLocator。这里简单略过，详细内容请看我的另外一篇博文《HBase之setupClusterConnection流程》。然后构造了ServerManager，他就是HMaster用于管理region servers信息的类。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117231109455-1210485191.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;　　再接下来，来到createProcedureExecutor，这是一个重量级的方法。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117231202188-592926634.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　让我们首先来到MasterProcedureEnv的构造方法，这个构造方法看似简单，却同时构造了两个重要的对象。RSProcedureDispatcher、MasterProcedureScheduler。其中的RSProcedureDispatcher负责HMaster向RegionServer的Procedure调用，而MasterProcedureScheduler负责的是Master自身的Procedure的调用。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117231219545-26765756.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;　　需要注意的是，在MasterProcedureScheduler中有几个队列的成员变量，他们的作用就是保存将要调用procedure，然后由具体线程调用。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117231345545-1763033998.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;　　接下来是WALProcedureStore，这里主要传入了一个LeaseRecovery对象，而他的实际类型是MasterProcedureEnv.WALStoreLeaseRecovery，他的主要作用是对hdfs的文件恢复租约。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117231400495-814798761.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;　　在ProcedureExecutor的构造方法中只是对其成员变量的赋值，并没有什么比较重要的方法。不过，在这里我们需要记住，在这里传入的store类型为WALProcedureStore，scheduler类型为MasterProcedureScheduler。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117231423015-843964723.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;　　接下来来到WALProcedureStore.start方法。在这里，根据传入的线程数初始化了Slot数量，并且启动WALProcedureStoreSyncThread线程用于调用syncLoop方法。这里就简单略过，我们先继续后面的流程。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117231440314-905301515.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;　　下面，来到ProcedureExecutor.init方法。这里将WorkerThread，添加到workerThread成员变量中。接着调用store.recoverLease，恢复相关文件的租约。然后调用scheduler.start，将scheduler中的running置位true。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117231457904-1659879209.png&quot; alt=&quot;&quot;/&gt;　　这里简单看一下WorkThread中的run方法。这里的流程在我的博文《hbase之InitMetaProcedure流程》中有相关介绍，感兴趣的大家可以去看一下。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117231657253-586342722.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　接下来来到finishActiveMasterInitialization的第二张图。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;　　首先创建了AssignmentManager，AssignmentManager的作用就是用来操作assign/unassign。然后调用了AssignmentManager.start方法。关于AssignmentManager的相关调用我在博文《HBase之AssignmentManager相关调用》中有介绍，感兴趣的同学可以去看一下。接下来构造并调用了RegionServerTracker，用于通过ZK跟踪在线RegionServers。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117231829834-1273033991.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　然后调用了initializeZKBasedSystemTrackers方法，在这里初始化了所有基于ZK的系统跟踪器。尽管如此，还是有些方法值得我们探究。首先介绍各种Tracker，这些都是直接或间接继承自ZKListener，或者将传入的ZK保存到自己的成员变量中用来实现对自己所在ZK目录中状态的监听。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117231849646-2039200159.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　然后来到LoadBalancerFactory.getLoadBalancer方法，这里调用ReflectionUtils.newInstance通过反射创建了StochasticLoadBalancer，同时由于StochasticLoadBalancer实现了Configurable接口。因此在通过反射创建了StochasticLoadBalancer，紧接着变调用了setConf方法。在StochasticLoadBalancer.setConf中调用了构造了各种CostFunction。在这里我们简单略过&lt;img src=&quot;http://note.youdao.com/src/0C88F437FE54460F96D46BE59A284E73&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117231908116-401991944.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　接下来来到方法的后面，这里构建了SnapshotManager、MasterFlushTableProcedureManager(二者都继承自抽象类ProcedureManagerHost)并且注册到创建的MasterProcedureManagerHost对象中。接着调用了MasterProcedureManagerHost.initialize，调用了刚刚注册进来的两个对象initialize方法。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117231948315-473513334.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;　　接下来来到finishActiveMasterInitialization的下一张图。如果已经不是第一次调用，那么就不会调用框二中所选的内容，不过，感兴趣的同学可以去看我的博客《hbase之InitMetaProcedure流程》。这里我们只介绍框一与框三中的内容。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117232029860-1449166042.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　来到HMaster.startServiceThreads。这里的executorService大家可能已经忘记了，他是在HMaster构造时实例化的(具体是在HMaster的父类HRegionServer构造的最后)。通过调用executorService.startExecutorService，ExecutorType的类型与最大线程数量传入ExecutorService.startExecutorService，构造了相应名称的线程池，并且将其置于ExecutorService的成员变量executorMap的管理之下。接下来我们简单介绍一下getChoreService().scheduleChore。这是ScheduledChore调用的通用方式，通过getChoreService获取初始化的成员变量choreService(同样在HMaster的父类HRegionServer构造的最后实例化的)，然后调用其scheduleChore方法，在上面我已经讲过了，这里就不再赘述了。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117232046227-281113462.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;　　接着调用waitForRegionServers等待RegionServer的注册。关于HMaster与HRegionServer的交互流程我在以后的章节中会介绍到。接下来调用waitUntilMetaOnline，等待hbase:meta上线并且可读。以为后面assignmentManager.joinCluster中loadMeta做准备。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117232107677-1502701847.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　接下来，我们首先来到assignmentManager.joinCluster&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;　　在loadMeta中，主要用于载入hbase:meta的各个Region,并且将其加入到regionStates的管理中。接下来调用processOfflineRegions，当前保存在AssignmentManager.regionStates中，其状态OFFLINE的Regions。然后将成员变量ritChore加入到ProcedureExecutor的timeoutExecutor中。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117232130033-2070637083.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;　　接下来调用了TableStateManager.start，将当前的表都置于TableStateManager的管理之中。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117232152221-1074908381.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　下面框选中的内容虽然多，但是，我们只是简单介绍。因为这里已经不是很主要的流程了。首先是几个ScheduledChore的子类构建并调用。接着，调用ServerManager.startChore其主要讲FlushedSequenceIdFlusher这个ScheduledChore构建并开始调用。然后，调用了initClusterSchemaService、cpHost.preMasterInitialization。最后，将三个ConfigurationObserver注册到configurationManager中。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117232205246-1622362036.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;　　来到FAMI中的最后一张图，这里我们只是引出，关于其中具体的流程，我们将在后面意义道来。在后面主要介绍initMobCleaner。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117232242887-262744256.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　下图首先构建了ExpiredMobFileCleanerChore(这个ScheduledChore用于定期删除过期的mob文件)，然后将其加入到choreService中并启动。紧接着构建并启动了MobCompactionChore，这个ScheduledChore用于定期压缩以合并小的mob文件。然后构建了MasterMobCompactionThread。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181117232305057-1634347958.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　至此，HMaster的启动流程就完成了，感谢大家内心观看。说实话，不仅各位看的辛苦，小编我写的也很辛苦，所以，留下你的赞，小编更有动力发表更好的文章。&lt;/p&gt;
&lt;p&gt;　　学完这一节，很多同学可能会对netty的原理想要有比较深入的了解。请各位同学不要着急，在介绍完HBase中比较重要的流程，小编就会为大家带来netty的深入应用以及源码剖析。请大家持续关注。&lt;/p&gt;
</description>
<pubDate>Sat, 17 Nov 2018 15:28:00 +0000</pubDate>
<dc:creator>letsfly</dc:creator>
<og:description>紧接着上一节HMaster的构建完成。接下来会调用HMaster调用master.start(),master.join()。 由HMaster的继承关系，很明显，他是Runnable的子类。也就是说</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/letsfly/p/9976238.html</dc:identifier>
</item>
<item>
<title>[译]RabbitMQ教程C#版 - 远程过程调用(RPC) - Esofar</title>
<link>http://www.cnblogs.com/esofar/p/rabbitmq-rpc.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/esofar/p/rabbitmq-rpc.html</guid>
<description>&lt;blockquote readability=&quot;8.625&quot;&gt;
&lt;p&gt;&lt;strong&gt;先决条件&lt;/strong&gt;&lt;br/&gt;本教程假定 RabbitMQ 已经安装，并运行在&lt;code&gt;localhost&lt;/code&gt;标准端口（5672）。如果你使用不同的主机、端口或证书，则需要调整连接设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从哪里获得帮助&lt;/strong&gt;&lt;br/&gt;如果您在阅读本教程时遇到困难，可以通过邮件列表 &lt;a href=&quot;https://groups.google.com/forum/#!forum/rabbitmq-users&quot;&gt;联系我们&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在第 &lt;a href=&quot;https://www.cnblogs.com/esofar/p/rabbitmq-work-queues.html&quot;&gt;教程[2]&lt;/a&gt; 中，我们学习了如何使用工作队列在多个工作单元之间分配耗时任务。&lt;/p&gt;
&lt;p&gt;但是如果我们想要运行一个在远程计算机上的函数并等待其结果呢？这将是另外一回事了。这种模式通常被称为 &lt;em&gt;远程过程调用&lt;/em&gt; 或 &lt;em&gt;RPC&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;在本篇教程中，我们将使用 RabbitMQ 构建一个 RPC 系统：一个客户端和一个可扩展的 RPC 服务器。由于我们没有什么耗时任务值得分发，那干脆就创建一个返回斐波那契数列的虚拟 RPC 服务吧。&lt;/p&gt;
&lt;h2 id=&quot;客户端接口&quot;&gt;客户端接口&lt;/h2&gt;
&lt;p&gt;为了说明如何使用 RPC 服务，我们将创建一个简单的客户端类。该类将暴露一个名为&lt;code&gt;Call&lt;/code&gt;的方法，用来发送 RPC 请求并且保持阻塞状态，直到接收到应答为止。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var rpcClient = new RPCClient();

Console.WriteLine(&quot; [x] Requesting fib(30)&quot;);
var response = rpcClient.Call(&quot;30&quot;);
Console.WriteLine(&quot; [.] Got '{0}'&quot;, response);

rpcClient.Close();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;关于 RPC 的说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽管 RPC 在计算机中是一种很常见的模式，但它经常受到批评。问题出现在当程序员不知道一个函数是本地调用还是一个耗时的 RPC 请求。这样的混淆，会导致系统不可预测，以及给调试增加不必要的复杂性。误用 RPC 可能会导致不可维护的混乱代码，而不是简化软件。&lt;/p&gt;
&lt;p&gt;牢记这些限制，请考虑如下建议：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确保可以明显区分哪些函数是本地调用，哪些是远程调用。&lt;/li&gt;
&lt;li&gt;为您的系统编写文档，明确组件之间的依赖关系。&lt;/li&gt;
&lt;li&gt;捕获异常，当 RPC 服务长时间宕机时客户端该如何应对。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当有疑问的时候可以先避免使用 RPC。如果可以的话，考虑使用异步管道 - 而不是类似 RPC 的阻塞，其会将结果以异步的方式推送到下一个计算阶段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;回调队列&quot;&gt;回调队列&lt;/h2&gt;
&lt;p&gt;一般来讲，基于 RabbitMQ 进行 RPC 通信是非常简单的，客户端发送一个请求消息，然后服务端用一个响应消息作为应答。为了能接收到响应，我们需要在发送请求过程中指定一个'callback'队列地址。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var props = channel.CreateBasicProperties();
props.ReplyTo = replyQueueName;

var messageBytes = Encoding.UTF8.GetBytes(message);
channel.BasicPublish(exchange: &quot;&quot;,
                     routingKey: &quot;rpc_queue&quot;,
                     basicProperties: props,
                     body: messageBytes);

// ... then code to read a response message from the callback_queue ...&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7.895652173913&quot;&gt;
&lt;p&gt;&lt;strong&gt;消息属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AMQP 0-9-1 协议在消息中预定义了一个包含 14 个属性的集合，大多数属性很少使用，但以下情况除外：&lt;br/&gt;&lt;code&gt;Persistent&lt;/code&gt;：将消息标记为持久的（值为2）或者瞬时的（其他值），可以参考 &lt;a href=&quot;https://www.cnblogs.com/esofar/p/rabbitmq-work-queues.html&quot;&gt;教程[2]&lt;/a&gt;。&lt;br/&gt;&lt;code&gt;DeliveryMode&lt;/code&gt;：熟悉 AMQP 协议的人可以选择此属性而不是熟悉协议的人可以选择使用此属性而不是&lt;code&gt;Persistent&lt;/code&gt;，它们控制的东西是一样的。&lt;br/&gt;&lt;code&gt;ContentType&lt;/code&gt;：用于描述编码的 mime 类型。例如，对于经常使用的 JSON 编码，将此属性设置为：&lt;code&gt;application/json&lt;/code&gt;是一种很好的做法。&lt;br/&gt;&lt;code&gt;ReplyTo&lt;/code&gt;：通常用于命名回调队列。&lt;br/&gt;&lt;code&gt;CorrelationId&lt;/code&gt;：用于将 RPC 响应与请求相关联。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关联id&quot;&gt;关联ID&lt;/h2&gt;
&lt;p&gt;在上面介绍的方法中，我们建议为每个 RPC 请求创建一个回调队列，但是这种方式效率低。幸运的是我们有一种更好的方式，那就是为每个客户端创建一个独立的回调队列。&lt;/p&gt;
&lt;p&gt;这种方式会引出一个新的问题，在收到响应的回调队列中，它无法区分响应属于哪一个请求，此时便是&lt;code&gt;CorrelationId&lt;/code&gt;属性的所用之处。我们将为每个请求的&lt;code&gt;CorrelationId&lt;/code&gt;设置一个唯一值。之后当我们在回调队列接收到响应的时候，再去检查下这个属性是否和请求中的值匹配，如此一来，我们就可以把响应和请求关联起来了。如果出现一个未知的&lt;code&gt;CorrelationId&lt;/code&gt;值，我们可以安全的销毁这个消息，因为这个消息不属于我们的请求。&lt;/p&gt;
&lt;p&gt;你可能会问，为什么我们应该忽略回调队列中的未知的消息，而不是用错误来标识失败呢？这是因为于服务器端可能存在竞争条件。虽然不太可能，但是 RPC 服务器可能在仅发送了响应消息而未发送消息确认的情况下挂掉，如果出现这种情况，RPC 服务器重启之后将会重新处理该请求。这就是为什么在客户端上我们必须优雅地处理重复的响应，并且理想情况下 RPC 应该是幂等的。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/785976/201811/785976-20181117212349010-1581646652.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的 RPC 会是这样工作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端启动时，会创建一个匿名的独占回调队列。&lt;/li&gt;
&lt;li&gt;对于 RPC 请求，客户端发送带有两个属性的消息：&lt;code&gt;ReplyTo&lt;/code&gt;（设置为回调队列）和&lt;code&gt;CorrelationId&lt;/code&gt;（为每个请求设置唯一值）。&lt;/li&gt;
&lt;li&gt;请求被发送到&lt;code&gt;rpc_queue&lt;/code&gt;队列。&lt;/li&gt;
&lt;li&gt;RPC 工作线程（或者叫：服务器）正在等待该队列上的请求。当出现请求时，它会执行该作业，并使用&lt;code&gt;ReplyTo&lt;/code&gt;属性设置的队列将带有结果的消息发送回客户端。&lt;/li&gt;
&lt;li&gt;客户端等待回调队列上的数据。出现消息时，它会检查&lt;code&gt;CorrelationId&lt;/code&gt;属性。如果它与请求中的值匹配，则返回对应用程序的响应。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;组合在一起&quot;&gt;组合在一起&lt;/h2&gt;
&lt;p&gt;斐波纳契 任务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static int fib(int n)
{
    if (n == 0 || n == 1) return n;
    return fib(n - 1) + fib(n - 2);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们宣布我们的斐波那契函数。并假定只允许有效的正整数输入。 （不要期望这个适用于大数字，它可能是最慢的递归实现）。&lt;/p&gt;
&lt;p&gt;我们的 RPC 服务端代码 &lt;a href=&quot;https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/RPCServer/RPCServer.cs&quot;&gt;RPCServer.cs&lt;/a&gt; 看起来如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using System.Text;

class RPCServer
{
    public static void Main()
    {
        var factory = new ConnectionFactory() { HostName = &quot;localhost&quot; };
        using (var connection = factory.CreateConnection())
        using (var channel = connection.CreateModel())
        {
            channel.QueueDeclare(queue: &quot;rpc_queue&quot;, durable: false,
              exclusive: false, autoDelete: false, arguments: null);
            channel.BasicQos(0, 1, false);
            var consumer = new EventingBasicConsumer(channel);
            channel.BasicConsume(queue: &quot;rpc_queue&quot;,
              autoAck: false, consumer: consumer);
            Console.WriteLine(&quot; [x] Awaiting RPC requests&quot;);

            consumer.Received += (model, ea) =&amp;gt;
            {
                string response = null;

                var body = ea.Body;
                var props = ea.BasicProperties;
                var replyProps = channel.CreateBasicProperties();
                replyProps.CorrelationId = props.CorrelationId;

                try
                {
                    var message = Encoding.UTF8.GetString(body);
                    int n = int.Parse(message);
                    Console.WriteLine(&quot; [.] fib({0})&quot;, message);
                    response = fib(n).ToString();
                }
                catch (Exception e)
                {
                    Console.WriteLine(&quot; [.] &quot; + e.Message);
                    response = &quot;&quot;;
                }
                finally
                {
                    var responseBytes = Encoding.UTF8.GetBytes(response);
                    channel.BasicPublish(exchange: &quot;&quot;, routingKey: props.ReplyTo,
                      basicProperties: replyProps, body: responseBytes);
                    channel.BasicAck(deliveryTag: ea.DeliveryTag,
                      multiple: false);
                }
            };

            Console.WriteLine(&quot; Press [enter] to exit.&quot;);
            Console.ReadLine();
        }
    }

    /// 

    /// Assumes only valid positive integer input.
    /// Don't expect this one to work for big numbers, and it's
    /// probably the slowest recursive implementation possible.
    /// 
    private static int fib(int n)
    {
        if (n == 0 || n == 1)
        {
            return n;
        }

        return fib(n - 1) + fib(n - 2);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务端代码非常简单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;像往常一样，首先建立连接，通道和声明队列。&lt;/li&gt;
&lt;li&gt;我们可能希望运行多个服务器进程。为了在多个服务器上平均分配负载，我们需要设置&lt;code&gt;channel.BasicQos&lt;/code&gt;中的&lt;code&gt;prefetchCount&lt;/code&gt;值。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;BasicConsume&lt;/code&gt;访问队列，然后注册一个交付处理程序，并在其中完成工作并发回响应。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们的 RPC 客户端 &lt;a href=&quot;https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/RPCClient/RPCClient.cs&quot;&gt;RPCClient.cs&lt;/a&gt; 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System;
using System.Collections.Concurrent;
using System.Text;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;

public class RpcClient
{
    private readonly IConnection connection;
    private readonly IModel channel;
    private readonly string replyQueueName;
    private readonly EventingBasicConsumer consumer;
    private readonly BlockingCollection&amp;lt;string&amp;gt; respQueue = new BlockingCollection&amp;lt;string&amp;gt;();
    private readonly IBasicProperties props;

public RpcClient()
{
        var factory = new ConnectionFactory() { HostName = &quot;localhost&quot; };

        connection = factory.CreateConnection();
        channel = connection.CreateModel();
        replyQueueName = channel.QueueDeclare().QueueName;
        consumer = new EventingBasicConsumer(channel);

        props = channel.CreateBasicProperties();
        var correlationId = Guid.NewGuid().ToString();
        props.CorrelationId = correlationId;
        props.ReplyTo = replyQueueName;

        consumer.Received += (model, ea) =&amp;gt;
        {
            var body = ea.Body;
            var response = Encoding.UTF8.GetString(body);
            if (ea.BasicProperties.CorrelationId == correlationId)
            {
                respQueue.Add(response);
            }
        };
    }

    public string Call(string message)
    {
        var messageBytes = Encoding.UTF8.GetBytes(message);
        channel.BasicPublish(
            exchange: &quot;&quot;,
            routingKey: &quot;rpc_queue&quot;,
            basicProperties: props,
            body: messageBytes);

        channel.BasicConsume(
            consumer: consumer,
            queue: replyQueueName,
            autoAck: true);

        return respQueue.Take(); ;
    }

    public void Close()
    {
        connection.Close();
    }
}

public class Rpc
{
    public static void Main()
    {
        var rpcClient = new RpcClient();

        Console.WriteLine(&quot; [x] Requesting fib(30)&quot;);
        var response = rpcClient.Call(&quot;30&quot;);

        Console.WriteLine(&quot; [.] Got '{0}'&quot;, response);
        rpcClient.Close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端代码稍微复杂一些：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;建立连接和通道，并为响应声明一个独有的 'callback' 队列。&lt;/li&gt;
&lt;li&gt;订阅这个 'callback' 队列，以便可以接收到 RPC 响应。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Call&lt;/code&gt;方法用来生成实际的 RPC 请求。&lt;/li&gt;
&lt;li&gt;在这里，我们首先生成一个唯一的&lt;code&gt;CorrelationId&lt;/code&gt;编号并保存它，while 循环会使用该值来捕获匹配的响应。&lt;/li&gt;
&lt;li&gt;接下来，我们发布请求消息，其中包含两个属性：&lt;code&gt;ReplyTo&lt;/code&gt;和&lt;code&gt;CorrelationId&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;此时，我们可以坐下来稍微一等，直到指定的响应到来。&lt;/li&gt;
&lt;li&gt;while 循环做的工作非常简单，对于每个响应消息，它都会检查&lt;code&gt;CorrelationId&lt;/code&gt;是否是我们正在寻找的那一个。如果是这样，它就会保存该响应。&lt;/li&gt;
&lt;li&gt;最后，我们将响应返回给用户。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;客户发出请求：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var rpcClient = new RPCClient();

Console.WriteLine(&quot; [x] Requesting fib(30)&quot;);
var response = rpcClient.Call(&quot;30&quot;);
Console.WriteLine(&quot; [.] Got '{0}'&quot;, response);

rpcClient.Close();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在是查看 &lt;a href=&quot;https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/RPCClient/RPCClient.cs&quot;&gt;RPCClient.cs&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/RPCServer/RPCServer.cs&quot;&gt;RPCServer.cs&lt;/a&gt; 的完整示例源代码（包括基本异常处理）的好时机哦。&lt;/p&gt;
&lt;p&gt;像往常一样设置（请参见 &lt;a href=&quot;https://www.cnblogs.com/esofar/p/rabbitmq-hello-world.html&quot;&gt;教程[1]&lt;/a&gt;]）：&lt;/p&gt;
&lt;p&gt;我们的 RPC 服务现已准备就绪，现在可以启动服务端：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd RPCServer
dotnet run
# =&amp;gt; [x] Awaiting RPC requests&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要请求斐波纳契数，请运行客户端：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd RPCClient
dotnet run
# =&amp;gt; [x] Requesting fib(30)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里介绍的设计并不是 RPC 服务的唯一可能实现，但它仍具有一些重要优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果 RPC 服务器太慢，您可以通过运行另一个服务器来扩展。尝试在新开一个控制台，运行第二个 RPCServer。&lt;/li&gt;
&lt;li&gt;在客户端，RPC 只需要发送和接收一条消息。不需要像&lt;code&gt;QueueDeclare&lt;/code&gt;一样同步调用。因此，对于单个 RPC 请求，RPC 客户端只需要一次网络往返。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们的代码很简单，也并没有尝试去解决更复杂（但很重要）的问题，比如就像：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果服务端没有运行，客户端应该如何反应？&lt;/li&gt;
&lt;li&gt;客户端是否应该为 RPC 设置某种超时机制？&lt;/li&gt;
&lt;li&gt;如果服务端出现故障并引发异常，是否应将其转发给客户端？&lt;/li&gt;
&lt;li&gt;在处理之前防止无效的传入消息（例如：检查边界、类型）。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;4.4943820224719&quot;&gt;
&lt;p&gt;如果您想进行实验，您可能会发现 &lt;a href=&quot;http://www.rabbitmq.com/management.html&quot;&gt;管理 UI&lt;/a&gt; 对于查看队列非常有用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;本文翻译自 RabbitMQ 官方教程 C# 版本。如本文介绍内容与官方有所出入，请以官方最新内容为准。水平有限，翻译的不好请见谅，如有翻译错误还请指正。&lt;/p&gt;
</description>
<pubDate>Sat, 17 Nov 2018 14:59:00 +0000</pubDate>
<dc:creator>Esofar</dc:creator>
<og:description>先决条件 本教程假定 RabbitMQ 已经安装，并运行在 标准端口（5672）。如果你使用不同的主机、端口或证书，则需要调整连接设置。 从哪里获得帮助 如果您在阅读本教程时遇到困难，可以通过邮件列表</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/esofar/p/rabbitmq-rpc.html</dc:identifier>
</item>
<item>
<title>限流的简单使用及学习 - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/b7a4ab721dcf0cfcb620eed21c6388a5.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/b7a4ab721dcf0cfcb620eed21c6388a5.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近系统刚做了一次大的重构，以及下游子服务都做了升级改造。&lt;/p&gt;
&lt;p&gt;整个系统间的调用都是采用spring cloud这一套去实现的。我所负责的为业务服务端，专门为web端和pc端提供接口调用。在服务刚上线的一段时间，出现了一次雪崩的事件，整个调用链路如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201811/799093-20181117215553923-477550589.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;调用链路很简单，因为文本匹配服务 需要分词，匹配，已经从ES获取匹配后的术语语料等数据，所以会有请求挤压，一段时间类服务就崩溃了。为了紧急处理这种情况，所以需要再业务方加上限流机制（后续优化下游的匹配算法）。刚好也针对于这种情况，自己来学习下几种限流的方式。&lt;/p&gt;
&lt;h3 id=&quot;限流算法分类&quot;&gt;限流算法分类&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参见的限流算法有：令牌桶，漏桶，计数器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;计数器限流算法&quot;&gt;计数器限流算法&lt;/h4&gt;
&lt;p&gt;计数器是最简单也是最粗暴的一种限流算法，同时也是比较常用的，主要用来限制总并发数，比如数据库连接池大小、线程池大小、程序访问并发数等都是使用计数器算法。&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;使用Redis的限流做法：&lt;/li&gt;
&lt;/ol&gt;&lt;div data-mode=&quot;java&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 限流方法，通过redis进行方法级别的限流措施。
 */
@Service
@Transactional
@Slf4j
public class MethodThrottleService {

    @Autowired
    private RedisTemplate&amp;lt;String, String&amp;gt; redisTemplate;

    /**
     * 通过指定key值获取是否是合法请求，如果在规定缓存时间内仍然存在该key值，说明该请求不合法
     *
     * @param key        请求key值
     * @param expireTime 过期时间
     * @param timeUnit   过期时间单位
     * @return 是否过期 true || false
     */
    public Boolean validateKeyRequest(String key, int expireTime, TimeUnit timeUnit) {
        ValueOperations&amp;lt;String, String&amp;gt; ops = redisTemplate.opsForValue();
        String result = ops.get(key);
        if (StringUtils.isNotBlank(result)) {
            return false;
        }

        ops.set(key, key, expireTime, timeUnit);
        return true;
    }

    /**
     * 通过指定用户和方法名判断请求是否合法请求，如果在规定缓存时间内仍然存在该key值，说明该请求不合法
     *
     * @param methodName 方法名
     * @param perCount   规定时间请求的次数
     * @param iolId      用户名
     * @return 是否过期 true || false
     */
    public Boolean validateUserRequest(String methodName, int perCount, String iolId, int expireTime, TimeUnit timeUnit) {
        ValueOperations&amp;lt;String, String&amp;gt; ops = redisTemplate.opsForValue();
        String cacheKey = getCacheKey(iolId, methodName);
        Long requestCount = ops.increment(cacheKey, 1);
        log.info(&quot;requestCount = {}&quot;, requestCount);
        redisTemplate.expire(cacheKey,expireTime, timeUnit );
        if (requestCount &amp;gt;= perCount) {
            log.info(&quot;MethodThrottle exceed weight limit！ iolId = {}, methodName = {}, requestCount = {}&quot;, iolId, methodName, requestCount);
            return false;
        }

        return true;
    }

    /**
     * 获取缓存的key值
     * @param targetName 目标名称
     * @param methodName 方法名称
     * @return 缓存key
      */
    private String getCacheKey(String targetName, String methodName) {
        StringBuilder sb = new StringBuilder(&quot;&quot;);
        sb.append(&quot;limitRate.&quot;).append(targetName).append(&quot;.&quot;).append(methodName);
        return sb.toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用redis限流，可以针对于用户+方法名进行精准限流。同时可以根据请求key值进行限流，目的是限定规定时间类同样参数的请求次数。&lt;br/&gt;但是redis 限流会有很大的性能瓶颈，频繁的写入，读取，过期会对redis性能损耗比较大。不建议此种方法。&lt;br/&gt;另外计数器还可以使用&lt;code&gt;AtomicInteger&lt;/code&gt; 和 &lt;code&gt;Semaphore&lt;/code&gt;，具体就不在这列出代码了，具体可以参考：&lt;a href=&quot;https://www.jianshu.com/p/d11baa736d22&quot;&gt;Java限流策略-简书&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;令牌桶算法&quot;&gt;令牌桶算法&lt;/h4&gt;
&lt;p&gt;令牌桶算法是一个存放固定容量的令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：（参考开涛：亿级流量网站架构核心技术 中第4章部分内容）&lt;br/&gt;如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌；&lt;/li&gt;
&lt;li&gt;桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝；&lt;br/&gt;-当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上；&lt;br/&gt;-如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201811/799093-20181117215554822-1898457493.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;备注（10r/s： 一秒钟10令牌放入桶中）&lt;br/&gt;对于令牌桶限流，我们可以使用&lt;code&gt;Guava&lt;/code&gt;开源得到&lt;code&gt;RateLimiter&lt;/code&gt; 来做，具体可以参考如下代码：&lt;/p&gt;
&lt;div data-mode=&quot;java&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code&gt;//每秒只发出10个令牌
RateLimiter rateLimiter = RateLimiter.create(10);
/**
 * 尝试获取令牌
 *
 * @return 获取令牌是否成功 true || false
 */
public boolean tryAcquire() {
    return rateLimiter.tryAcquire();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;漏桶算法&quot;&gt;漏桶算法&lt;/h4&gt;
&lt;p&gt;漏桶作为计量工具（The Leaky Bucket Algorithm as a Meter）时，可以用于流量整形（Traffic Shaping）和流量控制（TrafficPolicing），漏桶算法的描述如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个固定容量的漏桶，按照常量固定速率流出水滴；&lt;/li&gt;
&lt;li&gt;如果桶是空的，则不需流出水滴；&lt;/li&gt;
&lt;li&gt;可以以任意速率流入水滴到漏桶；&lt;/li&gt;
&lt;li&gt;如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201811/799093-20181117215555274-667164208.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;令牌桶和漏桶对比：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求；&lt;/li&gt;
&lt;li&gt;漏桶则是按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝；&lt;/li&gt;
&lt;li&gt;令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌），并允许一定程度突发流量；&lt;/li&gt;
&lt;li&gt;漏桶限制的是常量流出速率（即流出速率是一个固定常量值，比如都是1的速率流出，而不能一次是1，下次又是2），从而平滑突发流入速率；&lt;/li&gt;
&lt;li&gt;令牌桶允许一定程度的突发，而漏桶主要目的是平滑流入速率；&lt;/li&gt;
&lt;li&gt;两个算法实现可以一样，但是方向是相反的，对于相同的参数得到的限流效果是一样的。&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Sat, 17 Nov 2018 13:56:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>前言 最近系统刚做了一次大的重构，以及下游子服务都做了升级改造。 整个系统间的调用都是采用spring cloud这一套去实现的。我所负责的为业务服务端，专门为web端和pc端提供接口调用。在服务刚上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wang-meng/p/b7a4ab721dcf0cfcb620eed21c6388a5.html</dc:identifier>
</item>
<item>
<title>孤荷凌寒自学python第十天序列之字符串的常用方法 - 孤荷凌寒</title>
<link>http://www.cnblogs.com/lhghroom/p/9975798.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lhghroom/p/9975798.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Python的字符串操作方法非常丰富，原生支持字符串的多种操作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 查找子字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;string.find(str,[beg=0],[end=len(string)])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从字符串string中寻找str，可以指定从string的beg位置起开始找，直到string的end位置结束寻找。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数beg和end是可选参数，如果不指定那么，默认从string的最开头，即index为0的位置开始找，直到string整个字符串都找完。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Str可以是单个字符，也可以是一个字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此方法会返回一个int类型的对象值。表示str这个字符串的第一个字符位于string字符串中的index值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strLong='孤荷凌寒的QQ号是：578652607'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strShort='QQ'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strLong.find(strShort))   #从strLong中寻找strShort，没有指定从strLong的起始index和结束index中去找，则默认寻找strLong的全部字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   #返回值5表示strShort代表的值’QQ’在strLong 的index值的第5位开始。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; intTemp=strLong.find(strShort,4)    #从strLong中寻找strShort，这一次指定了从strLong的index值为4的字符开始往后寻找，直到最后。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(intTemp)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   #返回值仍然是5！！！表示strShort代表的值’QQ’在strLong 的index值的第5位开始。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; intTemp=strLong.find(strShort,6)    #从strLong中寻找strShort，这一次指定了从strLong的index值为6的字符开始往后寻找，但因为从第6位字符开找是找不到的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(intTemp)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   #返回值是-1。表示是没有找到的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; intTemp=strLong.find(strShort,2,8)    #从strLong中寻找strShort，这一次指定了从strLong的index值为4的字符开始往后寻找，也指定了要一直找到strLong的index值为8的字符处为止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(intTemp)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#返回值仍然是5！！！表示strShort代表的值’QQ’在strLong 的index值的第5位开始。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2 将列表等对象连接成字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;connetString.join(obj)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此处的连接成字符串是指将如列表等中的多个元素合并成一个字符串。而不是指将两个字符串连接起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;connectString指的是连接字符或连接字符串，意思是要用哪个符号来间隔列表中的多个元素，使其作为连接字符将列表中的多个元素合并成一个字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Obj是指如列表等需要合并其中元素为一个完整字符串的对象，可以为多种可以接受的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此方法将返回合并后的字符串对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strLst='孤荷凌寒小时候家里很穷。'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstStr=list(strLst)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstStr)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['孤', '荷', '凌', '寒', '小', '时', '候', '家', '里', '很', '穷', '。']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strConnect=&quot;-&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strConnect.join(lstStr)   #特别注意这儿的写法，此join方法是由连接字符或连接字符串发出的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;'孤-荷-凌-寒-小-时-候-家-里-很-穷-。'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strEnd=strConnect.join(lstStr)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strEnd)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;孤-荷-凌-寒-小-时-候-家-里-很-穷-。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了可以将列表的内容合并起来，其它非标准的序列也可以使用join方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; objA='','我','是','自','学','Python','的','孤','荷','凌','寒',''&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strConnect='=='&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strResult=strConnect.join(objA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strResult)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;==我==是==自==学==Python==的==孤==荷==凌==寒==&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3 将字符串的所有字符全部变成小写，只针对英文字符部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;string.lower()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;string是指要进行处理的字符串对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此方法并不将改变string对象本身，而是返回一个改变后的新的字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strLs='孤荷凌寒的QQ号码是578652607'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strResult=strLs.lower()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strLs)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;孤荷凌寒的QQ号码是578652607  #strLs本身的值并没有改变&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strResult)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;孤荷凌寒的qq号码是578652607&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4 将字符串的所有字符全部变成大写，只针对英文字符部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;string.upper()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;string是指要进行处理的字符串对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此方法并不将改变string对象本身，而是返回一个改变后的新的字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strLs='孤荷凌寒的qq号码是578652607'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strResult=strLs.upper()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strLs)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;孤荷凌寒的qq号码是578652607  #strLs本身的值并没有改变&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strResult)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;孤荷凌寒的QQ号码是578652607&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5 将字符串的所有英文字符进行大小写字母的反转，原来是大写字母的换成小写字母，原来是小写字母的，换成大写字母。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;string.swapcase()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;string是指要进行处理的字符串对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此方法并不将改变string对象本身，而是返回一个改变后的新的字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strLs='孤荷凌寒的qq号码是578652607,这是QQ号码哦。'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strResult=strLs.upper()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strLs)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;孤荷凌寒的qq号码是578652607,这是QQ号码哦。  #strLs本身的值并没有改变&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strResult)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;孤荷凌寒的QQ号码是578652607,这是qq号码哦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6 查找并替换字符串中的子字符或子字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;String.replace(oldkey,newkey[,maxcount])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;String是指要进行查找并替换操作的长字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数oldkey是指要查找的子字符串；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数newkey是指要将查找到的子字符串替换成的新字符串；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可选参数maxcount是最多替换次数，是指如果在String中找到了多个oldkey，那么最多只替换前面maxcount个oldkey为newkey。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此方法并不改变String的值，而是返回一个新的替换操作完成后的新字符串对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strLong='孤荷凌寒小时候家里很穷。孤荷凌寒小时候最大的心愿就是能够考个大学。但家里实在太穷，甚至没有钱上高中，孤荷凌寒后来初中毕业后只好读了中等师范学校。'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strOldKey='孤荷凌寒'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strNewKey='我'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strResult=strLong.replace(strOldKey,strNewKey,2) #本来有三个strOldKey,但只替换前面两个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strLong)  #strLong本身的值并没有改变&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;孤荷凌寒小时候家里很穷。孤荷凌寒小时候最大的心愿就是能够考个大学。但家里实在太穷，甚至没有钱上高中，孤荷凌寒后来初中毕业后只好读了中等师范学校。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strResult)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我小时候家里很穷。我小时候最大的心愿就是能够考个大学。但家里实在太穷，甚至没有钱上高中，孤荷凌寒后来初中毕业后只好读了中等师范学校。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7 将字符串按指定的分隔符号或分隔字符串切割开并成为列表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;String.split([strCutCharOrString][,maxcount=string.count(String)])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;String是指要被切割的字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可选参数 strCutCharOrString 表示分隔标识字符或字符串，如果 不指定，默认为空格。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可选参数 maxcount 表示最多切割几次，如果不指定，则默认在String中找到多少个strCutCharOrString就切割几次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本方法返回一个列表对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strLong='1997年9月，孤荷凌寒进入中等师范学校学习，中等师范学校在过去是专门培养小学老师的学校，与中专一样，学制三年，可惜当时中等师范学校是不教习英语与计算机的，也没有高深的数学课程。'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strCutChar='，'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; intCutCount=5  #在strLong中本来有六个strCutChar,即中文逗号有六个,但只在前面五个地方进行切割。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstResult=strLong.split(strCutChar,intCutCount)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstResult)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['1997年9月', '孤荷凌寒进入中等师范学校学习', '中等师范学校在过去是专门培养小学老师的学校', '与中专一样', '学制三年', '可惜当时中等师范学校是不教习英语与计算机的，也没有高深的数学课程。']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8 删除一个字符串首和尾指定的字符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;String.strip([charOrChars])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;String是指要被删除首和尾指定字符的字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可选参数charOrChars是指要删除的处于字符串String首和尾的哪个字符或哪些字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果不指定charOrChars参数，则默认删除掉字符串String首和尾的空格字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;charOrChars参数可以只传入单个字符；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;charOrChars参数也可以传入一个字符串，则会将charOrChars参数字符串中的每一个字符都执行一次操作，而不是将charOrChars参数字符串整体执行一次操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此方法不对原字符串String的值进行任何修改，而是返回一个新的去除了首尾指定字符后的新字符串对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strTemp='    孤 荷 凌 寒    '&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strR=strTemp.strip()   #strip方法没有指定可选参数，则默认去除strTemp首尾的空格字符，注意并不会删除strTemp字符串中间的空格&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strTemp)   #strTemp本身的值并没有被修改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    孤 荷 凌 寒   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strR)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;孤 荷 凌 寒&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print('---' + strTemp + '---')  #在前后加上’---’方便看首尾空格是否还存在。   #strTemp本身的值并没有被修改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---    孤 荷 凌 寒    ---&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print('---' + strR + '---')  #在前后加上’---’方便看首尾空格是否还存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---孤 荷 凌 寒---&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strTemp='1234孤1荷2凌3寒4321'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strR2=strTemp.strip('1')  #这一次strip方法传入了可选参数‘1’，是一个单个字符，则只会去除strTemp首尾的字符1，而不会删除strTemp字符串中间的字符1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strR3=strTemp.strip('1234')  #这一次strip方法传入了可选参数‘1234’，是一个字符串，并不是说将删除strTemp字符串首尾的‘1234’，而是会分别删除strTemp字符串首尾的‘1’，‘2’，‘3’，‘4’，从下面的输出结果中就可以看到，虽然strTemp字符串尾巴的字符串是：’4321’，在此次执行strip方法时也被删除了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strTemp)   #strTemp本身的值并没有被修改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1234孤1荷2凌3寒4321&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strR2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;234孤1荷2凌3寒432&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strR3)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;孤1荷2凌3寒&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9 指定一个对照表，将字符串中符合对照表中其中一行任意一个或多个关键字的字符更换成另一行中的关键字字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;String.translate(table[,deletechars])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;String是指要进行字符替换操作的字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数table是指一张二维字符对照表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可选参数deletechars，用法不明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此操作没有对原字符串String的内容作任何修改，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将返回一个替换完成后的新字符串对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strRow1='一二三四五六七八九十'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strRow2='壹贰叁肆伍陆柒捌玖拾'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; tableTemp=str.maketrans(strRow1,strRow2)  #将此表格的两行合并成一张二维对照表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(tableTemp) #打印时，显示的是对照字符的 编码 对照&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{19968: 22777, 20108: 36144, 19977: 21441, 22235: 32902, 20116: 20237, 20845: 38470, 19971: 26578, 20843: 25420, 20061: 29590, 21313: 25342}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strLong='孤荷凌寒的QQ号是五七八六五二六零七'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strR=strLong.translate(tableTemp)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strLong) #原字符串strLong的值没有发生变化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;孤荷凌寒的QQ号是五七八六五二六零七&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strR)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;孤荷凌寒的QQ号是伍柒捌陆伍贰陆零柒&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——————————&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天整理的学习笔记完成，最后例行说明下我的自学思路：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;诚挚期待您的交流分享批评指点！&lt;strong&gt;欢迎联系我加入从零开始的自学联盟。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1noO8wToR8OOmLvfQF0vvmw&quot;&gt;https://pan.baidu.com/s/1noO8wToR8OOmLvfQF0vvmw&lt;/a&gt;  密码：6kgy&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Bilibili:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.bilibili.com/video/av35774836/&quot;&gt;https://www.bilibili.com/video/av35774836/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜马拉雅语音笔记：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.ximalaya.com/keji/19103006/137361136&quot;&gt;https://www.ximalaya.com/keji/19103006/137361136&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1246771/201811/1246771-20181117214207681-1079844586.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1246771/201811/1246771-20181117214351803-882228153.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1246771/201811/1246771-20181117214123061-1037491958.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Nov 2018 13:47:00 +0000</pubDate>
<dc:creator>孤荷凌寒</dc:creator>
<og:description>孤荷凌寒自学python第十天序列之字符串的常用方法 （完整学习过程屏幕记录视频地址在文末，手写笔记在文末） Python的字符串操作方法非常丰富，原生支持字符串的多种操作： 1 查找子字符串 str</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lhghroom/p/9975798.html</dc:identifier>
</item>
<item>
<title>Angular2，Springboot，Zuul，Shiro跨域CORS请求踩坑实录 - 冷豪</title>
<link>http://www.cnblogs.com/learnhow/p/9975515.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learnhow/p/9975515.html</guid>
<description>&lt;p&gt;前言：前后端分离，业务分离，网关路由等已经成为当下web application开发的流行趋势。前端以单页面路由为核心的框架为主体，可以单独部署在nodejs或nginx上。后端以springboot为代表的分布式微服务框架为主体，可以独立运行在任何端口上。相互通过符合restful规范的接口访问或数据交换。在这样的开发模式下，首先需要解决的就是由于跨域而引起的访问，cookie传递以及权限管理问题。本文以时下最流行的Angular2，Springboot，Zuul，Shiro为例，提供最佳实践。&lt;/p&gt;
&lt;p&gt;一、一般访问&lt;/p&gt;
&lt;p&gt;开发中首先遇到的问题就是由于前端运行端口和后端运行端口不一致所造成的跨域访问。推荐在Springboot项目上增加过滤器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@WebFilter
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CorsFilter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Filter {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
        HttpServletResponse response &lt;/span&gt;=&lt;span&gt; (HttpServletResponse) res;
        HttpServletRequest request &lt;/span&gt;=&lt;span&gt; (HttpServletRequest) req;
        response.setHeader(&lt;/span&gt;&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;&lt;span&gt;));
        response.setHeader(&lt;/span&gt;&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE, PUT&quot;&lt;span&gt;);
        response.setHeader(&lt;/span&gt;&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;&lt;span&gt;);
        response.setHeader(&lt;/span&gt;&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With&quot;&lt;span&gt;);
        response.setHeader(&lt;/span&gt;&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;&lt;span&gt;);
        chain.doFilter(req, res);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init(FilterConfig arg0) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、身份认证auth&lt;/p&gt;
&lt;p&gt;当用户登录以后理论上我们可以在后端我们可以获取当前用户的session数据，可是依然存在问题。造成这个问题的主要原因是后端依靠sessionid来确认数据，正常情况下浏览器会将数据保存在cookie中，而在非跨域的环境中，浏览器的每一次访问都会携带自己的cookie信息。但是Angular2这样的异步框架http模块默认请求时不会携带cookie信息的。这个问题的解决方法是前端请求需要增加“withCredentials: true”字段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;httpOptions: {
        headers: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HttpHeaders({ 'Content-Type': 'application/json'&lt;span&gt; }),
        withCredentials: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.http.get&amp;lt;Users&amp;gt;(global.loginUrl + 'getUsers', global.httpOptions);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仅仅如此还不够，如果我们的前端并不是直接访问后端服务，而是通过Zuul这样的网管路由做了代理访问。你会发现后端依然无法正确获取session。原因是Zuul默认是不转发请求头或会过滤掉一些重要的头信息。因此我们还需要在Zuul的配置文件中增加一条：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;zuul:
  routes:
    &lt;/span&gt;&amp;lt;servername&amp;gt;&lt;span&gt;
      sensitiveHeaders: &lt;/span&gt;&quot;*&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样前端请求携带的cookie信息才会顺利被发送到后端服务，后端才能够获取到正确的session。&lt;/p&gt;
&lt;p&gt;三、Shiro过滤器&lt;/p&gt;
&lt;p&gt;准确的这个问题不是跨域造成的，根据目前HTML5的流行趋势，在发送Post和Put请求前会首先通过Options请求做探测。在没有配置Shiro过滤器的情况下，这都不是问题。可以一旦后端服务配置了根绝url的权限过滤，前端的请求又会出现问题。原因是Shiro的默认过滤器使用了重定向，而Options在重定向后认为地址不可达因此不会继续发送正确的请求。要解决这个问题，我们需要重写Shiro的FormAuthenticationFilter：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
public class ShiroConfig {
    @Bean
    public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager, @Qualifier(&lt;/span&gt;&quot;authFilter&quot;&lt;span&gt;) Filter filter) {
        ShiroFilterFactoryBean shiroFilterFactoryBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);
        Map&lt;/span&gt;&amp;lt;String, Filter&amp;gt; filters = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        filters.put(&lt;/span&gt;&quot;authc&quot;&lt;span&gt;, filter);
        filters.put(&lt;/span&gt;&quot;roles&quot;&lt;span&gt;, filter);
        filters.put(&lt;/span&gt;&quot;perms&quot;&lt;span&gt;, filter);
        shiroFilterFactoryBean.setFilters(filters);
        
        Map&lt;/span&gt;&amp;lt;String, String&amp;gt; filterChainDefinitionMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
        
        filterChainDefinitionMap.put(&lt;/span&gt;&quot;/*&quot;, &quot;anon&quot;&lt;span&gt;);
        filterChainDefinitionMap.put(&lt;/span&gt;&quot;/auth/*&quot;, &quot;authc&quot;&lt;span&gt;);
        filterChainDefinitionMap.put(&lt;/span&gt;&quot;/auth/admin/*&quot;, &quot;roles[admin,administrator]&quot;&lt;span&gt;);
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; shiroFilterFactoryBean;
    }
    
    @Bean(&lt;/span&gt;&quot;authFilter&quot;&lt;span&gt;)
    public Filter authenticationFilter() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormAuthenticationFilter() {
            @Override
            protected &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; HttpServletRequest) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (((HttpServletRequest) request).getMethod().toUpperCase().equals(&quot;OPTIONS&quot;&lt;span&gt;)) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    }
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; super.isAccessAllowed(request, response, mappedValue);
            }

            @Override
            protected &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {
                WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然Shiro也为我们预留了接口，我们只需要按照需求配置即可。&lt;/p&gt;
&lt;p&gt;四、总结&lt;/p&gt;
&lt;p&gt;当下流行的前后端分离框架跨域是我们遇到的第一个问题，我们可以在服务端配置允许跨域访问来解决，具体方法推荐使用WebFilter过滤器。但是默认的rest请求sessionid，因此我们还需要让前端在请求头携带cookie。另外如果我们在前端展示与后端服务之前使用了网关还需要让网关服务允许所有的请求头通过而不要进行过滤。最后如果我们还使用了安全框架就必须让基于url权限管理功能放行所有的Options请求，以便让前端不会误认为请求地址不可达。&lt;/p&gt;
</description>
<pubDate>Sat, 17 Nov 2018 12:42:00 +0000</pubDate>
<dc:creator>冷豪</dc:creator>
<og:description>前言：前后端分离，业务分离，网关路由等已经成为当下web application开发的流行趋势。前端以单页面路由为核心的框架为主体，可以单独部署在nodejs或nginx上。后端以springboot</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learnhow/p/9975515.html</dc:identifier>
</item>
<item>
<title>从头开始学eShopOnContainers——Visual Studio 2017环境配置 - 猎尘</title>
<link>http://www.cnblogs.com/dusthunter/p/9973815.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dusthunter/p/9973815.html</guid>
<description>&lt;h2&gt;一、安装和配置Docker环境&lt;/h2&gt;
&lt;h4&gt;1、安装Docker CE for Windows&lt;/h4&gt;
&lt;p&gt;　　从官方网站下载并安装，&lt;a href=&quot;https://docs.docker.com/docker-for-windows/install/&quot; rel=&quot;nofollow&quot;&gt;https://docs.docker.com/docker-for-windows/install/&lt;/a&gt;。&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;默认情况下&lt;/span&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;Docker for Windows使用Hyper-V运行Linux VM。 &lt;span&gt;如果您没有安装/启用Hyper-V，它将被安装，您可能需要重新启动计算机。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　注意&lt;/strong&gt;:&lt;/span&gt; 您需要&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;检查是否安装了其它可能与Hyper-V不兼容的虚拟机管理程序。例如：基于&lt;span lang=&quot;zh-CN&quot;&gt;Intel HAXM&lt;/span&gt;技术的&lt;span lang=&quot;zh-CN&quot;&gt;Google's Android&lt;/span&gt;模拟器，目前此模拟器和&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;Hyper-V不兼容&lt;/span&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Set needed assigned Memory and CPU to Docker &quot;&gt;2、将所需的内存和CPU设置为Docker&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Set needed assigned Memory and CPU to Docker &quot;&gt;　　&lt;span title=&quot;For the development environment of eShopOnContainers, by default, it runs 1 instance of SQL Server running as a container with multiple databases (one DB per microservice), other 6 additional ASP.NET Core apps/services each one running as a container, plus 1&quot;&gt;对于eShopOnContainers的开发环境，默认情况下，它运行1个&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Set needed assigned Memory and CPU to Docker &quot;&gt;&lt;span title=&quot;For the development environment of eShopOnContainers, by default, it runs 1 instance of SQL Server running as a container with multiple databases (one DB per microservice), other 6 additional ASP.NET Core apps/services each one running as a container, plus 1&quot;&gt;具有多个数据库的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;SQL Server&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Set needed assigned Memory and CPU to Docker &quot;&gt;&lt;span title=&quot;For the development environment of eShopOnContainers, by default, it runs 1 instance of SQL Server running as a container with multiple databases (one DB per microservice), other 6 additional ASP.NET Core apps/services each one running as a container, plus 1&quot;&gt;容器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;（每个微服务一个数据库），以及6个额外的ASP.NET Core应用程序/服务容器，和1个 &lt;span title=&quot;Redis server running as a container.&quot;&gt;Redis服务容器。&lt;span title=&quot;Therefore, especially because of the SQL Server requirements on memory, it is important to set Docker up properly with enough memory RAM and CPU assigned to it or you will get errors when starting the containers with VS 2017 or &amp;quot;docker-compose up&amp;quot;. &quot;&gt;由于SQL Server对内存的要求较高，因此需要&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Set needed assigned Memory and CPU to Docker &quot;&gt;&lt;span title=&quot;For the development environment of eShopOnContainers, by default, it runs 1 instance of SQL Server running as a container with multiple databases (one DB per microservice), other 6 additional ASP.NET Core apps/services each one running as a container, plus 1&quot;&gt;&lt;span title=&quot;Redis server running as a container.&quot;&gt;&lt;span title=&quot;Therefore, especially because of the SQL Server requirements on memory, it is important to set Docker up properly with enough memory RAM and CPU assigned to it or you will get errors when starting the containers with VS 2017 or &amp;quot;docker-compose up&amp;quot;. &quot;&gt;设置Docker&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;分配足够的内存RAM和CPU，否则在使用VS 2017或“docker-compose up”命令启动容器时会报错。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span title=&quot;Once Docker for Windows is installed in your machine, enter into its Settings and the Advanced menu option so you are able to adjust it to the minimum amount of memory and CPU (Memory: Around 4096MB and CPU:3) as shown in the image.&quot;&gt;　　在您的计算机上安装Docker for Windows后，进入其设置和高级菜单选项，调整为最小内存为4G以上，CPU为3核以上，如图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Set needed assigned Memory and CPU to Docker &quot;&gt;&lt;span title=&quot;For the development environment of eShopOnContainers, by default, it runs 1 instance of SQL Server running as a container with multiple databases (one DB per microservice), other 6 additional ASP.NET Core apps/services each one running as a container, plus 1&quot;&gt;&lt;span title=&quot;Redis server running as a container.&quot;&gt;&lt;span title=&quot;Therefore, especially because of the SQL Server requirements on memory, it is important to set Docker up properly with enough memory RAM and CPU assigned to it or you will get errors when starting the containers with VS 2017 or &amp;quot;docker-compose up&amp;quot;. &quot;&gt;&lt;span title=&quot;Once Docker for Windows is installed in your machine, enter into its Settings and the Advanced menu option so you are able to adjust it to the minimum amount of memory and CPU (Memory: Around 4096MB and CPU:3) as shown in the image.&quot;&gt;&lt;span title=&quot;Usually you might need a 16GB memory machine for this configuration if you also want to run the Android emulator for the Xamarin app or multiple instances of applications demanding significant memory at the same time.&quot;&gt;&lt;span title=&quot;If you have a less powerful machine, you can try with a lower configuration and/or by not starting certain containers like the basket and Redis.&quot;&gt;&lt;span title=&quot;But if you don't start all the containers, the application will not fully function properly, of course.&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/206781/201811/206781-20181117142129787-929773598.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;3、磁盘共享设置 (为了使用Visual Studio 2017部署和调试)&lt;/h4&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;　　需要共享您放置源代码以及Docker For Windows的文件夹所在的&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;驱动器&lt;/span&gt;。如果没有共享相应的文件夹，启动调试时会报错。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/206781/201811/206781-20181117194513632-262978857.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt; 4、设置防火墙规则&lt;/h4&gt;
&lt;p&gt;　　&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;在本地防火墙中打开端口，以便可以通过STS（安全令牌服务容器，&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;IP：10.0.75.1&lt;/span&gt;&lt;/span&gt; ）进行身份验证，该IP为Docker默认设置。&lt;span&gt;Xamarin app或SPA app等客户端也需要打开相应的防火墙端口。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span&gt;　　&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;您可以在本地防火墙中手动创建规则，也可以通过执行解决方案的cli-windows目录中提供的add-firewall-rules-for-sts-auth-thru-docker.ps1脚本来创建该规则。&lt;br/&gt;　　&lt;span&gt;您需要通过在防火墙中创建一个IN-BOUND RULE来打开解决方案使用的端口5100到5110，如下面的屏幕截图所示（对于Windows）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/206781/201811/206781-20181117161623347-1880494287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;　　&lt;span&gt;注意：&lt;/span&gt;通过PowerShell脚本设置防火墙规则时可能会因为Windows PowerShell® 默认执行策略未设置而报错。具体参考：https://go.microsoft.com/fwlink/?LinkID=135170。&lt;/p&gt;
&lt;p&gt;　　可以通过PowerShell执行&quot;Set-ExecutionPolicy UNRESTRICTED -Scope CurrentUser&quot;命令临时允许脚本运行，运行完设置防火墙规则脚本后再通过“Set-ExecutionPolicy Undefined -Scope CurrentUser”还原默认设置。&lt;/p&gt;
&lt;p&gt;　　要查看当前执行策略设置可通过命令：“ Get-ExecutionPolicy -List”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;二、安装并配置Visual Studio 2017环境&lt;/h2&gt;
&lt;h4&gt; 1、安装最新版Visual Studio 2017&lt;/h4&gt;
&lt;p&gt;　　如果只需要进行服务端（微服务和Web应用程序）开发，只需要选择“Asp.Net和Web开发、.Net Core跨平台开发”两个工作负载，需要部署到微软Azure时可选择“Azure开发”工作负载。&lt;/p&gt;
&lt;p&gt;　　如果需要进行移动App (基于Xamarin的iOS, Android和Windows UWP移动应用) 开发，则还需要选择“使用.Net的移动开发、通用Windows平台开发”两个工作负载。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;　　&lt;span&gt;注意：&lt;/span&gt;&lt;span&gt;&lt;span&gt;安装“.Net的移动开发”工作负载，必须取消右侧的安装详细信息中的“Google Android仿真器、Intel硬件加速管理器”两个组件，因为这两个组件与Hyper-V不兼容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt; 2、从Github获取eShopOnContainers源代码&lt;/h4&gt;
&lt;p&gt;　　可以直接从&lt;a href=&quot;https://github.com/dotnet-architecture/eShopOnContainers&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet-architecture/eShopOnContainers&lt;/a&gt;下载源代码，或者通过git克隆：“&lt;code&gt;git clone https://github.com/dotnet-architecture/eShopOnContainers.git&lt;/code&gt;”。&lt;/p&gt;
&lt;h4&gt;3、打开并运行eShopOnContainers解决方案&lt;/h4&gt;
&lt;p&gt;　　如果只进行服务端调试，打开“eShopOnContainers-ServicesAndWebApps.sln”解决方案，如果还需要调试移动App，打开“eShopOnContainers.sln”解决方案。&lt;/p&gt;
&lt;p&gt;　　将“docker-compose”设置为默认启动项目，按F5或者点运行。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　&lt;span&gt;注意：&lt;/span&gt;由于第一次运行Docker需从互联网下载&quot;SQL for Linux , Redis , ASPNET&quot;等Docker镜像，视网速可能需要等10分钟左右。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;4、测试所有应用和微服务&lt;/h4&gt;
&lt;p&gt;　　容器正常部署运行后，可通过以下地址访问任一应用或服务:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MVC网页: &lt;a href=&quot;http://localhost:5100&quot; rel=&quot;nofollow&quot;&gt;http://localhost:5100&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;单页应用网页: &lt;a href=&quot;http://localhost:5104&quot; rel=&quot;nofollow&quot;&gt;http://localhost:5104&lt;/a&gt; (需要单独安装依赖并编译才能正常运行)&lt;/li&gt;
&lt;li&gt;商品目录微服务: &lt;a href=&quot;http://localhost:5101&quot; rel=&quot;nofollow&quot;&gt;http://localhost:5101&lt;/a&gt; (不需要认证)&lt;/li&gt;
&lt;li&gt;订单微服务: &lt;a href=&quot;http://localhost:5102&quot; rel=&quot;nofollow&quot;&gt;http://localhost:5102&lt;/a&gt; (需要认证)&lt;/li&gt;
&lt;li&gt;购物车微服务: &lt;a href=&quot;http://localhost:5103&quot; rel=&quot;nofollow&quot;&gt;http://localhost:5103&lt;/a&gt; (需要认证)&lt;/li&gt;
&lt;li&gt;认证微服务: &lt;a href=&quot;http://localhost:5105&quot; rel=&quot;nofollow&quot;&gt;http://localhost:5105&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;订单数据库(SQL Server 连接字符串): Server=tcp:localhost,5432;Database=Microsoft.eShopOnContainers.Services.OrderingDb;User Id=sa;Password=Pass@word;&lt;/li&gt;
&lt;li&gt;商品目录数据库 (SQL Server 连接字符串): Server=tcp:localhost,5434;Database=CatalogDB;User Id=sa;Password=Pass@word&lt;/li&gt;
&lt;li&gt;认证数据库 (SQL Server 连接字符串): Server=localhost,5433;Database=aspnet-Microsoft.eShopOnContainers;User Id=sa;Password=Pass@word&lt;/li&gt;
&lt;li&gt;购物车数据 (Redis): 监听 localhost:6379&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　&lt;span&gt;注意：&lt;/span&gt;单页应用网页需要单独安装依赖并编译才能正常运行，暂时未处理，打开为空白页。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt; 5、MVC网页运行效果&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/206781/201811/206781-20181117202716359-822466414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 17 Nov 2018 12:30:00 +0000</pubDate>
<dc:creator>猎尘</dc:creator>
<og:description>一、安装和配置Docker环境 1、安装Docker CE for Windows 从官方网站下载并安装，https://docs.docker.com/docker-for-windows/inst</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dusthunter/p/9973815.html</dc:identifier>
</item>
<item>
<title>（第二部）程序员逆天改命之胜天半子 - 锋哥程序十年</title>
<link>http://www.cnblogs.com/bianchengniuren/p/9975173.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bianchengniuren/p/9975173.html</guid>
<description>&lt;p&gt;自从上次vico大师与众黑客一战之后，再也没有人敢来c++山庄撒野。我们也终于知道vico大师原来是师傅的同门师弟。当年因为带头&lt;strong&gt;反对&lt;/strong&gt;不带薪加班，被逐出仙山。后来在BAT三座仙山之外自成一派，美名其曰&lt;strong&gt;J山&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; vico大师的天赋其实要远胜与于师傅。师傅作为&lt;strong&gt;996&lt;/strong&gt;的发明和执行者，后来又发明了更加惨无人道的&lt;strong&gt;8116&lt;/strong&gt;，终于把自己都搭了进去。何谓8116？就是8点上班，11点下班，一周上六天。但是师傅的发明却对这个社会的进步十分有积极的意义。即使2000多年后，依然被越来越多的企业主所使用。虽然后来在程序猿的眼里成了&lt;strong&gt;千夫所指&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;vico大师看我英俊潇洒，骨骼精奇，是一个写代码的好料，决定带我到J山修炼。一日，我正在树底下苦苦研究《&lt;strong&gt;Unix高级环境编程&lt;/strong&gt;》一书。vico大师飘然而至。他指着J山告诉我：“此山牢不可破，正是依据Linux系统原理建造。山上一草一树皆为&lt;strong&gt;外设&lt;/strong&gt;，山的主体是&lt;strong&gt;内核&lt;/strong&gt;，内核和外设的之间的植被层，是为&lt;strong&gt;驱动&lt;/strong&gt;。”我指着山上一间间的道观问大师：“那房屋在你的系统里算是什么？” 大师哈哈一笑：“房屋就是一个个的&lt;strong&gt;应用&lt;/strong&gt;。” 我幡然大悟，缘来vico大师才是LINUX系统的真正缔造者和发明者。vico大师不无得意的说：“此山的&lt;strong&gt;防火墙&lt;/strong&gt;牢不可破，可以抵挡一切互联网攻击。什么&lt;strong&gt;蠕虫病毒&lt;/strong&gt;，&lt;strong&gt;冰河木马&lt;/strong&gt;都是浮云。”&lt;/p&gt;
&lt;p&gt;vico大师为了建造J山，和他的大弟子锋哥费尽心机，听说吐血都吐了几脸盘。后来J山建造完成之后，锋哥被vico大师逐出师门。至于个中原因，成了江湖中一个永远解不开的&lt;strong&gt;谜&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;江山代有才人出，城头变换幻大王旗。之前武林以语言种类来区分门派。形成各种&lt;strong&gt;鄙视链&lt;/strong&gt;。c++的看不起java的，java的看不起python的，纷争不断。然而合久必分，分久必合。悄然间，武林冒出了一个新的物种，&lt;strong&gt;产品经理&lt;/strong&gt;！以大魔头锋哥为代表。&lt;/p&gt;
&lt;p&gt;大魔头锋哥带领他的产品经理团队，以&lt;strong&gt;摧&lt;/strong&gt;&lt;strong&gt;枯拉朽&lt;/strong&gt;的态势，不断攻占程序员山庄。程序员抵挡不住，分分逃往J山，向vico大师&lt;strong&gt;求救&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;大魔头锋哥在BAT仙山练道的时候，曾是vico大师的大弟子。由于悟性极高，一直&lt;strong&gt;泡不到妞&lt;/strong&gt;，所以有大量的时间参悟代码背后的&lt;strong&gt;人生哲理&lt;/strong&gt;。其道行并不在vico大师之下。&lt;/p&gt;
&lt;p&gt;J山能抵挡大魔王锋哥的进攻吗？&lt;/p&gt;
&lt;p&gt;正在思索间，天空中忽然传来一阵爽朗的声音：“师傅，我来看你了！” vico大师正翘着二郎腿躺在屋檐上，嘴里叼着一根棒棒糖，听到声音一翻身从屋顶跳下来：“哈哈哈哈哈，锋儿，好久不见。这次给为师带来什么好手信？”。 正说话间，天空出现一个巨大的&lt;strong&gt;黑影&lt;/strong&gt;，由远而进。倏忽间，速度极快已经来到跟前。“给师傅带了本好书”，话未说完，来人从袖口扔出一本书，以极快的速度来到vico大师的跟前。vico大师以四两拨千斤之力接住，巨大的力道震的虎口一麻。心中暗暗骂一句：“这孽徒功力又有进步了”。 vico大师拿起书一看，书面上赫然写着《&lt;strong&gt;产品经理从入门到精通&lt;/strong&gt;》。vico大师再也忍不住破口大骂：“你这孽徒，枉为师教了你十年代码。你竟然加入产品经理行列，与万千程序员为敌”。&lt;/p&gt;
&lt;p&gt;锋哥哈哈一笑：“废话少说，这次来我要带走师娘，你若敢说半个不字，今日定当&lt;strong&gt;夷平J山&lt;/strong&gt;，教你无处藏身”。&lt;/p&gt;
&lt;p&gt;我艹，原来锋哥当年被逐出师门，是因为与师傅的老婆苦茶大师有一腿。真相已经大白，锋哥&lt;strong&gt;逆天而为&lt;/strong&gt;，真是漫天程序员得而诛之。&lt;/p&gt;
&lt;p&gt;vico大师大怒道：“苦茶已经与我结为夫妇，这是上天的缘分，你竟意欲何为？” 锋哥道：“当年你要不是用一辆&lt;strong&gt;兰博鸡尼&lt;/strong&gt;将苦茶从我身边抢走，我早就已经开着&lt;strong&gt;共享单车&lt;/strong&gt;把苦茶娶回家。苦茶和我是同班同学，大学相恋四年，没想到因为贪慕虚荣，被你骗走。今日，我们要做个了断。”&lt;/p&gt;
&lt;p&gt;正说话间，产品经理大军杀到。漫天飞舞着产品经理的黑影和大旗。上面隐隐约约写着一些字，“&lt;strong&gt;明天一定要发布版本&lt;/strong&gt;”，“&lt;strong&gt;竞品都能实现，你为什么不能&lt;/strong&gt;”，“&lt;strong&gt;今晚全体留下来加班&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;J山的程序员本来已经进入战斗状态，但是看到这些字，竟然好像见到了咒语一样，浑身冒虚汗。还没有开始战斗，功力已经减了一半。&lt;/p&gt;
&lt;p&gt;vico大师见形势不妙，赶紧命令撤退。十万程序员大军瞬间&lt;strong&gt;隐遁山林&lt;/strong&gt;，消失的无影无踪。&lt;/p&gt;
&lt;p&gt;vico大师哈哈一笑道：“J山设计巧妙，防火墙已经升级加固，非尔等之徒可以攻破”。&lt;/p&gt;
&lt;p&gt;锋哥鄙夷一笑，道：“你们费尽心机去防护网络入侵，但万万没想到，网络驱动只是系统万千外设的其中一个。” 锋哥顿了一顿，指着山上道：“山上的一草一木，皆为外设。这些外设的制造者，只想着怎么将这些设备卖给你们，从来不去考虑怎么加固驱动。每一个驱动都是入侵的接口。” &lt;/p&gt;
&lt;p&gt;vico大师大吃一惊，没想到&lt;strong&gt;系统最大的漏洞竟然是人，人就是最大的漏洞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但vico大师仍然不甘心的道：“驱动虽然是漏洞，但是&lt;strong&gt;驱动&lt;/strong&gt;由&lt;strong&gt;内核&lt;/strong&gt;管理。内核之大，你就算能通过驱动这一关，也必然会迷失在&lt;strong&gt;内核的迷雾森林&lt;/strong&gt;，找不到出路”。锋哥早有准备，拿出早已经准备好的升级版FIND工具：“三天之内，遍历内核的所有路径，到时教你无路可逃”。&lt;/p&gt;
&lt;p&gt;vico大师撤退，锋哥带领他的产品经理大军，开始攻击外设驱动。&lt;/p&gt;
&lt;p&gt;回到家里，苦茶大师看到vico大师满脸愁容，道：“此劫早已经注定，锋哥与我青华同门，能力出众，我愿与大师&lt;strong&gt;解忧&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;苦茶大师遁入&lt;strong&gt;内核&lt;/strong&gt;，锋哥想要攻破内核，必然要经过&lt;strong&gt;华容道&lt;/strong&gt;。华容道一年四季寒冷彻骨。苦茶大师就静静的在华容道等待锋哥的到来。一会儿可能是感觉到冷了，苦茶大师抽出佩剑，开始舞了起来。&lt;strong&gt;漫天的剑气如雪花一样&lt;/strong&gt;，片片下落。突然间剑气一收，苦茶大师好像突然间用尽了所有的能量，灯枯油尽，坐在华容路口，刚好把华容路口堵住。&lt;/p&gt;
&lt;p&gt;此时锋哥突然出现，看到苦茶大师坐在华容路口，像一块石头一样。锋哥大声叫道：“&lt;strong&gt;苦茶，我来了&lt;/strong&gt;。” 苦茶艰难转过头来，微微一笑，看着锋哥说：“&lt;strong&gt;一切上天早已注定，请原谅我&lt;/strong&gt;”。 锋哥抓着苦茶的手，冰凉的像石头一样。锋哥发了疯的说：“你还有什么要对我说，我一定帮你实现”。苦茶用尽了最后的力气说：“&lt;strong&gt;还有第三部，记得要看&lt;/strong&gt;”。 瞬间，苦茶变成了一块石头，把华容道死死堵住。&lt;/p&gt;
&lt;p&gt;锋哥因为不肯把苦茶变成的石头炸开，无法通过华容道。只能率领产品经理铩羽而归。&lt;/p&gt;
&lt;p&gt;苦茶用生命为江湖换来了一段宝贵的平静。&lt;/p&gt;
</description>
<pubDate>Sat, 17 Nov 2018 11:20:00 +0000</pubDate>
<dc:creator>锋哥程序十年</dc:creator>
<og:description>自从上次vico大师与众黑客一战之后，再也没有人敢来c++山庄撒野。我们也终于知道vico大师原来是师傅的同门师弟。当年因为带头反对不带薪加班，被逐出仙山。后来在BAT三座仙山之外自成一派，美名其曰J</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bianchengniuren/p/9975173.html</dc:identifier>
</item>
<item>
<title>理解 iOS 和 macOS 的内存管理 - noark9</title>
<link>http://www.cnblogs.com/noark9/p/9975124.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noark9/p/9975124.html</guid>
<description>&lt;p&gt;在 iOS 和 macOS 应用的开发中，无论是使用 Objective-C 还是使用 swift 都是通过引用计数策略来进行内存管理的，但是在日常开发中80%（这里，我瞎说的，8020 原则嘛😆）以上的情况，我们不需要考虑内存问题，因为 Objective-C 2.0 引入的自动引用计数（ARC）技术为开发者们自动的完成了内存管理这项工作。ARC 的出现，在一定程度上拯救了当时刚入门的 iOS 程序员们，如果是没有接触过内存管理的开发者，在第一次遇到僵尸对象时一定是吓得发抖😱😱😱My Brains~。但是 ARC 只是在代码层面上自动添加了内存管理的代码，并不能真正的自动内存管理，以及一些高内存消耗的特殊场景我们必须要进行手动内存管理，所以理解内存管理是每一个 iOS 或者 macOS 应用开发者的必备能力。&lt;/p&gt;
&lt;p&gt;本文将会介绍 iOS 和 macOS 应用开发过程中，如何进行内存管理，以及介绍一些内存管理使用的场景，帮助大家解决内存方面的问题，本文将会重点介绍内存管理的逻辑、思路，而不是类似教你分分钟手写 &lt;code&gt;weak&lt;/code&gt; 的实现，之类的问题，毕竟大家一般拧螺丝比较多，至于✈️🚀🛸的制造技艺嘛，还是要靠万能的 Google 了。&lt;/p&gt;
&lt;p&gt;本文其实是内存管理的起点，而不是结束，各位 iOS 大佬们肯定会发现很多东西在本文中是找不到的，因为这里的内容非常基础，只是帮助初学 iOS 的同学们能够快速理解如何管理内存而写的。&lt;/p&gt;

&lt;p&gt;很多人接触到内存管理可以追溯到大学时候的 C 语言程序设计课程，在大学中为数不多的实践型语言课程中相信 C 语言以及 C 语言中的指针是很多人的噩梦，并且这个噩梦延续到了 C++，当然这个是后话了。所以 Java 之类的，拥有垃圾回收机制的语言，也就慢慢的变得越来越受欢迎（大雾🤪🤪🤪）。&lt;/p&gt;
&lt;p&gt;内存管理基本原则：&lt;/p&gt;
&lt;center&gt;&lt;span&gt;在需要的时候分配内存，在不需要的时候释放内存&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;这里来一段简单的 C 代码～&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#define BUFFER_SIZE 128

void dosth() {
    char *some_string = malloc(BUFFER_SIZE);
    // 对 some_string 做各种操作
    free(some_string);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这么一句话看起来似乎不是很复杂，但是光这一个内存管理，管得无数英雄尽折腰啊，因为实际的代码并不会像上面那么简单，比如上面我要把字符串 &lt;code&gt;some_string&lt;/code&gt; 返回出来的话要怎么办呢？（我不会回答你的👻）&lt;/p&gt;

&lt;h2 id=&quot;内存引用计数reference-countingrc以及-mrc&quot;&gt;内存引用计数（Reference Counting，RC）以及 MRC&lt;/h2&gt;
&lt;p&gt;Objective-C 和 Swift 的内存管理策略都是引用计数，什么是引用计数呢？下面是 wiki 上摘抄而来的内容：&lt;/p&gt;
&lt;blockquote readability=&quot;14.083969465649&quot;&gt;
&lt;p&gt;&lt;strong&gt;引用计数&lt;/strong&gt;是计算机&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80&quot;&gt;编程语言&lt;/a&gt;中的一种&lt;strong&gt;内存管理技术&lt;/strong&gt;，是指将资源（可以是&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1&quot;&gt;对象&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98&quot;&gt;内存&lt;/a&gt;或&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%A3%81%E7%A2%9F&quot;&gt;磁盘&lt;/a&gt;空间等等）的被&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BC%95%E7%94%A8&quot;&gt;引用&lt;/a&gt;次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。同时引用计数还可以指使用引用计数技术回收未使用资源的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&quot;&gt;垃圾回收&lt;/a&gt;算法。&lt;/p&gt;
&lt;p&gt;当创建一个对象的实例并在堆上申请内存时，对象的引用计数就为1，在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1，需要释放一个对象时，就将该对象的引用计数减1，直至对象的引用计数为0，对象的内存会被立刻释放。&lt;/p&gt;
&lt;p&gt;来源：https://zh.wikipedia.org/wiki/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;似乎有点抽象，这里使用 &lt;code&gt;setter&lt;/code&gt; 方法的经典实现作为例子我们来看下代码~&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;- (void)setSomeObject:(NSObject *aSomeObject) {
    if (_someObject != aSomeObject) {
        id oldValue = _someObject;
        _someObject = [aSomeObject retain];  // aSomeObject retain count +1
        [oldValue release];  // oldValue retain count -1
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们图解下这部分代码，图中，矩形为变量（指针），圆圈为实际对象，剪头表示变量指向的对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/76924-c7cbe7fab68db281.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/76924-76636ebded95c6a7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/76924-ef312974c5ba452d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/76924-fe662aef060b7fb4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的写法是 MRC 时代的经典方式，这里就不多说了，因为本文的目的是让大家理解 ARC 下的内存管理。&lt;/p&gt;
&lt;h2 id=&quot;人工内存管理时代-manual-reference-countingmrc&quot;&gt;人工内存管理时代 —— Manual Reference Counting（MRC）&lt;/h2&gt;
&lt;p&gt;人工管理内存引用计数的方法叫做 Manual Reference Counting（MRC），在上一节的最后，我们已经看到了内存管理的一些些代码，也看到了内存管理时发生了一些什么，因为 MRC 是 ARC 的基础，为了更好地理解 ARC，下面是我对 iOS，macOS 下内存管理的总结：&lt;/p&gt;
&lt;center&gt;&lt;span&gt;对象之间存在持有关系，是否被持有，决定了对象是否被销毁&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;也就是说，对于引用计数的内存管理，最重要的事情是理清楚对象之间的持有关系，而不关注实际的引用数字，也就是逻辑关系清楚了，那么实际的引用数也就不会出问题了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;&lt;br/&gt;这里引用《Objective-C 高级编程》里面办公室的灯的例子，不过我们稍微改改&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自习室有一个灯，灯可以创建灯光，老师要求大家节约用电，只有在有人需要使用的时候才打开灯&lt;/li&gt;
&lt;li&gt;同学 A 来看书，他打开了灯（创建灯光） —— A 持有灯光&lt;/li&gt;
&lt;li&gt;同学 B，C，D 也来看书，他们也需要灯光 —— B，C，D 分别持有灯光&lt;/li&gt;
&lt;li&gt;这时候 A，B，C 回宿舍了，他们不需要开灯了 —— A，B，C 释放了灯光&lt;/li&gt;
&lt;li&gt;由于这时候 D 还需要灯光，所以灯一直是打开的 —— D 依然持有灯光&lt;/li&gt;
&lt;li&gt;当 D 离开自习室时 —— D 释放了灯光&lt;/li&gt;
&lt;li&gt;这时候自习室里面已经没有人需要灯光了，于是灯光被释放了（灯被关了）&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;上面的例子“灯光”就是我们的被持有的对象，同学们是持有“灯光”的对象，在这个场景，只要我们理清楚谁持有了“灯光”，那么我们就能完美的控制“灯光”，不至于没人的时候“灯光”一直存在导致浪费电（内存泄漏），也不至于有同学需要“灯光”的时候“灯光”被释放。&lt;/p&gt;
&lt;p&gt;这里看上去很简单，但是实际项目中将会是这样的场景不断的叠加，从而产生非常复杂的持有关系。例子中的同学 A，B，C，D，自习室以及灯也是被其他对象持有的。所以对于最小的一个场景，我们再来一遍：&lt;/p&gt;
&lt;center&gt;&lt;span&gt;对象之间存在持有关系，是否被持有，决定了对象是否被销毁&lt;/span&gt;&lt;/center&gt;
&lt;h2 id=&quot;创造力的解放-automatic-reference-countingarc&quot;&gt;创造力的解放 —— Automatic Reference Counting（ARC）&lt;/h2&gt;
&lt;p&gt;但是平时大家会发现从来没用过 &lt;code&gt;retain&lt;/code&gt;，&lt;code&gt;release&lt;/code&gt; 之类的函数啊？特别是刚入门的同学，CoreFoundation 也没有使用过就更纳闷了&lt;/p&gt;
&lt;p&gt;原因很简单，因为这个时代我们用上了 ARC，ARC 号称帮助程序员管理内存，而很多人曲解了“帮助”这个词，在布道的时候都会说：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ARC 已经是自动内存管理了，我们不需要管理内存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一句误导性的话，ARC 只是帮我们在代码中他可以推断的部分，自动的添加了 &lt;code&gt;retain&lt;/code&gt;，&lt;code&gt;release&lt;/code&gt; 等代码，但是并不代表他帮我们管理内存了，实际上 ARC 只是帮我们省略了部分代码，在 ARC 无法推断的部分，是需要我们告诉 ARC 如何管理内存的，所以就算是使用 ARC，本质依然是开发者自己管理内存，只是 ARC 帮我们把简单情况搞定了而已&lt;/p&gt;
&lt;p&gt;但是，就算是 ARC 仅仅帮我们把简单的情况搞定了，也非常大的程度上解放了大家的创造力、生产力，因为毕竟很多时候内存管理代码都是会被漏写的，并且由于漏写的时候不一定会发现问题，而是随着程序运行才会出现问题，在开发后期解决起来其实挺麻烦的&lt;/p&gt;
&lt;h3 id=&quot;arc-下的内存管理&quot;&gt;ARC 下的内存管理&lt;/h3&gt;
&lt;p&gt;那么我们来说说 ARC 中如何进行内存管理，当然核心还是这句话：&lt;strong&gt;对象之间存在持有关系，是否被持有，决定了对象是否被销毁&lt;/strong&gt;，当然我们补充一句话：&lt;strong&gt;ARC 中的内存管理，就是理清对象之间的持有关系&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;strong-和-weak&quot;&gt;&lt;code&gt;strong&lt;/code&gt; 和 &lt;code&gt;weak&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;在上面一节中，其实大家应该发现只写了 &lt;code&gt;retain&lt;/code&gt;，是因为 MRC 的时代只有 &lt;code&gt;retain&lt;/code&gt;，&lt;code&gt;release&lt;/code&gt;，&lt;code&gt;autorelease&lt;/code&gt; 这几个手动内存管理的函数。而 &lt;code&gt;strong&lt;/code&gt;，&lt;code&gt;weak&lt;/code&gt;，&lt;code&gt;__weak&lt;/code&gt; 之类的关键字是 Objective-C 2.0 跟着 ARC 一起引入的，可以认为他们就是 ARC 时代的内存管理代码&lt;/p&gt;
&lt;p&gt;对于属性 &lt;code&gt;strong&lt;/code&gt;，&lt;code&gt;weak&lt;/code&gt;，&lt;code&gt;assign&lt;/code&gt;，&lt;code&gt;copy&lt;/code&gt; 告诉 ARC 如何构造属性对应变量的 setter 方法，对于内存管理的意义来说，就是告诉编译器对象属性和对象之间的关系，也就是说平时开发过程中，一直在使用的 &lt;code&gt;strong&lt;/code&gt;，&lt;code&gt;weak&lt;/code&gt; 其实就是在做内存管理，只是大部分时间大家没有意识到而已&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;strong&lt;/code&gt;：设置属性时，将会持有（retain）对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weak&lt;/code&gt;：设置属性时，不会持有对象，并且在对象被释放时，属性值将会被设置为 &lt;code&gt;nil&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assign&lt;/code&gt;：设置属性时，不会持有对象（仅在属性为基本类型时使用，因为基本类型不是对象，不存在释放）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy&lt;/code&gt;：设置属性时，会调用对象的 &lt;code&gt;copy&lt;/code&gt; 方法获取对象的一个副本并持有（对于不可变类型非常有用）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般情况下，我们都会使用 &lt;code&gt;strong&lt;/code&gt; 来描述一个对象的属性，也就是大部分场景下，对象都会持有他的属性，那么下面看下不会持有的情况&lt;/p&gt;
&lt;h5 id=&quot;属性描述的场景-delegate-模式&quot;&gt;属性描述的场景 —— delegate 模式&lt;/h5&gt;
&lt;p&gt;这里用经典的 &lt;code&gt;UITableViewDelegate&lt;/code&gt; 和 &lt;code&gt;UITableViewDataSource&lt;/code&gt; 来进行举例&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UITableView&lt;/code&gt; 的 delegate 和 datasource 应该是学习 iOS 开发过程中最早接触到的 iOS 中的 delegate 模式&lt;br/&gt;在很多的的例子中，教导我们自己开发的对象，使用的 delegate 的属性要设置为 &lt;code&gt;weak&lt;/code&gt; 的，但是很少有说为什么（因为循环引用），更少有人会说为什么会产生循环引用，接下来这里用 &lt;code&gt;UITableView&lt;/code&gt; 的来详解下&lt;/p&gt;
&lt;p&gt;先看 &lt;code&gt;UITableView&lt;/code&gt; 中的定义&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@interface UITableView : UIScrollView &amp;lt;NSCoding, UIDataSourceTranslating&amp;gt;
// Other Definations ...
@property (nonatomic, weak, nullable) id &amp;lt;UITableViewDataSource&amp;gt; dataSource;
@property (nonatomic, weak, nullable) id &amp;lt;UITableViewDelegate&amp;gt; delegate;
// Other Definations ...
@end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来看下 &lt;code&gt;UITableViewController&lt;/code&gt; 中一般的写法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@interface XXXTableViewController : UITableViewController

@property (nonatomic, strong) UITableView *tableView;

@end

@implementation XXXTableViewController()

- (void)viewDidLoad {
    [super viewDidLoad];
    self.tableView.delegate = self;
    self.tableView.dataSource = self;
}

@end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面用一个图梳理一下持有关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/76924-78b88c13ef350ba3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;持有关系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图上有三个对象关系&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;controller&lt;/code&gt; 持有 &lt;code&gt;tableView&lt;/code&gt;，&lt;code&gt;strong&lt;/code&gt; 属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tableView&lt;/code&gt; 没有持有 &lt;code&gt;conntroller&lt;/code&gt;，&lt;code&gt;weak&lt;/code&gt; 属性&lt;/li&gt;
&lt;li&gt;其他对象持有 &lt;code&gt;controller&lt;/code&gt;，&lt;code&gt;strong&lt;/code&gt; 属性&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么当第三个关系被打破时，也就是没有对象持有 &lt;code&gt;controller&lt;/code&gt; 了（发生 &lt;code&gt;[controller release]&lt;/code&gt;，这时候 &lt;code&gt;controller&lt;/code&gt; 会释放他所有的内存，发生下面的事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;其他对象调用 &lt;code&gt;[controller release]&lt;/code&gt;，没有对象持有 &lt;code&gt;controller&lt;/code&gt;，&lt;code&gt;controller&lt;/code&gt; 开始释放内存（调用 &lt;code&gt;dealloc&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[tableView release]&lt;/code&gt;，没有对象持有 &lt;code&gt;tableView&lt;/code&gt; 内存被释放&lt;/li&gt;
&lt;li&gt;&lt;code&gt;controller&lt;/code&gt; 内存被释放&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因为 &lt;code&gt;weak&lt;/code&gt; 属性不会发生持有关系，所以上面过程完成后，都没有任何对象持有 &lt;code&gt;tableView&lt;/code&gt; 和 &lt;code&gt;controller&lt;/code&gt; 于是都被释放&lt;/p&gt;
&lt;p&gt;假设上面对象关系中的 2 变为 &lt;code&gt;tableView&lt;/code&gt; 持有 &lt;code&gt;conntroller&lt;/code&gt;，&lt;code&gt;strong&lt;/code&gt; 属性&lt;/p&gt;
&lt;p&gt;那么当第三个关系被打破时，也就是没有对象持有 &lt;code&gt;controller&lt;/code&gt; 了（发生 &lt;code&gt;[controller release]&lt;/code&gt;，这时候 &lt;code&gt;controller&lt;/code&gt; 会释放他所有的内存，发生下面的事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其他对象调用 &lt;code&gt;[controller release]&lt;/code&gt;，&lt;code&gt;tableView&lt;/code&gt; 依然持有 &lt;code&gt;controller&lt;/code&gt;，&lt;code&gt;controller&lt;/code&gt; 不会释放内存（不会调用 &lt;code&gt;dealloc&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样，&lt;code&gt;tableView&lt;/code&gt; 和 &lt;code&gt;controller&lt;/code&gt; 互相持有，但是没有任何对象在持有他们，但是他们不会被释放，因为都有一个对象持有着他们，于是内存泄漏，这种情况是一种简单的循环引用&lt;/p&gt;
&lt;p&gt;所以，这就是为什么我们写的代码如果会使用到 delegate 模式，需要将 delegate 的属性设置为 &lt;code&gt;weak&lt;/code&gt;，但是从上面例子我们可以理解到，并不是 delegate 需要 &lt;code&gt;weak&lt;/code&gt; 而是因为出现了 delegate 和使用 delegate 的对象互相持有（循环引用），那么如果我们的代码中不会出现循环引用，那么使用 &lt;code&gt;weak&lt;/code&gt; 反而会出错（delegate 被过早的释放），不过这种时候往往有其他对象会持有 delegate&lt;/p&gt;
&lt;p&gt;上面其实只描述了最简单的循环引用场景，在复杂的场景中，可能会有很多个对象依次持有直到循环，面对各种各样复杂的场景，本文认为解决内存问题的方法都是，针对每个对象，每个类，理清他们之间的持有关系，也就是：&lt;/p&gt;
&lt;center&gt;&lt;span&gt;对象之间存在持有关系，是否被持有，决定了对象是否被销毁，ARC 中的内存管理，就是理清对象之间的持有关系&lt;/span&gt;&lt;/center&gt;
&lt;h4 id=&quot;weak-和-__strong&quot;&gt;&lt;code&gt;__weak&lt;/code&gt; 和 &lt;code&gt;__strong&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;strong&lt;/code&gt; 和 &lt;code&gt;weak&lt;/code&gt; 是在设置属性的时候使用的，&lt;code&gt;__weak&lt;/code&gt; 和 &lt;code&gt;__strong&lt;/code&gt; 是用于变量的，这两个关键字在开发的过程中不会频繁的用到，是因为如果没有指定，那么变量默认是通过 &lt;code&gt;__strong&lt;/code&gt; 修饰的，不过当我们需要使用这两个关键字的时候，那么也将是我们面对坑最多的情况的时候 —— block 的使用&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;__strong&lt;/code&gt;：变量默认的修饰符，对应 property 的 &lt;code&gt;strong&lt;/code&gt;，会持有（这里可以认为是当前代码块持有）变量，这里的持有相当于在变量赋值后调用 &lt;code&gt;retain&lt;/code&gt; 方法，在代码块结束时调用 &lt;code&gt;release&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__weak&lt;/code&gt;：对应 property 的 &lt;code&gt;weak&lt;/code&gt;，同样在变量被释放后，变量的值会变成 &lt;code&gt;nil&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;变量描述符场景-block-的循环引用&quot;&gt;变量描述符场景 —— block 的循环引用&lt;/h5&gt;
&lt;p&gt;下面我们来看个平常经常会遇到的场景，考虑下面的代码：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;// 文件 Dummy.h
@interface Dummy : NSObject

@property (nonatomic, strong) void (^do_block)();

- (void)do_sth:(NSString *)msg;

@end

// 文件 Dummy.m
@interface Dummy()
@end

@implementation Dummy

- (void)do_sth:(NSString *)msg {
    NSLog(@&quot;Enter do_sth&quot;);
    self.do_block = ^() {
        [self do_sth_inner:msg];
    };
    self.do_block();
    NSLog(@&quot;Exit do_sth&quot;);
}

- (void)do_sth_inner:(NSString *)msg {
    NSLog(@&quot;do sth inner: %@&quot;, msg);
}

@end

// 文件 AppDelegate.m
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    Dummy *dummy = [[Dummy alloc] init];
    [dummy do_sth:@&quot;hello&quot;];
    return YES;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建一个空白的单页面 iOS 应用，这里大家一定知道结果了，在控制台会输出这样的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2018-11-15 22:56:34.281346+0800 iOSPlayground[42178:5466855] Enter do_sth
2018-11-15 22:56:34.281445+0800 iOSPlayground[42178:5466855] do sth inner: hello
2018-11-15 22:56:34.281536+0800 iOSPlayground[42178:5466855] Exit do_sth&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然相信大家已经看出问题来了，上面的代码会造成循环引用，当然很多时候我们在学习写 iOS 代码的时候，都会有人教导过我们 block 里面的 self 是会存在循环引用的（如上代码的结果），必须要使用 &lt;code&gt;__weak&lt;/code&gt;，那么为什么呢？这里依然回到上面的内存管理原则，我们来梳理一下持有关系，首先这里有一个基础知识，那就是 block 是一个对象，并且他会持有所有他捕获的变量，这里我们来看下内存持有关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/76924-32a62ad82c20cd87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;持有关系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样，我们来分析下这个持有关系&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;self&lt;/code&gt; 对象持有了 &lt;code&gt;do_block&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;由于 &lt;code&gt;self&lt;/code&gt; 在 &lt;code&gt;do_block&lt;/code&gt; 中使用了，所以 &lt;code&gt;do_block&lt;/code&gt; 的代码区块持有了 &lt;code&gt;self&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其他对象（这里是 &lt;code&gt;AppDelegate&lt;/code&gt; 实例）通过变量的方式持有对外的 &lt;code&gt;dummy&lt;/code&gt; 对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么在我们的代码执行到 &lt;code&gt;-application:didFinishLaunchingWithOptions:&lt;/code&gt; 最后一行的时候，由于代码块的结束，ARC 将会对块内产生的对象分别调用 &lt;code&gt;release&lt;/code&gt; 释放对象，这时候，上面 3 的持有关系被打破了&lt;/p&gt;
&lt;p&gt;但是，由于 1，2 这两条持有关系存在，所以无论是 &lt;code&gt;self&lt;/code&gt; 对象，还是 &lt;code&gt;do_sth&lt;/code&gt; block 他们都至少被一个对象所持有，所以，他们无法被释放，并且也无法被外界所访问到，形成了&lt;strong&gt;循环引用&lt;/strong&gt;导致内存泄漏，通过 Xcode 提供的内存图（Debug Memeory Graph）我们也可以看到，这一现象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/76924-f673df69a66fb58d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;内存图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么这里的解决方法就是，进行下面的修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- (void)do_sth:(NSString *)msg {
    NSLog(@&quot;Enter do_sth&quot;);
    __weak typeof(self) weakself = self;
    self.do_block = ^() {
        [weakself do_sth_inner:msg];
    };
    self.do_block();
    NSLog(@&quot;Exit do_sth&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样打破了上面持有关系 2 中，&lt;code&gt;do_block&lt;/code&gt; 持有 &lt;code&gt;self&lt;/code&gt; 的问题，这样就和上面描述 delegate 的场景一样了&lt;/p&gt;
&lt;h5 id=&quot;变量描述符场景-block-的循环引用-2&quot;&gt;变量描述符场景 —— block 的循环引用 2&lt;/h5&gt;
&lt;p&gt;接下来看下另外一个循环引用的场景，&lt;code&gt;Dummy&lt;/code&gt; 类的定义不变，使用方法做一些调整：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    Dummy *dummy = [[Dummy alloc] init];    
    dummy.do_block = ^{
        [dummy do_sth_inner:@&quot;hello2&quot;];
    };
    dummy.do_block();
    return YES;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;奇怪，这里没有 &lt;code&gt;self&lt;/code&gt; 了啊，为什么依然循环引用了啊？接着继续看持有关系图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/76924-70818007d849e4e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;持有关系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是和上一个场景很像？因为就是一样的，只是一个视野在类的内部，另一个视野在类的外部，在类的内部那就是 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;do_block&lt;/code&gt; 互相持有，形成循环引用；在类的外部那就是 &lt;code&gt;dummy&lt;/code&gt; 和 &lt;code&gt;do_block&lt;/code&gt; 互相持有，形成循环应用&lt;/p&gt;
&lt;h2 id=&quot;一点个人经验&quot;&gt;一点个人经验&lt;/h2&gt;
&lt;p&gt;实际项目肯定不会是本文中这么明显简单的场景，但是再多复杂的场景肯定是这些简单的场景不断的嵌套组合而成，所以保证代码内存没有问题的最好的方法是每次遇到需要处理内存场景时，仔细分析对象间的持有关系，也就是保证组成复杂场景的每个小场景都没有问题，那么基本就不会出现问题了，对于出现内存管理出现问题的情况，一般我们都能定位到是某一部分代码内存泄漏了，那么直接分析那部分代码的持有关系是否正确&lt;/p&gt;
&lt;p&gt;iOS macOS 开发中的内存管理不要在意引用计数，引用计数是给运行时看的东西，作为人类我们需要在意对象间的持有关系，理清持有关系那么就表明引用计数不会有问题&lt;/p&gt;

&lt;p&gt;到此对于内存管理的思路算是结束了，但是就像本文一开始所说的，这里并不是结束而是开始，接下来建议大家在有了一定经验后可以再去深入了解下面的内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Core Foundation 框架的内存管理，没有 ARC 的眷顾&lt;/li&gt;
&lt;li&gt;Core Foundation 框架和 Objective-C 的内存交互 —— Toll-Free Bridging，ARC 和 CF 框架的桥梁&lt;/li&gt;
&lt;li&gt;Objective-C 高级编程 —— 《iOS 与 OS X 多线程和内存管理》，我从这本书里面收益良多&lt;/li&gt;
&lt;li&gt;Swift 下的内存管理，分清 &lt;code&gt;weak&lt;/code&gt;，&lt;code&gt;unowned&lt;/code&gt; 有什么区别，逻辑依然是理清持有关系&lt;/li&gt;
&lt;li&gt;C 语言入门，Objective-C 源自于 C 语言，所有 C 语言的招式在 Objective-C 中都好用，在某些特殊场景会必定会用到&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后欢迎大家订阅我的微信公众号 Little Code&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/76924-daa1d6ba5ccf273b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Little Code&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;公众号主要发一些开发相关的技术文章&lt;/li&gt;
&lt;li&gt;谈谈自己对技术的理解，经验&lt;/li&gt;
&lt;li&gt;也许会谈谈人生的感悟&lt;/li&gt;
&lt;li&gt;本人不是很高产，但是力求保证质量和原创&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 17 Nov 2018 10:53:00 +0000</pubDate>
<dc:creator>noark9</dc:creator>
<og:description>在 iOS 和 macOS 应用的开发中，无论是使用 Objective C 还是使用 swift 都是通过引用计数策略来进行内存管理的，但是在日常开发中80%（这里，我瞎说的，8020 原则嘛😆）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noark9/p/9975124.html</dc:identifier>
</item>
<item>
<title>分享知识-快乐自己：Struts2（动态方法、动态结果、通配符、方法内部跳转、action跳转、OGNL 的使用及注意事项） - GDBD</title>
<link>http://www.cnblogs.com/mlq2017/p/9974838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mlq2017/p/9974838.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、动态方法调用：&lt;/strong&gt;使用关键 符号 ! 进行操作   例如：/命名空间 ! 方法名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、动态结果集：&lt;/strong&gt;就是说，通过后台返回的结果 ${} 获取，重定向到符合预期的页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181117165942495-1903565844.png&quot; alt=&quot;&quot; width=&quot;702&quot; height=&quot;250&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、万能通配符：&lt;/strong&gt;*_*  ：第一个 * 为 类名、第二个 * 为方法名；{1}是第一个 *&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、内部方法的调用：&lt;/strong&gt;就是说 Action 类中的 A()  调用 B()  A方法返回B()的结果集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、跳转Action：&lt;/strong&gt;就是说访问一个方法，根据返回的结果匹配 result中的 name 值 跳入下一个action &lt;strong&gt;（result type=chain）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181117165711733-1873938400.png&quot; alt=&quot;&quot; width=&quot;670&quot; height=&quot;262&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 6、OGNL：（不过多讲述相关概念，这里以代码为核心）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;值栈的内部结构分为两部分：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一部分：root，结构是 list 集合一般操作的都是 root 里面的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第二部分：context，结构为 Map 集合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用经历：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;root 单列集合下的 前台获取的时候不需要写 #&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;context 双列集合  前台获取的时候需要写 #&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、往 单列集合中推送 集合类型的数据时，不能触碰到集合的引用名称。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将泛型集合推送到值栈中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181117172926246-1526083273.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用 &amp;lt;s:debug/&amp;gt; 标签查看 值栈的信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181117173320194-1827508502.png&quot; alt=&quot;&quot; width=&quot;362&quot; height=&quot;312&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2、值栈的访问顺序为 从上往下 寻址。如有同名的属性名，则寻址离值栈顶端最近的&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181117171959204-1380292959.png&quot; alt=&quot;&quot; width=&quot;571&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;核心代码截取：推送到root 也就是单列集合下&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181117172113763-1936823522.png&quot; alt=&quot;&quot; width=&quot;474&quot; height=&quot;421&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用 &amp;lt;s:debug/&amp;gt; 标签查看 值栈的信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181117172240979-1170904497.png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;226&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、在我们实现 Action 接口 或 继承ActionSupport 的类中的成员属性都是放在 root 单列集合下的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181117173538497-1970461064.png&quot; alt=&quot;&quot; width=&quot;519&quot; height=&quot;115&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181117173708498-47282217.png&quot; alt=&quot;&quot; width=&quot;522&quot; height=&quot;213&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、往值栈 context 推送 key那一列会有我们指定的引用名称（需要获取的时候需要 #）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181117174550419-845535006.png&quot; alt=&quot;&quot; width=&quot;645&quot; height=&quot;242&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181117174520902-706331485.png&quot; alt=&quot;&quot; width=&quot;647&quot; height=&quot;74&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 以上为可能会遇到的问题。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;a href=&quot;https://github.com/MlqBeginner/BlogGardenWarehouse/blob/master/StrutsDay03.rar&quot; target=&quot;_blank&quot;&gt;点我下载案例Demo：&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 案例结构：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181117174934518-1946187650.png&quot; alt=&quot;&quot; width=&quot;328&quot; height=&quot;447&quot;/&gt;为演示通配符需要方法名与jsp名称一致，add.jsp 与 list.jsp 创建在 CoordinAction文件下 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;POM：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_346c9c62-3c55-40c2-825c-6d15a9f26481&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_346c9c62-3c55-40c2-825c-6d15a9f26481&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_346c9c62-3c55-40c2-825c-6d15a9f26481&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
 &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;1.7&amp;lt;/maven.compiler.source&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;1.7&amp;lt;/maven.compiler.target&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;

        &amp;lt;!--测试JAR--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--javaee.jar包是支持javaweb编程的基础jar包，跟javase编程需要jre一样！--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javaee&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;javaee-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Struts2-core核心--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.struts&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;struts2-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.3.4.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--xwork 的核心包，最主要的功能是 支持了过滤器（interceptor）。--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.struts.xwork&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;xwork-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.3.4.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;CoordinAction：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_299105be-3f3f-498a-8e1d-cb2e16061306&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_299105be-3f3f-498a-8e1d-cb2e16061306&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_299105be-3f3f-498a-8e1d-cb2e16061306&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gdbd.action;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionSupport;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; asus
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CoordinAction &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ActionSupport {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String message;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String mess;
　　...省略 Get Set


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
     * 动态方法的调用
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String list() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setMessage(&quot;通过调用 add 方法拿到返回的name寻址，再次调度 Action 中的list&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;list&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String add() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setMessage(&quot;动态方法调度！！！！&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;add&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String get() {
        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; session =&lt;span&gt; ActionContext.getContext().getSession();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.message != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            session.put(&lt;/span&gt;&quot;message&quot;, &quot;动态结果集调用成功！！！&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setMess(&quot;demo2&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            session.put(&lt;/span&gt;&quot;message&quot;, &quot;动态结果集调用失败！！！&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setMess(&quot;error&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;get&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
     * 内部方法的调用
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String demo1() {
        Map request &lt;/span&gt;= (Map) ActionContext.getContext().get(&quot;request&quot;&lt;span&gt;);
        request.put(&lt;/span&gt;&quot;message&quot;, &quot;测试数据Action内部调度！！！&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;demo2&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String demo2() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; demo1();
    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;OgnlAction：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_360e809f-a73c-4910-b0db-67a3ca79b6a3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_360e809f-a73c-4910-b0db-67a3ca79b6a3&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_360e809f-a73c-4910-b0db-67a3ca79b6a3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gdbd.action;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.gdbd.bean.UserInfo;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionSupport;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.util.ValueStack;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; asus
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OgnlAction &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ActionSupport {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;UserInfo&amp;gt;&lt;span&gt; List;
　　...省略 Get Set


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
     * OGNL：存储到单列集合
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String demo1() {
        ActionContext context &lt;/span&gt;=&lt;span&gt; ActionContext.getContext();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取值栈&lt;/span&gt;
        ValueStack valueStack =&lt;span&gt; context.getValueStack();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;伪造数据&lt;/span&gt;
        UserInfo userInfo=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserInfo();
        userInfo.setUserName(&lt;/span&gt;&quot;MLQ&quot;&lt;span&gt;);
        userInfo.setUserPwd(&lt;/span&gt;&quot;MLQ&quot;&lt;span&gt;);
        UserInfo userInfo1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserInfo();
        userInfo1.setUserName(&lt;/span&gt;&quot;FKX&quot;&lt;span&gt;);
        userInfo1.setUserPwd(&lt;/span&gt;&quot;FKX&quot;&lt;span&gt;);
        List&lt;/span&gt;&amp;lt;UserInfo&amp;gt; infoList=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;UserInfo&amp;gt;&lt;span&gt;();
        infoList.add(userInfo);
        infoList.add(userInfo1);
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
         * 将数据推送到单列集合中
         * 缺点：对集合类型进行操作的时候，没有办法触碰到集合的引用名称
         * 例如：添加一个 泛型List&amp;lt;UserInfo&amp;gt; 集合  没有
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        valueStack.push(userInfo);
        valueStack.push(userInfo1);
        valueStack.push(infoList);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;  &quot;demo1&quot;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
     * OGNL：存储到双列集合
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String demo2() {
        ActionContext context &lt;/span&gt;=&lt;span&gt; ActionContext.getContext();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取值栈&lt;/span&gt;
        ValueStack valueStack =&lt;span&gt; context.getValueStack();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;伪造数据&lt;/span&gt;
        UserInfo userInfo=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserInfo();
        userInfo.setUserName(&lt;/span&gt;&quot;MLQ&quot;&lt;span&gt;);
        userInfo.setUserPwd(&lt;/span&gt;&quot;MLQ&quot;&lt;span&gt;);
        UserInfo userInfo1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserInfo();
        userInfo1.setUserName(&lt;/span&gt;&quot;FKX&quot;&lt;span&gt;);
        userInfo1.setUserPwd(&lt;/span&gt;&quot;FKX&quot;&lt;span&gt;);
        List&lt;/span&gt;&amp;lt;UserInfo&amp;gt; infoList=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;UserInfo&amp;gt;&lt;span&gt;();
        infoList.add(userInfo);
        infoList.add(userInfo1);
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
         * 将数据推送到双列集合中
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;valueStack.push(infoList);将泛型集合推送到值栈中，没有引用地址&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.List=&lt;span&gt;infoList;
        valueStack.getContext().put(&lt;/span&gt;&quot;infoList&quot;&lt;span&gt;,infoList);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;  &quot;demo1&quot;&lt;span&gt;;
    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;UserInfo：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_a61bb3cd-dda4-44fb-9c6a-40319ada2da1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a61bb3cd-dda4-44fb-9c6a-40319ada2da1&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a61bb3cd-dda4-44fb-9c6a-40319ada2da1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gdbd.bean;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * user 实体类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; asus
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserInfo &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userName;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userPwd;

    ...省略 Get Set
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;struts.xml：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_8469e210-3af4-40d1-b354-8295b69b2457&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8469e210-3af4-40d1-b354-8295b69b2457&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8469e210-3af4-40d1-b354-8295b69b2457&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE struts PUBLIC  &quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;
        &quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&amp;gt;
&amp;lt;struts&amp;gt;

    &amp;lt;!-- 是否开启动态方法调用 --&amp;gt;
    &amp;lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;/&amp;gt;
    &amp;lt;!--更改 Struts.xml的 节点不需要重启--&amp;gt;
    &amp;lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;&amp;gt;&amp;lt;/constant&amp;gt;

    &amp;lt;!--动态--&amp;gt;
    &amp;lt;&lt;span&gt;package&lt;/span&gt; name=&quot;default&quot; namespace=&quot;/&quot; &lt;span&gt;extends&lt;/span&gt;=&quot;struts-default&quot;&amp;gt;

        &amp;lt;!--动态方法调度 使用（ ! ） --&amp;gt;
        &amp;lt;action name=&quot;demo&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.gdbd.action.CoordinAction&quot;&amp;gt;
            &amp;lt;result name=&quot;add&quot;&amp;gt;/error.jsp&amp;lt;/result&amp;gt;
        &amp;lt;/action&amp;gt;
        &amp;lt;!--
            *_*&lt;span&gt;：
            第一个 &lt;/span&gt;*&lt;span&gt;  为 类名
            第二个 &lt;/span&gt;*&lt;span&gt;  为  方法名
        &lt;/span&gt;--&amp;gt;
        &amp;lt;!--万能通配符--&amp;gt;
        &amp;lt;action name=&quot;*_*&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.gdbd.action.{1}&quot; method=&quot;{2}&quot;&amp;gt;
            &amp;lt;result name=&quot;{2}&quot;&amp;gt;{1}/{2}.jsp&amp;lt;/result&amp;gt;
        &amp;lt;/action&amp;gt;

    &amp;lt;/&lt;span&gt;package&lt;/span&gt;&amp;gt;

    &amp;lt;!--内部方法的调用--&amp;gt;
    &amp;lt;&lt;span&gt;package&lt;/span&gt; name=&quot;demo&quot; namespace=&quot;/demo1&quot; &lt;span&gt;extends&lt;/span&gt;=&quot;struts-default&quot;&amp;gt;

        &amp;lt;!--&lt;span&gt;
            action 内部方法调度
         &lt;/span&gt;--&amp;gt;
        &amp;lt;action name=&quot;mo&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.gdbd.action.CoordinAction&quot; method=&quot;demo1&quot;&amp;gt;
            &amp;lt;result name=&quot;demo2&quot;&amp;gt;/demo2.jsp&amp;lt;/result&amp;gt;
        &amp;lt;/action&amp;gt;
        &amp;lt;!--&lt;span&gt;
            action 内部方法调度 重定向页面
         &lt;/span&gt;--&amp;gt;
        &amp;lt;action name=&quot;mo1&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.gdbd.action.CoordinAction&quot; method=&quot;demo1&quot;&amp;gt;
            &amp;lt;result name=&quot;demo2&quot; type=&quot;redirect&quot;&amp;gt;/demo2.jsp&amp;lt;/result&amp;gt;
        &amp;lt;/action&amp;gt;

    &amp;lt;/&lt;span&gt;package&lt;/span&gt;&amp;gt;

    &amp;lt;!--调度 action 中的方法，在根据结果集再次跳转到 action 方法 --&amp;gt;
    &amp;lt;&lt;span&gt;package&lt;/span&gt; name=&quot;demo2&quot; namespace=&quot;/demo2&quot; &lt;span&gt;extends&lt;/span&gt;=&quot;struts-default&quot;&amp;gt;

        &amp;lt;action name=&quot;listdemo&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.gdbd.action.CoordinAction&quot; method=&quot;list&quot;&amp;gt;
            &amp;lt;result name=&quot;list&quot;&amp;gt;/demo2.jsp&amp;lt;/result&amp;gt;
        &amp;lt;/action&amp;gt;

        &amp;lt;action name=&quot;mo&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.gdbd.action.CoordinAction&quot; method=&quot;add&quot;&amp;gt;
            &amp;lt;result name=&quot;add&quot; type=&quot;chain&quot;&amp;gt;
                &amp;lt;!--默认是转发--&amp;gt;
                &amp;lt;param name=&quot;actionName&quot;&amp;gt;listdemo&amp;lt;/param&amp;gt;
                &amp;lt;param name=&quot;namespace&quot;&amp;gt;/demo2&amp;lt;/param&amp;gt;
            &amp;lt;/result&amp;gt;
        &amp;lt;/action&amp;gt;

    &amp;lt;/&lt;span&gt;package&lt;/span&gt;&amp;gt;

    &amp;lt;!--动态结果：重定向页面（转发无效）--&amp;gt;
    &amp;lt;&lt;span&gt;package&lt;/span&gt; name=&quot;demo3&quot; namespace=&quot;/demo3&quot; &lt;span&gt;extends&lt;/span&gt;=&quot;struts-default&quot;&amp;gt;

        &amp;lt;action name=&quot;mo&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.gdbd.action.CoordinAction&quot; method=&quot;get&quot;&amp;gt;
            &amp;lt;result name=&quot;get&quot; type=&quot;redirect&quot;&amp;gt;${mess}&amp;lt;/result&amp;gt;
        &amp;lt;/action&amp;gt;
        &amp;lt;action name=&quot;demo2&quot;&amp;gt;
            &amp;lt;result&amp;gt;/demo2.jsp&amp;lt;/result&amp;gt;
        &amp;lt;/action&amp;gt;
        &amp;lt;action name=&quot;error&quot;&amp;gt;
            &amp;lt;result&amp;gt;/error.jsp&amp;lt;/result&amp;gt;
        &amp;lt;/action&amp;gt;

    &amp;lt;/&lt;span&gt;package&lt;/span&gt;&amp;gt;

    &amp;lt;!--OGNL 测试--&amp;gt;
    &amp;lt;&lt;span&gt;package&lt;/span&gt; name=&quot;demo4&quot; namespace=&quot;/demo4&quot; &lt;span&gt;extends&lt;/span&gt;=&quot;struts-default&quot;&amp;gt;

        &amp;lt;!--推送到单列集合中--&amp;gt;
        &amp;lt;action name=&quot;mo&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.gdbd.action.OgnlAction&quot; method=&quot;demo1&quot;&amp;gt;
            &amp;lt;result name=&quot;demo1&quot;&amp;gt;/demo1.jsp&amp;lt;/result&amp;gt;
        &amp;lt;/action&amp;gt;
        &amp;lt;!--推送到双列集合中--&amp;gt;
        &amp;lt;action name=&quot;mo1&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.gdbd.action.OgnlAction&quot; method=&quot;demo2&quot;&amp;gt;
            &amp;lt;result name=&quot;demo1&quot;&amp;gt;/demo1.jsp&amp;lt;/result&amp;gt;
        &amp;lt;/action&amp;gt;
    &amp;lt;/&lt;span&gt;package&lt;/span&gt;&amp;gt;

&amp;lt;/struts&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;add.jsp：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_4df21474-f377-46be-9a74-a5f0de6ecb94&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4df21474-f377-46be-9a74-a5f0de6ecb94&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4df21474-f377-46be-9a74-a5f0de6ecb94&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&amp;lt;%--&lt;span&gt;
  Created by IntelliJ IDEA.
  User: asus
  Date: &lt;/span&gt;2018/11/17&lt;span&gt;
  Time: &lt;/span&gt;9:33&lt;span&gt;
  To change &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; template use File | Settings |&lt;span&gt; File Templates.
&lt;/span&gt;--%&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;add==========&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;list.jsp：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_ea8e7a7a-99a4-41c9-8ffc-9d45d7f3db78&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ea8e7a7a-99a4-41c9-8ffc-9d45d7f3db78&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ea8e7a7a-99a4-41c9-8ffc-9d45d7f3db78&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&amp;lt;%--&lt;span&gt;
  Created by IntelliJ IDEA.
  User: asus
  Date: &lt;/span&gt;2018/11/17&lt;span&gt;
  Time: &lt;/span&gt;9:33&lt;span&gt;
  To change &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; template use File | Settings |&lt;span&gt; File Templates.
&lt;/span&gt;--%&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;list==========&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;demo1.jsp：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_ad2a6905-bd96-40d1-8bcd-d2514eab9732&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ad2a6905-bd96-40d1-8bcd-d2514eab9732&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ad2a6905-bd96-40d1-8bcd-d2514eab9732&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&amp;lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&amp;gt;
&amp;lt;%--&lt;span&gt;
  Created by IntelliJ IDEA.
  User: asus
  Date: &lt;/span&gt;2018/11/17&lt;span&gt;
  Time: &lt;/span&gt;9:33&lt;span&gt;
  To change &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; template use File | Settings |&lt;span&gt; File Templates.
&lt;/span&gt;--%&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;fieldset&amp;gt;
    &amp;lt;legend&amp;gt;OGNL：获取的结果（值栈单列集合）&amp;lt;/legend&amp;gt;&lt;span&gt;
    姓名为：&lt;/span&gt;&amp;lt;s:property value=&quot;userName&quot;&amp;gt;&amp;lt;/s:property&amp;gt;
    &amp;lt;br/&amp;gt;&lt;span&gt;
    密码为：&lt;/span&gt;&amp;lt;s:property value=&quot;userPwd&quot;&amp;gt;&amp;lt;/s:property&amp;gt;
&amp;lt;/fieldset&amp;gt;
&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;fieldset&amp;gt;
    &amp;lt;legend&amp;gt;OGNL：获取的结果（值栈Root 单列集合）&amp;lt;/legend&amp;gt;&lt;span&gt;
    姓名为：&lt;/span&gt;&amp;lt;s:property value=&quot;List[0].userName&quot;&amp;gt;&amp;lt;/s:property&amp;gt;
    &amp;lt;br/&amp;gt;&lt;span&gt;
    密码为：&lt;/span&gt;&amp;lt;s:property value=&quot;List[1].userPwd&quot;&amp;gt;&amp;lt;/s:property&amp;gt;
&amp;lt;/fieldset&amp;gt;
&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;fieldset&amp;gt;
    &amp;lt;legend&amp;gt;OGNL：获取的结果（值栈双列集合）&amp;lt;/legend&amp;gt;&lt;span&gt;
    姓名为：&lt;/span&gt;&amp;lt;s:property value=&quot;#infoList[0].userName&quot;&amp;gt;&amp;lt;/s:property&amp;gt;
    &amp;lt;br/&amp;gt;&lt;span&gt;
    密码为：&lt;/span&gt;&amp;lt;s:property value=&quot;#infoList[1].userPwd&quot;&amp;gt;&amp;lt;/s:property&amp;gt;
&amp;lt;/fieldset&amp;gt;
&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;fieldset&amp;gt;
    &amp;lt;legend&amp;gt;OGNL：获取的结果（值栈双列集合,便利读取）&amp;lt;/legend&amp;gt;
    &amp;lt;s:iterator value=&quot;infoList&quot; id=&quot;info&quot;&amp;gt;
        &amp;lt;s:property value=&quot;#info.userName&quot;/&amp;gt;
    &amp;lt;/s:iterator&amp;gt;
&amp;lt;/fieldset&amp;gt;
&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;s:debug/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;demo2.jsp：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_703c0dad-4038-41cf-838f-b877c9587f09&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_703c0dad-4038-41cf-838f-b877c9587f09&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_703c0dad-4038-41cf-838f-b877c9587f09&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;%--&lt;span&gt;
  Created by IntelliJ IDEA.
  User: asus
  Date: &lt;/span&gt;2018/11/17&lt;span&gt;
  Time: &lt;/span&gt;9:33&lt;span&gt;
  To change &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; template use File | Settings |&lt;span&gt; File Templates.
&lt;/span&gt;--%&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;${message}&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;error.jsp：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_bb52d11b-3150-46a3-b86f-e0e778acc3dc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bb52d11b-3150-46a3-b86f-e0e778acc3dc&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bb52d11b-3150-46a3-b86f-e0e778acc3dc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;%--&lt;span&gt;
  Created by IntelliJ IDEA.
  User: asus
  Date: &lt;/span&gt;2018/11/17&lt;span&gt;
  Time: &lt;/span&gt;9:33&lt;span&gt;
  To change &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; template use File | Settings |&lt;span&gt; File Templates.
&lt;/span&gt;--%&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;${message}&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;index.jsp：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7215b231-1a12-4044-808b-63feeb10c526&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7215b231-1a12-4044-808b-63feeb10c526&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7215b231-1a12-4044-808b-63feeb10c526&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;%--&lt;span&gt;
  Created by IntelliJ IDEA.
  User: asus
  Date: &lt;/span&gt;2018/11/17&lt;span&gt;
  Time: &lt;/span&gt;10:34&lt;span&gt;
  To change &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; template use File | Settings |&lt;span&gt; File Templates.
&lt;/span&gt;--%&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;fieldset&amp;gt;
    &amp;lt;legend&amp;gt;动态方法调度&amp;lt;/legend&amp;gt;
    &amp;lt;a href=&quot;/demo!add&quot;&amp;gt;动态方法调度&amp;lt;/a&amp;gt;
&amp;lt;/fieldset&amp;gt;
&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;fieldset&amp;gt;
    &amp;lt;legend&amp;gt;万能通配符&amp;lt;/legend&amp;gt;
    &amp;lt;a href=&quot;/CoordinAction_list&quot;&amp;gt;万能通配符&amp;lt;/a&amp;gt;
    &amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;&lt;span&gt;nbsp;
    &lt;/span&gt;&amp;lt;a href=&quot;/CoordinAction_add&quot;&amp;gt;万能通配符&amp;lt;/a&amp;gt;
&amp;lt;/fieldset&amp;gt;
&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;fieldset&amp;gt;
    &amp;lt;legend&amp;gt;内部方法调度返回的信息&amp;lt;/legend&amp;gt;
    &amp;lt;a href=&quot;/demo1/mo&quot;&amp;gt;内部方法调度返回的信息：默认是转发&amp;lt;/a&amp;gt;
    &amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;&lt;span&gt;nbsp;
    &lt;/span&gt;&amp;lt;a href=&quot;/demo1/mo1&quot;&amp;gt;内部方法调度返回的信息：使用重定向&amp;lt;/a&amp;gt;
&amp;lt;/fieldset&amp;gt;
&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;fieldset&amp;gt;
    &amp;lt;legend&amp;gt;调度 action 中的方法，在根据结果集再次跳转到 action 方法&amp;lt;/legend&amp;gt;
    &amp;lt;a href=&quot;/demo2/mo&quot;&amp;gt;跳转 add 方法 根据结果再次 指向list：转发操作&amp;lt;/a&amp;gt;
    &amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;&lt;span&gt;nbsp;
    &lt;/span&gt;&amp;lt;a href=&quot;#&quot;&amp;gt;###&amp;lt;/a&amp;gt;
&amp;lt;/fieldset&amp;gt;
&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;fieldset&amp;gt;
    &amp;lt;legend&amp;gt;动态结果调度&amp;lt;/legend&amp;gt;
    &amp;lt;a href=&quot;/demo3/mo?message=123&quot;&amp;gt;动态结果调度：重定向&amp;lt;/a&amp;gt;
    &amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;&lt;span&gt;nbsp;
    &lt;/span&gt;&amp;lt;a href=&quot;#&quot;&amp;gt;###&amp;lt;/a&amp;gt;
&amp;lt;/fieldset&amp;gt;
&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;fieldset&amp;gt;
    &amp;lt;legend&amp;gt;OGNL&amp;lt;/legend&amp;gt;
    &amp;lt;a href=&quot;/demo4/mo&quot;&amp;gt;OGNL：存储到值栈的单列集合&amp;lt;/a&amp;gt;
    &amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;&lt;span&gt;nbsp;
    &lt;/span&gt;&amp;lt;a href=&quot;/demo4/mo1&quot;&amp;gt;OGNL：存储到值栈的单列集合&amp;lt;/a&amp;gt;
    &amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;&lt;span&gt;nbsp;
&lt;/span&gt;&amp;lt;/fieldset&amp;gt;
&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;web.xml：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_8b1f3e8d-ce27-4ce9-9c15-d9dc9bdc67a9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8b1f3e8d-ce27-4ce9-9c15-d9dc9bdc67a9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8b1f3e8d-ce27-4ce9-9c15-d9dc9bdc67a9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE web-&lt;span&gt;app PUBLIC
        &lt;/span&gt;&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;
        &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &amp;gt;

&amp;lt;web-app&amp;gt;
    &amp;lt;display-name&amp;gt;Archetype Created Web Application&amp;lt;/display-name&amp;gt;

    &amp;lt;!--核心过滤器--&amp;gt;
    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&amp;lt;/filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;

&amp;lt;/web-app&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 17 Nov 2018 10:16:00 +0000</pubDate>
<dc:creator>GDBD</dc:creator>
<og:description>这里主要以案例演示：涵盖以下知识点 1、动态方法调用：使用关键 符号 ! 进行操作 例如：/命名空间 ! 方法名 2、动态结果集：就是说，通过后台返回的结果 ${} 获取，重定向到符合预期的页面。 3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mlq2017/p/9974838.html</dc:identifier>
</item>
</channel>
</rss>