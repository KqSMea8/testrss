<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SmartCode.ETL 这不是先有鸡还是蛋的问题! - Ahoo-Wang</title>
<link>http://www.cnblogs.com/Ahoo-Wang/p/SmartCode-ETL.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Ahoo-Wang/p/SmartCode-ETL.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;继国庆节 SmartCode 正式版（SmartCode.Generator）发布之后，SmartCode 迎来了新的能力 SmartCode.ETL !&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5.8284518828452&quot;&gt;
&lt;p&gt;SmartCode 正式版从开始发布就从未说过自己仅仅是个代码生成器，这点上从我第一次宣布SmartCode正式开源的文章就可以说明：&lt;a href=&quot;https://www.cnblogs.com/Ahoo-Wang/p/SmartCode-intro.html&quot;&gt;《SmartCode 不只是代码生成器》&lt;/a&gt;，这不仅仅是一句推广语！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;smartcode.generator&quot;&gt;SmartCode.Generator&lt;/h2&gt;
&lt;p&gt;相信不少同学都用过各种代码生成器，这里我就不做详细介绍了，如果想体验 SmartCode.Generator 请至 &lt;a href=&quot;https://www.cnblogs.com/Ahoo-Wang/p/SmartCode-intro.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/Ahoo-Wang/p/SmartCode-intro.html&lt;/a&gt; 配置好数据库连接，一键生成解决方案。&lt;/p&gt;
&lt;h2 id=&quot;why-smartcode.etl&quot;&gt;Why SmartCode.ETL&lt;/h2&gt;
&lt;p&gt;相信不少已经落地微服务架构方案的同学都会遇到同样的问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;业务方的查询需求似乎总是跨微服务DB的&lt;/li&gt;
&lt;li&gt;领导层需要查看的报表数据总是全局的（需要聚合跨微服务DB的）&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;so-smartcode.etl&quot;&gt;So SmartCode.ETL&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;从多个微服务DB 同步业务聚合查询数据到 all_biz DB （解决：微服务架构一定会遇到的业务方需要跨微服务DB查询的问题）&lt;/li&gt;
&lt;li&gt;从 all_biz DB 同步聚合分析数据到 report DB (解决：领导层查看的报表数据聚合问题)&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;how-smartcode.etl&quot;&gt;How SmartCode.ETL&lt;/h2&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;安装 SmartCode from dotnet-cli&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;dotnet tool install --global SmartCode.CLI&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;使用 SmartCode.Generator 生成 同步Sql表结构脚本，以及 SmartCode.ETL 构建配置&lt;/li&gt;
&lt;li&gt;执行Sql同步脚本初始化表结构&lt;/li&gt;
&lt;li&gt;使用任务调度（crontab） + SmartCode.ETL 同步分析数据&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过持久化 etl_task 监控 etl执行情况（目前支持PostgreSql）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;简单来说就是SmartCode生成SmartCode，任务调度执行SmartCode命令行。（这真的不是先有鸡还是蛋的问题.....）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;smartcode-插件概览&quot;&gt;SmartCode 插件概览&lt;/h2&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;SmartCode&quot;: {
    &quot;Version&quot;: &quot;v1.16.15&quot;,
    &quot;Plugins&quot;: [
      {
        &quot;Type&quot;: &quot;SmartCode.IDataSource,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.NoneDataSource,SmartCode&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IBuildTask,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.App.BuildTasks.ClearBuildTask,SmartCode.App&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IBuildTask,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.App.BuildTasks.ProjectBuildTask,SmartCode.App&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IBuildTask,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.App.BuildTasks.MultiTemplateBuildTask,SmartCode.App&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IBuildTask,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.App.BuildTasks.ProcessBuildTask,SmartCode.App&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IOutput,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.App.Outputs.FileOutput,SmartCode.App&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IDataSource,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.Generator.DbTableSource,SmartCode.Generator&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IBuildTask,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.Generator.BuildTasks.TableBuildTask,SmartCode.Generator&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IBuildTask,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.Generator.BuildTasks.SingleBuildTask,SmartCode.Generator&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.INamingConverter,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.Generator.TableNamingConverter,SmartCode.Generator&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.TemplateEngine.ITemplateEngine,SmartCode.TemplateEngine&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.TemplateEngine.Impl.HandlebarsTemplateEngine,SmartCode.TemplateEngine&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.TemplateEngine.ITemplateEngine,SmartCode.TemplateEngine&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.TemplateEngine.Impl.OfficialRazorTemplateEngine,SmartCode.TemplateEngine&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.Generator.IDbTypeConverter,SmartCode.Generator&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.Generator.DbTypeConverter.DefaultDbTypeConverter,SmartCode.Generator&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IDataSource,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.ETL.ExtractDataSource,SmartCode.ETL&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IBuildTask,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.ETL.BuildTasks.TransformBuildTask,SmartCode.ETL&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.ETL.ITransformEngine,SmartCode.ETL&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.ETL.TransformEngine.RazorTransformEngine,SmartCode.ETL&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IBuildTask,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.ETL.BuildTasks.LoadBuildTask,SmartCode.ETL&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.ETL.IETLRepository,SmartCode.ETL&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.ETL.NoneETLRepository,SmartCode.ETL&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.ETL.IETLRepository,SmartCode.ETL&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.ETL.PostgreSql.PGETLRepository,SmartCode.ETL.PostgreSql&quot;,
        &quot;Paramters&quot;: {
          &quot;ConnectionString&quot;: &quot;Server=localhost;Port=5432;User Id=postgres;Password=SmartSql; Database=smartcode_etl;&quot;
        }
      }
    ]
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;etl-构建配置&quot;&gt;ETL 构建配置&lt;/h2&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;Author: Ahoo Wang
DataSource:
  Name: Extract
  Paramters:
    DbProvider: SqlServer
    ConnectionString: Data Source=.;Initial Catalog=SmartSqlDB;Integrated Security=True
    Query: SELECT [Id],[UserName],[Status],[LastLoginTime],[CreationTime],[ModifyTime],[Deleted] FROM [T_User] With(NoLock) Where ModifyTime&amp;gt;@LastMaxModifyTime
    PKColumn: Id
    AutoIncrement: true
    ModifyTime: ModifyTime
Paramters:
  ETLCode: SmartCode.ETL.Test
  ETLRepository: PG
Build:
  Transform:
    Type: Transform
    Paramters:
      Script: 
  Load2PostgreSql: 
    Type: Load
    Paramters:
      DbProvider: PostgreSql
      ConnectionString: Server=localhost;Port=5432;User Id=postgres;Password=SmartSql; Database=smartsql_db;
      Table: t_user__temp
      PreCommand: CREATE TABLE t_user__temp( LIKE t_user );
      PostCommand: &quot;Delete From t_user as source Where EXISTS(select * from t_user__temp temp where temp.id=source.id);
      Insert Into t_user  SELECT * From t_user__temp;
      Drop Table t_user__temp;
      &quot;
      ColumnMapping: [{Column: Id,Mapping: id}
      ,{Column: UserName,Mapping: user_name}
      ,{Column: Status,Mapping: status}
      ,{Column: LastLoginTime,Mapping: last_login_time}
      ,{Column: CreationTime,Mapping: creation_time}
      ,{Column: ModifyTime,Mapping: modify_time}
      ,{Column: Deleted,Mapping: deleted}]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;根-paramters&quot;&gt;根 Paramters&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;ETLCode&lt;/td&gt;
&lt;td&gt;ETL任务Code,区分任务类型，唯一&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ETLRepository&lt;/td&gt;
&lt;td&gt;ETL任务持久化仓储，None/PG&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;datasource-参数说明&quot;&gt;DataSource 参数说明&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;属性 Name:Extract,使用 ExtractDataSource 插件作为数据源&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;DbProvider&lt;/td&gt;
&lt;td&gt;数据驱动提供者:MySql,MariaDB,PostgreSql,SqlServer,Oracle,SQLite&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ConnectionString&lt;/td&gt;
&lt;td&gt;连接字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Query&lt;/td&gt;
&lt;td&gt;查询命令，需要抽取的数据。默认会自动注入三个参数 LastMaxId,LastMaxModifyTime,LastQueryTime 作为查询条件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;PKColumn&lt;/td&gt;
&lt;td&gt;主键列名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;AutoIncrement&lt;/td&gt;
&lt;td&gt;是否为自增主键，true 自动计算抽取的最大主键值(MaxId)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ModifyTime&lt;/td&gt;
&lt;td&gt;最近一次修改时间列名，设置后自定计算抽取的最大修改时间列(MaxModifyTime)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;build.load-参数说明&quot;&gt;Build.Load 参数说明&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;属性 Type:Load,使用 LoadBuildTask 插件作为构建任务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;build.load.paramters&quot;&gt;Build.Load.Paramters&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;DbProvider&lt;/td&gt;
&lt;td&gt;数据驱动提供者:MySql,MariaDB,PostgreSql,SqlServer,Oracle,SQLite&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ConnectionString&lt;/td&gt;
&lt;td&gt;连接字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Table&lt;/td&gt;
&lt;td&gt;目标表名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;PreCommand&lt;/td&gt;
&lt;td&gt;执行批量插入任务之前执行的命令&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;PostCommand&lt;/td&gt;
&lt;td&gt;执行批量插入任务之后执行的命令&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ColumnMapping&lt;/td&gt;
&lt;td&gt;列映射&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;同步策略&quot;&gt;同步策略&lt;/h2&gt;
&lt;h3 id=&quot;lastmaxid&quot;&gt;LastMaxId&lt;/h3&gt;
&lt;p&gt;LastMaxId 即上一次抽取的数据最大Id值(第一次抽取时LastMaxId为-1)，该模式使用于数据插入后不再变更的数据表。&lt;/p&gt;
&lt;h3 id=&quot;lastmaxmodifytime&quot;&gt;LastMaxModifyTime&lt;/h3&gt;
&lt;p&gt;LastMaxModifyTime 即上一次抽取的数据最大ModifyTime值(第一次抽取时LastMaxModifyTime为1970-01-01 08:00:00)，适用于插入数据后还会变更的数据表。&lt;/p&gt;
&lt;h3 id=&quot;并发任务同步&quot;&gt;并发任务同步&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;对 Id 取模,分拆不同任务，同时并发执行&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;大数据量同步&quot;&gt;大数据量同步&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;使用 Top/Limit 限制数据抽取数量，分多次同步执行完成整个数据同步。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;etl_task-任务监控&quot;&gt;ETL_Task 任务监控&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/457833/201811/457833-20181106004654672-1271542321.png&quot; alt=&quot;SmartCode.ETL&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;性能监控&quot;&gt;性能监控&lt;/h4&gt;
&lt;h5 id=&quot;运行环境&quot;&gt;运行环境&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;源抽取库：Windows Server 2012 , 8 vCPU 16 GB + SSD + SqlServer-2014&lt;/li&gt;
&lt;li&gt;目标分析库：CentOS-7 , 8 vCPU 16 GB + SSD + PostgreSql-11 + SmartCode&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下是数据抽取性能，抽取数量为 1434678，耗时 41267 毫秒。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;MaxId&quot;: 1755822,
    &quot;PKColumn&quot;: &quot;Id&quot;,
    &quot;QuerySize&quot;: 1434678,
    &quot;QueryTime&quot;: &quot;2018-11-01T11:31:53.6191084+08:00&quot;,
    &quot;QueryCommand&quot;: {
        &quot;Taken&quot;: 41267,
        &quot;Command&quot;: &quot;Select * From T_ProductSearchLog  With(NoLock) Where Id&amp;gt;@LastMaxId&quot;,
        &quot;Paramters&quot;: {
            &quot;LastMaxId&quot;: -1,
            &quot;LastQueryTime&quot;: &quot;1970-01-01T08:00:00&quot;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;etl_task.load&quot;&gt;ETL_Task.Load&lt;/h5&gt;
&lt;p&gt;以下是数据加载性能，批量插入数据量为 1434678，耗时 21817 毫秒，平均每秒插入 65759.6 条数据。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;Size&quot;: 1434678,
    &quot;Table&quot;: &quot;t_product_search_log&quot;,
    &quot;Taken&quot;: 21817,
    &quot;PreCommand&quot;: null,
    &quot;PostCommand&quot;: null
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;目前 SmartCode.ETL 已经落地到我们的生产环境了（11-01上线截至目前执行了 26069 次同步任务，暂无error日志抛出）&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PS： 虽然 SmartCode.ETL 只花了周末俩天时间完成扩展，但已经可以满足我们至少90%的应用场景。这足以见得 SmartCode 扩展能力是多么令人意外了。当然SmartCode的其他能力还得后续等各位一起发掘！！！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 05 Nov 2018 16:49:00 +0000</pubDate>
<dc:creator>Ahoo-Wang</dc:creator>
<og:description>继国庆节 SmartCode 正式版（SmartCode.Generator）发布之后，SmartCode 迎来了新的能力 SmartCode.ETL ! SmartCode 正式版从开始发布就从未说</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Ahoo-Wang/p/SmartCode-ETL.html</dc:identifier>
</item>
<item>
<title>【LeetCode题解】142_环形链表2（Linked-List-Cycle-II） - StrongXGP</title>
<link>http://www.cnblogs.com/xugenpeng/p/9912496.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xugenpeng/p/9912496.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：不允许修改给定的链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶&lt;/strong&gt;：&lt;br/&gt;你是否可以不用额外空间解决此题？&lt;/p&gt;

&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;最直接的解法就是利用一个集合保存每次遍历的节点的引用。之后，从链表头开始遍历，每遍历一个节点，就判断该节点的引用是否在集合中，如果不在集合中，则将该节点的引用放入集合中；如果在集合中，则返回该节点的引用（环的入口）。当然，如果能遍历到链表尾部，此时链表无环，返回 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;java-实现&quot;&gt;Java 实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

import java.util.Set;
import java.util.HashSet;

public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode curr = head;
        Set&amp;lt;ListNode&amp;gt; nodesSeen = new HashSet&amp;lt;&amp;gt;();
        while (curr != null) {
            if (nodesSeen.contains(curr)) {
                return curr;
            }
            nodesSeen.add(curr);
            curr = curr.next;
        }
        return curr;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;python-实现&quot;&gt;Python 实现&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def detectCycle(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        curr = head
        nodes_seen = set()
        while curr:
            if curr in nodes_seen:
                return curr
            nodes_seen.add(curr)
            curr = curr.next
        return curr&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;复杂度分析&quot;&gt;复杂度分析&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;时间复杂度：&lt;/strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间复杂度：&lt;/strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;思路-1&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;和 &lt;a href=&quot;https://blog.csdn.net/x273591655/article/details/83343679&quot;&gt;LeetCode 第 141 题&lt;/a&gt;一样，如果不想占用额外的空间的话，可以采用双指针的方式。&lt;/p&gt;
&lt;p&gt;假设链表的起始节点为 A，环的入口节点为 B，两个指针（快慢指针）相交节点为 C，AB 两点之间的长度为 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，BC 两点之间的长度为 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;，CB 两点之间的长度为 &lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt;。慢指针 &lt;code&gt;slow&lt;/code&gt; 走过的长度为 &lt;span class=&quot;math inline&quot;&gt;\(x+y\)&lt;/span&gt;，快指针 &lt;code&gt;fast&lt;/code&gt; 为了“赶上”慢指针，应该走过的长度为 &lt;span class=&quot;math inline&quot;&gt;\(x + y + z + y\)&lt;/span&gt;，同时，由于快指针的速度是慢指针的两倍，因此相同时间内，快指针走过的路程应该是慢指针（走过的路程）的两倍，即&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181106003039216.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ x + y + z + y = 2 (x + y) \]&lt;/span&gt;&lt;br/&gt;化简得，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ x = z \]&lt;/span&gt;&lt;br/&gt;因此，如果此时有另外一个慢指针 &lt;code&gt;slow2&lt;/code&gt; 从起始节点 A 出发，则两个慢指针会在节点 B （环的入口）相遇。&lt;/p&gt;
&lt;h2 id=&quot;java-实现-1&quot;&gt;Java 实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head, fast = head;
        while (fast != null &amp;amp;&amp;amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            
            if (slow == fast) {
                ListNode slow2 = head;
                while (slow != slow2) {
                    slow = slow.next;
                    slow2 = slow2.next;
                }
                return slow;
            }
        }
        return null;
    }
}
// Runtime: 1 ms
// Your runtime beats 100.00 % of python submissions.&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;python-实现-1&quot;&gt;Python 实现&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def detectCycle(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            
            if slow == fast:
                slow2 = head
                while slow != slow2:
                    slow = slow.next
                    slow2 = slow2.next
                return slow
        return None
# Runtime: 44 ms
# Your runtime beats 99.73 % of python submissions.&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;复杂度分析-1&quot;&gt;复杂度分析&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;时间复杂度：&lt;/strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 表示链表的长度。最坏的情况下（链表有环），需要迭代的次数为 &lt;span class=&quot;math inline&quot;&gt;\(x + y + z = n\)&lt;/span&gt; 次，因此时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间复杂度：&lt;/strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;，只需要存储 3 个引用&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 05 Nov 2018 16:37:00 +0000</pubDate>
<dc:creator>StrongXGP</dc:creator>
<og:description>[toc] 描述 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 。 说明 ：不允许修改给定的链表。 进阶 ： 你是否可以不用额外空间解决此题？ 解法一：哈希表 思路 最直接的解法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xugenpeng/p/9912496.html</dc:identifier>
</item>
<item>
<title>分布式系统监视zabbix讲解七之分布式监控--技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/9910954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/9910954.html</guid>
<description>&lt;h2 id=&quot;分布式监控&quot; class=&quot;sectionedit1&quot;&gt;分布式监控&lt;/h2&gt;
&lt;h3 id=&quot;概述&quot; class=&quot;sectionedit2&quot;&gt;概述&lt;/h3&gt;
&lt;div class=&quot;level4&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;Zabbix通过Zabbix proxy为IT基础设施提供有效和可用的分布式监控&lt;/p&gt;
&lt;p&gt;代理(proxy)可用于代替Zabbix server本地收集数据，然后将数据报告给服务器。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;proxy_特征&quot; class=&quot;sectionedit3&quot;&gt;Proxy 特征&lt;/h3&gt;
&lt;div class=&quot;level5&quot; readability=&quot;6.9447144592953&quot;&gt;
&lt;p&gt;当选择使用/不使用proxy时，必须考虑几个注意事项。&lt;/p&gt;
&lt;div class=&quot;table sectionedit4&quot; readability=&quot;24.800857843137&quot;&gt;
&lt;table class=&quot;inline&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;row0&quot;&gt;&lt;th class=&quot;col0&quot;&gt; &lt;/th&gt;
&lt;th class=&quot;col1&quot;&gt;Proxy&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;row1&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;轻量级（Lightweight）&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row2&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;图形界面（GUI）&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row3&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;独立工作（Works independently）&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row4&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;易于维护（Easy maintenance）&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row5&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;自动生成数据库（Automatic DB creation）&lt;/em&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row6&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;本地管理（Local administration）&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row7&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;准备嵌入式硬件 （Ready for embedded hardware）&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row8&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;单向TCP连接（One way TCP connections）&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row9&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;集中配置（Centralised configuration）&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row10&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;生成通知（Generates notifications）&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;代理&quot; class=&quot;sectionedit1&quot;&gt;代理&lt;/h2&gt;
&lt;h3 id=&quot;概述&quot; class=&quot;sectionedit2&quot;&gt;概述&lt;/h3&gt;
&lt;div class=&quot;level4&quot; readability=&quot;39&quot;&gt;
&lt;p&gt;zabbix proxy 可以代替 zabbix server 收集性能和可用性数据,然后把数据汇报给 zabbix server,并且在一定程度上分担了zabbix server 的压力.&lt;/p&gt;
&lt;p&gt;此外，当所有agents和proxies报告给一个Zabbix server并且所有数据都集中收集时，使用proxy是实现集中式和分布式监控的最简单方法。&lt;/p&gt;
&lt;p&gt;zabbix proxy 使用场景:&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li class=&quot;level1&quot;&gt;
&lt;p&gt;监控远程区域设备&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;监控本地网络不稳定区域&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;当 zabbix 监控上千设备时,使用它来减轻 server 的压力&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;简化分布式监控的维护&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a class=&quot;media&quot; title=&quot;manual:proxies:proxy.png&quot; href=&quot;https://www.zabbix.com/documentation/3.4/_detail/manual/proxies/proxy.png?id=zh%3Amanual%3Adistributed_monitoring%3Aproxies&quot;&gt;&lt;img class=&quot;media&quot; src=&quot;https://www.zabbix.com/documentation/3.4/_media/manual/proxies/proxy.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;zabbix proxy 仅仅需要一条 tcp 连接到 zabbix server,所以防火墙上仅仅需要加上一条规则即可。&lt;/p&gt;
&lt;p&gt;zabbix proxy 数据库必须和 server 分开,否则数据会被破坏。&lt;/p&gt;
&lt;p&gt;proxy 收集到数据之后，首先将数据缓存在本地,然后在一定得时间之后传递给 zabbix server，这样就不会因为服务器的任何临时通信问题而丢失数据。这个时间由proxy配置文件中参数 &lt;em&gt;ProxyLocalBuffer&lt;/em&gt; 和 &lt;em&gt;ProxyOfflineBuffer&lt;/em&gt; 决定。&lt;/p&gt;
&lt;p&gt;注意从Zabbix server数据库直接更新最新配置的proxy可能会比Zabbix server新，而Zabbix server的配置由于cacheupdatefrequency 的原因而无法快速更新。因此，proxy收集发送Zabbix server数据可能会被忽略。&lt;/p&gt;

&lt;p&gt;zabbix proxy 是一个数据收集器,它不计算触发器、不处理事件、不发送报警。有关proxy功能的概述，如下表：&lt;/p&gt;
&lt;div class=&quot;table sectionedit3&quot;&gt;
&lt;table class=&quot;inline&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;row0&quot;&gt;&lt;th class=&quot;col0 leftalign&quot; colspan=&quot;2&quot;&gt;功能&lt;/th&gt;
&lt;th class=&quot;col2 leftalign&quot;&gt;proxy支持(yes/no)&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;row1&quot;&gt;&lt;td class=&quot;col0 leftalign&quot; colspan=&quot;2&quot;&gt;项目（Items）&lt;/td&gt;
&lt;td class=&quot;col2 leftalign&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row2&quot;&gt;&lt;td class=&quot;col0 leftalign&quot; rowspan=&quot;13&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;em&gt;Zabbix agent checks&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col2 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row3&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;Zabbix agent checks (active)&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt; &lt;sup&gt;1&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row4&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;Simple checks&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row5&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;Trapper items&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row6&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;SNMP checks&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row7&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;SNMP traps&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row8&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;IPMI checks&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row9&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;JMX checks&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row10&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;日志文件监控（Log file monitoring）&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row11&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;内部检查（Internal checks）&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row12&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;SSH checks&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row13&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;Telnet checks&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row14&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;外部检查（External checks）&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row15&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0&quot; colspan=&quot;2&quot;&gt;内置web监控（Built-in web monitoring）&lt;/td&gt;
&lt;td class=&quot;col2 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row16&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0 leftalign&quot; colspan=&quot;2&quot;&gt;网络发现(Network discovery)&lt;/td&gt;
&lt;td class=&quot;col2 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row17&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0 leftalign&quot; colspan=&quot;2&quot;&gt;自动发现（Low-level discovery）&lt;/td&gt;
&lt;td class=&quot;col2 leftalign&quot;&gt;&lt;strong&gt;Yes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row18&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0 leftalign&quot; colspan=&quot;2&quot;&gt;触发器计算（Calculating triggers）&lt;/td&gt;
&lt;td class=&quot;col2 leftalign&quot;&gt;&lt;em&gt;No&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row19&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0 leftalign&quot; colspan=&quot;2&quot;&gt;处理事件（Processing events）&lt;/td&gt;
&lt;td class=&quot;col2 leftalign&quot;&gt;&lt;em&gt;No&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row20&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0 leftalign&quot; colspan=&quot;2&quot;&gt;发送报警（Sending alerts）&lt;/td&gt;
&lt;td class=&quot;col2 leftalign&quot;&gt;&lt;em&gt;No&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row21&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0 leftalign&quot; colspan=&quot;2&quot;&gt;远程命令（Remote commands）&lt;/td&gt;
&lt;td class=&quot;col2 leftalign&quot;&gt;&lt;em&gt;No&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;


&lt;p&gt;[1]使用 agent active 模式,一定要记住在 agent 的配置文件参数 &lt;strong&gt;ServerActive&lt;/strong&gt; 加上 proxy 的 IP 地址。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;配置&quot; class=&quot;sectionedit4&quot;&gt;配置&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;一旦安装并配置了一个proxy，我们便可以在zabbix管理站点配置它了。&lt;/p&gt;
&lt;/div&gt;
&lt;h5 id=&quot;添加_proxies&quot; class=&quot;sectionedit5&quot;&gt;添加 proxies&lt;/h5&gt;
&lt;div class=&quot;level5&quot; readability=&quot;15.808047249908&quot;&gt;
&lt;p&gt;要在Zabbix前端配置代理：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;media wikilink2&quot; title=&quot;zh:manual:distributed_monitoring:proxy.png&quot; href=&quot;https://www.zabbix.com/documentation/3.4/_detail/zh/manual/distributed_monitoring/proxy.png?id=zh%3Amanual%3Adistributed_monitoring%3Aproxies&quot;&gt;&lt;img class=&quot;media&quot; src=&quot;https://www.zabbix.com/documentation/3.4/_media/zh/manual/distributed_monitoring/proxy.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;table sectionedit6&quot;&gt;
&lt;table class=&quot;inline&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;row0&quot;&gt;&lt;th class=&quot;col0&quot;&gt;参数&lt;/th&gt;
&lt;th class=&quot;col1&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;row1&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;agent代理程序名称&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1&quot;&gt;proxy名称。它必须与proxy配置文件中的Hostname参数中的名称相同。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row2&quot; readability=&quot;7&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;代理模式（Proxy mode）&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1&quot;&gt;选择proxy模式&lt;br/&gt;&lt;strong&gt;Active&lt;/strong&gt; - the proxy will connect to the Zabbix server and request configuration data&lt;br/&gt;&lt;strong&gt;Passive&lt;/strong&gt; - Zabbix server connects to the proxy&lt;br/&gt;&lt;em&gt;Note&lt;/em&gt; that without encrypted communications (sensitive) proxy configuration data may become available to parties having access to the Zabbix server trapper port when using an active proxy. This is possible because anyone may pretend to be an active proxy and request configuration data if authentication does not take place.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row3&quot; readability=&quot;5&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;系统代理程序模式&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1&quot;&gt;选择proxy模式&lt;br/&gt;&lt;strong&gt;主动式&lt;/strong&gt; - proxy将连接到Zabbix server并请求配置数据&lt;br/&gt;&lt;strong&gt;被动式&lt;/strong&gt; - Zabbix server连接到代理proxy&lt;br/&gt;&lt;em&gt;注意&lt;/em&gt;，当使用active proxy，未加密通信（敏感）proxy配置数据可用于访问Zabbix server trapper端口。如果不进行身份验证，任何人都可以伪装成active proxy并请求配置数据。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row4&quot; readability=&quot;3&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;Hosts&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1&quot;&gt;Add hosts to be monitored by the proxy.&lt;br/&gt;Hosts already monitored by another proxy are greyed out in the &lt;em&gt;Other hosts&lt;/em&gt; selection.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row5&quot; readability=&quot;3&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;主机&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1&quot;&gt;添加要由proxy监视的主机。&lt;br/&gt;被另一个proxy监视的主机在&lt;em&gt;其他主机&lt;/em&gt;选项中显示为灰色。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row6&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;Description&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1 leftalign&quot;&gt;Enter the proxy description.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row7&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;描述&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1&quot;&gt;输入proxy描述。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;该 &lt;strong&gt;加密&lt;/strong&gt;选项卡允许你与proxy的加密连接。&lt;/p&gt;
&lt;div class=&quot;table sectionedit7&quot;&gt;
&lt;table class=&quot;inline&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;row0&quot;&gt;&lt;th class=&quot;col0 leftalign&quot;&gt;参数&lt;/th&gt;
&lt;th class=&quot;col1&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr class=&quot;row1&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;连接代理&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1&quot;&gt;服务器如何连接到被动代理：非加密（默认），共享秘钥（PSK）或证书。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row2&quot; readability=&quot;3&quot;&gt;&lt;td class=&quot;col0&quot;&gt;&lt;em&gt;从代理连接&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1&quot;&gt;从active proxy中选择允许的连接类型。可以同时选择几种连接类型（用于测试和切换到其他连接类型）。默认为“无加密”。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row3&quot; readability=&quot;4&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;发行者&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1&quot;&gt;允许颁发证书。证书首先通过CA（认证机构）验证。如果CA有效，则由CA签名，这时可以使用&lt;em&gt;发行者&lt;/em&gt;字段来进一步限制允许的CA。该字段是可选的，如果你的Zabbix安装使用多个CA的证书，则使用该字段。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row4&quot; readability=&quot;4&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;主体&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1&quot;&gt;允许的证书。证书首先通过CA验证。如果它有效，由CA签名，这时&lt;em&gt;主体&lt;/em&gt;字段可以用于仅允许一个&lt;em&gt;主体&lt;/em&gt;字符串值。如果此字段为空，则接受CA签名的任何有效证书。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row5&quot; readability=&quot;2&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;共享密钥一致性&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1&quot;&gt;共享密钥身份字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row6&quot; readability=&quot;4&quot;&gt;&lt;td class=&quot;col0 leftalign&quot;&gt;&lt;em&gt;共享密钥（PSK）&lt;/em&gt;&lt;/td&gt;
&lt;td class=&quot;col1&quot;&gt;共享密钥(16进制)。如果Zabbix使用mbed TLS（PolarSSL）库，最大长度为64位十六进制（32字节PSK）；如果Zabbix使用GnuTLS或OpenSSL库，最大长度为512位十六进制数（256字节PSK）。示例：1f87b595725ac58dd977beef14b97461a7c1045b9a1c963065002c5473194952&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;


&lt;h2 class=&quot;table sectionedit7&quot;&gt;实现分布式监控&lt;/h2&gt;
&lt;div class=&quot;table sectionedit7&quot; readability=&quot;34.179292929293&quot;&gt; 
&lt;h3&gt;三类节点软件安装&lt;/h3&gt;
&lt;h4&gt;1. &lt;span&gt;监控节点&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;zabbix-sever&lt;/p&gt;
&lt;p&gt;zabbix-sever-mysql&lt;/p&gt;
&lt;p&gt;zabbix-web&lt;/p&gt;
&lt;p&gt;zabbix-web-mysql&lt;/p&gt;
&lt;p&gt;db&lt;/p&gt;

&lt;h4&gt;2. &lt;span&gt;被监控节点&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;zabbix-agent&lt;/p&gt;

&lt;h4&gt;3. &lt;span&gt;代理节点&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;zabbix-proxy&lt;/p&gt;
&lt;p&gt;zabbix-proxy-mysql&lt;/p&gt;
&lt;p&gt;db&lt;/p&gt;

&lt;h3&gt;1.准备工作（略）&lt;/h3&gt;
&lt;p&gt;1. 关闭selinux&lt;/p&gt;
&lt;p&gt;2. 关闭iptables&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;时间同步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;互相可解析主机名&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2.监控节点安装配置（10.220.5.137）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;略。大家可以在我的第一篇博客中详细看下，监控节点如何安装《&lt;a id=&quot;post_title_link_9892708&quot; href=&quot;https://www.cnblogs.com/kenken2018/p/9892708.html&quot;&gt;分布式系统监视zabbix讲解一之zabbix安装--技术流ken&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3.配置代理节点（10.220.5.138）&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;1.安装&lt;/span&gt;&lt;/h4&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install zabbix-proxy-mysql mariadb-server -y
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.创建表和数据库用户&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&amp;gt;&lt;span&gt; create database zabbix;
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; grant all on *.* to zabbix@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; identified by &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected, &lt;span&gt;1&lt;/span&gt; warning (&lt;span&gt;0.05&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3.准备表和数据&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# cp /usr/share/doc/zabbix-proxy-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/schema.sql.gz ./&lt;span&gt;
[root@ken &lt;/span&gt;~]# gunzip schema.sql.gz 
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.把表和数据导入到数据库&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; source /root/schema.sql
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;5.配置proxy的配置文件&lt;/h4&gt;
&lt;p&gt;配置文件内容很长，这里列出来几行须要修改的部分，你也可以根据你自己的情况来修改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /etc/zabbix/zabbix_proxy.conf &lt;br/&gt;ProxyMode=1           #更改为被动模式，不用修改主机名了&lt;br/&gt;Server=&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.137   #指定监控节点&lt;/span&gt;&lt;span&gt;
        ListenPort&lt;/span&gt;=&lt;span&gt;10051      #开启监控端口&lt;/span&gt;&lt;span&gt;
        DBHost&lt;/span&gt;=&lt;span&gt;localhost      #数据库地址
        DBName&lt;/span&gt;=&lt;span&gt;zabbix         #数据库名字
        DBUser&lt;/span&gt;=&lt;span&gt;zabbix         #数据库用户
        DBPassword&lt;/span&gt;=&lt;span&gt;123        #用户zabbix的密码&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;6.启动zabbix-proxy&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart zabbix-proxy
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;四.配置zabbix-agent客户端（10.220.5.139）&lt;/h3&gt;
&lt;h4&gt;1.下载zabbix-agent客户端&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install zabbix-agent -y
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.配置zabbix-agent客户端&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /etc/zabbix/&lt;span&gt;zabbix_agentd.conf
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;&lt;span&gt; ### Option: Server
 &lt;/span&gt;&lt;span&gt;87&lt;/span&gt;&lt;span&gt; #       List of comma delimited IP addresses (or hostnames) of Zabbix servers and Zabbix proxies.
 &lt;/span&gt;&lt;span&gt;88&lt;/span&gt; #       Incoming connections will be accepted only &lt;span&gt;from&lt;/span&gt;&lt;span&gt; the hosts listed here.
 &lt;/span&gt;&lt;span&gt;89&lt;/span&gt; #       If IPv6 support &lt;span&gt;is&lt;/span&gt; enabled then &lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;::127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;::ffff:127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; are treated equally.
 &lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt; #
 &lt;/span&gt;&lt;span&gt;91&lt;/span&gt; # Mandatory: yes, &lt;span&gt;if&lt;/span&gt; StartAgents &lt;span&gt;is&lt;/span&gt; not explicitly &lt;span&gt;set&lt;/span&gt; to &lt;span&gt;0&lt;/span&gt;
 &lt;span&gt;92&lt;/span&gt;&lt;span&gt; # Default:
 &lt;/span&gt;&lt;span&gt;93&lt;/span&gt; # Server=
 &lt;span&gt;94&lt;/span&gt; 
 &lt;span&gt;95&lt;/span&gt; Server=&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.138             #ip地址指向代理服务器端&lt;/span&gt;
 &lt;span&gt;96&lt;/span&gt; 
 &lt;span&gt;97&lt;/span&gt;&lt;span&gt; ### Option: ListenPort
 &lt;/span&gt;&lt;span&gt;98&lt;/span&gt; #       Agent will listen on &lt;span&gt;this&lt;/span&gt; port &lt;span&gt;for&lt;/span&gt; connections &lt;span&gt;from&lt;/span&gt;&lt;span&gt; the server.
 &lt;/span&gt;&lt;span&gt;99&lt;/span&gt;&lt;span&gt; #
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt; # Mandatory: no
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; # Range: &lt;span&gt;1024&lt;/span&gt;-&lt;span&gt;32767&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;&lt;span&gt; # Default:
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; # ListenPort=&lt;span&gt;10050&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3.重启zabbix-proxy客户端&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart zabbix-agent
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;五.在zabbix网页端添加代理服务器&lt;/h3&gt;
&lt;p&gt;第一步：创建主机&lt;/p&gt;
&lt;p&gt;首先需要把主机，即添加10.220.5.139被监控节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181105200344689-434166797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二步：创建proxy.点击administration&amp;gt;proxies&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181105200546290-687687599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第三步：查看。monitoring&amp;gt;latest data &amp;gt;select（你的主机）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181106003526328-392513535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 05 Nov 2018 16:36:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>分布式监控 概述 Zabbix通过Zabbix proxy为IT基础设施提供有效和可用的分布式监控 代理(proxy)可用于代替Zabbix server本地收集数据，然后将数据报告给服务器。 Zab</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/9910954.html</dc:identifier>
</item>
<item>
<title>java多线程重要知识点整理一 - 陈芳志</title>
<link>http://www.cnblogs.com/chenfangzhi/p/9912484.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenfangzhi/p/9912484.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;本系列文是对自己学习多线程和平时使用过程中的知识梳理，不适合基础比较差的阅读，适合看过java编程实战做整体回顾的，想到了会不断补充。&lt;/p&gt;
&lt;h2 id=&quot;线程池的使用&quot;&gt;1. 线程池的使用&lt;/h2&gt;
&lt;p&gt;线程池其实在实际工作中有用到的话理解其实是非常简单的，合理的利用线程池能极大的提高效率。主要说明下程池的使用和参数的意义（暂时不考虑定时线程池）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. corePoolSize 线程池的最小大小
2. maximumPoolSize 线程池的最大大小
3. keepAliveTime 大于线程池最小大小的空余线程的包活时间
4. workQueue 工作队列用于存放任务
5. threadFactory 创建线程的线程工厂
6. handler  用于处理任务被拒绝的情况&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;线程池的任务投递过程&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;向线程池投递一个任务时，首先看工作者线程有没有小于corePoolSize，如果是，利用threadFactory创建一个线程将任务投递&lt;/li&gt;
&lt;li&gt;第一步如果大于corePoolSize，则将任务投递到workQueue，这里需要考虑workQueue是无界还是有界的情况，如果是无界肯定投递成功返回。如果是有界，投递成功则返回，否则看线程数有没有小于maximumPoolSize，如果是则再开一个线程返回，不是的话则调用handler的拒绝逻辑。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;需要注意的点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果放的workQueue是无界队列，那么maximumPoolSize这个参数其实就无效了，永远不会创建超过corePoolSize的线程数量，所以任务永远不会因为容量问题被拒绝，如果生产者速度一直大于消费者，很可能造成内存溢出&lt;/li&gt;
&lt;li&gt;第1条说workQueue是无界队列那么任务永远不会因为容量问题被拒绝，但是handler还是有用的，当你关闭了线程池池，继续提交任务会用到这个来拒绝&lt;/li&gt;
&lt;li&gt;用户代码在提交任务时底层使用的阻塞队列的offer方法，所有一般是不会阻塞的，要么成功，要么被阻绝。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;关于线程池参数的设置&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;corePoolSize，maximumPoolSize，workQueue核心参数：&lt;br/&gt;根据你的业务场景，如果是cpu密集型，可以设置线程池固定为ncpu+1，队列采用一个有界的，防止内存溢出。如果还是出现任务被拒绝是不是应该考虑加机器了。&lt;br/&gt;如果是io密集型，需要根据io和cpu的比例来做相应的估算，这种也不是十分精确的，毕竟网络情况也会发生变化。这里推荐书中的公式： ncpu&lt;em&gt;ucpu&lt;/em&gt;(1+w/c) ncpu:cpu个数 ucpu:每个cpu利用率 w/c: io/cpu&lt;br/&gt;另外不同类型的任务最好采用不同的线程池有利于线程池的设置，混杂的任务很难设置。&lt;/p&gt;
&lt;p&gt;threadFactory:我主要用于设置线程的名字，这样在日志区分度更高&lt;/p&gt;
&lt;p&gt;handler：拒绝执行器，这个得根据业务场景类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于Executors的工具方法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;alibaba编码规约中建议是手动创建线程池，这样根据自己的业务做更好的定制，而且自己也能更加的清理里面的逻辑。如果一时图快，可能在系统的负载不断升高时出现问题，反而更加不好排查。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于线程池的优雅停机&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;在提高性能的同时不要忘记数据的安全性，因为线程池的特点，任务会被缓存在队列中，如果是不重要的应用可以直接将线程设置成守护线程，这样在应用停机的时候直接停机。&lt;br/&gt;对于重要的应用，如果应用重启这些数据都是要考虑到的。这里就需要十分清楚中断机制，因为这里涉及任务取消的逻辑，这些逻辑是要对自己的任务代码自己进行相应的处理。线程池shutdown方法执行之后后续的任务都会被拒绝，已经有的任务会继续执行完，这个比较好理解。shutdownNow方法返回队列中的所有任务，然后发中断给正在执行的任务，这里返回的任务你可以进行持久化，主要就是正在执行的任务的处理，对于短任务你可以不响应中断，耗时任务必须得考虑进程退出时间过长被强杀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际应用场景举例&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;应用日志的记录：我们对于一些业务日志可能写到mysql中，如果每个操作插入一条日志必然会很耗时，这是我们可以单独开一个日志线程，将日志投递到日志线程对象的queue中，然后他定时扫，批量如库，既提高吞吐量，有降低延迟&lt;/li&gt;
&lt;li&gt;第三方接口对接：在对接第三方时候，很多时候是http，这种操作相当耗时，可以利用线程池来进行异步化，如果需要得到返回接口可以利用Feature和CompletableFuture（后续讲解）&lt;/li&gt;
&lt;li&gt;耗时的线程不安全操作：这种场景比较少，但公司确实遇到了，具体就是后台提交一个任务，这种任务可能会执行几十分钟，任务不能同时执行。这里思路就是采用单线程池，然后利用提交时返回的Future来实现任务的取消功能。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;关于异常&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;只有execute提交的任务才会将异常交给未捕获异常处理器，默认的未捕获异常处理器会打印异常。但是如果是submit会将异常封装到饭返回的Future中在get的时候才会抛出，可以通过改写线程池的afterExecute方法。&lt;br/&gt;源码中的例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void afterExecute(Runnable r, Throwable t) {
     super.afterExecute(r, t);
     if (t == null &amp;amp;&amp;amp; r instanceof Future&amp;lt;?&amp;gt;) {
       try {
         Object result = ((Future&amp;lt;?&amp;gt;) r).get();
       } catch (CancellationException ce) {
           t = ce;
       } catch (ExecutionException ee) {
           t = ee.getCause();
       } catch (InterruptedException ie) {
           Thread.currentThread().interrupt(); // ignore/reset
       }
     }
     if (t != null)
       System.out.println(t);
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;java中断机制&quot;&gt;2. java中断机制&lt;/h2&gt;
&lt;p&gt;中断机制对于javq多线程编程是一个十分基础的东西，很多时候都是在使用类库所以没有注意到，对于自己更好的使用类库和自己封装类库，中断是十分重要的。对于中断处理的好坏直接影响了编写的api合理性和使用类库时正确性。&lt;/p&gt;
&lt;p&gt;在多线程中，很多时候会遇到需要停止一个线程中的任务这样的需求。实现这样的需求很容易想到在对象中放置一个标志位，然后线程在执行的过程中去不停的检测这个标志位，如果标志位被设置成false就退出。另外标志位需要采用volatile来修饰，可以保证内存的可见性。例子如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Main {
    public static void main(String[] args) throws InterruptedException {
        //创建一个任务
        Task task = new Task();
        new Thread(task).start();
        Thread.sleep(3_000);
        task.stop = true;
    }
}

@Slf4j
class Task implements Runnable {
    /**
     * 是否停止的标志位
     */
    public volatile boolean stop = false;
    /**
     * 执行次数计数器
     */
    AtomicInteger adder = new AtomicInteger();

    @Override
    public void run() {
        while (!stop) {
            log.info(&quot;运行次数：{}&quot;, adder.incrementAndGet());
            try {
                Thread.sleep(1_000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        log.warn(&quot;退出运行！&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码是很多人一开始就能想到的方案，但是，仔细想想就会发现问题，上面的代码中的sleep函数是一个类库封装好的，所以如果设置了停止标志位，那么每次检测运行都得等到while循环才行。这就是引入中断的意义，jdk中很多函数都能响应中断的操作。&lt;/p&gt;
&lt;p&gt;先说一下java中断的含义：java中断是一种线程间协作机制，用来告诉一个线程可以停止了，但是具体那个线程是否响应以及采取什么样的动作，java语言没有做任何强制规定。这里就需要和操作系统的中的中断明确区别，这两种虽然中文名一样，但是实际的意义却差以千里。ava的中断是协作的，相当于只是告诉一个线程，但是那个线程可以选择不响应或者需要中断。&lt;/p&gt;
&lt;p&gt;第二个版本的代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MainInterrupt {
    public static void main(String[] args) throws InterruptedException {
        //创建一个任务
        Thread thread = new Thread(new TaskInterrupt());
        thread.start();
        Thread.sleep(3_000);
        thread.interrupt();
    }
}

@Slf4j
class TaskInterrupt implements Runnable {
    /**
     * 执行次数计数器
     */
    AtomicInteger adder = new AtomicInteger();

    @Override
    public void run() {
        while (!Thread.interrupted()) {
            log.info(&quot;运行次数：{}&quot;, adder.incrementAndGet());
            try {
                Thread.sleep(1_000);
            } catch (InterruptedException e) {
                log.warn(&quot;随眠过程打断退出！&quot;);
                break;
            }
        }
        log.warn(&quot;退出运行！&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;中断的api：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;public void interrupt() 给一个线程发起中断&lt;/li&gt;
&lt;li&gt;public static boolean interrupted() 检测线程是否处于中断位，并清除标志位，&lt;strong&gt;这也是唯一清除标志位的 方法&lt;/strong&gt;！&lt;/li&gt;
&lt;li&gt;public boolean isInterrupted() 检测线程是否中断&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;中断的处理&quot;&gt;中断的处理&lt;/h3&gt;
&lt;p&gt;封装的自己类库代码的时候一定要考虑清楚对于中断的处理，例如BlockingQueue的&lt;code&gt;E poll(long timeout, TimeUnit unit)throws InterruptedException&lt;/code&gt;这个api，他的实现都是选择了将异常抛出，底层实现一般是Lock的&lt;code&gt;lockInterruptibly()&lt;/code&gt;方法阻塞抛出。你站在用户代码的角度去想，如果你实现了这个方法是阻塞的，然后又把异常吃了，怎么去实现被取消后的逻辑，用户代码又怎么去针对取消做相应的动作。所以封装类库的时候最好还是重新抛出。&lt;/p&gt;
&lt;p&gt;另外还有一种就是重置中断位，有些操作不能直接抛出，像Runnable接口，还有抛出异常前执行一些动作的情况。在处理完之后重置下中断位，这样就能让用户代码感知并做相应的处理。&lt;/p&gt;
&lt;h2 id=&quot;线程间通信机制总结&quot;&gt;3. 线程间通信机制总结&lt;/h2&gt;
&lt;p&gt;这里只是简单的罗列，当时面试的时候被问到线程间通信，当时没反应过来，其实都是知道的，这一块知道这么个东西比较简单，很多需要看源码的实现，看区别。以后会进行相关的源码分析&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;synchronize关键字&lt;/li&gt;
&lt;li&gt;对象的wait，notify，notifyall&lt;/li&gt;
&lt;li&gt;Thread的join&lt;/li&gt;
&lt;li&gt;Semaphore，ReentrantLock，CyclicBarrier，CountDownLatch，(这些都是基于AQS的工具类)BlockingQueue&lt;/li&gt;
&lt;li&gt;FutureTask相关的&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 05 Nov 2018 16:29:00 +0000</pubDate>
<dc:creator>陈芳志</dc:creator>
<og:description>java多线程重要知识点整理一 [TOC] 本系列文是对自己学习多线程和平时使用过程中的知识梳理，不适合基础比较差的阅读，适合看过java编程实战做整体回顾的，想到了会不断补充。 1. 线程池的使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenfangzhi/p/9912484.html</dc:identifier>
</item>
<item>
<title>Linux双网卡bond、起子接口 - wholj</title>
<link>http://www.cnblogs.com/wholj/p/9912423.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wholj/p/9912423.html</guid>
<description>&lt;h2 id=&quot;适用场景&quot;&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;服务器两张网卡需要做bond，并且bond后网卡需配置不同网段的地址，用于走不同流量，这个时候就可以采用起子接口的方式。&lt;/p&gt;
&lt;h2 id=&quot;实验场景&quot;&gt;&lt;strong&gt;实验场景&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;设备
&lt;ul&gt;&lt;li&gt;服务器：Server_A&lt;/li&gt;
&lt;li&gt;核心交换机：Switch_A、Switch_B&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;交换机连接方式：堆叠&lt;/li&gt;
&lt;li&gt;服务器网卡：enp176s0f0、enp176s0f1做bond&lt;/li&gt;
&lt;li&gt;IP段划分
&lt;ul&gt;&lt;li&gt;业务段
&lt;ul&gt;&lt;li&gt;VLAN 201：10.10.51.0/24&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;公网
&lt;ul&gt;&lt;li&gt;VLAN 401：111.20.200.88/27&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;要求&lt;br/&gt;服务器Server_A上联的两台核心交换机Switch_A和Switch_B采用堆叠方式，Server_A的enp176s0f0和enp176s0f1光口分别互联Switch_A和Switch_B；现要求enp176s0f0和enp176s0f1做bond，地址10.10.51.16走业务流量，地址111.20.200.90走公网流量，交换机端口做捆绑eth-trunk并透传VLAN201和VLAN401。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;网卡配置脚本&quot;&gt;&lt;strong&gt;网卡配置脚本&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# 停掉NetworkManager服务
systemctl stop NetworkManager.service   
systemctl disable NetworkManager.service

# 备份
cp /etc/sysconfig/network-scripts/ifcfg-enp176s0f0{,.bak}
cp /etc/sysconfig/network-scripts/ifcfg-enp176s0f1{,.bak}

# 将网卡协议改为none并设备未开机自启动，并做双网卡配置
sed -i 's/BOOTPROTO=dhcp/BOOTPROTO=none/' /etc/sysconfig/network-scripts/ifcfg-enp176s0f0
sed -i 's/ONBOOT=no/ONBOOT=yes/' /etc/sysconfig/network-scripts/ifcfg-enp176s0f0
echo &quot;MASTER=bond0&quot; &amp;gt;&amp;gt;/etc/sysconfig/network-scripts/ifcfg-enp176s0f0
echo &quot;SLAVE=yes&quot; &amp;gt;&amp;gt;/etc/sysconfig/network-scripts/ifcfg-enp176s0f0

sed -i 's/BOOTPROTO=dhcp/BOOTPROTO=none/' /etc/sysconfig/network-scripts/ifcfg-enp176s0f1
sed -i 's/ONBOOT=no/ONBOOT=yes/' /etc/sysconfig/network-scripts/ifcfg-enp176s0f1
echo &quot;MASTER=bond0&quot; &amp;gt;&amp;gt;/etc/sysconfig/network-scripts/ifcfg-enp176s0f1
echo &quot;SLAVE=yes&quot; &amp;gt;&amp;gt;/etc/sysconfig/network-scripts/ifcfg-enp176s0f1

# 配置网卡bond0
echo &quot;DEVICE=bond0
TYPE=Ethernet
ONBOOT=yes
BOOTPROTO=static&quot; &amp;gt;/etc/sysconfig/network-scripts/ifcfg-bond0

# 写模块文件，bond模式为mode 0
echo &quot;alias bond0 bonding
options bond0 miimon=100 mode=0&quot; &amp;gt;/etc/modprobe.d/bond.conf
# 加载模块
modprobe bonding

# 起子接口bond0.201
echo &quot;DEVICE=bond0.201
TYPE=Vlan
PHYSDEV=bond0
ONBOOT=yes
BOOTPROTO=static
REORDER_HDR=yes
IPADDR=10.10.51.16
GATEWAY=10.10.51.1
NETMASK=255.255.255.0
DNS1=114.114.114.114
DNS2=8.8.8.8
VLAN=yes
VLAN_ID=201&quot; &amp;gt;/etc/sysconfig/network-scripts/ifcfg-bond0.201

# 起子接口bond0.401
echo &quot;DEVICE=bond0.401
TYPE=Vlan
PHYSDEV=bond0
ONBOOT=yes
BOOTPROTO=static
REORDER_HDR=yes
IPADDR=111.20.200.90
GATEWAY=111.20.200.89
NETMASK=255.255.255.0
DNS1=114.114.114.114
DNS2=8.8.8.8
VLAN=yes
VLAN_ID=401&quot; &amp;gt;/etc/sysconfig/network-scripts/ifcfg-bond0.401

# 加载模块并重启主机
modprobe 8021q
reboot&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关键点&quot;&gt;&lt;strong&gt;关键点&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;交换机侧如果起eth-trunk，那么服务器侧则必须起子接口&lt;/li&gt;
&lt;li&gt;交换机侧和服务器侧要么都起lacp协商，要么都不起，否则将造成端口不同
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;交换机侧eth-trunk口配置示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[HH2B108-H01-2-HW9006X-SW001-Eth-Trunk12]display this 
#
interface Eth-Trunk12
port link-type trunk
port trunk allow-pass vlan 201 401
#
return&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;服务器侧起lacp协议使用bond模式4，示例如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; # more /etc/modprobe.d/bond.conf
 alias bond0 bonding
 options bond0 miimon=100 mode=4 lacp_rate=1&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;子接口配置文件中&quot;DEVICE=bond0.401“中的VLAN号一定要和需要透传的VLAN号保持一致&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置子接口后一定要重启服务器才能生效！！！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 05 Nov 2018 15:57:00 +0000</pubDate>
<dc:creator>wholj</dc:creator>
<og:description>适用场景 服务器两张网卡需要做bond，并且bond后网卡需配置不同网段的地址，用于走不同流量，这个时候就可以采用起子接口的方式。 实验场景 设备 服务器：Server_A 核心交换机：Switch_</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wholj/p/9912423.html</dc:identifier>
</item>
<item>
<title>UVA-10539  打表+二分 - 欣崽</title>
<link>http://www.cnblogs.com/033000-/p/9912388.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/033000-/p/9912388.html</guid>
<description>&lt;p&gt;题意非常简单，就是给你一个区间（闭区间），然后让你统计区间内有多少数满足本身不是素数，但只有一个素因子&lt;/p&gt;

&lt;p&gt;首先注意题目中区间左右端点最大可以取到1e12,这早就超越了int的表示范围&lt;/p&gt;
&lt;p&gt;我们首先打表计算出1e6内的素数表，然后计算所有满足要求的数，存进数组，最后排序&lt;/p&gt;
&lt;p&gt;然后对于给定的区间[L,R],我们用二分找到上界和下届&lt;/p&gt;
&lt;p&gt;二分一直是我心中的痛，总是用不好，以后碰一道二分记录一道&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:cpp;collapse:true;;gutter:true;&quot;&gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;iomanip&amp;gt;
#include&amp;lt;assert.h&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;list&amp;gt;
#include&amp;lt;map&amp;gt;
#include&amp;lt;set&amp;gt;
#include&amp;lt;sstream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;queue&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;bitset&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#pragma warning(disable:4996)
#define me(s)  memset(s,0,sizeof(s))
#define _for(i,a,b) for(int i=(a);i&amp;lt;(b);++i)
#define _rep(i,a,b) for(int i=(a);i&amp;lt;=(b);++i)
using namespace std;
typedef pair &amp;lt;int, int&amp;gt; pii;
typedef long long ll;
typedef unsigned long long llu;
const int inf = 0x3f3f3f3f;
const int MOD = 1e9 + 7;
const double pi = acos(-1.0);
const double eps = 1e-15;
const int maxn = 1000000;
ll p[maxn + 5], vis[maxn + 5], pcnt;
vector&amp;lt;ll&amp;gt; ans;
void init()
{
        me(vis);
        pcnt = 0;
        for (int i = 2; i&amp;lt;maxn; i++) {
                if (!vis[i]) {
                        p[pcnt++] = i;
                        for (int j = 2; i*j &amp;lt; maxn; j++) vis[i*j] = true;
                }
        }
        for (int i = 0; i&amp;lt;pcnt; i++) {
                ll tmp = p[i] * p[i];//刚开始没用p数组没用ll坑死
                while (tmp &amp;lt; 1000000000000LL) {
                        ans.push_back(tmp);
                        tmp *= p[i];
                }
        }
        sort(ans.begin(), ans.end());
}
ll L, R;
int main()
{
        init();
        int T; scanf(&quot;%d&quot;, &amp;amp;T);
        while (T--) {
                scanf(&quot;%lld%lld&quot;, &amp;amp;L, &amp;amp;R);
                cout &amp;lt;&amp;lt; lower_bound(ans.begin(), ans.end(), R+1) - lower_bound(ans.begin(), ans.end(), L) &amp;lt;&amp;lt; endl;
        }
}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 05 Nov 2018 15:46:00 +0000</pubDate>
<dc:creator>欣崽</dc:creator>
<og:description>题意非常简单，就是给你一个区间（闭区间），然后让你统计区间内有多少数满足本身不是素数，但只有一个素因子 首先注意题目中区间左右端点最大可以取到1e12,这早就超越了int的表示范围 我们首先打表计算出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/033000-/p/9912388.html</dc:identifier>
</item>
<item>
<title>以中间件，路由，跨进程事件的姿势使用WebSocket - 若邪</title>
<link>http://www.cnblogs.com/jaycewu/p/9912166.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jaycewu/p/9912166.html</guid>
<description>&lt;p&gt;通过参考koa中间件，socket.io远程事件调用，以一种新的姿势来使用WebSocket。&lt;/p&gt;
&lt;h2 id=&quot;浏览器端&quot;&gt;浏览器端&lt;/h2&gt;
&lt;p&gt;浏览器端使用WebSocket很简单&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// Create WebSocket connection.
const socket = new WebSocket('ws://localhost:8080');

// Connection opened
socket.addEventListener('open', function (event) {
    socket.send('Hello Server!');
});

// Listen for messages
socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket&quot;&gt;MDN&lt;/a&gt;关于WebSocket的介绍&lt;/p&gt;
&lt;p&gt;能注册的事件有onclose，onerror，onmessage，onopen。用的比较多的是onmessage，从服务器接受到数据后，会触发message事件。通过注册相应的事件处理函数，可以根据后端推送的数据做相应的操作。&lt;/p&gt;
&lt;p&gt;如果只是写个demo,单单输出后端推送的信息,如下使用即可：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际使用过程中，我们需要判断后端推送的数据然后执行相应的操作。比如聊天室应用中，需要判断消息是广播的还是私聊的或者群聊的，以及是纯文字信息还是图片等多媒体信息。这时message处理函数里可能就是一堆的if else。那么有没有什么别的优雅的姿势呢？答案就是中间件与事件，跨进程的事件的发布与订阅。在说远程事件发布订阅之前，需要先从中间件开始，因为后面实现的远程事件发布订阅是基于中间件的。&lt;/p&gt;
&lt;h2 id=&quot;中间件&quot;&gt;中间件&lt;/h2&gt;
&lt;p&gt;前面说了，在WebSocket实例上可以注册事件有onclose，onerror，onmessage，onopen。每一个事件的处理函数里可能需要做各种判断，特别是message事件。参考koa，可以将事件处理函数以中间件方式来进行使用，将不同的操作逻辑分发到不同的中间件中，比如聊天室应用中，聊天信息与系统信息(比如用户登录属于系统信息)是可以放到不同的中间件中处理的。&lt;/p&gt;
&lt;p&gt;koa提供use接口来注册中间件。我们针对不同的事件提供相应的中间件注册接口，并且对原生的WebSocket做封装。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default class EasySocket{
    constructor(config) {
       this.url = config.url;
       this.openMiddleware = [];
       this.closeMiddleware = [];
       this.messageMiddleware = [];
       this.errorMiddleware = [];
       
       this.openFn = Promise.resolve();
       this.closeFn = Promise.resolve();
       this.messageFn = Promise.resolve();
       this.errorFn = Promise.resolve();
    }
    openUse(fn) {
        this.openMiddleware.push(fn);
        return this;
    }
    closeUse(fn) {
        this.closeMiddleware.push(fn);
        return this;
    }
    messageUse(fn) {
        this.messageMiddleware.push(fn);
        return this;
    }
    errorUse(fn) {
        this.errorMiddleware.push(fn);
        return this;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;xxxUse&lt;/code&gt;注册相应的中间件。 &lt;code&gt;xxxMiddleware&lt;/code&gt;中就是相应的中间件。&lt;code&gt;xxxFn&lt;/code&gt; 中间件通过compose处理后的结构&lt;/p&gt;
&lt;p&gt;再添加一个connect方法，处理相应的中间件并且实例化原生WebSocket&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;connect(url) {
        this.url = url || this.url;
        if (!this.url) {
            throw new Error('url is required!');
        }
        try {
            this.socket = new WebSocket(this.url, 'echo-protocol');
        } catch (e) {
            throw e;
        }

        this.openFn = compose(this.openMiddleware);
        this.socket.addEventListener('open', (event) =&amp;gt; {
            let context = { client: this, event };
            this.openFn(context).catch(error =&amp;gt; { console.log(error) });
        });

        this.closeFn = compose(this.closeMiddleware);
        this.socket.addEventListener('close', (event) =&amp;gt; {
            let context = { client: this, event };
            this.closeFn(context).then(() =&amp;gt; {
            }).catch(error =&amp;gt; {
                console.log(error)
            });
        });

        this.messageFn = compose(this.messageMiddleware);
        this.socket.addEventListener('message', (event) =&amp;gt; {
            let res;
            try {
                res = JSON.parse(event.data);
            } catch (error) {
                res = event.data;
            }
            let context = { client: this, event, res };
            this.messageFn(context).then(() =&amp;gt; {

            }).catch(error =&amp;gt; {
                console.log(error)
            });
        });

        this.errorFn = compose(this.errorMiddleware);
        this.socket.addEventListener('error', (event) =&amp;gt; {
            let context = { client: this, event };
            this.errorFn(context).then(() =&amp;gt; {

            }).catch(error =&amp;gt; {
                console.log(error)
            });
        });
        return this;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;a href=&quot;https://github.com/koajs/compose&quot;&gt;koa-compose&lt;/a&gt;模块处理中间件。注意context传入了哪些东西，后续定义中间件的时候都已使用。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0588235294118&quot;&gt;
&lt;p&gt;compose的作用可看这篇文章 &lt;a href=&quot;https://juejin.im/post/5bd7238d51882579201028b0&quot;&gt;傻瓜式解读koa中间件处理模块koa-compose&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后就可以使用了：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;new EasySocket()
  .openUse((context, next) =&amp;gt; {
    console.log(&quot;open&quot;);
    next();
  })
  .closeUse((context, next) =&amp;gt; {
    console.log(&quot;close&quot;);
    next();
  })
  .errorUse((context, next) =&amp;gt; {
    console.log(&quot;error&quot;, context.event);
    next();
  })
  .messageUse((context, next) =&amp;gt; {
    //用户登录处理中间件
    if (context.res.action === 'userEnter') {
      console.log(context.res.user.name+' 进入聊天室');
    }
    next();
  })
  .messageUse((context, next) =&amp;gt; {
    //创建房间处理中间件
    if (context.res.action === 'createRoom') {
      console.log('创建房间 '+context.res.room.anme);
    }
    next();
  })
  .connect('ws://localhost:8080')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，用户登录与创建房间的逻辑放到两个中间件中分开处理。不足之处就是每个中间件都要判断context.res.action，而这个context.res就是后端返回的数据。怎么消除这个频繁的if判断呢? 我们实现一个简单的消息处理路由。&lt;/p&gt;
&lt;h2 id=&quot;路由&quot;&gt;路由&lt;/h2&gt;
&lt;p&gt;定义消息路由中间件&lt;/p&gt;
&lt;p&gt;messageRouteMiddleware.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default (routes) =&amp;gt; {
    return async (context, next) =&amp;gt; {
        if (routes[context.req.action]) {
            await routes[context.req.action](context,next);
        } else {
            console.log(context.req)
            next();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义路由&lt;/p&gt;
&lt;p&gt;router.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default {
    userEnter:function(context,next){
        console.log(context.res.user.name+' 进入聊天室');
        next();
    },
    createRoom:function(context,next){
        console.log('创建房间 '+context.res.room.anme);
        next();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;new EasySocket()
  .openUse((context, next) =&amp;gt; {
    console.log(&quot;open&quot;);
    next();
  })
  .closeUse((context, next) =&amp;gt; {
    console.log(&quot;close&quot;);
    next();
  })
  .errorUse((context, next) =&amp;gt; {
    console.log(&quot;error&quot;, context.event);
    next();
  })
  .messageUse(messageRouteMiddleware(router))//使用消息路由中间件，并传入定义好的路由
  .connect('ws://localhost:8080')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一切都变得美好了，感觉就像在使用koa。想一个问题，当接收到后端推送的消息时，我们需要做相应的DOM操作。比如路由里面定义的userEnter，我们可能需要在对应的函数里操作用户列表的DOM，追加新用户。这使用原生JS或JQ都是没有问题的，但是如果使用vue,react这些，因为是组件化的，用户列表可能就是一个组件，怎么访问到这个组件实例呢？(当然也可以访问vuex,redux的store,但是并不是所有组件的数据都是用store管理的)。&lt;/p&gt;
&lt;p&gt;我们需要一个运行时注册中间件的功能，然后在组件的相应的生命周期钩子里注册中间件并且传入组件实例&lt;/p&gt;
&lt;p&gt;运行时注册中间件，修改如下代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;messageUse(fn, runtime) {
        this.messageMiddleware.push(fn);
        if (runtime) {
            this.messageFn = compose(this.messageMiddleware);
        }
        return this;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 messageRouteMiddleware.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default (routes,component) =&amp;gt; {
    return async (context, next) =&amp;gt; {
        if (routes[context.req.action]) {
            context.component=component;//将组件实例挂到context下
            await routes[context.req.action](context,next);
        } else {
            console.log(context.req)
            next();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似vue mounted中使用&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;mounted(){
  let client = this.$wsClients.get(&quot;im&quot;);//获取指定EasySocket实例
  client.messageUse(messageRouteMiddleware(router,this),true)//运行时注册中间件，并传入定义好的路由以及当前组件中的this
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;路由中通过 context.component 即可访问到当前组件。&lt;/p&gt;
&lt;p&gt;完美了吗？每次组件mounted 都注册一次中间件，问题很大。所以需要一个判断中间件是否已经注册的功能。也就是一个支持具名注册中间件的功能。这里就暂时不实现了，走另外一条路，也就是之前说到的远程事件的发布与订阅，我们也可以称之为跨进程事件。&lt;/p&gt;
&lt;h2 id=&quot;跨进程事件&quot;&gt;跨进程事件&lt;/h2&gt;
&lt;p&gt;看一段socket.io的代码：&lt;/p&gt;
&lt;p&gt;Server (app.js)&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var app = require('http').createServer(handler)
var io = require('socket.io')(app);
var fs = require('fs');
app.listen(80);
function handler (req, res) {
  fs.readFile(__dirname + '/index.html',
  function (err, data) {
    if (err) {
      res.writeHead(500);
      return res.end('Error loading index.html');
    }

    res.writeHead(200);
    res.end(data);
  });
}
io.on('connection', function (socket) {
  socket.emit('news', { hello: 'world' });
  socket.on('my other event', function (data) {
    console.log(data);
  });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Client (index.html)&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&amp;lt;script src=&quot;/socket.io/socket.io.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  var socket = io('http://localhost');
  socket.on('news', function (data) {
    console.log(data);
    socket.emit('my other event', { my: 'data' });
  });
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意力转到这两部分：&lt;/p&gt;
&lt;p&gt;服务端&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  socket.emit('news', { hello: 'world' });
  socket.on('my other event', function (data) {
    console.log(data);
  });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  var socket = io('http://localhost');
  socket.on('news', function (data) {
    console.log(data);
    socket.emit('my other event', { my: 'data' });
  });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用事件，客户端通过on订阅'news'事件，并且当触发‘new’事件的时候通过emit发布'my other event'事件。服务端在用户连接的时候发布'news'事件，并且订阅'my other event'事件。&lt;/p&gt;
&lt;p&gt;一般我们使用事件的时候，都是在同一个页面中on和emit。而socket.io的神奇之处就是同一事件的on和emit是分别在客户端和服务端，这就是跨进程的事件。&lt;/p&gt;
&lt;p&gt;那么，在某一端emit某个事件的时候，另一端如果on监听了此事件，是如何知道这个事件emit(发布)了呢？&lt;/p&gt;
&lt;p&gt;没有看socket.io源码之前，我设想应该是emit方法里做了某些事情。就像java或c#，实现rpc的时候，可以依据接口定义动态生成实现(也称为代理)，动态实现的(代理)方法中，就会将当前方法名称以及参数通过相应协议进行序列化，然后通过http或者tcp等网络协议传输到RPC服务端，服务端进行反序列化，通过反射等技术调用本地实现，并返回执行结果给客户端。客户端拿到结果后，整个调用完成，就像调用本地方法一样实现了远程方法的调用。&lt;/p&gt;
&lt;p&gt;看了socket.io emit的代码实现后，思路也是大同小异，通过将当前emit的事件名和参数按一定规则组合成数据，然后将数据通过WebSocket的send方法发送出去。接收端按规则取到事件名和参数，然后本地触发emit。(注意远程emit和本地emit，socket.io中直接调用的是远程emit)。&lt;/p&gt;
&lt;p&gt;下面是实现代码，事件直接用的&lt;a href=&quot;https://github.com/component/emitter&quot;&gt;emitter&lt;/a&gt;模块，并且为了能自定义emit事件名和参数组合规则，以中间件的方式提供处理方法：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default class EasySocket extends Emitter{//继承Emitter
    constructor(config) {
       this.url = config.url;
       this.openMiddleware = [];
       this.closeMiddleware = [];
       this.messageMiddleware = [];
       this.errorMiddleware = [];
       this.remoteEmitMiddleware = [];//新增的部分
       
       this.openFn = Promise.resolve();
       this.closeFn = Promise.resolve();
       this.messageFn = Promise.resolve();
       this.errorFn = Promise.resolve();
       this.remoteEmitFn = Promise.resolve();//新增的部分
    }
    openUse(fn) {
        this.openMiddleware.push(fn);
        return this;
    }
    closeUse(fn) {
        this.closeMiddleware.push(fn);
        return this;
    }
    messageUse(fn) {
        this.messageMiddleware.push(fn);
        return this;
    }
    errorUse(fn) {
        this.errorMiddleware.push(fn);
        return this;
    }
    //新增的部分
    remoteEmitUse(fn, runtime) {
        this.remoteEmitMiddleware.push(fn);
        if (runtime) {
            this.remoteEmitFn = compose(this.remoteEmitMiddleware);
        }
        return this;
    }
    connect(url) {
       ...
       //新增部分
       this.remoteEmitFn = compose(this.remoteEmitMiddleware);
    }
    //重写emit方法，支持本地调用以远程调用
    emit(event, args, isLocal = false) {
        let arr = [event, args];
        if (isLocal) {
            super.emit.apply(this, arr);
            return this;
        }
        let evt = {
            event: event,
            args: args
        }
        let remoteEmitContext = { client: this, event: evt };
        this.remoteEmitFn(remoteEmitContext).catch(error =&amp;gt; { console.log(error) })
        return this;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一个简单的处理中间件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;client.remoteEmitUse((context, next) =&amp;gt; {
    let client = context.client;
    let event = context.event;
    if (client.socket.readyState !== 1) {
      alert(&quot;连接已断开!&quot;);
    } else {
      client.socket.send(JSON.stringify({
        type: 'event',
        event: event.event,
        args: event.args
      }));
      next();
    }
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;意味着调用&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;client.emit('chatMessage',{
    from:'admin',
    masg:&quot;Hello WebSocket&quot;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就会组合成数据&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
    type: 'event',
    event: 'chatMessage',
    args: {
        from:'admin',
        masg:&quot;Hello WebSocket&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发送出去。&lt;/p&gt;
&lt;p&gt;服务端接受到这样的数据，可以做相应的数据处理（后面会使用nodejs实现类似的编程模式），也可以直接发送给别的客户端。客户受到类似的数据，可以写专门的中间件进行处理，比如：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;client.messageUse((context, next) =&amp;gt; {
    if (context.res.type === 'event') {
      context.client.emit(context.res.event, context.res.args, true);//注意这里的emit是本地emit。
    }
    next();
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果本地订阅的chatMessage事件，回到函数就会被触发。&lt;/p&gt;
&lt;p&gt;在vue或react中使用，也会比之前使用路由的方式简单&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;mounted() {
   let client = this.$wsClients.get(&quot;im&quot;);
   client.on(&quot;chatMessage&quot;, data =&amp;gt; {
      let isSelf = data.from.id == this.user.id;
      let msg = {
        name: data.from.name,
        msg: data.msg,
        createdDate: data.createdDate,
        isSelf
      };
      this.broadcastMessageList.push(msg);
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组件销毁的时候移除相应的事件订阅即可，或者清空所有事件订阅&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;destroyed() {
    let client = this.$wsClients.get(&quot;im&quot;);
    client.removeAllListeners();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;心跳重连&quot;&gt;心跳重连&lt;/h2&gt;
&lt;p&gt;核心代码直接从&lt;a href=&quot;https://github.com/zimv/websocket-heartbeat-js&quot;&gt;websocket-heartbeat-js&lt;/a&gt; copy过来的(用npm包，还得在它的基础上再包一层)，相关文章 &lt;a href=&quot;https://www.cnblogs.com/1wen/p/5808276.html&quot;&gt;初探和实现websocket心跳重连&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    heartCheck() {
        this.heartReset();
        this.heartStart();
    }
    heartStart() {
        this.pingTimeoutId = setTimeout(() =&amp;gt; {
            //这里发送一个心跳，后端收到后，返回一个心跳消息
            this.socket.send(this.pingMsg);
            //接收到心跳信息说明连接正常,会执行heartCheck(),重置心跳(清除下面定时器)
            this.pongTimeoutId = setTimeout(() =&amp;gt; {
                //此定时器有运行的机会，说明发送ping后，设置的超时时间内未收到返回信息
                this.socket.close();//不直接调用reconnect，避免旧WebSocket实例没有真正关闭，导致不可预料的问题
            }, this.pongTimeout);
        }, this.pingTimeout);
    }
    heartReset() {
        clearTimeout(this.pingTimeoutId);
        clearTimeout(this.pongTimeoutId);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/wjkang/easy-socket-browser&quot;&gt;easy-socket-browser&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;nodejs实现的类似的编程模式(有空再细说)：&lt;a href=&quot;https://github.com/wjkang/easy-socket-node&quot;&gt;easy-socket-node&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实现的聊天室例子：&lt;a href=&quot;http://jaycewu.coding.me/easy-socket-chat/#/&quot;&gt;online chat demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;聊天室前端源码：&lt;a href=&quot;https://github.com/wjkang/lazy-mock-im&quot;&gt;lazy-mock-im&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;聊天室服务端源码：&lt;a href=&quot;https://github.com/wjkang/lazy-mock/tree/chat&quot;&gt;lazy-mock&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Nov 2018 14:51:00 +0000</pubDate>
<dc:creator>若邪</dc:creator>
<og:description>通过参考koa中间件，socket.io远程事件调用，以一种新的姿势来使用WebSocket。 浏览器端 浏览器端使用WebSocket很简单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jaycewu/p/9912166.html</dc:identifier>
</item>
<item>
<title>Java进阶篇设计模式之十 ---- 访问者模式和中介者模式 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/9911997.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/9911997.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/9873514.html&quot;&gt;上一篇&lt;/a&gt;中我们学习了结构型模式的解释器模式(Interpreter Pattern)和迭代器模式（Iterator Pattern）。本篇则来学习下行为型模式的两个模式，访问者模式(Visitor Pattern)和中介者模式（Mediator Pattern）。&lt;/p&gt;
&lt;h2 id=&quot;访问者模式&quot;&gt;访问者模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;访问者模式（VisitorPattern），顾名思义使用了这个模式后就可以在不修改已有程序结构的前提下，通过添加额外的&lt;strong&gt;访问者&lt;/strong&gt;来完成对已有代码功能的提升，它属于行为模式。访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。&lt;br/&gt;其主要目的是将数据结构与数据操作分离。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;访问者模式可以说是设计模式中最难以理解的一个模式，因为相比其它模式而言，它过于”绕“了。但是我们可以通过生活中的一些例子来理解它，比如家里来了客人，客人就是访问者，他可以做一些事情，但是又不能做全部的事情； 又或者说去网吧上网的小明，小明也是访问者，他可以在网吧玩游戏、看视频、听音乐等等，但是不能破坏网吧中的设备等等。按照这么理解，我们大概就可以知道&lt;strong&gt;访问者模式&lt;/strong&gt;主要是做什么了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问者模式&lt;/strong&gt;主要由这五个角色组成，抽象访问者(Visitor)、具体访问者(ConcreteVisitor)、抽象节点(Node)、具体节点(ConcreteNode)和结构对象(ObjectStructure)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象访问者(Visitor)角色：声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口。&lt;/li&gt;
&lt;li&gt;具体访问者(ConcreteVisitor)角色：实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作。&lt;/li&gt;
&lt;li&gt;抽象节点(Node)角色：声明一个接受操作，接受一个访问者对象作为一个参数。&lt;/li&gt;
&lt;li&gt;具体节点(ConcreteNode)角色：实现了抽象节点所规定的接受操作。&lt;/li&gt;
&lt;li&gt;结构对象(ObjectStructure)角色：有如下的责任，可以遍历结构中的所有元素。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例图如下:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181105203837733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里为了方便理解，我们使用一个简单的示例来加以说明。&lt;br/&gt;图书馆有一台电脑，有两个账户，其中一个是管理员的账户，拥有所有权限，但是设置了密码；另一个账户是不需要密码，但是只能玩游戏和看图片。张三和李四先后使用了这台电脑，那么他们就可以当作是访问者。&lt;br/&gt;那么我们便可以根据这里例子来使用访问者模式进行开发，首先定义一个抽象的访问者，拥有玩游戏和看图片的方法；然后再定义一个抽象节点电脑，接受这个请求。&lt;br/&gt;那么这个抽象类的代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
interface Visitor {
   void visit(Games games);
   void visit(Photos photos);
}

interface Computer {
   void accept(Visitor visitor);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义好该抽象类之后，我们需要设计不同的访问者对节点进行不同的处理。并且需要设计具体节点类实现刚刚抽象节点的方法。&lt;/p&gt;
&lt;p&gt;那么代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class ZhangSan implements Visitor {
   @Override
   public void visit(Games games) {
       games.play();
   }

   @Override
   public void visit(Photos photos) {
       photos.watch();
   }
}

class LiSi implements Visitor {
   @Override
   public void visit(Games games) {
       games.play();
   }
   @Override
   public void visit(Photos photos) {
       photos.watch();
   }
}

class Games implements Computer {
   @Override
   public void accept(Visitor visitor) {
       visitor.visit(this);
   }

   public void play() {
       System.out.println(&quot;play lol&quot;);
   }
}

class Photos implements Computer {
   @Override
   public void accept(Visitor visitor) {
       visitor.visit(this);
   }
   
   public void watch() {
       System.out.println(&quot;watch scenery photo&quot;);
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们还需要定义一个结构对象角色，提供一个的接口并允许该访问者进行访问，它可以对这些角色进行增加、修改或删除等操作和遍历。&lt;br/&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class ObjectStructure {

    private List&amp;lt;Computer&amp;gt; computers = new ArrayList&amp;lt;Computer&amp;gt;();

    public void action(Visitor visitor) {
        computers.forEach(c -&amp;gt; {
            c.accept(visitor);
        });
    }
    public void add(Computer computer) {
        computers.add(computer);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写好之后，那么我们来进行测试。&lt;br/&gt;测试代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public static void main(String[] args) {
       // 创建一个结构对象
       ObjectStructure os = new ObjectStructure();
       // 给结构增加一个节点
       os.add(new Games());
       // 给结构增加一个节点
       os.add(new Photos());
       // 创建一个访问者
       Visitor visitor = new ZhangSan();
       os.action(visitor);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出结果:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;play lol
watch scenery photo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;访问者模式优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;扩展性好，可以在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能；&lt;br/&gt;符合单一职责原则，通过访问者将无关的行为分离，使职责单一；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;访问者模式缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;违反了迪米特原则，因为具体元素对访问者公布细节；&lt;br/&gt;违反了依赖倒置原则，依赖了具体类，没有依赖抽象；&lt;br/&gt;对象结构变化困难，若对象结构发生了改变，访问者的接口和访问者的实现也都要发生相应的改变；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作；&lt;br/&gt;需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作&quot;污染&quot;这些对象的类，也不希望在增加新操作时修改这些类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;中介者模式&quot;&gt;中介者模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;中介者模式（Mediator Pattern），定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为，属于行为型模式。&lt;br/&gt;其主要的目的是用来降低多个对象和类之间的通信复杂性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的来说就是提供一个平台。比如生活中我们经常用到的聊天软件QQ、微信群，或者是上网购物的网站淘宝、京东，又或者是房产中介。但是无论是QQ群，还是房产中介，他们都是充当一个中间平台的作用，我们可以直接通过这个平台得到我们想要的信息，避免了独自获取花费的成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中介者模式&lt;/strong&gt;主要由这四个角色组成， 抽象中介者(Mediator)、具体中介者(ConcreteMediator)、 抽象同事类(Colleague)和具体同事类(ConcreteColleague) 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象中介者(Mediator): 定义了同事对象到中介者对象之间的接口。&lt;/li&gt;
&lt;li&gt;具体中介者(ConcreteMediator): 实现抽象中介者的方法，它需要知道所有的具体同事类，同时需要从具体的同事类那里接收信息，并且向具体的同事类发送信息。&lt;/li&gt;
&lt;li&gt;抽象同事类(Colleague): 定义了中介者对象的接口，它只知道中介者而不知道其他的同事对象。&lt;/li&gt;
&lt;li&gt;具体同事类(ConcreteColleague) : 每个具体同事类都只需要知道自己的行为即可，但是他们都需要认识中介者。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例图如下:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181105211356878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里为了方便理解，我们使用一个简单的示例来加以说明。&lt;br/&gt;xuwujing创建了一个Java的QQ群，并邀请了很多人进来，其中张三也加进来了，进群之后，大家开始互相打招呼进行交流。。。&lt;br/&gt;那么我们便可以根据这个简单的例子来使用中介者模式进行开发。&lt;br/&gt;首先依旧定义一个抽象的中介者，就是QQ群，可以进行交流；然后再定义一个抽象的同事类，可以谈话。&lt;br/&gt;那么这个抽象类的代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
interface QQqun {
   void exchange(Person person,String message);
}

abstract class Person{
   protected String name;
   protected QQqun qun;  
   Person(String name,QQqun qun){
       this.name = name;
       this.qun = qun;
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义好该抽象类之后，我们再来定义具体的同事类，也就是xuwujing和张三，可以进行交流。&lt;/p&gt;
&lt;p&gt;那么代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class ZhangSan extends Person{

   ZhangSan(String name, QQqun qun) {
       super(name, qun);
   }
   
    void exchange(String message){
       qun.exchange(this,message);
   }
   
    void talk(String message){
       System.out.println(name +&quot;说：&quot; + message);
   }
}

class XuWuJing extends Person{

   XuWuJing(String name, QQqun qun) {
       super(name, qun);
   }
   
    void exchange(String message){
       qun.exchange(this,message);
   }
   
    void talk(String message){
       System.out.println(name +&quot;回应：&quot; + message);
   }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后再来定义具体中介者对象，这个QQ群的具体实现。&lt;br/&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class JavaQQqun implements QQqun{
    private ZhangSan zs;
    private XuWuJing xwj;

    public ZhangSan getZs() {
        return zs;
    }

    public void setZs(ZhangSan zs) {
        this.zs = zs;
    }

    public XuWuJing getXwj() {
        return xwj;
    }


    public void setXwj(XuWuJing xwj) {
        this.xwj = xwj;
    }


    @Override
    public void exchange(Person person, String message) {
            if(zs.equals(person)){
                zs.talk(message);
            }else if(xwj.equals(person)){
                xwj.talk(message);
            }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后再来进行测试，定义好交流平台以及需要交流的人员。&lt;br/&gt;那么测试代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public static void main(String[] args) {
    JavaQQqun jq = new JavaQQqun();  
       ZhangSan zs = new ZhangSan(&quot;张三&quot;, jq);
       XuWuJing xwj = new XuWuJing(&quot;xuwujing&quot;, jq);
       jq.setZs(zs);
       jq.setXwj(xwj);      
       zs.talk(&quot;大家好！我是张三!&quot;);;
       xwj.talk(&quot;欢迎你！张三！&quot;);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出结果:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;张三说：大家好！我是张三
xuwujing回应：欢迎你！张三！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;中介者模式优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;灵活性高，因为将同事类进行了解耦，使其不必有关联性；&lt;br/&gt;降低了类的复杂度，将一对多转化成了一对一；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;中介者模式缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;中介者使用过多，会使系统变得复杂难以维护；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;若不明确各个类的职责，那么就不要进行使用！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;和外观模式、代理模式比较&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;中介者模式和外观模式、代理模式比较类似，但是又有不同。&lt;br/&gt;和外观模式比较，中介者模式中，同事类必须依赖与中介者，中介者也知道同事类；但是外观模式中，子系统是不需要知道外观类的存在，并且子系统是可以脱离外观模式的。&lt;br/&gt;和代理模式，代理模式的核心就是代理作用，主要还是对原先的类进行扩展或增加控制，比如进行权限控制；而中介者模式主要目的是为了减少对象之前的耦合，也就是同事类直接相互独立，互不影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文章: https://www.cnblogs.com/chenssy/p/3348520.html&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;
&lt;p&gt;分享一首很有节奏感的电音！&lt;/p&gt;

&lt;h3 id=&quot;项目的代码&quot;&gt;项目的代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xuwujing/java-study&quot;&gt;java-study&lt;/a&gt;是本人在学习Java过程中记录的一些代码，也包括之前博文中使用的代码。如果感觉不错，希望顺手给个start，当然如果有不足，也希望提出。&lt;br/&gt;github地址: https://github.com/xuwujing/java-study&lt;/p&gt;
&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：http://www.cnblogs.com/xuwujing&lt;br/&gt;CSDN出处：http://blog.csdn.net/qazwsxpcm　&lt;br/&gt;个人博客出处：http://www.panchengming.com&lt;/p&gt;
</description>
<pubDate>Mon, 05 Nov 2018 14:27:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/9911997.html</dc:identifier>
</item>
<item>
<title>Shell编程-01-Shell脚本初步入门 - Surpassme</title>
<link>http://www.cnblogs.com/surpassme/p/9911671.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surpassme/p/9911671.html</guid>
<description>&lt;h3 id=&quot;什么是shell&quot;&gt;什么是Shell&lt;/h3&gt;
&lt;p&gt;    简单来说Shell其实就是一个&lt;strong&gt;命令解释器&lt;/strong&gt;，而它的作用就是解释并执行用户输入的命令及程序。用户每输入一条命令，Shell就解释执行一次。这种方式很容易让大家想起在Windows环境中使用的command命令，我们在cmd窗口输入一条命令，按下Enter键，则执行相应的命令和结果。&lt;br/&gt;    &lt;strong&gt;Shell位于操作系统的最外层，对外提供与用户交互式的对话并返回相应的执行结果，对内则是将用户输入的命令解释给操作系统。&lt;/strong&gt;Shell在操作系统中所处的位置如下图所示：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-ba75bb194385aa46.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-1 Shell在操作系统的位置.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Shell在英文中的意思就是外壳、贝壳等，从图中也可以看出，Shell就像壳一样包住了系统的核心（Kernel）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Shell命令与Command命令对比&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-23a0a410ba2167f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-2 Shell命令与Command命令_c2i.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是shell脚本&quot;&gt;什么是Shell脚本&lt;/h3&gt;
&lt;p&gt;    在理解了Shell之后，我们再来看看Shell脚本。当命令或程序语句不是在命令行中执行时，而是通过程序文件来执行时，该程序就称之为Shell脚本，我依然拿Windows来做比例。当我们需要执行比较少的命令时，我们可以一个一个命令的进行手动输入，如果需要执行成百上千的命令时，你会怎么办？聪明的你肯定会脱口而出，用&lt;strong&gt;批处理&lt;/strong&gt;（扩展名一般为bat或cmd）。其实Shell脚本就类似于批处理，通过在脚本中定义变量、执行命令、调用函数和逻辑判断、循环等形成一个有机的整体，便形成一个功能强大、自动化程度较高的脚本。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Windows通过批处理获取系统信息保存为txt文件，而后自动打开该文件，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@echo off
set date=%date:~0,4%-%date:~5,2%-%date:~8,2%
echo &quot;当前时间为：&quot;%date%
cd /d &quot;D:\&quot;
mkdir SystemInfo
cd /d &quot;SystemInfo&quot;
systeminfo&amp;gt;systeminfo%date%.txt
start systeminfo%date%.txt
pause&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Shell脚本判断当前登录用户是否为root&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# !/bin/bash
currentName=`whoami`
echo $currentName
if [ &quot;$currentName&quot; = &quot;root&quot; ]
  then
    echo &quot;Current Login User is root&quot;
else
  echo &quot;Current Login User is :&quot;$currentName
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;shell脚本语言的种类&quot;&gt;Shell脚本语言的种类&lt;/h3&gt;
&lt;p&gt;    Shell 脚本语言是&lt;strong&gt;弱类型语言，即无须定义变量类型即可使用&lt;/strong&gt;。在UNIX/Linux中主要有两大类Shell:&lt;strong&gt;Bourne Shell&lt;/strong&gt;和&lt;strong&gt;C Shell&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;bourne-shell&quot;&gt;Bourne Shell&lt;/h4&gt;
&lt;p&gt;    Bourne Shell包括&lt;strong&gt;Bourne Shell（sh）、Korn Shell(ksh)、Bourne Again Shell(bash)&lt;/strong&gt;三种类型。&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Bourne Shell&lt;br/&gt;  由AT&amp;amp;T的Steve Bourne开发，是标准的UNIX Shell，很多UNIX系统都配有sh。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Korn Shell(ksh)&lt;br/&gt;  由David Korn开发，是Bournd Shell(sh)的超集合并且添加了csh引入的新功能，是目前很多UNIX系统标配的Shell，这些系统上的/bin/sh往往指向/bin/ksh的符号链接&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Bourne Again Shell(bash)&lt;br/&gt;  由GNU项目组开发，主要目标是与POSIX标准操持一致，同时兼容sh。bash从csh和ksh借鉴了很多功能，是各种Linux发行版本默认配置的Shell。Linux系统上的/bin/sh往往是指向/bin/bash的符号链接。但bash和sh还是有很多不同之处，虽然bash扩展了一些命令和参数，但bash并不完全兼容sh，两者之间有些行为并不一致。在大多数情况下区别不太大，有时还可以使用bash替代sh。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;c-shell&quot;&gt;C Shell&lt;/h4&gt;
&lt;p&gt;    C Shell包括&lt;strong&gt;csh和tcsh&lt;/strong&gt;两种。csh由Berkeley大学开发，随之BSD UNIX发布，它的流程控制语句很像C语言，支持很多Bourne Shell所不支持的功能，如作业控制、别名、系统算术、命令历史、命令行编辑等。tcsh是csh的增强版，加入了命令补全等功能，在FreeBSD、Mac OS X等系统上代替了csh。&lt;br/&gt;    以上介绍的这些Shell中，较为通用的是标准的Bourne Shell（sh）和C Shell(csh)，而其中Bourne Shell(sh)已经被Bourne Again Shell（bash）所取代。可通过以下命令查看CentOS 7.3系统Shell的支持情况。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[admin@CentOS7 tmp]$ cat /etc/shells
/bin/sh             #Linux常用的Shell,指向/bin/bash
/bin/bash           #Linux常用的Shell,也是默认使用的Shell
/sbin/nologin       #Linux常用的Shell，用于禁止用户登录
/usr/bin/sh
/usr/bin/bash
/usr/sbin/nologin
/bin/tcsh
/bin/csh&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Linux系统中主流的Shell是bash，而bash是由Bourne Shell（sh）发展而来，同时bash还包含了csh和ksh的特色。因此大多数脚本都可以不做修改即可在sh运行，如果使用sh后结果与预期有差异，可以尝试用bash代替sh.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;常用操作系统默认shell&quot;&gt;常用操作系统默认Shell&lt;/h3&gt;
&lt;p&gt;    在常用的操作系统中，Linux中默认的Shell是Bourne Again Shell(bash)，Solaris和FreeBSD下默认的是Bourne Shell（sh），AIX下默认的是Korn Shell（ksh）。那么问题来了，我们该如何查看所使用系统的Shell？以CentOS为例查看系统默认的Shell：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方法一：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[admin@CentOS7 tmp]$ echo $SHELL
/bin/bash&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;方法二：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[admin@CentOS7 tmp]$ grep root /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;root用户结尾的/bin/bash就是用户登录后的Shell解释器。&lt;strong&gt;后续文章中重点讲解的是Bourne Again Shell(bash)&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;shell-脚本的建立和执行&quot;&gt;Shell 脚本的建立和执行&lt;/h3&gt;
&lt;h4 id=&quot;shell脚本的建立&quot;&gt;Shell脚本的建立&lt;/h4&gt;
&lt;p&gt;    在Linux系统中，Shell脚本通常是在编辑器&lt;strong&gt;vi/vim&lt;/strong&gt;中进行编写。可由UNIX/Linux命令、bash shell命令、程序结构控制语句、注释等组成，推荐使用vim。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Shell脚本开头（第一行）&lt;br/&gt;  一个规范标准的Shell脚本会在第一行指出由哪个解释器来执行脚本中的内容，一般如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#!/bin/bash
或
#!/bin/sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、第一行一般要求小于255个字符。&lt;br/&gt;2、&lt;strong&gt;#!/bin/bash不是注释&lt;/strong&gt;，在执行脚本时，内核会根据#!后的解释器确定使用哪个解释器来执行脚本的内容。&lt;br/&gt;3、&lt;strong&gt;这一行必须位于每个脚本顶端的第一行，如果不是第一行则是代表注释&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
echo &quot;bash test&quot;
#!/bin/bash #代表该行是注释
#!/bin/sh   #代表该行是注释&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;bash和sh的区别&lt;br/&gt;  早期的bash与sh稍有不同，bash包含csh和ksh的特色，但大多数的脚本都可以直接在sh上运行。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-4c302934ba502abb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-3 bash和sh区别.jpg&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从上图可以看到sh为bash的软链接，大多数情况下，脚本开头使用#!/bin/bash和#!/bin/sh是没有区别的。但还是建议采用&lt;strong&gt;#!/bin/bash&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  一般情况下，安装完Linux系统之后会自动安装好bash软件，查看bash版本如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[admin@CentOS7 etc]$ cat /etc/redhat-release
CentOS Linux release 7.3.1611 (Core) #当前系统版本
[admin@CentOS7 etc]$ bash --version
GNU bash, version 4.2.46(1)-release (x86_64-redhat-linux-gnu) # bash 版本，后续省略自由软件提示信息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想体验更高版本的bash，升级方法如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum -y update bash #在线升级
rpm -qa bash  #查看bash安装包
bash-4.2.46-20.el7_2.x86_64&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  以下是常用脚本开头的写法，不同语言的脚本在开头一般都要加上如下标识内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/sh
#!/bin/bash
#!/usr/bin/awk
#!/bin/sed
#!/usr/bin/tcsh
#!/usr/bin/perl&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;    CentOS中默认的Shell均为bash。因此即在脚本中未加#!/bin/bash，它也会使用bash去解释。如果不希望使用系统默认的Shell解释器，就需要自行指定解释器。&lt;strong&gt;建议大家一开始就养成好习惯，遵循Shell编程规范，在开头第一行指定所使用的解释器&lt;/strong&gt;&lt;br/&gt;    如果在开头未指定解释器，要使用对应的解释器来执行脚本时，可以使用如下方法：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;Shell脚本： bash test.sh或sh test.sh
Python脚本：python test.py&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;脚本注释&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    在很多编程语言中，都会支持单行和多行注释，方便阅读和维护，在Shell中，使用&lt;strong&gt;#&lt;/strong&gt;对所在行进行注释，注释的内容并不会当作命令执行。注释可单独一行也可以紧跟在命令后面。建议在写脚本添加必要的注释，方便自己也方便后续维护者或使用者。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;注释中尽量不要使用中文，脚本中也尽量不要使用中文&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;shell脚本的执行&quot;&gt;Shell脚本的执行&lt;/h4&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Shell脚本的执行流程&lt;br/&gt;    当脚本运行时，它会先查找&lt;strong&gt;系统环境变量ENV&lt;/strong&gt;，该变量指定了环境文件（加载顺序通常是/etc/profile、~/.bash_profile、~/.bashrc、/etc/bashrc等），在加载了上述环境变量文件后，Shell开始执行Shell脚本中的内容。&lt;br/&gt;    Shell脚本执行的顺序是&lt;strong&gt;从上到下，从左到右依次执行每一行的命令及语句&lt;/strong&gt;。如果Shell中存在脚本嵌套（子脚本）时，就会执行嵌套脚本的内容，完成后再返回父脚本继续执行父脚本内后续的命令和语句。通常情况下，执行Shell脚本时，会向系统内核启动一个新的进程，以便在该进程中执行脚本的命令和子脚本，其流程图如下所示：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-9daaf4d87a9479a4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-4 Shell脚本执行基本流程图_c2i.jpg&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Shell脚本的执行方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;【1】bash script-name或sh script-name&lt;/strong&gt;&lt;br/&gt;    这种方式是当脚本文件本身没有可执行权限（即文件属性没有x占位符）时常使用的方式或脚本文件没有指定解释器时常用的方法。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-7b8c33689b19de23.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-5 Shell执行方式-1.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【2】path/script-name或./script-name&lt;/strong&gt;&lt;br/&gt;    这种方式是指在当前路径下执行脚本，&lt;strong&gt;前提是脚本必须有可执行权限&lt;/strong&gt;，具体方法为&lt;strong&gt;chmod +x script-name&lt;/strong&gt;。然后通过相对路径或绝对路径执行脚本。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-bfc9c099fffd8049.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-6 Shell执行方式-2.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【3】source script-name或. script-name&lt;/strong&gt;&lt;br/&gt;    这种方法通常使用source或&quot; . &quot;读入或加载指定的Shell脚本，如son.sh，然后依次执行指定的Shell脚本文件son.sh中的所有语句。这些语句将在当前父Shell脚本father.sh中运行（其他几种模式都会启动新的进程执行子脚本）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;使用source或&quot; . &quot;可以将son.sh自身脚本中的变量值或函数等的返回值传递到当前父Shell脚本father.sh中使用，这是和其他两种方法最大的区别，因此需要特别注意。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-6f450348e66be058.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-7 Shell执行方式-3_c2i.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【4】sh&amp;lt;script-name或cat script-name | sh&lt;/strong&gt;&lt;br/&gt;    这种方法同样适用于bash，这种方法并不常见，了解知道即可。其原理就是利用了管道技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-e100c186bc0c0eca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-8 Shell执行方式-4.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家可以看看以下脚本的正确答案是哪一个？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-6b23c4ba123d937f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-9 Shell执行示例-1.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考的答案选项如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[ ] 当前用户&lt;/li&gt;
&lt;li&gt;[ ] admin&lt;/li&gt;
&lt;li&gt;[ ] 无内容输入&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;正确答案是&lt;strong&gt;无内容输入&lt;/strong&gt;。原因可查看Shell脚本的几种执行方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过这个示例我们可以得出如下结论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;子Shell脚本会直接继承父Shell的变量、函数等，如儿子继承父亲基因。&lt;/li&gt;
&lt;li&gt;如果希望父Shell继承子Shell的变量，就要使用source或&quot; . &quot;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-6d22eacda0c782c2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3-10 Shell执行示例-2.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;脚本规范&quot;&gt;脚本规范&lt;/h3&gt;
&lt;p&gt;    每种语言都有自己的开发规范，虽然不是强制遵守，但有规范的代码不便方便阅读、维护、多人协同开发，同时也能减少出现Bug的概率。主要的规范如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;【1】Shell脚本的第一行指定脚本解释器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#!/bin/bash
或
#!/bin/sh&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;【2】Shell脚本的开关添加版本、版权、作者等&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#Date:2017-11-29 22:50
#Author:Surpassme
#Description:This is sample shell scripts
#Version:1.5&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;【3】Shell脚本中尽量不要使用中文&lt;/strong&gt;&lt;br/&gt;  虽说Linux也能兼容中文，但还是存在切换系统环境后中文出现乱码的问题。如果非要用中文，可对系统进行字符集调整。如&lt;strong&gt;export LANG=&quot;zh_CN.UTF-8&quot;&lt;/strong&gt;，并在脚本中重新定义字符集设置和系统保持一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;【4】Shell脚本尽量添加扩展名.sh&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;【5】养成良好的脚本书写习惯&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;1、成对的符号尽量一次性写全，防止遗漏
2、中括号（[]）两端至少要保留一个空格。
3、流程控制语句，应一次性将格式写完，再添加内容
4、良好的代码缩进，方便阅读
5、脚本的各个符号必须为英文状态下的符号
6、常规变量的字符串定义时应加双引号（&quot;&quot;）并且等号前后均不能有空格，需要强引用（指所见即所得的字符串引用），则使用单引号（''），如果是命令引用，则用反引号（``）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;本文同步在微信订阅号上发布，如各位小伙伴们喜欢我的文章，也可以关注我的微信订阅号：woaitest，或扫描下面的二维码添加关注：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3349421-2a0edd703123621d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MyQRCode.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Nov 2018 13:27:00 +0000</pubDate>
<dc:creator>Surpassme</dc:creator>
<og:description>什么是Shell     简单来说Shell其实就是一个 命令解释器 ，而它的作用就是解释并执行用户输入的命令及程序。用户每输入一条命令，Shell就解释执行一次。这种方式很容易让</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surpassme/p/9911671.html</dc:identifier>
</item>
<item>
<title>解析·NOIP·冷门 CLZ最小环 - 迷失の风之旅人</title>
<link>http://www.cnblogs.com/Chen574118090/p/9911566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Chen574118090/p/9911566.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;赐予我力量，去改变我所能改变的;赐予我勇气，去接受我不能改变的;并赐予我智慧，去分辨这两者。&lt;br/&gt;-----安东尼达斯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NOIP的图论题中有一部分是跟图上的环有关的。蒟蒻的我在USACO上刷题时发现了一种（或许）还没有普及的快速最小环算法，拥有极高的效率，可以在求最短路的时间复杂度内求出经过任意一点的最小环大小或权值。作者将它称作&lt;strong&gt;Calculate lacework zoomly shortest cyclic&lt;/strong&gt;，这里暂译作&lt;strong&gt;CLZ最小环&lt;/strong&gt;。&lt;br/&gt;与Floyd求图上最小环不同，CLZ最小环还可以很快捷地求出经过特定点的最小环。&lt;br/&gt;CLZ最小环的思路也极为简单，很容易理解：对于求经过一个点&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;的最小环时，即首先进行最短路操作，在进行第一次松弛操作后重新将该点标记为未访问，并重新访问。由于是与最短路同时运作，所以其复杂度几乎取决于最短路算法。当然，CLZ最小环仍有其独立的优化方案。&lt;/p&gt;
&lt;h4 id=&quot;朴素情况&quot;&gt;朴素情况&lt;/h4&gt;
&lt;p&gt;首先让我们考虑朴素情况，非负带环有向图。对于求最小环中所含的点数，我们只需要将每一条边的权值修改为1，再按上述过程操作即可。&lt;br/&gt;至于如何回退操作，相信不用细讲。我们可以在最短路算法的最前定义一个布尔型变量bool wait初始值为1，在进行完松弛操作后判断wait的状态来决定是否需要将起点重新放入。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void dijkstra(int u){   
    bool wait=1;
    /*
    blblblblblbl
    */
    if(wait){
       dis[u]=0x3f3f3f3f,vis[u]=0;//对单个点进行初始化
       q.push(u);//将点重新放入
       wait=0;//设定当前松弛次数
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数代码如下&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void dijkstra(int u){
    pall note;
    bool wait=1;
    for(register int i=0;i&amp;lt;maxn;i++)dis[i]=0x3f3f3f3f,vis[i]=0;
    dis[u]=0;vis[u]=1;
    set&amp;lt;pall,cmp&amp;gt; s;
    s.insert(make_pair(u,0));
    for(register int i=0;i&amp;lt;n &amp;amp;&amp;amp; s.size();i++){
        set&amp;lt;pall,cmp&amp;gt;::iterator it=s.begin();
        u=it-&amp;gt;X;
        s.erase(*it);
        vis[u]=1;
        for(register int j=p[u];~j;j=E[j].next){
            int v=E[j].v;
            int w=E[j].w;
            if(dis[v]&amp;gt;dis[u]+w &amp;amp;&amp;amp; !vis[v]){
                s.erase(make_pair(v,dis[v]));
                s.insert(make_pair(v,dis[v]=dis[u]+w));
                note=make_pair(u,v);
            }
        }
        if(wait){
            dis[u]=0x3f3f3f3f;
            vis[u]=0;
            wait=0;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;无向图&quot;&gt;无向图&lt;/h4&gt;
&lt;p&gt;对于无向图来说，若允许经过同一条边多次，则与上述操作无异。但若每条边只能经过一次，则需要一些额外的操作。因为无向图的性质，我们可以知道，从&lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;的路径权值和与从&lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt;的路径权值和是相等的。因此我们可以考虑判断当前路径的权值&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;与上一条路径的权值&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;是否相等，并以此来考虑是否选择当前路径。&lt;br/&gt;当然也有更简单的判断方式。若数据量较大，我们只需将等待的wait往后延长一次松弛操作即可。而数据较小时，我们可以直接暴力求解，不在本题的考虑范围之内。&lt;br/&gt;对于普适且较为常规的情况，我们可以先求出点&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;连向的边与&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;的距离，保存该距离，并枚举每一个距离的总长度即可。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;if(dis[u]==w)continue;
/*-----------写法分割线------------*/
if(wait==1 &amp;amp;&amp;amp; E[i ^ 1].w==w)continue;
wait++;
int wait=0;
if(wait==1){
    dis[u]=0x3f3f3f3f;
    q.push(u);
    //wait=0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;带负权&quot;&gt;带负权&lt;/h4&gt;
&lt;h5 id=&quot;负环判断&quot;&gt;负环判断&lt;/h5&gt;
&lt;p&gt;普通的spfa可以直接解决，也可以将所有边权去反，再判断带负权的正环。详情见下文详述。&lt;/p&gt;
&lt;h5 id=&quot;正环判断&quot;&gt;正环判断&lt;/h5&gt;
&lt;p&gt;所谓正环有两种定义。一个环上所有边为正，或一个环上权值的和为正。&lt;br/&gt;对于第一种定义，我们只需要在遇见负边时跳过即可。&lt;br/&gt;对于第二种定义，则需要些许变通。我们不再直接修改或操作原边权值，而是再在结构体中声明新的变量将点的数量转化为边权值。如下图，两种边权是不会互相干扰的。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14445028-f945333b964edade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;由于有负边权，我们选择使用spfa跑最短路。我们在跑最短路的过程中同时计算两种权值。当且仅当两种边权都有更优解时我们才用新答案替换原有答案（可以稍微思考一下）。当我们按题目给的边权走，使得当前最短路为负数时，我们直接跳过该判断。并不用但担心这里会跳出正确答案，因为由于我们会在每一个点都进行一次spfa寻找操作，所以有且一定有至少一种情况让我们在跑环的过程中边权绝不为负。且这里的为负就跳出也为CLZ最小环算法提供了很好的剪枝。&lt;br/&gt;以下是带负边权的有向图最小环代码&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void spfa(int u){
    //额外的，E[i].a记录点的数量转化来的边权,即E[i].a恒等于1 
    //ges[u]记录当前最小环内的点数，即a权值维护的最小值 
    bool wait=1;
    for(register int i=0;i&amp;lt;maxn;i++)dis[i]=0x3f3f3f3f,vis[i]=0,ges[i]=0x3f3f3f3f;
    dis[u]=0;vis[u]=1;
    ges[u]=0;
    queue&amp;lt;int&amp;gt; q;
    q.push(u);
    while(!q.empty()){
        u=q.front();
        q.pop();
        vis[u]=0;
        for(register int i=p[u];~i;i=E[i].next){
            int v=E[i].v;
            int w=E[i].w;
            int a=E[i].a;
            if(dis[v]&amp;gt;dis[u]+w &amp;amp;&amp;amp; ges[v]&amp;gt;ges[u]+a &amp;amp;&amp;amp; dis[u]+w&amp;gt;0){
                ges[v]=ges[u]+a;
                dis[v]=dis[u]+w;
                //cout&amp;lt;&amp;lt;dis[v]&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;dis[u]+w&amp;lt;&amp;lt;endl;
                if(!vis[v]){
                    vis[v]=1;
                    q.push(v);
                }
            }
        }
        if(wait){
            q.push(u);
            dis[u]=0x3f3f3f3f;
            vis[u]=0;
            ges[u]=0x3f3f3f3f;
            wait=0;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以发现，其实CLZ最小环只是一种延迟操作的思想。作者只不过是使用了这一思路的一小部分，利用其智慧将最短路的松弛操作分开而已。或许在未来作者会以该思路获得更多灵感，笔者也会持续关注。&lt;br/&gt;最后附上朴素写法的板子&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define maxn 3000
#define maxm 5000
#define X first
#define Y second
#define pall pair&amp;lt;int,int&amp;gt;
using namespace std;
inline char get(){
    static char buf[300],*p1=buf,*p2=buf;
    return p1==p2 &amp;amp;&amp;amp; (p2=(p1=buf)+fread(buf,1,30,stdin),p1==p2)?EOF:*p1++;
}
inline int read(){
    register char c=get();register int f=1,_=0;
    while(c&amp;gt;'9' || c&amp;lt;'0')f=(c=='-')?-1:1,c=get();
    while(c&amp;lt;='9' &amp;amp;&amp;amp; c&amp;gt;='0')_=(_&amp;lt;&amp;lt;3)+(_&amp;lt;&amp;lt;1)+(c^48),c=get();
    return _*f;
}
struct edge{
    int u,v,w,next;
}E[maxm];
struct cmp{
    operator ()(const pall &amp;amp;a,const pall &amp;amp;b)const{
        if(a.Y!=b.Y)return a.Y&amp;lt;b.Y;
        return a.X&amp;lt;b.X;
    }
};
int p[maxn],eid;
inline void init(){
    for(register int i=0;i&amp;lt;maxn;i++)p[i]=-1;
    eid=0;
}
inline void insert(int u,int v,int w){
    E[eid].u=u;
    E[eid].v=v;
    E[eid].w=w;
    E[eid].next=p[u];
    p[u]=eid++;
}
inline void insert2(int u,int v,int w){
    insert(u,v,w);
    insert(v,u,w);
}
int n,m;
int dis[maxn],vis[maxn];
void dijkstra(int u){
    pall note;
    bool wait=1;
    for(register int i=0;i&amp;lt;maxn;i++)dis[i]=0x3f3f3f3f,vis[i]=0;
    dis[u]=0;vis[u]=1;
    set&amp;lt;pall,cmp&amp;gt; s;
    s.insert(make_pair(u,0));
    for(register int i=0;i&amp;lt;n &amp;amp;&amp;amp; s.size();i++){
        set&amp;lt;pall,cmp&amp;gt;::iterator it=s.begin();
        u=it-&amp;gt;X;
        s.erase(*it);
        vis[u]=1;
        for(register int j=p[u];~j;j=E[j].next){
            int v=E[j].v;
            int w=E[j].w;
            if(dis[v]&amp;gt;dis[u]+w &amp;amp;&amp;amp; !vis[v]){
                s.erase(make_pair(v,dis[v]));
                s.insert(make_pair(v,dis[v]=dis[u]+w));
                note=make_pair(u,v);
            }
        }
        if(wait){
            dis[u]=0x3f3f3f3f;
            vis[u]=0;
            wait=0;
        }
    }
}
int u,v,w;
int main(){
    freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);
    init();
    n=read();m=read();
    for(register int i=0;i&amp;lt;m;i++){
        u=read();v=read();w=read();
        insert(u,v,1);
    }
    int ans=0x3f3f3f3f;
    for(register int i=1;i&amp;lt;=n;i++){
        dijkstra(i);
        ans=min(ans,dis[i]);
    }
    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 05 Nov 2018 13:09:00 +0000</pubDate>
<dc:creator>迷失の风之旅人</dc:creator>
<og:description>图论里的最小环快速计算！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Chen574118090/p/9911566.html</dc:identifier>
</item>
</channel>
</rss>