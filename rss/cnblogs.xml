<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>干了这杯Java之Vector - 阿克西斯教成员污米饭</title>
<link>http://www.cnblogs.com/imeng/p/7687091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imeng/p/7687091.html</guid>
<description>&lt;p&gt;Vector实现了AbstractList抽象类和List接口,和ArrayList一样是基于Array存储的&lt;/p&gt;
&lt;p&gt;Vector 是线程安全的,在大多数方法上存在synchronized关键字&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//Vector存放的元素,初始化默认长度为10&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; Object[] elementData;

&lt;span class=&quot;co&quot;&gt;//元素个数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; elementCount;

&lt;span class=&quot;co&quot;&gt;//每次扩容大小,默认为0&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; capacityIncrement;

&lt;span class=&quot;co&quot;&gt;//构造函数，无指定初始化大小和无扩容大小&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Vector() {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;);
}

&lt;span class=&quot;co&quot;&gt;//构造函数，指定初始化大小和无扩容大小&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Vector(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; initialCapacity) {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;(initialCapacity, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
}

&lt;span class=&quot;co&quot;&gt;//构造函数，指定初始化大小和扩容大小&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Vector(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; initialCapacity, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; capacityIncrement) {
    &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;();
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (initialCapacity &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;Illegal Capacity: &quot;&lt;/span&gt;+
                                           initialCapacity);
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[initialCapacity];
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;capacityIncrement&lt;/span&gt; = capacityIncrement;
}

&lt;span class=&quot;co&quot;&gt;//构造函数,Collection集合&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Vector(Collection&amp;lt;? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; E&amp;gt; c) {
    elementData = c.&lt;span class=&quot;fu&quot;&gt;toArray&lt;/span&gt;();
    elementCount = elementData.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (elementData.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;() != Object[].&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;)
        elementData = Arrays.&lt;span class=&quot;fu&quot;&gt;copyOf&lt;/span&gt;(elementData, elementCount, Object[].&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//确保扩容的最小容量&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ensureCapacity&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; minCapacity) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (minCapacity &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        modCount++;
        &lt;span class=&quot;fu&quot;&gt;ensureCapacityHelper&lt;/span&gt;(minCapacity);
    }
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ensureCapacityHelper&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; minCapacity) {
    &lt;span class=&quot;co&quot;&gt;// overflow-conscious code&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (minCapacity - elementData.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        &lt;span class=&quot;fu&quot;&gt;grow&lt;/span&gt;(minCapacity);
}

&lt;span class=&quot;co&quot;&gt;//扩容&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;grow&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; minCapacity) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; oldCapacity = elementData.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;//当扩容大小为0的时候,扩容为原来的2倍&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; newCapacity = oldCapacity + ((capacityIncrement &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) ?
                                     capacityIncrement : oldCapacity);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (newCapacity - minCapacity &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        newCapacity = minCapacity;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (newCapacity - MAX_ARRAY_SIZE &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        newCapacity = &lt;span class=&quot;fu&quot;&gt;hugeCapacity&lt;/span&gt;(minCapacity);
    elementData = Arrays.&lt;span class=&quot;fu&quot;&gt;copyOf&lt;/span&gt;(elementData, newCapacity);
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hugeCapacity&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; minCapacity) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (minCapacity &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// overflow&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; OutOfMemoryError();
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (minCapacity &amp;gt; MAX_ARRAY_SIZE) ?
        Integer.&lt;span class=&quot;fu&quot;&gt;MAX_VALUE&lt;/span&gt; :
        MAX_ARRAY_SIZE;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;ensureCapacity(int minCapacity)方法确保Vector的最小长度,当扩容2倍小于minCapacity时,扩容到minCapacity大小,minCapacity不能小于0&lt;/li&gt;
&lt;li&gt;最大长度为2的31次方-1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置大小&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setSize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; newSize) {
    modCount++;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (newSize &amp;gt; elementCount) {
        &lt;span class=&quot;fu&quot;&gt;ensureCapacityHelper&lt;/span&gt;(newSize);
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = newSize ; i &amp;lt; elementCount ; i++) {
            elementData[i] = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        }
    }
    elementCount = newSize;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;超过大小的被设置为Null&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;copyInto&lt;/span&gt;(Object[] anArray) {
    System.&lt;span class=&quot;fu&quot;&gt;arraycopy&lt;/span&gt;(elementData, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, anArray, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, elementCount);
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;trimToSize&lt;/span&gt;() {
    modCount++;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; oldCapacity = elementData.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (elementCount &amp;lt; oldCapacity) {
        elementData = Arrays.&lt;span class=&quot;fu&quot;&gt;copyOf&lt;/span&gt;(elementData, elementCount);
    }
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;indexOf&lt;/span&gt;(Object o, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (o == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = index ; i &amp;lt; elementCount ; i++)
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (elementData[i]==&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; i;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = index ; i &amp;lt; elementCount ; i++)
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (o.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(elementData[i]))
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; i;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是否为空&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; elementCount == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置索引上的元素&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setElementAt&lt;/span&gt;(E obj, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (index &amp;gt;= elementCount) {
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayIndexOutOfBoundsException(index + &lt;span class=&quot;st&quot;&gt;&quot; &amp;gt;= &quot;&lt;/span&gt; +
                                                 elementCount);
    }
    elementData[index] = obj;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加元素&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt; &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addElement&lt;/span&gt;(E obj) {
    modCount++;
    &lt;span class=&quot;fu&quot;&gt;ensureCapacityHelper&lt;/span&gt;(elementCount + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    elementData[elementCount++] = obj;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插入元素&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;insertElementAt&lt;/span&gt;(E obj, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index) {
    modCount++;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (index &amp;gt; elementCount) {
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayIndexOutOfBoundsException(index
                                                 + &lt;span class=&quot;st&quot;&gt;&quot; &amp;gt; &quot;&lt;/span&gt; + elementCount);
    }
    &lt;span class=&quot;fu&quot;&gt;ensureCapacityHelper&lt;/span&gt;(elementCount + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    System.&lt;span class=&quot;fu&quot;&gt;arraycopy&lt;/span&gt;(elementData, index, elementData, index + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, elementCount - index);
    elementData[index] = obj;
    elementCount++;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;扩容&lt;/li&gt;
&lt;li&gt;数组拷贝向索引后移动&lt;/li&gt;
&lt;li&gt;删除为向前移动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;删除元素&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;removeElement&lt;/span&gt;(Object obj) {
    modCount++;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;fu&quot;&gt;indexOf&lt;/span&gt;(obj);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (i &amp;gt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        &lt;span class=&quot;fu&quot;&gt;removeElementAt&lt;/span&gt;(i);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;只能删除第一个&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 18 Oct 2017 07:52:00 +0000</pubDate>
<dc:creator>阿克西斯教成员污米饭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imeng/p/7687091.html</dc:identifier>
</item>
<item>
<title>面试题：求给定字符串中最长无重复子字符串的长度。 - Kkky</title>
<link>http://www.cnblogs.com/kkkky/p/7687083.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kkkky/p/7687083.html</guid>
<description>&lt;p&gt;&lt;strong&gt;题干：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;p&gt;Given &lt;code&gt;&quot;abcabcbb&quot;&lt;/code&gt;, the answer is &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, which the length is 3.&lt;/p&gt;
&lt;p&gt;Given &lt;code&gt;&quot;bbbbb&quot;&lt;/code&gt;, the answer is &lt;code&gt;&quot;b&quot;&lt;/code&gt;, with the length of 1.&lt;/p&gt;
&lt;p&gt;Given &lt;code&gt;&quot;pwwkew&quot;&lt;/code&gt;, the answer is &lt;code&gt;&quot;wke&quot;&lt;/code&gt;, with the length of 3. Note that the answer must be a substring, &lt;code&gt;&quot;pwke&quot;&lt;/code&gt; is a &lt;em&gt;subsequence&lt;/em&gt; and not a substring.&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;解法一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;列出所有字符串，并判断是否有重复字符。（最直观的方法，但是运算量极大，不要用）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int ans = 0;
        for (int i = 0; i &amp;lt; n; i++)
            for (int j = i + 1; j &amp;lt;= n; j++)
                if (allUnique(s, i, j)) ans = Math.max(ans, j - i);
        return ans;
    }

    public boolean allUnique(String s, int start, int end) {
        Set&amp;lt;Character&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        for (int i = start; i &amp;lt; end; i++) {
            Character ch = s.charAt(i);
            if (set.contains(ch)) return false;
            set.add(ch);
        }
        return true;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;解法二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用HashSet做划窗来判断字符唯一性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class LengthOfLongestSubstring3 {
        /*
         * 思路：
         *      用Set做一个范围为 [i,j)的划窗（利用Set检查char的唯一性）。
         *      在确定s[i,j-1]没有重复字符的情况下，只需检查s[j]是否存在于s[i,j-1]中就可以了。
         *      如果s[j]存在于s[i,j-1]中，那么划窗变为 [i+1,j)，继续检查。
         * 
         **/
        public int lengthOfLongestSubstring(String s) {
                int n = s.length();
                Set&amp;lt;Character&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
                int ans = 0, i = 0, j = 0;
                while (i &amp;lt; n &amp;amp;&amp;amp; j &amp;lt; n) {
                        // try to extend the range [i, j]
                        if (!set.contains(s.charAt(j))) {
                                // 此处是根据角标j来遍历，一个一个的往里存
                                set.add(s.charAt(j++));
                                ans = Math.max(ans, j - i);
                        } else {
                                set.remove(s.charAt(i++));
                        }
                }
                return ans;
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;思考：&lt;/strong&gt;整个流程中，角标是如何变化的？以及while（i&amp;lt;n &amp;amp; j&amp;lt;n）配合i++和j++这种代码结构。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;解法三：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用HashMap建立{字符-索引}的映射&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Solution {
                /*
                 *思路：
                 *      使用HashMap存放{字符-索引}的映射，当我们发现重复的字符时，直接跳过这些字符。
                 *      通过遍历j1来循环。如果s[i,j)中有重复元素s[j1]，且重复元素s[j1]在s[i,j)中的索引为j'，
                 *      那么我们直接跳过[i,j′]这个区间即可，直接将i赋值为j'+1。
                 * 
                 * */
                public int lengthOfLongestSubstring(String s) {
                        int n = s.length(), ans = 0;
                        Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); // Hashmap中存放的是 字符-索引
                        // try to extend the range [i, j]
                        for (int j = 0, i = 0; j &amp;lt; n; j++) {
                                if (map.containsKey(s.charAt(j))) {
                                        //如果map里已经有这个index[j]处的char，将i赋成map.get(s.charAt(j))，即j+1。
                                        i = Math.max(map.get(s.charAt(j)), i);
                                }
                                ans = Math.max(ans, j - i + 1);
                                //如果map里没有这个char，将char加入哈希表中，索引设为j+1。
                                map.put(s.charAt(j), j + 1);
                        }
                        return ans;
                }
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;思考：&lt;/strong&gt;怎么用一次循环完成整个算法的？想清楚整个流程中两个索引i，j是怎么变化的。&lt;/p&gt;
</description>
<pubDate>Wed, 18 Oct 2017 07:51:00 +0000</pubDate>
<dc:creator>Kkky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kkkky/p/7687083.html</dc:identifier>
</item>
<item>
<title>chromium源码阅读--Browser进程初始化 - 丹西</title>
<link>http://www.cnblogs.com/danxi/p/7685629.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danxi/p/7685629.html</guid>
<description>&lt;p&gt;最近在研读chromium源码，经过一段懵懂期，查阅了官网和网上的技术文章，是时候自己总结一下了，首先从Browser进程启动以及IPC message loop开始吧，这是每个主线程必须有的一个IPC消息轮训主体，类似之前的quagga里thread。&lt;/p&gt;
&lt;p&gt;首先来看看chromium的多进程模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/938024/201710/938024-20171018110641287-23867482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                          图1  多进程模型&lt;/p&gt;
&lt;p&gt;图1描述了chromium里 browser进程，（隐含了zygote进程），render进程以及 WebKit的关系，Webkit是网页渲染引擎，这里我就不发散开了。&lt;/p&gt;
&lt;p&gt;浏览器进程有 browser进程，render进程，还有GPU进程，plugin进程等等，首先启动肯定是browser进程。&lt;/p&gt;
&lt;p&gt;那么我们先从browser进程开始， 以下是Browser进程主函数， 在&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a class=&quot;packageName&quot; href=&quot;https://cs.chromium.org/chromium/&quot;&gt;chromium&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;//&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/&quot;&gt;src&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/content/&quot;&gt;content&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/content/browser/&quot;&gt;browser&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;a class=&quot;v-f&quot; href=&quot;https://cs.chromium.org/chromium/src/content/browser/browser_main.cc&quot;&gt;browser_main.cc&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 33行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Main routine for running as the Browser process.&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BrowserMain(&lt;span&gt;const&lt;/span&gt; MainFunctionParams&amp;amp;&lt;span&gt; parameters) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  ScopedBrowserMainEvent scoped_browser_main_event;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;base&lt;/span&gt;::trace_event::TraceLog::GetInstance()-&amp;gt;SetProcessName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Browser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;base&lt;/span&gt;::trace_event::TraceLog::GetInstance()-&amp;gt;&lt;span&gt;SetProcessSortIndex(
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;      kTraceEventBrowserProcessSortIndex);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;   std::unique_ptr&amp;lt;BrowserMainRunner&amp;gt;&lt;span&gt; main_runner(BrowserMainRunner::Create());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt; exit_code = main_runner-&amp;gt;&lt;span&gt;Initialize(parameters);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (exit_code &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; exit_code;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;   exit_code = main_runner-&amp;gt;&lt;span&gt;Run();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;   main_runner-&amp;gt;&lt;span&gt;Shutdown();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; exit_code;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，启动browser进程可以有多种方式，比如，shell模式的browser就是以ContentMain来启动的。这个函数很简单，创建了一个BrowserMainRunner对象，并且Run()起来就完成了所有的工作。&lt;/p&gt;
&lt;p&gt;那么，事情肯定没这么简单，BrowserMainRunner就是browser进程执行主体实现，包揽了所有的事情，那么接着来看 &lt;span class=&quot;v-b v-i&quot;&gt;&lt;a class=&quot;packageName&quot; href=&quot;https://cs.chromium.org/chromium/&quot;&gt;在 chromium&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;//&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/&quot;&gt;src&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/content/&quot;&gt;content&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/content/browser/&quot;&gt;browser&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;a class=&quot;v-f&quot; href=&quot;https://cs.chromium.org/chromium/src/content/browser/browser_main_runner.cc&quot;&gt;browser_main_runner.cc 239行&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; static&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; BrowserMainRunner*&lt;span&gt; BrowserMainRunner::Create() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrowserMainRunnerImpl();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;v-b v-i&quot;&gt;&lt;span class=&quot;v-j&quot;&gt;&lt;span class=&quot;v-b v-i&quot;&gt;&lt;span class=&quot;v-j&quot;&gt;&lt;span class=&quot;v-b v-i&quot;&gt;&lt;span class=&quot;v-j&quot;&gt;&lt;span class=&quot;v-b v-i&quot;&gt;&lt;span class=&quot;v-j&quot;&gt;原来&lt;span&gt;BrowserMainRunner只是定义了接口，是由它的子类&lt;span&gt;BrowserMainRunnerImpl&lt;/span&gt;来实现，通过Impl模式来隐藏细节，那么看main_runner的initialize和Run函数是如何实现的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;v-b v-i&quot;&gt;&lt;span class=&quot;v-j&quot;&gt;&lt;span class=&quot;v-b v-i&quot;&gt;&lt;span class=&quot;v-j&quot;&gt;&lt;span class=&quot;v-b v-i&quot;&gt;&lt;span class=&quot;v-j&quot;&gt;&lt;span class=&quot;v-b v-i&quot;&gt;&lt;span class=&quot;v-j&quot;&gt;&lt;span&gt;在&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a class=&quot;packageName&quot; href=&quot;https://cs.chromium.org/chromium/&quot;&gt;chromium&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;//&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/&quot;&gt;src&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/content/&quot;&gt;content&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/content/browser/&quot;&gt;browser&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;a class=&quot;v-f&quot; href=&quot;https://cs.chromium.org/chromium/src/content/browser/browser_main_runner.cc&quot;&gt;browser_main_runner.cc&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 51行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; BrowserMainRunnerImpl : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BrowserMainRunner {

  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Initialize(&lt;span&gt;const&lt;/span&gt; MainFunctionParams&amp;amp; parameters) &lt;span&gt;override&lt;/span&gt;&lt;span&gt; {
      ......
      &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;::TimeTicks start_time_step1 = &lt;span&gt;base&lt;/span&gt;&lt;span&gt;::TimeTicks::Now();

      SkGraphics::Init();

      &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;::StatisticsRecorder::Initialize();

      notification_service_.reset(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotificationServiceImpl);
      main_loop_.reset(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrowserMainLoop(parameters));

      main_loop_&lt;/span&gt;-&amp;gt;&lt;span&gt;Init();

      main_loop_&lt;/span&gt;-&amp;gt;&lt;span&gt;EarlyInitialization();
      ......

      main_loop_&lt;/span&gt;-&amp;gt;&lt;span&gt;PreMainMessageLoopStart();
      main_loop_&lt;/span&gt;-&amp;gt;&lt;span&gt;MainMessageLoopStart();
      main_loop_&lt;/span&gt;-&amp;gt;&lt;span&gt;PostMainMessageLoopStart();
      ui::InitializeInputMethod();

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;::TimeTicks start_time_step2 = &lt;span&gt;base&lt;/span&gt;&lt;span&gt;::TimeTicks::Now();
    main_loop_&lt;/span&gt;-&amp;gt;&lt;span&gt;CreateStartupTasks();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result_code = main_loop_-&amp;gt;&lt;span&gt;GetResultCode();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result_code &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result_code;
      .....
  }

  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Run() &lt;span&gt;override&lt;/span&gt;&lt;span&gt; {
    DCHECK(initialization_started_);
    DCHECK(&lt;/span&gt;!&lt;span&gt;is_shutdown_);
    main_loop_&lt;/span&gt;-&amp;gt;&lt;span&gt;RunMainMessageLoopParts();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; main_loop_-&amp;gt;&lt;span&gt;GetResultCode();
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以看到 main_loop_ 成员接管了所有的工作，那么它的声明是什么：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  std::unique_ptr&amp;lt;BrowserMainLoop&amp;gt; main_loop_;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 &lt;span class=&quot;v-b v-i&quot;&gt;&lt;a class=&quot;packageName&quot; href=&quot;https://cs.chromium.org/chromium/&quot;&gt;chromium&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;//&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/&quot;&gt;src&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/content/&quot;&gt;content&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/content/browser/&quot;&gt;browser&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;a class=&quot;v-f&quot; href=&quot;https://cs.chromium.org/chromium/src/content/browser/browser_main_loop.h&quot;&gt;browser_main_loop.h&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 里给出了 BrowserMainLoop的声明，BrowserMainLoop的初始化顺序如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Quick reference for initialization order:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Constructor
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Init()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; EarlyInitialization()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; InitializeToolkit()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PreMainMessageLoopStart()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MainMessageLoopStart()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   InitializeMainThread()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PostMainMessageLoopStart()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CreateStartupTasks()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   PreCreateThreads()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   CreateThreads()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   BrowserThreadsStarted()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     InitializeMojo()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     InitStartupTracingForDuration()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   PreMainMessageLoopRun()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个流程已经在前面的BrowserMainRunnerImpl的实例对象的initialize已经完成，包含了大量信息，这里我就主要看主线程的IPC消息循环的部分，如下声明了IPC消息轮询对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Members initialized in |MainMessageLoopStart()| &lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;   std::unique_ptr&amp;lt;&lt;span&gt;base&lt;/span&gt;::MessageLoop&amp;gt; main_message_loop_;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a class=&quot;packageName&quot; href=&quot;https://cs.chromium.org/chromium/&quot;&gt;chromium&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;//&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/&quot;&gt;src&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/content/&quot;&gt;content&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/content/browser/&quot;&gt;browser&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;a class=&quot;v-f&quot; href=&quot;https://cs.chromium.org/chromium/src/content/browser/browser_main_loop.cc&quot;&gt;browser_main_loop.cc&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 710行，&lt;span&gt;MainMessageLoopStart函数负责初始化成员变量main_message_loop_，如果当前进程没有就指向一个&lt;span&gt;base&lt;span&gt;::MessageLoopForUI&lt;/span&gt;&lt;/span&gt;指针.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BrowserMainLoop::MainMessageLoopStart() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DO NOT add more code here. Use PreMainMessageLoopStart() above or
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PostMainMessageLoopStart() below.&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;   TRACE_EVENT0(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;startup&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BrowserMainLoop::MainMessageLoopStart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create a MessageLoop if one does not already exist for the current thread.&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;base&lt;/span&gt;&lt;span&gt;::MessageLoop::current())
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     main_message_loop_.reset(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;::MessageLoopForUI);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  InitializeMainThread();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到了这里我们可以看到，base::&lt;span&gt;MessageLoopForUI&lt;/span&gt;，顾名思义，是UI类型的IPC消息轮询，嗯，没错，Browser进程负责UI方面的IPC消息接收和转发（routing）。&lt;/p&gt;
&lt;p&gt;接下来，就将这个消息轮询对象加入到主线程当中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BrowserMainLoop::InitializeMainThread() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   TRACE_EVENT0(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;startup&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BrowserMainLoop::InitializeMainThread&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;base&lt;/span&gt;::PlatformThread::SetName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CrBrowserMain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register the main thread by instantiating it, but don't call any methods.&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;  main_thread_.reset(
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;       &lt;span&gt;new&lt;/span&gt; BrowserThreadImpl(BrowserThread::UI, &lt;span&gt;base&lt;/span&gt;&lt;span&gt;::MessageLoop::current()));
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化完成之后，我们返回之前main_runner_的Run（）是执行&lt;span&gt;RunMainMessageLoopParts&lt;/span&gt;（）函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BrowserMainLoop::RunMainMessageLoopParts() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Don't use the TRACE_EVENT0 macro because the tracing infrastructure doesn't
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; expect synchronous events around the main loop of a thread.&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;   TRACE_EVENT_ASYNC_BEGIN0(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;toplevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BrowserMain:MESSAGE_LOOP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;bool&lt;/span&gt; ran_main_loop = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (parts_)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ran_main_loop = parts_-&amp;gt;MainMessageLoopRun(&amp;amp;&lt;span&gt;result_code_);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ran_main_loop)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    MainMessageLoopRun();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;   TRACE_EVENT_ASYNC_END0(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;toplevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BrowserMain:MESSAGE_LOOP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们需要分析一下 &lt;span class=&quot;f-b f-L&quot;&gt;BrowserMainParts&lt;/span&gt; 这个类以及它的子类，因为它开始涉及到平台相关的内容了。&lt;/p&gt;
&lt;p&gt;BrowserMainParts的子类有&lt;span class=&quot;f-b f-L&quot;&gt;ChromeBrowserMainParts，&lt;/span&gt; ChromeBrowserMainPartsAndroid，&lt;span class=&quot;f-b f-L&quot;&gt;ChromeBrowserMainPartsPosix&lt;/span&gt; 等等，涉及chrome相关的，都没有重载MainMessageLoopRun，当然也有重载这个函数，比如&lt;span class=&quot;f-b&quot;&gt;ShellBrowserMainParts&lt;/span&gt;类。&lt;/p&gt;
&lt;p&gt;那么在&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a class=&quot;packageName&quot; href=&quot;https://cs.chromium.org/chromium/&quot;&gt;chromium&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;//&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/&quot;&gt;src&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/content/&quot;&gt;content&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/content/browser/&quot;&gt;browser&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;a class=&quot;v-f&quot; href=&quot;https://cs.chromium.org/chromium/src/content/browser/browser_main_loop.cc&quot;&gt;browser_main_loop.cc&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 1708行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BrowserMainLoop::MainMessageLoopRun() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; defined(OS_ANDROID)
&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Android's main message loop is the Java message loop.&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  NOTREACHED();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   DCHECK(&lt;span&gt;base&lt;/span&gt;&lt;span&gt;::MessageLoopForUI::IsCurrent());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (parameters_.ui_task) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;base&lt;/span&gt;::ThreadTaskRunnerHandle::Get()-&amp;gt;&lt;span&gt;PostTask(FROM_HERE,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                                                   *&lt;span&gt;parameters_.ui_task);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;base&lt;/span&gt;&lt;span&gt;::RunLoop run_loop;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;  run_loop.Run();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RunLoop是一个可以处理嵌套IPC消息的辅助类，它里面声明了一个 RunLoop::Delegate类，来协助完成对IPC消息轮询嵌套层级的执行。&lt;/p&gt;
&lt;p&gt;这里简单解释一下消息嵌套，即当前处理的IPC消息过程中有收到了新的IPC消息。RunLoop以一种类似入栈出栈的思路来实现消息嵌套。&lt;/p&gt;
&lt;p&gt;我们接着看RunLoop的声明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;enum&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Type {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    kDefault,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    kNestableTasksAllowed,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;  };
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;   RunLoop(Type type = Type::kDefault);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;RunLoop::RunLoop(Type type)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    : delegate_(tls_delegate.Get().Get()),
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;      type_(type),
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      origin_task_runner_(ThreadTaskRunnerHandle::Get()),
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       weak_factory_(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   DCHECK(delegate_) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A RunLoop::Delegate must be bound to this thread prior &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;to using RunLoop.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  DCHECK(origin_task_runner_);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   DCHECK(IsNestingAllowedOnCurrentThread() ||
&lt;span&gt;11&lt;/span&gt;          type_ !=&lt;span&gt; Type::kNestableTasksAllowed);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认的话是不支持嵌套的，通过&lt;span&gt;ThreadTaskRunnerHandle::Get()获取当前线程的IPC消息sender&lt;/span&gt;，并且偷偷的将从当前线程变量里的tls_delegate来初始化 RunLoop::Delegate delegate_ 成员变量，那么tls_delegate是什么呢？&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a class=&quot;packageName&quot; href=&quot;https://cs.chromium.org/chromium/&quot;&gt;在 chromium&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;//&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/&quot;&gt;src&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/base/&quot;&gt;base&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;a class=&quot;v-f&quot; href=&quot;https://cs.chromium.org/chromium/src/base/run_loop.cc&quot;&gt;run_loop.cc 73行&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; static&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; RunLoop::Delegate::Client*&lt;span&gt; RunLoop::RegisterDelegateForCurrentThread(
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Delegate* &lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Bind |delegate| to this thread.&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;   DCHECK(!&lt;span&gt;delegate&lt;/span&gt;-&amp;gt;&lt;span&gt;bound_);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   DCHECK_CALLED_ON_VALID_THREAD(&lt;span&gt;delegate&lt;/span&gt;-&amp;gt;&lt;span&gt;bound_thread_checker_);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; There can only be one RunLoop::Delegate per thread.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   DCHECK(!&lt;span&gt;tls_delegate.Get().Get());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   tls_delegate.Get().Set(&lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;delegate&lt;/span&gt;-&amp;gt;bound_ = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; &amp;amp;&lt;span&gt;delegate&lt;/span&gt;-&amp;gt;&lt;span&gt;client_interface_;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;函数RegisterDelegateForCurrentThread负责对tls_delegate进行赋值。而这个函数是在MessageLoop的&lt;span&gt;BindToCurrentThread函数里调用的。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; MessageLoop::BindToCurrentThread() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   DCHECK(!&lt;span&gt;pump_);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pump_factory_.is_null())
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     pump_ =&lt;span&gt; std::move(pump_factory_).Run();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     pump_ =&lt;span&gt; CreateMessagePumpForType(type_);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   DCHECK(!current()) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;should only have one message loop per thread&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   GetTLSMessageLoop()-&amp;gt;Set(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;   incoming_task_queue_-&amp;gt;&lt;span&gt;StartScheduling();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   unbound_task_runner_-&amp;gt;&lt;span&gt;BindToCurrentThread();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   unbound_task_runner_ =&lt;span&gt; nullptr;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  SetThreadTaskRunnerHandle();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   thread_id_ =&lt;span&gt; PlatformThread::CurrentId();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;   scoped_set_sequence_local_storage_map_for_current_thread_ = std::make_unique&amp;lt;
&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;internal&lt;/span&gt;::ScopedSetSequenceLocalStorageMapForCurrentThread&amp;gt;&lt;span&gt;(
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;       &amp;amp;&lt;span&gt;sequence_local_storage_map_);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;   run_loop_client_ = RunLoop::RegisterDelegateForCurrentThread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里，又悄悄的把MessageLoop和RunLoop联系到了一起，RunLoop的delegate_指向一个MessageLoop指针，那么我们接下来可以看一下MessageLoop的声明了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BASE_EXPORT MessageLoop : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MessagePump::Delegate,
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                                 &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RunLoop::Delegate {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;  ......
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，可以看到RunLoop的Run函数实际上是调用的MessageLoop的Run函数，来到了消息循环的主体，到此由于篇幅过长，那么下面单独写一章来看消息处理的具体流程。&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Wed, 18 Oct 2017 07:42:00 +0000</pubDate>
<dc:creator>丹西</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/danxi/p/7685629.html</dc:identifier>
</item>
<item>
<title>Nodejs入门-基于Node.js的简单应用 - PC.aaron</title>
<link>http://www.cnblogs.com/aaron-pan/p/7686906.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aaron-pan/p/7686906.html</guid>
<description>&lt;h2&gt;服务端JavaScript&lt;/h2&gt;
&lt;p&gt;　　众所周知的，JavaScript是运行在浏览器的脚本语言，JavaScript通常作为客户端程序设计语言使用，以JavaScript写出的程序常在用户的浏览器上运行。直至Nodejs的出现，Node.js大部分基本模块都用JavaScript语言编写，Node.js的出现使JavaScript也能用于服务器端编程。Node.js含有一系列内置模块，使得程序可以脱离&lt;a href=&quot;https://zh.wikipedia.org/wiki/Apache_HTTP_Server&quot; target=&quot;_blank&quot;&gt;Apache HTTP Server&lt;/a&gt;或&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF%E8%B3%87%E8%A8%8A%E6%9C%8D%E5%8B%99&quot; target=&quot;_blank&quot;&gt;IIS&lt;/a&gt;，作为独立服务器运行。&lt;/p&gt;
&lt;h2&gt;Node.js概况&lt;/h2&gt;
&lt;p&gt;　　Node.js允许通过JavaScript和一系列模块来编写服务器端应用和网络相关的应用。&lt;/p&gt;
&lt;p&gt;　　核心模块包括文件系统I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL等）、二进制数据流、加密算法、数据流等等。&lt;/p&gt;
&lt;p&gt;　　运用Node.js的相关框架可以快速的完成应用的开发，常用的框架有Express.js、Koa.js、Socket.IO和Connect等。&lt;/p&gt;
&lt;p&gt;　　Node.js主要用于编写像Web服务器一样的网络应用，这和PHP和Python是类似的。但是Node.js与其他语言最大的不同之处在于，PHP等语言是阻塞的（只有前一条命令执行完毕才会执行后面的命令），而Node.js是非阻塞的（多条命令可以同时被运行，通过回调函数得知命令已结束运行）。&lt;/p&gt;
&lt;p&gt;　　Node.js是事件驱动的。开发者可以在不使用线程的情况下开发出一个能够承载高并发的服务器。&lt;/p&gt;
&lt;p&gt;　　Node.js使用Google &lt;a href=&quot;https://zh.wikipedia.org/wiki/V8_(JavaScript%E5%BC%95%E6%93%8E)&quot; target=&quot;_blank&quot;&gt;V8JavaScript 引擎&lt;/a&gt;，因为V8是基于BSD许可证的开源软件且速度非常快并且专注于网络功能，在HTTP、DNS、TCP等方面更加成熟。&lt;/p&gt;
&lt;p&gt;　　Node.js的包管理器npm可完成相关依赖包的模块下载。&lt;/p&gt;
&lt;h2&gt;Node.js简单应用&lt;/h2&gt;
&lt;p&gt;　　应用说明：通过启动本地服务器，完成图片上传并展示的功能。&lt;/p&gt;
&lt;h3&gt;　　一、需要的模块&lt;/h3&gt;
&lt;p&gt;　　HTTP服务器模块（HTTP服务器）：&lt;a href=&quot;http://nodejs.cn/api/http.html#http_http&quot; target=&quot;_blank&quot;&gt;http://nodejs.cn/api/http.html#http_http&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　fs模块（文件系统）：&lt;a href=&quot;http://nodejs.cn/api/fs.html#fs_file_system&quot; target=&quot;_blank&quot;&gt;http://nodejs.cn/api/fs.html#fs_file_system&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　url模块（网址）：&lt;a href=&quot;http://nodejs.cn/api/url.html#url_class_url&quot; target=&quot;_blank&quot;&gt;http://nodejs.cn/api/url.html#url_class_url&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　formidable模块（处理文件上传，ps：该模块需要npm install安装）：&lt;a href=&quot;https://cnodejs.org/topic/4f16442ccae1f4aa2700104d&quot; target=&quot;_blank&quot;&gt;https://cnodejs.org/topic/4f16442ccae1f4aa2700104d&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;　　二、思路分析&lt;/h3&gt;
&lt;p&gt;　　1.启动服务器，发送HTTP请求&lt;/p&gt;
&lt;p&gt;　　2.通过获取请求参数，执行路由跳转或处理程序&lt;/p&gt;
&lt;h3&gt;　　三、模块抽取及代码展示&lt;/h3&gt;
&lt;p&gt;　　1.抽取出主页面index.js（解耦）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by aaron.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; server=require('./server'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; router=require('./router'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; requestHandlers=require('./requestHandlers'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; handle=&lt;span&gt;{}
    handle[&lt;/span&gt;'/']=&lt;span&gt;requestHandlers.start,
    handle[&lt;/span&gt;'/start']=&lt;span&gt;requestHandlers.start,
    handle[&lt;/span&gt;'/upload']=&lt;span&gt;requestHandlers.upload,
    handle[&lt;/span&gt;'/show']=&lt;span&gt;requestHandlers.show;

server.start(router.route,handle);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.创建服务器并监听客户端请求事件server.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by aaron.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; http=require('http'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url=require('url'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; start(route,handle) {
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; onRequest(request,response) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; postData=''&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pathname=&lt;span&gt;url.parse(request.url).pathname;
        console.log(&lt;/span&gt;'Request for'+pathname+'received'&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;node-formidable会对postData及setEncoding处理&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;request.setEncoding('utf8');
        request.addListener('data',function (postDataChunk) {
            postData+=postDataChunk;
            console.log('Received POST data chunk'+postDataChunk+'.');
        });
        request.addListener('end',function () {
            route(handle,pathname,response,postData);
        })&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        route(handle,pathname,response,request);

    }
    http.createServer(onRequest).listen(&lt;/span&gt;8888&lt;span&gt;);
    console.log(&lt;/span&gt;'Server has started.'&lt;span&gt;);
}

exports.start&lt;/span&gt;=start;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.获取请求参数并执行路由跳转router.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by aaron.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; route(handle,pathname,response,request) {
    console.log(&lt;/span&gt;'About to route a request for'+&lt;span&gt;pathname);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; handle[pathname]==='function'&lt;span&gt;){
        handle[pathname](response,request);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        console.log(&lt;/span&gt;'No request handler found for'+&lt;span&gt;pathname);
        response.writeHead(&lt;/span&gt;404,{'Content-type':'text/plain'&lt;span&gt;});
        response.write(&lt;/span&gt;'404 Not found'&lt;span&gt;);
        response.end();
    }
}

exports.route&lt;/span&gt;=route;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.请求处理程序并作出响应requestHandler.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by aaron.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行非阻塞操作，从node来执行一个shell命令&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; exec=require('child_process'&lt;span&gt;).exec;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; querystring=require('querystring'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fs=require('fs'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; formidable=require('formidable'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; start(response) {
    console.log(&lt;/span&gt;'Request handler &quot;start&quot; was called.'&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; body='&amp;lt;html&amp;gt;' +
        '&amp;lt;head&amp;gt;' +
        '&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;/&amp;gt;' +
        '&amp;lt;/head&amp;gt;' +
        '&amp;lt;body&amp;gt;' +
        '&amp;lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&amp;gt;' +
        '&amp;lt;input type=&quot;file&quot; name=&quot;upload&quot;/&amp;gt;' +
        '&amp;lt;br/&amp;gt;'+
        '&amp;lt;input type=&quot;submit&quot; value=&quot;Upload file&quot;/&amp;gt;'+
        '&amp;lt;/form&amp;gt;' +
        '&amp;lt;/body&amp;gt;'+
        '&amp;lt;/html&amp;gt;'&lt;span&gt;;

    response.writeHead(&lt;/span&gt;200,{'Content-type':'text/html'&lt;span&gt;});
    response.write(body);
    response.end();
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; upload(response,request) {
    console.log(&lt;/span&gt;'Request handler &quot;upload &quot; was called.'&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; form=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; formidable.IncomingForm();
    form.parse(request,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (error,fields,files) {
        console.log(&lt;/span&gt;'parsing done:&amp;lt;br/&amp;gt;'+&lt;span&gt;files.upload.path);
        fs.renameSync(files.upload.path,&lt;/span&gt;'C:/temp/test.jpg'&lt;span&gt;);
        response.writeHead(&lt;/span&gt;200,{'Content-type':'text/html'&lt;span&gt;});
        response.write(&lt;/span&gt;'received image:&amp;lt;br/&amp;gt;'&lt;span&gt;);
        response.write(&lt;/span&gt;'&amp;lt;img src=&quot;/show&quot;/&amp;gt;'&lt;span&gt;);
        response.end();
    })
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;response.writeHead(200,{'Content-type':'text/plain'});
    response.write('You`ve sent the text:'+
        querystring.parse(postData).text
    );
    response.end();&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show(response,postData) {
    console.log(&lt;/span&gt;'Request handler &quot;show&quot; was called.'&lt;span&gt;);
    fs.readFile(&lt;/span&gt;'C:/temp/test.jpg','binary',&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (error,file) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(error){
            response.writeHead(&lt;/span&gt;500,{'Content-type':'text/plain'&lt;span&gt;});
            response.write(error&lt;/span&gt;+'\n'&lt;span&gt;);
            response.end();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            response.writeHead(&lt;/span&gt;200,{'Content-type':'image/jpg'&lt;span&gt;});
            response.write(file,&lt;/span&gt;'binary'&lt;span&gt;);
            response.end();
        }
    })
}

exports.start&lt;/span&gt;=&lt;span&gt;start;
exports.upload&lt;/span&gt;=&lt;span&gt;upload;
exports.show&lt;/span&gt;=show;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　5.结果展示&lt;/h3&gt;
&lt;p&gt;　　选择图片--&amp;gt; 上传 --&amp;gt; 展示图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1141454/201710/1141454-20171018152435115-1243176047.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1141454/201710/1141454-20171018152444459-445389339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 补充说明&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1141454/201710/1141454-20171018151750818-1395460215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　fs.renameSync()执行函数时如果执行图片上传的盘不是系统盘时会提示报错，解决方案是图片路径设置为绝对路径并设置为系统盘。&lt;/p&gt;

&lt;h3&gt;更多参考&lt;/h3&gt;
&lt;p&gt;　　《Node.js入门》：https://www.nodebeginner.org/index-zh-cn.html&lt;/p&gt;
&lt;p&gt;　　维基百科：https://zh.wikipedia.org/wiki/Node.js&lt;/p&gt;
&lt;p&gt; 　　Node.js中文网：http://nodejs.cn/api/&lt;/p&gt;



</description>
<pubDate>Wed, 18 Oct 2017 07:28:00 +0000</pubDate>
<dc:creator>PC.aaron</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aaron-pan/p/7686906.html</dc:identifier>
</item>
<item>
<title>WiFi网络WPA2 KRACK漏洞分析报告 - 阿里聚安全</title>
<link>http://www.cnblogs.com/alisecurity/p/7686781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alisecurity/p/7686781.html</guid>
<description>&lt;p&gt;————————&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0x00 漏洞概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安全研究员Mathy Vanhoef发现的WPA2协议的KRA（Key Reinstallation Attacks）漏洞，利用WPA2协议标准加密密钥生成机制上的设计缺陷，四次握手协商加密密钥过程中第三个消息报文可被篡改重放，导致在用密钥被重新安装。&lt;/p&gt;

&lt;p&gt;WiFi网络通过WPA2 handshake四次握手消息协商用于后续数据通信的加密密钥，其中交互的第三个消息报文被篡改重放，可导致中间人攻击重置重放计数器(replay counter)及随机数值(nonce)，重放给client端，使client安装上不安全的加密密钥。&lt;/p&gt;

&lt;p&gt;此漏洞攻击方式被命名为Key reinstallation attacks密钥重装攻击，除了影响已经在用的数据加密密钥，同时也影响PeerKey, group key, Fast BSS切换FT握手等，会导致WiFi通信数据加密通道不安全，存在被嗅探、篡改和重放等风险，攻击者可获取WiFi网络中的数据信息。&lt;/p&gt;

&lt;p&gt;几乎所有支持Wi-Fi的设备（Android, Linux, Apple, Windows, OpenBSD, MediaTek, Linksys等）都面临安全威胁，危害较大。&lt;/p&gt;

&lt;p&gt;该漏洞相关影响取决于被攻击的握手过程和数据加密协议，例如AES-CCMP可被重放和解密，TCP流量存在被劫持和注入恶意流量的可能，WPATKIP和GCMP可被重放、篡改及解密，影响会更大，因为GCMP两端使用的相同的认证密钥。&lt;/p&gt;

&lt;p&gt;相关CVE如下，其中每个CVE代表一种特定场景下的密钥重装攻击。&lt;/p&gt;
&lt;p&gt;l  CVE-2017-13077: 四次握手过程中重装PTK-TK加密密钥对&lt;/p&gt;
&lt;p&gt;l  CVE-2017-13078: 四次握手过程中重装GTK&lt;/p&gt;
&lt;p&gt;l  CVE-2017-13079: 四次握手过程中重装IGTK&lt;/p&gt;
&lt;p&gt;l  CVE-2017-13080: Group key 握手过程中重装GTK&lt;/p&gt;
&lt;p&gt;l  CVE-2017-13081: 握手过程中重装IGTK&lt;/p&gt;
&lt;p&gt;l  CVE-2017-13082: 接收重传的快速BSS切换重关联请求，在处理过程中重安装PTK-TK加密密钥对&lt;/p&gt;
&lt;p&gt;l  CVE-2017-13084: 在PeerKey握手过程中重安装STK KEY&lt;/p&gt;
&lt;p&gt;l  CVE-2017-13086: 在DTLS握手过程中重安装TDLS PeerKey&lt;/p&gt;
&lt;p&gt;l  CVE-2017-13087: 在处理WNM睡眠模式响应帧过程中重安装GTK&lt;/p&gt;
&lt;p&gt;l  CVE-2017-13088: 在处理WNM睡眠模式响应帧过程中重安装IGTK&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;漏洞攻击演示视频：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;https://www.youtube.com/watch?v=BtdN1SM5Z5o&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0x01 WPA2协议介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WPA全名为Wi-Fi Protected Access，有WPA和WPA2两个标准, WPA（Wi-Fi Protected Access）加密方式目前有四种认证方式：WPA、WPA-PSK、WPA2、WPA2-PSK，采用的加密算法有两种：AES（Advanced Encryption Standard高级加密算法）和TKIP（Temporal Key Integrity Protocol临时密钥完整性协议）。&lt;/p&gt;

&lt;p&gt;由于WEP已被证明为不安全的协议，在&lt;a href=&quot;https://baike.baidu.com/item/802.11i&quot; target=&quot;_blank&quot;&gt;802.11i&lt;/a&gt;协议完善前，采用WPA为用户提供一个临时性的解决方案。该标准的&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86&quot; target=&quot;_blank&quot;&gt;数据加密&lt;/a&gt;采用TKIP协议(Temporary Key Integrity Protocol)，TKIP的两个主要功能是：逐包密钥及消息完整性检查（MIC），与WEP相同的加密算法RC4来实现这一点，虽然TKIP解决了所有已知的WEP问题，但WPA2的AES加密更安全，适应更广泛的工业标准并在实践中广泛使用。&lt;/p&gt;

&lt;p&gt;WPA2是WPA的增强型版本，与WPA相比，WPA2新增了支持AES的加密方式，采用AES加密机制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0x02  Key reinstallation attacks密钥重装攻击&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;四次握手协商密钥过程中消息报文见图1EAPOL格式，其中重放计数replay counter字段用于检测重复报文，每次发送一个报文，重放计数加一，nonce字段为加密密钥生成所需要的随机数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://epo.alicdn.com/image/45uridpeong0.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图1 EAPOL帧简化报文格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以group key为例，首先Client进入PTK-INIT状态，初始化(PMK)，当接收到消息1进入PTK_START状态，client会生成随机数SNonce，计算临时TPTK，发送消息2（带SNonce）到AP，当Client接收到消息3，replay counter重放计数等有效的条件下，进入PTK-NEGOTIATING协商状态，同时标记TPTK为有效，发送消息4到AP，然后直接进入PTK-DONE状态,使用MLME-SETKEYS安装KEY。&lt;strong&gt;特别注意的是，此状态机过程来自于802.11标准，清晰的考虑了未收到消息2或者4的情况，消息1或者3会继续重传。&lt;/strong&gt;具体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://epo.alicdn.com/image/45urim473mo0.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图&lt;/strong&gt;&lt;strong&gt;2 四次握手状态机，KEY用MLME-SETKEYS.request命令字进行安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当client作为Supplicant加入wifi网络，client与AP认证端Authenticator进行四次握手协商新的加密密钥，见下图3，在接收到四次握手中的第3个消息报文时会安装新生成的加密密钥，后续数据通信使用该密钥进行数据加密。&lt;/p&gt;

&lt;p&gt;因为报文可能丢失，如果AP未接收到client的响应会重发第三个消息报文，所以&lt;strong&gt;client可能重复接收到第3个消息报文多次。每次当client接收到此消息，都会重新安装相同的加密密钥，然后重置协议加密使用到的nonce值及重放计数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;攻击者可通过嗅探、重放四次握手过程中的第3个消息报文，强制重置协议加密使用到的nonce值及重放计数，重安装加密密钥，从而攻击协议的加密机制，数据报文可被重放、解密及篡改。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该攻击方法同时可用于攻击已在使用的加密密钥、group key、PeerKey, TDLS及快速BSS切换握手等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://epo.alicdn.com/image/45urj131h800.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图3 Group Key场景四次握手&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;0x03 漏洞根因分析及影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;802.11协议标准仅提供描述粗粒度的伪码描述四次握手的状态机，但并未清晰描述特定的握手消息应该在什么时候处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;密钥重装漏洞滥用了消息3重传的流程，首先在Client和AP之间确定MitM中间人攻击的点，在AP接收到消息4之前不断重传篡改后的消息3，导致Client重新安装已用的加密密钥，同时重置nonce值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际情况，实施此攻击的时候，并非所有的Wi-Fi客户端client都正确实现了此状态机，Windows和iOS未接收处理消息3的重传，这违背了802.11标准，所以密钥重装漏洞攻击的时候并未生效产生漏洞，但在group key握手的场景下仍然存在安全漏洞，此外在FT握手情况下仍可能被间接攻击。&lt;/p&gt;

&lt;p&gt;对于Android 6.0影响更大，在此攻击的情况下，强制使用了可预测全零的加密密钥。&lt;/p&gt;

&lt;p&gt;密钥重装漏洞攻击实际影响如下图4，第一列代表不同类型的Client客户端，第2列表示不同Client类型是否接受消息3，第三列表示如果PTK配置，EAPOL消息明文是否接收，第4列表示首个消息3报文快速发送后是否接收明文EAPOL报文，&lt;strong&gt;最后两列表示是否受到此漏洞攻击的影响。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特别需要注意的，研究者当前并没有破解Wi-Fi网络的密码，也并没有通过四次握手协商过程的攻击破解新生成的加密密钥。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://epo.alicdn.com/image/45urjbbm4j60.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图4不同Clients的实际漏洞效果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0x04 漏洞影响范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此漏洞存在于协议标准设计缺陷，所有支持WPA2的客户端都受到影响。&lt;/p&gt;
&lt;p&gt;攻击主要面向WPA2客户端设备。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0x05 漏洞安全加固建议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、 漏洞攻击需要实施MitM中间人攻击，条件许可建议合理部署无线入侵防御系统或者VPN加密，及时监测恶意钓鱼WiFi，禁止私搭AP等；&lt;/p&gt;
&lt;p&gt;2、 及时升级此漏洞的安全补丁（有补丁的情况），更新WPA2客户端到最新版本；&lt;/p&gt;
&lt;p&gt;3、 仅连接可信wifi，公共场合尽量使用蜂窝移动网络，wifi连接不用的情况下建议禁用，攻击面最小化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux的hostapd和wpa_supplicant补丁已公布，详见 &lt;a href=&quot;https://w1.fi/security/2017-1/&quot; target=&quot;_blank&quot;&gt;https://w1.fi/security/2017-1/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;微软在Windows 10操作系统中发布补丁KB4041676。&lt;/p&gt;
&lt;p&gt;苹果在最新的beta版本iOS等中修复了无线网络安全漏洞。&lt;/p&gt;

&lt;p&gt;参考文档:&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://papers.mathyvanhoef.com/ccs2017.pdf&quot; target=&quot;_blank&quot;&gt;https://papers.mathyvanhoef.com/ccs2017.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]&lt;a href=&quot;https://techcrunch.com/2017/10/16/wpa2-shown-to-be-vulnerable-to-key-reinstallation-attacks/&quot; target=&quot;_blank&quot;&gt;https://techcrunch.com/2017/10/16/wpa2-shown-to-be-vulnerable-to-key-reinstallation-attacks/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;-------------------------------&lt;/p&gt;
&lt;p&gt;更多安全类热点信息和知识分享，请关注阿里聚安全的&lt;a href=&quot;https://jaq.alibaba.com/community/index.htm&quot; target=&quot;_blank&quot;&gt;官方博客&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Oct 2017 07:10:00 +0000</pubDate>
<dc:creator>阿里聚安全</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/alisecurity/p/7686781.html</dc:identifier>
</item>
<item>
<title>Spring 源码剖析IOC容器（一）概览 - 只会一点java</title>
<link>http://www.cnblogs.com/dennyzhangdd/p/7652075.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dennyzhangdd/p/7652075.html</guid>
<description>&lt;h2&gt;目录&lt;/h2&gt;
&lt;p&gt;一、容器概述&lt;/p&gt;
&lt;p&gt;二、核心类源码解读&lt;/p&gt;
&lt;p&gt;三、模拟容器获取Bean&lt;/p&gt;
&lt;p&gt;=======================&lt;/p&gt;
&lt;h2&gt;一、容器概述&lt;/h2&gt;
&lt;p&gt;spring IOC控制反转，又称为DI依赖注入：大体是先初始化bean再注入使用的过程。本系列默认JDK8源码。容器接口设计图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/584866/201710/584866-20171013110059980-1761797826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，可见主要有&lt;span&gt;&lt;strong&gt;两条主线&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.BeanFactory-》HierarchicalBeanFactory-》ConfigurableBeanFactory&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BeanFactory接口定义了基本的Ioc容器的规范，包括getBean()这样的Ioc容器的基本方法（通过这个方法可以从容器中取得Bean）。&lt;/li&gt;
&lt;li&gt;HierarchicalBeanFactory增加了getParentBeanFactory()的接口功能，使BeanFactory具备了双亲Ioc容器的管理功能。&lt;/li&gt;
&lt;li&gt;ConfigurableBeanFactory定义了一些配置功能，比如通过setParentBeanFactory()设置双亲Ioc容器，通过addBeanPostProcessor()配置Bean后置处理器，等等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;strong&gt;2.BeanFactory-》ListableBeanFactory-》ApplicationContext-》WebApplicationContext/ConfigurableApplicationContext&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ListableBeanFactory细化了许多BeanFactory的接口功能，比如定义了getBeanDefinitionNames()接口方法；&lt;/li&gt;
&lt;li&gt;ApplicationContext接口，它通过继承MessageSource、ResourcePatternResolver、ApplicationEventPublisher接口，在BeanFactory简单Ioc容器的基础上添加了许多对高级容器的特性支持。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;二、核心类源码解读&lt;/h2&gt;
&lt;h3&gt;2.1 BeanFactory接口&lt;/h3&gt;
&lt;p&gt;尊重源码，&lt;span&gt;&lt;span&gt;以下摘自&lt;span&gt;&lt;span&gt;BeanFactory&lt;/span&gt;&lt;/span&gt;源码注释翻译：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;BeanFactory是获取spring bean容器的顶级接口。该接口被持有一系列bean &lt;span&gt;&lt;span&gt;definitions的对象所实现。依赖bean definitions,工厂返回一个原型实例或者一个单例实例。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;通常，BeanFactory将加载存储在配置中的&lt;/span&gt;&lt;span&gt;&lt;span&gt;bean definitions资源(例如XML文档)。这些定义没有限制何种方式存储：LDAP, RDBMS, XML,properties file等。并且鼓励使用bean的依赖注入引用。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;实现类需要支持&lt;span&gt;&lt;strong&gt;Bean的完整生命周期&lt;/strong&gt;&lt;/span&gt;，完整的&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;初始化方法及其标准顺序（格式：接口 方法）&lt;/strong&gt;&lt;/span&gt;为:&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1.BeanNameAware setBeanName 设置bean名称&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.BeanClassLoaderAware setBeanClassLoader 设置bean类加载器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.BeanFactoryAware setBeanFactory 设置bean工厂&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.EnvironmentAware setEnvironment 设置环境：profiles+properties&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5.EmbeddedValueResolverAware setEmbeddedValueResolver 设置嵌入式值解析器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6.ResourceLoaderAware setResourceLoader 设置资源载入器，只适用于在应用程序上下文中运行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7.ApplicationEventPublisherAware setApplicationEventPublisher注入应用事件发布器ApplicationEventPublisher&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8.MessageSourceAware setMessageSource 设置国际化支持&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9.ApplicationContextAware setApplicationContext 设置应用上下文&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10.ServletContextAware setServletContext 设置servlet上下文&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11.BeanPostProcessors postProcessBeforeInitialization 执行bean处理器前置方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12.InitializingBean afterPropertiesSet 执行初始化Bean设置完属性后置方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13.&lt;/span&gt;&lt;span&gt;&lt;span&gt;a custom init-method definition 执行自定义初始化方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14.BeanPostProcessors postProcessAfterInitialization 执行&lt;/span&gt;&lt;span&gt;&lt;span&gt;bean处理器后置方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;销毁顺序：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;1.DestructionAwareBeanPostProcessors postProcessBeforeDestruction 销毁处理器的前置方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.DisposableBean destroy Bean销毁回调方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.a custom destroy-method definition 用户自定义销毁方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BeanFactory {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转定义符&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     String FACTORY_BEAN_PREFIX = &quot;&amp;amp;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义5种获取Bean方法&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     Object getBean(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &amp;lt;T&amp;gt; T getBean(String name, Class&amp;lt;T&amp;gt; requiredType) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException; 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     Object getBean(String name, Object... args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType, Object... args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断容器是否含有指定名字的Bean&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsBean(String name);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询指定名字的Bean是否是Singleton类型的Bean.&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; isSingleton(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询指定名字的Bean是否是Prototype类型的&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; isPrototype(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询指定了名字的Bean的Class类型是否是特定的Class类型.&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; isTypeMatch(String name, ResolvableType typeToMatch) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; isTypeMatch(String name, Class&amp;lt;?&amp;gt; typeToMatch) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询指定名字的Bean的Class类型.&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     Class&amp;lt;?&amp;gt; getType(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询指定了名字的Bean的所有别名，这些都是在BeanDefinition中定义的&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    String[] getAliases(String name);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.2 &lt;strong&gt;XmlBeanFactory实现类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;spring3.1之后推荐直接使用：DefaultListableBeanFactory+XmlBeanDefinitionReader（第三节有样例）。虽然这个类已废弃，但不妨碍我们来简单理解一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@&lt;span&gt;Deprecated
&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @SuppressWarnings({&quot;serial&quot;, &quot;all&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; XmlBeanFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; DefaultListableBeanFactory {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; XmlBeanDefinitionReader reader = &lt;span&gt;new&lt;/span&gt; XmlBeanDefinitionReader(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//载入资源构造&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; XmlBeanFactory(Resource resource) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;(resource, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//通过载入资源和&lt;span class=&quot;crayon-c&quot;&gt;父类的BeanFactory构造&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(parentBeanFactory);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.reader.loadBeanDefinitions(resource);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.在XmlBeanFactory中实例化了一个XmlBeanDefinitionReader，这个Reader对象就是用来处理以xml形式的持有类信息的&lt;strong&gt;&lt;strong&gt;BeanDefinitionl&lt;/strong&gt;&lt;/strong&gt;类。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;&lt;strong&gt;BeanDefinitionl&lt;/strong&gt;&lt;/strong&gt;信息封装成&lt;strong&gt;Resource&lt;/strong&gt;，作为构造入参&lt;/p&gt;
&lt;p&gt;3.调用reader的&lt;span&gt;loadBeanDefinitions&lt;/span&gt;，完成容器的初始化和注入。&lt;/p&gt;
&lt;h2&gt;三、模拟容器获取Bean&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.容器IOC获取bean初始化&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         ClassPathResource resource = &lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;spring.xml&quot;&lt;span&gt;);&lt;span&gt;//&lt;span&gt;&lt;span&gt;载入资源&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         DefaultListableBeanFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultListableBeanFactory();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         XmlBeanDefinitionReader reader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlBeanDefinitionReader(factory);&lt;span&gt;//&lt;/span&gt;构造reader
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        reader.&lt;span&gt;loadBeanDefinitions&lt;/span&gt;(resource);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心方法，解析bean定义
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         Dao dao = factory.&lt;span&gt;getBean&lt;/span&gt;(&quot;daoImpl&quot;, Dao.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);&lt;span&gt;&lt;span&gt;//IOC容器DefaultListableBeanFactory通过名称和类class获取bean单例对象&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         dao.select();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行Bean实例方法&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;
&lt;pre&gt;
spring.xml中就写一行：定义一个Bean即可&lt;br/&gt;&amp;lt;bean id=&quot;daoImpl&quot; class=&quot;spring.aop.xml.dao.impl.DaoImpl&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;本文概述IOC原理并分析了核心源码，最后结合一个简单例子，模拟了最简单的容器DefaultListableBeanFactory从xml载入bean定义并生成对象的过程。&lt;/p&gt;



&lt;p&gt;=======================&lt;/p&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;http://www.zzcode.cn/springioc/thread-39.html&lt;/p&gt;
</description>
<pubDate>Wed, 18 Oct 2017 07:08:00 +0000</pubDate>
<dc:creator>只会一点java</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dennyzhangdd/p/7652075.html</dc:identifier>
</item>
<item>
<title>EF框架搭建小总结--ModelFirst模型优先 - 天下！行</title>
<link>http://www.cnblogs.com/txqx/p/7685401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/txqx/p/7685401.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;span&gt;去年&lt;/span&gt;&lt;/span&gt;刚工作的时候，也是刚刚正式接触.net，当时了解了EF以及三种开发模式，Database First、Model First 、Code First。公司用的开发模式是Database First，由于公司有一套成熟的框架，我只需要按部就班的开发即可，因此就没有详细学习过这些开发模式，总觉得缺点什么。正好这段时间没有什么任务，并且在博客园浏览学习了很多大神的对技术、生活、职业、人生的一些总结，学习很多，这几天对这三种开发模式有了进一步的理解。我觉得我也该学着给大家分享一些知识了，就先趁热打铁，把我对 ModelFirst的实现过程加以总结、分享下来，若有不当之处，还望各路大神多多指教&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用工具：&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;win7操作系统，vs2012， sqlserver2008&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;开始：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1&lt;span&gt;.新建项目：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018100204224-788788686.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;2.在新建好的项目中新建ADO.NET实体数据模型，如下图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018101855849-1035108609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击新建项后，弹出如下窗口：选中ADO.NET实体数据模型，填好新建项的名称，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018102400974-390479630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 点击添加后，开始选择模型内容，我们选择空模型，点击完成按钮&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018103925771-1332845330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建完成后，在vs2012页面上会弹出edmx关系图，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018104457959-1770017373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.新增实体&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在edmx关系图的空白处单击鼠标右键，添加实体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018105134552-718941794.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在弹出的窗口中添加实体内容，下图是创建了一个student实体，主键为ID&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018110233787-1317543076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为实体添加属性：在student的属性上右键新增标量属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018110735162-1488456888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在添加属性后，右键选择属性，可以在右方的标记处对属性进行修改&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018111606756-1979224450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4 与数据库关联，生成相关数据表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在空白处单击右键，选择‘根据模型生成数据库’，弹出数据库连接窗口，点击新建连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018113728912-87501311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在弹出的窗口点击更改&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018113349209-145071141.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;选择Microsoft SQL Server,点击确定&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018113357068-307839310.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在弹出的窗口中，填入你的数据库相关信息&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018113405849-1069451894.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;连接成功后，单击下一步，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018113414615-930217059.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;在弹出的窗口上点击完成，成功与sql server关联&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018114405584-850260638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;完成上述操作后，Ctrl+Shift+S保存更新全部生成的页面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;执行生成的sql脚本，找到系统生成的sql脚本，右键执行，即可在关联数据库中创建表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018142418834-594455567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;生成的数据表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018142818756-427730430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;5 往数据表中添加数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Program类中添加代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ModelFirst
{
    class Program
    {
        static void Main(string[] args)
        {
            #region 添加数据
            //1.声明上下文
            ModelFirstContainer dbContext = new ModelFirstContainer();
            //2.对数据库的操作
            student st = new student();//实例化实体
           
            //为实体赋值
            st.ID = 1;
            st.NAME = &quot;张三&quot;;
            st.AGE = &quot;18&quot;;

            //增加实体到上下文
            dbContext.studentSet.Attach(st);
            dbContext.Entry(st).State = System.Data.EntityState.Added;

            //保存
            dbContext.SaveChanges();


            #endregion
        }
    }
}　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行程序后，在数据表中成功添加新的数据，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223156/201710/1223156-20171018144627052-82996067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 18 Oct 2017 06:48:00 +0000</pubDate>
<dc:creator>天下！行</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/txqx/p/7685401.html</dc:identifier>
</item>
<item>
<title>activemq的几种基本通信方式总结 - javaobject</title>
<link>http://www.cnblogs.com/a8457013/p/7686459.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/a8457013/p/7686459.html</guid>
<description>&lt;p&gt;     在前面一篇文章里讨论过几种应用系统集成的方式，发现实际上面向消息队列的集成方案算是一个总体比较合理的选择。这里，我们先针对具体的一个消息队列Activemq的基本通信方式进行探讨。activemq是JMS消息通信规范的一个实现。总的来说，消息规范里面定义最常见的几种消息通信模式主要有发布-订阅、点对点这两种。另外，通过结合这些模式的具体应用，我们在处理某些应用场景的时候也衍生出来了一种请求应答的模式。下面，我们针对这几种方式一一讨论一下。&lt;/p&gt;


&lt;p&gt;    在讨论具体方式的时候，我们先看看使用activemq需要启动服务的主要过程。&lt;/p&gt;
&lt;p&gt;    按照JMS的规范，我们首先需要获得一个JMS connection factory.，通过这个connection factory来创建connection.在这个基础之上我们再创建session, destination, producer和consumer。因此主要的几个步骤如下：&lt;/p&gt;
&lt;p&gt;1. 获得JMS connection factory. 通过我们提供特定环境的连接信息来构造factory。&lt;/p&gt;
&lt;p&gt;2. 利用factory构造JMS connection&lt;/p&gt;
&lt;p&gt;3. 启动connection&lt;/p&gt;
&lt;p&gt;4. 通过connection创建JMS session.&lt;/p&gt;
&lt;p&gt;5. 指定JMS destination.&lt;/p&gt;
&lt;p&gt;6. 创建JMS producer或者创建JMS message并提供destination.&lt;/p&gt;
&lt;p&gt;7. 创建JMS consumer或注册JMS message listener.&lt;/p&gt;
&lt;p&gt;8. 发送和接收JMS message.&lt;/p&gt;
&lt;p&gt;9. 关闭所有JMS资源，包括connection, session, producer, consumer等。&lt;/p&gt;


&lt;p&gt;     发布订阅模式有点类似于我们日常生活中订阅报纸。每年到年尾的时候，邮局就会发一本报纸集合让我们来选择订阅哪一个。在这个表里头列了所有出版发行的报纸，那么对于我们每一个订阅者来说，我们可以选择一份或者多份报纸。比如北京日报、潇湘晨报等。那么这些个我们订阅的报纸，就相当于发布订阅模式里的topic。有很多个人订阅报纸，也有人可能和我订阅了相同的报纸。那么，在这里，相当于我们在同一个topic里注册了。对于一份报纸发行方来说，它和所有的订阅者就构成了一个1对多的关系。这种关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;magplus&quot; title=&quot;点击查看原始大小图片&quot; src=&quot;http://dl2.iteye.com/upload/attachment/0086/5400/605c3d41-70af-3c3c-8f9d-0077a252964e.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;448&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     现在，假定我们用前面讨论的场景来写一个简单的示例。我们首先需要定义的是publisher.&lt;/p&gt;
&lt;h2&gt;publisher&lt;/h2&gt;
&lt;p&gt;     publisher是属于发布信息的一方，它通过定义一个或者多个topic，然后给这些topic发送消息。&lt;/p&gt;
&lt;p&gt;    publisher的构造函数如下：&lt;/p&gt;
&lt;div id=&quot;&quot; class=&quot;dp-highlighter&quot;&gt;

&lt;ol class=&quot;dp-j&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;public Publisher() &lt;span class=&quot;keyword&quot;&gt;throws JMSException {  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        factory = &lt;span class=&quot;keyword&quot;&gt;new ActiveMQConnectionFactory(brokerURL);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        connection = factory.createConnection();  &lt;/li&gt;
&lt;li&gt;        &lt;span class=&quot;keyword&quot;&gt;try {  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        connection.start();  &lt;/li&gt;
&lt;li&gt;        } &lt;span class=&quot;keyword&quot;&gt;catch (JMSException jmse) {  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            connection.close();  &lt;/li&gt;
&lt;li&gt;            &lt;span class=&quot;keyword&quot;&gt;throw jmse;  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        }  &lt;/li&gt;
&lt;li&gt;        session = connection.createSession(&lt;span class=&quot;keyword&quot;&gt;false, Session.AUTO_ACKNOWLEDGE);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        producer = session.createProducer(&lt;span class=&quot;keyword&quot;&gt;null);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    }  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;     我们按照前面说的流程定义了基本的connectionFactory, connection, session, producer。这里代码就是主要实现初始化的效果。&lt;/p&gt;
&lt;p&gt;    接着，我们需要定义一系列的topic让所有的consumer来订阅，设置topic的代码如下：&lt;/p&gt;
&lt;div id=&quot;&quot; class=&quot;dp-highlighter&quot;&gt;

&lt;ol class=&quot;dp-j&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;protected &lt;span class=&quot;keyword&quot;&gt;void setTopics(String[] stocks) &lt;span class=&quot;keyword&quot;&gt;throws JMSException {  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    destinations = &lt;span class=&quot;keyword&quot;&gt;new Destination[stocks.length];  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;for(&lt;span class=&quot;keyword&quot;&gt;int i = &lt;span class=&quot;number&quot;&gt;0; i &amp;lt; stocks.length; i++) {  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        destinations[i] = session.createTopic(&lt;span class=&quot;string&quot;&gt;&quot;STOCKS.&quot; + stocks[i]);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    }  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;     这里destinations是一个内部定义的成员变量Destination[]。这里我们总共定义了的topic数取决于给定的参数stocks。&lt;/p&gt;
&lt;p&gt;     在定义好topic之后我们要给这些指定的topic发消息，具体实现的代码如下：&lt;/p&gt;
&lt;div id=&quot;&quot; class=&quot;dp-highlighter&quot;&gt;

&lt;ol class=&quot;dp-j&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;protected &lt;span class=&quot;keyword&quot;&gt;void sendMessage(String[] stocks) &lt;span class=&quot;keyword&quot;&gt;throws JMSException {  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;for(&lt;span class=&quot;keyword&quot;&gt;int i = &lt;span class=&quot;number&quot;&gt;0; i &amp;lt; stocks.length; i++) {  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        Message message = createStockMessage(stocks[i], session);  &lt;/li&gt;
&lt;li&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Sending: &quot; + ((ActiveMQMapMessage)message).getContentMap() + &lt;span class=&quot;string&quot;&gt;&quot; on destination: &quot; + destinations[i]);  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        producer.send(destinations[i], message);  &lt;/li&gt;
&lt;li&gt;    }  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;protected Message createStockMessage(String stock, Session session) &lt;span class=&quot;keyword&quot;&gt;throws JMSException {  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    MapMessage message = session.createMapMessage();  &lt;/li&gt;
&lt;li&gt;    message.setString(&lt;span class=&quot;string&quot;&gt;&quot;stock&quot;, stock);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    message.setDouble(&lt;span class=&quot;string&quot;&gt;&quot;price&quot;, &lt;span class=&quot;number&quot;&gt;1.00);  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    message.setDouble(&lt;span class=&quot;string&quot;&gt;&quot;offer&quot;, &lt;span class=&quot;number&quot;&gt;0.01);  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    message.setBoolean(&lt;span class=&quot;string&quot;&gt;&quot;up&quot;, &lt;span class=&quot;keyword&quot;&gt;true);  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;          &lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;return message;  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;     前面的代码很简单，在sendMessage方法里我们遍历每个topic，然后给每个topic发送定义的Message消息。&lt;/p&gt;
&lt;p&gt;    在定义好前面发送消息的基础之后，我们调用他们的代码就很简单了：&lt;/p&gt;
&lt;div id=&quot;&quot; class=&quot;dp-highlighter&quot;&gt;

&lt;ol class=&quot;dp-j&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;public &lt;span class=&quot;keyword&quot;&gt;static &lt;span class=&quot;keyword&quot;&gt;void main(String[] args) &lt;span class=&quot;keyword&quot;&gt;throws JMSException {  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;if(args.length &amp;lt; &lt;span class=&quot;number&quot;&gt;1)  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        &lt;span class=&quot;keyword&quot;&gt;throw &lt;span class=&quot;keyword&quot;&gt;new IllegalArgumentException();  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;      &lt;/li&gt;
&lt;li&gt;        &lt;/li&gt;
&lt;li&gt;        Publisher publisher = &lt;span class=&quot;keyword&quot;&gt;new Publisher();  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;          &lt;/li&gt;
&lt;li&gt;        &lt;/li&gt;
&lt;li&gt;    publisher.setTopics(args);  &lt;/li&gt;
&lt;li&gt;          &lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;for(&lt;span class=&quot;keyword&quot;&gt;int i = &lt;span class=&quot;number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10; i++) {  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        publisher.sendMessage(args);  &lt;/li&gt;
&lt;li&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Publisher '&quot; + i + &lt;span class=&quot;string&quot;&gt;&quot; price messages&quot;);  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        &lt;span class=&quot;keyword&quot;&gt;try {  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            Thread.sleep(&lt;span class=&quot;number&quot;&gt;1000);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        } &lt;span class=&quot;keyword&quot;&gt;catch(InterruptedException e) {  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            e.printStackTrace();  &lt;/li&gt;
&lt;li&gt;        }  &lt;/li&gt;
&lt;li&gt;    }  &lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li&gt;    publisher.close();  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;     调用他们的代码就是我们遍历所有topic，然后通过sendMessage发送消息。在发送一个消息之后先sleep1秒钟。要注意的一个地方就是我们使用完资源之后必须要使用close方法将这些资源关闭释放。close方法关闭资源的具体实现如下：&lt;/p&gt;
&lt;div id=&quot;&quot; class=&quot;dp-highlighter&quot;&gt;

&lt;ol class=&quot;dp-j&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;public &lt;span class=&quot;keyword&quot;&gt;void close() &lt;span class=&quot;keyword&quot;&gt;throws JMSException {  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;if (connection != &lt;span class=&quot;keyword&quot;&gt;null) {  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        connection.close();  &lt;/li&gt;
&lt;li&gt;     }  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;h2&gt;consumer&lt;/h2&gt;
&lt;p&gt;    Consumer的代码也很类似，具体的步骤无非就是1.初始化资源。 2. 接收消息。 3. 必要的时候关闭资源。&lt;/p&gt;
&lt;p&gt;    初始化资源可以放到构造函数里面：&lt;/p&gt;
&lt;div id=&quot;&quot; class=&quot;dp-highlighter&quot;&gt;

&lt;ol class=&quot;dp-j&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;public Consumer() &lt;span class=&quot;keyword&quot;&gt;throws JMSException {  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        factory = &lt;span class=&quot;keyword&quot;&gt;new ActiveMQConnectionFactory(brokerURL);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        connection = factory.createConnection();  &lt;/li&gt;
&lt;li&gt;        connection.start();  &lt;/li&gt;
&lt;li&gt;        session = connection.createSession(&lt;span class=&quot;keyword&quot;&gt;false, Session.AUTO_ACKNOWLEDGE);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    }  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;     接收和处理消息的方法有两种，分为同步和异步的，一般同步的方式我们是通过MessageConsumer.receive()方法来处理接收到的消息。而异步的方法则是通过注册一个MessageListener的方法，使用MessageConsumer.setMessageListener()。这里我们采用异步的方式实现：&lt;/p&gt;
&lt;div id=&quot;&quot; class=&quot;dp-highlighter&quot;&gt;

&lt;ol class=&quot;dp-j&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;public &lt;span class=&quot;keyword&quot;&gt;static &lt;span class=&quot;keyword&quot;&gt;void main(String[] args) &lt;span class=&quot;keyword&quot;&gt;throws JMSException {  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    Consumer consumer = &lt;span class=&quot;keyword&quot;&gt;new Consumer();  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;for (String stock : args) {  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    Destination destination = consumer.getSession().createTopic(&lt;span class=&quot;string&quot;&gt;&quot;STOCKS.&quot; + stock);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    MessageConsumer messageConsumer = consumer.getSession().createConsumer(destination);  &lt;/li&gt;
&lt;li&gt;    messageConsumer.setMessageListener(&lt;span class=&quot;keyword&quot;&gt;new Listener());  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    }  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;li&gt;      &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;public Session getSession() {  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;return session;  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;     在前面的代码里我们先找到同样的topic,然后遍历所有的topic去获得消息。对于消息的处理我们专门通过Listener对象来负责。&lt;/p&gt;
&lt;p&gt;    Listener对象的职责很简单，主要就是处理接收到的消息：&lt;/p&gt;
&lt;div id=&quot;&quot; class=&quot;dp-highlighter&quot;&gt;

&lt;ol class=&quot;dp-j&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;public &lt;span class=&quot;keyword&quot;&gt;class Listener &lt;span class=&quot;keyword&quot;&gt;implements MessageListener {  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;public &lt;span class=&quot;keyword&quot;&gt;void onMessage(Message message) {  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        &lt;span class=&quot;keyword&quot;&gt;try {  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            MapMessage map = (MapMessage)message;  &lt;/li&gt;
&lt;li&gt;            String stock = map.getString(&lt;span class=&quot;string&quot;&gt;&quot;stock&quot;);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            &lt;span class=&quot;keyword&quot;&gt;double price = map.getDouble(&lt;span class=&quot;string&quot;&gt;&quot;price&quot;);  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            &lt;span class=&quot;keyword&quot;&gt;double offer = map.getDouble(&lt;span class=&quot;string&quot;&gt;&quot;offer&quot;);  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            &lt;span class=&quot;keyword&quot;&gt;boolean up = map.getBoolean(&lt;span class=&quot;string&quot;&gt;&quot;up&quot;);  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            DecimalFormat df = &lt;span class=&quot;keyword&quot;&gt;new DecimalFormat( &lt;span class=&quot;string&quot;&gt;&quot;#,###,###,##0.00&quot; );  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            System.out.println(stock + &lt;span class=&quot;string&quot;&gt;&quot;\t&quot; + df.format(price) + &lt;span class=&quot;string&quot;&gt;&quot;\t&quot; + df.format(offer) + &lt;span class=&quot;string&quot;&gt;&quot;\t&quot; + (up?&lt;span class=&quot;string&quot;&gt;&quot;up&quot;:&lt;span class=&quot;string&quot;&gt;&quot;down&quot;));  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        } &lt;span class=&quot;keyword&quot;&gt;catch (Exception e) {  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            e.printStackTrace();  &lt;/li&gt;
&lt;li&gt;        }  &lt;/li&gt;
&lt;li&gt;    }  &lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;    它实现了MessageListener接口，里面的onMessage方法就是在接收到消息之后会被调用的方法。&lt;/p&gt;
&lt;p&gt;    现在，通过实现前面的publisher和consumer我们已经实现了pub-sub模式的一个实例。仔细回想它的步骤的话，主要就是要两者设定一个共同的topic，有了这个topic之后他们可以实现一方发消息另外一方接收。另外，为了连接到具体的message server,这里是使用了连接tcp://localhost:16161作为定义ActiveMQConnectionFactory的路径。在publisher端通过session创建producer，根据指定的参数创建destination，然后将消息和destination作为producer.send()方法的参数发消息。在consumer端也要创建类似的connection, session。通过session得到destination，再通过session.createConsumer(destination)来得到一个MessageConsumer对象。有了这个MessageConsumer我们就可以自行选择是直接同步的receive消息还是注册listener了。&lt;/p&gt;

&lt;p&gt;    p2p的过程则理解起来更加简单。它好比是两个人打电话，这两个人是独享这一条通信链路的。一方发送消息，另外一方接收，就这么简单。在实际应用中因为有多个用户对使用p2p的链路，它的通信场景如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;magplus&quot; title=&quot;点击查看原始大小图片&quot; src=&quot;http://dl2.iteye.com/upload/attachment/0086/5406/847f46bb-3d45-3e6f-b663-05669360c5b1.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;435&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    我们再来看看一个p2p的示例：&lt;/p&gt;
&lt;p&gt;    在p2p的场景里，相互通信的双方是通过一个类似于队列的方式来进行交流。和前面pub-sub的区别在于一个topic有一个发送者和多个接收者，而在p2p里一个queue只有一个发送者和一个接收者。&lt;/p&gt;
&lt;h2&gt;发送者&lt;/h2&gt;
&lt;p&gt;    和前面的示例非常相似，我们构造函数里需要初始化的内容基本上差不多：&lt;/p&gt;

&lt;div id=&quot;&quot; class=&quot;dp-highlighter&quot;&gt;

&lt;ol class=&quot;dp-j&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;public Publisher() &lt;span class=&quot;keyword&quot;&gt;throws JMSException {  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    factory = &lt;span class=&quot;keyword&quot;&gt;new ActiveMQConnectionFactory(brokerURL);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    connection = factory.createConnection();  &lt;/li&gt;
&lt;li&gt;    connection.start();  &lt;/li&gt;
&lt;li&gt;    session = connection.createSession(&lt;span class=&quot;keyword&quot;&gt;false, Session.AUTO_ACKNOWLEDGE);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    producer = session.createProducer(&lt;span class=&quot;keyword&quot;&gt;null);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
     发送消息的方法如下：


&lt;div id=&quot;&quot; class=&quot;dp-highlighter&quot;&gt;

&lt;ol class=&quot;dp-j&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;public &lt;span class=&quot;keyword&quot;&gt;void sendMessage() &lt;span class=&quot;keyword&quot;&gt;throws JMSException {  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;for(&lt;span class=&quot;keyword&quot;&gt;int i = &lt;span class=&quot;number&quot;&gt;0; i &amp;lt; jobs.length; i++)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    {  &lt;/li&gt;
&lt;li&gt;        String job = jobs[i];  &lt;/li&gt;
&lt;li&gt;        Destination destination = session.createQueue(&lt;span class=&quot;string&quot;&gt;&quot;JOBS.&quot; + job);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        Message message = session.createObjectMessage(i);  &lt;/li&gt;
&lt;li&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Sending: id: &quot; + ((ObjectMessage)message).getObject() + &lt;span class=&quot;string&quot;&gt;&quot; on queue: &quot; + destination);  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        producer.send(destination, message);  &lt;/li&gt;
&lt;li&gt;    }  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
     这里我们定义了一个jobs的数组，通过遍历这个数组来创建不同的job queue。这样就相当于建立了多个点对点通信的链路。

&lt;p&gt;    消息发送者的启动代码如下：&lt;/p&gt;

&lt;div id=&quot;&quot; class=&quot;dp-highlighter&quot;&gt;

&lt;ol class=&quot;dp-j&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;public &lt;span class=&quot;keyword&quot;&gt;static &lt;span class=&quot;keyword&quot;&gt;void main(String[] args) &lt;span class=&quot;keyword&quot;&gt;throws JMSException {  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    Publisher publisher = &lt;span class=&quot;keyword&quot;&gt;new Publisher();  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;for(&lt;span class=&quot;keyword&quot;&gt;int i = &lt;span class=&quot;number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10; i++) {  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        publisher.sendMessage();  &lt;/li&gt;
&lt;li&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Published &quot; + i + &lt;span class=&quot;string&quot;&gt;&quot; job messages&quot;);  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;try {  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            Thread.sleep(&lt;span class=&quot;number&quot;&gt;1000);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        } &lt;span class=&quot;keyword&quot;&gt;catch (InterruptedException x) {  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        e.printStackTrace();  &lt;/li&gt;
&lt;li&gt;        }  &lt;/li&gt;
&lt;li&gt;    }  &lt;/li&gt;
&lt;li&gt;    publisher.close();  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
     我们在这里发送10条消息，当然，在每个sendMessage的方法里实际上是针对每个queue发送了10条。


&lt;h2&gt;接收者&lt;/h2&gt;
&lt;p&gt;     接收者的代码很简单，一个构造函数初始化所有的资源：&lt;/p&gt;

&lt;div id=&quot;&quot; class=&quot;dp-highlighter&quot;&gt;

&lt;ol class=&quot;dp-j&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;public Consumer() &lt;span class=&quot;keyword&quot;&gt;throws JMSException {  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        factory = &lt;span class=&quot;keyword&quot;&gt;new ActiveMQConnectionFactory(brokerURL);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        connection = factory.createConnection();  &lt;/li&gt;
&lt;li&gt;        connection.start();  &lt;/li&gt;
&lt;li&gt;        session = connection.createSession(&lt;span class=&quot;keyword&quot;&gt;false, Session.AUTO_ACKNOWLEDGE);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    }  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
    还有一个就是注册消息处理的对象：


&lt;div id=&quot;&quot; class=&quot;dp-highlighter&quot;&gt;

&lt;ol class=&quot;dp-j&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;public &lt;span class=&quot;keyword&quot;&gt;static &lt;span class=&quot;keyword&quot;&gt;void main(String[] args) &lt;span class=&quot;keyword&quot;&gt;throws JMSException {  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        Consumer consumer = &lt;span class=&quot;keyword&quot;&gt;new Consumer();  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        &lt;span class=&quot;keyword&quot;&gt;for (String job : consumer.jobs) {  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            Destination destination = consumer.getSession().createQueue(&lt;span class=&quot;string&quot;&gt;&quot;JOBS.&quot; + job);  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            MessageConsumer messageConsumer = consumer.getSession().createConsumer(destination);  &lt;/li&gt;
&lt;li&gt;            messageConsumer.setMessageListener(&lt;span class=&quot;keyword&quot;&gt;new Listener(job));  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        }  &lt;/li&gt;
&lt;li&gt;    }  &lt;/li&gt;
&lt;li&gt;      &lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;public Session getSession() {  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        &lt;span class=&quot;keyword&quot;&gt;return session;  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    }  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
     具体注册的对象处理方法和前面还是类似，实现MessageListener接口就可以了。</description>
<pubDate>Wed, 18 Oct 2017 06:21:00 +0000</pubDate>
<dc:creator>javaobject</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/a8457013/p/7686459.html</dc:identifier>
</item>
<item>
<title>C#多线程 - 番茄你个西红柿|</title>
<link>http://www.cnblogs.com/lbczzvv/p/7686365.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lbczzvv/p/7686365.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、使用线程的理由&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、可以使用线程将代码同其他代码隔离，提高应用程序的可靠性。&lt;/p&gt;
&lt;p&gt;2、可以使用线程来简化编码。&lt;/p&gt;
&lt;p&gt;3、可以使用线程来实现并发执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、基本知识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、进程与线程：进程作为操作系统执行程序的基本单位，拥有应用程序的资源，进程包含线程，进程的资源被线程共享，线程不拥有资源。&lt;/p&gt;
&lt;p&gt;2、前台线程和后台线程：通过Thread类新建线程默认为前台线程。当所有前台线程关闭时，所有的后台线程也会被直接终止，不会抛出异常。&lt;/p&gt;
&lt;p&gt;3、挂起（Suspend）和唤醒（Resume）：由于线程的执行顺序和程序的执行情况不可预知，所以使用挂起和唤醒容易发生死锁的情况，在实际应用中应该尽量少用。&lt;/p&gt;
&lt;p&gt;4、阻塞线程：Join，阻塞调用线程，直到该线程终止。&lt;/p&gt;
&lt;p&gt;5、终止线程：Abort：抛出 ThreadAbortException 异常让线程终止，终止后的线程不可唤醒。Interrupt：抛出 ThreadInterruptException 异常让线程终止，通过捕获异常可以继续执行。&lt;/p&gt;
&lt;p&gt;6、线程优先级：AboveNormal BelowNormal Highest Lowest Normal，默认为Normal。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、线程的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程函数通过委托传递，可以不带参数，也可以带参数（只能有一个参数），可以用一个类或结构体封装参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Test
{
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
Thread t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadStart(TestMethod));
Thread t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParameterizedThreadStart(TestMethod));
t1.IsBackground &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
t2.IsBackground &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
t1.Start();
t2.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
Console.ReadKey();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestMethod()
{
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不带参数的线程函数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TestMethod(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; data)
{
&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; datastr = data &lt;span&gt;as&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;带参数的线程函数，参数为：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, datastr);
}
} 
}&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;四、线程池&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于线程的创建和销毁需要耗费一定的开销，过多的使用线程会造成内存资源的浪费，出于对性能的考虑，于是引入了线程池的概念。线程池维护一个请求队列，线程池的代码从队列提取任务，然后委派给线程池的一个线程执行，线程执行完不会被立即销毁，这样既可以在后台执行任务，又可以减少线程创建和销毁所带来的开销。&lt;/p&gt;
&lt;p&gt;线程池线程默认为后台线程（IsBackground）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Test
{
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将工作项加入到线程池队列中，这里可以传递一个线程参数&lt;/span&gt;
ThreadPool.QueueUserWorkItem(TestMethod, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
Console.ReadKey();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TestMethod(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; data)
{
&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; datastr = data &lt;span&gt;as&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
Console.WriteLine(datastr);
}
}
}&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;五、Task类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用ThreadPool的QueueUserWorkItem()方法发起一次异步的线程执行很简单，但是该方法最大的问题是没有一个内建的机制让你知道操作什么时候完成，有没有一个内建的机制在操作完成后获得一个返回值。为此，可以使用System.Threading.Tasks中的Task类。&lt;/p&gt;
&lt;p&gt;构造一个Task&amp;lt;TResult&amp;gt;对象，并为泛型TResult参数传递一个操作的返回类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Test
{
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
Task&lt;/span&gt;&amp;lt;Int32&amp;gt; t = &lt;span&gt;new&lt;/span&gt; Task&amp;lt;Int32&amp;gt;(n =&amp;gt; Sum((Int32)n), &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
t.Start();
t.Wait();
Console.WriteLine(t.Result);
Console.ReadKey();
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Int32 Sum(Int32 n)
{
Int32 sum &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (; n &amp;gt; &lt;span&gt;0&lt;/span&gt;; --&lt;span&gt;n)
&lt;/span&gt;&lt;span&gt;checked&lt;/span&gt;{ sum += n;} &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结果太大，抛出异常&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sum;
}
}
}&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;一个任务完成时，自动启动一个新任务。&lt;br/&gt;一个任务完成后，它可以启动另一个任务，下面重写了前面的代码，不阻塞任何线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Test
{
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
Task&lt;/span&gt;&amp;lt;Int32&amp;gt; t = &lt;span&gt;new&lt;/span&gt; Task&amp;lt;Int32&amp;gt;(n =&amp;gt; Sum((Int32)n), &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
t.Start();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t.Wait();&lt;/span&gt;
Task cwt = t.ContinueWith(task =&amp;gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The result is {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,t.Result));
Console.ReadKey();
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Int32 Sum(Int32 n)
{
Int32 sum &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (; n &amp;gt; &lt;span&gt;0&lt;/span&gt;; --&lt;span&gt;n)
&lt;/span&gt;&lt;span&gt;checked&lt;/span&gt;{ sum += n;} &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结果溢出，抛出异常&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sum;
}
}
}&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;六、委托异步执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;委托的异步调用：BeginInvoke() 和 EndInvoke()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Test
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MyDelegate(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; data);
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
MyDelegate mydelegate &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyDelegate(TestMethod);
IAsyncResult result &lt;/span&gt;= mydelegate.BeginInvoke(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Thread Param&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TestCallback, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Callback Param&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步执行完成&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt; resultstr =&lt;span&gt; mydelegate.EndInvoke(result);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程函数&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TestMethod(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; data)
{
&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; datastr = data &lt;span&gt;as&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; datastr;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步回调函数&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestCallback(IAsyncResult data)
{
Console.WriteLine(data.AsyncState);
}
}
}&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;七、线程同步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1）原子操作（Interlocked）：所有方法都是执行一次原子读取或一次写入操作。&lt;/p&gt;
&lt;p&gt;　　2）lock()语句：避免锁定public类型，否则实例将超出代码控制的范围，定义private对象来锁定。&lt;/p&gt;
&lt;p&gt;　　3）Monitor实现线程同步&lt;/p&gt;
&lt;p&gt;　　　　通过Monitor.Enter() 和 Monitor.Exit()实现排它锁的获取和释放，获取之后独占资源，不允许其他线程访问。&lt;/p&gt;
&lt;p&gt;　　　　还有一个TryEnter方法，请求不到资源时不会阻塞等待，可以设置超时时间，获取不到直接返回false。&lt;/p&gt;
&lt;p&gt;　　4）ReaderWriterLock&lt;/p&gt;
&lt;p&gt;　　　　当对资源操作读多写少的时候，为了提高资源的利用率，让读操作锁为共享锁，多个线程可以并发读取资源，而写操作为独占锁，只允许一个线程操作。&lt;/p&gt;
&lt;p&gt;　　5）事件（Event）类实现同步&lt;/p&gt;
&lt;p&gt;　　　　事件类有两种状态，终止状态和非终止状态，终止状态时调用WaitOne可以请求成功，通过Set将时间状态设置为终止状态。&lt;/p&gt;
&lt;p&gt;　　　　1）AutoResetEvent（自动重置事件）&lt;/p&gt;
&lt;p&gt;　　　　2）ManualResetEvent（手动重置事件）&lt;/p&gt;
&lt;p&gt;　　6）信号量（Semaphore）&lt;/p&gt;
&lt;p&gt;　　　　　　信号量是由内核对象维护的int变量，为0时，线程阻塞，大于0时解除阻塞，当一个信号量上的等待线程解除阻塞后，信号量计数+1。&lt;/p&gt;
&lt;p&gt;　　　　　　线程通过WaitOne将信号量减1，通过Release将信号量加1，使用很简单。&lt;/p&gt;
&lt;p&gt;　　7）互斥体（Mutex）&lt;/p&gt;
&lt;p&gt;　　　　　　独占资源，用法与Semaphore相似。&lt;/p&gt;
&lt;p&gt; 　 8）跨进程间的同步&lt;/p&gt;
&lt;p&gt;　　　　　　通过设置同步对象的名称就可以实现系统级的同步，不同应用程序通过同步对象的名称识别不同同步对象。&lt;/p&gt;


</description>
<pubDate>Wed, 18 Oct 2017 06:03:00 +0000</pubDate>
<dc:creator>番茄你个西红柿|</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lbczzvv/p/7686365.html</dc:identifier>
</item>
<item>
<title>AlexNet 网络详解及Tensorflow实现源码 - 行动派Xdpie</title>
<link>http://www.cnblogs.com/vipyoumay/p/7686230.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vipyoumay/p/7686230.html</guid>
<description>&lt;p&gt;&lt;strong&gt;版权声明：本文为博主原创文章，未经博主允许不得转载。&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;一张图片是由一个个像素组成，每个像素的颜色常常用RGB、HSB、CYMK、RGBA等颜色值来表示，每个颜色值的取值范围不一样，但都代表了一个像素点数据信息。对图片的数据处理过程中，RGB使用得最多，RGB表示红绿蓝三通道色，取值范围为0~255，所以一个像素点可以把它看作是一个三维数组，即：&lt;code&gt;array([[[0, 255, 255]]])&lt;/code&gt;，三个数值分布表示R、G、B（红、绿、蓝）的颜色值。比如下图一张3*3大小的jpg格式的图片:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-08-13-48-58.png&quot; alt=&quot;2017-10-08-13-48-58&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它的图片经过Tensorflow解码后，数据值输出为&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;image_path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'images/image.jpg'&lt;/span&gt;
filename_queue &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.train.string_input_producer(tf.train.match_filenames_once(image_path))
image_reader &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.WholeFileReader()
_,image_file &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; image_reader.read(filename_queue)
image &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.image.decode_jpeg(image_file)  &lt;span class=&quot;co&quot;&gt;# 如果是png格式的图片，使用tf.image.decode_png()&lt;/span&gt;
sess.run(image)


&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;result

array([[[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;], [&lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;], [&lt;span class=&quot;dv&quot;&gt;254&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]],
       [[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;191&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;], [&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;108&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;233&lt;/span&gt;], [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;191&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]],
       [[&lt;span class=&quot;dv&quot;&gt;254&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;], [&lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;], [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图片的数据处理不仅仅就是把RGB值转换成运算需要的值，还包括调整图片大小、图片截取、图片翻转、图片色彩调整，标注框、多线程处理图片等等，在这里就不一一介绍了，但是对于图片的处理是进行卷积网络的首要任务，你需要了解，并学会对图片的相关操作。这里只介绍RGB值的转换，为下一节的卷积提供数据支持。&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;卷积神经网络（CNN）的基本架构通常包括卷积层，池化层，全链层三大层次，其中不同的层中可能还会包括一些非线性变化（RELU函数）、数据归一化处理、dropoout等。我们常听说的LeNet-5、AlexNet、VGG、ResNet等都是卷积神经网络，而且都是由这些层组成，只是每个网络的层数不一样，所达到的分类效果也不一样。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;卷积层&quot;&gt;2.1. 卷积层&lt;/h2&gt;
&lt;p&gt;卷积层是整个神经网络中最重要的一层，该层最核心的部分为过滤器，或者称为卷积核，卷积核有大小和深度两个属性，大小常用的有3X3、5X5，也有11X11的卷积核，而深度通俗一点理解就是卷积核的个数。卷积核的大小和深度均由人工指定，而权重参数则在初始化的时候由程序随机生成，并在后期训练过程中不断优化这些权重值，以达到最好的分类效果。卷积的过程就是用这些权重值不断的去乘这些图片的RGB值，以提取图片数据信息。下面的动图完美地诠释了卷积是怎么发生的：&lt;br/&gt;&lt;img src=&quot;http://www.omegaxy.com/Pictures/CNN/Convolution_schematic.gif&quot; alt=&quot;2017-10-08-15-05-31&quot;/&gt;&lt;br/&gt;上面黄色3X3大小不停移动的就是卷积核，绿色部分是5X5的输入矩阵，粉色部分是卷积后的结果，称作特征值。从上面动图看出，卷积不仅提取了图片信息，也可以达到降维效果。如果希望卷积后的特征值维度和原图片一致，需要设置&lt;code&gt;padding&lt;/code&gt;值（全零填充）为&lt;code&gt;SAME&lt;/code&gt;（如果为&lt;code&gt;VALID&lt;/code&gt;表示不填充），其中&lt;code&gt;i&lt;/code&gt;为输入图片，&lt;code&gt;k&lt;/code&gt;为卷积核大小，&lt;code&gt;strides&lt;/code&gt;为移动步长（移动步长&amp;gt;1也可以达到降维的效果）。&lt;/p&gt;
&lt;pre class=&quot;pythong&quot;&gt;
&lt;code&gt;tf.nn.conv2d(i, k,strides,padding='VALID')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在卷积层中，过滤器中的参数是共享的，即一个过滤器中的参数值在对所有图片数据进行卷积过程中保持不变，这样卷积层的参数个数就和图片大小无关，它只和过滤器的尺寸，深度，以及当前层节点的矩阵深度有关。比如，以手写图片为例，输入矩阵的维度是28X28X1，假设第一层卷积层使用的过滤器大小为5X5，深度为16，则该卷积层的参数个数为5X5X1X16+16=416个，而如果使用500个隐藏节点的全链层会有1.5百万个参数，相比之下，卷积层的参数个数远远小于全链层，这就是为什么卷积网络广泛用于图片识别上的原因。&lt;/p&gt;
&lt;p&gt;对于卷积后的矩阵大小，有一个计算公式，如果使用了全0填充，则卷积后的矩阵大小为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[out_{length}=\left \lceil in_{length}/stride_{length} \right \rceil\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[out_{width}=\left \lceil in_{width}/stride_{width} \right \rceil\]&lt;/span&gt;&lt;br/&gt;即输出矩阵的长等于输入矩阵长度除以长度方向上的步长，并向上取整数值；输出矩阵的宽度等于输入矩阵的宽度除以宽度方向上的步长，并向上取整数值。&lt;br/&gt;如果不使用全0填充，则输出矩阵的大小为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[out_{length}=\left \lceil (in_{length}-filter_{length}+1)/stride_{length} \right \rceil\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[out_{width}=\left \lceil (in_{width}-filter_{width}+1)/stride_{width} \right \rceil\]&lt;/span&gt;&lt;br/&gt;卷积计算完成后，往往会加入一个修正线性单元ReLU函数，也就是把数据非线性化。为什么要把数据进行非线性化呢，这是因为非线性代表了输入和输出的关系是一条曲线而不是直线，曲线能够刻画输入中更为复杂的变化。比如一个输入值大部分时间都很稳定，但有可能会在某个时间点出现极值，但是通过ReLU函数以后，数据变得平滑，这样以便对复杂的数据进行训练。&lt;br/&gt;ReLU是分段线性的，当输入为非负时，输出将与输入相同；而当输入为负时，输出均为0。它的优点在于不受“梯度消失”的影响，且取值范围为[0,+∞]；其缺点在于当使用了较大的学习速率时，易受达到饱和的神经元的影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-09-15-39-32.png&quot; alt=&quot;2017-10-09-15-39-32&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;池化层&quot;&gt;2.2. 池化层&lt;/h2&gt;
&lt;p&gt;卷积层后一般会加入池化层，池化层可以非常有效地缩小矩阵的尺寸，从而减少最后全链层中的参数，使用池化层既可以加快计算速度也有防止过拟合问题的作用。&lt;br/&gt;池化层也存在一个过滤器，但是过滤器对于输入的数据的处理并不是像卷积核对输入数据进行节点的加权和，而只是简单的计算最大值或者平均值。过滤器的大小、是否全0填充、步长等也是由人工指定，而深度跟卷积核深度不一样，卷积层使用过滤器是横跨整个深度的，而池化层使用的过滤器只影响一个深度上的节点，在计算过程中，池化层过滤器不仅要在长和宽两个维度移动，还要在深度这个维度移动。使用最大值操作的池化层被称之为最大池化层，这种池化层使用得最多，使用平均值操作的池化层被称之为平均池化层，这种池化层的使用相对要少一点。&lt;br/&gt;以下动图可以看到最大值池化层的计算过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.omegaxy.com/Pictures/CNN/pooling.gif&quot; alt=&quot;2017-10-09-15-58-41&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Tensorflow程序很容易就可以实现最大值池化层的操作：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;
pool &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.nn.max_pool(i, ksize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;], stride&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;], padding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'SAME'&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;# i为输入矩阵&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# ksize为过滤器尺寸，其中第一个和第四个值必须为1，表示过滤器不可以垮不同的输入样列和节点矩阵深度。中间的两个值为尺寸，常使用2*2或3*3。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# stride为步长，第一个值和第四个值与ksize一样&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# padding为全0填充，‘SAME’表示使用全0填充，‘VALID’表示不使用全0填充&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;全链层&quot;&gt;2.3. 全链层&lt;/h2&gt;
&lt;p&gt;在KNN或线性分类中有对数据进行归一化处理，而在神经网络中，也会做数据归一化的处理，原因和之前的一样，避免数据值大的节点对分类造成影响。归一化的目标在于将输入保持在一个可接受的范围内。例如，将输入归一化到[0.0，1.0]区间内。在卷积神经网络中，对数据归一化的处理我们有可能放在数据正式输入到全链层之前或之后，或其他地方，每个网络都可能不一样。&lt;/p&gt;
&lt;p&gt;全链层的作用就是进行正确的图片分类，不同神经网络的全链层层数不同，但作用确是相同的。输入到全链层的神经元个数通过卷积层和池化层的处理后大大的减少了，比如以AlexNet为例，一张227*227大小，颜色通道数为3的图片经过处理后，输入到全链层的神经元个数有4096个,最后softmax的输出，则可以根据实际分类标签数来定。&lt;/p&gt;
&lt;p&gt;在全链层中，会使用dropout以随机的去掉一些神经元，这样能够比较有效地防止神经网络的过拟合。相对于一般如线性模型使用正则的方法来防止模型过拟合，而在神经网络中Dropout通过修改神经网络本身结构来实现。对于某一层神经元，通过定义的概率来随机删除一些神经元，同时保持输入层与输出层神经元的个人不变，然后按照神经网络的学习方法进行参数更新，下一次迭代中，重新随机删除一些神经元，直至训练结束。&lt;br/&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-09-16-57-39.png&quot; alt=&quot;2017-10-09-16-57-39&quot;/&gt;&lt;/p&gt;


&lt;p&gt;AlexNet是2012年ILSVRC比赛的冠军，它的出现直接打破了沉寂多年的图片识别领域（在1998年出现LeNet-5网络一直占据图片识别的领头地位），给该领域带来了新的契机，并一步步发展至今，甚至打败了人类的识别精确度，可惜的是2017年的ILSVRC举办方宣布从2018年起将取消该比赛，因为目前的神经网络精确度已经达到跟高的程度了。但深度学习的步伐不会停止，人们将在其他方面进行深入的研究。&lt;/p&gt;
&lt;p&gt;AlexNet是神经网络之父Hinton的学生Alex Krizhevsky开发完成，它总共有8层，其中有5个卷积层，3个全链层，附上最经典的AlexNet网络架构图，如下。Alex在他的论文中写到，他在处理图片的时候使用了两个GPU进行计算，因此，从图中看出，在卷积过程中他做了分组的处理，但是由于硬件资源问题，我们做的Alex网络是使用一个CPU进行计算的，但原理和他的一样，只是计算速度慢一点而已，对于大多数没有性能优良的GPU的人来说，用我们搭建好的网络，完全可以使用家用台式机进行训练。&lt;br/&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-09-17-25-04.png&quot; alt=&quot;2017-10-09-17-25-04&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Alex在论文中写到他使用的输入图片大小为224 X 224 X 3，但我们使用的图片尺寸为227 X 227 X 3，这个没有太大影响。AlexNet网络分为8层结构，前5层其实不完全是卷积层，有些层还加入了池化层，并对数据进行标准化处理。下面简要介绍一下每一层：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一层&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;11 * 11&lt;/td&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;td&gt;4 * 4&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3 * 3&lt;/td&gt;
&lt;td&gt;2 * 2&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第一层包含了卷积层、标准化操作和池化层，其中卷积层和池化层的参数在上表已给出。在Tensorflow中，搭建的部分代码程序为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;26&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 1st Layer: Conv (w ReLu) -&amp;gt; Lrn -&amp;gt; Pool&lt;/span&gt;
conv1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; conv(X, &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;96&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, padding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'VALID'&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'conv1'&lt;/span&gt;)
norm1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; lrn(conv1, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;2e-05&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.75&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'norm1'&lt;/span&gt;)
pool1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; max_pool(norm1, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, padding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'VALID'&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'pool1'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第二层&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5 * 5&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;td&gt;1 * 1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3 * 3&lt;/td&gt;
&lt;td&gt;2 * 2&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第二层实际也包含了卷积层、标准化操作和池化层，其中卷积层和池化层的参数在上表已给出。在Tensorflow中，搭建的部分代码程序为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;26&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 2nd Layer: Conv (w ReLu)  -&amp;gt; Lrn -&amp;gt; Pool with 2 groups&lt;/span&gt;
conv2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; conv(pool1, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;256&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, groups&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'conv2'&lt;/span&gt;)
norm2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; lrn(conv2, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;2e-05&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.75&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'norm2'&lt;/span&gt;)
pool2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; max_pool(norm2, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, padding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'VALID'&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'pool2'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第三层&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3 * 3&lt;/td&gt;
&lt;td&gt;384&lt;/td&gt;
&lt;td&gt;1 * 1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第三层仅有一个卷积层，卷积核的相关信息如上表，在Tensorflow中的部分代码为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 3rd Layer: Conv (w ReLu)&lt;/span&gt;
conv3 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; conv(pool2, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;384&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'conv3'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第四层&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3 * 3&lt;/td&gt;
&lt;td&gt;384&lt;/td&gt;
&lt;td&gt;1 * 1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第四层仅有一个卷积层，卷积核的相关信息如上表，该层与第三层很相似，只是把数据分成了2组进行处理，在Tensorflow中的部分代码为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 4th Layer: Conv (w ReLu) splitted into two groups&lt;/span&gt;
conv4 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; conv(conv3, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;384&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, groups&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'conv4'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第五层&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3 * 3&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;td&gt;1 * 1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3 * 3&lt;/td&gt;
&lt;td&gt;2 * 2&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第五层是最后一层卷积层，包含一个卷积层和一个池化层，卷积核和池化层过滤器的相关信息如上表，该层仍然把数据分成了2组进行处理，在Tensorflow中的部分代码为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 5th Layer: Conv (w ReLu) -&amp;gt; Pool splitted into two groups&lt;/span&gt;
conv5 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; conv(conv4, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;256&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, groups&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'conv5'&lt;/span&gt;)
pool5 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; max_pool(conv5, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, padding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'VALID'&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'pool5'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第六层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第六层是全链层，卷积层输出的数据一共有4096个神经元，在进入第六层全链层后，首先做了数据的平滑处理，并随机删除了一些神经元，在Tensorflow中的部分代码为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 6th Layer: Flatten -&amp;gt; FC (w ReLu) -&amp;gt; Dropout&lt;/span&gt;
flattened &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.reshape(pool5, [&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;256&lt;/span&gt;])
fc6 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fc(flattened, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;256&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4096&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'fc6'&lt;/span&gt;)
dropout6 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; dropout(fc6, &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.KEEP_PROB)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第七层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第七层是全链层，也会做dropout处理，在Tensorflow中的部分代码为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 7th Layer: FC (w ReLu) -&amp;gt; Dropout&lt;/span&gt;
fc7 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fc(dropout6, &lt;span class=&quot;dv&quot;&gt;4096&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4096&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'fc7'&lt;/span&gt;)
dropout7 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; dropout(fc7, &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.KEEP_PROB)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第八层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第八层是全链层，在最后softmax函数输出的分类标签是根据实际分类情况来定义的，可能有2种，可能10种，可能120种等等，在Tensorflow中的部分代码为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 8th Layer: FC and return unscaled activations&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.fc8 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fc(dropout7, &lt;span class=&quot;dv&quot;&gt;4096&lt;/span&gt;, &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.NUM_CLASSES, relu&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'fc8'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在搭建完整的AlexNet之前，需要做一些准备工作，以方便后期做训练的时候观测网络的运行情况。首先就是配置Tensorboard，Tensorboard是一款可视化工具，可以用它来展现你的TensorFlow图像，绘制图像生成的定量指标图，观察loss函数的收敛情况，网络的精确度，以及附加数据等等，具体如何配置，网上也有很多讲解，这里就不详细讲述了；另外就是准备数据，imageNet官网上有很多图片数据可以供大家免费使用，官网地址：&lt;a href=&quot;http://image-net.org/download-images&quot; class=&quot;uri&quot;&gt;http://image-net.org/download-images&lt;/a&gt; 。网上还有很多免费使用的爬虫可以去爬取数据，总之，数据是训练的根本，在网络搭建好之前最好准备充分。准备好的数据放入当前训练项目的根目录下。&lt;/p&gt;
&lt;p&gt;为了让各种需求的人能够复用AlexNet，我们在Python类中定义了AlexNet，并把接口暴露出来，需要使用的人根据自己的情况调用网络，并输入数据以及分类标签个数等信息就可以开始训练数据了。要使用搭建好的网络进行训练，不仅仅要利用网络，更是需要网络中的各项权重参数和偏置来达到更好的分类效果，目前，我们使用的是别人已经训练好的参数，所有的参数数据存放在bvlc_alexnet.npy这个文件中，下载地址为：&lt;a href=&quot;http://www.cs.toronto.edu/~guerzhoy/tf_alexnet/&quot; class=&quot;uri&quot;&gt;http://www.cs.toronto.edu/~guerzhoy/tf_alexnet/&lt;/a&gt; ，下载后放入当前训练项目的根目录下即可。如果你有充分的时间和优越的硬件资源，你也可以自己训练参数，并把这些参数存储起来供以后使用，但是该bvlc_alexnet.npy文件中的参数是imageNet训练好了的，使用这些参数训练的模型精确度比我们之前训练的要高。&lt;br/&gt;在Tensorflow中，定义加载参数的程序代码如下，默认的参数就是bvlc_alexnet.npy中存储的权重和偏置值。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; load_initial_weights(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;, session):

    &lt;span class=&quot;co&quot;&gt;&quot;&quot;&quot;Load weights from file into network.&quot;&quot;&quot;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;# Load the weights into memory&lt;/span&gt;
    weights_dict &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.load(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.WEIGHTS_PATH, encoding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'bytes'&lt;/span&gt;).item()

    &lt;span class=&quot;co&quot;&gt;# Loop over all layer names stored in the weights dict&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; op_name &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; weights_dict:

        &lt;span class=&quot;co&quot;&gt;# Check if layer should be trained from scratch&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; op_name &lt;span class=&quot;op&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.SKIP_LAYER:

            &lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; tf.variable_scope(op_name, reuse&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;):

                &lt;span class=&quot;co&quot;&gt;# Assign weights/biases to their corresponding tf variable&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; data &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; weights_dict[op_name]:

                    &lt;span class=&quot;co&quot;&gt;# Biases&lt;/span&gt;
                    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(data.shape) &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:
                        var &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.get_variable(&lt;span class=&quot;st&quot;&gt;'biases'&lt;/span&gt;, trainable&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;)
                        session.run(var.assign(data))

                    &lt;span class=&quot;co&quot;&gt;# Weights&lt;/span&gt;
                    &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
                        var &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.get_variable(&lt;span class=&quot;st&quot;&gt;'weights'&lt;/span&gt;, trainable&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;)
                        session.run(var.assign(data))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上一节讲述AlexNet的架构的时，曾出现过数据分组处理，这里用程序来描述一下在一个CPU情况下，如何把数据进行分组处理。数据的分组处理都在卷积层中发生，因此首先一个卷积函数，由于在第一层卷积没有分组，所以在函数中需要做分组的判断，如果没有分组，输入数据和权重直接做卷积运算；如果有分组，则把输入数据和权重先划分后做卷积运算，卷积结束后再用&lt;code&gt;concat()&lt;/code&gt;合并起来，这就是分组的具体操作。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; conv(x, filter_height, filter_width, num_filters, stride_y, stride_x, name,padding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'SAME'&lt;/span&gt;, groups&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;):
    &lt;span class=&quot;co&quot;&gt;&quot;&quot;&quot;Create a convolution layer.&quot;&quot;&quot;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;# Get number of input channels&lt;/span&gt;
    input_channels &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt;(x.get_shape()[&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;])

    &lt;span class=&quot;co&quot;&gt;# Create lambda function for the convolution&lt;/span&gt;
    convolve &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; i, k: tf.nn.conv2d(i, k,
                                         strides&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, stride_y, stride_x, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;],
                                         padding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;padding)

    &lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; tf.variable_scope(name) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; scope:
        &lt;span class=&quot;co&quot;&gt;# Create tf variables for the weights and biases of the conv layer&lt;/span&gt;
        weights &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.get_variable(&lt;span class=&quot;st&quot;&gt;'weights'&lt;/span&gt;, shape&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[filter_height,
                                                    filter_width,
                                                    input_channels&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;groups,
                                                    num_filters])
        biases &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.get_variable(&lt;span class=&quot;st&quot;&gt;'biases'&lt;/span&gt;, shape&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[num_filters])

    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; groups &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:
        conv &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; convolve(x, weights)

    &lt;span class=&quot;co&quot;&gt;# In the cases of multiple groups, split inputs &amp;amp; weights and&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
        &lt;span class=&quot;co&quot;&gt;# Split input and weights and convolve them separately&lt;/span&gt;
        input_groups &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.split(axis&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, num_or_size_splits&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;groups, value&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;x)
        weight_groups &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.split(axis&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, num_or_size_splits&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;groups,
                                 value&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;weights)
        output_groups &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [convolve(i, k) &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i, k &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;zip&lt;/span&gt;(input_groups, weight_groups)]

        &lt;span class=&quot;co&quot;&gt;# Concat the convolved output together again&lt;/span&gt;
        conv &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.concat(axis&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, values&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;output_groups)

    &lt;span class=&quot;co&quot;&gt;# Add biases&lt;/span&gt;
    bias &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.reshape(tf.nn.bias_add(conv, biases), tf.shape(conv))

    &lt;span class=&quot;co&quot;&gt;# Apply relu function&lt;/span&gt;
    relu &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.nn.relu(bias, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;scope.name)

    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; relu&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于AlexNet中池化层，全链层的代码在alexnet.py已经全部定义好了，这里就不一一列出来了。接着开始如何在Tensorflow中导入图片，在图片数据量大的情况下，Tensorflow会建议把数据转换成tfrecords文件，然后在导入到网络中运算，这样的好处是可以加快计算速度，节约内存空间。但我们没有这样做，因为在训练网络的时候我们没有发现转换成tfrecords文件就明显提高了计算速度，所以这里直接把原生的图片直接转化成三维数据输入到网络中。这样做代码还要简短一点，而图片也是预先存储在硬盘中，需要训练的那一部分再从硬盘中读取到内存中，并没有浪费内存资源。&lt;/p&gt;
&lt;p&gt;在Python类中定义图片生成器，需要的参数有图片URL，实际的标签向量和标签个数，batch_size等。首先打乱整个训练集图片的顺序，因为图片名可能是按照某种规律来定义的，打乱图片顺序可以帮助我们更好的训练网络。完成这一步后就可以把图片从RGB色转换成BRG三维数组。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;31&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ImageDataGenerator(&lt;span class=&quot;bu&quot;&gt;object&lt;/span&gt;):
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;, images, labels, batch_size, num_classes, shuffle&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;, buffer_size&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;):

        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.img_paths &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; images
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.labels &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; labels
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.num_classes &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; num_classes
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.data_size &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.labels)
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.pointer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;# 打乱图片顺序&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; shuffle:
            &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;._shuffle_lists()
        
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.img_paths &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; convert_to_tensor(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.img_paths, dtype&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;dtypes.string)
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.labels &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; convert_to_tensor(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.labels, dtype&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;dtypes.int32)

        data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Dataset.from_tensor_slices((&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.img_paths, &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.labels))
        data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data.&lt;span class=&quot;bu&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;._parse_function_train, num_threads&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;,
                        output_buffer_size&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; batch_size)

        data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data.batch(batch_size)

        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data

    
    &lt;span class=&quot;co&quot;&gt;&quot;&quot;&quot;打乱图片顺序&quot;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; _shuffle_lists(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):
        path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.img_paths
        labels &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.labels
        permutation &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.random.permutation(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.data_size)
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.img_paths &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.labels &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
        &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; permutation:
            &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.img_paths.append(path[i])
            &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.labels.append(labels[i])


    &lt;span class=&quot;co&quot;&gt;&quot;&quot;&quot;把图片生成三维数组，以及把标签转化为向量&quot;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; _parse_function_train(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;, filename, label):
        one_hot &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.one_hot(label, &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.num_classes)
        img_string &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.read_file(filename)
        img_decoded &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.image.decode_png(img_string, channels&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
        img_resized &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.image.resize_images(img_decoded, [&lt;span class=&quot;dv&quot;&gt;227&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;227&lt;/span&gt;])
        img_centered &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.subtract(img_resized, VGG_MEAN)
        img_bgr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; img_centered[:, :, ::&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]
        
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; img_bgr, one_hot&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;网络搭建完成，数据准备就绪，最后就是开始训练了。由于网络和图片生成器是可以复用的，在训练图片的时候需要用户根据自己的实际情况编写代码调用网络和图片生成器模块，同时定义好损失函数和优化器，以及需要在Tensorboard中观测的各项指标等等操作。下面一节我们将开始进行网络训练。&lt;br/&gt;&lt;/p&gt;


&lt;h2 id=&quot;定义分类&quot;&gt;5.1. 定义分类&lt;/h2&gt;
&lt;p&gt;如上一节讲的，datagenerator.py（图片转换模块）和alexnet.py（AlexNet网络模块）已经搭建好了，你在使用的时候无需做修改。现在你只需要根据自己的分类需求编写精调代码，如finetune.py中所示。&lt;br/&gt;假设有3万张猫狗图片训练集和3000张测试集，它们大小不一。我们的目的是使用AlexNet正确的分类猫和狗两种动物，因此，类别标签个数只有2个，并用0代表猫，1代表狗。如果你需要分类其他的动物或者物品，或者anything，你需要标注好图片的实际标签，定义好图片Tensorboard存放的目录，以及训练好的模型和参数的存放目录等等。就像这样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; os
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; np
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; tensorflow &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; tf
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; alexnet &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; AlexNet
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; datagenerator &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; ImageDataGenerator
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; datetime &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; datetime
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; glob
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; tensorflow.contrib.data &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Iterator

learning_rate &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;1e-4&lt;/span&gt;                   &lt;span class=&quot;co&quot;&gt;# 学习率&lt;/span&gt;
num_epochs &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;                       &lt;span class=&quot;co&quot;&gt;# 代的个数&lt;/span&gt;
batch_size &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt;                      &lt;span class=&quot;co&quot;&gt;# 一次性处理的图片张数&lt;/span&gt;
dropout_rate &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;                     &lt;span class=&quot;co&quot;&gt;# dropout的概率&lt;/span&gt;
num_classes &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;                        &lt;span class=&quot;co&quot;&gt;# 类别标签&lt;/span&gt;
train_layers &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'fc8'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'fc7'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'fc6'&lt;/span&gt;]   &lt;span class=&quot;co&quot;&gt;# 训练层，即三个全链层&lt;/span&gt;
display_step &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;                      &lt;span class=&quot;co&quot;&gt;# 显示间隔次数&lt;/span&gt;

filewriter_path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;./tmp/tensorboard&quot;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;# 存储tensorboard文件&lt;/span&gt;
checkpoint_path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;./tmp/checkpoints&quot;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;# 训练好的模型和参数存放目录&lt;/span&gt;

&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;not&lt;/span&gt; os.path.isdir(checkpoint_path): &lt;span class=&quot;co&quot;&gt;#如果没有存放模型的目录，程序自动生成&lt;/span&gt;
    os.mkdir(checkpoint_path)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着调用图片生成器，来生成图片数据，并初始化数据：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;
train_image_path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'train/'&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;# 指定训练集数据路径（根据实际情况指定训练数据集的路径）&lt;/span&gt;
test_image_cat_path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'test/cat/'&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;# 指定测试集数据路径（根据实际情况指定测试数据集的路径）&lt;/span&gt;
test_image_dog_path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'test/dog/'&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 打开训练数据集目录，读取全部图片，生成图片路径列表&lt;/span&gt;
image_filenames_cat &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.array(glob.glob(train_image_path &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'cat.*.jpg'&lt;/span&gt;))
image_filenames_dog &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.array(glob.glob(train_image_path &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'dog.*.jpg'&lt;/span&gt;))

&lt;span class=&quot;co&quot;&gt;# 打开测试数据集目录，读取全部图片，生成图片路径列表&lt;/span&gt;
test_image_filenames_cat &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.array(glob.glob(test_image_cat_path &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'*.jpg'&lt;/span&gt;))
test_image_filenames_dog &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.array(glob.glob(test_image_dog_path &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'*.jpg'&lt;/span&gt;))

image_path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
label_path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
test_image &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
test_label &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []

&lt;span class=&quot;co&quot;&gt;# 遍历训练集图片URL，并把图片对应的实际标签和路径分别存入两个新列表中&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; catitem &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; image_filenames_cat:
    image_path.append(catitem)
    label_path.append(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; dogitem &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; image_filenames_dog:
    image_path.append(dogitem)
    label_path.append(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;# 遍历测试集图片URL，并把图片路径存入一个新列表中&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; catitem &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; test_image_filenames_cat:
    test_image.append(catitem)
    test_label.append(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)

&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; dogitem &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; test_image_filenames_cat:
    test_image.append(dogitem)
    test_label.append(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;# 调用图片生成器，把训练集图片转换成三维数组&lt;/span&gt;
tr_data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; ImageDataGenerator(
    images&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;image_path,
    labels&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;label_path,
    batch_size&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;batch_size,
    num_classes&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;num_classes)

&lt;span class=&quot;co&quot;&gt;# 调用图片生成器，把测试集图片转换成三维数组&lt;/span&gt;
test_data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; ImageDataGenerator(
    images&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;test_image,
    labels&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;test_label,
    batch_size&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;batch_size,
    num_classes&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;num_classes,
    shuffle&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;# 定义迭代器&lt;/span&gt;
iterator &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Iterator.from_structure(tr_data.data.output_types,
                                   tr_data.data.output_shapes)
&lt;span class=&quot;co&quot;&gt;# 定义每次迭代的数据&lt;/span&gt;
next_batch &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; iterator.get_next()

&lt;span class=&quot;co&quot;&gt;# 初始化数据&lt;/span&gt;
training_initalize &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; iterator.make_initializer(tr_data.data)
testing_initalize &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; iterator.make_initializer(test_data.data)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;训练数据准备好以后，让数据通过AlexNet。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;
x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.placeholder(tf.float32, [batch_size, &lt;span class=&quot;dv&quot;&gt;227&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;227&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;])
y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.placeholder(tf.float32, [batch_size, num_classes])
keep_prob &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.placeholder(tf.float32) &lt;span class=&quot;co&quot;&gt;# dropout概率&lt;/span&gt;


&lt;span class=&quot;co&quot;&gt;# 图片数据通过AlexNet网络处理&lt;/span&gt;
model &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; AlexNet(x, keep_prob, num_classes, train_layers)

&lt;span class=&quot;co&quot;&gt;# 定义我们需要训练的全连层的变量列表&lt;/span&gt;
var_list &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [v &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; v &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; tf.trainable_variables() &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; v.name.split(&lt;span class=&quot;st&quot;&gt;'/'&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; train_layers]


&lt;span class=&quot;co&quot;&gt;# 执行整个网络图&lt;/span&gt;
score &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; model.fc8&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着当然就是定义损失函数，优化器。整个网络需要优化三层全链层的参数，同时在优化参数过程中，使用的是梯度下降算法，而不是反向传播算法。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 损失函数&lt;/span&gt;
loss &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;score, labels&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;y))

&lt;span class=&quot;co&quot;&gt;# 定义需要精调的每一层的梯度&lt;/span&gt;
gradients &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.gradients(loss, var_list)
gradients &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;list&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;zip&lt;/span&gt;(gradients, var_list))

&lt;span class=&quot;co&quot;&gt;# 优化器，采用梯度下降算法进行优化&lt;/span&gt;
optimizer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.train.GradientDescentOptimizer(learning_rate)

&lt;span class=&quot;co&quot;&gt;# 需要精调的每一层都采用梯度下降算法优化参数&lt;/span&gt;
train_op &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; optimizer.apply_gradients(grads_and_vars&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;gradients)

&lt;span class=&quot;co&quot;&gt;# 定义网络精确度&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; tf.name_scope(&lt;span class=&quot;st&quot;&gt;&quot;accuracy&quot;&lt;/span&gt;):
    correct_pred &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.equal(tf.argmax(score, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), tf.argmax(y, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
    accuracy &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.reduce_mean(tf.cast(correct_pred, tf.float32))

&lt;span class=&quot;co&quot;&gt;# 以下几步是需要在Tensorboard中观测loss的收敛情况和网络的精确度而定义的&lt;/span&gt;
tf.summary.scalar(&lt;span class=&quot;st&quot;&gt;'cross_entropy'&lt;/span&gt;, loss)
tf.summary.scalar(&lt;span class=&quot;st&quot;&gt;'accuracy'&lt;/span&gt;, accuracy)
merged_summary &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.summary.merge_all()
writer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.summary.FileWriter(filewriter_path)
saver &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.train.Saver()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，训练数据：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;
&lt;span class=&quot;co&quot;&gt;# 定义一代的迭代次数&lt;/span&gt;
train_batches_per_epoch &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt;(np.floor(tr_data.data_size &lt;span class=&quot;op&quot;&gt;/&lt;/span&gt; batch_size))
test_batches_per_epoch &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt;(np.floor(test_data.data_size &lt;span class=&quot;op&quot;&gt;/&lt;/span&gt; batch_size))

&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; tf.Session() &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; sess:
    sess.run(tf.global_variables_initializer())

    &lt;span class=&quot;co&quot;&gt;# 把模型图加入Tensorboard&lt;/span&gt;
    writer.add_graph(sess.graph)

    &lt;span class=&quot;co&quot;&gt;# 把训练好的权重加入未训练的网络中&lt;/span&gt;
    model.load_initial_weights(sess)

    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;{} Start training...&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(datetime.now()))
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;{} Open Tensorboard at --logdir {}&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(datetime.now(),
                                                      filewriter_path))

    &lt;span class=&quot;co&quot;&gt;# 总共训练100代&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; epoch &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(num_epochs):
        sess.run(iterator.make_initializer(tr_data.data))
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;{} Epoch number: {} start&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(datetime.now(), epoch &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))

        &lt;span class=&quot;co&quot;&gt;# 开始训练每一代，一代的次数为train_batches_per_epoch的值&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; step &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(train_batches_per_epoch):
            img_batch, label_batch &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; sess.run(next_batch)
            sess.run(optimizer, feed_dict&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{x: img_batch,
                                           y: label_batch,
                                           keep_prob: dropout_rate})
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; step &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; display_step &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:
                s &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; sess.run(merged_summary, feed_dict&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{x: img_batch,
                                                        y: label_batch,
                                                        keep_prob: &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;.})

                writer.add_summary(s, epoch &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; train_batches_per_epoch &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; step)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;训练完成后需要验证模型的精确度，这个时候就得用上测试数据集了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;
&lt;span class=&quot;co&quot;&gt;# 测试模型精确度&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;{} Start validation&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(datetime.now()))
sess.run(testing_initalize)
test_acc &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;.
test_count &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(test_batches_per_epoch):
    img_batch, label_batch &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; sess.run(next_batch)
    acc &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; sess.run(accuracy, feed_dict&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{x: img_batch, y: label_batch, keep_prob: &lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;})
    test_acc &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; acc
    test_count &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;

test_acc &lt;span class=&quot;op&quot;&gt;/=&lt;/span&gt; test_count

&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;{} Validation Accuracy = {:.4f}&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(datetime.now(), test_acc))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后把训练好的模型持久化。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 把训练好的模型存储起来&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;{} Saving checkpoint of model...&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(datetime.now()))

checkpoint_name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; os.path.join(checkpoint_path,&lt;span class=&quot;st&quot;&gt;'model_epoch'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(epoch &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'.ckpt'&lt;/span&gt;)
save_path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; saver.save(sess, checkpoint_name)

&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;{} Epoch number: {} end&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(datetime.now(), epoch &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此为止，一个完整的AlexNet就搭建完成了。在准备好训练集和测试集数据后，下面我们开始训练网络。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;训练网络&quot;&gt;5.2. 训练网络&lt;/h2&gt;
&lt;p&gt;我们总共训练了100代，使用CPU计算进行计算，在台式机上跑了一天左右，完成了3万张图片的训练和3000张图片的测试，网络的识别精确度为71.25%，这个结果不是很好，可能与数据量少有关系。如果你有上十万张的数据集，再增加训练次数，相信你网络的精度应该比我们训练的还要好。下面看看网络的计算图，这是Tensorboard中记录下的，通过该图，你可以对整个网络的架构及运行一目了然。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-16-13-54-41.png&quot; alt=&quot;2017-10-16-13-54-41&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;验证&quot;&gt;5.3. 验证&lt;/h2&gt;
&lt;p&gt;网络训练好了以后，当然我们想迫不及待的试试我们网络。首先我们还是得编写自己的验证代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;27&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; tensorflow &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; tf
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; alexnet &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; AlexNet             &lt;span class=&quot;co&quot;&gt;# import训练好的网络&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; plt

class_name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'cat'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'dog'&lt;/span&gt;]             &lt;span class=&quot;co&quot;&gt;# 自定义猫狗标签&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; test_image(path_image, num_class, weights_path&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'Default'&lt;/span&gt;):
    &lt;span class=&quot;co&quot;&gt;# 把新图片进行转换&lt;/span&gt;
    img_string &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.read_file(path_image)
    img_decoded &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.image.decode_png(img_string, channels&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
    img_resized &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.image.resize_images(img_decoded, [&lt;span class=&quot;dv&quot;&gt;227&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;227&lt;/span&gt;])
    img_resized &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.reshape(img_resized, shape&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;227&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;227&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;])
    
    &lt;span class=&quot;co&quot;&gt;# 图片通过AlexNet&lt;/span&gt;
    model &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; AlexNet(img_resized, &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, skip_layer&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;, weights_path&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;weights_path)
    score &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.nn.softmax(model.fc8)
    &lt;span class=&quot;bu&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.arg_max(score, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
    saver &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.train.Saver()

    &lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; tf.Session() &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; sess:
        sess.run(tf.global_variables_initializer())
        saver.restore(sess, &lt;span class=&quot;st&quot;&gt;&quot;./tmp/checkpoints/model_epoch10.ckpt&quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 导入训练好的参数&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;# score = model.fc8&lt;/span&gt;
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sess.run(model.fc8))
        prob &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; sess.run(&lt;span class=&quot;bu&quot;&gt;max&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]

        &lt;span class=&quot;co&quot;&gt;# 在matplotlib中观测分类结果&lt;/span&gt;
        plt.imshow(img_decoded.&lt;span class=&quot;bu&quot;&gt;eval&lt;/span&gt;())
        plt.title(&lt;span class=&quot;st&quot;&gt;&quot;Class:&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; class_name[prob])
        plt.show()


test_image(&lt;span class=&quot;st&quot;&gt;'./test/20.jpg'&lt;/span&gt;, num_class&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 输入一张新图片&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在网上任意下载10张猫狗图片来进行验证，有三张图片识别错误（如下图），验证的精确度70%，效果不是很理想。但是如果你感兴趣，你可以下载我们的代码，用自己的训练集来试试，代码地址为：&lt;a href=&quot;https://github.com/stephen-v/tensorflow_alexnet_classify&quot; class=&quot;uri&quot;&gt;https://github.com/stephen-v/tensorflow_alexnet_classify&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-18-10-16-50.png&quot; alt=&quot;2017-10-18-10-16-50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-18-10-18-37.png&quot; alt=&quot;2017-10-18-10-18-37&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-18-10-19-57.png&quot; alt=&quot;2017-10-18-10-19-57&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-18-10-21-22.png&quot; alt=&quot;2017-10-18-10-21-22&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-18-10-23-09.png&quot; alt=&quot;2017-10-18-10-23-09&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-18-10-27-53.png&quot; alt=&quot;2017-10-18-10-27-53&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-18-10-26-36.png&quot; alt=&quot;2017-10-18-10-26-36&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-18-10-29-58.png&quot; alt=&quot;2017-10-18-10-29-58&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-18-10-33-15.png&quot; alt=&quot;2017-10-18-10-33-15&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2017-10-18-10-38-02.png&quot; alt=&quot;2017-10-18-10-38-02&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.9078947368421&quot;&gt;
&lt;p&gt;作者：帅虫哥 出处： &lt;a href=&quot;http://www.cnblogs.com/vipyoumay/p/7686230.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/vipyoumay/p/7686230.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 18 Oct 2017 05:42:00 +0000</pubDate>
<dc:creator>行动派Xdpie</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vipyoumay/p/7686230.html</dc:identifier>
</item>
</channel>
</rss>