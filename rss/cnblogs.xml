<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>病毒分析第一讲,分析病毒注意事项,以及简单分析主要功能 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7882980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7882980.html</guid>
<description>

&lt;h2&gt;一丶认识木马和病毒的区别&lt;/h2&gt;
&lt;p&gt;木马和病毒是两个不一样的,有人会把木马认为是病毒,但其实不是&lt;/p&gt;
&lt;p&gt;说下区别&lt;/p&gt;

&lt;p&gt;木马:&lt;/p&gt;
&lt;p&gt;　　木马没有破坏性,木马主要功能是收集用户信息,控制机器等等.&lt;/p&gt;
&lt;p&gt;病毒:&lt;/p&gt;
&lt;p&gt;　　病毒一般带有破坏性的行为,比如格式化盘符,修改电脑的文件,传染....&lt;/p&gt;
&lt;h2&gt;二丶分析病毒的前提准备&lt;/h2&gt;
&lt;h3&gt;1.在分析病毒样本之前,首先要把病毒的名字修改一下.&lt;/h3&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123034335196-2067248258.png&quot; alt=&quot;&quot;/&gt;,加上.v后缀&lt;/p&gt;
&lt;h3&gt;2.使用虚拟机进行分析(当然你可以用真机分析,^_^),并且建立虚拟机快照&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123034442618-1630496352.png&quot; alt=&quot;&quot;/&gt;虚拟机软件&lt;/p&gt;
&lt;h3&gt;3.建立快照&lt;/h3&gt;
&lt;p&gt; 建立快照之前,建议把所以该用到的工具进行配置.配置好了一切就可以开始正常操作了.&lt;/p&gt;
&lt;p&gt;-&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123035329665-2137732592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.观察病毒行为&lt;/h3&gt;
&lt;p&gt;　　1.第一种分析方式&lt;/p&gt;
&lt;p&gt;　　　　　　关键API下断点&lt;/p&gt;
&lt;p&gt;　　　　CreateFile  CreateProcess  OpenProcess, WriteProcessMemory  VirtualAllocEx,服务相关,注册表相关,网络相关,因为只要是病毒,肯定会操作的.&lt;/p&gt;
&lt;p&gt;　　2.第二种分析方式&lt;/p&gt;
&lt;p&gt;　　　　使用一种观察其行为的工具,在虚拟机中看看在怎么做.&lt;/p&gt;
&lt;p&gt;　　　　工具:&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123035704321-1091012929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;工具会打包上传&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123035846743-338753050.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装好之后的界面:&lt;/p&gt;
&lt;p&gt;设置:&lt;/p&gt;
&lt;p&gt;　　工具-选项-保护-设置保护模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123040044727-102780231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　1.学习模式, 可以检测特定程序的使用的关键API,比如: 创建文件,修改内存...但是不阻止&lt;/p&gt;
&lt;p&gt;　　2.正常模式,正常模式则会在调用这些关键API之后,则会问你是否允许操作&lt;/p&gt;
&lt;p&gt;　　3.安静模式,安静模式则不操作,不提示.&lt;/p&gt;
&lt;h2&gt;三丶在学习模式下,观看病毒行为&lt;/h2&gt;
&lt;h3&gt;一丶分析病毒的基本行为&lt;/h3&gt;
&lt;p&gt;此时,我们可以把我们的病毒样本放到虚拟机中运行了,如果建立了快照,则可以运行起来了,到时候恢复快照即可.&lt;/p&gt;
&lt;p&gt;病毒样本:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123040426586-678336806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;拖放到虚拟机中运行,先打开Mal病毒分析工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123041352305-741824830.png&quot; alt=&quot;&quot;/&gt;并运行.&lt;/p&gt;
&lt;p&gt;第一步初次分析得到&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123041732836-851935886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123041835946-514044368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　可以得出&lt;/p&gt;
&lt;p&gt;　　1. 主体样本会释放 SampleSrv.exe子体&lt;/p&gt;
&lt;p&gt;　　2.主体创建进行,运行SampleSrv.exe&lt;/p&gt;
&lt;p&gt;　　3.主体不断的修改其他进程内存&lt;/p&gt;
&lt;p&gt;　　4.子体SamPleSrv.exe释放DestToplayer.exe&lt;/p&gt;
&lt;p&gt;　　5.字体SamPleSrv.exe创建进行运行了DestToplayer.exe&lt;/p&gt;
&lt;p&gt;　　6.Desttoplayer.exe运行iexplore.exe&lt;/p&gt;
&lt;p&gt;　　7.Iexplore.exe修改注册表的值&lt;/p&gt;
&lt;p&gt;　　8.Iexplore.exe不断的修改文件&lt;/p&gt;
&lt;p&gt;由此得出流程图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123042541993-1397297308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 二丶根据第一次分析,分析具体怎么做.&lt;/h3&gt;
&lt;p&gt;　　根据第一次的分析,我们发现Iexipore.exe (也就是IE浏览器)不断的修改文件(感染文件)&lt;/p&gt;
&lt;h4&gt;1.附加感染文件&lt;/h4&gt;
&lt;p&gt;那么此时,我们OD附加一下,然后在CreateFile下断点,因为感染文件肯定会打开文件.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123042825196-237952560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OD附加进程是存在的,因为创建进程的时候,窗口已经隐藏了.&lt;/p&gt;
&lt;h4&gt;2.打开模块,关键api下断点&lt;/h4&gt;
&lt;p&gt;ALT + E打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123043058540-233110309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CTRL + N 查看CreateFile&lt;/p&gt;
&lt;h4&gt;3.关键API下断点&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123043243540-2031984921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;4.栈回溯看其谁调用&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123043349196-726667791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123043419102-2071813153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;5.查看节,看下属于哪个节&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123043545711-878002917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;属于一个堆内存&lt;/p&gt;
&lt;p&gt;节区开始是&lt;/p&gt;
&lt;p&gt;2001000&lt;/p&gt;
&lt;p&gt;大小是 D000&lt;/p&gt;
&lt;p&gt;我们跳转到这个节地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123043749696-1163502141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在内存中看到,它是一个EXE? MZ开头&lt;/p&gt;
&lt;p&gt;我们查看下OEP,然后在内存中DUM这块内存下来.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123043851758-743457370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B0开始是我们的PE头,那么 OEP的入口点是7C79&lt;/p&gt;
&lt;p&gt;直接DUp内存&lt;/p&gt;
&lt;h3&gt;6.Dup内存&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123044211118-1058625382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先用的这个工具是OD插件中带的.网上可以查到很多.(工具会打包)&lt;/p&gt;
&lt;h3&gt;7.IDA分析dump出来的文件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123044453102-964056792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.1,分析导入表,查看CreateFile被谁引用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123044706399-601087536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按X键看被谁引用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123044737071-1317661720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一步一步往上跟&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123045243446-1593873072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一次跟到这里,我们点击上面的注释哪里,可以继续网上跟,看谁引用了.&lt;/p&gt;
&lt;p&gt;注意,上面的注释没有我这么多我们要设置一下 &lt;/p&gt;
&lt;p&gt;中文:设置 - &amp;gt; 常规 - &amp;gt; 显示交叉参考 - &amp;gt; 设置你喜欢的数目&lt;/p&gt;
&lt;p&gt;英文: Options - &amp;gt; General - &amp;gt; Cross-references -&amp;gt; disassembly(Non-Graph) -&amp;gt; 设置你喜欢的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123045637961-1371145892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一层一层的交叉引用展开,粗略的按下F5键看一下,其中一个是修改PE文件的,暂时可以将这个引用修改为 修改PE 节(ChangePE Sections)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123050009758-1497544060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一层一层的往上跟可以看到遍历文件,所以我们修改一下函数名字&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123050131180-1583984990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续网上跟可以看出获得磁盘驱动器的函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171123050327508-1218990147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按下x,看下此函数谁调用的.我们发现它是一个线程开辟去做的事情,那么这个线程看下是谁用的.&lt;/p&gt;
&lt;p&gt;那么继续往下追则是DLLEntry了,也就是 DLL main DLL的入口点了.&lt;/p&gt;
&lt;p&gt;由此得出,这个是DLL,被注入的IE中的,然后执行程序,不断循环遍历文件,进行感染exe文件的.&lt;/p&gt;
&lt;p&gt;那么我们要知道怎么注入的,在上面的沙箱中也没看到,明天讲解.&lt;/p&gt;


&lt;p&gt;&lt;span&gt; 链接:&lt;a target=&quot;_blank&quot;&gt; https://pan.baidu.com/s/1eRSOjpK&lt;/a&gt; 密码: 19jt&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 Nov 2017 21:11:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7882980.html</dc:identifier>
</item>
<item>
<title>Unity3D高性能战争迷雾实现 - SChivas</title>
<link>http://www.cnblogs.com/SChivas/p/7881515.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SChivas/p/7881515.html</guid>
<description>&lt;p&gt;　　先上效果图吧，这是为了吸引到你们的ヽ(｡◕‿◕｡)ﾉﾟ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171122220122165-66998208.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;战争迷雾效果演示图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171122220226586-51772465.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;战争调试界面演示图&lt;/p&gt;

&lt;p&gt;　　由于是gif录制，为了压缩图片，帧率有点低，实际运行时，参数调整好是不会像这样一卡一顿的。&lt;/p&gt;



&lt;p&gt;　　战争迷雾一般用于Startcraft等RTS类型游戏，还有就是War3等类型的Moba类型游戏，主要包括三个概念：未探索区域、已探索区域、当前视野。&lt;/p&gt;
&lt;p&gt;　　1）未探索区域：一般展示为黑色区域，像星际争霸这样的游戏，开局时未探索区域一般是暗黑的，只有地图上的原始晶体矿产能够被看到，敌人建筑、角色等都不暴露。&lt;/p&gt;
&lt;p&gt;　　2）已探索区域：一般显示为灰色区域，已探索表示某块区域曾经被你的视野覆盖过，星际争霸中已探索的区域会保留你当时视野离开时该区域的建筑状态，所以可以看到敌人的建筑。&lt;/p&gt;
&lt;p&gt;　　3）当前视野：一般全亮，视野范围内除了隐身单位等特俗设定，所有的建筑、角色、特效等都是可见的，视野一般锁定在可移动角色或者特定魔法上面，会随着角色的移动而移动，随着魔法的消失而消失。&lt;/p&gt;



&lt;p&gt;　　战争迷雾的实现方式大体上可以分为两个步骤：贴图生成、屏幕渲染。&lt;/p&gt;

&lt;h2&gt;贴图生成&lt;/h2&gt;
&lt;p&gt;　　贴图的生成有两种方式：&lt;/p&gt;
&lt;p&gt;　　1）拼接法：&lt;/p&gt;
&lt;p&gt;　　　　使用类似地图拼接的原理去实现，贴图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171122224940868-1760133380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;战争迷雾拼接贴图&lt;/p&gt;

&lt;p&gt;　　　　这种方式个人认为很不靠谱，局限性很大，而且迷雾总是会运动的，在平滑处理这点上会比较粗糙，不太自然。这里不再赘述它的实现原理。&lt;/p&gt;
&lt;p&gt;　　2）绘制法：绘制法和使用的地图模型有很大关系，一般有使用的有两种模型：一个是正方形地图，另外一个是六边形地图。六边形地图示例如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171122225702102-725160654.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;六边形地图贴图&lt;/p&gt;

&lt;p&gt;　　　　原理简单直白，使用正方形/者六边形划分地图空间，以正方形/六边形为单位标记被探索过和当前视野区域。这里探索过的区域是棱角分明的，可以使用高斯模糊进行模糊处理。一般来说，正方形/六边形边长是选择合适，太长会导致模糊处理效果不理想，太短会导致地图单元格太多，全图刷新消耗增大。另外说一句，战争迷雾的地图和战斗系统的逻辑地图其实是可以分离的，所以两种并没有必然联系，你可以单独为你的战争迷雾系统选择地图模型。&lt;/p&gt;

&lt;h2&gt;屏幕渲染&lt;/h2&gt;
&lt;p&gt;　　得到如上贴图以后，就可以渲染到屏幕了，渲染方式一般来说有3种：&lt;/p&gt;
&lt;p&gt;　　1）屏幕后处理：在原本屏幕显示图像上叠加混合战争迷雾贴图。&lt;/p&gt;
&lt;p&gt;　　2）摄像机投影：使用投影仪进行投影，将战争迷雾投影到世界空间。&lt;/p&gt;
&lt;p&gt;　　3）模型贴图：使用一种覆盖整个世界空间的平面模型贴图绘制战争迷雾。&lt;/p&gt;
&lt;p&gt;　　不管你选择使用哪一种方式，在这一步当中都需要在Shader里进行像素级别的平滑过渡。从上一个时刻的贴图状态过渡到当前时刻的贴图状态。&lt;/p&gt;



&lt;p&gt;　　原理大致上应该是清楚了，因为这个系统的设计原理实际上也不算是复杂，下面就一些重要步骤给出代码实现。这里实践的时候采用的是正方形地图，模型贴图方式。正方形地图模型不管是模糊处理还是Shader绘制都要比六边形地图简单。正方形贴图Buffer使用Color32的二维数组表示，根据位置信息，每个正方形网格会对应一个Color32数据，包含颜色值和透明度，能够很好的进行边缘平滑效果。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Color buffers -- prepared on the worker thread.&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Color32[] mBuffer0;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Color32[] mBuffer1;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; Color32[] mBuffer2;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这里使用了3个Buffer，是因为图像处理是很耗时的，所以为它单独开辟了线程去处理，为了线程同步问题，才增设了Buffer，关于线程这点稍后再说。&lt;/p&gt;

&lt;h2&gt;刷新贴图Buffer&lt;/h2&gt;
&lt;p&gt;　　贴图Buffer需要根据游戏逻辑中各个带有视野的单位去实时刷新，在正方形地图模型中，是根据单位当前位置和视野半径做圆，将圆内圈住的小正方形标记为探索。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RevealUsingRadius (IFOWRevealer r, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; worldToTex)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Position relative to the fog of war&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     Vector3 pos = (r.GetPosition() - mOrigin) *&lt;span&gt; worldToTex;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; radius = r.GetRadius() * worldToTex -&lt;span&gt; radiusOffset;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Coordinates we'll be dealing with&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; xmin = Mathf.RoundToInt(pos.x -&lt;span&gt; radius);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ymin = Mathf.RoundToInt(pos.z -&lt;span&gt; radius);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; xmax = Mathf.RoundToInt(pos.x +&lt;span&gt; radius);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ymax = Mathf.RoundToInt(pos.z +&lt;span&gt; radius);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; cx =&lt;span&gt; Mathf.RoundToInt(pos.x);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; cy =&lt;span&gt; Mathf.RoundToInt(pos.z);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     cx = Mathf.Clamp(cx, &lt;span&gt;0&lt;/span&gt;, textureSize - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     cy = Mathf.Clamp(cy, &lt;span&gt;0&lt;/span&gt;, textureSize - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; radiusSqr = Mathf.RoundToInt(radius *&lt;span&gt; radius);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; y = ymin; y &amp;lt; ymax; ++&lt;span&gt;y)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (y &amp;gt; -&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; y &amp;lt;&lt;span&gt; textureSize)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; yw = y *&lt;span&gt; textureSize;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x = xmin; x &amp;lt; xmax; ++&lt;span&gt;x)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (x &amp;gt; -&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; x &amp;lt;&lt;span&gt; textureSize)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; xd = x -&lt;span&gt; cx;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; yd = y -&lt;span&gt; cy;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; dist = xd * xd + yd *&lt;span&gt; yd;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reveal this pixel&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (dist &amp;lt; radiusSqr) mBuffer1[x + yw].r = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　第一个参数包含了视野单位的信息，包括位置和视野半径；第二个参数为世界坐标到贴图坐标的坐标变换，R通道用于记录视野信息。&lt;/p&gt;

&lt;h2&gt;贴图Buffer模糊&lt;/h2&gt;
&lt;p&gt;　　每次贴图刷新以后，进行一次贴图模糊处理。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BlurVisibility ()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    Color32 c;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; y = &lt;span&gt;0&lt;/span&gt;; y &amp;lt; textureSize; ++&lt;span&gt;y)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; yw = y *&lt;span&gt; textureSize;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; yw0 = (y - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (yw0 &amp;lt; &lt;span&gt;0&lt;/span&gt;) yw0 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; yw1 = (y + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (yw1 == textureSize) yw1 =&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         yw0 *=&lt;span&gt; textureSize;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         yw1 *=&lt;span&gt; textureSize;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; textureSize; ++&lt;span&gt;x)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; x0 = (x - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (x0 &amp;lt; &lt;span&gt;0&lt;/span&gt;) x0 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; x1 = (x + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (x1 == textureSize) x1 =&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; index = x +&lt;span&gt; yw;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; val =&lt;span&gt; mBuffer1[index].r;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;             val += mBuffer1[x0 +&lt;span&gt; yw].r;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             val += mBuffer1[x1 +&lt;span&gt; yw].r;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             val += mBuffer1[x +&lt;span&gt; yw0].r;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             val += mBuffer1[x +&lt;span&gt; yw1].r;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;             val += mBuffer1[x0 +&lt;span&gt; yw0].r;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             val += mBuffer1[x1 +&lt;span&gt; yw0].r;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             val += mBuffer1[x0 +&lt;span&gt; yw1].r;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             val += mBuffer1[x1 +&lt;span&gt; yw1].r;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;             c =&lt;span&gt; mBuffer2[index];
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             c.r = (&lt;span&gt;byte&lt;/span&gt;)(val / &lt;span&gt;9&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             mBuffer2[index] =&lt;span&gt; c;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Swap the buffer so that the blurred one is used&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     Color32[] temp =&lt;span&gt; mBuffer1;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     mBuffer1 =&lt;span&gt; mBuffer2;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     mBuffer2 =&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　用周围的8个小正方形进行了加权模糊，这里并没有像高斯模糊那样去分不同的权重。&lt;/p&gt;

&lt;h2&gt;Buffer运用到贴图&lt;/h2&gt;
&lt;p&gt;　　Buffer一旦处理完毕，就可以生成/刷新贴图供屏幕显示用，不管你使用上述说的方式中的哪一种，在Shader执行贴图采样时，这张贴图是必须的。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; UpdateTexture ()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;enableRender)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (mTexture == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Native ARGB format is the fastest as it involves no data conversion&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         mTexture = &lt;span&gt;new&lt;/span&gt; Texture2D(textureSize, textureSize, TextureFormat.ARGB32, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         mTexture.wrapMode =&lt;span&gt; TextureWrapMode.Clamp;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        mTexture.SetPixels32(mBuffer0);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        mTexture.Apply();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         mState =&lt;span&gt; State.Blending;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (mState ==&lt;span&gt; State.UpdateTexture)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        mTexture.SetPixels32(mBuffer0);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        mTexture.Apply();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         mBlendFactor =&lt;span&gt; 0f;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         mState =&lt;span&gt; State.Blending;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;屏幕渲染&lt;/h2&gt;
&lt;p&gt;　　主要是做两件事情：CS测在OnWillRenderObject给Shader传递参数；另外就是Shader中根据最新的战争迷雾贴图和战争迷雾颜色设定执行平滑过渡。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnWillRenderObject()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (mMat != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; FOWSystem.instance.texture != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         mMat.SetTexture(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_MainTex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FOWSystem.instance.texture);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         mMat.SetFloat(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_BlendFactor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FOWSystem.instance.blendFactor);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (FOWSystem.instance.enableFog)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             mMat.SetColor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_Unexplored&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, unexploredColor);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             mMat.SetColor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_Unexplored&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, exploredColor);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         mMat.SetColor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_Explored&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, exploredColor);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　其中blendFactor是过渡因子，会在Update中根据时间刷新，用于控制Shader的平滑过渡过程。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;fixed4 frag(v2f i) : SV_Target
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     half4 data =&lt;span&gt; tex2D(_MainTex, i.uv);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     half2 fog =&lt;span&gt; lerp(data.rg, data.ba, _BlendFactor);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     half4 color =&lt;span&gt; lerp(_Unexplored, _Explored, fog.g);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     color.a = (&lt;span&gt;1&lt;/span&gt; - fog.r) *&lt;span&gt; color.a;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; color;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; ENDCG
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　data是贴图，rg和ba通道是连续的两个战争迷雾状态的数据，其中r通道表示当前是否可见（是否在视野内），g通道表示是否被探索过（大于0则探索过）。&lt;/p&gt;

&lt;h2&gt;多线程&lt;/h2&gt;
&lt;p&gt;　　本例当作，贴图Buffer的刷新和模糊处理是在子线程处理的；而Buffer运用到贴图在主线程中；屏幕渲染在GPU当作。所以Unity主线程只是在不停地刷新贴图，而贴图Buffer和模糊处理这两个很耗性能的操作全部由子线程代劳，这就是标题所说的“高性能”原因所在，即使子线程每次的处理周期达到30毫秒，它依旧不会影响到游戏帧率。&lt;/p&gt;
&lt;p&gt;　　多线程编程必然要考虑的一点线程同步，此处主要的问题有两个：&lt;/p&gt;
&lt;p&gt;　　　　1）工作子线程输入：刷新贴图Buffer需要Unity主线程（或者游戏逻辑主线程）中游戏中的视野体数据（位置、视野半径）&lt;/p&gt;
&lt;p&gt;　　　　2）工作子线程输出：由最新的游戏逻辑数据刷新贴图Buffer，以及进行贴图Buffer混合以后，要在Unity主线程将数据运用到贴图&lt;/p&gt;
&lt;p&gt;　　工作子线程的输入同步问题稍后再说，这里说以下第二步是怎样去保证同步的，其大致步骤是：&lt;/p&gt;
&lt;p&gt;　　　　1）设置3个状态用于线程同步：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; State
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    Blending,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    NeedUpdate,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    UpdateTexture,
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　2）NeedUpdate表示子线程需要处理贴图Buffer，这个状态的设置是由设定的刷新频率和实际处理时的刷新速度决定的：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ThreadUpdate()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     System.Diagnostics.Stopwatch sw = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Diagnostics.Stopwatch();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (mThreadWork)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (mState ==&lt;span&gt; State.NeedUpdate)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            sw.Reset();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            sw.Start();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            UpdateBuffer();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            sw.Stop();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             mElapsed = &lt;span&gt;0.001f&lt;/span&gt; * (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)sw.ElapsedMilliseconds;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             mState =&lt;span&gt; State.UpdateTexture;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         Thread.Sleep(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; UNITY_EDITOR
&lt;span&gt;19&lt;/span&gt;     Debug.Log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FOW thread exit!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　3）子线程会将Unity主线程（或者游戏逻辑线程）提供的最新视野状态数据刷新到贴图Buffer1的R通道，然后使用Buffer2做临时缓存对Buffer1执行模糊，模糊以后交换双缓存，最后将Buffer1的bg通道拷贝到Buffer0，所以Buffer0的bg和rg通道分别存放了上一次刷洗和当前本次刷新的战争迷雾状态数据，Buffer0运用到贴图以后由Shader在这两个状态间进行平滑过渡。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RevealMap ()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; mTextureSizeSqr; ++&lt;span&gt;index)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (mBuffer1[index].g &amp;lt;&lt;span&gt; mBuffer1[index].r)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             mBuffer1[index].g =&lt;span&gt; mBuffer1[index].r;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; MergeBuffer()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; mTextureSizeSqr; ++&lt;span&gt;index)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         mBuffer0[index].b =&lt;span&gt; mBuffer1[index].r;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         mBuffer0[index].a =&lt;span&gt; mBuffer1[index].g;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　4）子线程工作处理完以后设置UpdateTexture状态，通知Unity主线程：“嘿，饭已经做好了，你来吃吧！”，Unity主线程随后将Buffer0缓存运用到贴图。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update ()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;enableSystem)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (textureBlendTime &amp;gt;&lt;span&gt; 0f)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         mBlendFactor = Mathf.Clamp01(mBlendFactor + Time.deltaTime /&lt;span&gt; textureBlendTime);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; mBlendFactor =&lt;span&gt; 1f;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (mState ==&lt;span&gt; State.Blending)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;float&lt;/span&gt; time =&lt;span&gt; Time.time;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (mNextUpdate &amp;lt;&lt;span&gt; time)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             mNextUpdate = time +&lt;span&gt; updateFrequency;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             mState =&lt;span&gt; State.NeedUpdate;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (mState !=&lt;span&gt; State.NeedUpdate)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        UpdateTexture();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　5）UpdateTexture执行完毕以后，进入Blending状态，此时Unity主线程要等待下一次更新时间，时间到则设置NeedUpdate状态，通知子线程：“嘿，家伙，你该做饭了！”。&lt;/p&gt;

&lt;h2&gt;模块分离&lt;/h2&gt;
&lt;p&gt;　　上面讲到贴图Buffer刷新子线程和Unity渲染主线程的同步与临界资源的互斥，现在来说说Unity主线程（游戏逻辑主线程）与贴图Buffer刷新子线程的同步。&lt;/p&gt;
&lt;p&gt;　　1）使用互斥锁同步视野体生命周期&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Revealers that the thread is currently working with&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; BetterList&amp;lt;IFOWRevealer&amp;gt; mRevealers = &lt;span&gt;new&lt;/span&gt; BetterList&amp;lt;IFOWRevealer&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Revealers that have been added since last update&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; BetterList&amp;lt;IFOWRevealer&amp;gt; mAdded = &lt;span&gt;new&lt;/span&gt; BetterList&amp;lt;IFOWRevealer&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Revealers that have been removed since last update&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; BetterList&amp;lt;IFOWRevealer&amp;gt; mRemoved = &lt;span&gt;new&lt;/span&gt; BetterList&amp;lt;IFOWRevealer&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddRevealer (IFOWRevealer rev)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (rev != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (mAdded) mAdded.Add(rev);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RemoveRevealer (IFOWRevealer rev)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (rev != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (mRemoved) mRemoved.Add(rev);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　这个应该没啥好说的，子线程在处理这两个列表时同样需要加锁。&lt;/p&gt;
&lt;p&gt;　　2）视野体使用IFOWRevelrs接口，方便模块隔离和扩展。同步问题这里采用了一种简单粗暴的方式，由于战争迷雾属于表现层面的东西，即使用于帧同步也不会有问题。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFOWRevealer
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给FOWSystem使用的接口&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsValid();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    Vector3 GetPosition();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt;&lt;span&gt; GetRadius();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给FOWLogic使用的接口，维护数据以及其有效性&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; Update(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; deltaMS);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Release();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　继承IFOWRevealer接口用来实现各种不同的视野体，本示例中给出了角色视野体与临时视野体的实现，其它视野体自行根据需要扩展。&lt;/p&gt;



&lt;p&gt;　　其它还有FOWlogic模块用来隔离FOW系统和游戏逻辑，FOWRender用于fow渲染等，不再一一说明，自行阅读代码。&lt;/p&gt;
&lt;p&gt;　　有关六边形地图的战争迷雾实现稍作变通应该做起来问题也不是太大，相关信息可以参考：&lt;a href=&quot;http://catlikecoding.com/unity/tutorials/hex-map/part-21/&quot; target=&quot;_blank&quot;&gt;Hex Map 21 Exploration&lt;/a&gt;和&lt;a href=&quot;http://catlikecoding.com/unity/tutorials/hex-map/part-22/&quot; target=&quot;_blank&quot;&gt;Hex Map 22 Advanced Vision&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　这一系列文章都有译文，英文不好的同学参考：&lt;a href=&quot;http://gad.qq.com/program/translateview/7213770&quot; target=&quot;_blank&quot;&gt;Unity 六边形地图系列（二十一）：探索&lt;/a&gt;和&lt;a href=&quot;http://gad.qq.com/program/translateview/7213940&quot; target=&quot;_blank&quot;&gt;Unity 六边形地图系列(二十二) ：高级视野效果&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　组后，本演示工程的核心算法是由&lt;a href=&quot;http://www.tasharen.com/forum/index.php?PHPSESSID=a53915lu8je2d1a9shmuem6to3&amp;amp;topic=1291.0&quot; target=&quot;_blank&quot;&gt;TasharenFogOfWar&lt;/a&gt;移植而来的，该插件由NGUI作者发布，不过已经被我大幅修改。&lt;/p&gt;



&lt;p&gt;　　最后附上本演示工程的GitHub地址：&lt;a href=&quot;https://github.com/smilehao/fog-of-war&quot; target=&quot;_blank&quot;&gt;https://github.com/smilehao/fog-of-war&lt;/a&gt;。&lt;/p&gt;

</description>
<pubDate>Wed, 22 Nov 2017 17:27:00 +0000</pubDate>
<dc:creator>SChivas</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SChivas/p/7881515.html</dc:identifier>
</item>
<item>
<title>【YFMemoryLeakDetector】人人都能理解的 iOS 内存泄露检测工具类 - iOS122</title>
<link>http://www.cnblogs.com/ios122/p/7882383.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ios122/p/7882383.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;即使到今天，iOS 应用的内存泄露检测，仍然是一个很重要的主题。我在一年前，项目中随手写过一个简单的工具类，当时的确解决了大问题。视图和控制器相关的内存泄露，几乎都不存在了。后来想着一直就那个工具，写一篇文章，不过一直没有写。&lt;/p&gt;
&lt;p&gt;时过境迁，今天在网上搜了下 “iOS 内存泄露检测”，各种讨论技术文章，有点头大。我忍不住看了下自己当时的代码，突然感觉自己的思路好特别，好有创意。我真的就是在“创建”时把数据记录到一个字典里，在“释放”时，从字典里移出对象；所谓的检测，其实就是打印那个字典，仍然在字典中的很有可能就是泄露喽。&lt;/p&gt;
&lt;p&gt;当然，还是有一些技术细节的。我把旧代码适度拆分整理为一个开源库了，取名为 &lt;a href=&quot;https://github.com/ios122/YFMemoryLeakDetector&quot;&gt;YFMemoryLeakDetector&lt;/a&gt;。本篇，将着重讲述简洁之下，可能不易察觉的一些考量。&lt;/p&gt;
&lt;p&gt;注意：这个库，相当程度上是为当时的项目量身定制的，你可能需要适当修改，才能在自己的项目中真正发挥出它的力量。&lt;/p&gt;
&lt;h2 id=&quot;核心技术分析&quot;&gt;核心技术分析&lt;/h2&gt;
&lt;h3 id=&quot;aop-机制借助-aspects-库实现&quot;&gt;AOP 机制，借助 Aspects 库实现&lt;/h3&gt;
&lt;p&gt;Aspects 这个库的基本用法，我专门说过，大家可以参考 &lt;a href=&quot;http://www.cnblogs.com/ios122/p/4763060.html&quot;&gt;Aspects– iOS的AOP面向切面编程的库&lt;/a&gt;。当然，用黑魔法直接操作运行时，也是很酷的。不过我当时的确是因为偷懒，才用的 Aspects。一直到现在，我依然觉得，它可能比黑魔法更可靠些。&lt;/p&gt;
&lt;h3 id=&quot;在字典中直接存储指针地址而不是直接存储对象自身&quot;&gt;在字典中直接存储指针地址，而不是直接存储对象自身&lt;/h3&gt;
&lt;p&gt;存储指针地址的好处是，就是不会因为存储本身影响对象的引用计数。当然，指针地址本身，在 OC 中，其实就是对象自身。而要想得到存地址，不存对象的效果，就要祭出整个工具库的灵魂函数：&lt;/p&gt;
&lt;pre class=&quot;oc&quot;&gt;
&lt;code&gt;NSValue * key = [NSValue valueWithPointer: (__bridge const void * _Nullable)(info.instance)];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将对象转换为 NSValue，直接以 NSValue 为键，来标记对象。这句代码，是整个机制的灵魂所在，也是比其他类似的内存泄露分析库更简洁的重要原因之一。我当时也是搜遍的整个网络，才知道自己要的究竟是什么。&lt;/p&gt;
&lt;p&gt;另外，还有一点必须提一下， NSValue 是可以在反向转换为 oc 对象的，这有利于你在拿到工具库提供的泄露信息后，进一步定位和分析问题：&lt;/p&gt;
&lt;pre class=&quot;oc&quot;&gt;
&lt;code&gt;UIViewController * vc = (UIViewController *)[key pointerValue];&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对控制器和视图采用不同的拦截策略&quot;&gt;对控制器和视图，采用不同的拦截策略&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;对象销毁，统一拦截的是 &lt;strong&gt;dealloc&lt;/strong&gt;。现在网上的很多策略，基本也是这样。&lt;/li&gt;
&lt;li&gt;对象创建，对于视图，拦截的是 &lt;strong&gt;willMoveToSuperview:&lt;/strong&gt; ；对于控制器拦截的是 &lt;strong&gt;viewDidLoad&lt;/strong&gt; 。直到现在，我依然以为，没有调用过这两个方法的视图或控制器对象，本身没有多大的拦截价值。当然，这依然因项目而异。作为一个工具类，只要它能解决大多数场景下的问题，我觉得就可以了。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;在-load-时自动开启监测&quot;&gt;在 &lt;strong&gt;load&lt;/strong&gt; 时，自动开启监测&lt;/h3&gt;
&lt;p&gt;所以，你只要把&lt;a href=&quot;https://github.com/ios122/YFMemoryLeakDetector/tree/master/memory_leak_detection/memory_leak_detection/lib&quot;&gt;工具库源码&lt;/a&gt;拖拽到项目中，不需要任何修改，就可以自动监测内存泄露情况了。然后在需要的地方，在合适的时候，去读取 YFMemoryLeakDetector 的单例属性，分析结果即可。当然，这是我今天重构优化过的版本。原来是需要手动初始化的，好 Low，当时写的!&lt;/p&gt;
&lt;pre class=&quot;oc&quot;&gt;
&lt;code&gt;+ (void)load
{
    [[YFMemoryLeakDetector sharedInstance] setup];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;见码如晤&quot;&gt;“见码如晤”&lt;/h2&gt;
&lt;p&gt;YFMemoryLeakDetector.h 头文件部分，主要简化为暴露了存储可能有内存泄露情况的视图和控制器的字典属性；同时提供了一个单例方法，以便于具体分析和操作内存分析情况。&lt;/p&gt;
&lt;pre class=&quot;oc&quot;&gt;
&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

/**
 *  分析页面和页面内视图是否有内存泄露的情况.
 */
@interface  YFMemoryLeakDetector: NSObject

#pragma mark - 属性.

/*
  已加载,但尚未正确释放,有内存风险的控制器对象.
 
 以指针地址为key,以对象字符串为值.所以不用担心因为记录本身而引起的内存泄露问题.
 
 必要时,可以使用类似 (UIViewController *)[key pointerValue] 的语法来获取原始的 OC对象来进一步做些过滤操作.
 */
@property (strong, atomic) NSMutableDictionary * loadedViewControllers;

/*
 已加载,但尚未正确释放,有内存风险的视图对象.
 
 以指针地址为key,以对象字符串为值.所以不用担心因为记录本身而引起的内存泄露问题.
 
 必要时,可以使用类似 (UIView *)[key pointerValue] 的语法来获取原始的 OC对象来进一步做些过滤操作.
 */
@property (strong, atomic) NSMutableDictionary * loadedViews; //!&amp;lt; 已加载的视图.



#pragma mark - 单例方法.
+(YFMemoryLeakDetector *) sharedInstance;
@end
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;YFMemoryLeakDetector.m 实现，借助于 &lt;strong&gt;Aspects&lt;/strong&gt; 和 &lt;strong&gt;valueWithPointer：&lt;/strong&gt; 代码大大简化。&lt;/p&gt;
&lt;pre class=&quot;oc&quot;&gt;
&lt;code&gt;#import &amp;lt;objc/runtime.h&amp;gt;
#import &amp;lt;UIKit/UIKit.h&amp;gt;

#import &quot;YFMemoryLeakDetector.h&quot;
#import &quot;Aspects.h&quot;

@interface  YFMemoryLeakDetector()
@end

@implementation  YFMemoryLeakDetector

static YFMemoryLeakDetector * sharedLocalSession = nil;

+ (void)load
{
    [[YFMemoryLeakDetector sharedInstance] setup];
}

+(YFMemoryLeakDetector *) sharedInstance{
    @synchronized(self){
        if (sharedLocalSession == nil) {
            sharedLocalSession = [[self alloc] init];
        }
    }
    return  sharedLocalSession;
}


- (void)setup
{
    self.loadedViewControllers = [NSMutableDictionary dictionaryWithCapacity: 42];
    self.loadedViews = [NSMutableDictionary dictionaryWithCapacity:42];
    
    /* 控制器循环引用的检测. */
    [UIViewController aspect_hookSelector:@selector(viewDidLoad) withOptions:AspectPositionAfter usingBlock:^(id&amp;lt;AspectInfo&amp;gt; info) {
        NSValue * key = [NSValue valueWithPointer: (__bridge const void * _Nullable)(info.instance)];

        [self.loadedViewControllers setObject:[NSString stringWithFormat:@&quot;%@&quot;, info.instance] forKey:key];
    }error:NULL];
    
    [UIViewController aspect_hookSelector:NSSelectorFromString(@&quot;dealloc&quot;) withOptions:AspectPositionBefore usingBlock:^(id&amp;lt;AspectInfo&amp;gt; info) {
        NSValue * key = [NSValue valueWithPointer: (__bridge const void * _Nullable)(info.instance)];

        [self.loadedViewControllers removeObjectForKey: key];
    }error:NULL];
    
    /* 视图循环引用的检测. */
    /* 只捕捉已经从父视图移除,却未释放的视图.以指针区分. */
    [UIView aspect_hookSelector:@selector(willMoveToSuperview:) withOptions:AspectPositionBefore usingBlock:^(id&amp;lt;AspectInfo&amp;gt; info, UIView * superview){
        /* 过滤以 _ 开头的私有类. */
        NSString * viewClassname = NSStringFromClass(object_getClass(info.instance));
        if ([viewClassname hasPrefix:@&quot;_&quot;]) {
            return;
        }
        
        /* 兼容处理使用了KVO机制监测 delloc 方法的库,如 RAC. */
        if ([viewClassname hasPrefix:@&quot;NSKVONotifying_&quot;]) {
            return;
        }
        
        NSValue * key = [NSValue valueWithPointer: (__bridge const void * _Nullable)(info.instance)];
        
        /* 从父视图移除时,就直接判定为已释放.
         这样做的合理性在于:当视图从父视图移除后,一般是很难再出发循环引用的条件了,所以可适度忽略.
         */
        if (!superview) {
            [self.loadedViews removeObjectForKey: key];
        }
        
        NSMutableDictionary * obj = [self.loadedViews objectForKey: key];
        
        if (obj) { /* 一个 UIView 视图,只记录一次即可.因为一个UIView,最多只被 delloc 一次. */
            return;
        }
        
        [self.loadedViews setObject: [NSString stringWithFormat:@&quot;%@&quot;, info.instance] forKey:key];
        
        /* 仅对有效实例进行捕捉.直接捕捉类对象,会引起未知崩溃,尤其涉及到和其他有KVO机制的类库配合使用时. */
        [info.instance aspect_hookSelector:NSSelectorFromString(@&quot;dealloc&quot;) withOptions:AspectPositionBefore usingBlock:^(id&amp;lt;AspectInfo&amp;gt; info){
            [self.loadedViews removeObjectForKey: key];
        }error:NULL];
    }error:NULL];
}
@end
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用示例&quot;&gt;使用示例：&lt;/h2&gt;
&lt;p&gt;这里展示一个基于工具类，二次分析的示例:&lt;/p&gt;
&lt;pre class=&quot;oc&quot;&gt;
&lt;code&gt;YFMemoryLeakDetector * memoryLeakDetector = [YFMemoryLeakDetector sharedInstance];
        
/* 控制器检测结果的输出. */
[memoryLeakDetector.loadedViewControllers enumerateKeysAndObjectsUsingBlock:^(NSValue *  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {
    UIViewController * vc = (UIViewController *)[key pointerValue];
    if (!vc.parentViewController) { /* 进一步过滤掉有父控制器的控制器. */
        NSLog(@&quot;有内存泄露风险的控制器: %@&quot;, obj);
    }
}];
    
/* 视图检测结果的输出. */
[memoryLeakDetector.loadedViews enumerateKeysAndObjectsUsingBlock:^(NSValue *  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {
    UIView * view = (UIView *)[key pointerValue];
    if (!view.superview) { /* 进一步过滤掉有父视图的视图,即只输出一组视图的根节点,这样便于更进一步定位问题. */
        NSLog(@&quot;有内存泄露风险的视图: %@&quot;, obj);
    }
}];&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
</description>
<pubDate>Wed, 22 Nov 2017 17:23:00 +0000</pubDate>
<dc:creator>iOS122</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ios122/p/7882383.html</dc:identifier>
</item>
<item>
<title>9. 使用ZooKeeper Java API编程 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/7882107.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/7882107.html</guid>
<description>&lt;p&gt;ZooKeeper是用Java开发的，3.4.6版本的Java API文档可以在http://zookeeper.apache.org/doc/r3.4.6/api/index.html上找到。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;本章的代码在Linux操作系统下进行测试，运行ZooKeeper服务器实例的版本为3.4.6。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开发应用程序的ZooKeeper Java绑定主要由两个Java包组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;org.apache.zookeeper&lt;/li&gt;
&lt;li&gt;org.apache.zookeeper.data&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;org.apache.zookeeper包由ZooKeeper监视的接口定义和ZooKeeper的各种回调处理程序组成。 它定义了ZooKeeper客户端类库的主要类以及许多ZooKeeper事件类型和状态的静态定义。 org.apache.zookeeper.data包定义了与数据寄存器（也称为znode）相关的特性，例如访问控制列表（ACL），IDs，stats等。&lt;/p&gt;
&lt;p&gt;ZooKeeper Java API中的org.apache.zookeeper.server，org.apache.zookeeper.server.quorum和org.apache.zookeeper.server.upgrade包是服务器实现的一部分。 org.apache.zookeeper.client包用于查询ZooKeeper服务器的状态。&lt;/p&gt;
&lt;h3 id=&quot;一-准备开发环境&quot;&gt;一 准备开发环境&lt;/h3&gt;
&lt;p&gt;Apache ZooKeeper是一个复杂的软件，因此它需要运行许多其他类库。 依赖库作为jar文件在ZooKeeper发行版中附带在lib目录中。 核心ZooKeeper jar文件名字为zookeeper-3.4.6.jar，位于主目录下。&lt;/p&gt;
&lt;p&gt;要开发Java的ZooKeeper应用程序，我们必须设置指向ZooKeeper jar的类路径，以及ZooKeeper所依赖的所有第三方库。在 bin 目录下有一个 zkEnv.sh文件，可以用来设置CLASSPATH。&lt;/p&gt;
&lt;p&gt;我们需要将脚本如下设置，在命令行中执行以下语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ZOOBINDIR=${ZK_HOME}/bin
$ source ${ZOOBINDIR}/zkEnv.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;shell变量&lt;code&gt;ZK_HOME&lt;/code&gt;被设置为安装ZooKeeper的路径，在我的设置中，它是&lt;code&gt;/usr/share/zookeeper&lt;/code&gt;。 之后，CLASSPATH变量被正确设置，在我的系统中，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ echo $CLASSPATH 
/usr/share/zookeeper-3.4.6/bin/../build/classes :/usr/share/zookeeper-3.4.6/bin/../build/lib/*.jar :/usr/share/zookeeper-3.4.6/bin/../lib/slf4j-log4j12-1.6.1.jar :/usr/share/zookeeper-3.4.6/bin/../lib/slf4j-api-1.6.1.jar :/usr/share/zookeeper-3.4.6/bin/../lib/netty-3.7.0.Final.jar :/usr/share/zookeeper-3.4.6/bin/../lib/log4j-1.2.16.jar :/usr/share/zookeeper-3.4.6/bin/../lib/jline-0.9.94.jar :/usr/share/zookeeper-3.4.6/bin/../zookeeper-3.4.6.jar :/usr/share/zookeeper-3.4.6/bin/../src/java/lib/*.jar :/usr/share/zookeeper-3.4.6/bin/../conf:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Windows操作系统中，需要运行zkEnv.cmd脚本。 现在可以使用CLASSPATH变量来编译和运行使用ZooKeeper API编写的Java程序。 可以在Uni/Linux中的主目录的.bashrc文件中找到zkEnv.sh脚本，避免每次启动shell会话时都采用它。&lt;/p&gt;
&lt;h3 id=&quot;二-第一个zookeeper程序&quot;&gt;二 第一个ZooKeeper程序&lt;/h3&gt;
&lt;p&gt;为了引入ZooKeeper Java API，让我们从一个非常简单的程序开始，它可以连接到localhost中的ZooKeeper实例，如果连接成功，它将在ZooKeeper名称空间的根路径下打印znode的列表。&lt;/p&gt;
&lt;p&gt;这个程序的代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*Our First ZooKeeper Program*/
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.ZooKeeper;
public class HelloZooKeeper {
  public static void main(String[] args) throws IOException {
    String hostPort = &quot;localhost:2181&quot;;
    String zpath = &quot;/&quot;;
    List &amp;lt;String&amp;gt; zooChildren = new ArrayList&amp;lt;String&amp;gt;();
    ZooKeeper zk = new ZooKeeper(hostPort, 2000, null);
    if (zk != null) {
      try {
        zooChildren = zk.getChildren(zpath, false);
        System.out.println(&quot;Znodes of '/': &quot;);
        for (String child: zooChildren) {
          //print the children
          System.out.println(child);
        }
      } catch (KeeperException e) {
        e.printStackTrace();
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在构建和执行前面的代码片段之前，让我们来看看它具体做了什么。代码从导入语句开始。使用这些语句，我们导入了程序各个组件所需的包。如前所述，org.apache.zookeeper包包含客户端与ZooKeeper服务器进行交互所需的所有类和接口。在导入包之后，定义了一个名为&lt;code&gt;HelloZooKeeper&lt;/code&gt;的类。由于我们要连接到在同一系统中运行的ZooKeeper实例，在&lt;code&gt;main&lt;/code&gt;方法中将主机和端口字符串定义为&lt;code&gt;localhost:2181&lt;/code&gt;。代码行&lt;code&gt;zk = new ZooKeeper(hostPort, 2000, null)&lt;/code&gt;调用ZooKeeper构造方法，该构造方法尝试连接到ZooKeeper服务器并返回一个引用。对于连接到ZooKeeper服务器实例并维护该连接的客户端程序，需要维护一个实时会话。在此例中，构造方法实例化的&lt;code&gt;zk&lt;/code&gt;对象返回的引用表示这个会话。 ZooKeeper API是围绕这个引用构建的，每个方法调用都需要一个引用来执行。&lt;/p&gt;
&lt;p&gt;ZooKeeper类的构造方法使用以下代码创建ZooKeeper实例的引用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用的参数含义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;connectString：以逗号分隔的主机:端口号列表，每个对应一个ZooKeeper服务器。 例如，10.0.0.1:2001，10.0.0.2:2002和10.0.0.3:2003表示三个节点的ZooKeeper ensemble的有效的主机:端口匹配对。&lt;/li&gt;
&lt;li&gt;sessionTimeout：这是以毫秒为单位的会话超时时间。这是ZooKeeper在宣布session结束之前，没有从客户端获得心跳的时间。&lt;/li&gt;
&lt;li&gt;watcher：一个watcher对象，如果创建，当状态改变和发生节点事件时会收到通知。这个watcher对象需要通过一个用户定义的类单独创建，通过实现&lt;code&gt;Watcher&lt;/code&gt;接口并将实例化的对象传递给ZooKeeper构造方法。客户端应用程序可以收到各种类型的事件的通知，例如连接丢失、会话过期等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ZooKeeper Java API定义了另外带有三个参数的构造方法，以指定更高级的操作。代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ZooKeeper类的上面的构造方法中，如果设置为true，&lt;code&gt;boolean canBeReadOnly&lt;/code&gt;参数允许创建的客户端在网络分区的情况下进入只读模式。只读模式是客户端无法找到任何多数服务器的场景，但有一个可以到达的分区服务器，以只读模式连接到它，这样就允许对服务器的读取请求，而写入请求则不允许。客户端继续尝试在后台连接到大多数服务器，同时仍然保持只读模式。分区服务器仅仅是ZooKeeper组的一个子集，它是由于集群中的网络分配而形成的。大多数服务器构成了ensemble中的大多数quorum。&lt;/p&gt;
&lt;p&gt;以下构造方法显示了两个附加参数的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ZooKeeper(String connectString, int sessionTimeout, Watcher watcher, long sessionId, byte[] sessionPasswd)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个构造方法允许ZooKeeper客户端对象创建两个额外的参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sessionId：在客户端重新连接到ZooKeeper服务器的情况下，可以使用特定的会话ID来引用先前连接的会话&lt;/li&gt;
&lt;li&gt;sessionPasswd：如果指定的会话需要密码，可以在这里指定&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下构造方法是前两个调用的组合：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ZooKeeper(String connectString, int sessionTimeout,Watcher watcher, long sessionId, byte[] sessionPasswd,boolean canBeReadOnly)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此构造方法是前两个调用的组合，允许在启用只读模式的情况下重新连接到指定的会话。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Note&lt;br/&gt;ZooKeeper类的详细Java API文档可以在http://zookeeper.apache.org/doc/r3.4.6/api/index.html上查询。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，回到我们的ZooKeeper程序。 在调用构造方法后，如果连接成功，我们将得到ZooKeeper服务器的引用。 我们通过下面的代码将引用传递给&lt;code&gt;getChildren&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zooChildren = zk.getChildren(zpath, false)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ZooKeeper类的&lt;code&gt;getChildren(String path，boolean watch)&lt;/code&gt;方法返回给定路径上znode的子级列表。 我们只是迭代这个方法返回的列表，并将字符串打印到控制台。&lt;/p&gt;
&lt;p&gt;将程序命名为HelloZooKeeper.java，并编译我们的程序如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ javac -cp $CLASSPATH HelloZooKeeper.java&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我们运行的程序之前，需要使用以下命令来启动ZooKeeper服务器实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ${ZK_HOME}/bin/zkServer.sh start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ java -cp $CLASSPATH HelloZooKeeper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行程序会在控制台上打印日志消息，显示所使用的ZooKeeper版本，Java版本，Java类路径，服务器体系结构等等。 这里显示了这些日志消息的一部分：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-b0559923f3d0550a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;输出结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ZooKeeper Java API生成的日志消息对调试非常有用。 它为我们提供了关于客户端连接到ZooKeeper服务器，建立会话等后台得信息。 上面显示的最后三条日志消息告诉我们客户端如何使用程序中指定的参数来启动连接，以及在成功连接后，服务器如何为客户端分配会话ID。&lt;/p&gt;
&lt;p&gt;最后，程序执行最后在控制台中输出以下内容：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-fe8c8ffb7231df05.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;子节点信息&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用ZooKeeper shell来验证程序的正确性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ $ZK_HOME/bin/zkCli.sh -server localhost&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-c40aae7a17a7d5d8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;shell 输出结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;恭喜！ 我们刚刚成功编写了我们的第一个ZooKeeper客户端程序。&lt;/p&gt;
&lt;h3 id=&quot;二-实现watcher接口&quot;&gt;二 实现Watcher接口&lt;/h3&gt;
&lt;p&gt;ZooKeeper Watcher监视使客户端能够接收来自ZooKeeper服务器的通知，并在发生时处理这些事件。 ZooKeeper Java API提供了一个名为&lt;code&gt;Watcher&lt;/code&gt;的公共接口，客户端事件处理程序类必须实现该接口才能接收有关来自ZooKeeper服务器的事件通知。 以编程方式，使用这种客户端的应用程序通过向客户端注册回调(callback)对象来处理这些事件。&lt;/p&gt;
&lt;p&gt;我们将实现&lt;code&gt;Watcher&lt;/code&gt;接口，处理与znode关联的数据更改时由ZooKeeper生成的事件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Watcher&lt;/code&gt;接口在org.apache.zookeeper包中声明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Watcher {
  void process(WatchedEvent event);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了演示znode数据监视器（Watcher），有两个Java类：&lt;code&gt;DataWatcher&lt;/code&gt;和&lt;code&gt;DataUpdater&lt;/code&gt;。 &lt;code&gt;DataWatcher&lt;/code&gt;将一直运行，并在&lt;code&gt;/MyConfig&lt;/code&gt;指定znode路径中侦听来自ZooKeeper服务器的&lt;code&gt;NodeDataChange&lt;/code&gt;事件。&lt;code&gt;DataUpdate&lt;/code&gt;r类将定期更新此znode路径中的数据字段，这将生成事件，并且在接收到这些事件后，&lt;code&gt;DataWatcher&lt;/code&gt;类将把更改后的数据打印到控制台上。&lt;/p&gt;
&lt;p&gt;以下是&lt;code&gt;DataWatcher.java&lt;/code&gt;类的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.io.IOException;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooDefs;
import org.apache.zookeeper.ZooKeeper;

public class DataWatcher implements Watcher, Runnable {
  private static String hostPort = &quot;localhost:2181&quot;;
  private static String zooDataPath = &quot;/MyConfig&quot;;
  byte zoo_data[] = null;
  ZooKeeper zk;

  public DataWatcher() {
    try {
      zk = new ZooKeeper(hostPort, 2000, this);
      if (zk != null) {
        try {
          //Create the znode if it doesn't exist, with the following code:
          if (zk.exists(zooDataPath, this) == null) {
            zk.create(zooDataPath, &quot;&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
          }
        } catch (KeeperException | InterruptedException e) {
          e.printStackTrace();
        }
      }
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
  public void printData() throws InterruptedException, KeeperException {
    zoo_data = zk.getData(zooDataPath, this, null);
    String zString = new String(zoo_data);
    // The following code prints the current content of the znode to the console:
    System.out.printf(&quot;\nCurrent Data @ ZK Path %s: %s&quot;, zooDataPath, zString);
  }
  @Override
  public void process(WatchedEvent event) {
    System.out.printf(
    &quot;\nEvent Received: %s&quot;, event.toString());
    //We will process only events of type NodeDataChanged
    if (event.getType() == Event.EventType.NodeDataChanged) {
      try {
        printData();
      } catch (InterruptedException e) {
        e.printStackTrace();
      } catch (KeeperException e) {
        e.printStackTrace();
      }
    }
  }
  public static void main(String[] args)
  throws InterruptedException, KeeperException {
    DataWatcher dataWatcher = new DataWatcher();
    dataWatcher.printData();
    dataWatcher.run();
  }
  public void run() {
    try {
      synchronized (this) {
        while (true) {
          wait();
        }
      }
    } catch (InterruptedException e) {
      e.printStackTrace();
      Thread.currentThread().interrupt();
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看一下&lt;code&gt;DataWatcher.java&lt;/code&gt;类的代码来理解一个ZooKeeper监视器的实现。 &lt;code&gt;DataWatcher&lt;/code&gt;公共类实现&lt;code&gt;Watcher&lt;/code&gt;接口以及&lt;code&gt;Runnable&lt;/code&gt;接口，打算将监视器作为线程运行。 &lt;code&gt;main&lt;/code&gt;方法创建&lt;code&gt;DataWatcher&lt;/code&gt;类的一个实例。 在前面的代码中&lt;code&gt;，DataWatcher&lt;/code&gt;构造方法尝试连接到在本地主机上运行的ZooKeeper实例。 如果连接成功，我们用下面的代码检查znode路径&lt;code&gt;/MyConfig&lt;/code&gt;是否存在：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (zk.exists(zooDataPath, this) == null) {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果znode不存在ZooKeeper命名空间中，那么&lt;code&gt;exists&lt;/code&gt;方法调用将返回null，并且尝试使用代码将其创建为持久化znode，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zk.create(zooDataPath, &quot;&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来是&lt;code&gt;process&lt;/code&gt;方法，它在org.apache.ZooKeeper的&lt;code&gt;Watcher&lt;/code&gt;接口中声明，并由&lt;code&gt;DataWatcher&lt;/code&gt;类使用以下代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void process(WatchedEvent event) {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了简单起见，在&lt;code&gt;process&lt;/code&gt;方法中，打印从ZooKeeper实例接收的事件，并仅对&lt;code&gt;NodeDataChanged&lt;/code&gt;类型的事件进行进一步处理，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (event.getType() == Event.EventType.NodeDataChanged)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当znode路径&lt;code&gt;/MyConfig&lt;/code&gt;的数据字段发生任何更新或更改而收到&lt;code&gt;NodeDataChanged&lt;/code&gt;类型的事件时，调用&lt;code&gt;printData&lt;/code&gt;方法来打印znode的当前内容。 在znode上执行一个&lt;code&gt;getData&lt;/code&gt;调用时，我们再次设置一个监视，这是该方法的第二个参数，如下面的代码所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zoo_data = zk.getData(zooDataPath, this, null);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;监视事件是发送给设置监视的客户端的一次性触发器，为了不断接收进一步的事件通知，客户端应该重置监视器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DataUpdater.java&lt;/code&gt;是一个简单的类，它连接到运行本地主机的ZooKeeper实例，并用随机字符串更新znode路径&lt;code&gt;/MyConfig&lt;/code&gt;的数据字段。 在这里，我们选择使用通用唯一标识符（UUID）字符串更新znode，因为后续的UUID生成器调用将保证生成唯一的字符串。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DataUpdater.java&lt;/code&gt;类代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.io.IOException;
import java.util.UUID;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooKeeper;
public class DataUpdater implements Watcher {
  private static String hostPort = &quot;localhost:2181&quot;;
  private static String zooDataPath = &quot;/MyConfig&quot;;
  ZooKeeper zk;

  public DataUpdater() throws IOException {
    try {
      zk = new ZooKeeper(hostPort, 2000, this);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

// updates the znode path /MyConfig every 5 seconds with a new UUID string.
public void run() throws InterruptedException, KeeperException {
    while (true) {
      String uuid = UUID.randomUUID().toString();
      byte zoo_data[] = uuid.getBytes();
      zk.setData(zooDataPath, zoo_data, -1);
      try {
        Thread.sleep(5000); // Sleep for 5 secs
      } catch(InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
  }

public static void main(String[] args) throws
  IOException, InterruptedException, KeeperException {
    DataUpdater dataUpdater = new DataUpdater();
    dataUpdater.run();
  }
  @Override
  public void process(WatchedEvent event) {
    System.out.printf(&quot;\nEvent Received: %s&quot;, event.toString());
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码使ZooKeeper服务器触发一个&lt;code&gt;NodeDataChanged&lt;/code&gt;事件。 由于&lt;code&gt;DataWatcher&lt;/code&gt;为此znode路径设置了监视，因此它会接收数据更改事件的通知。 然后它检索更新的数据，重置监视，并在控制台上打印数据。&lt;/p&gt;
&lt;p&gt;使用以下命令编译&lt;code&gt;DataWatcher&lt;/code&gt;和&lt;code&gt;DataUpdater&lt;/code&gt;类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ javac –cp $CLASSPATH DataWatcher.java
$ javac –cp $CLASSPATH DataUpdater.java&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要执行监视器和更新程序，需要打开两个终端窗口。 我要先运行监视器，因为它创建了&lt;code&gt;/MyConfig&lt;/code&gt;的znode（如果还未在ZooKeeper的命名空间中创建的话）。 运行监视器之前，请确保ZooKeeper服务器在本地主机上已经运行。&lt;/p&gt;
&lt;p&gt;在其中一个终端窗口中，通过运行以下命令来执行watcher类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ java –cp $CLASSPATH DataWatcher&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出类似于以下屏幕截图所示的消息：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-c04a568b02dbe1aa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;DataWatcher输出&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如前面的截图所示，znode路径&lt;code&gt;/MyConfig&lt;/code&gt;是由&lt;code&gt;DataWatcher&lt;/code&gt;类创建的。 它也打印znode的内容，但没有打印在控制台中，因为我们在创建znode时没有设置任何数据。 当znode被创建时，类中的监视者收到了&lt;code&gt;NodeCreated&lt;/code&gt;类型的事件通知，这个通知被打印在控制台中。 &lt;code&gt;DataWatcher&lt;/code&gt;类继续运行，并从ZooKeeper服务器侦听&lt;code&gt;/MyConfig&lt;/code&gt;节点上的事件。&lt;/p&gt;
&lt;p&gt;让我们在另一个终端窗口中运行&lt;code&gt;DataUpdater&lt;/code&gt;类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ java -cp $CLASSPATH DataUpdater&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将最初的ZooKeeper特定日志消息记录到控制台后，&lt;code&gt;DataUpdater&lt;/code&gt;类运行时没有提示。 它将一个新的UUID字符串设置到ZooKeeper路径&lt;code&gt;/MyConfig&lt;/code&gt;的数据字段中。 因此，看到每隔5秒钟，在下面的屏幕截图中显示的输出内容打印在运行&lt;code&gt;DataWatche&lt;/code&gt;的终端窗口中：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-0c254e3cdca6f3af.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;DataUpdater输出&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DataWatcher&lt;/code&gt;也可以使用ZooKeeper shell进行测试。 继续像以前一样在终端中运行&lt;code&gt;DataWatcher&lt;/code&gt;类，并在另一个终端中调用ZooKeeper shell并运行以下屏幕截图中所示的命令：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-7f5b69d7ea4b60d7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Shell 测试&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在DataWatcher正在运行的终端中，将打印以下消息：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-acd6a8eef203531b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;事件捕获&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三-示例群集监视器&quot;&gt;三 示例——群集监视器&lt;/h3&gt;
&lt;p&gt;通过互联网提供的流行服务，如电子邮件，文件服务平台，在线游戏等，都是通过跨越多个数据中心的高度可用的成百上千台服务器来服务的，而这些服务器通常在地理位置上分开。 在这种集群中，设置了一些专用的服务器节点来监视生产网络中承载服务或应用程序的服务器的活跃性。 在云计算环境中，也用于管理云环境的这种监控节点被称为云控制器。 这些控制器节点的一个重要工作是实时检测生产服务器的故障，并相应地通知管理员，并采取必要的措施，例如将故障服务器上的应用程序故障转移到另一个服务器，从而确保容错性和高可用性。&lt;/p&gt;
&lt;p&gt;在本节中，我们将使用ZooKeeper Java客户端API开发一个简约的分布式集群监视器模型。 使用ZooKeeper的ephemeral znode概念来构建这个监视模型相当简单和优雅，如以下步骤所述：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个生产服务器运行一个ZooKeeper客户端作为守护进程。 这个过程连接到ZooKeeper服务器，并在&lt;code&gt;/ZooKeeper&lt;/code&gt;命名空间的预定义路径（比如&lt;code&gt;/Members&lt;/code&gt;）下创建一个带有名称（最好是其网络名称或主机名）的ephemeral znode。&lt;/li&gt;
&lt;li&gt;云控制器节点运行ZooKeeper监视器进程，该进程监视路径&lt;code&gt;/Members&lt;/code&gt;并监听&lt;code&gt;NodeChildrenChanged&lt;/code&gt;类型的事件。 这个监视器进程作为服务或守护进程运行，并设置或重置路径上的监视，并且实现其逻辑以调用适当的模块来为监视事件采取必要的行动。&lt;/li&gt;
&lt;li&gt;现在，如果生产服务器由于硬件故障或软件崩溃而关闭，ZooKeeper客户端进程就会被终止，导致服务器和ZooKeeper服务之间的会话被终止。 由于ephemeral znode的属性唯一，每当客户端连接关闭时，ZooKeeper服务会自动删除路径&lt;code&gt;/Members&lt;/code&gt;中的znode。&lt;/li&gt;
&lt;li&gt;路径中znode的删除引发了&lt;code&gt;NodeChildrenChanged&lt;/code&gt;事件，因此云控制器中的观察器进程会收到通知。 通过调用路径&lt;code&gt;/Members&lt;/code&gt;中的&lt;code&gt;getChildren&lt;/code&gt;方法，可以确定哪个服务器节点已经关闭。&lt;/li&gt;
&lt;li&gt;然后，控制器节点可以采取适当的措施，比如执行恢复逻辑以重启另一台服务器中的故障服务。&lt;/li&gt;
&lt;li&gt;这个逻辑可以构建为实时工作，保证接近于零停机的时间和高度可用的服务。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为实现这个集群监控模型，我们将开发两个Java类。 &lt;code&gt;ClusterMonito&lt;/code&gt;r类将持续运行监视器，以监视ZooKeeper树中的路径&lt;code&gt;/Members&lt;/code&gt;。 处理完引发事件后，我们将在控制台中打印znode列表并重置监视。 另一个类&lt;code&gt;ClusterClient&lt;/code&gt;将启动到ZooKeeper服务器的连接，在&lt;code&gt;/Members&lt;/code&gt;下创建一个ephemeral znode。&lt;/p&gt;
&lt;p&gt;要模拟具有多个节点的集群，我们在同一台计算机上启动多个客户端，并使用客户端进程的进程ID创建ephemeral znode。 通过查看进程标识，&lt;code&gt;ClusterMonito&lt;/code&gt;r类可以确定哪个客户进程已经关闭，哪些进程还在。 在实际情况中，客户端进程通常会使用当前正在运行的服务器的主机名创建ephemeral znode。 下面显示了这两个类的源代码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ClusterMonitor.java&lt;/code&gt;类定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.io.IOException;
import java.util.List;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooDefs.Ids;
import org.apache.zookeeper.ZooKeeper;
public class ClusterMonitor implements Runnable {
private static String membershipRoot = &quot;/Members&quot;;
private final Watcher connectionWatcher;
private final Watcher childrenWatcher;
private ZooKeeper zk;
boolean alive=true;
public ClusterMonitor(String HostPort) throws IOException, InterruptedException, KeeperException {
    connectionWatcher = new Watcher() {
      @Override
      public void process(WatchedEvent event) {
        if(event.getType()==Watcher.Event.EventType.None &amp;amp;&amp;amp; event.getState() == Watcher.Event.KeeperState.SyncConnected) {
            System.out.printf(&quot;\nEvent Received: %s&quot;, event.toString());
          }
      }
    };

    childrenWatcher = new Watcher() {
      @Override
      public void process(WatchedEvent event) {
        System.out.printf(&quot;\nEvent Received: %s&quot;, event.toString());
        if (event.getType() == Event.EventType.NodeChildrenChanged) {
            try {
              //Get current list of child znode, 
              //reset the watch
              List&amp;lt;String&amp;gt; children = zk.getChildren( membershipRoot, this);
              wall(&quot;!!!Cluster Membership Change!!!&quot;);
              wall(&quot;Members: &quot; + children);
            } catch (KeeperException e) {
              throw new RuntimeException(e);
            } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
              alive = false;
              throw new RuntimeException(e);
            }
          }
      }
    };

    zk = new ZooKeeper(HostPort, 2000, connectionWatcher);

    // Ensure the parent znode exists
    if(zk.exists(membershipRoot, false) == null) {
      zk.create(membershipRoot, &quot;ClusterMonitorRoot&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
    }

    // Set a watch on the parent znode
    List&amp;lt;String&amp;gt; children = zk.getChildren(membershipRoot, childrenWatcher);
    System.err.println(&quot;Members: &quot; + children);
  }

  public synchronized void close() {
    try {
      zk.close();
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

  public void wall (String message) {
    System.out.printf(&quot;\nMESSAGE: %s&quot;, message);
  }

  public void run() {
    try {
      synchronized (this) {
        while (alive) {
          wait();
        }
      }
    } catch (InterruptedException e) {
      e.printStackTrace();
      Thread.currentThread().interrupt();
    } finally {
      this.close();
    }
  }

  public static void main(String[] args) throws IOException, InterruptedException, KeeperException {
    if (args.length != 1) {
      System.err.println(&quot;Usage: ClusterMonitor &amp;lt;Host:Port&amp;gt;&quot;);
      System.exit(0);
    }
    String hostPort = args[0];
    new ClusterMonitor(hostPort).run();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ClusterClient.java&lt;/code&gt;类定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.io.IOException;
import java.lang.management.ManagementFactory;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooDefs.Ids;
import org.apache.zookeeper.ZooKeeper;
public class ClusterClient implements Watcher, Runnable {
private static String membershipRoot = &quot;/Members&quot;;
ZooKeeper zk;
public ClusterClient(String hostPort, Long pid) {
  String processId = pid.toString();
  try {
    zk = new ZooKeeper(hostPort, 2000, this);
  } catch (IOException e) {
    e.printStackTrace();
  }
  if (zk != null) {
    try {
      zk.create(membershipRoot + '/' + processId, processId.getBytes(),Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
    } catch (
      KeeperException | InterruptedException e) {
        e.printStackTrace();
      }
    }
  }

  public synchronized void close() {
    try {
      zk.close();
    }
    catch (InterruptedException e) {
      e.printStackTrace();
        }
  }

  @Override
  public void process(WatchedEvent event) {
    System.out.printf(&quot;\nEvent Received: %s&quot;, event.toString());
  }

  public void run() {
    try {
      synchronized (this) {
        while (true) {
          wait();
          }
      }
    } catch (InterruptedException e) {
      e.printStackTrace();
      Thread.currentThread().interrupt();
    } finally {
      this.close();
    }
  }

  public static void main(String[] args) {
    if (args.length != 1) {
      System.err.println(&quot;Usage: ClusterClient &amp;lt;Host:Port&amp;gt;&quot;);
      System.exit(0);
    }
    String hostPort = args[0];
    //Get the process id
    String name = ManagementFactory.getRuntimeMXBean().getName();
    int index = name.indexOf('@');
    Long processId = Long.parseLong(name.substring(0, index));
    new ClusterClient(hostPort, processId).run();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用下面命令编译这两个类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ javac -cp $CLASSPATH ClusterMonitor.java
$ javac -cp $CLASSPATH ClusterClient.java&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要执行群集监控模型，打开两个终端。 在其中一个终端中，运行&lt;code&gt;ClusterMonitor&lt;/code&gt;类。 在另一个终端中，通过在后台运行&lt;code&gt;ClusterClient&lt;/code&gt;类来执行多个实例。&lt;/p&gt;
&lt;p&gt;在第一个终端中，执行&lt;code&gt;ClusterMonitor&lt;/code&gt;类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ java -cp $CLASSPATH ClusterMonitorlocalhost:2181&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如前面的示例所示，看到来自客户端API的调试日志消息，最后，&lt;code&gt;ClusterMonitor&lt;/code&gt;类开始监视事件，输入如下内容：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-d7d2a2d47b17d711.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ClusterMonitor类输出&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，执行&lt;code&gt;ClusterClient&lt;/code&gt;类的五个实例来模拟一个集群的五个节点。&lt;code&gt;ClusterClient&lt;/code&gt;在ZooKeeper树的&lt;code&gt;/Members&lt;/code&gt;路径中使用自己的进程ID创建ephemeral znode：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ java -cp $CLASSPATH ClusterClient localhost:2181 2&amp;gt;&amp;amp;1&amp;gt;/dev/null &amp;amp;
[1] 4028
$ java -cp $CLASSPATH ClusterClient localhost:2181 2&amp;gt;&amp;amp;1&amp;gt;/dev/null &amp;amp;
[2] 4045
$ java -cp $CLASSPATH ClusterClient localhost:2181 2&amp;gt;&amp;amp;1&amp;gt;/dev/null &amp;amp;
[3] 4057
$ java -cp $CLASSPATH ClusterClient localhost:2181 2&amp;gt;&amp;amp;1&amp;gt;/dev/null &amp;amp;
[4] 4072
$ java -cp $CLASSPATH ClusterClient localhost:2181 2&amp;gt;&amp;amp;1&amp;gt;/dev/null &amp;amp;
[5] 4084&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与此相对应，将观察到&lt;code&gt;ClusterMonitor&lt;/code&gt;类检测到这些新的&lt;code&gt;ClusterClient&lt;/code&gt;类实例，因为它正在监视ZooKeeper树的&lt;code&gt;/Members&lt;/code&gt;路径上的事件。 这模拟了一个真正的集群中的节点加入事件。 可以在&lt;code&gt;ClusterMonitor&lt;/code&gt;类的终端中看到输出，这与下面的截图中显示的类似：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-7b6812d567c691c7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;监视事件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，如果杀死一个&lt;code&gt;ClusterClient.java&lt;/code&gt;进程，那么它与ZooKeeper服务器一起维护的会话将被终止。因此，客户端创建的ephemeral znode将被删除。删除将触发&lt;code&gt;NodeChildrenChanged&lt;/code&gt;事件，该事件将被ClusterMonitor类捕获。该模拟在集群中一个节点离开的场景。&lt;/p&gt;
&lt;p&gt;让我们用ID 4084终止&lt;code&gt;ClusterClien&lt;/code&gt;t进程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ kill -9 4084&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下屏幕截图显示了&lt;code&gt;ClusterMonitor&lt;/code&gt;类的终端中的输出。 它列出了当前可用的进程及其进程ID，这些进程ID模拟了实时服务器：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-2fd75fc09e2932a8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;可用进程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的简单而优雅的集群监控模型的示例实现展示了ZooKeeper的真正威力。 在没有ZooKeeper的情况下，开发这样一个能够实时监控节点活跃度的模型将是一项真正的艰巨任务。&lt;/p&gt;
</description>
<pubDate>Wed, 22 Nov 2017 16:33:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/7882107.html</dc:identifier>
</item>
<item>
<title>浅谈数组处理的方法 - sjpqy</title>
<link>http://www.cnblogs.com/shenjp/p/7882061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shenjp/p/7882061.html</guid>
<description>&lt;p&gt;数组处理的方法有很多,如果我们想对里面的任何一项数据进行操作,那我们最常用的方法就是 for 循环, 有的时候for循环也特别麻烦,其实数组有很多操作数据的方法&lt;/p&gt;
&lt;p&gt;一, map方法&lt;/p&gt;
&lt;p&gt;如果你在用reat,这个方法一定是经常用到的,我们在渲染list列表的时候通常就会用这个方法&lt;/p&gt;
&lt;p&gt;map(); 是对数组里面每一项数据进行操作,返回每次调用的结果组成的数组, 假如要给数组里面的每一个数乘以2&lt;/p&gt;
&lt;p&gt;for方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
let arr = [1, 2, 3, 4, 5&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; arr.lrngth; i ++&lt;span&gt;) {
    arr[i] &lt;/span&gt;= arr[i] * 2&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;map方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
let arr = [1, 2, 3, 4, 5&lt;span&gt;];
arr.map(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item * 2&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;es6写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
let arr = [1, 2, 3, 4, 5&lt;span&gt;];
arr.map(item &lt;/span&gt;=&amp;gt; item * 2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二, filter&lt;/p&gt;
&lt;p&gt;filter(); 顾名思义就是过去的意思,可以更加返回的条件进行筛选,加入有一个数组,里面是一个个对象,要筛选出符合条件的对象,就可以用这个方法,这个方法返回一个新的数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
let list =&lt;span&gt; [
    {name: &lt;/span&gt;'aa', age: 22&lt;span&gt;},
    {name: &lt;/span&gt;'bb', age: 21&lt;span&gt;},
    {name: &lt;/span&gt;'cc', age: 20&lt;span&gt;},
    {name: &lt;/span&gt;'dd', age: 22&lt;span&gt;}
]
list.filter(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item.age &amp;gt; 21&lt;span&gt;;
});&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1094267/201711/1094267-20171122233124883-1278244277.png&quot; alt=&quot;&quot; width=&quot;265&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三, every和some&lt;/p&gt;
&lt;p&gt;every();和some为什么要写到一起呢,就是因为这两个方法长得太像了,every();对数组中每一项都给定行数,如果函数对每一项都返回true,则返回true; 而some,是对数组中每一项给定函数,只要有一项返回true, 则返回true, 有点类似于&amp;amp;&amp;amp; 与 || ,假如一个签到,要每个人到了才能开始,就可以用every&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
let list =&lt;span&gt; [
    {name: &lt;/span&gt;'aa', age: 22, isHell: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;},
    {name: &lt;/span&gt;'bb', age: 21, isHell: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;},
    {name: &lt;/span&gt;'cc', age: 20, isHell: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;},
    {name: &lt;/span&gt;'dd', age: 22, isHell: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;}
]
list.every(item &lt;/span&gt;=&amp;gt; item.isHell)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1094267/201711/1094267-20171122234125399-1012290181.png&quot; alt=&quot;&quot; width=&quot;313&quot; height=&quot;247&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到要每一个都满足条件,才会返回true,只要有一个不满足则返回false;&lt;/p&gt;
&lt;p&gt;再来看看some();&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1094267/201711/1094267-20171122234455227-2100383558.png&quot; alt=&quot;&quot; width=&quot;329&quot; height=&quot;261&quot;/&gt;&lt;/p&gt;
&lt;p&gt;some()只有所有的条件不满足才会返回false;&lt;/p&gt;
&lt;p&gt;四, forEach&lt;/p&gt;
&lt;p&gt;forEach();是对数组中每一项运行给定函数,但是没有返回值,这个方法和for循环差不多,只是写法上不一样而已,假如要给每一个对象都加一个属性,就可以用这个方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1094267/201711/1094267-20171122235050883-1796134531.png&quot; alt=&quot;&quot; width=&quot;333&quot; height=&quot;231&quot;/&gt;&lt;/p&gt;
&lt;p&gt;五, reduce&lt;/p&gt;
&lt;p&gt;reduce(); 每次只能接受两个参数,这两个参数就是当前的结果,和当前序列的下一项,这个方法常用在累加器上,其他的技巧暂时没有发现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1094267/201711/1094267-20171122235717961-11984809.png&quot; alt=&quot;&quot; width=&quot;240&quot; height=&quot;56&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果数组里面是字符串,返回出来的数据就是每一项字符串拼接之后的新字符串&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1094267/201711/1094267-20171123000035274-1185240584.png&quot; alt=&quot;&quot; width=&quot;306&quot; height=&quot;57&quot;/&gt;&lt;/p&gt;
&lt;p&gt;六, find 和 findIndex&lt;/p&gt;
&lt;p&gt;find();传入一个测试条件,或者函数, 返回数组中符合条件的第一个元素.&lt;/p&gt;
&lt;p&gt;findIndex(), 传入一个测试条件或者函数,返回素组中符合条件的第一个元素的索引值&lt;/p&gt;
&lt;p&gt; 当数组中的元素满足测试条件时,find和fandIndex返回符合条件的第一个元素或者索引,之后就不会再调用执行函数,如果都没有符合条件的元素,返回 -1;&lt;/p&gt;
&lt;p&gt;比如要从一个数组中找出第一个大于 30 的元素和索引值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1094267/201711/1094267-20171123001115508-2007673295.png&quot; alt=&quot;&quot; width=&quot;299&quot; height=&quot;126&quot;/&gt;&lt;/p&gt;


&lt;p&gt;参考: https://juejin.im/post/5a0c16d16fb9a0450b65edad&lt;/p&gt;

</description>
<pubDate>Wed, 22 Nov 2017 16:15:00 +0000</pubDate>
<dc:creator>sjpqy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shenjp/p/7882061.html</dc:identifier>
</item>
<item>
<title>【爬虫】利用Scrapy抓取京东商品、豆瓣电影、技术问题 - alexander.bruce.lee</title>
<link>http://www.cnblogs.com/accipiter/p/7882020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/accipiter/p/7882020.html</guid>
<description>&lt;p&gt;
&lt;h3&gt;　　1.scrapy基本了解&lt;/h3&gt;
&lt;/p&gt;
&lt;p&gt;　　Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。可以应用在包括数据挖掘， 信息处理或存储历史数据等一系列的程序中。其最初是为了页面抓取(更确切来说,网络抓取)所设计的,也可以应用在获取API所返回的数据(比如Web Services)或者通用的网络爬虫。&lt;/p&gt;
&lt;p&gt;　　Scrapy也能帮你实现高阶的爬虫框架，比如爬取时的网站认证、内容的分析处理、重复抓取、分布式爬取等等很复杂的事。&lt;/p&gt;

&lt;p&gt;　　Scrapy主要包括了以下组件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;引擎(Scrapy): 用来处理整个系统的数据流处理, 触发事务(框架核心)&lt;/li&gt;
&lt;li&gt;调度器(Scheduler): 用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址&lt;/li&gt;
&lt;li&gt;下载器(Downloader): 用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)&lt;/li&gt;
&lt;li&gt;爬虫(Spiders): 爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面&lt;/li&gt;
&lt;li&gt;项目管道(Pipeline): 负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。&lt;/li&gt;
&lt;li&gt;下载器中间件(Downloader Middlewares): 位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。&lt;/li&gt;
&lt;li&gt;爬虫中间件(Spider Middlewares): 介于Scrapy引擎和爬虫之间的框架，主要工作是处理蜘蛛的响应输入和请求输出。&lt;/li&gt;
&lt;li&gt;调度中间件(Scheduler Middewares): 介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　Scrapy运行流程大概如下：&lt;/p&gt;
&lt;p&gt;1.首先，引擎从调度器中取出一个链接(URL)用于接下来的抓取&lt;/p&gt;
&lt;p&gt;2.引擎把URL封装成一个请求(Request)传给下载器，下载器把资源下载下来，并封装成应答包(Response)&lt;/p&gt;
&lt;p&gt;3.然后，爬虫解析Response&lt;/p&gt;
&lt;p&gt;4.若是解析出实体（Item）,则交给实体管道进行进一步的处理。&lt;/p&gt;
&lt;p&gt;5.若是解析出的是链接（URL）,则把URL交给Scheduler等待抓取&lt;/p&gt;
&lt;h3&gt;　　2.安装scrapy&lt;/h3&gt;
&lt;p&gt;    　　虚拟环境安装：&lt;/p&gt;
&lt;p&gt;    sudo pip install virtualenv #安装虚拟环境工具&lt;/p&gt;
&lt;p&gt;    virtualenv ENV #创建一个虚拟环境目录 &lt;/p&gt;
&lt;p&gt;    source ./ENV/bin/active #激活虚拟环境 &lt;/p&gt;
&lt;p&gt;    pip install Scrapy #验证是否安装成功 &lt;/p&gt;
&lt;p&gt;    pip list #验证安装&lt;/p&gt;
&lt;p&gt;    可以如下测试：&lt;/p&gt;
&lt;p&gt;    scrapy bench&lt;/p&gt;
&lt;p&gt;
&lt;h3&gt;　　3.使用scrapy&lt;/h3&gt;
&lt;/p&gt;
&lt;p&gt;   　　 在抓取之前, 你需要新建一个Scrapy工程. 进入一个你想用来保存代码的目录，然后执行：&lt;/p&gt;
&lt;p&gt;        　　$ scrapy startproject tutorial&lt;/p&gt;
&lt;p&gt;　　　　这个命令会在当前目录下创建一个新目录 tutorial, 它的结构如下:&lt;/p&gt;
&lt;p&gt;|____scrapy.cfg&lt;/p&gt;
&lt;p&gt;|____tutorial&lt;/p&gt;
&lt;p&gt;| |______init__.py&lt;/p&gt;
&lt;p&gt;| |______init__.pyc&lt;/p&gt;
&lt;p&gt;| |____items.py&lt;/p&gt;
&lt;p&gt;| |____items.pyc&lt;/p&gt;
&lt;p&gt;| |____pipelines.py&lt;/p&gt;
&lt;p&gt;| |____settings.py&lt;/p&gt;
&lt;p&gt;| |____settings.pyc&lt;/p&gt;
&lt;p&gt;| |____spiders&lt;/p&gt;
&lt;p&gt;| | |______init__.py&lt;/p&gt;
&lt;p&gt;| | |______init__.pyc&lt;/p&gt;
&lt;p&gt;| | |____example.py&lt;/p&gt;
&lt;p&gt;| | |____example.pyc&lt;/p&gt;

&lt;p&gt;　　这些文件主要是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;scrapy.cfg: 项目配置文件&lt;/li&gt;
&lt;li&gt;tutorial/: 项目python模块, 之后您将在此加入代码&lt;/li&gt;
&lt;li&gt;tutorial/items.py: 项目items文件&lt;/li&gt;
&lt;li&gt;tutorial/pipelines.py: 项目管道文件&lt;/li&gt;
&lt;li&gt;tutorial/settings.py: 项目配置文件&lt;/li&gt;
&lt;li&gt;tutorial/spiders: 放置spider的目录&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;　　3.1. 定义Item&lt;/h4&gt;
&lt;div readability=&quot;10.761517615176&quot;&gt;　　items是将要装载抓取的数据的容器，它工作方式像 python 里面的字典，但它提供更多的保护，比如对未定义的字段填充以防止拼写错误通过创建scrapy.Item类, 并且定义类型为 scrapy.Field 的类属性来声明一个Item.我们通过将需要的item模型化。在 tutorial 目录下的 &lt;a href=&quot;http://items.py&quot;&gt;items.py&lt;/a&gt; 文件中编辑。&lt;/div&gt;

&lt;h4&gt;　　3.2. 编写Spider&lt;/h4&gt;
&lt;p&gt;　　Spider 是用户编写的类, 用于从一个域（或域组）中抓取信息, 定义了用于下载的URL的初步列表, 如何跟踪链接，以及如何来解析这些网页的内容用于提取items。&lt;/p&gt;
&lt;p&gt;要建立一个 Spider，继承 scrapy.Spider 基类，并确定三个主要的、强制的属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;name：爬虫的识别名，它必须是唯一的，在不同的爬虫中你必须定义不同的名字.&lt;/li&gt;
&lt;li&gt;start_urls：包含了Spider在启动时进行爬取的url列表。因此，第一个被获取到的页面将是其中之一。后续的URL则从初始的URL获取到的数据中提取。我们可以利用正则表达式定义和过滤需要进行跟进的链接。&lt;/li&gt;
&lt;li&gt;parse()：是spider的一个方法。被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。&lt;br/&gt;这个方法负责解析返回的数据、匹配抓取的数据(解析为 item )并跟踪更多的 URL。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　在 /tutorial/tutorial/spiders 目录下创建&lt;/p&gt;
&lt;p&gt;　　example.py&lt;/p&gt;

&lt;h4&gt;　　3.3 .爬取&lt;/h4&gt;
&lt;p&gt;　　到项目根目录, 然后运行命令&lt;/p&gt;
&lt;p&gt;　　$ scrapy crawl example&lt;/p&gt;



</description>
<pubDate>Wed, 22 Nov 2017 16:02:00 +0000</pubDate>
<dc:creator>alexander.bruce.lee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/accipiter/p/7882020.html</dc:identifier>
</item>
<item>
<title>发现AspNet.Core版本控制库Bug一枚，你还想入坑？ - 流氓少年/kel</title>
<link>http://www.cnblogs.com/mangshao/p/7881237.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mangshao/p/7881237.html</guid>
<description>&lt;p&gt;我，博客写作小白一枚，注册账号多年却未曾留下只言片语，在潜水的这些年里从大家的博客中收获了很多新的知识忽觉惶恐心有不安，是时候给大家分享一些我的经验和教训了。嗯嗯，实话告诉大家前面的话的都是来凑字数的，哈哈，其实就是懒^_^，第一次写如有叙述不清的地方还请大家多包涵&lt;/p&gt;
&lt;h2&gt;问题复现&lt;/h2&gt;
&lt;p&gt;问题的复现一两句话也不好说也说不清楚，如果单独使用Microsoft.AspNetCore.Mvc.Versioning库是不会出现问题的，这个问题的复现需要结合其他库的。还是用代码来详细阐述吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/411296/201711/411296-20171122214634680-1584497862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/411296/201711/411296-20171122214709680-598848656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/411296/201711/411296-20171122214725696-1153593959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码真心不多，大家看完后是否也是这种想法呢，简单的说下这段代码意图，在请求接口api/v1/values/{id}时出现未处理的异常，则由异常处理中间件重写请求到/error/page/500接口（即：输出字符串exception），接下来我将用调试的方式让大家来见证这个问题。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/411296/201711/411296-20171122231611680-308400499.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图我们发现如下的现象：&lt;/p&gt;
&lt;p&gt;第一次请求：异常中间件&lt;span&gt;并没有&lt;/span&gt;成功的将请求重写到/error/page/500接口，而是重写到了原来的请求上去，所以抛出了2次异常。&lt;/p&gt;
&lt;p&gt;第二次请求，异常中间件则成功的将请求重写到/error/page/500接口，所以抛出了1次异常，并输入了字符串exception。&lt;/p&gt;
&lt;h2&gt;问题解决&lt;/h2&gt;
&lt;p&gt;这个问题其实是由Microsoft.AspNetCore.Mvc.Versioning库第一次请求到达后会将正确的action缓存到当前上下文的Items中（即：HttpContext.Items)，当action执行完成（不管是否出现未出的异常）后并未清理当前上下文中缓存数据，这将导致所有类似于异常处理中间件这种在一次请求中存在二次重入http管道的中间件出现异常。我们只需要继承DefaultApiVersionRoutePolicy重写OnSingleMatch方法在action执行完成后清理掉items中的缓存即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/411296/201711/411296-20171122234657040-1181612337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/mangshao/XSharp.Extensions.Mvc.Versioning.rar&quot; target=&quot;_blank&quot;&gt;代码下载&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 Nov 2017 15:52:00 +0000</pubDate>
<dc:creator>流氓少年/kel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mangshao/p/7881237.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 WebGL 的 3D “弹力”布局 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/7878665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/7878665.html</guid>
<description>&lt;p&gt;&lt;span&gt;分子力(molecular force)，又称分子间作用力、范得瓦耳斯力，是指分子间的相互作用。当二分子相距较远时，主要表现为吸引力，这种力主要来源于一个分子被另一个分子随时间迅速变化的电偶极矩所极化而引起的相互作用；当二分子非常接近时，则排斥力成为主要的，这是由于各分子的外层电子云开始重叠而产生的排斥作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;HT for Web&lt;/code&gt; 提供了弹力布局（也称为力导向布局）的功能，即根据节点之间存在互斥力，相互连接的节点间存在引力， 弹力布局运行一段时间后，整体拓扑网络结构会逐渐达到收敛稳定的平衡状态。这个功能很有趣，今天我们就将它的魅力展现出来。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本例地址：&lt;span&gt;&lt;a href=&quot;http://www.hightopo.com/demo/pipeline/index.html&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/demo/pipeline/index.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201711/591709-20171122130754790-2033662965.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用弹力布局功能需要在引入 ht.js 核心库之后，再引入一个 &lt;code&gt;ht-forcelayout.js&lt;/code&gt; 的弹力布局插件库，因为还用到了 form 表单，所以要引入 ht-form.js 的表单插件库：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&quot;../../guide/lib/core/ht.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;../../guide/lib/plugin/ht-forcelayout.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;../../guide/lib/plugin/ht-form.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;ht.layout.Force3dLayout&lt;/code&gt; 类提供 &lt;code&gt;3D&lt;/code&gt; 弹力布局，构造函数可传入 &lt;code&gt;DataModel&lt;/code&gt; 和 &lt;code&gt;Graph3dView&lt;/code&gt; 两种参数。 默认仅对未选中图元进行布局，如果构造函数参数为 &lt;code&gt;Graph3dView&lt;/code&gt; 时，则视图组件的 &lt;code&gt;isMovable&lt;/code&gt; 和 &lt;code&gt;isVisible&lt;/code&gt; 函数将影响图元是否可布局， 图元 &lt;code&gt;style&lt;/code&gt; 上的 &lt;code&gt;layoutable&lt;/code&gt; 属性也可设为 &lt;code&gt;false&lt;/code&gt; 阻止图元参与布局。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;介绍完 HT 封装的弹力布局的背景之后，接下来就是帮助你们也能轻松地实现这个效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们定义一个颜色数组变量，存储各个弹力球的颜色，还定义了一个随机函数，用来生成数随机的数组中的颜色：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; colorList = ['#FFAFA4', '#B887C5', '#B9EA9C', '#CFD9E7', '#4590B8', '#FF9C30'&lt;span&gt;], 
    colorLen &lt;/span&gt;=&lt;span&gt; colorList.length;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; randomColor = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ran = Math.random() *&lt;span&gt; colorLen;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; colorList[Math.floor(ran)];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机6种颜色&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接着创建弹力球，简单生成一个 3D 节点，通过设置这个节点的 style 样式属性来控制节点的显示方式，其中将“shape3d”设置为“sphere”即可将 ht.Node 六面体变成 3D 球体模型，再设置“shape3d”属性为前面定义的随机颜色，s3 是 HT 封装的设置 3D 节点大小的 setSize3d 函数的简写，最后将这个节点添加进数据模型 dataModel 中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; createNode = &lt;span&gt;function&lt;/span&gt;(dm) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建node节点 圆&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Node();
    node.s({&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置样式为 setStyle 的简写&lt;/span&gt;
        'shape3d': 'sphere'&lt;span&gt;,
        &lt;/span&gt;'shape3d.color': randomColor()&lt;span&gt;//设置&lt;/span&gt;&lt;span&gt;随机颜色&lt;/span&gt;
&lt;span&gt;    });
    node.s3(&lt;/span&gt;40, 40, 40&lt;span&gt;);
    dm.add(node);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;现在效果图上出现的还有各个弹力球之间的连线，这个连线我们一看就觉得很不一般，也是通过构造一个一个节点，这个节点是通过 &lt;a href=&quot;http://hightopo.com/guide/guide/plugin/modeling/ht-modeling-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 建模手册&lt;/a&gt; setShape3dModel函数自定义的 ht.Default.createRingModel 根据 xy 平面的曲线，环绕一周形成的 3D 环形模型，将其命名为‘custom’：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
ht.Default.setShape3dModel(&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建模型 根据xy平面的曲线，环绕一周形成3D模型。&lt;/span&gt;
    'custom', ht.Default.createRingModel( [0.5, 0.5, -0.2, 0, 0.5, -0.5], [1, 3&lt;span&gt;] )
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;HT 将用户自定义的属性和 HT 默认的属性调用方法分为 node.a 和 node.s 这样就能将两者有效地区分开来（具体参照 &lt;a href=&quot;http://www.hightopo.com/guide/guide/core/beginners/ht-beginners-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 入门手册&lt;/a&gt; style 章节），我们在创建管线的时候就用了这种方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; updatePipeline = &lt;span&gt;function&lt;/span&gt;(edge) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新设置edge的样式&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; pipeline = edge.a('pipeline'&lt;span&gt;);
    pipeline.s3(&lt;/span&gt;1, 1, 1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置大小&lt;/span&gt;
    pipeline.p3(0, 0, 0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置坐标&lt;/span&gt;

    &lt;span&gt;var&lt;/span&gt; node1 = edge.getSourceAgent(),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取图形上连接的起始节点&lt;/span&gt;
    node2 = edge.getTargetAgent();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取图形上连接的目标节点&lt;/span&gt;
    pipeline.s('mat', createMatrix(node1.p3(), node2.p3(), 20));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3d整体图形矩阵变化&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最神秘的是如何能做出让两个节点“若即若离”的效果？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们知道，矩阵能描述任意线性变换。线性变换保留了直线和平行线，线性变换保留直线的同时，其他的几何性质如长度、角度、面积和体积可能被变换改变了。简单的说，线性变换可能“拉伸”坐标系，但不会“弯曲”或“卷折”坐标系。这个函数主要是将我们的连接线在拖动弹力球后被拖拉的连接线的进行一个“变化矩阵”的操作，变化矩阵也是 HT 封装的 ht.Default.createMatrix 函数，通过将节点的 style 属性 mat 设置为一个自定义的函数，就是将这个节点的坐标乘上在“mat”属性对应的值，也就是说如果当前这个管线的旋转角为 [Math.PI/6, 0, 0]，假设我们在 createMatrix 函数中设置 r3 为 [Math.PI/3, 0, 0]，那么这个节点会旋转 90 度。非常轻松地创建出变化矩阵：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; createMatrix = &lt;span&gt;function&lt;/span&gt;(p1, p2, width) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;createMatrix(array, matrix)将一组JSON描述的缩放、移动和旋转等操作转换成对应的变化矩阵&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; vec = [p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2&lt;span&gt;]],
        dist &lt;/span&gt;= ht.Default.getDistance(p1, p2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取两点之间距离，或向量长度&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ht.Default.createMatrix({
        s3: [width, dist, width],
    r3: [Math.PI&lt;/span&gt;/2 - Math.asin(vec[1]/dist), Math.atan2(vec[0], vec[2]), 0&lt;span&gt;],
    rotationMode: &lt;/span&gt;'xyz'&lt;span&gt;,
    t3: [(p1[&lt;/span&gt;0]+p2[0])/2, (p1[1]+p2[1])/2, (p1[2]+p2[2])/2]
&lt;span&gt;    });
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;基础配件全部定义完毕，接着就是将“shape3d”属性设置为自定义的 3D 模型“custom” ，并将“layoutable”属性设置为“false”阻止图元参与布局，并将点之间的连线通过edge.a('pipeline', node)重新刷新，并添加进数据模型 dataModel 中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; createEdge = &lt;span&gt;function&lt;/span&gt;(dm, node1, node2) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建‘custom’模型的edge&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Node();
    node.s({
        &lt;/span&gt;'shape3d': 'custom'&lt;span&gt;,
        &lt;/span&gt;'shape3d.color': '#ECE0D4'&lt;span&gt;,
        &lt;/span&gt;'layoutable': &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    });
    dm.add(node);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; edge = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Edge(node1, node2);
    edge.a(&lt;/span&gt;'pipeline'&lt;span&gt;, node);
    edge.s(&lt;/span&gt;'edge.color', 'rgba(0, 0, 0, 0)'&lt;span&gt;);
    dm.add(edge);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; edge;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;插：我们还可以在工业上用 HeatMap 热图上做文章，效果依旧很炫，具体地址 &lt;a href=&quot;http://hightopo.com/guide/guide/plugin/forcelayout/examples/example_heatmap3d.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://hightopo.com/guide/guide/plugin/forcelayout/examples/example_heatmap3d.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201711/591709-20171122141711461-1798815274.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;界面上的图形全部绘制完毕，剩下的就只有 form 表单，首先将 form 表单添加进 HTML 页面，用的是 HT 封装的 ht.widget.FormPane 函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; formPane = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.widget.FormPane();
formPane.setWidth(&lt;/span&gt;230&lt;span&gt;);
formPane.setHeight(&lt;/span&gt;125&lt;span&gt;);
formPane.addToDOM();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;记住，form 表单要设置宽高，不然不显示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;form 表单添加行是通过 addRow 函数，我们重点来说一下下面的几行，Color、Range 和 Intensity，这三个名字主要是用来控制“头灯”的。在 HT 中直接通过 setHeadlightColor/setHeadlightRange/setHeadlightIntensity 三个函数来控制“头灯”的颜色、范围以及灯的强度，onValueChanged 属性，顾名思义属性值改变之后触发的事件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
['Color', 'Range', 'Intensity'].forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; { id: name },
    func &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(oV, nV) {
        g3d[&lt;/span&gt;'setHeadlight' + name](nV);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; === g3d.setHeadlightColor(nV)/g3d.setHeadlightRange(nV)/g3d.setHeadlightIntensity(nV)&lt;/span&gt;
&lt;span&gt;    };
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name === 'Color'&lt;span&gt;)
        obj.colorPicker &lt;/span&gt;= {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ht.widget.ColorPicker为颜色选择框 &lt;/span&gt;
        instant: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        value: g3d[&lt;/span&gt;'getHeadlight' + name](),&lt;span&gt;//&lt;/span&gt;&lt;span&gt; === g3d.getHeadlightColor()&lt;/span&gt;
&lt;span&gt;        onValueChanged: func
    };
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
        obj.slider &lt;/span&gt;= {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;滑动条&lt;/span&gt;
            min: 0&lt;span&gt;,
        max: name &lt;/span&gt;=== 'Range' ? 20000 : 3&lt;span&gt;,
        step: &lt;/span&gt;0.1&lt;span&gt;,
        value: g3d[&lt;/span&gt;'getHeadlight' +&lt;span&gt; name](),
        onValueChanged: func
        };
    formPane.addRow([ name, obj ], [ &lt;/span&gt;70, 0.1&lt;span&gt; ]);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;slider 和 colorPicker 都是 HT 自定义的滑动条和颜色选择器，详情请参考 &lt;a href=&quot;http://hightopo.com/guide/guide/plugin/form/ht-form-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 表单手册&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果还有不懂的请咨询我，或者可以直接上&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;a href=&quot;http://hightopo.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;HT for Web&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;官网查阅手册。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 Nov 2017 15:48:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/7878665.html</dc:identifier>
</item>
<item>
<title>解决弹出蒙层滑动穿透问题-vue - 布尔-</title>
<link>http://www.cnblogs.com/buerjj/p/7876057.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buerjj/p/7876057.html</guid>
<description>&lt;p&gt;　　最近开发过程中遇到一些小问题(似乎问题总是那么多)，但一直没什么时间去优化与解决。程序员不能被业务绑架，有时间还是花点在代码上😀，开始这次的vue尝试吧。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【遇到的问题】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;在一个可滑动列表页弹出一个全屏蒙层，蒙层固定，中间一块显示消息框，当用手滑动蒙层空白处时，滑动事件会穿透到底部列表页，导致列表页的滑动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【要实现的目标】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1. 滑动蒙层空白处不让滑动事件穿透。　　 2. 当蒙层消息框文字多时，要让文字可上下滑动。&lt;/p&gt;
&lt;p&gt;　　没图不说话，要实现的效果其实如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/928234/201711/928234-20171122225030008-1517077567.gif&quot; alt=&quot;&quot; width=&quot;163&quot; height=&quot;290&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【实现思路】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;&lt;span&gt;1. vue提供的 &lt;strong&gt;@touchmove.prevent &lt;/strong&gt;可以用来阻止滑动，但是这个方法会对其内的子div的滑动事件也禁止掉了，这样会导致中间文字无法滑动。如果没有中间滑动需求，用 &lt;strong&gt;@touchmove.prevent &lt;/strong&gt;实现是一个很好的方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　2. 蒙层设为fixed悬浮在最上，底部列表设置overflow-y: hidden；这样可以列表内容就不可以滑了，但实际过程中没有效果，于是想到继续往列表父div向上追溯，对body设置相关样式，这样就控制住了底部列表滑动问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　3. 蒙层空白处点击事件与中间文字点击事件处理，防止事件冒泡带来其他bug。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【相关实现代码】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;1. html代码都是比较简单，列表页for循环实现；蒙层用一个变量控制其显示和隐藏。但这里有几个注意点: a. 给上面列表的div动态绑定了 &lt;/span&gt;noScroll class，它的作用是当消息蒙层显示时切换到相关的css样式； b. 弹出的全屏蒙层，加有点击事件是为了点空白处让蒙层消失，但这里对显示的每行文字还加了@click.stop=&quot;messageTitleClick(num)&quot;这个方法，为什么加它呢——是因为蒙层空白处的点击方法对整个蒙层都生效，在文字上加上这个方法可以屏蔽掉蒙层点击方法的影响，即使这个方法里什么也不做它也是有作用的，另外这个方法上加了stop是为了防止它的点击事件穿透到后面的div&lt;span&gt;。代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
　　 &amp;lt;!-- 列表 --&amp;gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;:class&lt;/span&gt;&lt;span&gt;=&quot;{noScroll: isShowPopup}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item&quot;&lt;/span&gt;&lt;span&gt; v-for&lt;/span&gt;&lt;span&gt;=&quot;num in 50&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;itemClick(num)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width:100%&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;点击item{{num}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

　　 &amp;lt;!-- 蒙层 --&amp;gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;isShowPopup&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;popup&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;popUpEmptyClick()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;message-title&quot;&lt;/span&gt;&lt;span&gt; v-for&lt;/span&gt;&lt;span&gt;=&quot;num in 30&quot;&lt;/span&gt;&lt;span&gt; @click.stop&lt;/span&gt;&lt;span&gt;=&quot;messageTitleClick(num)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
          消息提示 {{num}}
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2. 给整个列表动态绑定的css如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/* 当前蒙层显示时生效 */&lt;span&gt;
.noScroll &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
  overflow-y: hidden;
&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3. 给列表整个div动态绑定 .noScroll 后，底部列表照样可以滑动，所以考虑继续向上追溯。利用watch监听蒙层是否显示，当显示时，设置body相应样式；但蒙层消失时，body样式恢复。但是在vue里怎么操作body里，虽然vue是数据驱动的，不提倡直接操作Dom。但此刻我也是没什么好办法了，就直接操作Dom了，好想说黑猫白猫😀。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  watch: {
    isShowPopup(newVal, oldVal) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newVal == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
        document.body.style.cssText &lt;/span&gt;= &quot;overflow-y: hidden&quot;&lt;span&gt;;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        document.body.style.cssText &lt;/span&gt;= &quot;overflow-y: auto&quot;&lt;span&gt;;
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【Demo地址】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　手动将路由切到 /three 就是此页示例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;https://github.com/LiJinShi/wechat_back_vue&quot; target=&quot;_blank&quot;&gt;https://github.com/LiJinShi/wechat_back_vue&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 22 Nov 2017 15:30:00 +0000</pubDate>
<dc:creator>布尔-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/buerjj/p/7876057.html</dc:identifier>
</item>
<item>
<title>Nginx+Tomcat+Redis实现持久会话 - Aubin</title>
<link>http://www.cnblogs.com/aubin/p/7881837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aubin/p/7881837.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1026632/201711/1026632-20171122230329508-476656948.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;使用开源web应用solo blog进行项目演示。前端使用Nginx作为负载均衡器，后端Tomcat连接Redis实现session存储。Redis的特点就是可以将session持久化。样才能真正实现后台多个Tomcat负载平衡，用户请求能够发往任何一个tomcat主机。&lt;/li&gt;
&lt;li&gt;keeplived、zabbix与ansible暂不在本文章的范围当中,会在之后的文章逐一进行讲解&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;p&gt;部署环境&lt;br/&gt;CentOS7&lt;br/&gt;Nginx1.10.2&lt;br/&gt;Tomcat7.0&lt;br/&gt;Redis3.2.3&lt;br/&gt;Mariadb 5.5.44&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1026632/201711/1026632-20171122230344352-1220040719.png&quot;/&gt;&lt;/p&gt;

&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装前准备&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ntpdate 172.18.0.1
iptables -F&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装Nginx&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum install nginx&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;修改配置文件&lt;br/&gt;upstream tomcatservers：创建后端服务器组，要在http内部追加&lt;br/&gt;location：匹配URL，在server内部追加&lt;br/&gt;注：省略号为其他默认的参数，如果没有特殊需要按默认即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/nginx/nginx.conf
http {
...
upstream tomcatservers {
    server 172.18.68.21:8080;
    server 172.18.68.22:8080;
    }
...
server {
...
    location / {
        proxy_pass http://tomcatservers;
     }
...
}
}
systemctl start nginx&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;检查端口&lt;br/&gt;启动服务器要检查80端口是否正常监听&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ss -ntl&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两台Tomcat服务器的配置完全一样。以下步骤在两台主机重复操作即可&lt;/p&gt;
&lt;ul readability=&quot;14.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装前准备&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ntpdate 172.18.0.1
iptables -F&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装Tomcat&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum install Tomcat&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;部署solo&lt;br/&gt;.war包复制到webapps目录下后重启tomcat，tomcat会自动解压其文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp solo-2.4.1.war  /usr/share/tomcat/webapps/
systemctl restart tomcat&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;配置solo&lt;br/&gt;serverhost为前端负载均衡的域名或者IP，如果部署完毕后出现静态资源无法加载的情况，多数是这里出了问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /usr/share/tomcat/webapps/solo-2.4/WEB-INF/classes
vim latke.properties
  #### Server ####
  # 配置协议
  serverScheme=http
  # 配置客户端访问站点时的域名或IP，也就是前端Nginx的域名
  serverHost=www.shuaiguoxia.com
  # 使用的端口
  serverPort=80&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;配置solo连接MySQL&lt;br/&gt;H2 runtime的部分是solo默认使用的，把他手动注释掉后把MySQL runtime部分注释取消。&lt;br/&gt;设定MySQL的用户名密码，然后把172.18.68.41改为MySQL(主)的IP地址。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#### H2 runtime ####
#runtimeDatabase=H2
#jdbc.username=root
#jdbc.password=
#jdbc.driver=org.h2.Driver
#jdbc.URL=jdbc:h2:~/solo_h2/db
#jdbc.pool=h2
#
#### MySQL runtime ####
runtimeDatabase=MYSQL
jdbc.username=root                     # 用户名
jdbc.password=123456                   # 密码
jdbc.driver=com.mysql.jdbc.Driver
jdbc.URL=jdbc:mysql://172.18.68.41:3306/solo?useUnicode=yes&amp;amp;characterEncoding=utf8
jdbc.pool=druid&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;配置Tomcat连接Reids&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Tomcat连接Reids需要3个软件包：&lt;br/&gt;commons-pool2-2.2.jar&lt;br/&gt;jedis-2.5.2.jar&lt;br/&gt;tomcat-redis-session-manager-2.0.0.jar&lt;br/&gt;下载地址https://github.com/izerui/tomcat-redis-session-manager&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;将所需要的jar包复制到 /usr/share/tomcat/lib/&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp commons-pool2-2.2.jar /usr/share/tomcat/lib/
cp jedis-2.5.2.jar
cp tomcat-redis-session-manager-2.0.0.jar&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;修改contest.xml文件,再文件中加入以下两行。&lt;br/&gt;IP为RedisIP地址，端口为Redis监听的端口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/tomcat/context.xml
#
 &amp;lt;Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; /&amp;gt;
  &amp;lt;Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;  
   host=&quot;172.18.68.31&quot;  
   port=&quot;6379&quot;  
   database=&quot;0&quot;  
   maxInactiveInterval=&quot;60&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启Tomcat&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;systemctl restart tomcat&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis服务器一共两台，一主一从。仅仅配置文件不同，其他过程全部相同。&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装前准备&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ntpdate 172.18.0.1
iptables -F&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装Redis&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum install Redis&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Redis主节点的配置&lt;br/&gt;主节点仅配置IP、监听的端口、与连接密码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/redis.conf
bind 0.0.0.0                            # 监听所有IP
port 6379                               # 设定监听的端口
requirepass 123456                      # 设定连接的密码&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Redis从节点配置&lt;br/&gt;从节点设置为只读&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bind 0.0.0.0                            # 监听所有IP
slaveof 172.18.68.31 6379               # 设定主节点的IP+端口
masterauth 123456                       # 主节点的连接密码
slave-read-only yes                     # 从节点为只读&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;确认主从配置成功&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;shell &amp;gt; redis-cli -h 172.18.68.32        # 连接从服务器redis
127.0.0.1:6379&amp;gt; INFO replication         # 查看主从复制状态信息
# Replication
role:slave
master_host:172.18.68.31                 # 主节点IP
master_port:6379                         # 主节点的端口
master_link_status:up                    # up为主从同步正常
master_last_io_seconds_ago:9
master_sync_in_progress:0
slave_repl_offset:1420
slave_priority:100
slave_read_only:1
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL服务器一共两台，一主一从。仅仅配置文件不同，其他过程全部相同。&lt;/p&gt;
&lt;ul readability=&quot;22.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装前准备&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ntpdate 172.18.0.1
iptables -F&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;安装Mariadb&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum install Mariadb
#
#
#运行初始化脚本对MySQL进行
cd /usr/local/mysql/bin
mysql_secure_installation          #MySql初始化脚本，以下为每一项的翻译
  先回车
  是否设置root密码
  输入密码
  确认密码
  是否设置匿名用户
  是否允许root远程登录
  删除test数据库
  现在是否生效&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;MySQL主服务器的配置&lt;br/&gt;主从同步就必须要开启二进制日志，修改配置文件一共有两点。&lt;br/&gt;1.server-id必须不能冲突&lt;br/&gt;2.在主服务器创建授权用户，让用户有复制权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;shell &amp;gt; vim /etc/my.cnf
server-id=1                                         #节点ID
log-bin=mysql-bin                                   #指定二进制日志前缀
relay-log=mysql-relay-bin                           #指定relaylog日志前缀
replicate-wild-ignore-table=mysql.%                 #排除要复制的表
replicate-wild-ignore-table=test.%
replicate-wild-ignore-table=information_schema.%&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在主服务器行创建授权用户，让从服务器有权限复制主服务器数据。授权用户应该匹配最小权限法则，允许连接的IP地址越精确越好。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Musql &amp;gt; grant replication slave on *.* to 
 'slave_user'@'10.0.0.67' identified by '123456';&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;19&quot;&gt;
&lt;p&gt;MySQL从服务器的配置&lt;br/&gt;MySQL的主从配置也仅仅是server-id不同&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;shell &amp;gt; vim /etc/my.cnf
server-id=2                                         #节点ID
log-bin=mysql-bin                                   #指定二进制日志前缀
relay-log=mysql-relay-bin                           #指定relaylog日志前缀
replicate-wild-ignore-table=mysql.%                 #排除要复制的表
replicate-wild-ignore-table=test.%
replicate-wild-ignore-table=information_schema.%&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在从服务器连mysql命令行配置,配置主节点的IP、用户名密码。最重要的是master_log_file、master_log_pos，这两项是在主节点上查询后的结果，要与主节点查询结果相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 在MySQL主服务器中查询结果
MariaDB [(none)]&amp;gt; show master status\G;
*************************** 1. row ***************************
        File: master-log.000003
        Position: 18893845
        Binlog_Do_DB: 
        Binlog_Ignore_DB: &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置MySQL从服务器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MySQL &amp;gt; change master to 
master_host='10.0.0.66',
master_user='slave_user',
master_password='123456',
master_log_file='mysql-bin.000001',
master_log_pos=106;`&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;查看主动同步情况&lt;br/&gt;在从服务器中查看主从同步情况。最后两行的yes标志着主从同步成功。还可以通过查询表、库甚至数据的方式查询验证主从同步情况。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [(none)]&amp;gt; show slave status\G;
*************************** 1. row ***************************
           Slave_IO_State: Waiting for master to send event
              Master_Host: 172.18.68.41
              Master_User: slave-user
              Master_Port: 3306
            Connect_Retry: 60
          Master_Log_File: master-log.000002
      Read_Master_Log_Pos: 245
           Relay_Log_File: mysql-relay-bin.000002
            Relay_Log_Pos: 530
    Relay_Master_Log_File: master-log.000002
         Slave_IO_Running: Yes
        Slave_SQL_Running: Yes&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过浏览器访问172.18.68.11/solo-2.4就能访问部署的solo博客，初次进入会让你注册一个用户密码，就是管理员账号密码。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1026632/201711/1026632-20171122230421836-1259415855.png&quot;/&gt;&lt;br/&gt;至此不管Nginx怎样调度，Tomcat都能将客户端的session保存在Redis中。可以通过windwos的Redis管理软件查看到在Redis主从两个数据库都有了session信息。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1026632/201711/1026632-20171122230429977-1577526576.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 Nov 2017 15:11:00 +0000</pubDate>
<dc:creator>Aubin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aubin/p/7881837.html</dc:identifier>
</item>
</channel>
</rss>