<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>利用.NET Core类库System.Reflection.DispatchProxy实现简易Aop - Elder_James</title>
<link>http://www.cnblogs.com/ElderJames/p/implement-simple-Aop-using-a-dotnet-core-library-System-Reflection-DispatchProxy.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ElderJames/p/implement-simple-Aop-using-a-dotnet-core-library-System-Reflection-DispatchProxy.html</guid>
<description>&lt;p&gt;Aop即是面向切面编程，众多Aop框架里Castle是最为人所知的，另外还有Autofac、还有死去的Spring.NET，当然，.NET Core社区新秀AspectCore在性能与功能上都非常优秀，已经逐渐被社区推崇和有越来越多的人使用。感谢柠檬同学的礼物！&lt;/p&gt;
&lt;p&gt;如果大家出于自身需求或者学习，想实现一个Aop，是不是觉得一来就要使用Emit去做？最近我了解到了System.Reflection.DispatchProxy这个corefx类库，已经实现了动态代理功能。&lt;/p&gt;
&lt;p&gt;下面演示一下它的使用方法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        //创建代理类，并把SamepleProxy作为拦截器注入
        var samepleProxy = (targetInterface)SamepleProxy.Create&amp;lt;targetInterface, SamepleProxy&amp;gt;();
        //执行接口方法
        samepleProxy.Write(&quot;here is invoke by proxy&quot;);
    }
}

//需要被生成代理实例的接口
public interface targetInterface
{
    //这个方法会被代理类实现
    void Write(string writesomeshing);
}

public class SamepleProxy : DispatchProxy
{
    /// &amp;lt;summary&amp;gt;
    /// 拦截调用
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;method&quot;&amp;gt;所拦截的方法信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;所拦截方法被传入的参数指&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    protected override object Invoke(MethodInfo targetMethod, object[] args)
    {
        Console.WriteLine(args[0]);
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;System.Reflection.DispatchProxy&lt;/code&gt;只有一个Api，就是&lt;code&gt;objecct Create&amp;lt;T,TProxy&amp;gt;() where TProxy:DispatchProxy&lt;/code&gt;,约束了只能传入泛型参数，并不能从方法传入类型，这就会带来很多问题。而更可气的是，给官方提了issue之后，还是不给增加这个api……&lt;br/&gt;幸好，在那个issue下，issue作者提供了一个解决方案，就是用反射来构造这个泛型方法。我还在这基础上，封装了一下，加入了传入拦截器实例和传入拦截器构造方法参数的功能。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 拦截器接口
/// &amp;lt;/summary&amp;gt;
public interface IInterceptor
{
    /// &amp;lt;summary&amp;gt;
    /// 拦截器调用
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;target&quot;&amp;gt;代理实例&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;method&quot;&amp;gt;所拦截的方法&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;所拦截方法传入的参数值&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;返回值会传递给方法返回值&amp;lt;/returns&amp;gt;    
    object Intercept(object target, MethodInfo method, object[] parameters);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拦截器要实现这个接口，下面是对DispatchProxy的封装，实现更多创建代理实例的方法&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ProxyGenerator : DispatchProxy
{
    private IInterceptor interceptor { get; set; }
    private static object proxy { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 创建代理实例
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;targetType&quot;&amp;gt;所要代理的接口类型&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;interceptor&quot;&amp;gt;拦截器&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;代理实例&amp;lt;/returns&amp;gt;
    public static object Create(Type targetType, IInterceptor interceptor)
    {
        object proxy = GetProxy(targetType);
        MethodInfo method = typeof(ProxyGenerator).GetMethod(nameof(CreateInstance), BindingFlags.NonPublic | BindingFlags.Instance, Type.DefaultBinder, new[] { typeof(IInterceptor) }, null);
        method.Invoke(proxy, new object[] { interceptor });
        return proxy;
    }

    /// &amp;lt;summary&amp;gt;
    /// 创建代理实例
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;targetType&quot;&amp;gt;所要代理的接口类型&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;interceptorType&quot;&amp;gt;拦截器类型&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;拦截器构造函数参数值&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;代理实例&amp;lt;/returns&amp;gt;
    public static object Create(Type targetType, Type interceptorType, params object[] parameters)
    {
        object proxy = GetProxy(targetType);
        MethodInfo method = typeof(ProxyGenerator).GetMethod(nameof(CreateInstance), BindingFlags.NonPublic | BindingFlags.Instance, Type.DefaultBinder, new[] { typeof(Type), typeof(object[]) }, null);
        method.Invoke(proxy, new object[] { interceptorType, parameters });
        return proxy;
    }


    /// &amp;lt;summary&amp;gt;
    /// 创建代理实例 TTarget:所要代理的接口类型 TInterceptor:拦截器类型
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;拦截器构造函数参数值&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;代理实例&amp;lt;/returns&amp;gt;
    public static TTarget Create&amp;lt;TTarget, TInterceptor&amp;gt;(params object[] parameters) where TInterceptor : IInterceptor
    {
        object proxy = GetProxy(typeof(TTarget));
        MethodInfo method = typeof(ProxyGenerator).GetMethod(nameof(CreateInstance), BindingFlags.NonPublic | BindingFlags.Instance, Type.DefaultBinder, new[] { typeof(Type), typeof(object[]) }, null);
        method.Invoke(proxy, new object[] { typeof(TInterceptor), parameters });
        return (TTarget)proxy;
    }

    private static object GetProxy(Type targetType)
    {
        MethodInfo method = typeof(DispatchProxy).GetMethod(nameof(DispatchProxy.Create), new Type[] { });
        method = method.MakeGenericMethod(targetType, typeof(ProxyGenerator));
        proxy = method.Invoke(null, null);
        return proxy;
    }

    private void CreateInstance(Type interceptorType, object[] parameters)
    {
        this.interceptor = (IInterceptor)Activator.CreateInstance(interceptorType, parameters);
    }

    private void CreateInstance(IInterceptor interceptor)
    {
        this.interceptor = interceptor;
    }

    protected override object Invoke(MethodInfo method, object[] parameters)
    {
        return this.interceptor.Intercept(proxy, method, parameters);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        // var poxy = (targetInterface)ProxyGenerator.Create(typeof(targetInterface), new SamepleProxy());
        // 或
        //var poxy = (targetInterface)ProxyGenerator.Create(typeof(targetInterface), typeof(SamepleProxy));
        // 或
        var poxy = ProxyGenerator.Create&amp;lt;targetInterface, SamepleProxy&amp;gt;();
        poxy.Write(&quot;here is invoked by coreproxy&quot;);
    }
}


public class SamepleProxy : IInterceptor
{
    public object Intercept(object target, MethodInfo method, object[] parameters)
    {
        Console.WriteLine(parameters[0]);
        return null;
    }
}

public interface targetInterface
{
    void Write(string writesome);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结一下就是，微软爸爸给我们的这个轮子还是即轻便又很好用的。&lt;br/&gt;本文的实例代码可以在我的github上找到：&lt;a href=&quot;https://github.com/ElderJames/CoreProxy&quot; class=&quot;uri&quot;&gt;https://github.com/ElderJames/CoreProxy&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Sep 2018 15:46:00 +0000</pubDate>
<dc:creator>Elder_James</dc:creator>
<og:description>Aop即是面向切面编程，众多Aop框架里Castle是最为人所知的，另外还有Autofac、还有死去的Spring.NET，当然，.NET Core社区新秀AspectCore在性能与功能上都非常优秀</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ElderJames/p/implement-simple-Aop-using-a-dotnet-core-library-System-Reflection-DispatchProxy.html</dc:identifier>
</item>
<item>
<title>MySql数据库实现分布式的主从结构 - 小勇DW3</title>
<link>http://www.cnblogs.com/gxyandwmm/p/9572153.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gxyandwmm/p/9572153.html</guid>
<description>
&lt;p&gt;最近学习了关于使用MySql数据的实现主动结构的原理，在以前的并发访问低的场景一下，一般一台性能高的服务器作为一个MySql数据，就可以满足业务的增删改查场景，但是随着网络用户的增加&lt;/p&gt;
&lt;p&gt;当出现高并发，高QPS的情况下，一台MySql就很难支撑这种场景了，根据现在的分布式处理架构，处理在使用Redis这种高效的缓存数据库外，其实也可以针对数据库端进行分布式处理，也就是原来&lt;/p&gt;
&lt;p&gt;和Redis相同，使用分布式主从架构，通过Master 和 Slave 实现读写分析，数据采用主从复制的原理，这种采用读写分析，同时读的Slave机器可以多台配置的架构，极大了增加的后台的稳定性和满足&lt;/p&gt;
&lt;p&gt;高并发的情景；&lt;/p&gt;

&lt;h2&gt;下面进行原理分析：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901232037686-933970824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;配置的简要过程说明：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Mysql的配置文件【在Spring中进行设置】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901232235705-1807159569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据源的配置：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Master数据源：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901232523009-1863717659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Slave数据源：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901232620665-708967924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;源代码的可以采用基于自定义注解的方式实现：&lt;/p&gt;
&lt;p&gt;1、使用一个选择类，用来配置选择方式；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901232757945-1543957932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系统的配置需要采用一个路由配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901233002832-1496995675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在spring中注册数据源【通过master和slave关键字匹配对应的数据源】：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901233050703-1666715957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;采用注解的方式实现在Mapper接口上通过注解就可以实现自动匹配，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901233238211-1452180625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 自定义注解的实现：使用Aspectj的代理模式 AOP原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901233344194-1602873942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;把注解匹配到具体实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901233539628-1475357956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; Spring中配置注册:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201809/1449963-20180901233957372-612112313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置完成！&lt;/p&gt;

</description>
<pubDate>Sat, 01 Sep 2018 15:42:00 +0000</pubDate>
<dc:creator>小勇DW3</dc:creator>
<og:description>最近学习了关于使用MySql数据的实现主动结构的原理，在以前的并发访问低的场景一下，一般一台性能高的服务器作为一个MySql数据，就可以满足业务的增删改查场景，但是随着网络用户的增加 当出现高并发，高</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gxyandwmm/p/9572153.html</dc:identifier>
</item>
<item>
<title>没做过大项目，但我会建大项目 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/build-complicate-program.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/build-complicate-program.html</guid>
<description>&lt;p&gt;刚出来实习的时候，参与的项目使用的还是SSH框架。&lt;/p&gt;
&lt;p&gt;那时候还在使用SVN进行版本管理，常常在合并代码的时候遇到各种莫名其妙的问题。&lt;/p&gt;
&lt;p&gt;那时候使用着曾经宇宙最好用的JAVA IDE Eclipse写代码，也没有觉得界面简陋影响编码。&lt;/p&gt;
&lt;p&gt;那时候还不知道啥时微服务，只知道有需求了就把代码往单体项目的代码里加，而且是前端和后台代码放一起的那种。什么Vue、React、Angular，不存在的，JQuery搞定一切。&lt;/p&gt;
&lt;p&gt;因为项目小，或者因为业务并不复杂，虽然项目代码都放一块，但是勉强还可以看，找相关的代码也算比较快。&lt;/p&gt;
&lt;p&gt;后来，慢慢接触到了一些大点的项目，而且微服务的设计理念也更加盛行和深入人心。所以，我们会发现在当今宇宙最好的JAVA IDE Intellij IDEA中多了越来越多的微服务项目，日益膨胀的业务，让我们在找相应的项目以及代码的时候力不从心。&lt;/p&gt;
&lt;p&gt;所以，这时候项目的编排就很重要，换句话说就是，大项目应该有大项目的样子。这篇就来看看我们如果在Intellij IDEA中搭建项目目录结构清新的大项目。&lt;/p&gt;
&lt;h3 id=&quot;项目结构对比&quot;&gt;项目结构对比&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;项目划分前&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233616835-1531223148.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候如果要添加代码，我们会在项目里面通过创建各个package用于区分业务代码，或者新建平级的module。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目划分后&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233624985-1678514422.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何创建有层次的大项目框架&quot;&gt;如何创建有层次的大项目框架&lt;/h3&gt;
&lt;h4 id=&quot;创建root项目&quot;&gt;1、创建root项目&lt;/h4&gt;
&lt;p&gt;点击File-&amp;gt;new-&amp;gt;Project，点击图中的左侧的maven，创建一个maven父级项目&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233633719-1893484142.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击next，进入下一步&lt;/p&gt;
&lt;h4 id=&quot;填写maven坐标项目&quot;&gt;2、填写maven坐标项目&lt;/h4&gt;
&lt;p&gt;因为创建的是maven项目，所以需要定义groupId和artifactId，自己填写即可&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233642152-335487651.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击next，进入下一步&lt;/p&gt;
&lt;h4 id=&quot;确认项目信息并完成父级项目创建&quot;&gt;3、确认项目信息并完成父级项目创建&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233649712-1729317451.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;父级项目概览&quot;&gt;4、父级项目概览&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233708353-192630572.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是一个再普通不过的maven项目，下面我们需要在这个项目中新建子module。&lt;/p&gt;
&lt;h4 id=&quot;创建聚合项目&quot;&gt;5、创建聚合项目&lt;/h4&gt;
&lt;p&gt;我们在微服务开发模式下经常需要开发一个接口服务，同时可能还需要一个用于同步数据的服务，如果我们把这两个服务散落在root项目目录下，有时候因为命名而隔得很远，找代码也不方便。&lt;/p&gt;
&lt;p&gt;这时候就需要一个聚合项目，该项目用于编排某个服务项目的原子项目（xxx），如服务的实现项目(&quot;xxx-service&quot;)，服务的接口项目(&quot;xxx-api&quot;)，服务的同步数据项目(&quot;xxx-sync&quot;)。&lt;/p&gt;
&lt;p&gt;这里我们就创建一个聚合项目spring&lt;/p&gt;
&lt;h5 id=&quot;创建spring项目&quot;&gt;5.1 创建“spring”项目&lt;/h5&gt;
&lt;p&gt;在root项目上右键选择new-&amp;gt;module&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233744404-911372159.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;创建一个maven的spring项目&quot;&gt;5.2 创建一个maven的“spring”项目&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233800040-1870113016.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击next，进入下一步&lt;/p&gt;
&lt;h5 id=&quot;填写maven的坐标信息&quot;&gt;5.3 填写maven的坐标信息&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233811636-1828637657.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意这里因为是在root下新建子module，所以这里有个“Parent”选项，即继承了root项目，填写下artifactId即可。&lt;/p&gt;
&lt;p&gt;点击next，进入下一步&lt;/p&gt;
&lt;h5 id=&quot;确认项目信息并完成聚合项目创建&quot;&gt;5.4 确认项目信息并完成聚合项目创建&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233841919-422003729.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;聚合项目概览&quot;&gt;5.5 聚合项目概览&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233851371-1182342528.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意这里聚合项目“spring”已经创建成功，点击root项目的pom文件，可以看到已经多了属性标签，如右图所示。&lt;/p&gt;
&lt;h4 id=&quot;创建聚合项目下的子项目&quot;&gt;6、创建聚合项目下的子项目&lt;/h4&gt;
&lt;p&gt;有了聚合项目，我们就可以在“spring”下创建子项目了，具体步骤如下&lt;/p&gt;
&lt;h5 id=&quot;创建聚合项目下的子项目-1&quot;&gt;6.1 创建聚合项目下的子项目&lt;/h5&gt;
&lt;p&gt;在“spring”项目上右键new-&amp;gt;module，这时候我们选择创建一个springboot的项目&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233921579-1051599046.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击next，进入下一步&lt;/p&gt;
&lt;h5 id=&quot;填写项目基本信息&quot;&gt;6.2 填写项目基本信息&lt;/h5&gt;
&lt;p&gt;填写好springboot项目的maven坐标信息&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233930779-1552771541.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击next，进入下一步，一直到确认信息页面&lt;/p&gt;
&lt;h5 id=&quot;确认项目信息&quot;&gt;6.3确认项目信息&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233939555-565578481.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意这里默认content root和module file location只到/Users/jackie/workspace/root/spring，但是我们要创建的是springboot项目，位于聚合项目下的子项目。所以需要将两个变量的信息改为如图所示，即加上新建项目的名称信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我在这里尝试过几次，都没有加上子项目的名称，导致新建的项目一直和聚合项目平级，无法起到聚合的目的，所以这里需要格外注意。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;聚合项目下的子项目概览&quot;&gt;6.4 聚合项目下的子项目概览&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180901233947203-1345503214.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里“spring”作为聚合项目，可以将该目录下的src目录删除，仅保留pom文件用于编排子项目。&lt;/p&gt;
&lt;p&gt;至此，我们完成了基本父级项目的创建，聚合项目的创建以及聚合项目下子项目的创建。&lt;/p&gt;
&lt;p&gt;看完这边，相信再复杂的目录结构层次也难不倒你了。&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Sep 2018 15:42:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>大项目实战可遇不可求，但是搭建大项目的技能我们志在必得。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/build-complicate-program.html</dc:identifier>
</item>
<item>
<title>python爬虫-淘宝商品密码（图文教程附源码） - BruceLong</title>
<link>http://www.cnblogs.com/yunlongaimeng/p/9572082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunlongaimeng/p/9572082.html</guid>
<description>&lt;p&gt;&lt;span&gt;今天闲着没事，不想像书上介绍的那样，我相信所有的数据都是有规律可以寻找的，然后去分析了一下淘宝的商品数据的规律和加密方式，用了最简单的知识去解析了需要的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个也让我学到了，解决问题的方法不止一个，我们要常常学会去思考，学会去学习，相信我们爬虫还是可以拿到我们想要的一切需要的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我也对数据感兴趣，就是感觉，世间万物都是有规律可寻的，就看我们能不能去发现其中的秘密。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们去解决一个问题的时候，那一种成就感是别人难以体会的。只有我们去亲身体验才会感到真正的幸福。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所用模块：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;re+requests+json&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所用环境：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;windows10 + pycharm&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;实战分析：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;第一步：根据url来在google chrome中分析数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302991/201809/1302991-20180901232642477-1681289849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302991/201809/1302991-20180901232751504-1944284487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析的结果是：数据就是通过json来存储的&lt;/p&gt;
&lt;p&gt;第二步：&lt;/p&gt;
&lt;p&gt;得到网页的源码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302991/201809/1302991-20180901232957569-1919365885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三步把得到的数据进行解析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302991/201809/1302991-20180901233051285-1926312380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 第四步：对数据进行解密&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302991/201809/1302991-20180901233123498-1512218709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第五步：就可以把json的数据拿到并分析得到相应的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302991/201809/1302991-20180901233208886-2082848913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 以下是源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在搜索框中输入美食得到的数据q=%E7%BE%8E%E9%A3%9F&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://s.taobao.com/search?q=%E7%BE%8E%E9%A3%9F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; response =&lt;span&gt; requests.get(url)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(response.text)&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用正则对html源码进行解析到一个json数据&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; pattern = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;g_page_config =(.*?});&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, re.S)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; result =&lt;span&gt; re.search(pattern, response.text)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(result.group(1))&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发现并不是那么简单而是加密的数据并是有规律可寻的，以下是加密的几个数据段&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     json_data = re.sub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(\\\\u003d)|(\\\\u0026)|(\\\\u003c)|(\\\\u003e)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, result.group(1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;数据解密成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(json_data)&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;数据解密失败，原因是：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,e)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; json_dumps = json.dumps(json_data)&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(json_dumps)&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; data_count = 1
&lt;span&gt;27&lt;/span&gt; data =&lt;span&gt; json.loads(json_data)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 分析json的数据并把需要的数据给读取出来&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; good &lt;span&gt;in&lt;/span&gt; data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mods&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;itemlist&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;auctions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;商店名：{},商品标题:{},\n商品图片：{},\n商品产地：{},商品价格：{},付款人数：{},\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(good[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nick&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], good[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], good[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pic_url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], good[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item_loc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], good[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;view_price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],good[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;view_sales&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     data_count += 1
&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(data_count)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 01 Sep 2018 15:17:00 +0000</pubDate>
<dc:creator>BruceLong</dc:creator>
<og:description>今天闲着没事，不想像书上介绍的那样，我相信所有的数据都是有规律可以寻找的，然后去分析了一下淘宝的商品数据的规律和加密方式，用了最简单的知识去解析了需要的数据。 这个也让我学到了，解决问题的方法不止一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunlongaimeng/p/9572082.html</dc:identifier>
</item>
<item>
<title>win32进程概念之句柄表,以及内核对象. - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/9571964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/9571964.html</guid>
<description>&lt;h2&gt;一丶什么是句柄表什么是内核对象.&lt;/h2&gt;
&lt;h3&gt;1.句柄表的生成&lt;/h3&gt;
&lt;p&gt;我们知道.我们使用CreateProcess 的时候会返回一个进程句柄.以及线程句柄. 其实在调用CreateProcess的时候.内核中会新建一个EPROCESS结构来存储我们的进程信息.&lt;/p&gt;
&lt;p&gt;例如如下图:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901213809885-626063259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是有一个问题.怎么给三环使用.难道直接返回EPROCESS?&lt;/p&gt;
&lt;p&gt;其实不是这样的. 第一EPROCESS在高两G. 三环程序是不可以访问的.所以返回的地址是高两G所以不能使用. 但是为了解决这一问题. &lt;/p&gt;
&lt;p&gt;windows创建了一个表格. 返回这个表格的索引. 而我们使用的就是这个索引.&lt;/p&gt;
&lt;h3&gt;2.什么是内核对象.&lt;/h3&gt;
&lt;p&gt;内核对象就是我们上面所说的EPROCESS. 有很多内核对象.具体可以看下CloseHandle. 这个API表示他可以关闭什么内核对象.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Access token&lt;/li&gt;
&lt;li&gt;Communications device&lt;/li&gt;
&lt;li&gt;Console input&lt;/li&gt;
&lt;li&gt;Console screen buffer&lt;/li&gt;
&lt;li&gt;Event&lt;/li&gt;
&lt;li&gt;File&lt;/li&gt;
&lt;li&gt;File mapping&lt;/li&gt;
&lt;li&gt;I/O completion port&lt;/li&gt;
&lt;li&gt;Job&lt;/li&gt;
&lt;li&gt;Mailslot&lt;/li&gt;
&lt;li&gt;Memory resource notification&lt;/li&gt;
&lt;li&gt;Mutex&lt;/li&gt;
&lt;li&gt;Named pipe&lt;/li&gt;
&lt;li&gt;Pipe&lt;/li&gt;
&lt;li&gt;Process&lt;/li&gt;
&lt;li&gt;Semaphore&lt;/li&gt;
&lt;li&gt;Thread&lt;/li&gt;
&lt;li&gt;Transaction&lt;/li&gt;
&lt;li&gt;Waitable timer&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以操作事件  文件 互斥体 线程. 等等....&lt;/p&gt;
&lt;h2&gt;二丶多进程共用内核对象&lt;/h2&gt;
&lt;h3&gt;1.第一种方法. 使用OpenProcess&lt;/h3&gt;
&lt;p&gt;在windows程序中.我们操作的都是内核对象. 我们可以通过OpenProcess API来打开一个已有进程的内核对象.&lt;/p&gt;
&lt;p&gt;如下图:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901214607042-1110188052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个进程里面的句柄表都是私有的. 例如第一张表. 句柄索引位1. 对应内核对象为A. 那么将索引传给B进程是没用用的.&lt;/p&gt;
&lt;p&gt;B进程只有使用API打开之后才能获得 A内核对象.&lt;/p&gt;

&lt;p&gt;其中中间的紫色表代表引用计数. 也就是说这个内核对象引用一次 这个值则会+1&lt;/p&gt;
&lt;p&gt;而CloseHandle作用就是 使内核对象的引用计数-1 如果都关闭了.那么此时内核对象没有人使用. 也没有执向了.所以就会销毁这个内核对象了.也就是说.当内核对象的引用计数位为0了.那么此时的内核对象&lt;/p&gt;
&lt;p&gt;才是真正的销毁.&lt;/p&gt;
&lt;p&gt;而线程是特例:  当线程的内核对象引用计数为0的时候也不会关闭.  此时必须先关闭线程.在使用CloseHandle 是引用计数 -1才可以.&lt;/p&gt;
&lt;h3&gt;2.使用继承句柄技术&lt;/h3&gt;
&lt;p&gt;在windows程序中. A创建 B .或者带有内核对象的 API在创建的时候. 都有一个SD属性.也就是安全属性.这个属性可以表示你创建的这个句柄是否可以继承.&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;p&gt; 　　CreateEvent()创建事件. 先不用管API的作用.我们看下API的参数吧.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HANDLE CreateEventA(
  LPSECURITY_ATTRIBUTES lpEventAttributes,     安全属性结构体 主要介绍他
  BOOL                  bManualReset,
  BOOL                  bInitialState,
  LPCSTR                lpName
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个就是安全属性结构体.如果我们不指定.默认就是父进程的.&lt;/p&gt;
&lt;p&gt;安全属性结构体.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _SECURITY_ATTRIBUTES {
  DWORD  nLength;                                         当前结构体大小.windows扩展使用的
  LPVOID lpSecurityDescriptor;                        表明这个句柄给谁用谁可以访问.谁可以关闭.不重要 具体可以看下API中的结构体的定义.不重要不列出来了.
  BOOL   bInheritHandle;                                重要.表明句柄是否可以被继承.
} SECURITY_ATTRIBUTES, &lt;/span&gt;*PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901220056740-1225123869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们的句柄可以被继承. 那么句柄表的第一项就填1.表示这个句柄可以被继承.如果不能继承.则为0&lt;/p&gt;
&lt;p&gt;此时我们的子进程就可以继承父进程的 所有可继承的句柄表了.  注意.是所有可继承.  可以是共享的了. 如下图所示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901220651916-527597919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A进程创建的 B D是可以继承的. 所以 子进程可以完全复制A进程 可继承句柄表. 不允许继承的为0 都赋值为0&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;二丶进程PID解析&lt;/h2&gt;
&lt;p&gt;在windows任务管理器中.有PID选项.我们可以选中查看. 而且在windows中也常常听到进程ID的概念.&lt;/p&gt;
&lt;p&gt;那么进程ID到底是个什么东西.&lt;/p&gt;
&lt;p&gt;其实进程ID是全局的句柄表的一个索引.  上面所讲的句柄表.都是自己私有的句柄表. PID是全局句柄表里面的.&lt;/p&gt;
&lt;p&gt;这个句柄表里面记录了所有的正在运行进程的句柄.而且是唯一的. 如果进程死亡那么这个pid可能会执向别的句柄.  但也是唯一的.如下图所示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901221724455-868725913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而这个全局句柄表才是真正有意义的.为什么这样说.&lt;/p&gt;
&lt;p&gt;我们可以做个测试.&lt;/p&gt;
&lt;p&gt;1.使用OpenProcess打开进程句柄.&lt;/p&gt;
&lt;p&gt;2.使用TerminlateProcess结束进程.&lt;/p&gt;
&lt;p&gt;OpenProcess(访问权限,句柄是否可以继承,进程PID)&lt;/p&gt;
&lt;p&gt;TerminlateProcess(进程句柄,自定义的退出码) 结束进程.&lt;/p&gt;
&lt;p&gt;使用上面的两个API可以测试一下我们已有的进程是否可以被关闭. 如果测试过后你会发现.&lt;/p&gt;
&lt;p&gt;只有PID获得句柄才是有用了.也就是说全局句柄表. 而上面所讲的都是子进程的句柄表.&lt;/p&gt;

&lt;h2&gt;三丶常用进程操作API&lt;/h2&gt;
&lt;p&gt;1. GetModuleFileName()  获取当前模块路径 例如:  c:\\1.exe&lt;/p&gt;
&lt;p&gt;2.GetCurretDirectory()     获取当前的工作目录 例如:  c:\text\abc&lt;/p&gt;
&lt;p&gt;3.OpenProcess()  根据进程PID打开进程.获取进程句柄.&lt;/p&gt;
&lt;p&gt;4.FindWindow()    根据类名以及文件名.返回窗口句柄.&lt;/p&gt;
&lt;p&gt;5.GetWindowsThreadProcessId()  根据窗口句柄.获取进程PID&lt;/p&gt;
&lt;p&gt;6.EnumProcesses 遍历所有进程.返回进程PID    具体参考MSDN 有提供的例子.&lt;/p&gt;
&lt;p&gt;7.GetCommandLine() 获取命令行参数&lt;/p&gt;
&lt;p&gt;8.CreateToolHelp32Snapshot() 创建进程快照. 如果懂逆向的就知道.FS寄存器中的TEB PEB结构中有存储当前模块的或者进程的链表.这个是保存当前这一时刻的快照.&lt;/p&gt;
&lt;p&gt;我们可以进行遍历. 具体参考MSDN或者本博客. &lt;/p&gt;

&lt;h2&gt;四丶编写windows程序遇到的问题.&lt;/h2&gt;
&lt;p&gt;我们在编写windows程序的时候.会包含windows.h 但是有的函数可能就没有. 比如上面我们说的第八个函数. 快照函数.&lt;/p&gt;
&lt;p&gt;此时我们要查询MSDN. 我们可以搜索一下网页的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901223937766-775455115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以在下边看到所需要的头文件 是 tlhelp32.h 此时我们包含一下即可.&lt;/p&gt;
&lt;p&gt;遇到的问题2.&lt;/p&gt;
&lt;p&gt;有的时候我们头文件也包含了也去使用了.但是调用API的时候出错了.为什么?&lt;/p&gt;
&lt;p&gt;原因是 有的API在高版本中才有.低版本中使用的时候是没有导出的.此时使用就会出错.提示没有这个API.&lt;/p&gt;
&lt;p&gt;解决方法: 如果学过win32的 说的这个方法你们就理解了.如果没学过也没关系.一般这个问题很少遇见. 博主也才预见过一次.&lt;/p&gt;
&lt;p&gt;可以使用 loadlibary加载所需要的dll. 然后使用 GetProcAddress获取函数地址. 使用函数指针来使用这个函数.&lt;/p&gt;

</description>
<pubDate>Sat, 01 Sep 2018 14:42:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<og:description>句柄表跟内核对象 一丶什么是句柄表什么是内核对象. 1.句柄表的生成 我们知道.我们使用CreateProcess 的时候会返回一个进程句柄.以及线程句柄. 其实在调用CreateProcess的时候</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/9571964.html</dc:identifier>
</item>
<item>
<title>Python制作回合制手游外挂简单教程（上） - Rest探路者</title>
<link>http://www.cnblogs.com/Java-Starter/p/9571919.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java-Starter/p/9571919.html</guid>
<description>&lt;h2 align=&quot;left&quot;&gt;&lt;strong&gt;引入：&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;每次玩回合制游戏的时候，反反复复的日常任务让人不胜其烦&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;玩问道的时候，我们希望能够自动刷道，玩梦幻希望能自动做师门、捉鬼等等&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;该外挂只能模拟鼠标键盘操作，并不能修改游戏数据&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我这里使用的python2.7&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;开发工具是PyCharm&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;strong&gt;前期知识准备：&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;首先下载autopy包，我这里PyCharm可以直接导入autopy包&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;或者用利用pip进行安装：pip install autopy&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;strong&gt;鼠标移动&lt;/strong&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;复制如下代码，运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;

import time

 

import autopy

#quick move

autopy.mouse.move(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

 

#smooth move

#autopy.mouse.smooth_move(&lt;/span&gt;&lt;span&gt;1370&lt;/span&gt;,&lt;span&gt;120&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;会发现鼠标瞬间移动到坐标(1,1)的位置，我的电脑是1920*1080的，最右下角的坐标就是(1920,1080)。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;将move换成smooth_move,会发现鼠标慢慢地移动到指定坐标&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;官方文档的解释：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;autopy.mouse.move(x: float, y: float)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    Moves the mouse to the given (x, y) coordinate.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    Exceptions:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            ValueError is thrown if the point is out of index.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;autopy.mouse.smooth_move(x: float, y: float)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    Smoothly moves the mouse to the given (x, y) coordinate in a straight line.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    Exceptions:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            ValueError is thrown if the point is out of index.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;坐标超过分辨率会报异常&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;strong&gt;鼠标点击&lt;/strong&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;运行代码，发现当前位置产生了点击操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;

import autopy

autopy.mouse.click() # 单击&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;strong&gt;键盘操作&lt;/strong&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;下面时一些常见的键值码和键的对应：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   字母和数字键　数字小键盘的键　　功能键　　　　其它键 &lt;br/&gt;      键   键码      键   键码          键   键码       键      键码 &lt;br/&gt;      A   65          0   96            F1   112       Backspace    8 &lt;br/&gt;      B   66          1   97            F2   113       Tab       9 &lt;br/&gt;      C   67          2   98            F3   114       Clear      12 &lt;br/&gt;      D   68          3   99            F4   115       Enter      13 &lt;br/&gt;      E   69          4   100           F5   116      Shift      16 &lt;br/&gt;      F   70          5   101           F6   117      Control     17 &lt;br/&gt;      G   71         6   102           F7   118      Alt       18 &lt;br/&gt;      H   72         7   103           F8   119      Caps Lock    20 &lt;br/&gt;      I    73          8   104          F9   120      Esc       27 &lt;br/&gt;      J    74          9   105          F10  121     Spacebar    32 &lt;br/&gt;      K   75         *   106           F11  122      Page Up     33 &lt;br/&gt;      L   76         +   107           F12  123      Page Down    34 &lt;br/&gt;      M   77        Enter 108                          End       35 &lt;br/&gt;      N   78         -   109                              Home      36 &lt;br/&gt;      O   79         .   110                              Left Arrow   37 &lt;br/&gt;      P   80         /   111                              Up Arrow    38 &lt;br/&gt;      Q   81                                                Right Arrow   39 &lt;br/&gt;      R   82                                                Down Arrow    40 &lt;br/&gt;      S   83                                                Insert      45 &lt;br/&gt;      T   84                                                Delete      46 &lt;br/&gt;      U   85                                                Help       47 &lt;br/&gt;      V   86                                                Num Lock     144   &lt;br/&gt;      W  87          &lt;br/&gt;      X   88      &lt;br/&gt;      Y   89      &lt;br/&gt;      Z   90      &lt;br/&gt;      0   48      &lt;br/&gt;      1   49      &lt;br/&gt;      2   50       &lt;br/&gt;      3   51       &lt;br/&gt;      4   52       &lt;br/&gt;      5   53       &lt;br/&gt;      6   54       &lt;br/&gt;      7   55       &lt;br/&gt;      8   56       &lt;br/&gt;      9   57&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;复制代码，运行，这里需要win32api包&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;调用win32api的keybd_event方法，用过要释放按键&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
#coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;

import time

import win32api

 

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #alt键位码是18

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #tab键位码是9

time.sleep(&lt;/span&gt;&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;)

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #enter键位码是13

 

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) #释放按键

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

time.sleep(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; 可以看到，完成了切换窗口的操作，相当于我们按alt+tab,然后回车进入&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;开始制作外挂：&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;这里以问道手游为例(回合制手游类似)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;需要夜神模拟器，并在模拟器上安装问道&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我试过蓝叠和MuMu模拟器，我用autopy移动鼠标到模拟器时鼠标就消失了，不能完成后续的自动操作，后来百度了&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;说有的模拟器不受win窗口的控制。不管那么多，我们先用夜神模拟器吧！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1201453/201809/1201453-20180901222349163-1818644615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;进入游戏，打开“活动”&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1201453/201809/1201453-20180901222357917-1861327743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;我们以“竞技场”活动举例说明&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1201453/201809/1201453-20180901222405574-162648938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; 这里我们要用到截图工具，我用的是&lt;a href=&quot;https://picpick.app/zh/&quot; target=&quot;_blank&quot;&gt;PicPick&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 个人用户免费，我主要用它来测量坐标&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1201453/201809/1201453-20180901222410955-1044140543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 记录下竞技场前往的坐标(1358,504)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1201453/201809/1201453-20180901222416237-1122311475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;记录下竞技场按钮的坐标(1332,650)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;制作回合制脚本首先得要熟悉任务流程&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;然后点击竞技场，走完这个任务流程，依次记录按钮的坐标&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;竞技场任务一天可以做五次，我们对步骤循环五次&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;战斗时间我们需要自己来计时，不同门派，土豪或者平民玩家时间都不一样&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我是平民玩家，大概耗时60s，点击过挑战让代码延迟60s再继续执行&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1201453/201809/1201453-20180901222448326-720592957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;复制代码，运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
#coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;

import autopy

import time

import win32api

import win32con

#竞技场

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #alt键位码是18

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #tab键位码是9

time.sleep(&lt;/span&gt;&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;)

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  #enter键位码是13

 

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) #释放按键

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

win32api.keybd_event(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,win32con.KEYEVENTF_KEYUP,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

time.sleep(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)

 

def mousemove_click(x,y):

    autopy.mouse.smooth_move(x, y)

    autopy.mouse.click()

 

mousemove_click(&lt;/span&gt;&lt;span&gt;771&lt;/span&gt;, &lt;span&gt;203&lt;/span&gt;&lt;span&gt;)  # 活动的坐标

 

mousemove_click(&lt;/span&gt;&lt;span&gt;1358&lt;/span&gt;,&lt;span&gt;504&lt;/span&gt;)  # 竞技场&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;前往&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;的坐标

 

time.sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;)#从天墉城城中心/&lt;span&gt;其他地图走到竞技使者花费20s

 

mousemove_click(&lt;/span&gt;&lt;span&gt;1334&lt;/span&gt;, &lt;span&gt;650&lt;/span&gt;&lt;span&gt;)  # 竞技使者对话框中的竞技场的坐标

 

 

#挑战完毕会出现对话窗口

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;):

    mousemove_click(&lt;/span&gt;&lt;span&gt;664&lt;/span&gt;,&lt;span&gt;706&lt;/span&gt;&lt;span&gt;) #挑战试炼童子

 

    mousemove_click(&lt;/span&gt;&lt;span&gt;1082&lt;/span&gt;,&lt;span&gt;578&lt;/span&gt;&lt;span&gt;) #确认

 

    mousemove_click(&lt;/span&gt;&lt;span&gt;1530&lt;/span&gt;, &lt;span&gt;794&lt;/span&gt;&lt;span&gt;)  # 战斗自动

 

    time.sleep(&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;)#挑战试炼童子预计60s
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 align=&quot;left&quot;&gt; 效果如下：&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1201453/201809/1201453-20180901222007369-1205355222.gif&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;349&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下一集将介绍如何实现队长模式刷道(自动组队，自动跑环接任务)&lt;/p&gt;

</description>
<pubDate>Sat, 01 Sep 2018 14:29:00 +0000</pubDate>
<dc:creator>Rest探路者</dc:creator>
<og:description>引入： 每次玩回合制游戏的时候，反反复复的日常任务让人不胜其烦 玩问道的时候，我们希望能够自动刷道，玩梦幻希望能自动做师门、捉鬼等等 说明： 该外挂只能模拟鼠标键盘操作，并不能修改游戏数据 我这里使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java-Starter/p/9571919.html</dc:identifier>
</item>
<item>
<title>MySQL优化指南 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/9183795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/9183795.html</guid>
<description>&lt;p&gt;当MySQL单表记录数过大时，增删改查性能都会急剧下降，可以参考以下步骤来优化：&lt;/p&gt;
&lt;h3&gt;单表优化&lt;/h3&gt;
&lt;p&gt;除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在&lt;code&gt;千万级&lt;/code&gt;以下，字符串为主的表在&lt;code&gt;五百万&lt;/code&gt;以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量：&lt;/p&gt;
&lt;h4&gt;字段&lt;/h4&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;尽量使用&lt;code&gt;TINYINT&lt;/code&gt;、&lt;code&gt;SMALLINT&lt;/code&gt;、&lt;code&gt;MEDIUM_INT&lt;/code&gt;作为整数类型而非&lt;code&gt;INT&lt;/code&gt;，如果非负则加上&lt;code&gt;UNSIGNED&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;VARCHAR&lt;/code&gt;的长度只分配真正需要的空间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用枚举或整数代替字符串类型&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;尽量使用&lt;code&gt;TIMESTAMP&lt;/code&gt;而非&lt;code&gt;DATETIME&lt;/code&gt;，&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;单表不要有太多字段，建议在20以内&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;避免使用NULL字段，很难查询优化且占用额外索引空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用整型来存IP&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;索引&lt;/h4&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;索引并不是越多越好，要根据查询有针对性的创建，考虑在&lt;code&gt;WHERE&lt;/code&gt;和&lt;code&gt;ORDER BY&lt;/code&gt;命令上涉及的列建立索引，可根据&lt;code&gt;EXPLAIN&lt;/code&gt;来查看是否用了索引还是全表扫描&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;应尽量避免在&lt;code&gt;WHERE&lt;/code&gt;子句中对字段进行&lt;code&gt;NULL&lt;/code&gt;值判断，否则将导致引擎放弃使用索引而进行全表扫描&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;值分布很稀少的字段不适合建索引，例如&quot;性别&quot;这种只有两三个值的字段&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;字符字段只建前缀索引&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;字符字段最好不要做主键&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不用外键，由程序保证约束&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;尽量不用&lt;code&gt;UNIQUE&lt;/code&gt;，由程序保证约束&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;查询SQL&lt;/h4&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可通过开启慢查询日志来找出较慢的SQL&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;不做列运算：&lt;code&gt;SELECT id WHERE age + 1 = 10&lt;/code&gt;，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不用&lt;code&gt;SELECT *&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;OR&lt;/code&gt;改写成&lt;code&gt;IN&lt;/code&gt;：&lt;code&gt;OR&lt;/code&gt;的效率是n级别，&lt;code&gt;IN&lt;/code&gt;的效率是log(n)级别，in的个数建议控制在200以内&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不用函数和触发器，在应用程序实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免&lt;code&gt;%xxx&lt;/code&gt;式查询&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;少用&lt;code&gt;JOIN&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用同类型进行比较，比如用&lt;code&gt;'123'&lt;/code&gt;和&lt;code&gt;'123'&lt;/code&gt;比，&lt;code&gt;123&lt;/code&gt;和&lt;code&gt;123&lt;/code&gt;比&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;尽量避免在&lt;code&gt;WHERE&lt;/code&gt;子句中使用!=或&amp;lt;&amp;gt;操作符，否则将引擎放弃使用索引而进行全表扫描&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于连续数值，使用&lt;code&gt;BETWEEN&lt;/code&gt;不用&lt;code&gt;IN&lt;/code&gt;：&lt;code&gt;SELECT id FROM t WHERE num BETWEEN 1 AND 5&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;列表数据不要拿全表，要使用&lt;code&gt;LIMIT&lt;/code&gt;来分页，每页数量也不要太大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;引擎&lt;/h4&gt;
&lt;p&gt;目前广泛使用的是MyISAM和InnoDB两种引擎：&lt;/p&gt;
&lt;h5&gt;MyISAM&lt;/h5&gt;
&lt;p&gt;MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持事务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持外键&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不支持崩溃后的安全恢复&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在表有读取查询的同时，支持往表中插入新纪录&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持&lt;code&gt;BLOB&lt;/code&gt;和&lt;code&gt;TEXT&lt;/code&gt;的前500个字符索引，支持全文索引&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持延迟更新索引，极大提升写入性能&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;InnoDB&lt;/h5&gt;
&lt;p&gt;InnoDB在MySQL 5.5后成为默认索引，它的特点是：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持行锁，采用MVCC来支持高并发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持事务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持外键&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持崩溃后的安全恢复&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不支持全文索引&lt;/p&gt;
&lt;p&gt;ps: 据说innodb已经在mysql 5.6.4支持全文索引了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总体来讲，MyISAM适合&lt;code&gt;SELECT&lt;/code&gt;密集型的表，而InnoDB适合&lt;code&gt;INSERT&lt;/code&gt;和&lt;code&gt;UPDATE&lt;/code&gt;密集型的表&lt;/p&gt;
&lt;h4&gt;系统调优参数&lt;/h4&gt;
&lt;p&gt;可以使用下面几个工具来做基准测试：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-0.89189189189189&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/akopytov/sysbench&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;sysbench&lt;/a&gt;：一个模块化，跨平台以及多线程的性能测试工具&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.85555555555556&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tmcallaghan/iibench-mysql&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;iibench-mysql&lt;/a&gt;：基于 Java 的 MySQL/Percona/MariaDB 索引进行插入性能测试工具&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.78260869565217&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Percona-Lab/tpcc-mysql&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;tpcc-mysql&lt;/a&gt;：Percona开发的TPC-C测试工具&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体的调优参数内容较多，具体可参考官方文档，这里介绍一些比较重要的参数：&lt;/p&gt;
&lt;ul readability=&quot;26&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;back_log：back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;thread_concurrency：并发线程数，设为CPU核数的两倍&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;skip_name_resolve：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;key_buffer_size：索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。对于内存4G左右，可设为256M或384M，通过查询&lt;code&gt;show status like 'key_read%'&lt;/code&gt;，保证&lt;code&gt;key_reads / key_read_requests&lt;/code&gt;在0.1%以下最好&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;innodb_buffer_pool_size：缓存数据块和索引块，对InnoDB表性能影响最大。通过查询&lt;code&gt;show status like 'Innodb_buffer_pool_read%'&lt;/code&gt;，保证&lt;code&gt; (Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests&lt;/code&gt;越高越好&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;innodb_additional_mem_pool_size：InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL会记录Warning信息到数据库的错误日志中，这时就需要该调整这个参数大小&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;innodb_log_buffer_size：InnoDB存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;query_cache_size：缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用Query Cache可能会得不偿失。根据命中率&lt;code&gt;(Qcache_hits/(Qcache_hits+Qcache_inserts)*100))&lt;/code&gt;进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大.&lt;br/&gt;可以通过命令&lt;code&gt;show status like 'Qcache_%'&lt;/code&gt;查看目前系统Query catch使用大小&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;read_buffer_size：MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;sort_buffer_size：MySql执行排序使用的缓冲大小。如果想要增加&lt;code&gt;ORDER BY&lt;/code&gt;的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;read_rnd_buffer_size：MySql的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;thread_cache_size：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;table_cache：类似于thread_cache_size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;升级硬件&lt;/h4&gt;
&lt;p&gt;Scale up，这个不多说了，根据MySQL是CPU密集型还是I/O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能&lt;/p&gt;
&lt;h3&gt;读写分离&lt;/h3&gt;
&lt;p&gt;也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离&lt;/p&gt;
&lt;h3&gt;缓存&lt;/h3&gt;
&lt;p&gt;缓存可以发生在这些层次：&lt;/p&gt;
&lt;ul readability=&quot;2.8838709677419&quot;&gt;&lt;li readability=&quot;-0.67857142857143&quot;&gt;
&lt;p&gt;MySQL内部：在&lt;a&gt;系统调优参数&lt;/a&gt;介绍了相关设置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;数据访问层：比如MyBatis针对SQL语句做缓存，而Hibernate可以精确到单个记录，这里缓存的对象主要是持久化对象&lt;code&gt;Persistence Object&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象&lt;code&gt;Data Transfer Object&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Web层：针对web页面做缓存&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;浏览器客户端：用户端的缓存&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以根据实际情况在一个层次或多个层次结合加入缓存。这里重点介绍下服务层的缓存实现，目前主要有两种方式：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;直写式（Write Through）：在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如Spring Cache的工作方式。这种实现非常简单，同步好，但效率一般。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;回写式（Write Back）：当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;表分区&lt;/h3&gt;
&lt;p&gt;MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码&lt;/p&gt;
&lt;p&gt;对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/506684/201806/506684-20180614165047525-1003841775.png&quot; alt=&quot;请叫我头头哥_mysql优化&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过&lt;code&gt;EXPLAIN PARTITIONS&lt;/code&gt;来查看某条SQL语句会落在那些分区上，从而进行SQL优化，如下图5条记录落在两个分区上：&lt;/p&gt;
&lt;pre class=&quot;hljs asciidoc&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-section&quot;&gt;mysql&amp;gt; explain partitions select count(1) from user_partition where id in (1,2,3,4,5);
+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+
&lt;span class=&quot;hljs-section&quot;&gt;| id | select_type | table          | partitions | type  | possible_keys | key     | key_len | ref  | rows | Extra                    |
+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+
&lt;span class=&quot;hljs-section&quot;&gt;|  1 | SIMPLE      | user_partition | p1,p4      | range | PRIMARY       | PRIMARY | 8       | NULL |    5 | Using where; Using index |
+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+
1 row in set (0.00 sec)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分区的好处是：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以让单表存储更多的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;部分查询能够从查询条件确定只落在少数分区上，速度会很快&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以备份和恢复单个分区&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分区的限制和缺点：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个表最多只能有1024个分区&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;分区表无法使用外键约束&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;NULL值会使分区过滤无效&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所有分区必须使用相同的存储引擎&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分区的类型：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分区适合的场景有：&lt;/p&gt;
&lt;pre class=&quot;hljs sql&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE members (
    firstname &lt;span class=&quot;hljs-built_in&quot;&gt;VARCHAR(&lt;span class=&quot;hljs-number&quot;&gt;25) &lt;span class=&quot;hljs-keyword&quot;&gt;NOT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
    lastname &lt;span class=&quot;hljs-built_in&quot;&gt;VARCHAR(&lt;span class=&quot;hljs-number&quot;&gt;25) &lt;span class=&quot;hljs-keyword&quot;&gt;NOT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
    username &lt;span class=&quot;hljs-built_in&quot;&gt;VARCHAR(&lt;span class=&quot;hljs-number&quot;&gt;16) &lt;span class=&quot;hljs-keyword&quot;&gt;NOT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
    email &lt;span class=&quot;hljs-built_in&quot;&gt;VARCHAR(&lt;span class=&quot;hljs-number&quot;&gt;35),
    joined &lt;span class=&quot;hljs-built_in&quot;&gt;DATE &lt;span class=&quot;hljs-keyword&quot;&gt;NOT &lt;span class=&quot;hljs-literal&quot;&gt;NULL
)
&lt;span class=&quot;hljs-keyword&quot;&gt;PARTITION &lt;span class=&quot;hljs-keyword&quot;&gt;BY &lt;span class=&quot;hljs-keyword&quot;&gt;RANGE( &lt;span class=&quot;hljs-keyword&quot;&gt;YEAR(joined) ) (
    &lt;span class=&quot;hljs-keyword&quot;&gt;PARTITION p0 &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES &lt;span class=&quot;hljs-keyword&quot;&gt;LESS &lt;span class=&quot;hljs-keyword&quot;&gt;THAN (&lt;span class=&quot;hljs-number&quot;&gt;1960),
    &lt;span class=&quot;hljs-keyword&quot;&gt;PARTITION p1 &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES &lt;span class=&quot;hljs-keyword&quot;&gt;LESS &lt;span class=&quot;hljs-keyword&quot;&gt;THAN (&lt;span class=&quot;hljs-number&quot;&gt;1970),
    &lt;span class=&quot;hljs-keyword&quot;&gt;PARTITION p2 &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES &lt;span class=&quot;hljs-keyword&quot;&gt;LESS &lt;span class=&quot;hljs-keyword&quot;&gt;THAN (&lt;span class=&quot;hljs-number&quot;&gt;1980),
    &lt;span class=&quot;hljs-keyword&quot;&gt;PARTITION p3 &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES &lt;span class=&quot;hljs-keyword&quot;&gt;LESS &lt;span class=&quot;hljs-keyword&quot;&gt;THAN (&lt;span class=&quot;hljs-number&quot;&gt;1990),
    &lt;span class=&quot;hljs-keyword&quot;&gt;PARTITION p4 &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES &lt;span class=&quot;hljs-keyword&quot;&gt;LESS &lt;span class=&quot;hljs-keyword&quot;&gt;THAN MAXVALUE
);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询时加上时间范围条件效率会非常高，同时对于不需要的历史数据能很容的批量删除。&lt;/p&gt;
&lt;p&gt;另外MySQL有一种早期的简单的分区实现 - 合并表（merge table），限制较多且缺乏优化，不建议使用，应该用新的分区机制来替代&lt;/p&gt;
&lt;h3&gt;垂直拆分&lt;/h3&gt;
&lt;p&gt;垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联&lt;/p&gt;
&lt;p&gt;比如原始的用户表是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/506684/201806/506684-20180614165108196-1729607270.png&quot; alt=&quot;请叫我头头哥_mysql优化&quot;/&gt;&lt;/p&gt;
&lt;p&gt;垂直拆分后是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/506684/201806/506684-20180614165133684-551616626.png&quot; alt=&quot;请叫我头头哥_mysql优化&quot;/&gt;&lt;/p&gt;
&lt;p&gt;垂直拆分的优点是：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block 就少)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据维护简单&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点是：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;主键出现冗余，需要管理冗余列&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;依然存在单表数据量过大的问题（需要水平拆分）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务处理复杂&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;水平拆分&lt;/h3&gt;
&lt;h4&gt;概述&lt;/h4&gt;
&lt;p&gt;水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。前面的表分区本质上也是一种特殊的库内分表&lt;/p&gt;
&lt;p&gt;库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决&lt;/p&gt;
&lt;p&gt;前面垂直拆分的用户表如果进行水平拆分，结果是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/506684/201806/506684-20180614165209681-658841207.png&quot; alt=&quot;请叫我头头哥_mysql优化&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际情况中往往会是垂直拆分和水平拆分的结合，即将&lt;code&gt;Users_A_M&lt;/code&gt;和&lt;code&gt;Users_N_Z&lt;/code&gt;再拆成&lt;code&gt;Users&lt;/code&gt;和&lt;code&gt;UserExtras&lt;/code&gt;，这样一共四张表&lt;/p&gt;
&lt;p&gt;水平拆分的优点是:&lt;/p&gt;
&lt;p&gt;缺点是：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;分片事务一致性难以解决&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;跨节点Join性能差，逻辑复杂&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据多次扩展难度跟维护量极大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;分片原则&lt;/h4&gt;
&lt;ul readability=&quot;6.419587628866&quot;&gt;&lt;li readability=&quot;-0.69230769230769&quot;&gt;
&lt;p&gt;能不分就不分，参考&lt;a&gt;单表优化&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询SQL跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性Hash分片，这几种分片都有利于扩容&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;尽量不要在一个事务中的SQL跨越多个分片，分布式事务一直是个不好处理的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;查询条件尽量优化，尽量避免Select * 的方式，大量数据结果集下，会消耗大量带宽和CPU资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过数据冗余和表分区赖降低跨库Join的可能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里特别强调一下分片规则的选择问题，如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。&lt;/p&gt;
&lt;p&gt;总体上来说，分片的选择是取决于最频繁的查询SQL的条件，因为不带任何Where语句的查询SQL，会遍历所有的分片，性能相对最差，因此这种SQL越多，对系统的影响越大，所以我们要尽量避免这种SQL的产生。&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;由于水平拆分牵涉的逻辑比较复杂，当前也有了不少比较成熟的解决方案。这些方案分为两大类：客户端架构和代理架构。&lt;/p&gt;
&lt;h5&gt;客户端架构&lt;/h5&gt;
&lt;p&gt;通过修改数据访问层，如JDBC、Data Source、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以Jar包的方式呈现&lt;/p&gt;
&lt;p&gt;这是一个客户端架构的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/506684/201806/506684-20180614165232689-1736220081.png&quot; alt=&quot;请叫我头头哥_mysql优化&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到分片的实现是和应用服务器在一起的，通过修改Spring JDBC层来实现&lt;/p&gt;
&lt;p&gt;客户端架构的优点是：&lt;/p&gt;
&lt;p&gt;缺点是：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将分片逻辑的压力放在应用服务器上，造成额外风险&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;代理架构&lt;/h5&gt;
&lt;p&gt;通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件&lt;/p&gt;
&lt;p&gt;这是一个代理架构的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/506684/201806/506684-20180614165323775-1528247953.png&quot; alt=&quot;请叫我头头哥_mysql优化&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要Zookeeper之类的服务组件来管理&lt;/p&gt;
&lt;p&gt;代理架构的优点是：&lt;/p&gt;
&lt;p&gt;缺点是：&lt;/p&gt;
&lt;h5&gt;各方案比较&lt;/h5&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; &lt;/th&gt;
&lt;th&gt;出品方&lt;/th&gt;
&lt;th&gt;架构模型&lt;/th&gt;
&lt;th&gt;支持数据库&lt;/th&gt;
&lt;th&gt;分库&lt;/th&gt;
&lt;th&gt;分表&lt;/th&gt;
&lt;th&gt;读写分离&lt;/th&gt;
&lt;th&gt;外部依赖&lt;/th&gt;
&lt;th&gt;是否开源&lt;/th&gt;
&lt;th&gt;实现语言&lt;/th&gt;
&lt;th&gt;支持语言&lt;/th&gt;
&lt;th&gt;最后更新&lt;/th&gt;
&lt;th&gt;Github星数&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://www.mysql.com/products/enterprise/fabric.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;MySQL Fabric&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;MySQL官方&lt;/td&gt;
&lt;td&gt;代理架构&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;python&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;4个月前&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/alibaba/cobar&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Cobar&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;阿里巴巴&lt;/td&gt;
&lt;td&gt;代理架构&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;两年前&lt;/td&gt;
&lt;td&gt;1287&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/alibaba/cobarclient&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Cobar Client&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;阿里巴巴&lt;/td&gt;
&lt;td&gt;客户端架构&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;三年前&lt;/td&gt;
&lt;td&gt;344&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/alibaba/tb_tddl&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;TDDL&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;淘宝&lt;/td&gt;
&lt;td&gt;客户端架构&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;Diamond&lt;/td&gt;
&lt;td&gt;只开源部分&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;519&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/Qihoo360/Atlas&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Atlas&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;奇虎360&lt;/td&gt;
&lt;td&gt;代理架构&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;10个月前&lt;/td&gt;
&lt;td&gt;1941&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/brucexx/heisenberg&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Heisenberg&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;百度熊照&lt;/td&gt;
&lt;td&gt;代理架构&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;2个月前&lt;/td&gt;
&lt;td&gt;197&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/jojoin/TribeDB&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;TribeDB&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;个人&lt;/td&gt;
&lt;td&gt;代理架构&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;NodeJS&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;3个月前&lt;/td&gt;
&lt;td&gt;126&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/dangdangdotcom/sharding-jdbc&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;ShardingJDBC&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;当当&lt;/td&gt;
&lt;td&gt;客户端架构&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;当天&lt;/td&gt;
&lt;td&gt;1144&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/gaoxianglong/shark&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Shark&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;个人&lt;/td&gt;
&lt;td&gt;客户端架构&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;两天前&lt;/td&gt;
&lt;td&gt;84&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/flike/kingshard&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;KingShard&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;个人&lt;/td&gt;
&lt;td&gt;代理架构&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Golang&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;两天前&lt;/td&gt;
&lt;td&gt;1836&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://www.onexsoft.com/?page_id=3383&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;OneProxy&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;平民软件&lt;/td&gt;
&lt;td&gt;代理架构&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://mycat.io/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;MyCat&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;社区&lt;/td&gt;
&lt;td&gt;代理架构&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;两天前&lt;/td&gt;
&lt;td&gt;1270&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/youtube/vitess&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Vitess&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Youtube&lt;/td&gt;
&lt;td&gt;代理架构&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Golang&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;当天&lt;/td&gt;
&lt;td&gt;3636&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/siddontang/mixer&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Mixer&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;个人&lt;/td&gt;
&lt;td&gt;代理架构&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Golang&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;9个月前&lt;/td&gt;
&lt;td&gt;472&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/tumblr/jetpants&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;JetPants&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Tumblr&lt;/td&gt;
&lt;td&gt;客户端架构&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Ruby&lt;/td&gt;
&lt;td&gt;Ruby&lt;/td&gt;
&lt;td&gt;10个月前&lt;/td&gt;
&lt;td&gt;957&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/hibernate/hibernate-shards&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;HibernateShard&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Hibernate&lt;/td&gt;
&lt;td&gt;客户端架构&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;4年前&lt;/td&gt;
&lt;td&gt;57&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/makersoft/mybatis-shards&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;MybatisShard&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;MakerSoft&lt;/td&gt;
&lt;td&gt;客户端架构&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;11个月前&lt;/td&gt;
&lt;td&gt;119&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/twitter/gizzard&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Gizzard&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Twitter&lt;/td&gt;
&lt;td&gt;代理架构&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;td&gt;3年前&lt;/td&gt;
&lt;td&gt;2087&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如此多的方案，如何进行选择？可以按以下思路来考虑：&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;确定是使用代理架构还是客户端架构。中小型规模或是比较简单的场景倾向于选择客户端架构，复杂场景或大规模系统倾向选择代理架构&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;具体功能是否满足，比如需要跨节点&lt;code&gt;ORDER BY&lt;/code&gt;，那么支持该功能的优先考虑&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不考虑一年内没有更新的产品，说明开发停滞，甚至无人维护和技术支持&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最好按大公司-&amp;gt;社区-&amp;gt;小公司-&amp;gt;个人这样的出品方顺序来选择&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;选择口碑较好的，比如github星数、使用者数量质量和使用者反馈&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;开源的优先，往往项目有特殊需求可能需要改动源代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;按照上述思路，推荐以下选择：&lt;/p&gt;
&lt;h3&gt;兼容MySQL且可水平扩展的数据库&lt;/h3&gt;
&lt;p&gt;目前也有一些开源数据库兼容MySQL协议，如：&lt;/p&gt;
&lt;p&gt;但其工业品质和MySQL尚有差距，且需要较大的运维投入，如果想将原始的MySQL迁移到可水平扩展的新数据库中，可以考虑一些云数据库：&lt;/p&gt;
&lt;h3&gt;NoSQL&lt;/h3&gt;
&lt;p&gt;在MySQL上做Sharding是一种戴着镣铐的跳舞，事实上很多大表本身对MySQL这种RDBMS的需求并不大，并不要求ACID，可以考虑将这些表迁移到NoSQL，彻底解决水平扩展问题，例如：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;日志类、监控类、统计类数据&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;非结构化或弱结构化数据&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对事务要求不强，且无太多关联操作的数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考资料:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/YsUtRchqbVT0hKT23jflUK&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Mysql那点事&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6nN8uatxu9L6-QbRz3pOFg&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Mysql策略&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;MySQL :: MySQL 5.6 Reference Manual&lt;/a&gt;&lt;/p&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 01 Sep 2018 14:08:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>当MySQL单表记录数过大时，增删改查性能都会急剧下降，可以参考以下步骤来优化： 单表优化 除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/9183795.html</dc:identifier>
</item>
<item>
<title>SpringBoot项目使用多线程处理任务时无法通过@Autowired注入bean - Bug开发工程师</title>
<link>http://www.cnblogs.com/xiaolong1996/p/9571645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaolong1996/p/9571645.html</guid>
<description>&lt;p&gt;　　最近在做一个“温湿度控制”的项目，项目要求通过用户设定的温湿度数值和实时采集到的数值进行比对分析，因为数据的对比与分析是一个通过前端页面控制的定时任务，经理要求在用户开启定时任务时，单独开启一个线程进行数据的对比分析，并将采集到的温湿度数值存入数据库中的历史数据表，按照我们正常的逻辑应该是用户在请求开启定时任务时，前端页面通过调用后端接口，创建一个新的线程来执行定时任务，然后在线程类中使用 &lt;strong&gt;@Autowired&lt;/strong&gt; 注解注入保存历史数据的service层，在线程类中调用service层保存历史数据的方法实现温湿度数据的保存，这时就出现了一个很尴尬的问题，在新开启的线程中使用 &lt;span&gt;&lt;strong&gt;@Autowired&lt;/strong&gt;&lt;/span&gt; 注解无法注入需要的bean(即：保存历史数据的service层)，程序一直在报 NullPointerException 。&lt;/p&gt;
&lt;p&gt;这是controller层，方法 startExperiment 和 stopExperiment 分别是开始定时任务和停止定时任务的方法，getData方法不属于本次讨论范围，不用管&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.backstage.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.fastjson.JSONObject;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.backstage.entity.JsonResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.backstage.entity.Threshold;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.backstage.service.MainPageService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @ProjectName:
 * @Package: com.backstage.controller
 * @ClassName: MainPageController
 * @Description: 主页面相关操作控制器
 * @Author: wangzhilong
 * @CreateDate: 2018/8/29 9:49
 * @Version: 1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
@RequestMapping(&lt;/span&gt;&quot;/main&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainPageController {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MainPageService mainPageService;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 开始实验
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; threshold
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&quot;/startExperiment&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JsonResponse startExperiment(HttpServletRequest request, Threshold threshold) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mainPageService.startExperiment(request, threshold);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 停止实验
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&quot;/stopExperiment&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JsonResponse stopExperiment() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mainPageService.stopExperiment();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取实时数据
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&quot;/getData&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JSONObject getData() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; service 层接口代码，没什么好说的，直接上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.backstage.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.fastjson.JSONObject;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.backstage.entity.JsonResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.backstage.entity.Threshold;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @ProjectName: 
 * @Package: com.backstage.service
 * @ClassName: MainPageService
 * @Description: 主页面相关操作业务层接口
 * @Author: wangzhilong
 * @CreateDate: 2018/8/29 9:51
 * @Version: 1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MainPageService {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 开始实验
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; threshold
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    JsonResponse startExperiment(HttpServletRequest request, Threshold threshold);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 停止实验
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    JsonResponse stopExperiment();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取实时数据
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    JSONObject getData();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; service 层实现类代码，关于springboot项目使用多线程进行业务处理不属于本章节的讨论范围，如有需要，请留言，我会在看到留言后第一时间更新相关技术文章，由于这里删除了一些与本章节无关的代码，如果复制到开发工具内有报错问题，麻烦大家提醒我一下，以便修改，非常感谢&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.backstage.service.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.fastjson.JSONObject;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.backstage.entity.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.backstage.monitor.TimingMonitoring;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.backstage.service.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scheduling.Trigger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scheduling.TriggerContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scheduling.support.CronTrigger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ScheduledFuture;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @ProjectName: 
 * @Package: com.backstage.service.impl
 * @ClassName: MainPageServiceImpl
 * @Description: 主页面相关操作业务层实现类
 * @Author: wangzhilong
 * @CreateDate: 2018/8/29 9:51
 * @Version: 1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainPageServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MainPageService {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ThreadPoolTaskScheduler threadPoolTaskScheduler;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ScheduledFuture&amp;lt;?&amp;gt;&lt;span&gt; future2;


    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ThreadPoolTaskScheduler threadPoolTaskScheduler() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolTaskScheduler();
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 开始实验
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; threshold
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JsonResponse startExperiment(HttpServletRequest request, Threshold threshold) {

        TimingMonitoring timingMonitoring &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimingMonitoring();
        timingMonitoring.setThreshold(threshold, list, experiment.getId(), experimentData.getId());

        future2 &lt;/span&gt;= threadPoolTaskScheduler.schedule(&lt;span&gt;new&lt;/span&gt; TimingMonitoring(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Trigger() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date nextExecutionTime(TriggerContext triggerContext) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置定时任务的执行时间为3秒钟执行一次&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CronTrigger(&quot;0/10 * * * * ?&quot;&lt;span&gt;).nextExecutionTime(triggerContext);
            }
        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResponse(0,&quot;开始实验!&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 停止实验
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JsonResponse stopExperiment() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (future2 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            experimentService.upd(getTime());
            future2.cancel(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResponse(0,&quot;结束实验!&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取实时数据
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JSONObject getData() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String getTime() {
        SimpleDateFormat format &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; format.format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重点，线程类代码，大家注意看，我在代码最开始使用了spring的 @Autowired 注解注入需要的service，可在调用service中的add方法时，程序报空指针异常，一直认为是add方法或者sql语句有问题，找了一上午，也没发现任何问题，后来单独调用这个add方法是可以正常插入数据的，唯独在这个线程类中调用时报错，感觉和线程有莫大的关系，百度一搜，还真找到了，原来，在线程中为了线程安全，是防注入的，没办法，要用到这个类啊。只能从bean工厂里拿个实例了，继续往下看&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.backstage.monitor;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.backstage.entity.DetailedData;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.backstage.entity.Threshold;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.backstage.entity.ValveValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.backstage.service.DetailedDataService;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @ProjectName:
 * @Package: com.backstage.monitor
 * @ClassName: TimingMonitoring
 * @Description: 定时监测温(湿)度 数据
 * @Author: wangzhilong
 * @CreateDate: 2018/8/29 10:11
 * @Version: 1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TimingMonitoring &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;历史数据业务层接口&lt;/span&gt;
&lt;span&gt;    @Autowired
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DetailedDataService detailedDataService;


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Threshold threshold;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;阈值实体类&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; List&amp;lt;ValveValue&amp;gt; settingData;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设定的温湿度数据&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Integer id;                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实验记录id&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Integer dataId;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;历史数据主表id&lt;/span&gt;

    


    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setThreshold(Threshold threshold, List&amp;lt;ValveValue&amp;gt;&lt;span&gt; settingData, Integer id, Integer dataId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.threshold =&lt;span&gt; threshold;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.settingData =&lt;span&gt; settingData;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dataId =&lt;span&gt; dataId;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟从PLC获取到的数据&lt;/span&gt;
        String data = &quot;001,50.5,002,37,003,45.6,004,40,005,55.2,006,58&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data == &lt;span&gt;null&lt;/span&gt; || data.trim() == &quot;&quot;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若获取到的数据为空，则直接停止该方法的执行&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; temperature = 0.0;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;温度&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; humidity = 0.0;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;湿度&lt;/span&gt;
        Integer type = &lt;span&gt;null&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据类型，1是温度，2是湿度

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析数据，并将数据保存到历史数据数据库&lt;/span&gt;
        String[] str = data.split(&quot;,&quot;&lt;span&gt;);
        SimpleDateFormat format &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; str.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 1 || i == 5 || i == 9) {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;温度&lt;/span&gt;
                type = 1&lt;span&gt;;
                temperature &lt;/span&gt;+=&lt;span&gt; Double.parseDouble(str[i]);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;温度&quot; + i + &quot; -》 &quot; + str[i-1] + &quot;:&quot; + str[i]);&lt;/span&gt;
                detailedDataService.add(&lt;span&gt;new&lt;/span&gt; DetailedData(&lt;span&gt;null&lt;/span&gt;, type, Double.parseDouble(str[i]), format.format(&lt;span&gt;new&lt;/span&gt; Date()), str[i - 1&lt;span&gt;], dataId));
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 3 || i == 7 || i == 11) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;湿度&lt;/span&gt;
                type = 2&lt;span&gt;;
                humidity &lt;/span&gt;+=&lt;span&gt; Double.parseDouble(str[i]);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;湿度&quot; + i + &quot; -》 &quot; + str[i-1] + &quot;:&quot; + str[i]);&lt;/span&gt;
                detailedDataService.add(&lt;span&gt;new&lt;/span&gt; DetailedData(&lt;span&gt;null&lt;/span&gt;, type, Double.parseDouble(str[i]), format.format(&lt;span&gt;new&lt;/span&gt; Date()), str[i - 1&lt;span&gt;], dataId));
            }
        }

    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取当前时间，精确到毫秒
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String getTime() {
        SimpleDateFormat format &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; format.format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获取bean对象的工具类，既然程序无法通过注解拿到需要的bean，那就只好自己写个工具类来获取喽，下面是工具类代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.backstage.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.BeansException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContextAware;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @ProjectName:
 * @Package: com.backstage.config
 * @ClassName: ApplicationContextProvider
 * @Description: 获取bean对象的工具类
 * @Author: wangzhilong
 * @CreateDate: 2018/8/31 13:26
 * @Version: 1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Author:ZhuShangJin
 * Date:2018/7/3
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ApplicationContextProvider &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ApplicationContextAware {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 上下文对象实例
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ApplicationContext applicationContext;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setApplicationContext(ApplicationContext applicationContext) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.applicationContext =&lt;span&gt; applicationContext;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取applicationContext
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ApplicationContext getApplicationContext() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; applicationContext;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过name获取 Bean.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object getBean(String name) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getApplicationContext().getBean(name);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过class获取Bean.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; clazz
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt;&lt;span&gt; clazz) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getApplicationContext().getBean(clazz);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过name,以及Clazz返回指定的Bean
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; clazz
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T getBean(String name, Class&amp;lt;T&amp;gt;&lt;span&gt; clazz) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getApplicationContext().getBean(name, clazz);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样呢，就可以在线程类中写一个无参的构造方法，在构造方法中，通过调用工具类中的 getBean() 方法就可以拿到实例了，程序在调用这个线程类时，会自动调用其无参的构造方法，在构造方法中我们将需要的bean对象注入，然后就可以正常使用了，下边是线程类修改后的代码，由于别的地方没有改动，所以这里只给大家改动的代码，省得大家看到一大堆代码头疼。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TimingMonitoring() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new的时候注入需要的bean&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.detailedDataService = ApplicationContextProvider.getBean(DetailedDataService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好了，至此呢，问题就得到解决了，文章中如错误或不足，请指出，不胜感激，本人小白一枚，如有不足，请多多包含，也请各位大佬能不吝赐教，抱拳&lt;/p&gt;
&lt;p&gt;参考地址：&lt;a href=&quot;https://blog.csdn.net/zsj777/article/details/80965081&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/zsj777/article/details/80965081&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Sep 2018 13:18:00 +0000</pubDate>
<dc:creator>Bug开发工程师</dc:creator>
<og:description>springboot 项目使用多线程处理任务时，在线程中无法通过 @Autowired 注入所需的bean</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaolong1996/p/9571645.html</dc:identifier>
</item>
<item>
<title>【Recorder.js+百度语音识别】全栈方案技术细节 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9557355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9557355.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;项目中需要利用百度语音接口在Web端实现语音识别功能，采用了这样的技术方案，但实现时遇到了很多问题，发现网上大部分文章都只是在详解官方提供的example示例，对实际开发没有提供什么有价值的建议，而&lt;code&gt;recorder.js&lt;/code&gt;是无法直接适配百度AI的语音接口的，故本篇将开发中各个细节点记录与此，欢迎指点交流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一.-技术栈选择&quot;&gt;一. 技术栈选择&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;：利用百度语音接口在Web端实现语音识别功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术栈&lt;/strong&gt;：&lt;code&gt;React&lt;/code&gt;+&lt;code&gt;recorder-tool.js&lt;/code&gt; +&lt;code&gt;recorder.js&lt;/code&gt; + &lt;code&gt;Express&lt;/code&gt; + &lt;code&gt;Baidu语音识别API&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;recorder.js&lt;/code&gt;项目地址:&lt;a href=&quot;https://github.com/mattdiamond/Recorderjs&quot; class=&quot;uri&quot;&gt;https://github.com/mattdiamond/Recorderjs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演示效果&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/29/97de565ecd7cd784637c396b604c58ac.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二.-前端开发细节&quot;&gt;二. 前端开发细节&lt;/h2&gt;
&lt;h3 id=&quot;为recorder.js提供一个代理对象&quot;&gt;为recorder.js提供一个代理对象&lt;/h3&gt;
&lt;p&gt;前端的主框架采用&lt;code&gt;React&lt;/code&gt;，在基本结构和语法上并没有太多问题，为了使用&lt;code&gt;recorder.js&lt;/code&gt;，我们封装了一个&lt;code&gt;recorder-tool.js&lt;/code&gt;作为代理，其实现方法较为简单，就是将官方示例中&lt;code&gt;example&lt;/code&gt;示例中的&lt;code&gt;html&lt;/code&gt;文件的脚本部分封装成一个单例对象作为&lt;code&gt;recorder.js&lt;/code&gt;的代理，然后暴露一组&lt;code&gt;API&lt;/code&gt;供上层调用，大致的结构如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import Recorder from './recorder-src';
//Singleton
var recorder;

//start record
function startRecord() {
    recorder &amp;amp;&amp;amp; recorder.record();
}

//stop record
function stopRecord(button) {
    recorder &amp;amp;&amp;amp; recorder.stop();
}

//....其他一些方法

export default {
    init : init,
    start: startRecord,
    stop: stopRecord,
    exportData: exportData,
    sendRequest: sendRequest,
    clear: clearRecord,
    createDownloadLink : createDownloadLink
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解除exportwav方法的回调地狱&quot;&gt;解除exportWAV方法的回调地狱&lt;/h3&gt;
&lt;p&gt;官方示例中输出&lt;code&gt;wav&lt;/code&gt;编码格式的数据这个动作是通过&lt;code&gt;webworker&lt;/code&gt;来完成的，也就是说二进制数据处理的开始和结束时间点是通过事件来触发的，&lt;code&gt;recorder.exportWAV( )&lt;/code&gt;接收一个回调函数作为入参，在得到&lt;code&gt;wav&lt;/code&gt;格式的数据后会执行传入的回调函数，如果要在&lt;code&gt;react&lt;/code&gt;中实现，就需要写成：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//record-page.js
...
//处理录音-事件监听
proce***ecord(){
    RecorderTools.exportData(function(blob){
        var wav = preProcessData(blob);
        //发送请求
        axios.post({...})
                    .then(function(response){
                          handle(response);
                   })
    });
}
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你或许已经发现了这个【回调地狱】的现象，深度的嵌套会让逻辑变的复杂且代码高度耦合，想把一些方法从&lt;code&gt;react&lt;/code&gt;中剥离出去非常困难，我们希望使用一些其他的方式来转换代码的控制权，而不是把一大堆后续的逻辑传进&lt;code&gt;exportData( )&lt;/code&gt;方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;方法一：使用HTML自定义事件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们在一个存在的DOM元素上添加一个自定义事件&lt;code&gt;recorder.export&lt;/code&gt;的监听器，并在传入&lt;code&gt;recorder.exportWAV( )&lt;/code&gt;方法的回调函数中，手动初始化触发一个自定义事件(暂不考虑兼容性问题)，并把&lt;code&gt;recorder.js&lt;/code&gt;导出的数据挂在这个event对象上，然后在指定元素上派发这个事件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//export data
function exportData() {
    recorder &amp;amp;&amp;amp; recorder.exportWAV(function (blob) {
        //init event
        var exportDone = document.createEvent('HTMLEvents');
            exportDone.initEvent('recorder.export', true, true);
            //add payload
            exportDone.data = blob;
            //dispatch
            document.getElementById('panel').dispatchEvent(exportDone);
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们后续的处理逻辑就可以用常规的方式在&lt;code&gt;React&lt;/code&gt;组件中继续编写后续的业务逻辑，这样就实现了基本的&lt;em&gt;职责分离&lt;/em&gt;和&lt;em&gt;代码分离&lt;/em&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;方法二：监听WebWorker&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;recorder.js&lt;/code&gt;中使用&lt;strong&gt;DOM0&lt;/strong&gt;级事件模型来与&lt;code&gt;webworker&lt;/code&gt;通讯，为了不覆盖原功能，我们可以通过&lt;strong&gt;DOM2事件模型&lt;/strong&gt;在recorder实例上绑定额外的监听器:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;recorder.worker.addEventListener('message',function(event){
    //event.data中就包含了转换后的WAV数据
    processData(event.data);
    ...
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就可以在自己的逻辑代码或二次封装的代码中实现对转码动作的监听。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;方法三：Promise化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用&lt;code&gt;Promise&lt;/code&gt;来实现异步的调用，将音频处理的代码剥离出去,最终的调用方式为：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;RecorderTools.exportData().then(data){
     //继续在React组件文件中编写其他逻辑或调用方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考代码如下:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//RecorderTools.js中的方法定义
function exportData(){
    return new Promise(function(resolve, reject){
        recorder &amp;amp;&amp;amp; recorder.exportWAV(function(blob){
            resolve(blob);
        })
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;回调，事件监听，Promise都是&lt;code&gt;javascript&lt;/code&gt;中重要的异步模式，根据个人喜好和实际场景选择使用即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;如何提交blob对象&quot;&gt;如何提交Blob对象&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;recorder.js&lt;/code&gt;的官方示例可以看到，如果不将录音输出为本地&lt;code&gt;wav&lt;/code&gt;格式的文件，我们得到的是一个&lt;code&gt;Blob&lt;/code&gt;对象，&lt;code&gt;Blob&lt;/code&gt;对象需要使用form表单的方式进行提交，具体方法如下(使用&lt;code&gt;axios&lt;/code&gt;发送&lt;code&gt;http&lt;/code&gt;请求)：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt; var formData = new FormData();
     formData.set('recorder.wav',blob);//blob即为要发送的数据
     axios({
            url:'http://localhost:8927/transmit',
            method : 'POST',
            headers:{
                'Content-Type': 'multipart/form-data'//此处也可以赋值为false
            },
            data:formData
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三.-recorder.js的功能扩展&quot;&gt;三. Recorder.js的功能扩展&lt;/h2&gt;
&lt;p&gt;百度AI语音识别接口接收的语音文件需要满足如下的要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pcm&lt;/code&gt;格式或&lt;code&gt;wav&lt;/code&gt;格式文件的二进制数据经过&lt;strong&gt;base64&lt;/strong&gt;转换后的编码&lt;/li&gt;
&lt;li&gt;16000Hz采样率&lt;/li&gt;
&lt;li&gt;16bit位深&lt;/li&gt;
&lt;li&gt;单声道&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要利用&lt;code&gt;recorder.js&lt;/code&gt;实现上述需求，需要对源码进行一些功能扩展。编码转换可以在服务端进行，而&lt;code&gt;recorder.js&lt;/code&gt;中的&lt;code&gt;floatTo16BitPCM( )&lt;/code&gt;方法看名字应该是为了满足16bit位深这个条件的，那么我们只需要考虑单声道和16000采样率这两个条件了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/29/2d99c572d7b799c86686c9a21ff4f445.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源码中&lt;code&gt;Recorder&lt;/code&gt;构造函数是可以接受参数的，而这个参数会被合入实例的&lt;code&gt;config&lt;/code&gt;属性，其中&lt;code&gt;numChannles&lt;/code&gt;就是声道数，所以我们只需要在实例化是传入自定义的声道数目即可：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;new Recorder({
    numChannels:1//单声道
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来看16000采样率这个条件，查看源码可以知道，源码中对于&lt;code&gt;sampleRate&lt;/code&gt;的使用，一律使用了音频流数据源上下文的&lt;code&gt;sampleRate&lt;/code&gt;，也就是对应着电脑声卡的采样率（&lt;code&gt;48000Hz&lt;/code&gt;或&lt;code&gt;44100Hz&lt;/code&gt;），那如何得到&lt;code&gt;16000Hz&lt;/code&gt;采样率的数据呢？比如一个&lt;code&gt;48000Hz&lt;/code&gt;采样率的声卡采集的信号点，1秒采集了48000次，那么这48000个数据要变成16000个数据，最简单的办法就是每4个点取1个然后组成新的数据，也就是说实际上声音采集设备传过来的采样率是固定的，我们需要多少的采样率，只需要自己拿一个比例系数去换算一下，然后丢弃掉一部分数据点（当然也可以求平均值）就可以了，封装后的调用方式为：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;new Recorder({
    numChannels:1,
    sampleRate:16000
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么在源码中需要做一些功能的扩展，关键的部分在下面这段代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//recorder.js部分源码
function exportWAV(type) {
    var buffers = [];
    for (var channel = 0; channel &amp;lt; numChannels; channel++) {
        buffers.push(mergeBuffers(recBuffers[channel], recLength));
    }
    var interleaved = undefined;
    if (numChannels === 2) {
        interleaved = interleave(buffers[0], buffers[1]);
    } else {
        interleaved = buffers[0];
        //此处是重点，可以看到对于单声道的情况是没有进行处理的，那么仿照双声道的处理方式来添加采样函数，此处改为interleaved = extractSingleChannel(buffers[0]);
    }
    var dataview = encodeWAV(interleaved);
    var audioBlob = new Blob([dataview], { type: type });

    self.postMessage({ command: 'exportWAV', data: audioBlob });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;extractSingleChannel( )&lt;/code&gt;的具体实现参考&lt;code&gt;interleave( )方法&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
*sampleStep是系统的context.sampleRate/自定义sampleRate后取整的结果，这个方法实现了对单声道的*采样数据处理。
*/

function extractSingleChannel(input) {
    //如果此处不按比例缩短，实际输出的文件会包含sampleStep倍长度的空录音
    var length = Math.ceil(input.length / sampleStep);
    var result = new Float32Array(length);
    var index = 0,
        inputIndex = 0;
    while (index &amp;lt; length) {
        //此处是处理关键，算法就是输入的数据点每隔sampleStep距离取一个点放入result
        result[index++] = input[inputIndex];
        inputIndex += sampleStep;
    }
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样处理后&lt;code&gt;exportWAV( )&lt;/code&gt;方法输出的Blob对象中存放的数据就满足了百度语音的识别要求。&lt;/p&gt;
&lt;h2 id=&quot;四.-服务端开发细节&quot;&gt;四. 服务端开发细节&lt;/h2&gt;
&lt;p&gt;在服务端我们使用&lt;code&gt;Express&lt;/code&gt;框架来部署一个消息中转服务，这里涉及的知识点相对较少，可以使用百度AI的&lt;code&gt;nodejs-sdk&lt;/code&gt;来实现，也可以自行封装，权限验证的方法几乎都是通用的，按照官方文档来做就可以了。&lt;/p&gt;
&lt;p&gt;通过&lt;strong&gt;multipart/form-data&lt;/strong&gt;方式提交的表单无法直接通过&lt;code&gt;req.body&lt;/code&gt;或&lt;code&gt;req.params&lt;/code&gt;进行处理，这里使用官方推荐的&lt;code&gt;Multer&lt;/code&gt;中间件来处理，此处较为简单，直接附上笔者的参考代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/29/5d158f5acb624c5bb84b8d6225a17cd5.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此处有一点需要注意的是：在实例化&lt;code&gt;Multer&lt;/code&gt;时，传参和不传参时得到的转换对象是不一样的，如果涉及到相关场景可以直接在控制台打印出来确保使用了正确的属性。&lt;/p&gt;
</description>
<pubDate>Sat, 01 Sep 2018 13:01:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>项目中需要利用百度语音接口在Web端实现语音识别功能，采用了这样的技术方案，但实现时遇到了很多问题，发现网上大部分文章都只是在详解官方提供的example示例，对实际开发没有提供什么有价值的建议，而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9557355.html</dc:identifier>
</item>
<item>
<title>机器学习(十一)  支持向量机 SVM（上） - 本心依然</title>
<link>http://www.cnblogs.com/zhangtaotqy/p/9571590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangtaotqy/p/9571590.html</guid>
<description>&lt;h2&gt;一、什么是支撑向量机SVM （Support Vector Machine）&lt;/h2&gt;
&lt;p&gt;SVM(Support Vector Machine)指的是&lt;a href=&quot;https://baike.baidu.com/item/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/9683835&quot; target=&quot;_blank&quot; data-lemmaid=&quot;9683835&quot;&gt;支持向量机&lt;/a&gt;，是常见的一种判别方法。在机器学习领域，是一个有监督的学习模型，通常用来进行模式识别、分类以及回归分析。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;10.730245231608&quot;&gt;Vapnik等人在多年研究统计学习理论基础上对线性&lt;a href=&quot;https://baike.baidu.com/item/%E5%88%86%E7%B1%BB%E5%99%A8&quot; target=&quot;_blank&quot;&gt;分类器&lt;/a&gt;提出了另一种设计最佳准则。其原理也从线性可分说起，然后扩展到线性不可分的情况。甚至扩展到使用非线性函数中去，这种分类器被称为支持向量机（Support Vector Machine，简称SVM）。支持向量机的提出有很深的理论背景。&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;6.3&quot;&gt;支持&lt;a href=&quot;https://baike.baidu.com/item/%E5%90%91%E9%87%8F&quot; target=&quot;_blank&quot;&gt;向量&lt;/a&gt;机方法是在后来提出的一种新方法。&lt;/div&gt;
&lt;p&gt;SVM的主要思想可以概括为两点：&lt;/p&gt;
&lt;ol class=&quot;custom_num para-list list-paddingleft-1&quot; readability=&quot;-1.4645669291339&quot;&gt;&lt;li class=&quot;list-num-1-1 list-num-paddingleft-1&quot; readability=&quot;0.48076923076923&quot;&gt;
&lt;div class=&quot;para&quot; readability=&quot;11.538461538462&quot;&gt;它是针对线性可分情况进行分析，对于线性不可分的情况，通过使用非线性&lt;a href=&quot;https://baike.baidu.com/item/%E6%98%A0%E5%B0%84&quot; target=&quot;_blank&quot;&gt;映射&lt;/a&gt;算法将低维输入空间线性不可分的样本转化为&lt;a href=&quot;https://baike.baidu.com/item/%E9%AB%98%E7%BB%B4&quot; target=&quot;_blank&quot;&gt;高维&lt;/a&gt;特征空间使其线性可分，从而使得高维特征空间采用线性算法对样本的非线性特征进行线性分析成为可能。&lt;/div&gt;
&lt;/li&gt;
&lt;li class=&quot;list-num-1-2 list-num-paddingleft-1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;它基于结构风险最小化理论之上在特征空间中构建最优超平面，使得学习器得到全局最优化，并且在整个样本空间的期望以某个概率满足一定上界。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901192825020-1513426673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901192832273-777307283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、SVM背后的最优化问题&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901195632836-1313798627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901195637944-1305694856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901195641413-101512618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901195645157-182869934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901195656684-243312882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901195706326-202592138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901195712491-1104441243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、Soft Margin SVM  和 SVM 正则化&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901201556673-306492676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901201601063-2077420060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901201604571-953980224.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901201607819-1166711860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、scikit-learn中的SVM&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901204322771-424043147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901204326354-1735261308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901204329580-1163903069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901204332764-983681895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901204337473-1721566901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901204341050-35810562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901204344932-1945128475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、SVM中使用多项式特征和核函数&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901205844387-801239756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901205910497-1404066777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201809/1071925-20180901205915112-1190723294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Sep 2018 13:00:00 +0000</pubDate>
<dc:creator>本心依然</dc:creator>
<og:description>一、什么是支撑向量机SVM （Support Vector Machine） SVM(Support Vector Machine)指的是支持向量机，是常见的一种判别方法。在机器学习领域，是一个有监督</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangtaotqy/p/9571590.html</dc:identifier>
</item>
</channel>
</rss>