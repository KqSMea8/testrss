<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>浅谈static其一之不死变量 - joenahm</title>
<link>http://www.cnblogs.com/joenahm/p/8970208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joenahm/p/8970208.html</guid>
<description>&lt;p&gt;在学习汇编的过程中，小有所悟，遂把自己所思所想记下，以便日后查阅。&lt;/p&gt;

&lt;p&gt;首先说说我对这个关键字的理解。static字面上就是静止的、静态的、不变的之类的意思，所以在被它修饰之后，应该也会带有这样的一些特点。事实证明也确实是这样，利用这样的特点能很方便的达到一些编程实践中所要达到的一些效果。而它的存在在本质上又有什么样的原理在里面呢？说到这，我就不得不说，学底层的东西有一点好，就是能了解原理。对于我这样的一个喜欢知根知底的人来说，确实很有吸引力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存储角度：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在最近的汇编学习中，我了解到内存中有（但不是仅有）3中不同的区域，分别是：&lt;strong&gt;静态存储区域、堆和栈&lt;/strong&gt;。然后它们有着不同的职能，而静态存储区就和我们这次要聊的static有着莫大的关联。&lt;/p&gt;
&lt;p&gt;大家都知道，程序要先加载到内存中，才能正常工作。那有没有具体想过，程序究竟是怎么被加载到内存中的？以及，程序到底是啥？就我现在的理解，程序在存储的角度看，就是变量和函数。所以，把程序加载到内存也就是把变量和函数加载到内存。那么问题就来了，这里的变量是哪些变量呢？好吧。。其实哪种变量都有可能，我最关注的就是&lt;strong&gt;全局变量&lt;/strong&gt;和&lt;strong&gt;静态变量（&lt;/strong&gt;&lt;em&gt;被static修饰的变量&lt;/em&gt;&lt;strong&gt;）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为这两种变量是要被放到内存的静态存储区的（对，变量虽然都是变量，但存储的位置却大有不同）。所以说，从存储的角度看，全局变量和静态变量是存储在同一地方的，而且这两种变量（所占的空间）还是要写死在生成的目标可执行文件中的（对于编译型语言）。&lt;/p&gt;
&lt;p&gt;我推断：&lt;/p&gt;
&lt;p&gt;1.全局变量好理解，它要先于任何函数而存在，所以它不可能在栈中；而堆变量也要从函数中申请，所以在没有函数存在的前提下，存放在静态存储区的全局变量只能由目标可执行文件提供。&lt;/p&gt;
&lt;p&gt;2.静态变量则是在函数执行完毕从栈中弹出后依然存在的，所以它肯定不在栈上，而它又不是动态申请来的，所以也不在堆上，那从存储角度讲，它的存在其实和函数是没有关系的。所以要加载它只能从目标可执行文件中来。&lt;/p&gt;
&lt;p&gt;所以，从存储的视角来看，static变量与全局变量并无差别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;逻辑角度：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里有两个概念要说明一下，就是&lt;strong&gt;作用域&lt;/strong&gt;和&lt;strong&gt;生存期&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个变量的作用域就是能访问这个变量的范围；而一个变量的生存期则是我能访问这个变量的时期或者说时机。&lt;/p&gt;
&lt;p&gt;这样就有了至少四种组合：1.全局可访问+局部（函数内）生存期 2.全局可访问+全局生存期 3.局部可访问+局部生存期 4.局部可访问+全局生存期&lt;/p&gt;
&lt;p&gt;第1种可能性简直是一个逆天的存在。。。单线程的程序同一时间不可能跑两个函数，所以这样的做法毫无意义。所以这种可能性根本不存在。&lt;/p&gt;
&lt;p&gt;第2种可能性就是全局变量。&lt;/p&gt;
&lt;p&gt;第3种可能性就是栈变量，也就是函数的局部变量。&lt;/p&gt;
&lt;p&gt;而第4种可能性就是我们今天的重头戏，被static修饰的静态变量。（其实我暗想，堆变量也能在十分别扭的操作下达到这种效果，但是实在不是常规途径）&lt;/p&gt;

&lt;p&gt;全局生存期对全局变量来说理所当然，但是对一个作用域是局部的函数内部的变量来说意味着什么呢？&lt;strong&gt;这意味着函数结束从栈中被弹出后，变量的值还存在&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这就是static的语义所在——不变的，这里的不变指的是变量的生存状态不变。哈哈，中二一点其实也可以叫它作“不死变量”。&lt;/p&gt;
&lt;p&gt;那也许有人会问：这有什么用呢？当然有用，我最感兴趣的一个作用是：函数可以存住东西了。函数终于不再那么的“动态”了，开始有点“静态”的影子了。&lt;/p&gt;
&lt;p&gt;举个例子的话，比如我要从一个字符串中往外一个一个地取字符，运用了static修饰符，我就可以优雅地每调用一次一个函数就取到一个直达取完。C语言的话我可以写成下边的样子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; getChar(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;str){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; result =&lt;span&gt; str[index];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     index++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; *&lt;span&gt;argv[]){    
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *str = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt;&lt;span&gt; c;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;( (c=getChar(str)) != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ){
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        putchar(c);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样的一个好处是我可以不用破坏原字符串而且是很方便地用一个独立的函数，实现了所想即所得。&lt;/p&gt;

&lt;p&gt;全局生存期是它们的共同点，而不同则在于&lt;strong&gt;作用域&lt;/strong&gt;的不同，这也是static的作用所在。全局变量，在所有函数中均可访问，那这样就会产生安全性问题，导致在用这个变量的时候不能确保它的值只被本函数所控制。这就是所谓的&lt;strong&gt;封装性&lt;/strong&gt;差。而static修饰符恰能解决这一点，由于被它修饰的变量是函数的局部变量，导致它的作用域仅在这个函数内，这样我们便可安心大胆的断定，这个变量的值只由本函数控制。&lt;/p&gt;

&lt;p&gt;而在像Java这样的语言中，却不允许用static修饰局部作用域的变量。我想可能是因为已经能有其它的方式来表达类似的语义了，虽然不完全一样。而且到了面向对象编程的时候，我们完全可以换另一种思维来考虑问题，所以也不是那么的需要这样的函数设计方式了。在Java中，static的含义与C语言中大不相同。我们目前只说了“不死变量”这一种语义，就这一点Java是没有的，可它却有另外的含义。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;未完待续...&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Apr 2018 17:06:00 +0000</pubDate>
<dc:creator>joenahm</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/joenahm/p/8970208.html</dc:identifier>
</item>
<item>
<title>音视频编解码（一）——解码：代码实现 - 冷豪</title>
<link>http://www.cnblogs.com/learnhow/p/8970019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learnhow/p/8970019.html</guid>
<description>&lt;p&gt;前言：对于从未接触过音视频编解码的同学来说，使用FFmpeg的学习曲线恐怕略显陡峭。本人由于工作需要，正好需要在项目中使用。因此特地将开发过程总结下来。只当提供给有兴趣的同学参考和学习。&lt;/p&gt;
&lt;p&gt;由于FFmpeg是使用C语言开发，所有和函数调用都是面向过程的。以我目前的学习经验来说，通常我会把一个功能的代码全部放在main函数中实现。经过测试和修改认为功能正常，再以C++面向对象的方式逐步将代码分解和封装。因此在对本套指南中我也会采用先代码实现再功能封装的步骤。&lt;/p&gt;
&lt;p&gt;一、开发前的准备工作&lt;/p&gt;
&lt;p&gt;开发工具为VS2013+Qt5，目录结构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bin:工作和测试目录&lt;/li&gt;
&lt;li&gt;doc:开发文档目录&lt;/li&gt;
&lt;li&gt;include:ffmpeg头文件配置目录&lt;/li&gt;
&lt;li&gt;lib:ffmpeg静态库配置目录&lt;/li&gt;
&lt;li&gt;src:源码目录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;属性页配置：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;常规-输出目录：..\..\bin&lt;/li&gt;
&lt;li&gt;调试-工作目录：..\..\bin&lt;/li&gt;
&lt;li&gt;C/C++-常规-附加包含目录：..\..\include&lt;/li&gt;
&lt;li&gt;链接器-常规-附加库目录：..\..\lib&lt;/li&gt;
&lt;li&gt;链接器-系统-子系统：控制台 (/SUBSYSTEM:CONSOLE)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;二、编解码基础知识&lt;/p&gt;
&lt;p&gt;（1）封装格式&lt;/p&gt;
&lt;p&gt;所谓封装格式是指音视频的组合格式，例如最常见的封装格式有mp4、mp3、flv等。简单来说，我们平时接触到的带有后缀的音视频文件都是一种封装格式。不同的封装格式遵循不同的协议标准。有兴趣的同学可以自行扩展，更深的东西我也不懂。&lt;/p&gt;
&lt;p&gt;（2）编码格式&lt;/p&gt;
&lt;p&gt;以mp4为例，通常应该包含有视频和音频。视频的编码格式为&lt;em&gt;YUV420P&lt;/em&gt;，音频的编码格式为&lt;em&gt;PCM&lt;/em&gt;。再以&lt;em&gt;YUV420&lt;/em&gt;编码格式为例。我们知道通常图像的显示为&lt;em&gt;RGB&lt;/em&gt;（红绿蓝三原色），在视频压缩的时候会首先将代表每一帧画面的&lt;em&gt;RGB&lt;/em&gt;压缩为&lt;em&gt;YUV&lt;/em&gt;，再按照关键帧（&lt;em&gt;I&lt;/em&gt;帧），过渡帧（&lt;em&gt;P&lt;/em&gt;帧或&lt;em&gt;B&lt;/em&gt;帧）进行运算和编码。解码的过程正好相反，解码器会读到I帧，并根据&lt;em&gt;I&lt;/em&gt;帧运算和解码&lt;em&gt;P&lt;/em&gt;帧以及&lt;em&gt;B&lt;/em&gt;帧。并最终根据视频文件预设的&lt;em&gt;FPS&lt;/em&gt;还原每一帧画面的&lt;em&gt;RGB&lt;/em&gt;数据。最后推送给显卡。所以通常我们说的编码过程就包括：画面采集、转码、编码再封装。&lt;/p&gt;
&lt;p&gt;（3）视频解码和音频解码有什么区别&lt;/p&gt;
&lt;p&gt;玩游戏的同学肯定对&lt;em&gt;FPS&lt;/em&gt;不陌生，&lt;em&gt;FPS&lt;/em&gt;太低画面会感觉闪烁不够连贯，&lt;em&gt;FPS&lt;/em&gt;越高需要显卡性能越好。一些高速摄像机的采集速度能够达到11000帧/秒，那么在播放这类影片的时候我们是否也需要以11000帧/秒播放呢？当然不是，通常我们会按照25帧/秒或者60帧/秒设定图像的&lt;em&gt;FPS&lt;/em&gt;值。但是由于视频存在关键帧和过渡帧的区别，关键帧保存了完整的画面而过渡帧只是保存了与前一帧画面的变化部分，需要通过关键帧计算获得。因此我们需要对每一帧都进行解码，即获取画面的&lt;em&gt;YUV&lt;/em&gt;数据。同时只对我们真正需要显示的画面进行转码，即将&lt;em&gt;YUV&lt;/em&gt;数据转换成&lt;em&gt;RGB&lt;/em&gt;数据，包括计算画面的宽高等。&lt;/p&gt;
&lt;p&gt;但是音频则不然，音频的播放必须和采集保持同步。提高或降低音频的播放速度都会让音质发生变化，这也是变声器的原理。因此在实际开发中为了保证播放的音视频同步，我们往往会按照音频的播放速度来控制视频的解码转码速度。&lt;/p&gt;
&lt;p&gt;三、代码实现&lt;/p&gt;
&lt;p&gt;（1）注册FFmpeg组件：注册和初始化FFmpeg封装器和网络设备&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;av_register_all();
avformat_network_init();
avdevice_register_all();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （2）打开文件和创建输入设备&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
AVFormatContext *pFormatCtx =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; errnum = avformat_open_input(&amp;amp;&lt;span&gt;pFormatCtx, filename, NULL, NULL);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    av_strerror(errnum, errbuf, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(errbuf));
    cout &lt;/span&gt;&amp;lt;&amp;lt; errbuf &amp;lt;&amp;lt;&lt;span&gt; endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AVFormatContext 表示一个封装器，在读取多媒体文件的时候，它负责保存与封装和编解码有关的上下文信息。avformat_open_input函数可以根据文件后缀名来创建封装器。&lt;/p&gt;
&lt;p&gt;（3）遍历流并初始化解码器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; pFormatCtx-&amp;gt;nb_streams; ++&lt;span&gt;i) {
    AVCodecContext &lt;/span&gt;*pCodecCtx = pFormatCtx-&amp;gt;streams[i]-&amp;gt;codec; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解码器上下文&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (pCodecCtx-&amp;gt;codec_type == AVMEDIA_TYPE_VIDEO) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 视频通道&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; videoIndex =&lt;span&gt; i;
            
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 视频的宽，高&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; srcWidth = pCodecCtx-&amp;gt;&lt;span&gt;width;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; srcHeight = pCodecCtx-&amp;gt;&lt;span&gt;height;
            
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建视频解码器，打开解码器&lt;/span&gt;
        AVCodec *codec = avcodec_find_decoder(pCodecCtx-&amp;gt;&lt;span&gt;codec_id);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;codec) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 无法创建对应的解码器&lt;/span&gt;
&lt;span&gt;        }

        errnum &lt;/span&gt;=&lt;span&gt; avcodec_open2(pCodecCtx, codec, NULL);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            av_strerror(errnum, errbuf, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(errbuf));
            cout &lt;/span&gt;&amp;lt;&amp;lt; errbuf &amp;lt;&amp;lt;&lt;span&gt; endl;
        }
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;video decoder open success!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pCodecCtx-&amp;gt;codec_type == AVMEDIA_TYPE_AUDIO) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 音频通道&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; audioIndex =&lt;span&gt; i;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建音频解码器，打开解码器&lt;/span&gt;
        AVCodec *codec = avcodec_find_decoder(pCodecCtx-&amp;gt;&lt;span&gt;codec_id);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;codec) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 无法创建对应的解码器&lt;/span&gt;
&lt;span&gt;        }

        errnum &lt;/span&gt;=&lt;span&gt; avcodec_open2(pCodecCtx, codec, NULL);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            av_strerror(errnum, errbuf, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(errbuf));
            cout &lt;/span&gt;&amp;lt;&amp;lt; errbuf &amp;lt;&amp;lt;&lt;span&gt; endl;&lt;/span&gt;&lt;span&gt;
        }

        int sampleRate &lt;/span&gt;= pCodecCtx-&amp;gt;sample_rate; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 音频采样率&lt;/span&gt;
        int channels = pCodecCtx-&amp;gt;channels; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声道数&lt;/span&gt;
        AVSampleFormat fmt = pCodecCtx-&amp;gt;sample_fmt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 样本格式&lt;/span&gt;
&lt;span&gt;
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;audio decoder open success!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    }
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;封装器中保存了各种流媒体的通道，通常视频通道为0，音频通道为1。除此以外可能还包含字幕流通道等。&lt;/p&gt;
&lt;p&gt;第2步和第3步基本就是打开多媒体文件的主要步骤，解码和转码的所有参数都可以在这里获取。接下来我们就需要循环进行读取、解码、转码直到播放完成。&lt;/p&gt;
&lt;p&gt;（4）读取压缩数据：之所以称为压缩数据主要是为了区分&lt;strong&gt;&lt;em&gt;AVPacket&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;AVFrame&lt;/em&gt;&lt;/strong&gt;两个结构体。&lt;em&gt;AVPacket&lt;/em&gt;表示一幅经过了关键帧或过渡帧编码后的画面，&lt;em&gt;AVFrame&lt;/em&gt;表示一个&lt;em&gt;AVPacket&lt;/em&gt;经过解码后的完整&lt;em&gt;YUV&lt;/em&gt;画面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
AVPacket *pkt =&lt;span&gt; NULL;
pkt &lt;/span&gt;= av_packet_alloc(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化AVPacket
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取一帧数据&lt;/span&gt;
errnum =&lt;span&gt; av_read_frame(pFormatCtx, pkt);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum ==&lt;span&gt; AVERROR_EOF) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已经读取到文件尾&lt;/span&gt;
    av_strerror(errnum, errbuf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(errbuf));
    cout &lt;/span&gt;&amp;lt;&amp;lt; errbuf &amp;lt;&amp;lt;&lt;span&gt; endl;
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    av_strerror(errnum, errbuf, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(errbuf));
    cout &lt;/span&gt;&amp;lt;&amp;lt; errbuf &amp;lt;&amp;lt;&lt;span&gt; endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）解码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
errnum =&lt;span&gt; avcodec_send_packet(pCodecCtx, pkt);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    av_strerror(errnum, errbuf, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(errbuf));
    cout &lt;/span&gt;&amp;lt;&amp;lt; errbuf &amp;lt;&amp;lt;&lt;span&gt; endl;
}

AVFrame &lt;/span&gt;*yuv =&lt;span&gt; av_frame_alloc();
AVFrame &lt;/span&gt;*pcm =&lt;span&gt; av_frame_alloc();
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pkt-&amp;gt;stream_index == videoIndex) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断当前解码帧为视频帧&lt;/span&gt;
    errnum = avcodec_receive_frame(pCodecCtx, yuv); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解码视频&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        av_strerror(errnum, errbuf, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(errbuf));
        cout &lt;/span&gt;&amp;lt;&amp;lt; errbuf &amp;lt;&amp;lt;&lt;span&gt; endl;
    }
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pkt-&amp;gt;stream_index == audioIndex) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断当前解码帧为音频帧&lt;/span&gt;
    errnum = avcodec_receive_frame(pCodecCtx, pcm); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解码音频&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (errnum &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        av_strerror(errnum, errbuf, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(errbuf));
        cout &lt;/span&gt;&amp;lt;&amp;lt; errbuf &amp;lt;&amp;lt;&lt;span&gt; endl;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（6）视频转码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 720p输出标准&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; outWidth = &lt;span&gt;720&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; outHeight = &lt;span&gt;480&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *outData = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[outWidth * outHeight * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]

SwsContext &lt;/span&gt;*videoSwsCtx =&lt;span&gt; NULL;
videoSwsCtx &lt;/span&gt;= sws_getCachedContext(videoSwsCtx, srcWidth, srcHeight, (AVPixelFormat)pixFmt, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入&lt;/span&gt;
    outWidth, outHeight, AV_PIX_FMT_BGRA, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出&lt;/span&gt;
    SWS_BICUBIC, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 算法&lt;/span&gt;
    &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分配数据空间&lt;/span&gt;
uint8_t *dstData[AV_NUM_DATA_POINTERS] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
dstData[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = (uint8_t *&lt;span&gt;)outData;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dstStride[AV_NUM_DATA_POINTERS] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
dstStride[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = outWidth * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h = sws_scale(videoSwsCtx, yuv-&amp;gt;data, yuv-&amp;gt;linesize, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, srcHeight, dstData, dstStride);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h !=&lt;span&gt; outHeight) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转码失败&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要解释一下outWidth * outHeight * 4计算理由：720p标准的视频画面包含720 * 480个像素点，每一个像素点包含了RGBA4类数据，每一类数据分别由1个byte即8个bit表示。因此一幅完整画面所占的大小为outWidth * outHeight * 4。&lt;/p&gt;
&lt;p&gt;（7）音频转码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt; *outData = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;]; 输出指针

AVCodecContext &lt;/span&gt;*pCodecCtx = pFormatCtx-&amp;gt;streams[audioIndex]-&amp;gt;codec; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取音频解码器上下文&lt;/span&gt;
SwrContext *audioSwrCtx =&lt;span&gt; NULL;
audioSwrCtx &lt;/span&gt;=&lt;span&gt; swr_alloc();
audioSwrCtx &lt;/span&gt;=&lt;span&gt; swr_alloc_set_opts(audioSwrCtx,
    AV_CH_LAYOUT_STEREO, AV_SAMPLE_FMT_S16, &lt;/span&gt;&lt;span&gt;44100&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出参数：双通道立体声 CD音质&lt;/span&gt;
    pCodecCtx-&amp;gt;channel_layout, pCodecCtx-&amp;gt;sample_fmt, pCodecCtx-&amp;gt;sample_rate, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入参数&lt;/span&gt;
    &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
swr_init(audioSwrCtx);

uint8_t &lt;/span&gt;*&lt;span&gt;out&lt;/span&gt;[AV_NUM_DATA_POINTERS] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;] = (uint8_t *&lt;span&gt;)outData;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算输出空间&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; dst_nb_samples = av_rescale_rnd(pcm-&amp;gt;nb_samples, pCodecCtx-&amp;gt;sample_rate, pCodecCtx-&amp;gt;&lt;span&gt;sample_rate, AV_ROUND_UP);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; swr_convert(audioSwrCtx,
    &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;, dst_nb_samples,
    (&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; uint8_t **)pcm-&amp;gt;data, pcm-&amp;gt;&lt;span&gt;nb_samples);
    
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; channels = av_get_channel_layout_nb_channels(AV_CH_LAYOUT_STEREO); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; AV_CH_LAYOUT_STEREO -&amp;gt; 2 根据声道类型得到声道数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际音频数据长度&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; dst_bufsize =&lt;span&gt; av_samples_get_buffer_size(NULL,
    channels, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通道数&lt;/span&gt;
    pcm-&amp;gt;nb_samples,&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1024&lt;/span&gt;
&lt;span&gt;    AV_SAMPLE_FMT_S16,
    &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dst_bufsize &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 音频转码错误&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此我们已经基本完成了对一个多媒体文件的解码工作，不过离真正的播放还有一些工作没有完成。包括对代码的封装和界面设计我们都会放在下一篇博客中介绍。&lt;/p&gt;
&lt;p&gt;完整的项目代码：https://gitee.com/learnhow/ffmpeg_studio/tree/master/_64bit/src/av_player&lt;/p&gt;
</description>
<pubDate>Sat, 28 Apr 2018 16:59:00 +0000</pubDate>
<dc:creator>冷豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learnhow/p/8970019.html</dc:identifier>
</item>
<item>
<title>条件语句，while循环语句：完整的温度转换程序 - 李灏维</title>
<link>http://www.cnblogs.com/haov/p/8970058.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haov/p/8970058.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    a &lt;/span&gt;= int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;摄氏温度换为华氏温度请按 1\n华氏温度转为摄氏温度请按 2\n退出请按 3\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; a==1&lt;span&gt;:
        c &lt;/span&gt;= float(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入摄氏温度:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
        f &lt;/span&gt;= (c)*9/5+32
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;摄氏{:.2f}温度转为华氏温度是{:.2f}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(c,f))
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; a==2&lt;span&gt;:
        f &lt;/span&gt;= float(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入华氏温度:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
        c &lt;/span&gt;= 5/9*(float(f)-32&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;华氏{:.2f}温度转为摄氏温度是{:.2f}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(f,c))
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1386463/201804/1386463-20180428235857555-1959427918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Apr 2018 15:59:00 +0000</pubDate>
<dc:creator>李灏维</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haov/p/8970058.html</dc:identifier>
</item>
<item>
<title>Oracle知识梳理（一）理论篇：基本概念和术语整理 - 糖拌西红柿</title>
<link>http://www.cnblogs.com/TheGCC/p/8916573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TheGCC/p/8916573.html</guid>
<description>&lt;p&gt;一、关系数据库&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;         &lt;/span&gt; &lt;/strong&gt;&lt;span&gt;关系数据库是目前应用最为广泛的数据库系统，它采用关系数据模型作为数据的组织方式，关系数据模型由&lt;span&gt;关系的数据结构&lt;/span&gt;，&lt;span&gt;关系的操作集合&lt;/span&gt;和&lt;span&gt;关系的完整性约束&lt;/span&gt;三部分组成。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;二、关系数据库中的一些基本术语和定义&lt;/p&gt;

&lt;p&gt;1、关系数据模型  &lt;/p&gt;

&lt;p&gt;关系数据模型是建立在严格的数学概念的基础上，由一组关系组成，每个关系的数据结构是一张严格规范化的二维表，简单说关系数据模型就是用二维表的形式来表示实体和实体间联系的数据模型。&lt;/p&gt;

&lt;p&gt; ①&lt;span&gt;&lt;strong&gt;二维表&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;简单说关系数据库中数据的主要存储形式是二维表，这种二维表具有严格的规则要求，表中每一列代表着关系数据库中的一个属性，每一列的名字就是一个属性名；每一行代表一个记录，即对应现实中的一个物理实体。其中，列称为属性或者字段，行被称为元组或者记录。&lt;/p&gt;
&lt;table border=&quot;3&quot;&gt;&lt;caption&gt;例：用户表&lt;/caption&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;用户编号&lt;/td&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;td&gt;密码&lt;/td&gt;
&lt;td&gt;性别&lt;/td&gt;
&lt;td&gt;年龄&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;001&lt;/td&gt;
&lt;td&gt;url123&lt;/td&gt;
&lt;td&gt;12345789&lt;/td&gt;
&lt;td&gt;男&lt;/td&gt;
&lt;td&gt;34&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;002&lt;/td&gt;
&lt;td&gt;adm336&lt;/td&gt;
&lt;td&gt;abcdefg&lt;/td&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;②&lt;span&gt;&lt;strong&gt;关系&lt;/strong&gt;&lt;/span&gt;：一般说某个关系，即是指某张表。一个关系对应一张表。&lt;/p&gt;
&lt;p&gt;③&lt;strong&gt;&lt;span&gt;元组&lt;/span&gt;&lt;/strong&gt;：表中的某一行成为一个元组，一行即对应一个物理实体，元组就是物理实体的抽象。&lt;/p&gt;
&lt;p&gt;④&lt;strong&gt;&lt;span&gt;属性&lt;/span&gt;&lt;/strong&gt;：表中的一列即为一个属性，给每一列的命名即为属性名：如例表中的 用户名一列。&lt;/p&gt;
&lt;p&gt;⑤&lt;strong&gt;&lt;span&gt;域&lt;/span&gt;&lt;/strong&gt;：即是指某一个属性的取值范围，属性的取值范围成为该属性的域，如：性别的取值为男/女；用户编号的域为一个三位数的整数。&lt;/p&gt;
&lt;p&gt;⑥&lt;span&gt;&lt;strong&gt;关键字或者码（key）&lt;/strong&gt;&lt;/span&gt;：也称作码键，表中的某个属性组（多个属性组成，也可以为单个属性构成），它可以唯一确定一个元组，例表中用户编号可以唯一确定一个用户（即整个表中不存在与这行数据相同的另一行），关系数据库中通常称为主码或者主键。有时也会遇到不止一个属性能唯一确定一个元组的时候，所有可以唯一确定一个元组的属性统称为候选码，而主码是在候选码中选出，候选码包含主码。&lt;/p&gt;
&lt;p&gt;⑦&lt;span&gt;&lt;strong&gt;分量&lt;/strong&gt;&lt;/span&gt;：元组中某一个属性的属性值&lt;/p&gt;
&lt;p&gt;⑧&lt;span&gt;&lt;strong&gt;关系模式&lt;/strong&gt;&lt;/span&gt;：              一般的具体书面表示时，一个关系模式的表示形式为  ： 关系名（属性1，属性2，属性3……），简记为：R（U）或者R（A1，A2，A3……）&lt;/p&gt;
&lt;p&gt;       R（U，D, dom ,F）,R为关系名（表名），U是组成该关系的属性集合，D为属性的域，dom为属性向域的映像的集合。&lt;/p&gt;
&lt;table border=&quot;3&quot;&gt;&lt;caption&gt;术语对比&lt;/caption&gt;
&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;关系术语&lt;/td&gt;
&lt;td&gt;表格称谓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;关系名&lt;/td&gt;
&lt;td&gt;表格名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;关系&lt;/td&gt;
&lt;td&gt;二维表（具体的一张）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;元组&lt;/td&gt;
&lt;td&gt;一条记录/表中的一行&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;表中的列&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;属性名&lt;/td&gt;
&lt;td&gt;列名&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;属性值&lt;/td&gt;
&lt;td&gt;列中的取值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;分量&lt;/td&gt;
&lt;td&gt;一行中某个列的列值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;非规范关系&lt;/td&gt;
&lt;td&gt;表中表（表的嵌套）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;2、关系数据模型的特点&lt;/p&gt;
&lt;p&gt;①关系必须规范化：关系模式中每个关系都必须满足一定的要求。&lt;/p&gt;
&lt;p&gt;②模型概念单一：关系数据模型的优点就是模型概念单一，无论具体的实体还是实体间的联系，都用简单的二维表来描述和表示，对数据的检索和操作结果也是关系（表），其数据结构简单清晰，便于理解  和操作。&lt;/p&gt;
&lt;p&gt; ③操作集合：在关系数据模式中，操作的对象和结果都是元组的集合，即关系（表）&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关系数据模式建立在严格的数学概念基础上，其数据模型的概念单一（即表）。关系数据模型的存取路径对用户透明，从而具有更高的数据独立性、更好的安全保密性，简化了专业人士的开发建立工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、关系操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关系操作的对象和结果都是集合，称为一次一集合的方式，而非关系数据模型的一次一记录数据操作方式。关系数据库中常用的数据操作包括：  &lt;strong&gt;&lt;span&gt;查询操作（Query）和插入操作（Insert）、删除操作（Delete）、修改操作&lt;/span&gt;&lt;/strong&gt;两大部分。具体见下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368510/201804/1368510-20180428215009575-643585940.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;以上关系操作均为逻辑理论操作，在实际的数据库系统中，为了实现这些关系操作，我们可以使用一种关系代数和关系演算之间的语言&lt;strong&gt;SQL（结构化查询语言）&lt;/strong&gt;,SQL具有丰富的查询、数据定义、数据控制功能。Oracle中主要使用SQL*plus。&lt;/p&gt;
&lt;p&gt;4、关系的完整性&lt;/p&gt;
&lt;p&gt;①&lt;span&gt;&lt;strong&gt;实体完整性&lt;/strong&gt;&lt;/span&gt;：若属性（一个或者一组）A为关系B的主属性，则A不能为空。简单的解释就是，一个表中的主键不能为空值，这里的主键包括单一属性的主键非空，和组合主键的属性组中属性均不能为空。&lt;/p&gt;
&lt;p&gt;实体完整性是针对基本关系的，即一个表中的元组对应现实中的物理实体，而现实中的物理实体是可区分的，每个都是独立唯一的。而主键（主属性）则作为整个唯一的标识，主键为空，则表示存在不可标识的实体，这与理论矛盾，所以主键不能为空。&lt;/p&gt;
&lt;p&gt;②&lt;span&gt;&lt;strong&gt;参照完整性&lt;/strong&gt;&lt;/span&gt;：若属性（或属性组）F是基本关系R的外键，它与基本关系S的主键K相对应（即关系R引用关系S的主键为外键，其中S和R不一定是不同关系），则对于R中每个元组在F上的值必须为如下两种情况之一：空值（F中所有属性为空），等于S中某元组的主键。&lt;/p&gt;
&lt;p&gt;外键：现实世界中，实体之间往往存在着某种联系，这些联系在关系数据库中都用关系来描述，这就存在着关系与关系间的引用：如果F是基本关系R的一个或一组属性，但不是R关系的主键，而K是基本关系S的主键，如果F与K相对应，则称F是R的外键（Foreign Key），并称基本关系R为参照关系（Referencing Relation）,基本关系S被称为被参照关系或目标关系。&lt;/p&gt;
&lt;table border=&quot;3&quot;&gt;&lt;caption&gt;关系S&lt;/caption&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;用户名（主键）&lt;/td&gt;
&lt;td&gt;密码&lt;/td&gt;
&lt;td&gt;年龄&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GMM123&lt;/td&gt;
&lt;td&gt;123456&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SST789&lt;/td&gt;
&lt;td&gt;admin22&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;table border=&quot;3&quot;&gt;&lt;caption&gt;关系R&lt;/caption&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Id(主键)&lt;/td&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;td&gt;职务&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;001&lt;/td&gt;
&lt;td&gt;GMM123&lt;/td&gt;
&lt;td&gt;老师&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;002&lt;/td&gt;
&lt;td&gt;SST789&lt;/td&gt;
&lt;td&gt;老师&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;例如上面两表，关系S中的用户名为关系S的主键，与R中的用户名属性对应，则用户名为关系R的外键。&lt;/p&gt;
&lt;p&gt;③&lt;strong&gt;用户自定义完整性&lt;/strong&gt;：实体完整性和参照完整性是任何关系数据库都必须遵守的，除此以外，根据具体不同的情况和问题，往往需要一些额外的约束条件，具体为用户在定义关系时自己定义的。&lt;/p&gt;
&lt;p&gt;5、关系数据库中的规范化理论&lt;/p&gt;
&lt;p&gt;函数依赖：   设R（U）是属性集合U上的一个关系模式，X，Y是U的子集，若对于R（U）的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等而在Y上的属性值不等，则称X函数确定Y或者Y依 赖于X，记作X→Y。&lt;/p&gt;
&lt;p&gt;函数依赖的分类：&lt;/p&gt;
&lt;p&gt;平凡函数依赖与非平凡函数依赖&lt;/p&gt;
&lt;p&gt;完全函数依赖与部分函数依赖&lt;/p&gt;
&lt;p&gt;传递函数依赖&lt;/p&gt;
&lt;p&gt;范式理论：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; ①第一范式（1NF）：如果关系模式R中每一个属性值都是一个不可分解的数据项，则称该关系模式满足第一范式，记为R∈1NF。（不可分割意思为单一属性，属性值必须为“原子”的）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; ②第二范式（2NF）：在满足第一范式的前提下（即R∈1NF），且它的所有非主属性都完全函数依赖与R的任一候选键，则称该关系满足第二范式，即R∈2NF。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; ③第三范式（3NF）：在满足R∈2NF的前提下，且所有非主属性，都不传递函数依赖于任何候选键，则R满足第三范式，即R∈3NF。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; ④BCNF范式（BCNF）：对于一个关系模式R，如果对于每一个函数依赖X→Y，其中的决定因素X都含有键，则称关系模式R满足BCNF范式，即R∈BCNF。&lt;/strong&gt;&lt;/span&gt;     &lt;/p&gt;
&lt;p&gt; 通常认为BC范式是对第三范式的修正和扩展，BCNF的本质意义在于：其中每一个决定因素都是一个主键。或者说，在BCNF中除了候选键决定其所有属性或主键决定其所有属性之外，绝不会存在其他的非平凡函数依赖。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;范式在数据库的设计中占有很大的比重，通过它可以优化数据库设计，避免一些问题，例如：减少数据的冗余，改进数据库整体组织，增强数据的一致性，增加数据库设计的灵活性。因此在数据库设计时，应根据实际情况，使关系模式满足适当的范式，使数据库设计更加规范&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;三、数据库设计&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1、实体 - 关系模型（E - R）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       实际具体设计中，我们需要将现实生活中的实际物体进行抽象化，转变成数学模型，进而转化为关系模型。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;①实体（Entity）：是E—R模型的基本对象，是现实世界中各种事务的抽象。简单点说就是对应着现实生活中确实存在的事务，例如：张三、李四具体的某个人，也可以是学生这个现实中的群体。&lt;/p&gt;
&lt;p&gt;②属性（Attribute）：实体的若干特征，即为实体的属性。例如，现实生活中学生会有学号这个特征，转化为关系中的学号属性。&lt;/p&gt;
&lt;p&gt;③联系（Relationship): 实体之间会存在各种各样的关系与联系，例如老师和学生存在师生关系，一个语文老师可能是一个班所有学生的共同语文老师，而对于具体某个学生而言，他们只有一个语文老师，即一对多，和一对一。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一对一联系（1：1）：对于实体集A和B来说，A中任意一个实体a，B中至多有一个实体b与之联系，反过来也是如此，则A与B就是一对一联系。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一对多联系（1：N）：在实体集A中每一个实体a，B中有N个实体与之联系，对于实体集B中的每一个实体b，实体集A中至多有一个实体a与之联系，则A与B为一对多联系。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;多对多联系（M：N）：如果对于实体集A中每一个实体a，B中有N个实体与之对应，而且对于B中每个实体b，A中有M个实体与之对应，则A和B是多对多联系。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、E—R图绘制&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368510/201804/1368510-20180428230237080-1894454786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Sat, 28 Apr 2018 15:24:00 +0000</pubDate>
<dc:creator>糖拌西红柿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TheGCC/p/8916573.html</dc:identifier>
</item>
<item>
<title>Page Object设计模式实践 - 菜鸟可米</title>
<link>http://www.cnblogs.com/cnkemi/p/8969977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnkemi/p/8969977.html</guid>
<description>&lt;p&gt;　　&lt;strong&gt;Page Object&lt;/strong&gt;模式是使用Selenium的广大同行最为公认的一种设计模式。在设计测试时，把元素和方法按照页面抽象出来，分离成一定的对象，然后再进行组织。&lt;/p&gt;
&lt;p&gt;　　Page Object模式，创建一个对象来对应页面的一个应用。故我们可以为每个页面定义一个类，并为每个页面的属性和操作构建模型。体现在对界面交互细节的封装，测试在更上层使用页面对象，在底层的属性或者操作的更改不会中断测试。减少代码重复，提高测试代码的可读性和可维护性。&lt;/p&gt;
&lt;p&gt;　　下面将以登录qq邮箱为例，通过Page Object设计模式来实现。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.by &lt;span&gt;import&lt;/span&gt;&lt;span&gt; By
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sleep

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建基础类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BasePage(object):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, driver):
        self.base_url &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://mail.qq.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        self.driver &lt;/span&gt;=&lt;span&gt; driver
        self.timeout &lt;/span&gt;= 30

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打开页面&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; _open(self):
        url &lt;/span&gt;=&lt;span&gt; self.base_url
        self.driver.get(url)
        self.driver.switch_to.frame(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;login_frame&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;切换到登录窗口的iframe&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; open(self):
        self._open()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定位方法封装&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; find_element(self,*&lt;span&gt;loc):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.driver.find_element(*&lt;span&gt;loc)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建LoginPage类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoginPage(BasePage):
    username_loc &lt;/span&gt;= (By.ID, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    password_loc &lt;/span&gt;= (By.ID, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    login_loc &lt;/span&gt;= (By.ID, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login_button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入用户名&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; type_username(self,username):
        self.find_element(&lt;/span&gt;*&lt;span&gt;self.username_loc).clear()
        self.find_element(&lt;/span&gt;*&lt;span&gt;self.username_loc).send_keys(username)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入密码&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; type_password(self,password):
        self.find_element(&lt;/span&gt;*&lt;span&gt;self.password_loc).send_keys(password)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;点击登录&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; type_login(self):
        self.find_element(&lt;/span&gt;*&lt;span&gt;self.login_loc).click()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建test_user_login()函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_user_login(driver, username, password):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;测试用户名/密码是否可以登录&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    login_page &lt;/span&gt;=&lt;span&gt; LoginPage(driver)
    login_page.open()
    login_page.type_username(username)
    login_page.type_password(password)
    login_page.type_login()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建main()函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    driver &lt;/span&gt;=&lt;span&gt; webdriver.Edge()
    username &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3494xxxxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;qq号码&lt;/span&gt;
    password = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kemixxxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;qq密码&lt;/span&gt;
&lt;span&gt;    test_user_login(driver, username, password)
    sleep(&lt;/span&gt;3&lt;span&gt;)

    driver.quit()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　虽然该实现方法看上去复杂多了，但其中的设计好处是不同层关心不同的问题。页面对象只关心元素的定位，测试用例只关心测试数据。&lt;/p&gt;
</description>
<pubDate>Sat, 28 Apr 2018 15:17:00 +0000</pubDate>
<dc:creator>菜鸟可米</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cnkemi/p/8969977.html</dc:identifier>
</item>
<item>
<title>Spark Streaming - SCLi</title>
<link>http://www.cnblogs.com/scls/p/8969971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/scls/p/8969971.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;Spark Streaming&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1、课程目标&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;1、掌握sparkStreaming底层原理和架构&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;2、掌握DStream的原理&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;3、掌握sparkStreaming与flume整合&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;4、掌握sparkStreaming与kafka整合&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;2、sparkStreaming&lt;/span&gt;&lt;/h3&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3、sparkStreaming特性&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;1、易用性&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;2、容错性&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;3、融合spark体系&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;4、sparkStreaming原理&lt;/span&gt;&lt;/h3&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;5、Dstream&lt;/span&gt;&lt;/h3&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;6、Dstream操作&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;transformation&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;outputOperations&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;7、DStream操作实战&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;需要引入对应的jar包&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;span&gt;      &lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.spark&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spark-streaming_2.&lt;span&gt;11&lt;/span&gt;&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;2.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cn.itcast.stream
​
import org.apache.spark.{SparkConf, SparkContext}
import org.apache.spark.streaming.{Seconds, StreamingContext}
import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream}
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo:利用sparkStreaming接受socket数据，实现单词计数&lt;/span&gt;
&lt;span&gt;object&lt;/span&gt;&lt;span&gt; SparkStreamingSocket {
  def main(args: Array[String]): Unit &lt;/span&gt;=&lt;span&gt; {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、创建sparkConf   设置master的地址local[N] ,n必须大于1，其中1个线程负责去接受数据，另一线程负责处理接受到的数据&lt;/span&gt;
      val sparkConf: SparkConf = &lt;span&gt;new&lt;/span&gt; SparkConf().setAppName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SparkStreamingSocket&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).setMaster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local[2]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、创建sparkContext&lt;/span&gt;
      val sc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SparkContext(sparkConf)
      sc.setLogLevel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WARN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、创建streamingContext,需要sparkContext和以多久时间间隔为一个批次&lt;/span&gt;
     val ssc = &lt;span&gt;new&lt;/span&gt; StreamingContext(sc,Seconds(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、通过streaming接受socket数据&lt;/span&gt;
      val stream: ReceiverInputDStream[String] = ssc.socketTextStream(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.200.100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;9999&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、切分每一行&lt;/span&gt;
      val words: DStream[String] = stream.flatMap(_.split(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6、每个单词记为1&lt;/span&gt;
      val wordAndOne: DStream[(String, Int)] = words.map((_,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7、相同单词出现的次数累加&lt;/span&gt;
      val result: DStream[(String, Int)] = wordAndOne.reduceByKey(_+&lt;span&gt;_)
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8、打印&lt;/span&gt;
&lt;span&gt;      result.print()
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9、开启流式计算&lt;/span&gt;
&lt;span&gt;      ssc.start()
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一直会阻塞，等待退出&lt;/span&gt;
&lt;span&gt;      ssc.awaitTermination()
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cn.itcast.stream
​
import org.apache.spark.{SparkConf, SparkContext}
import org.apache.spark.streaming.{Seconds, StreamingContext}
import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream}
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo:利用sparkStreaming接受socket数据，实现所有批次单词计数结果累加&lt;/span&gt;
&lt;span&gt;object&lt;/span&gt;&lt;span&gt; SparkStreamingSocketTotal {
​
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个方法
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;currentValues:他表示在当前批次每个单词出现的所有的1   (hadoop,1) (hadoop,1)(hadoop,1)
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;historyValues:他表示在之前所有批次中每个单词出现的总次数   (hadoop,100)&lt;/span&gt;
  def updateFunc(currentValues:Seq[Int], historyValues:Option[Int]):Option[Int] =&lt;span&gt; {
          val newValue: Int &lt;/span&gt;= currentValues.sum+historyValues.getOrElse(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
          Some(newValue)
  }
​
  def main(args: Array[String]): Unit &lt;/span&gt;=&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、创建sparkConf&lt;/span&gt;
      val sparkConf: SparkConf = &lt;span&gt;new&lt;/span&gt; SparkConf().setAppName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SparkStreamingSocketTotal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).setMaster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local[2]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、创建sparkContext&lt;/span&gt;
      val sc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SparkContext(sparkConf)
      sc.setLogLevel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WARN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、创建streamingContext&lt;/span&gt;
      val ssc = &lt;span&gt;new&lt;/span&gt; StreamingContext(sc,Seconds(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;))
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置checkpoint目录&lt;/span&gt;
      ssc.checkpoint(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./ck&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、接受socket数据&lt;/span&gt;
      val stream: ReceiverInputDStream[String] = ssc.socketTextStream(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.200.100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;9999&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、切分每一行&lt;/span&gt;
      val words: DStream[String] = stream.flatMap(_.split(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6、把每一个单词计为1&lt;/span&gt;
      val wordAndOne: DStream[(String, Int)] = words.map((_,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7、相同单词出现的次数累加&lt;/span&gt;
      val result: DStream[(String, Int)] =&lt;span&gt; wordAndOne.updateStateByKey(updateFunc)
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8、打印结果数据&lt;/span&gt;
&lt;span&gt;      result.print()
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9、开启流式计算&lt;/span&gt;
&lt;span&gt;      ssc.start()
      ssc.awaitTermination()
    }
}
​&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cn.itcast.stream
​
import org.apache.spark.{SparkConf, SparkContext}
import org.apache.spark.streaming.{Seconds, StreamingContext}
import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream}
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo:利用sparkStreaming开窗函数 reducebyKeyAndWindow实现单词计数&lt;/span&gt;
&lt;span&gt;object&lt;/span&gt;&lt;span&gt; SparkStreamingSocketWindow {
​
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个方法
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;currentValues:他表示在当前批次每个单词出现的所有的1   (hadoop,1) (hadoop,1)(hadoop,1)
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;historyValues:他表示在之前所有批次中每个单词出现的总次数   (hadoop,100)&lt;/span&gt;
  def updateFunc(currentValues:Seq[Int], historyValues:Option[Int]):Option[Int] =&lt;span&gt; {
    val newValue: Int &lt;/span&gt;= currentValues.sum+historyValues.getOrElse(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    Some(newValue)
  }
​
  def main(args: Array[String]): Unit &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、创建sparkConf&lt;/span&gt;
    val sparkConf: SparkConf = &lt;span&gt;new&lt;/span&gt; SparkConf().setAppName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SparkStreamingSocketWindow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).setMaster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local[2]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、创建sparkContext&lt;/span&gt;
    val sc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SparkContext(sparkConf)
    sc.setLogLevel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WARN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、创建streamingContext&lt;/span&gt;
    val ssc = &lt;span&gt;new&lt;/span&gt; StreamingContext(sc,Seconds(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置checkpoint目录&lt;/span&gt;
    ssc.checkpoint(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./ck&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、接受socket数据&lt;/span&gt;
    val stream: ReceiverInputDStream[String] = ssc.socketTextStream(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.200.100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;9999&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、切分每一行&lt;/span&gt;
    val words: DStream[String] = stream.flatMap(_.split(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6、把每一个单词计为1&lt;/span&gt;
    val wordAndOne: DStream[(String, Int)] = words.map((_,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7、相同单词出现的次数累加
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;reduceByKeyAndWindow该方法需要三个参数
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;reduceFunc：需要一个函数
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;windowDuration:表示窗口的长度
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;slideDuration:表示窗口滑动时间间隔，即每隔多久计算一次&lt;/span&gt;
    val result: DStream[(String, Int)] = wordAndOne.reduceByKeyAndWindow((x:Int,y:Int)=&amp;gt;x+y,Seconds(&lt;span&gt;5&lt;/span&gt;),Seconds(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;))
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8、打印结果数据&lt;/span&gt;
&lt;span&gt;    result.print()
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9、开启流式计算&lt;/span&gt;
&lt;span&gt;    ssc.start()
    ssc.awaitTermination()
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;* 4.SparkStreaming开窗函数统计一定时间内的热门词汇&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cn.itcast.stream

import org.apache.spark.{SparkConf, SparkContext}import org.apache.spark.rdd.RDDimport org.apache.spark.streaming.{Seconds, StreamingContext}import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo:利用sparkStreaming开窗函数统计单位时间内热门词汇----出现频率比较高的词汇object SparkStreamingSocketWindowHotWords { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个方法 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;currentValues:他表示在当前批次每个单词出现的所有的1 (hadoop,1) (hadoop,1)(hadoop,1) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;historyValues:他表示在之前所有批次中每个单词出现的总次数 (hadoop,100) def updateFunc(currentValues:Seq[Int], historyValues:Option[Int]):Option[Int] = {&lt;/span&gt;
&lt;span&gt;

val newValue: Int &lt;/span&gt;= currentValues.sum+historyValues.getOrElse(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
Some(newValue)
}

def main(args: Array[String]): Unit &lt;/span&gt;=&lt;span&gt; {


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、创建sparkConf&lt;/span&gt;
val sparkConf: SparkConf = &lt;span&gt;new&lt;/span&gt; SparkConf().setAppName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SparkStreamingSocketWindowHotWords&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).setMaster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local[2]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、创建sparkContext&lt;/span&gt;
val sc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SparkContext(sparkConf)
sc.setLogLevel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WARN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、创建streamingContext&lt;/span&gt;
val ssc = &lt;span&gt;new&lt;/span&gt; StreamingContext(sc,Seconds(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置checkpoint目录&lt;/span&gt;
ssc.checkpoint(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./ck&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、接受socket数据&lt;/span&gt;
val stream: ReceiverInputDStream[String] = ssc.socketTextStream(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.200.100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;9999&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、切分每一行&lt;/span&gt;
val words: DStream[String] = stream.flatMap(_.split(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6、把每一个单词计为1&lt;/span&gt;
val wordAndOne: DStream[(String, Int)] = words.map((_,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7、相同单词出现的次数累加
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;reduceByKeyAndWindow该方法需要三个参数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;reduceFunc：需要一个函数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;windowDuration:表示窗口的长度
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;slideDuration:表示窗口滑动时间间隔，即每隔多久计算一次&lt;/span&gt;
val result: DStream[(String, Int)] = wordAndOne.reduceByKeyAndWindow((x:Int,y:Int)=&amp;gt;x+y,Seconds(&lt;span&gt;10&lt;/span&gt;),Seconds(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;))
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8、按照单词出现的次数降序排列&lt;/span&gt;
val sortedDstream: DStream[(String, Int)] = result.transform(rdd =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将rdd中数据按照单词出现的次数降序排列&lt;/span&gt;
  val sortedRDD: RDD[(String, Int)] = rdd.sortBy(_._2, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出前3位&lt;/span&gt;
  val sortHotWords: Array[(String, Int)] = sortedRDD.take(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印前3位结果数据&lt;/span&gt;
  sortHotWords.&lt;span&gt;foreach&lt;/span&gt;(x =&amp;gt;&lt;span&gt; println(x))
  sortedRDD
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9、打印排序后的结果数据&lt;/span&gt;
&lt;span&gt;sortedDstream.print()
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10、开启流式计算&lt;/span&gt;
&lt;span&gt;ssc.start()
ssc.awaitTermination()
}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;8、SparkStreaming整合Flume&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Poll方式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      package cn.itcast.dstream.flume
​
      import java.net.InetSocketAddress
​
      import org.apache.spark.{SparkConf, SparkContext}
      import org.apache.spark.storage.StorageLevel
      import org.apache.spark.streaming.{Seconds, StreamingContext}
      import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream}
      import org.apache.spark.streaming.flume.{FlumeUtils, SparkFlumeEvent}
​
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo:利用sparkStreaming对接flume数据，实现单词计算------Poll拉模式&lt;/span&gt;
      &lt;span&gt;object&lt;/span&gt;&lt;span&gt; SparkStreamingFlume_Poll {
        def main(args: Array[String]): Unit &lt;/span&gt;=&lt;span&gt; {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、创建sparkConf&lt;/span&gt;
            val sparkConf: SparkConf = &lt;span&gt;new&lt;/span&gt; SparkConf().setAppName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SparkStreamingFlume_Poll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).setMaster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local[2]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、创建sparkContext&lt;/span&gt;
            val sc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SparkContext(sparkConf)
            sc.setLogLevel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WARN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、创建StreamingContext&lt;/span&gt;
            val ssc = &lt;span&gt;new&lt;/span&gt; StreamingContext(sc,Seconds(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;))
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个flume地址集合，可以同时接受多个flume的数据&lt;/span&gt;
          val address=Seq(&lt;span&gt;new&lt;/span&gt; InetSocketAddress(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.200.100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;9999&lt;/span&gt;),&lt;span&gt;new&lt;/span&gt; InetSocketAddress(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.200.101&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;9999&lt;/span&gt;&lt;span&gt;))
​
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、获取flume中数据&lt;/span&gt;
            val stream: ReceiverInputDStream[SparkFlumeEvent] =&lt;span&gt; FlumeUtils.createPollingStream(ssc,address,StorageLevel.MEMORY_AND_DISK_SER_2)
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、从Dstream中获取flume中的数据  {&quot;header&quot;:xxxxx   &quot;body&quot;:xxxxxx}&lt;/span&gt;
            val lineDstream: DStream[String] = stream.map(x =&amp;gt; &lt;span&gt;new&lt;/span&gt; String(x.&lt;span&gt;event&lt;/span&gt;&lt;span&gt;.getBody.array()))
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6、切分每一行,每个单词计为1&lt;/span&gt;
            val wordAndOne: DStream[(String, Int)] = lineDstream.flatMap(_.split(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;)).map((_,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7、相同单词出现的次数累加&lt;/span&gt;
            val result: DStream[(String, Int)] = wordAndOne.reduceByKey(_+&lt;span&gt;_)
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8、打印输出&lt;/span&gt;
&lt;span&gt;          result.print()
​
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启计算&lt;/span&gt;
&lt;span&gt;            ssc.start()
            ssc.awaitTermination()
​
        }
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;push方式&lt;/span&gt;&lt;/span&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cn.itcast.dstream.flume
​
import org.apache.spark.{SparkConf, SparkContext}
import org.apache.spark.streaming.{Seconds, StreamingContext}
import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream}
import org.apache.spark.streaming.flume.{FlumeUtils, SparkFlumeEvent}
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo:利用sparkStreaming对接flume数据，实现单词计数------Push推模式&lt;/span&gt;
&lt;span&gt;object&lt;/span&gt;&lt;span&gt; SparkStreamingFlume_Push {
​
  def main(args: Array[String]): Unit &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、创建sparkConf&lt;/span&gt;
      val sparkConf: SparkConf = &lt;span&gt;new&lt;/span&gt; SparkConf().setAppName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SparkStreamingFlume_Push&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).setMaster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local[2]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、创建sparkContext&lt;/span&gt;
      val sc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SparkContext(sparkConf)
      sc.setLogLevel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WARN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、创建StreamingContext&lt;/span&gt;
      val ssc = &lt;span&gt;new&lt;/span&gt; StreamingContext(sc,Seconds(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、获取flume中的数据&lt;/span&gt;
    val stream: ReceiverInputDStream[SparkFlumeEvent] = FlumeUtils.createStream(ssc,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.11.123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;9999&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、从Dstream中获取flume中的数据  {&quot;header&quot;:xxxxx   &quot;body&quot;:xxxxxx}&lt;/span&gt;
    val lineDstream: DStream[String] = stream.map(x =&amp;gt; &lt;span&gt;new&lt;/span&gt; String(x.&lt;span&gt;event&lt;/span&gt;&lt;span&gt;.getBody.array()))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6、切分每一行,每个单词计为1&lt;/span&gt;
    val wordAndOne: DStream[(String, Int)] = lineDstream.flatMap(_.split(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;)).map((_,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7、相同单词出现的次数累加&lt;/span&gt;
    val result: DStream[(String, Int)] = wordAndOne.reduceByKey(_+&lt;span&gt;_)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8、打印输出&lt;/span&gt;
&lt;span&gt;    result.print()
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启计算&lt;/span&gt;
&lt;span&gt;    ssc.start()
    ssc.awaitTermination()
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;9、Spark Streaming整合kafka实战&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cn.itcast.kafka
​
import org.apache.spark.{SparkConf, SparkContext}
import org.apache.spark.streaming.{Seconds, StreamingContext}
import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream}
import org.apache.spark.streaming.kafka.KafkaUtils
​
import scala.collection.immutable
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo:sparkStreaming整合kafka---基于receiver（高级api）&lt;/span&gt;
&lt;span&gt;object&lt;/span&gt;&lt;span&gt; SparkStreamingKafkaReceiver {
  def main(args: Array[String]): Unit &lt;/span&gt;=&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、创建sparkConf&lt;/span&gt;
      val sparkConf: SparkConf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SparkConf()
                                  .setAppName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SparkStreamingKafkaReceiver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                                  .setMaster(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local[4]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程数要大于receiver个数&lt;/span&gt;
                                    .&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spark.streaming.receiver.writeAheadLog.enable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                                      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示开启WAL预写日志，保证数据源的可靠性
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、创建sparkContext&lt;/span&gt;
      val sc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SparkContext(sparkConf)
      sc.setLogLevel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WARN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、创建streamingContext&lt;/span&gt;
      val ssc = &lt;span&gt;new&lt;/span&gt; StreamingContext(sc,Seconds(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;))
        ssc.checkpoint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./spark_receiver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、准备zk地址&lt;/span&gt;
      val zkQuorum=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;node1:2181,node2:2181,node3:2181&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、准备groupId&lt;/span&gt;
      val groupId=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spark_receiver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6、定义topic   当前这个value并不是topic对应的分区数，而是针对于每一个分区使用多少个线程去消费&lt;/span&gt;
     val topics=Map(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spark_01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -&amp;gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7、KafkaUtils.createStream 去接受kafka中topic数据
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(String, String) 前面一个string表示topic名称，后面一个string表示topic中的数据
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用多个reveiver接受器去接受kafka中topic数据&lt;/span&gt;
    val dstreamSeq: immutable.IndexedSeq[ReceiverInputDStream[(String, String)]] = (&lt;span&gt;1&lt;/span&gt; to &lt;span&gt;3&lt;/span&gt;).map(x =&amp;gt;&lt;span&gt; {
      val stream: ReceiverInputDStream[(String, String)] &lt;/span&gt;=&lt;span&gt; KafkaUtils.createStream(ssc, zkQuorum, groupId, topics)
      stream
      }
    )
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用streamingcontext调用union,获取得到所有receiver接受器的数据&lt;/span&gt;
    val totalDstream: DStream[(String, String)] =&lt;span&gt; ssc.union(dstreamSeq)
​
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8、获取kafka中topic的数据&lt;/span&gt;
    val topicData: DStream[String] =&lt;span&gt; totalDstream.map(_._2)
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9、切分每一行&lt;/span&gt;
      val wordAndOne: DStream[(String, Int)] = topicData.flatMap(_.split(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;)).map((_,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10、相同单词出现的次数累加&lt;/span&gt;
      val result: DStream[(String, Int)] = wordAndOne.reduceByKey(_+&lt;span&gt;_)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;11、打印结果数据&lt;/span&gt;
&lt;span&gt;      result.print()
​
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;12、开启流式计算&lt;/span&gt;
&lt;span&gt;      ssc.start()
      ssc.awaitTermination()
​
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cn.itcast.kafka
​
import kafka.serializer.StringDecoder
import org.apache.spark.{SparkConf, SparkContext}
import org.apache.spark.streaming.{Seconds, StreamingContext}
import org.apache.spark.streaming.dstream.{DStream, InputDStream}
import org.apache.spark.streaming.kafka.KafkaUtils
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo:sparkSteaming整合kafka----采用direct(低级Api)&lt;/span&gt;
&lt;span&gt;object&lt;/span&gt;&lt;span&gt; SparkStreamingKafkaDirect {
  def main(args: Array[String]): Unit &lt;/span&gt;=&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、创建sparkConf&lt;/span&gt;
      val sparkConf: SparkConf = &lt;span&gt;new&lt;/span&gt; SparkConf().setAppName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SparkStreamingKafkaDirect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).setMaster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local[2]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、创建sparkContext&lt;/span&gt;
      val sc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SparkContext(sparkConf)
      sc.setLogLevel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WARN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、创建streamingcontext&lt;/span&gt;
      val ssc = &lt;span&gt;new&lt;/span&gt; StreamingContext(sc,Seconds(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;))
      ssc.checkpoint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./spark_direct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;它会保存topic的偏移量
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、准备kafka参数&lt;/span&gt;
      val kafkaParams=Map(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metadata.broker.list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;-&amp;gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;node1:9092,node2:9092,node3:9092&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group.id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -&amp;gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spark_direct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、准备topic&lt;/span&gt;
      val topics=Set(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spark_01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6、获取kafka中的数据&lt;/span&gt;
      val dstream: InputDStream[(String, String)] =&lt;span&gt; KafkaUtils.createDirectStream[String,String,StringDecoder,StringDecoder](ssc,kafkaParams,topics)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7、获取topic中的数据&lt;/span&gt;
        val data: DStream[String] =&lt;span&gt; dstream.map(_._2)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8、切分每一行，每个单词计为1，把相同单词出现的次数累加&lt;/span&gt;
        val result: DStream[(String, Int)] = data.flatMap(_.split(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;)).map((_,&lt;span&gt;1&lt;/span&gt;)).reduceByKey(_+&lt;span&gt;_)
​
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9、打印结果数据&lt;/span&gt;
&lt;span&gt;        result.print()
​
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10、开启流式计算&lt;/span&gt;
&lt;span&gt;        ssc.start()
        ssc.awaitTermination()
​
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 28 Apr 2018 15:15:00 +0000</pubDate>
<dc:creator>SCLi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/scls/p/8969971.html</dc:identifier>
</item>
<item>
<title>模仿天猫实战【SSM版】——后台开发 - 我没有三颗心脏</title>
<link>http://www.cnblogs.com/wmyskxz/p/8969842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/8969842.html</guid>
<description>&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;上一篇文章链接：&lt;a href=&quot;https://www.jianshu.com/p/5e44ee046b43&quot;&gt;模仿天猫实战【SSM版】——项目起步&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-3eee3c0023557f8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;后台需求分析&quot;&gt;后台需求分析&lt;/h2&gt;
&lt;p&gt;在开始码代码之前，还是需要先清楚自己要做什么事情，后台具体需要实现哪些功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-ccc3aa2fdf8e00de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt; 订单、用户、订单、推荐链接均不提供增删的功能。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;后台界面设计&quot;&gt;后台界面设计&lt;/h2&gt;
&lt;p&gt;不像前端那样有原型直接照搬就可以了，后台的设计还真的有难到我...毕竟我是一个对美有一定要求的人，一方面想尽量的简洁、简单，另一方面又不想要太难看，那怎么办呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-c27798bcd2932a19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那当然是找模板了，找到一个顺眼的下载下来就开始改，&lt;/p&gt;
&lt;p&gt;这个模板的原地址在这里：&lt;a href=&quot;http://www.cssmoban.com/cssthemes/7381.shtml&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-f1c023b9fdbb91ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顺便安利一下 FireFox ，真是开发神器，配合着修改，棒棒哒：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-16d9367e5b6b201e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;经过一番折腾...&quot;&gt;经过一番折腾...&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-c5f593fb37178a82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;摁，就这风格了，而且我还发现右上角的【Search】框是下载的模板用 js 实现的...对于管理来说更加方便了....而且居然还实现了分页....&lt;/p&gt;
&lt;p&gt;一个邪恶的想法又诞生了...&lt;/p&gt;
&lt;h4 id=&quot;一些规定&quot;&gt;一些规定&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;为了降低项目的难度，我们做了很多的精简，现在我们作出如下的规定：&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;全站没有商家，只有一家 Tmall ，后台没有验证，可以直接进入&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;前台的路径就是默认路径，后台的路径需要加上 “/admin” 后缀，&lt;/strong&gt;如访问后台则为：localhost/admin （&lt;strong&gt;默认为分类管理页&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;管理路径统一为：admin/listXxxxx&lt;/strong&gt;，如分类管理路径为：admin/listCategory，用户管理路径为：admin/listUser，诸如此类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编辑路径统一为：admin/editXxxxx&lt;/strong&gt;，如编辑分类路径为：admin/editCategory，产品编辑页为：admin/editProduct，诸如此类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;删除路径统一为：admin/deleteXxxxx&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新路径统一为：admin/updateXxxxx&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;关于页面路径的一些规定：&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;前端页面统一在【WEB-INF/views】下，后端页面统一在【WEB-INF/views/admin】下&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;分类管理&quot;&gt;分类管理&lt;/h2&gt;
&lt;p&gt;正式开始编写我们的代码，以 Category 为例。&lt;/p&gt;
&lt;h4 id=&quot;编写-service-层&quot;&gt;编写 Service 层&lt;/h4&gt;
&lt;p&gt;我们需要在这一层上考虑需要完成的功能，对应我们上面画的后台功能图，分类管理也就是完成分类的查询还有修改的工作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.wmyskxz.service;

import cn.wmyskxz.pojo.Category;

import java.util.List;

public interface CategoryService {

    /**
     * 返回分类列表
     * @return
     */
    List&amp;lt;Category&amp;gt; list();

    /**
     * 通过id获取对应的数据
     * @param id
     * @return
     */
    Category get(Integer id);

    /**
     * 更新分类
     * @param category
     * @return
     */
    void update(Category category);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;编写 CategoryServiceImpl ：&lt;br/&gt;在同一包下编写实现类&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;package cn.wmyskxz.service;

import cn.wmyskxz.mapper.CategoryMapper;
import cn.wmyskxz.pojo.Category;
import cn.wmyskxz.pojo.CategoryExample;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * CategoryService 的实现类
 *
 * @author: @我没有三颗心脏
 * @create: 2018-04-27-下午 16:35
 */
@Service
public class CategoryServiceImpl implements CategoryService {

    @Autowired
    CategoryMapper categoryMapper;

    public List&amp;lt;Category&amp;gt; list() {
        CategoryExample example = new CategoryExample();
        List&amp;lt;Category&amp;gt; categories = categoryMapper.selectByExample(example);
        return categories;
    }

    public Category get(Integer id) {
        return categoryMapper.selectByPrimaryKey(id);
    }

    public void update(Category category) {
        categoryMapper.updateByPrimaryKey(category);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;编写-categorycontroller&quot;&gt;编写 CategoryController&lt;/h4&gt;
&lt;p&gt;根据业务需求可以很容易的编写出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.wmyskxz.controller;

import cn.wmyskxz.pojo.Category;
import cn.wmyskxz.service.CategoryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.List;

/**
 * Category 的控制类
 *
 * @author: @我没有三颗心脏
 * @create: 2018-04-27-下午 16:37
 */
@Controller
@RequestMapping(&quot;/admin&quot;)
public class CategoryController {

    @Autowired
    CategoryService categoryService;

    @RequestMapping(&quot;/listCategory&quot;)
    public String list(Model model) {
        List&amp;lt;Category&amp;gt; categories = categoryService.list();
        model.addAttribute(&quot;categories&quot;, categories);
        return &quot;admin/listCategory&quot;;
    }

    @RequestMapping(&quot;/editCategory&quot;)
    public String edit(Category category,Model model) {
        model.addAttribute(&quot;category&quot;, category);
        return &quot;admin/editCategory&quot;;
    }

    @RequestMapping(&quot;/updateCategory&quot;)
    public String update(Category category) {
        categoryService.update(category);
        return &quot;redirect:listCategory&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;jsp-相关文件编写&quot;&gt;JSP 相关文件编写&lt;/h4&gt;
&lt;p&gt;自己研究了一会儿这个模板，感觉还是挺好改的，然后就给改成了大概以下这个样子（&lt;em&gt;自己在数据库中加入了 16 条数据&lt;/em&gt;）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分类管理页&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-4a983d7478357872.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分类编辑页&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-16014296cfec5ea8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模板下载下来之后文件目录是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-971cc1225aa97f5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们直接整个拷贝【assets】文件夹放在【webapp】目录下，然后根据模板里面的代码就可以开始修改了，修改下来的两个文件源码如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;listCategory.jsp&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
         pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot; %&amp;gt;
&amp;lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt;
    &amp;lt;title&amp;gt;模仿天猫-后台&amp;lt;/title&amp;gt;
    &amp;lt;!-- Bootstrap Styles--&amp;gt;
    &amp;lt;link href=&quot;../assets/css/bootstrap.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;
    &amp;lt;!-- FontAwesome Styles--&amp;gt;
    &amp;lt;link href=&quot;../assets/css/font-awesome.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;
    &amp;lt;!-- Morris Chart Styles--&amp;gt;

    &amp;lt;!-- Custom Styles--&amp;gt;
    &amp;lt;link href=&quot;../assets/css/custom-styles.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;
    &amp;lt;!-- Google Fonts--&amp;gt;
    &amp;lt;link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css' /&amp;gt;
    &amp;lt;!-- TABLE STYLES--&amp;gt;
    &amp;lt;link href=&quot;../assets/js/dataTables/dataTables.bootstrap.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;wrapper&quot;&amp;gt;
    &amp;lt;nav class=&quot;navbar navbar-default top-navbar&quot; role=&quot;navigation&quot;&amp;gt;
        &amp;lt;div class=&quot;navbar-header&quot;&amp;gt;
            &amp;lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.sidebar-collapse&quot;&amp;gt;
                &amp;lt;span class=&quot;sr-only&quot;&amp;gt;Toggle navigation&amp;lt;/span&amp;gt;
                &amp;lt;span class=&quot;icon-bar&quot;&amp;gt;&amp;lt;/span&amp;gt;
                &amp;lt;span class=&quot;icon-bar&quot;&amp;gt;&amp;lt;/span&amp;gt;
                &amp;lt;span class=&quot;icon-bar&quot;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/button&amp;gt;
            &amp;lt;a class=&quot;navbar-brand&quot; href=&quot;listCategory&quot;&amp;gt;Tmall&amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/nav&amp;gt;

    &amp;lt;!--/. NAV TOP  --&amp;gt;
    &amp;lt;nav class=&quot;navbar-default navbar-side&quot; role=&quot;navigation&quot;&amp;gt;
        &amp;lt;div class=&quot;sidebar-collapse&quot;&amp;gt;
            &amp;lt;ul class=&quot;nav&quot; id=&quot;main-menu&quot;&amp;gt;

                &amp;lt;li&amp;gt;
                    &amp;lt;a class=&quot;active-menu&quot; href=&quot;listCategory&quot;&amp;gt;&amp;lt;i class=&quot;fa fa-bars&quot;&amp;gt;&amp;lt;/i&amp;gt; 分类管理&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;listUser&quot;&amp;gt;&amp;lt;i class=&quot;fa fa-user&quot;&amp;gt;&amp;lt;/i&amp;gt; 用户管理&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;listOrder&quot;&amp;gt;&amp;lt;i class=&quot;fa fa-list-alt&quot;&amp;gt;&amp;lt;/i&amp;gt; 订单管理&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;listProduct&quot;&amp;gt;&amp;lt;i class=&quot;fa fa-th-list&quot;&amp;gt;&amp;lt;/i&amp;gt; 产品管理&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;listLink&quot;&amp;gt;&amp;lt;i class=&quot;fa fa-link&quot;&amp;gt;&amp;lt;/i&amp;gt; 推荐链接管理&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/div&amp;gt;

    &amp;lt;/nav&amp;gt;
    &amp;lt;!-- /. NAV SIDE  --&amp;gt;
    &amp;lt;div id=&quot;page-wrapper&quot;&amp;gt;
        &amp;lt;div id=&quot;page-inner&quot;&amp;gt;
            &amp;lt;div class=&quot;row&quot;&amp;gt;
                &amp;lt;div class=&quot;col-md-12&quot;&amp;gt;
                    &amp;lt;h1 class=&quot;page-header&quot;&amp;gt;
                        分类管理
                        &amp;lt;small&amp;gt;&amp;lt;/small&amp;gt;
                    &amp;lt;/h1&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;

            &amp;lt;div class=&quot;row&quot;&amp;gt;
                &amp;lt;div class=&quot;col-md-12&quot;&amp;gt;
                    &amp;lt;!-- Advanced Tables --&amp;gt;
                    &amp;lt;div class=&quot;panel panel-default&quot;&amp;gt;
                        &amp;lt;div class=&quot;panel-heading&quot;&amp;gt;
                            分类管理表
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&quot;panel-body&quot;&amp;gt;
                            &amp;lt;div class=&quot;table-responsive&quot;&amp;gt;
                                &amp;lt;table class=&quot;table table-striped table-bordered table-hover&quot; id=&quot;dataTables-example&quot;&amp;gt;
                                    &amp;lt;thead&amp;gt;
                                    &amp;lt;tr&amp;gt;
                                        &amp;lt;th&amp;gt;分类id&amp;lt;/th&amp;gt;
                                        &amp;lt;th&amp;gt;分类名称&amp;lt;/th&amp;gt;

                                        &amp;lt;th&amp;gt;编辑分类&amp;lt;/th&amp;gt;
                                        &amp;lt;th&amp;gt;产品管理&amp;lt;/th&amp;gt;
                                        &amp;lt;th&amp;gt;属性管理&amp;lt;/th&amp;gt;
                                    &amp;lt;/tr&amp;gt;
                                    &amp;lt;/thead&amp;gt;
                                    &amp;lt;tbody&amp;gt;
                                    &amp;lt;c:forEach items=&quot;${categories}&quot; var=&quot;c&quot;&amp;gt;
                                        &amp;lt;tr&amp;gt;
                                            &amp;lt;td&amp;gt;${c.id}&amp;lt;/td&amp;gt;
                                            &amp;lt;td&amp;gt;${c.name}&amp;lt;/td&amp;gt;

                                            &amp;lt;td&amp;gt;&amp;lt;a href=&quot;editCategory?id=${c.id}&amp;amp;name=${c.name}&quot;&amp;gt;&amp;lt;span class=&quot;glyphicon glyphicon-th-list&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
                                            &amp;lt;td&amp;gt;&amp;lt;a href=&quot;listProduct?category_id=${c.id}&quot;&amp;gt;&amp;lt;span class=&quot;glyphicon glyphicon-shopping-cart&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
                                            &amp;lt;td&amp;gt;&amp;lt;a href=&quot;listProperty?category_id=${c.id}&quot;&amp;gt;&amp;lt;span class=&quot;glyphicon glyphicon-edit&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
                                        &amp;lt;/tr&amp;gt;
                                    &amp;lt;/c:forEach&amp;gt;
                                    &amp;lt;/tbody&amp;gt;
                                &amp;lt;/table&amp;gt;
                            &amp;lt;/div&amp;gt;

                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;!--End Advanced Tables --&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;

        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;!-- /. PAGE WRAPPER  --&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;!-- /. WRAPPER  --&amp;gt;
&amp;lt;!-- JS Scripts--&amp;gt;
&amp;lt;!-- jQuery Js --&amp;gt;
&amp;lt;script src=&quot;../assets/js/jquery-1.10.2.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;!-- Bootstrap Js --&amp;gt;
&amp;lt;script src=&quot;../assets/js/bootstrap.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;!-- Metis Menu Js --&amp;gt;
&amp;lt;script src=&quot;../assets/js/jquery.metisMenu.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;!-- DATA TABLE SCRIPTS --&amp;gt;
&amp;lt;script src=&quot;../assets/js/dataTables/jquery.dataTables.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;../assets/js/dataTables/dataTables.bootstrap.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    $(document).ready(function () {
        $('#dataTables-example').dataTable();
    });
&amp;lt;/script&amp;gt;
&amp;lt;!-- Custom Js --&amp;gt;
&amp;lt;script src=&quot;../assets/js/custom-scripts.js&quot;&amp;gt;&amp;lt;/script&amp;gt;


&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;editCategory.jsp&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
         pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot; %&amp;gt;
&amp;lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;/&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;/&amp;gt;
    &amp;lt;title&amp;gt;模仿天猫-后台&amp;lt;/title&amp;gt;
    &amp;lt;!-- Bootstrap Styles--&amp;gt;
    &amp;lt;link href=&quot;../assets/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;/&amp;gt;
    &amp;lt;!-- FontAwesome Styles--&amp;gt;
    &amp;lt;link href=&quot;../assets/css/font-awesome.css&quot; rel=&quot;stylesheet&quot;/&amp;gt;
    &amp;lt;!-- Morris Chart Styles--&amp;gt;

    &amp;lt;!-- Custom Styles--&amp;gt;
    &amp;lt;link href=&quot;../assets/css/custom-styles.css&quot; rel=&quot;stylesheet&quot;/&amp;gt;
    &amp;lt;!-- Google Fonts--&amp;gt;
    &amp;lt;link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'/&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;wrapper&quot;&amp;gt;
    &amp;lt;nav class=&quot;navbar navbar-default top-navbar&quot; role=&quot;navigation&quot;&amp;gt;
        &amp;lt;div class=&quot;navbar-header&quot;&amp;gt;
            &amp;lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.sidebar-collapse&quot;&amp;gt;
                &amp;lt;span class=&quot;sr-only&quot;&amp;gt;Toggle navigation&amp;lt;/span&amp;gt;
                &amp;lt;span class=&quot;icon-bar&quot;&amp;gt;&amp;lt;/span&amp;gt;
                &amp;lt;span class=&quot;icon-bar&quot;&amp;gt;&amp;lt;/span&amp;gt;
                &amp;lt;span class=&quot;icon-bar&quot;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/button&amp;gt;
            &amp;lt;a class=&quot;navbar-brand&quot; href=&quot;listCategory&quot;&amp;gt;Tmall&amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/nav&amp;gt;

    &amp;lt;!--/. NAV TOP  --&amp;gt;
    &amp;lt;nav class=&quot;navbar-default navbar-side&quot; role=&quot;navigation&quot;&amp;gt;
        &amp;lt;div class=&quot;sidebar-collapse&quot;&amp;gt;
            &amp;lt;ul class=&quot;nav&quot; id=&quot;main-menu&quot;&amp;gt;

                &amp;lt;li&amp;gt;
                    &amp;lt;a class=&quot;active-menu&quot; href=&quot;listCategory&quot;&amp;gt;&amp;lt;i class=&quot;fa fa-bars&quot;&amp;gt;&amp;lt;/i&amp;gt; 分类管理&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;listUser&quot;&amp;gt;&amp;lt;i class=&quot;fa fa-user&quot;&amp;gt;&amp;lt;/i&amp;gt; 用户管理&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;listOrder&quot;&amp;gt;&amp;lt;i class=&quot;fa fa-list-alt&quot;&amp;gt;&amp;lt;/i&amp;gt; 订单管理&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;listProduct&quot;&amp;gt;&amp;lt;i class=&quot;fa fa-th-list&quot;&amp;gt;&amp;lt;/i&amp;gt; 产品管理&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;listLink&quot;&amp;gt;&amp;lt;i class=&quot;fa fa-link&quot;&amp;gt;&amp;lt;/i&amp;gt; 推荐链接管理&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/div&amp;gt;

    &amp;lt;/nav&amp;gt;
    &amp;lt;!-- /. NAV SIDE  --&amp;gt;
    &amp;lt;div id=&quot;page-wrapper&quot;&amp;gt;
        &amp;lt;div id=&quot;page-inner&quot;&amp;gt;
            &amp;lt;div class=&quot;row&quot;&amp;gt;
                &amp;lt;div class=&quot;col-md-12&quot;&amp;gt;
                    &amp;lt;h1 class=&quot;page-header&quot;&amp;gt;
                        分类管理
                        &amp;lt;small&amp;gt; - id:${category.id} &amp;lt;/small&amp;gt;
                    &amp;lt;/h1&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;

            &amp;lt;div class=&quot;row&quot;&amp;gt;
                &amp;lt;div class=&quot;col-md-6&quot;&amp;gt;
                    &amp;lt;!-- Advanced Tables --&amp;gt;
                    &amp;lt;div class=&quot;panel panel-default&quot;&amp;gt;
                        &amp;lt;div class=&quot;panel-heading&quot;&amp;gt;
                            编辑分类
                        &amp;lt;/div&amp;gt;
                        &amp;lt;div class=&quot;panel-body&quot;&amp;gt;
                            &amp;lt;div class=&quot;row col-lg-12&quot;&amp;gt;
                                &amp;lt;form action=&quot;updateCategory&quot; role=&quot;form&quot;&amp;gt;
                                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                                        &amp;lt;%-- 隐藏id属性，一并提交 --%&amp;gt;
                                        &amp;lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;${category.id}&quot;&amp;gt;
                                        &amp;lt;label&amp;gt;分类名称：&amp;lt;/label&amp;gt;
                                        &amp;lt;input name=&quot;name&quot; class=&quot;form-control&quot; value=&quot;${category.name}&quot;&amp;gt; &amp;lt;br/&amp;gt;
                                        &amp;lt;div class=&quot;pull-right&quot;&amp;gt;
                                            &amp;lt;input type=&quot;submit&quot; class=&quot;btn btn-default&quot;&amp;gt;
                                        &amp;lt;/div&amp;gt;
                                    &amp;lt;/div&amp;gt;
                                &amp;lt;/form&amp;gt;
                            &amp;lt;/div&amp;gt;

                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;!--End Advanced Tables --&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;

        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;!-- /. PAGE WRAPPER  --&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;!-- /. WRAPPER  --&amp;gt;
&amp;lt;!-- JS Scripts--&amp;gt;
&amp;lt;!-- jQuery Js --&amp;gt;
&amp;lt;script src=&quot;../assets/js/jquery-1.10.2.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;!-- Bootstrap Js --&amp;gt;
&amp;lt;script src=&quot;../assets/js/bootstrap.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;这样就完成了-category-的后台管理模块&quot;&gt;这样就完成了 Category 的后台管理模块&lt;/h4&gt;
&lt;p&gt;其他模块的思路跟 Category 如出一辙，就比较偏向于体力劳动了...&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt; 所有本类的 id 属性均为 &lt;code&gt;id&lt;/code&gt; ，所有外键的 id 都是 &lt;code&gt;属性名_id&lt;/code&gt; 这样的格式，保持统一！&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;example-条件查询&quot;&gt;Example 条件查询&lt;/h2&gt;
&lt;p&gt;MyBatis 逆向工程自动生成文件的时候自动生成了 Example 条件查询类，我们到底应该怎么使用它呢，这里简要的说明一下。&lt;/p&gt;
&lt;p&gt;不得不说这个东西还挺神奇，也很方便，比如我们需要查询 category_id 对应下的属性表，我们可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public List&amp;lt;Property&amp;gt; list(Integer category_id) {
    PropertyExample example = new PropertyExample();
    example.or().andCategory_idEqualTo(category_id);
    List&amp;lt;Property&amp;gt; properties = propertyMapper.selectByExample(example);
    return properties;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过方法名其实也很容易看懂这些是什么意思，我们首先创建了一个 PropertyExample 实例对象，然后通过 &lt;code&gt;.or()&lt;/code&gt; 方法开启条件查询，&lt;code&gt;.andCategory_idEqualTo()&lt;/code&gt; 匹配对应的 category_id ，自动生成的 sql 语句就像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-77a9f0157eba3e78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/biandous/article/details/65630783&quot;&gt;更多详情戳这里 - 引用其他博客的详细说明&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;idea-快速重构&quot;&gt;IDEA 快速重构&lt;/h2&gt;
&lt;p&gt;当我编写好了 PropertyService 、PropertyServiceImpl、 PropertyController 之后再想要去编写 Product 的这一系列文件的时候，发现其实很多代码都是重复的，只是很少一部分的代码需要改动，暂时不考虑设计模式的话，我们可以使用 IDEA 来完成快速重构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接复制 PropertyController 的代码到 ProductController 中，然后【Ctrl + F】搜索 Property ：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-02324398e7cb52b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以发现所有的 Property 都高亮了，然后我们怎么批量修改呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-22868fcd1d7ab8ff.gif?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后继续疯狂码代码...&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;开发过程中遇到的一些问题&quot;&gt;开发过程中遇到的一些问题&lt;/h2&gt;
&lt;h4 id=&quot;propertyvalue-遇到的麻烦&quot;&gt;PropertyValue 遇到的麻烦&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-320fc236c47427d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PropertyValue 属性值表，这个表关联了两个外键，一个指向 Product ，另一个指向 Property ，当我按照之前的设计把 listProduct.jsp 设计成下面这个样子的时候，点击【编辑属性】，Property 的信息应该怎么传递？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-663fe5770f82dc3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-c1937d1fb2ff0ad2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;也就是说，如何处理从 listProduct 跳转到 listPropertyValue 页面时凭空跳出来的 Property 的相关信息？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 PropertyValueServiceImpl 中增加：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Autowired
PropertyService propertyService;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们现在有 category_id 和 product_id ，我们可以利用 Property 和 Category 之间的联系，通过 category_id 查询出所有对应的 Property ，然后再筛选出同时匹配 property_id 和 product_id 的 PropertyValue：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public List&amp;lt;PropertyValue&amp;gt; list(Integer product_id, Integer category_id) {
    PropertyValueExample example = new PropertyValueExample();
    List&amp;lt;PropertyValue&amp;gt; propertyValues = new ArrayList&amp;lt;PropertyValue&amp;gt;();
    List&amp;lt;Property&amp;gt; properties = propertyService.list(category_id);
    for (Property property : properties) {
        // 筛选出同时匹配 property_id 和 product_id 的值
        example.or().andProperti_idEqualTo(property.getId()).andProduct_idEqualTo(product_id);
        propertyValues.addAll(propertyValueMapper.selectByExample(example));
    }
    return propertyValues;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;emmm...这样的思路出来之后，对应的 Controller 就清晰了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/listPropertyValue&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;list&lt;/span&gt;(Model model, Integer product_id, Integer category_id) {
    List&amp;lt;PropertyValue&amp;gt; propertyValues = propertyValueService.&lt;span class=&quot;fu&quot;&gt;list&lt;/span&gt;(product_id, category_id);
    model.&lt;span class=&quot;fu&quot;&gt;addAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;propertyValues&quot;&lt;/span&gt;, propertyValues);
    Product product = productService.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(product_id);
    model.&lt;span class=&quot;fu&quot;&gt;addAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;product&quot;&lt;/span&gt;, product);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;admin/listPropertyValue&quot;&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加入一条数据测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-6e15372ceb60a814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另一个问题是添加属性值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加的属性值必须是当前 Category 下有的属性值，所以我们可以在 Controller 上自动注入一个 PropertyService 通过 category_id 查询到当前分类下所有的 Property 然后传递给 listPropertyValue ：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
PropertyService propertyService;

&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/listPropertyValue&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;list&lt;/span&gt;(Model model, Integer product_id, Integer category_id) {
    List&amp;lt;PropertyValue&amp;gt; propertyValues = propertyValueService.&lt;span class=&quot;fu&quot;&gt;list&lt;/span&gt;(product_id, category_id);
    model.&lt;span class=&quot;fu&quot;&gt;addAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;propertyValues&quot;&lt;/span&gt;, propertyValues);
    Product product = productService.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(product_id);
    model.&lt;span class=&quot;fu&quot;&gt;addAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;product&quot;&lt;/span&gt;, product);
    List&amp;lt;Property&amp;gt; properties = propertyService.&lt;span class=&quot;fu&quot;&gt;list&lt;/span&gt;(category_id);
    model.&lt;span class=&quot;fu&quot;&gt;addAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;properties&quot;&lt;/span&gt;, properties);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;admin/listPropertyValue&quot;&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;期间发现一个 BUG，PropertyValue 表里的 property_id 居然写成了 properti_id，吓得我赶紧检查了一下所有表的字段，其他的没问题，重新生成一下逆向工程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;然后获取属性名称：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-913cf5641162aaa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;完善之后大概是这样：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-63c0a4d1c28f7633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;产品图片管理&quot;&gt;产品图片管理&lt;/h4&gt;
&lt;p&gt;产品图片的管理需要涉及到文件的上传操作，我们需要先提供必要的 jar 包依赖：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;commons-fileupload&lt;/li&gt;
&lt;li&gt;commons-io&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同样的搜索 maven 库添加依赖到 pom.xml中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 上传文件fileupload --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-fileupload&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-fileupload&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-io&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;产品图片如何管理？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;规定一：&lt;/strong&gt;&lt;br/&gt;所有的产品图片均保存在【img/product/】对应的 product_id 目录下，并且默认的文件名为 1，2，3，4，5 ，例如 product_id 为 1 的产品的产品图片 1 保存于：【img/product/1/1.jpg】&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规定二：&lt;/strong&gt;&lt;br/&gt;每一个产品对应五张图片，文件名分别为 1.jpg ，2.jpg 以此类推，不能少也不能多，删除也只是将对应目录下的图片删除，id 并不改变&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规定三：&lt;/strong&gt;&lt;br/&gt;默认产品打开的大图即为该产品图片目录中的 1.jpg&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;界面大概设计成了这样：&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-77a779e13d7b2d50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;莫名其妙一个 BUG：&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;我把表单设计成了这样，隐藏了两个属性，一个 product_id，一个 id：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-7ef327a861da75d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了方便操作，我想要直接申明两个参数用来接收上面的两个属性，大概是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-dc05f02505bc41ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是上面两种方法都不行，我还查了一些资料在 @RequestParam 注解里设置了 required 属性，仍然获取不到，但是我改成用 ProductImage 来接收就好了..Why?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-6bf39c8f3fe9ca82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后来写着写着，又必须要使用上面两种方法了....&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;根据我们的规定来完成代码&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;ProductImageService 层还是跟之前的没有多大的区别，但是值得注意的是，根据我们的规定，我们的删除需要做一些改动（根据 product_id 批量删除）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package cn.wmyskxz.service;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import cn.wmyskxz.mapper.PropertyValueMapper;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import cn.wmyskxz.pojo.*;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Service;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * cn.wmyskxz.pojo.PropertyValueValueService 实现类&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @author: @我没有三颗心脏&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @create: 2018-04-28-上午 7:47&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Service&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; PropertyValueServiceImpl &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; PropertyValueService {

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    PropertyValueMapper propertyValueMapper;

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    PropertyService propertyService;

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    ProductService productService;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(PropertyValue propertyValue) {
        propertyValueMapper.&lt;span class=&quot;fu&quot;&gt;insert&lt;/span&gt;(propertyValue);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;delete&lt;/span&gt;(Integer id) {
        propertyValueMapper.&lt;span class=&quot;fu&quot;&gt;deleteByPrimaryKey&lt;/span&gt;(id);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;deleteByProductId&lt;/span&gt;(Integer product_id) {
        &lt;span class=&quot;co&quot;&gt;// 按条件查询出需要删除的列表&lt;/span&gt;
        PropertyValueExample example = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;PropertyValueExample&lt;/span&gt;();
        example.&lt;span class=&quot;fu&quot;&gt;or&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;andProduct_idEqualTo&lt;/span&gt;(product_id);
        Integer category_id = productService.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(product_id).&lt;span class=&quot;fu&quot;&gt;getCategory_id&lt;/span&gt;();
        List&amp;lt;PropertyValue&amp;gt; propertyValues = &lt;span class=&quot;fu&quot;&gt;list&lt;/span&gt;(product_id, category_id);
        &lt;span class=&quot;co&quot;&gt;// 循环删除&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; propertyValues.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;(); i++) {
            propertyValueMapper.&lt;span class=&quot;fu&quot;&gt;deleteByPrimaryKey&lt;/span&gt;(propertyValues.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(i).&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;());
        }
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(PropertyValue propertyValue) {
        propertyValueMapper.&lt;span class=&quot;fu&quot;&gt;updateByPrimaryKey&lt;/span&gt;(propertyValue);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; List&amp;lt;PropertyValue&amp;gt; &lt;span class=&quot;fu&quot;&gt;list&lt;/span&gt;(Integer product_id, Integer category_id) {
        PropertyValueExample example = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;PropertyValueExample&lt;/span&gt;();
        List&amp;lt;PropertyValue&amp;gt; propertyValues = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;PropertyValue&amp;gt;();
        List&amp;lt;Property&amp;gt; properties = propertyService.&lt;span class=&quot;fu&quot;&gt;list&lt;/span&gt;(category_id);
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Property property : properties) {
            &lt;span class=&quot;co&quot;&gt;// 筛选出同时匹配 property_id 和 product_id 的值&lt;/span&gt;
            example.&lt;span class=&quot;fu&quot;&gt;or&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;andProperty_idEqualTo&lt;/span&gt;(property.&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;()).&lt;span class=&quot;fu&quot;&gt;andProduct_idEqualTo&lt;/span&gt;(product_id);
            propertyValues.&lt;span class=&quot;fu&quot;&gt;addAll&lt;/span&gt;(propertyValueMapper.&lt;span class=&quot;fu&quot;&gt;selectByExample&lt;/span&gt;(example));
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; propertyValues;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; PropertyValue &lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(Integer id) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; propertyValueMapper.&lt;span class=&quot;fu&quot;&gt;selectByPrimaryKey&lt;/span&gt;(id);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;首先在 ProductController 中 add 和 delete 方法中增加以下代码：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
ProductImageService productImageService;

&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/addProduct&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Product product) {
    productService.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(product);

    &lt;span class=&quot;co&quot;&gt;// 创建新的 Product 时默认创建 5 个对应的 ProductImage 数据&lt;/span&gt;
    ProductImage productImage = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ProductImage&lt;/span&gt;();
    productImage.&lt;span class=&quot;fu&quot;&gt;setProduct_id&lt;/span&gt;(product.&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;());
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;; i++) {
        productImage.&lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;(i);
        productImageService.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(productImage);
    }

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;redirect:listProduct?category_id=&quot;&lt;/span&gt; + product.&lt;span class=&quot;fu&quot;&gt;getCategory_id&lt;/span&gt;();
}

&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/deleteProduct&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;delete&lt;/span&gt;(Integer id, HttpServletRequest request) {

    &lt;span class=&quot;co&quot;&gt;// 在删除产品的时候将对应的 5 个 ProductImage 数据也删除了&lt;/span&gt;
    productImageService.&lt;span class=&quot;fu&quot;&gt;deleteByProductId&lt;/span&gt;(id);
    &lt;span class=&quot;co&quot;&gt;// 同时删除目录下的相关文件&lt;/span&gt;
    String path = request.&lt;span class=&quot;fu&quot;&gt;getSession&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getServletContext&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getRealPath&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt; + id);
    &lt;span class=&quot;fu&quot;&gt;deleteDir&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; File(path));

    &lt;span class=&quot;co&quot;&gt;// 删除外键对应的数据&lt;/span&gt;
    propertyValueService.&lt;span class=&quot;fu&quot;&gt;deleteByProductId&lt;/span&gt;(id);

    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; category_id = productService.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(id).&lt;span class=&quot;fu&quot;&gt;getCategory_id&lt;/span&gt;();
    productService.&lt;span class=&quot;fu&quot;&gt;delete&lt;/span&gt;(id);

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;redirect:listProduct?category_id=&quot;&lt;/span&gt; + category_id;
}

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 递归删除目录下的所有文件及子目录下所有文件&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param dir &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;将要删除的文件目录&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;boolean Returns &quot;true&quot; if all deletions were successful.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * If a deletion fails, the method stops attempting to&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * delete and returns &quot;false&quot;.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;deleteDir&lt;/span&gt;(File dir) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (dir.&lt;span class=&quot;fu&quot;&gt;isDirectory&lt;/span&gt;()) {
        String[] children = dir.&lt;span class=&quot;fu&quot;&gt;list&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;//递归删除目录中的子目录下&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; children.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; i++) {
            &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; success = &lt;span class=&quot;fu&quot;&gt;deleteDir&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; File(dir, children[i]));
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!success) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
            }
        }
    }
    &lt;span class=&quot;co&quot;&gt;// 目录此时为空，可以删除&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; dir.&lt;span class=&quot;fu&quot;&gt;delete&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后编写我们的 ProductImageController ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.wmyskxz.controller;

import cn.wmyskxz.pojo.Product;
import cn.wmyskxz.pojo.ProductImage;
import cn.wmyskxz.service.ProductImageService;
import cn.wmyskxz.service.ProductService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletRequest;
import java.io.File;
import java.util.List;

/**
 * ProductImage 的控制器
 *
 * @author: @我没有三颗心脏
 * @create: 2018-04-28-下午 14:10
 */
@Controller
@RequestMapping(&quot;/admin&quot;)
public class ProductImageController {

    @Autowired
    ProductImageService productImageService;

    @Autowired
    ProductService productService;

    @RequestMapping(&quot;/editProductImage&quot;)
    public String edit(Model model, Integer product_id) {
        List&amp;lt;ProductImage&amp;gt; productImages = productImageService.list(product_id);
        model.addAttribute(&quot;productImages&quot;, productImages);
        Product product = productService.get(product_id);
        model.addAttribute(&quot;product&quot;, product);
        return &quot;admin/editProductImage&quot;;
    }

    @RequestMapping(value = &quot;/updateProductImage&quot;, method = RequestMethod.POST)
    public String update(HttpServletRequest request,
//                       @RequestParam(&quot;productImage&quot;) ProductImage productImage,
                         Integer product_id, 
                         Integer id,
                         @RequestParam(&quot;picture&quot;) MultipartFile picture) {

        // 上传文件到指定位置
        String filePath = request.getSession().getServletContext()
                .getRealPath(&quot;img/product/&quot; + product_id);
        // 因为 id 是自增长键，所以需要 % 5 来作为文件名
        String fileName = (id % 5 == 0 ? 5 : id % 5) + &quot;.jpg&quot;;
        File uploadPicture = new File(filePath, fileName);
        if (!uploadPicture.exists()) {
            uploadPicture.mkdirs();
        }
        // 保存
        try {
            picture.transferTo(uploadPicture);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return &quot;redirect:editProductImage?product_id=&quot; + product_id;
    }

    @RequestMapping(&quot;/deleteProductImage&quot;)
    public String delete(Integer id, Integer product_id, HttpServletRequest request) {
        // 不删除表中的数据（在 ProductController 中统一删除），删除对应文件
        String filePath = request.getSession().getServletContext()
                .getRealPath(&quot;img/product/&quot; + product_id);
        String fileName = id + &quot;.jpg&quot;;
        new File(filePath, fileName).delete();

        return &quot;redirect:editProductImage?product_id=&quot; + product_id;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;再优化一下界面的东西，增加没有图片显示的 error 图片，大概就是这个样子：&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-1503d0b3ed63d785.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就只贴一下 table 的代码吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;c:forEach items=&quot;${productImages}&quot; var=&quot;pi&quot;&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;${pi.product_id}&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;${pi.id}&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;&amp;lt;img class=&quot;col-md-8&quot;
                 src=&quot;../img/product/${pi.product_id}/${pi.id%5==0?5:pi.id%5}.jpg&quot;
                 onerror=&quot;this.src='../img/product/error.png'&quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td class=&quot;col-md-5&quot;&amp;gt;
            &amp;lt;form action=&quot;updateProductImage&quot; method=&quot;post&quot;
                  enctype=&quot;multipart/form-data&quot;&amp;gt;
                &amp;lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;${pi.id}&quot;&amp;gt;
                &amp;lt;input type=&quot;hidden&quot; name=&quot;product_id&quot;
                       value=&quot;${pi.product_id}&quot;&amp;gt;
                &amp;lt;input type=&quot;file&quot; name=&quot;picture&quot; class=&quot;pull-left&quot;&amp;gt;
                &amp;lt;input type=&quot;submit&quot; class=&quot;btn btn-primary pull-right&quot; value=&quot;上传&quot;&amp;gt;
            &amp;lt;/form&amp;gt;
        &amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;
            &amp;lt;a href=&quot;deleteProductImage?product_id=${pi.product_id}&amp;amp;id=${pi.id}&quot;&amp;gt;&amp;lt;span
                    class=&quot;glyphicon glyphicon-trash&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/c:forEach&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在写图片管理的时候又遇到一个坑&quot;&gt;在写图片管理的时候又遇到一个坑&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;在删除顶层数据库数据的时候，要注意删除其下的有外键关联的数据&lt;/strong&gt;，特别是 product_id 这个东西，是很多表的外键，删除 product 之前需要先清空有关联的其他表的数据....&lt;/p&gt;
&lt;p&gt;总之坑是很多啦..不过项目在进展总归是好事...耐心耐心...&lt;/p&gt;
&lt;h4 id=&quot;接着码代码....&quot;&gt;接着码代码....&lt;/h4&gt;
&lt;p&gt;还剩下一些体力活的东西，就先结博文啦...（心累.jpg）&lt;/p&gt;
&lt;p&gt;有一些催更的朋友，希望能别催啦...每天都在码啦，而且本身也是很low的东西，写完之后我会上传 github 的。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-dc0bd48aaa532767.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我给自己埋了一个大坑说要模仿天猫，并且陷进去的时候，一方面痛苦着一方面也察觉了自己很多不足的地方，就觉得还是很值得，现在来做一下简短的总结。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进度比想象中慢了很多，虽然一步一步按照之前的分析图来编写代码总体是顺畅的，但是有那种写着写着突然发现之前的设计有问题的感觉，中途也改了几次，&lt;strong&gt;发现自己分析问题不够全面。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;项目中有许多类似的代码，并且在 Controller 和 Impl 中不断有其他的东西加入，总觉得是糟糕的代码，但是又不知道应该进一步如何改进。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方向永远比努力重要，在行动之前思考清楚，&lt;/strong&gt;我一直觉得是很重要的一点，我觉得通过对项目的分析，对我项目的进展有一个整体的构思，各个模块该有什么功能都比较清晰，特别在编写 JSP 文件的时候能明显感觉不会很迷茫，这是比较好的一点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发现自己阅读代码量很少，&lt;/strong&gt;这种感觉体现在很多地方，一是写代码时感觉到自己思想的局限性，二是觉得自己写的代码有很多的相似性，虽然这个项目是自己突发奇想的想要去做的，但是有很多细节的地方，是自己没有去注意到的，比如类型要求、边界判断、事务处理等等等...&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;3.3290322580645&quot;&gt;
&lt;p&gt;欢迎转载，转载请注明出处！&lt;br/&gt;@我没有三颗心脏&lt;br/&gt;CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq939419061&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qq939419061&lt;/a&gt;&lt;br/&gt;简书：&lt;a href=&quot;http://www.jianshu.com/u/a40d61a49221&quot; class=&quot;uri&quot;&gt;http://www.jianshu.com/u/a40d61a49221&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 28 Apr 2018 14:34:00 +0000</pubDate>
<dc:creator>我没有三颗心脏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wmyskxz/p/8969842.html</dc:identifier>
</item>
<item>
<title>深入浅出低功耗蓝牙(BLE)协议栈 - iini</title>
<link>http://www.cnblogs.com/iini/p/8969828.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iini/p/8969828.html</guid>
<description>&lt;p&gt;BLE协议栈为什么要分层？怎么理解BLE“连接”？如果BLE协议只有ATT层没有GATT层会发生什么？&lt;/p&gt;
&lt;h2&gt;协议栈框架&lt;/h2&gt;
&lt;p&gt;一般而言，我们把某个协议的实现代码称为协议栈（protocol stack），BLE协议栈就是实现低功耗蓝牙协议的代码，理解和掌握BLE协议是实现BLE协议栈的前提。在深入BLE协议栈各个组成部分之前，我们先看一下BLE协议栈整体架构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201804/1366713-20180428221935991-1554321639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如上图所述，要实现一个BLE应用，首先需要一个支持BLE射频的芯片，然后还需要提供一个与此芯片配套的BLE协议栈，最后在协议栈上开发自己的应用。可以看出BLE协议栈是连接芯片和应用的桥梁，是实现整个BLE应用的关键。那BLE协议栈具体包含哪些功能呢？简单来说，BLE协议栈主要用来对你的应用数据进行&lt;strong&gt;层层封包&lt;/strong&gt;，以生成一个满足BLE协议的空中数据包，也就是说，把应用数据包裹在一系列的帧头（header）和帧尾（tail）中。具体来说，BLE协议栈主要由如下几部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;PHY&lt;/strong&gt;&lt;strong&gt;层&lt;/strong&gt;（Physical layer物理层）。PHY层用来指定BLE所用的无线频段，调制解调方式和方法等。PHY层做得好不好，直接决定整个BLE芯片的功耗，灵敏度以及selectivity等射频指标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LL&lt;/strong&gt;&lt;strong&gt;层&lt;/strong&gt;（Link Layer链路层）。LL层是整个BLE协议栈的核心，也是BLE协议栈的难点和重点。像Nordic的BLE协议栈能同时支持20个link（连接），就是LL层的功劳。LL层要做的事情非常多，比如具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的GAP或者ATT。&lt;/li&gt;
&lt;li&gt;HCI（Host controller interface）。HCI是可选的（&lt;a href=&quot;http://www.cnblogs.com/iini/p/8834970.html&quot; target=&quot;_blank&quot;&gt;具体请参考文章： 三种蓝牙架构实现方案（蓝牙协议栈方案）&lt;/a&gt;），HCI主要用于2颗芯片实现BLE协议栈的场合，用来规范两者之间的通信协议和通信命令等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GAP&lt;/strong&gt;&lt;strong&gt;层&lt;/strong&gt;（Generic access profile）。GAP是对LL层payload（有效数据包）如何进行解析的两种方式中的一种，而且是最简单的那一种。GAP简单的对LL payload进行一些规范和定义，因此GAP能实现的功能极其有限。GAP目前主要用来进行广播，扫描和发起连接等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L2CAP&lt;/strong&gt;&lt;strong&gt;层&lt;/strong&gt;（Logic link control and adaptation protocol）。L2CAP对LL进行了一次简单封装，LL只关心传输的数据本身，L2CAP就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SMP&lt;/strong&gt;（Secure manager protocol）。SMP用来管理BLE连接的加密和安全的，如何保证连接的安全性，同时不影响用户的体验，这些都是SMP要考虑的工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ATT&lt;/strong&gt;（Attribute protocol）。简单来说，ATT层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE协议栈中，开发者接触最多的就是ATT。&lt;strong&gt;BLE引入了attribute概念，用来描述一条一条的数据&lt;/strong&gt;。Attribute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GATT&lt;/strong&gt;（Generic attribute profile ）。GATT用来规范attribute中的数据内容，并运用group（分组）的概念对attribute进行分类管理。没有GATT，BLE协议栈也能跑，但互联互通就会出问题，也正是因为有了GATT和各种各样的应用profile，BLE摆脱了ZigBee等无线协议的兼容性困境，成了出货量最大的2.4G无线通信产品。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我相信很多人看了上面的介绍，还是不懂BLE协议栈的工作原理，以及每一层具体干什么的，为什么要这么分层。下面我以如何发送一个数据包为例来讲解BLE协议栈各层是如何紧密配合，以完成发送任务的。&lt;/p&gt;
&lt;h2&gt;如何通过无线发送一个数据包&lt;/h2&gt;
&lt;p&gt;假设有设备A和设备B，设备A要把自己目前的电量状态83%（十六进制表示为0x53）发给设备B，该怎么做呢？作为一个开发者，他希望越简单越好，对他而言，他希望调用一个简单的API就能完成这件事，比如send(0x53)，实际上我们的BLE协议栈就是这样设计的，开发者只需调用send(0x53)就可以把数据发送出去了，其余的事情BLE协议栈帮你搞定。很多人会想，BLE协议栈是不是直接在物理层就把0x53发出去，就如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201804/1366713-20180428222118891-143146891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方式初看起来挺美的，但由于很多细节没有考虑到，实际是不可行的。首先，它没有考虑用哪一个射频信道来进行传输，在不更改API的情况下，我们只能对协议栈进行分层，为此引入LL层，开发者还是调用send(0x53)，send(0x53)再调用send_LL(0x53,2402M)（注：2402M为信道频率）。这里还有一个问题，设备B怎么知道这个数据包是发给自己的还是其他人的，为此BLE引入&lt;strong&gt;access address&lt;/strong&gt;&lt;strong&gt;概念，用来指明接收者身份&lt;/strong&gt;，其中，0x8E89BED6这个access address比较特殊，它表示要发给周边所有设备，即广播。如果你要一对一的进行通信（BLE协议将其称为&lt;strong&gt;连接&lt;/strong&gt;），即设备A的数据包只能设备B接收，同样设备B的数据包只能设备A接收，那么就必须生成一个独特的&lt;strong&gt;随机&lt;/strong&gt;access address以标识设备A和设备B两者之间的连接。&lt;/p&gt;
&lt;h3&gt;广播方式&lt;/h3&gt;
&lt;p&gt;我们先来看一下简单的广播情况，这种情况下，我们把设备A叫&lt;strong&gt;advertiser&lt;/strong&gt;（广播者），设备B叫&lt;strong&gt;scanner&lt;/strong&gt;或者&lt;strong&gt;observer&lt;/strong&gt;（扫描者）。广播状态下设备A的LL层API将变成send_LL(0x53,2402M, 0x8E89BED6)。由于设备B可以同时接收到很多设备的广播，因此数据包还必须包含设备A的device address（0xE1022AAB753B）以确认该广播包来自设备A，为此send_LL参数需要变成(0x53,2402M, 0x8E89BED6, 0xE1022AAB753B)。LL层还要检查数据的完整性，即数据在传输过程中有没有发生窜改，为此引入CRC24对数据包进行检验 (假设为0xB2C78E) 。同时为了调制解调电路工作更高效，每一个数据包的最前面会加上1个字节的preamble（前导帧），preamble一般为0x55或者0xAA。这样，整个空中包就变成（注：&lt;strong&gt;空中包用小端模式表示！&lt;/strong&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201804/1366713-20180428222250223-182188059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 上面这个数据包还有如下问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;没有对数据包进行分类组织，设备B无法找到自己想要的数据0x53。为此我们需要在access address之后加入两个字段：LL header和长度字节。LL header用来表示数据包的LL类型，长度字节用来指明payload的长度&lt;/li&gt;
&lt;li&gt;设备B什么时候开启射频窗口以接收空中数据包？如上图case1所示，当设备A的数据包在空中传输的时候，设备B把接收窗口关闭，此时通信将失败；同样对case2来说，当设备A没有在空中发送数据包时，设备B把接收窗口打开，此时通信也将失败。只有case3的情况，通信才能成功，即设备A的数据包在空中传输时，设备B正好打开射频接收窗口，此时通信才能成功，换句话说，&lt;strong&gt;LL&lt;/strong&gt;&lt;strong&gt;层还必须定义通信时序&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当设备B拿到数据0x53后，该如何解析这个数据呢？它到底表示湿度还是电量，还是别的意思？这个就是GAP层要做的工作，GAP层引入了LTV（Length-Type-Value）结构来定义数据，比如020105，02-长度，01-类型（强制字段，表示广播flag，广播包必须包含该字段），05-值。由于广播包最大只能为31个字节，它能定义的数据类型极其有限，像这里说的电量，GAP就没有定义，因此要通过广播方式把电量数据发出去，只能使用供应商自定义数据类型0xFF，即04FF590053，其中04表示长度，FF表示数据类型（自定义数据），0x0059是供应商ID（自定义数据中的强制字段），0x53就是我们的数据(设备双方约定0x53就是表示电量，而不是其他意思)。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最终空中传输的数据包将变成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AAD6BE898E600E3B75AB2A02E102010504FF5900&lt;strong&gt;53&lt;/strong&gt;8EC7B2
&lt;ul&gt;&lt;li&gt;AA – 前导帧(preamble)&lt;/li&gt;
&lt;li&gt;D6BE898E – 访问地址(access address)&lt;/li&gt;
&lt;li&gt;60 – LL帧头字段(LL header)&lt;/li&gt;
&lt;li&gt;0E – 有效数据包长度(payload length)&lt;/li&gt;
&lt;li&gt;3B75AB2A02E1 – 广播者设备地址(advertiser address)&lt;/li&gt;
&lt;li&gt;02010504FF5900&lt;strong&gt;53 –&lt;/strong&gt; &lt;strong&gt;广播数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;8EC7B2 – CRC24值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201804/1366713-20180428222348224-876399692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了PHY，LL和GAP，就可以发送广播包了，但广播包携带的信息极其有限，而且还有如下几大限制：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;无法进行一对一通信 （广播是一对多通信，而且是单方向的通信）&lt;/li&gt;
&lt;li&gt;由于不支持组包和拆包，因此无法传输大数据&lt;/li&gt;
&lt;li&gt;通信不可靠。广播信道不能太多，否则将导致扫描端效率低下。为此，BLE只使用37(2402MHz) /38(2426MHz) /39(2480MHz)三个信道进行广播和扫描，因此广播不支持跳频。由于广播是一对多的，所以广播也无法支持ACK。这些都使广播通信变得不可靠。&lt;/li&gt;
&lt;li&gt;扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对37/38/39三个通道进行扫描，这样功耗就会比较高。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而连接则可以很好解决上述问题，下面我们就来看看连接是如何将0x53发送出去的。&lt;/p&gt;
&lt;h3&gt;连接方式&lt;/h3&gt;
&lt;p&gt;到底什么叫连接(connection)？像有线UART，很容易理解，就是用线（Rx和Tx等）把设备A和设备B相连，即为连接。用“线”把两个设备相连，实际是让2个设备有共同的通信媒介，并让两者时钟同步起来。蓝牙连接有何尝不是这个道理，&lt;strong&gt;所谓设备&lt;/strong&gt;&lt;strong&gt;A&lt;/strong&gt;&lt;strong&gt;和设备B&lt;/strong&gt;&lt;strong&gt;建立蓝牙连接，就是指设备A&lt;/strong&gt;&lt;strong&gt;和设备B&lt;/strong&gt;&lt;strong&gt;两者“同步”成功&lt;/strong&gt;，其具体包含以下几方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设备A和设备B对接下来要使用的物理信道达成一致&lt;/li&gt;
&lt;li&gt;设备A和设备B双方建立一个共同的时间锚点，也就是说，把双方的时间原点变成同一个点&lt;/li&gt;
&lt;li&gt;设备A和设备B两者时钟同步成功，即双方都知道对方什么时候发送数据包什么时候接收数据包&lt;/li&gt;
&lt;li&gt;连接成功后，设备A和设备B通信流程如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201804/1366713-20180428222439868-1062770995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，一旦设备A和设备B连接成功（此种情况下，我们把设备A称为&lt;strong&gt;Master&lt;/strong&gt;或者&lt;strong&gt;Central&lt;/strong&gt;，把设备B称为&lt;strong&gt;Slave&lt;/strong&gt;或者&lt;strong&gt;Peripheral&lt;/strong&gt;），设备A将周期性以CI（connection interval）为间隔向设备B发送数据包，而设备B也周期性地以CI为间隔打开射频接收窗口以接收设备A的数据包。同时按照蓝牙spec要求，设备B收到设备A数据包&lt;strong&gt;150us&lt;/strong&gt;&lt;strong&gt;后&lt;/strong&gt;，设备B切换到发送状态，把自己的数据发给设备A；设备A则切换到接收状态，接收设备B发过来的数据。由此可见，连接状态下，设备A和设备B的射频发送和接收窗口都是周期性地有计划地开和关，而且开的时间非常短，从而大大减低系统功耗并大大提高系统效率。&lt;/p&gt;

&lt;p&gt;现在我们看看连接状态下是如何把数据0x53发送出去的，从中大家可以体会到蓝牙协议栈分层的妙处。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对开发者来说，很简单，他只需要调用send(0x53)&lt;/li&gt;
&lt;li&gt;GATT层定义数据的类型和分组，方便起见，我们用0x0013表示电量这种数据类型，这样GATT层把数据打包成130053（&lt;strong&gt;小端模式&lt;/strong&gt;！）&lt;/li&gt;
&lt;li&gt;ATT层用来选择具体的通信命令，比如读/写/notify/indicate等，这里选择notify命令0x1B，这样数据包变成了：1B130053&lt;/li&gt;
&lt;li&gt;L2CAP用来指定connection interval（连接间隔），比如每10ms同步一次（CI不体现在数据包中），同时指定逻辑通道编号0004（表示ATT命令），最后把ATT数据长度0x0004加在包头，这样数据就变为：040004001B130053&lt;/li&gt;
&lt;li&gt;LL层要做的工作很多，首先LL层需要指定用哪个物理信道进行传输（物理信道不体现在数据包中），然后再给此连接分配一个Access address（0x50655DAB）以标识此连接只为设备A和设备B直连服务，然后加上LL header和payload length字段，LL header标识此packet为数据packet，而不是control packet等，payload length为整个L2CAP字段的长度，最后加上CRC24字段，以保证整个packet的数据完整性，所以数据包最后变成：
&lt;ul&gt;&lt;li&gt;AAAB5D65501E08040004001B130053D550F6
&lt;ul&gt;&lt;li&gt;AA – 前导帧(preamble)&lt;/li&gt;
&lt;li&gt;0x50655DAB – 访问地址(access address)&lt;/li&gt;
&lt;li&gt;1E – LL帧头字段(LL header)&lt;/li&gt;
&lt;li&gt;08 – 有效数据包长度(payload length)&lt;/li&gt;
&lt;li&gt;04000400 – ATT数据长度，以及L2CAP通道编号&lt;/li&gt;
&lt;li&gt;1B – notify command&lt;/li&gt;
&lt;li&gt;0x0013 – 电量数据handle&lt;/li&gt;
&lt;li&gt;0x53 – 真正要发送的电量数据&lt;/li&gt;
&lt;li&gt;0xF650D5 – CRC24值&lt;/li&gt;
&lt;li&gt;虽然开发者只调用了 send(0x53)，但由于低功耗蓝牙协议栈层层打包，最后空中实际传输的数据将变成下图所示的模样，这就既满足了低功耗蓝牙通信的需求，又让用户API变得简单，可谓一箭双雕！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201804/1366713-20180428222526803-270666623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面只是对BLE协议栈实现原理做了一个简单概述，即便如此，由于都是关于BLE协议栈底层的东西，很多开发者还是会觉得比较枯燥和晦涩，而且对很多开发者来说，他们也不关心BLE协议栈是如何实现的，他们更关心的是BLE协议栈的使用，即怎么开发一个BLE应用。BLE应用是实打实的东西，不能像上面讲述协议栈一样泛泛而谈，必须结合具体的蓝牙芯片和蓝牙协议栈来讲解，为此后面将以Nordic芯片及协议栈作为范例，来具体讲解如何开发BLE应用，以及如何通过代码去理解BLE协议中定义的一些概念和术语。&lt;/p&gt;
</description>
<pubDate>Sat, 28 Apr 2018 14:28:00 +0000</pubDate>
<dc:creator>iini</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iini/p/8969828.html</dc:identifier>
</item>
<item>
<title>CSS实现元素居中原理解析 - laixiangran</title>
<link>http://www.cnblogs.com/laixiangran/p/8969722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laixiangran/p/8969722.html</guid>
<description>&lt;p&gt;在 CSS 中要设置元素水平垂直居中是一个非常常见的需求了。但就是这样一个从理论上来看似乎实现起来极其简单的，在实践中，它往往难住了很多人。&lt;/p&gt;
&lt;p&gt;让元素水平居中相对比较简单：如果它是一个行内元素，就对它的父元素应用 &lt;code&gt;text-align: center&lt;/code&gt;；如果它是一个块级元素，就对它自身应用 &lt;code&gt;margin: auto&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然而如果要对一个元素进行垂直居中，那就没有那么容易了，有时候光是想想就令人头皮发麻了。&lt;/p&gt;
&lt;p&gt;本文分别从行内元素和块级元素进行说明，将目前比较流行的实现方式进行汇集并解析实现原理，方便大家查阅。这里要说明一点，每一种方式都不是十全十美的，关键要看自己的需求，从而分析出哪种实现方式是最合适的。&lt;/p&gt;
&lt;h2 id=&quot;行内元素&quot;&gt;行内元素&lt;/h2&gt;
&lt;p&gt;首先我们先把基础代码写出来：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;main&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;span&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;content&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;我是要居中的行内元素span&lt;span class=&quot;kw&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.main&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#50ba8b&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#5b4d4e&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#FFFFFF&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;class 为 &lt;code&gt;.main&lt;/code&gt; 的 div 包裹这一个 class 为 &lt;code&gt;.content&lt;/code&gt; 的行内元素 span，我们的目的就是要让 &lt;code&gt;.content&lt;/code&gt; 元素 在 &lt;code&gt;.main&lt;/code&gt; 元素中居中。&lt;/p&gt;
&lt;h3 id=&quot;水平居中&quot;&gt;水平居中&lt;/h3&gt;
&lt;h4 id=&quot;text-align&quot;&gt;text-align&lt;/h4&gt;
&lt;p&gt;行内元素的水平居中比较简单，我们直接在 &lt;code&gt;.main&lt;/code&gt; 中添加 &lt;code&gt;text-align: center;&lt;/code&gt; 即可，此时 &lt;code&gt;.main&lt;/code&gt; 变为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.main&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#50ba8b&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;text-align:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;/* 水平居中 */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实现原理：&lt;/strong&gt; 设置 &lt;code&gt;text-align&lt;/code&gt; 的值为 &lt;code&gt;center&lt;/code&gt; ，因为该属性规定元素中的文本的水平对齐方式，那么设置为 &lt;code&gt;center&lt;/code&gt; 则文本就水平居中了。&lt;/p&gt;
&lt;h3 id=&quot;垂直居中&quot;&gt;垂直居中&lt;/h3&gt;
&lt;h4 id=&quot;line-height&quot;&gt;line-height&lt;/h4&gt;
&lt;p&gt;行内元素的垂直居中我们分为 &lt;code&gt;一行&lt;/code&gt; 和 &lt;code&gt;多行或者图片等替换元素&lt;/code&gt; 来说明。&lt;/p&gt;
&lt;p&gt;如果是 &lt;code&gt;一行&lt;/code&gt;，那么我们可以使用 &lt;code&gt;line-height&lt;/code&gt; 来实现，此时 &lt;code&gt;.main&lt;/code&gt; 元素 css 代码变为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.main&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/* 可以不设置 */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#50ba8b&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;line-height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/* 垂直居中 */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实设置了 &lt;code&gt;line-height&lt;/code&gt; 就可以让文本垂直居中，并不需要同时设置 &lt;code&gt;height&lt;/code&gt;，这里也是一直存在的一个误区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现原理：&lt;/strong&gt; 这种方式实现垂直居中运用的是 CSS 中“行距的上下等分机制”，这也说明了为什么该方式只适用于 &lt;code&gt;一行&lt;/code&gt; 的文本。&lt;/p&gt;
&lt;p&gt;还有一点需要说明是，这种方式实现的垂直居中是“近似”的，并不是完美的垂直居中，因为文字字形的垂直中线位置普遍要比真正的“行框盒子”的垂直中线位置低，而由于我们平时使用的 font-size 比较小，使得这点偏差不容易察觉出来，那么感官上也就看成是垂直居中了。&lt;/p&gt;
&lt;h4 id=&quot;line-height-及-vertical-align&quot;&gt;line-height 及 vertical-align&lt;/h4&gt;
&lt;p&gt;下面再来说说 &lt;code&gt;多行或者图片等替换元素&lt;/code&gt; 的垂直居中效果实现，这里我们需要同时借助 &lt;code&gt;line-height&lt;/code&gt; 和 &lt;code&gt;vertical-align&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;p&gt;先让文本换行：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;main&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;span&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;content&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        我是要居中的行内元素span &lt;span class=&quot;kw&quot;&gt;&amp;lt;br&amp;gt;&lt;/span&gt;
        我是要居中的行内元素span
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看修改之后的 css 代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.main&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#50ba8b&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;line-height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;inline-block&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#5b4d4e&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#FFFFFF&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;line-height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;20px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;20px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;vertical-align:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;middle&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实现原理：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置 &lt;code&gt;.content&lt;/code&gt; 元素的 display 为 inline-block。作用在于既能重置外部的 line-height 为正常大小，又能保持行内元素特性，从而可以设置 vertical-align 属性，以及产生一个非常关键的“行框盒子”。我们需要的其实并不是这个“行框盒子”，而是每个“行框盒子”都会附带的一个产物 —— “幽灵空白节点”，即一个宽度为 0，表现如同普通字符的看不见的“节点”。有了这个“幽灵空白节点”，我们的 &lt;code&gt;line-height: 300px;&lt;/code&gt; 就有了作用的对象，从而相当于在 &lt;code&gt;.content&lt;/code&gt; 元素前面撑起了一个高度为 300px 的宽度为 0 的行内元素。&lt;/li&gt;
&lt;li&gt;因为行内元素默认都是基线对齐的，所以我们通过对 &lt;code&gt;.content&lt;/code&gt; 元素设置 &lt;code&gt;vertical-align: middle;&lt;/code&gt; 来调整多行文本的垂直位置，从而实现我们想要的“垂直居中”效果。这种方式也适用于 &lt;code&gt;图片等替换元素&lt;/code&gt; 的垂直居中效果。当然这里的“垂直居中”也是近似的，这是由于 vertical-align 导致的，具体为什么可以深入了解 &lt;code&gt;vertical-align: middle;&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;块级元素&quot;&gt;块级元素&lt;/h2&gt;
&lt;p&gt;依然先把基础代码写出来：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;main&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;content&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;我是要居中的块级元素div&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.main&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#50ba8b&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;150px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;150px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#5b4d4e&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;class 为 &lt;code&gt;.main&lt;/code&gt; 的 div 包裹这一个 class 为 &lt;code&gt;.content&lt;/code&gt; 的 块级元素 div，我们的目的就是要让 &lt;code&gt;.content&lt;/code&gt; 元素 在 &lt;code&gt;.main&lt;/code&gt; 元素中居中。&lt;/p&gt;
&lt;h3 id=&quot;position-margin-auto&quot;&gt;position + margin: auto&lt;/h3&gt;
&lt;p&gt;实现代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.main&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#50ba8b&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;co&quot;&gt;/*关键代码*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;150px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;150px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#5b4d4e&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;/*关键代码*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;absolute&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;left:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;bottom:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;right:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实现原理：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置 &lt;code&gt;.main&lt;/code&gt; 元素为相对定位 &lt;code&gt;position: relative;&lt;/code&gt;，这样其子元素设置绝对定位时就相对它了。&lt;/li&gt;
&lt;li&gt;然后设置 &lt;code&gt;.content&lt;/code&gt; 元素为绝对定位 &lt;code&gt;position: absolute;&lt;/code&gt; 并设置它的 &lt;code&gt;top&lt;/code&gt;、&lt;code&gt;left&lt;/code&gt;、&lt;code&gt;bottom&lt;/code&gt;、&lt;code&gt;right&lt;/code&gt; 都为0，这样该元素的元素的尺寸表现为“格式化宽度和格式化高度”，和 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 的“正常流宽度”一样，同属于外部尺寸，也就是尺寸自动填充父级元素的可用尺寸，但由于此时我们设置了 &lt;code&gt;.content&lt;/code&gt; 元素的宽高，就限制了元素自动填充，这样就多出来150px的空间了。&lt;/li&gt;
&lt;li&gt;最后我们设置 &lt;code&gt;.content&lt;/code&gt; 元素为 &lt;code&gt;margin: auto;&lt;/code&gt; ，此时根据 auto 的计算规则，将上下左右剩余空间全部等分了，自然就居中了。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;position-margin-lefttop&quot;&gt;position + margin-left/top&lt;/h3&gt;
&lt;p&gt;实现代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.main&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#50ba8b&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;co&quot;&gt;/*关键代码*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;150px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;150px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#5b4d4e&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;/*关键代码*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;absolute&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;left:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;margin-left:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;-75px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;margin-top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;-75px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实现原理：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置 &lt;code&gt;.main&lt;/code&gt; 元素为相对定位 &lt;code&gt;position: relative;&lt;/code&gt;，这样其子元素设置绝对定位时就相对它了。&lt;/li&gt;
&lt;li&gt;然后设置 &lt;code&gt;.content&lt;/code&gt; 元素为绝对定位 &lt;code&gt;position: absolute;&lt;/code&gt; 并设置 &lt;code&gt;top: 50%;&lt;/code&gt;、&lt;code&gt;left: 50%;&lt;/code&gt;，这样&lt;code&gt;.content&lt;/code&gt; 元素的左上角就位于 &lt;code&gt;.main&lt;/code&gt; 元素的中心了。&lt;/li&gt;
&lt;li&gt;最后设置 &lt;code&gt;.content&lt;/code&gt; 元素 &lt;code&gt;margin-left: -75px;&lt;/code&gt;、&lt;code&gt;margin-top: -75px;&lt;/code&gt; 将自身左移及上移宽高的一半，这样 &lt;code&gt;.content&lt;/code&gt; 元素的中心处于 &lt;code&gt;.main&lt;/code&gt; 元素的中心处，自然就实现了居中效果。&lt;/li&gt;
&lt;li&gt;这种方法的缺点就是需要固定 &lt;code&gt;.content&lt;/code&gt; 元素的宽高。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;position-translate&quot;&gt;position + translate&lt;/h3&gt;
&lt;p&gt;实现代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.main&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#50ba8b&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;co&quot;&gt;/*关键代码*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;150px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;150px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#5b4d4e&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;/*关键代码*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;absolute&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;left:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;transform:&lt;/span&gt; translate(&lt;span class=&quot;dt&quot;&gt;-50%&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;-50%&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实现原理：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置 &lt;code&gt;.main&lt;/code&gt; 元素为相对定位 &lt;code&gt;position: relative;&lt;/code&gt;，这样其子元素设置绝对定位时就相对它了。&lt;/li&gt;
&lt;li&gt;然后设置 &lt;code&gt;.content&lt;/code&gt; 元素为绝对定位 &lt;code&gt;position: absolute;&lt;/code&gt; 并设置 &lt;code&gt;top: 50%;&lt;/code&gt;、&lt;code&gt;left: 50%;&lt;/code&gt;，这样&lt;code&gt;.content&lt;/code&gt; 元素的左上角就位于 &lt;code&gt;.main&lt;/code&gt; 元素的中心了。&lt;/li&gt;
&lt;li&gt;最后设置 &lt;code&gt;.content&lt;/code&gt; 元素 &lt;code&gt;transform: translate(-50%, -50%);&lt;/code&gt; 将自身左移及上移宽高的一半，这样 &lt;code&gt;.content&lt;/code&gt; 元素的中心处于 &lt;code&gt;.main&lt;/code&gt; 元素的中心处，自然就实现了居中效果。&lt;/li&gt;
&lt;li&gt;这种方法的好处就是不需要固定 &lt;code&gt;.content&lt;/code&gt; 元素的宽高。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;flexbox&quot;&gt;Flexbox&lt;/h3&gt;
&lt;p&gt;实现代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.main&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#50ba8b&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;/*关键代码*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;150px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;150px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#5b4d4e&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;/*关键代码*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实现原理：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置 &lt;code&gt;.main&lt;/code&gt; 元素 &lt;code&gt;display: flex;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;然后设置 &lt;code&gt;.content&lt;/code&gt; 元素为 &lt;code&gt;margin: auto;&lt;/code&gt; 即可实现居中。&lt;/li&gt;
&lt;li&gt;这是毋庸置疑的最佳解决方案，我们不需要设置 &lt;code&gt;.content&lt;/code&gt; 元素为绝对定位，&lt;code&gt;margin: auto&lt;/code&gt; 自然就可以作用于宽高，而且我们也不需要设置 &lt;code&gt;.content&lt;/code&gt; 元素的宽高， 因为Flexbox(伸缩盒)是专门针对这类需求所设计的。&lt;/li&gt;
&lt;li&gt;缺点就是目前浏览器支持程度相对其它方式会低些。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Flexbox 的另一个好处在于，它还可以将匿名容器(即没有被标签包裹的文本节点)垂直居中。比如我们不设置 &lt;code&gt;.main&lt;/code&gt; 元素为 &lt;code&gt;display: flex;&lt;/code&gt;，而是设置 &lt;code&gt;.content&lt;/code&gt; 元素为 &lt;code&gt;display: flex;&lt;/code&gt;，并借助 Flexbox 规范所引入的 align-items 和 justify-content 属性，我们可以让它内部的文本也实现居中（我们可以对&lt;code&gt;.main&lt;/code&gt; 元素使用相同的属性来使 &lt;code&gt;.content&lt;/code&gt; 元素元素居中，但比 &lt;code&gt;margin: auto&lt;/code&gt; 方法要更加优雅一些，并且同时起到了回退的作用）。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.content&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;150px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;150px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#5b4d4e&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;/*关键代码*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;align-items:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;justify-content:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 28 Apr 2018 13:49:00 +0000</pubDate>
<dc:creator>laixiangran</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laixiangran/p/8969722.html</dc:identifier>
</item>
<item>
<title>Java关键字---this的由来和其三大作用 - 秦学苦练</title>
<link>http://www.cnblogs.com/Qinstudy/p/Qinstudy.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Qinstudy/p/Qinstudy.html</guid>
<description>&lt;p&gt;&lt;strong&gt;【声明】&lt;/strong&gt;欢迎转载，但请保留文章原始出处→_→&lt;/p&gt;
&lt;p&gt;秦学苦练：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Java关键字---this的由来和发挥的作用&quot; href=&quot;http://www.cnblogs.com/Qinstudy/p/Qinstudy.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/Qinstudy/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章来源：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Java关键字---this的由来和发挥的作用&quot; href=&quot;http://www.cnblogs.com/Qinstudy/p/Qinstudy.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/Qinstudy/p/Qinstudy.html&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【正文】 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;秦学苦练博主，你好！我是立志要掌握Java编程语言的一名小白，最近我在学习Java中的面向对象的三大特性（封装、继承、多态）时，常常会碰到this关键词，但书上只是简单讲了this的几个作用，我听得是云里雾里，并没有讲解Java设计者为什么要创建this关键字，是出于一个什么原因创建了this关键字呢？还有this关键字解决了什么问题呢？&lt;/p&gt;
&lt;p&gt;这些都是我的疑惑，至于我为什么问到这些问题，是因为我觉得学习概念不仅仅要学习概念的本身，更重要的是了解、理解知识的由来。再次拜谢博主啦----&lt;a href=&quot;http://www.cnblogs.com/Qinstudy/&quot; target=&quot;_blank&quot;&gt;秦学苦练&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;                                                                                                                                                                                                        Java初学者——小张&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://www.cnblogs.com/Qinstudy/&quot; target=&quot;_blank&quot;&gt;秦学苦练&lt;/a&gt;的回答：&lt;/p&gt;
&lt;p&gt;小张，你好！我刚开始学习this时，也只知道this关键字在程序中有哪些作用，但不知道this关键字怎么产生的？你讲的这句话很好--学习概念不仅仅要学习概念的本身，&lt;strong&gt;更重要的是了解、理解知识的由来&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;你提出了两个问题，我把问题罗列出来：&lt;/p&gt;
&lt;p&gt;1.Java设计者为什么要创建this关键字，是出于一个什么原因创建了this关键字呢？           简言之，this关键字产生的背景&lt;/p&gt;
&lt;p&gt;2.还有this关键字解决了什么问题呢？       简言之，this关键字的作用&lt;/p&gt;

&lt;p&gt;受“更重要的是了解、理解知识的由来”的鼓舞，我去网上查阅了相关资料，&lt;strong&gt;《Java编程思想》（第四版第5章5.4，P84页）&lt;/strong&gt;给出了不错的回答。下面我把书中的知识按照自己的理解讲述一下：&lt;/p&gt;
&lt;p&gt;this关键字可以这么去理解，在英语中，指示代词this，用来指代某个东西，例如：Look,this is  a table.  this指代table。&lt;/p&gt;
&lt;p&gt;在Java语言的设计中，&lt;strong&gt;this&lt;/strong&gt;也是具有&lt;strong&gt;指向关系&lt;/strong&gt;的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. this关键字产生的背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我先来回答，Java设计人员为什么创建了this关键字？我将用一段代码来说明原因。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; speak(){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;           &lt;span&gt;System.out.println(&quot;某一个对象去调用方法&quot;);&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       Person p1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       Person p2=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      p1.speak();     //p1对象去调用speak（）方法
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;      p2.speak();    //p2对象去调用speak（）方法&lt;/span&gt;11 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（亲测）运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;某一个对象去调用方法&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;某一个对象去调用方法&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;但是，当只有一个speak（）方法，编译器如何知道speak（）方法是被p1还是被p2所调用的呢？为了能用简便、面向对象的语法来编写代码--即“发送消息给对象”，编译器做了一些幕后工作。它&lt;strong&gt;暗自把”所操作对象的引用”作为第一个参数&lt;/strong&gt;传递给speak（）方法。所以上述调用后的方法变成了这样：&lt;/p&gt;
&lt;p&gt;Person speak(p1);&lt;/p&gt;
&lt;p&gt;Person speak(p2);&lt;/p&gt;
&lt;p&gt;这是&lt;strong&gt;内部的表现形式&lt;/strong&gt;。如果我们这样写，编译器会报错，但这种写法会帮助你去理解编译器所做的事。假设你希望在方法的内部获得对当前对象的引用，由于这个引用是编译器“偷偷”传入的，所以没有标识符可用。&lt;/p&gt;
&lt;p&gt;于是，为了解决‘&lt;strong&gt;在方法的内部获得对当前对象的引用&lt;/strong&gt;’这一背景问题，Java设计师专门设计了&lt;strong&gt;this关键字，用来在方法的内部获得对当前对象的引用&lt;/strong&gt;。this关键字只能在方法内部使用，表示对&lt;strong&gt;&quot;调用方法的那个对象“的引用&lt;/strong&gt;。可以这么说，&lt;strong&gt;this的用法和其他new出来对象的引用并无不同&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但要注意，如果在方法内部调用同一个类的另一个方法时，可以省略this，直接调用即可。因为当前方法中的this引用会自动应用于同一类中的其他方法。所以小张你可以这样写代码，编译器是不会报错的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;p&gt;class Person{&lt;br/&gt;  public void speak(){}&lt;br/&gt;  public void eat(){&lt;br/&gt;   //在方法内部调用同一个类的另一个方法时，可以省略this，直接调用即可。&lt;br/&gt;    speak(); //&lt;strong&gt;编译器自动翻译成this.speak（）。&lt;/strong&gt;&lt;br/&gt;  }&lt;br/&gt;  public static void main(String[] args){&lt;br/&gt;  }&lt;br/&gt;}&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这就是this关键字为什么产生了，小张啊，总而言之，this关键字产生的背景：&lt;strong&gt;为了解决‘在方法的内部获得对当前对象的引用’这一问题&lt;/strong&gt;。this关键字被设计出来了，用来在方法的内部获得对当前对象的引用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.this关键字的作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;三大作用：&lt;/p&gt;
&lt;p&gt;     1） &lt;span&gt;&lt;span&gt;区分局部变量和成员变量同名情况&lt;/span&gt;&lt;strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;this.成员变量&lt;/strong&gt;调用本类中的成员变量&lt;/span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     2）&lt;span&gt;通过&lt;strong&gt;this.方法（）&lt;/strong&gt;调用本类中的方法&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   &lt;/strong&gt; 3）&lt;strong&gt;this&lt;span&gt;在构造方法之间的调用。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小张啊，也许你看了这三大作用，可能还是云&lt;span&gt;里雾里。你在信中，说自己在学习Java中的面向对象的三大特性&lt;strong&gt;（&lt;/strong&gt;&lt;/span&gt;封装、继承、多态），所以我认为你已经懂了private封装、extends继承，并且&lt;/p&gt;
&lt;p&gt;知道set、get方法，和空参、有参构造方法的相关概念。下面这个程序需要你有上面的这些基础，如果你暂时没有这些基础，不用着急，先去看看这些基础。看懂这些基础后，你再回过头来，看下面的代码，你会有种豁然开朗的顿悟！&lt;/p&gt;
&lt;p&gt;如果你已经有了上面这些基础，下面我用一个完整的程序将this关键字的三大作用讲清楚。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; day_12;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Person类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
      
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person(String name){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String name中的&lt;strong&gt;name是局部变量
         &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  this的作用1：区分局部变量和成员变量同名情况&lt;/span&gt;
          &lt;span&gt;this&lt;/span&gt;.name=name; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;this.name中的&lt;strong&gt;name是成员变量&lt;/strong&gt;&lt;/span&gt;
&lt;span&gt;      }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person(String name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age){
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;作用3：this关键字在构造方法间的调用&lt;/span&gt;
          &lt;span&gt;this&lt;/span&gt;(name);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用this(name)去调用只有一个参数 name的构造方法&lt;/span&gt;
          &lt;span&gt;this&lt;/span&gt;.age=&lt;span&gt;age;
      }
      
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name){
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
      }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName(){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
      }
      
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(){
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age=&lt;span&gt;age;
      }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge(){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
      }      
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; day_12;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Worker类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Worker &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Person {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Worker(String name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age){
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name,age);  //super(name,age) 调用父类Person的具有两个参数的构造方法。
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;作用2：&lt;strong&gt;this在方法中的使用&lt;/strong&gt;&lt;/span&gt;
        System.out.println(&lt;span&gt;this&lt;/span&gt;.getName()+&quot;在砍树！&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;strong&gt;this.getName() 有封装的思想在里面&lt;/strong&gt;。由于不知道调用getName（）方法的对象是谁，我就用模糊的概念，&lt;strong&gt;哪个对象去调用work（）方法，this就指代哪个对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很显然，Worker类的对象wk去调用work()方法，那&lt;strong&gt;this就指向了wk对象&lt;/strong&gt;。所以用this.getName()来获得wk对象中的属性：光头强。&lt;/p&gt;
&lt;p&gt;//测试类：Test&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; day_12;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
       Worker wk&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Worker(&quot;光头强&quot;,28&lt;span&gt;);
       wk.work();   
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（亲测）运行结果：&lt;strong&gt;光头强在砍树&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.方法论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小张，很高兴，你能提出这样两个问题，这两个问题促使我去思考this关键字产生的背景以及this的三大作用。给你讲述了this之后，我觉得自己对this的理解又加深了！小张啊，以后在Java学习过程中遇到云里雾里的问题，尽管给我写信，只要是我能弄明白的，一定平铺直叙地讲清楚。学习一门语言，多思考、常总结是不错的状态，与你共勉！&lt;/p&gt;

</description>
<pubDate>Sat, 28 Apr 2018 12:40:00 +0000</pubDate>
<dc:creator>秦学苦练</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Qinstudy/p/Qinstudy.html</dc:identifier>
</item>
</channel>
</rss>