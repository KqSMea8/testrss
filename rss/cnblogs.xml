<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>字符串匹配「 KMP 算法 」 - Mystical-W</title>
<link>http://www.cnblogs.com/bljfy/p/9570592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bljfy/p/9570592.html</guid>
<description>&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;众所周知，字符串无论是在 OI 中还是别的计算机领域都占有比较大的比重，今天说的就是一个关于匹配字符串的算法——「 KMP 算法 」。&lt;/p&gt;

&lt;h2&gt;0x00&lt;/h2&gt;
&lt;p&gt;KMP 算法用于解决这样的一类问题：给定一个文本串 T 和模式串 S，要求你求出 S 在 T 中出现的次数和位置(我们定义位置为 S 中第一个字符在 T 中匹配到的位置)&lt;/p&gt;
&lt;p&gt;当然它还有许多别的用法。具体的可以通过一道题目来体现一下 &lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=3336&quot; target=&quot;_blank&quot;&gt;HDU 3336&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;0x01&lt;/h2&gt;
&lt;p&gt;我们都知道朴素的匹配字符串的算法，不知道的看下面这个例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;文本串:ＡＢＡＤＣＡＤＣＡＢ
模式串:ＡＤＣＡＢ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;A 和 A 匹配，比较下一位。一直到发现 B 和 D 不匹配。&lt;/li&gt;
&lt;li&gt;不匹配就将模式串后移一位。&lt;/li&gt;
&lt;li&gt;A 和 B 不匹配，重复之前的过程直到匹配完成。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是我们发现下面这种情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ＡＢＡＢＣＡＤＣＡＢ
　　ＡＤＣＡＢ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一位 B 和 D 并不能匹配。但是按照朴素算法的话会将模式串一位一位的往后移动。&lt;/p&gt;
&lt;p&gt;直到出现下面的情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ＡＢＡＢＣＡＤＣＡＢ
　　　　　ＡＤＣＡＢ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;试想，如果在第五位失配后我们可以直接将模式串的第一位直接移动到第四位。&lt;/p&gt;
&lt;p&gt;虽然我们能够看出这样很简单，但如何让计算机也看出来呢？&lt;/p&gt;
&lt;p&gt;这里我们引入一个 $next$ 数组，通俗的说，$next[i]$ 含义就是长度为 $i$ 的模式串前缀的前缀和后缀所共有的最长的字串。&lt;/p&gt;
&lt;p&gt;我们先不说 $next$ 数组怎样求，先来说说它怎么用。&lt;/p&gt;
&lt;p&gt;是不是很绕口呢&lt;/p&gt;
&lt;p&gt;我们看看这句话是啥意思&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;模式串：ＡＤＣＡＢ
前缀：Ａ，ＡＤ，ＡＤＣ，ＡＤＣＡ
后缀：Ｂ，ＡＢ，ＣＡＢ，ＤＣＡＢ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个就是在一个长度为 $5$ 的前缀中所有的前缀和后缀&lt;/p&gt;
&lt;p&gt;我们看这些前后缀中有哪些是满足有共同的元素的&lt;/p&gt;
&lt;p&gt;只有下面这两个&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ＡＤ，ＡＢ
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它们返回的 $next$ 值是 $1$，也就是说在第五位失配之后，第一位就会跳到第四位去继续匹配。&lt;/p&gt;

&lt;h2&gt;0x02&lt;/h2&gt;
&lt;p&gt;这个 next 数组怎么求出来的。&lt;/p&gt;
&lt;p&gt;我们试图让模式串自己匹配自己。&lt;/p&gt;
&lt;p&gt;说到这里大概就知道为什么之前不告诉大家怎么求 $next$ 数组了吧？&lt;/p&gt;
&lt;p&gt;因为这个 $next$ 数组会用了就会求了。而两者相比的话，「 用 」这一方面比较简单好理解&lt;/p&gt;
&lt;p&gt;看下面这个求 $next$ 数组的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Getnext() {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;; i&amp;lt;=n; i++&lt;span&gt;) {
        p &lt;/span&gt;= nxt[i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;i的前一位在失配后哪一位会跳过来&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(p &amp;amp;&amp;amp; s[p+&lt;span&gt;1&lt;/span&gt;] != s[i]) p =&lt;span&gt; nxt[p];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果next[i]这一位还是不能和s[i]匹配，那就继续往前跳
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这句话中p!=0表示如果跳到第一位就可以不用跳了&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(s[p+&lt;span&gt;1&lt;/span&gt;] == s[i]) nxt[i] = p+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果找到了能够匹配的，就更新next[i]&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; nxt[i] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找不到就是0&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面贴一下完整的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstring&amp;gt;
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn = 1e6+&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, m, next[maxn], p;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; T[maxn], S[maxn];
inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Getnext() {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;; i&amp;lt;=n; i++&lt;span&gt;) {
        p &lt;/span&gt;= next[i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(p &amp;amp;&amp;amp; s[p+&lt;span&gt;1&lt;/span&gt;] != s[i]) p =&lt;span&gt; next[p];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s[p+&lt;span&gt;1&lt;/span&gt;] == s[i]) next[i] = p+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; next[i] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, T+&lt;span&gt;1&lt;/span&gt;, S+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    n &lt;/span&gt;= strlen(T+&lt;span&gt;1&lt;/span&gt;), m = strlen(S+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    Getnx();
    p &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;; i&amp;lt;=n; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p &amp;amp;&amp;amp; T[i] != S[p+&lt;span&gt;1&lt;/span&gt;]) p =&lt;span&gt; next[p];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(T[i] == S[p+&lt;span&gt;1&lt;/span&gt;]) p++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; p = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(p == m) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i-m+&lt;span&gt;1&lt;/span&gt;), p =&lt;span&gt; next[p];
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;; i&amp;lt;=m; i++&lt;span&gt;) {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, next[i]);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 01 Sep 2018 07:38:00 +0000</pubDate>
<dc:creator>Mystical-W</dc:creator>
<og:description>引言 众所周知，字符串无论是在 OI 中还是别的计算机领域都占有比较大的比重，今天说的就是一个关于匹配字符串的算法——「 KMP 算法 」。 0x00 KMP 算法用于解决这样的一类问题：给定一个文本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bljfy/p/9570592.html</dc:identifier>
</item>
<item>
<title>基于三角网格排序的人体三围测量算法 - xiconxi</title>
<link>http://www.cnblogs.com/xiconxi/p/9570192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiconxi/p/9570192.html</guid>
<description>&lt;p&gt;  本文讨论的范围不包含几何重建、纹理重建，仅包含基于已有的人体三维三角网格模型(下称人体三角网格)的三维测量算法。围度测量实际上是对三维模型与特定平面求交，并对交集进一步分析其交集的特定闭合部分(若存在多个闭合部分)的轮廓周长和面积等数据，即求三维网格的切片。国标GB/T 16160-2008《服装用人体测量的部位及方法》中给出了人体各尺寸特征的与人身高的比例数据(下称特征比例)，求出特定比例处与身高方向构成的点法式平面与三维网格的切片即可进一步得到特定特征的具体数值。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;人体三角网格的坐标系矫正&quot;&gt;1.1 人体三角网格的坐标系矫正&lt;/h3&gt;
&lt;p&gt;  假定人体三角网格的坐标系中Z轴方向为人角的中点与头顶中心构成的方向向量，而手持扫描仪获取到的人体三角网格的坐标系取决于首次扫描的朝向，因此网格的Z轴方向与正确的坐标系有误差，需要通过额外的工作进行坐标轴的矫正。&lt;/p&gt;&lt;p&gt;  本文采用的核心方法为PCA(Principal Component Analysis)。对于手臂与身体躯干的面元粘连问题，可通过扫描目标张开手臂进行规避，而此时扫描目标人站立并张开手臂时的高低肩会影响PCA坐标矫正的效果。影响PCA算法的主要部分为手臂部分三维点，去除手臂部分三维点进行二次PCA算法即可。简单地可以通过特定的比例关系选取，亦可通过三维点到Z轴的距离选取。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三角网格切片算法&quot;&gt;1.2 三角网格切片算法&lt;/h3&gt;
&lt;h4 id=&quot;基于排序的三角网格切片算法&quot;&gt;1.2.1 基于排序的三角网格切片算法&lt;/h4&gt;
&lt;p&gt;  基于三角网格的切片算法可分为两类。一是基于半边数据结构的三角网格切片算法，假定半边结构半边对象为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct HE_edge{
    HE_vert* from;
    HE_vert* to;
    HE_edge* pair;   // oppositely oriented adjacent half-edge 
    HE_edge* next;   // next half-edge around the face
    ...               // other members
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且此时获取到了平面plane与指定片面相交的起始半边&lt;em&gt;s&lt;/em&gt;, 可知算法的结果为从&lt;em&gt;s&lt;/em&gt;出发的一个半边序列,那么算法可以简单描述为&lt;em&gt;HE_Slice(s-&amp;gt;pair,*)&lt;/em&gt;，通过循环去递归可进一步优化:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void HE_Slice(HE_edge* curr, std::vector&amp;lt;glm::vec3&amp;gt;&amp;amp; res){
    if(curr-&amp;gt;next == s || curr-&amp;gt;next-&amp;gt;next == s) return ;
    for(auto e: {e-&amp;gt;next, e-&amp;gt;next-&amp;gt;next}) {
        if(is_intersect(e,plane)) {
            ... // calculate and store the intersection
            HE_Slice(e-&amp;gt;pair, res);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;基于排序的三角网格切片算法-1&quot;&gt;1.2.2 基于排序的三角网格切片算法&lt;/h4&gt;
&lt;p&gt;  基于半边数据结构的切片算法是高效的，但半边数据结构的维持需要较多的内存支持且构建耗时_O(n*log(n))_、只提供了局部拓扑信息不能支持按身高比例高效获取特定半边。上述两个缺点均可通过下面介绍的面元排序解决。考虑到人体三角网格与平面plane的交集可以为多个闭合部分(手与躯干、双脚),半边结构能且只能获取到给定的初始半边所在闭合部分，不能获得指定平面与三角网格的交集的闭合部分的数量(下称闭合数)。算法框架如下:&lt;br/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 对共享顶点结构的三角网格进行排序
2. 通过二分查找确定需要与平面求交的有序面元的最小子序列
3. 遍历子序列，生成平面与三角形面元的边的交的集合,集合元素为{A,B,k},其中A,B为边的顶点索引，k为相交系数。
4. 通过选择排序对3.生成的集合完成有序化，并得到闭合部分的划分。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  参与切片算法的最小几何元素为边，因此对三角网格排序应当等价于对三角形面元排序。排序算法简单描述如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 1. 对共享顶点结构的三角网格进行排序
void sortByVector(TriMesh *mesh, glm::vec3 x) {
    std::sort(mesh-&amp;gt;f.begin(), mesh-&amp;gt;f.end(), [=](glm::ivec3&amp;amp; e1, glm::ivec3&amp;amp; e2){
        return glm::dot(mesh-&amp;gt;v[e1[0]] - mesh-&amp;gt;v[e2[0]], x) &amp;gt; 0;
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  易知实际中参与切片算法的面元是排序后的面元序列的一个子序列，当给出切片平面(点法式平面，法向量为Z轴)和面元在Z轴上的最大投影距离_gap_时，子序列提取算法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 2. 通过二分查找确定需要与平面求交的面元的最小有序子序列
std::array&amp;lt;std::vector&amp;lt;glm::ivec3&amp;gt;::iterator,2&amp;gt; getSliceInterval(TriMesh* mesh,glm::vec3 n, float d, float gap) {
    std::array&amp;lt;std::vector&amp;lt;glm::ivec3&amp;gt;::iterator,2&amp;gt; result = {
        std::lower_bound(mesh-&amp;gt;f.begin(),mesh-&amp;gt;f.end(), d-gap,
            [=](glm::ivec3&amp;amp; e1,float v){
        return v &amp;lt; glm::dot(mesh-&amp;gt;v[e1[0]], n);
    }), std::lower_bound(mesh-&amp;gt;f.begin(),mesh-&amp;gt;f.end(), d+gap,
            [=](glm::ivec3&amp;amp; e1,float v){
        return v &amp;lt; glm::dot(mesh-&amp;gt;v[e1[0]], n);
    })};

    if(result[0] &amp;gt; result[1]) std::swap(result[0],result[1]);
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  确定子序列的边界，切片算法便只需要极少的面元与特定平面求交。面元与平面的相交判定与交线等几何计算如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool isFaceInersected(TriMesh* mesh,glm::ivec3 f, glm::vec3 n, float d){
    int flags = ((glm::dot( mesh-&amp;gt;v[f[0]], n ) &amp;gt; d)+(glm::dot( mesh-&amp;gt;v[f[1]], n ) &amp;gt; d)+(glm::dot( mesh-&amp;gt;v[f[2]], n ) &amp;gt; d));
    return flags ==  1 || flags == 2;
}

std::array&amp;lt;glm::vec3,2&amp;gt; getFaceIntersection(TriMesh* mesh,glm::ivec3 f, glm::vec3 n, float d){
    std::array&amp;lt;glm::vec3,2&amp;gt; result;
    int size = 0;
    // dot(N, P1) + dot(N, t*(P1-P2) ) = d  // 0 &amp;lt; t &amp;lt; 1
    for(int i:{0,1,2})  {
        double numerator   =  d - glm::dot( mesh-&amp;gt;v[f[i]], n);
        double denominator = glm::dot( mesh-&amp;gt;v[f[i==2?0:i+1]] - mesh-&amp;gt;v[f[i]], n );
        if(abs(denominator) &amp;gt; 1e-8) {
            numerator /= denominator;
            if(numerator &amp;gt;= 0 &amp;amp;&amp;amp; numerator &amp;lt;= 1.0) {
                result[size++] = glm::vec3(f[i],f[i==2?0:i+1],numerator);
            }
        }
    }
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  3.得到的线段是无序的，不能够满足后续操作，如闭合数、特定闭合部分的平滑、特定部分的周长面积等几何特征的计算，故需要对3.的结果有序化。考虑到实际网格规模下的交线的规模往往低于10000,算法设计采用了选择排序，算法复杂度为_O(n*log(n))_,简单描述如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//4. 通过选择排序对3.生成的集合完成有序化，并得到闭合部分的划分。
std::vector&amp;lt;std::array&amp;lt; std::vector&amp;lt;std::array&amp;lt;glm::vec3,2&amp;gt;&amp;gt;::iterator,2&amp;gt;&amp;gt; sortContours(std::vector&amp;lt;std::array&amp;lt;glm::vec3,2&amp;gt;&amp;gt;&amp;amp;&amp;amp; intersections) {
    std::vector&amp;lt;std::array&amp;lt; std::vector&amp;lt;std::array&amp;lt;glm::vec3,2&amp;gt;&amp;gt;::iterator,2&amp;gt;&amp;gt; intervals = {{intersections.begin(),intersections.begin()}};
    for(auto it = intersections.begin(); it != intersections.end(); it++) {
        auto find_it = std::find_if(std::next(it), intersections.end(), [=](std::array&amp;lt;glm::vec3,2&amp;gt;&amp;amp; e){
            return  (e[0][0] == (*it)[1][1] &amp;amp;&amp;amp; e[0][1] == (*it)[1][0]) || (e[0][0] == (*it)[0][1] &amp;amp;&amp;amp; e[0][1] == (*it)[0][0])
                    ||(e[1][0] == (*it)[0][1] &amp;amp;&amp;amp; e[1][1] == (*it)[0][0]) || (e[1][0] == (*it)[1][1] &amp;amp;&amp;amp; e[1][1] == (*it)[1][0]);
        });
        if(find_it != intersections.end()) {
            std::swap(*std::next(it),*find_it);
        }else{
            (*std::prev(intervals.end()))[1] = std::next(it);
            if(it != std::prev(intersections.end()))
                intervals.push_back({std::next(it),std::next(it)});
        }
    }
    return intervals;
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  到此，基于排序的切片算法基本原理和实现已介绍完毕。具体的代码实现可见本人git仓库&lt;a href=&quot;https://github.com/xiconxi/YubaMesh&quot;&gt;yubaMesh&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Sep 2018 06:17:00 +0000</pubDate>
<dc:creator>xiconxi</dc:creator>
<og:description>  本文讨论的范围不包含几何重建、纹理重建，仅包含基于已有的人体三维三角网格模型(下称人体三角网格)的三维测量算法。围度测量实际上是对三维模型与特定平面求交，并对交集进一步分析其交</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiconxi/p/9570192.html</dc:identifier>
</item>
<item>
<title>小功能大用处 ---- 一键检测各服务器是否存活 - 任小为</title>
<link>http://www.cnblogs.com/wellful/p/9569816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wellful/p/9569816.html</guid>
<description>&lt;p&gt;工作中会遇到判断服务器是否存活的场景，比如：批量重启服务器后，各宿主机或虚拟机是否启动成功。&lt;/p&gt;
&lt;p&gt;检测服务器是否存活的原理很简单：先检查服务器是否通（ping）；如果不通则检查服务器上的服务是否通，如果服务也不通，则说明这台服务器没有开启。可以使用的工具有：ping、telnet、nmap或者tcping等。&lt;/p&gt;
&lt;p&gt;nmap功能强大，用处广泛；tcping可以在服务器禁ping的情况下检查机器是否存活（比如windows机器默认就是禁ping的）。在这里，我用的是ping和telnet组合。&lt;/p&gt;
&lt;p&gt;关于ping工具，合理的使用相关参数比较有利于排查问题，比如：&quot;-c&quot;参数可以用来限制发送ping多少个包，&quot;-i&quot;参数可以用来限制ping的频率等。举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
ping -c2 -i0.02 www.baidu.com &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上一段代码意思为：以0.02秒的间隔时间ping www.baidu.com 2次，并将结果（正确或错误）引入到“黑洞”（丢弃），合理的使用参数可以帮助我们快速判断目标主机是否可达。当然，会有人问：你将测试结果引入到黑洞，我怎么知道目标主机是通还是不通呢？这个时候可以通过判断操作状态得知，命令为：&lt;/p&gt;

&lt;p&gt;　　如果上面的结果返回值为0，说明www.baidu.com可达，否则www.baidu.com可能不通，需要进行下一步再判断。有人说，通过手动执行命令麻烦，可否再精巧些？那就写成脚本吧，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
#!/bin/bash
# test.

ping -c2 -i0.02 www.baidu.com &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
if [ $? -eq 0 ];then
    echo &quot;Host can access ....&quot;
else
    ...
fi
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　解释上面那段脚本，如果主机不通，则执行后续动作，这些后续动作放在&quot;else&quot;代码块中，后续动作可以使用nmap、telnet等工具，这里介绍telnet。&lt;/p&gt;
&lt;p&gt;有人会说，telnet容易，如果telnet程序一直卡在那里则说明服务器端口不通，然后通过“CTRL+c”终止就行了，但是怎样在脚本中使用telnet呢？简单，通过Linux的管道功能（“|”），可以让脚本沉睡一段时间，这段时间内telnet执行任务，待沉睡时间到期则终止telnet程序。话虽如此，怎样实现呢？如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
(sleep 1;) | telnet www.baidu.com 80 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　判断某台服务器是否存活，可以先ping IP，再telnet port，如果是测试一个IP，则可将脚本写成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
#!/bin/bash
# test.

host= www.baidu.com
port=80
telnet_file=/tmp/telnet_file.txt

ping -c2 -i0.02 $host &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
if [ $? -eq 0 ];then
    echo &quot;$host can access ....&quot;
else
    (sleep 1;) | telnet $host $port &amp;gt; $telnet_file
    grep -B 1 \] $telnet_file &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
    if [ $? -eq 0 ];then
        echo &quot;$host can access ...&quot;
    else
        echo &quot;$host can not access !!!&quot;&lt;br/&gt;fi
fi
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的脚本是针对一个IP进行判断，说实话如果是判断一台服务器是否可达的话直接终端敲命令就知道了，不需要“大费周折”写脚本了，但是如果同时测试多台机器就需要用到脚本了。对于编写批量判断多台主机是否可达的脚本，只需要将上述思路稍作整理，灵活使用linux基础命令即可实现。当然，如果目标机器非常多的情况下，推荐使用ansible或者saltstack，或者干脆写个python多进程的脚本去判断。&lt;/p&gt;
&lt;p&gt;下面贴出我之前基于ping和telnet工具写的脚本，大致原理和上面讲述的相似，在执行脚本前，请先编辑服务器配置文件。&lt;/p&gt;
&lt;p&gt;执行脚本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
renxiaowei$ cat check.sh

#!/bin/bash
# 功能：一键检测宿主机、虚拟机是否存活
# 作者：任小为
# 版本：v1.0

file=server.txt
result_base=/tmp/check_host_net

rm -rf $result_base
mkdir -p $result_base

super_host(){
    super_ip_list=${result_base}/super_ip_list.txt
    super_alive=${result_base}/super_alive.txt
    super_die=${result_base}/super_die.txt
    super_telnet=${result_base}/super_telnet.txt

    echo &quot;&quot;
    echo -e &quot;\033[44;36m检测宿主机是否存活... \033[0m&quot;

    egrep -v &quot;#|^$&quot; $file | awk '{print $1,$2}' | uniq &amp;gt; $super_ip_list

    count=0
    for ip in $(cat ${super_ip_list} | awk '{print $1}');do
        let count++
        echo &quot;count=$count&quot;

        ping -c 2 -i 0.02 $ip &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
        if [ $? -eq 0 ];then
            echo $ip &amp;gt;&amp;gt; ${super_alive}
        else
            super_port=`grep $ip ${super_ip_list} | awk '{print $2}'`
            (sleep 1;) | telnet $ip ${super_port} &amp;gt;&amp;gt; ${super_telnet}
        fi
    done

    if [ -e ${super_telnet} ];then
        super_ip=${result_base}/super_ip.txt
        cat ${super_ip_list} | awk '{print $1}' &amp;gt; ${super_ip}

        cat ${super_telnet} | grep -B 1 \] | grep [0-9] | awk '{print $3}' | cut -d '.' -f 1,2,3,4 &amp;gt;&amp;gt; ${super_alive}
        cat ${super_ip} ${super_alive} | sort | uniq -u &amp;gt; ${super_die}
    fi

    echo &quot;&quot;
    echo -e &quot;\033[32;49;1m存活的宿主机: \033[31;49;0m&quot;
    echo -e &quot;`cat ${super_alive}`\n&quot;
    
    if [ -s ${super_die} ];then
        echo -e &quot;\033[31;49;1m检测不通的宿主机:\033[31;49;0m&quot;
        echo -e &quot;\033[31;49;1m`cat ${super_die}`\033[31;49;0m\n&quot;
    else
        echo -e &quot;\033[44;36m所有宿主机都存活.\033[0m\n&quot;
    fi
}

sub_host(){
    sub_ip_list=${result_base}/sub_ip_list.txt
    sub_alive=${result_base}/sub_alive.txt
    sub_die=${result_base}/sub_die.txt
    sub_telnet=${result_base}/sub_telnet.txt

    echo &quot;&quot;
    echo -e &quot;\033[44;36m检测虚拟机是否存活... \033[0m&quot;

    egrep -v &quot;#|^$&quot; $file | awk '{print $3,$4}' | uniq &amp;gt; $sub_ip_list

    sub_count=0
    for sub_ip in $(cat ${sub_ip_list} | awk '{print $1}');do
        let sub_count++
        echo &quot;count=${sub_count}&quot;

        ping -c 2 -i 0.02 ${sub_ip} &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
        if [ $? -eq 0 ];then
            echo ${sub_ip} &amp;gt;&amp;gt; ${sub_alive}
        else
            sub_port=`grep ${sub_ip} ${sub_ip_list} | awk '{print $2}'`
            (sleep 1;) | telnet ${sub_ip} ${sub_port} &amp;gt;&amp;gt; ${sub_telnet}
        fi
    done

    if [ -e ${sub_telnet} ];then
        sub_ip=${result_base}/sub_ip.txt
        cat ${sub_ip_list} |awk '{print $1}' &amp;gt; ${sub_ip}

        cat ${sub_telnet} | grep -B 1 \] | grep [0-9] | awk '{print $3}' | cut -d '.' -f 1,2,3,4 &amp;gt;&amp;gt; ${sub_alive}
        cat ${sub_ip} ${sub_alive} | sort | uniq -u &amp;gt; ${sub_die}
    fi

    echo &quot;&quot;
    echo -e &quot;\033[32;49;1m存活的虚拟机: \033[31;49;0m&quot;
    echo -e &quot;`cat ${sub_alive}`\n&quot;

    if [ -s ${sub_die} ];then
        echo -e &quot;\033[31;49;1m检测不通的虚拟机:\033[31;49;0m&quot;
        echo -e &quot;\033[31;49;1m`cat ${sub_die}`\033[31;49;0m\n&quot;
    else
        echo -e &quot;\033[44;36m所有虚拟机都存活.\033[0m\n&quot;
    fi
}

case $1 in
    super)
        super_host
        ;;
    vm)
        sub_host
        ;;
    help)
        echo &quot;&quot;
        echo &quot;`grep &quot;功能&quot; $file`&quot;
        echo &quot;super选项代表检测宿主机;&quot;
        echo -e &quot;vm选项代表检测虚拟机.\n&quot;
        ;;
    *)
        echo &quot;&quot;
        echo -e $&quot;Usage: sh $0 { super | vm | help }\n&quot;
esac
exit 0 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;服务器配置文件格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
renxiaowei$ cat server.txt 
#功能：用于一键检测宿主机、虚拟机是否存活的文件
#格式：vm宿主机 ------ 宿主机管理端口 ---- 虚拟机 ---- 虚拟机管理端口

192.168.2.2           80            192.168.2.50     22 
192.168.2.3           80            192.168.2.51     22

192.168.3.2           80            192.168.3.52     22
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　请将脚本、服务器配置文件放在同一个目录下。&lt;/p&gt;
&lt;p&gt;脚本执行方式：chmod + x check.sh &amp;amp;&amp;amp; ./check.sh [super|vm|help] 或者 sh check.sh [super|vm|help] 。&lt;/p&gt;
&lt;p&gt;脚本参数“super”意为宿主机检测；参数“vm”意为虚拟机检测。&lt;/p&gt;

</description>
<pubDate>Sat, 01 Sep 2018 06:11:00 +0000</pubDate>
<dc:creator>任小为</dc:creator>
<og:description>工作中会遇到判断服务器是否存活的场景，比如：批量重启服务器后，各宿主机或虚拟机是否启动成功。 检测服务器是否存活的原理很简单：先检查服务器是否通（ping）；如果不通则检查服务器上的服务是否通，如果服</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wellful/p/9569816.html</dc:identifier>
</item>
<item>
<title>Java 多线程(五）之 synchronized 的使用 - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9569957.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9569957.html</guid>
<description>&lt;p&gt;并发编程为我们带来了很多便利， 但同时也带来了线程安全问题。&lt;/p&gt;
&lt;h3 id=&quot;线程安全&quot;&gt;线程安全&lt;/h3&gt;
&lt;p&gt;线程安全性的定义：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当多个线程访问某一个类时， 这个类始终能表示出正确的行为， 那么就称这个类是线程安全的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其产生的原因可以归结如下：&lt;/p&gt;
&lt;p&gt;1.共享数据： 只有共享的数据才会产生带来安全性问题。 如果是方法内部声明的变量， 其是在虚拟机栈中， 为每个线程独享， 不存在安全性问题。&lt;/p&gt;
&lt;p&gt;2.多个线程对共享数据进行同时操作。多线程对同一共享数据进行同时性的操作，此时共享数据就会影响到彼此。&lt;/p&gt;
&lt;p&gt;由线程安全引起的问题， 在此做一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class UnsafeThread implements Runnable {

    private static int count = 0;
    public void increase(){
        count++;
    }
    public void run() {
        for (int i = 0; i &amp;lt; 2000000; i++) {
            increase();
        }
    }

    public static void main(String[] args) {
        UnsafeThread myThread = new UnsafeThread();
        Thread thread1 = new Thread(myThread);
        Thread thread2 = new Thread(myThread);
        thread1.start();
        thread2.start();
        try {
            thread1.join();
            thread2.join();
            System.out.println(count);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行后， 两个线程， 每个线程对 count 进行了 &lt;code&gt;2000000&lt;/code&gt; 次自增， 预期的结果应该是 &lt;code&gt;4000000&lt;/code&gt;, 然而， 执行后发现结果基本上都不是对的， 每次不一样, 但都比 &lt;code&gt;4000000&lt;/code&gt; 小。为什么？&lt;/p&gt;
&lt;p&gt;i++ 的步骤， 应该是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;读-&amp;gt;改-&amp;gt;写&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是， 如果在一个线程读的时候， 还没写回去， 另一个线程也读了，那么就是有一次操作相当于没有效， 导致最后的结果就会比预期的少了。&lt;/p&gt;
&lt;h3 id=&quot;互斥锁&quot;&gt;互斥锁&lt;/h3&gt;
&lt;p&gt;因此， 为了解决该这些问题， 我们想到的对策：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;消除共享数据： 想法很好， 但有些情况下想要完全的消除是不可能的， 我们只可能尽可能的减少共享数据。&lt;/li&gt;
&lt;li&gt;限定同一时刻， 只有一个线程能对共享数据进行操作， 其他线程需要等到该线程处理完之后再进行操作。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;互斥锁就可以解决这类问题。&lt;/p&gt;
&lt;p&gt;互斥锁的特点&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;线程在进入同步代码块之前会自动获取锁，并且在退出同步代码块时会自动释放锁。&lt;/li&gt;
&lt;li&gt;在同一时刻， 只有一个线程能持有这个锁。当线程 &lt;code&gt;A&lt;/code&gt; 尝试获取一个由线程 &lt;code&gt;B&lt;/code&gt; 持有的锁时， 线程 &lt;code&gt;A&lt;/code&gt; 必须等待或阻塞， 直到线程 &lt;code&gt;B&lt;/code&gt; 释放了这个锁。 如果 &lt;code&gt;B&lt;/code&gt; 不释放这个锁， 则 &lt;code&gt;A&lt;/code&gt; 就需要一直等待。&lt;/li&gt;
&lt;li&gt;可重入性： 指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;内置锁-synchronized&quot;&gt;内置锁 synchronized&lt;/h3&gt;
&lt;p&gt;在本文章， 我们来讨论 Java 所提供的一种内置的互斥锁, 使用 &lt;code&gt;synchronized&lt;/code&gt; 来修饰：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; synchronized(lock){
    // 访问或修改共享数据
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对刚刚的问题， 我们只需要加一个关键字即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public synchronized void increase(){
    count++;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后的输出结果， 必然是 &lt;code&gt;4000000&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;由 &lt;code&gt;synchronized&lt;/code&gt; 修饰的代码块以原子方式（一组语句组成一个不可分割的单元）执行。 任何执行同步代码块的线程， 都看不到其他线程正在执行的由同一个锁保护的同步代码块。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 的使用有如下三种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;普通同步方法，锁是当前实例对象(this);&lt;/li&gt;
&lt;li&gt;静态同步方法，锁是当前类的 Class 对象;&lt;/li&gt;
&lt;li&gt;同步代码块，锁是括号里面的对象。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;普通同步方法锁是当前实例对象this&quot;&gt;普通同步方法，锁是当前实例对象(this)&lt;/h4&gt;
&lt;p&gt;普通同步方法， 锁的是当前的 &lt;code&gt;this&lt;/code&gt; 对象， 在以上的代码中， 我们验证了互斥的效果。&lt;/p&gt;
&lt;h5 id=&quot;验证普通方法中的锁的对象是同一个&quot;&gt;验证普通方法中的锁的对象是同一个。&lt;/h5&gt;
&lt;p&gt;如果两个函数 &lt;code&gt;increase&lt;/code&gt; 和 &lt;code&gt;decrease&lt;/code&gt; 是同一对象中的普通函数，都使用 &lt;code&gt;synchronized&lt;/code&gt;。 则一个函数正在运行时， 锁已经被一个线程所获得，如果另一个线程 相要进入另一个函数就进不去了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyThread implements Runnable {
    private int state=0;
    private static int count = 0;
    public synchronized void increase(){
        System.out.println(System.currentTimeMillis()+&quot; increase begin&quot;);
        try {
            Thread.sleep(5000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(System.currentTimeMillis()+&quot; increase end&quot;);
    }
    public synchronized void decrease(){
        System.out.println(System.currentTimeMillis()+&quot; decrease begin&quot;);
        try {
            Thread.sleep(10000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(System.currentTimeMillis()+&quot; decrease end&quot;);
    }
    public void run() {
        if (state == 0) {
            state = 1;
            increase();
        }else{
            state = 0;
            decrease();
        }
    }

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        Thread thread1 = new Thread(myThread);
        Thread thread2 = new Thread(myThread);
        thread1.start();
        thread2.start();
        try {
            thread1.join();
            thread2.join();
            System.out.println(count);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该段代码运行后结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1535644833489 increase begin
1535644838489 increase end
1535644838489 decrease begin
1535644848489 decrease end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;thread1&lt;/code&gt; 运行时，其启动的是 &lt;code&gt;increase&lt;/code&gt; 函数， 函数内部暂停了 &lt;code&gt;5000&lt;/code&gt; 毫秒， 在此期间， &lt;code&gt;thread2&lt;/code&gt; 已经启动， 但却需要等待 &lt;code&gt;increase&lt;/code&gt; 结束后才能进入 &lt;code&gt;decrease&lt;/code&gt; 函数。&lt;/p&gt;
&lt;h5 id=&quot;验证不同的对象普通方法的锁不一样&quot;&gt;验证不同的对象普通方法的锁不一样&lt;/h5&gt;
&lt;p&gt;如果对象不一样， 则锁不一样， 起不到作用。&lt;/p&gt;
&lt;p&gt;在刚刚结果出现错误的线程中， 给 &lt;code&gt;UnsafeThread&lt;/code&gt; 加上 &lt;code&gt;synchronized&lt;/code&gt; ， 并改变 &lt;code&gt;main&lt;/code&gt; 函数来验证这个结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    UnsafeThread unsafeThread = new UnsafeThread();
    UnsafeThread unsafeThread2 = new UnsafeThread();
    Thread thread1 = new Thread(unsafeThread);
    Thread thread2 = new Thread(unsafeThread2);
    thread1.start();
    thread2.start();
    try {
        thread1.join();
        thread2.join();
        System.out.println(count);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果也会是比 &lt;code&gt;4000000&lt;/code&gt; 小的数字， 因为 &lt;code&gt;count&lt;/code&gt; 是 &lt;code&gt;static&lt;/code&gt; 修饰的， 是一个全局变量， 哪怕是两个不同的对象操作的也是同一个变量。而由于 &lt;code&gt;unsafeThread&lt;/code&gt; 和 &lt;code&gt;unsafeThread2&lt;/code&gt; 是两个不同的对象， 因此 &lt;code&gt;synchronized&lt;/code&gt; 锁的对象就不一样， 锁不一样就起不到互斥的效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为锁的是当前的对象， 因此如果两个线程所持有的对象如果不一样， 则不会起到互斥的作用&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;静态同步方法锁是当前类的class对象&quot;&gt;静态同步方法，锁是当前类的class对象&lt;/h4&gt;
&lt;p&gt;如果 &lt;code&gt;synchronized&lt;/code&gt; 作用在静态方法上， 锁的是当前的 Class 进行加锁。因为静态成员不属于具体的某一个对象， 因此显然继续使用 this 作为锁是不可行的。&lt;/p&gt;
&lt;h5 id=&quot;验证同类的static-方法之间-锁是同一个锁&quot;&gt;验证同类的&lt;code&gt;static&lt;/code&gt; 方法之间， 锁是同一个锁。&lt;/h5&gt;
&lt;p&gt;首先， 定义两个线程类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadA implements Runnable {
    private ThreadStaticTest threadStaticTest;

    public ThreadA(ThreadStaticTest threadStaticTest) {
        this.threadStaticTest = threadStaticTest;
    }
    public void run() {
        threadStaticTest.staticMethodA();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadB implements Runnable {
    private ThreadStaticTest threadStaticTest;

    public ThreadB(ThreadStaticTest threadStaticTest) {
        this.threadStaticTest = threadStaticTest;
    }
    public void run() {
        threadStaticTest.staticMethodB();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后， 定义一个测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadStaticTest {
    public synchronized static void staticMethodA() {
        System.out.println(Thread.currentThread().getName() + &quot; staticMethodA in &quot;
            + System.currentTimeMillis());
        try {
            Thread.sleep(2000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + &quot; staticMethodA out &quot; 
            + System.currentTimeMillis());
    }

    public synchronized static void staticMethodB() {
        System.out.println(Thread.currentThread().getName() + &quot; staticMethodB in &quot; 
            + System.currentTimeMillis());
        try {
            Thread.sleep(3000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + &quot; staticMethodB out &quot; 
            + System.currentTimeMillis());
    }


    public static void main(String[] args) {
        ThreadStaticTest threadStaticTest = new ThreadStaticTest();
        Thread ta = new Thread(new ThreadA(threadStaticTest));
        Thread tb = new Thread(new ThreadB(threadStaticTest));

        ta.setName(&quot;ThreadA&quot;);
        tb.setName(&quot;ThreadB&quot;);
        ta.start();
        tb.start();

        try {
            ta.join();
            tb.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行后的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ThreadA staticMethodA in 1535769147351
ThreadA staticMethodA out 1535769149351
ThreadB staticMethodB in 1535769149351
ThreadB staticMethodB out 1535769152351&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果上看，没什么不同。 但其本质上， 锁的对象还是不一样的， &lt;code&gt;synchronized&lt;/code&gt; 关键字加到静态方法上， 锁的是 Class 类， 而加到非静态方法上， 锁的是 &lt;code&gt;this&lt;/code&gt;对象。&lt;/p&gt;
&lt;h5 id=&quot;验证同一个类的-static-方法和普通方法锁不同&quot;&gt;验证同一个类的 static 方法和普通方法锁不同&lt;/h5&gt;
&lt;p&gt;首先，在之前的 &lt;code&gt;ThreadStaticTest&lt;/code&gt; 类内部加上普通方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public synchronized void methodC() {
    System.out.println(Thread.currentThread().getName() + &quot; methodC in &quot;
            + System.currentTimeMillis());
    try {
        Thread.sleep(3000L);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(Thread.currentThread().getName() + &quot; methodC out &quot;
            + System.currentTimeMillis());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义新的线程类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadC implements Runnable {
    private ThreadStaticTest threadStaticTest;

    public ThreadC(ThreadStaticTest threadStaticTest) {
        this.threadStaticTest = threadStaticTest;
    }
    public void run() {
        threadStaticTest.methodC();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后在 main 函数中添加新的调用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    ThreadStaticTest threadStaticTest = new ThreadStaticTest();
    Thread ta = new Thread(new ThreadA(threadStaticTest));
    Thread tb = new Thread(new ThreadB(threadStaticTest));
    Thread tc = new Thread(new ThreadC(threadStaticTest));

    ta.setName(&quot;ThreadA&quot;);
    tb.setName(&quot;ThreadB&quot;);
    tc.setName(&quot;ThreadC&quot;);
    ta.start();
    tb.start();
    tc.start();

    try {
        ta.join();
        tb.join();
        tc.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ThreadA staticMethodA in 1535769547612
ThreadC methodC in 1535769547612
ThreadA staticMethodA out 1535769549612
ThreadB staticMethodB in 1535769549612
ThreadC methodC out 1535769550612
ThreadB staticMethodB out 1535769552612&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到， 名为 &lt;code&gt;ThreadC&lt;/code&gt; 的线程“乱入”， 而线程 &lt;code&gt;ThreadA&lt;/code&gt; 和 &lt;code&gt;ThreadB&lt;/code&gt; 还是一个结束后一个在进入。证明 &lt;code&gt;ThreadA&lt;/code&gt; 和 &lt;code&gt;ThreadB&lt;/code&gt; 持有的是同一个锁。&lt;/p&gt;
&lt;h4 id=&quot;同步代码块锁是括号里面的对象&quot;&gt;同步代码块，锁是括号里面的对象&lt;/h4&gt;
&lt;p&gt;在方法（静态或普通）上使用 &lt;code&gt;synchronized&lt;/code&gt; ， &lt;strong&gt;随之而带来的就是性能上的降低， 在前面我们证明了， 如果同一对象的多个普通方法使用了 &lt;code&gt;synchronized&lt;/code&gt; ，他们之间会相互阻塞的， 因为持有同样的锁 。所以， 最好只在并发情景中需要修改共享数据的方法上使用它&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么， 我们怎么来做呢？可能有时候我们编写的方法很庞大， 但其中只有一小块是操作共享数据的， 这时候在方法上加 &lt;code&gt;synchronized&lt;/code&gt; 显然是不划算的， 同步代码块就可以解决此类的问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; synchronized(lock){
    // 访问或修改共享数据
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在同步代码块中， &lt;code&gt;synchronized&lt;/code&gt; 后面括号中的 &lt;code&gt;lock&lt;/code&gt; 可以是&lt;strong&gt;任意对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;前面的普通方法， 对应的是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; synchronized(this){
    // 访问或修改共享数据
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;静态方法对应的是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // XXX 对应的是相应的类名
 synchronized(XXX.class){
    // 访问或修改共享数据
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而使用了同步代码块之后， 我们可以一定程度上减少性能的降低。 如果有两个变量， 对应方法 methodA 和 methodB 进行修改, 如果使用两个不同的 &lt;code&gt;lockA&lt;/code&gt; 和 &lt;code&gt;lockB&lt;/code&gt; 对他们进行加锁，则操作时不会相互阻塞。&lt;/p&gt;
&lt;p&gt;首先， 定义测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SynBlock {

    private Lock lockA = new Lock();

    private Lock lockB = new Lock();

    private static int countA = 0;

    private static int countB = 0;

    public void methodA() {
        synchronized (lockA) {
            try {
                System.out.println(Thread.currentThread().getName() + &quot; methodA begin &quot;
                        + System.currentTimeMillis());
                for (int i = 0; i &amp;lt; 2000000; i++) {
                    countA++;
                }
                Thread.sleep(1000L);
                System.out.println(Thread.currentThread().getName() + &quot; methodA end &quot;
                        + System.currentTimeMillis());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public void methodB() {
        synchronized (lockB) {
            try {
                System.out.println(Thread.currentThread().getName() + &quot; methodA begin &quot;
                        + System.currentTimeMillis());
                for (int i = 0; i &amp;lt; 1000000; i++) {
                    countB++;
                }
                Thread.sleep(2000L);
                System.out.println(Thread.currentThread().getName() + &quot; methodA end &quot;
                        + System.currentTimeMillis());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    class Lock {

    }

    public static void main(String[] args) {
        SynBlock synBlock = new SynBlock();
        Thread threadA = new Thread(new SynBlockThreadA(synBlock));
        Thread threadB = new Thread(new SynBlockThreadB(synBlock));

        threadA.setName(&quot;ThreadA&quot;);
        threadB.setName(&quot;ThreadB&quot;);
        threadA.start();
        threadB.start();

        try {
            threadA.join();
            threadB.join();
            System.out.println(&quot;countA=&quot; + countA);
            System.out.println(&quot;countB=&quot; + countB);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的线程类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SynBlockThreadA implements Runnable {

    private SynBlock synBlock;

    public SynBlockThreadA(SynBlock synBlock) {
        this.synBlock = synBlock;
    }
    public void run() {
        synBlock.methodA();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class SynBlockThreadB implements Runnable {

    private SynBlock synBlock;

    public SynBlockThreadB(SynBlock synBlock) {
        this.synBlock = synBlock;
    }
    public void run() {
        synBlock.methodB();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后的输出结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ThreadA methodA begin 1535772725304
ThreadB methodA begin 1535772725304
ThreadA methodA end 1535772726319
ThreadB methodA end 1535772727320
countA=2000000
countB=1000000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果可以看出 &lt;code&gt;ThreadA&lt;/code&gt; 和 &lt;code&gt;ThreadB&lt;/code&gt; 没有互相阻塞。&lt;/p&gt;
&lt;p&gt;但是， 而如果将 &lt;code&gt;methodB&lt;/code&gt; 中的 &lt;code&gt;lockB&lt;/code&gt; 改成 &lt;code&gt;lockA&lt;/code&gt;, 则运行结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ThreadA methodA begin 1535774917415
ThreadA methodA end 1535774918431
ThreadB methodA begin 1535774918431
ThreadB methodA end 1535774920431
countA=2000000
countB=1000000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;起到了互斥的效果。&lt;/p&gt;
&lt;p&gt;因此， 同步代码块的如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在多个线程持有同一个&lt;code&gt;lock&lt;/code&gt;(括号内的对象相同)，同一时间只有一个线程可以执行 &lt;code&gt;synchronized&lt;/code&gt; 同步代码块中的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 的使用到此暂时就结束， 后续会进行其原理的深入讲解和结合锁进行更深入的使用讲解。&lt;/p&gt;
</description>
<pubDate>Sat, 01 Sep 2018 04:52:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>并发编程为我们带来了很多便利， 但同时也带来了线程安全问题。 线程安全 线程安全性的定义： 当多个线程访问某一个类时， 这个类始终能表示出正确的行为， 那么就称这个类是线程安全的。 其产生的原因可以归</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9569957.html</dc:identifier>
</item>
<item>
<title>《通过C#学Proto.Actor模型》之Persistence - 桂素伟</title>
<link>http://www.cnblogs.com/axzxs2001/p/9569899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/axzxs2001/p/9569899.html</guid>
<description>&lt;p&gt;&lt;span&gt;Actor是有状态的，当每一步执行失败后，返回失败地方继续执行时，希望此时的状态是正确的，为了保证这一点，持久化就成了必要的环节了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Proto.Actor提供了三种方式执久化：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Event Sourcing事件溯源&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Snapshotting快照&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Event Sourcing with Snapshotting带快照的事件溯源&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;span&gt;不管是那种持久化方式，首先要构造一个持久化的提供者，这个提者是内存也好，数据库也罢，本例中用Sqlite作为持久化的载体；在Actor中，实现持久化，首先要创建一个Persistence对象，用来将快照或事件保存起来，最重要的一点是，我们用事件溯源或快照，是帮我们保留住Actor在某刻的状，保留下来，以便我们再次启动时能延续这个状态，所以Persistence有一个很关键的作用就是能从持久化的载体中把原来的状态回复过来，这里，Event Source的把原来的状态步骤走再走一次，到达当前流程的点，但快照不然，直接取的是最后时刻的状态；带快照的事件溯源则是两者的结合。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;码友看码：&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;NuGet安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Proto.Actor&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Proto.Persistence&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Proto.Persistence.Sqlite&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Data.Sqlite;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Proto;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Proto.Persistence;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Proto.Persistence.SnapshotStrategies;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Proto.Persistence.Sqlite;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;  
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; P008_Persistence
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用sqlite持久化后&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; actorid = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myactorid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; dbfile = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;C:\MyFile\Source\Repos\ProtoActorSample\ProtoActorSample\P008_Persistence\data.sqlite&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sqliteProvider = &lt;span&gt;new&lt;/span&gt; SqliteProvider(&lt;span&gt;new&lt;/span&gt; SqliteConnectionStringBuilder() { DataSource =&lt;span&gt; dbfile });
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1、事件溯源   2、快照   3、带快照的事件溯源  4、退出&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                 &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (Console.ReadLine())
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;                        CallEventSource(actorid, sqliteProvider);
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;                        CallSnapShoot(actorid, sqliteProvider);
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;                        CallSnapShootEventSource(actorid, sqliteProvider);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事件溯源
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;actorid&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sqliteProvider&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CallEventSource(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; actorid, SqliteProvider sqliteProvider)
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;        {          
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; props = Actor.FromProducer(() =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventSourceDataActor(sqliteProvider, actorid));
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; pid =&lt;span&gt; Actor.Spawn(props);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (result)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1、Tell  2、删除持久化  3、退出&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;  
&lt;span&gt; 52&lt;/span&gt;                 &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (Console.ReadLine())
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; random = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; no = random.Next(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                         Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;随机产生的数字：{no}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                         pid.Tell(&lt;span&gt;new&lt;/span&gt; Data { Amount =&lt;span&gt; no });
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成处理后清理持久化的操作          &lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;                         sqliteProvider.DeleteEventsAsync(actorid, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;).Wait();
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                         result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;            }       
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;  
&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快照
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;actorid&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sqliteProvider&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CallSnapShoot(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; actorid, SqliteProvider sqliteProvider)
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; props = Actor.FromProducer(() =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SnapShootDataActor(sqliteProvider, actorid));
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; pid =&lt;span&gt; Actor.Spawn(props);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (result)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1、Tell  2、删除持久化  3、退出&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;  
&lt;span&gt; 85&lt;/span&gt;                 &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (Console.ReadLine())
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; random = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; no = random.Next(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                         Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;随机产生的数字：{no}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                         pid.Tell(&lt;span&gt;new&lt;/span&gt; Data { Amount =&lt;span&gt; no });
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成处理后清理持久化的操作          &lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;                         sqliteProvider.DeleteEventsAsync(actorid, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;).Wait();
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                         result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;             
&lt;span&gt;103&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快照事件溯源
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;actorid&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sqliteProvider&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CallSnapShootEventSource(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; actorid, SqliteProvider sqliteProvider)
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; props = Actor.FromProducer(() =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SnapShootEventSourceDataActor(sqliteProvider, sqliteProvider, actorid));
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; pid =&lt;span&gt; Actor.Spawn(props);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (result)
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1、Tell  2、删除持久化  3、退出&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;  
&lt;span&gt;118&lt;/span&gt;                 &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (Console.ReadLine())
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; random = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; no = random.Next(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                         Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;随机产生的数字：{no}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                         pid.Tell(&lt;span&gt;new&lt;/span&gt; Data { Amount =&lt;span&gt; no });
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成处理后清理持久化的操作          &lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;                         sqliteProvider.DeleteEventsAsync(actorid, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;).Wait();
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;                         sqliteProvider.DeleteSnapshotsAsync(actorid, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;).Wait();
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;                         result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;            }         
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;  
&lt;span&gt;139&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Data
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; Amount { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;  
&lt;span&gt;144&lt;/span&gt;     &lt;span&gt;#region&lt;/span&gt; 事件溯源
&lt;span&gt;145&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EventSourceDataActor : IActor
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; _value = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Persistence _persistence;
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;  
&lt;span&gt;150&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; EventSourceDataActor(IEventStore eventStore, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; actorId)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;事件溯源持久化方式&lt;/span&gt;
&lt;span&gt;153&lt;/span&gt;             _persistence =&lt;span&gt; Persistence.WithEventSourcing(eventStore, actorId, ApplyEvent);
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ApplyEvent(Proto.Persistence.Event @event)
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (@event.Data)
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; Data msg:
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;                     _value = _value +&lt;span&gt; msg.Amount;
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;                     Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;累计：{_value}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ReceiveAsync(IContext context)
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (context.Message)
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; Started _:
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;                     &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _persistence.RecoverStateAsync();
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; Data msg:
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;                     &lt;span&gt;await&lt;/span&gt; _persistence.PersistEventAsync(&lt;span&gt;new&lt;/span&gt; Data { Amount =&lt;span&gt; msg.Amount });
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;     &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt;  
&lt;span&gt;180&lt;/span&gt;     &lt;span&gt;#region&lt;/span&gt; 快照
&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SnapShootDataActor : IActor
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; _value = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Persistence _persistence;
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;  
&lt;span&gt;186&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; SnapShootDataActor(ISnapshotStore snapshotStore, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; actorId)
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;快照持久化方式&lt;/span&gt;
&lt;span&gt;189&lt;/span&gt;             _persistence =&lt;span&gt; Persistence.WithSnapshotting(snapshotStore, actorId, ApplySnapshot);
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ApplySnapshot(Proto.Persistence.Snapshot snapshot)
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (snapshot.State)
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; value:
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;                     _value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;                     Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;累计：{_value}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ReceiveAsync(IContext context)
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (context.Message)
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; Started _:
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;                     &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _persistence.RecoverStateAsync();
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; Data msg:
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;                     _value = _value +&lt;span&gt; msg.Amount;
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;                     &lt;span&gt;await&lt;/span&gt; _persistence.DeleteSnapshotsAsync(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;                     &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _persistence.PersistSnapshotAsync(_value);
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt;     &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;217&lt;/span&gt;  
&lt;span&gt;218&lt;/span&gt;     &lt;span&gt;#region&lt;/span&gt; 事件溯源and快照
&lt;span&gt;219&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SnapShootEventSourceDataActor : IActor
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; _value = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Persistence _persistence;
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;  
&lt;span&gt;224&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; SnapShootEventSourceDataActor(IEventStore  eventStore, ISnapshotStore snapshotStore, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; actorId)
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注释快照策略
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;_persistence = Persistence.WithEventSourcingAndSnapshotting(eventStore, snapshotStore, actorId, ApplyEvent, ApplySnapshot, new IntervalStrategy(5), () =&amp;gt; { return _value; });
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;无快照策略&lt;/span&gt;
&lt;span&gt;229&lt;/span&gt;             _persistence =&lt;span&gt; Persistence.WithEventSourcingAndSnapshotting(eventStore, snapshotStore, actorId, ApplyEvent, ApplySnapshot);
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ApplyEvent(Proto.Persistence.Event @event)
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (@event.Data)
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; Data msg:
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;                     _value = _value +&lt;span&gt; msg.Amount;
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;                     Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;事件溯源累计：{_value}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ApplySnapshot(Proto.Persistence.Snapshot snapshot)
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (snapshot.State)
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; value:
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;                     _value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt;                     Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;快照累计：{_value}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ReceiveAsync(IContext context)
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (context.Message)
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; Started _:
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt;                     &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _persistence.RecoverStateAsync();
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; Data msg:
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;                     &lt;span&gt;await&lt;/span&gt; _persistence.PersistEventAsync(&lt;span&gt;new&lt;/span&gt; Data { Amount =&lt;span&gt; msg.Amount });
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;无快照策略时启用&lt;/span&gt;
&lt;span&gt;261&lt;/span&gt;                     &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _persistence.PersistSnapshotAsync(_value);
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;     &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;267&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;通过代码看到，持久化是通过在&lt;span lang=&quot;EN-US&quot;&gt;Actor中定义&lt;span lang=&quot;EN-US&quot;&gt;Persistence时，关联一个参数为，&lt;span lang=&quot;EN-US&quot;&gt;Event或&lt;span lang=&quot;EN-US&quot;&gt;Snapshot的方法，并且&lt;span lang=&quot;EN-US&quot;&gt;Actor的&lt;span lang=&quot;EN-US&quot;&gt;Receive方法在&lt;span lang=&quot;EN-US&quot;&gt;Stared到达是恢复（从持久载体中读取数据来恢复），在具体消息到达时，调用&lt;span lang=&quot;EN-US&quot;&gt;Persistence.PersistEventAsync或&lt;span lang=&quot;EN-US&quot;&gt;Persistence.PersisSnapshotAsync来持久化状态数据，这两个方法，都会把调用似递到&lt;span lang=&quot;EN-US&quot;&gt;Persistence产生是关联的那个方法，并把消息实体类通过&lt;span lang=&quot;EN-US&quot;&gt;Event.Data或&lt;span lang=&quot;EN-US&quot;&gt;Snapshot.State传递进去。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;span&gt;此例分别演示了事件溯源，快照，带快照事件溯源，例子很简单，就是把每次产生的随机数累加起来&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1、事件溯源&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/14888/201809/14888-20180901123140497-1044441066.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;三个绿色箭头，意思是进了三次“&lt;span lang=&quot;EN-US&quot;&gt;1、事件溯源”这个选项&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;三次蓝色箭头，意思是调用了三次&lt;span lang=&quot;EN-US&quot;&gt;Tell方法，用来获取三次随机数，蓝色椭圆是产生的三个数字，分别是&lt;span lang=&quot;EN-US&quot;&gt;7，&lt;span lang=&quot;EN-US&quot;&gt;7，&lt;span lang=&quot;EN-US&quot;&gt;6，蓝色方框是累计结果，从上往下，第一次是&lt;span lang=&quot;EN-US&quot;&gt;(0+7)7，第二次是&lt;span lang=&quot;EN-US&quot;&gt;(7+7)14，第三次是&lt;span lang=&quot;EN-US&quot;&gt;(14+6)20&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;红色箭头是退出事件溯源的方法，返回上一级&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;绿色方框是绿色箭头再次进入，自动恢复，事件溯源后的结果（即从持久化载体中把之前的所有事件重新走一次）还是之前退出时的结果，累计&lt;span lang=&quot;EN-US&quot;&gt;20，所以不管这个&lt;span lang=&quot;EN-US&quot;&gt;Actor在什么地方退出，再次运行，都会把之前的补运行回来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;也可以打开&lt;span lang=&quot;EN-US&quot;&gt;sqlite库进行查看保存的事件结果&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2、 快照&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/14888/201809/14888-20180901123235607-10952889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;快照与事件溯源类似，差别在于每次再次进来，只取上次退出时的结果，同时，在数据里，只保存了最后一次的结果。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span lang=&quot;EN-US&quot;&gt;3、带快照的事件溯源&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/14888/201809/14888-20180901123305077-867647143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;与快照类似，上面代码我们是一个事件，一个快照。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;官方给出带快照的事件可以通过快照策略来保存快照&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;在创建持久化对象时，可以添加快照策略&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; _persistence = Persistence.WithEventSourcingAndSnapshotting(eventStore, snapshotStore, actorId, ApplyEvent, ApplySnapshot, &lt;span&gt;new&lt;/span&gt; IntervalStrategy(&lt;span&gt;5&lt;/span&gt;), () =&amp;gt; { &lt;span&gt;return&lt;/span&gt; _value; });
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;您可以选择ISnapshotStrategy在保存事件时指定自动保存快照。提供的策略是：&lt;/span&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;EventTypeStrategy - 根据保存的事件类型保存快照&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;IntervalStrategy - 根据保存的事件数量，即每100个事件，定期保存快照&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;TimeStrategy - 根据时间以固定间隔保存快照，即在快照之间等待至少6小时&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;span&gt;同时要在Actor的Receive把保存快照注释掉，Demo中我用的是5个事件后保存一次快照，如下图结果&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/14888/201809/14888-20180901123412791-403397225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;绿色是第一次，要保存一下快照，然后之后第五个事件过来后保存第二次快照，如果在第四个事件后程序就退出，那快照保存的只有第一次的，不有担心，当再次调用时，因为记录下了所有事件，Actor会取出最后一次快照，再支执行快照后的事件，这是因为在保存快照和事件时，会把他们的索引保存起来，索引是一样的，就能用最后的快照+这个快照索引后的事件，恢复到退出的地方。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;记得执行后查看Sqlite数据，有助于你更好的了解Proto.Actor的Persistence机制哦！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Sep 2018 04:35:00 +0000</pubDate>
<dc:creator>桂素伟</dc:creator>
<og:description>Actor是有状态的，当每一步执行失败后，返回失败地方继续执行时，希望此时的状态是正确的，为了保证这一点，持久化就成了必要的环节了。 Proto.Actor提供了三种方式执久化： • Event</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/axzxs2001/p/9569899.html</dc:identifier>
</item>
<item>
<title>常见踩坑案例分析（一） - 玉树临枫</title>
<link>http://www.cnblogs.com/yuanfy008/p/9569525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanfy008/p/9569525.html</guid>
<description>&lt;p&gt;计划真的赶不上变化，时间过得真快。废话不多说了，今天主要记录之前有同事遇到的一些坑分享出来。&lt;/p&gt;

&lt;p&gt;　　对于其他对象的应用，一般在使用之前会判断它是否为空，如果不为空才会使用它以及它里面的一些属性值。但是对于基本类型的封装类型，就有很多人漏掉对于它的判断。&lt;/p&gt;
&lt;p&gt;　　就在前面几天有位同事(应届生)问我说这段代码它怎么会报空指针呢？ 先模拟下这个场景下的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三方的实体类对象&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Count{
    Integer total;
    String name;
    String leavingNum;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fun() {
        Count count &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Count();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 经过一系类对应值的获取之后
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要判断total是否为0,如果为0就进行其他的业务操作。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (count.total == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比方说打印日志。&lt;/span&gt;
&lt;span&gt;        }
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
        fun();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　他给我看的代码就是类似fun()方法中的代码, 我一看这个代码就感觉不对劲，我说你这个Count类下的total属性是int吗？如果是int就可以这么用。他说为什么？ “如果是Integer类型，那么它的初始值不是0而是null, 而你上面的这些逻辑又不能保证total 一定会获取到数值，那么它就还有可能是null，你这样使用的话就有可能包NPE的问题。所以&lt;/span&gt;&lt;strong&gt;针对对象的使用提前判空更有保障&lt;/strong&gt;&lt;span&gt;。” 我接着说。 在我说的过程中他反应还是很快的，立马查看了这个实体类中total字段的类型，于是就明白了。 &lt;strong&gt;如果没有养成提前使用判空的习惯（除非你能保证一定会有值），老手都容易会踩这样的坑&lt;/strong&gt;。比方说针对Boolean类型的使用，有很多人会直接这样的哦（这样肯定会有问题的）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        Boolean flag = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 经过一系类操作处理
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行判断&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;......  &lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　另外针对基本类型的封装类型使用还有些要注意的请看这篇文章：&lt;a href=&quot;https://www.cnblogs.com/yuanfy008/p/8321217.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/yuanfy008/p/8321217.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　现在有很多都是基于分布式服务，那应该会存在这个域对应数据需要同步到其他域下，然后这种同步必然会产生差异，需要一种自检的job去检测差异。打个比方有些商家自己有官网售卖自己的产品，也还有可能会在天猫开旗舰店售卖。假如它分配在天猫的商品信息是通过它本地天猫数据库同步过去的，那么这种难免会产生差异，特别是库存，如果一边多一边少就可能会导致超卖的情况。 所以这种情况需要有个job对比两边的差异，下面先简单模拟下事发情况（注意下面的用法）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SubListTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始集合（有序）&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         list.addAll(Arrays.asList(1, 2, 3, 4&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 业务场景：需要将list集合与很多场景下的数据进行对比，然后取出不同的。
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对比的场景就不还原了，假设每次都是前面两个不同。 这里只列举四次对比，为了方便查看效果不使用for循环
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一次截取不同的数据&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         list = list.subList(0, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查看list中有多少数据&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        System.out.println(list);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询有新的数据，往list中添加&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         list.addAll(Arrays.asList(5, 6&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二次截取&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         list = list.subList(0, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        System.out.println(list);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询有新的数据，往list中添加&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         list.addAll(Arrays.asList(7, 8&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三次截取&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         list = list.subList(0, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        System.out.println(list);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询有新的数据，往list中添加&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         list.addAll(Arrays.asList(9, 10&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第四次截取&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         list = list.subList(0, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        System.out.println(list);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;看到上面代码其实很简单，输出结果大家也都知道。下面先一步一步的分析，然后再介绍在大量数据的情况下这会产生结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一步：查看下list的内存分配地址，后面会有需要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690169/201809/690169-20180901111559020-656448416.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　第二步：跳到第一次截取之后，看list有什么变化？ &lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690169/201809/690169-20180901111702891-1105276885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　它的内存地址变了，也就说每次subList都会产生一个新对象，那么得查看下这subList的源码，而源码中确实是会产生一个新对象&lt;strong&gt;。但是请仔细SubList的构造函数，其中会存放它的父级对象。&lt;/strong&gt;那么这会产生什么影响呢？请接着往下看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; List&amp;lt;E&amp;gt; subList(&lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; toIndex) {
       subListRangeCheck(fromIndex, toIndex, size);
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SubList(&lt;span&gt;this&lt;/span&gt;, 0&lt;span&gt;, fromIndex, toIndex);
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SubList &lt;span&gt;extends&lt;/span&gt; AbstractList&amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RandomAccess {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AbstractList&amp;lt;E&amp;gt;&lt;span&gt; parent;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; parentOffset;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; offset;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;

        SubList(AbstractList&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; parent,
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; toIndex) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parent =&lt;span&gt; parent;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parentOffset =&lt;span&gt; fromIndex;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.offset = offset +&lt;span&gt; fromIndex;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size = toIndex -&lt;span&gt; fromIndex;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.modCount = ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.modCount;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后面方法省略  &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第三步：在第三次截取之前直接在源码中SubList构造函数中打断点，然后跳转进来，看看对应对象的属性值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690169/201809/690169-20180901112003844-221007192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　咋一看，这里面怎么param_1怎么来的？&lt;strong&gt;通过第二步查看SubList的源码再加上第一步的需要你留意list原生的的对象内存地址，你就知道param_1对应是这个list的根对象，它一直保留子对象新增的对象。&lt;/strong&gt;那么大家想下，这种做法当遇到海量数据对比差异时会产生什么影响呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　如果刚才看懂了上面所说的，那么肯定会明白这个list的根对象累积到后面肯定会变成大对象，这样会导致平凡的fullGc而且你还回收不掉。因为它一直在使用，直至这个程序运行结束。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;那么像上面这种场景怎么优化解决呢？ 可以这样考虑， 每次对比时候都弄一个新的list去获取差异，然后再把这个有差异的list添加至总的差异结果集中。（其实我们平时也不会用一个list去反反复复的subList）。如果大家有更好的优化，请留言探讨。&lt;/p&gt;

</description>
<pubDate>Sat, 01 Sep 2018 03:39:00 +0000</pubDate>
<dc:creator>玉树临枫</dc:creator>
<og:description>计划真的赶不上变化，时间过得真快。废话不多说了，今天主要记录之前有同事遇到的一些坑分享出来。 一、封装类的应用会引起NPE异常 对于其他对象的应用，一般在使用之前会判断它是否为空，如果不为空才会使用它</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanfy008/p/9569525.html</dc:identifier>
</item>
<item>
<title>Nodejs入门（二） - 宣火鱼竹</title>
<link>http://www.cnblogs.com/firefish1/p/9569662.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/firefish1/p/9569662.html</guid>
<description>&lt;h4 id=&quot;nodejs基础api&quot;&gt;Nodejs基础api&lt;/h4&gt;
&lt;p&gt;1、path&lt;br/&gt;path模块提供了很多实用的工具函数，用于处理文件与目录的路径，下面是它的api：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li&gt;normalize 方法可以输出规范格式的path字符串&lt;/li&gt;
&lt;li&gt;join 方法用于拼接path字符串&lt;/li&gt;
&lt;li&gt;resolve 方法用于将相对路径解析为绝对路径&lt;/li&gt;
&lt;li&gt;name 方法用于查看文件名
&lt;ul&gt;&lt;li&gt;basename查看文件名&lt;/li&gt;
&lt;li&gt;dirname查看所在路径&lt;/li&gt;
&lt;li&gt;extname查看扩展名&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;parse与format，parse用于将一个路径字符串返回成一个对象，而format则正好相反，如果有时候你需要修改一个路径的话，就可以先parse修改之后再format回去&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;delimiter 提供不同系统下的分隔符，windows系统（；）和posix（：）系统分隔符不同。sep 返回各平台的分隔符（Windows，POSIX/）&lt;/p&gt;
&lt;p&gt;//delimiter&lt;br/&gt;console.log(process.env.PATH)&lt;br/&gt;'C:\Windows\system32;C:\Windows;C:\Program Files\node'&lt;/p&gt;
&lt;p&gt;process.env.PATH.split(path.delimiter)&lt;br/&gt;['C:\Windows\system32', 'C:\Windows', 'C:\Program Files\node\']&lt;/p&gt;
&lt;p&gt;//sep&lt;br/&gt;'foo\bar\baz'.split(path.sep)&lt;br/&gt;返回：['foo','bar','baz']&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;path路径需要注意的一些地方&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;_dirname、_filename总是返回文件的绝对路径&lt;/li&gt;
&lt;li&gt;process.cwd( )总是返回执行node命令所在文件夹&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、Buffer（缓冲）&lt;br/&gt;Buffer是global对象的属性，&lt;strong&gt;用于处理二进制数据流&lt;/strong&gt;。它的实例类似整数数组，但是它里面是一些0-255的数字（默认用十六进制表示）大小固定。且用C++代码在V8堆外分配物理内存&lt;/p&gt;
&lt;p&gt;如何实例化Buffer：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Buffer.alloc( length ) or Buffer.alloc( length,1 )&lt;/li&gt;
&lt;li&gt;Buffer.allocUnsafe( length ) // 它较于alloc的区别是没做初始化，这样速度快，但内存块原来有的东西没清空，所以要用fill( )于write( )把里面的内容重写一下&lt;/li&gt;
&lt;li&gt;Buffer.from( [1,2,3] ) or Buffer.form( 字符串 , 编码格式)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下是它的类的一些常用方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Buffer.byteLength 返回一个字符串的实际字节长度&lt;/li&gt;
&lt;li&gt;Buffer.isBuffer( ) 判断是否时buffer对象&lt;/li&gt;
&lt;li&gt;Buffer.concat( ) 拼接buffer，传入的参数是一个数组&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再看下实例的属性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;buf.length 返回 buf 在字节数上分配的内存量&lt;/li&gt;
&lt;li&gt;buf.toString( ) 根据指定的字符编码解码 buf 成一个字符串&lt;/li&gt;
&lt;li&gt;buf.fill( ) 用于填充buf&lt;/li&gt;
&lt;li&gt;buf.equals( ) 比较两个buf的内容是否一样&lt;/li&gt;
&lt;li&gt;buf.indexOf( ) 用于查找匹配&lt;/li&gt;
&lt;li&gt;buf.copy( )&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、event&lt;br/&gt;Nodejs所有能触发事件的对象都是EventEmitter类的实例，这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数绑定到会被对象触发的命名事件上。&lt;br/&gt;eventEmitter.on() 方法用于注册监听器，eventEmitter.emit() 方法用于触发事件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const EventEmiter = require('events');

class triggerEvent extends EventEmiter {}

const ex = new triggerEvent();//实例化

ex.on(&quot;error&quot;,(err,time) =&amp;gt; {
  console.log(err);
  console.log(time)
});//事件绑定

ex.emit(&quot;err&quot;,new Error(&quot;opps!&quot;),Date.now());//手动触发事件,并传两个参数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Nodejs事件的绑定还可以用once进行绑定，让事件只触发一次。&lt;br/&gt;而事件可以通过removeListener（event name，function name）进行移除，或者使用removeAllListeners（event name）移除所有&lt;/p&gt;
&lt;p&gt;4、fs（文件系统）&lt;br/&gt;fs 模块提供了一些 API，用于以一种类似标准 POSIX 函数的方式与文件系统进行交互。&lt;br/&gt;所有的文件系统操作都有异步和同步两种形式。&lt;br/&gt;异步形式的最后一个参数都是完成时回调函数。 传给回调函数的参数取决于具体方法，但&lt;strong&gt;回调函数的第一个参数都会保留给异常&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;fs.readFile( ) 读取文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; const fs = require(&quot;fs&quot;);

    fs.readFile(&quot;./event.js&quot;,'utf8',(err,data) =&amp;gt; {
      if(err) {
        throw err;
      } else {
        console.log(data);
      }
    })//异步读取文件

    const data = fs.readFileSync(&quot;./event.js&quot;,'utf-8');//同步读取文件
    console.log(data);
    &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;fs.writeFile( ) 写入文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;const fs = require(&quot;fs&quot;);

const content = Buffer.from(&quot;balabalabala&quot;);

fs.writeFile(&quot;./text&quot;,content,err =&amp;gt; {
  if(err){
    throw err;
  } else {
    console.log(&quot;done !&quot;);
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;fs.stat( ) 输出文件的stats属性&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;const fs = require(&quot;fs&quot;);
 
fs.stat(&quot;stat.js&quot;, (err,stats) =&amp;gt; {
    if(err) {
      console.log(&quot;文件不存在！&quot;);
      return;
    } else {
      console.log(stats.isFile());//是否为文件
      console.log(stats.isDirectory());//是否为文件夹
    }
 })&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;fs.watch( ) 监视文件或者文件夹&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;const fs = require(&quot;fs&quot;);

fs.watch('./',{
  recursive: true //指明是否全部子目录应该被监视，或只是当前目录。
},(eventType,filename) =&amp;gt; {
  console.log(&quot;变化类型&quot;,eventType);
  console.log(&quot;变化的文件名&quot;,filename);
})&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;fs.createReadStream( ) 创建数据流，读取数据&lt;br/&gt;数据是一点点流动的，不是全部接受，相较于&lt;code&gt;fs.readFile( )&lt;/code&gt;会显得更加优雅&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;const fs = require(&quot;fs&quot;);

const rs = fs.createReadStream('./readstream.js');

rs.pipe(process.stdout);//数据导向哪里，stdout就是控制台&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;fs.createWriteStream( ) 创建数据流，写入数据&lt;br/&gt;同 &lt;code&gt;fs.createReadStream( )&lt;/code&gt;，它是一种优雅的写入数据的方式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;const fs = require(&quot;fs&quot;);

const ws = fs.createWriteStream('./test.txt');

const timer = setInterval(() =&amp;gt; {
  const num = parseInt(Math.random() * 10);//取19以内的随机数
  if(num &amp;lt; 8){
    ws.write(num + '');//转换为字符串，因为只能写入buffer或者字符串
  } else {
    clearInterval(timer);//清楚定时器
    ws.end();//结束写入数据流
  }
},1000);//每个一秒写入一段数据

ws.on(&quot;finish&quot;,() =&amp;gt; {
  console.log(&quot;done!&quot;);
});//监听事件结束&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面还有一些常用的api：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;fs.rename( ) 修改文件名&lt;/li&gt;
&lt;li&gt;fs.unlink( ) 删除文件&lt;/li&gt;
&lt;li&gt;fs.readdir( ) 读取文件夹下的所有文件名&lt;/li&gt;
&lt;li&gt;fs.mkdir( ) 创建文件夹&lt;/li&gt;
&lt;li&gt;fs.rmdir( ) 删除文件夹&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 01 Sep 2018 03:38:00 +0000</pubDate>
<dc:creator>宣火鱼竹</dc:creator>
<og:description>这是我发布的有关Nodejs学习的第二篇博客，这篇主要介绍Nodejs一些常用的api，还有一些小栗子可以更直观的了解。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/firefish1/p/9569662.html</dc:identifier>
</item>
<item>
<title>Linux系统文件权限体详解 - 浪漫De刺猬</title>
<link>http://www.cnblogs.com/liang-io/p/9567180.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liang-io/p/9567180.html</guid>
<description>&lt;p&gt;改变权限属性的命令chmod&lt;/p&gt;
&lt;p&gt;　　chmod是来改变文件或者目录权限的命令，但只有文件的属主和超级用户root才有这样的权限，通过chmod来改变文件或目录的权限有俩种方式，一种是通过&lt;span&gt;权限字母和操作符表达式&lt;/span&gt;的方法，来设置权限，另一种是使用&lt;span&gt;数字方法&lt;/span&gt;来设置权限。&lt;/p&gt;
&lt;h4&gt;　　chmod    [数字组合]　　文件名&lt;/h4&gt;
&lt;table border=&quot;2&quot; align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;r&lt;/td&gt;
&lt;td&gt; read&lt;/td&gt;
&lt;td&gt; 4&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;write&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;execute&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5&gt; &lt;/h5&gt;
&lt;h4&gt;　　举例子：创建一个ett.txt文件，并查看文件的权限。&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430251/201808/1430251-20180831173447622-541247170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此文件的权限属主位代表的数字为4+2+0=6；属组位代表的数字为4+0+0=4，其他用户组代表的是4+0+0=4，所以数字组合为644&lt;/p&gt;
&lt;h4&gt;　　例一，用chmod命令的数字方法来设置权限，如下：（次数字方法最为常用）&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430251/201809/1430251-20180901080424257-627437252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　例子二，用touch创建一个.sh文件，测试属主的权限，属组和其他用户组的权限不在一一测试。。。&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430251/201809/1430251-20180901081231289-249092078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　权限字母和操作符表达式&lt;/h4&gt;
&lt;table border=&quot;2&quot; align=&quot;center&quot;&gt;&lt;thead&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;标识&lt;/td&gt;
&lt;td&gt;u（user）&lt;/td&gt;
&lt;td&gt;g（group）&lt;/td&gt;
&lt;td&gt;o（others）&lt;/td&gt;
&lt;td&gt;a（all）&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;含义&lt;/td&gt;
&lt;td&gt;用户&lt;/td&gt;
&lt;td&gt;组&lt;/td&gt;
&lt;td&gt;其他&lt;/td&gt;
&lt;td&gt;所有用户&lt;/td&gt;
&lt;td&gt;增减权限&lt;/td&gt;
&lt;td&gt;减少权限&lt;/td&gt;
&lt;td&gt;重新分配权限&lt;/td&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;

&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430251/201809/1430251-20180901083452189-512482410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　小结：针对目录跟文件权限对比说明&lt;/h4&gt;
&lt;table border=&quot;2&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr align=&quot;left&quot; valign=&quot;middle&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;文件&lt;/td&gt;
&lt;td&gt;目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;left&quot; valign=&quot;middle&quot; readability=&quot;4&quot;&gt;&lt;td&gt;r（read）读取权限&lt;/td&gt;
&lt;td&gt;表示具有读取阅读文件内容的权限&lt;/td&gt;
&lt;td&gt;表示具有浏览目录的权限（注意：与进入目录的权限不同）&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;left&quot; valign=&quot;middle&quot; readability=&quot;6&quot;&gt;&lt;td&gt;w（write）写入权限&lt;/td&gt;
&lt;td&gt;表示具有新增，修改文件内容的权限(注意：删除和移动文件和文件本身无关，看上级目录)&lt;/td&gt;
&lt;td&gt;表示具有新增，删除，移动目录的内文件权限（需要有x权限配合，要不没有r 有x ls -l 查看文件会显示文件名 ，但是文件属性都是一堆？？？？）&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;left&quot; valign=&quot;middle&quot; readability=&quot;7&quot;&gt;&lt;td&gt;x（execute）（执行权限）&lt;/td&gt;
&lt;td&gt;表示具有执行文件权限（普通用户同时还需要r权限，root用户不用r也能执行，文件本身也能执行才可以哦）&lt;/td&gt;
&lt;td&gt;表示具有进入目录的权限&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h4&gt;既然我们可以更改权限了，那么有没有想过我们创建的文件或目录默认权限呢？&lt;span&gt;umask&lt;/span&gt;可以分配默认权限，文件的默认安全权限为644，目录为755（Linux）&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430251/201809/1430251-20180901102423082-1414352076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;在linux下我们查看的方式有两种，一种可以直接输入umask，就可以看到数字形态的权限设置分数，一种则是加-S（Symbolic）参数，就能以符号类型的方式来显示出权限了，如下：&lt;/h4&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1430251/201809/1430251-20180901103445844-1572442310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　Umask的设置很简单，只需要在umask命令后加想要拿掉的权限数字就行：&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430251/201809/1430251-20180901104044694-150240775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        Linux下的etc/profile和etc/bashrc中都有默认的umask设置，我们来看一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ SUID -gt 99] &amp;amp;&amp;amp; [ &quot; 'id -gn' &quot; =&quot; 'id =un' &quot;&lt;span&gt;];then
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     umask 002
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     umask 022
&lt;span&gt;5&lt;/span&gt; fi
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;         这个是在etc/profile中的一部分内容，可以看到根据不同的uid设置了不同的umask，其实在etc/bashrc文件中也有基本相同的这部分代码，我们可以在这两个文件中设置umask，那么二者有什么区别呢？如果实在etc/profile中修改，只有在重新登录用户的时候才会发生改变，而在etc/bashrc中修改的话要是切换目录就会发生改变，因为profile是在登录用户的时候调用的。一般不常永久改umask，只是临时更改用，没啥较大用途的命令（个人观点）&lt;/p&gt;
&lt;h4&gt;　　Linux系统是如何计算出文件或目录权限的呢？&lt;/h4&gt;
&lt;table border=&quot;2&quot; cellspacing=&quot;2&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td colspan=&quot;2&quot; align=&quot;left&quot; valign=&quot;middle&quot;&gt;  &lt;/td&gt;
&lt;td&gt;默认最大权限&lt;/td&gt;
&lt;td&gt;umask值&lt;/td&gt;
&lt;td&gt;用户创建文件的权限&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;文件&lt;/td&gt;
&lt;td&gt;创建文件umask为偶数的时候&lt;/td&gt;
&lt;td&gt;666[-rw-rw-rw-]&lt;/td&gt;
&lt;td&gt;022（全偶数）[-----w--w-]&lt;/td&gt;
&lt;td&gt;644 [-rw-r--r--]（说明：偶数加减法  默认的最大权限 —umask 值=用户创建文件的权限）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;创建文件umask为奇数的时候&lt;/p&gt;
&lt;p&gt;（umask部分或者全部都为奇数）&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;666[-rw-rw-rw-]&lt;/td&gt;
&lt;td&gt;123(部分位为奇数) [--x--w--wx]&lt;/td&gt;
&lt;td&gt;644（以为umask的值123中又个都是奇数，因此在计算543的基础上加上101，即奇数对应的文件数字权限位分别加1即可）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;目录&lt;/td&gt;
&lt;td&gt; umask为奇数偶数都一样&lt;/td&gt;
&lt;td&gt;777[-rwxrwxrwx]&lt;/td&gt;
&lt;td&gt;022[-----w--w-]&lt;/td&gt;
&lt;td&gt;755[-rwxr-xr-x](说明：默认最大权限—umask值=用户创建目录的权限)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt; 可以看到上面在计算创建的文件和目录的默认权限的时候，我是这样认为的：666-022=644；777-022=755.，这样数字相减正好是用户创建的目录或文件的权限，（说明：如果是文件的话umask为奇数的话，需要在做减法后，奇数对应的文件数字权限上加1，目录则不需要，博主亲测望采纳！）更多计算方法请参考&lt;a href=&quot;http://blog.51cto.com/oceanho/1752988&quot; target=&quot;_blank&quot;&gt;Linux默认权限的计算公式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;loading....&lt;/p&gt;

</description>
<pubDate>Sat, 01 Sep 2018 03:29:00 +0000</pubDate>
<dc:creator>浪漫De刺猬</dc:creator>
<og:description>改变权限属性的命令chmod chmod是来改变文件或者目录权限的命令，但只有文件的属主和超级用户root才有这样的权限，通过chmod来改变文件或目录的权限有俩种方式，一种是通过权限字母和操作符表达</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liang-io/p/9567180.html</dc:identifier>
</item>
<item>
<title>钉钉JSAPI前端鉴权 - zhang90030</title>
<link>http://www.cnblogs.com/zhang90030/p/9569515.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhang90030/p/9569515.html</guid>
<description>&lt;p&gt;钉钉二次开发分为如下表所示三种类型的开发，只有企业内部应用才需要对JSAPI鉴权。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;120&quot;&gt;
&lt;p align=&quot;center&quot;&gt;类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;163&quot;&gt;
&lt;p align=&quot;center&quot;&gt;开发方式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;93&quot;&gt;
&lt;p align=&quot;center&quot;&gt;JSAPI&lt;span&gt;鉴权&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;191&quot;&gt;
&lt;p align=&quot;center&quot;&gt;应用场景&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;120&quot;&gt;
&lt;p align=&quot;center&quot;&gt;第三方企业应用&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;163&quot;&gt;
&lt;p align=&quot;center&quot;&gt;E&lt;span&gt;应用开发&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;93&quot;&gt;
&lt;p align=&quot;center&quot;&gt;不需要&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;191&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;用于发布到钉钉应用市场，供广大用户下载，应用可选收费或免费，需要收取保证金，并进行应用审核&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;120&quot;&gt;
&lt;p align=&quot;center&quot;&gt;企业内部应用&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;163&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;H5&lt;span&gt;开发，&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;月中旬也开始支持&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;应用开发&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;93&quot;&gt;
&lt;p align=&quot;center&quot;&gt;需要&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;191&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;只能企业内部应用，不能发布到钉钉市场&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;120&quot;&gt;
&lt;p align=&quot;center&quot;&gt;第三方个人应用&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;163&quot;&gt;
&lt;p align=&quot;center&quot;&gt;E&lt;span&gt;应用开发&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;93&quot;&gt;
&lt;p align=&quot;center&quot;&gt;需要&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;191&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;应用与企业不挂钩，服务于个人&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;先来看一下钉钉官网给出的JSAPI鉴权的流程，它分为四个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取token&lt;/li&gt;
&lt;li&gt;获取ticket&lt;/li&gt;
&lt;li&gt;获取数字签名&lt;/li&gt;
&lt;li&gt;设置权限&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/379004/201809/379004-20180901101545454-4018568.png&quot; alt=&quot;&quot; width=&quot;1053&quot; height=&quot;945&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看钉钉开发文档，它给出了两个JSAPI的鉴权demo，分别是java和php的，需要前后端配合，而本文讲述的是纯前端JSAPI鉴权，完全实现前后端分离。&lt;/p&gt;
&lt;p&gt;下面的代码将用到以下三个js依赖包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import CryptoJS from 'crypto-js'; // 加密，用于生成数字签名&lt;span&gt;
import &lt;/span&gt;* as dd from &quot;dingtalk-jsapi&quot;&lt;span&gt;; // 钉钉JSAPI
import axios from &lt;/span&gt;&quot;axios&quot;; // HTTP请求
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 提示：下面的代码，用了ES6和ES7的一些语法，没接触过的朋友，可自行百度&lt;/p&gt;

&lt;p&gt;首先根据corpid和corpsecret参数，从钉钉服务器获取token。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 获取token信息
 * @param {Object} params {corpid, corpsecret}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getToken(params) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; await axios.get('/proxy/gettoken'&lt;span&gt;, {
            params
        })
        .then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(response) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response.data.access_token;
        });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;细心的朋友会发现，axios请求的URL并没有直接指定 https://oapi.dingtalk.com/gettoken，这是因为直接写这个URL，会存在跨域问题，因此，这里我们用了代理。&lt;/p&gt;
&lt;p&gt;代理可以采用nginx代理或者node代理，这里推荐用node代理。&lt;/p&gt;
&lt;p&gt;因为需要代理的请求是https请求，本人也没跑通nginx代理https请求，如果有哪位朋友跑通了nginx代理的，麻烦告知一声，也学习以下。&lt;/p&gt;

&lt;p&gt;如果采用vue-cli创建的项目，可以直接在proxyTable中配置，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　proxyTable: {
     &lt;/span&gt;'/proxy'&lt;span&gt;: {
        target: &lt;/span&gt;'https://oapi.dingtalk.com'&lt;span&gt;,
        secure: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置跨域&lt;/span&gt;
        changeOrigin: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        pathRewrite: {
          &lt;/span&gt;'^/proxy': ''&lt;span&gt;
        }

     }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;不过上面的配置只能在dev开发环境中使用，如果需要在生产环境中使用，还是需要自己写nodejs代码实现，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express = require('express'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; proxy = require('http-proxy-middleware'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; express();

app.use(&lt;/span&gt;'/proxy'&lt;span&gt;, proxy({
    target: &lt;/span&gt;'https://oapi.dingtalk.com'&lt;span&gt;,
    changeOrigin: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    pathRewrite: {
        &lt;/span&gt;'^/proxy': ''&lt;span&gt;
      }
    }));
app.listen(&lt;/span&gt;3000);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 这代码量是不是很少，随便百度下都搞定。&lt;/p&gt;

&lt;p&gt;根据上面获取的access_token，从钉钉服务器获取ticket。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 获取ticket信息
 * @param {Object} params {access_token}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getJsticket(params) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; await axios.get('/proxy/get_jsapi_ticket'&lt;span&gt;, {
            params
        })
        .then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(response) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response.data.ticket;
        });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;钉钉官网的demo是后台实现生成数字签名，通过crypto-js前端加密库就可以将这个功能移植到前端来。&lt;/p&gt;
&lt;p&gt;ticket是上面生成的；&lt;/p&gt;
&lt;p&gt;nonce可以是任何字符串；&lt;/p&gt;
&lt;p&gt;timeStamp是当前时间戳；&lt;/p&gt;
&lt;p&gt;url是当前访问的URL地址，不包括#及后面的部分，特别注意这个参数，别搞错了。如果设置错了，可以通过下面的dd.error输出查看钉钉服务器获取的URL地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 获取签名信息
 * @param {*} ticket
 * @param {*} nonce
 * @param {*} timeStamp
 * @param {*} url
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getJsApiSingnature(ticket, nonce, timeStamp, url) {
    let plainTex &lt;/span&gt;= &quot;jsapi_ticket=&quot; + ticket + &quot;&amp;amp;noncestr=&quot; + nonce + &quot;&amp;amp;timestamp=&quot; + timeStamp + &quot;&amp;amp;url=&quot; +&lt;span&gt; url;
    let signature &lt;/span&gt;=&lt;span&gt; CryptoJS.SHA1(plainTex).toString();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; signature;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;通过dd.config设置需要的权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 步骤4：设置权限&lt;/span&gt;
&lt;span&gt;    dd.config({
        agentId: agentId,
        corpId: corpid, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必填，企业ID&lt;/span&gt;
        timeStamp: timeStamp, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，生成签名的时间戳&lt;/span&gt;
        nonceStr: nonce, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，生成签名的随机串&lt;/span&gt;
        signature: signature, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，签名&lt;/span&gt;
        jsApiList: jsApiList &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，需要使用的jsapi列表，注意：不要带dd。&lt;/span&gt;
    });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;jsApiList是权限列表，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; jsApiList =&lt;span&gt; [
    &lt;/span&gt;'biz.user.get'&lt;span&gt;,
    &lt;/span&gt;'device.geolocation.get'&lt;span&gt;,
    &lt;/span&gt;'biz.util.uploadImage'&lt;span&gt;
];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面配置成功之后，就能调用JSAPI中需要鉴权的功能了，下面以获取当前地理位置为例说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 测试代码，通过调用位置服务，测试鉴权是否正确
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; testJsApi() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取位置&lt;/span&gt;
    dd.ready(() =&amp;gt;&lt;span&gt; {
        dd.device.geolocation.get({
            targetAccuracy: &lt;/span&gt;200&lt;span&gt;,
            coordinate: &lt;/span&gt;1&lt;span&gt;,
            withReGeocode: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
            useCache: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认是true，如果需要频繁获取地理位置，请设置false,&lt;/span&gt;
            onSuccess: result =&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 高德坐标 result 结构
                    {
                        longitude : Number,
                        latitude : Number,
                        accuracy : Number,
                        address : String,
                        province : String,
                        city : String,
                        district : String,
                        road : String,
                        netType : String,
                        operatorType : String,
                        errorMessage : String,
                        errorCode : Number,
                        isWifiEnabled : Boolean,
                        isGpsEnabled : Boolean,
                        isFromMock : Boolean,
                        provider : wifi|lbs|gps,
                        accuracy : Number,
                        isMobileEnabled : Boolean
                    }
                    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                console.log(result)
                alert(&lt;/span&gt;&quot;success: &quot; +&lt;span&gt; JSON.stringify(result))
            },
            onFail: err &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(err)
                alert(&lt;/span&gt;&quot;error: &quot; +&lt;span&gt; JSON.stringify(err))
            }
        });
    });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查看鉴权错误信息&lt;/span&gt;
    dd.error(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err) {
        alert(&lt;/span&gt;'dd error: ' + JSON.stringify(err)&lt;span&gt;);
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果鉴权失败，则dd.error将输出钉钉服务器采用的数字签名参数，可以与自己采用的参数做比较&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getAccessToken() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 步骤1：获取token&lt;/span&gt;
    let access_token =&lt;span&gt; await getToken({
        corpid,
        corpsecret
    });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 步骤2：获取ticket&lt;/span&gt;
    let ticket =&lt;span&gt; await getJsticket({
        access_token
    });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 步骤3：获取数字签名&lt;/span&gt;
    let signature =&lt;span&gt; getJsApiSingnature(ticket, nonce, timeStamp, url);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 步骤4：设置权限&lt;/span&gt;
&lt;span&gt;    dd.config({
        agentId: agentId,
        corpId: corpid, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必填，企业ID&lt;/span&gt;
        timeStamp: timeStamp, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，生成签名的时间戳&lt;/span&gt;
        nonceStr: nonce, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，生成签名的随机串&lt;/span&gt;
        signature: signature, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，签名&lt;/span&gt;
        jsApiList: jsApiList &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，需要使用的jsapi列表，注意：不要带dd。&lt;/span&gt;
&lt;span&gt;    });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试定位功能&lt;/span&gt;
&lt;span&gt;    testJsApi();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



</description>
<pubDate>Sat, 01 Sep 2018 02:59:00 +0000</pubDate>
<dc:creator>zhang90030</dc:creator>
<og:description>介绍了钉钉企业内部应用的JSAPI前端鉴权实现方式，主要包括获取token、获取ticket、获取数字签名和设置权限等步骤，中间还介绍了nodejs设置https代理的方式，以及crypto-js加密</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhang90030/p/9569515.html</dc:identifier>
</item>
<item>
<title>设计模式之--原型模式 - 代码改变世界-Coding</title>
<link>http://www.cnblogs.com/vitasyuan/p/9569404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vitasyuan/p/9569404.html</guid>
<description>&lt;h4 id=&quot;原型模式定义&quot;&gt;1.原型模式定义&lt;/h4&gt;
&lt;p&gt;原型模式非常简单，定义如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;通用类图&quot;&gt;2.通用类图&lt;/h4&gt;
&lt;p&gt;原型模式的核心是实现Cloneable接口，此接口为JDK提供的一个标识接口，只有实现了此接口的类才能被拷贝。&lt;br/&gt;原型模式的通用类图如下；&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/929184/201809/929184-20180901102215005-401900953.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;通用原型实现代码&quot;&gt;3.通用原型实现代码&lt;/h4&gt;
&lt;p&gt;原型类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ConcretePrototype implements Cloneable {

    private int id;

    private String name;

    public ConcretePrototype() {
        System.out.println(&quot;ConcretePrototype construct.&quot;);
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        ConcretePrototype concretePrototype = null;
        try {
            concretePrototype = (ConcretePrototype) super.clone();
        } catch (Exception e) {

        }
        return concretePrototype;
    }

    @Override
    public String toString() {
        return &quot;ConcretePrototype{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                '}';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Client测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Client {

    public static void main(String[] args) throws Exception {
        ConcretePrototype concretePrototype = new ConcretePrototype();
        concretePrototype.setId(123);
        concretePrototype.setName(&quot;test&quot;);

        ConcretePrototype cloneType = (ConcretePrototype) concretePrototype.clone();
        cloneType.setId(111);
        cloneType.setName(&quot;test111&quot;);
        System.out.println(concretePrototype);
        System.out.println(cloneType);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ConcretePrototype construct.
ConcretePrototype{id=123, name='test'}
ConcretePrototype{id=111, name='test111'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过输出结果可以看出，通过clone方法拷贝了一个新的对象。&lt;/p&gt;
&lt;h4 id=&quot;原型模式的优点&quot;&gt;4.原型模式的优点&lt;/h4&gt;
&lt;p&gt;1.性能优良&lt;br/&gt;原型模式是在内存中二进制流的拷贝，要比直接new一个对象快的多&lt;/p&gt;
&lt;p&gt;2.通过3中的输出结果来看，在clone对象的时候构造函数不会执行，这对于一些需要在构造函数中做一些初始化的类来说可能称为约束&lt;/p&gt;
&lt;h4 id=&quot;需要注意的点&quot;&gt;5.需要注意的点&lt;/h4&gt;
&lt;p&gt;在原型模式拷贝的时候需要注意可变引用类型的属性，下面通过一个例子来说明此问题：&lt;br/&gt;拷贝对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DeepClone implements Cloneable{

    private Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();

    public void addPair(String key, String value){
        map.put(key, value);
    }

    public Map&amp;lt;String , Object&amp;gt; getMap(){
        return map;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        DeepClone  deepClone = null;
        try {
            deepClone = (DeepClone) super.clone();
        } catch (Exception e) {

        }
        return deepClone;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Client类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Client {

    public static void main(String[] args) throws Exception {
        DeepClone deepClone = new DeepClone();
        deepClone.addPair(&quot;key1&quot;, &quot;value1&quot;);

        DeepClone clone = (DeepClone) deepClone.clone();
        clone.addPair(&quot;key2&quot;, &quot;value2&quot;);
        System.out.println(deepClone.getMap());

    }


}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{key1=value1, key2=value2}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用clone方法拷贝对象的时候引用类型的属性不会继续做拷贝，而是多个拷贝对象使用同一个属性，这种被称为浅拷贝。&lt;br/&gt;下面对clone方法重写完成深拷贝：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
protected Object clone() throws CloneNotSupportedException {
    DeepClone  deepClone = null;
    try {
        deepClone = (DeepClone) super.clone();
        Map&amp;lt;String, Object&amp;gt; cloneMap = new HashMap&amp;lt;&amp;gt;();
        cloneMap.putAll(this.map);

        deepClone.map = cloneMap;
    } catch (Exception e) {

    }
    return deepClone;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新执行client输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{key1=value1}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 01 Sep 2018 02:23:00 +0000</pubDate>
<dc:creator>代码改变世界-Coding</dc:creator>
<og:description>1.原型模式定义 原型模式非常简单，定义如下： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 2.通用类图 原型模式的核心是实现Cloneable接口，此接口为JDK提供的一个标识接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vitasyuan/p/9569404.html</dc:identifier>
</item>
</channel>
</rss>