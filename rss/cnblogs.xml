<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>iOS 加锁的方式 - 国孩</title>
<link>http://www.cnblogs.com/guohai-stronger/p/9663459.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guohai-stronger/p/9663459.html</guid>
<description>&lt;p&gt;iOS多线程编程中，经常碰到多个线程访问共同的一个资源，在线程相互交互的情况下，需要一些同步措施，来保证线程之间交互的时候是安全的。下面我们一起看一下学一下iOS的几种常用的加锁方式，希望对大家有所帮助！！！&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;@synchronized&lt;/li&gt;
&lt;li&gt;NSLock对象锁&lt;/li&gt;
&lt;li&gt;NSRecursiveLock递归锁&lt;/li&gt;
&lt;li&gt;NSConditionLock条件锁&lt;/li&gt;
&lt;li&gt;dispatch_semaphore 信号量实现加锁（也就是GCD）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;介绍与使用&lt;/h2&gt;
&lt;h3&gt;1.@synchronized&lt;/h3&gt;
&lt;p&gt;@synchronized关键字加锁，互斥锁，性能较差不推荐在项目中使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@synchronized(这里添加一个OC对象，一般使用self) {
       这里写要加锁的代码
  }&lt;br/&gt;&lt;span&gt;注意点
&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 1&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;.加锁的代码要尽量少
&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt; 2.添加的OC对象必须在多个线程中都是同一个对象
 3.它的优点是不需要显式的创建锁对象，便可以实现锁的机制。
 4. @synchronized块会隐式的添加异常处理例程来保护代码，该处理例程会在异常抛出的时候就会自动　　的释放互斥锁。如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们以一个最经典的例子：卖票&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置票的数量为5&lt;/span&gt;
    _tickets = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程1&lt;/span&gt;
    dispatch_async(self.concurrentQueue, ^&lt;span&gt;{
        [self saleTickets];
    });
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程2&lt;/span&gt;
    dispatch_async(self.concurrentQueue, ^&lt;span&gt;{
        [self saleTickets];
    });
 
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)saleTickets
{
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        &lt;span&gt;@synchronized&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt; {
            [NSThread sleepForTimeInterval:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_tickets &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                _tickets&lt;/span&gt;--&lt;span&gt;;
                NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;剩余票数= %ld, Thread:%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,_tickets,[NSThread currentThread]);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;票卖完了  Thread:%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,[NSThread currentThread]);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.NSLock&lt;/h3&gt;
&lt;p&gt;基本所有锁的接口都是通过NSLocking协议定义的，定义了lock和unlock方法，通过这些方法获取和释放锁。&lt;/p&gt;
&lt;p&gt;下面还是以卖票的例子讲述一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置票的数量为5&lt;/span&gt;
    _tickets = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建锁&lt;/span&gt;
    _mutexLock =&lt;span&gt; [[NSLock alloc] init];
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程1&lt;/span&gt;
    dispatch_async(self.concurrentQueue, ^&lt;span&gt;{
        [self saleTickets];
    });
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程2&lt;/span&gt;
    dispatch_async(self.concurrentQueue, ^&lt;span&gt;{
        [self saleTickets];
    });
 
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)saleTickets
{
 
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        [NSThread sleepForTimeInterval:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加锁&lt;/span&gt;
        [_mutexLock &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_tickets &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            _tickets&lt;/span&gt;--&lt;span&gt;;
            NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;剩余票数= %ld, Thread:%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,_tickets,[NSThread currentThread]);        
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;票卖完了  Thread:%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,[NSThread currentThread]);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解锁&lt;/span&gt;
&lt;span&gt;        [_mutexLock unlock];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.NSRecursiveLock递归锁&lt;/h3&gt;
&lt;p&gt;使用锁比较容易犯的错误是在递归或者循环中造成死锁。&lt;/p&gt;
&lt;p&gt;如下代码锁会被多次lock，造成自己被阻塞。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建锁&lt;/span&gt;
    _mutexLock =&lt;span&gt; [[NSLock alloc]init];
  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程1&lt;/span&gt;
    dispatch_async(self.concurrentQueue, ^&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;(^TestMethod)(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
        TestMethod &lt;/span&gt;= ^(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
        {
            [_mutexLock &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                [NSThread sleepForTimeInterval:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                TestMethod(value&lt;/span&gt;--&lt;span&gt;);
            }
            [_mutexLock unlock];
        };
        
        TestMethod(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果把这个NSLock换成NSRecursiveLock，就可以解决问题。&lt;/p&gt;
&lt;p&gt;NSRecursiveLock类定义的锁，可以在同一线程多次lock，不会造成死锁。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建锁&lt;/span&gt;
    _rsLock =&lt;span&gt; [[NSRecursiveLock alloc] init];
    
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程1&lt;/span&gt;
    dispatch_async(self.concurrentQueue, ^&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;(^TestMethod)(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
        TestMethod &lt;/span&gt;= ^(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
        {
            [_rsLock &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                [NSThread sleepForTimeInterval:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                TestMethod(value&lt;/span&gt;--&lt;span&gt;);
            }
            [_rsLock unlock];
        };
        
        TestMethod(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;4.NSConditionLock条件锁&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
NSMutableArray *products =&lt;span&gt; [NSMutableArray array];  
NSInteger HAS_DATA &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;  
NSInteger NO_DATA &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;), ^&lt;span&gt;{  
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {  
        [&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;&lt;span&gt; lockWhenCondition&lt;/span&gt;:NO_DATA];  
        [products addObject:[[NSObject alloc] init]];  
        NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;produce a product,总量:%zi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,products.count);  
        [&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;&lt;span&gt; unlockWithCondition&lt;/span&gt;:HAS_DATA];  
        sleep(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  
    }  
});  
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;), ^&lt;span&gt;{  
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {  
       NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;wait for product&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
        [&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; lockWhenCondition:HAS_DATA];  
       [products removeObjectAtIndex:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];  
       NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;custome a product&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
       [&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; unlockWithCondition:NO_DATA];  
    }  
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在线程1中的加锁使用了lock，所以是不要条件的，也就锁住了。但在unlock的使用整型条件，它可以开启其他线程中正在等待钥匙的临界池，当线程1循环到一次的时候，打开了线程2的阻塞。&lt;/p&gt;
&lt;p&gt;NSCoditionLock中lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，具体使用根据需求来区分。&lt;/p&gt;

&lt;h3&gt;5.dispatch_semaphore信号量实现加锁&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
dispatch_semaphore_t signal = dispatch_semaphore_create(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  
dispatch_time_t overTime &lt;/span&gt;= dispatch_time(DISPATCH_TIME_NOW, &lt;span&gt;3&lt;/span&gt; *&lt;span&gt; NSEC_PER_SEC);  
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;), ^&lt;span&gt;{  
    &lt;span&gt;dispatch_semaphore_wait&lt;/span&gt;(signal, overTime);  
            NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;需要线程同步的操作1 开始&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
            sleep(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);  
            NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;需要线程同步的操作1 结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
        &lt;span&gt;dispatch_semaphore_signal&lt;/span&gt;(signal);  
});  
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;), ^&lt;span&gt;{  
        sleep(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  
        &lt;span&gt;dispatch_semaphore_wait&lt;/span&gt;(signal, overTime);  
            NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;需要线程同步的操作2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
        &lt;span&gt;dispatch_semaphore_signal&lt;/span&gt;(signal);  
});  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dispatch_semaphore是GCD用于同步的方式，与之相关的共有三个函数，dispatch_semaphore_wait，dispatch_semaphore_signal，dispatch_semaphore_create。&lt;/p&gt;
&lt;p&gt;（1）dispatch_semaphore_create的声明为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dispatch_semaphore_t dispatch_semaphore_create(&lt;span&gt;long&lt;/span&gt; value);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;传入的参数是long类型，输出一个dispatch_semaphore_t类型值为Value的信号量（value传入值不能小于0，否则会报错NULL）&lt;/p&gt;
&lt;p&gt;（2）dispatch_semaphore_signal声明为下面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;long&lt;/span&gt; dispatch_semaphore_signal(dispatch_semaphore_t dsema); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法会使dsema加1；&lt;/p&gt;
&lt;p&gt;（3）dispatch_semaphore_wait的声明为下面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;long&lt;/span&gt; dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法会使dsema减1。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整个逻辑如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果dsema信号量值为大于0，该函数所在线程就会继续执行下面的语句，并将信号量的减去1；如果dsema为0时，函数就会阻塞当前的线程，如果等待的期间发现dsema的值被dispatch_semaphore_signal加1了，并且该函数得到了信号量，那么继续向下执行，并将信号量减1，如果等待期间没有获得信号量或者值一直为0，那么等到timeout，所处的线程也会自动执行下面的代码。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;dispatch_semaphore，当信号量为1时，可以作为锁使用。如果没有出现等待的情况，它的性能比pthread_mutex还要高，当如果有等待情况的时候，性能就会下降很多，相比OSSpinLock（暂不讲解），它的优势在于等待的时侯不会消耗CPU资源。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;针对上面代码，发现如果超时时间overTime&amp;gt;2,可完成同步操作，反之，在线程1还没有执行完的情况下，此时超时了，将自动执行下面的代码。&lt;/p&gt;
&lt;p&gt;上面代码执行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt;-&lt;span&gt;18&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;40&lt;/span&gt;:&lt;span&gt;52.324&lt;/span&gt; SafeMultiThread[&lt;span&gt;35945&lt;/span&gt;:&lt;span&gt;579032&lt;/span&gt;&lt;span&gt;] 需要线程同步的操作1 开始  
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt;-&lt;span&gt;18&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;40&lt;/span&gt;:&lt;span&gt;52.325&lt;/span&gt; SafeMultiThread[&lt;span&gt;35945&lt;/span&gt;:&lt;span&gt;579032&lt;/span&gt;&lt;span&gt;] 需要线程同步的操作1 结束  
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt;-&lt;span&gt;18&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;40&lt;/span&gt;:&lt;span&gt;52.326&lt;/span&gt; SafeMultiThread[&lt;span&gt;35945&lt;/span&gt;:&lt;span&gt;579033&lt;/span&gt;] 需要线程同步的操作2  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果将overTime&amp;lt;2s的时候，执行为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt;-&lt;span&gt;18&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;40&lt;/span&gt;:&lt;span&gt;52.049&lt;/span&gt; SafeMultiThread[&lt;span&gt;30834&lt;/span&gt;:&lt;span&gt;434334&lt;/span&gt;&lt;span&gt;] 需要线程同步的操作1 开始  
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt;-&lt;span&gt;18&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;40&lt;/span&gt;:&lt;span&gt;52.554&lt;/span&gt; SafeMultiThread[&lt;span&gt;30834&lt;/span&gt;:&lt;span&gt;434332&lt;/span&gt;&lt;span&gt;] 需要线程同步的操作2  
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt;-&lt;span&gt;18&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;40&lt;/span&gt;:&lt;span&gt;52.054&lt;/span&gt; SafeMultiThread[&lt;span&gt;30834&lt;/span&gt;:&lt;span&gt;434334&lt;/span&gt;] 需要线程同步的操作1 结束  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上就是自己在开发中所经常使用到的加锁方式，希望对大家有所帮助！！！&lt;/p&gt;

</description>
<pubDate>Tue, 18 Sep 2018 07:43:00 +0000</pubDate>
<dc:creator>国孩</dc:creator>
<og:description>iOS多线程编程中，经常碰到多个线程访问共同的一个资源，在线程相互交互的情况下，需要一些同步措施，来保证线程之间交互的时候是安全的。下面我们一起看一下学一下iOS的几种常用的加锁方式，希望对大家有所帮</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guohai-stronger/p/9663459.html</dc:identifier>
</item>
<item>
<title>CSS魔法堂：一起玩透伪元素和Content属性 - ^_^肥仔John</title>
<link>http://www.cnblogs.com/fsjohnhuang/p/9665156.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fsjohnhuang/p/9665156.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt; 继上篇《&lt;a href=&quot;https://www.cnblogs.com/fsjohnhuang/p/9551799.html&quot;&gt;CSS魔法堂：稍稍深入伪类选择器&lt;/a&gt;》记录完伪类后，我自然而然要向伪元素伸出“魔掌”的啦^_^。本文讲讲述伪元素以及功能强大的Contet属性，让我们可以通过伪元素更好地实现更多的可能！&lt;/p&gt;
&lt;h2 id=&quot;初识伪元素&quot;&gt;初识伪元素&lt;/h2&gt;
&lt;p&gt; 说起伪元素我第一想到的莫过于&lt;code&gt;::before&lt;/code&gt;和&lt;code&gt;::after&lt;/code&gt;这两个了，它俩其实就是在其附属的选择器命中的元素上插入第一个子节点和追加最后一个子节点。那这时我不禁地想问：“直接添加两个class为.before和.after不是一样的吗？”&lt;br/&gt; 其实使用伪元素&lt;code&gt;::before&lt;/code&gt;和&lt;code&gt;::after&lt;/code&gt;以下两个好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HTML的代码量减少，对SEO有帮助；&lt;/li&gt;
&lt;li&gt;提高JavaScript查询元素的效率。&lt;br/&gt; 那为什么会这两好处呢？原因就是伪元素并不存在于DOM中，而是位于CSSOM，HTML代码和DOM Tree中均没有它的身影，量少了自然效率有所提升。但这也引入一个问题——我们没办法通过JavaScript完全操控伪元素（我将在下面一节为大家讲述）&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;一大波伪元素来了&quot;&gt;一大波伪元素来了&lt;/h3&gt;
&lt;p&gt;除了&lt;code&gt;::before&lt;/code&gt;和&lt;code&gt;::after&lt;/code&gt;外，别漏了以下的哦！&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;:first-line&lt;/code&gt;：只能用于块级元素。用于设置附属元素的第一个行内容的样式。可用的CSS属性为&lt;code&gt;font,color,background,word-spacing,letter-spacing,text-decoration,vertical-align,text-transform,line-height,clear&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:first-letter&lt;/code&gt;：只能用于块级元素。用于设置附属元素的第一个字母的样式。可用的CSS属性为&lt;code&gt;font,color,background,marin,padding,border,text-decoration,vertical-align,text-transform,line-height,float,clear&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;::selection&lt;/code&gt;：匹配选中部分的内容。可用的CSS属性为&lt;code&gt;background,color&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;有没有发现有的伪元素前缀是&lt;code&gt;:&lt;/code&gt;有的却是&lt;code&gt;::&lt;/code&gt;呢？&lt;code&gt;::&lt;/code&gt;是CSS3的写法，其实除了&lt;code&gt;::selection&lt;/code&gt;外，其他伪元素既两种前缀都是可以的，为兼容性可选择使用&lt;code&gt;:&lt;/code&gt;，为容易区分伪元素和伪类则使用&lt;code&gt;::&lt;/code&gt;，但我还是建议使用&lt;code&gt;::&lt;/code&gt;来提高可读性，兼容性就让postcss等工具帮我们处理就好了。&lt;/p&gt;
&lt;h3 id=&quot;before和after的注意事项&quot;&gt;&lt;code&gt;::before&lt;/code&gt;和&lt;code&gt;::after&lt;/code&gt;的注意事项&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;默认&lt;code&gt;display: inline&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;必须设置content属性，否则一切都是无用功；&lt;/li&gt;
&lt;li&gt;默认&lt;code&gt;user-select: none&lt;/code&gt;，就是&lt;code&gt;::before&lt;/code&gt;和&lt;code&gt;::after&lt;/code&gt;的内容无法被用户选中的；&lt;/li&gt;
&lt;li&gt;伪元素和伪类结合使用形如：&lt;code&gt;.target:hover::after&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;javascript操作伪元素&quot;&gt;JavaScript操作伪元素&lt;/h2&gt;
&lt;p&gt; 上文提到由于伪元素仅位于CSSOM中，因此我们仅能通过操作CSSOM API——&lt;code&gt;window.getComputedStyle&lt;/code&gt;来读取伪元素的样式信息，注意：我们能做的就是读取，无法设置的哦！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{- window.getComputedStyle的类型 -}
data PseudoElement = &quot;:before&quot; | &quot;::before&quot; | &quot;:after&quot; | &quot;::after&quot; | &quot;:first-line&quot; | &quot;::first-line&quot; | &quot;:first-letter&quot; | &quot;::first-letter&quot; | &quot;::selection&quot; | &quot;:backdrop&quot; | &quot;::backdrop&quot; | Null

window.getComputedStyle :: HTMLElement -&amp;gt; PesudoElement -&amp;gt; CSSStyleDeclaration

{- CSSStyleDeclaration实例的方法 -}
data CSSPropertyName = &quot;float&quot; | &quot;backround-color&quot; | ......
data DOMPropertyName = &quot;cssFloat&quot; | &quot;styleFloat&quot; | &quot;backgroundColor&quot; | ......

-- IE9+的方法
CSSStyleDeclaration#getPropertyValue :: CSSPropertyName -&amp;gt; *
-- IE6~8的方法
CSSStyleDeclaration#getAttribute :: CSSPropertyName -&amp;gt; *
-- 键值对方式获取
CSSStyleDeclaration#[DOMPropertyName] -&amp;gt; *&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.target[title=&quot;hello world&quot;]::after{
  display: inline-block;
  content: attr(title);
  background: red;
  text-decoration: underline;
}

const elTarget = document.querySelector(&quot;.target&quot;)
const computedStyle = window.getComputedStyle(elTarget, &quot;::after&quot;)
const content = computedStyle.getPropertyValue(&quot;content&quot;)
const bg = computedStyle.getAttribute(&quot;backgroundColor&quot;)
const txtDecoration = computedStyle[&quot;text-decoration&quot;]

console.log(content) // &quot;hello world&quot;
console.log(bg)      // red
console.log(txtDecoration) // underline&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;玩透content属性&quot;&gt;玩透Content属性&lt;/h2&gt;
&lt;p&gt; 到这里我们已经可以利用&lt;code&gt;::before&lt;/code&gt;和&lt;code&gt;::after&lt;/code&gt;实现tooltip等效果了，但其实更为强大的且更需花时间研究的才刚要开始呢！那就是Content属性，不仅仅可以简单直接地设置一个字符串作为伪元素的内容，它还具备一定限度的编程能力，就如上面&lt;code&gt;attr(title)&lt;/code&gt;那样，以其附属元素的title特性作为content值。下面请允许我为大家介绍吧！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;div::after{
    content: &quot;普通字符串&quot;;
    content: attr(父元素的html属性名称);
    content: url(图片、音频、视频等资源的url);
    /* 使用unicode字符集，采用4位16进制编码
     * 但不同的浏览器显示存在差异，而且移动端识别度更差
     */
    content: &quot;\21e0&quot;;
    /* content的多个值可以任意组合，各部分通过空格分隔 */
    content: &quot;'&quot; attr(title) &quot;'&quot;;
    
    /* 自增计数器，用于插入数字/字母/罗马数字编号
     * counter-reset: [&amp;lt;identifier&amp;gt; &amp;lt;integer&amp;gt;?]+，必选，用于标识自增计数器的作用范围，&amp;lt;identifier&amp;gt;为自定义名称，&amp;lt;integer&amp;gt;为起始编号默认为0。
     * counter-increment: [&amp;lt;identifier&amp;gt; &amp;lt;integer&amp;gt;?]+，用于标识计数器与实际关联的范围，&amp;lt;identifier&amp;gt;为counter-reset中的自定义名称，&amp;lt;integer&amp;gt;为步长默认为1。
     * &amp;lt;list-style-type&amp;gt;: disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha
     */
    content: counter(&amp;lt;identifier&amp;gt;, &amp;lt;list-style-type&amp;gt;);
    
    /* 以父附属元素的qutoes值作为content的值
     */
    content: open-quote | close-quote | no-open-quote | no-close-quote;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;换行符：HTML实体为&lt;code&gt;&amp;amp;#010&lt;/code&gt;，CSS为&lt;code&gt;\A&lt;/code&gt;，JS为&lt;code&gt;\uA&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; 可以看到Content接受6种类型，和一种组合方式。其中最后两种比较复杂，我们后面逐一说明。&lt;/p&gt;
&lt;h3 id=&quot;自定义计数器&quot;&gt;自定义计数器&lt;/h3&gt;
&lt;p&gt; HTML为我们提供&lt;code&gt;ul&lt;/code&gt;或&lt;code&gt;ol&lt;/code&gt;和&lt;code&gt;li&lt;/code&gt;来实现列表，但如果我们希望实现更为可性化的列表，那么该如何处理呢？content属性的counter类型值就能帮到我们。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- HTML 部分--&amp;gt;
.dl
 .dt{chapter1}
 .dd{text11}
 .dd{text12}
 .dt{chapter2}
 .dd{text21}
 
/* CSS部分 */
.dl {
  counter-reset: dt 0; /* 表示解析到.dl时，重置dt计数器为0 */
  
  &amp;amp; .dt {
    counter-reset: dd 0; /* 表示解析到.dt时，重置dd计数器为0 */
    
    &amp;amp;::before{
        counter-increment: dt 1; /* 表示解析到.dt时，dt计数器自增1 */
        content: counter(dt, lower-roman) &quot; &quot;;
    }
  }
  
  &amp;amp; .dd::before {
    counter-increment: dd 1; /* 表示解析到.dd时，dd计数器自增1 */
    content: counter(dd) &quot; &quot;;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/347002/201809/347002-20180917215116373-954063412.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;counter-reset&lt;/code&gt;来定义和重置计数器，通过&lt;code&gt;counter-increment&lt;/code&gt;来增加计数器的值，然后通过&lt;code&gt;counter&lt;/code&gt;来决定使用哪个计数器，并指定使用哪种样式。&lt;br/&gt; 如果用JavaScript来表示应该是这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const globalCounters = {&quot;__temp&quot;:{}}

function resetCounter(name, value){
  globalCounters[name] = value
}
function incrementCounter(name, step){
  const oVal = globalCounters[name]
  if (oVal){
    globalCounters[name] = oVal + step
  }
  else{
    globalCounters.__temp[name] = step
  }
}
function counter(name, style){
    return globalCounters[name] || globalCounters.__temp[name]
}

function applyCSS(mount){
    const clz = mount.className
    if (clz == &quot;dl&quot;){
        resetCounter(&quot;dt&quot;, 0)
        const children = mount.children
        for (let i = 0; i &amp;lt; children.length; ++i){
          applyCSS(children[i])
        }
    }
    else if (clz == &quot;dt&quot;){
        resetCounter(&quot;dd&quot;, 0)
        incrementCounter(&quot;dt&quot;, 1)
        const elAsBefore = document.createElement(&quot;span&quot;)
        elAsBefore.textContent = counter(&quot;dt&quot;, &quot;lower-roman&quot;) + &quot; &quot;
        mount.insertBefore(mount.firstChild)
    }
    else if (clz == &quot;dd&quot;){
        incrementCounter(&quot;dd&quot;, 1)
        const elAsBefore = document.createElement(&quot;span&quot;)
        elAsBefore.textContent = counter(&quot;dd&quot;, &quot;lower-roman&quot;) + &quot; &quot;
        mount.insertBefore(mount.firstChild)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;嵌套计数器&quot;&gt;嵌套计数器&lt;/h4&gt;
&lt;p&gt; 对于多层嵌套计数器我们可以使用&lt;code&gt;counters(&amp;lt;identifier&amp;gt;, &amp;lt;separator&amp;gt;, &amp;lt;list-style-type&amp;gt;?)&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;.ol
  .li
    .ol
      .li{a}
      .li{b}
  .li
    .ol
      .li{c}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.ol {
    counter-reset: ol;
    &amp;amp; .li::before {
        counter-increment: ol;
        content: counters(ol, &quot;.&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;content的限制&quot;&gt;Content的限制&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;IE8+才支持Content属性；&lt;/li&gt;
&lt;li&gt;除了Opera9.5+中所有元素均支持外，其他浏览器仅能用于&lt;code&gt;:before,:after&lt;/code&gt;内使用；&lt;/li&gt;
&lt;li&gt;无法通过JS获取Counter和Counters的运算结果。得到的就只能是&lt;code&gt;&quot;counter(mycouonter) \&quot; \&quot;&quot;&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;自定义引号&quot;&gt;自定义引号&lt;/h3&gt;
&lt;p&gt; 引号这个平时很少在意的符号，其实在不同的文化中使用的引号将不尽相同，如简体中文地区使用的&lt;code&gt;&quot;&quot;&lt;/code&gt;，而日本则使用&lt;code&gt;「」&lt;/code&gt;。那我们根据需求自定义引号呢？答案是肯定的。&lt;br/&gt; 通过&lt;code&gt;open-quote&lt;/code&gt;,&lt;code&gt;close-quote&lt;/code&gt;,&lt;code&gt;no-open-quote&lt;/code&gt;和&lt;code&gt;no-close-quote&lt;/code&gt;即可实现，下面我们通过例子来理解。&lt;br/&gt; &lt;code&gt;&amp;lt;q&amp;gt;&lt;/code&gt;会根据父元素的&lt;code&gt;lang&lt;/code&gt;属性自动创建&lt;code&gt;::before&lt;/code&gt;和&lt;code&gt;::after&lt;/code&gt;来实现插入quotation marks。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;p[lang=en]&amp;gt;q{英语}
p[lang=no]&amp;gt;q{挪威语}
p[lang=zh]&amp;gt;q{汉语}
p[lang=en]&amp;gt;q.no-quote{英语2}
div[lang=no]&amp;gt;.quote{挪威语2}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CSS片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p[lang=en] &amp;gt; q{
  quotes: &quot;&amp;lt;!--&quot; &quot;--&amp;gt;&quot;; /* 定义引号 */
}
p[lang=en] &amp;gt; q.no-quote::before{
  content: no-open-quote;
  /*或者 content: none;*/
}
div[lang=no] &amp;gt; .quote {
  quotes: &quot;&amp;lt;&amp;lt;-&quot; &quot;-&amp;gt;&amp;gt;&quot;;
}
div[lang=no] &amp;gt; .quote::before {
  content: open-quote;
}
div[lang=no] &amp;gt; .quote::after {
  content: close-quote;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/347002/201809/347002-20180917215144433-1085134067.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;h3 id=&quot;分割线&quot;&gt;分割线&lt;/h3&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;p.sep{or}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.sep {
  position: relative;
  text-align: center;
  
  &amp;amp;::before,
  &amp;amp;::after {
    content: &quot;&quot;;
    box-sizing: border-box;
    height: 1px;
    width: 50%;
    border-left: 3em solid transparent;
    border-right: 3em solid transparent;
    position: absolute;
    top: 50%;
  }
  
  &amp;amp;::before {
    left: 0;
  }
  
  &amp;amp;::after {
    right: 0;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;只读效果通过遮罩原来的元素实现&quot;&gt;只读效果(通过遮罩原来的元素实现)&lt;/h3&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;.input-group {
  position: relative;
  
  &amp;amp;.readonly::before {
    content: &quot;&quot;;
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;计数器&quot;&gt;计数器&lt;/h3&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;.selections&amp;gt;input[type=checkbox]{option1}+input[type=checkbox]{option2}
.selection-count&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.selections{
  counter-reset: selection-count;
  
  &amp;amp; input:checked {
    counter-increment: selection-count;
  }
}
.selection-count::before {
  content: counter(selection-count);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt; 尊重原创，转载请注明来自：&lt;a href=&quot;https://www.cnblogs.com/fsjohnhuang/p/9665156.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/fsjohnhuang/p/9665156.html&lt;/a&gt; 肥仔John^_^&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.wozhuye.com/compatible/297.html&quot; class=&quot;uri&quot;&gt;http://www.wozhuye.com/compatible/297.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://dev.opera.com/articles/css-generated-content-techniques/&quot; class=&quot;uri&quot;&gt;https://dev.opera.com/articles/css-generated-content-techniques/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 07:35:00 +0000</pubDate>
<dc:creator>^_^肥仔John</dc:creator>
<og:description>前言  继上篇《</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fsjohnhuang/p/9665156.html</dc:identifier>
</item>
<item>
<title>微信分享大图遇到的问题（Android） - 懒星人</title>
<link>http://www.cnblogs.com/lanxingren/p/9669036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lanxingren/p/9669036.html</guid>
<description>&lt;p&gt;要做一个微信图片分享的功能，但是对于大图会如下问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1410837/201809/1410837-20180918141230201-1745381659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当时没有仔细查看错误日志，单纯的以为是图片太大的问题。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; WXsharePic(String transaction, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isSession, Bitmap bitmap) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化WXImageObject和WXMediaMessage对象&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     WXImageObject imageObject = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WXImageObject(bitmap);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     WXMediaMessage msg = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WXMediaMessage();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     msg.mediaObject =&lt;span&gt; imageObject;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置缩略图&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     Bitmap scaledBitmap = Bitmap.createScaledBitmap(bitmap, 200, 200, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    bitmap.recycle();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     msg.thumbData =&lt;span&gt; getBitmapByte(scaledBitmap);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造一个Req&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     SendMessageToWX.Req req = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SendMessageToWX.Req();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     req.transaction = transaction +&lt;span&gt; Long.toString(System.currentTimeMillis());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     req.message =&lt;span&gt; msg;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示发送给朋友圈  WXSceneTimeline  表示发送给朋友  WXSceneSession&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     req.scene = isSession ?&lt;span&gt; SendMessageToWX.Req.WXSceneSession : SendMessageToWX.Req.WXSceneTimeline;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用api接口发送数据到微信&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    api.sendReq(req);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;想法一：&lt;/h3&gt;
&lt;p&gt;查看微信的文档，发现如下信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1410837/201809/1410837-20180918143025959-48561425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;初步判定是略缩图过大导致的，准备对略缩图进一步压缩。&lt;/p&gt;
&lt;p&gt;但是在调试过程中发现略缩图并没有超过32K，于是&lt;span&gt;这种想法不正确&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;想法二：&lt;/h3&gt;
&lt;p&gt;既然不是略缩图过大，那大概率就是原图过大了。然而微信官方文档上也没有说明原图大小限制，所以也不知道是否是这个原因。&lt;/p&gt;
&lt;p&gt;于是准备测试一下是否是这个原因，对原图进一步压缩。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] bitmap2Bytes(Bitmap bitmap, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxkb) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     ByteArrayOutputStream output = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     bitmap.compress(Bitmap.CompressFormat.PNG, 100&lt;span&gt;, output);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; options = 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (output.toByteArray().length &amp;gt; maxkb&amp;amp;&amp;amp; options != 10&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         output.reset(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空output&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         bitmap.compress(Bitmap.CompressFormat.JPEG, options, output);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里压缩options%，把压缩后的数据存放到output中&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         options -= 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; output.toByteArray();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从代码可知，设置了一个最大kb值，并每次循环压缩率递减10%.&lt;/p&gt;
&lt;p&gt;然而实际运行中发现无论maxkb设置的多小，还是会出这个问题。&lt;/p&gt;
&lt;p&gt;仔细调试发现，原图大小为3M多，即使是最小10%的压缩率也过大了。&lt;/p&gt;
&lt;p&gt;于是将压缩率递减改为1%.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;将压缩率递减改为1%，并且maxkb设置为500KB时，就没问题了！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，有两个很严重的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.微信的原图最大只能是500KB吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.循环压缩所需时间太久，差不多半分钟才能压缩完毕，效率太低。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;想法三：&lt;/h3&gt;
&lt;p&gt;这个时候，我才开始注意起错误日志来。&lt;/p&gt;
&lt;p&gt;错误日志是Binder类出现的，字面意思是数据过大。查看微信的SDK源码可以发现实际上调用微信API，微信会将图片传递给一个新的活动。&lt;/p&gt;
&lt;p&gt;而&lt;span&gt;Intent传值有大小限制，最大只能512KB&lt;/span&gt;！&lt;/p&gt;
&lt;p&gt;现在错误原因知道了，&lt;strong&gt;&lt;span&gt;微信分享图片会涉及到启动一个新活动，而新活动涉及到Intent传值，而Intent传值有大小限制，于是就会出问题。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可是如何解决呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;既然直接传图片的Bitmap太大，那就把图片先保存在本地，然后直接传递图片的地址。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;分享图片：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; WXsharePic(String transaction, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isSession, Bitmap bitmap, String path) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化WXImageObject和WXMediaMessage对象&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    WXImageObject imageObject;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;StringUtil.isBlank(path)) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         imageObject = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WXImageObject();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        imageObject.setImagePath(path);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         imageObject = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WXImageObject(bitmap);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     WXMediaMessage msg = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WXMediaMessage();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     msg.mediaObject =&lt;span&gt; imageObject;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置缩略图&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     Bitmap scaledBitmap = Bitmap.createScaledBitmap(bitmap, 200, 200, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    bitmap.recycle();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     msg.thumbData =&lt;span&gt; getBitmapByte(scaledBitmap);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造一个Req&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     SendMessageToWX.Req req = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SendMessageToWX.Req();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     req.transaction = transaction +&lt;span&gt; Long.toString(System.currentTimeMillis());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     req.message =&lt;span&gt; msg;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示发送给朋友圈  WXSceneTimeline  表示发送给朋友  WXSceneSession&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     req.scene = isSession ?&lt;span&gt; SendMessageToWX.Req.WXSceneSession : SendMessageToWX.Req.WXSceneTimeline;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用api接口发送数据到微信&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    api.sendReq(req);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;调用分享：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; shareToMoment() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Bitmap sharePicture =&lt;span&gt; getBitmapByView(svShare);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     AndPermission.with(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            .permission(Permission.WRITE_EXTERNAL_STORAGE)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             .onGranted(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Action() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onAction(List&amp;lt;String&amp;gt;&lt;span&gt; permissions) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     String path =&lt;span&gt; saveImageToGallery(sharePicture);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     WXsharePic(&quot;he&quot; + System.currentTimeMillis(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, sharePicture, path);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             .onDenied(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Action() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onAction(@NonNull List&amp;lt;String&amp;gt;&lt;span&gt; permissions) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     Log.e(&quot;Activity&quot;, &quot;权限申请失败&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            .start();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;保存图片：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String saveImageToGallery(Bitmap bmp) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先保存图片&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;      String storePath = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + &quot;dearxy&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      File appDir = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(storePath);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;appDir.exists()) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;         appDir.mkdir();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      String fileName = System.currentTimeMillis() + &quot;.jpg&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      File file = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(appDir, fileName);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;          FileOutputStream fos = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(file);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过io流的方式来压缩保存图片&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;          bmp.compress(Bitmap.CompressFormat.JPEG, 60&lt;span&gt;, fos);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;         fos.flush();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;         fos.close();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;      } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;         e.printStackTrace();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;      &lt;span&gt;return&lt;/span&gt; storePath + &quot;/&quot; +&lt;span&gt; fileName;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;&lt;li&gt;遇到问题直接查看错误日志，找到问题的根源，不能想当然；&lt;/li&gt;
&lt;li&gt;对于安卓基础的了解有待加强；&lt;/li&gt;
&lt;li&gt;总算明白了为什么QQ分享需要请求存储权限；&lt;/li&gt;
&lt;li&gt;BAT现在是大家，对于他们的API需要熟悉了解。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大家如果有什么疑问或者建议可以通过评论或者&lt;a href=&quot;mailto:he_jhua@foxmail.com&quot; target=&quot;_blank&quot;&gt;邮件&lt;/a&gt;的方式联系我，欢迎大家的评论~&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 07:12:00 +0000</pubDate>
<dc:creator>懒星人</dc:creator>
<og:description>分享微信大图中遇到的问题总结。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lanxingren/p/9669036.html</dc:identifier>
</item>
<item>
<title>每周一个linux命令之---uptime详解 - vinter_he</title>
<link>http://www.cnblogs.com/vinter/p/9668896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vinter/p/9668896.html</guid>
<description>&lt;p&gt;linux命令 uptime详解&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;引言：从今天开始，每周更新一个对程序员有用的linux命令，我真的没敢写每天一个，我怕我坚持不下去，每周一个还是可以的。既然每周一个了，就肯定不能拿ls，chmod这种命令来凑数了。降低数量，保障质量。与大家共勉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进入正题&lt;/p&gt;
&lt;h2 id=&quot;uptime&quot;&gt;uptime&lt;/h2&gt;
&lt;p&gt;我们先来看一下命令执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;11:10:42 up 4 days, 19:23,  2 users,  load average: 3.17, 3.45, 3.65
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来分组解释一下，大概分成一下几个部分&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统当前时间 11:10:42&lt;/li&gt;
&lt;li&gt;up 4 days, 19:23 从上次启动开始系统运行的时间&lt;/li&gt;
&lt;li&gt;2 users 注意这里实际是连接数量，可以自己测试出来，同一用户多个连接的时候算多个&lt;/li&gt;
&lt;li&gt;load average: 3.17, 3.45, 3.65 这是重头戏，分别描述了1分钟5分钟15分钟内系统平均负载&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们使用man uptime命令进行查询uptime的说明如下（man命令不了解的稍微百度一下就明白，这是一个类似手册的功能）&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注：一般我们使用 uptime -h 即命令加-h或--help的形式得到的是比较简单的帮助文档，而man命令一般会给出更详细的解释，不过一般都是英文的，其实也没有太难的词语希望大家坚持英文阅读。提高技术水平的同时也潜移默化的提高了英语水平&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;uptime  gives  a  one  line display of the following information.
       The current time, how long the system has been running, how  many
       users  are  currently logged on, and the system load averages for
       the past 1, 5, and 15 minutes.

       This is the same information contained in the  header  line  dis‐
       played by w(1).

       System  load averages is the average number of processes that are
       either in a runnable or uninterruptable state.  A  process  in  a
       runnable state is either using the CPU or waiting to use the CPU.
       A process in  uninterruptable  state  is  waiting  for  some  I/O
       access,  eg  waiting  for  disk.  The averages are taken over the
       three time intervals.  Load averages are not normalized  for  the
       number of CPUs in a system, so a load average of 1 means a single
       CPU system is loaded all the time while on  a  4  CPU  system  it
       means it was idle 75% of the time.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然我知道大部分童鞋是不想看那么长串的英文的，我翻译了一下如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;uptime 在一行中给了如下信息：当前时间，系统已经运行了多久，多少用户连接目前正在使用系统，系统在过去1,5,15分钟内的平均负载。&lt;br/&gt;这与w（1）显示的标题行中包含相同的信息。&lt;br/&gt;系统负载平均值是处于可运行或不可中断状态的平均进程数。 进程在可运行状态是指进程正在使用CPU或等待使用CPU。 处于不可中断状态的进程是指的进程正在等待某些I/O访问，例如等待磁盘。 平均值是在三个时间间隔内取得的。 对于系统中的CPU数量，负载平均值没有标准化，因此负载平均值为1意味着单个CPU系统一直在加载，而在4 CPU系统上，这意味着它在75％的时间内处于空闲状态。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里我们做一个比喻便于理解，我们把处于可运行或不可中断状态的的平均进程数量比喻成货物数量，而cpu可以理解为传送带。货物数量是1个的话，如果只有一条传送带，那么传送带就是满负荷运行，如果有4个传送带，那么就有三条空闲（即上文说的75%空闲）。平均负载就可以理解为一段时间内的平均货物数量。&lt;/p&gt;
&lt;p&gt;接下来我们学习一下uptime可携带的参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;OPTIONS
       -p, --pretty
              show uptime in pretty format//以比较友好的格式输出

       -h, --help
              display this help text//显示帮助选项

       -s, --since
              system up since, in yyyy-mm-dd HH:MM:SS format//系统启动时间

       -V, --version
              display version information and exit//版本信息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@dev1:~$ uptime -p
up 4 days, 22 hours, 38 minutes
@dev1:~$ uptime -s
2018-09-13 15:47:04
@dev1:~$ uptime -V
uptime from procps-ng 3.3.10
@dev1:~$ uptime -h

Usage:
 uptime [options]

Options:
 -p, --pretty   show uptime in pretty format
 -h, --help     display this help and exit
 -s, --since    system up since
 -V, --version  output version information and exit

For more details see uptime(1).&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面顺便提一下怎么查系统的cpu核心数量。（方法有很多种，我觉得这种最好记忆）&lt;/p&gt;
&lt;h2 id=&quot;lscpu&quot;&gt;lscpu&lt;/h2&gt;
&lt;p&gt;这个命令应该是比较好记的，毕竟ls，cpu这两个我们都记得了。&lt;br/&gt;这里面显示了很多选项。其中cpu(s)：数量表明了cpu的个数。如下图&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Architecture:          x86_64 //cpu架构
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian//小端（低位字节存储在内存的低地址端 intel的cpu一般是小端，amd的一般是大端 Big Endian）
CPU(s):                4//cpu数量
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他参数以后再讲吧。一篇文章太长了不利于学习和记忆。&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 06:53:00 +0000</pubDate>
<dc:creator>vinter_he</dc:creator>
<og:description>每周一个linux命令之 uptime详解 linux命令 uptime详解 引言：从今天开始，每周更新一个对程序员有用的linux命令，我真的没敢写每天一个，我怕我坚持不下去，每周一个还是可以的。既</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vinter/p/9668896.html</dc:identifier>
</item>
<item>
<title>2018年9月CSP CCF认证考试 经验 - CF过2100就买ARCTERYX</title>
<link>http://www.cnblogs.com/yichuan-sun/p/9668857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichuan-sun/p/9668857.html</guid>
<description>&lt;p&gt;这一两个月全忙着做这个CSP和PAT了。上上周刚去北京工业大学考完PAT，上周日（今天周二）又去人大考CSP，学校在昌平真不方便。&lt;/p&gt;
&lt;p&gt;CSP可以携带纸质资料，但我匆匆打印的六七个模板全都没用上，那两本算法书也是翻开都没翻开。我在人大用的显示屏很大，差不多和苹果一体机的显示器那么大。电脑里预装的IDE我记得有eclipse、codeblocks（但是内部没有GNU，也就是说codeblocks不能用）、devc++、别的还有我叫不上名字的，我忘了。我用的是devc++，但是同样不能调试。按照我参加以往所有比赛的经验，&lt;strong&gt;对于所有的比赛，几乎都不能用IDE内置的调试功能&lt;/strong&gt;，这要求我们会用&lt;strong&gt;打印调试&lt;/strong&gt;，也就是结合system(&quot;pause&quot;)，用输出数据来进行肉眼调试。我就是这样把第四题的一个用例调试对的。&lt;/p&gt;
&lt;p&gt;还有一点需要注意，&lt;strong&gt;程序提交之后不能查看运行结果，也就是说，不知道自己做的对还是错，即使自己写的编译错误了，0分了，也不知道&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;题目的难度嘛，与我做过的往届的真题相比较，是偏简单的。第一题水题，第二题更是简单得无以复加，也就是上一届第一题的难度吧，反正前两个题不到二十分钟就过了，满分。接着后面的三个半小时，我才拿了40分。。。菜的抠脚。。。&lt;/p&gt;
&lt;p&gt;第三题又体现了csp的风格，是一道奇长无比的字符串模拟题，光题干打印出来得有五六页A4纸。看呀看想呀想，先跳过，大模拟最后做，免得脑子不够用。&lt;/p&gt;
&lt;p&gt;第四题我想用搜索来做，但是写错了，写了俩多小时，接近三小时，写成了对非降序列才有效的算法，我又不知道下一步该怎么改，于是想暴力骗一波分，结果骗分程序又写错了，于是就gg了。巧了用例里应该恰好有一个非降序列，让我蒙对了10分。&lt;/p&gt;
&lt;p&gt;第五题看半天，一头雾水，直接没做。&lt;/p&gt;
&lt;p&gt;一看时间还有快一个小时，于是去写第三题大模拟，写的很顺，对前两个测试点应该没问题，交上，运气好，多对了一个，30分。&lt;/p&gt;
&lt;p&gt;看看还有半小时，但是实在坐不下去了，黔驴技穷了，就走了。在人大校园内买了几个月饼回去给同学，就坐上地铁走了。12月还得再来一次。&lt;/p&gt;
&lt;p&gt;今天出分，我写此文。过CCSP考试线了，准备去杭州。进无止境。!&lt;/p&gt;
&lt;p&gt;附上一张人大图书馆的全景照&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486725/201809/1486725-20180918144854205-700744254.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以及人大的校徽纪念月饼，比我学校的校徽纪念月饼好吃，但是价格也是十多倍￣ω￣=&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486725/201809/1486725-20180918145019298-955230385.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 06:48:00 +0000</pubDate>
<dc:creator>CF过2100就买ARCTERYX</dc:creator>
<og:description>这一两个月全忙着做这个CSP和PAT了。上上周刚去北京工业大学考完PAT，上周日（今天周二）又去人大考CSP，学校在昌平真不方便。 CSP可以携带纸质资料，但我匆匆打印的六七个模板全都没用上，那两本算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yichuan-sun/p/9668857.html</dc:identifier>
</item>
<item>
<title>分布式系统消息中间件——RabbitMQ的使用基础篇 - 人在江湖`飘</title>
<link>http://www.cnblogs.com/hunternet/p/9668851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hunternet/p/9668851.html</guid>
<description>&lt;h2 id=&quot;分布式系统消息中间件rabbitmq的使用基础篇&quot;&gt;分布式系统消息中间件——RabbitMQ的使用基础篇&lt;/h2&gt;
&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;    我是在解决分布式事务的一致性问题时了解到RabbitMQ的，当时主要是要基于RabbitMQ来实现我们分布式系统之间对有事务可靠性要求的系统间通信的。关于分布式事务一致性问题及其常见的解决方案，可以看我另一篇博客。提到RabbitMQ，不难想到的几个关键字:消息中间件、消息队列。而消息队列不由让我想到，当时在大学学习操作系统这门课，消息队列不难想到生产者消费者模式。(PS:操作系统这门课程真的很好也很重要，其中的一些思想在我工作的很长一段一时间内给了我很大帮助和启发，给我提供了许多解决问题的思路。强烈建议每一个程序员都去学一学操作系统！)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-8/59528487.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;一-消息中间件&quot;&gt;一 消息中间件&lt;/h4&gt;
&lt;h5 id=&quot;简介&quot;&gt;1.1 简介&lt;/h5&gt;
&lt;p&gt;    消息中间件也可以称消息队列，是指用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息队列模型，可以在分布式环境下扩展进程的通信。当下主流的消息中间件有RabbitMQ、Kafka、ActiveMQ、RocketMQ等。其能在不同平台之间进行通信，常用来屏蔽各种平台协议之间的特性，实现应用程序之间的协同。其优点在于能够在客户端和服务器之间进行同步和异步的连接，并且在任何时刻都可以将消息进行传送和转发。是分布式系统中非常重要的组件，主要用来解决应用耦合、异步通信、流量削峰等问题。&lt;/p&gt;
&lt;h5 id=&quot;作用&quot;&gt;2.2 作用&lt;/h5&gt;
&lt;p&gt;    消息中间件几大主要作用如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解耦&lt;/li&gt;
&lt;li&gt;冗余(存储)&lt;/li&gt;
&lt;li&gt;扩展性&lt;/li&gt;
&lt;li&gt;削峰&lt;/li&gt;
&lt;li&gt;可恢复性&lt;/li&gt;
&lt;li&gt;顺序保证&lt;/li&gt;
&lt;li&gt;缓冲&lt;/li&gt;
&lt;li&gt;异步通信&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;消息中间件的两种模式&quot;&gt;2.3 消息中间件的两种模式&lt;/h5&gt;
&lt;h6 id=&quot;p2p模式&quot;&gt;2.3.1 P2P模式&lt;/h6&gt;
&lt;p&gt;    P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。&lt;/p&gt;
&lt;p&gt;P2P的特点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)&lt;/li&gt;
&lt;li&gt;发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行它不会影响到消息被发送到队列&lt;/li&gt;
&lt;li&gt;接收者在成功接收消息之后需向队列应答成功&lt;/li&gt;
&lt;li&gt;如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;pubsub模式&quot;&gt;2.3.2 Pub/Sub模式&lt;/h6&gt;
&lt;p&gt;    Pub/Sub模式包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。&lt;/p&gt;
&lt;p&gt;Pub/Sub的特点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个消息可以有多个消费者&lt;/li&gt;
&lt;li&gt;发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。&lt;/li&gt;
&lt;li&gt;为了消费消息，订阅者必须保持运行的状态。&lt;/li&gt;
&lt;li&gt;如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;常用中间件介绍与对比&quot;&gt;2.4 常用中间件介绍与对比&lt;/h5&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache定级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;RabbitMQ比Kafka可靠，kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。&lt;/p&gt;
&lt;h4 id=&quot;二-rabbitmq了解&quot;&gt;二 RabbitMQ了解&lt;/h4&gt;
&lt;h5 id=&quot;简介-1&quot;&gt;2.1 简介&lt;/h5&gt;
&lt;p&gt;    RabbitMQ是流行的开源消息队列系统。RabbitMQ是AMQP（高级消息队列协议）的标准实现。支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。同时实现了一个Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由(Routing)，负载均衡(Load balance)或者数据持久化都有很好的支持。其主要特点如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可靠性&lt;/li&gt;
&lt;li&gt;灵活的路由&lt;/li&gt;
&lt;li&gt;扩展性&lt;/li&gt;
&lt;li&gt;高可用性&lt;/li&gt;
&lt;li&gt;多种协议&lt;/li&gt;
&lt;li&gt;多语言客户端&lt;/li&gt;
&lt;li&gt;管理界面&lt;/li&gt;
&lt;li&gt;插件机制&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;概念&quot;&gt;2.2 概念&lt;/h5&gt;
&lt;p&gt;    RabbitMQ从整体上来看是一个典型的生产者消费者模型，主要负责接收、存储和转发消息。其整体模型架构如下图所示:&lt;img src=&quot;http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-9/84394083.jpg&quot; alt=&quot;RabbitMQ 模型架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先来看一个RabbitMQ的运转流程，稍后会对这个流程中所涉及到的一些概念进行详细的解释。&lt;/p&gt;
&lt;p&gt;生产者:&lt;/p&gt;
&lt;p&gt;(1)生产者连接到RabbitMQ Broker，建立一个连接( Connection)开启一个信道(Channel)&lt;br/&gt;(2)生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等&lt;br/&gt;(3)生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等&lt;br/&gt;(4)生产者通过路由键将交换器和队列绑定起来&lt;br/&gt;(5)生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息。&lt;br/&gt;(6)相应的交换器根据接收到的路由键查找相匹配的队列。&lt;br/&gt;(7)如果找到，则将从生产者发送过来的消息存入相应的队列中。&lt;br/&gt;(8)如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者&lt;br/&gt;(9)关闭信道。&lt;br/&gt;(10)关闭连接。'&lt;/p&gt;
&lt;p&gt;消费者:&lt;/p&gt;
&lt;p&gt;(1)消费者连接到RabbitMQ Broker ，建立一个连接(Connection)，开启一个信道(Channel) 。&lt;br/&gt;(2)消费者向RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，&lt;br/&gt;(3)等待RabbitMQ Broker 回应并投递相应队列中的消息，消费者接收消息。&lt;br/&gt;(4)消费者确认(ack) 接收到的消息。&lt;br/&gt;(5)RabbitMQ 从队列中删除相应己经被确认的消息。&lt;br/&gt;(6)关闭信道。&lt;/p&gt;
&lt;p&gt;(7)关闭连接。&lt;/p&gt;
&lt;h6 id=&quot;信道&quot;&gt;2.2.1 信道&lt;/h6&gt;
&lt;p&gt;这里我们主要讨论两个问题：&lt;/p&gt;
&lt;p&gt;为何要有信道?&lt;/p&gt;
&lt;p&gt;    主要原因还是在于TCP连接的&quot;昂贵&quot;性。无论是生产者还是消费者，都需要和RabbitMQ Broker 建立连接，这个连接就是一条TCP 连接。而操作系统对于TCP连接的创建于销毁是非常昂贵的开销。假设消费者要消费消息，并根据服务需求合理调度线程，若只进行TCP连接，那么当高并发的时候，每秒可能都有成千上万的TCP连接，不仅仅是对TCP连接的浪费，也很快会超过操作系统每秒所能建立连接的数量。如果能在一条TCP连接上操作，又能保证各个线程之间的私密性就完美了，于是信道的概念出现了。&lt;/p&gt;
&lt;p&gt;信道为何?&lt;/p&gt;
&lt;p&gt;    信道是建立在Connection 之上的虚拟连接。当应用程序与Rabbit Broker建立TCP连接的时候，客户端紧接着可以创建一个AMQP 信道(Channel) ，每个信道都会被指派一个唯一的D。RabbitMQ 处理的每条AMQP 指令都是通过信道完成的。信道就像电缆里的光纤束。一条电缆内含有许多光纤束，允许所有的连接通过多条光线束进行传输和接收。&lt;/p&gt;
&lt;h6 id=&quot;生产者消费者&quot;&gt;2.2.2 生产者消费者&lt;/h6&gt;
&lt;p&gt;    关于生产者消费者我们需要了解几个概念:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Producer:生产者，即消息投递者一方。&lt;/li&gt;
&lt;li&gt;消息:消息一般分两个部分:消息体(payload)和标签。标签用来描述这条消息，如:一个交换器的名称或者一个路由Key，Rabbit通过解析标签来确定消息的去向，payload是消息内容可以使一个json，数组等等。&lt;/li&gt;
&lt;li&gt;Consumer:消费者，就是接收消息的一方。消费者订阅RabbitMQ的队列，当消费者消费一条消息时，只是消费消息的消息体。在消息路由的过程中，会丢弃标签，存入到队列中的只有消息体。&lt;/li&gt;
&lt;li&gt;Broker:消息中间件的服务节点。&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;队列交换器路由key绑定&quot;&gt;2.2.3 队列、交换器、路由key、绑定&lt;/h6&gt;
&lt;p&gt;    从RabbitMQ的运转流程我们可以知道生产者的消息是发布到交换器上的。而消费者则是从队列上获取消息的。那么消息到底是如何从交换器到队列的呢?我们先具体了解一下这几个概念。&lt;/p&gt;
&lt;p&gt;    Queue:队列，是RabbitMQ的内部对象，用于存储消息。RabbitMQ中消息只能存储在队列中。生产者投递消息到队列，消费者从队列中获取消息并消费。多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊(轮询)给多个消费者进行消费，而不是每个消费者都收到所有的消息进行消费。(注意：RabbitMQ不支持队列层面的广播消费，如果需要广播消费，可以采用一个交换器通过路由Key绑定多个队列，由多个消费者来订阅这些队列的方式。)&lt;/p&gt;
&lt;p&gt;    Exchange：交换器。在RabbitMQ中，生产者并非直接将消息投递到队列中。真实情况是，生产者将消息发送到Exchange(交换器)，由交换器将消息路由到一个或多个队列中。如果路由不到，或返回给生产者，或直接丢弃，或做其它处理。&lt;/p&gt;
&lt;p&gt;    RoutingKey:路由Key。生产者将消息发送给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则。这个路由Key需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键固定的情况下，生产者可以在发送消息给交换器时通过指定RoutingKey来决定消息流向哪里。&lt;/p&gt;
&lt;p&gt;    Binding：RabbitMQ通过绑定将交换器和队列关联起来，在绑定的时候一般会指定一个绑定键，这样RabbitMQ就可以指定如何正确的路由到队列了。&lt;/p&gt;
&lt;p&gt;    从这里我们可以看到在RabbitMQ中交换器和队列实际上可以是一对多，也可以是多对多关系。交换器和队列就像我们关系数据库中的两张表。他们同归BindingKey做关联(多对多关系表)。在我们投递消息时，可以通过Exchange和RoutingKey(对应BindingKey)就可以找到相对应的队列。&lt;/p&gt;
&lt;p&gt;    RabbitMQ主要有四种类型的交换器:&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;fanout：扇形交换器，它会把发送到该交换器的消息路由到所有与该交换器绑定的队列中。如果使用扇形交换器，则不会匹配路由Key。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/39683646.jpg&quot; alt=&quot;RabbitMQ Fanout交换器&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;direct:direct交换器，会把消息路由到RoutingKey与BindingKey完全匹配的队列中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/40498280.jpg&quot; alt=&quot;RabbitMQ direct交换器&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;topic:完全匹配BindingKey和RoutingKey的direct交换器 有些时候并不能满足实际业务的需求。topic 类型的交换器在匹配规则上进行了扩展，它与direct 类型的交换器相似，也是将消息路由到BindingKey 和RoutingKey 相匹配的队&lt;br/&gt;列中，但这里的匹配规则有些不同，它约定:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RoutingKey 为一个点号&quot;.&quot;分隔的字符串(被点号&quot;.&quot;分隔开的每一段独立的字符&lt;br/&gt;串称为一个单词)λ，如&quot;hs.rabbitmq.client&quot;，&quot;com.rabbit.client&quot;等。&lt;/li&gt;
&lt;li&gt;BindingKey 和RoutingKey 一样也是点号&quot;.&quot;分隔的字符串;&lt;/li&gt;
&lt;li&gt;BindingKey 中可以存在两种特殊字符串&quot;*&quot;和&quot;#&quot;，用于做模糊匹配，其中&quot;*&quot;用于匹配一个单词，&quot;#&quot;用于匹配多规格单词(可以是零个)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/30382119.jpg&quot; alt=&quot;RabbitMQ topic交换器&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    如图:&lt;/p&gt;
&lt;p&gt;​ · 路由键为&quot; apple.rabbit.client&quot; 的消息会同时路由到Queuel 和Queue2;&lt;br/&gt;​ · 路由键为&quot; orange.mq.client&quot; 的消息只会路由到Queue2 中:&lt;br/&gt;​ · 路由键为&quot; apple.mq.demo&quot; 的消息只会路由到Queue2 中:&lt;br/&gt;​ · 路由键为&quot; banana.rabbit.demo&quot; 的消息只会路由到Queuel 中:&lt;br/&gt;​ · 路由键为&quot; apple.orange.banana&quot; 的消息将会被丢弃或者返回给生产者因为它没有匹配任何路由键。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;header:headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中&lt;br/&gt;的headers 属性进行匹配。在绑定队列和交换器时制定一组键值对， 当发送消息到交换器时，&lt;br/&gt;RabbitMQ 会获取到该消息的headers (也是一个键值对的形式) ，对比其中的键值对是否完全&lt;br/&gt;匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由&lt;br/&gt;到该队列。(注:该交换器类型性能较差且不实用，因此一般不会用到)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;了解了上面的概念，我们再来思考消息是如何从交换器到队列的。首先Rabbit在接收到消息时，会解析消息的标签从而得到消息的交换器与路由key信息。然后根据交换器的类型、路由key以及该交换器和队列的绑定关系来决定消息最终投递到哪个队列里面。&lt;/p&gt;
&lt;h4 id=&quot;三-rabbitmq使用&quot;&gt;三 RabbitMQ使用&lt;/h4&gt;
&lt;h5 id=&quot;rabbitmq安装&quot;&gt;3.1 RabbitMQ安装&lt;/h5&gt;
&lt;p&gt;这里我们基于docker来安装。&lt;/p&gt;
&lt;h6 id=&quot;拉取镜像&quot;&gt;3.1.1 拉取镜像&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;docker pull rabbitmq:management&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;启动容器&quot;&gt;3.1.2 启动容器&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d  --name rabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;rabbitmq-客户端开发使用&quot;&gt;3.2 RabbitMQ 客户端开发使用&lt;/h5&gt;
&lt;p&gt;这里我们以dotnet平台下RabbitMQ.Client3.6.9(可以从nuget中下载)为示例，简单介绍dotnet平台下对RabbitMQ的简单操作。更详细的内容可以从nuget中下载源码和文档进行查看。&lt;/p&gt;
&lt;h6 id=&quot;连接rabbit&quot;&gt;3.2.1 连接Rabbit&lt;/h6&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  ConnectionFactory factory = new ConnectionFactory();
            factory.UserName = &quot;admin&quot;;//用户名
            factory.Password = &quot;admin&quot;;//密码      
            factory.HostName = &quot;192.168.17.205&quot;;//主机名
            factory.VirtualHost = &quot;&quot;;//虚拟主机(这个暂时不需要，稍后的文章里会介绍虚拟主机的概念)
            factory.Port = 15672;//端口
            IConnection conn = factory.CreateConnection();//创建连接&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;创建信道&quot;&gt;3.2.2 创建信道&lt;/h6&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    IModel channel = conn.CreateModel();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：Connection 可以用来创建多个Channel 实例，但是Channel 实例不能在线程问共享，应用程序应该为每一个线程开辟一个Channel 。某些情况下Channel 的操作可以并发运行，但是在其他情况下会导致在网络上出现错误的通信帧交错，同时也会影响友送方确认( publisherconfrrm)机制的运行，所以多线程问共享Channel实例是非线程安全的。&lt;/p&gt;
&lt;h6 id=&quot;交换器队列和绑定&quot;&gt;3.2.3 交换器、队列和绑定&lt;/h6&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; channel.ExchangeDeclare(&quot;exchangeName&quot;, &quot;direct&quot;, true);
 String queueName = channel.QueueDeclare().QueueName;
 channel.QueueBind(queueName, &quot;exchangeName&quot;, &quot;routingKey&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    如上创建了一个持久化的、非自动删除的、绑定类型为direct 的交换器，同时也创建了一个非持久化的、排他的、自动删除的队列(此队列的名称由RabbitMQ 自动生成)。这里的交换器和队列也都没有设置特殊的参数。&lt;/p&gt;
&lt;p&gt;    上面的代码也展示了如何使用路由键将队列和交换器绑定起来。上面声明的队列具备如下特性: 只对当前应用中同一个Connection 层面可用，同一个Connection 的不同Channel可共用，并且也会在应用连接断开时自动删除。&lt;/p&gt;
&lt;p&gt;    上述方法根据参数不同，可以有不同的重载形式，根据自身的需要进行调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ExchangeDeclare方法详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ExchangeDeclare有多个重载方法，这些重载方法都是由下面这个方法中缺省的某些参数构成的。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;void ExchangeDeclare(string exchange, string type, bool durable, bool autoDelete, IDictionary&amp;lt;string, object&amp;gt; arguments);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;exchange : 交换器的名称。&lt;/li&gt;
&lt;li&gt;type : 交换器的类型，常见的如fanout、direct 、topic&lt;/li&gt;
&lt;li&gt;durable: 设置是否持久化。durab l e 设置为true 表示持久化， 反之是非持久化。持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。&lt;/li&gt;
&lt;li&gt;autoDelete : 设置是否自动删除。autoDelete 设置为true 则表示自动删除。自动删除的前提是至少有一个队列或者交换器与这个交换器绑定，之后所有与这个交换器绑定的队列或者交换器都与此解绑。注意不能错误地把这个参数理解为:&quot;当与此交换器连接的客户端都断开时， RabbitMQ 会自动删除本交换器&quot;。&lt;/li&gt;
&lt;li&gt;internal : 设置是否是内置的。如果设置为true ，则表示是内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式。&lt;/li&gt;
&lt;li&gt;argument : 其他一些结构化参数，比如alternate - exchange。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;QueueDeclare方法详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;QueueDeclare只有两个重载。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; QueueDeclareOk QueueDeclare();
 
 QueueDeclareOk QueueDeclare(string queue, bool durable, bool exclusive, bool autoDelete, IDictionary&amp;lt;string, object&amp;gt; arguments);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不带任何参数的queueDeclare 方法默认创建一个由RabbitMQ 命名的(类似这种amq.gen-LhQzlgv3GhDOv8PIDabOXA 名称，这种队列也称之为匿名队列〉、排他的、自动删除的、非持久化的队列。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;queue : 队列的名称。&lt;/li&gt;
&lt;li&gt;durable: 设置是否持久化。为true 则设置队列为持久化。持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。&lt;/li&gt;
&lt;li&gt;exclusive : 设置是否排他。为true 则设置队列为排他的。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意三点:排他队列是基于连接( Connection) 可见的，同一个连接的不同信道(Channel)是可以同时访问同一连接创建的排他队列; &quot;首次&quot;是指如果一个连接己经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同:即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除，这种队列适用于一个客户端同时发送和读取消息的应用场景。&lt;/li&gt;
&lt;li&gt;autoDelete: 设置是否自动删除。为true 则设置队列为自动删除。自动删除的前提是:至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为:当连接到此队列的所有客户端断开时，这个队列自动删除&quot;，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列。&lt;/li&gt;
&lt;li&gt;argurnents: 设置队列的其他一些参数，如x-rnessage-ttl、x-expires、x-rnax-length、x-rnax-length-bytes、x-dead-letter-exchange、x-deadletter-routing-key, x-rnax-priority等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意:生产者和消费者都能够使用queueDeclare 来声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，然后将信道直为&quot;传输&quot;模式，之后才能声明队列。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QueueBind 方法详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将队列和交换器绑定的方法如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;void QueueBind(string queue, string exchange, string routingKey, IDictionary&amp;lt;string, object&amp;gt; arguments);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;queue: 队列名称:&lt;/li&gt;
&lt;li&gt;exchange: 交换器的名称:&lt;/li&gt;
&lt;li&gt;routingKey: 用来绑定队列和交换器的路由键;&lt;/li&gt;
&lt;li&gt;argument: 定义绑定的一些参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将队列与交换器解绑的方法如下:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;QueueUnbind(string queue, string exchange, string routingKey, IDictionary&amp;lt;string, object&amp;gt; arguments);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其参数与绑定意义相同。&lt;/p&gt;
&lt;p&gt;注：除队列可以绑定交换器外，交换器同样可以绑定队列。即:ExchangeBind方法，其使用方式与队列绑定相似。&lt;/p&gt;
&lt;h6 id=&quot;发送消息&quot;&gt;3.2.4 发送消息&lt;/h6&gt;
&lt;p&gt;    发送消息可以使用BasicPublish方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void BasicPublish(string exchange, string routingKey, bool mandatory,IBasicProperties basicProperties, byte[] body);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;exchange: 交换器的名称，指明消息需要发送到哪个交换器中。如果设置为空字符串，则消息会被发送到RabbitMQ 默认的交换器中。&lt;/li&gt;
&lt;li&gt;routingKey : 路由键，交换器根据路由键将消息存储到相应的队列之中。&lt;/li&gt;
&lt;li&gt;basicProperties: 消息的基本属性集。&lt;/li&gt;
&lt;li&gt;body : 消息体( pay1oad ),真正需要发送的消息。&lt;/li&gt;
&lt;li&gt;mandatory: 是否将消息返回给生产者(会在后续的文章中介绍这个参数).&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;消费消息&quot;&gt;3.2.5 消费消息&lt;/h6&gt;
&lt;p&gt;    RabbitMQ 的消费模式分两种: 推(Push)模式和拉(Pull)模式。推模式采用BasicConsume&lt;br/&gt;进行消费，而拉模式则是调用BasicGet进行消费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推模式:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; EventingBasicConsumer consumer = new EventingBasicConsumer(channel);//定义消费者对象
 consumer.Received += (model, ea) =&amp;gt;
 {
        //do someting;
        channel.BasicAck(ea.DeliveryTag, multiple: false);//确认
 };
   channel.BasicConsume(queue: &quot;queueName&quot;,
                        noAck: false,
                        consumer: consumer);//订阅消息&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;string BasicConsume(string queue, bool noAck, string consumerTag, bool noLocal, bool exclusive, IDictionary&amp;lt;string, object&amp;gt; arguments, IBasicConsumer consumer);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;queue : 队列的名称:&lt;/li&gt;
&lt;li&gt;noAck : 设置是否需要确认，false为需要确认。&lt;/li&gt;
&lt;li&gt;consumerTag: 消费者标签，用来区分多个消费者:&lt;/li&gt;
&lt;li&gt;noLocal : 设置为true 则表示不能将同一个Connection中生产者发送的消息传送给这个Connection中的消费者:&lt;/li&gt;
&lt;li&gt;exclusive : 设置是否排他&lt;/li&gt;
&lt;li&gt;arguments : 设置消费者的其他参数&lt;/li&gt;
&lt;li&gt;consumer: 指定处理消息的消费者对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;拉模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BasicGetResult result = channel.BasicGet(&quot;queueName&quot;, noAck: false);//获取消息

channel.BasicAck(result.DeliveryTag, multiple: false);//确认&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;关闭连接&quot;&gt;3.2.6 关闭连接&lt;/h6&gt;
&lt;p&gt;在应用程序使用完之后，需要关闭连接，释放资源:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;channel.close();
conn.close() ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显式地关闭Channel 是个好习惯，但这不是必须的，在Connection 关闭的时候，Channel 也会自动关闭。&lt;/p&gt;
&lt;h4 id=&quot;结束语&quot;&gt;结束语&lt;/h4&gt;
&lt;p&gt;    以上简单介绍了分布式系统中消息中间件的概念与作用，以及RabbitMQ的一些基本概念与简单使用。下一篇文章将继续针对RabbitMQ进行总结。主要内容包括何时创建队列、RabbitMQ的确认机制、过期时间的使用、死信队列、以及利用RabbitMQ实现延迟队列......&lt;/p&gt;
&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;
&lt;p&gt;《RabbitMQ实战指南》&lt;/p&gt;
&lt;p&gt;《RabbitMQ实战 高效部署分布式消息队列》&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 06:47:00 +0000</pubDate>
<dc:creator>人在江湖`飘</dc:creator>
<og:description>分布式系统消息中间件——RabbitMQ的使用基础篇 前言     我是在解决分布式事务的一致性问题时了解到RabbitMQ的，当时主要是要基于RabbitMQ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hunternet/p/9668851.html</dc:identifier>
</item>
<item>
<title>python使用多线程 - 雪山飞猪</title>
<link>http://www.cnblogs.com/chenqionghe/p/9668829.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqionghe/p/9668829.html</guid>
<description>&lt;p&gt;threading 模块支持守护线程， 其工作方式是：守护线程一般是一个等待客户端请求服务的服务器。 &lt;/p&gt;
&lt;p&gt;如果把一个线程设置为守护线程，进程退出时不需要等待这个线程执行完成。&lt;/p&gt;
&lt;p&gt;如果主线程准备退出时，不需要等待某些子线程完成，就可以为这些子线程设置守护线程标记。 需要在启动线程之前执行如下赋值语句： thread.daemon = True，检查线程的守护状态也只需要检查这个值即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整个 Python 程序将在所有非守护线程退出之后才退出， 换句话说， 就是没有剩下存活的非守护线程时才退出。 &lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;使用thread模块&lt;/h2&gt;
&lt;p&gt;以下是三种使用 Thread 类的方法(一般使用第一个或第三个方案)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;创建 Thread 的实例，传给它一个函数。&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import threading
from time import sleep, ctime
loops = [3, 2, 1, 1, 1]
def loop(i, nsec):
    print(f'start loop {i} at: {ctime()}')
    sleep(nsec)
    print(f'end loop {i} at: {ctime()}')
def main():
    print('start at', ctime())
    threads = []
    nloops = range(len(loops))
    for i in nloops:
        t = threading.Thread(target=loop, args=(i, loops[i]))
        threads.append(t)
    for i in nloops: # start threads
        threads[i].start()
    for i in nloops: # wait for all
        threads[i].join() # threads to finish
    print(f'all done at: {ctime()}')
if __name__ == '__main__':
    main()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当所有线程都分配完成之后，通过调用每个线程的 start()方法让它们开始执行，而不是 在这之前就会执行。&lt;br/&gt;相比于管理一组锁（分配、获取、释放、检查锁状态等）而言，这里只 需要为每个线程调用 join()方法即可。&lt;br/&gt;join()方法将等待线程结束，或者在提供了超时时间的情况下，达到超时时间。&lt;br/&gt;使用 join()方法要比等待锁释放的无限循环更加清晰（这也是这种锁 又称为自旋锁的原因）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;创建 Thread 的实例，传给它一个可调用的类实例。&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import threading
from time import sleep, ctime
# 创建 Thread 的实例，传给它一个可调用的类实例
loops = [3, 2, 1, 1, 1]
class ThreadFunc(object):
    def __init__(self, func, args, name=''):
        self.name = name
        self.func = func
        self.args = args
    def __call__(self):
        self.func(*self.args)
def loop(i, nsec):
    print(f'start loop {i} at: {ctime()}')
    sleep(nsec)
    print(f'end loop {i} at: {ctime()}')
def main():
    print('start at', ctime())
    threads = []
    nloops = range(len(loops))
    for i in nloops:
        t = threading.Thread(target=ThreadFunc(loop, (i, loops[i]), loop.__name__))
        threads.append(t)
    for i in nloops: # start threads
        threads[i].start()
    for i in nloops: # wait for all
        threads[i].join() # threads to finish
    print(f'all done at: {ctime()}')
if __name__ == '__main__':
    main()
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;派生 Thread 的子类，并创建子类的实例。&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import threading
from time import sleep, ctime
# 创建 Thread 的实例，传给它一个可调用的类实例
# 子类的构造函数必须先调用其基类的构造函数
# 特殊方法__call__()在 子类中必须要写为 run()
loops = [3, 2, 1, 1, 1]
class MyThread(threading.Thread):
    def __init__(self, func, args, name=''):
        threading.Thread.__init__(self)
        self.name = name
        self.func = func
        self.args = args
    def run(self):
        self.func(*self.args)
def loop(i, nsec):
    print(f'start loop {i} at: {ctime()}')
    sleep(nsec)
    print(f'end loop {i} at: {ctime()}')
def main():
    print('start at', ctime())
    threads = []
    nloops = range(len(loops))
    for i in nloops:
        t = MyThread(loop, (i, loops[i]), loop.__name__)
        threads.append(t)
    for i in nloops: # start threads
        threads[i].start()
    for i in nloops: # wait for all
        threads[i].join() # threads to finish
    print(f'all done at: {ctime()}')
if __name__ == '__main__':
    main()
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;使用锁&lt;/h2&gt;
&lt;p&gt;python和java一样，也具有锁机制，而且创建与使用锁都是很简便的。&lt;/p&gt;
&lt;p&gt;一般在多线程代码中，总会有一些特 定的函数或代码块不希望（或不应该）被多个线程同时执行，通常包括修改数据库、更新文件或 其他会产生竞态条件的类似情况&lt;/p&gt;
&lt;p&gt;锁有两种状态：锁定和未锁定。而且它也只支持两个函数：获得锁和释放锁。&lt;/p&gt;
&lt;p&gt;一般锁的调用如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 加载线程的锁对象
lock = threading.Lock()
# 获取锁
lock.acquire()
# ...代码
# 释放锁
lock.release()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更简洁的方法是使用with关键字，如下代码功能同上&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 加载线程的锁对象
lock = threading.Lock()
with lock :
    #...代码
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import threading
from time import sleep, ctime

lock = threading.Lock()

def a():
    lock.acquire()
    for x in range(5):
        print(f'a:{str(x)}')
        sleep(0.01)
    lock.release()


def b():
    lock.acquire()
    for x in range(5):
        print(f'a:{str(x)}')
        sleep(0.01)
    lock.release()


threading.Thread(target=a).start()
threading.Thread(target=b).start()
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;相关属性和方法 &lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;Thread对象的属性&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;线程名&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ident&lt;/td&gt;
&lt;td&gt;线程的标识符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;daemon&lt;/td&gt;
&lt;td&gt;布尔标志，表示这个线程是否是守护线程&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;
&lt;h3&gt; Thread对象的方法&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td&gt;&lt;em&gt;init&lt;/em&gt;(group=None, tatget=None, name=None, args=(), kwargs ={}, verbose=None, daemon=None)&lt;/td&gt;
&lt;td&gt;实例化一个线程对象，需要有一个可调用的 target，以及其参数 args 或 kwargs。还可以传递 name 或 group 参数，不过后者还未实现。此 外 ， verbose 标 志 也 是 可 接 受 的 。 而 daemon 的 值 将 会 设 定 thread.daemon 属性/标志&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;start()&lt;/td&gt;
&lt;td&gt;开始执行该线程&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;run()&lt;/td&gt;
&lt;td&gt;定义线程功能的方法（通常在子类中被应用开发者重写）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;join (timeout=None)&lt;/td&gt;
&lt;td&gt;直至启动的线程终止之前一直挂起；除非给出了 timeout（秒），否则 会一直阻塞&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;is_alive()&lt;/td&gt;
&lt;td&gt;布尔标志，表示这个线程是否还存活&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;threading模块其他函数&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;wiz-table-container&quot;&gt;
&lt;div class=&quot;wiz-table-body&quot;&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td&gt;start()&lt;/td&gt;
&lt;td&gt;开始执行该线程&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;active_count()&lt;/td&gt;
&lt;td&gt;当前活动的 Thread 对象个数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;enumerate()&lt;/td&gt;
&lt;td&gt;返回当前活动的 Thread 对象列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;settrace(func)&lt;/td&gt;
&lt;td&gt;为所有线程设置一个 trace 函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;setprofile (func)&lt;/td&gt;
&lt;td&gt;为所有线程设置一个 profile 函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;stack_size(size=0)&lt;/td&gt;
&lt;td&gt;返回新创建线程的栈大小；或为后续创建的线程设定栈的大小 为 size&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Lock()&lt;/td&gt;
&lt;td&gt;加载线程的锁对象，是一个基本的锁对象，一次只能一个锁定，其余锁请求，需等待锁释放后才能获取,对象有acquire()和release()方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;RLock()&lt;/td&gt;
&lt;td&gt;多重锁，在同一线程中可用被多次acquire。如果使用RLock，那么acquire和release必须成对出现，调用了n次acquire锁请求，则必须调用n次的release才能在线程中释放锁对象&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h2&gt;后记 &lt;/h2&gt;
&lt;p&gt;在Python多线程下，每个线程的执行方式：&lt;br/&gt;1、获取GIL&lt;br/&gt;2、执行代码直到sleep或者是python虚拟机将其挂起。&lt;br/&gt;3、释放GIL&lt;/p&gt;
&lt;p&gt;通常来说，多线程是一个好东西。不过由于 Python 的 GIL 的限制，多线程更适合于 I/O 密集型应用（I/O 释放了 GIL，可以允 许更多的并发），而不是计算密集型应用。对于后一种情况而言，为了实现更好的并行性，你需要使用多进程，以便让 CPU 的其他内核来执行。&lt;/p&gt;
&lt;p&gt;请注意：多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低&lt;br/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 06:44:00 +0000</pubDate>
<dc:creator>雪山飞猪</dc:creator>
<og:description>threading 模块支持守护线程， 其工作方式是：守护线程一般是一个等待客户端请求服务的服务器。 如果把一个线程设置为守护线程，进程退出时不需要等待这个线程执行完成。 如果主线程准备退出时，不需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenqionghe/p/9668829.html</dc:identifier>
</item>
<item>
<title>微服务架构盛行的时代，你需要了解点 Spring Boot - 程序员私房菜</title>
<link>http://www.cnblogs.com/eson15/p/9668776.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eson15/p/9668776.html</guid>
<description>&lt;p&gt;随着互联网的高速发展，庞大的用户群体和快速的需求变化已经成为了传统架构的痛点。&lt;/p&gt;
&lt;p&gt;在这种情况下，如何从系统架构的角度出发，构建出灵活、易扩展的系统来快速响应需求的变化，同时，随着用户量的增加，如何保证系统的稳定性、高可用性、可伸缩性等等，成为了系统架构面临的挑战。&lt;/p&gt;
&lt;p&gt;为了解决这些问题，微服务架构应运而生，它的本质在于分布式、去中心化。&lt;/p&gt;
&lt;p&gt;微服务架构是一种架构模式或者说一种架构风格，它提倡将传统的一站式应用（左下图）根据业务拆分成一个个服务（右下图），彻底去掉耦合，每个服务提供单个业务功能，一个服务只做一件事，运行在其独立的进程中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1441773/201809/1441773-20180918143943722-2082557712.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个服务之间互相协调、互相配合，为用户提供最终的价值。服务之间采用轻量级的通信机制（通常是基于 http 的 RESTful API）。&lt;/p&gt;
&lt;p&gt;每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。不同的服务也可以使用不同的数据库和数据存储。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1441773/201809/1441773-20180918144000086-1659272080.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来开发这些服务。&lt;/p&gt;
&lt;p&gt;Spring Boot 诞生时，微服务概念正处于酝酿阶段，Spring Boot 的研发融合了微服务架构的理念，是 Java 领域微服务架构最优落地的技术，给微服务架构提供了技术支撑。Spring Boot 有哪些优势呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1441773/201809/1441773-20180918144016604-1492327827.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;良好的基因：Spring Boot 是伴随着 Spring 4.0 诞生的，继承了 Spring 框架的优秀基因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;简化编码：传统的 Spring web 项目需要引入一堆相关的依赖，而在 Spring Boot 中，我们只需要引入一个 starter-web 依赖即可快速创建 web 应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;简化配置：传统的 Spring 项目一度被人认为是“配置地狱”，而 Spring Boot 更多的是采用 Java Config 的方式，简化了配置的繁琐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;简化部署：Spring Boot 项目不需要在服务器上去部署 tomcat，因为 Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，通过命令一键式启动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;简化监控：可以引入 spring-boot-start-actuator 依赖，直接使用 REST 方式来获取进程的运行期性能参数，从而达到监控的目的，还可以配合 Spring Cloud 一起使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;微服务是未来发展的趋势，使用 Spring Boot 开发项目，会颠覆传统的开发模式，大大提升开发效率，可以说如果你使用 Spring Boot 开发过项目，你就不愿意再回到原来的开发方式了。&lt;/p&gt;
&lt;p&gt;看看 Spring 官方对 Spring Boot 的定位：Build Anything，Build 任何东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1441773/201809/1441773-20180918143737008-822081845.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot 旨在尽可能快地启动和运行，并且只需最少的 Spring 前期配置。 同时我们也来看一下官方对后面两个的定位：&lt;/p&gt;
&lt;p&gt;SpringCloud：Coordinate Anything，协调任何事情；&lt;/p&gt;
&lt;p&gt;SpringCloud Data Flow：Connect everything，连接任何东西。&lt;/p&gt;
&lt;p&gt;仔细品味一下，Spring 官网对 Spring Boot、SpringCloud 和 SpringCloud Data Flow 三者定位的措辞非常有味道，同时也可以看出，官方对这三个技术非常重视，我们还有什么理由不去学习呢？在微服务盛行的今天，你真的需要了解点 Spring Boot。我对 Spring Boot 也稍有些研究，如果你有兴趣，可以关注我的微信公众号，回复“微服务”，我们一起学习。&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 06:43:00 +0000</pubDate>
<dc:creator>程序员私房菜</dc:creator>
<og:description>随着互联网的高速发展，庞大的用户群体和快速的需求变化已经成为了传统架构的痛点。 在这种情况下，如何从系统架构的角度出发，构建出灵活、易扩展的系统来快速响应需求的变化，同时，随着用户量的增加，如何保证系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eson15/p/9668776.html</dc:identifier>
</item>
<item>
<title>配置中心框架IConfCenter - 神牛003</title>
<link>http://www.cnblogs.com/wangrudong003/p/9668798.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangrudong003/p/9668798.html</guid>
<description>&lt;p&gt;本篇和大家分享的是一个简易配置中心框架&lt;strong&gt;&lt;a href=&quot;https://github.com/shenniubuxing3/IConfCenter&quot;&gt;IConfCenter&lt;/a&gt;&lt;/strong&gt;，框架是利用空余时间写的，主要以配置文件+redis存储方式作为数据同步驱动，目前支持的配置文件格式有 .properties 和 .config，后期有时间可能增加 .xml 和 .yml文件的识别。&lt;/p&gt;
&lt;p&gt;框架结构简单分为：&lt;/p&gt;
&lt;p&gt;发一张配置中心应用到项目中的手工设计图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/348819/201809/348819-20180918143955916-590863942.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;confAdmin - 配置中心后台管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后台管理主要就是一个简单的操作界面，采用springboot+thymeleaf+jquery搭建，目前主要有两个功能：展示配置文件列表和启用某个配置&lt;/p&gt;
&lt;p&gt;&lt;span data-spm-anchor-id=&quot;a2c4e.11153940.blogcont641577.i10.4fc861ed9Oit4X&quot;&gt;&lt;strong&gt;展示配置文件列表&lt;/strong&gt;：其实就是读取本地磁盘目录中的配置文件信息，主要的service代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 配置文件列表
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * @return
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;File&amp;gt;&lt;span&gt; getListConf() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         File baseFile = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(confCenterConf.confserver_confs_basepath);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         File[] files =&lt;span&gt; baseFile.listFiles();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         List&amp;lt;File&amp;gt; list =&lt;span&gt; Arrays.asList(files).
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                stream().
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                sorted(Comparator.comparing(File::lastModified).reversed()).
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                collect(Collectors.toList());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-spm-anchor-id=&quot;a2c4e.11153940.blogcont641577.i12.4fc861ed9Oit4X&quot;&gt;&lt;strong&gt;启用某个配置&lt;/strong&gt;：主要通过界面按钮触发ajax提交一个启动post请求，后端通过解析指定配置文件内容为Map结构，并永久存储于Redis缓存中(直到下一次配置内容更新)，最后通过Redis的发布功能通知给订阅该配置的客户端，让客户端通过api重新获取并更新本地配置。主要的Service代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 启用某个配置+通知消费端（订阅channel规则：confs_配置文件名）
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * @param confPath
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * @return
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MoRp qyConf(String confPath) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         MoRp rp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MoRp();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        rp.setStatus(EnumHelper.EmRpStatus.失败.getVal());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取配置文件&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             Map&amp;lt;String, Object&amp;gt; map =&lt;span&gt; LoadConf.readConfToMap(confPath);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (map.isEmpty()) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 rp.setMessage(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;加载配置文件失败，稍后重试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rp;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件名称&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             String filePathToName = LoadConf.getFilePathToName(confPath, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存key&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             String cacheKey = String.format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;confs_%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, filePathToName);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2018.09.13 临时增加配置文件修改时间&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             File file = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(confPath);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             MoGetConfRp confRp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MoGetConfRp();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            confRp.setConfLastModified(file.lastModified());
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            confRp.setConfs(map);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            confRp.setConfVersion(filePathToName);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            confRp.setStatus(EnumHelper.EmRpStatus.成功.getVal());
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储到缓存中 永久&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (jedisTool.&lt;span&gt;set&lt;/span&gt;(cacheKey, confRp, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布消息，通知客户端更新配置&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                jedisTool.publish(cacheKey, confRp.getConfVersion());
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                rp.setStatus(EnumHelper.EmRpStatus.成功.getVal());
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                rp.setMessage(EnumHelper.EmRpStatus.成功.toString());
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rp;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;confCenter - 配置中心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要提供了一个获取指定版本的配置文件信息api，信息来源由Redis缓存提供，当Redis缓存不存在时不会去解析配置文件，因此主要用ConfiAdmin管理后台触发数据来源。其主要代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 获取配置信息
     *
     * @param rq
     * @return
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MoGetConfRp getconf(MoGetConfRq rq) {

        MoGetConfRp rp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MoGetConfRp();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;未指定配置版本，采用默认配置版本&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (rq.getConfVersion().isEmpty()) {
                rq.setConfVersion(confCenterConf.confserver_confs_currentConfVersion);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (rq.getConfVersion().isEmpty()) {
                rp.setMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未找到配置版本&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rp;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存key&lt;/span&gt;
            String cacheKey = String.format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;confs_%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, rq.getConfVersion());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取缓存中是否存在&lt;/span&gt;
            rp = jedisTool.&lt;span&gt;get&lt;/span&gt;(cacheKey, MoGetConfRp.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rp.getStatus() == EnumHelper.EmRpStatus.成功.getVal() &amp;amp;&amp;amp;&lt;span&gt;
                    rp.getConfs().size() &lt;/span&gt;&amp;gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                rp.setStatus(EnumHelper.EmRpStatus.成功.getVal());
                rp.setMessage(EnumHelper.EmRpStatus.成功.toString());
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rp;
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rp;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-spm-anchor-id=&quot;a2c4e.11153940.blogcont641577.i17.4fc861ed9Oit4X&quot;&gt;confclient - 客户端&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-spm-anchor-id=&quot;a2c4e.11153940.blogcont641577.i17.4fc861ed9Oit4X&quot;&gt;主要干了两个事情：每分钟获取配置和订阅配置中心刷新配置。该客户端项目各位可以打包成jar引入项目中，加上相关配置即可引入配置中心客户端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-spm-anchor-id=&quot;a2c4e.11153940.blogcont641577.i17.4fc861ed9Oit4X&quot;&gt;每分钟获取配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-spm-anchor-id=&quot;a2c4e.11153940.blogcont641577.i17.4fc861ed9Oit4X&quot;&gt;为了配置内容的一致性，这里采用了Scheduled每隔一分钟请求一下配置中心api，然后通过版本号对比是否有更新，如果对比有新版本那么即可更新缓存于本地的配置信息。主要代码如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 每分钟获取配置，版本号不一致更新本地缓存
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     @Scheduled(initialDelay =  &lt;span&gt;1000&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt;,fixedDelay = &lt;span&gt;1000&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refreshConf() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;new&lt;/span&gt; Date() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:当前配置版本&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                confCenterConf.confserver_confs_currentConfVersion);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (confCenterConf.confserver_confs_currentConfVersion.isEmpty()) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;版本为空，无法自动拉取配置&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        updateConf(confCenterConf.confserver_confs_currentConfVersion);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * 更新本地配置
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * @param strVersion
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; updateConf(String strVersion) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取配置中心配置&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         MoGetConfRp rp =&lt;span&gt; confCenterClientService.getConfCenterConf(strVersion);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (rp.getStatus() !=&lt;span&gt; EnumHelper.EmRpStatus.成功.getVal()) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(rp.getConfLastModified() ==&lt;span&gt; confCenterClientService.getConfLastModified()){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;new&lt;/span&gt; Date() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:更新本地配置&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;版本不一致，更新本地缓存&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        confCenterClientService.setConf(rp);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;订阅配置中心刷新配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过实现CommandLineRunner接口的run方法，在项目启动时通过Redis订阅配置中心消息，达到配置中心主动通知更新配置的目的。主要代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 程序启动执行服务 订阅配置中心刷新配置通道
     * 
     * @param strings
     * @throws Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(String... strings) throws Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;订阅配置中心刷新配置通道&lt;/span&gt;
&lt;span&gt;        jedisTool.subscribe(
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;confs_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; confCenterConf.confserver_confs_currentConfVersion,
                b &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;new&lt;/span&gt; Date() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:收到配置中心刷新配置通知，版本-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; b);
                    updateConf(b.toString());
                });
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在文章结尾时，发一张配置中心后台管理界面图，并希望各位能够喜欢配置中心框架&lt;strong&gt;&lt;a href=&quot;https://github.com/shenniubuxing3/IConfCenter&quot;&gt;IConfCenter&lt;/a&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/348819/201809/348819-20180918144033059-776575975.gif&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont641577.i3.4fc861ed9Oit4X&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 06:42:00 +0000</pubDate>
<dc:creator>神牛003</dc:creator>
<og:description>本篇和大家分享的是一个简易配置中心框架IConfCenter，框架是利用空余时间写的，主要以配置文件+redis存储方式作为数据同步驱动，目前支持的配置文件格式有 .properties 和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangrudong003/p/9668798.html</dc:identifier>
</item>
<item>
<title>深圳scala-meetup-20180902（1）- Monadic 编程风格 - 雪川大虫</title>
<link>http://www.cnblogs.com/tiger-xc/p/9668785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-xc/p/9668785.html</guid>
<description>&lt;p&gt;  &lt;span&gt;刚完成了9月份深圳scala-meetup，趁刮台风有空，把我在meetup里的分享在这里发表一下。我这次的分享主要分三个主题：“Monadic编程风格“、”Future vs Task and ReaderMonad应用方法“及”using heterogeneous monads in for-comprehension with MonadTransformer“。这篇想先介绍一下Monadic编程风格。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Monadic编程就是用Monad来编程，它的形式是：F[G]，F是个Monad，然后G是具体的运算，G就是我们习惯的运算表达式如1+1、update('a','new content')等等，可能会产生副作用的，比如输入输出，更改数据等。形象点描述：如果我们把F[_]当作是一个管道，那么Monadic编程模式就像是在F这个管道里组装连接一些可能产生副作用的运算表达式。实际上真正产生运算结果的是管道内部的这些运算表达式。这是疯了吗？我们为什么不直接按序运算这些表达式来获取结果呢？我们先听听下面的分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看看下面这段程序：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;行令编程模式（imperative programming）
def au(t:T): T      &lt;/span&gt;&lt;span&gt;async&lt;/span&gt;&lt;span&gt; update with result
val t2 &lt;/span&gt;=&lt;span&gt; au(t1)
val t3 &lt;/span&gt;=&lt;span&gt; au(t2)
val t4 &lt;/span&gt;= au(t2 + t3)         t4 = ???&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果上面每一行指令都在不同的线程里运算，那么完成运算的顺序就是不确定的。最后t4的结果是不可预料的了。为了保证这个运算顺序，我们可能要使用锁，这又回到在OO编程里最棘手的问题：运行低效、死锁、难以理解跟踪等。基本上OO编程的多线程程序不但难以理解而且运算难以捉摸，结果难以预览，很难做的对。我们再看看Monadic编程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;monadic programming : program with monads
val fp3 &lt;/span&gt;= F[p1] ⊕ F[p1] ⊕ F[p1] = F[p1+p2+&lt;span&gt;p3] 
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;、延迟运算 ：val res =&lt;span&gt; fp3.run
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、按序运算 ：flatMap{a =&amp;gt; flatMap{b =&amp;gt; flatMap{c =&amp;gt;…&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们看到：所谓的Monadic编程就是在F[_]管道内运算式p1,p2,p3的连接。这样做可以达到延迟运算和按序运算两个主要目的。延迟运算可以让我们完成对所有运算表达式的组合再一次性进行完整的运算。按序运算可以保证运算是按照编程人员的意图进行的，这里的flatMap是一种函数链，运算得到a后再运算b，得到b后再继续运算c 。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是我们自创的一个F[_]结构Tube[A]和它的使用示范：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Tube[A](run: A) {
    def map[B](f: A &lt;/span&gt;=&amp;gt; B): Tube[B] =&lt;span&gt; Tube(f(run))
    def flatMap[B](f: A &lt;/span&gt;=&amp;gt; Tube[B]): Tube[B] =&lt;span&gt; f(run)
  }

  val value: Tube[Int] &lt;/span&gt;= Tube(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
  def add(a: Int, b: Int): Tube[Int] &lt;/span&gt;= Tube(a+&lt;span&gt;b)

  val f &lt;/span&gt;= &lt;span&gt;for&lt;/span&gt;&lt;span&gt; {
    a &lt;/span&gt;&amp;lt;-&lt;span&gt; value
    b &lt;/span&gt;&amp;lt;- add(a , &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
    c &lt;/span&gt;&amp;lt;-&lt;span&gt; add(a,b)
  } &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; c

  println(f)          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Tube(23)&lt;/span&gt;
  println(f.run)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;首先，Tube[A]是个Monad，因为它支持map和flatMap。对任何Tube类型我们都可以用for-comprehension来组合运算式，最后run来获取运算结果。以上a,b,c都是中间结果，可以在for{...}中任意使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;值得注意的是：Monadic操作与scala里集合的操作很相似，不同的是Monadic操作类型只包含一个内部元素，而集合包含了多个元素，如List(1,2,3)有3个元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际上，简单的一个Tube结构好像没什么特别用处，说白了它连中途终止运算的功能都没有。scala库里现成的Monad中Option,Either都有特别的作用：Option可以在遇到None值时中断运算并立即返回None值。Either在遇到Left值时立即返回Left，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  val value: Option[Int] = Some(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
  def add(a: Int, b: Int): Option[Int] &lt;/span&gt;= Some(a+&lt;span&gt;b)

  val p &lt;/span&gt;= &lt;span&gt;for&lt;/span&gt;&lt;span&gt; {
    a &lt;/span&gt;&amp;lt;-&lt;span&gt; value
    b &lt;/span&gt;&amp;lt;- add(a, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
    _ &lt;/span&gt;&amp;lt;-&lt;span&gt; None
    c &lt;/span&gt;&amp;lt;-&lt;span&gt; add(a,b)
  } &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; a

  println(p)     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;
&lt;span&gt;

  val value: Either[String,Int] &lt;/span&gt;= Right(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
  def add(a: Int, b: Int): Either[String,Int] &lt;/span&gt;= Right(a+&lt;span&gt;b)

  val p &lt;/span&gt;= &lt;span&gt;for&lt;/span&gt;&lt;span&gt; {
    a &lt;/span&gt;&amp;lt;-&lt;span&gt; value
    b &lt;/span&gt;&amp;lt;- add(a, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
    _ &lt;/span&gt;&amp;lt;- Left(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oh no ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    c &lt;/span&gt;&amp;lt;-&lt;span&gt; add(a,b)
  } &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; c

  println(p)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;oh no ...&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;好了，下面我们就用一个形象点的例子来示范Monadic编程风格：这是一个模拟数据库操作的例子，我们用一个KVStore来模拟数据库：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; KVStore[K,V] {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; val s = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentHashMap[K,V]()
    def create(k: K, v: V): Future[Boolean] &lt;/span&gt;= Future.successful(s.putIfAbsent(k,v) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    def read(k: K): Future[Option[V]] &lt;/span&gt;= Future.successful(Option(s.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(k)))
    def update(k: K, v: V): Future[Unit] &lt;/span&gt;=&lt;span&gt; Future.successful(s.put(k,v))
    def delete(k: K): Future[Boolean] &lt;/span&gt;= Future.successful(s.remove(k) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对KVStore的操作函数都采用了Future作为结果类型，这样可以实现non-blocking操作。Future是个Monad（虽然它不是一种纯函数impure function, 这个我们后面再解释），所以我们可以用for-comprehension来编程，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; type FoodName =&lt;span&gt; String
  type Quantity &lt;/span&gt;=&lt;span&gt; Int
  type FoodStore &lt;/span&gt;=&lt;span&gt; KVStore[String,Int]

  def addFood(food: FoodName, qty: Quantity )(&lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; fs: FoodStore): Future[Unit] = &lt;span&gt;for&lt;/span&gt;&lt;span&gt; {
    current &lt;/span&gt;&amp;lt;-&lt;span&gt; fs.read(food)
    newQty &lt;/span&gt;= current.map(cq =&amp;gt; cq +&lt;span&gt; qty ).getOrElse(qty)
    _ &lt;/span&gt;&amp;lt;-&lt;span&gt;  fs.update(food, newQty)
  } &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; ()

  def takeFood(food: FoodName, qty: Quantity)(&lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; fs: FoodStore): Future[Quantity] = &lt;span&gt;for&lt;/span&gt;&lt;span&gt; {
    current &lt;/span&gt;&amp;lt;-&lt;span&gt; fs.read(food)
    instock &lt;/span&gt;= current.getOrElse(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    taken &lt;/span&gt;=&lt;span&gt; Math.min(instock,qty)
    left &lt;/span&gt;= instock -&lt;span&gt; taken
    _ &lt;/span&gt;&amp;lt;- &lt;span&gt;if&lt;/span&gt; (left &amp;gt; &lt;span&gt;0&lt;/span&gt;) fs.update(food,left) &lt;span&gt;else&lt;/span&gt;&lt;span&gt; fs.delete(food)
  } &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; taken

  def cookSauce(qty: Quantity)(&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;: (FoodName,Quantity) =&amp;gt;&lt;span&gt; Future[Quantity],
                               put:(FoodName,Quantity) &lt;/span&gt;=&amp;gt; Future[Unit]): Future[Quantity] = &lt;span&gt;for&lt;/span&gt;&lt;span&gt; {
    tomato &lt;/span&gt;&amp;lt;- &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tomato&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,qty)
    veggie &lt;/span&gt;&amp;lt;- &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Veggie&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,qty)
    garlic &lt;/span&gt;&amp;lt;- &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Garlic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, qty * &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
    sauceQ &lt;/span&gt;= tomato / &lt;span&gt;2&lt;/span&gt; + veggie * &lt;span&gt;3&lt;/span&gt; / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    _ &lt;/span&gt;&amp;lt;- put(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sauce&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,sauceQ)
  } &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; sauceQ

  def cookMeals(qty: Quantity)(&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;: (FoodName,Quantity) =&amp;gt;&lt;span&gt; Future[Quantity],
                               put: (FoodName,Quantity) &lt;/span&gt;=&amp;gt; Future[Unit]): Future[Quantity] =
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; {
       pasta &lt;/span&gt;&amp;lt;- &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pasta&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, qty)
       sauce &lt;/span&gt;&amp;lt;- &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sauce&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, qty)
      _ &lt;/span&gt;&amp;lt;- &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Spice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)

      meals &lt;/span&gt;=&lt;span&gt; Math.min(pasta,sauce)
      _ &lt;/span&gt;&amp;lt;- put(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Meal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, meals)

    } &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; meals&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面几个操作函数都是Future类型的，具体的操作都包含在for{...}里。我们看到：在for{...}里可以产生中间结果、也可以直接写运算表达式、也可以使用这些中间运算结果。for{...}里的情景就像正常的行令式编程。然后我们又对这些操作函数进行组合：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   &lt;span&gt;implicit&lt;/span&gt; val refrigerator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FoodStore

   val shopping: Future[Unit] &lt;/span&gt;= &lt;span&gt;for&lt;/span&gt;&lt;span&gt; {
     _ &lt;/span&gt;&amp;lt;- addFood(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tomato&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
     _ &lt;/span&gt;&amp;lt;- addFood(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Veggie&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;&lt;span&gt;)
     _ &lt;/span&gt;&amp;lt;- addFood(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Garlic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;42&lt;/span&gt;&lt;span&gt;)
     _ &lt;/span&gt;&amp;lt;- addFood(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Spice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
     _ &lt;/span&gt;&amp;lt;- addFood(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pasta&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)
   } &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; ()

   val cooking: Future[Quantity] &lt;/span&gt;= &lt;span&gt;for&lt;/span&gt;&lt;span&gt; {
     _ &lt;/span&gt;&amp;lt;-&lt;span&gt; shopping
     sauce &lt;/span&gt;&amp;lt;- cookSauce(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)(takeFood(_,_),addFood(_,_))
     meals &lt;/span&gt;&amp;lt;- cookMeals(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)(takeFood(_,_),addFood(_,_))
   } &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; (meals)

   val todaysMeals &lt;/span&gt;= Await.result(cooking,&lt;span&gt;3&lt;/span&gt;&lt;span&gt; seconds)

  println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;we have $todaysMeals pasta meals for the day.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最后组合成这个cooking monad, 然后一次性Await.result(cooking...)获取最终结果。通过上面这个例子我们可以得到这么一种对Monadic编程风格的感觉，就是：用for-comprehension来组合，组合、再组合，然后run（Await.result）获取结果。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 18 Sep 2018 06:40:00 +0000</pubDate>
<dc:creator>雪川大虫</dc:creator>
<og:description>刚完成了9月份深圳scala-meetup，趁刮台风有空，把我在meetup里的分享在这里发表一下。我这次的分享主要分三个主题：“Monadic编程风格“、”Future vs Task</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiger-xc/p/9668785.html</dc:identifier>
</item>
</channel>
</rss>