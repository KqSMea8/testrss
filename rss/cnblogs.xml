<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>4.1ASP.NET Core请求过程「深入浅出ASP.NET Core系列」 - 张飞洪</title>
<link>http://www.cnblogs.com/jackyfei/p/9927065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackyfei/p/9927065.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;希望给你3-5分钟的碎片化学习，可能是坐地铁、等公交，积少成多，水滴石穿，谢谢关注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里展示整体的HTTP请求的过程，这里化繁为简，保留了主干流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/127185/201811/127185-20181108230943300-1181581079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从浏览器输入域名开始，这里忽略了建立TCP的3次握手，向服务器发起HTTPRequest请求，服务器接受到之后，会触发服务器对网站的动态解析，然后把生成的网页信息通过HTTPResponse返回给用户，内部包含HTML的Body，Head等信息，最后就是浏览器对这些HTML信息进行内部引擎渲染的过程了。&lt;/p&gt;

&lt;p&gt;ASP.NET Core是整个HTTP请求的一个环节，这个环节都做了哪些工作呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/127185/201811/127185-20181108230924796-1722203288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，整个请求流程更加细化，特别是ASP.NET Core Application进行了放大，内部包含很重要的两个组建，一个是Kestrel，一个是管道，而管道不是一个，可以是多个，使用的委托方式，可以无限扩展。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/127185/201811/127185-20181108232217281-1292266548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core Applicaton进一步放大，可以了解到，Kestrel其实在这里并没有做真正的核心处理，只是做一层封装为HttpContext，并往下传。真正处理请求的是管道，管道其实就是RequestDelegate，处理完成后封装成HttpContext进行回传，当然，HttpContext内含HttpRequest和HttpResponse。以上只是一个初略的描述，但是作为开发来说，有个初步印象就可以了，再细化下去，已经超过碎片化时间，先打住，如果要继续深究，请关注我后面的专题内容。&lt;/p&gt;
&lt;blockquote readability=&quot;5.4905660377358&quot;&gt;
&lt;p&gt; 我是张飞洪，入行10年有余，人不堪其忧，吾不改其乐，谢谢您关注我的&lt;a href=&quot;http://mp.toutiao.com/preview_article/?pgc_id=6621514934175924744&quot; target=&quot;_blank&quot;&gt;头条号&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 08 Nov 2018 15:36:00 +0000</pubDate>
<dc:creator>张飞洪</dc:creator>
<og:description>希望给你3-5分钟的碎片化学习，可能是坐地铁、等公交，积少成多，水滴石穿，谢谢关注。 HTTP请求过程 这里展示整体的HTTP请求的过程，这里化繁为简，保留了主干流程： 从浏览器输入域名开始，这里忽略</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackyfei/p/9927065.html</dc:identifier>
</item>
<item>
<title>【杂谈】Java I/O的底层实现 - 猫毛·波拿巴</title>
<link>http://www.cnblogs.com/longfurcat/p/9932348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longfurcat/p/9932348.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Java I/O功能封装的很好，使用起来很方便，就是刚开始学的时候，如果不了解装饰器模式，会被他繁多的类给吓到。用多了也就习惯了，而且现在有很多实用的封装良好的实用类，可直接读写整个文件。开发者不知道底层实现细节，也可以灵活使用，这是封装的一大优点。但是，作为一名软件开发人员，对其所使用的代码不能仅仅停留在熟悉功能特性上，最好对其实现原理也要有一定了解。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：本文引用了部分外文内容，并根据自己的理解进行了翻译，连接将在文末贴出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; --------------------------------------外文引用内容Begin（已翻译）----------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓冲处理、内核空间vs用户空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;缓冲，以及如何处理缓冲是所有IO的基本内容。术语&quot;I/O&quot;（输入输出）指的不过就是&lt;span&gt;&lt;strong&gt;从缓冲区移入或移除数据&lt;/strong&gt;&lt;/span&gt;。通常，进程执行I/O操作的方式是，向操作系统发送请求，请求其填充自己的缓冲区（或者把自己缓冲区的内容写出）。这就是I/O这个概念的全部内容。要实现这些传输操作，操作系统底层的实现非常复杂。但是在概念上，本文所要讲述的内容则非常直白。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181108213823896-609313275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注意：User space和Kernel space 都属于内存。内存分为两个区，用户区和系统区（内核区）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　上图简要展示了，&lt;span&gt;&lt;strong&gt;块数据&lt;/strong&gt;&lt;/span&gt;如何从外部源头（比如硬盘）移入到进程的内存空间的过程。首先，这个进程通过&lt;strong&gt;系统调用&lt;/strong&gt;read()，请求填充自己的缓冲区。这将导致内核发送一个命令到磁盘控制器，使其从磁盘中抓取数据。磁盘控制器通过DMA把数据直接写入到内核空间缓冲区，这个过程不需要CPU干预。一旦磁盘控制器完成了填充数据的任务，内核就将数据从内核空间的临时缓冲区转移到进程指定的缓冲区内。&lt;/p&gt;
&lt;p&gt;　　有一件事需要注意，&lt;span&gt;&lt;strong&gt;内核会试图缓冲或者说预加载一些数据&lt;/strong&gt;&lt;/span&gt;，所以有可能进程所请求的数据已经在内核空间里了。如果这样的话，进程请求的数据，只需要从内核缓冲区拷贝一份即可。如果数据不在内核空间内，则在内核获取数据到内存的过程中，此进程将被挂起。&lt;/p&gt;
&lt;p&gt;--------------------------------------外文引用内容End（已翻译）-------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从上述内容可知：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java的读写操作，底层由C/C++实现。而不是直接与OS接触&lt;/li&gt;
&lt;li&gt;C/C++读写操作，需要OS服务&lt;/li&gt;
&lt;li&gt;内核自带缓冲，会过分加载&lt;/li&gt;
&lt;li&gt;如果内存中没有数据的缓冲，读写操作将阻塞当前线程（OS会帮你挂起线程）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;DMA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　DMA（Direct Memory Access，直接内存存取）是I/O设备控制方式的一种。我个人认为它们的主要差别在于CPU的参与I/O控制的程度&lt;/p&gt;
&lt;p&gt;I/O设备控制方式有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序I/O方式——CPU需反复检查&lt;/li&gt;
&lt;li&gt;中断I/O方式——每完成一个字节的读写，通知CPU&lt;/li&gt;
&lt;li&gt;DMA方式——每完成一个块(多字节)的读写，通知CPU&lt;/li&gt;
&lt;li&gt;I/O通道方式（暂不了解）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在DMA读写I/O设备的时候，CPU不会被影响，它可以继续执行。注意！这里能继续执行，指的是CPU可以继续运行，而此I/O操作的线程已经被挂起，不参与CPU调度。I/O操作完成后，该线程才被唤醒，参与调度（加入就绪队列，等待时间片）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;系统调用是应用程序间接调用OS函数的方式。C语言有提供与系统调用相对应的库函数。这里就是read、write。&lt;strong&gt;　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BufferedXXStream&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　注意，对于Java来说，系统调用的开销是比较大的。首先读写操作要触发的是本地方法read0，readBytes，write0，writeBytes，这里JNI需要一定开销。还有就是每产生一个系统调用，就可能产生上千个机器指令，这种开销是不容小觑的。所以，我们要尝试减少系统调用。那有人就会问了，不行啊，我数据又不能缺斤少两，少读少写肯定出问题，怎么减少调用？这不是很好解决吗，每次多读写一点，调用的次数不就少了嘛。而BufferedXXStream就是这么用的，例如，BufferedInputStream的read无参方法只读取一个字节，而实际上BufferedInputStream默认读取了8kb，这些数据用字节数组保留。&lt;/p&gt;
&lt;p&gt; 　    对了，如果对上图，不是很理解，可以看看这张。&lt;/p&gt;
&lt;p&gt;　　 即运行时，有一个对象BufferedInputStream，其调用一次read()方法，数据保留到buf数组中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181108232129731-1245975992.png&quot; alt=&quot;&quot; width=&quot;576&quot; height=&quot;325&quot;/&gt;&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;entry-title&quot;&gt;&lt;a href=&quot;https://howtodoinjava.com/java/io/how-java-io-works-internally-at-lower-level/&quot; target=&quot;_blank&quot;&gt;How Java I/O Works Internally at Lower Level?&lt;/a&gt;（需FQ）&lt;/p&gt;
</description>
<pubDate>Thu, 08 Nov 2018 15:31:00 +0000</pubDate>
<dc:creator>猫毛&amp;#183;波拿巴</dc:creator>
<og:description>前言 Java I/O功能封装的很好，使用起来很方便，就是刚开始学的时候，如果不了解装饰器模式，会被他繁多的类给吓到。用多了也就习惯了，而且现在有很多实用的封装良好的实用类，可直接读写整个文件。开发者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longfurcat/p/9932348.html</dc:identifier>
</item>
<item>
<title>java集合之LinkedList - 辰砂tj</title>
<link>http://www.cnblogs.com/tojian/p/9932657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tojian/p/9932657.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;title: java集合之LinkedList&lt;br/&gt;tags: java集合&lt;br/&gt;author: 辰砂&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。&lt;/p&gt;
&lt;p&gt;注意，此实现不是同步的。如果不存在这样的对象，则应该使用 Collections.synchronizedList 方法来“包装”该列表。最好在创建时完成这一操作，以防止对列表进行意外的不同步访问，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; List list = Collections.synchronizedList(new LinkedList(...));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181108230257810-2085537773.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LinkedList&amp;lt;E&amp;gt;
    extends AbstractSequentialList&amp;lt;E&amp;gt;
    implements List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。&lt;/p&gt;
&lt;p&gt;LinkedList 实现 List 接口，能对它进行队列操作。&lt;/p&gt;
&lt;p&gt;LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。&lt;/p&gt;
&lt;p&gt;LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。&lt;/p&gt;
&lt;p&gt;LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。&lt;/p&gt;
&lt;p&gt;LinkedList 是非同步的&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;二.linkedlist的用法-参考优秀博文&quot;&gt;二.LinkedList的用法 (参考优秀博文)&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class LinkedListTest {
    public static void main(String[] args) {
        // 测试LinkedList的API
        testLinkedListAPIs() ;

        // 将LinkedList当作 LIFO(后进先出)的堆栈
        useLinkedListAsLIFO();

        // 将LinkedList当作 FIFO(先进先出)的队列
        useLinkedListAsFIFO();
    }

    /*
     * 测试LinkedList中部分API
     */
    private static void testLinkedListAPIs() {
        String val = null;
        //LinkedList llist;
        //llist.offer(&quot;10&quot;);
        // 新建一个LinkedList
        LinkedList llist = new LinkedList();
        //---- 添加操作 ----
        // 依次添加1,2,3
        llist.add(&quot;1&quot;);
        llist.add(&quot;2&quot;);
        llist.add(&quot;3&quot;);

        // 将“4”添加到第一个位置
        llist.add(1, &quot;4&quot;);


        System.out.println(&quot;\nTest \&quot;addFirst(), removeFirst(), getFirst()\&quot;&quot;);
        // (01) 将“10”添加到第一个位置。  失败的话，抛出异常！
        llist.addFirst(&quot;10&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将第一个元素删除。        失败的话，抛出异常！
        System.out.println(&quot;llist.removeFirst():&quot;+llist.removeFirst());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取第一个元素。          失败的话，抛出异常！
        System.out.println(&quot;llist.getFirst():&quot;+llist.getFirst());


        System.out.println(&quot;\nTest \&quot;offerFirst(), pollFirst(), peekFirst()\&quot;&quot;);
        // (01) 将“10”添加到第一个位置。  返回true。
        llist.offerFirst(&quot;10&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将第一个元素删除。        失败的话，返回null。
        System.out.println(&quot;llist.pollFirst():&quot;+llist.pollFirst());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取第一个元素。          失败的话，返回null。
        System.out.println(&quot;llist.peekFirst():&quot;+llist.peekFirst());


        System.out.println(&quot;\nTest \&quot;addLast(), removeLast(), getLast()\&quot;&quot;);
        // (01) 将“20”添加到最后一个位置。  失败的话，抛出异常！
        llist.addLast(&quot;20&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将最后一个元素删除。        失败的话，抛出异常！
        System.out.println(&quot;llist.removeLast():&quot;+llist.removeLast());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取最后一个元素。          失败的话，抛出异常！
        System.out.println(&quot;llist.getLast():&quot;+llist.getLast());


        System.out.println(&quot;\nTest \&quot;offerLast(), pollLast(), peekLast()\&quot;&quot;);
        // (01) 将“20”添加到第一个位置。  返回true。
        llist.offerLast(&quot;20&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将第一个元素删除。        失败的话，返回null。
        System.out.println(&quot;llist.pollLast():&quot;+llist.pollLast());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取第一个元素。          失败的话，返回null。
        System.out.println(&quot;llist.peekLast():&quot;+llist.peekLast());



        // 将第3个元素设置300。不建议在LinkedList中使用此操作，因为效率低！
        llist.set(2, &quot;300&quot;);
        // 获取第3个元素。不建议在LinkedList中使用此操作，因为效率低！
        System.out.println(&quot;\nget(3):&quot;+llist.get(2));


        // ---- toArray(T[] a) ----
        // 将LinkedList转行为数组
        String[] arr = (String[])llist.toArray(new String[0]);
        for(String str:arr) {
            System.out.println(&quot;str:&quot;+str);
        }

        // 输出大小
        System.out.println(&quot;size:&quot;+llist.size());
        // 清空LinkedList
        llist.clear();
        // 判断LinkedList是否为空
        System.out.println(&quot;isEmpty():&quot;+llist.isEmpty()+&quot;\n&quot;);

    }

    /**
     * 将LinkedList当作 LIFO(后进先出)的堆栈
     */
    private static void useLinkedListAsLIFO() {
        System.out.println(&quot;\nuseLinkedListAsLIFO&quot;);
        // 新建一个LinkedList
        LinkedList stack = new LinkedList();

        // 将1,2,3,4添加到堆栈中
        stack.push(&quot;1&quot;);
        stack.push(&quot;2&quot;);
        stack.push(&quot;3&quot;);
        stack.push(&quot;4&quot;);
        // 打印“栈”
        System.out.println(&quot;stack:&quot;+stack);

        // 删除“栈顶元素”
        System.out.println(&quot;stack.pop():&quot;+stack.pop());

        // 取出“栈顶元素”
        System.out.println(&quot;stack.peek():&quot;+stack.peek());

        // 打印“栈”
        System.out.println(&quot;stack:&quot;+stack);
    }

    /**
     * 将LinkedList当作 FIFO(先进先出)的队列
     */
    private static void useLinkedListAsFIFO() {
        System.out.println(&quot;\nuseLinkedListAsFIFO&quot;);
        // 新建一个LinkedList
        LinkedList queue = new LinkedList();

        // 将10,20,30,40添加到队列。每次都是插入到末尾
        queue.add(&quot;10&quot;);
        queue.add(&quot;20&quot;);
        queue.add(&quot;30&quot;);
        queue.add(&quot;40&quot;);
        // 打印“队列”
        System.out.println(&quot;queue:&quot;+queue);

        // 删除(队列的第一个元素)
        System.out.println(&quot;queue.remove():&quot;+queue.remove());

        // 读取(队列的第一个元素)
        System.out.println(&quot;queue.element():&quot;+queue.element());

        // 打印“队列”
        System.out.println(&quot;queue:&quot;+queue);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三.源码解读&quot;&gt;三.源码解读&lt;/h2&gt;
&lt;h3 id=&quot;数据结构&quot;&gt;1.数据结构&lt;/h3&gt;
&lt;p&gt;LinkedList 是一个双向链表。内部类 Node 是 LinkedList 中的基本数据结构，包含当前节点值，上一个节点得引用，和下个节点的引用。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 链表中有多少个节点，默认为 0    
transient int size = 0;
// 头节点
transient Node&amp;lt;E&amp;gt; first;
// 尾节点
transient Node&amp;lt;E&amp;gt; last;
    private static class Node&amp;lt;E&amp;gt; {
        E item;
        Node&amp;lt;E&amp;gt; next;
        Node&amp;lt;E&amp;gt; prev;
        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181108230334351-2123075201.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;构造方法&quot;&gt;2.构造方法&lt;/h3&gt;
&lt;p&gt;比较简单，默认无参构造，和一个 Collection 参数的构造（ 将里面元素按顺序前后连接，修改节点个数，并且操作次数 + 1 ）。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public LinkedList() {
    }

    /**
     * Constructs a list containing the elements of the specified
     * collection, in the order they are returned by the collection's
     * iterator.
     *
     * @param  c the collection whose elements are to be placed into this list
     * @throws NullPointerException if the specified collection is null
     */
    public LinkedList(Collection&amp;lt;? extends E&amp;gt; c) {
        this();
        addAll(c);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加方法add&quot;&gt;3.添加方法ADD&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 尾部插入
public boolean add(E e) {
    // 去为节点加
    linkLast(e);
    return true;
}
// 将指定的元素防止在链表的尾节点，以前的尾节点变成它前面的节点，如果上个尾节点为null，说明以前是的空链表。
void linkLast(E e) {
    final Node&amp;lt;E&amp;gt; l = last;
    final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
 // 添加一个，我们就需要把size增加
    size++;
    modCount++;
}
add(int index, E element)
  public void add(int index, E element) {
  // 边界校验
      checkPositionIndex(index);
      if (index == size)
          linkLast(element);
      else
          linkBefore(element, node(index));
  }
  /**
   * Returns the (non-null) Node at the specified element index.
   */
  Node&amp;lt;E&amp;gt; node(int index) {
      // assert isElementIndex(index);
// 双链表可以分别从 头节点 或者尾节点开始遍历，计算它是在前面一半，还是在后面的位置，决定遍历方式。
// 这也是LinkedList 为什么要使用双向链表，提升了使用游标操作链表的效率。
      if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) {
          Node&amp;lt;E&amp;gt; x = first;
          for (int i = 0; i &amp;lt; index; i++)
              x = x.next;
          return x;
      } else {
          Node&amp;lt;E&amp;gt; x = last;
          for (int i = size - 1; i &amp;gt; index; i--)
              x = x.prev;
          return x;
      }
  }
  /**
   * Inserts element e before non-null Node succ.
   */
  void linkBefore(E e, Node&amp;lt;E&amp;gt; succ) {
      // assert succ != null;
      final Node&amp;lt;E&amp;gt; pred = succ.prev;
      final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(pred, e, succ);
      succ.prev = newNode;
      if (pred == null)
          first = newNode;
      else
          pred.next = newNode;
      size++;
      modCount++;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查索引是否越界，虽然 ListedList 中没有索引概念；&lt;br/&gt;如果 index 和 size 相同，则在尾节点上加上元素；&lt;br/&gt;不相同的话，先去遍历链表查找到索引位置的节点，然后在它的前面插入节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181108230403582-1035346423.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 1.s-&amp;gt;prior=p-&amp;gt;prior;
 2. p-&amp;gt;prior-&amp;gt;next=s;
 3. s-&amp;gt;next=p;
 4. p-&amp;gt;prior=s;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取元素get&quot;&gt;4.获取元素Get&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public E get(int index) {  
// 检查索引越界；
// 跟上面的一样，查找该索引位置的节点，然后获取它的元素。
    checkElementIndex(index);  
    return node(index).item;  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除元素remove&quot;&gt;5.删除元素Remove&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   public E remove() {
       return removeFirst();
   }
   // 移除头节点
   public E removeFirst() {
       final Node&amp;lt;E&amp;gt; f = first;
       if (f == null)
           throw new NoSuchElementException();
       return unlinkFirst(f);
   }
   // 参数 f 为头节点
// 将头节点指向 next 节点，如果 next节点 为 null 则链表 为 null ，链表大小减 1 ，修改次数记录加 1.
   private E unlinkFirst(Node&amp;lt;E&amp;gt; f) {
       // assert f == first &amp;amp;&amp;amp; f != null;
       final E element = f.item;
       final Node&amp;lt;E&amp;gt; next = f.next;
       f.item = null;
       f.next = null; // help GC
       first = next;
       if (next == null)
           last = null;
       else
           next.prev = null;
       size--;
       modCount++;
       return element;
   }
public E remove(int index) {  
    checkElementIndex(index);  
    return unlink(node(index));  
}  
    /**
     * Unlinks non-null node x.
     */
    E unlink(Node&amp;lt;E&amp;gt; x) {
        // assert x != null;
        final E element = x.item;
        final Node&amp;lt;E&amp;gt; next = x.next;
        final Node&amp;lt;E&amp;gt; prev = x.prev;
        // 如果本节点为头节点，头节点指向next
        if (prev == null) {
            first = next;
        } else {
            // 不是头节点，则将前节点和后节点连接起来，然后删掉本节点的引用 GC
            prev.next = next;
            x.prev = null;
        }
        // 如果是尾节点，则将尾节点指向前节点
        if (next == null) {
            last = prev;
        } else {
            // 连接，双向链表，双方都有引用，删除自身的引用GC
            next.prev = prev;
            x.next = null;
        }
        // 删除自身 GC
        x.item = null;
        size--;
        modCount++;
        return element;
    }

// 遍历 equals 找出 node，然后调用 unlink(Node&amp;lt;E&amp;gt; x)   
public boolean remove(Object o) {
        if (o == null) {
            for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {
            for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181108230420521-947719206.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;更新元素set&quot;&gt;6.更新元素Set&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
*有索引，第一件事去检查索引是否越界；根据索引找出 node；
*替换 node 的元素，返回 该索引位置 Node 的旧元素的值。
*注意，Set 方法不增加LinkedList 的修改次数
*/
public E set(int index, E element) {
    checkElementIndex(index);
    Node&amp;lt;E&amp;gt; x = node(index);
    E oldVal = x.item;
    x.item = element;
    return oldVal;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;清空clear&quot;&gt;7.清空clear()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//释放所有的元素，让他们直接无引用，垃圾回收器发现这些 node 元素是不可达的时候，释放内存。
// 数据恢复默认；修改次数记录加一。
public void clear() {  
       // Clearing all of the links between nodes is &quot;unnecessary&quot;, but:  
       // - helps a generational GC if the discarded nodes inhabit  
       //   more than one generation  
       // - is sure to free memory even if there is a reachable Iterator  
       for (Node&amp;lt;E&amp;gt; x = first; x != null; ) {  
           Node&amp;lt;E&amp;gt; next = x.next;  
           x.item = null;  
           x.next = null;  
           x.prev = null;  
           x = next;  
       }  
       first = last = null;  
       size = 0;  
       modCount++;  
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四arraylist和linkedlist比较&quot;&gt;四、ArrayList和LinkedList比较&lt;/h2&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ArrayList的实现是基于数组，LinkedList的实现是基于双向链表。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于随机访问，ArrayList优于LinkedList&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于插入和删除操作，LinkedList优于ArrayList&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;https://blog.wuwii.com/java-linkedlist.html#more&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/skywang12345/p/3308807.html&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Thu, 08 Nov 2018 15:06:00 +0000</pubDate>
<dc:creator>辰砂tj</dc:creator>
<og:description>title: java集合之LinkedList tags: java集合 author: 辰砂 一. LinkedList概述： List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tojian/p/9932657.html</dc:identifier>
</item>
<item>
<title>Vue.js-05：第五章 - 计算属性与监听器 - 墨墨墨墨小宇</title>
<link>http://www.cnblogs.com/danvic712/p/9919205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danvic712/p/9919205.html</guid>
<description>&lt;h3&gt;&lt;strong&gt; 一、前言&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　在 Vue 中，我们可以很方便的将数据使用插值表达式（ Mustache 语法）的方式渲染到页面元素中，但是插值表达式的设计初衷是用于简单运算，即我们不应该对差值做过多的操作。当我们需要对差值做进一步的处理时，这时，我们就应该使用到 Vue 中的计算属性来完成这一操作。同时，当差值数据变化时执行异步或开销较大的操作时，我们可以通过采用监听器的方式来达到我们的目的。&lt;/p&gt;
&lt;p&gt;　　学习系列目录地址：&lt;a href=&quot;https://www.cnblogs.com/danvic712/p/9549100.html&quot; target=&quot;_black&quot;&gt;https://www.cnblogs.com/danvic712/p/9549100.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　仓储地址：&lt;a href=&quot;https://github.com/Lanesra712/VueTrial/blob/master/Chapter01-Rookie/watcher.html&quot; target=&quot;_blcak&quot;&gt;https://github.com/Lanesra712/VueTrial/blob/master/Chapter01-Rookie/watcher.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 二、干货合集&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;　　&lt;strong&gt;1、计算属性&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;计算属性，一般是用来描述一个属性值依赖于另一个的属性值，当我们使用插值表达式将计算属性绑定到页面元素上时，计算属性会在依赖的属性值的变化时自动的更新 DOM 元素。例如在下面的代码中，我们在 computed 中，定义了一个 reversedMessage 属性，它可以根据我们的 data 中的 message 属性的变化自动的获取到反转后的 message 的属性值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    输入的值：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    反转的值：{{reversedMessage}}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data: {
            message: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;
        },
        computed: {
            reversedMessage: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的 this 指向 当前的 vm 实例&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.message.split(&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;).reverse().join(&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
            }
        },
        methods: {}
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201811/1310859-20181108224925485-1357222603.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可能你会发觉，这里的写法和我们定义方法时很相似，我们完全也可以在 methods 中定义一个方法来实现这个需求。原来，计算属性的本质就是一个方法，只不过，我们在使用计算属性的时候，是把计算属性的名称直接当做属性来使用，而并不会把计算属性当做一个方法去调用。&lt;/p&gt;
&lt;p&gt;　　那么，为什么我们还要去使用计算属性而不是去定义一个方法呢？原来，计算属性是基于它们的依赖进行缓存的。即只有在相关依赖发生改变时它们才会重新求值。例如在上面的例子中，只要 message 的属性值没有发生改变，无论任何使用我们使用到 reversedMessage 属性，都会立即返回之前的计算结果，而不必再次执行函数。&lt;/p&gt;
&lt;p&gt;　　反之，如果你使用方法的形式实现，当你使用到 reversedMessage 方法时，无论 message 属性是否发生了改变，方法都会重新执行一次，这无形中增加了系统的开销。当然，你也可以自己在方法中实现根据依赖进行缓存，嗯，如果你不嫌烦的话。。。&lt;/p&gt;
&lt;p&gt;　　在上面的案例中，对于 reversedMessage 这个计算属性来说，我们主要的目的是为了获取属性的值，即使用的是计算属性的 getter 方法。不过，如果你需要使用到计算属性的 setter 方法时，我们也是可以为计算属性提供一个 setter 方法的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    输入的值：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    反转的值：{{reversedMessage}}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data: {
            message: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;
        },
        computed: {
            reversedMessage: {
                get: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.message.split(&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;).reverse().join(&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
                },
                set: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.message &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; value.split(&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;).reverse().join(&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
                }
            }
        },
        methods: {}
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在上面的代码中，我们为计算属性 reversedMessage 增加了一个 setter 方法：通过设置 reversedMessage 的值，同样进行反转操作，并最终将结果赋值给属性 message。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201811/1310859-20181108225144735-579625588.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　&lt;strong&gt;2、监听属性&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在 vue 中，我们不光可以使用计算属性的方式来监听数据的变化，还可以使用 watch 监听器的方法来监测某个数据发生的变化。不同的是，计算属性仅仅是对于依赖数据的变化后进行的数据操作，而 watch 更加侧重于对于监测中的某个数据发生变化后所执行的一系列的业务逻辑操作。&lt;/p&gt;
&lt;p&gt;　　监听器以 key-value 的形式定义，key 是一个字符串，它是需要被监测的对象，而 value 则可以是字符串（方法的名称）、函数（可以获取到监听对象改变前的值以及更新后的值）或是一个对象（对象内可以包含回调函数的其它选项，例如是否初始化时执行监听 immediate，或是是否执行深度遍历 deep，即是否对对象内部的属性进行监听）。&lt;/p&gt;
&lt;p&gt;　　1）回调值为函数方法&lt;/p&gt;
&lt;p&gt;　　在下面的例子中，我们监听了 message 属性的变化，根据属性的变化后执行了回调方法，打印出了属性变化前后的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    输入的值：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data: {
            message: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;
        },
        computed: {},
        watch: {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调为未创建的方法&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (newValue, oldValue) {
                console.log(`新值：${newValue} &lt;/span&gt;&lt;span&gt;---------&lt;/span&gt;&lt;span&gt; 旧值：${oldValue}`)
            }
        },
        methods: {}
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201811/1310859-20181108225310520-1131933270.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　同样的，我们可以通过方法名称指明回调为已经定义好的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    输入的值：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data: {
            message: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;
        },
        computed: {},
        watch: {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调为已创建好的方法&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;recording&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        },
        methods: {
            recording: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (newValue, oldValue) {
                console.log(`method记录：新值：${newValue} &lt;/span&gt;&lt;span&gt;---------&lt;/span&gt;&lt;span&gt; 旧值：${oldValue}`)
            }
        }
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201811/1310859-20181108225404165-373876787.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）回调值为对象&lt;/p&gt;
&lt;p&gt;　　当我们监听的回调值为一个对象时，我们不仅可以设置回调函数，还可以设置一些回调的属性。例如，在下面的例子中，我们监听了 User 这个对象，同时执行了执行深度遍历，这时，当我们监听到 User.name 这个属性发生改变的时候，我们就可以执行我们的回调函数。注意，深度遍历默认为 false，当不启用深度遍历时，我们是无法监听到对象的内部属性的变化的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    用户姓名：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;User.name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data: {
            message: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
            User: {
                name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                gender: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            }
        },
        computed: {},
        watch: {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调为对象&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;User&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
                handler: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (newValue, oldValue) {
                    console.log(`对象记录：新值：${newValue.name} &lt;/span&gt;&lt;span&gt;---------&lt;/span&gt;&lt;span&gt; 旧值：${oldValue.name}`)
                },
                deep: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            }
        },
        methods: {}
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201811/1310859-20181108225458325-1472155828.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可能你发现了，为什么 newValue 与 oldValue 都是一样的啊？原来，当我们监听的数据为对象或数组时，newValue 和 oldValue 是相等的，因为对象和数组都为引用类型，这两个的形参指向的也是同一个数据对象。同时，如果我们不启用深度遍历，我们将无法监听到对于 User 对象中 name 属性的变化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    用户姓名：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;User.name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data: {
            message: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
            User: {
                name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                gender: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            }
        },
        computed: {},
        watch: {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调为对象&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;User&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
                handler: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (newValue, oldValue) {
                    console.log(`对象记录：新值：${newValue.name} &lt;/span&gt;&lt;span&gt;---------&lt;/span&gt;&lt;span&gt; 旧值：${oldValue.name}`)
                },
                deep: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
            }
        },
        methods: {}
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201811/1310859-20181108225533239-2079743454.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 三、总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　1、计算属性的结果会被缓存起来，只有依赖的属性发生变化时才会重新计算，必须返回一个数据，主要用来进行纯数据的操作。&lt;/p&gt;
&lt;p&gt;　　2、监听器主要用来监听某个数据的变化，从而去执行某些具体的回调业务逻辑，不仅仅局限于返回数据。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 四、参考&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　1、&lt;a href=&quot;https://segmentfault.com/a/1190000010408657&quot; target=&quot;_blank&quot;&gt;深入理解 Vue Computed 计算属性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　2、&lt;a href=&quot;https://www.w3cplus.com/vue/vue-computed-intro.html&quot; target=&quot;_blank&quot;&gt;Vue 2.0学习笔记： Vue中的computed属性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　3、&lt;a href=&quot;https://juejin.im/post/5a6f21a86fb9a01ca47ac4b9&quot; target=&quot;_blank&quot;&gt;Vue系列之computed使用详解&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 08 Nov 2018 15:00:00 +0000</pubDate>
<dc:creator>墨墨墨墨小宇</dc:creator>
<og:description>一、前言 在 Vue 中，我们可以很方便的将数据使用插值表达式（ Mustache 语法）的方式渲染到页面元素中，但是插值表达式的设计初衷是用于简单运算，即我们不应该对差值做过多的操作。当我们需要对差</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/danvic712/p/9919205.html</dc:identifier>
</item>
<item>
<title>Unity3D_(插件)使用Camera渲染制作Minimap小地图 - Cynical丶Gary</title>
<link>http://www.cnblogs.com/1138720556Gary/p/9932608.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1138720556Gary/p/9932608.html</guid>
<description>

&lt;p&gt;&lt;strong&gt;　　制作小地图：使用Camera渲染出来Render Texture&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　游戏项目已托管到Github上　　&lt;a href=&quot;https://github.com/luoweiwu/Unity_Minimap_plug-in&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;小地图效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181108225122710-27523645.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（不足：当玩家旋转方向的时候，并未对玩家UI进行角度转换~）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181108234141577-200844533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;预制场景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　创建一个场景Gary_map&lt;/p&gt;
&lt;p&gt;　　调整场景灯光亮度Intensity为0.3&lt;/p&gt;
&lt;p&gt;　　添加一个Plane地面，给地面添加材质模拟地图场景&lt;/p&gt;
&lt;p&gt;　　添加一个Capsule物体作为玩家Player,为Player绑定PlayerMove脚本控制其移动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181108202748422-257981704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_efe42332-5119-4148-9f99-a3c01104ffe8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_efe42332-5119-4148-9f99-a3c01104ffe8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_efe42332-5119-4148-9f99-a3c01104ffe8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PlayerMove : MonoBehaviour {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; speed = &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use this for initialization&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start () {
        
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update is called once per frame&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update () {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; h = Input.GetAxis(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Horizontal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; v = Input.GetAxis(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Vertical&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        transform.Translate(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Vector3(h,&lt;span&gt;0&lt;/span&gt;,v)*speed*&lt;span&gt;Time.deltaTime);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;PlayerMove.cs&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　添加几个Capsule物体作为敌人Enemy，给Enemy添加脚本使其随机移动&lt;/p&gt;
&lt;p&gt;　　添加材质给Player，区别于敌人&lt;/p&gt;
&lt;p&gt;　　添加Ground标签给地面，Human标签给玩家和敌人（目的：只用来作为摄像机Culling Mask渲染层级，不做玩家和敌人区分）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181108210726582-1225072489.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_e6a90d33-2ae4-4db8-8cf8-0ae49e17a236&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e6a90d33-2ae4-4db8-8cf8-0ae49e17a236&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e6a90d33-2ae4-4db8-8cf8-0ae49e17a236&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EnemyMove : MonoBehaviour {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; speed =&lt;span&gt;4&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; timer = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; dirx = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; dirz = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update is called once per frame&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update () {
        timer &lt;/span&gt;+=&lt;span&gt; Time.deltaTime;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timer &amp;gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)
        {
            dirx &lt;/span&gt;= Random.Range(-&lt;span&gt;1f, 1f);
            dirz &lt;/span&gt;= Random.Range(-&lt;span&gt;1f, 1f);
            timer &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        transform.Translate(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Vector3(dirx, &lt;span&gt;0&lt;/span&gt;, dirz) * speed *&lt;span&gt; Time.deltaTime);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;EnemyMove.cs&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　给Player添加Quad，作为小地图的mapicon,放到Player正上方并将其x轴旋转90°&lt;/p&gt;
&lt;p&gt;　　给mapicon添加一个图标，材质设为Diffuse(透明)&lt;/p&gt;
&lt;p&gt;　　给mapicon一个Minimap标签&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181108212454333-273389718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　给每个敌人AI一个红色的icon&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181108212733146-1317622182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　添加一个Camera放到Player中，Position设置为(0,9,0)，X轴旋转90°，命名为minimap-camera&lt;/p&gt;
&lt;p&gt;　　设置minimap-camera的Projection为Orthographic&lt;/p&gt;
&lt;p&gt;　　minimap-camera小地图大小由Size控制&lt;/p&gt;
&lt;p&gt;　　为了将在小地图上看不见敌人，将Culling Mask取消Human的渲染&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181108213928811-1431210342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　将小地图渲染的视觉渲染到Render Texture图片上&lt;/p&gt;
&lt;p&gt;　　创建一个新的Render Texture，命名为minimap-texture，将minimap-texture绑定到minimap-camera上的Target Texture&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181108214558110-240435096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用NGUI添加小地图进场景中&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　添加NUI编辑包&lt;/p&gt;
&lt;p&gt;　　如果遇到提示RuntimePlatform.WindowsWebPlayerNGUI过时，将WindowsWebPlayerNGUI修改为WindowsPlayerNGUI&lt;/p&gt;
&lt;p&gt;　　添加NGUI中第一个背景UI Root&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181108222057706-1571427792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　UI Root添加一个Simple Texture&lt;/p&gt;
&lt;p&gt;　　将Texture放到UI Root右上角并将minimap-texture指定到UITexture上的Texture中&lt;/p&gt;
&lt;p&gt;　　将Texture下的Anchors设置为Unified,放置到UI Root右上方&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181108223749281-831311874.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　将正方形地图制作成圆形地图&lt;/p&gt;
&lt;p&gt;　　制作一个自定义材质Mask，取名minimap-mat&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181108224016075-1301541962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　将minimap-mat放置到Texture下的Material中，可通过改变Size来改变小地图的大小&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181108224238713-356472747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　切换3D视角，地图camera渲染地面&lt;/p&gt;
&lt;p&gt;　　Main Camera和minimap-camera下的Culling Mask设置渲染Ground标签(地面)&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181108225333705-1804188144.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 08 Nov 2018 14:56:00 +0000</pubDate>
<dc:creator>Cynical丶Gary</dc:creator>
<og:description>制作小地图：使用Camera渲染出来Render Texture 游戏项目已托管到Github上 传送门 小地图效果： （不足：当玩家旋转方向的时候，并未对玩家UI进行角度转换~） 预制场景 创建一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1138720556Gary/p/9932608.html</dc:identifier>
</item>
<item>
<title>我的机器学习之路--anaconda环境搭载 - cyrio</title>
<link>http://www.cnblogs.com/cyrio/p/9932128.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyrio/p/9932128.html</guid>
<description>
&lt;p&gt;&lt;span&gt;网上许多教程比较晦涩难懂，本教程按照笔者（新手）自己的视角记录，希望给大家一些帮助&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、安装anaconda&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前比较推荐的机器学习环境为anaconda。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Anaconda指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过anaconda中的navigator我们可以方便的管理不同的python版本，随时创建或销毁一个环境，不同环境可以有不同的python版本（如，同时存在py3.6和py2.7），并且在不同的环境中允许使用存在不同的包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以方便的在cmd切换到某个环境，方便我们在遇到一些只支持py2的包时能够快速使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我计算机的操作系统为windows10 64位，选择下载anaconda3。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先进入anaconda官网 https://www.anaconda.com/download/，选择你对应的系统来下载.exe文件进行安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1523532/201811/1523532-20181108215614485-1321082856.png&quot; alt=&quot;&quot; width=&quot;814&quot; height=&quot;366&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后选择你自己想要安装的路径，一路next就好了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1523532/201811/1523532-20181108215804309-1618448127.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;PS：值得注意的是，这里记得将第一个选项（为anaconda添加到系统PATH环境变量）和第二个选项（能够让pycharm别的程序调用）打钩&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;等待安装完毕。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装完毕之后我们可以在开始菜单看到有关快捷方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击&lt;img src=&quot;https://img2018.cnblogs.com/blog/1523532/201811/1523532-20181108220008545-1519346062.png&quot; alt=&quot;&quot;/&gt;，我们就可以进入一个比较形象的管理界面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在管理界面我们可以选择自己想要用的环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、安装tensorflow&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从开始菜单的&lt;img src=&quot;https://img2018.cnblogs.com/blog/1523532/201811/1523532-20181108220145033-443305553.png&quot; alt=&quot;&quot;/&gt;进入cmd&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1523532/201811/1523532-20181108220225640-1680833732.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显示如下界面，其中base表示你现在在base环境，后面的路径为你现在运行的路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;PS：可以通过输入d:&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　cd 文件夹名&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　进入任意目录&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这里输入conda -h查看帮助&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;conda info -e查看你安装了哪些环境&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;conda list 查看当前环境下你装了哪些包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了后续下载速度的考虑，我们在这里设置清华大学镜像源，就不用翻到国外服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开C:\Users\Shinelon（PS：shinelon为你的用户名），找到.condarc这个文件，右键用记事本或notepad++编辑，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;覆盖以下内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;em&gt;channels:&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;- https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&lt;/span&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;span&gt;- defaults&lt;/span&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;span&gt;ssl_verify: true&lt;/span&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;span&gt;show_channel_urls: true&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着我们把pip（安装别的包时可能要用到的一个程序）的源也改一下，改成豆瓣的源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在同一个目录新建pip.ini，粘贴以下内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;[global]&lt;/em&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;em&gt;index-url = http://mirrors.aliyun.com/pypi/simple&lt;/em&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;em&gt;[install]&lt;/em&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;em&gt;trusted-host=mirrors.aliyun.com&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;好了，源设置完毕&lt;/p&gt;


&lt;p&gt;&lt;span&gt;我们现在要新建一个新的环境，我目前推荐的版本为py3.6，在conda界面输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt; conda create -n tens  python=3.6&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tens可以替换成任意字符，即你创建的环境的名字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;activate tens&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即可进入该环境，此时&amp;lt;base&amp;gt;变成了&amp;lt;tens&amp;gt;，表示创建成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1523532/201811/1523532-20181108222147178-1213447395.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;接着我们输入&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;pip install tensorflow-gpu&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;tensorflow有cpu和gpu两种版本，你可以选择你想要的，一般来说GPU运行速度较快，但是在往往安装过程中gpu会出现很多问题。&lt;/p&gt;
&lt;p&gt;系统会自动识别前置包并下载。&lt;/p&gt;
&lt;p&gt;（如果你选择安装GPU版本，你还需要下载CUDNN，CUDA这两个软件，你可以选择从英伟达官网下载，也可以选择安装tensorflow-gpu时pip自动给你安装）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;！！特别重要的一点，请务必安装CUDNN 6.0 + CUDA 8.0 来搭配py3.6 ，别的版本可能引起未知的错误！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;！！同时请从网上下载微软的visual studio 2015版本 安装，在安装时你只需要安装本体+&quot;c++&quot;选项，不需要别的，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是即使你现在使用了别的版本的vs，也请安装2015版，否则将无法使用tensorflow-gpu，因为有必要组件在安装vs2015时被安装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        vs允许同时存在多个版本，但是请确保你的C盘够大……&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在你安装成功之后，请在&amp;lt;tens&amp;gt;的cmd中输入&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;python&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果出现一串版本号，则进入成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后逐行输入：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;import tensorflow as tf&lt;br/&gt;hello = tf.constant('Hello, TensorFlow!')&lt;br/&gt;sess = tf.Session()&lt;br/&gt;print sess.run(hello)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果不报错，输出了 b“Hello, TensorFlow!”则表示你安装成功！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果出现报错，请在搜索引擎中粘贴你的报错来查找错误原因，也欢迎留言交流。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、为pycharm配置解释器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从官网下载community社区版的pycharm（一款比较好用的IDE，你可以选择自己喜欢的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装好之后新建一个项目create new project&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1523532/201811/1523532-20181108224710306-1992470001.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 你可以选择你项目要存储的位置&lt;/p&gt;
&lt;p&gt;点开下面的小箭头&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1523532/201811/1523532-20181108224801640-366363119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1523532/201811/1523532-20181108224819147-299776349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择add local&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1523532/201811/1523532-20181108224835034-1835382629.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择system interpreter&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1523532/201811/1523532-20181108224916257-1445449487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加载你本地的python.exe&lt;/p&gt;
&lt;p&gt;然后你就可以在pycharm中编辑运行你的程序了。&lt;/p&gt;

&lt;p&gt;#################################################&lt;/p&gt;
&lt;p&gt;本次教程到这里结束，欢迎大家留言交流&lt;/p&gt;
</description>
<pubDate>Thu, 08 Nov 2018 14:51:00 +0000</pubDate>
<dc:creator>cyrio</dc:creator>
<og:description>网上许多教程比较晦涩难懂，本教程按照笔者（新手）自己的视角记录，希望给大家一些帮助 1、安装anaconda 目前比较推荐的机器学习环境为anaconda。 Anaconda指的是一个开源的Pytho</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyrio/p/9932128.html</dc:identifier>
</item>
<item>
<title>Shell应用之网卡流量监测 - 小短腿电工</title>
<link>http://www.cnblogs.com/haozheyu/p/9932487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haozheyu/p/9932487.html</guid>
<description>&lt;p&gt;需求分析&lt;br/&gt;1）按固定时间监测一次网卡流量&lt;br/&gt;2）当网卡流量为0时重启网卡&lt;/p&gt;
&lt;p&gt;一、网卡流量查询&lt;br/&gt;sar（System ActivityReporter系统活动情况报告）是目前Linux上最为全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：文件的读写情况、系统调用的使用情况、磁盘I/O、CPU效率、内存使用状况、进程活动及IPC有关的活动等，sar命令有sysstat安装包安装。&lt;br/&gt;这里我们利用sar 命令中的网络监控功能&lt;br/&gt;sar -n #统计网络信息&lt;br/&gt;sar -n选项使用6个不同的选项：DEV，EDEV，NFS，NFSD，SOCK，IP，EIP，ICMP，EICMP，TCP，ETCP，UDP，SOCK6，IP6，EIP6，ICMP6，EICMP6和UDP6 ，DEV显示网络接口信息，EDEV显示关于网络错误的统计数据，NFS统计活动的NFS客户端的信息，NFSD统计NFS服务器的信息，SOCK显示套接字信息，ALL显示所有5个开关。它们可以单独或者一起使用。&lt;br/&gt;sar -n DEV 1 1： 每间隔1秒统计一次，总计统计1次，其中的average是在多次统计后的平均值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@mail sbin]# sar -n DEV 1 1  
Linux 3.10.0-862.el7.x86_64 (mail.rhcc.com)     11/08/18    _x86_64_    (1 CPU)

21:33:15        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
21:33:16        ens37      1.01      0.00      0.06      0.00      0.00      0.00      0.00
21:33:16           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
21:33:16    virbr0-nic      0.00      0.00      0.00      0.00      0.00      0.00      0.00
21:33:16       virbr0      0.00      0.00      0.00      0.00      0.00      0.00      0.00
21:33:16        ens33      0.00      0.00      0.00      0.00      0.00      0.00      0.00

Average:        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
Average:        ens37      1.01      0.00      0.06      0.00      0.00      0.00      0.00
Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:    virbr0-nic      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:       virbr0      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:        ens33      0.00      0.00      0.00      0.00      0.00      0.00      0.00&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;二、网卡的查询和重启&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  #&amp;gt;查询的命令有
  397  ip a
  398  ifconfig 
  399  nmcli device show
  #&amp;gt;网卡重启 
  402  ifdown ens37 &amp;amp;&amp;amp; ifup ens37
  405  ifdown ens37 ; ifup ens37
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;网络网卡的配置路径在&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@mail sbin]# cd /etc/sysconfig/network-scripts/
更改完配置记得重启服务&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三、抓包分析&lt;br/&gt;通常网卡流量异常时都需要查看分析，往往抓包就是最直观的查看方式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@mail network-scripts]# tcpdump -nn -i ens37 -c 100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&amp;gt;加上-w 参数可以将抓取的内容保存到固定的&lt;/em&gt;.cap文件中，这个文件是可以用&lt;/p&gt;
&lt;p&gt;Windows的wireshark工具查看的，同样tcpdump -r *.cap 也可以查看。&lt;/p&gt;
&lt;p&gt;四、案例分析&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
LANG=C  #&amp;gt;设置英文的的环境
if [ ! rpm -q sysstat &amp;amp;&amp;gt; /dev/null ]
then
    yum install -y sysstat
fi       #&amp;gt;判断sar是否可执行
sar -n DEV 1 10 |grep 'ens37' &amp;gt; /tmp/ens37_sar.log  #&amp;gt;监测网卡流量重定向
net_in=`grep '^Average:' /tmp/ens37_sar.log|awk '{print $5}'`     #&amp;gt;分析入流量
net_out=`grep '^Average:' /tmp/ens37_sar.log|awk '{print $6}'`     #&amp;gt;分析出流量
if [ $net_in == &quot;0&quot; -a $net_out == &quot;0&quot; ] 
then
    echo &quot;`date` ens37 Flow anomaly&quot;  &amp;gt;&amp;gt; /tmp/net.log
    ifdown ens37 &amp;amp;&amp;amp;  ifup ens37
fi      #&amp;gt;判断出入的流量是否为0 ，为0则重启网卡
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;五、定时监测的实现&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12765605-9e567dacacae1eec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/520&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@mail sbin]# crontab -e
no crontab for root - using an empty one
crontab: installing new crontab
[root@mail sbin]# crontab -l
30 * * * * /bin/sh /usr/local/sbin/tp.sh &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;-------------END---------------&lt;/p&gt;
</description>
<pubDate>Thu, 08 Nov 2018 14:29:00 +0000</pubDate>
<dc:creator>小短腿电工</dc:creator>
<og:description>需求分析 1）按固定时间监测一次网卡流量 2）当网卡流量为0时重启网卡 一、网卡流量查询 sar（System ActivityReporter系统活动情况报告）是目前Linux上最为全面的系统性能分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haozheyu/p/9932487.html</dc:identifier>
</item>
<item>
<title>webpack+react多页面开发(二)-终极架构 - Leinov</title>
<link>http://www.cnblogs.com/leinov/p/9932443.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leinov/p/9932443.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://www.h5cool.com/webpack-react3.png&quot; alt=&quot;webpack-react-multi-page&quot;/&gt;&lt;/p&gt;
&lt;p&gt;webpack在单页面打包上应用广泛，以create-react-app为首的脚手架众多，单页面打包通常指的是将业务js，css打包到同一个html文件中，整个项目只有一个html文件入口,但也有&lt;strong&gt;许多业务需要多个页面不同的入口，比如不同的h5活动，或者需要支持seo的官方网站，都需要多个不同的html&lt;/strong&gt;。&lt;strong&gt;webpack-react-multi-page&lt;/strong&gt;架构让你可以在多页面在项目开发中&lt;strong&gt;自动化打包新创建页面并保证每个页面都可以热更新&lt;/strong&gt; ，build打包后有清晰的文件层次结构。&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;概览&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1.85&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;webpack+react多页面架构&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;描述&lt;/td&gt;
&lt;td&gt;简单易用的多页面自动化开发架构&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;开发者&lt;/td&gt;
&lt;td&gt;leinov&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;发布日期&lt;/td&gt;
&lt;td&gt;2018-11-07&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;版本&lt;/td&gt;
&lt;td&gt;2.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;仓库&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/leinov/webpack-react-multi-page&quot;&gt;github地址&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;特性&quot;&gt;特性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;👩‍👩‍👧‍👧 支持多页面同时热加载开发&lt;/li&gt;
&lt;li&gt;📇 自动识别新创建页面&lt;/li&gt;
&lt;li&gt;📝 每个页面生成个性化信息&lt;/li&gt;
&lt;li&gt;🚻 分类打包&lt;/li&gt;
&lt;li&gt;🔗 灵活扩展&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装使用&quot;&gt;安装&amp;amp;使用&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;// clone
git clone git@github.com:leinov/webpack-react-multi-page.git

// 安装依赖包
npm install

// 开发
npm run dev

// 编译打包
npm run build

// 启动生产页面
npm start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新创建页面在src下添加文件夹并创建&lt;code&gt;pageinfo.json&lt;/code&gt; 然后&lt;code&gt;npm run dev&lt;/code&gt; 即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;|-- src
    |-- index/
    |-- page2/
        |-- index.js
        |-- pageinfo.json&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;项目架构&quot;&gt;项目架构&lt;/h2&gt;
&lt;h4 id=&quot;技术使用&quot;&gt;技术使用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;react16&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;webpack4&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;html-webpack-plugin 生成html文件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mini-css-extract-plugin css分离打包&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uglifyjs-webpack-plugin js压缩&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optimize-css-assets-webpack-plugin css压缩&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;es6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;babel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;opn 打开浏览器&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compression 开启gzip压缩&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;express&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;目录结构&quot;&gt;目录结构&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;|-- webpack-react-multi-pages //项目
    |-- dist //编译生产目录
        |-- index
            |-- index.css
            |-- index.js
        |-- about
            |-- about.css
            |-- about.js
        |-- images
        |-- index.html
        |-- about.html
    |-- node_modules //node包
    |-- src //开发目录
        |-- index //index页面打包入口
            |-- images/
            |-- js
                |-- app.js// 业务js
            |-- index.sass
            |-- index.js //页面js入口
        |-- about //about页面打包入口
            |-- images/
                |--js
                    |-- app.js// 业务js
            |-- about.sass
            |-- about.js //页面js入口
        |-- template.html // html模板
        |-- style.sass //公共sass
    |-- webpackConfig //在webpack中使用
        |-- getEntry.js //获取入口
        |-- getFilepath.js //src下需要打包页面文件夹
        |-- htmlconfig.js //每个页面html注入数据
    |-- package.json
    |-- .gitignore
    |-- webpack.config.js //webpack配置文件
    |-- www.js //生产启动程序&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;wiki&quot;&gt;wiki&lt;/h2&gt;
&lt;h3 id=&quot;webpack打包单页面应用&quot;&gt;webpack打包单页面应用&lt;/h3&gt;
&lt;p&gt;webpack在单页面打包上应用广泛，以create-react-app为首的接触脚手架众多，单页面打包通常指的是将业务js，css打包到同一个html文件中，整个项目只有一个html文件入口&lt;/p&gt;
&lt;h3 id=&quot;webpack单页面打包配置&quot;&gt;webpack单页面打包配置&lt;/h3&gt;
&lt;p&gt;webpack.config.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = (env, argv) =&amp;gt; ({
    entry: &quot;.src/index.js&quot;,
    output: {
        path: path.join(__dirname, &quot;dist&quot;),
        filename: &quot;bundle.js&quot;
    },
    module: {
        rules: [
        ...
        ],
    },
    plugins: [
        new HtmlWebpackPlugin({
            title: &quot;首页&quot;,
            filename:&quot;index.html&quot;,
            favicon:&quot;&quot;,
            template: &quot;./src/template.html&quot;,

        })
    ]
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就可以在&lt;code&gt;dist&lt;/code&gt;文件夹下打包出一个下面这样的文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
    &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;首页&amp;lt;/title&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div id=&quot;root&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;webpack多页面打包配置&quot;&gt;webpack多页面打包配置&lt;/h3&gt;
&lt;p&gt;webpack 的entry支持两种种格式&lt;/p&gt;
&lt;h4 id=&quot;打包单个文件&quot;&gt;打包单个文件&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
  entry: '.src/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就会在dist下打包出一个bundle.js&lt;/p&gt;
&lt;h4 id=&quot;打包出多个文件&quot;&gt;打包出多个文件&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
  entry: {
    index:&quot;./src/index.js&quot;,
    about:&quot;./src/about.js&quot;
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js' index.js,about.js这两个文件
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面在dist下打包出两个与entry属性名对应的js文件&lt;/p&gt;
&lt;h4 id=&quot;将每个js挂载到相应的html文件上&quot;&gt;将每个js挂载到相应的html文件上&lt;/h4&gt;
&lt;p&gt;这里我们需要用到&lt;code&gt;html-webpack-plugin&lt;/code&gt;这个webpack插件,每添加一个页面就需要在plugins添加一个&lt;code&gt;new HtmlWebpackPlugin({....})&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
module.exports = (env, argv) =&amp;gt; ({
    entry: {
        index:&quot;./src/index.js&quot;,
        about:&quot;./src/about.js&quot;
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js' index.js,about.js这两个文件
    }
    ....//其他配置
    plugins: [
        new HtmlWebpackPlugin(
            {
                filename:&quot;index.html&quot;,//生成的index.html
                template: &quot;./src/template.html&quot;,}) //模板
                chunks:[&quot;index&quot;]
            }),
        new HtmlWebpackPlugin(
            {
                filename:&quot;about.html&quot;,//生成的index.html
                template: &quot;./src/template.html&quot;,}) //模板
                chunks:[&quot;index&quot;]
            })
    ]
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;html-webpack-plugin&lt;/code&gt; 会通过 &lt;code&gt;template.html&lt;/code&gt; 模板生成对应的filename名的html文件，并一并打包到output中对应的文件夹下，注意，在没有特殊配置的情况下所有打包的文件都是对应到output中 &lt;code&gt;path&lt;/code&gt; 这个目录下，也包括html。这里的 &lt;code&gt;chunks&lt;/code&gt; 需要注意，它是确定该html需要引入哪个js，如果没写的话，默认会引出所有打包的js，当然这不是我们想要的。&lt;/p&gt;
&lt;p&gt;上面的配置最终可以在dist下打包出下面的文件结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;|-- dist
    |-- index.js
    |-- about.js
    |-- index.html //内挂载index.js
    |-- about.html //内挂载about.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面这样的配置，再加上devServer，我们已经可以实现多页面的配置开发了，但这样很不智能，因为你每增加一个页面，就要在wepback里面配置一次，会非常繁琐，所以我们来优化下，让我们只专注于开发页面，配置交给webpack自己.&lt;/p&gt;
&lt;h3 id=&quot;webpack多页面配置优化&quot;&gt;webpack多页面配置优化&lt;/h3&gt;
&lt;p&gt;我们再看下src下面的文件结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;|-- src
    |-- index
        |-- app.js
        |-- index.scss
        |-- index.js
    |-- about
        |-- app.js
        |-- index.scss
        |-- index.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;src下面每个文件夹对应一个html页面的js业务，如果我们直接把文件夹对应入口js找到并把他们合并生成对应的entry，那是不是就不用手动写entry了呢，是的!&lt;/p&gt;
&lt;h4 id=&quot;遍历文件目录&quot;&gt;遍历文件目录&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/* eslint-env node */

/**
 * @file: getFilePath.js  遍历文件目录
 * @author: leinov
 * @date: 2018-10-11
 */

const fs = require(&quot;fs&quot;);

/**
 * 【遍历某文件下的文件目录】
 *
 * @param {String} path 路径
 * @returns {Array} [&quot;about&quot;,&quot;index&quot;]
 */
module.exports = function getFilePath(path){
    let fileArr = [];
    let existpath = fs.existsSync(path); //是否存在目录
    if(existpath){
        let readdirSync = fs.readdirSync(path);  //获取目录下所有文件
        readdirSync.map((item)=&amp;gt;{
            let currentPath = path + &quot;/&quot; + item;
            let isDirector = fs.statSync(currentPath).isDirectory(); //判断是不是一个文件夹
            if(isDirector &amp;amp;&amp;amp; item !== &quot;component&quot;){ // component目录下为组件 需要排除
                fileArr.push(item);
            }
        });
        return fileArr;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如在src下有index页面项目，about项目 遍历结果为[&quot;index&quot;,&quot;about&quot;];&lt;/p&gt;
&lt;h4 id=&quot;遍历生成打包入口数组&quot;&gt;遍历生成打包入口数组&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/* eslint-env node */
/**
 * @file: getEntry.js 获取entry文件入口
 * @author: leinov
 * @date: 2018-10-11
 * @update: 2018-11-04 优化入口方法 调用getFilePath
 */
const getFilePath = require(&quot;./getFilepath&quot;);
/**
 * 【获取entry文件入口】
 *
 * @param {String} path 引入根路径
 * @returns {Object} 返回的entry { &quot;about/aoubt&quot;:&quot;./src/about/about.js&quot;,...}
 */
module.exports = function getEnty(path){
    let entry = {};
    getFilePath(path).map((item)=&amp;gt;{
        /**
         * 下面输出格式为{&quot;about/about&quot;:&quot;./src/aobout/index.js&quot;}
         * 这样目的是为了将js打包到对应的文件夹下
         */
        entry[`${item}/${item}`] = `${path}/${item}/index.js`;
    });
    return entry;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们使用getFilepath获取的数组，在获取到每个目录下的js文件，组合成一个js入口文件的如下格式的对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;index/index&quot;:&quot;./src/index/index.js&quot;,
    &quot;about/about&quot;:&quot;./src/about/index.js&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在webpack中使用getentry&quot;&gt;在webpack中使用getEntry&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;const getEntry = require(&quot;./webpackConfig/getEntry&quot;);
const entry = getEntry();

module.exports = (env, argv) =&amp;gt; ({
    entry: entry,
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就自动获取到了entry&lt;/p&gt;
&lt;h4 id=&quot;html-webpack-plugin自动配置&quot;&gt;html-webpack-plugin自动配置&lt;/h4&gt;
&lt;p&gt;因为每个页面都需要配置一个html，而且每个页面的标题，关键字，描述等信息可能不同，所以我们在每个页面文件夹下创建一个pageinfo.json,通过fs模块获取到json里信息再遍历到对应得html-webpack-plugin中生成一个html插件数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;index/pageinfo.json&lt;/code&gt; 生成&lt;code&gt;index.html&lt;/code&gt;页面信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;title&quot;:&quot;首页&quot;,
     &quot;keywords&quot;:&quot;webpack多页面&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;about/pageinfo.json&lt;/code&gt; 生成&lt;code&gt;about.html&lt;/code&gt;页面信息供&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;title&quot;:&quot;关于页面&quot;,
    &quot;keywords&quot;:&quot;webpack多页面关于页面&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过fs遍历读取并生成HtmlWebpackPlugin数组供webpack使用&lt;/p&gt;
&lt;h4 id=&quot;遍历html插件数组&quot;&gt;遍历html插件数组&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @file htmlconfig.js  页面html配置
 * @author:leinov
 * @date: 2018-10-09
 * @update: 2018-11-05
 * @use: 动态配置html页面，获取src下每个文件下的pageinfo.json内容,解析到HtmlWebpackPlugin中
 */

const fs = require(&quot;fs&quot;);
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);//生成html文件
const getFilePath = require(&quot;./getFilepath&quot;);
let htmlArr = [];

getFilePath(&quot;./src&quot;).map((item)=&amp;gt;{
    let infoJson ={},infoData={};
    try{
        // 读取pageinfo.json文件内容，如果在页面目录下没有找到pageinfo.json 捕获异常
        infoJson = fs.readFileSync(`src/${item}/pageinfo.json`,&quot;utf-8&quot;);//
        infoData = JSON.parse(infoJson);
    }catch(err){
        infoData = {};
    }
    htmlArr.push(new HtmlWebpackPlugin({
        title:infoData.title ? infoData.title : &quot;webpack,react多页面架构&quot;,
        meta:{
            keywords: infoData.keywords ? infoData.keywords : &quot;webpack，react，github&quot;,
            description:infoData.description ? infoData.description : &quot;这是一个webpack，react多页面架构&quot;
        },
        chunks:[`${item}/${item}`], //引入的js
        template: &quot;./src/template.html&quot;,
        filename : item == &quot;index&quot; ? &quot;index.html&quot; : `${item}/index.html`, //html位置
        minify:{//压缩html
            collapseWhitespace: true,
            preserveLineBreaks: true
        },
    }));
});

module.exports = htmlArr;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;wbpack终极配置&quot;&gt;wbpack终极配置&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;const path = require(&quot;path&quot;);
const getEntry = require(&quot;./webpackConfig/getEntry&quot;); //入口配置
const entry = getEntry(&quot;./src&quot;);
const htmlArr =require(&quot;./webpackConfig/htmlConfig&quot;);// html配置

module.exports = (env, argv) =&amp;gt; ({
    entry: entry
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js'
    }
    ....//其他配置
    devServer: {
    port: 3100,
    open: true,
    },
    plugins: [
        ...htmlArr
    ]
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一个自动化完整的多页面架构配置就完成了，如果我们要新创建一个页面&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;在src下创建一个文件目录&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;在新创建的文件目录下添加&lt;code&gt;index.js&lt;/code&gt;（必须，因为是webpack打包入口文件）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;在新创建文件夹下添加&lt;code&gt;pageinfo.json&lt;/code&gt;（非必须） 供html插件使用&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;npm run dev&lt;/code&gt;开发&lt;br/&gt;完整代码参考项目&lt;a href=&quot;https://github.com/leinov/webpack-react-multi-page&quot;&gt;code&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;版本&quot;&gt;版本&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;0.92771084337349&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;1.8723404255319&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/leinov/webpack-react-multi-page&quot;&gt;2.0&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2018-11-08&lt;/td&gt;
&lt;td&gt;&lt;code&gt;master&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;优化html插件自动化&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/leinov/webpack-react-multi-page/tree/version1.0&quot;&gt;1.0&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2018-10-07&lt;/td&gt;
&lt;td&gt;&lt;code&gt;version1.0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第一版&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Thu, 08 Nov 2018 14:21:00 +0000</pubDate>
<dc:creator>Leinov</dc:creator>
<og:description>webpack4+react16多页面架构 webpack在单页面打包上应用广泛，以create react app为首的脚手架众多，单页面打包通常指的是将业务js，css打包到同一个html文件中，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leinov/p/9932443.html</dc:identifier>
</item>
<item>
<title>python 生成器 - 旦复旦兮</title>
<link>http://www.cnblogs.com/ChinacloudTech/p/9932384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ChinacloudTech/p/9932384.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;tag blue label&quot;&gt;python&lt;/span&gt;&lt;span class=&quot;tag blue label&quot;&gt;生成器&lt;/span&gt;&lt;/p&gt;

&lt;h5 class=&quot;xsj_heading_h5&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;生成器&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;Python中提供的生成器：&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;1.生成器函数：常规函数定义，但是，使用yield语句而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次重它离开的地方继续执行&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;2.生成器表达式：类似于列表推导，但是，生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;生成器Generator：&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;　　本质：生成器的本质就是迭代器(所以自带了__iter__方法和__next__方法，不需要我们去实现)&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;　　特点：惰性运算,开发者自定义&lt;/p&gt;

&lt;h5 class=&quot;xsj_heading_h5&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;生成器函数：&lt;/span&gt;&lt;/h5&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot;&gt;含有yield关键字的函数就是生成器函数
特点：
    1 调用函数的之后函数不执行，返回一个生成器
    2 每次调用next方法的时候会取到一个值
    3 直到取完最后一个，在执行next会报错
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;一个简单的code 例子如下：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot; python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; time
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;genrator_fun1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    a = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    print(&lt;span class=&quot;hljs-string&quot;&gt;'现在定义了a变量'&lt;/span&gt;)
    &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; a
    b = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;
    print(&lt;span class=&quot;hljs-string&quot;&gt;'现在又定义了b变量'&lt;/span&gt;)
    &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; b

g1 = genrator_fun1()
print(&lt;span class=&quot;hljs-string&quot;&gt;'g1 : '&lt;/span&gt;,g1)       
print(&lt;span class=&quot;hljs-string&quot;&gt;'-'&lt;/span&gt;*&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;)   
print(next(g1))
time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)   
print(next(g1))
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_1&quot;&gt;g1 : &amp;lt;generator object genrator_fun1 at 0x00000227FF504888&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr class=&quot;xsj_minus&quot;/&gt;&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;现在定义了a变量&lt;br/&gt;1&lt;br/&gt;现在又定义了b变量&lt;br/&gt;2&lt;/p&gt;

&lt;h5 class=&quot;xsj_heading_h5&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;生成器的思考和好处&lt;/span&gt;&lt;/h5&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot;&gt;一个包含yield关键字的函数就是一个生成器函数。yield可以为我们从函数中返回值，但是yield又不同于return，return的执行意味着程序的结束，调用生成器函数不会得到返回的具体的值，而是得到一个可迭代的对象。每一次获取这个可迭代对象的值，就能推动函数的执行，获取新的返回值。直到函数执行结束。
生成器有什么好处呢？就是不会一下子在内存中生成太多数据
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;假如我想让工厂给学生做校服，生产2000000件衣服，我和工厂一说，工厂应该是先答应下来，然后再去生产，我可以一件一件的要，也可以根据学生一批一批的找工厂拿。&lt;br/&gt;而不能是一说要生产2000000件衣服，工厂就先去做生产2000000件衣服，等回来做好了，学生都毕业了。。。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot; python&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;produce&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;生产衣服&quot;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;2000000&lt;/span&gt;):
        &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;生产了第%s件衣服&quot;&lt;/span&gt;%i

product_g = produce()
print(product_g.__next__()) 
print(product_g.__next__()) 
print(product_g.__next__()) 
num = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; product_g:         
    print(i)
    num +=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; num == &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;:
        &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_1&quot;&gt;生产了第0件衣服&lt;br/&gt;生产了第1件衣服&lt;br/&gt;生产了第2件衣服&lt;br/&gt;生产了第3件衣服&lt;br/&gt;生产了第4件衣服&lt;br/&gt;生产了第5件衣服&lt;br/&gt;生产了第6件衣服&lt;br/&gt;生产了第7件衣服&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 class=&quot;xsj_heading_h6&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;从生成器中取值的几个方法&lt;/span&gt;&lt;/h6&gt;
&lt;ol&gt;&lt;li&gt;next&lt;/li&gt;
&lt;li&gt;for&lt;/li&gt;
&lt;li&gt;数据类型的强制转换 : 占用内存,比如list(product_g)&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 class=&quot;xsj_heading_h5&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;sent 函数&lt;/span&gt;&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;send 获取下一个值的效果和next基本一致&lt;/li&gt;
&lt;li&gt;只是在获取下一个值的时候，给上一yield的位置传递一个数据&lt;/li&gt;
&lt;li&gt;使用send的注意事项&lt;br/&gt;第一次使用生成器的时候 是用next获取下一个值&lt;br/&gt;最后一个yield不能接受外部的值&lt;br/&gt;Code :&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot; python&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;generator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    print(&lt;span class=&quot;hljs-number&quot;&gt;123&lt;/span&gt;)
    content = &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    print(&lt;span class=&quot;hljs-string&quot;&gt;'======='&lt;/span&gt;,content)
    print(&lt;span class=&quot;hljs-number&quot;&gt;456&lt;/span&gt;)
    &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;

g = generator()
ret = g.__next__()
print(&lt;span class=&quot;hljs-string&quot;&gt;'***'&lt;/span&gt;,ret)
ret = g.send(&lt;span class=&quot;hljs-string&quot;&gt;'hello'&lt;/span&gt;)   
print(&lt;span class=&quot;hljs-string&quot;&gt;'***'&lt;/span&gt;,ret)
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_1&quot;&gt;123&lt;br/&gt;*** 1&lt;br/&gt;======= hello&lt;br/&gt;456&lt;br/&gt;*** 2&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 08 Nov 2018 14:08:00 +0000</pubDate>
<dc:creator>旦复旦兮</dc:creator>
<og:description>python 生成器 python生成器 生成器 Python中提供的生成器： 1.生成器函数：常规函数定义，但是，使用yield语句而不是return语句返回结果。yield语句一次返回一个结果，在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ChinacloudTech/p/9932384.html</dc:identifier>
</item>
<item>
<title>一个秋招后计科学生的简单总结 - Erick_Lv</title>
<link>http://www.cnblogs.com/Erick-Lv/p/9932307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Erick-Lv/p/9932307.html</guid>
<description>&lt;p&gt;第一次这么详细地写个人经历，算是对自己大学几年学习编程的总结吧。我不是什么计算机大佬，也没有所谓的计算机天赋，这一路走来磕磕绊绊的，踩过许多坑，走了很多弯路，最后也是靠着一些运气，以一个应届生的身份加入到了完美世界（北京）。现在公司安排的员工公寓中，等待HR下发最后的通知，不出意外的话，周一就能正式开始实习了。趁现在，写一下个人感想吧，希望能对一些同学有启发！&lt;/p&gt;
&lt;p&gt;本博文没有涉及到太多技术性的东西，更多的是个人的经历以及总结，希望一些还在学习的同学能有所收获！！！&lt;/p&gt;
&lt;p&gt;PS：好久不来博客园写了，一直在CSDN。。。感觉CSDN的写作界面比较友好，，就是广告太多了。。。。。&lt;/p&gt;

&lt;p&gt;我的本科就读于一所普通的院校（非985、211），现在是大四，明年正式毕业，专业是计算机科学与技术，感谢我的学校给我提供的一些环境，让我可以有今天一点点小成绩；也十分感谢那些帮助过我的老师和同学们，很幸运可以遇到你们。&lt;/p&gt;
&lt;h2 id=&quot;来计算机专业之前&quot;&gt;来计算机专业之前&lt;/h2&gt;
&lt;p&gt;故事要从高考前开始说起。高考之前，像很多北方的男孩子一样，我是想着去报考军校的或者当一个飞行员的，很不幸，由于某些因素，这两个愿望都落空了。当时也不知道自己想要干什么，所以选择了飞行器有关的专业（可能还是很喜欢飞机之类的吧）。高考结束后，根据自己的实际成绩报考专业，第一志愿也很幸运地被现在地母校的飞行器专业录取，开始了我的大学的第一个阶段，飞行器与机械大类专业。&lt;/p&gt;
&lt;p&gt;大一上学期，都是高数、画法几何等的一些基础课程。我当时没有一些确切的目标，但是大体上想的时能进一些研究所之类的，所以这些课程学的非常认真，虽然我内心里不是很喜欢画各种工图。当然，有付出肯定是有回报的，我的成绩在专业里也非常靠前，再加上是学校的王牌专业之一，不禁有些飘飘然的感觉。现在再回想起来，当时的我挺幼稚的。在该学期，也经历了很多的课外活动，比如情景剧、辩论赛和各种的知识竞赛等，虽然有一些小的成绩，但总是感觉少了些什么。&lt;/p&gt;
&lt;p&gt;真正触动我的，是学校计算机博弈协会的宣讲。我本来对计算机程序设计毫无兴趣，甚至报志愿前，专门避开了计算机类的专业。本来我是不打算去的，也多亏了我的助导，他那时候是大三，而且他邻班的一个同学在这方面取得了很好的成绩，所以助导一直催促着我去，在抱着试试看的心态下，我和班里的另一个关系很好的同学就去听了一下宣讲会。上面提到的助导，现在某航发集团公司工作，而且算是他比较想去的公司吧；助导的邻班同学，也是我很佩服的一个学长，现在是北京某211高校的计算机专业硕士，也非常的优秀；另一个关系很好的同学，正在准备今年的考研，方向也是飞行器类的，衷心祝愿同学可以考研成功！&lt;/p&gt;
&lt;p&gt;宣讲会上，很多内容我都忘记了，但是有两点对我触动比较大：老师说协会的同学都是很优秀的；计算机以后的收入比较高，很多同学是10K起步的（税前、不扣除五险一金、正式转正入职）。当时听了很心动，尤其是收入上，因为之前总是对月薪年薪等缺乏具体的概念，不是到多少是合适的。抱着试试看的态度，我加入了机器博弈协会。上面提到老师的说法，现在来看部分是正确的，只有那些少数真正能投入精力进行学习的同学，才是比较优秀的；计算机如果学的比较好，就单纯看月薪或者年薪的话，真是很高的，至少如果一个能力较强强的同学转正，是很轻松超过老师说的那些的），甚至说10K根本都不考虑去了。&lt;/p&gt;
&lt;p&gt;寒假里自学C语言，开学后，在某个学长的指导下，我完成了第一个五子棋人人对弈的小程序，只是一个控制台的，能判断胜负等。我心情最激动时候，是写出下面这段很经典的入门代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int main() 
{
    printf(&quot;hello world !&quot;);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当时，我对计算程序设计的错误认识就没有了，取而代之的是一种可以自己掌控计算机的满足感，这也极大地激发了我在这方面的学习兴趣。&lt;/p&gt;
&lt;p&gt;大一下学期到大二下学期转专业之前，是我技术一个进步期，也是各种采坑和走弯路的时期。大一下学期，为了准备机器博弈校赛的选拔，我开始自己去研究那些博弈程序。很可惜，当时没有遇到正确的引路人，全都是靠着自己摸索。那时候，我一直以为C语言（或者说是编程）就那么几个模块，比如顺序、选择、分支和循环等，甚至觉得指针没什么用处。我不知道有算法和数据结构、不知道有ACM等的一些比赛、不知道有Github等的一些网站、不知道什么是面向对象程序设计、不知道软件工程、不知道前端后端等，总之就是各种不知道，一直被局限在自己的思维里，现在想想，真是可笑至极。&lt;/p&gt;
&lt;p&gt;后来被选去参加国赛，为了这个比赛，我“专门”地去学习C++，当时地想法也很幼稚：C++就是比C语言多了一个class，把printf、scanf等关键字换成了cout、cin等，反正也是各种无知，再加上我们组里都不是计算机专业出身的，所以就十分的尴尬了。又因为当时的信息不对称，不知道该怎么学、向谁请教等，导致我连DFS这种简单的算法，都是到比赛前一个月才突然有了灵感（大佬们就别喷我了，真的很菜。。）。不过还好，之前学长有写过搜索框架，我和当时的学长英语能力都还可以，然后照着论文去搞了一下评估函数，最后成绩还行，不过还是有些心虚。&lt;/p&gt;
&lt;p&gt;大二上学期，认识了几个计算机同学，知道了有数据结构和算法这些东西。当时借了一本C++的数据结构，我就像发现了武林秘籍一样，知道了原来自己还有这么多不会的，瞬间感觉被打脸了。我把这本C++的数据结构的所有代码和练习题，自己上机实践了至少一遍，理解了C++语言的一些基础、基本的面向对象的思想，更重要的是有了算法和数据结构的一些基本思想，基本上能读懂一些大佬们写的技术博客了，那是我感觉最充实的一个阶段之一。&lt;/p&gt;
&lt;h2 id=&quot;转入计算机专业&quot;&gt;转入计算机专业&lt;/h2&gt;
&lt;p&gt;后来，为了能更好地学习有关计算机地技术，我在大二下学期申请转入计算机专业。当时很多同学和我专业的负责老师，认为我这人不正常，非要从一个王牌专业转入一个非王牌的专业。现在来看，我个人感觉这个决定是很对的，至少从收入看是这样的。可能一年后，很多之前专业那些直接就业的同学的月收入（都是税前、不扣除各种金），能有我的1/2或1/3就算比较高的了，而且这是不算项目奖金，年终奖之类的。别喷我，我没装×，我个人是只想赚钱，你有你的价值观，我有我的判别标准，而且这是由行业性质和社会趋势决定的，而且我暂时不是什么大佬，牛×的人远比我赚的多。。。&lt;/p&gt;
&lt;p&gt;刚转来计科，就被数电和模电教做人了，，我曾经一度怀疑我学的不是计算机。。。数据结构这课，就去听过两次，因为之前很认真的自学了，期末成绩和课设成绩都很高。。。就这样，我的计算机专业之旅非常奇葩，，软件方向基本没话多少心思，最多考前突击一下，就能搞个还可以的成绩，，硬件和电路方面多亏了有同学的帮忙，才能勉强度日。。。&lt;/p&gt;
&lt;p&gt;在计算机专业里，还发生了很多有意义的事情，我就不赘述了，仅仅选出几个对其他同学有参考价值的事情吧。&lt;/p&gt;
&lt;p&gt;第一个是接触到了ACM校队的同学，跟着他们一起刷题、搞算法、包括大二暑假一直留校刷题等。虽然我没在这方面取得一些突出的成绩，但是这些基本的算法思想却深深印到我的脑海里了（算法dalao就忽略我这种小菜鸡啊）。&lt;/p&gt;
&lt;p&gt;第二个是一直坚持写代码。其实即使是转入了计算机学院，我还是很迷茫的。我不知道自己到底应该干嘛。在这期间，我尝试过各种技术，从前端到后端、从PC端到移动端、从AI到区块链等。当然，这些具体的编程语言我都忘得差不多了，但是一些基础的思想还是刻录在了头脑中。&lt;/p&gt;
&lt;p&gt;第三个是一直保持着一个还算可以的学习劲头吧。虽然我没能像那些dalao们一样，能在各种国际类大赛上一展身手（有部分原因是我找不到方向），但是我内心了还是很怕自己落后的，即使没找到具体的突破点，但是我任然是一个想要加入一个优秀的团队并不断学习的渴望，所以“不断学习”这根弦一直在紧绷着。我认为，不过是那个行业，都得有不断学习的观念，都要树立终身学习的意识，靠一个技能吃老本的时代已经过去了。&lt;/p&gt;
&lt;p&gt;不知不觉到了今年上半年，因为我想要加入一个优秀的团队、想要学习更多的东西，但是却一时想不出有更好的方式，所以选择了考研。不过，考研期间，也就是大三下学期，我还是有些心有不甘，总是觉得大学期间少了些什么。这学期，有我最喜欢的软件工程课，这门课不仅仅是老师讲解理论，更重要的是可以去实践，包括团队项目等，而且我们是ZX老师组织的一个全国性的软工课程，还可以参考其他院校同学的实践情况，我个人比较推荐这种方式；也感谢我的软工老师ZYF老师和助教ZR老师，在两位老师身上学到很多实际开发的流程经验。而且这期间，我还接触了一下区块链等的一些东西。虽然是在准备考研，但是却总想进入业界看一下，这也是后期放弃考研而秋招的一个伏笔。&lt;/p&gt;

&lt;p&gt;终于还是厌烦了天天刷题的应试教育，加上家里的一些原因，耗费了2-3个月处理的时间，我最终还是决定来业界。此时已经是9月份末期了，很多秋招都结束了。本来是计划着一直学习到明年春招呢，现在来看，两个月前的想法还是挺幼稚的。10月末的一个周三下午，我投出了第一份简历，这种行动一致持续到周五。本来以为要0offer了，没想到第二周来了好多的笔试和面试的机会。从投出简历到收到第一个电话期间，我的内心还是非常波动的，情绪也是很不稳定。不过好在后来一份份的邀请冲淡了我的不良情绪。&lt;/p&gt;
&lt;p&gt;我有收到小米、三七互娱、多益科技等一些大厂的，也有一些我个人认为比较有前景的创业公司的。不过多益科技的笔试谜一般的挂了（我个人感觉做的最好的一个😂），小米的岗位不是十分想去的，三七互娱一直没有回复，直到突然收到了完美世界的面试邀请。总共两轮面试，结果最后通过了，还是非常高兴的。之后三七又给了面试机会，不过既然完美世界要给offer了，那么我也不去三七互娱了，个人倾向于北京。创业公司的话，如果感觉是一个明星团队，而且个人实力允许，可以考虑加入。本次我接触的有两个是游戏界的明星创业团队，至少成员大部分是当年特别火的游戏的主程、策划之类的，而且A轮或者B轮融了很多钱，公司规模控制在几十人的那种，具体公司名称和人员不方便透露，不过我很看好他们，但是可能我更想先去大公司体验一下，所以选择了完美世界。&lt;/p&gt;
&lt;p&gt;之后，就是现在在完美的员工公寓里等待最后的实习计划了。&lt;/p&gt;
&lt;p&gt;感谢我遇到所有的HR和面试官，不管是大厂还是小厂，也不管是大公司还是创业公司，这些HR和面试官们的有很高的职业素质，我从他们身上学会了很多东西，希望这些公司发展顺利，这些人事业有成！！&lt;/p&gt;

&lt;p&gt;以下是我个人对于怎样学习的一些总结，这结合了我的一些经历，尤其是各种坑。希望可以对各位有所启发吧。可能这更适合新手。&lt;/p&gt;
&lt;h2 id=&quot;摒弃完美主义&quot;&gt;摒弃完美主义&lt;/h2&gt;
&lt;p&gt;编程中的“完美主义”是非常致命的。举个简单的例子，我们要学习某个技术，并把它应用到实际开发中。如果是以前的我，那么我可能会把与该技术有关的书都借来，然后研读每个细节，直到所有的点都弄明白，然后再动手尝试着去开发。其实这就是一种所谓的“完美主义”，绝大多数起因于我们之前的应试教育的阴影。正确的做法应该是尝试着去做，边学边做，这样才可以更加高效的学习，而且可以满足项目的进度。之前的方式，不仅影响进度，而且会让我们迷失在细节的汪洋大海中，失去兴趣。学中做、做中学。&lt;/p&gt;
&lt;h2 id=&quot;想清楚了立马就去做不要瞻前顾后&quot;&gt;想清楚了立马就去做，不要瞻前顾后&lt;/h2&gt;
&lt;p&gt;之前，我在学习某个技术的时候，一直在想这个东西有没有用，学了可以干什么。总是在纠结这种问题，很难全身心的投入到学习中；而且，纠结的时间，就几乎可以入门某个技术了。更要命的是，我们的知识体系不够，或者说是我们不了解整个知识框架，才有这种幼稚的想法。其实多学习一些技术，在很多时候可以拓宽我们的知识面，虽然很多东西会忘记，但是一些基本思路和基本方法都会有较深地印象，一些资深架构师、技术专家和项目负责人等，都有很广阔的知识体系。&lt;/p&gt;
&lt;h2 id=&quot;学习编程的核心是学习思路和特性而不是所谓的词法语法&quot;&gt;学习编程的核心是学习思路和特性，而不是所谓的词法、语法&lt;/h2&gt;
&lt;p&gt;首先，我要说明，&lt;strong&gt;词法语法很重要&lt;/strong&gt;，这是程序能运行的基础，但是在刚开始学习的时候，不要过分的纠结于这些细节，要把主要的精力放在语言本身特性上，如果是新手，还要注意学习算法和数据结构。&lt;/p&gt;
&lt;p&gt;举个简单的例子，C++本身的特性相当复杂（看看标准手册就知道了），号称最难的语言。如果我们有了C语言的基础了，再学习C++的话，最好不要直接看那么复杂的手册。其实应该C++的基本特性入手（我不是C++高手，不当的地方还请包含）：C++相比于C语言，最核心的是扩展了面向对象部分和泛型编程（包括STL）部分（先不考虑C++11以及以后的版本），因此我们在学习的时候，先把这两个基本点弄清楚。或者说，这两个点的基本用法先弄明白，搞清楚怎么回事后，在一步步地深入拓展下去；而不是每天都看标准手册，我估计那样正常人都会GG。。拓展的时候也是，每个点都要边学边练的策略，由浅入深。我之前踩的坑是刚开始就像搞明白所有的东西，结果最后搞得身心疲惫，以至于很难学精，而且丢了兴趣。&lt;/p&gt;
&lt;p&gt;同样的例子，如果由C++转Java，我们需要了解Java语言的基本特性是什么。先不考虑JVM的情况下，主要的区别有两大点：面向对象的部分和自动垃圾回收的部分（包括指针引用之类的）。掌握了基本特性，在一步步地去解决，不仅效率高，而且不会丢失兴趣。&lt;/p&gt;
&lt;h2 id=&quot;学习编程不要钻牛角尖编程最终目的是为了解决问题需求&quot;&gt;学习编程不要钻牛角尖，编程最终目的是为了解决问题（需求）&lt;/h2&gt;
&lt;p&gt;我遇到过很多同学，包括之前的我在内，总是容易钻牛角尖。比如说，将来是要做后台的，那么前端的东西一点都不碰；或者说，我认为Linux才是一个合格开发者必备的工具，用Windows显得很菜（可能一般是是服务端同学这么想）；又或者说，大佬们都用vim or Emacs，用IDE显得没有那么Geek等等。这样类似的问题有很多，我个人把它们归结为钻牛角尖。其实，现在来看，这种想法是很幼稚的，连基本的东西都搞不明白，就一味地追求所谓地“高手地配置”，没什么卵用；而且，只要能高效地解决问题，就不要管那些是否是“Geek”的东西，&lt;strong&gt;编程的本质是为了解决问题（需求）&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;要合理分配学习的重心搞明白问题的轻重缓急以需求为导向&quot;&gt;要合理分配学习的重心，搞明白问题的轻重缓急，以需求为导向&lt;/h2&gt;
&lt;p&gt;现在，各种新技术层出不穷，令人眼花缭乱，别说是新手了，就是有一定编程经验同学，也会纠结各种各样问题。但是，以我现在的观点来看，造成这种现象的一个很重要的原因是，我们没能搞明白自己的真正需求。技术总是学不完的，如果再像 应试教育那样，非要搞明白每个知识点，那么肯定完不成任务，正确的做法是先弄明白自己到底要干什么，然后再去搜集有关的资料等，最后确定解决问题的大体步骤，然后根据步骤来有计划地、分部分地学习。很多时候，编程学习需要不求甚解，这是和应试教育最大区别，也是我们最需要克服的障碍之一。&lt;/p&gt;
&lt;h2 id=&quot;多向他人请教多与别人交流保持一个谦卑的心态&quot;&gt;多向他人请教，多与别人交流，保持一个谦卑的心态&lt;/h2&gt;
&lt;p&gt;“程序员是最骄傲的一个群体”，这话不是没有道理的。甚至可以说相当一部分的程序员，都想要证明自己的牛×高明之处，总是有想要证明自己比别人聪明、比别人强，总要成为整个项目的最最最核心的人物，总是有强烈的个人英雄主义情结。我承认，曾经的我也是这样的，后来接触的人和事情多了以后，我也一直在反思自己的不足之处，我也一直在努力地克服自己的缺点。&lt;/p&gt;
&lt;p&gt;《商业的本质》一书有一句很经典的话：“商业的本质是一个团体活动”。我个人十分赞同这句话，我们在IT界，先排除那些纯粹公益性质的开源项目，我们中的绝大多数人编程是为了做商业性质项目来获取收入的。那么，我们从事的活动本质上也是一个商业活动，那么也就是团体活动了。而上述的行为，是非常“反团体”的，这种行为肯定会对真个项目组造成极为恶劣的影响。&lt;/p&gt;
&lt;p&gt;人都有有自己的个性，但是不能把这个作为一些坏毛病的借口，所谓“人不可以有傲气，但不可无傲骨”。我们要学会欣赏并学习周围同学（同事）有点和长处，多和他们交流，取长补短，真正地去发挥团队的力量。要记住一句话：别人总是有地方比自己聪明的。&lt;/p&gt;
&lt;h2 id=&quot;别和自己较劲&quot;&gt;别和自己较劲&lt;/h2&gt;
&lt;p&gt;这一点和别钻牛角尖类似，在这里单独拿出来，是为了再次强调。很多人遇到问题总是想自己去解决，总是认为参考别人的思路或者代码就显得自己很low，非要和自己较劲。其实才是这是一种非常low的想法，编程本身是一个思想活动，而思想最重要的还是交流，思想交流的价值不言而喻。因此，如果有自己确实解决不了的问题，应该及时向搜索引擎或者懂的人请教，这没什么，重要的是解决问题和学习新的思路与方法。&lt;/p&gt;
&lt;h2 id=&quot;多读多写代码&quot;&gt;多读多写代码&lt;/h2&gt;
&lt;p&gt;编程和写作有很多类似的地方，都是一个将思维反映在“纸面”上的活动，不过写作是一个比较“模糊”的映射，而编程需要一个精确的“映射”。成为一个优秀的作家，巨大的阅读量是一个先决条件；同时，只看不写也永远成不了作家。编程也是同理，要多看别人写的“文章”，同时也要自己不断练习，只有这样，才有机会成为dalao。&lt;/p&gt;
&lt;h2 id=&quot;善于总结多思考和反思&quot;&gt;善于总结、多思考和反思&lt;/h2&gt;
&lt;p&gt;“吾日三省吾身”，总结自己的得失，思考和反思自己的优劣，并合理地调整自身，才可以取得长足地进步。作为IT人，博客可能是一个最好的方式了，技术人要有自己的博客，至少是作为自己的笔记。&lt;/p&gt;
&lt;h2 id=&quot;有自己的判断力&quot;&gt;有自己的判断力&lt;/h2&gt;
&lt;p&gt;这和我自己踩的坑有关，我在这里不想指责谁，也不想埋怨有些事情，只能说当初选择“Leader”和“Team”的时候，确实是经验不足，不过这正好是一个很宝贵的经历，至少让我有了比其他同学更多的阅历！“悟已往之不谏，知来者之可追”，这些都过去了，重要的现在和未来。在这里，我只想说一句：&lt;strong&gt;选对方向、做对事、跟对人&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;还有其他的留作后续补充&quot;&gt;还有其他的，留作后续补充&lt;/h2&gt;
&lt;p&gt;其他的还有很多，时间原因，后续再更新吧。&lt;/p&gt;
</description>
<pubDate>Thu, 08 Nov 2018 13:54:00 +0000</pubDate>
<dc:creator>Erick_Lv</dc:creator>
<og:description>写在前面 第一次这么详细地写个人经历，算是对自己大学几年学习编程的总结吧。我不是什么计算机大佬，也没有所谓的计算机天赋，这一路走来磕磕绊绊的，踩过许多坑，走了很多弯路，最后也是靠着一些运气，以一个应届</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Erick-Lv/p/9932307.html</dc:identifier>
</item>
</channel>
</rss>