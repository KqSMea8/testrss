<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>网络库压力测试：mongols VS evpp - hi-nginx</title>
<link>http://www.cnblogs.com/hi-nginx/p/9527696.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hi-nginx/p/9527696.html</guid>
<description>&lt;p&gt;evpp是360出品的一个网络库，基于libevent，进行了许多改造，对c++11友好。据称比libevent性能要好。&lt;/p&gt;
&lt;p&gt;到底有多好呢？360开发人员有自己的测试，信不信由你。&lt;/p&gt;
&lt;p&gt;evpp源码下有个httpecho演示，我把它改为hello,world的样子:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void DefaultHandler(evpp::EventLoop* loop,
                    const evpp::http::ContextPtr&amp;amp; ctx,
                    const evpp::http::HTTPSendResponseCallback&amp;amp; cb) {
    std::stringstream oss;
    /*oss &amp;lt;&amp;lt; &quot;func=&quot; &amp;lt;&amp;lt; __FUNCTION__ &amp;lt;&amp;lt; &quot; OK&quot;
        &amp;lt;&amp;lt; &quot; ip=&quot; &amp;lt;&amp;lt; ctx-&amp;gt;remote_ip() &amp;lt;&amp;lt; &quot;\n&quot;
        &amp;lt;&amp;lt; &quot; uri=&quot; &amp;lt;&amp;lt; ctx-&amp;gt;uri() &amp;lt;&amp;lt; &quot;\n&quot;
        &amp;lt;&amp;lt; &quot; body=&quot; &amp;lt;&amp;lt; ctx-&amp;gt;body().ToString() &amp;lt;&amp;lt; &quot;\n&quot;;*/
        oss &amp;lt;&amp;lt;&quot;hello,world&quot;;
    //ctx-&amp;gt;AddResponseHeader(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;);
        ctx-&amp;gt;AddResponseHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);
    ctx-&amp;gt;AddResponseHeader(&quot;Server&quot;, &quot;evpp&quot;);
    cb(oss.str());
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后设置线程数为4，匹配我的笔记本。&lt;/p&gt;
&lt;p&gt;build，运行下，端口在29099。&lt;/p&gt;
&lt;p&gt;进而进行ab压力测试：&lt;/p&gt;
&lt;p&gt;分别是:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ab -kc100 -n100000 http://127.0.0.1:29099/&lt;/li&gt;
&lt;li&gt;ab -kc500 -n100000 http://127.0.0.1:29099/&lt;/li&gt;
&lt;li&gt;ab -kc800 -n100000 http://127.0.0.1:29099/&lt;/li&gt;
&lt;li&gt;ab -kc1000 -n100000 http://127.0.0.1:29099/&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;前三个跑的比较好，最后一个基本跑不动，报&lt;/p&gt;
&lt;p&gt;[warn] Error from accept() call: Too many open files&lt;/p&gt;
&lt;p&gt;前三个的RPS保持在&lt;strong&gt;[29000,36000)&lt;/strong&gt;区间，确实比libevent要好些。但绝对没有360开发人员宣传的那么好：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1358070/201808/1358070-20180824065201741-87986679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该图显示evpp对多个网络库进行了对比。对此，我只能说，其他库本就没有那么好。&lt;/p&gt;
&lt;p&gt;同样的输出，同样的线程数，&lt;a title=&quot;https://github.com/webcpp/mongols&quot; href=&quot;https://github.com/webcpp/mongols&quot; target=&quot;_blank&quot;&gt;mongols&lt;/a&gt;的测试数据都要优于evpp，RPS在&lt;strong&gt;[38000,42000）区&lt;/strong&gt;间。如果使用单线程，mongols的RPS基本&lt;strong&gt;42000+&lt;/strong&gt;。而且，mongols的内存占用仅仅为evpp的&lt;strong&gt;1/4&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一句话，不要迷信大厂！如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1358070/201808/1358070-20180824072152188-894146992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1358070/201808/1358070-20180824072204560-944528280.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;重要的事情应该再说一遍：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;不要迷信大厂&lt;/strong&gt;&lt;/span&gt;！&lt;/p&gt;

</description>
<pubDate>Thu, 23 Aug 2018 23:25:00 +0000</pubDate>
<dc:creator>hi-nginx</dc:creator>
<og:description>evpp是360出品的一个网络库，基于libevent，进行了许多改造，对c++11友好。据称比libevent性能要好。到底有多好呢？360开发人员有自己的测试，信不信由你。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hi-nginx/p/9527696.html</dc:identifier>
</item>
<item>
<title>中小团队落地配置中心详解 - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/9527661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/9527661.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;不知道配置文件上次什么时候修改的、修改了什么内容？改了配置文件还要重新发布项目或者手动触发重启服务？无缘无故发现配置文件错了影响到线上正常部署？你是否正在因为这些问题而困扰？50+线上项目，数百+配置文件，我们经常被这些配置文件虐的生无可恋，是时候作出改变了！本文将带你解决这些问题，喝着咖啡轻松运维&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;选型的原则：简单，易落地，不挑平台，不挑语言，尽量少的依赖。&lt;/p&gt;
&lt;p&gt;对比了Disconf、Apollo等方案，最终选择了Etcd+Confd的方案，基本符合上边的原则，且Etcd我们在部署Kubernetes的时候已经有过使用，算是轻车熟路。&lt;/p&gt;
&lt;h2 id=&quot;配置中心架构图&quot;&gt;配置中心架构图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/23/165665116f251abf?w=657&amp;amp;h=285&amp;amp;f=png&amp;amp;s=13455&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置中心整体采用C/S的模式，用Etcd作为服务端来存储数据，Confd作为客户端去Etcd取数据更新&lt;/li&gt;
&lt;li&gt;为了更方便的管理写了WebUI，实际上是一个Etcd服务的WebUI，主要与Etcd服务交互，去Etcd存取数据&lt;/li&gt;
&lt;li&gt;Confd根据配置文件去Etcd集群拉取数据，然后根据模板文件将数据按照设定的格式填充的固定的位置生成最终的配置文件&lt;/li&gt;
&lt;li&gt;配置文件生成后还可以配合&lt;code&gt;check_cmd&lt;/code&gt;和&lt;code&gt;reload_cmd&lt;/code&gt;命令对配置文件进行检查和重新加载&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;etcd集群&quot;&gt;Etcd集群&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;系统环境
&lt;ul&gt;&lt;li&gt;System：Debian 8&lt;/li&gt;
&lt;li&gt;Etcd：v3.3.9&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;服务器地址
&lt;ul&gt;&lt;li&gt;192.168.107.101&lt;/li&gt;
&lt;li&gt;192.168.107.102&lt;/li&gt;
&lt;li&gt;192.168.107.103&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;所有服务器都需要执行以下命令来安装etcd和创建目录&quot;&gt;所有服务器都需要执行以下命令来安装etcd和创建目录&lt;/h5&gt;
&lt;p&gt;1.下载etcd安装包并解压&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# wget https://github.com/coreos/etcd/releases/download/v3.3.9/etcd-v3.3.9-linux-amd64.tar.gz
# tar -zxvf etcd-v3.3.9-linux-amd64.tar.gz &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.拷贝程序到/usr/bin目录下方便执行，etcd为go编写，直接可运行，主要有两个文件etcd和ectdctl，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# mv etcd-v3.3.9-linux-amd64/etcd* /usr/bin/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.创建etcd配置文件目录&lt;code&gt;/etc/etcd&lt;/code&gt;和数据存放目录&lt;code&gt;/home/data/etcd&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# mkdir /etc/etcd /home/data/etcd&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;三个node节点etcd配置文件分别如下&quot;&gt;三个node节点etcd配置文件分别如下&lt;/h5&gt;
&lt;p&gt;node1配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cat /etc/etcd/etcd.conf 
name: 'node1'
data-dir: /home/data/etcd

listen-peer-urls: http://192.168.107.101:2380
listen-client-urls: http://192.168.107.101:2379,http://127.0.0.1:2379

initial-cluster-state: 'new'
initial-cluster-token: 'etcd-cluster-conf'
advertise-client-urls: http://192.168.107.101:2379
initial-advertise-peer-urls: http://192.168.107.101:2380
initial-cluster: node1=http://192.168.107.101:2380,node2=http://192.168.107.102:2380,node3=http://192.168.107.103:2380
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;node2配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cat /etc/etcd/etcd.conf 
name: 'node2'
data-dir: /home/data/etcd

listen-peer-urls: http://192.168.107.102:2380
listen-client-urls: http://192.168.107.102:2379,http://127.0.0.1:2379

initial-cluster-state: 'new'
initial-cluster-token: 'etcd-cluster-conf'
advertise-client-urls: http://192.168.107.102:2379
initial-advertise-peer-urls: http://192.168.107.102:2380
initial-cluster: node1=http://192.168.107.101:2380,node2=http://192.168.107.102:2380,node3=http://192.168.107.103:2380
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;node3配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cat /etc/etcd/etcd.conf 
name: 'node3'
data-dir: /home/data/etcd

listen-peer-urls: http://192.168.107.103:2380
listen-client-urls: http://192.168.107.103:2379,http://127.0.0.1:2379

initial-cluster-state: 'new'
initial-cluster-token: 'etcd-cluster-conf'
advertise-client-urls: http://192.168.107.103:2379
initial-advertise-peer-urls: http://192.168.107.103:2380
initial-cluster: node1=http://192.168.107.101:2380,node2=http://192.168.107.102:2380,node3=http://192.168.107.103:2380&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;每个节点配置完成后均启动&quot;&gt;每个节点配置完成后均启动&lt;/h5&gt;
&lt;p&gt;需要放在后台运行，推荐使用&lt;code&gt;screen&lt;/code&gt;工具&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# /usr/bin/etcd --config-file /etc/etcd/etcd.conf &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三个节点全部启动完成后，可通过&lt;code&gt;etcdctl member list&lt;/code&gt;命令查看集群列表，确认集群状态&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# etcdctl member list
732ca490026f580d: name=node3 peerURLs=http://192.168.107.103:2380 clientURLs=http://192.168.107.103:2379 isLeader=false
bc16d35c3ad1c5ee: name=node2 peerURLs=http://192.168.107.102:2380 clientURLs=http://192.168.107.102:2379 isLeader=true
f7a043d3b65cd4a4: name=node1 peerURLs=http://192.168.107.101:2380 clientURLs=http://192.168.107.101:2379 isLeader=false&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;confd&quot;&gt;Confd&lt;/h2&gt;
&lt;p&gt;1.下载confd并放到&lt;code&gt;/usr/bin/&lt;/code&gt;目录下方便使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# wget https://github.com/kelseyhightower/confd/releases/download/v0.16.0/confd-0.16.0-linux-amd64
# mv confd-0.16.0-linux-amd64 /usr/bin/confd
# chmod +x /usr/bin/confd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.新建confd配置文件目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# mkdir /etc/confd/{conf.d,templates}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.新建资源文件，&lt;code&gt;.toml&lt;/code&gt;文件结尾已经成了固定格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cat /etc/confd/conf.d/nginx.conf.toml 
[template]
src = &quot;nginx.conf.tmpl&quot;
dest = &quot;/tmp/nginx.conf&quot;

keys = [
   &quot;/conf/project/env/nginx/nginx.conf&quot;,
]

check_cmd = &quot;/usr/sbin/nginx -t -c {{.src}}&quot;
reload_cmd = &quot;/usr/sbin/service nginx reload&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们新建了一个nginx配置的资源文件，参数解释：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;&lt;strong&gt;src&lt;/strong&gt;：指定模板文件的位置，也就是nginx配置文件模板tmpl的位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dest&lt;/strong&gt;：指定最终生成或更新的配置文件绝对路径，这里为了测试我们给指定到/tmp/下&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;keys&lt;/strong&gt;：模板文件里边要用到的key，也就是etcd里边对应的这个项目配置文件的key&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;check_cmd&lt;/strong&gt;：在更新配置文件完成后执行的check命令，这里我们就check下nginx配置文件是否有语法错误&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;reload_cmd&lt;/strong&gt;：在check通过后可以执行这里配置的命令，上一步的check没有问题，就会执行reload命令重新加载配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;prefix&lt;/strong&gt;：配置key的前缀，例如我们的key都是以/conf开头的，那么可以增加个配置&lt;code&gt;prefix=&quot;/conf&quot;&lt;/code&gt;，在下边keys里就可以省略掉/conf了&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;owner&lt;/strong&gt;：配置生成配置文件的用户&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;mode&lt;/strong&gt;：配置生成配置文件的权限&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4.新建模板文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cat /etc/confd/templates/nginx.conf.tmpl 
{{getv &quot;/conf/project/env/nginx/nginx.conf&quot;}}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;confd的模板语法有很多，这里不赘述，具体可查官网&lt;/li&gt;
&lt;li&gt;我们是把整个配置文件的内容作为一个value存在etcd里边的，所以这里只需要一个getv指令获取到value的值填充到目标文件就可以了&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;联调测试&quot;&gt;联调测试&lt;/h2&gt;
&lt;p&gt;部署好了etcd集群和confd服务，接下来我们就要测试下他们是否能够正常协同工作了&lt;/p&gt;
&lt;p&gt;1.在Etcd服务器新建一个KV值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# etcdctl set /conf/project/env/nginx/nginx.conf 'user  www-data;
&amp;gt; worker_processes 4;
&amp;gt; 
&amp;gt; pid        /var/run/nginx.pid;
&amp;gt; error_log  /home/logs/nginx/error.log  warn;
&amp;gt; 
&amp;gt; events  {
&amp;gt;     use epoll;
&amp;gt;     worker_connections 51200;
&amp;gt; }
&amp;gt; 
&amp;gt; http {
&amp;gt;     default_type  application/octet-stream;
&amp;gt; 
&amp;gt;     server {
&amp;gt;         listen       80;
&amp;gt;         server_name  domain.com;
&amp;gt; 
&amp;gt;         root /home/project/webroot;
&amp;gt;         index index.shtml index.html;
&amp;gt;     }
&amp;gt; }'&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;# 查看设置key的内容
# etcdctl get /conf/project/env/nginx/nginx.conf
user  www-data;
worker_processes 4;

pid        /var/run/nginx.pid;
error_log  /home/logs/nginx/error.log  warn;

events  {
    use epoll;
    worker_connections 51200;
}

http {
    default_type  application/octet-stream;

    server {
        listen       80;
        server_name  domain.com;

        root /home/project/webroot;
        index index.shtml index.html;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Etcd API分v2和v3版本，两个版本差别较大，v3优化了很多，但考虑兼容性等问题我们这里使用v2版本&lt;/li&gt;
&lt;li&gt;默认为v2版本，可以通过环境变量&lt;code&gt;export ETCDCTL_API=3&lt;/code&gt;来切换到v3版本，v2通过&lt;code&gt;etcdctl -v&lt;/code&gt;可以查看api版本，v3通过&lt;code&gt;etcdctl version&lt;/code&gt;查看api版本&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.启动confd&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# confd -watch -backend etcd -node=http://192.168.107.101:2379 -node=http://192.168.107.102:2379 -node=http://192.168.107.103:2379
2018-08-23T13:46:13+08:00 onlinegame.i.nease.net confd[17084]: INFO Backend set to etcd
2018-08-23T13:46:13+08:00 onlinegame.i.nease.net confd[17084]: INFO Starting confd
2018-08-23T13:46:13+08:00 onlinegame.i.nease.net confd[17084]: INFO Backend source(s) set to http://192.168.107.101:2379, http://192.168.107.102:2379, http://192.168.107.103:2379
2018-08-23T13:46:13+08:00 onlinegame.i.nease.net confd[17084]: INFO Target config /tmp/nginx.conf out of sync
2018-08-23T13:46:13+08:00 onlinegame.i.nease.net confd[17084]: INFO Target config /tmp/nginx.conf has been updated&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置参数说明&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;&lt;strong&gt;-watch&lt;/strong&gt;：开启watch模式，监听etcd配置中心文件变化，一旦有变这边立即更新，没有这个选项配置中心修改client不会更新&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-backend&lt;/strong&gt;：后端类型，目前支持etcd、zookeeper、consul、vault、redis、file、rancher等多种类型，confd也有一些针对不通后端类型的单独配置，具体可以通过&lt;code&gt;confd --help&lt;/code&gt;命令查看&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;-node&lt;/strong&gt;：etcd节点地址，有多个节点的话就这么写多个-node就好了，我们etcd是三个节点的集群所以这里写三次'-node'&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-onetime&lt;/strong&gt;：可用来替换上边的&lt;code&gt;-watch&lt;/code&gt;参数，表示运行一次就退出，如果你不想让配置文件实时更新，只是想更新一次，可以用这个参数&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;-interval&lt;/strong&gt;：可用来替换上边的&lt;code&gt;-watch&lt;/code&gt;参数，表示每隔多少秒去backend取一次数据，如果想降低etcd服务器压力，又想让客户端配置文件能自动更新，可以通过这个参数来控制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3.通过上边日志可以看到/tmp/nginx.conf文件已经正常同步且更新了，查看/tmp/nginx.conf确定内容正确&lt;/p&gt;

&lt;p&gt;总不能所有的配置文件更新都通过命令行的方式吧？为了方便管理，花了三天（真的是三天）写了个WebUI，命名为Kerrigan，能够实现目录树，在线查看配置、修改配置、查看配置更新历史等实用功能&lt;/p&gt;
&lt;p&gt;配置页面，通过这个页面可以配置etcd的连接信息&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/23/165665116e1da76b?w=1195&amp;amp;h=414&amp;amp;f=png&amp;amp;s=15368&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首页，左侧项目列表（项目信息同步CMDB）&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/23/165665116ecd8359?w=1195&amp;amp;h=399&amp;amp;f=png&amp;amp;s=14710&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击项目列表后，根据对应规则去etcd里边取出目录结构按树状呈现出来&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/23/16566511701d7348?w=1195&amp;amp;h=464&amp;amp;f=png&amp;amp;s=28258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击配置文件，右侧会展示当前配置文件内容&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/23/165665116df1677d?w=1195&amp;amp;h=575&amp;amp;f=png&amp;amp;s=38239&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击“编辑”按钮可以编辑这个配置，新建页面一样，只是编辑不允许修改路径&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/23/16566511a31b488c?w=1195&amp;amp;h=866&amp;amp;f=png&amp;amp;s=47861&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击“历史”按钮，则跳转到配置文件的历史页面，这个页面展示了这个配置文件所有的修改历史&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/23/16566511aa19e02d?w=1194&amp;amp;h=600&amp;amp;f=png&amp;amp;s=36506&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;是不是要说这个界面丑爆了！没办法，前端后端测试加上线都我一人干，没有设计细胞，就这么看吧，并且最重要的不是功能好用么&lt;/li&gt;
&lt;li&gt;为什么不用K8S的configmap？我们最初是想用K8S的configmap来做配置中心的，但是并非所有的项目都跑在K8S里，且修改configmap也需要重启容器才能生效，所以就没有采用了&lt;/li&gt;
&lt;li&gt;etcd谁都可以修改么，感觉不安全啊？实际上我们是用了账号密码认证的，且只在内网，限制IP，安全一点吧，另一种解决方案是etcd走ssl，但client端要放证书比较麻烦没有采用&lt;/li&gt;
&lt;li&gt;怎么确认Client端配置文件更新成功了？如果你是一次性启动可以在启动命令之后判断启动命令是否正常执行，如果你是watch模式或者interval，那么。。只能人肉check了吧，我也没有好方法&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/6/1650dfc4a28a8e56?w=430&amp;amp;h=476&amp;amp;f=jpeg&amp;amp;s=68454&quot; alt=&quot;扫码关注公众号查看更多原创文章&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得文章对你有帮助，请转发分享让更多好友看到。如果你觉得读的不尽兴，推荐阅读以下文章：&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 22:10:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>不知道配置文件上次什么时候修改的、修改了什么内容？改了配置文件还要重新发布项目或者手动触发重启服务？无缘无故发现配置文件错了影响到线上正常部署？你是否正在因为这些问题而困扰？50+线上项目，数百+配置</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/37Y37/p/9527661.html</dc:identifier>
</item>
<item>
<title>10.0 花里胡哨的各个方位滑动查找元素 - 佬贰</title>
<link>http://www.cnblogs.com/pythontest/p/9527549.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythontest/p/9527549.html</guid>
<description>&lt;p&gt;&lt;span&gt;在介绍滑动查找元素之前，请先容许我插上一嘴&lt;/span&gt;--&lt;span&gt;之前章节有更新过  &lt;/span&gt;&lt;span&gt;Uiobject uicollection uiselector   &lt;/span&gt;&lt;span&gt;这里还有一个新东西叫做  &lt;/span&gt;&lt;span&gt;uiscrollable&lt;/span&gt;&lt;span&gt;这个&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;它里面是封装了所有的滑动处理的相关操作！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;name&lt;span&gt;这个叫做&lt;/span&gt;&lt;span&gt;uiscrollable&lt;/span&gt;&lt;span&gt;的类里面有那些东西了：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;  Scrollintoview-----&lt;span&gt;获取某个可滑动区域，然后滑动这个区域里面的元素查找我们所需要的元素&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#后面的text查找条件可以用组合查找也可以用 textcontains 关键之查找text，一般查找条件使用text.....因为一般可滑动的区域id和class都是一样的...&lt;br/&gt;driver.find_element_by_android_uiautomator\
    (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new UiScrollable(new UiSelector().resourceId(&quot;被滑动区域最后一层的id&quot;)).scrollIntoView(new UiSelector().text(&quot;我们需要查找的元素text&quot;))&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180824011131281-403426411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;代码：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; appium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.ui &lt;span&gt;import&lt;/span&gt;&lt;span&gt; WebDriverWait
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span&gt;import&lt;/span&gt;&lt;span&gt; expected_conditions as EC
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; appium.webdriver.common.touch_action &lt;span&gt;import&lt;/span&gt; TouchAction &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入Touch Action类&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time,re,os
Start&lt;/span&gt;=&lt;span&gt;{}
Start[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;platformName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;android&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设备型号  android或者ios&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;platformVersion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;安卓设备版本号&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;deviceName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.176.101:5555&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;安卓设备名称&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\xuexi\apk\anzhuoshichang_16793302.apk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设备路径  pc电脑存放apk包的路径&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;上面的路径不推荐这种写法，但是目前先这么写！后续告诉大家正确的写法&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;appPackage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;包名&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;appActivity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.baidu.appsearch.LauncherActivity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;容器&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;noReset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是否重新安装app  True不重新安装&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;unicodeKeyboard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是否禁用手机键盘  True禁用手机输入法&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;resetKeyboard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是否启动appium自带键盘 True开始手机输入法&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;automationName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uiautomator2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;可选模式  本教程默认 Uiautomator2&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;newCommandTimeout&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;400&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;超时时间（s）&lt;/span&gt;
driver = webdriver.Remote(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://127.0.0.1:4723/wd/hub&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,Start)
driver.implicitly_wait(&lt;/span&gt;10)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;隐式等待十秒&lt;/span&gt;
time.sleep(3&lt;span&gt;)
driver.find_elements_by_id(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho:id/title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0].click()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;点击首页 必备&lt;/span&gt;
WebDriverWait(driver,30,0.1).until(&lt;span&gt;lambda&lt;/span&gt; driver:driver.find_element_by_id(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho:id/libui_title_back_btn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
driver.find_element_by_android_uiautomator(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new UiScrollable(new UiSelector().resourceId(&quot;com.hiapk.marketpho:id/listview&quot;)).scrollIntoView(new UiSelector().textContains(&quot;滴滴车主&quot;))&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).click()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;如果跟着操作了&lt;/span&gt;--&lt;span&gt;是不是感觉上面说的那个【被滑动区域】很难找&lt;/span&gt;&lt;span&gt;....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;So..&lt;span&gt;从最上级开始看&lt;/span&gt;&lt;span&gt;----&lt;/span&gt;&lt;span&gt;有下级内容的就点一下 ，看下元素的&lt;/span&gt;&lt;span&gt;scroll&lt;/span&gt;&lt;span&gt;属性是不是为&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180824011328187-1226393117.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;如下图所示：这个看上去是不是好像是我们想要的区域&lt;/span&gt;---&lt;span&gt;但是仔细一看&lt;/span&gt;&lt;span&gt;---scroll&lt;/span&gt; &lt;span&gt;是&lt;/span&gt;&lt;span&gt;false--&lt;/span&gt;&lt;span&gt;所以这个也不是，&lt;/span&gt;&lt;span&gt;那么&lt;/span&gt;&lt;span&gt;继续往下找&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180824011546191-1304794671.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;再继续往下找，结果发现下一个属性就是为&lt;/span&gt;true&lt;span&gt;的&lt;/span&gt;&lt;span&gt;--那么&lt;/span&gt;&lt;span&gt;这个就是我们的想要的&lt;/span&gt;&lt;span&gt;....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180824011643117-1006242648.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;备注：&lt;span&gt;这种是官方给出的滑动查找元素的&lt;/span&gt;api....&lt;span&gt;我记得貌似&lt;/span&gt;&lt;span&gt;Uiscrollable&lt;/span&gt;&lt;span&gt;这个&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;里面还有很多花里胡哨的滑动的方法&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;我之前有试过&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;结果发现除了 这个&lt;/span&gt; &lt;span&gt;scrollIntoview&lt;/span&gt;&lt;span&gt;之外，其他的基本报错&lt;/span&gt;&lt;span&gt;..&lt;/span&gt;&lt;span&gt;因为其他的&lt;/span&gt;&lt;span&gt;api&lt;/span&gt;&lt;span&gt;包括这个&lt;/span&gt; &lt;span&gt;scrollIntoview  &lt;/span&gt;&lt;span&gt;我全部都没有用到&lt;/span&gt;&lt;span&gt;..&lt;/span&gt;&lt;span&gt;所以没有去研究&lt;/span&gt;&lt;span&gt;..&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;那么问题来了，我这边滑动查找元素是用的什么方法呢&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;...&lt;/p&gt;



&lt;p&gt;&lt;span&gt;记得上一章有介绍过&lt;/span&gt; TouchAction&lt;span&gt;这个很牛皮的方法是吧&lt;/span&gt;&lt;span&gt;....&lt;/span&gt;&lt;span&gt;我这边用的各个方位查找元素都是用的这个&lt;/span&gt;&lt;span&gt;..&lt;/span&gt;&lt;span&gt;并且对比了一下&lt;/span&gt;&lt;span&gt;api&lt;/span&gt; &lt;span&gt;貌似他的也是调用的&lt;/span&gt;&lt;span&gt;TouchAction&lt;/span&gt;&lt;span&gt;这个方法实现的&lt;/span&gt;&lt;span&gt;..&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;So..&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180824011841453-1474345142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;支持各个方位滑动查找元素&lt;/span&gt;..&lt;span&gt;唯一的缺点就是貌似稍微慢了那么一丢丢，只是一丢丢，实际上和&lt;/span&gt;&lt;span&gt;scrollIntoview&lt;/span&gt; &lt;span&gt;查找速度差不多，，建议把&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt;&lt;span&gt;的时间稍微调的长一点&lt;/span&gt;&lt;span&gt;..&lt;/span&gt;&lt;span&gt;时间越短越容易报错&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;代码：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; appium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.ui &lt;span&gt;import&lt;/span&gt;&lt;span&gt; WebDriverWait
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span&gt;import&lt;/span&gt;&lt;span&gt; expected_conditions as EC
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; appium.webdriver.common.touch_action &lt;span&gt;import&lt;/span&gt; TouchAction &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入Touch Action类&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time,re,os
Start&lt;/span&gt;=&lt;span&gt;{}
Start[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;platformName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;android&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设备型号  android或者ios&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;platformVersion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;安卓设备版本号&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;deviceName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.176.101:5555&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;安卓设备名称&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\xuexi\apk\anzhuoshichang_16793302.apk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设备路径  pc电脑存放apk包的路径&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;上面的路径不推荐这种写法，但是目前先这么写！后续告诉大家正确的写法&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;appPackage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;包名&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;appActivity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.baidu.appsearch.LauncherActivity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;容器&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;noReset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是否重新安装app  True不重新安装&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;unicodeKeyboard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是否禁用手机键盘  True禁用手机输入法&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;resetKeyboard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是否启动appium自带键盘 True开始手机输入法&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;automationName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uiautomator2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;可选模式  本教程默认 Uiautomator2&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;newCommandTimeout&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;400&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;超时时间（s）&lt;/span&gt;
driver = webdriver.Remote(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://127.0.0.1:4723/wd/hub&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,Start)
driver.implicitly_wait(&lt;/span&gt;10)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;隐式等待十秒&lt;/span&gt;
time.sleep(3&lt;span&gt;)
driver.find_elements_by_id(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho:id/title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0].click()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;点击首页 必备&lt;/span&gt;
WebDriverWait(driver,30,0.1).until(&lt;span&gt;lambda&lt;/span&gt; driver:driver.find_element_by_id(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho:id/libui_title_back_btn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; driver.find_element_by_android_uiautomator('new UiScrollable(new UiSelector().resourceId(&quot;com.hiapk.marketpho:id/listview&quot;)).scrollIntoView(new UiSelector().textContains(&quot;滴滴车主&quot;))').click()&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; scroll_my(x1, y1, x2, y2, element, type, timeOut):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;无限各方为滑动加载获取指定元素&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    timeStart &lt;/span&gt;= time.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%d%H%M%S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, time.localtime())
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; type == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                driver.find_element_by_id(element)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; type == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                driver.find_element_by_xpath(element)  #另外这里还可以写其他的元素定位方式在这里--建议把每个定位方式独立的封装成一个方法..&lt;br/&gt;用到定位方式就调用哪个方法---因为判断多了，代码执行就会耗时那么一丢丢..
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
            action &lt;/span&gt;=&lt;span&gt; TouchAction(driver)
            action.press(x&lt;/span&gt;=x1, y=y1).wait(ms=500).move_to(x=x2, y=&lt;span&gt;y2).release()
            action.perform()
            timeOver &lt;/span&gt;= time.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%d%H%M%S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, time.localtime())
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; int(timeOver) - int(timeStart) &amp;gt;=&lt;span&gt; int(timeOut):
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; type == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; driver.find_element_by_id(element)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; type == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; driver.find_element_by_xpath(element)
scroll_my(&lt;/span&gt;0.5,0.9,0.5,0.4,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@text=&quot;滴滴车主&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,300).click()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么问题来了 ，TouchAction  还有没有其他的骚操作呢？&lt;/p&gt;

</description>
<pubDate>Thu, 23 Aug 2018 17:24:00 +0000</pubDate>
<dc:creator>佬贰</dc:creator>
<og:description>在介绍滑动查找元素之前，请先容许我插上一嘴--之前章节有更新过 Uiobject uicollection uiselector 这里还有一个新东西叫做 uiscrollable这个class它里面是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pythontest/p/9527549.html</dc:identifier>
</item>
<item>
<title>koa源码阅读[3]-koa-send与它的衍生(static) - 贾顺名</title>
<link>http://www.cnblogs.com/jiasm/p/9527536.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiasm/p/9527536.html</guid>
<description>&lt;p&gt;&lt;code&gt;koa&lt;/code&gt;源码阅读的第四篇，涉及到向接口请求方提供文件数据。&lt;/p&gt;
&lt;blockquote readability=&quot;1.9322033898305&quot;&gt;
&lt;p&gt;第一篇：&lt;a href=&quot;https://www.cnblogs.com/jiasm/p/9351234.html&quot;&gt;koa源码阅读-0&lt;/a&gt;&lt;br/&gt;第二篇：&lt;a href=&quot;https://www.cnblogs.com/jiasm/p/9388966.html&quot;&gt;koa源码阅读-1-koa与koa-compose&lt;/a&gt;&lt;br/&gt;第三篇：&lt;a href=&quot;https://www.cnblogs.com/jiasm/p/9449405.html&quot;&gt;koa源码阅读-2-koa-router&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;处理静态文件是一个繁琐的事情，因为静态文件都是来自于服务器上，肯定不能放开所有权限让接口来读取。&lt;br/&gt;各种路径的校验，权限的匹配，都是需要考虑到的地方。&lt;br/&gt;而&lt;code&gt;koa-send&lt;/code&gt;和&lt;code&gt;koa-static&lt;/code&gt;就是帮助我们处理这些繁琐事情的中间件。&lt;br/&gt;&lt;code&gt;koa-send&lt;/code&gt;是&lt;code&gt;koa-static&lt;/code&gt;的基础，可以在&lt;code&gt;NPM&lt;/code&gt;的界面上看到，&lt;code&gt;static&lt;/code&gt;的&lt;code&gt;dependencies&lt;/code&gt;中包含了&lt;code&gt;koa-send&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.jiasm.org/images/koajs-code-review/koa-static-dependencies.png&quot; alt=&quot;&quot; width=&quot;656&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;koa-send&lt;/code&gt;主要是用于更方便的处理静态文件，与&lt;code&gt;koa-router&lt;/code&gt;之类的中间件不同的是，它并不是直接作为一个函数注入到&lt;code&gt;app.use&lt;/code&gt;中的。&lt;br/&gt;而是在某些中间件中进行调用，传入当前请求的&lt;code&gt;Context&lt;/code&gt;及文件对应的位置，然后实现功能。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/koajs/send&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;koa-send的GitHub地址&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;原生的文件读取、传输方式&quot;&gt;原生的文件读取、传输方式&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;Node&lt;/code&gt;中，如果使用原生的&lt;code&gt;fs&lt;/code&gt;模块进行文件数据传输，大致是这样的操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
const fs      = require('fs'&lt;span&gt;)
const Koa     &lt;/span&gt;= require('koa'&lt;span&gt;)
const Router  &lt;/span&gt;= require('koa-router'&lt;span&gt;)

const app     &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Koa()
const router  &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Router()
const file    &lt;/span&gt;= './test.log'&lt;span&gt;
const port    &lt;/span&gt;= 12306&lt;span&gt;

router.get(&lt;/span&gt;'/log', ctx =&amp;gt;&lt;span&gt; {
  const data &lt;/span&gt;=&lt;span&gt; fs.readFileSync(file).toString()
  ctx.body &lt;/span&gt;=&lt;span&gt; data
})

app.use(router.routes())
app.listen(port, () &lt;/span&gt;=&amp;gt; console.log(`Server run as http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:${port}`))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;或者用&lt;code&gt;createReadStream&lt;/code&gt;代替&lt;code&gt;readFileSync&lt;/code&gt;也是可行的，区别会在下边提到&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个简单的示例仅针对一个文件进行操作，而如果我们要读取的文件是有很多个，甚至于可能是通过接口参数传递过来的。&lt;br/&gt;所以很难保证这个文件一定是真实存在的，而且我们可能还需要添加一些权限设置，防止一些敏感文件被接口返回。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
router.get('/file', ctx =&amp;gt;&lt;span&gt; {
  const { fileName } &lt;/span&gt;=&lt;span&gt; ctx.query
  const path &lt;/span&gt;= path.resolve('./XXX'&lt;span&gt;, fileName)
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤隐藏文件&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (path.startsWith('.'&lt;span&gt;)) {
    ctx.status &lt;/span&gt;= 404
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断文件是否存在&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;fs.existsSync(path)) {
    ctx.status &lt;/span&gt;= 404
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; balabala&lt;/span&gt;
&lt;span&gt;
  const rs &lt;/span&gt;=&lt;span&gt; fs.createReadStream(path)
  ctx.body &lt;/span&gt;= rs &lt;span&gt;//&lt;/span&gt;&lt;span&gt; koa做了针对stream类型的处理，详情可以看之前的koa篇&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;添加了各种逻辑判断以后，读取静态文件就变得安全不少，可是这也只是在一个&lt;code&gt;router&lt;/code&gt;中做的处理。&lt;br/&gt;如果有多个接口都会进行静态文件的读取，势必会存在大量的重复逻辑，所以将其提炼为一个公共函数将是一个很好的选择。&lt;/p&gt;
&lt;h2 id=&quot;koa-send的方式&quot;&gt;koa-send的方式&lt;/h2&gt;
&lt;p&gt;这就是&lt;code&gt;koa-send&lt;/code&gt;做的事情了，提供了一个封装非常完善的处理静态文件的中间件。&lt;br/&gt;这里是两个最基础的使用例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
const path = require('path'&lt;span&gt;)
const send &lt;/span&gt;= require('koa-send'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 针对某个路径下的文件获取&lt;/span&gt;
router.get('/file', async ctx =&amp;gt;&lt;span&gt; {
  await send(ctx, ctx.query.path, {
    root: path.resolve(__dirname, &lt;/span&gt;'./public'&lt;span&gt;)
  })
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 针对某个文件的获取&lt;/span&gt;
router.get('/index', async ctx =&amp;gt;&lt;span&gt; {
  await send(ctx, &lt;/span&gt;'./public/index.log'&lt;span&gt;)
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;假设我们的目录结构是这样的，&lt;code&gt;simple-send.js&lt;/code&gt;为执行文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.
├── public
│   ├── a.log
│   ├── b.log
│   └── index.log
└── simple&lt;/span&gt;-send.js
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用&lt;code&gt;/file?path=XXX&lt;/code&gt;就可以很轻易的访问到&lt;code&gt;public&lt;/code&gt;下的文件。&lt;br/&gt;以及访问&lt;code&gt;/index&lt;/code&gt;就可以拿到&lt;code&gt;/public/index.log&lt;/code&gt;文件的内容。&lt;/p&gt;
&lt;h2 id=&quot;koa-send提供的功能&quot;&gt;koa-send提供的功能&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;koa-send&lt;/code&gt;提供了很多便民的选项，除去常用的&lt;code&gt;root&lt;/code&gt;以外，还有大概小十个的选项可供使用：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;options&lt;/th&gt;
&lt;th&gt;type&lt;/th&gt;
&lt;th&gt;default&lt;/th&gt;
&lt;th&gt;desc&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;maxage&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置浏览器可以缓存的毫秒数&lt;br/&gt;对应的&lt;code&gt;Header&lt;/code&gt;: &lt;code&gt;Cache-Control: max-age=XXX&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;immutable&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;通知浏览器该URL对应的资源不可变，可以无限期的缓存&lt;br/&gt;对应的&lt;code&gt;Header&lt;/code&gt;: &lt;code&gt;Cache-Control: max-age=XXX, immutable&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;hidden&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否支持隐藏文件的读取&lt;br/&gt;&lt;code&gt;.&lt;/code&gt;开头的文件被称为隐藏文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;root&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;String&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;设置静态文件路径的根目录，任何该目录之外的文件都是禁止访问的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;index&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;String&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;设置一个默认的文件名，在访问目录的时候生效，会自动拼接到路径后边 &lt;strong&gt;(此处有一个小彩蛋)&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;gzip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果访问接口的客户端支持&lt;code&gt;gzip&lt;/code&gt;，并且存在&lt;code&gt;.gz&lt;/code&gt;后缀的同名文件的情况下会传递&lt;code&gt;.gz&lt;/code&gt;文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;brotli&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;逻辑同上，如果支持&lt;code&gt;brotli&lt;/code&gt;且存在&lt;code&gt;.br&lt;/code&gt;后缀的同名文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;format&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;开启以后不会强要求路径结尾的&lt;code&gt;/&lt;/code&gt;，&lt;code&gt;/path&lt;/code&gt;和&lt;code&gt;/path/&lt;/code&gt;表示的是一个路径 &lt;strong&gt;(仅在&lt;code&gt;path&lt;/code&gt;是一个目录的情况下生效)&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;extensions&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果传递了一个数组，会尝试将数组中的所有&lt;code&gt;item&lt;/code&gt;作为文件的后缀进行匹配，匹配到哪个就读取哪个文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;setHeaders&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;用来手动指定一些&lt;code&gt;Headers&lt;/code&gt;，意义不大&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;参数们的具体表现&quot;&gt;参数们的具体表现&lt;/h3&gt;
&lt;p&gt;有些参数的搭配可以实现一些神奇的效果，有一些参数会影响到&lt;code&gt;Header&lt;/code&gt;，也有一些参数是用来优化性能的，类似&lt;code&gt;gzip&lt;/code&gt;和&lt;code&gt;brotli&lt;/code&gt;的选项。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;koa-send&lt;/code&gt;的主要逻辑可以分为这几块：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;path&lt;/code&gt;路径有效性的检查&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gzip&lt;/code&gt;等压缩逻辑的应用&lt;/li&gt;
&lt;li&gt;文件后缀、默认入口文件的匹配&lt;/li&gt;
&lt;li&gt;读取文件数据&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在函数的开头部分有这样的逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const resolvePath = require('resolve-path'&lt;span&gt;)
const {
  parse
} &lt;/span&gt;= require('path'&lt;span&gt;)

async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; send (ctx, path. opts =&lt;span&gt; {}) {
  const trailingSlash &lt;/span&gt;= path[path.length - 1] === '/'&lt;span&gt;
  const index &lt;/span&gt;=&lt;span&gt; opts.index

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处省略各种参数的初始值设置&lt;/span&gt;
&lt;span&gt;
  path &lt;/span&gt;=&lt;span&gt; path.substr(parse(path).root.length)

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; normalize path&lt;/span&gt;
  path = decode(path) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内部调用的是`decodeURIComponent`&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也就是说传入一个转义的路径也是可以正常使用的&lt;/span&gt;

  &lt;span&gt;if&lt;/span&gt; (index &amp;amp;&amp;amp; trailingSlash) path +=&lt;span&gt; index

  path &lt;/span&gt;=&lt;span&gt; resolvePath(root, path)

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hidden file support, ignore&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (!hidden &amp;amp;&amp;amp; isHidden(root, path)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; isHidden (root, path) {
  path &lt;/span&gt;=&lt;span&gt; path.substr(root.length).split(sep)
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; path.length; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (path[i][0] === '.') &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;路径检查&quot;&gt;路径检查&lt;/h3&gt;
&lt;p&gt;首先是判断传入的&lt;code&gt;path&lt;/code&gt;是否为一个目录，&lt;em&gt;(结尾为&lt;code&gt;/&lt;/code&gt;会被认为是一个目录)&lt;/em&gt;。&lt;br/&gt;如果是目录，并且存在一个有效的&lt;code&gt;index&lt;/code&gt;参数，则会将&lt;code&gt;index&lt;/code&gt;拼接到&lt;code&gt;path&lt;/code&gt;后边。&lt;br/&gt;也就是大概这样的操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
send(ctx, './public/'&lt;span&gt;, {
  index: &lt;/span&gt;'index.js'&lt;span&gt;
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ./public/index.js&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/resolve-path&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;resolve-path&lt;/a&gt; 是一个用来处理路径的包，用来帮助过滤一些异常的路径，类似&lt;code&gt;path//file&lt;/code&gt;、&lt;code&gt;/etc/XXX&lt;/code&gt; 这样的恶意路径，并且会返回处理后绝对路径。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;isHidden&lt;/code&gt;用来判断是否需要过滤隐藏文件。&lt;br/&gt;因为但凡是&lt;code&gt;.&lt;/code&gt;开头的文件都会被认为隐藏文件，同理目录使用&lt;code&gt;.&lt;/code&gt;开头也会被认为是隐藏的，所以就有了&lt;code&gt;isHidden&lt;/code&gt;函数的实现。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;其实我个人觉得这个使用一个正则就可以解决的问题。。为什么还要分割为数组呢？&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; isHidden (root, path) {
  path &lt;/span&gt;=&lt;span&gt; path.substr(root.length)

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RegExp(`${sep}\\.`).test(path)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;已经给社区提交了&lt;code&gt;PR&lt;/code&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;压缩的开启与文件夹的处理&quot;&gt;压缩的开启与文件夹的处理&lt;/h3&gt;
&lt;p&gt;在上边的这一坨代码执行完以后，我们就得到了一个有效的路径，&lt;em&gt;(如果是无效路径，&lt;code&gt;resolvePath&lt;/code&gt;会直接抛出异常)&lt;/em&gt;&lt;br/&gt;接下来做的事情就是检查是否有可用的压缩文件使用，此处没有什么逻辑，就是简单的&lt;code&gt;exists&lt;/code&gt;操作，以及&lt;code&gt;Content-Encoding&lt;/code&gt;的修改 &lt;em&gt;(用于开启压缩)&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后缀的匹配：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (extensions &amp;amp;&amp;amp; !/\.[^/]*$/.exec(path)) {
  const list =&lt;span&gt; [].concat(extensions)
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; list.length; i++&lt;span&gt;) {
    let ext &lt;/span&gt;=&lt;span&gt; list[i]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; ext !== 'string'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TypeError('option extensions must be array of strings or false'&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!/^\./.exec(ext)) ext = '.' +&lt;span&gt; ext
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (await fs.exists(path +&lt;span&gt; ext)) {
      path &lt;/span&gt;= path +&lt;span&gt; ext
      &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到这里的遍历是完全按照我们调用&lt;code&gt;send&lt;/code&gt;是传入的顺序来走的，并且还做了&lt;code&gt;.&lt;/code&gt;符号的兼容。&lt;br/&gt;也就是说这样的调用都是有效的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
await send(ctx, 'path'&lt;span&gt;, {
  extensions: [&lt;/span&gt;'.js', 'ts', '.tsx'&lt;span&gt;]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果在添加了后缀以后能够匹配到真实的文件，那么就认为这是一个有效的路径，然后进行了&lt;code&gt;break&lt;/code&gt;的操作，也就是文档中所说的：&lt;code&gt;First found is served.&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在结束这部分操作以后会进行目录的检测，判断当前路径是否为一个目录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;let stats
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
  stats &lt;/span&gt;=&lt;span&gt; await fs.stat(path)

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stats.isDirectory()) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (format &amp;amp;&amp;amp;&lt;span&gt; index) {
      path &lt;/span&gt;+= '/' +&lt;span&gt; index
      stats &lt;/span&gt;=&lt;span&gt; await fs.stat(path)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }
  }
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (err) {
  const notfound &lt;/span&gt;= ['ENOENT', 'ENAMETOOLONG', 'ENOTDIR'&lt;span&gt;]
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (notfound.includes(err.code)) {
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; createError(404&lt;span&gt;, err)
  }
  err.status &lt;/span&gt;= 500
  &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;一个小彩蛋&quot;&gt;一个小彩蛋&lt;/h4&gt;
&lt;p&gt;可以发现一个很有意思的事情，如果发现当前路径是一个目录以后，并且明确指定了&lt;code&gt;format&lt;/code&gt;，那么还会再尝试拼接一次&lt;code&gt;index&lt;/code&gt;。&lt;br/&gt;这就是上边所说的那个彩蛋了，当我们的&lt;code&gt;public&lt;/code&gt;路径结构长得像这样的时候：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;└── public
    └── index
        └── index # 实际的文件 hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以通过一个简单的方式获取到最底层的文件数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
router.get('/surprises', async ctx =&amp;gt;&lt;span&gt; {
  await send(ctx, &lt;/span&gt;'/'&lt;span&gt;, {
    root: &lt;/span&gt;'./public'&lt;span&gt;,
    index: &lt;/span&gt;'index'&lt;span&gt;
  })
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; curl http://127.0.0.1:12306/surprises&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里就用到了上边的几个逻辑处理，首先是&lt;code&gt;trailingSlash&lt;/code&gt;的判断，如果以&lt;code&gt;/&lt;/code&gt;结尾会拼接&lt;code&gt;index&lt;/code&gt;，以及如果当前&lt;code&gt;path&lt;/code&gt;匹配为是一个目录以后，又会拼接一次&lt;code&gt;index&lt;/code&gt;。&lt;br/&gt;所以一个简单的&lt;code&gt;/&lt;/code&gt;加上&lt;code&gt;index&lt;/code&gt;的参数就可以直接获取到&lt;code&gt;/index/index&lt;/code&gt;。&lt;br/&gt;&lt;em&gt;一个小小的彩蛋，实际开发中应该很少会这么玩&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;最终的读取文件操作&quot;&gt;最终的读取文件操作&lt;/h3&gt;
&lt;p&gt;最后终于来到了文件读取的逻辑处理，首先就是调用&lt;code&gt;setHeaders&lt;/code&gt;的操作。&lt;/p&gt;
&lt;p&gt;因为经过上边的层层筛选，这里拿到的&lt;code&gt;path&lt;/code&gt;和你调用&lt;code&gt;send&lt;/code&gt;时传入的&lt;code&gt;path&lt;/code&gt;不是同一个路径。&lt;br/&gt;不过倒也没有必要必须在&lt;code&gt;setHeaders&lt;/code&gt;函数中进行处理，因为可以看到在函数结束时，将实际的&lt;code&gt;path&lt;/code&gt;返回了出来。&lt;br/&gt;我们完全可以在&lt;code&gt;send&lt;/code&gt;执行完毕后再进行设置，至于官方&lt;code&gt;readme&lt;/code&gt;中所写的&lt;code&gt;and doing it after is too late because the headers are already sent.&lt;/code&gt;。&lt;br/&gt;这个不需要担心，因为&lt;code&gt;koa&lt;/code&gt;的返回数据都是放到&lt;code&gt;ctx.body&lt;/code&gt;中的，而&lt;code&gt;body&lt;/code&gt;的解析是在所有的中间件全部执行完以后才会进行处理。&lt;br/&gt;也就是说所有的中间件都执行完以后才会开始发送&lt;code&gt;http&lt;/code&gt;请求体，在此之前设置&lt;code&gt;Header&lt;/code&gt;都是有效的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (setHeaders) setHeaders(ctx.res, path, stats)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; stream&lt;/span&gt;
ctx.set('Content-Length'&lt;span&gt;, stats.size)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!ctx.response.get('Last-Modified')) ctx.set('Last-Modified'&lt;span&gt;, stats.mtime.toUTCString())
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!ctx.response.get('Cache-Control'&lt;span&gt;)) {
  const directives &lt;/span&gt;= ['max-age=' + (maxage / 1000 | 0&lt;span&gt;)]
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (immutable) {
    directives.push(&lt;/span&gt;'immutable'&lt;span&gt;)
  }
  ctx.set(&lt;/span&gt;'Cache-Control', directives.join(','&lt;span&gt;))
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!ctx.type) ctx.type = type(path, encodingExt) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接口返回的数据类型，默认会取出文件后缀&lt;/span&gt;
ctx.body =&lt;span&gt; fs.createReadStream(path)

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; path
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以及包括上边的&lt;code&gt;maxage&lt;/code&gt;和&lt;code&gt;immutable&lt;/code&gt;都是在这里生效的，但是要注意的是，如果&lt;code&gt;Cache-Control&lt;/code&gt;已经存在值了，&lt;code&gt;koa-send&lt;/code&gt;是不会去覆盖的。&lt;/p&gt;
&lt;h4 id=&quot;使用Stream与使用readFile的区别&quot;&gt;使用Stream与使用readFile的区别&lt;/h4&gt;
&lt;p&gt;在最后给&lt;code&gt;body&lt;/code&gt;赋值的位置可以看到，是使用的&lt;code&gt;Stream&lt;/code&gt;而并非是&lt;code&gt;readFile&lt;/code&gt;，使用&lt;code&gt;Stream&lt;/code&gt;进行传输能带来至少两个好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一种方式，如果是大文件，在读取完成后会临时存放到内存中，并且&lt;code&gt;toString&lt;/code&gt;是有长度限制的，如果是一个巨大的文件，&lt;code&gt;toString&lt;/code&gt;调用会抛出异常的。&lt;/li&gt;
&lt;li&gt;采用第一种方式进行读取文件，是要在全部的数据都读取完成后再返回给接口调用方，在读取数据的期间，接口都是处于&lt;code&gt;Wait&lt;/code&gt;的状态，没有任何数据返回。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以做一个类似这样的Demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
const http      = require('http'&lt;span&gt;)
const fs        &lt;/span&gt;= require('fs'&lt;span&gt;)
const filePath  &lt;/span&gt;= './test.log'&lt;span&gt;

http.createServer((req, res) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (req.url === '/'&lt;span&gt;) {
    res.end(&lt;/span&gt;'&amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;'&lt;span&gt;)
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (req.url === '/sync'&lt;span&gt;) {
    const data &lt;/span&gt;=&lt;span&gt; fs.readFileSync(filePath).toString()

    res.end(data)
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (req.url === '/pipe'&lt;span&gt;) {
    const rs &lt;/span&gt;=&lt;span&gt; fs.createReadStream(filePath)

    rs.pipe(res)
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    res.end(&lt;/span&gt;'404'&lt;span&gt;)
  }
}).listen(&lt;/span&gt;12306, () =&amp;gt; console.log('server run as http://127.0.0.1:12306'))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先访问首页&lt;code&gt;&lt;a class=&quot;vglnk&quot; href=&quot;http://127.0.0.1:12306/&quot; rel=&quot;nofollow&quot;&gt;http://127.0.0.1:12306/&lt;/a&gt;&lt;/code&gt;进入一个空的页面 &lt;em&gt;(主要是懒得搞&lt;code&gt;CORS&lt;/code&gt;了)&lt;/em&gt;，然后在控制台调用两个&lt;code&gt;fetch&lt;/code&gt;就可以得到这样的对比结果了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.jiasm.org/images/koajs-code-review/sync-timeline.png&quot; alt=&quot;sync-timeline&quot; width=&quot;807&quot; height=&quot;553&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://blog.jiasm.org/images/koajs-code-review/pipe-timeline.png&quot; alt=&quot;pipe-timeline&quot; width=&quot;812&quot; height=&quot;556&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出在下行传输的时间相差无几的同时，使用&lt;code&gt;readFileSync&lt;/code&gt;的方式会增加一定时间的&lt;code&gt;Waiting&lt;/code&gt;，而这个时间就是服务器在进行文件的读取，时间长短取决于读取的文件大小，以及机器的性能。&lt;/p&gt;
&lt;h2 id=&quot;koa-static&quot;&gt;koa-static&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;koa-static&lt;/code&gt;是一个基于&lt;code&gt;koa-send&lt;/code&gt;的浅封装。&lt;br/&gt;因为通过上边的实例也可以看到，&lt;code&gt;send&lt;/code&gt;方法需要自己在中间件中调用才行。&lt;br/&gt;手动指定&lt;code&gt;send&lt;/code&gt;对应的&lt;code&gt;path&lt;/code&gt;之类的参数，这些也是属于重复性的操作，所以&lt;code&gt;koa-static&lt;/code&gt;将这些逻辑进行了一次封装。&lt;br/&gt;让我们可以通过直接注册一个中间件来完成静态文件的处理，而不再需要关心参数的读取之类的问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const Koa = require('koa'&lt;span&gt;)
const app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Koa()
app.use(require(&lt;/span&gt;'koa-static')(root, opts))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;opts&lt;/code&gt;是透传到&lt;code&gt;koa-send&lt;/code&gt;中的，只不过会使用第一个参数&lt;code&gt;root&lt;/code&gt;来覆盖&lt;code&gt;opts&lt;/code&gt;中的&lt;code&gt;root&lt;/code&gt;。&lt;br/&gt;并且添加了一些细节化的操作：&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;默认添加一个&lt;code&gt;index.html&lt;/code&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (opts.index !== &lt;span&gt;false&lt;/span&gt;) opts.index = opts.index || 'index.html'
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;默认只针对&lt;code&gt;HEAD&lt;/code&gt;和&lt;code&gt;GET&lt;/code&gt;两种&lt;code&gt;METHOD&lt;/code&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (ctx.method === 'HEAD' || ctx.method === 'GET'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;添加一个&lt;code&gt;defer&lt;/code&gt;选项来决定是否先执行其他中间件。&lt;br/&gt;如果&lt;code&gt;defer&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;，则会先执行&lt;code&gt;send&lt;/code&gt;，优先匹配静态文件。&lt;br/&gt;否则则会等到其余中间件先执行，确定其他中间件没有处理该请求才会去寻找对应的静态资源。&lt;br/&gt;只需指定&lt;code&gt;root&lt;/code&gt;，剩下的工作交给&lt;code&gt;koa-static&lt;/code&gt;，我们就无需关心静态资源应该如何处理了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;koa-send&lt;/code&gt;与&lt;code&gt;koa-static&lt;/code&gt;算是两个非常轻量级的中间件了。&lt;br/&gt;本身没有太复杂的逻辑，就是一些重复的逻辑被提炼成的中间件。&lt;br/&gt;不过确实能够减少很多日常开发中的任务量，可以让人更专注的关注业务，而非这些边边角角的功能。&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 17:07:00 +0000</pubDate>
<dc:creator>贾顺名</dc:creator>
<og:description>koa源码阅读的第四篇，涉及到向接口请求方提供文件数据。 第一篇：koa源码阅读-0第二篇：koa源码阅读-1-koa与koa-compose第三篇：koa源码阅读-2-koa-router 处理静态</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiasm/p/9527536.html</dc:identifier>
</item>
<item>
<title>项目研发流程及管理之我见 - 超大的雪童子</title>
<link>http://www.cnblogs.com/yangsy0915/p/9527477.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangsy0915/p/9527477.html</guid>
<description>&lt;p&gt;随着工作年限的增长，我们从一开始负责一个功能，再到负责一个模块的数据字典及框架设计。再到负责整个系统的需求评审及架构设计。这一路见证着程序猿的成长。但当我们逐步成为一名架构师，或是一名项目管理人员时，会发现一个项目的成功，会牵扯到各式各样的问题及风险。无论是系统本身要兼容快速发展的业务形态，还是由于人员因素导致的项目延迟，又或是系统代码的臃肿或是难以维护，亦是新人来后的一脸迷茫。&lt;/p&gt;
&lt;p&gt;   那么下面，分享下，项目流程管理之我见。&lt;/p&gt;

&lt;p&gt;一、整体项目流程&lt;/p&gt;
&lt;p&gt;    1、 需求评审与确认&lt;/p&gt;
&lt;p&gt;    要求：PD会进行需求的整理并放入需求资源池。确定本期研发的功能需求，并开始需求评审，需求评审时，能够使技术人员能够完全理解本次需求的前因后果，作用，目标及整个流程。&lt;/p&gt;
&lt;p&gt;产出：该阶段主要为pd产出相关prd及demo，对需求进行宣讲，并记录疑问及难点。&lt;/p&gt;

&lt;p&gt;    2、模块流程文档&lt;/p&gt;
&lt;p&gt;    要求：围绕着本次迭代的核心问题，编写整个模块的闭环业务流程。如有复杂逻辑，需要画出用例图、协作图等。&lt;/p&gt;
&lt;p&gt;    同时，要给出该模块的非功能性需求，例如：调用量、日均增量、访问次数等待。&lt;/p&gt;
&lt;p&gt;    产出：领域模型、开发模块架构图、技术架构图、人员分工（每个人负责哪个模块）&lt;/p&gt;

&lt;p&gt;    3、详细设计及评审&lt;/p&gt;
&lt;p&gt;        （1）概念映射：抽取本次模块迭代的一些属于概念。&lt;/p&gt;
&lt;p&gt;        （2）框架设计：围绕着本次迭代的核心，进行模块的扩展构思，不仅仅以完成本次功能的模块为主旨，还需要考虑未来的体系中，该模块的可用性、扩展性。&lt;/p&gt;
&lt;p&gt;        （3）数据库设计：数据库设计时要严格遵守数据库范式、同时围绕系统做到可扩展。&lt;/p&gt;
&lt;p&gt;        （4）功能细化与调研各个环节中需要调用哪些接口服务。&lt;/p&gt;
&lt;p&gt;        （5）前后端传输对象的映射及定义，进行前后端最后评审。&lt;/p&gt;
&lt;p&gt;　　　产出：技术架构图、数据库关联关系图等，一致评审通过后，形成完整文档。&lt;/p&gt;

&lt;p&gt;    4、编码&lt;/p&gt;
&lt;p&gt;      （1）围绕着模块的核心构建核心框架代码（遇到问题可互相讨论）&lt;/p&gt;
&lt;p&gt;      （2）编码及功能实现。&lt;/p&gt;
&lt;p&gt;      （3）接口注释、复杂逻辑注释。&lt;/p&gt;

&lt;p&gt;    5、测试&lt;/p&gt;
&lt;p&gt;           要求：测试阶段，根据代码逻辑，编写每一个case的相关测试用例及单元测试。变更覆盖率不得低于百分之80。&lt;/p&gt;
&lt;p&gt;　　　产出：测试用例文档及单元测试TestCase。&lt;/p&gt;

&lt;p&gt;     6、发布前准备与发布&lt;/p&gt;
&lt;p&gt;          要求：查看代码检测工具，质量分不得小于35分、行单测覆盖率不得小于百分之60。从开发-&amp;gt;集成-&amp;gt;预发-&amp;gt;发布阶段，每一阶段都需要进行验证及日志查看。 &lt;/p&gt;
&lt;p&gt;注：预发前要充分做好回归测试（根据每次迭代的测试用例及单元测试进行测试），防止线上已有功能受到影响。&lt;/p&gt;

&lt;p&gt;     7、线上问题修复及运维&lt;/p&gt;
&lt;p&gt;           要求：（1）发布上线后出现问题，需要紧急变更处理，做好线下及预发验证，发布线上。同时在lark上记录该问题的前因后果。&lt;/p&gt;
&lt;p&gt;                      （2）约定时间，每日查看自己负责的模块及整体系统运行情况，发现问题及时抛出。&lt;/p&gt;

&lt;p&gt;二、代码质量及review&lt;/p&gt;
&lt;p&gt;      要求：每次迭代完的下个星期，抽出一下午时间进行代码质量及review（pmd检测大部分代码质量问题），包括：&lt;/p&gt;
&lt;p&gt;     （1）代码结构是否合理，能否有更好的实现。（结构角度、方法抽象、jvm堆栈内存占用等）&lt;/p&gt;
&lt;p&gt;     （2）代码中没考虑到的情况&lt;/p&gt;

&lt;p&gt;三、项目管理&lt;/p&gt;
&lt;p&gt;项目管理要点分为，时间把控、风险把控、补位意识、结果与目标导向四点：&lt;/p&gt;
&lt;p&gt;    时间把控：&lt;/p&gt;
&lt;p&gt;     （1）整个项目流程分为需求、设计、开发、测试、实施阶段。根据需求的复杂度、团队整体能力水平、调研负责度进行迭代周期的预测。&lt;/p&gt;
&lt;p&gt;     （2）一旦时间确定下来，就严格按照每个阶段的产出实行。&lt;/p&gt;

&lt;p&gt;    风险把控：&lt;/p&gt;
&lt;p&gt;     （1）意外情况或有进度风险的情况。需要及时暴露出来 风险原因及风险问题。并进行相关协调沟通，补位意识。&lt;/p&gt;

&lt;p&gt;    补位意识：&lt;/p&gt;
&lt;p&gt;     （1）项目风险确定，每个成员都有自身的长项，发现影响进度的问题，包含于自己能力的能力范畴内，帮助对方提速，追赶项目进度。&lt;/p&gt;

&lt;p&gt;    结果与目标导向：&lt;/p&gt;
&lt;p&gt;     （1）保质保量完成需求及模块的迭代。&lt;/p&gt;
&lt;p&gt;     （2）优化review及补充，使每个人能够知道对方模块的逻辑及全系统逻辑。&lt;/p&gt;
&lt;p&gt;     （3）问题总结及技能总结。&lt;/p&gt;
&lt;p&gt;     （4）从整个系统的层面、业务大图的层面去考虑整个系统或产品的发展及扩展。&lt;/p&gt;

&lt;p&gt;    当然，现实或许是残酷的，时间或许是紧迫的。很多时候，我们会因为各种各样的原因而搁置其中的部分流程。但规范决定着长远的风险可控，倘若有时间一定要将必要的补上，这是对别人负责，同时也是对自己负责。&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 16:35:00 +0000</pubDate>
<dc:creator>超大的雪童子</dc:creator>
<og:description>随着工作年限的增长，我们从一开始负责一个功能，再到负责一个模块的数据字典及框架设计。再到负责整个系统的需求评审及架构设计。这一路见证着程序猿的成长。但当我们逐步成为一名架构师，或是一名项目管理人员时，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangsy0915/p/9527477.html</dc:identifier>
</item>
<item>
<title>Nerd的畅销产品 - kid551</title>
<link>http://www.cnblogs.com/kid551/p/9527376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/9527376.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180824000423512-595454487.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;感谢陈大先生花费时间一起细致地讨论这个课题，促成此文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484435&amp;amp;idx=1&amp;amp;sn=9ca00732944ad8d145eb1ac2b42d32bb&amp;amp;chksm=ec20e3afdb576ab9b2c2c3cc1eddcd0e44658ccb3ac3da840ef2ed9a42dd967b5c191639ebbc&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;Nerd的套现ATM机&lt;/a&gt;》中已经谈到，对于nerd来讲最畅销的产品是“考试通过”。本文将继续这个话题的展开讨论，更深入细致地分析这个说法所包含的更多深意。&lt;/p&gt;
&lt;p&gt;在讨论nerd的产品之前，我们先要考察一下另外一个概念，市场。而要考虑市场，则需要从它的需求或者说motivation谈起。&lt;/p&gt;
&lt;p&gt;无论你从事的是何种事业又或是何种使命，例如你可以是在从事教育事业的园丁、是构建影响人类生活福祉的产品经理、又或是救死扶伤的医生，只要你所追求的目标和金钱挂钩，就不得不考虑市场这个概念。也即是，无论你是个高尚的人、卑鄙的人、漂亮的人、丑陋的人，只要你不得不开始谈“钱”，你就不得不考虑市场这个概念、研究市场的规律、顺应市场的法则。因为，钱这个东西，只和市场（market）有关。&lt;/p&gt;
&lt;p&gt;而决定市场的是什么呢？是高尚的品质？是纯粹的动机？是长足的眼光？是深刻的洞见？还是让人心醉的颜值？不，决定是市场的从来不是这些关乎道德伦理、艺术美丑的东西，而是一些冷峻、单调得多的东西：&lt;strong&gt;流行（popularity）、趋势、集体疯狂&lt;/strong&gt;。也即是，只要你的产品踩准了市场的流行、趋势、集体疯狂的点，那么你就能套利获取丰厚的报酬。&lt;/p&gt;
&lt;p&gt;任何一家商业机构，在盈利的层面，都不得不跪舔市场的流行、趋势、集体疯狂。无论是拥有众多发明创造、开源贡献的Google，还是做分享、共合作的腾讯，在“造血”的层面上——广告、游戏，可从来是毫不犹豫地疯狂地跪舔市场。表面上看这是矛盾的，其实不然。你的目标、使命是一个维度的东西，而你的资本累积和财富聚集是另一个维度的东西。例如巴菲特通过资本主义的利器保险和资本的复利，不断地吸取财富。可他同时又将这些赚到的财富捐献给比尔盖茨做慈善，以实现财富在社会中的再分配。&lt;/p&gt;
&lt;p&gt;由此得出的结论便是，但凡你要考虑钱的问题、财富积累的问题，你就不得不去跪舔市场的规律。而跪舔市场规律，只是单独的一条赚取财富的路径，它既不能代表使用这个工具的人的其它志向、看法、品德，也不能说明能那些善于利用市场并积累财富的人具备多么高尚的品质和长远的眼光。它有且只能代表，要获取钞票，你就得跪舔市场。&lt;/p&gt;
&lt;p&gt;有了这个清晰的前提，现在我们便可以去考察nerd的世界。nerd们容易陷入一个误区，即是将个人的事业追求同财富积累绑定在了一起。nerd们很容易因为自己在学术、在逻辑、在真相上有着不同常人的高品质追求，而误以为自己就可以凭借这些特质获取财富。&lt;/p&gt;
&lt;p&gt;为什么有那么多暗自叹息、怀才不遇的nerd？原因正是在此。像什么：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我是如此努力地探寻知识的边界，可为什么还是个穷教书匠？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我对自己的论文和学术成果，从来都是实事求是，不参入半点水分，为什么地位就是如此之低，总是在一线卖命，却总是分不到半点羹肴？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;为什么我从不哗众取宠、不做那些没有长远意义的事情，却总是得不到大家的青睐，进而无法建立影响力、无法变现自己的深谋远虑？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么呢？因为你把决定财富的“市场所需”和你自己的“追求所需”混在一起了。什么叫做市场？就是前面提到的，以流行、趋势、集体疯狂作为根基的一个体系。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;为什么各大底层商人，可以凭借几块破布发家致富？因为有大量的低端消费人群相辅相成。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;为什么直播的网红小姐姐，可以凭借整容脸在屏幕面前搔首弄姿一番就可以月入几万？因为有大量的屌丝群体在拥护、在疯狂。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;为什么你看不上的、low到爆的破网页，却可以年入几千万？因为有大量的算法优化来迎合最大数目的人流行为。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么，回过头来看，nerd的什么产品是最有市场、在市场上是最畅销的呢？是你的深刻洞见吗？曲高和寡。是你的深谋远虑吗？难以贴现。是你的鸿鹄之志吗？无人问津。都不是，是你nerd生产的“考试通过”这个产品！它的销量和市场需求是如此之巨大和确定，以至于你打开任何一款招聘软件，都能看到每一场考试（面试）所对应的市场价格。&lt;/p&gt;
&lt;p&gt;或许nerd们会鄙视地想：会考试有个屁用，知识都没融会贯通呢？！考得好又怎么样，你根本做不出有影响力的前沿研究。这就是典型的将“货币的追求”和“自我的追求”混为一谈。当你要考虑的问题是金钱时，你就不应该去问你想要什么、你觉得什么有价值。这正如无数的产品经理和CEO在谋划产品路线图的时候，都不会自负天真地去考虑我觉得什么是对的、我觉得什么有意义，而是通过不断的迭代验证循环，去发掘出市场需要什么。大企业尚且如此，作为一个nerd个体，如果你要考虑金钱的报酬，又怎敢去违背这个规律？！在这样的前提下，你该问的正确的问题是：市场想要从nerd身上获取什么产品？答案是市场需要你的文凭、你的title，终归起来就是你提供“考试通过”这个产品。&lt;/p&gt;
&lt;p&gt;谈论到这里，下一个会提出的问题便是，考试通过了又怎样呢？面试造核弹，工作就搬砖，你这有什么意义呢？&lt;/p&gt;
&lt;p&gt;如果你再一次从产品的角度去看待这个问题，其实很容易回答。如果你卖的就是“考试通过”这个产品，难道还要TM地去关心最终用户能否发挥这个产品的效果吗？这就好比是，如果你在销售一辆法拉利，你会去关心、去介意这个客户有没有买法拉利的必要吗？！你是不是还要担心，这个人如果把法拉利当作存放旧报纸的仓库，是不是就不要卖给他了？！请问如果你是法拉利的销售人员，你关心这个问题吗？！那TM当然不关心，买的越多越好啊！哪怕你直接把买到的法拉利扔进海里，那又怎么样呢，who care？！&lt;/p&gt;
&lt;p&gt;这不是在说读书人的清高、长远追求、深谋远虑、关心人类的未来是不正确的，而是说要让你在充分明确自己的目标追求的前提下，采取不同的工具和手段来实现目的。我们这里的讨论，有且只限于“需要钞票”这个前提下。在这个清晰的大目标之下，对于需要跪舔的市场来讲，这些东西就不重要了。&lt;/p&gt;
&lt;p&gt;这就好比是，你要烧饭做菜需要水，可是水在几公里外的河里，你怎么办呢？难道要违背客观的物理规律，不断抱怨这个水源为什么这么远？可不可以不走路？我明明厨艺一流为什么就不能让我做成一顿饭，反而让那些不怎么会烧饭的、只会下劳力的汉子，抢得先机、做好饭呢?&lt;/p&gt;
&lt;p&gt;如果这个情境对你来说没有问题，那么，当你要做成一件事（烧饭）的时候，就是缺乏资金（水源），你难道要违背市场的规律去拒绝获取资本吗？正确的做法当然就是像打水一般，好好地满足市场的客观规律，提供给它所需要的祭品——符合popularity、趋势、集体疯狂的产品，然后换回资金，再回过头去追求自己一开始的目标。&lt;/p&gt;
&lt;p&gt;（当然，资本是如此有魔性，以至于在打水的路上迷失了自我，拼了命地去河里打水，而忘记了自己需要烧饭，是为了烧饭才跑到河边的这个初衷。）&lt;/p&gt;
&lt;p&gt;但你绝对没有办法通过违背市场规律换得资金，就如同你无法通过违背物理规律，通过空间转移将几公里外的河水直接引入到家里。&lt;/p&gt;
&lt;p&gt;这就是分清市场规律和自身追求的重要性。即便是你很有追求、胸怀天下、时时刻刻想要创造价值，可是，当你在需要资金的时候，只要你违背了市场规律，就会造成无法盈利、断水断粮的后果。你需要去满足市场的规律，去好好售卖作为知识生产者的畅销产品：考试、证书、文凭。只有出售了市场需要的产品，满足了市场规律，你才能够从市场那里换取到你需要的资金、资本。&lt;/p&gt;
&lt;p&gt;而所谓的深刻洞见、透彻理解、清晰逻辑，在市场这个模型里，都只是制造你最后的产品“考试通过”的生产要素。它们是原材料，而不是最终的成品。所以，当你拿着一堆原材料，如我聪明、我逻辑好，去市场上妄图售卖时，当然是缘木求鱼。&lt;/p&gt;
&lt;p&gt;以产品的角度去对待面试、考试，会让你更容易克服一些心理上的障碍与困难。例如，对于程序员来讲，刷算法题是痛苦的。会在各种牛X、奇葩、数量繁多的算法题目面前败下阵来，不断地质问自己：我是否不够聪明，为什么我想不到这个方法，我理解不大透彻怎么办？！&lt;/p&gt;
&lt;p&gt;可如果你以产品的角度来看，你需要的就是把最终的产品“面试通过”给组装好，至于这个产品是由几块集成电路板构成的，根本不是终端用户真正关心的。同样，你的目的并不是成为算法的研究人员，那么，通过面试的最好方法，当然是“读书百遍，其义自见”或是“书读唐诗三百首，不会做诗也会吟”。通过不断地做题目，甚至是背诵题目，便可以在类似于机器学习的重复中，自然而然地找到里面看不见的Pattern。&lt;/p&gt;
&lt;p&gt;某个时间节点后，所有的教育都在打压和批判题海战术，不断地抨击死记硬背。其实我想说，真正用过这两个战术的人，其实很难落入被批判的陷阱之中。有问题的并不是“题海战术、死记硬背”本身，而是不知道为了什么、为了哪个方向去做这个事情。&lt;/p&gt;
&lt;p&gt;回顾一下为什么你可以在区分错别字和辨别多音字上有着扎实的基础？（你掌握的编程语言基础有这么扎实吗？）那不就是在高考前夕，通过一本又一本的练习册训练出来的吗？！靠的是什么？就是这种最简单粗暴的勤学苦练。并且，你会发现这个训练虽然单调乏味，但却极其高效。不过是几个月的时间，便能让你掌握看似无法实现的目标。&lt;/p&gt;
&lt;p&gt;甚至就是数学这样看似和智商极为相关的学科，都能够通过这样的训练而实现不错的成长。事实上，从我的角度来看，AI的发展和机器学习的理论，早已揭示出了题海战术中的道理和内涵。即便是计算机这样的蠢物，也可以通过不断地被数据冲刷，而找到内在的pattern，更何况是人？&lt;/p&gt;
&lt;p&gt;所以，制造这个畅销产品的技能，你一直都会，就是曾经高中时期不断使用的刷题、默默坚持。&lt;/p&gt;
&lt;p&gt;如果我们再从投入产出去分析一下“考试通过”这款产品，就会发现更多的惊喜。首先，为了生产这款产品，你需要投入的资本是：教科书、大脑、时间，确确实实不值几个钱。&lt;/p&gt;
&lt;p&gt;风险呢？风险就是考试不通过罢了。既不会掉块肉，也不会少层皮。唯一耗费的就是你的时间机会成本。不过，到哪里混时间不是混呢？把拿来混的时间用来做考试题，似乎也不算太过奢侈。比起耍抖音、耍电视剧要良心得多吧？&lt;/p&gt;
&lt;p&gt;而你的产出呢？一旦你通过，你便能够顺利跳槽进入大厂，进入到更好的圈子，拿到更多的薪水，接触更广阔的天地。并且，整个过程不需要你拼爹、拼钱、卖肉被潜，只是好好地考试即可。可算得上社会中为数不多的可以不通过所谓的关系和资源而获得晋升的机会了。并且，你还能顺道在准备的过程中，提高点智商，何乐而不为？&lt;/p&gt;
&lt;p&gt;综合考虑起来，“考试通过”是投资品中的珍奇异兽：有限的、近乎为零的投资成本，微乎其微的损失风险，但却有着不可限量的巨额回报！这绝对是你打着灯笼在任何的股市、基金市场上都找不到的优质投资品！它完全就是黑天鹅（有限的收益，无限的风险）的反面！如此好的产品与投资，怎能错过？！&lt;/p&gt;

&lt;p&gt;子在川上对曰：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;“百无一用是书生，只会闷头读书、会考试，有何用？”&lt;/p&gt;
&lt;p&gt;“有用啊。考试通过，进大厂、乱跳槽、升职加薪，样样不缺。”&lt;/p&gt;
&lt;p&gt;“我别的都不会，只会用一支笔，将考卷做对。”&lt;/p&gt;
&lt;/blockquote&gt;




&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484435&amp;amp;idx=1&amp;amp;sn=9ca00732944ad8d145eb1ac2b42d32bb&amp;amp;chksm=ec20e3afdb576ab9b2c2c3cc1eddcd0e44658ccb3ac3da840ef2ed9a42dd967b5c191639ebbc&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;Nerd的套现ATM机&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484431&amp;amp;idx=1&amp;amp;sn=9ab37eabfc56c309bfc183c4ad202f79&amp;amp;chksm=ec20e3b3db576aa5beab21c16db95b28d660f76ade46a7dba86dfacc8173cf2eac4cd1083b91&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;不过是备选的一道菜罢了&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484431&amp;amp;idx=2&amp;amp;sn=47220db14dfe1c94d669b561ec128c74&amp;amp;chksm=ec20e3b3db576aa5e7987092dc11c740134b42e1c79324af053d6ec5f354a3cf2182db971811&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;2018年07月写字总结&lt;/a&gt;》&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180824000510145-285090092.jpg&quot; alt=&quot;&quot; width=&quot;630&quot; height=&quot;315&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;



&lt;h3&gt;   &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;更多信息交流和观点分享，可加入知识星球：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180824000610326-1703750051.png&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;367&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 16:07:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<og:description>感谢陈大先生花费时间一起细致地讨论这个课题，促成此文。 《Nerd的套现ATM机》中已经谈到，对于nerd来讲最畅销的产品是“考试通过”。本文将继续这个话题的展开讨论，更深入细致地分析这个说法所包含的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/9527376.html</dc:identifier>
</item>
<item>
<title>python中文编码&amp;json中文输出问题 - msay</title>
<link>http://www.cnblogs.com/mingjiatang/p/9527345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mingjiatang/p/9527345.html</guid>
<description>&lt;p&gt;python2.x版本的字符编码有时让人很头疼，遇到问题，网上方法可以解决错误，但对原理还是一知半解，本文主要介绍 python 中字符串处理的原理，附带解决 json 文件输出时，显示中文而非 unicode 问题。首先简要介绍字符串编码的历史，其次，讲解 python 对于字符串的处理，及编码的检测与转换，最后，介绍 python 爬虫采取的 json 数据存入文件时中文输出的问题。&lt;br/&gt;参考书籍：Python网络爬虫从入门到实践 by唐松&lt;/p&gt;
&lt;p&gt;在python 2或者3 ，字符串编码只有两类 ：&lt;/p&gt;
&lt;p&gt;（1）通用的Unicode编码；&lt;br/&gt;（2）将Unicode转化为某种类型的编码，如UTF-8，GBK；&lt;/p&gt;
&lt;h2 id=&quot;计算机历史&quot;&gt;1、计算机历史：&lt;/h2&gt;
&lt;p&gt;计算机只处理数字，因此处理文本时，必须转换成数字才行。&lt;br/&gt;8位（bit）=1字节（byte）=256种不同状态=从000000到111111；&lt;br/&gt;1GB=1024M=1024（1024kb）=1024（1024（1024b））；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ASCII编码&lt;/strong&gt; 是对应英文字符与二进制数字之间的关系；ASCII一共规定了128种，如大写字母A是65，即01000001；可见一字母一字节；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GB2312编码&lt;/strong&gt; 简体中文常见的编码，两个字节代表一个中文汉字 ，理论上256*256个编码，即可表示65536种中文字；&lt;/p&gt;
&lt;p&gt;各国编码不同，为了各国能扩平台进行文本的转换与处理，&lt;strong&gt;Unicode&lt;/strong&gt;就被作为统一码或者单一码。Unicode编码通常是两个字节，unicode与ASCII编码的区别，在于unicode在ASCII编码前加了一个0，即字母A的ASCII编码为01000001，unicode编码即为&lt;code&gt;00000000&lt;/code&gt;01000001;但英文字母其实只用一个字节就够了，unicode编码写英文时多了一个字节，浪费存储空间。因而unicode开发了&lt;strong&gt;通用转换格式（Unicode Transformation Format(UTF)）&lt;/strong&gt;,常见的有utf-8或者utf-16；&lt;/p&gt;
&lt;h2 id=&quot;python字符编码&quot;&gt;2、python字符编码&lt;/h2&gt;
&lt;p&gt;参考地址：&lt;a href=&quot;https://www.jb51.net/article/139878.htm&quot; class=&quot;uri&quot;&gt;https://www.jb51.net/article/139878.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（1）encode的作用是，将unicode对象编码成其他编码的字符串，str.encode('utf-8'),编码成UTF-8；（2）decode的作用是将其他编码的字符串转换成Unicode编码，str.decode('UTF-8')；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;import chardet 查阅具体的编码类型，&lt;code&gt;chardet.detect(str)&lt;/code&gt;，但是str不能是unicode编码类型，但是&lt;strong&gt;该方法 不接受 本来已经是unicode的编码的 参数&lt;/strong&gt;，会有TypeError: Expected object of type bytes or bytearray, got: &amp;lt;type 'unicode'&amp;gt;错误；&lt;/li&gt;
&lt;li&gt;作为统一标准，unicode不能再被解码，如果UTF-8想转至其他非unicode，则必须（2）先decode 到unicode，在encode到其他非unicode的编码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;爬取网页时，可在F12 elements meta中查看网页编码方式，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/531939/201808/531939-20180824000321889-1908801539.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(2)中文，Python中的字典能够被序列化到json文件中存入json&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;with open(&quot;anjuke_salehouse.json&quot;,&quot;w&quot;,encoding='utf-8') as f:
    json.dump(all_house,f,ensure_ascii=False,sort_keys=True, indent=4);
    print(u'加载入文件完成...');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;存储数据如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/531939/201808/531939-20180824000455622-381866342.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;dump()的第一个参数是要序列化的对象，第二个参数是打开的文件句柄，注意文件打开&lt;code&gt;open()&lt;/code&gt;时加上以&lt;strong&gt;UTF-8编码&lt;/strong&gt;打开，在&lt;code&gt;dump()&lt;/code&gt;的时候也加上&lt;strong&gt;ensure_ascii=False&lt;/strong&gt;,不然会变成ascii码写到json文件中&lt;code&gt;json.dump(all_house,f,ensure_ascii=False,sort_keys=True, indent=4)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;json.dumps()/json.loads()等用法&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;json_str = json.dumps(all_house,ensure_ascii=False); #all——books 为列表、字典等python自带的数据结构，将其写成json
#print json_str; #[{&quot;brokername&quot;: &quot;王东宇&quot;},{},{}]
new_dict = json.loads(json_str);#主要是读json文件时，需要用到
#print new_dict; #{u'house_area': u'95', u'build_year': u'2005'}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;json.dumps() 是将一个Python数据结构转换为一个JSON编码的字符串,&lt;br/&gt;{&quot;name&quot;: &quot;xiaoming&quot;}&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/531939/201808/531939-20180824000552325-1570400602.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;json.loads() 是将一个JSON编码的字符串（字典形式）转换为一个Python数据结构,{u'name': u'xiaoming'}&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/531939/201808/531939-20180824000612247-788275856.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dumps转化后&lt;strong&gt;键与值都变成了双引号&lt;/strong&gt;，而在loads后变成python变量时，&lt;strong&gt;元素都变成了单引号，并且字符串前加多了个u&lt;/strong&gt;。&lt;br/&gt;一般要求当要字符串通过loads转为python数据类型时，得外层用单引号，里面元素key和value用双引号。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sort_keys：根据key排序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;dump与dumps的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw)&lt;/code&gt;；dump将一个对象序列化存入文件，dump需要一个类似于文件指针的参数（并不是真的指针，可称之为类文件对象），可以与文件操作结合，也就是说可以将dict转成str存入文件中，如&lt;code&gt;json.dump(all_house,f,ensure_ascii=False,sort_keys=True, indent=4)&lt;/code&gt;中的&lt;code&gt;f&lt;/code&gt;表示一个数据待写入的json文件句柄；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw)&lt;/code&gt;；而&lt;strong&gt;dumps(str)&lt;/strong&gt;直接给的是str，也就是直接将字典转成str，无需写入文件，类似一个数据格式的转换方法，将python字符串转成json字典。&lt;/li&gt;
&lt;li&gt;所以dumps是将dict转化成str格式，loads是将str转化成dict格式。&lt;br/&gt;dump和load也是类似的功能，只是与文件操作结合起来了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（3）中文存入txt&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f=open('net_saving_data.txt','w',encoding='utf-8');
for item in all_house:
    # house_area=item['house_area'];
    # price=item['price'];
    output='\t'.join([str(item['house_area']),str(item['price']),str(item['build_year']),str(item['house_title'])]);
    f.write(output);
    f.write('\n');
f.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/531939/201808/531939-20180824000633475-807986595.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在2.7.15版本的python中，提示错误&lt;code&gt;TypeError: 'encoding' is an invalid keyword argument for this function&lt;/code&gt;,无法传入encoding的参数，但是在3.7版本可传入encoding='utf-8'参数，即可对 txt进行中文写入。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;中文写入txt、json文件是无非就是&lt;strong&gt;open()文件时，需要添加utf-8&lt;/strong&gt;，&lt;strong&gt;dump()时，需要添加ensure_ascii=False&lt;/strong&gt;，防止ascii编码，但是刚开始因为python版本是2.7.15，不是3.7，导致存储不成功的时候，一直以为是代码的问题。所以最后发现就是版本的问题，也挺伤的。网上关于中文这个编码问题有很多，但是他们都没有强调python版本的问题！！！其他3.xx的版本没有试过。&lt;/li&gt;
&lt;li&gt;读取网页数据的时候，查看网页的charset，及chardet库对编码类型的查询，及时进行decode和encode的编码转化，应该就能避免很多编码问题了。其他的坑以后踩了再补吧。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 23 Aug 2018 16:07:00 +0000</pubDate>
<dc:creator>msay</dc:creator>
<og:description>python2.x版本的字符编码有时让人很头疼，遇到问题，网上方法可以解决错误，但对原理还是一知半解，本文主要介绍 python 中字符串处理的原理，附带解决 json 文件输出时，显示中文而非 un</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mingjiatang/p/9527345.html</dc:identifier>
</item>
<item>
<title>apache ignite系列（五）：分布式计算 - 堕落门徒</title>
<link>http://www.cnblogs.com/cord/p/9431867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cord/p/9431867.html</guid>
<description>&lt;h3 id=&quot;ignite分布式计算&quot;&gt;ignite分布式计算&lt;/h3&gt;
&lt;p&gt;在ignite中，有传统的MapReduce模型的分布式计算，也有基于分布式存储的并置计算，当数据分散到不同的节点上时，根据提供的并置键，计算会传播到数据所在的节点进行计算，再结合数据并置，相关联的数据存储在相同节点，这样可以避免在计算过程中涉及到大量的数据移动，有效保证计算的性能。&lt;/p&gt;
&lt;p&gt;ignite分布式计算的主要特点如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;自动部署&lt;/td&gt;
&lt;td&gt;计算用到的类可以自动传播，而不需要在每个节点都部署相关的类，这个可以通过配置&lt;code&gt;peerClassLoadingEnabled&lt;/code&gt;选项开启计算类的自动传播，但是缓存的实体类是无法自动传播的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;平衡加载&lt;/td&gt;
&lt;td&gt;数据在加载之后会在集群中进行一个再平衡的过程，保证数据均匀分布在各个节点，当有计算在集群中执行的时候，可以根据提供的并置键定位到数据所在节点进行计算，也就是并置计算。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;故障转移&lt;/td&gt;
&lt;td&gt;当节点出现故障或者其它计算的时候，任务会自动转移到集群中的其他节点执行&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;分布式闭包&quot;&gt;1.分布式闭包:&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Ignite计算网格可以对集群或者集群组内的任何闭包进行广播和负载平衡，包括纯Java的&lt;code&gt;runnables&lt;/code&gt;和&lt;code&gt;callables&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;broadcast&lt;/td&gt;
&lt;td&gt;将任务传播到部分指定节点或者全部节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;call/run&lt;/td&gt;
&lt;td&gt;执行单个任务或者任务集&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;apply&lt;/td&gt;
&lt;td&gt;apply接收一个闭包和一个集合作为参数，生成与参数数量等量的任务，每个任务分别是将闭包应用在其中一个参数上，并且会返回结果集。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;ComputeTestController.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    /** broadCast测试*/
    @RequestMapping(&quot;/broadcast&quot;)
    String broadcastTest(HttpServletRequest request, HttpServletResponse response) {
//        IgniteCompute compute = ignite.compute(ignite.cluster().forRemotes());  //只传播远程节点
        IgniteCompute compute = ignite.compute();
        compute.broadcast(() -&amp;gt; System.out.println(&quot;Hello Node: &quot; + ignite.cluster().localNode().id()));
        return &quot;all executed.&quot;;
    }

    /** call和run测试 */
    @RequestMapping(&quot;/call&quot;)
    public @ResponseBody
    String callTest(HttpServletRequest request, HttpServletResponse response) {
        Collection&amp;lt;IgniteCallable&amp;lt;Integer&amp;gt;&amp;gt; calls = new ArrayList&amp;lt;&amp;gt;();

        /** call */
        System.out.println(&quot;-----------call-----------&quot;);
        for(String word : &quot;How many characters&quot;.split(&quot; &quot;)) {
            calls.add(word::length);
//            calls.add(() -&amp;gt; word.length());
        }
        Collection&amp;lt;Integer&amp;gt; res = ignite.compute().call(calls);
        int total = res.stream().mapToInt(Integer::intValue).sum();
        System.out.println(String.format(&quot;the total lengths of all words is [%s].&quot;, total));

        /** run */
        System.out.println(&quot;-----------run-----------&quot;);
        for (String word : &quot;Print words on different cluster nodes&quot;.split(&quot; &quot;)) {
            ignite.compute().run(() -&amp;gt; System.out.println(word));
        }

        /** async call */
        System.out.println(&quot;-----------async call-----------&quot;);
        IgniteCompute asyncCompute =  ignite.compute().withAsync();
        asyncCompute.call(calls);
        asyncCompute.future().listen(fut -&amp;gt; {
            Collection&amp;lt;Integer&amp;gt; result = (Collection&amp;lt;Integer&amp;gt;)fut.get();
            int t = result.stream().mapToInt(Integer::intValue).sum();
            System.out.println(&quot;Total number of characters: &quot; + total);
        });

        /** async run */
        System.out.println(&quot;-----------async run-----------&quot;);
        Collection&amp;lt;ComputeTaskFuture&amp;lt;?&amp;gt;&amp;gt; futs = new ArrayList&amp;lt;&amp;gt;();
        asyncCompute = ignite.compute().withAsync();
        for (String word : &quot;Print words on different cluster nodes&quot;.split(&quot; &quot;)) {
            asyncCompute.run(() -&amp;gt; System.out.println(word));
            futs.add(asyncCompute.future());
        }
        futs.stream().forEach(ComputeTaskFuture::get);

        return &quot;all executed.&quot;;
    }

    /** apply测试 */
    @RequestMapping(&quot;/apply&quot;)
    public @ResponseBody
    String applyTest(HttpServletRequest request, HttpServletResponse response) {
        /** apply */
        System.out.println(&quot;-----------apply-----------&quot;);
        IgniteCompute compute = ignite.compute();
        Collection&amp;lt;Integer&amp;gt; res = compute.apply(
                String::length,
                Arrays.asList(&quot;How many characters&quot;.split(&quot; &quot;))
        );
        int total = res.stream().mapToInt(Integer::intValue).sum();
        System.out.println(String.format(&quot;the total lengths of all words is [%s].&quot;, total));

        /** async apply */
        IgniteCompute asyncCompute = ignite.compute().withAsync();
        res = asyncCompute.apply(
                String::length,
                Arrays.asList(&quot;How many characters&quot;.split(&quot; &quot;))
        );
        asyncCompute.future().listen(fut -&amp;gt; {
            int t = ((Collection&amp;lt;Integer&amp;gt;)fut.get()).stream().mapToInt(Integer::intValue).sum();
            System.out.println(String.format(&quot;Total number of characters: &quot; + total));
        });

        return &quot;all executed.&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;mapreduce&quot;&gt;2. MapReduce:&lt;/h4&gt;
&lt;p&gt;在ignite中MapReduce的实现是&lt;code&gt;ComputeTask&lt;/code&gt;，其主要方法是map()和reduce()，map()可以控制任务映射到节点的过程，而reduce()则是对最终计算结果集的一个处理。&lt;code&gt;ComputeTask&lt;/code&gt;有两个主要实现&lt;code&gt;ComputeTaskAdapter&lt;/code&gt;和&lt;code&gt;ComputeTaskSplitAdapter&lt;/code&gt;, 主要的区别在于&lt;code&gt;ComputeTaskAdapter&lt;/code&gt;需要手动实现map()方法，而&lt;code&gt;ComputeTaskSplitAdapter&lt;/code&gt;可以自动映射任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ComputeTaskAdapter&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**ComputeTaskAdapter*/
    @RequestMapping(&quot;/taskMap&quot;)
    public @ResponseBody
    String taskMapTest(HttpServletRequest request, HttpServletResponse response) {
        /**ComputeTaskMap*/
        int cnt = ignite.compute().execute(MapExampleCharacterCountTask.class, &quot;Hello Ignite Enable World!&quot;);

        System.out.println(String.format(&quot;&amp;gt;&amp;gt;&amp;gt; Total number of characters in the phrase is %s.&quot;, cnt));

        return &quot;all executed.&quot;;
    }

    private static class MapExampleCharacterCountTask extends ComputeTaskAdapter&amp;lt;String, Integer&amp;gt; {
        /**节点映射*/
        @Override
        public Map&amp;lt;? extends ComputeJob, ClusterNode&amp;gt; map(List&amp;lt;ClusterNode&amp;gt; nodes, String arg) throws IgniteException {
            Map&amp;lt;ComputeJob, ClusterNode&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
            Iterator&amp;lt;ClusterNode&amp;gt; it = nodes.iterator();
            for (final String word : arg.split(&quot; &quot;)) {
                // If we used all nodes, restart the iterator.
                if (!it.hasNext()) {
                    it = nodes.iterator();
                }
                ClusterNode node = it.next();
                map.put(new ComputeJobAdapter() {
                    @Override
                    public Object execute() throws IgniteException {
                        System.out.println(&quot;-------------------------------------&quot;);
                        System.out.println(String.format(&quot;&amp;gt;&amp;gt;&amp;gt; Printing [%s] on this node from ignite job.&quot;, word));
                        return word.length();
                    }
                }, node);
            }
            return map;
        }
        /**结果汇总*/
        @Override
        public Integer reduce(List&amp;lt;ComputeJobResult&amp;gt; results) throws IgniteException {
            int sum = 0;
            for (ComputeJobResult res : results) {
                sum += res.&amp;lt;Integer&amp;gt;getData();
            }
            return sum;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-------------------------------------
&amp;gt;&amp;gt;&amp;gt; Printing [Ignite] on this node from ignite job.
-------------------------------------
&amp;gt;&amp;gt;&amp;gt; Printing [World!] on this node from ignite job.
&amp;gt;&amp;gt;&amp;gt; Total number of characters in the phrase is 23.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ComputeTaskSplitAdapter&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**ComputeTaskSplitAdapter*/
    @RequestMapping(&quot;/taskSplit&quot;)
    public @ResponseBody
    String taskSplitTest(HttpServletRequest request, HttpServletResponse response) {
        /**ComputeTaskSplitAdapter(自动映射) */
        int result = ignite.compute().execute(SplitExampleDistributedCompute.class, null);
        System.out.println(String.format(&quot;&amp;gt;&amp;gt;&amp;gt; result: [%s]&quot;, result));

        return &quot;all executed.&quot;;
    }

    private static class SplitExampleDistributedCompute extends ComputeTaskSplitAdapter&amp;lt;String, Integer&amp;gt; {

        @Override
        protected Collection&amp;lt;? extends ComputeJob&amp;gt; split(int gridSize, String arg) throws IgniteException {
            Collection&amp;lt;ComputeJob&amp;gt; jobs = new LinkedList&amp;lt;&amp;gt;();
            jobs.add(new ComputeJobAdapter() {
                @Override
                public Object execute() throws IgniteException {
//                    IgniteCache&amp;lt;Long, Student&amp;gt; cache = Ignition.ignite().cache(CacheKeyConstant.STUDENT);
                    IgniteCache&amp;lt;Long, BinaryObject&amp;gt; cache = Ignition.ignite().cache(CacheKeyConstant.STUDENT).withKeepBinary();
                    /**普通查询*/
                    String sql_query = &quot;name = ? and email = ?&quot;;
//                    SqlQuery&amp;lt;Long, Student&amp;gt; cSqlQuery = new SqlQuery&amp;lt;&amp;gt;(Student.class, sql_query);
                    SqlQuery&amp;lt;Long, BinaryObject&amp;gt; cSqlQuery = new SqlQuery&amp;lt;&amp;gt;(Student.class, sql_query);
                    cSqlQuery.setReplicatedOnly(true).setArgs(&quot;student_54&quot;, &quot;student_54gmail.com&quot;);
//                  List&amp;lt;Cache.Entry&amp;lt;Long, Student&amp;gt;&amp;gt; result = cache.query(cSqlQuery).getAll();
                    List&amp;lt;Cache.Entry&amp;lt;Long, BinaryObject&amp;gt;&amp;gt; result = cache.query(cSqlQuery).getAll();
                    System.out.println(&quot;--------------------&quot;);
                    result.stream().map(x -&amp;gt; {
                        Integer studId = x.getValue().field(&quot;studId&quot;);
                        String name = x.getValue().field(&quot;name&quot;);
                        return String.format(&quot;name=[%s], studId=[%s].&quot;, name, studId);
                    }).forEach(System.out::println);
                    System.out.println(String.format(&quot;the query size is [%s].&quot;, result.size()));
                    return result.size();
                }
            });
            return jobs;
        }

        @Override
        public Integer reduce(List&amp;lt;ComputeJobResult&amp;gt; results) throws IgniteException {
            int sum = results.stream().mapToInt(x -&amp;gt; x.&amp;lt;Integer&amp;gt;getData()).sum();
            return sum;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;--------------------
name=[student_54], studId=[54].
the query size is [1].
&amp;gt;&amp;gt;&amp;gt; result: [1]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MapReduce的局限性:&lt;/p&gt;
&lt;p&gt;MapReduce适合解决并行和批处理的场景，不适合串行，迭代和递归一类无法并行和分割任务的场景。&lt;/p&gt;
&lt;h5 id=&quot;分布式计算存在的问题以及注意点&quot;&gt;分布式计算存在的问题以及注意点&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;   在使用ignite的分布式计算功能的时候，如果用到了缓存, 并且缓存value不是平台类型(java基础类型)，则需要考虑反序列化的问题。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现有两种解决方案:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;em&gt;部署缓存实体类包到ignite节点&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缓存实体类得实现Serializable接口，&lt;u&gt;并且得指定serialVersionUID&lt;/u&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;serialVersionUID表示实体类的当前版本，每个实现Serializable接口的类都有，如果没有的设置该值，java序列化机制会帮你默认生成一个。最好在使用serializable接口时，设定serialVersionUID为某个值，不然当在传输的某一端修改实体类时，serialVersionUID会被虚拟机设置成一个新的值，造成两端的serialVersionUID不一致会发生异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Student implements Serializable {

    private static final long serialVersionUID = -5941489737545326242L;
    ....
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将实体类打包成普通jar包，并放在$IGNITE_HOME/libs/路径下面:&lt;/p&gt;
&lt;p&gt;&lt;u&gt;注意：打包的时候不能打包成spring-boot的可执行包，要打包成普通jar包，这样相关类才能正常加载。当然如果集群里的节点均为应用节点，则可以不用考虑这个问题。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/564309/201808/564309-20180823232807163-1113327437.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; IgniteCache&amp;lt;Long, BinaryObject&amp;gt; cache = ignite.cache(&quot;student&quot;).withKeepBinary();
 BinaryObject obj = cache.get(k);  //获取二进制对象
 String name = obj.&amp;lt;String&amp;gt;field(&quot;name&quot;);  //读取二进制对象属性值&amp;lt;使用field方法&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;并置计算&quot;&gt;3.并置计算：&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;affinityCall(...)&lt;/code&gt;和&lt;code&gt;affinityRun(...)&lt;/code&gt;方法使作业和缓存着数据的节点位于一处，换句话说，给定缓存名字和关系键，这些方法会试图在指定的缓存中定位键所在的节点，然后在那里执行作业。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;并置的两种类型以及区别:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;数据并置&lt;/td&gt;
&lt;td&gt;将相关的缓存数据并置到一起，确保其所有键会缓存在同一个节点上，避免节点间数据移动产生的网络开销。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;计算并置&lt;/td&gt;
&lt;td&gt;根据关系键和缓存名称，定位关系键所在节点，并在该节点执行作业单元。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/564309/201808/564309-20180823232826330-1445768498.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ComputeTestController.class&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**并置计算测试*/
    @RequestMapping(&quot;/affinity&quot;)
    public @ResponseBody
    String affinityTest(HttpServletRequest request, HttpServletResponse response) {

        /** affinityRun call */
        System.out.println(&quot;-----------affinityRun call-----------&quot;);
        IgniteCompute compute = ignite.compute();
//        IgniteCompute compute = ignite.compute(ignite.cluster().forRemotes());
        for(int key = 0; key &amp;lt; 100; key++) {
//            final long k = key;
            //生成随机k值
            final long k = IntStream.generate(() -&amp;gt; (int)(System.nanoTime() % 100)).limit(1).findFirst().getAsInt();
            compute.affinityRun(CacheKeyConstant.STUDENT, k, () -&amp;gt; {
                IgniteCache&amp;lt;Long, BinaryObject&amp;gt; cache = ignite.cache(CacheKeyConstant.STUDENT).withKeepBinary();
                BinaryObject obj = cache.get(k);
                if(obj!=null) {
                    System.out.println(String.format(&quot;Co-located[key= %s, value= %s]&quot;, k, obj.&amp;lt;String&amp;gt;field(&quot;name&quot;)));
                }
            });
        }

        IgniteCache&amp;lt;Long, BinaryObject&amp;gt; cache = ignite.cache(CacheKeyConstant.STUDENT).withKeepBinary();
        cache.forEach(lo -&amp;gt; compute.affinityRun(CacheKeyConstant.STUDENT, lo.getKey(), () -&amp;gt; {
            System.out.println(lo.getValue().&amp;lt;String&amp;gt;field(&quot;name&quot;));
        }));

        return &quot;all executed.&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;-----------affinityRun call-----------
student_495
student_496
student_498
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，ignite分布式计算完毕。&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 15:29:00 +0000</pubDate>
<dc:creator>堕落门徒</dc:creator>
<og:description>ignite分布式计算 在ignite中，有传统的MapReduce模型的分布式计算，也有基于分布式存储的并置计算，当数据分散到不同的节点上时，根据提供的并置键，计算会传播到数据所在的节点进行计算，再</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cord/p/9431867.html</dc:identifier>
</item>
<item>
<title>Java 多线程(二）之 Thread 优先级 - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9527226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9527226.html</guid>
<description>&lt;h2 id=&quot;thread-中线程优先级相关属性&quot;&gt;Thread 中线程优先级相关属性&lt;/h2&gt;
&lt;p&gt;每个线程均有优先级，在 Thread 中， 与优先级对应的属性如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 线程的优先级属性
 */
private int priority;
/**
 * 线程所能拥有的最大优先级.
 */
public final static int MIN_PRIORITY = 1;

/**
 * 线程默认的优先级.
 */
public final static int NORM_PRIORITY = 5;

/**
 * 线程所能拥有的最大优先级.
 */
public final static int MAX_PRIORITY = 10;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;相关函数&quot;&gt;相关函数&lt;/h2&gt;
&lt;p&gt;在此只讨论 Thread 类中的。&lt;/p&gt;
&lt;h3 id=&quot;优先级初始化&quot;&gt;优先级初始化&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize, AccessControlContext acc) {
    // ....
    this.priority = parent.getPriority();
    setPriority(priority);
   // ....
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;init() 函数对优先级进行了初始化。并调用 setPriority(priority) 函数进行设置。从中得知， 线程的优先级是继承于创建它的线程的。&lt;/p&gt;
&lt;h3 id=&quot;设置优先级&quot;&gt;设置优先级&lt;/h3&gt;
&lt;p&gt;在 init() 中， 除了给 this.priority 赋值， 还调用了 setPriority(priority) 函数， 因为在该函数内部还调用了一个 native 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final void setPriority(int newPriority) {
    ThreadGroup g;
    checkAccess();
    // 不能大于最大优先级 MAX_PRIORITY
    if (newPriority &amp;gt; MAX_PRIORITY || newPriority &amp;lt; MIN_PRIORITY) {
        throw new IllegalArgumentException();
    }
    if((g = getThreadGroup()) != null) {
        // 如比所属线程组的最大优先级还大， 则取线程组的最大优先级
        if (newPriority &amp;gt; g.getMaxPriority()) {
            newPriority = g.getMaxPriority();
        }
        setPriority0(priority = newPriority);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由代码可知， 设置的优先级不能大于最大优先级，也不能大于所在线程组的最高优先级&lt;/p&gt;
&lt;h3 id=&quot;获取优先级&quot;&gt;获取优先级&lt;/h3&gt;
&lt;p&gt;获取当前的优先级， 其实就是返回 priority 属性的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final int getPriority() {
    return priority;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上可知， 在 Thread 中， 线程的优先级有如下特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Java 线程的优先级从 1~10；&lt;/li&gt;
&lt;li&gt;Java 线程默认优先级是 5；&lt;/li&gt;
&lt;li&gt;Java 线程的优先级继承于创建它的线程。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;是不是感觉 2 和 3 有所矛盾呢？可以在后面的代码和结果中找答案。&lt;/p&gt;
&lt;h2 id=&quot;默认优先级&quot;&gt;默认优先级&lt;/h2&gt;
&lt;p&gt;先上代码来感受一下线程优先级的作用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadPriorityTest {
    class PrimeRun implements Runnable {
        public void run() {
            System.out.println(Thread.currentThread().getName() +&quot;::&quot;+
                    Thread.currentThread().getPriority());
            System.out.println(Thread.currentThread().getName() + &quot; Run begin&quot;);
            for (int i = 0; i &amp;lt; 10; i++) {
                System.out.println(Thread.currentThread().getName()+&quot;::&quot;+i);
            }
            System.out.println(Thread.currentThread().getName() + &quot; Run end&quot;);
        }
    }

    public void test(){
        System.out.println(Thread.currentThread().getName()+&quot; begin&quot;);
        Thread p4 = new Thread(new PrimeRun());
        Thread p6 = new Thread(new PrimeRun());
        p4.setName(&quot;P4&quot;);
        p6.setName(&quot;P6&quot;);
        p4.start();
        p6.start();
        System.out.println(Thread.currentThread().getName()+&quot; end&quot;);
    }

    public static void main(String[] args) {
        new ThreadPriorityTest().test();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 PrimeRun 类的 run() 方法中， 只是对 0 到 10 进行输出， 前面加上线程名字以识别。没有对线程进行设置， 按以上分析的 init() 方法可知， 优先级继承于 ThreadPriorityTest 中的优先级， 没进行设置优先级默认为 5。 输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180823231537178?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;输出&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 p4 和 p6 的线程优先级都是 5， 输出是无序的， P4 和 P6 交叉输出， 因此每次的结果都不一样。&lt;/p&gt;

&lt;p&gt;将线程中的优先级改一下， test() 函数变成如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void test(){
    System.out.println(Thread.currentThread().getName()+&quot; begin&quot;);
    Thread p4 = new Thread(new PrimeRun());
    Thread p6 = new Thread(new PrimeRun());
    p4.setName(&quot;P4&quot;);
    p4.setPriority(4);
    p6.setName(&quot;P6&quot;);
    p6.setPriority(6);
    p4.start();
    p6.start();
    System.out.println(Thread.currentThread().getName()+&quot; end&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在运行之后的输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/2018082323161222?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;设置优先级后输出&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到， P6 先于 P4 运行完。&lt;/p&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;但是（一般 「但是」 后面的东西都要注意）&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;优先级和操作系统及虚拟机版本相关。&lt;br/&gt;++优先级只是代表告知了 「线程调度器」该线程的重要度有多大。如果有大量线程都被堵塞，都在等候运&lt;br/&gt;行，调试程序会首先运行具有最高优先级的那个线程。然而，这并不表示优先级较低的线程不会运行（换言之，不会因为存在优先级而导致死锁）。若线程的优先级较低，只不过表示它被准许运行的机会小一些而已。++&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此， 在实际的编码时， 认为高优先级一定先于低优先级的线程执行， 最后会出问题的。&lt;/p&gt;
&lt;h2 id=&quot;优先级继承&quot;&gt;优先级继承&lt;/h2&gt;
&lt;p&gt;而关于特点 2 和 3 的区别， 我们在第一次 test() 时， P4 和 P6 的优先级都是 5， 我们将函数改一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public void test(){
    Thread.currentThread().setPriority(10);
    System.out.println(Thread.currentThread().getName()+&quot; begin&quot;);
    Thread p4 = new Thread(new PrimeRun());
    Thread p6 = new Thread(new PrimeRun());
    p4.setName(&quot;P4&quot;);
    p6.setName(&quot;P6&quot;);
    p4.start();
    p6.start();
    System.out.println(Thread.currentThread().getName()+&quot; end&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在创建 P4 和 P6 之前将当前线程的优先级设置为 10， 并在 run() 中去掉一些无关的输出， 最后输入如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180823231643934?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;继承优先级&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 15:23:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>介绍了 Thread 类相关的优先级</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9527226.html</dc:identifier>
</item>
<item>
<title>参考KOA，5步手写一款粗糙的web框架 - cherryvsun</title>
<link>http://www.cnblogs.com/cherryvenus/p/9527211.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cherryvenus/p/9527211.html</guid>
<description>&lt;p&gt;我经常在网上看到类似于&lt;code&gt;KOA VS express&lt;/code&gt;的文章，大家都在讨论哪一个好，哪一个更好。作为小白，我真心看不出他两who更胜一筹。我只知道，我只会跟着官方文档的start做一个DEMO，然后我就会宣称我会用KOA或者express框架了。但是几个礼拜后，我就全忘了。web框架就相当于一个工具，要使用起来，那是分分钟的事。毕竟人家写这个框架就是为了方便大家上手使用。但是这种生硬的照搬模式，不适合我这种理解能力极差的使用者。因此我决定扒一扒源码，通过官方API，自己写一个web框架，其实就相当于“抄”一遍源码，加上自己的理解，从而加深影响。不仅需要知其然，还要需要知其所以然。&lt;/p&gt;
&lt;p&gt;我这里选择KOA作为参考范本，只有一个原因！他非常的精简！核心只有4个js文件！基本上就是对createServer的一个封装。&lt;/p&gt;
&lt;p&gt;在开始解刨KOA之前，createServer的用法还是需要回顾下的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const http = require('http');
let app=http.createServer((req, res) =&amp;gt; {
    //此处省略其他操作
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.body=&quot;我是createServer&quot;;
    res.end('okay');
});
app.listen(3000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回顾了createServer，接下来就是解刨KOA的那4个文件了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;application.js
&lt;ul&gt;&lt;li&gt;这个js主要就是对createServer的封装，其中一个最主要的目的就是将他的callback分离出来，让我们可以通过&lt;code&gt;app.use(callback);&lt;/code&gt;来调用，其中&lt;code&gt;callback&lt;/code&gt;大概就是令大家闻风丧胆的中间件（middleWare）了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;request.js
&lt;ul&gt;&lt;li&gt;封装createServer中返回的req，主要用于读写属性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;response.js
&lt;ul&gt;&lt;li&gt;封装createServer中返回的res，主要用于读写属性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;context.js
&lt;ul&gt;&lt;li&gt;这个文件就很重要了，它主要是封装了request和response，用于框架和中间件的沟通。所以他叫上下文，也是有道理的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了～开始写框架咯～&lt;/p&gt;
&lt;p&gt;&lt;em&gt;仅分析大概思路，分析KOA的原理，所以并不是100%重现KOA。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本文github地址：&lt;a href=&quot;https://github.com/nanaSun/myHTTP&quot;&gt;点我&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;step1-封装http.createserver&quot;&gt;step1 封装&lt;code&gt;http.createServer&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;先写一个初始版的&lt;code&gt;application&lt;/code&gt;，让程序先跑起来。这里我们仅仅实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;封装&lt;code&gt;http.createServer&lt;/code&gt;到myhttp的类&lt;/li&gt;
&lt;li&gt;将回调独立出来&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen&lt;/code&gt;方法可以直接用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;step1/application.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let http=require(&quot;http&quot;)
class myhttp{
    handleRequest(req,res){
        console.log(req,res)
    }
    listen(...args){
        // 起一个服务
        let server = http.createServer(this.handleRequest.bind(this));
        server.listen(...args)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这边的&lt;code&gt;listen&lt;/code&gt;完全和&lt;code&gt;server.listen&lt;/code&gt;的用法一摸一样，就是传递了下参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;友情链接&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://nodejs.cn/api/http.html#http_server_listen&quot;&gt;&lt;code&gt;server.listen&lt;/code&gt;的API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6解构赋值&lt;code&gt;...&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step1/testhttp.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let myhttp=require(&quot;./application&quot;)
let app= new myhttp()
app.listen(3000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;testhttp.js&lt;/code&gt;，结果打印出了&lt;code&gt;req&lt;/code&gt;和&lt;code&gt;res&lt;/code&gt;就成功了~&lt;/p&gt;
&lt;h2 id=&quot;step2-封装原生req和res&quot;&gt;step2 封装原生req和res&lt;/h2&gt;
&lt;p&gt;这里我们需要做的封装，所需只有两步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读取（get）req和res的内容&lt;/li&gt;
&lt;li&gt;修改（set）res的内容&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;step2/request.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let request={
    get url(){
        return this.req.url
    }
}
module.exports=request&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;step2/response.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let response={
    get body(){
        return this.res.body
    },
    set body(value){
        this.res.body=value
    }
}
module.exports=response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果po上代码，就是这么简单，需要的属性可以自己加上去。那么问题来这个&lt;code&gt;this&lt;/code&gt;指向哪里？？代码是很简单，但是这个指向，并不简单。&lt;/p&gt;
&lt;p&gt;回到我们的&lt;code&gt;application.js&lt;/code&gt;，让这个&lt;code&gt;this&lt;/code&gt;指向我们的myhttp的实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step2/application.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class myhttp{
    constructor(){
        this.request=Object.create(request)
        this.response=Object.create(response)
    }
    handleRequest(req,res){
        let request=Object.create(this.request)
        let response=Object.create(this.response)
        request.req=req
        request.request=request
        response.req=req
        response.response=response
        console.log(request.headers.host,request.req.headers.host,req.headers.host)
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处，我们用&lt;code&gt;Object.create&lt;/code&gt;拷贝了一个副本，然后把request和response分别挂上，我们可以通过最后的一个测试看到，我们可以直接通过&lt;code&gt;request.headers.host&lt;/code&gt;访问我们需要的信息，而可以不用通过&lt;code&gt;request.req.headers.host&lt;/code&gt;这么长的一个指令。这为我们下一步，将&lt;code&gt;request&lt;/code&gt;和&lt;code&gt;response&lt;/code&gt;挂到&lt;code&gt;context&lt;/code&gt;打了基础。&lt;/p&gt;
&lt;h2 id=&quot;step3-context闪亮登场&quot;&gt;step3 &lt;code&gt;context&lt;/code&gt;闪亮登场&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;context&lt;/code&gt;的功能，我对他没有其他要求，就可以直接&lt;code&gt;context.headers.host&lt;/code&gt;，而不用&lt;code&gt;context.request.headers.host&lt;/code&gt;,但是我不可能每次新增需要的属性，都去写一个get/set吧？于是&lt;code&gt;Object.defineProperty&lt;/code&gt;这个神操作来了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step3/content.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let context = {
}
//可读可写
function access(target,property){
   Object.defineProperty(context,property,{
        get(){
            return this[target][property]
        },
        set(value){
            this[target][property]=value
        }
   })
}
//只可读
function getter(target,property){
   Object.defineProperty(context,property,{
        get(){
            return this[target][property]
        }
   })
}
getter('request','headers')
access('response','body')
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就可以方便地进行定义数据了，不过需要注意地是，&lt;code&gt;Object.defineProperty&lt;/code&gt;地对象只能定义一次，不能多次定义，会报错滴。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step3/application.js&lt;/strong&gt;&lt;br/&gt;接下来就是连接&lt;code&gt;context&lt;/code&gt;和&lt;code&gt;request&lt;/code&gt;和&lt;code&gt;response&lt;/code&gt;了，新建一个&lt;code&gt;createContext&lt;/code&gt;，将&lt;code&gt;response&lt;/code&gt;和&lt;code&gt;request&lt;/code&gt;颠来倒去地挂到&lt;code&gt;context&lt;/code&gt;就可了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class myhttp{
    constructor(){
        this.context=Object.create(context)
        ...
    }
    createContext(req,res){
        let ctx=Object.create(this.context)
        let request=Object.create(this.request)
        let response=Object.create(this.response)
        ctx.request=request
        ctx.response=response
        ctx.request.req=ctx.req=req
        ctx.response.res=ctx.res=res
        return ctx
    }
    handleRequest(req,res){
        let ctx=this.createContext(req,res)
        console.log(ctx.headers)
        ctx.body=&quot;text&quot;
        console.log(ctx.body,res.body)
        res.end(ctx.body);
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上3步终于把准备工作做好了，接下来进入正题。😭&lt;br/&gt;&lt;em&gt;友情链接：&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;step4-实现use&quot;&gt;step4 实现&lt;code&gt;use&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;这里我需要完成两个功能点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;use&lt;/code&gt;可以多次调用，中间件middleWare按顺序执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use&lt;/code&gt;中传入&lt;code&gt;ctx&lt;/code&gt;上下文，供中间件middleWare调用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;想要多个中间件执行，那么就建一个数组，将所有地方法都保存在里头，然后等到执行的地时候forEach一下，逐个执行。传入的&lt;code&gt;ctx&lt;/code&gt;就在执行的时候传入即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step4/application.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class myhttp{
    constructor(){
        this.middleWares=[]
        ...
    }
    use(callback){
        this.middleWares.push(callback)
        return this;
    }
    ...
    handleRequest(req,res){
        ...
        this.middleWares.forEach(m=&amp;gt;{
            m(ctx)
        })
        ...
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处在&lt;code&gt;use&lt;/code&gt;中加了一个小功能，就是让use可以实现链式调用，直接返回&lt;code&gt;this&lt;/code&gt;即可，因为&lt;code&gt;this&lt;/code&gt;就指代了&lt;code&gt;myhttp&lt;/code&gt;的实例&lt;code&gt;app&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step4/testhttp.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
app.use(ctx=&amp;gt;{
    console.log(1)
}).use(ctx=&amp;gt;{
    console.log(2)
})
app.use(ctx=&amp;gt;{
    console.log(3)
})
...&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;step5-实现中间件的异步执行&quot;&gt;&lt;strong&gt;step5 实现中间件的异步执行&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;任何程序只要加上了异步之后，感觉难度就蹭蹭蹭往上涨。&lt;/p&gt;
&lt;p&gt;这里要分两点来处理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;use&lt;/code&gt;中中间件的异步执行&lt;/li&gt;
&lt;li&gt;中间件的异步完成后&lt;code&gt;compose&lt;/code&gt;的异步执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;首先是&lt;code&gt;use&lt;/code&gt;中的异步&lt;/em&gt;&lt;br/&gt;如果我需要中间件是异步的，那么我们可以利用async/await这么写，返回一个promise&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app.use(async (ctx,next)=&amp;gt;{
    await next()//等待下方完成后再继续执行
    ctx.body=&quot;aaa&quot;
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是promise，那么我就不能按照普通的程序foreach执行了，我们需要一个完成之后在执行另一个，那么这边我们就需要将这些函数组合放入另一个方法&lt;code&gt;compose&lt;/code&gt;中进行处理，然后返回一个promise，最后来一个&lt;code&gt;then&lt;/code&gt;，告诉程序我执行完了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;handleRequest(req,res){
    ....
    this.compose(ctx,this.middleWares).then(()=&amp;gt;{
        res.end(ctx.body)
    }).catch(err=&amp;gt;{
        console.log(err)
    })
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么compose怎么写呢？&lt;/p&gt;
&lt;p&gt;首先这个middlewares需要一个执行完之后再进行下一个的执行，也就是回调。其次compose需要返回一个promise，为了告诉最后我执行完毕了。&lt;/p&gt;
&lt;p&gt;第一版本compose，简易的回调，像这样。不过这个和&lt;code&gt;foreach&lt;/code&gt;并无差别。这里的&lt;code&gt;fn&lt;/code&gt;就是我们的中间件，&lt;code&gt;()=&amp;gt;dispatch(index+1)&lt;/code&gt;就是&lt;code&gt;next&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;compose(ctx,middlewares){
    function dispatch(index){
        console.log(index)
        if(index===middlewares.length) return;
        let fn=middlewares[index]
        fn(ctx,()=&amp;gt;dispatch(index+1));
    }
    dispatch(0)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二版本compose，我们加上async/await，并返回promise，像这样。不过这个和&lt;code&gt;foreach&lt;/code&gt;并无差别。&lt;code&gt;dispatch&lt;/code&gt;一定要返回一个promise。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;compose(ctx,middlewares){
    async function dispatch(index){
        console.log(index)
        if(index===middlewares.length) return;
        let fn=middlewares[index]
        return await fn(ctx,()=&amp;gt;dispatch(index+1));
    }
    return dispatch(0)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;return await fn(ctx,()=&amp;gt;dispatch(index+1));&lt;/code&gt;注意此处，这就是为什么我们需要在&lt;code&gt;next&lt;/code&gt;前面加上await才能生效？作为promise的&lt;code&gt;fn&lt;/code&gt;已经执行完毕了，如果不等待后方的promise，那么就直接&lt;code&gt;then&lt;/code&gt;了，后方的&lt;code&gt;next&lt;/code&gt;就自生自灭了。所以如果是异步的，我们就需要在中间件上加上&lt;code&gt;async/await&lt;/code&gt;以保证&lt;code&gt;next&lt;/code&gt;执行完之后再返回上一个&lt;code&gt;promise&lt;/code&gt;。无法理解？😷了？我们看几个例子。&lt;/p&gt;
&lt;p&gt;具体操作如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function makeAPromise(ctx){
    return new Promise((rs,rj)=&amp;gt;{
        setTimeout(()=&amp;gt;{
            ctx.body=&quot;bbb&quot;
            rs()
        },1000)
    })
}
//如果下方有需要执行的异步操作
app.use(async (ctx,next)=&amp;gt;{
    await next()//等待下方完成后再继续执行
    ctx.body=&quot;aaa&quot;
})
app.use(async (ctx,next)=&amp;gt;{
    await makeAPromise(ctx).then(()=&amp;gt;{next()})
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码先执行&lt;code&gt;ctx.body=&quot;bbb&quot;&lt;/code&gt;再执行&lt;code&gt;ctx.body=&quot;aaa&quot;&lt;/code&gt;，因此打印出来是&lt;code&gt;aaa&lt;/code&gt;。如果我们反一反：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app.use(async (ctx,next)=&amp;gt;{
    ctx.body=&quot;aaa&quot;
    await next()//等待下方代码完成
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么上述代码就先执行&lt;code&gt;ctx.body=&quot;aaa&quot;&lt;/code&gt;再执行&lt;code&gt;ctx.body=&quot;bb&quot;&lt;/code&gt;，因此打印出来是&lt;code&gt;bbb&lt;/code&gt;。&lt;br/&gt;这个时候我们会想，既然我这个中间件不是异步的，那么是不是就可以不用加上async/await了呢？实践出真理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app.use((ctx,next)=&amp;gt;{
    ctx.body=&quot;aaa&quot;
    next()//不等了
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么程序就不会等后面的异步结束就先结束了。因此如果有异步的需求，尤其是需要靠异步执行再进行下一步的的操作，就算本中间件没有异步需求，也要加上async/await。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;终于写完了，感觉脑细胞死了不少，接下来我去研究router和ejs，等这一块加入我的web框架之后，就很完美了~&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 15:16:00 +0000</pubDate>
<dc:creator>cherryvsun</dc:creator>
<og:description>我经常在网上看到类似于 的文章，大家都在讨论哪一个好，哪一个更好。作为小白，我真心看不出他两who更胜一筹。我只知道，我只会跟着官方文档的start做一个DEMO，然后我就会宣称我会用KOA或者exp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cherryvenus/p/9527211.html</dc:identifier>
</item>
</channel>
</rss>