<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>图解高内聚与低耦合 - 大道方圆</title>
<link>http://www.cnblogs.com/xdecode/p/9393885.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xdecode/p/9393885.html</guid>
<description>&lt;h3&gt;模块&lt;/h3&gt;
&lt;p&gt;模块就是从逻辑上将系统分解为更细微的部分, 分而治之, 复杂问题拆解为若干简单问题, 逐个解决.&lt;/p&gt;
&lt;p&gt;耦合主要描述模块之间的关系, 内聚主要描述模块内部. 模块的粒度可大可小, 可以是函数, 类, 功能块等等.&lt;/p&gt;
&lt;h3&gt;耦合&lt;/h3&gt;
&lt;p&gt;模块之间存在依赖, 导致改动可能会互相影响, 关系越紧密, 耦合越强, 模块独立性越差.&lt;/p&gt;
&lt;p&gt;比如模块A直接操作了模块B中数据, 则视为强耦合, 若A只是通过数据与模块B交互, 则视为弱耦合.&lt;/p&gt;
&lt;p&gt;独立的模块便于扩展, 维护, 写单元测试, 如果模块之间重重依赖, 会极大降低开发效率. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201808/1285727-20180814163526953-948810994.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 内聚&lt;/h3&gt;
&lt;p&gt;模块内部的元素, 关联性越强, 则内聚越高, 模块单一性更强. 一个模块应当尽可能独立完成某个功能, &lt;/p&gt;
&lt;p&gt;如果有各种场景需要被引入到当前模块, 代码质量将变得非常脆弱, 这种情况建议拆分为多个模块.&lt;/p&gt;
&lt;p&gt;低内聚的模块代码, 不管是维护, 扩展还是重构都相当麻烦, 难以下手.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201808/1285727-20180814155818504-403677563.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;接口设计原则&lt;/h3&gt;
&lt;p&gt;好的接口应当满足设计模式六大原则, 很多设计模式, 框架都是基于高内聚低耦合这个出发点的.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;单一职责原则: 一个类只负责一个功能领域中的相应职责.&lt;/li&gt;
&lt;li&gt;开闭原则: 一个软件实体应当对扩展开放，对修改关闭.&lt;/li&gt;
&lt;li&gt;里氏代换原则: 所有引用基类（父类）的地方必须能透明地使用其子类的对象.&lt;/li&gt;
&lt;li&gt;依赖倒转原则: 抽象不应该依赖于细节, 细节应当依赖于抽象. 换言之, 要针对接口编程, 而不是针对实现编程.&lt;/li&gt;
&lt;li&gt;接口隔离原则: 使用多个专门的接口, 而不使用单一的总接口, 即客户端不应该依赖那些它不需要的接口.&lt;/li&gt;
&lt;li&gt;迪米特法则: 一个软件实体应当尽可能少地与其他实体发生相互作用, 例如外观模式, 对外暴露统一接口.&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;举几个栗子&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201808/1285727-20180814160557707-701511251.png&quot; alt=&quot;&quot; width=&quot;41&quot; height=&quot;40&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;外观模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为系统中多个子系统提供一致的对外调用, 对客户端隐藏子系统细节, 降低其与子系统的耦合.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201808/1285727-20180814225922436-957043812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;桥接模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JDBC中的把面向厂商的接口(Driver)和面向使用者的API(DriverManager)做了拆分隔离.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开发者只需要关注JDBC API, 无需关注不同数据库Driver接口实现&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         Class.forName(&quot;com.mysql.jdbc.Driver&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         Connection conn = DriverManager.getConnection(url, username, password);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201808/1285727-20180814230918572-785179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适配器模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引入第三方库(hibernate, log4j), 不应该直接在代码中继承或者使用其实体类.&lt;/p&gt;
&lt;p&gt;需要抽出上层统一接口, 然后增加实现类, 对外暴露接口.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代码与log4j强耦合, 不推荐&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         org.apache.log4j.Logger.getRootLogger().info(&quot;info&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 底层可以随意更换log框架&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         FRLoggerFactory.getLogger().info(&quot;info&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201808/1285727-20180814231139308-1798143042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 14 Aug 2018 23:07:00 +0000</pubDate>
<dc:creator>大道方圆</dc:creator>
<og:description>模块 模块就是从逻辑上将系统分解为更细微的部分, 分而治之, 复杂问题拆解为若干简单问题, 逐个解决. 耦合主要描述模块之间的关系, 内聚主要描述模块内部. 模块的粒度可大可小, 可以是函数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xdecode/p/9393885.html</dc:identifier>
</item>
<item>
<title>NQA与静态路由联动 - 流昔岁月</title>
<link>http://www.cnblogs.com/lxsy/p/9475488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lxsy/p/9475488.html</guid>
<description>&lt;p&gt;一、NQA的原理及应用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 定义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　网络质量分析NQA，是一种实时的网络性能探测和分析技术，能够对网络抖动、丢包率、网络时延等信息进行分析和统计，实时监控网络的QoS，同时也能让管理者快速定位故障点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用NQA的测试结果，用户可以：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.及时了解网络的性能状况，针对不同的网络性能，进行相应的处理；&lt;/p&gt;



&lt;p&gt;NQA还提供了与Track和应用模块联动的功能，实时监控网络状态的变化，及时进行相应的处理，从而避免通信的中断或服务质量的降低。&lt;span class=&quot;sup--normal&quot; data-sup=&quot;1&quot;&gt; &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NQA具有以下几个特点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.支持多种测试类型&lt;/p&gt;

&lt;div class=&quot;para&quot; readability=&quot;10.818930041152&quot;&gt;　　传统的Ping功能是使用&lt;a href=&quot;https://baike.baidu.com/item/ICMP/572452&quot; target=&quot;_blank&quot; data-lemmaid=&quot;572452&quot;&gt;ICMP&lt;/a&gt;（Internet Control Message Protocol，互联网控制报文协议）测试数据包在本端和指定目的端之间的往返时间。NQA是对Ping功能的扩展和增强，它提供了更多的功能。&lt;/div&gt;

&lt;div class=&quot;para&quot; readability=&quot;5.7132352941176&quot;&gt;　　目前NQA支持11种测试类型：&lt;span&gt;ICMP-echo、&lt;a href=&quot;https://baike.baidu.com/item/DHCP&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;DHCP&lt;/span&gt;&lt;/a&gt;、DNS、&lt;a href=&quot;https://baike.baidu.com/item/FTP&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;FTP&lt;/span&gt;&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/HTTP&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;/a&gt;、UDPjitter、&lt;a href=&quot;https://baike.baidu.com/item/SNMP&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;SNMP&lt;/span&gt;&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/TCP&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/UDP&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;UDP&lt;/span&gt;&lt;/a&gt;-echo、Voice&lt;/span&gt;和&lt;a href=&quot;https://baike.baidu.com/item/DLSw/927541&quot; target=&quot;_blank&quot; data-lemmaid=&quot;927541&quot;&gt;DLSw&lt;/a&gt;测试。&lt;/div&gt;

&lt;p&gt;2.支持多测试组并发&lt;/p&gt;

&lt;p&gt;　　NQA模块支持多个测试组并发，用户可以根据需求手工配置并发个数。但对于DHCP测试，同一时刻只允许有一个测试组进行测试。&lt;/p&gt;

&lt;p&gt;3. 支持联动功能&lt;/p&gt;

&lt;div class=&quot;para&quot; readability=&quot;7.1504424778761&quot;&gt;　　联动功能是指NQA提供探测功能，把探测结果通知其他模块，其他模块再根据探测结果进行相应处理的功能。目前实现了&lt;span&gt;与VRRP、&lt;a href=&quot;https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/100778&quot; target=&quot;_blank&quot; data-lemmaid=&quot;100778&quot;&gt;&lt;span&gt;静态路由&lt;/span&gt;&lt;/a&gt;、备份中心&lt;/span&gt;和&lt;a href=&quot;https://baike.baidu.com/item/%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1/7344539&quot; target=&quot;_blank&quot; data-lemmaid=&quot;7344539&quot;&gt;策略路由&lt;/a&gt;的联动。&lt;/div&gt;
&lt;p&gt;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;NQA联动主要应用在网络要求不高的场景使用，像企业到运营商的一般都是走静态路由，像这种网络一般都是秒级以上的；数据中心这种要求高的场景用BFD这种毫秒级的联动方法是比较合适的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;timeout、probe-count、frequency&lt;/span&gt;和&lt;span&gt;interval&lt;/span&gt;命令之间有制约关系，所以配置改四条命令时需要注意命令取值及相互配合，否则会导致测试失败。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于质量较差、传输速率不高的网络，为了保证nqa探测报文能够收到回应，需要加大发送探测报文的超时时间&lt;span&gt;timeout&lt;/span&gt;取值。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对于不可靠网络，可将探测次数probe-count取值设置相对大些&lt;/span&gt;。因为可能发送较大次数的探测报文才能获得探测成功。&lt;/li&gt;
&lt;li&gt;发送报文的时间间隔&lt;span&gt;interval取值必须大于timeout取值&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;自动执行测试的时间间隔&lt;span&gt;frequency取值必须大于等于interval和probe-count取值的乘积&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;nqa test-instance admin CNC&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　test-type icmp                                   //配置nqa测试类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　destination-address ipv4 61.1.1.2     //配置nqa测试目的地址（路由可达即可）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　frequency 6                                        //配置nqa测试试例的测试周期&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　interval seconds 3                              //配置nqa测试报文的发送间隔&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　timeout 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　probe-count 2                                    //配置一次测试的探针数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　start now&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 二、实验拓扑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1178373/201808/1178373-20180814161620724-272170961.png&quot; alt=&quot;&quot; width=&quot;729&quot; height=&quot;294&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、组网要求&lt;/p&gt;
&lt;p&gt;1. 双线nat接入&lt;/p&gt;
&lt;p&gt;2.实现访问联通走联通出口，访问电信走电信出口&lt;/p&gt;
&lt;p&gt;3.通过NQA 对链路进行监测，实现任意出口故障，不影响用户上网（如果联通故障，原本走联通的流量走电信，反之亦然）&lt;/p&gt;
&lt;p&gt; 四、配置&lt;/p&gt;
&lt;p&gt;①运营商基础配置&lt;/p&gt;
&lt;p&gt;AR2:&lt;/p&gt;
&lt;p&gt;interface GigabitEthernet0/0/0&lt;br/&gt;ip address 61.1.1.2 255.255.255.248&lt;br/&gt;#&lt;br/&gt;interface GigabitEthernet0/0/1&lt;br/&gt;ip address 198.1.1.1 255.255.255.252&lt;br/&gt;#&lt;/p&gt;
&lt;p&gt;interface LoopBack0&lt;br/&gt;ip address 100.1.1.1 255.255.255.255&lt;br/&gt;#&lt;br/&gt;ospf 1&lt;br/&gt;area 0.0.0.0&lt;br/&gt;network 61.1.1.0 0.0.0.7&lt;br/&gt;network 100.1.1.1 0.0.0.0&lt;br/&gt;network 198.1.1.0 0.0.0.3&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------&lt;/p&gt;
&lt;p&gt;AR3:&lt;/p&gt;
&lt;p&gt;interface GigabitEthernet0/0/0&lt;br/&gt;ip address 198.1.1.2 255.255.255.252&lt;br/&gt;#&lt;br/&gt;interface GigabitEthernet0/0/1&lt;br/&gt;ip address 202.1.1.2 255.255.255.0&lt;br/&gt;#&lt;br/&gt;interface LoopBack0&lt;br/&gt;ip address 200.2.2.1 255.255.255.255&lt;br/&gt;#&lt;br/&gt;ospf 1&lt;br/&gt;area 0.0.0.0&lt;br/&gt;network 198.1.1.0 0.0.0.3&lt;br/&gt;network 200.2.2.1 0.0.0.0&lt;br/&gt;network 202.1.1.0 0.0.0.7&lt;/p&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1178373/201808/1178373-20180815001957431-647171137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;②用户配置：&lt;/p&gt;
&lt;p&gt;AR1:&lt;/p&gt;
&lt;p&gt;1)基础配置&lt;/p&gt;
&lt;p&gt;interface GigabitEthernet0/0/0&lt;br/&gt;ip address 61.1.1.1 255.255.255.248&lt;br/&gt;#&lt;br/&gt;interface GigabitEthernet0/0/1&lt;br/&gt;ip address 202.1.1.1 255.255.255.248&lt;br/&gt;#&lt;br/&gt;interface GigabitEthernet0/0/2&lt;br/&gt;ip address 10.1.1.1 255.255.255.0&lt;/p&gt;
&lt;p&gt; 2)NAT配置&lt;/p&gt;
&lt;p&gt;#创建内网源地址acl&lt;/p&gt;
&lt;p&gt;acl number 2000 &lt;/p&gt;
&lt;p&gt;rule 5 permit source 10.1.1.0 0.0.0.255&lt;/p&gt;

&lt;p&gt;#调用acl进行nat&lt;/p&gt;
&lt;p&gt;interface GigabitEthernet0/0/0&lt;br/&gt;ip address 61.1.1.1 255.255.255.248&lt;br/&gt;&lt;span&gt;nat outbound 2000&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;interface GigabitEthernet0/0/1&lt;br/&gt;ip address 202.1.1.1 255.255.255.248&lt;br/&gt;&lt;span&gt;nat outbound 2000&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3)配置NQA&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#联通nqa实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;nqa test-instance admin CNC&lt;br/&gt;test-type icmp&lt;br/&gt;destination-address ipv4 61.1.1.2&lt;br/&gt;frequency 6&lt;br/&gt;interval seconds 3&lt;br/&gt;timeout 2&lt;br/&gt;probe-count 2&lt;br/&gt;start now&lt;/p&gt;
&lt;p&gt;#电信nqa实例&lt;/p&gt;
&lt;p&gt;nqa test-instance admin CTC&lt;br/&gt;test-type icmp&lt;br/&gt;destination-address ipv4 202.1.1.2&lt;br/&gt;frequency 6&lt;br/&gt;timeout 2&lt;br/&gt;probe-count 2&lt;br/&gt;start now&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1178373/201808/1178373-20180815003022948-1475028669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过“dis nqa results test-instance admin CNC” 查看Completion:success  ，说明探测成功了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;#配置静态路由联动&lt;/p&gt;

&lt;p&gt;ip route-static 100.1.1.0 255.255.255.0 61.1.1.2 track nqa admin CNC   //联通的流量走联通，并进行NQA联动&lt;br/&gt;ip route-static 200.1.1.0 255.255.255.0 202.1.1.2 track nqa admin CTC //电信的流量走联通，并进行NQA联动&lt;/p&gt;
&lt;p&gt;ip route-static 0.0.0.0 0.0.0.0 202.1.1.2 track nqa admin CTC    //走电信&lt;br/&gt;ip route-static 0.0.0.0 0.0.0.0 61.1.1.2 preference 61 track nqa admin CNC  //走联通&lt;br/&gt;上面两台默认路由，如果走电信的断了，走电信的默认路由会消失；如果走联通的断了也是一样，这样两条链路单独断那条都不会断网；两条默认路由为了不出现负载分担的情况，降低其中一条的优先级。&lt;/p&gt;

&lt;p&gt;五、测试&lt;/p&gt;
&lt;p&gt;断开AR3和交换机LSW2的连线，丢几个包后恢复正常，说明流量已经切换到了联通去了；链路恢复后不会出现丢包现象&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1178373/201808/1178373-20180815010421897-507022554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;断电信之后的路由表：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1178373/201808/1178373-20180815012711707-1859924052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;断联通之后的路由表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1178373/201808/1178373-20180815013053845-85672622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 14 Aug 2018 17:16:00 +0000</pubDate>
<dc:creator>流昔岁月</dc:creator>
<og:description>一、NQA的原理及应用 定义： 网络质量分析NQA，是一种实时的网络性能探测和分析技术，能够对网络抖动、丢包率、网络时延等信息进行分析和统计，实时监控网络的QoS，同时也能让管理者快速定位故障点。 利</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lxsy/p/9475488.html</dc:identifier>
</item>
<item>
<title>用树莓派做一个离线下载机 - Summer7C</title>
<link>http://www.cnblogs.com/Summer7C/p/9478773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Summer7C/p/9478773.html</guid>
<description>&lt;p&gt;用树莓派可以做很多有意思的东西，它相当于一个小型的电脑，装上系统完全可以作为一个家用的小型服务器。&lt;/p&gt;
&lt;p&gt;通过这个小型服务器，可以实现一个“离线”下载机。不过这里的离线下载不是真的离线，因为树莓派还是在线的——既然树莓派当做了小型服务器，那应该长期保持在线状态了——不过由于树莓派的功耗很小，而且占用空间也很小，所以当做家用服务器还是很可以的。&lt;/p&gt;
&lt;p&gt;这个树莓派的离线下载器是使用aria搭建的，aria是一个开源的多线程下载工具，可以完成很多种类的下载任务。通过aria2我们就可以很轻松的完成下载任务，包括wget这类工具做不了的。&lt;/p&gt;
&lt;p&gt;首先是安装aria2，我们可以通过aria2的官网下载安装：http://aria2.github.io/&lt;/p&gt;
&lt;p&gt;同样，如果你的树莓派和我用的一个系统——debian，也可以使用debian的命令安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$&lt;span&gt;sudo&lt;/span&gt; apt &lt;span&gt;install&lt;/span&gt; aria2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只需要等待片刻，就可以安装成功。&lt;/p&gt;
&lt;p&gt;之后，我们就可以使用aria2进行下载任务，aria2的下载命令很简单，例如，我们想要下载一个mp3,则只用输入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$aria2c XXXX/abc.mp3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体的aria2的使用方式，我们可以参考aria2的官方文档：http://aria2.github.io/manual/en/html/index.html&lt;/p&gt;
&lt;p&gt;这样就可以了吗？当然不行，这还不够一个离线下载工具的易用性。&lt;/p&gt;
&lt;p&gt;接下来就是给aria2安装图形界面，aria2官方推荐有很多图形界面，并且，aria2也提供了rpc接口可以供我们进行调用，下面我们就使用一个开源的界面给aria2安装图形工具。&lt;/p&gt;
&lt;p&gt;我们选用的图形工具是Aria2 WebUI，这个工具可以在aria2的官网上找到，我们进入它的github，把项目clone下来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/ziahamza/webui-aria2.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拿到代码后，只用输入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
node node-server.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图形界面就可以跑起来了，不过在此之前你需要安装nodejs环境，通过以下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$&lt;span&gt;sudo&lt;/span&gt; apt &lt;span&gt;install&lt;/span&gt; nodejs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样跑起来并不能使用，我们需要先配置以下启动项，将aria2 webui下的configconfiguration.js打开，将&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
host: location.protocol.startsWith('http') ? location.hostname : 'localhost'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一行改成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
host: location.protocol.startsWith('http') ? location.hostname : '0.0.0.0'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不然在服务器之外没办法访问的。&lt;/p&gt;
&lt;p&gt;然后我们可以在其他主机上输入树莓派的内网IP地址，比如树莓派的IP位192.168.1.122，在和树莓派的路由器同意网段的主机上，访问192.168.1.122:8888，我们就可以看到web页面了。&lt;/p&gt;
&lt;p&gt;但是，这个只是一个页面而已，这个页面和aria2是通过rpc交互的，所以我们需要启动aria2的rpc：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
aria2c --enable-rpc --rpc-listen-all
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们的图形界面就可以访问aria2的服务了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789559/201808/789559-20180814232333513-71159176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就访问到了界面，如果平时我们有什么大文件需要下载的时候，我们就可以睡觉前点击下载，然后把电脑关了，第二天起床就下载到了树莓派上了。接下来我们可以将树莓派的数据通过路由器内网下载到电脑硬盘，这个过程就很快了，如果想要一个简单的方式建立一个http文件访问的话，我们可以在aria2的下载目录下，使用python3的命令快速建立一个http访问文件，进行下载：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
python3 -m http.server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789559/201808/789559-20180814232751248-529928284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击文件，就可以快速下载了，感觉是不是很棒呢？&lt;/p&gt;

</description>
<pubDate>Tue, 14 Aug 2018 15:29:00 +0000</pubDate>
<dc:creator>Summer7C</dc:creator>
<og:description>用树莓派可以做很多有意思的东西，它相当于一个小型的电脑，装上系统完全可以作为一个家用的小型服务器。 通过这个小型服务器，可以实现一个“离线”下载机。不过这里的离线下载不是真的离线，因为树莓派还是在线的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Summer7C/p/9478773.html</dc:identifier>
</item>
<item>
<title>webpack4.0各个击破（1）—— html部分 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9478777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9478777.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;作为前端最火的构建工具，是前端自动化工具链&lt;strong&gt;最重要的部分&lt;/strong&gt;，使用门槛较高。本系列是笔者自己的学习记录，比较基础，希望通过&lt;strong&gt;问题 + 解决方式&lt;/strong&gt;的模式，以前端构建中遇到的具体需求为出发点，学习&lt;code&gt;webpack&lt;/code&gt;工具中相应的处理办法。（本篇中的参数配置及使用方式均基于&lt;code&gt;webpack4.0版本&lt;/code&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/14/70e37037050f4cceaf20683f1e778f67.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一.-webpack中的html&quot;&gt;一. webpack中的html&lt;/h2&gt;
&lt;p&gt;对于浏览器而言，&lt;code&gt;html&lt;/code&gt;文件是用户访问的入口点，也是所有资源的挂载点，所有资源都是通过&lt;code&gt;html&lt;/code&gt;中的标记来进行引用的。而在&lt;code&gt;webpack&lt;/code&gt;的构建世界里，&lt;code&gt;html&lt;/code&gt;只是一个展示板，而&lt;code&gt;entry&lt;/code&gt;参数中指定的&lt;code&gt;javascript&lt;/code&gt;入口文件才是真正在构建过程中管理和调度资源的挂载点，&lt;code&gt;html&lt;/code&gt;文件中最终展示的内容，都是&lt;code&gt;webpack&lt;/code&gt;在加工并为所有资源打好标记以后传递给它的，业界将这种有别与浏览器的模式称之为&lt;strong&gt;“webpack的逆向注入”&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;二.html文件基本处理需求&quot;&gt;二.html文件基本处理需求&lt;/h2&gt;
&lt;p&gt;前端项目可以大致分为 &lt;strong&gt;单页面应用&lt;/strong&gt; 和 &lt;strong&gt;多页面应用&lt;/strong&gt;，现代化组件中的&lt;code&gt;html&lt;/code&gt;文件主要作为访问入口文件，是&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 样式标签和&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;脚本标签的挂载点，打包中需要解决的基本问题包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;个性化内容填充（例如页面标题，描述，关键词）&lt;/li&gt;
&lt;li&gt;多余空格删除（连续多个空白字符的合并）&lt;/li&gt;
&lt;li&gt;代码压缩（多余空白字符的合并）&lt;/li&gt;
&lt;li&gt;去除注释&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三.入口html文件的处理&quot;&gt;三.入口html文件的处理&lt;/h2&gt;
&lt;h3 id=&quot;单页面应用打包&quot;&gt;3.1 单页面应用打包&lt;/h3&gt;
&lt;p&gt;对于入口&lt;code&gt;html&lt;/code&gt;文件的处理直接使用&lt;code&gt;html-webpack-plugin&lt;/code&gt;插件来设置一定的配置参数即可，详细的配置参数可以参考其github地址:&lt;a href=&quot;https://github.com/jantimon/html-webpack-plugin&quot;&gt;html-webpack-plugin项目地址&lt;/a&gt;，在此直接给出基本用法示例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;webpack.config.js&lt;/code&gt;配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/14/702cdd3ef99210c8418d07ce328cdc55.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;index.html&lt;/code&gt;模板文件(构建生成的入口页面是以此为模板的):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/14/8d818faefb11eeb36786d59ec5dafdfd.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打包后生成的&lt;code&gt;index.html&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;tony stark&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;bruce banner &amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;main.boundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多页面应用打包&quot;&gt;3.2 多页面应用打包&lt;/h3&gt;
&lt;p&gt;如果项目中有多个页面，那么打包的时候需要考虑两个基本问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.如何自动生成多个页面？&lt;/li&gt;
&lt;li&gt;2.如果引用中存在公共的模块，怎样才能提取公共模块？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了演示多页面应用打包的场景，我们来构建如下的一组示例项目及其依赖关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/14/e0b3ef020053016d8d6b75ffebbb5ad4.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多页面应用的基本结构理解起来并不复杂，可以将其看做是多个单页面应用的组合，在&lt;code&gt;webpack&lt;/code&gt;中需要进行一些配置调整：&lt;/p&gt;
&lt;p&gt;entry参数需要配置多个依赖入口文件:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;entry:{
    &quot;main&quot;:__dirname + &quot;/src/indexController.js&quot;,
    &quot;about&quot;:__dirname + &quot;/src/aboutController.js&quot;,
    &quot;list&quot;:__dirname + &quot;/src/listController.js&quot;,
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;html文件则需要分别引用对应的入口文件并生成对应的访问入口：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    plugins:[
        //index.html
        new HtmlWebpackPlugin({
            title:'MainPage',
            template:'src/index.html',
            filename:'index.html',
            templateParameters:{
                param1:'tony stark',
                param2:'bruce banner'
            },
            chunks:['main'],
       }),
        //about.html
        new HtmlWebpackPlugin({
            title:'AboutPage',
            template:'src/about.html',
            filename:'about.html',
            templateParameters:{
                param1:'tony stark',
                param2:'bruce banner'
            },
            chunks:['about'],
       }),
       //list.html
       new HtmlWebpackPlugin({
            title:'ListPage',
            template:'src/list.html',
            filename:'list.html',
            templateParameters:{
                param1:'tony stark',
                param2:'bruce banner'
            },
            chunks:['list'],
       }),
    ],&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到在生成&lt;code&gt;html&lt;/code&gt;文件时已经为其单独引用了&lt;code&gt;chunks&lt;/code&gt;数组中指定的模块，这使得对应的页面生成时只依赖自己需要的脚本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.关于公共模块提取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/14/59b76e3a598c7c93c3d51ab2409e7194.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上一小节解决了&lt;strong&gt;多页面应用的基本打包&lt;/strong&gt;的需求，从得到的打包后的模块中，很容易看出它存在重复打包的问题，&lt;code&gt;eventbus.js&lt;/code&gt;这个公共库被&lt;code&gt;indexController.js&lt;/code&gt;和&lt;code&gt;aboutController.js&lt;/code&gt;中均被引用，但在不同的chunks中被重复打包，当公共部分的体积较大时，这样的方式明显是不能接受的。实际上分包问题并不是多页面应用中才存在的，而且是非常复杂的，它不仅要考虑公共模块本身的大小，模块之间的引用关系，还需要考虑同步引用和异步引用等等非常多的问题，笔者尚未研究清楚。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;1-3的版本中使用&lt;code&gt;commonsChunkPlugin&lt;/code&gt;插件来解决这个问题，在4.0以上的版本中废弃了原有方法，改为使用&lt;code&gt;optimization.splitChunks&lt;/code&gt;和&lt;code&gt;optimization.runtimeChunk&lt;/code&gt;来解决优化chunk拆分的问题，关于两者的区别可以看&lt;a href=&quot;https://www.cnblogs.com/wmhuang/p/8967639.html&quot;&gt;《webpack4：连奏中的进化》&lt;/a&gt;这篇博文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 组件模板html文件的处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在基于&lt;code&gt;Angular&lt;/code&gt;的项目中或许你会需要处理此类问题。github上点赞较多的&lt;code&gt;Angular-webpack-starter&lt;/code&gt;项目对于&lt;em&gt;html&lt;/em&gt;文件的处理是直接使用&lt;code&gt;raw-loader&lt;/code&gt;当做文本文件处理，推测其内部将&lt;em&gt;html&lt;/em&gt;文件中的内容当做模板字符串使用并在框架内部进行了加工。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;html-webpack-plugin&lt;/code&gt;插件是依赖于&lt;code&gt;html-loader&lt;/code&gt;而工作的，当你显式使用&lt;code&gt;/\.html$/&lt;/code&gt;作为规则来筛选文件时，同样会选择到作为入口文件的&lt;code&gt;html&lt;/code&gt;资源，从而造成冲突报错。在&lt;code&gt;Angularjs1.X&lt;/code&gt;项目中可考虑使用&lt;code&gt;ngTemplage-loader&lt;/code&gt;插件。&lt;/p&gt;
&lt;h2 id=&quot;四.-小结&quot;&gt;四. 小结&lt;/h2&gt;
&lt;p&gt;本文使用的&lt;code&gt;html&lt;/code&gt;文件是较为简单的，仅包含基本的标签和属性，并未包含其他资源引用（样式，图片等），毕竟&lt;code&gt;webpack&lt;/code&gt;的组成部分太过庞杂，去除干扰信息有针对性的学习更容易理解。资源管理及定位将在后续的章节阐述。&lt;/p&gt;
</description>
<pubDate>Tue, 14 Aug 2018 15:29:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>作为前端最火的构建工具，是前端自动化工具链 最重要的部分 ，使用门槛较高。本系列是笔者自己的学习记录，比较基础，希望通过 问题 + 解决方式 的模式，以前端构建中遇到的具体需求为出发点，学习 工具中相</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9478777.html</dc:identifier>
</item>
<item>
<title>概率软逻辑（PSL，Probabilistic soft logic）通用（可处理中文）版本 - 行者的灵感</title>
<link>http://www.cnblogs.com/zhangjiajia/p/9478683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangjiajia/p/9478683.html</guid>
<description>&lt;p&gt;概率软逻辑（PSL，Probabilistic soft logic）是用于开发概率模型的机器学习框架，由加州大学圣克鲁兹分校和马里兰大学联合开发。目前其复杂的环境构建方式和Groovy语言表达给像作者一样的初学者带来了不小的困难，而且诸多的依赖项使原本已经构建好的模型小错误频繁。&lt;/p&gt;
&lt;p&gt;经过努力，作者将其构建成单个jar包，并且加入编码机制使其可以支持各种语言的数据。主要贡献有三：&lt;/p&gt;
&lt;p&gt;1.将PSL原本复杂的依赖打包为单个jar包，加入依赖即可开始使用。&lt;/p&gt;
&lt;p&gt;2. 将不够熟悉的Groovy语言模型构建方式全部转化为java支持，只需一个.java文件便可进行模型构建。&lt;/p&gt;
&lt;p&gt;3.加入编码机制，使PSL可以处理除英文以外的语言。&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1PybpNoPpvk4jmSMw7Rm_7A&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1PybpNoPpvk4jmSMw7Rm_7A&lt;/a&gt; 密码：g1cx&lt;br/&gt;链接文件夹里有三个文件：&lt;br/&gt;PSL_swust1.0.jar 修改过的PSL模型&lt;br/&gt;SimpleAcquaintances.zip PSL官方例子的改编版本（不包含权重学习和函数）&lt;br/&gt;Entity_resolution.zip PSL官方例子的改编版本（包含权重学习和函数）&lt;/p&gt;

&lt;p&gt;以SimpleAcquaintances内SimpleAcquaintances.java为例进行阐述。&lt;/p&gt;
&lt;h3&gt;1.配置项&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * ======【配置项】======
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Tool tool &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tool();
        DataStore datastore;
        HashMap&lt;/span&gt;&amp;lt;String, Partition&amp;gt; partitions = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Partition&amp;gt;&lt;span&gt;();
        String path &lt;/span&gt;= tool.getPath(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleAcquaintances().getClass())
                &lt;/span&gt;+ &quot;/../data/&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; SimpleAcquaintances改为当前类名&lt;/span&gt;
        String[] paths =&lt;span&gt; tool.getFiles(path);
        PSLMODEL psl &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PSLMODEL(paths, &quot;H2&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在安装了postgresql数据库时可H2改为postgresql&lt;/span&gt;
        datastore =&lt;span&gt; psl.getDatastore();
        psl.transcoding &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否给数据编码(此值只决定数据是否编码，谓词默认都要编码)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用时SimpleAcquaintances需要改为当前类名，为了获取当前项目文件夹的数据文件夹data。另外当安装配置了postgreSQL时可将H2改为postgresql来使用postgreSQL数据库（H2为模型自带数据库，运行于内存）。transcoding 项设置为true时候会给数据编码（此时可设置谓词为UniqueIntID属性，提升模型计算效率），可以处理各种语言的数据，但是编码后无法合理使用PSL自带相似度计算函数(因为编码后数据不是原来的字符串了，相似度函数平时很少用到，自定义函数可以正常使用)。&lt;/p&gt;
&lt;h3&gt;2.定义分区&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 权重学习分区
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; partitions.put(&quot;learn_obs&quot;, datastore.getPartition(&quot;learn_obs&quot;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; partitions.put(&quot;learn_target&quot;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; datastore.getPartition(&quot;learn_target&quot;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; partitions.put(&quot;learn_truth&quot;, datastore.getPartition(&quot;learn_truth&quot;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实验分区&lt;/span&gt;
        datastore =&lt;span&gt; psl.getDatastore();
        partitions.put(&lt;/span&gt;&quot;obs&quot;, datastore.getPartition(&quot;obs&quot;&lt;span&gt;));
        partitions.put(&lt;/span&gt;&quot;target&quot;, datastore.getPartition(&quot;target&quot;&lt;span&gt;));
        partitions.put(&lt;/span&gt;&quot;truth&quot;, datastore.getPartition(&quot;truth&quot;&lt;span&gt;));
        psl.setPartitions(partitions);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当需要权重学习时（有训练数据时），需要定义权重学习分区。obs代表已知数据分区，target代表要推理的目标数据储存分区（当要使用LazyInference推理时可以不往里面加载数据），truth为真实数据分区。&lt;/p&gt;
&lt;h3&gt;3.谓词（函数）定义&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
HashMap&amp;lt;String, ConstantType[]&amp;gt; p = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, ConstantType[]&amp;gt;&lt;span&gt;();
        HashMap&lt;/span&gt;&amp;lt;String, ExternalFunction&amp;gt; f = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, ExternalFunction&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加谓词&lt;/span&gt;
        p.put(&quot;Lived&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConstantType[] { ConstantType.UniqueStringID,ConstantType.UniqueStringID });
        p.put(&lt;/span&gt;&quot;Likes&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConstantType[] { ConstantType.UniqueStringID,ConstantType.UniqueStringID });
        p.put(&lt;/span&gt;&quot;Knows&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConstantType[] { ConstantType.UniqueStringID,ConstantType.UniqueStringID });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加函数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      f.put(&quot;SameInitials&quot;, new SameInitials());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      f.put(&quot;SameNumTokens&quot;, new SameNumTokens());&lt;/span&gt;
        psl.definePredicates(p, f);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 谓词、函数输入模型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;谓词定义只需替换即可，可随意增加，常用属性有UniqueStringID、UniqueIntID、String等。函数可以定义PSL自带相似度函数（transcoding 为false时）。&lt;/p&gt;
&lt;h3&gt;4.规则定义&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
String[] rules =&lt;span&gt; {

                &lt;/span&gt;&quot;20.0: ( LIVED(P1, L) &amp;amp; (P1 != P2) &amp;amp; LIVED(P2, L) ) &amp;gt;&amp;gt; KNOWS(P1, P2) ^2&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;5.0: ( (L1 != L2) &amp;amp; (P1 != P2) &amp;amp; LIVED(P2, L2) &amp;amp; LIVED(P1, L1) ) &amp;gt;&amp;gt; ~( KNOWS(P1, P2) ) ^2&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;10.0: ( LIKES(P2, L) &amp;amp; (P1 != P2) &amp;amp; LIKES(P1, L) ) &amp;gt;&amp;gt; KNOWS(P1, P2) ^2&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;5.0: ( KNOWS(P1, P2) &amp;amp; KNOWS(P2, P3) &amp;amp; (P1 != P3) ) &amp;gt;&amp;gt; KNOWS(P1, P3) ^2&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;1.0 * KNOWS(P1, P2) + -1.0 * KNOWS(P2, P1) = 0.0 .&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;5.0: ~( KNOWS(P1, P2) ) ^2&quot;&lt;span&gt;

        };
        psl.defineRules(rules);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 规则输入模型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;权重: 规则体 &amp;gt;&amp;gt; 规则头 ，^2代表平方优化，按照两个例子里的规则格式增加规则即可。&lt;/p&gt;
&lt;h3&gt;5.导入数据&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * ======【导入数据】======
         * 其中&quot;1-2&quot;表示对数据的一二列进行转码
         * 只有在transcoding = true时作用，表示只对1，2两列进行转码
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        psl.loadData(&lt;/span&gt;&quot;Lived&quot;, path + &quot;Lived_obs.txt&quot;, &quot;obs&quot;, &quot;1-2&quot;&lt;span&gt;);
        psl.loadDataTruth(&lt;/span&gt;&quot;Likes&quot;, path + &quot;likes_obs.txt&quot;, &quot;obs&quot;, &quot;1-2&quot;&lt;span&gt;);
        psl.loadData(&lt;/span&gt;&quot;Knows&quot;, path + &quot;knows_obs.txt&quot;, &quot;obs&quot;, &quot;1-2&quot;&lt;span&gt;);
        psl.loadData(&lt;/span&gt;&quot;Knows&quot;, path + &quot;knows_targets.txt&quot;, &quot;target&quot;,&quot;1-2&quot;&lt;span&gt;);
        psl.loadDataTruth(&lt;/span&gt;&quot;Knows&quot;, path + &quot;knows_truth.txt&quot;, &quot;truth&quot;,&quot;1-2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      ArrayList&amp;lt;String[]&amp;gt; likepe = tool.fileToArrayList(path + &quot;likes_obs.txt&quot;, &quot;1-2-3&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      psl.insertDataTruth(&quot;Likes&quot;, likepe, &quot;obs&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      psl.insertData(&quot;Likes&quot;, likepe, &quot;obs&quot;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;提供了loadData，loadDataTruth，insertData，insertDataTruth四种方法载入数据，loadData(&quot;谓词&quot;,谓词对应文件路径, &quot;导入分区&quot;, &quot;1-2&quot;)，loadData，loadDataTruth区别在于loadDataTruth最后一列为概率值；insertData，insertDataTruth需要将文件转化为List数据，适用于一个数据文件存储了多个谓词的数据， &quot;1-2-3&quot;代表要取出1、2、3作为谓词的数据，insertDataTruth取出的每个数据 &quot;1-2-...-n&quot;的第n项是概率值。其中&quot;1-2&quot;表示对数据的一二列进行转码， 只有在transcoding = true时作用，表示只对数据文件里的1，2两列进行转码，多列增加即可，以“-”分开。&lt;/p&gt;
&lt;h3&gt;6.权重学习&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  psl.learnWeights(&quot;learn_target&quot;, &quot;Lived-Likes&quot;, &quot;learn_obs&quot;, &quot;learn_truth&quot;,&quot;MaxLikelihoodMPE&quot;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;(&quot;训练数据目标分区&quot;, &quot;封闭谓词（即：作为已知数据，推理过程不会再新产生的原子）&quot;, &quot;训练数据已知数据分区&quot;, &quot;真实数据分区&quot;,&quot;权重学习方法&quot;)&lt;br/&gt;有训练数据时候可进行权重学习优化规则权重。实现了五种权重优化方法：&lt;br/&gt;&quot;LazyMaxLikelihoodMPE&quot;,&lt;br/&gt;&quot;MaxLikelihoodMPE&quot;,&lt;br/&gt;&quot;MaxPiecewisePseudoLikelihood&quot;，&lt;br/&gt;&quot;MaxPseudoLikelihood&quot;,&lt;br/&gt;&quot;SimplexSampler&quot;&lt;br/&gt;替换即可使用。&lt;/p&gt;
&lt;h3&gt;7.打印输出模型&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
psl.printModel();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可查看已经定义的模型。&lt;/p&gt;
&lt;h3&gt;8.运行推理&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      psl.runLazyInference(&quot;已知数据分区&quot;, &quot;目标分区（存放结果）&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      psl.runLazyInference(&quot;obs&quot;, &quot;target&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      psl.runInference(&quot;&quot;已知数据分区&quot;&quot;,&quot;封闭谓词1-封闭谓词2&quot; , &quot;目标分区（包含定义的目标原子）&quot;);&lt;/span&gt;
        psl.runInference(&quot;obs&quot;,&quot;Lived-Likes&quot; , &quot;target&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;两种推理方式LazympeInference，mpeInference。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
psl.writeOutput(&quot;target&quot;, &quot;Knows&quot;&lt;span&gt;, path
                &lt;/span&gt;+ &quot;/result/knows_inffer.txt&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;(&quot;目标分区&quot;, &quot;要输出的数据对应谓词1-要输出的数据对应谓词2&quot;, 输出路径)。&lt;/p&gt;
&lt;h3&gt;10.评估实验结果&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
psl.evalResults(&quot;target&quot;, &quot;truth&quot;, &quot;Knows&quot;&lt;span&gt;, path
                &lt;/span&gt;+ &quot;/result/evalResults.txt&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;(&quot;目标分区&quot;, &quot;真实数据分区&quot;, &quot;目标谓词1-目标谓词2&quot;, 评估结果输出路径)。值得一提的是，&quot;目标谓词1-目标谓词2&quot;需要包含所有真实数据分区里所包含数据对应的谓词。&lt;/p&gt;
&lt;h3&gt;11.关闭模型&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
psl.closeModel();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;推理完成，请关闭模型。&lt;/p&gt;
</description>
<pubDate>Tue, 14 Aug 2018 15:15:00 +0000</pubDate>
<dc:creator>行者的灵感</dc:creator>
<og:description>一、简介 概率软逻辑（PSL，Probabilistic soft logic）是用于开发概率模型的机器学习框架，由加州大学圣克鲁兹分校和马里兰大学联合开发。目前其复杂的环境构建方式和Groovy语言</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangjiajia/p/9478683.html</dc:identifier>
</item>
<item>
<title>基于pandas python sklearn 的美团某商家的评论分类(文本分类） - 多一点</title>
<link>http://www.cnblogs.com/onemorepoint/p/9478429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onemorepoint/p/9478429.html</guid>
<description>&lt;h3 id=&quot;美团店铺评价语言处理以及分类nlp&quot;&gt;美团店铺评价语言处理以及分类（NLP）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;上两篇博客中介绍了美团店铺的订单信息以及数据分析以及可视化&lt;/li&gt;
&lt;li&gt;其中还有一部分评论文本信息并没有提及到，自然也就有了这篇&lt;/li&gt;
&lt;li&gt;主要用到的包有jieba，sklearn，pandas&lt;/li&gt;
&lt;li&gt;本篇博文主要先用的是词袋模型(bag of words),将文本以数值特征向量的形式来表示(每个文档构建一个特征向量，有很多的0，类似于前文说的category类的one-hot形式，得到的矩阵为稀疏矩阵)&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;导入数据分析常用库&quot;&gt;导入数据分析常用库&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pandas as pd
import numpy as np&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;读取文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;df=pd.read_excel(&quot;all_data_meituan.xlsx&quot;)[[&quot;comment&quot;,&quot;star&quot;]]
df.head()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/9ebd4c2bgy1fu9bm7nc6tj20qm0bijtc.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查看DataFrame的大小&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;df.shape&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;(17400, 2)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;df['sentiment']=df['star'].apply(lambda x:1 if x&amp;gt;30 else 0)
df=df.drop_duplicates() ## 去掉重复的评论，剩余的文本1406条，我们将数据复制为原有数据的三倍
df=df.dropna()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X=pd.concat([df[['comment']],df[['comment']],df[['comment']]])
y=pd.concat([df.sentiment,df.sentiment,df.sentiment])
X.columns=['comment']
X.reset_index
X.shape&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;(3138, 1)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
import jieba # 导入分词库
def chinese_word_cut(mytext):
    return &quot; &quot;.join(jieba.cut(mytext))
X['cut_comment']=X[&quot;comment&quot;].apply(chinese_word_cut)
X['cut_comment'].head()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Building prefix dict from the default dictionary ...
DEBUG:jieba:Building prefix dict from the default dictionary ...
Loading model from cache C:\Users\HUANG_~1\AppData\Local\Temp\jieba.cache
DEBUG:jieba:Loading model from cache C:\Users\HUANG_~1\AppData\Local\Temp\jieba.cache
Loading model cost 0.880 seconds.
DEBUG:jieba:Loading model cost 0.880 seconds.
Prefix dict has been built succesfully.
DEBUG:jieba:Prefix dict has been built succesfully.





0    还行 吧 ， 建议 不要 排队 那个 烤鸭 和 羊肉串 ， 因为 烤肉 时间 本来 就 不够...
1    去过 好 几次 了   东西 还是 老 样子   没 增添 什么 新花样   环境 倒 是 ...
2    一个 字 ： 好 ！ ！ ！   # 羊肉串 #   # 五花肉 #   # 牛舌 #   ...
3    第一次 来 吃 ， 之前 看过 好多 推荐 说 这个 好吃 ， 真的 抱 了 好 大 希望 ...
4    羊肉串 真的 不太 好吃 ， 那种 说 膻 不 膻 说 臭 不 臭 的 味 。 烤鸭 还 行...
Name: cut_comment, dtype: object&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;导入sklearn中的数据分割模块，设定test数据集大小，shuffle默认Ture&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.model_selection import  train_test_split
X_train,X_test,y_train,y_test= train_test_split(X,y,random_state=42,test_size=0.25)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;获取停用词&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def get_custom_stopwords(stop_words_file):
    with open(stop_words_file,encoding=&quot;utf-8&quot;) as f:
        custom_stopwords_list=[i.strip() for i in f.readlines()]
    return custom_stopwords_list&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;stop_words_file = &quot;stopwords.txt&quot;
stopwords = get_custom_stopwords(stop_words_file) # 获取停用词&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;导入词袋模型&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.feature_extraction.text import  CountVectorizer
vect=CountVectorizer()  # 实例化
vect # 查看参数&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;CountVectorizer(analyzer='word', binary=False, decode_error='strict',
        dtype=&amp;lt;class 'numpy.int64'&amp;gt;, encoding='utf-8', input='content',
        lowercase=True, max_df=1.0, max_features=None, min_df=1,
        ngram_range=(1, 1), preprocessor=None, stop_words=None,
        strip_accents=None, token_pattern='(?u)\\b\\w\\w+\\b',
        tokenizer=None, vocabulary=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# dir(vect)  # 查看vect的属性&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;将分割后的文本进行fit_transform,系数矩阵大小为2353*1965&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;vect.fit_transform(X_train[&quot;cut_comment&quot;])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;2353x1965 sparse matrix of type '&amp;lt;class 'numpy.int64'&amp;gt;'
    with 20491 stored elements in Compressed Sparse Row format&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;vect.fit_transform(X_train[&quot;cut_comment&quot;]).toarray().shape&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;(2353, 1965)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pd.DataFrame(vect.fit_transform(X_train[&quot;cut_comment&quot;]).toarray(),columns=vect.get_feature_names()).iloc[:,0:25].head()
# print(vect.get_feature_names())
#  数据维数1956，不算很大（未使用停用词）
# 将其转化为DataFrame&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;发现其中有很多的数字以及无效特征，随后传入实例化参数的同时，加入正则匹配取出这些无意义特征，同时取出停用词&lt;br/&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/9ebd4c2bgy1fu9c1rlvn1j20mo05c74b.jpg&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;vect = CountVectorizer(token_pattern=u'(?u)\\b[^\\d\\W]\\w+\\b',stop_words=frozenset(stopwords)) # 去除停用词，匹配以数字开头的非单词字符
pd.DataFrame(vect.fit_transform(X_train['cut_comment']).toarray(), columns=vect.get_feature_names()).head()
# 1691 columns,去掉以数字为特征值的列，减少了近三百列，由1965减小到1691 
# max_df = 0.8 # 在超过这一比例的文档中出现的关键词（过于平凡），去除掉（可以自行设定）
# min_df = 3 # 在低于这一数量的文档中出现的关键词（过于独特），去除掉。（可以自行设定）&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;取出数字特征之后&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/9ebd4c2bgy1fu9c4y3h26j20u5057wem.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;模型构建&quot;&gt;模型构建&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;从sklearn 朴素贝叶斯中导入多维贝叶斯&lt;/li&gt;
&lt;li&gt;朴素贝叶斯通常用来处理文本分类垃圾短信，速度飞快，效果一般都不会差很多&lt;/li&gt;
&lt;li&gt;MultinomialNB类可以选择默认参数，如果模型预测能力不符合要求，可以适当调整&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.naive_bayes import MultinomialNB
nb=MultinomialNB()  &lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.pipeline import make_pipeline # 导入make_pipeline方法
pipe=make_pipeline(vect,nb)
pipe.steps #  查看pipeline的步骤（与pipeline相似）&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[('countvectorizer',
  CountVectorizer(analyzer='word', binary=False, decode_error='strict',
          dtype=&amp;lt;class 'numpy.int64'&amp;gt;, encoding='utf-8', input='content',
          lowercase=True, max_df=1.0, max_features=None, min_df=1,
          ngram_range=(1, 1), preprocessor=None,
          stop_words=frozenset({'', '范围', '但愿', 'vs', '为', '过去', '集中', '这般', '孰知', '认为', '论', '36', '前后', '每年', '长期以来', 'our', '要不', '使用', '好象', 'such', '不但', '一下', 'how', '召开', '6', '全体', '严格', '除开', 'get', '可好', '毕竟', 'but', '如前所述', '满足', 'your', 'keeps', '只', '大抵', '己', 'concerning', &quot;they're&quot;, '再则', '有意的'...'reasonably', '绝对', '咧', '除此以外', '50', '得了', 'seeming', '只是', '背靠背', '弗', 'need', '其', '第二', '再者说'}),
          strip_accents=None, token_pattern='(?u)\\b[^\\d\\W]\\w+\\b',
          tokenizer=None, vocabulary=None)),
 ('multinomialnb', MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True))]&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pipe.fit(X_train.cut_comment, y_train)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Pipeline(memory=None,
     steps=[('countvectorizer', CountVectorizer(analyzer='word', binary=False, decode_error='strict',
        dtype=&amp;lt;class 'numpy.int64'&amp;gt;, encoding='utf-8', input='content',
        lowercase=True, max_df=1.0, max_features=None, min_df=1,
        ngram_range=(1, 1), preprocessor=None,
        stop_words=...e, vocabulary=None)), ('multinomialnb', MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True))])&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试集预测结果&quot;&gt;测试集预测结果&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y_pred = pipe.predict(X_test.cut_comment) 
# 对测试集进行预测（其中包括了转化以及预测）&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 模型对于测试集的准确率
from sklearn import  metrics
metrics.accuracy_score(y_test,y_pred)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.82929936305732488&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 模型对于测试集的混淆矩阵
metrics.confusion_matrix(y_test,y_pred)
# 测试集中的预测结果：真阳性1231个，假阳性417个，假阴性98个，真阴性为2604个&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[177, 112],
       [ 22, 474]], dtype=int64)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def get_confusion_matrix(conf,clas):
    import  matplotlib.pyplot as  plt
    fig,ax=plt.subplots(figsize=(2.5,2.5))
    ax.matshow(conf,cmap=plt.cm.Blues,alpha=0.3)
    tick_marks = np.arange(len(clas))
    plt.xticks(tick_marks,clas, rotation=45)
    plt.yticks(tick_marks, clas)
    for i in range(conf.shape[0]):
        for j in range(conf.shape[1]):
            ax.text(x=i,y=j,s=conf[i,j],
                   va='center',
                   ha='center')
    plt.xlabel(&quot;predict_label&quot;)
    plt.ylabel(&quot;true label&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;conf=metrics.confusion_matrix(y_test,y_pred)
class_names=np.array(['0','1'])
get_confusion_matrix(np.array(conf),clas=class_names)
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/9ebd4c2bgy1fu9l64amzrj208807vq2x.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;对整个数据集进行预测分类&quot;&gt;对整个数据集进行预测分类&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y_pred_all = pipe.predict(X['cut_comment'])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;metrics.accuracy_score(y,y_pred_all)
# 对于整个样本集的预测正确率，整个数据集的准确率高于测试集，说明有些过拟合
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.85659655831739967&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;metrics.confusion_matrix(y,y_pred_all)
#  真个数据集的混淆矩阵&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[ 801,  369],
       [  81, 1887]], dtype=int64)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y.value_counts()
# 初始样本中 正类与负类的数量&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;1    1968
0    1170
Name: sentiment, dtype: int64&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;metrics.f1_score(y_true=y,y_pred=y_pred_all)
# f1_score 评价模型对于真个数据集&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.89346590909090906&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;metrics.recall_score(y, y_pred_all)
# 检出率，也就是正类总样本检出的比例   真正/假阴+真正&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.95884146341463417&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;metrics.precision_score(y, y_pred_all)
#  准确率，  检测出的来正类中真正类的比例  真正/假阳+真正&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.83643617021276595&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(metrics.classification_report(y, y_pred_all))
# 分类报告&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;             precision    recall  f1-score   support

      0       0.91      0.68      0.78      1170
      1       0.84      0.96      0.89      1968

avg / total       0.86      0.86      0.85      3138&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 14 Aug 2018 14:34:00 +0000</pubDate>
<dc:creator>多一点</dc:creator>
<og:description>美团店铺评价语言处理以及分类（NLP） 上两篇博客中介绍了美团店铺的订单信息以及数据分析以及可视化 其中还有一部分评论文本信息并没有提及到，自然也就有了这篇 主要用到的包有jieba，sklearn，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/onemorepoint/p/9478429.html</dc:identifier>
</item>
<item>
<title>Tomcat类加载架构 - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/9478337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/9478337.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;　　主流的Java Web服务器（Tomcat、Jetty、WebLogic、WebSphere等）都有多个自定义的类加载器以及具备的类加载优势，本篇博文主要是通过以Tomcat为例简单认识Java Web服务器具有的特点、以及自定义类加载器是如何实现的。此外，&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本篇博文主要是根据Tomcat 5.x类加载架构编写的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;主要参考资料《深入理解Java虚拟机》&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;
&lt;h2&gt;&lt;span&gt;1、&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Web服务器需要解决的问题&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　一个功能健全的&lt;/span&gt;Web&lt;span&gt;服务器，都需要解决如下几个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　（1）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同一个服务器上的两个&lt;/span&gt;Web&lt;span&gt;程序所使用的&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;类库实现相互独立隔离&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;span&gt;不能一个类库在同一个服务器上只有一份却被多个程序使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;（2）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同一个服务器上的两个&lt;/span&gt;Web&lt;span&gt;应用程序所使用的&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;类库可以被共享&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;span&gt;如果不能共享的话，虚拟机内部的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Method Area &lt;span&gt;可能会出现过度膨胀现象。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;（3）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;服务器的类库要与&lt;/span&gt;Web&lt;span&gt;应用程序的类库相互隔离，互不影响（即服务器不收&lt;/span&gt;&lt;span&gt;Web&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;程序的影响）&lt;/strong&gt;&lt;/span&gt;：&lt;/span&gt;&lt;span&gt;&lt;span&gt;很多服务器可能是用&lt;/span&gt;Java&lt;span&gt;来实现，自然就得使用一些只属于自己的类库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;（4）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;支持&lt;/span&gt;JSP&lt;span&gt;的热替换（&lt;/span&gt;&lt;span&gt;HotSwap&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;span&gt;大部分主流服务器（WebLogic除外）修改&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;JSP文件都&lt;/span&gt;&lt;span&gt;不需要重启服务器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　试想一下，如果上述的4点中任何一点不能满足，特别是（1）-（3）点，那么整个Java Web服务器都是“混乱”的，或者说是不健全的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2、Tomcat类库存放目录&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　既然要满足以上四点基本要求，那么当部署一个Web应用时，一个Classpath路径目录是无法满足需求的，通常会&lt;span&gt;提供多个Classpath（一般以classes/lib命名）路径目录&lt;/span&gt;，&lt;span&gt;而&lt;span&gt;目录中都会有一个相应的自定义类加载器去加载里面的Java&lt;/span&gt;&lt;span&gt;&lt;span&gt;类&lt;/span&gt;。在Tomcat中就有三组目录，分别是：/common/*、/server/*、/shared/*；&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　但值得强调的是&lt;span&gt;在Tomcat 6.x之后这三组目录就不存在了，只有一个总的/lib目录，其他都需要进入配置文件需要时单独配置&lt;/span&gt;。所以这里介绍的目录未必能在tomcat安装目录下找到，不过其用意都是一样的；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;&lt;span&gt;　&lt;strong&gt;（1）&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;/common/*&lt;/span&gt;&lt;span&gt;：实际创建的时候为&lt;/span&gt;&lt;span&gt;/common/lib/&lt;/span&gt;&lt;span&gt;目录&lt;/span&gt;&lt;span&gt;，可以被&lt;/span&gt;Tomcat&lt;span&gt;与所有的&lt;/span&gt;&lt;span&gt;Web&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;应用共享的类库都在里面；&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　但是在&lt;/span&gt;Tomcat 6&lt;span&gt;之后&lt;/span&gt;&lt;span&gt;/common/lib/&lt;/span&gt;&lt;span&gt;目录被废弃，现在默认的是在&lt;/span&gt;&lt;span&gt;/lib/&lt;/span&gt;&lt;span&gt;下，实际上是将&lt;/span&gt;&lt;span&gt;/common&lt;/span&gt;、&lt;span&gt;/server、/shared&lt;/span&gt;&lt;span&gt;三个目录默认合并到一个&lt;/span&gt;&lt;span&gt;/lib&lt;/span&gt;&lt;span&gt;目录下。如果不满足具体的业务需求的话，可以在&lt;/span&gt;conf/catalina.properties&lt;span&gt;中设置&lt;/span&gt;server.loader&lt;span&gt;与&lt;/span&gt;shared.loader&lt;span&gt;。&lt;/span&gt;&lt;span&gt;打开&lt;/span&gt;conf/catalina.properties&lt;span&gt;可以看到：无论是&lt;/span&gt;${catalina.base}&lt;span&gt;，还是&lt;/span&gt;&quot;${catalina.home}&lt;span&gt;，都会去找&lt;/span&gt;/lib/&lt;span&gt;目录，指定加载的加载器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201808/1352849-20180814213344915-421723089.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　CATALINA_BASE&lt;span&gt;：是实例配置位置，也就是一个&lt;span&gt;tomcat&lt;span&gt;可以配置多个实例，实例里面有自己的配置；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;span&gt;CATALINA_HOME&lt;span&gt;：是&lt;span&gt;tomcat&lt;span&gt;安装位置；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　common.loader、server.loader、shared.loade&lt;span&gt;：表示&lt;span&gt;tomcat&lt;span&gt;指定自定义的&lt;span&gt;三个加载器。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  　　    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201808/1352849-20180814213532558-2023634130.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201808/1352849-20180814213459242-107098713.png&quot; alt=&quot;&quot;/&gt;　　　　　 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201808/1352849-20180814213443088-1268129577.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　（2）&lt;/span&gt;/server/*&lt;span&gt;：&lt;/span&gt;&lt;span&gt;实际创建的时候为&lt;/span&gt;/server/lib&lt;span&gt;目录，只能被&lt;/span&gt;&lt;span&gt;Tomcat&lt;/span&gt;&lt;span&gt;使用的类库。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　（3）&lt;/span&gt;/shared/*&lt;span&gt;：&lt;/span&gt;&lt;span&gt;实际创建的时候为&lt;/span&gt;/shared/lib&lt;span&gt;目录，可以被所有的&lt;/span&gt;&lt;span&gt;Web&lt;/span&gt;&lt;span&gt;应用程序共享使用，但是对&lt;/span&gt;&lt;span&gt;Tomcat&lt;/span&gt;&lt;span&gt;是不可见的。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　（4）&lt;/span&gt;/webapps(wtswebapps)/project/WEB-INF/*&lt;span&gt;：实际为&lt;/span&gt;&lt;span&gt;/WebApp/project/WEB-INF/lib&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;Project&lt;/span&gt;&lt;span&gt;&lt;span&gt;独享有的类库&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3、Tomcat自定义加载器&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;Tomcat&lt;span&gt;自定义的类加载器主要有：&lt;/span&gt;&lt;span&gt;ComnonClassLoader&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;CatalinaClassLoader&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;SharedClassLoader&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;WebAppClassLoader&lt;/span&gt;&lt;span&gt;四个类加载器。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（1）ComnonClassLoader&lt;span&gt;：加载&lt;/span&gt;/common/*&lt;span&gt;目录下的类，但是上述可知现在的指定加载都会在&lt;/span&gt;&lt;span&gt;Catalina.properties&lt;/span&gt;&lt;span&gt;中配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（2）CatalinaClassLoader&lt;span&gt;：加载&lt;/span&gt;&lt;span&gt;/server/*&lt;/span&gt;&lt;span&gt;目录下的类，同理现在在&lt;/span&gt;Catalina.properties&lt;span&gt;中指定配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（3）SharedClassLoader&lt;span&gt;：加载&lt;/span&gt;&lt;span&gt;/shared/*&lt;/span&gt;&lt;span&gt;目录下的类，同理现在在&lt;/span&gt;Catalina.properties&lt;span&gt;中指定配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（4）WebAppClassLoader&lt;span&gt;：加载&lt;/span&gt;&lt;span&gt;/webapps(wtswebapps)/project/WEB-INF/*&lt;/span&gt;&lt;span&gt;目录下项目&lt;/span&gt;&lt;span&gt;lib&lt;/span&gt;&lt;span&gt;中的类。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; 　　&lt;span&gt;结合之前三个类加载器（&lt;/span&gt;BootstrapClassLoader&lt;span&gt;、&lt;/span&gt;&lt;span&gt;ExtensionClassLoader&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;ApplicationLoader&lt;/span&gt;&lt;span&gt;）与&lt;/span&gt;&lt;span&gt;Tomcat&lt;/span&gt;&lt;span&gt;自定义的四个加载器组合成的委派关系（&lt;/span&gt;&lt;span&gt;Tomcat&lt;/span&gt;&lt;span&gt;服务器的类加载机构）如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201808/1352849-20180814215919494-1270345135.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　    &lt;span&gt;（注：其中JasperLoader为Jsp类加载器，JSP文件编译后为Class文件，需要加载）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　通过此关系图我们可以得到如下两点：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　（1）&lt;span&gt;&lt;strong&gt;CatalinaClassLoader&lt;span&gt;与&lt;/span&gt;&lt;span&gt;SharedClassLoader&lt;/span&gt;&lt;span&gt;是相互隔离独立的；&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　（2）&lt;span&gt;&lt;strong&gt;WebAppClassLoader&lt;span&gt;可以使用&lt;/span&gt;&lt;span&gt;SharedClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;加载类&lt;/strong&gt;&lt;/span&gt;，同理&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;WebAppClassLoader&lt;/span&gt;&lt;span&gt;可以代替&lt;/span&gt;&lt;span&gt;JspClassLoader&lt;/span&gt;&lt;span&gt;加载类，&lt;/span&gt;&lt;span&gt;CommonClassLoader&lt;/span&gt;&lt;span&gt;加载的类可以被&lt;/span&gt;&lt;span&gt;CatalinaClassLoader&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;SharedClassLoader&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;使用&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　同时需要注意还有以下两点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 14 Aug 2018 14:18:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<og:description>前言 主流的Java Web服务器（Tomcat、Jetty、WebLogic、WebSphere等）都有多个自定义的类加载器以及具备的类加载优势，本篇博文主要是通过以Tomcat为例简单认识Java</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/9478337.html</dc:identifier>
</item>
<item>
<title>Java内部类的使用小结 - 沙漏，为谁转</title>
<link>http://www.cnblogs.com/MJ1234/p/9478046.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MJ1234/p/9478046.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;☆：为什么要使用内部类：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;内部类：顾名思义就是把类放在某个范围里&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;类可以放在包中&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;类可以放在文件夹中&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;类可以放在类中 　　 //内部类&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;类可以放在方法中 　　 //内部类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、成员内部类&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;类中放置内部类，类里套类，类中类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;要使用内部类，就需要在外部类中实例化内部类的对象，然后通过对象打点调用内部类中的方法，通过方法操作内部类数据。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;内部类可以直接使用外部类的属性和方法，就像孙悟空钻进铁扇公主肚子里。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OuterClass {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;外部类中的属性&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; outer_1=100;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有属性    &lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; outer_2=10;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;公有属性
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;外部类方法outer_method1&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outer_method1(){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         System.out.println(&quot;outer_method1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         InnerClass ic=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InnerClass();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用内部类中的方法&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        ic.inner_method1();            
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用内部类中的私有属性和公有属性&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         System.out.println(ic.inner_1+&quot; &quot;+&lt;span&gt;ic.inner_2);    
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;有名的内部类InnerClass&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内部类中的属性&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; inner_1=123;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有属性&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; inner_2=321;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;公有属性
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内部类方法inner_method1&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inner_method1(){
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用外部类中的方法，&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            outer_method1();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用外部类中的私有属性和公有属性&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             System.out.println(outer_1+&quot; &quot;+&lt;span&gt;outer_2);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }    
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }    
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、局部内部类&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;方法中中放置内部类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;要使用方法中的内部类，就必须在方法中，内部类定义的下面实例化内部类的对象，然后通过内部类对象打点调用内部类的方法，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;内部类的作用域仅限于当前方法，对内部类定义开始到方法结束，作用域消失。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在内部类中可以直接使用外部类中的当前方法中的局部变量，在方法的外面不能使用方法中的内部类。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; *方法中放置内部类 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OuterClass {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;外部类中的属性&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; outer_1=100;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有属性&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; outer_2=10;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;公有属性
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;外部类中的方法&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outer_method1(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(&quot;outer_method1()&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         System.out.println(&quot;outer_1&quot;+&quot;outer_2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法中的内部类&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内部类中的属性&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; inner_1=123;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有属性&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; inner_2=321;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;公有属性
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内部类中的公有方法&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inner_method1(){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 System.out.println(&quot;public method1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                System.out.println(outer_1);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }    
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内部类中的私有 方法&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inner_method2(){
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 System.out.println(&quot;private method2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 System.out.println(outer_1+&quot; &quot;+&lt;span&gt;outer_2);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化内部类&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         InnerClass ic=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InnerClass();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        ic.inner_method1();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        ic.inner_method2();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         System.out.println(ic.inner_1+&quot; &quot;+&lt;span&gt;ic.inner_2);    
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;作用域到此处结束&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }    
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、匿名内部类&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;1. 匿名内部类是没有访问修饰符的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.有时候我为了免去给内部类命名，便倾向于使用匿名内部类，因为它没有名字。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.当前匿名内部类中实现的方法，只能实现一次，如果还想其他的实现，必须用匿名内部类重新new实现。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TetMethod1(){    
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;匿名内部类    new 的是CommonPerson的子实现，但没有类名，把子实现的对象赋值给长辈引用&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         CommonPerson cp=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CommonPerson(){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; study() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;有名内部类&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;class&lt;/span&gt; Student &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IPerson{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; study(){}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat(){}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Student stu1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         IPerson ip=&lt;span&gt;stu1;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;匿名内部类&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         IPerson ip1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IPerson(){
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; study(){}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         IPerson ip2=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IPerson(){
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; study(){}
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {}
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        };    
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IPerson {      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义的接口IPerson&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; study();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、嵌套内部类&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;嵌套内部类分为静态内部类和非静态内部类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.静态内部类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1、 它的创建不需要依赖于外部类。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、 它不能使用任何外围类的非static成员变量和方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.非静态内部类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.它的创建需要依赖于外部类 。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，可以随便调用外部类中的成员，不管是静态的还是非静态的，相当霸道。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OuterClass {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String name = &quot;ma&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     *静态内部类
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass1{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 在静态内部类中可以存在静态成员 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String name1 = &quot;1_static&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display(){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态内部类只能访问外围类的静态成员变量和方法&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             System.out.println(&quot;OuterClass name :&quot; +&lt;span&gt; name);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * 非静态内部类
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass2{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 非静态内部类中不能存在静态成员 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; String name2 = &quot;2_inner&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的,这就有点霸道了&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display(){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             System.out.println(&quot;OuterClass name：&quot; +&lt;span&gt; name);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display(){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 外部类访问静态内部类&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        System.out.println(InnerClass1.name1);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InnerClass1().display();  
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 非静态内部的创建需要依赖于外部类 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         OuterClass.InnerClass2 inner2=&lt;span&gt;new&lt;/span&gt; OuterClass().&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InnerClass2();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        System.out.println(inner2.name2);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        inner2.display();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 14 Aug 2018 13:33:00 +0000</pubDate>
<dc:creator>沙漏，为谁转</dc:creator>
<og:description>☆：为什么要使用内部类：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。内部类：顾名思义就是把类放在某个范</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MJ1234/p/9478046.html</dc:identifier>
</item>
<item>
<title>25.redux回顾,redux中的action函数异步 - 飞刀还问情</title>
<link>http://www.cnblogs.com/zhongchao666/p/9478008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhongchao666/p/9478008.html</guid>
<description>&lt;h4 id=&quot;回顾redux-类似于-vuex&quot;&gt;回顾:Redux: 类似于 Vuex&lt;/h4&gt;
&lt;h5 id=&quot;概念storereduceraction&quot;&gt;概念：store/reducer/action&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;action:动作 {type,.....} 一定要有type 其他属性不做限制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;reducer:通过计算产生state&lt;br/&gt;公式：(state,action)=&amp;gt;newState&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;store: 容器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;getState() 获取所有状态&lt;/p&gt;
&lt;p&gt;dispatch(action) dispatch里面可以跟对象和函数， —— 函数需要单独处理——中间件&lt;br/&gt;subscribe(监听函数);—— watch&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;触发条件：&lt;br/&gt;1、dispatch ---&amp;gt; reducer&lt;br/&gt;2、必须产生一个新的状态 newState&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;exp1:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.ction.js
export const PLUS = Symbol(&quot;PLUS&quot;);
export const MINUS = Symbol(&quot;MINUS&quot;);

export function plusAction(){
    return {type:PLUS};
}
export function minusAction(){
    return {type:MINUS};
}

2.reducer.js

import {PLUS} from &quot;./actions&quot;
//数据初始化
const initState = {count:1};

//创建reducer
const reducer = (state = initState,action = {})=&amp;gt;{
    const {type} = action;
    switch(type){
        case PLUS:
            return {...state,count:state.count+1};
        default:
            return state;
    }
}
export default reducer;

3.store

//引入
import {createStore} from &quot;redux&quot;;
import reducer from &quot;./reducer&quot;;
//创建store
const store = createStore(reducer);
store.subscribe(()=&amp;gt;console.log(store.getState()));
export default store;

4.App.js

import React, { Component } from 'react';
class App extends Component {
  render() {
    return (
      &amp;lt;div className=&quot;App&quot;&amp;gt;
        App
      &amp;lt;/div&amp;gt;
    );
  }
}
export default App;

5.Counter.js

//引入
import React,{Component} from &quot;react&quot;;
import {bindActionCreators} from &quot;redux&quot;;
import {connect} from &quot;react-redux&quot;;
import {plusAction,minusAction} from &quot;./actions&quot;;

//创建组件
class Counter extends Component{
    render(){
        console.log(11111,this.props);
        const {count,plusAction} = this.props;

        return (
            &amp;lt;div&amp;gt;
                {count}
                &amp;lt;input onClick={plusAction} value=&quot;+&quot; type=&quot;button&quot;/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
}

const mapStateToProps = state =&amp;gt;({
    count:state.count
});

function mapDispatchToProps(dispatch){
    return bindActionCreators({plusAction,minusAction},dispatch);
}

export default connect(mapStateToProps,mapDispatchToProps)(Counter);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;react-redux-providerconnect&quot;&gt;==react-redux==: {Provider,connect}&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Provider:提供 作用: 把状态 store共享给所有的子组件 包在&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;connect 用法： connect()(Comp); ---&amp;gt; this.props --&amp;gt; {dispatch}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;connect(mapStateToProps,xxxxxxx)(Comp); ---&amp;gt; this.props --&amp;gt;{ state, dispatch }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;exp1:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;index.js

import React from 'react';
import ReactDOM from 'react-dom';
import {Provider} from &quot;react-redux&quot;;

import store from &quot;./Counter/store&quot;;
import App from &quot;./Counter/App&quot;;
import registerServiceWorker from './registerServiceWorker';

ReactDOM.render(
    &amp;lt;Provider store={store}&amp;gt;
        &amp;lt;App /&amp;gt;
    &amp;lt;/Provider&amp;gt;,
    document.getElementById('root'));

registerServiceWorker();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12200279-85ccd42eb9859459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;异步action-在原有的异步函数内-包个函数-函数会有一个dispatch参数&quot;&gt;异步action —— 在原有的异步函数内 包个函数—— 函数会有一个dispatch参数&lt;/h5&gt;
&lt;h4 id=&quot;在action里面有延迟操作定时器数据交互ajaxfetch...&quot;&gt;==在action里面有延迟操作！定时器、数据交互(ajax,fetch...)==&lt;/h4&gt;
&lt;h5 id=&quot;用redux-thunk&quot;&gt;==用redux-thunk==&lt;/h5&gt;
&lt;h6 id=&quot;第一步&quot;&gt;第一步：&lt;/h6&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;1、安装 cnpm i -S redux-thunk&lt;br/&gt;2、引入 import thunk from &quot;redux-thunk&quot;;&lt;br/&gt;3、redux中引入applyMiddleware&lt;br/&gt;&lt;strong&gt;import {createStore,applyMiddleware} from &quot;redux&quot;;&lt;/strong&gt;&lt;br/&gt;4、const store = createStore(reducer,applyMiddleware(thunk));&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;第二步&quot;&gt;第二步：&lt;/h6&gt;
&lt;p&gt;++在异步anctions中使用++&lt;br/&gt;&lt;em&gt;问题1：&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;++定时器++&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;function plusAsyncAction(){
    setTimeout(()=&amp;gt;{  
            return {type:&quot;PLUS&quot;};
    },1000);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过==中间件==来解决&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function plusAsyncAction(){
    return function(dispatch){
        setTimeout(()=&amp;gt;{
              //自己手动派发action
                dispatch({type:&quot;PLUS&quot;});
        },1000);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;exp1:&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;import {createStore,applyMiddleware} from &quot;redux&quot;;引入模块&lt;br/&gt;const store = createStore(reducer,applyMiddleware(thunk)); 使用模块&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import React,{Component} from &quot;react&quot;;
import {createStore,applyMiddleware} from &quot;redux&quot;;
import thunk from &quot;redux-thunk&quot;;

//创建store
//数据初始化
const initState = {count:1};

//创建reducer
const reducer = (state=initState,action={})=&amp;gt;{
    const {type} = action;
    switch(type){
        case &quot;PLUS&quot;:
            return {...state,count:state.count+1};
        default:
            return state;
    }
}

//创建store
const store = createStore(reducer,applyMiddleware(thunk));

function plusAction(){
    return {type:&quot;PLUS&quot;};
}

function plusAsyncAction(){
    return function(dispatch,getState){
        const val = getState();//获取是修改之前的状态
        console.log(val,getState);
        setTimeout(()=&amp;gt;{
            //dispatch({type:&quot;PLUS&quot;});
            dispatch(plusAction());
        },1000)
    }
}

class Counter extends Component{

    constructor(...args){
        super(...args);
        store.subscribe(()=&amp;gt;{
            console.log(store.getState());
            this.forceUpdate();
        });
    }

    plus(){
        store.dispatch(plusAsyncAction());
    }
    render(){
        return (
            &amp;lt;div&amp;gt;
                {store.getState().count}
                &amp;lt;input onClick={this.plus.bind(this)} value=&quot;+&quot; type=&quot;button&quot;/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
}
export default Counter;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;res:&lt;br/&gt;延迟一秒显示&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12200279-b18b63fa72312b84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;问题2：&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;++交互(数据交互(ajax,fetch...))++&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;function fetchAsyncAction(){
        
        fetch(url).then.then(data=&amp;gt;{
            
            return {type:&quot;GET&quot;,payload:data};
        
        })
        
        //return undefined
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过==中间件==来解决&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function fetchAsyncAction(){
        
        return function(dispatch){
            fetch(url).then.then(data=&amp;gt;{
                dispatch({type:&quot;GET&quot;,payload:data});
            })
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;exp2:&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;数据交互&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import React,{Component} from &quot;react&quot;;
import {createStore,applyMiddleware} from &quot;redux&quot;;
import thunk from &quot;redux-thunk&quot;;
const url = &quot;http://localhost:9000/api/v2/movie/in_theaters?city=北京&quot;;
//创建store
//数据初始化
const initState = {subjects:[]};
//创建reducer
const reducer = (state = initState,action = {})=&amp;gt;{
    const {type} = action;
    switch(type){
        case &quot;GET&quot;:
            return {...state,subjects:action.payload};
        default:
            return state;
    }
}
//创建store
const store = createStore(reducer,applyMiddleware(thunk));

function fetchSyncAction(){
    return function(dispatch){
        fetch(url).then(res=&amp;gt;res.json()).then(data=&amp;gt;{
            console.log(data.subjects);
            dispatch({type:&quot;GET&quot;,payload:data.subjects});
        })
    }
}

//创建组件
class Fetch extends Component{
    constructor(...args){
        super(...args);
        store.subscribe(()=&amp;gt;{
            console.log(store.getState());
            this.forceUpdate();
        })
    }
    asyncFecth(){
        store.dispatch(fetchSyncAction());
    }
    fn(){

        //url:&quot;http://api.douban.com/v2/movie/in_theaters?city=北京&quot;,
        //url:&quot;http://localhost:9000/api/v2/movie/in_theaters?city=北京&quot;,
        
        //store.dispatch(plusAsyncAction());
        fetch(url).then(res=&amp;gt;res.json()).then(data=&amp;gt;{
            console.log(data.subjects);

            store.dispatch({type:&quot;GET&quot;,payload:data.subjects});
        })
    }

    render(){
        return (
            &amp;lt;div&amp;gt;
                {
                   store.getState().subjects.map(({id,title})=&amp;gt;{
                    return &amp;lt;div key={id}&amp;gt;{title}&amp;lt;/div&amp;gt;;
                    })
                }
                &amp;lt;input onClick={this.fn.bind(this)} value=&quot;普通fetch&quot; type=&quot;button&quot;/&amp;gt;
                &amp;lt;input onClick={this.asyncFecth.bind(this)} value=&quot;asyncFecth&quot; type=&quot;button&quot;/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }

}

export default Fetch;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;res:&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12200279-38c8da2ef5ccf925.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        dispatch(action)                 
View  -------------------&amp;gt;  reducer ---------&amp;gt; newState 


            异步                                同步
       dispatch(asyncAction)                 dispatch(action)
View  ----------------------&amp;gt; middleware拦截 ---------------&amp;gt;  reducer --------&amp;gt; newState&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;属性验证&quot;&gt;属性验证：&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;安装：cnpm i -D prop-types&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.46666666666667&quot;&gt;
&lt;p&gt;参考:&lt;a href=&quot;https://reactjs.org/docs/typechecking-with-proptypes.html?#___gatsby&quot; class=&quot;uri&quot;&gt;https://reactjs.org/docs/typechecking-with-proptypes.html?#___gatsby&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;Test.propTypes = {
        属性:验证规则
        optionalArray: PropTypes.array,
      optionalBool: PropTypes.bool,
      optionalFunc: PropTypes.func,
      optionalNumber: PropTypes.number,
      optionalObject: PropTypes.object,
      optionalString: PropTypes.string,
      optionalSymbol: PropTypes.symbol,

        
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;exp1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import React, { Component } from &quot;react&quot;;
import PropTypes from &quot;prop-types&quot;;

class Test extends Component {
    //判断name是否是字符串,若不是字符串则报错
    //,isRequired表示空也判断
    //写法二
    static propTypes = {
        name: PropTypes.string.isRequired,
    }
    
  render() {
      const {name} = this.props;
    return (
      &amp;lt;div&amp;gt;属性验证：name: {name}&amp;lt;/div&amp;gt;
    );
  }
}
//写法一
/*Test.propTypes = {
    name: PropTypes.string.isRequired,
}*/

export default Test;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;res:&lt;br/&gt;符合判定不返回任何值,不符合则会报错,并提醒输入的是何种类型数据.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12200279-b90507d0b93e358f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;exp2:&lt;/strong&gt;&lt;br/&gt;自定义属性验证&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import React, { Component } from &quot;react&quot;;
// import PropTypes from &quot;prop-types&quot;;

function Test(props){
    return (
      &amp;lt;div&amp;gt;属性验证：name: {props.name}&amp;lt;/div&amp;gt;
    );
}

const PropTypes = {
    string:function(props, propName, componentName){
        if(typeof props[propName] !== &quot;string&quot;){
            return new Error(`你输入的${propName}我期望的是 字符串 ，但是你给我的是 ${typeof props[propName]} `);
        }

    }
}

Test.propTypes = {
    name:PropTypes.string,
}
export default Test;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;res:&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12200279-1d46d65149f48cff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;在异步anctions中使用的案例&quot;&gt;在异步anctions中使用的案例&lt;/h5&gt;
&lt;h6 id=&quot;豆瓣网&quot;&gt;豆瓣网:&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12200279-4ad9e42070bf8c01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.App.js

import React, { Component } from &quot;react&quot;;
import { Provider} from &quot;react-redux&quot;;
import store from &quot;./store&quot;;
import MoveBox from &quot;./MoveBox&quot;;
import &quot;./index.css&quot;;
let arr = [
  {id:1,city:&quot;北京&quot;},
  {id:2,city:&quot;上海&quot;},
  {id:3,city:&quot;深圳&quot;},
  {id:4,city:&quot;青岛&quot;}
];

class App extends Component {
  render() {
    return (
      &amp;lt;Provider store={store}&amp;gt;
        &amp;lt;div className=&quot;App&quot;&amp;gt;
          &amp;lt;MoveBox arr={arr}/&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/Provider&amp;gt;
    );
  }
}
export default App;
-----------------------------------
2.index.css

.active{background:pink;}
-----------------------------------
3.reducer.js

import {QUERY} from &quot;./actions&quot;

const initState = {
    id:1,
    city:&quot;北京&quot;
};

export default (state = initState,action = {})=&amp;gt;{
    switch(action.type){
        case QUERY:
            return {...state,id:action.payload.id,city:action.payload.city};
        default:
            return state;
    }

};
-------------------------------

4.store.js
import {createStore, applyMiddleware} from &quot;redux&quot;;
import thunk from &quot;redux-thunk&quot;;
import reducer from &quot;./reducer&quot;;
const store = createStore(reducer,applyMiddleware(thunk));

//测试用
store.subscribe(()=&amp;gt;{
    console.log(&quot;store:&quot;,store.getState())
});

export default store;
----------------------------------
5.action.js

export const QUERY = Symbol(&quot;QUERY&quot;);

------------------------------------
6.MoveBox.js
import React, { Component } from &quot;react&quot;;
import { connect } from &quot;react-redux&quot;;
import MoveTitle from &quot;./MoveTitle&quot;;
import MoveList from &quot;./MoveList&quot;;

//url:&quot;http://api.douban.com/v2/movie/in_theaters?city=北京&quot;,
//url:&quot;http://localhost:9000/api/v2/movie/in_theaters?city=北京&quot;,
class MoveBox extends Component {
  render() {
      console.log(&quot;this.props:&quot;,this.props);
      const {id,city,arr} = this.props;
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;MoveTitle id={id} arr={arr}/&amp;gt;
        &amp;lt;MoveList city={city} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

function mapStateToProps(state){
    return {id:state.id,city:state.city};
}

export default connect(mapStateToProps)(MoveBox);
-------------------------------------------
7.MoveTitle.js
import React, { Component } from &quot;react&quot;;
import { connect } from &quot;react-redux&quot;;
import { QUERY } from &quot;./actions&quot;;
class MoveTitle extends Component {


    fn(item){
        this.props.dispatch({type:QUERY,payload:item});
    }

  render() {
      const {id,arr} = this.props; 
    return (
      &amp;lt;ul&amp;gt; 
          {
              arr.map(item=&amp;gt;{
                  return &amp;lt;input onClick={this.fn.bind(this,item)} className={item.id === id?&quot;active&quot;:&quot;&quot;} key={item.id} type=&quot;button&quot; value={item.city}/&amp;gt;
              })
          }
          
      &amp;lt;/ul&amp;gt;
    );
  }
}

export default connect()(MoveTitle);

--------------------------------------
8.MoveList.js
import React, { Component } from &quot;react&quot;;

//http://localhost:9000/api/v2/movie/in_theaters?city=北京&quot;,

const url = &quot;http://localhost:9000/api/v2/movie/in_theaters?city=&quot;;

class MoveList extends Component {

    state = {title:this.props.city,subjects:[]};

    UNSAFE_componentWillReceiveProps(props){

        console.log(&quot;UNSAFE_componentWillReceiveProps&quot;,props,this.props);
        this.featcData(props.city);
    }
    componentDidMount(){
        this.featcData();
    }

    featcData(city){
        city = city||this.props.city
        fetch(`${url}${city}`).then(res=&amp;gt;res.json()).then(data=&amp;gt;{
            console.log(111,data);
            this.setState(data);
        });
    }
  render() {
    return (
      &amp;lt;div&amp;gt; 
        {this.state.title}
        &amp;lt;hr /&amp;gt;
        &amp;lt;ul&amp;gt;
            {
                this.state.subjects.map(item=&amp;gt;{
                    return &amp;lt;li key={item.id}&amp;gt;{item.title}&amp;lt;/li&amp;gt;
                })
            }
        &amp;lt;/ul&amp;gt;


      &amp;lt;/div&amp;gt;
    );
  }
}

export default MoveList;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;res:&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12200279-6fc43839b94c7772.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 Aug 2018 13:27:00 +0000</pubDate>
<dc:creator>飞刀还问情</dc:creator>
<og:description>回顾:Redux: 类似于 Vuex 概念：store/reducer/action action:动作 {type,.....} 一定要有type 其他属性不做限制 reducer:通过计算产生st</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhongchao666/p/9478008.html</dc:identifier>
</item>
<item>
<title>callback vs async.js vs promise  vs async / await - 小蒋不素小蒋</title>
<link>http://www.cnblogs.com/xjnotxj/p/9477987.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjnotxj/p/9477987.html</guid>
<description>&lt;p&gt;需求：&lt;/p&gt;
&lt;p&gt;A、依次读取 A|B|C 三个文件，如果有失败，则立即终止。&lt;br/&gt;B、同时读取 A|B|C 三个文件，如果有失败，则立即终止。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;code&gt;需求A&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  
let read = function (code) {
    if (code) {
        return true;
    } else {
        return false;
    }
}

let readFileA = function (callback) {
    if (read(1)) {
        return callback(null, &quot;111&quot;);
    } else {
        return callback(&quot;a fail&quot;);
    }
}
let readFileB = function (callback) {
    if (read(1)) {
        return callback(null, &quot;222&quot;);
    } else {
        return callback(&quot;b fail&quot;);
    }
}
let readFileC = function (callback) {
    if (read(1)) {
        return callback(null, &quot;333&quot;);
    } else {
        return callback(&quot;c fail&quot;);
    }
}

readFileA(function (err, data) {
    if (err) {
        console.log(&quot;open file &quot; + err);
        return;
    }
    console.log(&quot;读取 a.txt 成功！内容：&quot; + data);
    readFileB(function (err, data) {
        if (err) {
            console.log(&quot;open file &quot; + err);
            return;
        }
        console.log(&quot;读取 b.txt 成功！内容：&quot; + data);
        readFileC(function (err, data) {
            if (err) {
                console.log(&quot;open file &quot; + err);
                return;
            }
            console.log(&quot;读取 c.txt 成功！内容：&quot; + data);
        });
    });
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;return：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;读取 a.txt 成功！内容：111
读取 b.txt 成功！内容：222
读取 c.txt 成功！内容：333&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;code&gt;需求B&lt;/code&gt;：太恶心了，不写了，总之很繁琐.&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;code&gt;async.js&lt;/code&gt;库的详细介绍可以见：[待写]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;需求A&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async.series&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var async = require(&quot;async&quot;);

let read = function (code) {
    if (code) {
        return true;
    } else {
        return false;
    }
}

let readFileA = function (callback) {
    if (read(1)) {
        return callback(null, &quot;111&quot;);
    } else {
        return callback(&quot;a fail&quot;);
    }
}

let readFileB = function (callback) {
    if (read(0)) {
        return callback(null, &quot;222&quot;);
    } else {
        return callback(&quot;b fail&quot;);
    }
}
let readFileC = function (callback) {
    if (read(1)) {
        return callback(null, &quot;333&quot;);
    } else {
        return callback(&quot;c fail&quot;);
    }
}

async.series([readFileA, readFileB, readFileC],
    function (err, datas) {
        if (err) {
            console.log(&quot;open file &quot; + err);
        }
        console.log(datas);
        return;
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当第二个readFileB()读取失败的话：&lt;/p&gt;
&lt;p&gt;return：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;open file b fail
[ '111', undefined ]&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;code&gt;需求B&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async.parallel&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var async = require(&quot;async&quot;);

let read = function (code) {
    if (code) {
        return true;
    } else {
        return false;
    }
}

let readFileA = function (callback) {
    if (read(1)) {
        return callback(null, &quot;111&quot;);
    } else {
        return callback(&quot;a fail&quot;);
    }
}

let readFileB = function (callback) {
    setTimeout(() =&amp;gt; {
        if (read(0)) {
            return callback(null, &quot;222&quot;);
        } else {
            return callback(&quot;b fail&quot;);
        }
    }, 1000);
}

let readFileC = function (callback) {
    if (read(1)) {
        return callback(null, &quot;333&quot;);
    } else {
        return callback(&quot;c fail&quot;);
    }
}

async.parallel([readFileA, readFileB, readFileC],
    function (err, datas) {
        if (err) {
            console.log(&quot;open file &quot; + err);
        }
        console.log(datas);
        return;
    });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当第二个readFileB()读取失败 (注意我给它加了setTimeout，为了体现跟上面串行结果的不一样) 的话：&lt;/p&gt;
&lt;p&gt;return：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;open file b fail
[ '111', undefined, '333' ]&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;总结：async.js跟callback比的好处：&lt;/p&gt;
&lt;p&gt;1、代码量少了，解决了回调地狱金字塔的缺陷&lt;/p&gt;
&lt;p&gt;2、async的第二个参数回调函数里，可以统一处理错误（建议用不同的Error类作区分）&lt;/p&gt;
&lt;p&gt;3、成功返回的结果datas可以汇总到一个数组中方便处理&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;em&gt;[拓展]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;promise 知识&lt;/p&gt;
&lt;h4 id=&quot;new-promise&quot;&gt;&lt;code&gt;new Promise()&lt;/code&gt;&lt;/h4&gt;
&lt;hr/&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//  promise在new的时候已经开始运行
 new Promise(() =&amp;gt; console.log(&quot;I have already started!&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;return:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;I have already started!&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;promise.thensuccesscallback-failurecallback&quot;&gt;&lt;code&gt;promise.then(successCallback, failureCallback);&lt;/code&gt;&lt;/h4&gt;
&lt;hr/&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;new Promise((resolve, reject) =&amp;gt; resolve()).then(function (data) {
    console.log(&quot;success&quot;);
}, function (data) {
    console.log(&quot;fail&quot;);
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;return:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;success&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;promise.catchfailurecallback&quot;&gt;&lt;code&gt;promise.catch(failureCallback)&lt;/code&gt;&lt;/h4&gt;
&lt;hr/&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// promise.catch(failureCallback) 是 promise.then(null, failureCallback) 的缩略形式
new Promise((resolve, reject) =&amp;gt; reject()).catch( function (data) {
    console.log(&quot;fail&quot;);
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;return:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fail&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;链式调用&quot;&gt;&lt;code&gt;链式调用&lt;/code&gt;&lt;/h4&gt;
&lt;hr/&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 链式调用的原理：then函数会返回一个新的promise
new Promise((resolve, reject) =&amp;gt; reject()).then(function (data) {
    console.log(&quot;success_1&quot;);
}, function (err) {
    console.log(&quot;fail_1&quot;);
}).then(function (data) {
    console.log(&quot;success_2&quot;);
}, function (err) {
    console.log(&quot;fail_2&quot;);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;return:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fail_1
success_2&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;提问&quot;&gt;提问&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;问1：&lt;code&gt;then函数&lt;/code&gt;会返回一个新的promise，但是then的successCallback和failureCallback这两个回调函数里都没法调用resolve()和reject()，那这个新的promise如何指定最终状态呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;不返回&lt;/td&gt;
&lt;td&gt;resolve(undefined)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;return 1&lt;/td&gt;
&lt;td&gt;resolve(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;return Promise.resolve()&lt;/td&gt;
&lt;td&gt;resolve()&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;return Promise.reject()&lt;/td&gt;
&lt;td&gt;reject()&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;throw Error()&lt;/td&gt;
&lt;td&gt;reject()&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;return new Promise()&lt;/td&gt;
&lt;td&gt;以此类推&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;而普通的 promise 对象，如果不显示调用 resolve/reject ，则没有任何反应，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;new Promise((resolve, reject) =&amp;gt; {return 1;}).then(function (data) {
    console.log(&quot;success&quot;);
}, function (err) {
    console.log(&quot;fail&quot;);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;return：&lt;/p&gt;
&lt;p&gt;没有任何输出&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;问2：then函数如果&lt;code&gt;successCallback&lt;/code&gt;和&lt;code&gt;failureCallback&lt;/code&gt;都为null，会发生什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什么都不会发生，&lt;code&gt;.then(null, null)&lt;/code&gt;只要一方为null，等于交给下一个then去接管这个回调&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;new Promise((resolve, reject) =&amp;gt; reject())
    .then(null, null)
    .then(null, null)
    .then(null, null)
    .then(null, null)
    .then(function (data) {
        console.log(&quot;success_2&quot;);
    }, function (err) {
        console.log(&quot;fail_2&quot;);
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;所以按照&lt;strong&gt;上面 2 个提问揭示的规律&lt;/strong&gt;，我们可以写成下面&lt;strong&gt;优雅的代码&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 链式调用的原理：then函数会返回一个新的promise
new Promise((resolve, reject) =&amp;gt; resolve()).then((data) =&amp;gt; {
    console.log(&quot;success_1&quot;);
}).then((data) =&amp;gt; {
    console.log(&quot;success_2&quot;);
    throw Error(&quot;error&quot;);
}).then((data) =&amp;gt; {
    console.log(&quot;success_3&quot;);
}).catch((err) =&amp;gt; {
    console.log(err);
}); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;return:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;success_1
success_2
Error: error ……&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：&lt;code&gt;.catch()&lt;/code&gt;后还可以继续接&lt;code&gt;.then()&lt;/code&gt;或&lt;code&gt;.catch()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就达到了如下别人家同步代码的清晰的表达s：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;try {
    let result = syncDoSomething();
    let newResult = syncDoSomethingElse(result);
    let finalResult = syncDoThirdThing(newResult);
    console.log(`Got the final result: ${finalResult}`);
  } catch(error) {
    console.log(error);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;所以，&lt;code&gt;需求A&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
let read = function (code) {
    if (code) {
        return true;
    } else {
        return false;
    }
}

let readFileA = function () {
    return new Promise(function (resolve, reject) {
        if (read(1)) {
            resolve(&quot;111&quot;);
        } else {
            reject(&quot;a fail&quot;);
        }
    });
}
let readFileB = function () {
    return new Promise(function (resolve, reject) {
        if (read(1)) {
            resolve(&quot;222&quot;);
        } else {
            reject(&quot;b fail&quot;);
        }
    });
}
let readFileC = function () {
    return new Promise(function (resolve, reject) {
        if (read(1)) {
            resolve(&quot;333&quot;);
        } else {
            reject(&quot;c fail&quot;);
        }
    });
}

//[串行] 场景：依次预加载多个资源，如果中途有失败，则进入.catch()
readFileA().then(function (data) {
    console.log(&quot;读取 a.txt 成功！内容：&quot; + data);
    return readFileB();
}).then(function (data) {
    console.log(&quot;读取 b.txt 成功！内容：&quot; + data);
    return readFileC();
}).then(function (data) {
    console.log(&quot;读取 c.txt 成功！内容：&quot; + data);
    return &quot;读取结束&quot;;
}).then(function (data) {
    console.log(data);
    return;
}).catch(function (err) {
    console.log(&quot;open file &quot; + err);
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;[拓展]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;promise&lt;/code&gt; vs &lt;code&gt;事件监听&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1\事件对于同一对象上发生多次的事情（如 keyup、touchstart 等）&lt;/p&gt;
&lt;p&gt;通过 .then 形式添加的回调函数，甚至都在异步操作完成之后才被添加的函数，都会被调用，如上所示。&lt;/p&gt;
&lt;p&gt;2\如果 promise 已成功或失败，且您之后添加了成功/失败回调，则将会调用正确的回调，即使事件发生在先。&lt;br/&gt;3\对某些功能可用的准确时间不是那么关注，更多地是关注对结果作出的反应。&lt;br/&gt;4\甚至都在异步操作完成之后才被添加的函数，都会被调用&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;promise 扩展知识&lt;/p&gt;
&lt;h4 id=&quot;promise.resolve-和-promise.reject&quot;&gt;&lt;code&gt;Promise.resolve()&lt;/code&gt; 和 &lt;code&gt;Promise.reject()&lt;/code&gt;&lt;/h4&gt;
&lt;hr/&gt;&lt;p&gt;手动创建一个已经resolve或者reject的promise的快捷方法。&lt;/p&gt;
&lt;h4 id=&quot;promise.all同时实现了需求b&quot;&gt;&lt;code&gt;promise.all&lt;/code&gt;：同时实现了&lt;code&gt;需求B&lt;/code&gt;:&lt;/h4&gt;
&lt;hr/&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//promise.all [并行] 场景：预加载多个资源，都完成后才能进入页面
Promise.all([readFileA(), readFileB(), readFileC()]).then(function (datas) {
    console.log(datas); //所有promise都resolve，返回array
    return;
}).catch(function (err) {
    console.log(&quot;open file &quot; + err); //只要有一个promise是reject，返回这个reject的value
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;promise.race&quot;&gt;&lt;code&gt;promise.race&lt;/code&gt;：&lt;/h4&gt;
&lt;hr/&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//promise.race [并行] 场景：taskA：fetch图片，taskB：settimeout抛错，让两个task赛跑实现请求超时报错功能
Promise.race([taskA(), taskB()]).then(function (data) { //进到resolve还是reject回调只取决于第一个确定状态的Promise
    console.log(data);
    return;
}).catch(function (err) {
    console.log(&quot;读取图片超时&quot;);
})&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;总结：promise跟callback比的好处：&lt;/p&gt;
&lt;p&gt;1、代码量少了，解决了回调地狱金字塔的缺陷&lt;/p&gt;
&lt;p&gt;2、.catch可以统一处理错误（建议用不同的Error类作区分）&lt;/p&gt;

&lt;h3 id=&quot;需求a&quot;&gt;&lt;code&gt;需求A&lt;/code&gt;:&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let read = function (code) {
    if (code) {
        return true;
    } else {
        return false;
    }
}

let readFileA = function () {
    return new Promise(function (resolve, reject) {
        if (read(1)) {
            resolve(&quot;111&quot;);
        } else {
            reject(&quot;a fail&quot;);
        }
    });
}
let readFileB = function () {
    return new Promise(function (resolve, reject) {
        if (read(1)) {
            resolve(&quot;222&quot;);
        } else {
            reject(&quot;b fail&quot;);
        }
    });
}
let readFileC = function () {
    return new Promise(function (resolve, reject) {
        if (read(1)) {
            resolve(&quot;333&quot;);
        } else {
            reject(&quot;c fail&quot;);
        }
    });
}

async function test() {
    try {
        let re_a = await readFileA();
        let re_b = await readFileB();
        let re_c = await readFileC();
        console.log({re_a, re_b, re_c}); //如果都成功，return： { re_a: '111', re_b: '222', re_c: '333' }
    } catch (err) {
        console.log(err); // 如果b失败，return： b fail
    }
}

test(); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：async / await 跟 callback 比的好处：&lt;/p&gt;
&lt;p&gt;1、代码量最少，解决了回调地狱金字塔的缺陷（Promise 通过 then 链来解决callback多层回调金字塔的问题，现在又用 async/await 来进一步优化它）（基于promise的async / await也试图淘汰promise）&lt;/p&gt;
&lt;p&gt;2、.catch可以统一处理错误（建议用不同的Error类作区分）&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;[拓展]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1、async 函数就是 Generator 函数的语法糖，&lt;strong&gt;本质上并不是同步代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、async 用于申明一个 function 是异步的，而 await (async wait) 用于等待一个异步方法执行完成。&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;await 只能出现在 async 函数中，所以在代码的顶层，我们无法使用await，所以添加它.then/catch来处理最终结果或掉落错误是正常的做法。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;try {
        let re_a = await readFileA();
        let re_b = await readFileB();
        let re_c = await readFileC();
        console.log({re_a, re_b, re_c});
    } catch (err) {
        console.log(err);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;return：&lt;/p&gt;
&lt;p&gt;报错&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;或者顶层使用立即执行函数表达式（IIFE）&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;(async () =&amp;gt; {

    try {
        let re_a = await readFileA();
        let re_b = await readFileB();
        let re_c = await readFileC();
        console.log({re_a, re_b, re_c});
    } catch (err) {
        console.log(err);
    } 

})()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;return：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{ re_a: '111', re_b: '222', re_c: '333' }&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;上面的例子还可以这样写：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;async function test() {
    try {
        let re_a = await readFileA();
        let re_b = await readFileB();
        let re_c = await readFileC();
        console.log({re_a, re_b, re_c}); //如果都成功，return： { re_a: '111', re_b: '222', re_c: '333' }
    } catch (err) {
        console.log(err); // 如果b失败，return： b fail
    }
}

test().then(function(data){
    console.log(&quot;success&quot;);
},function(err){
    console.log(&quot;fail&quot;); 
}); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;return：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{ re_a: '111', re_b: '222', re_c: '333' }
success&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、&lt;strong&gt;实际上 async 申明的 function 返回的就是一个 Promise 对象&lt;/strong&gt;，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。&lt;/p&gt;
&lt;p&gt;区别是，&lt;strong&gt;async 申明的 function 里可以通过 return值 / 抛异常 来实现普通 Promise 的 resolve() / reject()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是对等关系：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// async函数
async function foo () {
  return 'a'
}
// Promise
function foo () {
  return Promise.resolve('a')
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// async函数
async function foo () {
  throw new Error('error')
}
// Promise
function foo () {
  return Promise.reject(new Error('error'))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;用promise.all实现需求b&quot;&gt;用&lt;code&gt;promise.all&lt;/code&gt;实现&lt;code&gt;需求B&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;async/await 同样适用于 &lt;code&gt;Promise.all&lt;/code&gt;，因为 Promise.all 本身返回的就是 promise 对象。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let read = function (code) {
    if (code) {
        return true;
    } else {
        return false;
    }
}

let readFileA = function () {
    return new Promise(function (resolve, reject) {
        if (read(1)) {
            resolve(&quot;111&quot;);
        } else {
            reject(&quot;a fail&quot;);
        }
    });
}
let readFileB = function () {
    return new Promise(function (resolve, reject) {
        if (read(1)) {
            resolve(&quot;222&quot;);
        } else {
            reject(&quot;b fail&quot;);
        }
    });
}
let readFileC = function () {
    return new Promise(function (resolve, reject) {
        if (read(1)) {
            resolve(&quot;333&quot;);
        } else {
            reject(&quot;c fail&quot;);
        }
    });
}

async function test() {
    try {
        let re_a = await readFileA();
        let re_b = await readFileB();
        let re_c = await readFileC();
        console.log({re_a, re_b, re_c});
    } catch (err) {
        console.log(err);
    }
}

async function test() {
    try { 
        let results = await Promise.all([
            readFileA(),
            readFileB(),
            readFileC(),  
          ]);
        console.log(results);
    } catch (err) {
        console.log(err);
    }
}

test();&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;#### 参考资料&lt;/p&gt;
&lt;p&gt;[使用 promises]&lt;br/&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises&quot; class=&quot;uri&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[理解 JavaScript 的 async/await]&lt;br/&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007535316&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/a/1190000007535316&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[javascript.info-Async/await]&lt;br/&gt;&lt;a href=&quot;https://javascript.info/async-await#async-functions&quot; class=&quot;uri&quot;&gt;https://javascript.info/async-await#async-functions&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 Aug 2018 13:23:00 +0000</pubDate>
<dc:creator>小蒋不素小蒋</dc:creator>
<og:description>需求： A、依次读取 A|B|C 三个文件，如果有失败，则立即终止。 B、同时读取 A|B|C 三个文件，如果有失败，则立即终止。 一、callback ： return： ：太恶心了，不写了，总之很</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xjnotxj/p/9477987.html</dc:identifier>
</item>
</channel>
</rss>