<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用angular4和asp.net core 2 web api做个练习项目(四) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/7776378.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/7776378.html</guid>
<description>&lt;p&gt;第一部分: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7755801.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/7755801.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二部分: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7763397.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/7763397.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第三部分: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7768147.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/7768147.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;后台代码: &lt;a href=&quot;https://github.com/solenovex/asp.net-core-2.0-web-api-boilerplate&quot; target=&quot;_blank&quot;&gt;https://github.com/solenovex/asp.net-core-2.0-web-api-boilerplate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前台代码: &lt;a href=&quot;https://github.com/solenovex/angular-4-client-panel-app&quot; target=&quot;_blank&quot;&gt;https://github.com/solenovex/angular-4-client-panel-app&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;该系统的大部分页面都应该是用户登陆以后才可以看见, 没有登陆的话直接应该跳转到登陆页面.&lt;/p&gt;
&lt;p&gt;首先建立authguard:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ng g g guards/auth
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
import { Injectable } from '@angular/core'&lt;span&gt;;
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from &lt;/span&gt;'@angular/router'&lt;span&gt;;
import { Observable } from &lt;/span&gt;'rxjs/Observable'&lt;span&gt;;
import &lt;/span&gt;'rxjs/add/operator/map'&lt;span&gt;;
import { User } from &lt;/span&gt;'oidc-client'&lt;span&gt;;
import { AuthService } from &lt;/span&gt;'../services/auth.service'&lt;span&gt;;

@Injectable()
export class AuthGuard implements CanActivate {

  constructor(
    private router: Router,
    private authService: AuthService
  ) { }

  canActivate(): Observable&lt;/span&gt;&amp;lt;&lt;span&gt;boolean&lt;/span&gt;&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.authService.loginStatusChanged.map((user: User) =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (user) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.authService.login();
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    });
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在app.module.ts里面引用并注册:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
import { AuthGuard } from './guards/auth.guard'&lt;span&gt;;

const appRoutes: Routes &lt;/span&gt;=&lt;span&gt; [
  { path: &lt;/span&gt;''&lt;span&gt;, component: DashboardComponent, &lt;span&gt;canActivate: [AuthGuard]&lt;/span&gt; },
  { path: &lt;/span&gt;'login-callback'&lt;span&gt;, component: LoginCallbackComponent },
  { path: &lt;/span&gt;'register'&lt;span&gt;, component: RegisterComponent },
  { path: &lt;/span&gt;'add-client'&lt;span&gt;, component: AddClientComponent, &lt;span&gt;canActivate: [AuthGuard]&lt;/span&gt; },
  { path: &lt;/span&gt;'client/:id'&lt;span&gt;, component: ClientDetailsComponent, &lt;span&gt;canActivate: [AuthGuard]&lt;/span&gt; },
  { path: &lt;/span&gt;'edit-client/:id'&lt;span&gt;, component: EditClientComponent, &lt;span&gt;canActivate: [AuthGuard]&lt;/span&gt; }
];

  providers: [
    ClientService,
    AuthService,
    &lt;span&gt;AuthGuard&lt;/span&gt;
  ],&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要权限控制的路由需要加上 canActivate属性, 它的值是一个数组可以使用多个guards.&lt;/p&gt;
&lt;p&gt;别忘了在providers里面注册一下.&lt;/p&gt;
&lt;p&gt;然后运行.&lt;/p&gt;
&lt;p&gt;进入首页 http://localhost:4200, 如果没登陆, 那么直接跳转到authorization server的登陆页面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103061510138-2080376018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登录成功后, 会跳转到login-callback, 这里有一个地方需要改一下(可能是oidc-client的bug?):&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ngOnInit() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.authService.loginCallBack().subscribe(
      (user: User) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (user) {
         &lt;span&gt; window.location.href &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= '/'&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;
        }
      }
    );
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用的是window.location.href='/', 如果使用angular的路由router.navigate跳转的话会有问题.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103061518654-994492473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登陆成功后跳转到主页.&lt;/p&gt;

&lt;p&gt;由于用户注册是在authorization server进行的, 所以把angular项目中的相关文件以及app.module里面的调用删除...&lt;/p&gt;

&lt;p&gt;我们需要做一些全局的设置, 可以全局控制某些参数, 例如我们的余额是否可以输入.&lt;/p&gt;
&lt;p&gt;建立settings service:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ng g s services/settings
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建立settings model:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ng g interface models/Settings
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成的文件名首字母是小写的, 首字母还是改成大写的吧...&lt;/p&gt;
&lt;p&gt;Settings.ts:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export interface Settings {
  disableBalanceOnAdd&lt;/span&gt;?: &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;;
  disableBalanceOnEdit&lt;/span&gt;?: &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;settings.service.ts:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import { Injectable } from '@angular/core'&lt;span&gt;;
import { Settings } from &lt;/span&gt;'../models/Settings'&lt;span&gt;;

@Injectable()
export class SettingsService {

  private _settings: Settings &lt;/span&gt;=&lt;span&gt; {
    disableBalanceOnAdd: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    disableBalanceOnEdit: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  };

  constructor() { }

  get settings() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._settings;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再app.module.ts里面注册:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
import { SettingsService } from './services/settings.service'&lt;span&gt;;
providers: [

    ClientService,
    AuthService,
    &lt;span&gt;SettingsService,&lt;/span&gt;
    AuthGuard
  ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们使用settings service.&lt;/p&gt;
&lt;p&gt;在add-client.component.ts里面:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
import { SettingsService } from '../../services/settings.service'&lt;span&gt;;

public disableBalanceOnAdd &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

  constructor(
    public flashMessagesService: FlashMessagesService,
    public router: Router,
    public clientService: ClientService,
   &lt;span&gt; public settingsService: SettingsService&lt;/span&gt;
  ) { }

  ngOnInit() {
    &lt;/span&gt;&lt;span&gt;this.disableBalanceOnAdd = this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.settingsService.settings.disableBalanceOnAdd;&lt;/span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行一下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103064815498-873546669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现点击添加按钮不起作用!!!!, 点击明细也不起作用!!!!&lt;/p&gt;
&lt;p&gt;后来发现, 是auth service和auth guard里面写错了, 先修改auth service:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  tryGetUser() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Observable.fromPromise(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.manager.getUser());
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把这个方法改成public的.&lt;/p&gt;
&lt;p&gt;然后修改: auth guard:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  canActivate(): Observable&amp;lt;&lt;span&gt;boolean&lt;/span&gt;&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.authService&lt;span&gt;.tryGetUser()&lt;/span&gt;.map((user: User) =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (user) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.authService.login();
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    });
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这次再试试, 就没有问题了. 进入添加客户页面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103065042888-1114649303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个栏位的状态会根据settings里面的设置而变化.&lt;/p&gt;
&lt;p&gt;同样在edit-client里面修改一下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
import { SettingsService } from '../../services/settings.service'&lt;span&gt;;

disableBalanceOnEdit &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

  constructor(
    public clientService: ClientService,
    public router: Router,
    public route: ActivatedRoute,
    public flashMessagesService: FlashMessagesService,
   &lt;span&gt; public settingsService: SettingsService&lt;/span&gt;
  ) { }

  ngOnInit() {
    &lt;/span&gt;&lt;span&gt;this.disableBalanceOnEdit = this.settingsService.settings.disableBalanceOnEdit;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取ID&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.id = &lt;span&gt;this&lt;/span&gt;.route.snapshot.params['id'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取Client&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.clientService.getOne(+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.id).subscribe(
      client &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.client =&lt;span&gt; client;
      }
    );
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行一下, 应该好用!&lt;/p&gt;

&lt;p&gt;需要改一下setting.serviec, 将使用localstorage来存储settings:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import { Injectable } from '@angular/core'&lt;span&gt;;
import { Settings } from &lt;/span&gt;'../models/Settings'&lt;span&gt;;

@Injectable()
export class SettingsService {

  private _settings: Settings &lt;/span&gt;=&lt;span&gt; {
    disableBalanceOnAdd: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    disableBalanceOnEdit: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  };

  constructor() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (localStorage.getItem('settings'&lt;span&gt;)) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._settings = JSON.parse(localStorage.getItem('settings'&lt;span&gt;));
    }
  }

  get settings() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._settings;
  }

  set settings(value: Settings) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._settings =&lt;span&gt; value;
    localStorage.setItem(&lt;/span&gt;'settings', JSON.stringify(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._settings));
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后打开settings.component.ts:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
import { Component, OnInit } from '@angular/core'&lt;span&gt;;
import { SettingsService } from &lt;/span&gt;'../../services/settings.service'&lt;span&gt;;
import { Router } from &lt;/span&gt;'@angular/router'&lt;span&gt;;
import { FlashMessagesService } from &lt;/span&gt;'angular2-flash-messages'&lt;span&gt;;
import { Settings } from &lt;/span&gt;'../../models/Settings'&lt;span&gt;;

@Component({
  selector: &lt;/span&gt;'app-settings'&lt;span&gt;,
  templateUrl: &lt;/span&gt;'./settings.component.html'&lt;span&gt;,
  styleUrls: [&lt;/span&gt;'./settings.component.css'&lt;span&gt;]
})
export class SettingsComponent implements OnInit {

  settings: Settings;

  constructor(
    private settingsService: SettingsService,
    private flashMessagesService: FlashMessagesService,
    private router: Router
  ) { }

  ngOnInit() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.settings = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.settingsService.settings;
  }

  onSubmit() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.settingsService.settings = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.settings;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.flashMessagesService.show('Settings 保存了', { cssClass: 'alert-success', timeout: 4000&lt;span&gt; });
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个很简单.&lt;/p&gt;
&lt;p&gt;然后是html:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;row&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-md-6&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;routerLink&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-link&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-arrow-circle-o-left&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 回到Dashboard&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-md-6&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;card&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;card-header&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;编辑 Settings&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;card-body&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;(submit)&lt;/span&gt;&lt;span&gt;=&quot;onSubmit()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;disableBalanceOnAdd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Disable Blance on Add&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;disableBalanceOnAdd&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;disableBalanceOnAdd&quot;&lt;/span&gt;&lt;span&gt; [(ngModel)]&lt;/span&gt;&lt;span&gt;=&quot;settings.disableBalanceOnAdd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;disableBalanceOnEdit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Disable Blance on Edit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;disableBalanceOnEdit&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;disableBalanceOnEdit&quot;&lt;/span&gt;&lt;span&gt; [(ngModel)]&lt;/span&gt;&lt;span&gt;=&quot;settings.disableBalanceOnEdit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-primary btn-block&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Submit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;别忘了在app.module里面添加路由:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
const appRoutes: Routes =&lt;span&gt; [
  { path: &lt;/span&gt;''&lt;span&gt;, component: DashboardComponent, canActivate: [AuthGuard] },
  { path: &lt;/span&gt;'login-callback'&lt;span&gt;, component: LoginCallbackComponent },
  { path: &lt;/span&gt;'add-client'&lt;span&gt;, component: AddClientComponent, canActivate: [AuthGuard] },
  { path: &lt;/span&gt;'client/:id'&lt;span&gt;, component: ClientDetailsComponent, canActivate: [AuthGuard] },
  { path: &lt;/span&gt;'edit-client/:id'&lt;span&gt;, component: EditClientComponent, canActivate: [AuthGuard] },
 &lt;span&gt; { path: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;'settings', component: SettingsComponent, canActivate: [AuthGuard] },
  { path: '**'&lt;/span&gt;&lt;span&gt;&lt;span&gt;, component: PageNotFoundComponent }&lt;/span&gt;
];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;顺便把page Not found的路由也加上, 使用 ** wildcard.&lt;/p&gt;
&lt;p&gt;最后在navbar.html 添加上链接按钮:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;*ngIf&lt;/span&gt;&lt;span&gt;=&quot;isLoggedIn&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;nav-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-link&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; routerLink&lt;/span&gt;&lt;span&gt;=&quot;/settings&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Settings &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行一下试试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103071634185-845263468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刷新, 查看添加和编辑页面,再刷新, 应该好用.&lt;/p&gt;
&lt;p&gt;这个联系项目就到这了.&lt;/p&gt;
&lt;p&gt;然后我要用asp.net core 2.0 web api 和 identity server 4 以及 angular 5 做一个项目了(angular 5正式版刚刚出来), 大约 300个页面......&lt;/p&gt;
&lt;p&gt;也许之前还要做一个练习..请各位指教...&lt;/p&gt;

</description>
<pubDate>Thu, 02 Nov 2017 23:19:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/7776378.html</dc:identifier>
</item>
<item>
<title>Linux系列教程（十一）——Linux软件包管理之RPM命令 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/7751268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/7751268.html</guid>
<description>&lt;p&gt;　　前面我们介绍了Linux系统的常用命令介绍和文本编辑器vim命令的介绍。那么从这篇博客开始，我们会正式的讲解Linux的系统管理，首先要讲的是Linux的软件包管理。&lt;/p&gt;
&lt;h3&gt;1、Linux软件包分类&lt;/h3&gt;
&lt;h4&gt;　　一、源码包&lt;/h4&gt;
&lt;p&gt;　　　　源码包能直接看到源码，安装时需要人为手工设置安装位置，一般是/usr/local/软件名/。源码包的升级版——脚本安装包，人为的改动源码使其有安装界面。&lt;/p&gt;
&lt;p&gt;　　　　优点：&lt;/p&gt;
&lt;p&gt;　　　　①、开源，如果有足够的能力，可以直接修改源代码。&lt;/p&gt;
&lt;p&gt;　　　　②、安装时可以自由选择所需的功能。&lt;/p&gt;
&lt;p&gt;　　　　③、软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高。&lt;/p&gt;
&lt;p&gt;　　　　④、卸载方便，直接删了你安装软件的那个目录就好了。&lt;/p&gt;
&lt;p&gt;　　　　缺点：&lt;/p&gt;
&lt;p&gt;　　　　①、安装步骤较多，尤其安装较大的软件集合时，容易出现拼写错误。&lt;/p&gt;
&lt;p&gt;　　　　②、编译时间过长，比后面讲的二进制安装时间长。&lt;/p&gt;
&lt;p&gt;　　　　③、因为是编译安装，安装过程中一旦报错新手很难解决。&lt;/p&gt;

&lt;h4&gt;　　二、二进制包&lt;/h4&gt;
&lt;p&gt;　　　　这里的二进制包最要包括centos中的rpm包。rpm包有默认安装位置。/etc/ 配置文件安装目录；/usr/bin/ 可执行的命令安装目录；/usr/lib/ 程序所使用的函数库保存位置；/usr/share/doc/ 基本的软件使用手册保存位置；/usr/share/man/ 帮助文件保存位置。&lt;/p&gt;
&lt;p&gt;　　　　优点：&lt;/p&gt;
&lt;p&gt;　　　　①、包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载。&lt;/p&gt;
&lt;p&gt;　　　　②、安装速度比源码包快很多。&lt;/p&gt;
&lt;p&gt;　　　　缺点：CentOS-6.8-x86_64-bin-DVD1.iso&lt;/p&gt;
&lt;p&gt;　　　　①、已经经过编译了，看不到源代码。&lt;/p&gt;
&lt;p&gt;　　　　②、功能选择不如源代码包灵活。&lt;/p&gt;
&lt;p&gt;　　　　③、安装过程中有很多依赖的包，依赖性不好解决。&lt;/p&gt;

&lt;h3&gt;2、rpm 包命名规则&lt;/h3&gt;
&lt;p&gt;　　我们打开前面安装Linux系统的安装文件 CentOS-6.8-x86_64-bin-DVD1.iso。在package目录下都是rpm安装文件。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171101211938357-1122466240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们以 httpd-2.2.15-53.el6.centos.x86_64.rpm 文件为例来看rpm包的命名规则。&lt;/p&gt;
&lt;p&gt;　　①、httpd:软件包名&lt;/p&gt;
&lt;p&gt;　　②、2.2.15：软件版本&lt;/p&gt;
&lt;p&gt;　　③、15：软件发布的次数&lt;/p&gt;
&lt;p&gt;　　④、el6.centos：适合的Linux平台&lt;/p&gt;
&lt;p&gt;　　⑤、x86_64：适合的硬件平台，这里表示64位。&lt;/p&gt;
&lt;p&gt;　　⑥、rpm：rpm包的扩展名，注意Linux是没有扩展名的概念，这里是告诉管理员这是一个rpm包文件。&lt;/p&gt;

&lt;h3&gt;3、rpm包安装&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171101214951201-1060614410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　范例：以安装 httpd-2.2.15-53.el6.centos.x86_64.rpm 为例：&lt;/p&gt;
&lt;p&gt;　　　　我们进入到该rpm文件的挂载目录 /mnt/cdrom/Packages，执行命令：rpm -ivh httpd-2.2.15-53.el6.centos.x86_64.rpm&lt;/p&gt;
&lt;p&gt;　　注意：这种安装方法可能需要先安装各种依赖，安装过程特别繁琐，后面讲解yum安装会简单的多。&lt;/p&gt;

&lt;h3&gt;4、rpm包升级&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171101215242826-1964547615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5、rpm包卸载&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171101215313545-1834660725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;6、查询rpm包是否安装&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171101215513357-1371896459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171101215836201-796294074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;7、查询软件包的详细信息&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171101215539107-184003138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171101215858076-1309181871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;8、查询软件包的安装位置　　&lt;/h3&gt;
&lt;p&gt; 　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171101215615513-1264025821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171101215956404-205009069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;9、查询系统文件属于哪个RPM包&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171101215657388-212472999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;10、查询软件包的依赖性&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171101215728201-2103368753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;11、总结&lt;/h3&gt;
&lt;p&gt;　　本篇博客主要介绍了rpm包。包括rpm包的命名规则、安装、升级、卸载等，还有如何查询rpm包的相关信息。这里如果大家使用rpm命令手动安装某个软件包，你会发现安装遇到到的依赖让你痛不欲生，安装一个rpm时会要先先安装某个依赖的rpm，而安装这个依赖的rpm包是可能又必须先安装它所依赖的。在实际操作中，我们肯定是不会使用rpm命令手动安装软件包的，那么有更简单的方法吗？答案是肯定的，下一篇博客我们将介绍RPM包管理——yum在线管理。&lt;/p&gt;

</description>
<pubDate>Thu, 02 Nov 2017 22:45:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/7751268.html</dc:identifier>
</item>
<item>
<title>使用gitbook - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/7769281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/7769281.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　gitbook功能强大，可以自动实现搜索及翻页等功能，上手容易，用markdown书写即可，且可以自动生成响应式网站。本文将详细介绍如何使用gitbook&lt;/p&gt;

&lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;　　1、使用npm全局安装gitbook-cli&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install gitbook-cli -g
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/740839/201711/740839-20171101145523404-1390415700.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　2、使用gitbook --version来查看gitbook的版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
gitbook --version
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/740839/201711/740839-20171101145915123-736321935.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　3、接下来对gitbook进行基础配置，创建并进入一个笔记文件夹&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mkdir myNote
cd myNode&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、初始化gitbook，会自动生成两个文件。README.md用于书籍介绍，SUMMARY.md用于设置书籍的目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
gitbook init
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/740839/201711/740839-20171101150529216-784275256.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　5、接着，使用gitbook serve命令来启动gitbook本地服务器，预览默认的书籍内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
gitbook serve
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/740839/201711/740839-20171101150958045-56053908.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　6、打开localhost:4000，会出现如下页面&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/740839/201711/740839-20171101151055779-1305785437.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　7、使用gitbook install命令来安装插件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
gitbook install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8、生成静态网页&lt;/p&gt;
&lt;p&gt;　　使用gitbook build命令，gitbook把md文件构建成静态网页&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
gitbook build #生成静态网页
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;目录结构&lt;/h3&gt;
&lt;p&gt;　　GitBook 基本的目录结构如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.
├── book.json
├── README.md
├── SUMMARY.md
├── chapter&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;/
|&lt;span&gt;   ├── README.md
&lt;/span&gt;|&lt;span&gt;   └── something.md
└── chapter&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;
    ├── README.md
    └── something.md&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【book.json】&lt;/p&gt;
&lt;p&gt;　　该文件用于存放配置信息&lt;/p&gt;
&lt;p&gt;【Glossary.md】&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　允许指定要显示为注释的术语及其各自的定义。&lt;/span&gt;&lt;span&gt;根据这些条款，GitBook将自动构建一个索引并突出显示这些术语&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　该&lt;/span&gt;&lt;/span&gt;&lt;code&gt;GLOSSARY.md&lt;/code&gt;&lt;span&gt;&lt;span&gt;格式是列表&lt;/span&gt;&lt;/span&gt;&lt;code&gt;h2&lt;/code&gt;&lt;span&gt;&lt;span&gt;的标题，以及描述项一起&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;## Term
Definition &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt; term

## Another term
With it&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s definition, this can contain bold text&lt;/span&gt;
and all other kinds of inline markup ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【README.md】&lt;/p&gt;
&lt;p&gt;　　书本的第一页内容是从文件 &lt;code&gt;README.md&lt;/code&gt; 中提取的。如果这个文件名没有出现在 &lt;code&gt;SUMMARY&lt;/code&gt; 中，那么它会被添加为章节的第一个条目&lt;/p&gt;
&lt;p&gt;【.bookignore】&lt;/p&gt;
&lt;p&gt;　　GitBook将读取&lt;code&gt;.gitignore&lt;/code&gt;，&lt;code&gt;.bookignore&lt;/code&gt;以及&lt;code&gt;.ignore&lt;/code&gt;文件以获得文件和文件夹跳过列表&lt;/p&gt;
&lt;p&gt;【SUMMARY.md】&lt;/p&gt;
&lt;p&gt;　　该文件用于存放GitBook的文件目录信息，左侧的目录就是根据这个文件来生成的，默认对应的文件是 &lt;code&gt;SUMMARY.md&lt;/code&gt;，可以在 &lt;code&gt;book.json&lt;/code&gt; 重新定义该文件的对应值。它通过Markdown中的列表语法来表示文件的父子关系&lt;/p&gt;
&lt;p&gt;　　[注意]不被&lt;code&gt;SUMMARY.md&lt;/code&gt;包含的文件不会被&lt;code&gt;gitbook&lt;/code&gt;处理.&lt;/p&gt;
&lt;p&gt;　　该文件基本的写法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Summary

&lt;/span&gt;* [Part I](part1/&lt;span&gt;README.md)
    &lt;/span&gt;* [Writing &lt;span&gt;is&lt;/span&gt; nice](part1/&lt;span&gt;writing.md)
    &lt;/span&gt;* [GitBook &lt;span&gt;is&lt;/span&gt; nice](part1/&lt;span&gt;gitbook.md)
&lt;/span&gt;* [Part II](part2/&lt;span&gt;README.md)
    &lt;/span&gt;* [We love feedback](part2/&lt;span&gt;feedback_please.md)
    &lt;/span&gt;* [Better tools &lt;span&gt;for&lt;/span&gt; authors](part2/better_tools.md)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　目录中的章节可以使用锚点指向文件的特定部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Summary

### Part I

&lt;/span&gt;* [Part I](part1/&lt;span&gt;README.md)
    &lt;/span&gt;* [Writing &lt;span&gt;is&lt;/span&gt; nice](part1/&lt;span&gt;README.md#writing)
    &lt;/span&gt;* [GitBook &lt;span&gt;is&lt;/span&gt; nice](part1/&lt;span&gt;README.md#gitbook)
&lt;/span&gt;* [Part II](part2/&lt;span&gt;README.md)
    &lt;/span&gt;* [We love feedback](part2/&lt;span&gt;README.md#feedback)
    &lt;/span&gt;* [Better tools &lt;span&gt;for&lt;/span&gt; authors](part2/README.md#tools)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　目录可以分为以标题或水平线分隔的部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Summary

### Part I

&lt;/span&gt;* [Writing &lt;span&gt;is&lt;/span&gt; nice](part1/&lt;span&gt;writing.md)
&lt;/span&gt;* [GitBook &lt;span&gt;is&lt;/span&gt; nice](part1/&lt;span&gt;gitbook.md)

### Part II

&lt;/span&gt;* [We love feedback](part2/&lt;span&gt;feedback_please.md)
&lt;/span&gt;* [Better tools &lt;span&gt;for&lt;/span&gt; authors](part2/&lt;span&gt;better_tools.md)

&lt;/span&gt;----

* [Last part without title](part3/title.md)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;配置&lt;/h3&gt;
&lt;p&gt;　　下面是book.json中的一些配置信息&lt;/p&gt;
&lt;p&gt;【title】&lt;/p&gt;
&lt;p&gt;　　书本的标题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小火柴的前端小册子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【author】&lt;/p&gt;
&lt;p&gt;　　作者的相关信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiaohuochai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【description】&lt;/p&gt;
&lt;p&gt;　　本书的简单描述&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小火柴的前端学习记录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【language】&lt;/p&gt;
&lt;p&gt;　　Gitbook使用的语言&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;language&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zh-hans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【root】&lt;/p&gt;
&lt;p&gt;　　指定存放 GitBook 文件（除了 book.json）的根目录&lt;/p&gt;
&lt;p&gt;　　如果目录结构如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.
├── book.json
└── docs&lt;/span&gt;/&lt;span&gt;
    ├── README.md
    └── SUMMARY.md&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　则可以这样设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./docs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【structure】&lt;/p&gt;
&lt;p&gt;　　指定自述文件，摘要，词汇表等的路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;变量   　　　　　　　　 描述
structure.readme     自述文件名（默认为README.md）
structure.summary    摘要文件名（默认为SUMMARY.md）
structure.glossary   词汇表文件名（默认为GLOSSARY.md）
structure.languages  语言文件名（默认为LANGS.md）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【variables】&lt;/p&gt;
&lt;p&gt;　　可以通过{{book.value}}来获取变量，变量会从书本内容中寻找对应的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;variables&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }   &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【link】&lt;/p&gt;
&lt;p&gt;　　插件中的链接(null: default, false: remove, string: new value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;links&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Custom links at top of sidebar&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sidebar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Custom link name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://xiaohuochai.site&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sharing links&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sharing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;facebook&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;twitter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;weibo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;all&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;插件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;plugins　　        要加载的插件列表
pluginsConfig　  插件配置&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　gitbook默认带有6个插件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;highlight
search
sharing
font&lt;/span&gt;-&lt;span&gt;settings
livereload&lt;br/&gt;lunr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果要去除自带的插件， 可以在插件名称前面加&lt;code&gt;-&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面来介绍一些常用的插件&lt;/p&gt;
&lt;p&gt;【打赏功能：donate】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;donate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pluginsConfig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;donate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wechat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;例：/images/qr.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alipay&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://blog.willin.wang/static/images/qr.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;默认空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;默认值：Donate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alipayText&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;默认值：支付宝捐赠&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wechatText&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;默认值：微信捐赠&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【中文搜索：search-plus】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    plugins: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-lunr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;search-plus&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【广告功能：ad】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pluginsConfig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;contentTop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;Ads at the top of the page&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;contentBottom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%3Cdiv%3EAds%20at%20the%20bottom%20of%20the%20page%3C/div%3E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; note: contentBottom is escape('&amp;lt;div&amp;gt;Ads at the bottom of the page&amp;lt;/div&amp;gt;')&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【目录宽度可调节：splitter】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;splitter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【github图标】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;github&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ],
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pluginsConfig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;github&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://github.com/your/repo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【自定义页脚：tbfed-pagefooter】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tbfed-pagefooter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ],
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pluginsConfig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tbfed-pagefooter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
             &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;copyright&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;copy Taobao FED Team&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
             &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;modify_label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该文件修订时间：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
             &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;modify_format&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YYYY-MM-DD HH:mm:ss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    }
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【目录章节可折叠：&lt;code&gt;expandable-chapters&lt;/code&gt;】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    {
        plugins: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;expandable-chapters&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    }
    {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pluginsConfig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;expandable-chapters&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{}
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【畅言评论：changyan】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;changyan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    ],
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pluginsConfig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;changyan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;your changyan's appid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;conf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the conf in the code generate by changyan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【返回顶部：back-to-top-button】 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;back-to-top-button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【更换ico：favicon】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;favicon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    ],
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pluginsConfig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;favicon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shortcut&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;assets/images/favicon.ico&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bookmark&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;assets/images/favicon.ico&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appleTouch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;assets/images/apple-touch-icon.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appleTouchMore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;120x120&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;assets/images/apple-touch-icon-120x120.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;180x180&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;assets/images/apple-touch-icon-180x180.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;主题&lt;/h3&gt;
&lt;p&gt;　　目前 GitBook 提供了三类文档： Book 文档、API文档、FAQ文档。常用的是 Book 文档模式，如果需要使用 API 文档模式或者 FAQ 文档模式，只需引入文档对应的主题插件即可&lt;/p&gt;
&lt;p&gt;【Book】&lt;/p&gt;
&lt;p&gt; 　　Book 是常用的模式，大部分插件也都是针对这个模式做的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　　theme-default&lt;/code&gt; 是默认的 Book 主题。将 &lt;code&gt;showLevel&lt;/code&gt; 设为 &lt;code&gt;true&lt;/code&gt;， 就可以显示标题前面的数字索引，默认不显示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;theme-default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;showLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　them-comscore是另一个Book主题，可以为标题添加颜色&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;theme-comscore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【API】&lt;/p&gt;
&lt;p&gt;　　GitBook 同样可以编写 API 文档，只需要引入 &lt;code&gt;theme-api&lt;/code&gt; 插件，引入之后会替换默认的样式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;theme-api&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pluginsConfig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;theme-api&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;theme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dark&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【FAQ】&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　　theme-faq&lt;/code&gt; 插件主要用来制作知识库或者帮助中心，GitBook 的 帮助中心 就是使用的该主题。为了支持中文搜索需要引入 &lt;code&gt;search-pro&lt;/code&gt; 包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;theme-faq&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-lunr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;search-pro@^2.0.2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　编写帮助中心很简单，在 &lt;code&gt;Summary&lt;/code&gt; 里配置问题以及答案所在的文件，在对应文件中写入问题的答案即可&lt;/p&gt;
&lt;p&gt;　　[注意]由于FAQ主题默认会调用maxcdn里的bootstrap和fontawesome，所以对于国内用户来说，可访问性不是很好&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Summary

## HTML
&lt;/span&gt;*&lt;span&gt; [介绍](README.md)
&lt;/span&gt;*&lt;span&gt; [语法介绍](introduce.md)
&lt;/span&gt;* [结构](&lt;span&gt;struct&lt;/span&gt;&lt;span&gt;.md)

## HTTP
&lt;/span&gt;*&lt;span&gt;  [HTTP](HTTP.md)

## CSS
&lt;/span&gt;*&lt;span&gt; [display](display.md)
&lt;/span&gt;* [&lt;span&gt;float&lt;/span&gt;](&lt;span&gt;float&lt;/span&gt;&lt;span&gt;.md)
&lt;/span&gt;*&lt;span&gt; [absolute](absolute.md)
&lt;/span&gt;* [relative](relative.md)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;修改内容&lt;/h3&gt;
&lt;p&gt;　　下面在初始化的gitbook的基础上修改内容，并制作一个简单的电子书&lt;/p&gt;
&lt;p&gt;　　[注意]gitbook需要掌握markdown语法，详细信息&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/6211447.html&quot; target=&quot;_blank&quot;&gt;移步至此&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　修改目录文件SUMMARY.md&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Summary

&lt;/span&gt;*&lt;span&gt; [前言](README.md)
&lt;/span&gt;*&lt;span&gt; [HTML](HTML.md)
&lt;/span&gt;*&lt;span&gt; [CSS](CSS.md)
&lt;/span&gt;*&lt;span&gt; [JS](JS.md)
&lt;/span&gt;*&lt;span&gt; [ES6](ES6.md)
&lt;/span&gt;*&lt;span&gt; [HTTP](HTTP.md)
&lt;/span&gt;*&lt;span&gt; [前端框架](FELib.md)
    &lt;/span&gt;*&lt;span&gt; [Bootstrap](bs.md)
    &lt;/span&gt;*&lt;span&gt; [jQuery](jq.md)
    &lt;/span&gt;*&lt;span&gt; [Vue](vue.md)
&lt;/span&gt;*&lt;span&gt; [前端构建](build.md)
&lt;/span&gt;*&lt;span&gt; [版本管理](version.md)
&lt;/span&gt;*&lt;span&gt; [后端相关](BELib.md)
    &lt;/span&gt;*&lt;span&gt; [PHP](php.md)
    &lt;/span&gt;*&lt;span&gt; [MySQL](mysql.md)
    &lt;/span&gt;*&lt;span&gt; [NodeJS](node.md)
    &lt;/span&gt;*&lt;span&gt; [MongoDB](mongo.md)
&lt;/span&gt;*&lt;span&gt; [服务器端](server.md)
&lt;/span&gt;*&lt;span&gt; [辅助工具](helper.md)
&lt;/span&gt;*&lt;span&gt; [术语表](Glossary.md)
&lt;/span&gt;* [参考资料](Resources.md)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改book.json文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FE-booklet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小火柴的前端小册子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiaohuochai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;language&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zh-hans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;links&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sidebar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小火柴的博客&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://webhuochai.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;styles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;website&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;style.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;variables&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cdn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;://static.xiaohuochai.site/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-lunr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-search&lt;/span&gt;&lt;span&gt;&quot;,&lt;br/&gt;&quot;-livereload&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-sharing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;expandable-chapters&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;search-plus&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;splitter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;github&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tbfed-pagefooter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;back-to-top-button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;
  ],
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pluginsConfig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;github&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://github.com/littlematch0123/FE-booklet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tbfed-pagefooter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;copyright&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;copy; xiaohuochai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;modify_label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件修订时间：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;modify_format&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YYYY-MM-DD HH:mm:ss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最终效果如下&lt;/p&gt;


</description>
<pubDate>Thu, 02 Nov 2017 20:40:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/7769281.html</dc:identifier>
</item>
<item>
<title>javascript 之执行环境-08 - 风吹De麦浪</title>
<link>http://www.cnblogs.com/CandyManPing/p/7775506.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CandyManPing/p/7775506.html</guid>
<description>&lt;p&gt;&lt;strong&gt;执行环境&lt;/strong&gt;（Execution context，简称EC）或执行上下文对象（后面统一用执行上下文表示），它定义了变量或者函数有权访问的其他数据，决定了他们各自的行为。是不是有点不好理解，那我先简单翻译下： js代码执行时所在的环境。继续后面&lt;/p&gt;
&lt;p&gt;在JavaScript中执行环境分三种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;全局执行环境 ： 这个是最外围的执行环境，一旦代码被载入，引擎最先进入的就是这个环境。在浏览器中，全局环境就是window对象，因此所有全局属性和函数都是作为window对象的属性和方法创建。全局执行环境直到应用程序退出时才会被销毁。  &lt;/li&gt;
&lt;li&gt;函数执行环境：当执行流执行一个函数时，javascript会创建一个新的函数执行环境，函数执行环境中的代码执行完之后，该环境销毁，保存在其中的所有变量和函数定义也被之销毁。&lt;/li&gt;
&lt;li&gt;Eval（一个普通函数，但是他有一个快速通道通向编译器，可以将string变成可执行的代码）执行环境 ： Eval的执行环境和函数调用的执行环境相同。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么现在问题来了，平时工作中写的全局变量，函数以及嵌套函数应该不少了吧，每执行一个函数就会创建一个新的函数执行上下文，想想那么多执行上下文是不是有点恐怖，那么js又是如何管理那么多的执行上下文呢？&lt;/p&gt;
&lt;p&gt;当执行流执行一个函数时，就会给当前函数创建执行上下文，并且将该执行上下文被推入一个&lt;span&gt;&lt;strong&gt;执行上下文栈中（Execution context stack，ECS）&lt;/strong&gt;&lt;/span&gt;，在函数执行完之后，&lt;span&gt;&lt;strong&gt;执行上下文栈&lt;/strong&gt;&lt;/span&gt;将被弹出，并且把控制器返回给之前执行的执行上下文；&lt;/p&gt;
&lt;p&gt;根据工作原理执行上下文栈类似一个数组结构 ，我们模拟执行上下文栈的行为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ECStack = [];  //先定义执行上下文栈是一个数组：
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，用 globalEC表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalEC：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ECStack =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    globalEC
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; ];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在 JavaScript 遇到下面的这段代码了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; run3() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         console.log('run3'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; run2() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        run3();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; run1() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        run2();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    run1();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 伪代码&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; run1() 推入执行上下文栈&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     ECStack.push(run1.EC&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; run1中调用了run2，创建run2的执行上下文 推入执行上下文栈&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     ECStack.push(run2.&lt;span&gt;EC);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; run2还调用了run3，创建run3的执行上下文 推入执行上下文栈&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     ECStack.push(run3.EC&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; run3执行完毕&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    ECStack.pop();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; run2执行完毕&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    ECStack.pop();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; run1执行完毕&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    ECStack.pop();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; javascript接着执行下面的代码，但是ECStack底层永远有个globalContext，直到应用程序退出（例如关闭网页）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行环境（Execution context，简称EC）或执行上下文对象，它定义了变量或者函数有权访问的其他数据，决定了他们各自的行为。&lt;/p&gt;
&lt;p&gt;当执行流进入一个函数时，创建执行上下文对象，然后推入执行上下文栈。是不是感觉跟定义相差太远，难道是《javascript高程程序设计》写错了？&lt;/p&gt;
&lt;p&gt;当然不是，执行上下文到底包含了哪些内容所以欢迎阅读下一篇《javascript 之变量对象》。&lt;/p&gt;
</description>
<pubDate>Thu, 02 Nov 2017 16:48:00 +0000</pubDate>
<dc:creator>风吹De麦浪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CandyManPing/p/7775506.html</dc:identifier>
</item>
<item>
<title>mui的上拉加载更多 下拉刷新 自己封装的demo - 胖娘子_bug</title>
<link>http://www.cnblogs.com/pnz-bug/p/7775467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pnz-bug/p/7775467.html</guid>
<description>&lt;p&gt;----------------------------------------------- 这是一个非常呆萌的程序妹子，深夜码的丑代码------------------------------------------------&lt;/p&gt;&lt;p&gt;辗转用mui做了两个项目，空下来把mui上拉下拉做了一个简单的封装，希望可以帮助到需要的朋友&lt;/p&gt;&lt;div readability=&quot;64&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;!--
        作者：2444626121@qq.com
        时间：2017-11-02
        描述：如果有问题请邮箱联系我，并注明来自博客园，谢谢呢^o^
--&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;    
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&amp;gt;
    &amp;lt;title&amp;gt;mui上拉刷新下拉加载demo--封装&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;js/mui.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;link href=&quot;css/mui.min.css&quot; rel=&quot;stylesheet&quot;/&amp;gt; 
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
    li{
        height: 30px;
        line-height: 30px;
        font-size: 14px;
        color: #bbb;
        text-indent: 4%;
        border-bottom: 1px solid currentColor;
    }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
        &amp;lt;!--下拉刷新容器--&amp;gt;
        &amp;lt;div id=&quot;refreshContainer&quot; class=&quot;mui-content mui-scroll-wrapper&quot;&amp;gt;
          &amp;lt;div class=&quot;mui-scroll&quot;&amp;gt;
            &amp;lt;!--数据列表--&amp;gt;
            &amp;lt;ul class=&quot;mui-table-view mui-table-view-chevron&quot; id=&quot;list&quot;&amp;gt;
                
            &amp;lt;/ul&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;
   var pager = {};//分页
   var totalPage;//总页码
   pullRefresh(pager);//启用上拉下拉  
   function pullRefresh(){
          mui(&quot;#refreshContainer&quot;).pullRefresh({
                up:{
                   contentrefresh : &quot;正在加载...&quot;,//可选，正在加载状态时，上拉加载控件上显示的标题内容
                   contentnomore:'没 有 更 多 数 据 了',//可选，请求完毕若没有更多数据时显示的提醒内容；
                   callback:function(){//必选，刷新函数，根据具体业务来编写，比如通过ajax从服务器获取新数据；
                     window.setTimeout(function(){
                         getData(pager);
                     },500);
                   }
                 },
                 down : {
                     height:50,//可选,默认50.触发下拉刷新拖动距离,
                     auto: true,//可选,默认false.首次加载自动下拉刷新一次
                     contentdown : &quot;下拉可以刷新&quot;,//可选，在下拉可刷新状态时，下拉刷新控件上显示的标题内容
                     contentover : &quot;释放立即刷新&quot;,//可选，在释放可刷新状态时，下拉刷新控件上显示的标题内容
                     contentrefresh : &quot;正在刷新...&quot;,//可选，正在刷新状态时，下拉刷新控件上显示的标题内容
                     callback :function(){ //必选，刷新函数，根据具体业务来编写，比如通过ajax从服务器获取新数据；
                        window.setTimeout(function(){
                                pager['size']= 3;//条数
                                pager['page'] = 1;//页码       
                                //刷新要先清空父节点里面的子节点
                                var f = document.getElementById(&quot;list&quot;); 
                                var childs = f.childNodes; 
                                for(var i = childs.length - 1; i &amp;gt;= 0; i--) { 
                                  f.removeChild(childs[i]); 
                                }
                                getData(pager);
                        },500);
                      }
                }
        })
    }
   //这个方法是负责向接口请求数据的，你可以选择你喜欢的方式，我这里是直接用的mui.ajax
    function getData(params){
                mui.ajax(&quot;/article/getArticlePage&quot;,{
                  data:{
                    &quot;header&quot;:{&quot;os&quot;:&quot;wap&quot;,&quot;app&quot;:&quot;xxxx&quot;,&quot;ver&quot;:1.0},
                    &quot;data&quot;:params
                  },
                  dataType:'json',
                  type:'post',
                  headers:{'Content-Type':'application/json'},
                  success:function(data){
                      mui('#refreshContainer').pullRefresh().endPullupToRefresh(true);
                      //服务器返回响应，根据响应结果，分析是否登录成功；下面这坨都是在拼dom 你可以用jquery 或者是你所熟悉的angular,vue双向绑定
                      var returnData = data.data;
                      var element=document.getElementById(&quot;list&quot;);
                      var para;
                 　　　var node;
                      for(var i = 0; i&amp;lt;returnData.length;i++){
                            para = document.createElement(&quot;li&quot;);
                            node = document.createTextNode(returnData[i].article_title)
                            para.appendChild(node);
                            element.appendChild(para); 
                      }
                          
                          //这里很重要，这里获取页码 公式：总条数/每页显示条数 
                      totalPage = data.ext%pager.size!=0?
                      parseInt(data.ext/pager.size)+1:
                      data.ext/pager.size;
                      if(totalPage==pager.page){//总页码等于当前页码，停止上拉下拉
                         mui('#refreshContainer').pullRefresh().endPullupToRefresh(true);
                      }else{
                        pager.page++;
                        mui('#refreshContainer').pullRefresh().refresh(true);
                      }                   
                    },
                    error:function(xhr,type,errorThrown){
                        //异常处理；
                        console.log(type);
                    }
                 })
        }   
   
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面是效果图，想弄视频上来的 然后发现太鸡肋了 弄不上来  气死我了&lt;/p&gt;&lt;p&gt;还有我不知道怎么把源码放上来，呕死人了，还请大家帮忙支招&lt;/p&gt;</description>
<pubDate>Thu, 02 Nov 2017 16:41:00 +0000</pubDate>
<dc:creator>胖娘子_bug</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pnz-bug/p/7775467.html</dc:identifier>
</item>
<item>
<title>HTML的语法 - pylzp</title>
<link>http://www.cnblogs.com/lzp1103/p/7775270.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lzp1103/p/7775270.html</guid>
<description>&lt;p&gt;1，什么是HTML标记语言，他是表示网页信息的符号标记语言，特点包括：&lt;/p&gt;
&lt;p&gt;　　a，可以设置文本的格式，比如标题，文号，文本颜色，段落等待&lt;/p&gt;
&lt;p&gt;　　b，可以简历列表&lt;/p&gt;
&lt;p&gt;　　c，可以插入图像和媒体&lt;/p&gt;
&lt;p&gt;　　d，可以建立表格&lt;/p&gt;
&lt;p&gt;　　e，超连接，可以使用鼠标点击超连接来实现页面之间的跳转&lt;/p&gt;

&lt;p&gt;2，HTML的标记和他的属性&lt;/p&gt;
&lt;p&gt;　　a，HTML文档的保存格式：.html  .htm  .xhtml&lt;/p&gt;
&lt;p&gt;　　b，标记和被标记的内容构建出HTML文档，格式：&amp;lt;标记&amp;gt;内容&amp;lt;/标记&amp;gt;&lt;/p&gt;
&lt;p&gt;　　c，标记的属性：就是用来控制我们的内容（图像，文本等的）如何的显示，&lt;/p&gt;
&lt;p&gt;　　　　格式：&amp;lt;标记 属性1=属性值 属性2=属性值 ... ...&amp;gt;内容&amp;lt;/标记&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　　　例如：&amp;lt;body bgcolor = &quot;red&quot;&amp;gt;内容&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　　　以上的属性是用来控制我们的网页的背景颜色，bgcolor就是body的属性，他的值是red（红色）&lt;/p&gt;

&lt;p&gt;3，语法不区分字母大小写&lt;/p&gt;
&lt;p&gt;　　&amp;lt;HTML&amp;gt;,&amp;lt;Html&amp;gt;,&amp;lt;html&amp;gt;都是自定义相同的标记，但是在编写的时候尽量使用小写&lt;/p&gt;

&lt;p&gt;4，文档注解&lt;/p&gt;
&lt;p&gt;　　注释一段内容时使用“&amp;lt;!--”开始，以&quot;--&amp;gt;&quot;结束，例如：&amp;lt;!--这是一个测试用例--&amp;gt;&lt;/p&gt;

&lt;p&gt;5，代码格式&lt;/p&gt;
&lt;p&gt;　　空格键和回车键在网页中都不起作用，我们为了让代码清晰易读，可以使用空格和回车进行编排&lt;/p&gt;
&lt;p&gt;　　注意：缩进时严格的规则，以“Tab”键进行缩进&lt;/p&gt;
&lt;p&gt;6，字符实体&lt;/p&gt;
&lt;p&gt;　　a，什么是字符实体？&lt;/p&gt;
&lt;p&gt;　　比如我们想在网页上面显示一个&quot;&amp;lt;&quot;小于符号，但是&quot;&amp;lt;&quot;在HTML中文档标记的开始语言，如果我们直接使用“&amp;lt;”会出错，所以我们就会用一些实体名称来代替&lt;/p&gt;
&lt;p&gt;　　b，常见的符号实体&lt;/p&gt;
&lt;p&gt;　　&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;eg：&lt;/p&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;第一天&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body bgcolor=&quot;red&quot;&amp;gt;&lt;br/&gt;测试&lt;br/&gt;&amp;lt;!--这是一个测试用例--&amp;gt;&lt;p&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;
&lt;/p&gt;&lt;/pre&gt;

</description>
<pubDate>Thu, 02 Nov 2017 15:49:00 +0000</pubDate>
<dc:creator>pylzp</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lzp1103/p/7775270.html</dc:identifier>
</item>
<item>
<title>【译】Java中的字符串字面量 - 没课割绿地</title>
<link>http://www.cnblogs.com/justcooooode/p/7670256.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justcooooode/p/7670256.html</guid>
<description>&lt;p&gt;原文地址：&lt;a href=&quot;https://javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html&quot; target=&quot;_blank&quot;&gt;https://javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;em&gt;Corey McGlone&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;让我们由一个简单的问题开始，&lt;em&gt;什么是字符串字面量？&lt;/em&gt;一个字符串字面量就是两个双引号之间的字符序列，形如&lt;strong&gt;“string”&lt;/strong&gt;、&lt;strong&gt;“literal”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;你可能已经在你的程序中使用字符串字面量几百次了，但是你可能还没意识到它在Java中是多么特殊。&lt;/p&gt;
&lt;h3&gt;字符串是不可变的&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;究竟什么使字符串字面量这么特殊？&lt;/em&gt;首先，记住重要的一点是字符串对象是不可变的。&lt;/p&gt;
&lt;p&gt;这就意味着一旦创建，一个字符串对象就不能被改变（还是可以通过反射来改变）。&lt;/p&gt;
&lt;p&gt;不可变？不能被更改？那怎么解释这段代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImmutableStrings
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        String start &lt;/span&gt;= &quot;Hello&quot;&lt;span&gt;;
        String end &lt;/span&gt;= start.concat(&quot; World!&quot;&lt;span&gt;);
        System.out.println(end);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Output&lt;/span&gt;
&lt;span&gt;
Hello World&lt;/span&gt;!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看这段代码，字符串被改变了吗，还是没有？事实上，这段代码中并没有字符串对象被改变。&lt;/p&gt;
&lt;p&gt;我们首先将&lt;strong&gt;“Hello”&lt;/strong&gt;赋值给&lt;strong&gt;start&lt;/strong&gt;变量，为了实现这步，需要在堆中创建一个对象，并把它的引用存储在&lt;strong&gt;start&lt;/strong&gt;中。接下来，我们在这个对象上调用&lt;em&gt;&lt;strong&gt;concat(String)&lt;/strong&gt;&lt;/em&gt;方法。进行到这里Java耍了一个小把戏，如果我们查看&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html&quot; target=&quot;_blank&quot;&gt;String的API说明&lt;/a&gt;，会发现其中对于&lt;em&gt;concat(String)&lt;/em&gt;方法有如下的描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1177828/201711/1177828-20171102111114888-612476653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;em&gt;方法描述：将指定字符串连接在这个字符串的结尾。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果长度为0，则返回这个字符串对象。&lt;span&gt;&lt;strong&gt;否则就创建一个新的字符串对象&lt;/strong&gt;&lt;/span&gt;，表示这个字符串序列由原字符串对象和参数字符串二者所表示的字符串序列拼接而成。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 你肯定看到了，当你将两个字符串做拼接操作时，实际上并没有改变原对象，而是直接创建了一个包含原始对象的新的对象，并且将另一个字符串拼在了后面。&lt;/p&gt;
&lt;p&gt;我们上面那段代码就是这么执行的，&lt;em&gt;start&lt;/em&gt;变量所引用的字符串对象并没有改变，如果在调用concat方法之后&lt;span&gt;System.out.println(start);&lt;/span&gt; ，会发现&lt;em&gt;start&lt;/em&gt;仍然指向的是“Hello”。&lt;/p&gt;
&lt;p&gt;这时候你可能想到了字符串中的“&lt;strong&gt;+&lt;/strong&gt;”操作符，事实上字符串的“+”操作也是和&lt;em&gt;conca&lt;/em&gt;t做了同样的事情（“+”操作实际上是new了一个StringBuilder对象，然后调用append方法）。&lt;/p&gt;
&lt;h3&gt;字符串的存储——字符串常量池&lt;/h3&gt;
&lt;p&gt;你或许听说过“&lt;strong&gt;字符串常量池&lt;/strong&gt;”这个概念，究竟什么是字符串常量池？有人说是一个字符串对象容器。答案很接近了，但是不完全正确。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;事实上他是一用来保存字符串对象引用的容器。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即使字符串是不可变的，它仍然和Java中的其他对象一样。&lt;strong&gt;对象都是创建在堆中，字符串也不例外&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以字符串常量池仍然依靠堆，他们存储的只是堆中字符串的引用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;目前还没有解释这个池到底是什么，或者它为何存在。&lt;/p&gt;
&lt;p&gt;好吧，因为字符串对象是不可变的，所以复制多个引用来“共享”这个字符串是安全的。下面来看一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImmutableStrings
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        String one &lt;/span&gt;= &quot;someString&quot;&lt;span&gt;;
        String two &lt;/span&gt;= &quot;someString&quot;&lt;span&gt;;
        
        System.out.println(one.equals(two));
        System.out.println(one &lt;/span&gt;==&lt;span&gt; two);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Output&lt;/span&gt;

&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个例子中，实在没有必要为一个相同的字符串对象创建两个实例。如果字符串像StringBuffer一样是可变的，那么我们会被迫创建两个对象（如果不这样做的话，通过一个引用改变它的值，将会导致其他引用的值也同样改变，从而可能发生错误）。&lt;/p&gt;
&lt;p&gt;但是，我们知道字符串对象是不能被改变的，我们可以安全地通过两个引用&lt;em&gt;one&lt;/em&gt;和&lt;em&gt;two&lt;/em&gt;来使用一个字符串对象。&lt;/p&gt;
&lt;p&gt;这个工作是通过字符串常量池完成的，下面来看一下它是如何完成的：&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;当一个.java文件被编译成.class文件时，和所有其他常量一样，每个字符串字面量都通过一种特殊的方式被记录下来。&lt;/p&gt;
&lt;p&gt;当一个.class文件被加载时（&lt;strong&gt;注意加载发生在初始化之前&lt;/strong&gt;），JVM在.class文件中寻找字符串字面量。&lt;/p&gt;
&lt;p&gt;当找到一个时，JVM会检查是否有相等的字符串在常量池中存放了堆中引用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果找不到，就会在堆中创建一个对象，然后将它的引用存放在池中的一个常量表中。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一旦一个字符串对象的引用在常量池中被创建，这个字符串在程序中的所有字面量引用都会被常量池中已经存在的那个引用代替。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，在上面的例子中字符串常量池中只有一个引用，就是“someString”这个字符串对象的引用。&lt;/p&gt;
&lt;p&gt;局部变量&lt;em&gt;one&lt;/em&gt;和&lt;em&gt;two&lt;/em&gt;都被赋予了同一个字符串对象的引用。可以通过程序的输出来验证。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;equals&lt;/em&gt;方法检查的是两个字符串对象是否包含相同的数据(“someString”)，而“==”操作符作用在对象上比较的是引用是否相同，这意味着只有两个引用指向的是同一个对象才会返回true。&lt;/p&gt;
&lt;p&gt;所以例子中的两个引用是相等的。从输出可以看到，局部变量&lt;em&gt;one&lt;/em&gt;和&lt;em&gt;two&lt;/em&gt;不仅包含相同的数据，而且还指向相同的对象。&lt;/p&gt;
&lt;p&gt;无图无真相，来看一下他们之间的关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1177828/201711/1177828-20171102164759841-1762484593.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，对于字符串字面量有一点比较特殊。通过“new”关键字构建时一种不同的方式。&lt;/p&gt;
&lt;p&gt;下面举一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImmutableStrings
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        String one &lt;/span&gt;= &quot;someString&quot;&lt;span&gt;;
        String two &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;someString&quot;&lt;span&gt;);
        
        System.out.println(one.equals(two));
        System.out.println(one &lt;/span&gt;==&lt;span&gt; two);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Output&lt;/span&gt;

&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个例子中，可以看到由于关键字“new”，最后的结果有一点不同。&lt;/p&gt;
&lt;p&gt;此例中，两个字符串字面量仍然被放进了常量池的常量表中，但是当使用“new”时，JVM就会在&lt;span&gt;&lt;strong&gt;运行时&lt;/strong&gt;&lt;/span&gt;创建一个新对象，而不是使用常量表中的引用。&lt;/p&gt;
&lt;p&gt;虽然例子中的两个字符串引用所指向的对象包含相同的数据“someString”，但是这两个对象并不相同。&lt;/p&gt;
&lt;p&gt;这一点可以从输出看出来，&lt;em&gt;equals&lt;/em&gt;方法返回了true，而检查引用是否相等的“==”返回false。&lt;/p&gt;
&lt;p&gt;这表明两个变量指向的是两个不同的字符串对象。&lt;/p&gt;
&lt;p&gt;如果你想看图形化的表示，下面就是。要记住引用到常量池的字符串对象是在类加载的时候创建的，而另一个对象是在运行时，当“new String”语句被执行时。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1177828/201711/1177828-20171102171621451-1202329729.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你想得到两个引用到相同对象的局部变量，你可以使用String类中的定义的intern()方法。&lt;/p&gt;
&lt;p&gt;调用&lt;em&gt;two.intern()&lt;/em&gt;后，会在字符串常量池中寻找是否有值相等的对象引用。&lt;/p&gt;
&lt;p&gt;如果有的话，就会返回这个引用，然后你可以把它赋给局部变量。&lt;/p&gt;
&lt;p&gt;如果这么做的化，局部变量&lt;em&gt;one&lt;/em&gt;和&lt;em&gt;two&lt;/em&gt;都是同一个对象的引用，并且在字符串常量池中也存有一个引用，就如同第一张图那样。这时，在运行时创建的第二个字符串对象将会被GC回收。&lt;/p&gt;
&lt;h3&gt;垃圾回收&lt;/h3&gt;
&lt;p&gt;什么条件下对象才会被垃圾回收？当一个对象不再有引用指向它时，这个对象就会被回收。&lt;/p&gt;
&lt;p&gt;有人注意到字符串字面量在垃圾回收时有什么特殊的地方吗？&lt;/p&gt;
&lt;p&gt;让我们来看一个例子，然后你就会明白。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImmutableStrings
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        String one &lt;/span&gt;= &quot;someString&quot;&lt;span&gt;;
        String two &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;someString&quot;&lt;span&gt;);
        
        one &lt;/span&gt;= two = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在主函数结束前，有多少个对象可以被回收？0个？1个？还是2个？&lt;/p&gt;
&lt;p&gt;答案是一个。不像大多数对象，字符串字面量总是有一个来自字符串常量池的引用。&lt;/p&gt;
&lt;p&gt;这就意味着它们会一直有一个引用，所以它们不会被垃圾回收。见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1177828/201711/1177828-20171102225012295-439954284.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如你所见，局部变量&lt;em&gt;one&lt;/em&gt;和&lt;em&gt;two&lt;/em&gt;没有指向字符串对象，但是仍然有一个字符串常量池的引用。&lt;/p&gt;
&lt;p&gt;所以GC并不会回收这个对象。并且这个对象可以通过之前提到的intern()方法访问。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;对于字符串字面量，下面的几条结论你可以记住。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;相等的字符串字面量将会指向相同的字符串对象（甚至是在不同包的不同类中）。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总之，字符串字面量不会被垃圾回收。绝对不会。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在运行时创建的字符串和由字符串字面量创建的是两个不同的对象。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对于运行时创建的字符串你可以通过&lt;em&gt;intern()&lt;/em&gt;方法来重用字符串字面量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;使用equals()&lt;/em&gt;方法是比较两个字符串是否相等的最好方式。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面的资料也一定要看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html&quot; target=&quot;_blank&quot;&gt;API Spec for String&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5&quot; target=&quot;_blank&quot;&gt;JLS, §3.10.5 String Literals&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;关于字符串为什么被设计成不可变的可以参考：&lt;a href=&quot;http://www.cnblogs.com/justcooooode/p/7514863.html&quot; target=&quot;_blank&quot;&gt;为什么Java中的String类是不可变的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;字符串的创建和intern方法详解：&lt;a href=&quot;http://www.cnblogs.com/justcooooode/p/7603381.html&quot; target=&quot;_blank&quot;&gt;理解Java字符串常量池与intern方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译如有错误，恳请纠正。&lt;/p&gt;
</description>
<pubDate>Thu, 02 Nov 2017 15:42:00 +0000</pubDate>
<dc:creator>没课割绿地</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/justcooooode/p/7670256.html</dc:identifier>
</item>
<item>
<title>依赖注入与控制反转 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/7774624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/7774624.html</guid>
<description>&lt;p&gt;记得大学开的有一门课是软件工程，而且还是两个学期，可能实践的机会少有的理论可能也只是记住的，比如软件设计的六大原则:单一原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则、开闭原则，但没真正的理解明白为什么要这样。现在毕业也3年多了，项目也接触了几个，还有一些开源的框架，记得在中软给华为做外包时帮悍马其他组的支援了几天，当时还不知道ABP框架，对IOC也只是听说过，并没有理解。当接触了ABP框架才发现，原来当时做的项目就是采用的ABP框架啊。其实像这些设计原则、还有模式这些，主要还是为了系统的高内聚，低耦合。最近在自学javaweb,学javaweb自然不能少了spring,spring的核心就是IOC和AOP，今天主要来说下IOC——Inversion of Control/控制反转。&lt;/p&gt;
&lt;p&gt;一、依赖注入DI—Dependency Injection&lt;/p&gt;
&lt;p&gt;1.依赖&lt;/p&gt;
&lt;p&gt;在说IOC之前先聊下依赖注入，依赖注入可以分两部分一是依赖二是注入。那什么是依赖?不是我自身的但没有就活不下去,人没了空气、水、阳光，那就活不下去。所以人依赖空气、水、阳光。下面代码定义了一个Person和一个CleanAir的类，Person依赖CleanAir。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_0958025c-4d26-4939-b765-82bf390122d1&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0958025c-4d26-4939-b765-82bf390122d1&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0958025c-4d26-4939-b765-82bf390122d1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cyw.Model;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(CleanAir air) {
        
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.air =&lt;span&gt; air;
    }
    CleanAir air;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_8d7775e9-e722-460c-aa9c-4cebf4015a78&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8d7775e9-e722-460c-aa9c-4cebf4015a78&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8d7775e9-e722-460c-aa9c-4cebf4015a78&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cyw.Model;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CleanAir {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 但是有这样一句话世界上唯一不变的就是变化。之前干净的空气不复存在，而Person依赖的不在是CleanAir，而是比CleanAir更有内涵的DirtyAir.如果还是按照上面的方式来，那就需要在增加一个DirtyAir类的同时，还要修改Person,这种强依赖有很大的弊端，一个地方变化引起其他地方也要修改，而且改变的只是Air，但Person也要改变。那怎么样能尽量减少修改的地方呢？于是面向接口的编程出现了。下面是先定义一个接口IAir，类CleanAir实现接口IAir，在Person中不在直接依赖CleanAir，而是依赖接口IAir，这样即使是DirtyAir也只需要修改给Person不同的Air就像了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_6cb6d1b0-5e6b-45c1-b526-0fb75c00d3d6&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6cb6d1b0-5e6b-45c1-b526-0fb75c00d3d6&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6cb6d1b0-5e6b-45c1-b526-0fb75c00d3d6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cyw.Model;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IAir {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_2d8f45d1-cee7-49ec-b9ba-64e84933dcff&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2d8f45d1-cee7-49ec-b9ba-64e84933dcff&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2d8f45d1-cee7-49ec-b9ba-64e84933dcff&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cyw.Model;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CleanAir &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IAir {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_2b68e2a1-fdbc-41a9-92a1-87ab647af9a9&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2b68e2a1-fdbc-41a9-92a1-87ab647af9a9&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2b68e2a1-fdbc-41a9-92a1-87ab647af9a9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cyw.Model;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(IAir air) {
        
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.air =&lt;span&gt; air;
    }
    IAir air;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;2.注入&lt;/p&gt;
&lt;p&gt;注入是啥？注入那它之前是没有的，而是塞给它。上面实例化Person的时候我们可以塞给它一个只要实现IAir接口的对象就可以，只是我们这是手动的给，这有点类似代理设计模式，要给代理设置具体对象。&lt;/p&gt;
&lt;p&gt;二、控制反转 IOC——Inversion Of Control&lt;/p&gt;
&lt;p&gt;上面依赖注入分两部分，当然控制反转也可分两部分。一是控制二是反转。&lt;/p&gt;
&lt;p&gt;1.控制&lt;/p&gt;
&lt;p&gt;像上面的不管是直接在Person中生命CleanAir属性还是创建一个接口，都是需要在程序New()一个对象出来,是程序控制Air.而IOC呢，它有专门的容器来管理这些对象，控制着他们的创建及生命周期，只要配置下，不用我们在new了。下次如果有CoolAir(冷空气)，那只需要增加一个类CoolAir并实现IAir接口就行，然后在配置文件中配置一下，这样多省事。&lt;/p&gt;
&lt;p&gt;2.反转&lt;/p&gt;
&lt;p&gt;有反转那就有正转。上面的那种通过new来获取依赖的对象，是对象主动找依赖的对象，而IOC是管理着依赖的对象，然后给对象找它所对应的依赖的对象并注入。获取依赖对象的方式改变了，一个是主动一个是被动的。而Spring就是提供了自动注入依赖的功能。&lt;/p&gt;
&lt;p&gt;三、个人理解&lt;/p&gt;
&lt;p&gt;依赖注入手动注入依赖也算是依赖注入，控制反转呢算是自动注入依赖。手动注入还是需要new来创建对象，还是适应不了以后的变化，控制反转算是更加包容，不需要new创建，只要实现某个接口，IOC会自动注入。如果再往下一步思考，IOC配置的依赖在XML中，Xml中保存的内容都可以理解为字符串，怎么让字符串转换成对象呢，那就需要用到反射。其实这些不管是Java还是C#，思想都是一样的，不管那门语言，只要理解了思想，学习起来也不难，很容易就能上手。&lt;/p&gt;

</description>
<pubDate>Thu, 02 Nov 2017 15:40:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/7774624.html</dc:identifier>
</item>
<item>
<title>使用localstorage来存储页面信息 - 爱喝酸奶的吃货</title>
<link>http://www.cnblogs.com/yingzi1028/p/7774954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yingzi1028/p/7774954.html</guid>
<description>&lt;p&gt;     今天小颖在跟着慕课网学习vue，不学不知道，一学吓一跳，学了才发现，我之前知道的只是vue的冰山一角，嘻嘻，今天把小颖跟着慕课网学习的demo，给大家分享下，希望对大家有所帮助嘻嘻。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;https://cn.vuejs.org/v2/guide/installation.html#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-CLI&quot; target=&quot;_blank&quot;&gt;vue API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/yingzi1028/p/6925387.html&quot;&gt;vue2.0+element+node+webpack搭建的一个简单的后台管理界面&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;npm install --global vue-cli&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/813088/201711/813088-20171102215407341-1876647040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; vue init webpack vue-project&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/813088/201711/813088-20171102215919170-1699818764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;然后：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/813088/201711/813088-20171102220652420-489205927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;cd my-project&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;npm install    如果你配置了淘宝镜像，也可以用cnpm install&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;npm run dev&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们就在浏览器看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/813088/201711/813088-20171102221548060-486485892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 但我们最终要实现：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/813088/201711/813088-20171102222055591-1047307156.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;1.将App.vue修改为：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='vue-demo'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;txt&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;='newItem' &lt;/span&gt;&lt;span&gt;@keyup.enter&lt;/span&gt;&lt;span&gt;='addItemFun'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;its in items&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{its.name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
import store from &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./store&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  data() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      newItem: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
      items: store.fetch()
    }
  },
  watch: {
    items: {
      handler: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val, oldVal) {
        store.save(val);
      },
      deep: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    }
  },
  methods: {
    addItemFun() {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; _this &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
      _this.items.push({ &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: _this.newItem });
      _this.newItem &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
    }
  }
}

&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
#app &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
  font-family&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 'Avenir', Helvetica, Arial, sans-serif&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
  -webkit-font-smoothing&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; antialiased&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
  -moz-osx-font-smoothing&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; grayscale&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
  text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
  color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #2c3e50&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
  margin-top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 60px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;span&gt;

.vue-demo &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
  width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 400px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
  margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 30px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;span&gt;

.txt &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
  width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
  height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 25px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
  line-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 24px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
  border-radius&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 5px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于初学vue的同学，可能对于watch可能不太熟悉，那就麻烦大家移步到 &lt;a href=&quot;https://cn.vuejs.org/v2/api/#watch&quot; target=&quot;_blank&quot;&gt;vue API&lt;/a&gt; 或参考下小颖之前写的文章：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/yingzi1028/p/7702439.html&quot;&gt;vue——实例方法 / 数据&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2.在与App.vue同级目录下，新建store.js文件：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const STORAGE_KEY = 'todos-vuejs'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {

  fetch: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; window.JSON.parse(window.localStorage.getItem(STORAGE_KEY) || '[]'&lt;span&gt;)

  },

  save: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(items) {

    window.localStorage.setItem(STORAGE_KEY, window.JSON.stringify(items))

  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.在项目中打开cmd窗口，运行：npm run dev,就完成啦嘻嘻。&lt;/h3&gt;

</description>
<pubDate>Thu, 02 Nov 2017 14:37:00 +0000</pubDate>
<dc:creator>爱喝酸奶的吃货</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yingzi1028/p/7774954.html</dc:identifier>
</item>
<item>
<title>Linux中main是如何执行的 - HarlanC</title>
<link>http://www.cnblogs.com/harlanc/p/7774882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/harlanc/p/7774882.html</guid>
<description>&lt;p&gt;这是一个看似简单的问题，但是要从Linux底层一点点研究问题比较多。找到了一遍研究这个问题的文章，但可能比较老了，还是在x86机器上进行的测试。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.tldp.org/LDP/LG/issue84/hawk.html&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;开始&quot;&gt;开始&lt;/h2&gt;
&lt;p&gt;问题很简单：linux是怎么执行我的main()函数的？&lt;br/&gt;在这片文档中，我将使用下面的一个简单c程序来阐述它是如何工作的。这个c程序的文件叫做&quot;simple.c&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;main()
{
    return (0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编译&quot;&gt;编译&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;gcc -o simple simple.c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成可执行文件simple.&lt;/p&gt;
&lt;h2 id=&quot;在可执行文件中有些什么&quot;&gt;在可执行文件中有些什么？&lt;/h2&gt;
&lt;p&gt;为了看到在可执行文件中有什么，我们使用一个工具&quot;objdump&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;objdump -f simple

simple:     file format elf32-i386
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x080482d0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出给出了一些关键信息。首先，这个文件的格式是&quot;ELF64&quot;。其次是给出了程序执行的开始地址 &quot;0x080482d0&quot;&lt;/p&gt;
&lt;h2 id=&quot;什么是elf&quot;&gt;什么是ELF？&lt;/h2&gt;
&lt;p&gt;ELF是执行和链接格式（Execurable and Linking Format）的缩略词。它是UNIX系统的几种可执行文件格式中的一种。对于我们的这次探讨，有关ELF的有意思的地方是它的头格式。每个ELF可执行文件都有ELF头，像下面这个样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct
{
    unsigned char   e_ident[EI_NIDENT]; /* Magic number and other info */
    Elf32_Half  e_type;         /* Object file type */
    Elf32_Half  e_machine;      /* Architecture */
    Elf32_Word  e_version;      /* Object file version */
    Elf32_Addr  e_entry;        /* Entry point virtual address */
    Elf32_Off   e_phoff;        /* Program header table file offset */
    Elf32_Off   e_shoff;        /* Section header table file offset */
    Elf32_Word  e_flags;        /* Processor-specific flags */
    Elf32_Half  e_ehsize;       /* ELF header size in bytes */
    Elf32_Half  e_phentsize;        /* Program header table entry size */
    Elf32_Half  e_phnum;        /* Program header table entry count */
    Elf32_Half  e_shentsize;        /* Section header table entry size */
    Elf32_Half  e_shnum;        /* Section header table entry count */
    Elf32_Half  e_shstrndx;     /* Section header string table index */
} Elf32_Ehdr;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的结构中，&quot;e_entry&quot;字段是可执行文件的开始地址。&lt;/p&gt;
&lt;h2 id=&quot;地址0x080482d0上存放的是什么是程序执行的开始地址么&quot;&gt;地址&quot;0x080482d0&quot;上存放的是什么？是程序执行的开始地址么？&lt;/h2&gt;
&lt;p&gt;对于这个问题，我们来对&quot;simple&quot;做一下反汇编。有几种工具可以用来对可执行文件进行反汇编。我在这里使用了objdump:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;objdump --disassemble simple&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果有点长，我不会分析objdump的所有输出。我们的意图是看一下地址0x080482d0上存放的是什么。下面是输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;080482d0 &amp;lt;_start&amp;gt;:
 80482d0:       31 ed                   xor    %ebp,%ebp
 80482d2:       5e                      pop    %esi
 80482d3:       89 e1                   mov    %esp,%ecx
 80482d5:       83 e4 f0                and    $0xfffffff0,%esp
 80482d8:       50                      push   %eax
 80482d9:       54                      push   %esp
 80482da:       52                      push   %edx
 80482db:       68 20 84 04 08          push   $0x8048420
 80482e0:       68 74 82 04 08          push   $0x8048274
 80482e5:       51                      push   %ecx
 80482e6:       56                      push   %esi
 80482e7:       68 d0 83 04 08          push   $0x80483d0
 80482ec:       e8 cb ff ff ff          call   80482bc &amp;lt;_init+0x48&amp;gt;
 80482f1:       f4                      hlt    
 80482f2:       89 f6                   mov    %esi,%esi
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看上去开始地址上存放的是叫做&quot;_start&quot;的启动例程。它所做的是清空寄存器，向栈中push一些数据并且调用一个函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Stack Top   -------------------
        0x80483d
        -------------------
        esi
        -------------------
        ecx
        -------------------
        0x8048274
        -------------------
        0x8048420
        -------------------
        edx
        -------------------
        esp
        -------------------
        eax
        -------------------
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三个问题&quot;&gt;三个问题&lt;/h2&gt;
&lt;p&gt;现在，可能你已经想到了，关于这个&lt;a href=&quot;http://blog.csdn.net/qq_29343201/article/details/51252345&quot;&gt;栈帧&lt;/a&gt;我们有一些问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这些16进制数是什么？&lt;/li&gt;
&lt;li&gt;地址80482bc上存放的是什么，哪个函数被_start调用了？&lt;/li&gt;
&lt;li&gt;看起来这些汇编指令并没有用一些有意义的值来初始化寄存器。那么谁来初始化这些寄存器？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;让我们来一个一个回答这个问题。&lt;/p&gt;
&lt;h3 id=&quot;q1关于16进制数&quot;&gt;Q1&amp;gt;关于16进制数&lt;/h3&gt;
&lt;p&gt;如果你仔细研究了用objdump得到的反汇编输出，你就能很容易回答这个问题。&lt;br/&gt;下面是这个问题的回答：&lt;/p&gt;
&lt;p&gt;0x80483d0: 这是main()函数的地址。&lt;/p&gt;
&lt;p&gt;0x8048274: _init()函数的地址。&lt;/p&gt;
&lt;p&gt;0x8048420: _finit()函数地址。&lt;/p&gt;
&lt;p&gt;_init和_finit是GCC提供的initialization/finalization 函数。&lt;/p&gt;
&lt;p&gt;现在，我们不要去关心这些东西。基本上所有这些16进制数都是函数指针。&lt;/p&gt;
&lt;h3 id=&quot;q2地址80482bc上存放的是什么&quot;&gt;Q2&amp;gt;地址80482bc上存放的是什么？&lt;/h3&gt;
&lt;p&gt;让我们再次在反汇编输出中寻找地址80482bc。&lt;br/&gt;如果你看到了，汇编代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;80482bc:    ff 25 48 95 04 08       jmp    *0x8049548&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的*0x8049548是一个指针操作。它跳到地址0x8049548存储的地址值上。&lt;/p&gt;
&lt;h4 id=&quot;更多关于elf和动态链接&quot;&gt;更多关于ELF和动态链接&lt;/h4&gt;
&lt;p&gt;使用ELF，我们可以编译出一个可执行文件,它动态链接到几个libraries上。这里的&quot;动态链接&quot;意味着实际的链接过程发生在运行时。否则我们就得编译出一个巨大的可执行文件，这个文件包含了它所调用的所有libraries（&quot;一个『静态链接的可执行文件』&quot;）。如果你执行下面的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ldd simple

      libc.so.6 =&amp;gt; /lib/i686/libc.so.6 (0x42000000)
      /lib/ld-linux.so.2 =&amp;gt; /lib/ld-linux.so.2 (0x40000000)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你就能看到simple动态链接的所有libraries。所有动态链接的数据和函数都有『动态重定向入口(dynamic relocation entry)』。&lt;/p&gt;
&lt;p&gt;这个概念粗略的讲述如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在链接时我们不会得知一个动态符号的实际地址。只有在运行时我们才能知道这个实际地址。&lt;/li&gt;
&lt;li&gt;所以对于动态符号，我们为其实际地址预留出了存储单元。加载器会在运行时用动态符号的实际地址填充存储单元。&lt;/li&gt;
&lt;li&gt;我们的应用通过使用一种指针操作来间接得知动态符号的存储单元。在我们的例子中，在地址80482bc上，有一个简单的jump指令。jump到的单元由加载器在运行时存储到地址0x8049548上。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们通过使用objdump命令可以看到所有的动态链接入口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;objdump -R simple

    simple:     file format elf32-i386

    DYNAMIC RELOCATION RECORDS
    OFFSET   TYPE              VALUE 
    0804954c R_386_GLOB_DAT    __gmon_start__
    08049540 R_386_JUMP_SLOT   __register_frame_info
    08049544 R_386_JUMP_SLOT   __deregister_frame_info
    08049548 R_386_JUMP_SLOT   __libc_start_main&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的地址0x8049548被叫做&quot;JUMP SLOT&quot;，非常贴切。根据这个表，实际上我们想调用的是 __libc_start_main。&lt;/p&gt;
&lt;h4 id=&quot;libc_start_main是什么&quot;&gt;__libc_start_main是什么？&lt;/h4&gt;
&lt;p&gt;我们在玩一个接力游戏，现在球被传到了libc的手上。__libc_start_main是libc.so.6中的一个函数。如果你在glibc中查找__libc_start_main的源码，它的原型可能是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;extern int BP_SYM (__libc_start_main) (int (*main) (int, char **, char **),
        int argc,
        char *__unbounded *__unbounded ubp_av,
        void (*init) (void),
        void (*fini) (void),
        void (*rtld_fini) (void),
        void *__unbounded stack_end)
__attribute__ ((noreturn));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有汇编指令需要做的就是建立一个参数栈然后调用__libc_start_main。这个函数需要做的是建立/初始化一些数据结构/环境然后调用我们的main()。让我们看一下关于这个函数原型的栈帧，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Stack Top       -------------------
                        0x80483d0                                 main
                 ------------------- 
                        esi                                  argc
                 ------------------- 
                        ecx                                  argv 
                 ------------------- 
                        0x8048274                               _init
                 ------------------- 
                        0x8048420                               _fini
                 ------------------- 
                        edx                                 _rtlf_fini
                 ------------------- 
                        esp                                 stack_end
                 ------------------- 
                        eax                                 this is 0
                 ------------------- 

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据这个栈帧我们得知，esi,ecx,edx,esp,eax寄存器在函数 __libc_start_main()被执行前需要被填充合适的值。很清楚的是这些寄存器不是被前面我们所展示的启动汇编指令所填充的。那么，谁填充了这些寄存器呢？现在只留下唯一的一个地方了——内核。现在让我们回到第三个问题上。&lt;/p&gt;
&lt;h3 id=&quot;q3内核做了些什么&quot;&gt;Q3&amp;gt;内核做了些什么？&lt;/h3&gt;
&lt;p&gt;当我们通过在shell上输入一个名字来执行一个程序时，下面是Linux接下来会发生的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Shell调用内核的带argc/argv参数的系统调用&quot;execve&quot;。&lt;/li&gt;
&lt;li&gt;内核的系统调用句柄开始处理这个系统调用。在内核代码中，这个句柄为&quot;sys_execve&quot;.在x86机器上，用户模式的应用会通过以下寄存器将所有需要的参数传递到内核中。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;ebx:执行程序名字的字符串&lt;/li&gt;
&lt;li&gt;ecx:argv数组指针&lt;/li&gt;
&lt;li&gt;edx:环境变量数组指针&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;通用的execve内核系统调用句柄——也就是do_execve——被调用。它所做的是建立一个数据结构，将所有用户空间数据拷贝到内核空间，最后调用search_binary_handler()。Linux能够同时支持多种可执行文件格式，例如a.out和ELF。对于这个功能，存在一个数据结构&quot;struct linux_binfmt&quot;,对于每个二进制格式的加载器在这个数据结构都会有一个函数指针。search_binary_handler()会找到一个合适的句柄并且调用它。在我们的例子中，这个合适的句柄是load_elf_binary()。解释函数的每个细节是非常乏味的工作。所以我在这里就不这么做了。如果你感兴趣，阅读相关的书籍即可。接下来是函数的结尾部分，首先为文件操作建立内核数据结构，来读入ELF映像。然后它建立另一个内核数据结构，这个数据结构包含：代码容量，数据段开始处，堆栈段开始处，等等。然后为这个进程分配用户模式页，将argv和环境变量拷贝到分配的页面地址上。最后，argc和argv指针，环境变量数组指针通过create_elf_tables()被push到用户模式堆栈中,使用start_thread()让进程开始执行起来。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当执行_start汇编指令时，栈帧会是下面这个样子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Stack Top          -------------
                            argc
                        -------------
                            argv pointer
                        -------------
                            env pointer
                        ------------- 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;汇编指令通过以下方式从栈中获取所有信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pop %esi        &amp;lt;--- get argc
move %esp, %ecx     &amp;lt;--- get argv
              actually the argv address is the same as the current
              stack pointer.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在所有东西都准备好了，可以开始执行了。&lt;/p&gt;
&lt;h2 id=&quot;其他的寄存器呢&quot;&gt;其他的寄存器呢？&lt;/h2&gt;
&lt;p&gt;对于esp来说，它被用来当做应用程序的栈底。在弹出所有必要信息之后，_start例程简单的调整了栈指针(esp)——关闭了esp寄存器4个低地址位，这完全是有道理的，对于我们的main程序，这就是栈底。对于edx,它被rtld_fini使用，这是一种应用析构函数，内核使用下面的宏定义将它设为0：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define ELF_PLAT_INIT(_r)   do { \
    _r-&amp;gt;ebx = 0; _r-&amp;gt;ecx = 0; _r-&amp;gt;edx = 0; \
    _r-&amp;gt;esi = 0; _r-&amp;gt;edi = 0; _r-&amp;gt;ebp = 0; \
    _r-&amp;gt;eax = 0; \
} while (0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;0意味着在x86 Linux上我们不会使用这个功能。&lt;/p&gt;
&lt;h2 id=&quot;关于汇编指令&quot;&gt;关于汇编指令&lt;/h2&gt;
&lt;p&gt;这些汇编codes来自哪里？它是GCC codes的一部分。这些code的目标文件通常在/usr/lib/gcc-lib/i386-redhat-linux/XXX 和 /usr/lib下面，XXX是gcc版本号。文件名为crtbegin.o,crtend.o和gcrt1.o。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们总结一下整个过程。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;GCC将你的程序同crtbegin.o/crtend.o/gcrt1.o一块进行编译。其它默认libraries会被默认动态链接。可执行程序的开始地址被设置为_start。&lt;/li&gt;
&lt;li&gt;内核加载可执行文件，并且建立正文段，数据段，bss段和堆栈段，特别的，内核为参数和环境变量分配页面，并且将所有必要信息push到堆栈上。&lt;/li&gt;
&lt;li&gt;控制流程到了_start上面。_start从内核建立的堆栈上获取所有信息，为__libc_start_main建立参数栈，并且调用__libc_start_main。&lt;/li&gt;
&lt;li&gt;__libc_start_main初始化一些必要的东西，特别是C library（比如malloc)线程环境并且调用我们的main函数。&lt;/li&gt;
&lt;li&gt;我们的main会以main(argv,argv)来被调用。事实上，这里有意思的一点是main函数的签名。__libc_start_main认为main的签名为main(int, char &lt;strong&gt;, char&lt;/strong&gt; )，如果你感到好奇，尝试执行下面的程序。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;main(int argc, char** argv, char** env)
{
    int i = 0;
    while(env[i] != 0)
    {
       printf(&quot;%s\n&quot;, env[i++]);
    }
    return(0);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;在Linux中，我们的C main()函数由GCC,libc和Linux二进制加载器的共同协作来执行。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;objdump                         &quot;man objdump&quot; 

ELF header                      /usr/include/elf.h 

__libc_start_main            glibc source 
                                       ./sysdeps/generic/libc-start.c 

sys_execve                      linux kernel source code 
                                       arch/i386/kernel/process.c 
do_execve                        linux kernel source code 
                                       fs/exec.c 
struct linux_binfmt       linux kernel source code 
                                       include/linux/binfmts.h 
load_elf_binary             linux kernel source code
                                       fs/binfmt_elf.c 
create_elf_tables             linux kernel source code 
                                       fs/binfmt_elf.c 
start_thread                      linux kernel source code 
                                      include/asm/processor.h

&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 02 Nov 2017 14:19:00 +0000</pubDate>
<dc:creator>HarlanC</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/harlanc/p/7774882.html</dc:identifier>
</item>
</channel>
</rss>