<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring的核心接口 - palapala</title>
<link>http://www.cnblogs.com/ssskkk/p/9281785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ssskkk/p/9281785.html</guid>
<description>&lt;h3&gt;ContextLoaderListener接口&lt;/h3&gt;
&lt;p&gt;Create a new &lt;code&gt;ContextLoaderListener&lt;/code&gt; that will create a web application context based on the &quot;contextClass&quot; and &quot;contextConfigLocation&quot; servlet context-params. See &lt;a title=&quot;class in org.springframework.web.context&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/Spring-3.1.1/org/springframework/web/context/ContextLoader.html&quot;&gt;&lt;code&gt;ContextLoader&lt;/code&gt;&lt;/a&gt;superclass documentation for details on default values for each.&lt;/p&gt;
&lt;p&gt;This constructor is typically used when declaring &lt;code&gt;ContextLoaderListener&lt;/code&gt; as a &lt;code&gt;&amp;lt;listener&amp;gt;&lt;/code&gt; within &lt;code&gt;web.xml&lt;/code&gt;, where a no-arg constructor is required.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个接口实现了J2EE的&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/javaEE6/javax/servlet/ServletContextListener.html&quot; target=&quot;_blank&quot;&gt;ServletContextListener&lt;/a&gt;接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 通过listener 像Servlet容器注册 Web容器启动时 初始化Spring上下文的信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;!-- 加载Spring容器 --&amp;gt;
     &amp;lt;context-param&amp;gt;
         &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
         &amp;lt;param-value&amp;gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;classpath:applicationContext-core.xml&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&amp;lt;/param-value&amp;gt; 
      &amp;lt;/context-param&amp;gt;
      &amp;lt;!-- 通过listener 像Servlet容器注册 Web容器启动时 初始化context-param的配置信息。--&amp;gt;
    &amp;lt;listener&amp;gt;
        &amp;lt;listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;/listener&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;BeanFactory接口&lt;/h3&gt;
&lt;p&gt;　　Spring通过BeanFactory接口的&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/Spring-3.1.1/org/springframework/beans/factory/BeanFactory.html#getBean(java.lang.Class)&quot; target=&quot;_blank&quot;&gt;getBean&lt;/a&gt;来拿到我们所配置Bean的实列，交给Spring管理的Bean全部默认是单例。&lt;/p&gt;
&lt;p&gt;　　以下是批量扫描初始化Bean 交给Spring管理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&quot;com.sk.service.*&quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;IOC&lt;/h3&gt;
&lt;p&gt;ioc 是依赖注入，当我们的成员变量是Spring的一个Bean的时候，那这个成员变量可以由Spring帮我们注入(Spring会通过反射调用Set方法)&lt;/p&gt;
&lt;p&gt;依赖注入也叫控制反转，以前编程完完全全控制在我自己的手里。用了Spring之后 成员变量的初始化过程控制过程反转到Spring手里。&lt;/p&gt;
&lt;p&gt;注解用法:&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　DemoService demoService;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;AOP&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/ssskkk/p/9191845.html&quot; target=&quot;_blank&quot;&gt;AOP的实现原理，动态代理。&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从代理的原理我们知道，代理的目的是调用目标方法时可以转而执行&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/reflect/InvocationHandler.html&quot; target=&quot;_blank&quot;&gt;InvocationHandler&lt;/a&gt;的&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/reflect/InvocationHandler.html#invoke(java.lang.Object,%20java.lang.reflect.Method,%20java.lang.Object[])&quot; target=&quot;_blank&quot;&gt;invoke&lt;/a&gt;方法，所以如何在&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/reflect/InvocationHandler.html&quot; target=&quot;_blank&quot;&gt;InvocationHandler&lt;/a&gt;上做文章就是Spring实现AOP的关键所在。&lt;/p&gt;
&lt;p&gt;Spring的AOP实现遵守AOP联盟的约定，同时Spring又扩展了它。增加了 PointCut Advisor接口使得其更加灵活&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;!-- 切面逻辑类的对象 --&amp;gt;
    &amp;lt;bean id=&quot;myInterceptor&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.sk.util.MyInterceptor&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;!-- 在add方法上加各种各样的我们切入进来的逻辑 --&amp;gt;
        &amp;lt;aop:pointcut expression=&quot;execution(public * com.sk.service..*.*(..))&quot; id=&quot;servicePointcut&quot;/&amp;gt;
        
        &amp;lt;aop:aspect id = &quot;logAspect&quot; ref=&quot;myInterceptor&quot;&amp;gt;
            &amp;lt;!-- aop:pointcut可以加到aspect的里面来   加到里面的话 只能是logAspect 这个aspect使用 --&amp;gt;
            &amp;lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;servicePointcut&quot;/&amp;gt;
            &amp;lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;servicePointcut&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们执行的时候 符合我们execution(public * com.sk.service..*.*(..))语法要求的方法的时候，&lt;/p&gt;
&lt;p&gt;它会在方法执行之前 执行before方法(logInterceptor的before方法) 方法执行之后 执行after方法。&lt;/p&gt;
&lt;h3&gt;Junit测试&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testIoc() {
        BeanFactory beanFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext-core.xml&quot;&lt;span&gt;);
        DemoService demoService &lt;/span&gt;= beanFactory.getBean(DemoService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        demoService.testAop();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;利用JoinPoint模拟AOP 实现事物管理&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;JoinPoint:连接点(AOP切面切到我们程序时的连接点，切入的那个点)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的配置保持不变，首先给我们的Service 加一个自定义的注解&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MyAnnotation {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String transaction() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DemoServiceImpl  &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; DemoService{
    @Override
    @MyAnnotation(transaction&lt;/span&gt;= &quot;transaction&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testAop() {
        System.out.println(&lt;/span&gt;&quot;excute Service***********&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;完善我们的切面逻辑类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当我们的切面发现这个注解的时候 就进行事物的控制&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyInterceptor {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; before(JoinPoint jp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        MyAnnotation myAnnotation &lt;/span&gt;=&lt;span&gt;getHandlerChain(jp);
        System.out.println(&lt;/span&gt;&quot;方法开始通过AOP拿到方法上的注解-开始事物&quot;+&lt;span&gt;myAnnotation.transaction());
    }    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; after(JoinPoint jp)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception  {
        MyAnnotation myAnnotation &lt;/span&gt;=&lt;span&gt;getHandlerChain(jp);
        System.out.println(&lt;/span&gt;&quot;放过结束通过AOP拿到方法上的注解-结束事物&quot;+&lt;span&gt;myAnnotation.transaction());
    }    
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取方法或者类上的HandlerChain注解，方法上的优先 &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; MyAnnotation getHandlerChain(JoinPoint jp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        MethodSignature methodSignature &lt;/span&gt;=&lt;span&gt; (MethodSignature) jp.getSignature();
        Method realMethod &lt;/span&gt;=&lt;span&gt; jp.getTarget().getClass().getDeclaredMethod(methodSignature.getName(), methodSignature.getParameterTypes());  
        MyAnnotation myAnnotation &lt;/span&gt;= realMethod.getAnnotation(MyAnnotation.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(myAnnotation==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Object&amp;gt; cls =&lt;span&gt; jp.getTarget().getClass();
            myAnnotation &lt;/span&gt;= (MyAnnotation) cls.getAnnotation(MyAnnotation.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; myAnnotation;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果&lt;/p&gt;
&lt;p&gt;方法开始通过AOP拿到方法上的注解-开始事物transaction&lt;br/&gt;excute Service***********&lt;br/&gt;放过结束通过AOP拿到方法上的注解-结束事物transaction&lt;/p&gt;
&lt;p&gt;这里只是打印模拟，项目中需要和JDBC(或者Mybatis Hibernate)结合，进而控制数据库transaction的开启和关闭&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/ssskkk/p/9191845.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;推荐文章JAVA动态代理设计模式(AOP背后的原理)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 15:50:00 +0000</pubDate>
<dc:creator>palapala</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ssskkk/p/9281785.html</dc:identifier>
</item>
<item>
<title>（转）Web是如何工作的（3）：HTTP&amp;REST - MingsonZheng</title>
<link>http://www.cnblogs.com/MingsonZheng/p/9357640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MingsonZheng/p/9357640.html</guid>
<description>&lt;p&gt;我们在第一篇文章中介绍了基本的Web架构，然后在第二篇文章中谈论了Web应用程序的结构，现在是时候卷起袖子来近距离看看HTTP和REST。&lt;/p&gt;
&lt;p&gt;对于Web开发人员，是必须理解HTTP的，因为是HTTP使得信息可以在Web应用中传递——允许更好的用户交互和提高网站的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是HTTP？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在客户端-服务器模型中，客户端和服务器是以“请求-响应”消息方式来交互消息的：客户端发送请求，服务器响应请求。&lt;/p&gt;
&lt;p&gt;跟踪信息的流动比听起来的复杂得多，客户端和服务器都遵循一种通用的语言及一系列规则，所以它们都知道自己需要的是什么，这种语言或者说“协议”就是HTTP。&lt;/p&gt;
&lt;p&gt;HTTP协议定义了语法（数据格式和编码）、语义（语法的含义）以及即时（速度和顺序）。客户端和服务器之间每个HTTP请求和响应的交换可以认为是单个HTTP事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP: 主要内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我们深入探讨HTTP的细节前，有几件事值得一提的。&lt;/p&gt;
&lt;p&gt;首先，HTTP是基于文本的，这意味着客户端和服务器之间的消息交换是通过比特文本来完成的，每条消息包含两个部分：一个消息首行和一个消息正文。&lt;/p&gt;
&lt;p&gt;其次，HTTP是应用层协议，意味着它只是一个抽象层标准化主机之间是如何通信的。HTTP本身不能传送数据，它仍然得靠底层的TCP/IP协议在两台机器间获取请求和响应。&lt;/p&gt;
&lt;p&gt;（提醒一下，TCP/IP是由两部分组成的，它的功能是作为因特网底层“控制系统”，关于TCP/IP的介绍，可以查看这一系列中的第一篇文章）&lt;/p&gt;
&lt;p&gt;最后，你应该已经在你浏览器的地址栏见过“HTTPS”协议，你会想HTTPS是不是HTTP+“S”，简单的回答是近似，但是还是有点点不同。&lt;/p&gt;
&lt;p&gt;普通的HTTP请求和响应是没有加密的，很容易受到各种类型的安全攻击。而HTTPS是一种更安全的通信方式，它通过加密的方式使得信息更安全，它是在原有的HTTP数据外面加了一层TLS/SSL。&lt;/p&gt;
&lt;p&gt;SSL是一种安全协议，它允许客户端与服务器以一种安全的方式在网络中通信，它防止消息在网络传输过程中被窃听和篡改。&lt;/p&gt;
&lt;p&gt;客户端通常使用一个特殊的端口443来标识是否需要TLS/SSL连接。一旦客户端和服务器同意使用TLS/SSL来通信，他们就通过执行所谓的“TLS握手”来协商建立一个有状态的连接，然后客户端和服务器建立一个会话秘钥，在他们彼此通信时就使用这个秘钥来加密和解密消息。&lt;/p&gt;
&lt;p&gt;想Google和Facebook这样的大部分网站都使用HTTPS，毕竟它能使你的密码、个人信息和信用卡信息在网络上安全可靠。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP：细节&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有了这些基础知识，让我们深入了解一下HTTP的结构。&lt;/p&gt;
&lt;p&gt;我们通过访问https://www.github.com来与GitHub服务器通信。如果你使用的是谷歌浏览器或者安装了FireBug插件的火狐浏览器，那你可以通过查看“网络”页签来查看HTTP请求的详细信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP请求头&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP请求头通常包含元数据（关于数据的数据），这些元数据包含请求类型（GET、POST、PUT、DELETE），路径、状态码、内容类型、用户代理、cookie、Post主体（有时包含）等等。&lt;/p&gt;
&lt;p&gt;用访问Github这个例子，让我们近距离地看一下头部中最重要的部分，我们以“响应头”开始：&lt;/p&gt;
&lt;p&gt;请求URL：&lt;a href=&quot;https://github.com/&quot; class=&quot;uri&quot;&gt;https://github.com/&lt;/a&gt; （这是我们请求的URL）&lt;/p&gt;
&lt;p&gt;请求方法：GET （在这个例子里使用的这种HTTP请求方法，相当于浏览器说：“喂，GitHub服务器，把你的主要给我”）&lt;/p&gt;
&lt;p&gt;状态码：200 OK （这是服务器告诉客户端，说你的请求结果正常的一种标准方式。状态码200意味着服务器成功地找到了资源，并正在发送给你）&lt;/p&gt;
&lt;p&gt;远程地址：192.30.252.129：443 （这个IP地址和端口号是我们访问的GitHub网站，注意它的端口#443（意思是我们使用的是HTTPS协议，而不是HTTP））&lt;/p&gt;
&lt;p&gt;内容编码：gzip （这是我们接受的资源编码，在这个例子里，GitHub服务器告诉我们，它发送回来的内容是压缩过的，GitHub可能压缩了文件，这样你下载时耗时更少。）&lt;/p&gt;
&lt;p&gt;内容类型：text/html;字符集=utf-8 （规定响应主体中的数据表示方式，包括类型及其子集，这个类型描述的是数据类型，同时这个子集指定了这个数据类型的特定格式。在我们这个例子里，我们的文本是以HTML的形式返回给我们的；第二部分指定了对于这个HTML文档使用的字符编码，大部分情况下用的是这个例子中的用的UTF-8）&lt;/p&gt;
&lt;p&gt;头部信息还包含很多内容，它们是客户端必须传送给服务器的，这样服务器才可能知道如何响应请求。下面让我们看一下“请求头”部分：&lt;/p&gt;
&lt;p&gt;用户代理:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36 （这表示用户使用的软件，有时网站需要知道它们是如何被浏览的，所以浏览器发送这个用户代理字符串给服务器，服务器可以用来确定访问网站所用的内容）&lt;/p&gt;
&lt;p&gt;接收编码：gzip,deflate,sdch （规定浏览器将以什么编码来接收内容，我们可以看到列表中的gzip，这就是为什么GitHub服务器能够发送gzip格式的内容给我们。）&lt;/p&gt;
&lt;p&gt;接收语言：en-US;q=0.8 （描述我们想要的网页使用的语言，在这个例子里，“en”代表英语）&lt;/p&gt;
&lt;p&gt;主机：github.com （这就不言自明了吧）&lt;/p&gt;
&lt;p&gt;Cookie:_octo=GH1.1.491617779.1446477115; logged_in=yes; dotcom_user=iam-peekay; _gh_sess=somethingFakesomething FakesomethingFakesomethingFakesomethingFakesomethingFakesomethingFakesomethingFake; user_session=FakesomethingFake somethingFakesomethingFakesomethingFake; &lt;em&gt;ga=9389479283749823749; tz=America%2FLos_Angeles&lt;/em&gt; （这段文本是Web服务器存储在用户机器上，以便以后检索，这些信息是以键值对存储的，其中一个键值对是GitHub为了这个请求存储的，例如，“dotcom_user=iam-peekay”是用来告诉GitHub我的用户ID是iam-peekay）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tl;dr:这些键值对又是做什么的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;长话短说，我们留了很多键值对没有介绍，但是它们是如何生成的？&lt;/p&gt;
&lt;p&gt;你的浏览器在任何时间访问一个网站时，它都会去查看之前这个网站在你电脑上设置的cookie.&lt;/p&gt;
&lt;p&gt;所以，如果我访问www.github.com，我的浏览器将查找github保留在我硬盘上的cookie文件，如果找到了cookie文件，它就将把这些键值对包含在请求头里发送给服务器。&lt;/p&gt;
&lt;p&gt;GitHub网页服务器现在就可以以不同的方式使用cookie数据，比如以用户保存的个人配置来显示内容，以及统计他们访问网站的次数。&lt;/p&gt;
&lt;p&gt;如果浏览器没有找到cookie文件——这可能是因为之前从没有访问过这个网站或者阻止或删除了cookie——这样浏览器就不会发送任何cookie数据。&lt;/p&gt;
&lt;p&gt;在这个例子中，GitHub服务器创建了一个新的ID键值对，同时还有任何它需要的键值对，然后通过HTTP头部发送给我的电脑，我的电脑就把这些信息保存在硬盘里。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP 主体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就像上面看到的，服务保留了大部分它需要与客户端通信时用到的重要的元数据。&lt;/p&gt;
&lt;p&gt;现在回到主体部分。&lt;/p&gt;
&lt;p&gt;就像你猜的，主体就是信息部分的主体，这看请求类型，主体部分也可以是空的。&lt;/p&gt;
&lt;p&gt;在我们这个例子了，你在“响应”的页签里可以看到主体部分，自从我们发送了一个Get www.github.com的请求后，这个主体就包含了www.github.com的HTML页面内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附加练习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我希望这能让你更好地理解HTTP的结构，作为练习，当你访问www.github.com后，你可以看一下你浏览器请求的其它资源集（比如图片、JS文件等等）&lt;/p&gt;
&lt;p&gt;有了上面的知识，我们可以看一下客户端可以发起的各种HTTP请求方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP请求方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP动词或者方法，是告诉服务器通过URL中的数据标识去做什么，URL通常是指示一个特定的资源，当客户端使用含有HTTP动词的URL时，这是告诉服务器对于这个资源需要使用什么样的操作。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;GET &lt;a href=&quot;http://www.example.com/users&quot; class=&quot;uri&quot;&gt;http://www.example.com/users&lt;/a&gt; (取得所有用户)&lt;/p&gt;
&lt;p&gt;POST &lt;a href=&quot;http://www.example.com/users/a-unique-id&quot; class=&quot;uri&quot;&gt;http://www.example.com/users/a-unique-id&lt;/a&gt; (创建一个新用户)&lt;/p&gt;
&lt;p&gt;PUT &lt;a href=&quot;http://www.example.com/comments/a-unique-id&quot; class=&quot;uri&quot;&gt;http://www.example.com/comments/a-unique-id&lt;/a&gt; (更新评论)&lt;/p&gt;
&lt;p&gt;DELETE &lt;a href=&quot;http://www.example.com/comments/a-unique-id&quot; class=&quot;uri&quot;&gt;http://www.example.com/comments/a-unique-id&lt;/a&gt; (删除评论)&lt;/p&gt;
&lt;p&gt;当客户端发送一个请求，它将通过使用这些动词中的一个来指示是哪一类请求，其中最终要的一些动词是GET、POST、PUT和DELETE，这类动词还有其它如HEAD和OPTIONS，但是它们很少用到，所以我们在这篇文章中就不讨论它们了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GET是使用最普遍的请求方法，它的作用是从服务器上读取指定的URL。&lt;/p&gt;
&lt;p&gt;GET请求时只读的，这意味着服务器上的数据是不应该被修改的——服务器应该只是简单的获取未修改的数据。按这种方式，GET请求被认为是安全的操作，因为请求一次或者20次，它的效果都是一样的。&lt;/p&gt;
&lt;p&gt;此外，GET请求时幂等的，这意思就是你对同一个URL提交多次和提交一次导致的效果应该是一样的，因为一个GET请求只是请求服务器数据，而不去更改服务器上的任何数据。&lt;/p&gt;
&lt;p&gt;如果GET请求的资源被成功找到，那么响应状态码就是200（OK），如果资源不存在就是400（NOT FOUND）。（当你访问过期的或不存在的URL时，“404页面”就被作为是错误消息）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;POST&lt;/strong&gt;&lt;br/&gt;POST通常是用来创建新的资源，例如注册表单。但你想创建一些父资源（&lt;a href=&quot;http://example.com/users%EF%BC%89%E7%9A%84%E5%AD%90%E8%B5%84%E6%BA%90%EF%BC%88%E5%A6%82%E4%B8%80%E4%B8%AA%E6%96%B0%E7%94%A8%E6%88%B7&quot; class=&quot;uri&quot;&gt;http://example.com/users）的子资源（如一个新用户&lt;/a&gt;），你就可以用POST，你提交的资源是通过URL来识别其父资源，这样服务器在处理这个新资源是就会把它与其父资源联系起来。&lt;/p&gt;
&lt;p&gt;POST既不是安全的，也不是幂等的。这是因为你对同一个POST请求提交两次或多次，很可能导致创建了两个相同的资源。&lt;/p&gt;
&lt;p&gt;POST请求响应状态代码201(已创建)，并在头部带有指向新创建的资源的链接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PUT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PUT通常是用来更新资源的，它是通过URL和请求主体中的信息来识别要更新的资源。PUT也可以被用来创建新的资源。PUT请求也是不安全的操作，因为他们会修改服务器状态，然而，它是幂等的，因为你多次发送对同一个资源的PUT修改请求，它的效果和发送第一次的请求时一样的。&lt;/p&gt;
&lt;p&gt;如果资源被成功修改，PUT请求响应状态码是200（OK），如果资源不存在则返回404（NOT FOUND）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DELETE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DELETE通常是用来删除资源的。DELETE请求也是幂等的，因为你删除一个资源后，即使你多次重复发送多次同一个DELETE请求，结果也是一样的：资源已删除。&lt;/p&gt;
&lt;p&gt;如果你对同一个资源发送多次DELETE请求，你很可能会得到一个404的错误消息，因为服务器无法找到已被删除的资源。&lt;/p&gt;
&lt;p&gt;如果成功删除，DELETE请求响应状态码是200（OK），如果删除资源不存在就返回400（NOT FOUND）。&lt;/p&gt;
&lt;p&gt;对于上面的请求方法，如果服务器处理出错就返回500（服务器内部错误）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是REST呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我们完成这篇文章前还有最后一个属于：REST没有讲到。&lt;/p&gt;
&lt;p&gt;你可能之前听说过“REST风格的应用程序”，如果你在客户端与服务器使用HTTP通信的话，那么理解REST到底是什么意思是很重要的，这是遵循REST风格的一个好处。（事实上，我们上面定义的HTTP动词就很大程度上展示了REST是什么。）&lt;/p&gt;
&lt;p&gt;REST代表“Representational State Transfer”（表述性状态转移），这是一种针对设计应用程序的架构风格。&lt;/p&gt;
&lt;p&gt;它的基本想法是使用“无状态”，“客户端-服务器”，“可缓存”协议来使两台机器间通信——通常这个协议就是HTTP。这是一种奇特的方式来描述REST，REST给你一系列的约束去设计应用程序，这些约束使得系统性能、扩展性、简单、修改性、可见性、可移植性和可靠性更好。&lt;/p&gt;
&lt;p&gt;约束的全部内容很长，你可以从这里去了解更多。这篇文章的目的主要是想更深入地探讨以下两个最重要的点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、接口一致性：&lt;/strong&gt;&lt;br/&gt;这些约束告诉你如何去定义客户端与服务器之间的接口，让你以一种简单、可复制架构的方式去定义，也就是说：&lt;/p&gt;
&lt;p&gt;在请求里资源必须是可识别的（比如在URI用资源识别器）。一个资源（比如数据库里的数据）是定义资源表示的数据（如JSON，HTML）。资源和资源表示是分离的——客户端只与资源表示互动。&lt;/p&gt;
&lt;p&gt;客户端使用资源表示时必须要有足够的信息去操作服务器上的资源。&lt;/p&gt;
&lt;p&gt;客户端与服务器交换的每条消息必须是自我描述的，通过这些信息来决定如何处理这些消息。&lt;/p&gt;
&lt;p&gt;客户端必须使用HTTP主体内容、HTTP请求头、查询参数和URL发送状态数据。服务器必须使用HTTP主体内容、响应码和响应头部发送状态数据。&lt;/p&gt;
&lt;p&gt;注意：我们上面描述的HTTP动词使得“接口一致性”占据了很重要的部分，因为它们对那些操作的资源呈现一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、无状态：&lt;/strong&gt;&lt;br/&gt;这些约束表示所有状态数据需要处理的客户端请求必须包含在请求本身里（URL，查询参数、HTTP主体，或者HTTP头部），以及服务器发送的所有状态数据需要通过响应内容本身（HTTP头部、状态码和HTTP响应主体）需要返回给客户端。&lt;/p&gt;
&lt;p&gt;边注：状态或者应用程序状态是服务器完成请求所需要的数据。&lt;/p&gt;
&lt;p&gt;这就是说对于每一个请求，我们会来回发送状态信息，因此服务器不需要去维护、更新和发送状态。&lt;/p&gt;
&lt;p&gt;因为有了这种无状态系统使得应用程序更具扩展性，因为在多个请求中，服务器根本不用去操心维护同一会话状态，所有需要获取状态数据都可以在请求和响应本身取得。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结尾语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP很复杂，但正如你所见的，在客户端-服务器关系是一个关键的组成部分。&lt;/p&gt;
&lt;p&gt;设计REST风格的应用程序至少需要对HTTP有一个基本的了解，有了上面的内容，在你的下一个项目中，关于客户端-服务器通信的神秘之处会有一个更好的理解。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/Lau7/p/7886727.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/Lau7/p/7886727.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 15:50:00 +0000</pubDate>
<dc:creator>MingsonZheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MingsonZheng/p/9357640.html</dc:identifier>
</item>
<item>
<title>Python学习：16.Python面对对象（三、反射，构造方法，静态字段，静态方法） - BD-ld-2017</title>
<link>http://www.cnblogs.com/liudi2017/p/9357613.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liudi2017/p/9357613.html</guid>
<description>&lt;p&gt;&lt;span&gt;一、构造方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在使用类创建对象的时候（就是类后面加括号）就自动执行__init__方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

obj &lt;/span&gt;=&lt;span&gt; A()


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;虽然只是创建了obj对象，但是执行了__init__方法，输出了A&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Python中派生类可以继承父类的构造方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.基于super()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;遇到super()就表示去执行父类的xxx属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.tp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;annimal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        super(B,self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行B父类中的__init__方法，这里的self是obj&lt;br/&gt;　　　　 #super里的self不是传入后面的__init__方法里，而是直接传入A中的__init__，这里super会帮你传递参数&lt;/span&gt;
&lt;span&gt;
obj &lt;/span&gt;=&lt;span&gt; B()

输出结果：
B
A&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.通过父类的名称执行父类的构造方法。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.tp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;annimal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        A.&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;父类的名称跟上__init__()&lt;/span&gt;
&lt;span&gt;
obj &lt;/span&gt;=&lt;span&gt; B()    


输出结果：
B
A&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这两种方式中推荐super，使用第二中方法的时候，进行继承父类的方法的时候，是你指定父类的方法，看起来比较乱，但是使用super的时候，没有让你指定父类的名称，这种继承时候就按照正常的继承规则（上一节所讲）来进行。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、反射&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;利用反射查看面向对象的成员&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;根据字符串的形式去对象（某个模块）操作其成员&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; show(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Fshow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

r &lt;/span&gt;= hasattr(Foo,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;show&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(r)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看Foo类中是否有show函数&lt;/span&gt;
obj = Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
s &lt;/span&gt;= hasattr(obj,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看obj对象里name是否存在&lt;/span&gt;
t = hasattr(obj,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;show&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(t)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过对象查看是否存在show这个函数&lt;/span&gt;
&lt;span&gt;
输出结果：
True
True
True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们通过类进行查询的时候，仅仅只能找到类中的属性，但是我们通过类创建的对象查询的时候，我们不但可以找到对象中的属性（例如，self.name，直接在类中查询找不到），还可以找到对象中的方法（例如show函数），因为对象中有一个指向类的指针，当通过对象进行查询的时候，可以通过指针找到类中的属性。&lt;/p&gt;
&lt;h3&gt;利用反射导入模块、查找类、创建对象、查找对象中的字段&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.首先使用__import__导入文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数功能用于动态的导入模块，主要用于反射或者延迟加载模块。&lt;/p&gt;
&lt;p&gt; __import__(module)相当于import module&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.使用getattr(所导入的文件名，类名)导入类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;getattr根据字符串的形式去某个模块中寻找东西&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.通过找到的类创建对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.获取对象中的属性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;s2.py文件中的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; show(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Fshow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;s1.py文件中的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
m = &lt;span&gt;__import__&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

class_name &lt;/span&gt;= getattr(m,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

obj &lt;/span&gt;= class_name(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

val &lt;/span&gt;= getattr(obj,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(val)


输出结果：
Alexsel&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;三、静态字段&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;静态字段的作用，将每个对象里存在的重复的东西，使用静态字段在类中只需写一份。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    annimal &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这个是静态字段，是在类中保存的&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        temp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;普通字段，存放在对象中&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;普通方法，存放在类中&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; show(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SH&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(Foo.annimal)


输出结果：
Cat&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用静态字段的时候，优先使用类名访问静态字段。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;四、静态方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　静态方法是类中的函数，不需要实例。静态方法主要是用来存放逻辑性的代码，主要是一些逻辑属于类，但是和类本身没有交互，即在静态方法中，不会涉及到类中的方法和属性的操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    annimal &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; show(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SH&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;装饰器，使用这个装饰器装饰类中的一个方法，这个方法就变为静态方法&lt;/span&gt;
&lt;span&gt;    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; out():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


Foo.out()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;静态方法中不需要传递self，所以访问静态方法优先使用类去访问&lt;/span&gt;
obj =&lt;span&gt; Foo()
obj.out()


输出结果：
out
out&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;静态方法可以让我们不需要创建对象就可以执行类中的方法。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;五、类方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　类方法是将类本身作为对象进行操作的方法。他和静态方法的区别在于：不管这个方式是从实例调用还是从类调用，它都用第一个参数把类传递过来&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    annimal &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; show(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SH&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;装饰器，使用这个装饰器装饰类中的一个方法，这个方法就变为类方法&lt;/span&gt;
&lt;span&gt;    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; out(cls):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,cls)


Foo.out()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;类方法，会自动将的类传递到类方法的cls中&lt;/span&gt;
&lt;span&gt;

输出结果：
out &lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 23 Jul 2018 15:43:00 +0000</pubDate>
<dc:creator>BD-ld-2017</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liudi2017/p/9357613.html</dc:identifier>
</item>
<item>
<title>ParisGabriel：Python全栈工程师（0基础到精通）教程 第二十五课（文件操作、） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9357601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9357601.html</guid>
<description>
&lt;div align=&quot;left&quot;&gt;
&lt;p&gt;&lt;span&gt;ParisGabriel&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;         每天坚持手写  一天一篇  决定坚持几年 为了梦想为了信仰&lt;/p&gt;

&lt;div align=&quot;left&quot;&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709225751471-608583048.png&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;Python人工智能从入门到精通&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;最近简直要死了 发烧感冒 喉咙痛。。。。、&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;如何长期保存计算机中数据：&lt;br/&gt;需要文件操作&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;文件 file：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　　　文件&lt;strong&gt;是用于数据存储的单位&lt;/strong&gt;&lt;br/&gt;　　　　文件通常&lt;strong&gt;用来长期储存数据&lt;/strong&gt;&lt;br/&gt;　　　　文件中的&lt;strong&gt;数据&lt;/strong&gt;是&lt;strong&gt;以字节为单位&lt;/strong&gt;进行&lt;strong&gt;顺序储存&lt;/strong&gt;的&lt;br/&gt;&lt;span&gt;&lt;strong&gt;文件的操作流程：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;1.打开文件&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;2.读/写文件&lt;/strong&gt;&lt;br/&gt;　&lt;strong&gt;　3.关闭文件&lt;/strong&gt;&lt;br/&gt;　　注：&lt;br/&gt;　　　　&lt;strong&gt;任何&lt;/strong&gt;操作&lt;strong&gt;系统&lt;/strong&gt;， 一个应用程序&lt;strong&gt;同时打开文件&lt;/strong&gt;的&lt;strong&gt;数量有&lt;/strong&gt;最大数&lt;strong&gt;限&lt;/strong&gt;制&lt;br/&gt;&lt;strong&gt;文件打开函数：&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;&lt;span&gt;open&lt;/span&gt;&lt;/strong&gt;（file， mode=‘rt’） 用于&lt;strong&gt;打开&lt;/strong&gt;一个&lt;strong&gt;文件&lt;/strong&gt;， 返回此文件流对象，&lt;br/&gt;　　如果打开文件&lt;strong&gt;失败&lt;/strong&gt;， 则会&lt;strong&gt;触发osError&lt;/strong&gt;错误&lt;br/&gt;文件的关闭方法：&lt;br/&gt;　　&lt;strong&gt;&lt;span&gt;F.colse（）&lt;/span&gt;&lt;/strong&gt; #&lt;strong&gt;关闭问津&lt;/strong&gt;， &lt;strong&gt;释放系统资源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意文件的打开和关闭操作&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    f &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./aaa.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不存在此文件&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; f = open('./myfile.txt')  # 不存在此文件&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打开文件成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此处要进行读/写操作&lt;/span&gt;
&lt;span&gt;
    f.close()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 半闭文件&lt;/span&gt;
&lt;span&gt;except&lt;/span&gt;&lt;span&gt; OSError:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件打开失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件方法：&lt;/p&gt;
&lt;h2 id=&quot;_1&quot;&gt;&lt;span&gt;文件&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;mode&quot;&gt;mode 模式字符的含义&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'r'&lt;/td&gt;
&lt;td&gt;以只读方式打开(默认)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;'w'&lt;/td&gt;
&lt;td&gt;以只写方式打开，删除原有文件内容(如果文件不存在，则创建该文件并以只写方式打开)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;'x'&lt;/td&gt;
&lt;td&gt;创建一个新文件, 并以写模式打开这个文件,如果文件存在则会产生&quot;FileExistsError&quot;错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'a'&lt;/td&gt;
&lt;td&gt;以只写文件打开一个文件，如果有原文件则追加到文件末尾&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;'b'&lt;/td&gt;
&lt;td&gt;用二进制模式打开&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'t'&lt;/td&gt;
&lt;td&gt;文本文件模式打开 (默认)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'+'&lt;/td&gt;
&lt;td&gt;为更新内容打开一个磁盘文件 (可读可写)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;缺省模式是 'rt'&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;'w+b'&lt;/span&gt; 可以实现二进制随机读写，当打开文件时，文件内容将被清零&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;'r+b'&lt;/span&gt; 以二进制读和更新模式打开文件,打开文件时不会清空文件内容&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;'r+'&lt;/span&gt; 以文本模式读和更新模式打开文件,打开文件时不会清空文件内容&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;python_1&quot;&gt;&lt;span&gt;python 文件常用方法:&lt;/span&gt;&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.close()&lt;/td&gt;
&lt;td&gt;关闭文件(关闭后文件不能再读写会发生ValueError错误)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;F.readline()&lt;/td&gt;
&lt;td&gt;读取一行数据, 如果到达文件尾则返回空行&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;F.readlines(max_chars=-1)&lt;/td&gt;
&lt;td&gt;返回每行字符串的列表,max_chars为最大字符(或字节)数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.writelines(lines)&lt;/td&gt;
&lt;td&gt;将字符串的列表或字符串的列表中的内容写入文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;二进制文件操作方法&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;F.read(size=-1)&lt;/td&gt;
&lt;td&gt;从一个文件流中最多读取size个字符(文本文件)或字节(二进制文件),如果不给出参数，则默认读取文件中全部的内容并返回&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;F.write(text)&lt;/td&gt;
&lt;td&gt;写一个字符串到文件流中，返回写入的字符数(文本文件)或字节数(二进制文件)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.tell()&lt;/td&gt;
&lt;td&gt;返回当前文件流读写指针的绝对位置(字节为单位)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.seek(offset, whence=0)&lt;/td&gt;
&lt;td&gt;改变数据流读写指针的位置，返回新的绝对位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.flush()&lt;/td&gt;
&lt;td&gt;把写入文件对象的缓存内容写入到磁盘&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;F.readable()&lt;/td&gt;
&lt;td&gt;判断这个文件是否可读,可读返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;F.writable()&lt;/td&gt;
&lt;td&gt;判断这个文件是否可写,可写返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.seekable()&lt;/td&gt;
&lt;td&gt;返回这个文件对象是否支持随机定位&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.truncate(pos = None)&lt;/td&gt;
&lt;td&gt;剪掉 自pos位置之后的数据，返回新的文件长度&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;文本文件操作：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;操作模式：&lt;/strong&gt;&lt;br/&gt;　　‘t’&lt;br/&gt;　　&lt;strong&gt;说明：&lt;/strong&gt;&lt;br/&gt;　　　　1.默认&lt;strong&gt;文件&lt;/strong&gt;中&lt;strong&gt;储存的都为字节数据&lt;/strong&gt;， 在&lt;strong&gt;读写过程&lt;/strong&gt;中&lt;strong&gt;会自动&lt;/strong&gt;进行&lt;strong&gt;编解码&lt;/strong&gt;操作&lt;br/&gt;　　　　2.文本&lt;strong&gt;文件以行位单位进行分割&lt;/strong&gt;， 在&lt;strong&gt;python内部统一用&quot;\n&quot;&lt;/strong&gt;做为换行符&lt;strong&gt;进行分割&lt;/strong&gt;&lt;br/&gt;　　　　3.对文本文件的&lt;strong&gt;读写操作需要用字符串（str）进行数据操作&lt;/strong&gt;&lt;br/&gt;Linux换行符: '\n'&lt;br/&gt;Windows 换行符: '\r\n'&lt;br/&gt;新的Mac OS 换行符: '\n'&lt;br/&gt;旧的Macintosh换行符: '\r'(已不用了)&lt;/p&gt;

&lt;p&gt;文件流对象是可迭代对象， 迭代过程中将换行符“\n”作为分隔符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;phonenumber.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(line)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印每一行的数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;标准输入输出文件：&lt;/strong&gt;&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;sys.stdin&lt;/strong&gt;&lt;/span&gt; 　　 &lt;strong&gt;标准输入&lt;/strong&gt;文件&lt;br/&gt;　　&lt;strong&gt;&lt;span&gt;Ctrl + D&lt;/span&gt;&lt;/strong&gt;　　    输入文件&lt;strong&gt;结束符&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;&lt;span&gt;sys.stdout&lt;/span&gt;&lt;/strong&gt; 　 &lt;strong&gt; 标准输出文件&lt;/strong&gt;&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;sys.stderr &lt;/strong&gt;&lt;/span&gt;      &lt;strong&gt;标准错误&lt;/strong&gt;输出文件&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;标准文件绝对不能关闭&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;Linux系统内所有的硬件都会映射成文件 关闭文件会导致错误&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;模块：sys&lt;/strong&gt;&lt;br/&gt;注：&lt;br/&gt;　　&lt;strong&gt;标准文件不需要打开和关闭就可以使用&lt;/strong&gt;&lt;br/&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys

sys.stdout.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是标准输出\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
sys.stderr.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是一个错误\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys

s &lt;/span&gt;=&lt;span&gt; sys.stdin.read()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, s)


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;程序结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二进制文件操作：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　二进制文件操作模式字符：&lt;span&gt;&lt;strong&gt;‘b’&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;默认&lt;/strong&gt;文件中存储的是以&lt;strong&gt;字节数据为单位&lt;/strong&gt;， &lt;strong&gt;通常有人为规定&lt;/strong&gt;的&lt;strong&gt;格式&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;二进制文件&lt;/strong&gt;操作需要&lt;strong&gt;用字节串进行读写&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;&lt;span&gt;F.read&lt;/span&gt;&lt;/strong&gt;（）/&lt;span&gt;&lt;strong&gt;F.readline&lt;/strong&gt;&lt;/span&gt;() &lt;span&gt;&lt;strong&gt;F.readlines&lt;/strong&gt;&lt;/span&gt;（）返回类型&lt;br/&gt;对于文本操作&lt;br/&gt;　　&lt;span&gt;F.write&lt;/span&gt;（） 对于二进制文件也需要用字节串进行操作&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;F.tell&lt;/strong&gt;&lt;/span&gt;：&lt;br/&gt;&lt;strong&gt;　　作用：&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;返回当前的读写位置&lt;/strong&gt;（从文件头以字节为单位）&lt;br/&gt;　　&lt;strong&gt;&lt;span&gt;F.seek&lt;/span&gt;&lt;/strong&gt;方法：&lt;br/&gt;　　　　F.seek（偏移量，whence=相对位置）&lt;br/&gt;&lt;strong&gt;　　偏移量&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;大于0&lt;/strong&gt;的数代表向&lt;strong&gt;文件尾方向移动&lt;/strong&gt;的字节数&lt;br/&gt;　　　　&lt;strong&gt;小于0&lt;/strong&gt;的数代表向&lt;strong&gt;文件头方向移动&lt;/strong&gt;的字节数&lt;br/&gt;　&lt;strong&gt;　相对位置&lt;/strong&gt;&lt;br/&gt;　　　　&lt;span&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/span&gt;代表从&lt;strong&gt;文件头开始偏移&lt;/strong&gt;&lt;br/&gt;　　　　&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;代表从文件当&lt;strong&gt;前位置开始偏移&lt;/strong&gt;&lt;br/&gt;　　　　&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;代表从&lt;strong&gt;文件尾开始偏移&lt;/strong&gt; （第一个参数必须是负的）&lt;br/&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意用seek改变文件的读写位置,用tell来得到读写位置&lt;/span&gt;
&lt;span&gt;
f &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myseek.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
b &lt;/span&gt;= f.read(2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; b'AB' 读取出来&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(b)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; b'AB&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从头开始向后走5个字节&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; f.seek(5, 0)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从当前位置向后走3个字节&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; f.seek(3, 1)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从文件尾向前数15个字节&lt;/span&gt;
f.seek(-15, 2&lt;span&gt;)

b &lt;/span&gt;= f.read(5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(b)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; b'abcde'&lt;/span&gt;
&lt;span&gt;
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;汉字编码&lt;/span&gt;（只讲两种）&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;国标系列:&lt;/strong&gt;&lt;br/&gt;　　　　&lt;span&gt;GB18030&lt;/span&gt;(&lt;strong&gt;二字节或四字节&lt;/strong&gt;编码&lt;strong&gt;27553&lt;/strong&gt;个字)&lt;br/&gt;　　　　&lt;span&gt;GBk&lt;/span&gt;（&lt;strong&gt;二字节&lt;/strong&gt;编码&lt;strong&gt;21003&lt;/strong&gt;个字）&lt;br/&gt;　　　　&lt;span&gt;GB2312&lt;/span&gt;（&lt;strong&gt;二字节&lt;/strong&gt;编码&lt;strong&gt;6763&lt;/strong&gt;个字）&lt;br/&gt;　　　　（Windows 常用）&lt;br/&gt;　　&lt;strong&gt;国际标准&lt;/strong&gt;： &lt;strong&gt;Unicode &amp;lt;---&amp;gt; UTF-8 (Ascii 占1字节 汉字占3字节)&lt;/strong&gt;&lt;br/&gt;　　　　（Linux Mac OS X / IOS /Android）&lt;br/&gt;　　　　python编码字符串：&lt;br/&gt;　　　　‘gb18030’&lt;br/&gt;　　　　‘gb2312’&lt;br/&gt;　　　　‘gbk’&lt;br/&gt;　　　　‘utf-8’&lt;br/&gt;　　　　‘ascii’&lt;br/&gt;　　　　....&lt;br/&gt;&lt;strong&gt;以上字符串用于&lt;span&gt;encide&lt;/span&gt;和&lt;span&gt;decode&lt;/span&gt;中&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;编码注释：&lt;/strong&gt;&lt;br/&gt;　　在Python源文件中的&lt;strong&gt;第一行&lt;/strong&gt;或&lt;strong&gt;第二行&lt;/strong&gt;写入如下内容：&lt;br/&gt;　　　　&lt;strong&gt;&lt;span&gt;# -*- codeing：gbk -*-&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　　　#设置源文件&lt;strong&gt;编码格式为gbk&lt;/strong&gt;&lt;br/&gt;　　　　或&lt;br/&gt;　　　&lt;span&gt;&lt;strong&gt;　# -*- codeing：utf-8 -*-&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　　　#设置源文件&lt;strong&gt;编码格式为utf-8&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;作用：&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;告诉解释执行器&lt;/strong&gt;此&lt;strong&gt;文件的编码&lt;/strong&gt;是什么&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180723233711203-1903857670.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;练习:&lt;br/&gt;自己写一个文件 'info.txt' 内部存一些文字信息&lt;br/&gt;如:&lt;br/&gt;张三 20 100&lt;br/&gt;李四 21 96&lt;br/&gt;小王 22 98&lt;br/&gt;写程序将这些数据读取出来，打印到终端上&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    f &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myfile.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    L &lt;/span&gt;=&lt;span&gt; f.readlines()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L:
        s &lt;/span&gt;=&lt;span&gt; x.strip()
        n, a, s &lt;/span&gt;=&lt;span&gt; s.split()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;姓名：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, n, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年龄：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, int(a), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成绩：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, int(s))
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打开文件是失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;练习:&lt;br/&gt;1. 写程序，循环输入很多个人的姓名，电话号码,&lt;br/&gt;当输入结束后将这些信息存入到文件phonenumber.txt中&lt;br/&gt;(建议先用列表暂存数据，格式自己定义)&lt;/p&gt;
&lt;p&gt;　　２．　写程序，将phonenumber.txt文件中的数据读取出来．&lt;br/&gt;　　　　　再用以下格式打印出来:&lt;br/&gt;如:&lt;br/&gt;小张 的电话是 13888888888&lt;br/&gt;小李 的电话是 13999999999&lt;/p&gt;

&lt;p&gt;练习:&lt;br/&gt;1. 写程序实现复制文件的功能&lt;br/&gt;要求:&lt;br/&gt;1. 要考虑特大文件问题&lt;br/&gt;2. 要关闭文件&lt;br/&gt;3. 要能复制二进制文件&lt;br/&gt;如:&lt;br/&gt;请输入源文件路径名: /home/tarena/xxx.tar.gz&lt;br/&gt;请输入目标文件路径名: ./a.tar.gz&lt;br/&gt;显示:&lt;br/&gt;文件已成功复制&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; copy_myfile():
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        ypath &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;please inout raw path:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        xpath &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;please inout new path:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        f1 &lt;/span&gt;= open(xpath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w+b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        f &lt;/span&gt;= open(ypath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r+b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f:
            f1.write(x)
        f1.close()
        f.close()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;File copied&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file not inexeistence&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


copy_myfile()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 修改学生信息管理程序,要求加入两个功能:&lt;br/&gt;9) 保存信息到文件(si.txt)&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
L = [{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 20, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 98&lt;span&gt;},
     {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 21, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 99&lt;span&gt;},
     {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Garin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 19, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 100&lt;span&gt;}]


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; student_file(L):
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        f &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./si.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L:
            f.write(x[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
            f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            f.write(str(x[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
            f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            f.write(str(x[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
            f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; FileExistsError:
        f &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./si.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L:
            f.write(x[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
            f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            f.write(str(x[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
            f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            f.write(str(x[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
            f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

student_file(L)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;10) 从文件中读取数据(si.tx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;..................&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 15:39:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9357601.html</dc:identifier>
</item>
<item>
<title>springboot+security整合1 - 烦嚣的人</title>
<link>http://www.cnblogs.com/wuyoucao/p/9357551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuyoucao/p/9357551.html</guid>
<description>&lt;p&gt;下一篇，&lt;a href=&quot;https://www.cnblogs.com/wuyoucao/p/9357554.html&quot;&gt;点击跳转&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明springboot版本2.0.3&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-介绍&quot;&gt;一、 介绍&lt;/h2&gt;
&lt;p&gt;  Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。&lt;/p&gt;
&lt;h2 id=&quot;二-环境搭建&quot;&gt;二、 环境搭建&lt;/h2&gt;
&lt;p&gt;  建立springboot2项目,加入security依赖,mybatis依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据库为传统的用户--角色--权限，权限表记录了url和method，springboot配置文件如下：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;mybatis:
  type-aliases-package: com.example.demo.entity
server:
  port: 8081
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=true
    username: root
    password: 123456
  http:
    encoding:
      charset: utf-8
      enabled: true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;springboot启动类中加入如下代码,设置路由匹配规则。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
protected void configurePathMatch(PathMatchConfigurer configurer) {
    configurer.setUseSuffixPatternMatch(false) //设置路由是否后缀匹配，譬如/user能够匹配/user.,/user.aa
        .setUseTrailingSlashMatch(false); //设置是否后缀路径匹配，比如/user能够匹配/user,/user/
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三-security配置&quot;&gt;三、 security配置&lt;/h2&gt;
&lt;p&gt;  默认情况下security是无需任何自定义配置就可使用的，我们不考虑这种方式，直接讲如何个性化登录过程。&lt;/p&gt;
&lt;h4 id=&quot;建立security配置文件目前配置文件中还没有任何配置&quot;&gt;1、 建立security配置文件,目前配置文件中还没有任何配置。&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;个性化登录security中的登录如下&quot;&gt;2、 个性化登录，security中的登录如下：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAZAAD/4QOTaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjMtYzAxMSA2Ni4xNDU2NjEsIDIwMTIvMDIvMDYtMTQ6NTY6MjcgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTdFRTJGMTQ4RTFFMTFFOEFCNzlFMzVDMTkzNERBNDIiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTdFRTJGMTM4RTFFMTFFOEFCNzlFMzVDMTkzNERBNDIiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiBXaW5kb3dzIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiBzdFJlZjpkb2N1bWVudElEPSI2NDVGMTQxMkU0QjRCRTBBNTU0N0YyN0YzNjBGQUNFMSIvPiA8ZGM6Y3JlYXRvcj4gPHJkZjpTZXE+IDxyZGY6bGk+ZnhiPC9yZGY6bGk+IDwvcmRmOlNlcT4gPC9kYzpjcmVhdG9y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&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;security需要一个user的实体类实现&lt;code&gt;UserDetails&lt;/code&gt;接口,该实体类最后与系统中用户的实体类分开，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SecurityUser implements UserDetails{
    private static final long serialVersionUID = 1L;
    private String password;
    private String name;
    List&amp;lt;GrantedAuthority&amp;gt; authorities;
    
    public User(string name,string password) {
        this.id = id;
        this.password = password;
        this.name = name;
        this.age = age;
    }

    public void setAuthorities(List&amp;lt;GrantedAuthority&amp;gt; authorities) {
        this.authorities = authorities;
    }

    @Override
    public Collection&amp;lt;GrantedAuthority&amp;gt; getAuthorities() {
        return this.authorities;
    }

    @Override //获取校验用户名
    public String getUsername() {
        return String.valueOf(this.id);
    }

    @Override //获取校验用密码
    public String getPassword() {
        return password;
    }

    @Override //账户是否未过期
    public boolean isAccountNonExpired() {
        // TODO Auto-generated method stub
        return true;
    }

    @Override  //账户是否未锁定
    public boolean isAccountNonLocked() {
        // TODO Auto-generated method stub
        return true;
    }

    @Override  //帐户密码是否未过期，一般有的密码要求性高的系统会使用到，比较每隔一段时间就要求用户重置密码
    public boolean isCredentialsNonExpired() {
        // TODO Auto-generated method stub
        return true;
    }

    @Override //账户是否可用
    public boolean isEnabled() {
        // TODO Auto-generated method stub
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;编写了实体类还需要编写一个服务类SecurityService实现&lt;code&gt;UserDetailsService&lt;/code&gt;接口，重写loadByUsername方法，通过这个方法根据用户名获取用户信息，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class SecurityUserService implements UserDetailsService {
    @Autowired
    private JurisdictionMapper jurisdictionMapper;
    @Autowired
    private UserMapper userMapper;
    private Logger log = LoggerFactory.getLogger(this.getClass());


    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        log.info(&quot;登录用户id为：{}&quot;,username);
        int id = Integer.valueOf(username);
        User user = userMapper.getById(id);
        if(user==null) {
            //抛出错误，用户不存在
            throw new UsernameNotFoundException(&quot;用户名 &quot;+username+&quot;不存在&quot;);
        }
        //获取用户权限
        List&amp;lt;GrantedAuthority&amp;gt; authorities = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;Jurisdiction&amp;gt; jurisdictions = jurisdictionMapper.selectByUserId(id);
        for(Jurisdiction item : jurisdictions) {
            GrantedAuthority authority = new MyGrantedAuthority(item.getMethod(),item.getUrl());
            authorities.add(authority);
        }
        SecurityUser securityUser = new SecurityUser(user.getName(),user.getPassword(),authority):
        user.setAuthorities(authorities);
        return securityUser;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通常我们会对密码进行加密，所有还要编写一个passwordencode类，实现PasswordEncoder接口，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class MyPasswordEncoder implements PasswordEncoder {
    private Logger log = LoggerFactory.getLogger(this.getClass());

    @Override //不清楚除了在下面方法用到还有什么用处
    public String encode(CharSequence rawPassword) {
        return StringUtil.StringToMD5(rawPassword.toString());
    }

    //判断密码是否匹配
    @Override
    public boolean matches(CharSequence rawPassword, String encodedPassword) {
        return encodedPassword.equals(this.encode(rawPassword));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;编辑配置文件&quot;&gt;3、 编辑配置文件&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;编写config Bean以使用上面定义的验证逻辑,securityUserService、myPasswordEncoder通过@Autowired引入。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.userDetailsService(securityUserService)
        .passwordEncoder(myPasswordEncoder);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后编写configure Bean（和上一个不一样，参数不同），实现security验证逻辑,代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
    protected void configure(HttpSecurity http) throws Exception {
        http
        .csrf() //跨站
        .disable() //关闭跨站检测
        .authorizeRequests()//验证策略策略链
            .antMatchers(&quot;/public/**&quot;).permitAll()//无需验证路径
           .antMatchers(&quot;/login&quot;).permitAll()//放行登录
            .antMatchers(HttpMethod.GET, &quot;/user&quot;).hasAuthority(&quot;getAllUser&quot;)//拥有权限才可访问
            .antMatchers(HttpMethod.GET, &quot;/user&quot;).hasAnyAuthority(&quot;1&quot;,&quot;2&quot;)//拥有任一权限即可访问
            //角色类似，hasRole(),hasAnyRole()
            .anyRequest().authenticated()
        .and()
        .formLogin()
            .loginPage(&quot;/public/unlogin&quot;) //未登录跳转页面,设置了authenticationentrypoint后无需设置未登录跳转页面
            .loginProcessingUrl(&quot;/public/login&quot;)//处理登录post请求接口，无需自己实现
            .successForwardUrl(&quot;/success&quot;)//登录成功转发接口
            .failureForwardUrl(&quot;/failed&quot;)//登录失败转发接口
            .usernameParameter(&quot;id&quot;) //修改用户名的表单name，默认为username
            .passwordParameter(&quot;password&quot;)//修改密码的表单name，默认为password
        .and()
        .logout()//自定义登出
            .logoutUrl(&quot;/public/logout&quot;) //自定义登出api，无需自己实现
            .logoutSuccessUrl(&quot;public/logoutSuccess&quot;)
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里便可实现security与springboot的基本整合。&lt;/p&gt;
&lt;h2 id=&quot;四实现记住我功能&quot;&gt;四、实现记住我功能&lt;/h2&gt;
&lt;h4 id=&quot;建表&quot;&gt;1、 建表&lt;/h4&gt;
&lt;p&gt;  记住我功能需要数据库配合实现，首先要在数据库建一张表用户保存cookie和用户名，数据库建表语句如下：不能做修改&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `persistent_logins` (
  `username` varchar(64) NOT NULL,
  `series` varchar(64) NOT NULL,
  `token` varchar(64) NOT NULL,
  `last_used` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`series`)
)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;编写remembermeservice-bean&quot;&gt;2、 编写rememberMeservice Bean&lt;/h4&gt;
&lt;p&gt;  代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Bean
    public RememberMeServices rememberMeServices(){
        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();
        jdbcTokenRepository.setDataSource(dataSource);
        PersistentTokenBasedRememberMeServices rememberMeServices =
                new PersistentTokenBasedRememberMeServices(&quot;INTERNAL_SECRET_KEY&quot;,securityUserService,jdbcTokenRepository);
        //还可设置许多其他属性
       rememberMeServices.setCookieName(&quot;kkkkk&quot;); //客户端cookie名
        return rememberMeServices;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dataSource为@Autowired引入&lt;/p&gt;
&lt;h4 id=&quot;配置文件设置remember&quot;&gt;3、 配置文件设置remember&lt;/h4&gt;
&lt;p&gt;  在config(HttpSecurity http)中加入记住我功能&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;.rememberMe()
    .rememberMeServices(rememberMeServices())
    .key(&quot;INTERNAL_SECRET_KEY&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在登录表单中设置remember-me即可实现记住我功能。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 15:21:00 +0000</pubDate>
<dc:creator>烦嚣的人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuyoucao/p/9357551.html</dc:identifier>
</item>
<item>
<title>I-team 博客全文检索 Elasticsearch 实战 - haifeiWu</title>
<link>http://www.cnblogs.com/haifeiWu/p/9357547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haifeiWu/p/9357547.html</guid>
<description>&lt;p&gt;一直觉得博客缺点东西，最近还是发现了，当博客慢慢多起来的时候想要找一篇之前写的博客很是麻烦，于是作为后端开发的楼主觉得自己动手丰衣足食，也就有了这次博客全文检索功能Elasticsearch实战，这里还要感谢一下‘辉哥’赞助的一台服务器。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;全文检索工具选型&quot;&gt;全文检索工具选型&lt;/h2&gt;
&lt;p&gt;众所周知，支持全文检索的工具有很多，像 Lucene，solr， Elasticsearch 等，相比于其他的工具，显然 Elasticsearch 社区更加活跃，遇到问题相对来说也比较好解决，另外 Elasticsearch 提供的restful接口操作起来还是比较方便的，这也是楼主选择 Elasticsearch 的重要原因，当然 Elasticsearch 占据的内存相对来说比较大一点，楼主2G的云服务器跑起来也是捉襟见肘。&lt;/p&gt;
&lt;h2 id=&quot;数据迁移从-mysql-到-elasticsearch&quot;&gt;数据迁移，从 MySQL 到 Elasticsearch&lt;/h2&gt;
&lt;p&gt;这个功能相对来说比较简单，就是定时从 MySQL 更新数据到 Elasticsearch 中，本来楼主打算自己写一个数据迁移的工具，但是想起之前楼主做数据迁移时用到的DataX很是不错，看了写官方文档还是支持的，但是楼主硬是没有跑起来，原因就是楼主2G内存的云服务器不够使啊，DataX光是跑起来就要1G多的内存，所以楼主只能另谋它法。对DataX感兴趣的小伙伴可以看看楼主的另一篇文章&lt;a href=&quot;http://www.hchstudio.cn/article/2018/4928/&quot; title=&quot;阿里离线数据同步工具 DataX 踩坑记录&quot;&gt;阿里离线数据同步工具 DataX 踩坑记录&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;说起可以省内存的语言，小伙伴可能会想到最近比较火的golang，没错楼主也想到了。最后楼主使用的就是一个叫go-mysql-elasticsearch的工具，就是使用golang实现的从 MySQL 将数据迁移到 Elasticsearch 的工具。具体搭建过程楼主不在这里细说，感兴趣的小伙伴请移步&lt;a href=&quot;https://github.com/siddontang/go-mysql-elasticsearch&quot; title=&quot;go-mysql-elasticsearch&quot;&gt;go-mysql-elasticsearch&lt;/a&gt;，另外 Elasticsearch 环境的搭建，需要注意的就是安装 Elasticsearch 的机器内存应该大于或者等于2G，否则可能会出现起不起来的情况，楼主也不在这里赘述了，比较简单，请小伙伴们自行google。&lt;/p&gt;
&lt;p&gt;另外需要注意的是，在使用 go-mysql-elasticsearch 的时候应该开启mysql的binlog功能，go-mysql-elasticsearch的实现同步数据的思想就是将自己作为MySQL的一个slave挂载在MySQL上，这样就可以很轻松的将数据实时同步到 Elasticsearch 中，在启动 go-mysql-elasticsearch 的机器上最少应该有MySQL client工具，否则会启动报错。楼主的建议是根MySQL部署在同一台机器上，因为golang耗费内存极少，并不会有太大影响。下面给出楼主同步数据时 go-mysql-elasticsearch 的配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# MySQL address, user and password
# user must have replication privilege in MySQL.
my_addr = &quot;127.0.0.1:3306&quot;
my_user = &quot;root&quot;
my_pass = &quot;******&quot;
my_charset = &quot;utf8&quot;

# Set true when elasticsearch use https
#es_https = false
# Elasticsearch address
es_addr = &quot;127.0.0.1:9200&quot;
# Elasticsearch user and password, maybe set by shield, nginx, or x-pack
es_user = &quot;&quot;
es_pass = &quot;&quot;

# Path to store data, like master.info, if not set or empty,
# we must use this to support breakpoint resume syncing.
# TODO: support other storage, like etcd.
data_dir = &quot;./var&quot;

# Inner Http status address
stat_addr = &quot;127.0.0.1:12800&quot;

# pseudo server id like a slave
server_id = 1001

# mysql or mariadb
flavor = &quot;mysql&quot;

# mysqldump execution path
# if not set or empty, ignore mysqldump.
mysqldump = &quot;mysqldump&quot;

# if we have no privilege to use mysqldump with --master-data,
# we must skip it.
#skip_master_data = false

# minimal items to be inserted in one bulk
bulk_size = 128

# force flush the pending requests if we don't have enough items &amp;gt;= bulk_size
flush_bulk_time = &quot;200ms&quot;

# Ignore table without primary key
skip_no_pk_table = false

# MySQL data source
[[source]]
schema = &quot;billboard-blog&quot;

# Only below tables will be synced into Elasticsearch.
tables = [&quot;content&quot;]
# Below is for special rule mapping
[[rule]]
schema = &quot;billboard-blog&quot;
table = &quot;content&quot;
index = &quot;contentindex&quot;
type = &quot;content&quot;

[rule.field]
title=&quot;title&quot;
blog_desc=&quot;blog_desc&quot;
content=&quot;content&quot;


# Filter rule
[[rule]]
 schema = &quot;billboard-blog&quot;
 table = &quot;content&quot;
 index = &quot;contentindex&quot;
 type = &quot;content&quot;

# Only sync following columns
filter = [&quot;title&quot;, &quot;blog_desc&quot;, &quot;content&quot;]

# id rule
[[rule]]
 schema = &quot;billboard-blog&quot;
 table = &quot;content&quot;
 index = &quot;contentindex&quot;
 type = &quot;content&quot;
 id = [&quot;id&quot;]

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现全文检索功能的服务&quot;&gt;实现全文检索功能的服务&lt;/h2&gt;
&lt;p&gt;要想实现全文检索的功能并对外提供服务，web服务必不可少，楼主使用Spring Boot搭建web服务，对Spring Boot感兴趣的小伙伴也可以看一下楼主的另一篇文章，&lt;a href=&quot;http://www.hchstudio.cn/article/2018/6f25/&quot; title=&quot;使用Spring Boot实现博客统计服务&quot;&gt;使用Spring Boot实现博客统计服务&lt;/a&gt;。好了废话不多说了，请看代码&lt;/p&gt;
&lt;p&gt;接口实现代码，代码比较简单就是接收参数，调用service代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    @ApiOperation(value=&quot;全文检索接口&quot;, notes=&quot;&quot;)
    @ApiImplicitParam(name = &quot;searchParam&quot;, value = &quot;博客搜索条件（作者，描述，内容，标题）&quot;, required = true, dataType = &quot;String&quot;)
    @RequestMapping(value = &quot;/get_content_list_from_es&quot;, method = RequestMethod.GET)
    public ResultCode&amp;lt;List&amp;lt;ContentsWithBLOBs&amp;gt;&amp;gt; getContentListFromEs(String searchParam) {
        ResultCode&amp;lt;List&amp;lt;ContentsWithBLOBs&amp;gt;&amp;gt; resultCode = new ResultCode();
        try {
            LOGGER.info(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; method getContentListFromEs request params : {},{}，{}&quot;,searchParam);
            resultCode = contentService.getContentListFromEs(searchParam);
            LOGGER.info(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; method getContentListFromEs return value : {}&quot;,JSON.toJSONString(resultCode));
        } catch (Exception e) {
            e.printStackTrace();
            resultCode.setCode(Messages.API_ERROR_CODE);
            resultCode.setMsg(Messages.API_ERROR_MSG);
        }
        return resultCode;
    }
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;service代码实现，这里代码主要功能就是调用es的工具类，对博客描述，作者，博客标题，博客内容进行全文检索。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    @Override
    public ResultCode&amp;lt;List&amp;lt;ContentsWithBLOBs&amp;gt;&amp;gt; getContentListFromEs(String searchParam) {
        ResultCode resultCode = new ResultCode();

        // 校验参数，参数不能为空
        if (StringUtils.isBlank(searchParam)) {
            LOGGER.info(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; params not be null&quot;);
            resultCode.setMsg(Messages.INPUT_ERROR_MSG);
            resultCode.setCode(Messages.INPUT_ERROR_CODE);
            return resultCode;
        }

        String matchStr = &quot;blog_desc=&quot; + searchParam;
        List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; result = ElasticsearchUtils.searchListData(BillboardContants.ES_CONTENT_INDEX,BillboardContants.ES_CONTENT_TYPE,BillboardContants.ES_CONTENT_FIELD,true,matchStr);

        matchStr = &quot;author=&quot; + searchParam;
        result.addAll(ElasticsearchUtils.searchListData(BillboardContants.ES_CONTENT_INDEX,BillboardContants.ES_CONTENT_TYPE,BillboardContants.ES_CONTENT_FIELD,true,matchStr));

        matchStr = &quot;title=&quot; + searchParam;
        result.addAll(ElasticsearchUtils.searchListData(BillboardContants.ES_CONTENT_INDEX,BillboardContants.ES_CONTENT_TYPE,BillboardContants.ES_CONTENT_FIELD,true,matchStr));

        matchStr = &quot;content=&quot; + searchParam;
        result.addAll(ElasticsearchUtils.searchListData(BillboardContants.ES_CONTENT_INDEX,BillboardContants.ES_CONTENT_TYPE,BillboardContants.ES_CONTENT_FIELD,true,matchStr));

        List&amp;lt;ContentsWithBLOBs&amp;gt; data = JSON.parseArray(JSON.toJSONString(result),ContentsWithBLOBs.class);
        LOGGER.info(&quot;es return data : {}&quot;,JSON.toJSONString(result));
        resultCode.setData(data);
        return resultCode;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;楼主用到的es的工具类代码实现，就是使用es的java客户端对es进行检索。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    /**
     * 使用分词查询
     *
     * @param index       索引名称
     * @param type        类型名称,可传入多个type逗号分隔
     * @param fields      需要显示的字段，逗号分隔（缺省为全部字段）
     * @param matchPhrase true 使用，短语精准匹配
     * @param matchStr    过滤条件（xxx=111,aaa=222）
     * @return
     */
    public static List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; searchListData(String index, String type, String fields, boolean matchPhrase, String matchStr) {
        return searchListData(index, type, 0, 0, null, fields, null, matchPhrase, null, matchStr);
    }
    
    /**
     * 使用分词查询
     *
     * @param index          索引名称
     * @param type           类型名称,可传入多个type逗号分隔
     * @param startTime      开始时间
     * @param endTime        结束时间
     * @param size           文档大小限制
     * @param fields         需要显示的字段，逗号分隔（缺省为全部字段）
     * @param sortField      排序字段
     * @param matchPhrase    true 使用，短语精准匹配
     * @param highlightField 高亮字段
     * @param matchStr       过滤条件（xxx=111,aaa=222）
     * @return
     */
    public static List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; searchListData(String index, String type, long startTime, long endTime, Integer size, String fields, String sortField, boolean matchPhrase, String highlightField, String matchStr) {

        SearchRequestBuilder searchRequestBuilder = client.prepareSearch(index);
        if (StringUtils.isNotEmpty(type)) {
            searchRequestBuilder.setTypes(type.split(&quot;,&quot;));
        }
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();

        if (startTime &amp;gt; 0 &amp;amp;&amp;amp; endTime &amp;gt; 0) {
            boolQuery.must(QueryBuilders.rangeQuery(&quot;processTime&quot;)
                    .format(&quot;epoch_millis&quot;)
                    .from(startTime)
                    .to(endTime)
                    .includeLower(true)
                    .includeUpper(true));
        }

        //搜索的的字段
        if (StringUtils.isNotEmpty(matchStr)) {
            for (String s : matchStr.split(&quot;,&quot;)) {
                String[] ss = s.split(&quot;=&quot;);
                if (ss.length &amp;gt; 1) {
                    if (matchPhrase == Boolean.TRUE) {
                        boolQuery.must(QueryBuilders.matchPhraseQuery(s.split(&quot;=&quot;)[0], s.split(&quot;=&quot;)[1]));
                    } else {
                        boolQuery.must(QueryBuilders.matchQuery(s.split(&quot;=&quot;)[0], s.split(&quot;=&quot;)[1]));
                    }
                }

            }
        }

        // 高亮（xxx=111,aaa=222）
        if (StringUtils.isNotEmpty(highlightField)) {
            HighlightBuilder highlightBuilder = new HighlightBuilder();

            //highlightBuilder.preTags(&quot;&amp;lt;span style='color:red' &amp;gt;&quot;);//设置前缀
            //highlightBuilder.postTags(&quot;&amp;lt;/span&amp;gt;&quot;);//设置后缀

            // 设置高亮字段
            highlightBuilder.field(highlightField);
            searchRequestBuilder.highlighter(highlightBuilder);
        }


        searchRequestBuilder.setQuery(boolQuery);

        if (StringUtils.isNotEmpty(fields)) {
            searchRequestBuilder.setFetchSource(fields.split(&quot;,&quot;), null);
        }
        searchRequestBuilder.setFetchSource(true);

        if (StringUtils.isNotEmpty(sortField)) {
            searchRequestBuilder.addSort(sortField, SortOrder.DESC);
        }

        if (size != null &amp;amp;&amp;amp; size &amp;gt; 0) {
            searchRequestBuilder.setSize(size);
        }

        //打印的内容 可以在 Elasticsearch head 和 Kibana  上执行查询
        LOGGER.info(&quot;\n{}&quot;, searchRequestBuilder);

        SearchResponse searchResponse = searchRequestBuilder.execute().actionGet();

        long totalHits = searchResponse.getHits().totalHits;
        long length = searchResponse.getHits().getHits().length;

        LOGGER.info(&quot;共查询到[{}]条数据,处理数据条数[{}]&quot;, totalHits, length);

        if (searchResponse.status().getStatus() == 200) {
            // 解析对象
            return setSearchResponse(searchResponse, highlightField);
        }

        return null;

    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，楼主使用postman测试web服务，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.hchstudio.cn/postman_es.png&quot; alt=&quot;postman图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;过程中遇到的坑&quot;&gt;过程中遇到的坑&lt;/h2&gt;
&lt;h3 id=&quot;ik分词器的设置&quot;&gt;IK分词器的设置&lt;/h3&gt;
&lt;p&gt;这里需要注意的是，Elasticsearch的版本一定要与ik分词器的版本对应，不对应的话 Elasticsearch 会报错的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.3.0/elasticsearch-analysis-ik-6.3.0.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，重新启动 Elastic，就会自动加载这个新安装的插件。&lt;/p&gt;
&lt;p&gt;然后，新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，下面的命令只针对本文。基本上，凡是需要搜索的中文字段，都要单独设置一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ curl -X PUT 'localhost:9200/contentindex'  -H 'Content-Type: application/json' -d '
{
  &quot;mappings&quot;: {
    &quot;content&quot;: {
      &quot;properties&quot;: {
        &quot;content&quot;: {
          &quot;type&quot;: &quot;text&quot;,
          &quot;analyzer&quot;: &quot;ik_max_word&quot;,
          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;
        },
        &quot;title&quot;: {
          &quot;type&quot;: &quot;text&quot;,
          &quot;analyzer&quot;: &quot;ik_max_word&quot;,
          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;
        },
        &quot;blog_desc&quot;: {
          &quot;type&quot;: &quot;text&quot;,
          &quot;analyzer&quot;: &quot;ik_max_word&quot;,
          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;
        },
        &quot;author&quot;: {
          &quot;type&quot;: &quot;text&quot;,
          &quot;analyzer&quot;: &quot;ik_max_word&quot;,
          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;
        }
      }
    }
  }
}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，首先新建一个名称为contentindex的 Index，里面有一个名称为content的 Type。content有好多个字段，这里只为其中四个字段指定分词，&lt;strong&gt;content&lt;/strong&gt;， &lt;strong&gt;title&lt;/strong&gt;， &lt;strong&gt;blog_desc&lt;/strong&gt;，&lt;strong&gt;author&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;这四个字段都是中文，而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。&lt;/p&gt;
&lt;h3 id=&quot;mysql-binlog的设置&quot;&gt;MySQL binlog的设置&lt;/h3&gt;
&lt;p&gt;因为楼主运行 go-mysql-elasticsearch 的时候使用的MySQL的客户端跟要导出数据的MySQL server端的版本不一致导致报错，最终在 go-mysql-elasticsearch 原作者的帮助下解决，所以一定要使用同版本的MySQL server 与client，因为不同版本的MySQL特性不一样，也就导致了 go-mysql-elasticsearch 导出数据有略微的不同。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;整个过程相对来说比较简单，当然楼主通过这个功能的实现，也对es有了一个相对的认识，学习了一项新的技能，可能有的小伙伴对楼主的整个工程的代码比较感兴趣，暂时先不能透露，等楼主完善好了一并贡献出来。&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
</description>
<pubDate>Mon, 23 Jul 2018 15:20:00 +0000</pubDate>
<dc:creator>haifeiWu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haifeiWu/p/9357547.html</dc:identifier>
</item>
<item>
<title>一小部分机器学习算法小结: 优化算法、逻辑回归、支持向量机、决策树、集成算法、Word2Vec等 - 冬色</title>
<link>http://www.cnblogs.com/mengnan/p/9357500.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengnan/p/9357500.html</guid>
<description>&lt;h3 id=&quot;优化算法&quot;&gt;优化算法&lt;/h3&gt;
&lt;p&gt;先导知识：泰勒公式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(x)=\sum_{n=0}^{\infty}\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n \]&lt;/span&gt;&lt;br/&gt;一阶泰勒展开：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(x)\approx f(x_0)+f'(x_0)(x-x_0) \]&lt;/span&gt;&lt;br/&gt;二阶泰勒展开：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(x)\approx f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2}(x-x_0)^2 \]&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;梯度下降法&quot;&gt;梯度下降法&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} &amp;amp;f(x)=f(x^k)+g_k^T(x-x^k)\\ &amp;amp;其中，g_k=g(x^{(k)})=\nabla f(x^{(k)})=f'(x),\lambda_k 是步长，由一维搜索确定。\\ &amp;amp;即\lambda_k使得f(x^{(k)}+\lambda_kp_k)=\mathop{min}_{\lambda \geq 0}f(x^{(k)}+\lambda p_k),p_k为搜索方向，取负梯度方向p_k=-\nabla f(x^{(k)})\\ &amp;amp;当||g_k||&amp;lt;\epsilon或者||f(x^{k+1})-f(x^k)||&amp;lt;\epsilon或者||x^{k+1}-x^k||&amp;lt;\epsilon时，停止迭代 \end{align*} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意：为何&lt;em&gt;负梯度方向&lt;/em&gt;时是使函数值下降最快的方向，在迭代的每一步以&lt;em&gt;负梯度方向&lt;/em&gt;更新x的值：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} &amp;amp;f(x+\Delta x)=f(x)+\sum_{k=1}^{n}\frac{\partial f}{\partial x_{k}}*\Delta x+O(||x||^n)\\ &amp;amp;要使f(x+\Delta x)-f(x)&amp;lt;0,即损失函数减小，而O(||x||^n)可忽略，则\sum_{k=1}^n\frac{\partial f}{\partial x_{k}}*\Delta x&amp;lt;0\\ &amp;amp;可以令\Delta x=-\alpha \sum_{k=1}^{n}\frac{\partial f}{\partial x_k},而\alpha为步长，\alpha&amp;gt;0恒成立\\ &amp;amp;这样就可以满足\sum_{k=1}^n\frac{\partial f}{\partial x_{k}}*\Delta x&amp;lt;0，因此x一直要向负梯度方向更新 \end{align*} \]&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;拟牛顿法&quot;&gt;拟牛顿法&lt;/h4&gt;
&lt;p&gt;二阶泰勒：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(x)=f(x^{k})+g_k^T(x-x^k)+\frac{1}{2}(x-x_k)^TH(x^k)(x-x_k)\\ 其中，g_k(x)=\nabla f(x^{(k)})是f(x)的梯度向量在点x^{(k)}的值。\\H(x)=\left[\frac{\partial ^2 f}{\partial x_i\partial x_j}\right]_{n*n}。后者称为海赛矩阵(Heses\ matrix) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;函数有极小值的必要条件是在极值点处一阶导数为0，即梯度向量为0.&lt;/p&gt;
&lt;p&gt;可知：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \nabla f(x)=g_k+H_k(x-x^k) \]&lt;/span&gt;&lt;br/&gt;令&lt;span class=&quot;math inline&quot;&gt;\(\nabla f(x)=0\)&lt;/span&gt;，则&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ g_k^T+H_k(x-x_k)=0\\ H_k(x-x^k)=-g_k\\ x^{k+1}=x^k-H_k^{-1}g_k \]&lt;/span&gt;&lt;br/&gt;令&lt;span class=&quot;math inline&quot;&gt;\(p_k=-H^{-1}_kg_k\)&lt;/span&gt;，即&lt;span class=&quot;math inline&quot;&gt;\(H_kP_k=-g_k\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;整理下上述思路：&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;展开为二阶泰勒-&amp;gt;函数极小值必要条件-&amp;gt;&lt;span class=&quot;math inline&quot;&gt;\(\nabla f(x)=0\)&lt;/span&gt;-&amp;gt;求得搜索方向&lt;span class=&quot;math inline&quot;&gt;\(p_k=-H^{-1}_kg_k\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;求得了搜索方向，就可以类似于梯度下降法迭代&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的值。也就是&lt;span class=&quot;math inline&quot;&gt;\(x^{(k+1)}=x^k+p_k\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;注意到搜索方向&lt;span class=&quot;math inline&quot;&gt;\(p_k=-H^{-1}_kg_k\)&lt;/span&gt;,求解公式中存在矩阵的逆，矩阵的逆一般难求，需要考虑用一个&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;阶矩阵&lt;span class=&quot;math inline&quot;&gt;\(G_k=G(x^{(k)})\)&lt;/span&gt;近似代替&lt;span class=&quot;math inline&quot;&gt;\(H_k^{(-1)}=H^{-1}(x^{(k)})\)&lt;/span&gt;。这就是所谓的“拟”牛顿法&lt;/p&gt;
&lt;p&gt;首先看要近似的海塞矩阵&lt;span class=&quot;math inline&quot;&gt;\(H_k\)&lt;/span&gt;要满足的条件。对&lt;span class=&quot;math inline&quot;&gt;\(\nabla f(x)=g_k+H_k(x-x^k)\)&lt;/span&gt;取&lt;span class=&quot;math inline&quot;&gt;\(x=x^{(k+1)}\)&lt;/span&gt;，即得：&lt;span class=&quot;math inline&quot;&gt;\(g_{k+1}=g_k+H_k(x^{(k+1)}-x^k)\)&lt;/span&gt;，记&lt;span class=&quot;math inline&quot;&gt;\(y_k=g_{k+1}-g_k,\delta_k=x^{(k+1)}-x^k\)&lt;/span&gt;，则：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ y_k=H_k\delta_k \]&lt;/span&gt;&lt;br/&gt;这就是海塞矩阵要满足的条件。也就是&lt;span class=&quot;math inline&quot;&gt;\(H^{-1}_ky_k=\delta_k\)&lt;/span&gt;。根据这个条件，近似的算法有两种，也就是&quot;DFP&quot;算法和&quot;BFGS&quot;算法，以及推广的&quot;Broyden&quot;算法。&lt;strong&gt;参见《统计学习方法》-李航-p222~224&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;拉格朗日对偶性&quot;&gt;拉格朗日对偶性&lt;/h4&gt;
&lt;p&gt;约束最优化问题中，由于原始问题难求等原因，需要利用&lt;em&gt;拉格朗日对偶性&lt;/em&gt;将原始问题转化为对偶问题，通过求解对偶问题而求得原始问题的解。&lt;/p&gt;
&lt;p&gt;约束最优化问题：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathop{min}_{x\in R^n}f(x)\\ s.t\quad c_j(x)\leq 0,\ i=1,2,...,k\\ h_j(x)=0,\ j=1,2,...,l \]&lt;/span&gt;&lt;br/&gt;其转化而得的对偶问题：广义拉格朗日函数极大极小问题&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathop{max}_{\alpha,\beta}\theta_D(\alpha,\beta)=\mathop{max}_{\alpha,\beta}\mathop{min}_xL(x,\alpha,\beta)\\ st.\quad \alpha_i\geq0,\ i=1,2,...,k \]&lt;/span&gt;&lt;br/&gt;KTT条件：对偶问题和原问题能够相互转化的充要条件&lt;/p&gt;
&lt;p&gt;假设函数&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(c_i(x)\)&lt;/span&gt;是凸函数，&lt;span class=&quot;math inline&quot;&gt;\(h_j(x)\)&lt;/span&gt;是仿射函数，并且不等式约束&lt;span class=&quot;math inline&quot;&gt;\(c_i(x)\)&lt;/span&gt;是严格可行的，则&lt;span class=&quot;math inline&quot;&gt;\(x^*\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\alpha ^*,\beta ^*\)&lt;/span&gt;分别是原始问题和对偶问题的解的充要条件是&lt;span class=&quot;math inline&quot;&gt;\(x^ *\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(\alpha^*\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(\beta ^*\)&lt;/span&gt;满足KTT条件：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \nabla _x L(x^*,\alpha ^*,\beta ^*)=0\\ \alpha^*_ic_i(x^*)=0,\ i=1,2,...,k\\ c_i(x^*)\leq 0,\ i=1,2,...,k\\ \alpha ^*_i\geq0,\ i=1,2,...,k\\ h_j(x^*)=0,\ j=1,2,...,l \]&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;李航-《统计学习方法》-p218~p228&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;最大似然函数和最小损失函数&quot;&gt;最大似然函数和最小损失函数&lt;/h3&gt;
&lt;p&gt;当然你也可以叫它”最大似然函数和最小二乘估计“，两者殊途同归，都是意在&lt;em&gt;拟合数据&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;最小二乘估计&quot;&gt;最小二乘估计&lt;/h4&gt;
&lt;p&gt;模型最合理的&lt;em&gt;参数估计量&lt;/em&gt;应该使得模型最好的拟合样本数据，要求估计值和观测值之差的平方最小。&lt;/p&gt;
&lt;p&gt;定义：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Q=\sum_{i=1}^n(y-y')^2 \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt;为误差，&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;为观测值，&lt;span class=&quot;math inline&quot;&gt;\(y'\)&lt;/span&gt;为估计值，&lt;span class=&quot;math inline&quot;&gt;\(y'=\beta_0+\beta_1x\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;矩阵表示：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ min||A\beta-Y||_2 \]&lt;/span&gt;&lt;br/&gt;最优解为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \beta=(A^TA)^{-1}A^TY \]&lt;/span&gt;&lt;br/&gt;其中，估计值&lt;span class=&quot;math inline&quot;&gt;\(Y'=||A\beta||\)&lt;/span&gt;。关于求解方法参见：&lt;a href=&quot;https://blog.csdn.net/monsterhoho/article/details/46753673&quot;&gt;最小二乘法解的矩阵形式推导&lt;/a&gt;.若A非满秩，常常采用求&lt;em&gt;伪逆&lt;/em&gt;的方法或者岭回归等方法解决。求伪逆，参见&lt;strong&gt;周志华-《机器学习》-p402~p403（A.3奇异值分解）&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;最大似然函数&quot;&gt;最大似然函数&lt;/h4&gt;
&lt;p&gt;模型最合理的&lt;em&gt;参数估计量&lt;/em&gt;应该使得观测样本出现的概率最大。&lt;/p&gt;
&lt;p&gt;定义：联合概率密度函数&lt;span class=&quot;math inline&quot;&gt;\(p(D|\theta)\)&lt;/span&gt;称为相对于&lt;span class=&quot;math inline&quot;&gt;\({x_1,x_2,...,x_N}\)&lt;/span&gt;关于&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;的似然函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ l(\theta)=p(D|\theta)=p(x_1,x_2,...,x_N|\theta)=\prod_{i=1}^{N}p(x_i|\theta) \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;为待估计参数。&lt;/p&gt;
&lt;p&gt;与最小二乘法不同不需要确定概率分布函数不同，最大似然函数需要”已知“这个概率分布函数。事实上，若假设满足正态分布函数，&lt;strong&gt;最大似然函数和最小二乘估计是等价的&lt;/strong&gt;。参见：&lt;a href=&quot;https://blog.csdn.net/xidianzhimeng/article/details/20847289?locationNum=10&amp;amp;fps=1&quot;&gt;最大似然估计和最小二乘估计的区别与联系&lt;/a&gt;。最小二乘法以估计值和观测值的差平方和为损失函数，最大似然函数则是以最大化似然概率函数为目标函数。&lt;/p&gt;
&lt;h4 id=&quot;交叉熵&quot;&gt;交叉熵&lt;/h4&gt;
&lt;p&gt;交叉熵衡量的是两个分布&lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt;之间的相似性。&lt;/p&gt;
&lt;p&gt;定义：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ H(p,q)=-\sum_{i=1}^np(x_i)log(q(x_i)) \]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(H(p,q)​\)&lt;/span&gt;即为交叉熵。事实上，交叉熵是由KL散度（亦称相对熵）而来，相对熵：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ KL(P||Q)=\int _{-\infty}^{\infty}p(x)log\frac{p(x)}{q(x)}dx \]&lt;/span&gt;&lt;br/&gt;展开便得：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ KL(P||Q)=\int_{-\infty}^{\infty}p(x)log\ p(x)dx-\int_{-\infty}^{\infty}p(x)log\ q(x)=-H(P)+H(P,Q) \]&lt;/span&gt;&lt;br/&gt;在机器学习中，常常需要评估观测值和估计值之间的差距，由于KL散度能够度量两个概率分布之间的差距，可以&lt;strong&gt;最小化&lt;/strong&gt;KL散度实现“学习”的目的，又由于&lt;span class=&quot;math inline&quot;&gt;\(H(P)\)&lt;/span&gt;为固定值，所以通常直接&lt;strong&gt;最小化&lt;/strong&gt;交叉熵&lt;span class=&quot;math inline&quot;&gt;\(H(P,Q)\)&lt;/span&gt;，参见&lt;strong&gt;周志华-《机器学习》-p414~p415(C.3KL散度)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在分类问题中，交叉熵的本质就是似然函数的最大化。参见：&lt;a href=&quot;https://blog.csdn.net/diligent_321/article/details/53115369&quot;&gt;最大似然损失和交叉熵损失函数的联系&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于为何&lt;em&gt;逻辑logistic回归&lt;/em&gt;采用交叉熵（似然函数）而非最小二乘作损失函数，可能有两个原因：1.交叉熵常常用于分类，而最小二乘常常用于回归；2.计算便利&lt;/p&gt;
&lt;h3 id=&quot;逻辑回归&quot;&gt;逻辑回归&lt;/h3&gt;
&lt;p&gt;先导知识：&lt;/p&gt;
&lt;h4 id=&quot;指数族分布&quot;&gt;指数族分布&lt;/h4&gt;
&lt;p&gt;若某概率满足&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ p(y;\eta)=b(y)exp(\eta^TT(y)-a(\eta)) \]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\eta\)&lt;/span&gt;是自然参数，&lt;span class=&quot;math inline&quot;&gt;\(T(y)\)&lt;/span&gt;是充分统计量，&lt;span class=&quot;math inline&quot;&gt;\(exp(-a(\eta))\)&lt;/span&gt;起到归一化作用。确定&lt;span class=&quot;math inline&quot;&gt;\(T,a,b\)&lt;/span&gt;，就可以确定参数为&lt;span class=&quot;math inline&quot;&gt;\(\eta\)&lt;/span&gt;的指数族分布。高斯分布、伯努利分布、多项分布、泊松分布等都是指数族分布的特定形式。&lt;/p&gt;
&lt;p&gt;伯努利分布：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} p(y;\phi)&amp;amp;=\phi^y(1-\phi)^{1-y}\\ &amp;amp;=exp(ylog\ \phi+(1-y)log(1-\phi))\\ &amp;amp;=epx(ylog\frac{\phi}{1-\phi}+log(1-\phi)) \end{align*} \]&lt;/span&gt;&lt;br/&gt;对照上述指数族分布定义，则：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \left \{ \begin{array}{lr} T(y)=y,\\ \eta=log\frac{\phi}{1-\phi},(\frac{\phi}{1-\phi}=e^{\eta}-&amp;gt;(1+e^y)\phi=e^y-&amp;gt;\phi=\frac{e^{\eta}}{1+e^{\eta}}=\frac{1}{1+e^{-\eta}})\\ a(\eta)=-log(1-\phi)\\ b(y)=1 \end{array} \right . \end{equation} \]&lt;/span&gt;&lt;br/&gt;常见的概率分布参见：&lt;strong&gt;周志华-《机器学习》-p409~p413(C概率分布)&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;逻辑回归-1&quot;&gt;逻辑回归&lt;/h4&gt;
&lt;p&gt;考虑二分类问题，&lt;span class=&quot;math inline&quot;&gt;\(y\in\{0,1\}\)&lt;/span&gt;,因为是二分类问题，可以很自然的想到选择&lt;span class=&quot;math inline&quot;&gt;\(p(y|x;\theta)\)&lt;/span&gt;~&lt;span class=&quot;math inline&quot;&gt;\(Bernouli (\phi)\)&lt;/span&gt;，即服从伯努利分布。那么，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ h_\theta=E(y|x;\theta)=\phi=\frac{1}{1+e^{-\eta}}=\frac{1}{1+e^{-\theta^Tx}} \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(h_\theta(x)=E(y|x;\theta)=\phi\)&lt;/span&gt;是伯努利分布的性质（其数学期望等于每次实验成功的概率&lt;span class=&quot;math inline&quot;&gt;\(\phi\)&lt;/span&gt;），&lt;span class=&quot;math inline&quot;&gt;\(\phi=\frac{1}{1+e^{-\eta}}\)&lt;/span&gt;是伯努利分布为指数族分布时的结论（见&lt;span class=&quot;math inline&quot;&gt;\(\eta=log\frac{\phi}{1-\phi}\)&lt;/span&gt;后面推导过程）&lt;/p&gt;
&lt;p&gt;定义：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ h_\theta=g(\theta^Tx)=\frac{1}{1+e^{-\theta^Tx}} \]&lt;/span&gt;&lt;br/&gt;目标函数推导：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \left \{ \begin{array}{lr} p(Y=1|x;\theta)=h_\theta(x)\\ p(Y=0|x;\theta)=1-h_\theta(x) \end{array} \right . \end{equation} \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(h_\theta(x)\)&lt;/span&gt;表示类别为1的概率。&lt;/p&gt;
&lt;p&gt;结合起来&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ p(Y=y|x;\theta)=(h_{\theta})^y(1-h_{\theta})^{1-y} \]&lt;/span&gt;&lt;br/&gt;取&lt;em&gt;对数似然函数&lt;/em&gt;:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} l(\theta)&amp;amp;=\prod_{i=1}^m p(Y=y_i|x_i;\theta)\\ &amp;amp;=\prod_{i=1}^m(h_\theta(x_i))^{y_i}(1-h_\theta(x_i))^{1-y_i} \end{align*}\\ L(\theta)=\sum_{i=1}^{m}y_ilog\ h_{\theta}(x_i)+(1-y_i)log\ (1-h_\theta(x_i)) \]&lt;/span&gt;&lt;br/&gt;优化损失函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ J(\theta)=\frac{-1}{m}L(\theta) \]&lt;/span&gt;&lt;br/&gt;使用梯度下降法等优化算法优化即可。&lt;/p&gt;
&lt;p&gt;注意此处的损失函数和交叉熵定义：&lt;span class=&quot;math inline&quot;&gt;\(H(p,q)=-\sum_{i=1}^np(x_i)log(q(x_i))\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;列出其它常见的损失函数&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;0-1损失函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(y,f(x))= \begin{equation} \left \{ \begin{array}{lr} 1\quad y\neq f(x)\\ 0\quad y=f(x) \end{array} \right . \end{equation} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;平方损失函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(y,f(x))=(y-f(x))^2 \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;绝对值损失函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(y,f(x))=|y-f(x)| \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对数损失函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(y,p(y|x))=-log\ p(y|x) \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;支持向量机&quot;&gt;支持向量机&lt;/h3&gt;
&lt;p&gt;先导知识：&lt;/p&gt;
&lt;p&gt;点到直线距离公式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ d=|\frac{Ax_0+By_0+C}{\sqrt{A^2+B^2}}|=|\frac{wx_i+b}{||w||}| \]&lt;/span&gt;&lt;br/&gt;假设点X被正确分类。当X属于正类时，&lt;span class=&quot;math inline&quot;&gt;\(wx+b&amp;gt;0\)&lt;/span&gt;,此时点X在直线上方。当X属于负类时，&lt;span class=&quot;math inline&quot;&gt;\(wx+b&amp;lt;0\)&lt;/span&gt;，此时点X在直线下方。&lt;/p&gt;
&lt;p&gt;几何间隔最大化&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ max_{w,b}\ \gamma\\ s.t\quad \frac{y_i(wx_i+b)}{||w||}\geq \gamma,\ i=1,2,...,N \]&lt;/span&gt;&lt;br/&gt;这也即是，学习超平面参数&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;，使得当所有点到超平面的距离都大于某个数&lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt;：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{y_i(wx_i+b)}{||w||}\geq \gamma \]&lt;/span&gt;&lt;br/&gt;时，最大化这个数&lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt;。乘以&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt;的目的在于当&lt;span class=&quot;math inline&quot;&gt;\(y_i\in\{+1,-1\}\)&lt;/span&gt;时，无论&lt;span class=&quot;math inline&quot;&gt;\(wx_i+b\)&lt;/span&gt;得到的结果无论正负，只要分类结果正确，保持&lt;span class=&quot;math inline&quot;&gt;\(y_i(wx_i+b)\)&lt;/span&gt;为正。&lt;/p&gt;
&lt;p&gt;可以改写为，令函数间隔&lt;span class=&quot;math inline&quot;&gt;\(\hat{\gamma}=y_i(wx_i+b)\)&lt;/span&gt;，则&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ max_{w,b}\frac{\hat{\gamma}}{||w||}\\ s.t\quad y_i(wx_i+b)\geq\hat{\gamma},\ i=1,2,...,N \]&lt;/span&gt;&lt;br/&gt;由于有分母&lt;span class=&quot;math inline&quot;&gt;\(||w||\)&lt;/span&gt;有规范化作用，函数间隔&lt;span class=&quot;math inline&quot;&gt;\(\hat{\gamma}\)&lt;/span&gt;的取值并不影响最优化问题的解，令&lt;span class=&quot;math inline&quot;&gt;\(\hat{\gamma}=1\)&lt;/span&gt;翻转分子分母，变最大化问题为最小化问题：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ min_{w,b}\frac{1}{2}||w||^2\\ s.t\quad y_i(wx_i+b)-1\geq 0,\ i=1,2,...,N \]&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;线性可分支持向量机&quot;&gt;线性可分支持向量机&lt;/h4&gt;
&lt;p&gt;硬间隔最大化&lt;/p&gt;
&lt;p&gt;定义：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ min_{w,b}\frac{1}{2}||w||^2\\ s.t\quad y_i(wx_i+b)-1\geq 0 \]&lt;/span&gt;&lt;br/&gt;求得最优解&lt;span class=&quot;math inline&quot;&gt;\(w^*,b^*\)&lt;/span&gt;。代入之后就可以求得分离超平面：&lt;span class=&quot;math inline&quot;&gt;\(w^*x+b^*=0\)&lt;/span&gt;；分类决策函数：&lt;span class=&quot;math inline&quot;&gt;\(f(x)=sign(w^*x+b^*)\)&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;线性支持向量机&quot;&gt;线性支持向量机&lt;/h4&gt;
&lt;p&gt;软间隔最大化：正则化，引入松弛变量&lt;span class=&quot;math inline&quot;&gt;\(\xi_i\geq0\)&lt;/span&gt;，约束条件变为&lt;span class=&quot;math inline&quot;&gt;\(y_i(wx_i+b)\geq 1-\xi_i\)&lt;/span&gt;；并且对每个松弛变量&lt;span class=&quot;math inline&quot;&gt;\(\xi_i\)&lt;/span&gt;，支付一个代价&lt;span class=&quot;math inline&quot;&gt;\(\xi_i\)&lt;/span&gt;，目标函数变为&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}||w||^2+C\sum_{i=0}^{N}\xi_i\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt;为正则化参数。这样使得&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}||w||^2\)&lt;/span&gt;尽量小，即间隔最大而且误分类点个数尽可能少。&lt;/p&gt;
&lt;p&gt;定义：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ min_{w,b,\xi}\frac{1}{2}||w||^2+C\sum_{i=1}^N\xi_i\\ s.t\quad y_i(wx_i+b)\geq 1-\xi_i\ i=1,2,...,N\\ \xi_i\geq0,\ i=1,2,...,N \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\xi_i\geq 0\)&lt;/span&gt;原因：1)&lt;span class=&quot;math inline&quot;&gt;\(\xi_i\geq 0\)&lt;/span&gt;意为允许误分点，&lt;span class=&quot;math inline&quot;&gt;\(\xi&amp;gt;0\)&lt;/span&gt;意为允许误分点，&lt;span class=&quot;math inline&quot;&gt;\(\xi&amp;lt;0\)&lt;/span&gt;在分隔界面后侧无意义。2)目标是&lt;span class=&quot;math inline&quot;&gt;\(\mathop{&amp;lt;span class=&quot;md-search-hit md-search-select&quot;&amp;gt;min&amp;lt;/span&amp;gt;}_{w,b,\xi}\)&lt;/span&gt;，若允许&lt;span class=&quot;math inline&quot;&gt;\(\xi&amp;lt;0\)&lt;/span&gt;则会使目标式使&lt;span class=&quot;math inline&quot;&gt;\(\xi\to-\infty\)&lt;/span&gt;，错误&lt;/p&gt;
&lt;p&gt;原始最优化算法的拉格朗日函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(W,b,\xi,\alpha,\mu)=\frac{1}{2}||w||^2+C\sum_{i=1}^N\xi_i-\sum_{i=1}^{N}\alpha_i(y_i(wx_i+b)-1+\xi_i)-\sum_{i=1}^N\mu_i\xi_i \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(W,b\)&lt;/span&gt;为超平面的参数，&lt;span class=&quot;math inline&quot;&gt;\(\alpha,\xi\)&lt;/span&gt;为拉格朗日乘子(&lt;span class=&quot;math inline&quot;&gt;\(\alpha_i&amp;gt;0,\xi&amp;gt;0\)&lt;/span&gt;，两个条件，两个拉格朗日乘子)&lt;/p&gt;
&lt;p&gt;对偶问题是拉格朗日的极大极小问题&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ max_\alpha min_{w,b} L(w,b,\alpha) \]&lt;/span&gt;&lt;br/&gt;首先求&lt;span class=&quot;math inline&quot;&gt;\(L(w,b,\xi,\alpha,\mu)\)&lt;/span&gt;对&lt;span class=&quot;math inline&quot;&gt;\(w,b,\xi\)&lt;/span&gt;的极小。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \left \{ \begin{array}{lr} \frac{\partial}{\partial w}L(w,b,\xi,\alpha,\mu)=w-\sum_{i=1}^N\alpha_iy_ix_i=0\\ \frac{\partial}{\partial b}L(w,b,\xi,\alpha,\mu)=-\sum_{i=1}^N\alpha_i y_i=0\\ \frac{\partial}{\partial \xi}L(w,b,\xi,\alpha,\mu)=C-\alpha_i-\mu_i=0 \end{array} \right . \end{equation} \]&lt;/span&gt;&lt;br/&gt;求得：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \left \{ \begin{array}{lr} w=\sum_{i=1}^N\alpha_i y_i x_i\\ \sum_{i=1}^{N}\alpha_i y_i=0\\ C-\alpha_i-\mu_i=0 \end{array} \right . \end{equation} \]&lt;/span&gt;&lt;br/&gt;代入&lt;span class=&quot;math inline&quot;&gt;\(L(w,b,\xi,\alpha,\mu)\)&lt;/span&gt;得&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} L(w,b,\xi,\alpha,\mu)&amp;amp;=\frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)+C\sum_{i=1}^{N}\xi_i-\\ &amp;amp;\sum_{i=1}^{N}(\alpha_iy_i(wx_i+b)-\alpha_i+\alpha_i\xi_i)-\sum_{i=1}^{N}\mu_i\xi_i(1)\\ &amp;amp;=\frac{1}{2}\sum_{i=1}^{N}\sum_{i=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)+(C-\alpha_i-\mu_i)\sum_{i=1}^{N}\xi_i-\sum_{i=1}^N\alpha_i(2)\\ &amp;amp;=\frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)-\sum_{i=1}^N\alpha_i \end{align*} \]&lt;/span&gt;&lt;br/&gt;在(1)中，由于&lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^N\alpha_iy_i=0\)&lt;/span&gt;，则&lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^N(\alpha_iy_i(wx_i+b))=0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在(2)中，由于&lt;span class=&quot;math inline&quot;&gt;\(C-\alpha_i-\mu_i=0\)&lt;/span&gt;，则&lt;span class=&quot;math inline&quot;&gt;\((C-\alpha_i-\mu_i)\sum_{i=1}^{N}\xi_i=0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;得对偶问题：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} max_{\alpha}-\frac{1}{2}\sum_{i=1}^{N}\sum^{N}_{j=1}\alpha_i\alpha_jy_iy_j(x_ix_j)+\sum_{i=1}^N\alpha_i\\ s.t\quad \sum_{i=1}^{N}\alpha_iy_i=0\quad\\ C-\alpha_i-\mu_i=0\quad(1)\\ \alpha_i\geq0\quad(2)\\ \mu_i\geq0\quad(3)\\ (i=1,2,...,N) \end{align*} \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\((1),(2),(3)\)&lt;/span&gt;可得：&lt;span class=&quot;math inline&quot;&gt;\(0\leq\alpha_i\leq C\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也即是：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} max_{\alpha}-\frac{1}{2}\sum_{i=1}^{N}\sum^{N}_{j=1}\alpha_i\alpha_jy_iy_j(x_ix_j)+\sum_{i=1}^N\alpha_i\\ s.t\quad \sum_{i=1}^{N}\alpha_iy_i=0\\ 0\leq\alpha_i\leq C\\ (i=1,2,...,N) \end{align*} \]&lt;/span&gt;&lt;br/&gt;这就是&lt;em&gt;线性支持向量机&lt;/em&gt;的对偶问题。&lt;/p&gt;
&lt;p&gt;有对偶问题&lt;em&gt;据说&lt;/em&gt;易求得最优解&lt;span class=&quot;math inline&quot;&gt;\(\alpha^*=(\alpha_1^*,\alpha_2^*,...,\alpha_N^*)\)&lt;/span&gt;，从而求得原始问题中&lt;span class=&quot;math inline&quot;&gt;\(w^*=\sum_{i=1}^N\alpha_i^*y_ix_i\)&lt;/span&gt;，选择&lt;span class=&quot;math inline&quot;&gt;\(\alpha^*\)&lt;/span&gt;中一个适合条件&lt;span class=&quot;math inline&quot;&gt;\(0&amp;lt;\alpha_j^*&amp;lt;C\)&lt;/span&gt;分量&lt;span class=&quot;math inline&quot;&gt;\(\alpha_j^*\)&lt;/span&gt;，可得原始问题中的&lt;span class=&quot;math inline&quot;&gt;\(b^*=y_j-\sum_{i=1}^Ny_i\alpha_i^*(x_ix_j)\)&lt;/span&gt;。然后代入即得分离超平面：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ w^*x+b^*=0 \]&lt;/span&gt;&lt;br/&gt;分类决策函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(x)=sign(w^*x+b^*) \]&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;非线性支持向量机和核函数&quot;&gt;非线性支持向量机和核函数&lt;/h4&gt;
&lt;p&gt;举例而言，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ w_1(x^{(1)})^2+w_2(x^{(2)})^2+b=0 \]&lt;/span&gt;&lt;br/&gt;此为非线性问题，使用&lt;span class=&quot;math inline&quot;&gt;\(z=\phi(x)=(x^{(1)},x^{(2)})\)&lt;/span&gt;&lt;em&gt;映射&lt;/em&gt;可得&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ w_1z^{(1)}+w_2z^{(2)}+b=0 \]&lt;/span&gt;&lt;br/&gt;转化为了线性问题。&lt;/p&gt;
&lt;p&gt;从输入空间x到特征空间的映射&lt;span class=&quot;math inline&quot;&gt;\(\phi(x)​\)&lt;/span&gt;: &lt;span class=&quot;math inline&quot;&gt;\(x​\)&lt;/span&gt;-&amp;gt;&lt;span class=&quot;math inline&quot;&gt;\(H​\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;线性支持向量机只涉及输入实例与实例之间的内积，且映射函数&lt;span class=&quot;math inline&quot;&gt;\(\phi(x)\)&lt;/span&gt;不易求&lt;/p&gt;
&lt;p&gt;核函数&lt;span class=&quot;math inline&quot;&gt;\(K(x,z)=\phi(x)·\phi(z),\quad x,z\in X\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将输入空间的内积&lt;span class=&quot;math inline&quot;&gt;\(x_i·x_j\)&lt;/span&gt;转化为特征空间的内积&lt;span class=&quot;math inline&quot;&gt;\(\phi(x_i)·\phi(x_j)=K(x,z)\)&lt;/span&gt;，此时当映射函数是非线性函数时，就可以在线性SVM中学习非线性模型了。&lt;/p&gt;
&lt;h4 id=&quot;函数kxz为核函数的条件&quot;&gt;函数&lt;span class=&quot;math inline&quot;&gt;\(K(x,z)\)&lt;/span&gt;为核函数的条件&lt;/h4&gt;
&lt;p&gt;通常的核函数就是正定核函数。&lt;/p&gt;
&lt;p&gt;正定核的充要条件：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(K(x,z)\)&lt;/span&gt;是定义在&lt;span class=&quot;math inline&quot;&gt;\(X*X-&amp;gt;R\)&lt;/span&gt;上的对称函数，则&lt;span class=&quot;math inline&quot;&gt;\(K(x,z)\)&lt;/span&gt;为正定核函数的充要条件：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(K(x,z)\)&lt;/span&gt;对应的Gram矩阵：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ K=[k(x_i,x_j)]_{m*m}= \left[ \begin{matrix} (x_1,x_1)&amp;amp;(x_1,x_2)&amp;amp;(x_1,x_3)&amp;amp;\cdots&amp;amp;(x_1,x_m)\\ \vdots\\ (x_m,x_1)&amp;amp;(x_m,x_2)&amp;amp;(x_m,x_3)&amp;amp;\cdots&amp;amp;(x_m,x_m) \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;此矩阵&lt;strong&gt;半正定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常用核函数&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;多项式核函数：&lt;span class=&quot;math inline&quot;&gt;\(K(x,z)=(x·z+1)^p\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对应的分类决策函数为：&lt;span class=&quot;math inline&quot;&gt;\(f(x)=sign(\sum_{i=1}^{N_c}a_i^*y_i(x_i·x+1)^p+b^*)\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;高斯核函数：&lt;span class=&quot;math inline&quot;&gt;\(K(x,z)=exp(-\frac{||x-z||^2}{2\sigma^2})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对应的分类决策函数：&lt;span class=&quot;math inline&quot;&gt;\(f(x)=sign(\sum_{i=1}^{N_c}a_i^*y_iexp(-\frac{||x-z||^2}{2\sigma^2})+b^*)\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此处参见&lt;strong&gt;李航-《统计学习方法》-p122~p123&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高效实现支持向量机“学习”的算法：SMO序列最小最优化算法&lt;/p&gt;
&lt;p&gt;SMO求解如下凸二次规划的对偶问题：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} &amp;amp;min_\alpha\ \frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_jK(x_i,x_j)-\sum_{i=1}^{N}\alpha_i\\ &amp;amp;s.t\quad \sum_{i=1}^{N}\alpha_iy_i=0\\ &amp;amp;0\leq \alpha_i\leq C,\ i=1,2,...,N \end{align*} \]&lt;/span&gt;&lt;br/&gt;变量是拉格朗日乘子&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;，一个变量&lt;span class=&quot;math inline&quot;&gt;\(\alpha_i\)&lt;/span&gt;对应于一个样本点&lt;span class=&quot;math inline&quot;&gt;\((x_i,x_j)\)&lt;/span&gt;。变量总量等于训练样本容量&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;启发式算法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若所有变量符合KTT条件，则该问题可由KTT求得（KTT条件是该最优化问题的充要条件）&lt;/li&gt;
&lt;li&gt;否则，选择2个变量（1个最不符合KTT，另1个自动确定）构造新的二次规划问题求解。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;李航-《统计学习方法》-p95&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;kmeans&quot;&gt;KMeans&lt;/h3&gt;
&lt;p&gt;一种&lt;em&gt;聚类&lt;/em&gt;算法&lt;/p&gt;
&lt;p&gt;算法流程：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} 输入：&amp;amp;样本集D=\{x_1,x_2,...,x_m\};聚类簇数K\\ 过程：\\ &amp;amp;随机初始化K个均值向量\{u_i,u_2,...,u_k\}\\ &amp;amp;Repeat:\\ &amp;amp;\quad for\ i=1,2,...,m\quad do\\ &amp;amp;\qquad 将距离最近的均值向量u_i作为x_i的簇标记(C_{u_{j}}=C_{u_j}\cup(x_i))\\ &amp;amp;\quad for\ i=1,2,..,k\quad do\\ &amp;amp;\qquad 计算 均值均值向量u_i'=\frac{\sum_{x\in C_{u_j}}x}{|C_{u_j}|}并更新 \end{align*} \]&lt;/span&gt;&lt;br/&gt;总结下来就两步：1)样本划归簇标记；2)更新均值向量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KMeans算法优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原理简单，超参就一个聚类簇数K&lt;/li&gt;
&lt;li&gt;速度快&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;K值需要事先确定&lt;/li&gt;
&lt;li&gt;对初始均值向量敏感&lt;/li&gt;
&lt;li&gt;对离群点敏感&lt;/li&gt;
&lt;li&gt;不断对每一个样本分类调整，不断调整聚类中心，当数据量大时，时间开销大&lt;/li&gt;
&lt;li&gt;没有先验知识。比如不能加入先验：cluster A: 500; cluster B: 1000&lt;/li&gt;
&lt;li&gt;不能发现非凸形状的簇&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;决策树&quot;&gt;决策树&lt;/h3&gt;
&lt;p&gt;生成：&lt;/p&gt;
&lt;p&gt;常见的特征选择规则：&lt;/p&gt;
&lt;p&gt;先导知识：&lt;/p&gt;
&lt;p&gt;信息熵&lt;span class=&quot;math inline&quot;&gt;\(Ent(D)=-\sum_{k=1}^{|y|}p_klog\ p_k\)&lt;/span&gt;。 &lt;span class=&quot;math inline&quot;&gt;\(p_k\)&lt;/span&gt;: 当前样本集合中第k类样本所占比例。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(Ent(D)\)&lt;/span&gt;的值越小，则&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;的纯度越高。&lt;/p&gt;
&lt;p&gt;多说一句，这和交叉熵定义很像。交叉熵：&lt;span class=&quot;math inline&quot;&gt;\(H(p,q)=-\sum_{i=1}^np(x_i)log(q(x_i))\)&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;信息增益&lt;span class=&quot;math inline&quot;&gt;\(Gain(D,a)=Ent(D)-\sum_{v=1}^{V}\frac{D^v}{D}Ent(D^v)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;特征a上的信息增益，选择&lt;em&gt;较大&lt;/em&gt;的特征分裂&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;增益率&lt;span class=&quot;math inline&quot;&gt;\(Gain\_ratio(D,a)=\frac{Grain(D,a)}{IV(a)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(IV(a)=-\sum_{v=1}^{V}\frac{D^v}{D}log_2\frac{D^v}{D}\)&lt;/span&gt;称为特征a的“固有值”。&lt;/p&gt;
&lt;p&gt;特征a上的增益率，选择&lt;em&gt;较大&lt;/em&gt;的特征分裂&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;基尼值&lt;span class=&quot;math inline&quot;&gt;\(Gini(D)=\sum_{k=1}^{|y|}\sum_{k'\neq k}p_k p_{k'}=1-\sum_{k=1}^{|y|}p_k^2\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(Gini(D)\)&lt;/span&gt;反映了从数据集D中随机抽取两个样本，其类别标记不一致的概率。&lt;span class=&quot;math inline&quot;&gt;\(Gini(D)\)&lt;/span&gt;越小，数据集&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;的纯度越高。&lt;/p&gt;
&lt;p&gt;特征a的基尼指数定义为：&lt;span class=&quot;math inline&quot;&gt;\(Gini\_index(D,a)=\sum_{v=1}^V\frac{|D^v|}{|D|}Gini(D^v)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;选择划分后使得，基尼指数最小的特征&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;集成算法&quot;&gt;集成算法&lt;/h3&gt;
&lt;p&gt;boosting：将弱学习器提升为强学习器。典型代表：AdaBoost、GBDT等，GBDT将在下面单独介绍&lt;/p&gt;
&lt;p&gt;先从初始训练集训练出一个基学习器，根据基学习器的表现对训练样本分布进行调整，使之前错误分类的样本获得更多的“关注”，基于调整后的样本分布训练下一个基分类器，如此重复，再将T个基分类器加权结合。&lt;/p&gt;
&lt;p&gt;AdaBoost&lt;/p&gt;
&lt;p&gt;输入:训练数据集&lt;span class=&quot;math inline&quot;&gt;\(T=\{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}\)&lt;/span&gt;;弱学习算法&lt;br/&gt;输出:最终分类器&lt;span class=&quot;math inline&quot;&gt;\(G(x)\)&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;17.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;初始化训练数据的权值分布：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ D_1=(w_{11},w_{12},...,w_{1N}),\quad w_{1j}=\frac{1}{N},i=1,2,...,N \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;23&quot;&gt;
&lt;p&gt;对&lt;span class=&quot;math inline&quot;&gt;\(m=1,2,...,M\)&lt;/span&gt;（训练组合M个弱分类器）：&lt;/p&gt;
&lt;p&gt;1)使用带权值分布的&lt;span class=&quot;math inline&quot;&gt;\(D_m\)&lt;/span&gt;的训练数据集学习，得到基分类器&lt;span class=&quot;math inline&quot;&gt;\(G_m(x):x\to\{-1,+1\}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2)计算&lt;span class=&quot;math inline&quot;&gt;\(G_m(x)\)&lt;/span&gt;在训练数据集上的分类误差率&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ e_m=\sum_{i=1}^{N}p(G_m(x_i)\neq y_i)=\sum_{i=1}^{N}w_{m_i}I(G_m(x_i)\neq y_i) \]&lt;/span&gt;&lt;br/&gt;3)计算&lt;span class=&quot;math inline&quot;&gt;\(G_m(x)\)&lt;/span&gt;的系数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \alpha_m=\frac{1}{2}log \frac{1-e_m}{e_m} \]&lt;/span&gt;&lt;br/&gt;4)更新训练数据集的权值分布&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ D_{m+1}=(w_{({m+1},1)},w_{({m+1},2)},...,w_{({m+1},N)})\\ w_{(m+1,i)}=\frac{w_{(m,i)}}{Z_m}exp(-\alpha_m y_iG_m(x_i)),\quad i=1,2,...,N \]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(Z_m\)&lt;/span&gt;为规范化系数，&lt;span class=&quot;math inline&quot;&gt;\(Z_m=\sum_{i=1}^{N}w_{m_i}exp(-\alpha _my_iG_m(x_i))\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;构建基本分类器的线性分类器：&lt;span class=&quot;math inline&quot;&gt;\(f(x)=\sum_{m=1}^M\alpha_mG_m(x)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最终分类器：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ G(x)=sign(f(x))=sign(\sum_{m=1}^M\alpha_mG_m(x)) \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;简而言之，求两个参数：训练数据的权重&lt;span class=&quot;math inline&quot;&gt;\(D_m\)&lt;/span&gt;和基分类器&lt;span class=&quot;math inline&quot;&gt;\(G_m(x)\)&lt;/span&gt;的系数&lt;span class=&quot;math inline&quot;&gt;\(\alpha_m\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;AdaBoost算法是&lt;em&gt;加法模型&lt;/em&gt;，损失函数是&lt;em&gt;指数函数&lt;/em&gt;，学习算法是前向分布算法时的二分类学习方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参见李航-《统计学习方法》-p138~p142&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bagging：&lt;em&gt;随机森林即是bagging的一种扩展变体&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;从原始数据集中采取有放回抽样，构造“采样集”，采样集&lt;span class=&quot;math inline&quot;&gt;\(D'\)&lt;/span&gt;的数据量是和原始数据集&lt;span class=&quot;math inline&quot;&gt;\(D'\)&lt;/span&gt;相同的。可采样出T个含m个训练样本的采样集，然后基于每个采样集训练出一个基学习器，再将基学习器结合。&lt;/p&gt;
&lt;p&gt;显然有一部分样本会在采样集&lt;span class=&quot;math inline&quot;&gt;\(D'\)&lt;/span&gt;中出现多次，而另一部分样本始终不出现，样本在&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;次采样中始终不被采样到的概率为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \lim_{m\to \infty}(1-\frac{1}{m})^m=\frac{1}{e} \]&lt;/span&gt;&lt;br/&gt;随机森林&lt;/p&gt;
&lt;p&gt;随机性：&lt;/p&gt;
&lt;p&gt;1)基决策树的训练数据集由bagging产生。&lt;/p&gt;
&lt;p&gt;2)待选属性集随机产生。待选属性集由节点的属性集合中随机选择的&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个属性组成，&lt;span class=&quot;math inline&quot;&gt;\(k=log_2 d\)&lt;/span&gt;，d为节点属性集合的大小&lt;/p&gt;
&lt;p&gt;对于提升算法而言，基分类器&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;常采用回归树和逻辑回归。树模型有以下优缺点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点
&lt;ul&gt;&lt;li&gt;可解释性强&lt;/li&gt;
&lt;li&gt;具有伸缩不变性，不必归一化特征&lt;/li&gt;
&lt;li&gt;对异常点鲁棒&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;&lt;li&gt;缺乏平滑性。回归预测时，输出值只能输出有限的若干个数值&lt;/li&gt;
&lt;li&gt;不适合处理高维度稀疏数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;gbdt和xgboost区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;gbdt在函数空间中采用梯度下降法进行优化&lt;/li&gt;
&lt;li&gt;xgboost在函数空间中利用牛顿法进行优化&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;梯度提升决策树&quot;&gt;梯度提升决策树&lt;/h3&gt;
&lt;p&gt;梯度提升决策树(Gradient Boosting Decision Tree, GBDT)&lt;/p&gt;
&lt;p&gt;梯度提升算法利用梯度下降法的近似方法，其关键是利用&lt;em&gt;损失函数的负梯度在当前模型的值&lt;/em&gt;，也就是&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ -\left[ \frac{\partial L(y,f(x_i))}{\partial f(x_i)} \right]_{f(x)=f_{m-1}(x)} \]&lt;/span&gt;&lt;br/&gt;作为提升树算法中的&lt;em&gt;残差的近似值&lt;/em&gt;，拟合一个回归树&lt;/p&gt;
&lt;p&gt;模型F定义（加法模型）：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ F(x;w)=\sum_{t=0}^T\alpha_t h_t(x;w_t) \]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;为输入样本，&lt;span class=&quot;math inline&quot;&gt;\(h\)&lt;/span&gt;是分类回归树，&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;是分类回归树的权重，&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;是每棵树的权重&lt;/p&gt;
&lt;p&gt;目标：最小化损失函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ F^*=\mathop{argmin}_{F}\sum_{i=0}^N L(y_i,F(x_i;w)) \]&lt;/span&gt;&lt;br/&gt;迭代求局部最优解&lt;/p&gt;
&lt;h4 id=&quot;梯度提升决策树算法流程&quot;&gt;梯度提升决策树算法流程&lt;/h4&gt;
&lt;p&gt;输入：&lt;span class=&quot;math inline&quot;&gt;\((x_i,y_i),T\)&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化&lt;span class=&quot;math inline&quot;&gt;\(f_0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(for\ t=1\ to\ T\ do\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;计算损失函数的负梯度，作为残差的近似值：&lt;span class=&quot;math inline&quot;&gt;\(\tilde{y_i}=-\left[ \frac{\partial L(y,F(x_i))}{\partial F(x_i)} \right]_{F(x)=F_{t-1}(x)}\)&lt;/span&gt;,其中&lt;span class=&quot;math inline&quot;&gt;\(i=1,2,...,N\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;学习第&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;棵树：&lt;span class=&quot;math inline&quot;&gt;\(w^*=\mathop{argmin}_w\sum_{i=1}^{N}(\tilde{y_i}-h_t(x_i;w))\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;line search 寻找步长：&lt;span class=&quot;math inline&quot;&gt;\(\rho^*=\mathop{argmin}_{\rho}\sum_{i=1}^NL(y_i,F_{t-1}(x_i)+\rho h_t(x_i;w^*))\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;令&lt;span class=&quot;math inline&quot;&gt;\(f_t=\rho^*h_t(x;w^*)\)&lt;/span&gt;，更新模型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;输出&lt;span class=&quot;math inline&quot;&gt;\(F_t\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;稍微总结一下上两节(集成算法和梯度提升决策树)的内容，实际上述两节是一起的，但是内容过多而且&lt;strong&gt;非常重要&lt;/strong&gt;，所以拆成了两节。首先说了两种最重要的集成算法，boosting和bagging。boosting算法的代表有AdaBoost、梯度提升树，有名的工具包如XGBoost, LightGBM等，而bagging算法的代表有随机森林。实际上集成算法还包括stacking和blending等，stacking也是比较常用的集成算法，可参见：&lt;a href=&quot;https://blog.csdn.net/wstcjf/article/details/77989963&quot;&gt;详解stacking过程&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/jiaxin359/p/8559029.html&quot;&gt;集成学习中的 stacking 以及python实现&lt;/a&gt;。实际上，单是一个详解的boosting算法的篇幅都不止如此，况且并无能力指点江山。这里有篇关于XGBoost比较好的解释并且回答中包含了一个PPT，可以下载下来仔细看看：&lt;a href=&quot;https://www.zhihu.com/question/41354392/answer/98658997&quot;&gt;wepon-机器学习算法中 GBDT 和 XGBOOST 的区别有哪些?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再次强调，这部分非常重要，篇幅不够只是因为理解不深，不敢乱写而已:)&lt;/p&gt;
&lt;h3 id=&quot;大文件排序&quot;&gt;大文件排序&lt;/h3&gt;
&lt;p&gt;大文件，文件大小远大于内存大小，文件为若干数字，要求对这些数字排序&lt;/p&gt;
&lt;p&gt;外部排序：&lt;strong&gt;内存极少情况下，利用&lt;em&gt;分治&lt;/em&gt;策略，利用外存保存中间结果，再用多路归并排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体步骤：&lt;/p&gt;
&lt;p&gt;1)将大文件根据实际内存大小，分割为合理大小的小文件&lt;/p&gt;
&lt;p&gt;2)对每个小文件利用内部排序进行排序&lt;/p&gt;
&lt;p&gt;3)每次利用胜者树拿到各个小文件的最小值，从而得到全局最小值，每次将全局最小值写入最终的结果大文件&lt;/p&gt;
&lt;p&gt;总而言之，&lt;em&gt;分治&lt;/em&gt;和&lt;em&gt;合并&lt;/em&gt;的过程。&lt;/p&gt;
&lt;p&gt;胜者树和败者树可以在&lt;span class=&quot;math inline&quot;&gt;\(log(n)\)&lt;/span&gt;的时间内找到最值。胜者树的叶节点存储实际数字，非叶节点存储“胜者”下标。参见：&lt;a href=&quot;https://blog.csdn.net/whz_zb/article/details/7425152&quot;&gt;胜者树与败者树&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;word2vec&quot;&gt;Word2Vec&lt;/h3&gt;
&lt;p&gt;模型无法直接处理文字，需要转化为实数向量的形式。将word映射到一个新的空间中，并以多维的连续实数空间向量进行表示，叫做&lt;code&gt;word representation&lt;/code&gt;，或者&lt;code&gt;word embedding&lt;/code&gt;。&lt;code&gt;word embedding&lt;/code&gt;目前可以划分为两种方法。一是稀疏表示，如词袋等。二是非稀疏表示，如Word2Vec。Word2Vec在转化后的向量维度大幅降低，且能“保持词语语义”。举例而言，希望将&quot;queen&quot;转化为向量形式，使用one-hot表示，可能需要10000维向量，而使用Word2Vec表示，可能只要20维向量；Word2Vec还能保持词语的含义，两个词转化后的向量距离越小，其词义越相近。&lt;/p&gt;
&lt;p&gt;先导知识:&lt;/p&gt;
&lt;p&gt;1)稀疏表示的代表：词袋(one-hot)&lt;/p&gt;
&lt;p&gt;假设对于一个文本，将其仅仅看作是一个词集合，而忽略其词序和语法&lt;/p&gt;
&lt;p&gt;假设通过语料库训练得到了一个词典：{'hello','world','my'}&lt;/p&gt;
&lt;p&gt;则&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ &quot;world&quot;\to[0,1,0]\\ &quot;my&quot;\to[0,0,1] \]&lt;/span&gt;&lt;br/&gt;这是一个很简单的例子，通过语料库训练到的词典有可能含有10000个词语，这是很常见的:)，那么每个词语转化后的向量维数都为10000维&lt;/p&gt;
&lt;p&gt;2)n-gram&lt;/p&gt;
&lt;p&gt;n-gram是一种统计语言模型。根据前&lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt;个item预测第&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个item，这些item可以是音素（语言识别应用），字符（输入法应用），词（分词应用）。一般可以从大规模文本或者语料库中生成n-gram模型。&lt;/p&gt;
&lt;p&gt;从字符层级上看，给定一串字符，如for ex_，n-gram可以用来预测下一个可能的字符&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;假设T是由词序列&lt;span class=&quot;math inline&quot;&gt;\(A_1,A_2,....A_n\)&lt;/span&gt;组成，则&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ p(T)=p(A_1,A_2,...,A_n)=p(A_1)p(A_2|A_1)p(A_3|A_1,A_2)...p(A_n|A_1,A_2,...,A_{(n-1)}) \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;其实就是马尔科夫假设：一个item出现的概率只与前m个item有关&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参见&lt;a href=&quot;https://yq.aliyun.com/articles/224321&quot;&gt;词袋模型的通俗介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Word2Vec&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;分为两种语言模型：CBOW和Skip-gram&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/6cbb8645gw1f5to6e5d9lj216c0qkwhk.jpg&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CBOW根据上下文的词语预测当前词语出现概率&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最大化对数似然函数&lt;span class=&quot;math inline&quot;&gt;\(L=\sum _{w\in c}log\ P(w|context(w))\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;输入层是上下文的词向量（词向量是CBOW的参数，实际上是CBOW的副产物）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;投影层是简单的向量加法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;输出层是输出最可能的w。由于词料库中词汇量是固定的|c|个，可以将其看作是多分类问题。最后一层是Hierarchical softmax:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ p(w|context(w))=\prod_{j=2}^{l^w}p(d_j^w|x_w,\theta_{j-1}^w) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从根节点到叶节点经过了&lt;span class=&quot;math inline&quot;&gt;\(l^{w}-1\)&lt;/span&gt;个节点，编码从下标2开始（根节点无编码），对应的参数向量下标从1开始。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;skip-gram 已知当前词语，预测上下文&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;与CBOW不同之处在于：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输入层不再是多个词向量，而是一个词向量&lt;/li&gt;
&lt;li&gt;投影层实际什么都没干，直接将输入层的词向量传递给输出层&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;模型：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ p(context(w)|w)= \prod_{w \in context(w)}p(u|w) \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;这是一个词袋模型，所以每个u都是无序，相互独立的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Doc2Vec&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://adriancolyer.files.wordpress.com/2016/05/paragraph-vectors-fig-2.png?w=566&amp;amp;zoom=2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与Word2Vec唯一不同之处在于，串联起word vector在上下文中预测下一个单词。&lt;/p&gt;
&lt;p&gt;上下文是固定长度且在段落中sliding window中采样，段落向量在一段中共享在同一段中产生的所有窗口，但是不同段间不共享。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;connect&quot;&gt;Connect&lt;/h3&gt;
&lt;p&gt;Email: cncmn@sina.cn&lt;/p&gt;
&lt;p&gt;GitHub: &lt;a href=&quot;https://github.com/cnlinxi&quot;&gt;cnlinxi@github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这本是开学初整理的一份笔记，是当时感兴趣的点写写记记而成。本文只是介绍了机器学习领域非常小的一部分，权当管中窥豹。实际上这篇又是拾人牙慧，我尽可能在记得的地方加以引用，但难免疏漏，还请告知以补上引用。以及这里面肯定夹带了我的私货，如有错误，还请斧正。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;周志华-《机器学习》&lt;/p&gt;
&lt;p&gt;李航-《统计学习方法》&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 23 Jul 2018 15:08:00 +0000</pubDate>
<dc:creator>冬色</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mengnan/p/9357500.html</dc:identifier>
</item>
<item>
<title>模型构建:模型评估-分类问题 - hbsygfz</title>
<link>http://www.cnblogs.com/hbsygfz/p/9357437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hbsygfz/p/9357437.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;对模型的评估是指对模型泛化能力的评估，主要通过具体的性能度量指标来完成。在对比不同模型的能力时，使用不同的性能度量指标可能会导致不同的评判结果，因此也就意味着，模型的好坏只是相对的，什么样的模型是较好的，不仅取决于数据和算法，还取决于任务需求。本文主要对分类模型的性能度量指标（方法）进行总结。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文以二分类为例进行介绍。&lt;/p&gt;
&lt;h2 id=&quot;混淆矩阵&quot;&gt;1.混淆矩阵&lt;/h2&gt;
&lt;h3 id=&quot;混淆矩阵-1&quot;&gt;1.1 混淆矩阵&lt;/h3&gt;
&lt;p&gt;对于二分类问题，将模型预测的结果（正例、反例）与实际类别（正例、反例）进行比较，就会产生四种情况：&lt;br/&gt;&lt;strong&gt;真正例（true positive, TP）&lt;/strong&gt;：将实际正例预测为正例&lt;br/&gt;&lt;strong&gt;假正例（false positive, FP）&lt;/strong&gt;：将实际反例预测为正例&lt;br/&gt;&lt;strong&gt;真反例（true negative, TN）&lt;/strong&gt;：将实例反例预测为反例&lt;br/&gt;&lt;strong&gt;假反例（false negative, FN）&lt;/strong&gt;：将实际正例预测为反例&lt;br/&gt;TP+FP+TN+FN 为全部样例数，并得到如下矩阵：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180723225143934-1061262083.png&quot;/&gt;&lt;br/&gt;称这个矩阵为&lt;strong&gt;混淆矩阵（confusion matrix）&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;错误率&quot;&gt;1.2 错误率&lt;/h3&gt;
&lt;p&gt;错误率（errorRate）是指预测错误的样例占比，即：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ errorRate = \frac{FP+FN}{TP+FP+TN+FN} \]&lt;/span&gt;&lt;br/&gt;引用周志华老师书中的例子，错误率就是预测出的结果中，将好瓜预测成了坏瓜、将坏瓜预测成了好瓜的比例。&lt;/p&gt;
&lt;h3 id=&quot;正确率精度&quot;&gt;1.3 正确率（精度）&lt;/h3&gt;
&lt;p&gt;正确率（acuracy），又称为精度，就是与错误率相对的指标，即1-错误率，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ accuracy = \frac{TP+TN}{TP+FP+TN+FN}=1-errorRate \]&lt;/span&gt;&lt;br/&gt;仍然是西瓜这个例子，正确率是预测出的结果中，将好瓜预测成了好瓜、将坏瓜预测成了坏瓜的比例。&lt;br/&gt;错误率和正确率是一对从整体上去度量模型预测能力的指标，它无法评估模型对正例（或者反例）的预测能力强弱。这时候就需要使用查准率和查全率。&lt;/p&gt;
&lt;h3 id=&quot;查准率命中率&quot;&gt;1.4 查准率（命中率）&lt;/h3&gt;
&lt;p&gt;查准率（precision），又称为命中率，是指模型预测的正例（或反例）中正确的比例。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ precision = \frac{TP}{TP+FP} \]&lt;/span&gt;&lt;br/&gt;查准率就是预测出的好瓜中，实际是好瓜的比例。&lt;/p&gt;
&lt;h3 id=&quot;查全率召回率覆盖率&quot;&gt;1.5 查全率（召回率、覆盖率）&lt;/h3&gt;
&lt;p&gt;查全率（recall），又称为召回率、覆盖率，是指模型预测正确的正例（或反例）占全部实际正例（或反例）的比例。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ recall = \frac{TP}{TP+FN} \]&lt;/span&gt;&lt;br/&gt;查全率就是预测出的好瓜中，实际为好瓜的数量占全部好瓜的比例。&lt;/p&gt;
&lt;h3 id=&quot;f1值&quot;&gt;1.6 F1值&lt;/h3&gt;
&lt;p&gt;查全率和查准率是一对相矛盾的指标。以西瓜分类为例，为了将更多的好瓜识别出来（即提高查全率），那么就需要去识别更多的西瓜，但是这样就会影响命中率（即查准率）可能使查准率降低；反过来如果希望选出的瓜中真实的好瓜比例尽可能高（即提高查准率），那么就需要尽量选择最优把握的瓜，那么就可能会漏掉不少好瓜，即影响了查全率。&lt;br/&gt;因此，尝试定义查准率（precision）、查全率（recall）的复合指标。&lt;br/&gt;这里介绍常用的复合指标它们的加权调和平均数&lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(F_1\)&lt;/span&gt;&lt;/strong&gt;以及它的一般形式&lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(F_{\beta}\)&lt;/span&gt;&lt;/strong&gt;：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ F_1=\frac{2*precision*recall}{precision+recall} \]&lt;/span&gt;&lt;span class=&quot;math display&quot;&gt;\[ F_{\beta}=\frac{(1+{\beta}^2)*precision*recall}{{\beta}^2*precision+recall} \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(F_1\)&lt;/span&gt;认为查全率和查准率重要程度相同，而&lt;span class=&quot;math inline&quot;&gt;\(F_{\beta}\)&lt;/span&gt;则使用一个参数&lt;span class=&quot;math inline&quot;&gt;\(\beta&amp;gt;0\)&lt;/span&gt;度量二者之间的相对重要程度，&lt;span class=&quot;math inline&quot;&gt;\(\beta=1\)&lt;/span&gt;时，&lt;span class=&quot;math inline&quot;&gt;\(F_{\beta}\)&lt;/span&gt;即为&lt;span class=&quot;math inline&quot;&gt;\(F_1\)&lt;/span&gt;，代表二者重要程度相同；&lt;span class=&quot;math inline&quot;&gt;\(\beta&amp;gt;1\)&lt;/span&gt;时，代表查全率更重要；&lt;span class=&quot;math inline&quot;&gt;\(\beta&amp;lt;1\)&lt;/span&gt;时，代表查准率更重要。&lt;br/&gt;当一个模型进行了多次训练和预测，就会得到多个混淆矩阵，那又将如何计算这些指标？&lt;br/&gt;有两种思路：&lt;br/&gt;1）先计算各个混淆矩阵的指标，然后计算其平均值；&lt;br/&gt;2）先计算混淆矩阵的平均值，再计算各个指标；&lt;/p&gt;
&lt;h2 id=&quot;pr曲线&quot;&gt;2.PR曲线&lt;/h2&gt;
&lt;p&gt;模型对测试样本的预测一般会产生一个实值或者概率，同时设定一个&lt;strong&gt;阈值（threshold）&lt;/strong&gt;作为正例的判别标准，将预测值与这个阈值进行比较，大于这个阈值的认为是正例，小于这个阈值的认为是反例。对于同一个模型来说，设定不同的阈值，就会产生不同的预测结果。以&lt;strong&gt;查准率（precision）作为纵轴，查全率（recall）作为横轴&lt;/strong&gt;，调整这个阈值，就会得到一条变化曲线，称这条曲线为&lt;strong&gt;PR曲线&lt;/strong&gt;。&lt;br/&gt;通过PR曲线不仅可以直观地反映模型在不同阈值下的查全率和查准率，而且也可以用来比较两个不同模型的学习性能。&lt;br/&gt;如下是几种PR曲线示例：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180723230056442-1648876016.png&quot;/&gt;&lt;br/&gt;PR曲线有以下几点&lt;strong&gt;特征&lt;/strong&gt;：&lt;br/&gt;1）查准率（precision）、查全率（recall）都是0-1之间的指标，因此，横纵轴区间为[0,1]；&lt;br/&gt;2）曲线必经原点(0,0)，因为当查全率为0时，查准率必然为0；&lt;br/&gt;3）随着查全率的增加，查准率可能下降，也可能上升；&lt;br/&gt;4）曲线不可能经过(1,0)，因为当查全率为1时，查准率必然不为0；&lt;br/&gt;5）当一个模型的PR曲线完全包住另一个模型的PR曲线，说明前一个模型的性能优于后一个模型。比如，当查全率相同时，后者的查准率必然大于前者；当查准率相同时，后者的查全率必然大于前者。&lt;br/&gt;6）当一个模型的PR曲线与另一个模型的PR曲线发生交叉时，很难比较二者的性能优劣。有一种简单的比较方式，即做出P=R直线与两条PR曲线相交，交点即为查全率与查准率相等的点，这个点称为&lt;strong&gt;平衡点（Break-Event Point，即BEP）&lt;/strong&gt;，比较这个平衡点的高低即可，认为BEP大的曲线，模型性能更好。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180723230102375-175238801.png&quot;/&gt;&lt;br/&gt;还有一种比较准确的方式，即通过计算PR曲线下方的面积来比较两个模型的性能优劣，称这个面积为AUC-PR（Area Under ROC Curve）。&lt;/p&gt;
&lt;h2 id=&quot;roc曲线&quot;&gt;3.ROC曲线&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ROC曲线（Receiver Operating Characteristic），受试者工作特征曲线&lt;/strong&gt;，与PR曲线类似，通过调整正例的判别阈值绘制出来的。不同的是，ROC曲线&lt;strong&gt;以“真正例率（True Positive Rate,TPR）”作为纵轴，以“假正例率（False Positive Rate,TPR）”作为横轴&lt;/strong&gt;。TPR和FPR的定义如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ TPR=\frac{TP}{TP+FN} \]&lt;/span&gt;&lt;span class=&quot;math display&quot;&gt;\[ FPR=\frac{FP}{TN+FP} \]&lt;/span&gt;&lt;br/&gt;如下是几种ROC曲线示例：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180723225414189-1869006180.png&quot;/&gt;&lt;br/&gt;ROC曲线的定义来源于医学诊断，如果从“真正例率（True Positive Rate,TPR）”、“假正例率（False Positive Rate,TPR）”上来解释可能不太直观，我们直接回到医学领域理解可能要更容易。&lt;br/&gt;在医学诊断中，我们要识别病人是否有病，以阴阳为例，判断有病，即为找到阳例，判断无病，即为找到阴例。我们的任务是要尽可能地有病的人找出来，也尽量不要把没有病的人诊断为有病，所以要关注两个指标，即真阳性的样例中识别为阳性的比例、真阴性的样例中识别为阳性的比例，也就是上文中提到的TPR和FPR，第一个指标要尽可能大，第二个指标要尽可能小。但是，这两个指标类似于查全率和查准率，是相互制约的，要想识别出更多有病的人，就需要去诊断更多的人，那么就有可能误伤更多没有病的人。以这两个指标为横纵轴，不断调整阳例的识别标准，就绘制出了ROC曲线。&lt;br/&gt;ROC曲线有以下几点&lt;strong&gt;特征&lt;/strong&gt;：&lt;br/&gt;1）正对角线，代表随机猜想预测，一半预测正确，一半预测错误。&lt;br/&gt;2）点（0，1）是理想状态，代表全部正例都被预测为正例，同时没有反例被预测为正例。因此，越接近（0，1）点，预测能力越好。&lt;br/&gt;3）如果一个模型的ROC曲线完全包住另一个模型的ROC曲线，说明第一条曲线更接近于（0，1）点，其模型性能更好。&lt;br/&gt;4）如果两个模型的ROC曲线出现相交的情况，同样可以通过曲线下方与坐标轴围成的面积大小来比较二者的性能优劣，面积大的说明性能更好。这个面积指标被称作ROC-AUC（Area Under ROC Curve）。&lt;br/&gt;假设ROC曲线是由点&lt;span class=&quot;math inline&quot;&gt;\((x_1,y_1),(x_2,y_2)……(x_m,y_m)\)&lt;/span&gt;连成折线围成了，那么ROC-AUC的取值为下方各个小梯形面积之和：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180723225742106-1190241925.png&quot;/&gt;&lt;br/&gt;一般来说，我们说的AUC都是指ROC-AUC。&lt;/p&gt;
&lt;h2 id=&quot;参考与感谢&quot;&gt;4.参考与感谢&lt;/h2&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://book.douban.com/subject/10590856/&quot;&gt;统计学习方法&lt;/a&gt;&lt;br/&gt;[2] &lt;a href=&quot;https://book.douban.com/subject/26708119/&quot;&gt;机器学习&lt;/a&gt;&lt;br/&gt;[3] &lt;a href=&quot;https://www.cnblogs.com/gatherstars/p/6084696.html&quot;&gt;ROC曲线与AUC值&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 15:03:00 +0000</pubDate>
<dc:creator>hbsygfz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hbsygfz/p/9357437.html</dc:identifier>
</item>
<item>
<title>【Java并发】Executor框架 - Ye_yang</title>
<link>http://www.cnblogs.com/yeyang/p/9357382.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yeyang/p/9357382.html</guid>
<description>

&lt;p&gt;Java的线程既是工作单元，也是执行机制。从JDK5开始，把工作单元和执行机制分离开来。&lt;/p&gt;
&lt;p&gt;Executor框架由3大部分组成&lt;/p&gt;

&lt;h2 id=&quot;id-Runnable接口&quot;&gt;Runnable接口&lt;/h2&gt;
&lt;p&gt;不含有运行结果&lt;/p&gt;

&lt;h2 id=&quot;id-Callable接口&quot;&gt;Callable接口&lt;/h2&gt;
&lt;p&gt;含有运行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Callable&amp;lt;V&amp;gt;&lt;span&gt; {
    V call() &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; Runnable与Callable的区别&lt;/p&gt;
&lt;p&gt;Runnable和Callable的区别是，&lt;br/&gt;(1)Callable规定的方法是call(),Runnable规定的方法是run().&lt;/p&gt;
&lt;p&gt;(2)Callable的任务执行后可返回值，而Runnable的任务是不能返回值的&lt;/p&gt;
&lt;p&gt;(3)call方法可以抛出异常，run方法不可以&lt;/p&gt;
&lt;p&gt;(4)运行Callable任务可以拿到一个Future对象，Future 表示异步计算的结果。&lt;/p&gt;
&lt;h2 id=&quot;id-Future接口&quot;&gt;Future接口&lt;/h2&gt;
&lt;p&gt;Future接口代表异步计算的结果，通过Future接口提供的方法可以查看异步计算是否执行完成，或者等待执行结果并获取执行结果，同时还可以取消执行。&lt;/p&gt;

&lt;p&gt;一个使用Runnable的简单例子&lt;/p&gt;


&lt;h2 id=&quot;id-ThreadPoolExecutor&quot;&gt;ThreadPoolExecutor&lt;/h2&gt;
&lt;p&gt;ThreadPoolExecutor是Executor框架最核心的类，是线程池的实现类。&lt;/p&gt;
&lt;p&gt;核心配置参数包括&lt;/p&gt;
&lt;p&gt;corePoolSize：核心线程池的大小&lt;/p&gt;
&lt;p&gt;maximumPoolSize：最大线程池的大小&lt;/p&gt;
&lt;p&gt;BlockingQueue：暂时保存任务的工作队列&lt;/p&gt;
&lt;p&gt;RejectedExecutionHandler：当ThreadPoolExecutor已经饱和时（达到了最大线程池大小且工作队列已满）将执行的Handler。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize, 
                              &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
                              &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime, 
                              TimeUnit unit,
                              BlockingQueue&lt;/span&gt;&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以创建3种类型的ThreadPoolExecutor。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;FixedThreadPool&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SingleThreadExecutor&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CachedThreadPool&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;id-1.FixedThreadPool&quot;&gt;1.FixedThreadPool&lt;/h3&gt;
&lt;p&gt;FixedThreadPool是固定线程数的线程池，最多线程池中有nThreads个线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService newFixedThreadPool(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nThreads) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(nThreads, nThreads, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;nThreads为固定线程数&lt;/span&gt;
                                      0L, TimeUnit.MILLISECONDS, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;空闲线程的等待时间为0ms，表示立刻被终止&lt;/span&gt;
                                      &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;工作队列&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/676975/201807/676975-20180723232836233-366736957.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;415&quot;/&gt;&lt;/p&gt;
&lt;p&gt;FixedThreadPool的execute()方法内部执行过程&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当新任务被提交时，如果当前运行线程数小于nTheads，创建新线程执行任务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果当前运行线程数等于设置的最大线程数nThreads，将新任务加入到工作队列LinkedBlockingQueue中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线程执行完任务后会反复从LinkedBlockingQueue中获取新任务执行&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;LinkedBlockingQueue中没有新任务，线程空闲，线程将被终止。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意点：&lt;/p&gt;
&lt;p&gt;由于工作队列使用的是无界队列LinkedBlockingQueue，FixedThreadPool不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution()方法）。&lt;/p&gt;
&lt;h3 id=&quot;id-2.SingleThreadExecutor&quot;&gt;2.SingleThreadExecutor&lt;/h3&gt;
&lt;p&gt;SingleThreadExecutor是FixedThreadPool的特例，线程池中线程的固定数量为1，即最多有一个线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService newSingleThreadExecutor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FinalizableDelegatedExecutorService
            (&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 1,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;nThreads为固定线程数&lt;/span&gt;
                                    0L, TimeUnit.MILLISECONDS, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;空闲线程的等待时间为0ms，表示立刻被终止&lt;/span&gt;
                                    &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;())); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;工作队列&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/676975/201807/676975-20180723233002997-561260428.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SingleThreadExecutor的execute()方法内部执行过程与注意事项可参考FixedThreadPool的。&lt;/p&gt;
&lt;h3 id=&quot;id-3.CachedThreadPool&quot;&gt;3.CachedThreadPool&lt;/h3&gt;
&lt;p&gt;CachedThreadPool是根据需要创建新线程的线程池。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService newCachedThreadPool() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(0, Integer.MAX_VALUE, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;coolPoolSize为0，maxinumPoolSize为Integer.MAX_VALUE&lt;/span&gt;
                                      60L, TimeUnit.SECONDS, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;空闲线程的等待时间，空闲60s后被终止&lt;/span&gt;
                                      &lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;工作队列&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CachedThreadPool的execute()方法的内部运行过程&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当新任务被提交时，主线程将任务插入到工作队列中（SynchronousQueue的offer()方法），如果线程池有空闲线程在等待任务，新任务交给空闲线程处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果线程池中没有在等待任务的空闲线程，创建新线程执行任务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;线程执行完任务后，等待60s（SynchronousQueue.poll(60, TimeUnit.SECONDS)方法），如果没有等待新任务，线程终止&lt;/p&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;SynchronousQueue是一个没有容量的BlockingQueue。每一个插入操作必须等待另一个线程的移除操作。&lt;/p&gt;
&lt;p&gt;CachedThreadPool使用SynchronousQueue，把主线程提交的任务传递给空闲线程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/676975/201807/676975-20180723233125896-1388891622.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;p&gt;CachedThreadPool的线程池是无解的，没有限制数量，如果主线程提交任务的速度高于线程处理任务的速度，将不断创建新线程。&lt;/p&gt;
&lt;p&gt;极端情况下，会因创建过多线程耗尽CPU和内存。&lt;/p&gt;

&lt;h2 id=&quot;id-ScheduledThreadPoolExecutor&quot;&gt;ScheduledThreadPoolExecutor&lt;/h2&gt;
&lt;p&gt;ScheduledThreadPoolExecutor主要用于定时任务（定期执行，给定延迟后执行）&lt;/p&gt;
&lt;h2 id=&quot;id-执行方式&quot;&gt;执行方式&lt;/h2&gt;
&lt;h3 id=&quot;id-1.scheduleAtFixedRate&quot;&gt;1.scheduleAtFixedRate&lt;/h3&gt;
&lt;p&gt;任务按照固定周期执行，比如设定每10分钟执行一次，第8分钟时候执行了第一次，后续执行时间点为第18分钟，第28分钟，第38分钟&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; ScheduledFuture&amp;lt;?&amp;gt; scheduleAtFixedRate(Runnable command, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务&lt;/span&gt;
                                                  &lt;span&gt;long&lt;/span&gt; initialDelay, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始延迟&lt;/span&gt;
                                                  &lt;span&gt;long&lt;/span&gt; period, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务执行周期&lt;/span&gt;
                                                  TimeUnit unit)  
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;id-2.scheduleWithFixedDelay&quot;&gt;2.scheduleWithFixedDelay&lt;/h3&gt;
&lt;p&gt;任务按照固定延迟执行，比如设定延迟时间为10是分钟，第8分钟时候执行了第一次，任务执行完成后，再等待10分钟，执行下一次。如果任务执行了2分钟，则下一次为第20分钟&lt;/p&gt;

&lt;h2 id=&quot;id-实现原理&quot;&gt;实现原理&lt;/h2&gt;
&lt;h2&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/676975/201807/676975-20180723233205958-697838089.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/h2&gt;
&lt;h3 id=&quot;id-数据结构&quot;&gt;数据结构&lt;/h3&gt;
&lt;p&gt;ScheduledThreadPoolExecutor：定时任务执行器&lt;/p&gt;
&lt;p&gt;DelayQueue：使用DelayQueue作为任务队列，保存待调度的任务，任务按照执行的时间点排序。DelayQueue内部是用PriorityQueue实现。&lt;/p&gt;
&lt;p&gt;ScheduledFutureTask：待调度任务。&lt;/p&gt;
&lt;p&gt;ScheduledFutureTask的成员变量：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;time：任务将被执行的具体时间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;sequenceNumber：任务序号，time相同时，序号小的先执行&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;period：任务执行的间隔周期&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;id-运行机制&quot;&gt;运行机制&lt;/h3&gt;
&lt;p&gt;ScheduledThreadPoolExecutor内部运行过程&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;线程从DelayQueue中获取到到期的ScheduledFutureTask，到期是指time大于等于当前时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行任务ScheduledFutureTask&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修改ScheduledFutureTask的time为下次要执行的时间，放回到DelayQueue中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 23 Jul 2018 14:42:00 +0000</pubDate>
<dc:creator>Ye_yang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yeyang/p/9357382.html</dc:identifier>
</item>
<item>
<title>JsonBuilder初出茅庐 - 李新杰</title>
<link>http://www.cnblogs.com/lixinjie/p/json-builder.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/json-builder.html</guid>
<description>&lt;p&gt;　　互联网这股东风不久前刮到了甘凉国，国王老甘独具慧眼，想赶紧趁着东风未停大力发展移动互联网，因为他笃信布斯雷的理论：“站在风口上，猪都能飞起来”。无奈地方偏僻落后，国内无可用之才啊。老甘一筹莫展的低头凝思应声被打断，“启奏陛下，有四个从东土大唐来的和尚前来更换通关文牒”，听到“东土大唐”四个字，老甘心头一喜，答道：“请他们去正堂等候”。&lt;/p&gt;
&lt;p&gt;唐僧：贫僧唐三藏，自东土大唐而来，前往西天拜佛求经，今途径贵国，恳请陛下更换通关文牒。&lt;br/&gt;国王：高僧从东方而来，想必对互联网略知一二。&lt;br/&gt;唐僧：贫僧也是略有耳闻，不过我的徒儿对此颇有研究。&lt;br/&gt;国王：寡人现有一需求，还请高僧帮忙处理一下，事成之后，定放你们西行。需求文档一会发你。&lt;br/&gt;唐僧：遵命，谢陛下。&lt;br/&gt;国王：（发文档），@三藏。&lt;br/&gt;唐僧：收到。&lt;br/&gt;唐僧：@悟净，处理下文档中的需求。&lt;br/&gt;沙僧：收到。&lt;/p&gt;
&lt;p&gt;　　对接接口繁琐复杂，还要多方联调。悟空虽然水平高，但是脾气不好，怕打起来；八戒好吃懒惰，恐难当此任；悟净，为师只有辛苦你了。唐僧心里想到此，不由得叹气一声。&lt;/p&gt;
&lt;p&gt;沙僧：师傅，这文档写的乱七八糟、语句不通，很多入参、出参模糊不清，对方测试环境时好时坏，给他们打电话，他们说很忙暂时没时间管我。&lt;br/&gt;唐僧：悟净，这些为师都知道。程序员都没什么文化，注释、文档总是写不好；而且非常苦逼，总是熬夜加班，所以没有时间。你应该理解以下。&lt;br/&gt;沙僧：哎。。。入参报文格式为json，且非常复杂，我拼了一上午报文，每次都返回入参报文格式不正确。&lt;br/&gt;唐僧：你是怎么拼json格式的报文呢？&lt;br/&gt;沙僧：传统方法啊，先用Map和List组合好，再转成json字符串。&lt;br/&gt;唐僧：如果json非常复杂的话，要定义好多Map和List，光起些好点儿的名字就够头大的，还要再互相嵌套起来，稍有不慎，很容易出错。真是够够的了。而且要写很多代码。&lt;br/&gt;沙僧：谁说不是呢，师傅有什么好方法吗？&lt;br/&gt;唐僧：json结构你应该很熟悉，它是一个自我嵌套的递归结构。那我们就来设计一个构建器来直接构建json字符串，就叫JsonBuilder吧。&lt;br/&gt;沙僧：我突然想起StringBuilder，它的流式api非常好用，快捷方便。只是字符串是一维的，只有先后顺序，但json是二维的，既有先后顺序，还有内外顺序。&lt;br/&gt;唐僧：你说的内外顺序其实就是父子关系，这也很好处理。&lt;br/&gt;　　1)只需维护一个指向当前级别的指针，如果只是添加简单的key-value，当前级别保持不变。&lt;br/&gt;　　2)如果添加了复合value（子节点），当前指针指向新添加的级别（深入一级），此时该级别就成了新的当前级别。&lt;br/&gt;　　3)当前级别结束后只需回到父级别（退出一级），此时父级别就又成了新的当前级别，如此往复下去即可。&lt;br/&gt;沙僧：师傅，恕徒儿愚钝，您讲的太抽象了，能不能举个例子。&lt;br/&gt;唐僧：看下面的json，&lt;/p&gt;
&lt;p&gt;{&lt;br/&gt;  &quot;string&quot;:&quot;编程新说&quot;,&lt;br/&gt;  &quot;int&quot;:33,&lt;br/&gt;  &quot;boolean&quot;:true,&lt;br/&gt;  &quot;double&quot;:3.14,&lt;br/&gt;  &quot;null&quot;:null,&lt;br/&gt;  &quot;sub1&quot;:{&lt;br/&gt;    &quot;string&quot;:&quot;编程新说&quot;,&lt;br/&gt;    &quot;int&quot;:33,&lt;br/&gt;    &quot;boolean&quot;:true,&lt;br/&gt;    &quot;double&quot;:3.14,&lt;br/&gt;    &quot;null&quot;:null&lt;br/&gt;  },&lt;br/&gt;  &quot;sub2&quot;:[&lt;br/&gt;    {&lt;br/&gt;      &quot;string&quot;:&quot;编程新说&quot;,&lt;br/&gt;      &quot;int&quot;:33,&lt;br/&gt;      &quot;boolean&quot;:true,&lt;br/&gt;      &quot;double&quot;:3.14,&lt;br/&gt;      &quot;null&quot;:null&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      &quot;string&quot;:&quot;编程新说&quot;,&lt;br/&gt;      &quot;int&quot;:33,&lt;br/&gt;      &quot;boolean&quot;:true,&lt;br/&gt;      &quot;double&quot;:3.14,&lt;br/&gt;      &quot;null&quot;:null&lt;br/&gt;    }&lt;br/&gt;  ],&lt;br/&gt;  &quot;sub3&quot;:[&lt;br/&gt;    &quot;编程新说&quot;,&lt;br/&gt;    33,&lt;br/&gt;    true,&lt;br/&gt;    3.14,&lt;br/&gt;    null&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;　　1)首先指针指向最外层级别，此时添加5个简单的key-value，整个添加过程级别保持不变，即这5个值都添加给了当前级别。&lt;br/&gt;　　2)然后添加sub1节点，它是一个复合节点，所以当前指针指向新添加的节点级别，此时添加5个简单的key-value，都添加给了sub1，结束后指针回退到上一级。&lt;br/&gt;　　3)此时再添加sub2，当前指针指向sub2，因sub2是一个数组，也是复合节点。&lt;br/&gt;　　4)数组里包含的又是复合节点，只不过没有名字而已。添加一个无名字节点，当前指针指向该节点，此时可以为它添加5个key-value，然后回到上一级，即数组级别&lt;br/&gt;　　5)然后添加第二个无名字节点，为它添加5个key-value，回到上一级，再回到上一级。&lt;br/&gt;　　6)然后添加sub3，因为它的value都是简单值，所以添加value时当前级别不变，停留在数组级别。完成之后回到上一级，即最外层级别。&lt;br/&gt;沙僧：这么一讲解倒是非常直观，层次也很清晰，所见即所得。还是师傅厉害。&lt;br/&gt;唐僧：为师也没那么厉害了，只是趁着你们打妖怪的时候，多琢磨了一会儿。说起来简单，实现起来还是有些许难度的，要不你来试试。可以参考这个示例。&lt;/p&gt;
&lt;p&gt;JsonBuilder jb = new JsonBuilder();&lt;br/&gt;jb.kv(&quot;string&quot;, &quot;编程新说&quot;)&lt;br/&gt;.kv(&quot;int&quot;, 33)&lt;br/&gt;.kv(&quot;boolean&quot;, true)&lt;br/&gt;.kv(&quot;double&quot;, 3.14)&lt;br/&gt;.kv(&quot;null&quot;, null)&lt;br/&gt;.ko(&quot;sub1&quot;)&lt;br/&gt;    .kv(&quot;string&quot;, &quot;编程新说&quot;)&lt;br/&gt;    .kv(&quot;int&quot;, 33)&lt;br/&gt;    .kv(&quot;boolean&quot;, true)&lt;br/&gt;    .kv(&quot;double&quot;, 3.14)&lt;br/&gt;    .kv(&quot;null&quot;, null)&lt;br/&gt;.end()&lt;br/&gt;.ka(&quot;sub2&quot;)&lt;br/&gt;    .io()&lt;br/&gt;        .kv(&quot;string&quot;, &quot;编程新说&quot;)&lt;br/&gt;        .kv(&quot;int&quot;, 33)&lt;br/&gt;        .kv(&quot;boolean&quot;, true)&lt;br/&gt;        .kv(&quot;double&quot;, 3.14)&lt;br/&gt;        .kv(&quot;null&quot;, null)&lt;br/&gt;    .end()&lt;br/&gt;    .io()&lt;br/&gt;        .kv(&quot;string&quot;, &quot;编程新说&quot;)&lt;br/&gt;        .kv(&quot;int&quot;, 33)&lt;br/&gt;        .kv(&quot;boolean&quot;, true)&lt;br/&gt;        .kv(&quot;double&quot;, 3.14)&lt;br/&gt;        .kv(&quot;null&quot;, null)&lt;br/&gt;    .end()&lt;br/&gt;.end()&lt;br/&gt;.ka(&quot;sub3&quot;)&lt;br/&gt;    .iv(&quot;编程新说&quot;)&lt;br/&gt;    .iv(33)&lt;br/&gt;    .iv(true)&lt;br/&gt;    .iv(3.14)&lt;br/&gt;    .iv(null)&lt;br/&gt;.end();&lt;br/&gt;沙僧：好的，只是这变量名字有点。。。但别光我一人啊，也让广大群众试试吧。&lt;/p&gt;
&lt;p&gt;　　悟净得到师傅的指点后，有一点小小的豁然开朗，决定自己去实现一把。但想到又开始去对接口，不由得叹气一声，哎。。。&lt;/p&gt;

&lt;p&gt;PS：也可以按照此方法写一个MapBuilder。&lt;br/&gt;PS：也可以按照此方法写一个XmlBuilder。&lt;/p&gt;


&lt;p&gt;（完）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;编程新说&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr data-width=&quot;80%&quot;/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;用独特的视角说技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibyjamcabcjdWFl5NbLvP8Y42lnq8FO7erV4YRMvM24UexwHEvyqz25XiaAE5IhThMb7VNkh2useQFlqWPPtMWVA/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;1&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 23 Jul 2018 13:52:00 +0000</pubDate>
<dc:creator>李新杰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lixinjie/p/json-builder.html</dc:identifier>
</item>
</channel>
</rss>