<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET Core中使用GraphQL - 第一章 Hello World - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9907127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9907127.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181105072938212-1915933507.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;你是否已经厌倦了REST风格的API? 让我们来聊一下GraphQL。 GraphQL提供了一种声明式的方式从服务器拉取数据。你可以从GraphQL官网中了解到GraphQL的所有优点。在这一系列博客中，我将展示如何在ASP.NET Core中集成GraphQL, 并使用GraphQL作为你的API查询语言。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用GraphQL的声明式查询，你可以自定义API返回的属性列表。这与REST API中每个API只返回固定字段不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了在C#中使用GraphQL, GraphQL社区中提供了一个开源组件&lt;code&gt;graphql-dotnet&lt;/code&gt;。本系列博客中我们都将使用这个组件。&lt;/p&gt;
&lt;p&gt;首先我们创建一个空的ASP.NET Core App&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet new web --name chatper1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们添加对&lt;code&gt;graphql-dotnet&lt;/code&gt;库的引用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet add package GraphQL&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;下面我们来创建一个&lt;code&gt;query&lt;/code&gt;类, 我们将它命名为&lt;code&gt;HelloWorldQuery&lt;/code&gt;。&lt;code&gt;graphql-dotnet&lt;/code&gt;中，查询类都需要继承&lt;code&gt;ObjectGraphType&lt;/code&gt;类，所以&lt;code&gt;HelloWorldQuery&lt;/code&gt;的代码如下&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using GraphQL.Types;
public class HelloWorldQuery : ObjectGraphType
{
    public HelloWorldQuery()
    {
        Field&amp;lt;StringGraphType&amp;gt;(
            name: &quot;hello&quot;,
            resolve: context =&amp;gt; &quot;world&quot;
        );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里你可能注意到我们使用了一个泛型方法&lt;code&gt;Field&lt;/code&gt;，并传递了一个GraphQL的字符串类型&lt;code&gt;StringGraphType&lt;/code&gt;来定义了一个&lt;code&gt;hello&lt;/code&gt;字段, &lt;code&gt;resolve&lt;/code&gt; 参数是一个Func委托，在其中定义了如何返回当前字段的值，这里我们是直接返回了一个字符串hello。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;查询类中的返回字段都是定义在查询类的构造函数中的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在我们一个有了一个查询类，下一步我们需要使用这个查询类构建一个结构(schema)。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Startup.cs&lt;/code&gt;文件的&lt;code&gt;Configure&lt;/code&gt;方法中，使用以下代码替换原有代码&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var schema = new Schema {
    Query = new HelloWorldQuery() 
};

app.Run(async (context) =&amp;gt;
{
    var result = await new DocumentExecuter()
        .ExecuteAsync(doc =&amp;gt;
        {
            doc.Schema = schema;
            doc.Query = @&quot;
                query {
                    hello
                }
            &quot;;
        }).ConfigureAwait(false);

    var json = new DocumentWriter(indent: true)
        .Write(result)
    await context.Response.WriteAsync(json);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;DocumentExecuter&lt;/code&gt; 类的&lt;code&gt;ExecuteAsync&lt;/code&gt;方法中我们定义Action委托，并通过这个委托设置了一个&lt;code&gt;ExecutionOptions&lt;/code&gt;对象。这个对象初始化了我们定义的结构(schema), 并执行了我们定义的查询字符串。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;doc.Query&lt;/code&gt;定义了一个查询字符串&lt;/li&gt;
&lt;li&gt;最终查询执行的结果会通过&lt;code&gt;DocumentWriter&lt;/code&gt;类实例的&lt;code&gt;Write&lt;/code&gt;被转换成一个JSON字符串&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们来运行一下这个程序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet run&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你将在浏览器中看到以下结果&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;data&quot;: {
    &quot;hello&quot;: &quot;world&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上的例子中，你会发现使用GraphQL并不像想象中那么难。下面我们可以在&lt;code&gt;HelloWorldQuery&lt;/code&gt;类的构造函数中再添加一个字段&lt;code&gt;howdy&lt;/code&gt;, 并指定这个字段会返回一个字符串&lt;code&gt;universe&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Field&amp;lt;StringGraphType&amp;gt;(
    name: &quot;howdy&quot;,
    resolve: context =&amp;gt; &quot;universe&quot;
); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们继续修改&lt;code&gt;Startup&lt;/code&gt;类中的&lt;code&gt;Configure&lt;/code&gt;方法, 修改我们之前定义的query&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var schema = new Schema { 
    Query = new HelloWorldQuery()
};

app.Run(async (context) =&amp;gt;
{
    var result = await new DocumentExecuter()
        .ExecuteAsync(doc =&amp;gt;
        {
            doc.Schema = schema;
            doc.Query = @&quot;
                query {
                    hello
                    howdy
                }
            &quot;;
        }).ConfigureAwait(false);

    var json = new DocumentWriter(indent: true)
        .Write(result)
    await context.Response.WriteAsync(json);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新启动项目后，结果如下&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;data&quot;: {
    &quot;hello&quot;: &quot;world&quot;,
    &quot;howdy&quot;: &quot;universe&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本篇我们只是接触了GraphQL的一些皮毛，你可能会对GraphQL声明式行为有很多问题，没有关系，后续博客中，我们慢慢解开GraphQL的面纱。下一篇我们将介绍如何创建一个中间件(Middleware)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lamondlu/GraphQL_Blogs&quot;&gt;本篇源代码：https://github.com/lamondlu/GraphQL_Blogs&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 04 Nov 2018 23:38:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>前言 你是否已经厌倦了REST风格的API? 让我们来聊一下GraphQL。 GraphQL提供了一种声明式的方式从服务器拉取数据。你可以从GraphQL官网中了解到GraphQL的所有优点。在这一系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9907127.html</dc:identifier>
</item>
<item>
<title>Windbg程序调试系列4-Live Debugging - Eric zhou</title>
<link>http://www.cnblogs.com/tianqing/p/9905738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianqing/p/9905738.html</guid>
<description>&lt;p&gt;上篇博文中给大家分享了使用Windbg分析线程阻塞问题：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tianqing/p/9887309.html&quot; target=&quot;_blank&quot;&gt;Windbg程序调试系列3-线程阻塞问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本篇中我们继续，跟大家分享附加进程实时调试-Live Debugging。&lt;/p&gt;
&lt;p&gt;先说一下使用Windbg附加进程实时调试的&lt;span&gt;&lt;strong&gt;应用场景和注意事项&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;集成测试环境，影响异常后，分析异常和线程上下文的执行堆栈、参数情况；&lt;/li&gt;
&lt;li&gt;生产环境：短时间内调试程序异常，查看异常上下文和参数，但是调试时间不能太久。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/span&gt;附加进程调试会阻塞请求，调试后新的请求被阻塞住，前端调用受影响，因此要谨慎、权衡利弊，开发测试环境可以，生产环境要谨慎。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附加进程实时调试的套路：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;F6 Attache进程&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;加载SOS, .loadby sos clr&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;启用异常捕获 sxe clr&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;运行，捕获&amp;amp;查看异常 g  !pe&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;查看异常所在线程堆栈!clrstack, 查看异常所在线程堆栈的参数和变量 !clrstack -a / !dso&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;禁用异常捕获 sxd clr&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;退出调试 qd&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;动手实操：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. F6 Attache进程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;打开Windbg，按下F6键，选择要调试的进程，支持输入进程ID：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201811/23525-20181104205447351-1468913249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 加载SOS, .loadby sos clr&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
.loadby sos clr
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 启用异常捕获 sxe clr&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201811/23525-20181104205657137-632063684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. 运行，捕获&amp;amp;查看异常 g  !pe&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201811/23525-20181104205843837-633927966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图的输出中，我们发现了以下异常信息：&lt;span&gt;&lt;strong&gt;SocketException：远程追究强迫关闭了一个现有的连接&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;032&lt;/span&gt;&amp;gt; !&lt;span&gt;pe
Exception &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;: 000000d79aedb7a8
Exception type:   System.Net.Sockets.SocketException
Message:          远程主机强迫关闭了一个现有的连接。
InnerException:   &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
StackTrace (generated):
&lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
StackTraceString: &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
HResult: &lt;/span&gt;&lt;span&gt;80004005&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;异常Exception对象的内存地址：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;000000d79aedb7a8&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 查看异常所在线程堆栈!clrstack, 查看异常所在线程堆栈的参数和变量 !clrstack -a / !dso&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;032&lt;/span&gt;&amp;gt; &lt;span&gt;&lt;strong&gt;!&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;pe&lt;/strong&gt;&lt;/span&gt;
Exception &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;: 000000d79aedb7a8
Exception type:   System.Net.Sockets.SocketException
Message:          远程主机强迫关闭了一个现有的连接。
InnerException:   &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
StackTrace (generated):
&lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
StackTraceString: &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
HResult: &lt;/span&gt;&lt;span&gt;80004005&lt;/span&gt;
&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;032&lt;/span&gt;&amp;gt;&lt;span&gt;&lt;strong&gt; !&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;clrstack&lt;/strong&gt;&lt;/span&gt;
OS Thread Id: &lt;/span&gt;&lt;span&gt;0x15968&lt;/span&gt; (&lt;span&gt;32&lt;/span&gt;&lt;span&gt;)
        Child SP               IP Call Site
000000d7b927ea88 00007ffe61c395fc [HelperMethodFrame: 000000d7b927ea88] 
000000d7b927eb70 00007ffe52e68f0f &lt;/span&gt;*** WARNING: Unable to verify checksum &lt;span&gt;for&lt;/span&gt; C:\Windows\assembly\NativeImages_v4.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.30319_64\System\47e0be927382f169f5de470fab0ceb7d\System.ni.dll
System.Net.Sockets.NetworkStream.Read(Byte[], Int32, Int32) [f:\dd\NDP\fx\src\net\System\Net\Sockets\NetworkStream.cs @ &lt;/span&gt;&lt;span&gt;513&lt;/span&gt;&lt;span&gt;]
000000d7b927ebe0 00007ffe53e59c04 &lt;/span&gt;*** WARNING: Unable to verify checksum &lt;span&gt;for&lt;/span&gt; C:\Windows\assembly\NativeImages_v4.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.30319_64\mscorlib\5d0c037297cc1a64b52ce43b45c2ac2e\mscorlib.ni.dll
System.IO.BufferedStream.ReadByte() [f:\dd\ndp\clr\src\BCL\system\io\bufferedstream.cs @ &lt;/span&gt;&lt;span&gt;814&lt;/span&gt;&lt;span&gt;]
000000d7b927ec10 00007ffe53e2183c System.IO.BinaryReader.ReadByte() [f:\dd\ndp\clr\src\BCL\system\io\binaryreader.cs @ &lt;/span&gt;&lt;span&gt;143&lt;/span&gt;&lt;span&gt;]
000000d7b927ec40 00007ffdf6188eb5 RabbitMQ.Client.Impl.Frame.ReadFrom(RabbitMQ.Util.NetworkBinaryReader)
000000d7b927ecb0 00007ffdf6188e13 RabbitMQ.Client.Impl.SocketFrameHandler.ReadFrame()
000000d7b927ed10 00007ffdf6188cfc RabbitMQ.Client.Framing.Impl.Connection.MainLoopIteration()
000000d7b927ed50 00007ffdf6188a9f RabbitMQ.Client.Framing.Impl.Connection.MainLoop()
000000d7b927edb0 00007ffe53e34740 System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ &lt;/span&gt;&lt;span&gt;954&lt;/span&gt;&lt;span&gt;]
000000d7b927ee80 00007ffe53e345d4 System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ &lt;/span&gt;&lt;span&gt;902&lt;/span&gt;&lt;span&gt;]
000000d7b927eeb0 00007ffe53e345a2 System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ &lt;/span&gt;&lt;span&gt;891&lt;/span&gt;&lt;span&gt;]
000000d7b927ef00 00007ffe53ebcf62 System.Threading.ThreadHelper.ThreadStart() [f:\dd\ndp\clr\src\BCL\system\threading\thread.cs @ &lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;]
000000d7b927f158 00007ffe55325a03 [GCFrame: 000000d7b927f158] 
000000d7b927f4a8 00007ffe55325a03 [DebuggerU2MCatchHandlerFrame: 000000d7b927f4a8] &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的输出中，我们能看到异常所在的线程是32号线程，线程堆栈如下，RabbitMQ的通讯异常（心跳线程连接RabbitMQ Server异常）&lt;/p&gt;
&lt;p&gt;继续看线程堆栈的变量：&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;!clrstack -a&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;032&lt;/span&gt;&amp;gt; !clrstack -&lt;span&gt;a
OS Thread Id: &lt;/span&gt;&lt;span&gt;0x15968&lt;/span&gt; (&lt;span&gt;32&lt;/span&gt;&lt;span&gt;)
        Child SP               IP Call Site
000000d7b927ea88 00007ffe61c395fc [HelperMethodFrame: 000000d7b927ea88] 
000000d7b927eb70 00007ffe52e68f0f System.Net.Sockets.NetworkStream.Read(Byte[], Int32, Int32) [f:\dd\NDP\fx\src\net\System\Net\Sockets\NetworkStream.cs @ &lt;/span&gt;&lt;span&gt;513&lt;/span&gt;&lt;span&gt;]
    PARAMETERS:
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; = &amp;lt;no data&amp;gt;&lt;span&gt;
        buffer &lt;/span&gt;= &amp;lt;no data&amp;gt;&lt;span&gt;
        offset &lt;/span&gt;= &amp;lt;no data&amp;gt;&lt;span&gt;
        size &lt;/span&gt;= &amp;lt;no data&amp;gt;&lt;span&gt;
    LOCALS:
        &lt;/span&gt;&amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;&lt;span&gt;

000000d7b927ebe0 00007ffe53e59c04 System.IO.BufferedStream.ReadByte() [f:\dd\ndp\clr\src\BCL\system\io\bufferedstream.cs @ &lt;/span&gt;&lt;span&gt;814&lt;/span&gt;&lt;span&gt;]
    PARAMETERS:
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; (&amp;lt;CLR reg&amp;gt;) = &lt;span&gt;0x000000d79a3c2f18&lt;/span&gt;&lt;span&gt;
    LOCALS:
        &lt;/span&gt;&amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;&lt;span&gt;

000000d7b927ec10 00007ffe53e2183c System.IO.BinaryReader.ReadByte() [f:\dd\ndp\clr\src\BCL\system\io\binaryreader.cs @ &lt;/span&gt;&lt;span&gt;143&lt;/span&gt;&lt;span&gt;]
    PARAMETERS:
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; = &amp;lt;no data&amp;gt;&lt;span&gt;
    LOCALS:
        &lt;/span&gt;&amp;lt;no data&amp;gt;&lt;span&gt;

000000d7b927ec40 00007ffdf6188eb5 RabbitMQ.Client.Impl.Frame.ReadFrom(RabbitMQ.Util.NetworkBinaryReader)
    PARAMETERS:
        reader (&lt;/span&gt;&amp;lt;CLR reg&amp;gt;) = &lt;span&gt;0x000000d79a3c2f70&lt;/span&gt;&lt;span&gt;
    LOCALS:
        &lt;/span&gt;&amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;&lt;span&gt;

000000d7b927ecb0 00007ffdf6188e13 RabbitMQ.Client.Impl.SocketFrameHandler.ReadFrame()
    PARAMETERS:
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; = &amp;lt;no data&amp;gt;&lt;span&gt;
    LOCALS:
        &lt;/span&gt;&amp;lt;no data&amp;gt;
        &lt;span&gt;0x000000d7b927ece0&lt;/span&gt; = &lt;span&gt;0x0000000000000000&lt;/span&gt;
        &lt;span&gt;0x000000d7b927ecd8&lt;/span&gt; = &lt;span&gt;0x000000d79a3c2f70&lt;/span&gt;&lt;span&gt;

000000d7b927ed10 00007ffdf6188cfc RabbitMQ.Client.Framing.Impl.Connection.MainLoopIteration()
    PARAMETERS:
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; (&amp;lt;CLR reg&amp;gt;) = &lt;span&gt;0x000000d79a3c31b8&lt;/span&gt;&lt;span&gt;
    LOCALS:
        &lt;/span&gt;&amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;&lt;span&gt;

000000d7b927ed50 00007ffdf6188a9f RabbitMQ.Client.Framing.Impl.Connection.MainLoop()
    PARAMETERS:
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; (&lt;span&gt;0x000000d7b927edb0&lt;/span&gt;) = &lt;span&gt;0x000000d79a3c31b8&lt;/span&gt;&lt;span&gt;
    LOCALS:
        &lt;/span&gt;&lt;span&gt;0x000000d7b927ed8c&lt;/span&gt; = &lt;span&gt;0x0000000000000000&lt;/span&gt;
        &amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;&lt;span&gt;

000000d7b927edb0 00007ffe53e34740 System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ &lt;/span&gt;&lt;span&gt;954&lt;/span&gt;&lt;span&gt;]
    PARAMETERS:
        executionContext &lt;/span&gt;= &amp;lt;no data&amp;gt;&lt;span&gt;
        callback &lt;/span&gt;= &amp;lt;no data&amp;gt;&lt;span&gt;
        state &lt;/span&gt;= &amp;lt;no data&amp;gt;&lt;span&gt;
        preserveSyncCtx &lt;/span&gt;= &amp;lt;no data&amp;gt;&lt;span&gt;
    LOCALS:
        &lt;/span&gt;&amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;
        &amp;lt;no data&amp;gt;&lt;span&gt;

000000d7b927ee80 00007ffe53e345d4 System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ &lt;/span&gt;&lt;span&gt;902&lt;/span&gt;&lt;span&gt;]
    PARAMETERS:
        executionContext &lt;/span&gt;= &amp;lt;no data&amp;gt;&lt;span&gt;
        callback &lt;/span&gt;= &amp;lt;no data&amp;gt;&lt;span&gt;
        state &lt;/span&gt;= &amp;lt;no data&amp;gt;&lt;span&gt;
        preserveSyncCtx &lt;/span&gt;= &amp;lt;no data&amp;gt;&lt;span&gt;

000000d7b927eeb0 00007ffe53e345a2 System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ &lt;/span&gt;&lt;span&gt;891&lt;/span&gt;&lt;span&gt;]
    PARAMETERS:
        executionContext &lt;/span&gt;= &amp;lt;no data&amp;gt;&lt;span&gt;
        callback &lt;/span&gt;= &amp;lt;no data&amp;gt;&lt;span&gt;
        state &lt;/span&gt;= &amp;lt;no data&amp;gt;&lt;span&gt;

000000d7b927ef00 00007ffe53ebcf62 System.Threading.ThreadHelper.ThreadStart() [f:\dd\ndp\clr\src\BCL\system\threading\thread.cs @ &lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;]
    PARAMETERS:
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; = &amp;lt;no data&amp;gt;&lt;span&gt;

000000d7b927f158 00007ffe55325a03 [GCFrame: 000000d7b927f158] 
000000d7b927f4a8 00007ffe55325a03 [DebuggerU2MCatchHandlerFrame: 000000d7b927f4a8] &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;能看到部分参数的内存地址，但是很多是no data，这样的话，我们尝试用另一个命令，查询线程上下文中的所有变量信息：　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;!dso&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;032&lt;/span&gt;&amp;gt; &lt;span&gt;&lt;strong&gt;!&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;dso&lt;/strong&gt;&lt;/span&gt;
OS Thread Id: &lt;/span&gt;&lt;span&gt;0x15968&lt;/span&gt; (&lt;span&gt;32&lt;/span&gt;&lt;span&gt;)
RSP&lt;/span&gt;/&lt;span&gt;REG          Object           Name
000000D7B927E8D0 000000d79aedb7a8 System.Net.Sockets.SocketException
000000D7B927E948 000000d79aedb7a8 System.Net.Sockets.SocketException
000000D7B927E9A8 000000d79aedb7a8 System.Net.Sockets.SocketException
000000D7B927E9B0 000000d79aedb7a8 System.Net.Sockets.SocketException
000000D7B927E9E0 000000d79aedb7a8 System.Net.Sockets.SocketException
000000D7B927E9F0 000000d79aedb7a8 System.Net.Sockets.SocketException
000000D7B927EA78 000000d79aedb850 System.Text.StringBuilder
000000D7B927EAC0 000000d79aedb850 System.Text.StringBuilder
000000D7B927EAD0 000000d79aedb7a8 System.Net.Sockets.SocketException
000000D7B927EAD8 000000d79aedb7a8 System.Net.Sockets.SocketException
000000D7B927EB20 000000d79aedb7a8 System.Net.Sockets.SocketException
000000D7B927EB30 000000d79a3c2ed8 System.Net.Sockets.NetworkStream
000000D7B927EB60 000000d79a809eb0 System.Byte[]
000000D7B927EB70 000000d799fd1420 System.String    
000000D7B927EB78 000000d79aeda2e8 RabbitMQ.Client.Framing.BasicProperties
000000D7B927EB80 000000d79aeda568 System.Byte[]
000000D7B927EBB0 000000d79a017a90 System.Threading.ContextCallback
000000D7B927EBB8 000000d79a3c2f18 System.IO.BufferedStream
000000D7B927EBC0 000000d79a3c2f70 RabbitMQ.Util.NetworkBinaryReader
000000D7B927EBC8 000000d79a3c3ff0 System.Threading.ThreadHelper
000000D7B927EBF0 000000d79aeda0a8 System.String    HSF&lt;/span&gt;-&lt;span&gt;ServiceState
000000D7B927EBF8 000000d799fd1420 System.String    
000000D7B927EC00 000000d79a3c2f70 RabbitMQ.Util.NetworkBinaryReader
000000D7B927EC10 000000d79aeda2e8 RabbitMQ.Client.Framing.BasicProperties
000000D7B927EC20 000000d79aeda2e8 RabbitMQ.Client.Framing.BasicProperties
000000D7B927EC28 000000d79a017a90 System.Threading.ContextCallback
000000D7B927EC30 000000d79a3c6a00 RabbitMQ.Client.Framing.Impl.Model
000000D7B927EC50 000000d79a3c3ff0 System.Threading.ThreadHelper
000000D7B927EC78 000000d79a017a90 System.Threading.ContextCallback
000000D7B927EC80 000000d79a3c2bc0 RabbitMQ.Client.Impl.SocketFrameHandler
000000D7B927EC88 000000d79a3c2f70 RabbitMQ.Util.NetworkBinaryReader
000000D7B927EC90 000000d79a3c3ff0 System.Threading.ThreadHelper
000000D7B927ECB0 000000d79a017a90 System.Threading.ContextCallback
000000D7B927ECC0 000000d79a3c6688 RabbitMQ.Client.Impl.Session
000000D7B927ECC8 000000d79aedb430 RabbitMQ.Client.Impl.Frame
000000D7B927ECD8 000000d79a3c2f70 RabbitMQ.Util.NetworkBinaryReader
000000D7B927ECF0 000000d79a3c31b8 RabbitMQ.Client.Framing.Impl.Connection
000000D7B927ED80 000000d79a017a90 System.Threading.ContextCallback
000000D7B927EDB0 000000d79a3c31b8 RabbitMQ.Client.Framing.Impl.Connection
000000D7B927EDF0 000000d79a3c3f90 System.Threading.Thread
000000D7B927EE48 000000d79a3c3ff0 System.Threading.ThreadHelper
000000D7B927EE50 000000d79a3c4150 System.Threading.ExecutionContext
000000D7B927EE58 000000d79a017a90 System.Threading.ContextCallback
000000D7B927EEE8 000000d79a3c3ff0 System.Threading.ThreadHelper
000000D7B927EEF0 000000d79a3c4150 System.Threading.ExecutionContext
000000D7B927F100 000000d79a3c4018 System.Threading.ThreadStart&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 线程上下文中所有的变量的内存地址，我们都能看到，接下来看每个对象的信息，大家应该都会用了  !do objectAddress， 如果加载的Mex插件，可以用牛逼的  !do2&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;032&lt;/span&gt;&amp;gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;&lt;span&gt;do2 000000d79a3c6688&lt;/span&gt; 
&lt;/span&gt;&lt;span&gt;0x000000d79a3c6688&lt;/span&gt;&lt;span&gt; RabbitMQ.Client.Impl.Session
  &lt;/span&gt;&lt;span&gt;0000&lt;/span&gt;&lt;span&gt;  _shutdownLock                    : 000000d79a3c66d0 (System.Object)
  &lt;/span&gt;&lt;span&gt;0008&lt;/span&gt;  _sessionShutdown                 : 000000d79a3c6cf8 (System.EventHandler&amp;lt;RabbitMQ.Client.ShutdownEventArgs&amp;gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;0010&lt;/span&gt;  &amp;lt;CloseReason&amp;gt;&lt;span&gt;k__BackingField     : NULL
  &lt;/span&gt;&lt;span&gt;0018&lt;/span&gt;  &amp;lt;CommandReceived&amp;gt;k__BackingField : 000000d79a3c6c50 (System.Action&amp;lt;RabbitMQ.Client.Impl.ISession,RabbitMQ.Client.Impl.Command&amp;gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;0020&lt;/span&gt;  &amp;lt;Connection&amp;gt;&lt;span&gt;k__BackingField      : 000000d79a3c31b8 (RabbitMQ.Client.Framing.Impl.Connection)
  &lt;/span&gt;&lt;span&gt;0028&lt;/span&gt;  &amp;lt;ChannelNumber&amp;gt;k__BackingField   : &lt;span&gt;1&lt;/span&gt;&lt;span&gt; (System.Int32)
  &lt;/span&gt;&lt;span&gt;0030&lt;/span&gt;&lt;span&gt;  m_assembler                      : 000000d79a3c6790 (RabbitMQ.Client.Impl.CommandAssembler)
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;032&lt;/span&gt;&amp;gt; &lt;span&gt;!do&lt;/span&gt;&lt;span&gt;&lt;span&gt; 000000d79a3c6688&lt;/span&gt; 
Name:        RabbitMQ.Client.Impl.Session
MethodTable: 00007ffdf6257888
EEClass:     00007ffdf6264ce8
Size:        &lt;/span&gt;&lt;span&gt;72&lt;/span&gt;(&lt;span&gt;0x48&lt;/span&gt;&lt;span&gt;) bytes
File:        C:\TeldApp\HSF\HSF.Host&lt;/span&gt;-BillCM-&lt;span&gt;9086&lt;/span&gt;&lt;span&gt;\RabbitMQ.Client.dll
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ffe53fd6fd8  &lt;/span&gt;&lt;span&gt;4000283&lt;/span&gt;        &lt;span&gt;8&lt;/span&gt;        System.Object  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c66d0 _shutdownLock
00007ffdf6250760  &lt;/span&gt;&lt;span&gt;4000284&lt;/span&gt;       &lt;span&gt;10&lt;/span&gt; ...RabbitMQ.Client]]  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c6cf8 _sessionShutdown
00007ffe53fd9428  &lt;/span&gt;&lt;span&gt;4000285&lt;/span&gt;       &lt;span&gt;30&lt;/span&gt;         System.Int32  &lt;span&gt;1&lt;/span&gt; instance                &lt;span&gt;1&lt;/span&gt; &amp;lt;ChannelNumber&amp;gt;&lt;span&gt;k__BackingField
00007ffdf62506c0  &lt;/span&gt;&lt;span&gt;4000286&lt;/span&gt;       &lt;span&gt;18&lt;/span&gt; ...ShutdownEventArgs  &lt;span&gt;0&lt;/span&gt; instance &lt;span&gt;0000000000000000&lt;/span&gt; &amp;lt;CloseReason&amp;gt;&lt;span&gt;k__BackingField
00007ffdf6272e78  &lt;/span&gt;&lt;span&gt;4000287&lt;/span&gt;       &lt;span&gt;20&lt;/span&gt; ...RabbitMQ.Client]]  &lt;span&gt;0&lt;/span&gt; instance 000000d79a3c6c50 &amp;lt;CommandReceived&amp;gt;&lt;span&gt;k__BackingField
00007ffdf62549a0  &lt;/span&gt;&lt;span&gt;4000288&lt;/span&gt;       &lt;span&gt;28&lt;/span&gt; ...g.Impl.Connection  &lt;span&gt;0&lt;/span&gt; instance &lt;strong&gt;&lt;span&gt;000000d79a3c31b8&lt;/span&gt; &lt;/strong&gt;&amp;lt;Connection&amp;gt;&lt;span&gt;k__BackingField
00007ffdf62713b0  &lt;/span&gt;&lt;span&gt;4000289&lt;/span&gt;       &lt;span&gt;38&lt;/span&gt; ....CommandAssembler  &lt;span&gt;0&lt;/span&gt; instance 000000d79a3c6790 m_assembler
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们继续看Connection对象：000000d79a3c31b8 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;032&lt;/span&gt;&amp;gt; !&lt;span&gt;do&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 000000d79a3c31b8&lt;/span&gt; &lt;/strong&gt;
Name:        RabbitMQ.Client.Framing.Impl.Connection
MethodTable: 00007ffdf62549a0
EEClass:     00007ffdf6260b78
Size:        &lt;/span&gt;&lt;span&gt;232&lt;/span&gt;(&lt;span&gt;0xe8&lt;/span&gt;&lt;span&gt;) bytes
File:        C:\TeldApp\HSF\HSF.Host&lt;/span&gt;-BillCM-&lt;span&gt;9086&lt;/span&gt;&lt;span&gt;\RabbitMQ.Client.dll
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ffe53fd6fd8  &lt;/span&gt;&lt;span&gt;4000247&lt;/span&gt;        &lt;span&gt;8&lt;/span&gt;        System.Object  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c32a0 m_eventLock
00007ffdf6257c48  &lt;/span&gt;&lt;span&gt;4000248&lt;/span&gt;       &lt;span&gt;10&lt;/span&gt; ...Client.Impl.Frame  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c32b8 m_heartbeatFrame
00007ffe53fe7378  &lt;/span&gt;&lt;span&gt;4000249&lt;/span&gt;       &lt;span&gt;18&lt;/span&gt; ....ManualResetEvent  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c32f8 m_appContinuation
&lt;/span&gt;&lt;span&gt;0000000000000000&lt;/span&gt;  400024a       &lt;span&gt;20&lt;/span&gt;                       &lt;span&gt;0&lt;/span&gt; instance &lt;span&gt;0000000000000000&lt;/span&gt;&lt;span&gt; m_callbackException
00007ffe53954820  400024b       &lt;/span&gt;&lt;span&gt;28&lt;/span&gt; ...bject, mscorlib]]  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c51d8 m_clientProperties
00007ffdf62506c0  400024c       &lt;/span&gt;&lt;span&gt;30&lt;/span&gt; ...ShutdownEventArgs  &lt;span&gt;0&lt;/span&gt; instance &lt;span&gt;0000000000000000&lt;/span&gt;&lt;span&gt; m_closeReason
00007ffe53ff9a38  400024d       c2       System.Boolean  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; instance                &lt;span&gt;0&lt;/span&gt;&lt;span&gt; m_closed
&lt;/span&gt;&lt;span&gt;0000000000000000&lt;/span&gt;  400024e       &lt;span&gt;38&lt;/span&gt;                       &lt;span&gt;0&lt;/span&gt; instance &lt;span&gt;0000000000000000&lt;/span&gt;&lt;span&gt; m_connectionBlocked
00007ffdf6250760  400024f       &lt;/span&gt;&lt;span&gt;40&lt;/span&gt; ...RabbitMQ.Client]]  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c6750 m_connectionShutdown
00007ffe53953ff0  &lt;/span&gt;&lt;span&gt;4000250&lt;/span&gt;       &lt;span&gt;48&lt;/span&gt; ...tArgs, mscorlib]]  &lt;span&gt;0&lt;/span&gt; instance &lt;span&gt;0000000000000000&lt;/span&gt;&lt;span&gt; m_connectionUnblocked
00007ffdf622f7d0  &lt;/span&gt;&lt;span&gt;4000251&lt;/span&gt;       &lt;span&gt;50&lt;/span&gt; ...ConnectionFactory  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c2698 m_factory
00007ffdf6255cb8  &lt;/span&gt;&lt;span&gt;4000252&lt;/span&gt;       &lt;span&gt;58&lt;/span&gt; ...mpl.IFrameHandler  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c2bc0 m_frameHandler
00007ffe53ff40a0  &lt;/span&gt;&lt;span&gt;4000253&lt;/span&gt;       c8          System.Guid  &lt;span&gt;1&lt;/span&gt;&lt;span&gt; instance 000000d79a3c3280 m_id
00007ffdf625a5d0  &lt;/span&gt;&lt;span&gt;4000254&lt;/span&gt;       &lt;span&gt;60&lt;/span&gt; ...nt.Impl.ModelBase  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c3860 m_model0
00007ffe53ff9a38  &lt;/span&gt;&lt;span&gt;4000255&lt;/span&gt;       c3       System.Boolean  &lt;span&gt;1&lt;/span&gt; instance                &lt;span&gt;1&lt;/span&gt;&lt;span&gt; m_running
00007ffdf6257a48  &lt;/span&gt;&lt;span&gt;4000256&lt;/span&gt;       &lt;span&gt;68&lt;/span&gt; ....Impl.MainSession  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c35f0 m_session0
00007ffdf6259050  &lt;/span&gt;&lt;span&gt;4000257&lt;/span&gt;       &lt;span&gt;70&lt;/span&gt; ...pl.SessionManager  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c6018 m_sessionManager
00007ffdf6258068  &lt;/span&gt;&lt;span&gt;4000258&lt;/span&gt;       &lt;span&gt;78&lt;/span&gt; ...RabbitMQ.Client]]  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c3370 m_shutdownReport
00007ffe53fd5570  &lt;/span&gt;&lt;span&gt;4000259&lt;/span&gt;       c0        System.UInt16  &lt;span&gt;1&lt;/span&gt; instance               &lt;span&gt;60&lt;/span&gt;&lt;span&gt; m_heartbeat
00007ffe53ff3f28  400025a       d8      System.TimeSpan  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; instance 000000d79a3c3290 m_heartbeatTimeSpan
00007ffe53fd9428  400025b       b8         System.Int32  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; instance                &lt;span&gt;0&lt;/span&gt;&lt;span&gt; m_missedHeartbeats
00007ffe53ff4248  400025c       &lt;/span&gt;&lt;span&gt;80&lt;/span&gt; ...m.Threading.Timer  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c61f0 _heartbeatWriteTimer
00007ffe53ff4248  400025d       &lt;/span&gt;&lt;span&gt;88&lt;/span&gt; ...m.Threading.Timer  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c6428 _heartbeatReadTimer
00007ffe53ff4de8  400025e       &lt;/span&gt;&lt;span&gt;90&lt;/span&gt; ...ng.AutoResetEvent  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c33a8 m_heartbeatRead
00007ffe53ff4de8  400025f       &lt;/span&gt;&lt;span&gt;98&lt;/span&gt; ...ng.AutoResetEvent  &lt;span&gt;0&lt;/span&gt;&lt;span&gt; instance 000000d79a3c33f8 m_heartbeatWrite
00007ffe53ff9a38  &lt;/span&gt;&lt;span&gt;4000260&lt;/span&gt;       c4       System.Boolean  &lt;span&gt;1&lt;/span&gt; instance                &lt;span&gt;0&lt;/span&gt;&lt;span&gt; m_inConnectionNegotiation
00007ffdf6258e90  &lt;/span&gt;&lt;span&gt;4000261&lt;/span&gt;       a0 ...nsumerWorkService  &lt;span&gt;0&lt;/span&gt; instance 000000d79a3c3448 &amp;lt;ConsumerWorkService&amp;gt;&lt;span&gt;k__BackingField
00007ffe53ff21f0  &lt;/span&gt;&lt;span&gt;4000262&lt;/span&gt;       bc        System.UInt32  &lt;span&gt;1&lt;/span&gt; instance           &lt;span&gt;131072&lt;/span&gt; &amp;lt;FrameMax&amp;gt;&lt;span&gt;k__BackingField
00007ffdf625ace0  &lt;/span&gt;&lt;span&gt;4000263&lt;/span&gt;       a8 ...AmqpTcpEndpoint[]  &lt;span&gt;0&lt;/span&gt; instance &lt;span&gt;0000000000000000&lt;/span&gt; &amp;lt;KnownHosts&amp;gt;&lt;span&gt;k__BackingField
00007ffe53954820  &lt;/span&gt;&lt;span&gt;4000264&lt;/span&gt;       b0 ...bject, mscorlib]]  &lt;span&gt;0&lt;/span&gt; instance 000000d79a3c5468 &amp;lt;ServerProperties&amp;gt;&lt;span&gt;k__BackingField
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;032&lt;/span&gt;&amp;gt; !&lt;span&gt;do2 000000d79a3c31b8 
&lt;/span&gt;&lt;span&gt;0x000000d79a3c31b8&lt;/span&gt;&lt;span&gt; RabbitMQ.Client.Framing.Impl.Connection
  &lt;/span&gt;&lt;span&gt;0000&lt;/span&gt;&lt;span&gt;  m_eventLock                          : 000000d79a3c32a0 (System.Object)
  &lt;/span&gt;&lt;span&gt;0008&lt;/span&gt;&lt;span&gt;  m_heartbeatFrame                     : 000000d79a3c32b8 (RabbitMQ.Client.Impl.Frame)
  &lt;/span&gt;&lt;span&gt;0010&lt;/span&gt;&lt;span&gt;  m_appContinuation                    : 000000d79a3c32f8 (System.Threading.ManualResetEvent)
  &lt;/span&gt;&lt;span&gt;0018&lt;/span&gt;&lt;span&gt;  m_callbackException                  : NULL
  &lt;/span&gt;&lt;span&gt;0020&lt;/span&gt;  m_clientProperties                   : 000000d79a3c51d8 (System.Collections.Generic.Dictionary&amp;lt;System.String,System.Object&amp;gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;0028&lt;/span&gt;&lt;span&gt;  m_closeReason                        : NULL
  &lt;/span&gt;&lt;span&gt;0030&lt;/span&gt;&lt;span&gt;  m_connectionBlocked                  : NULL
  &lt;/span&gt;&lt;span&gt;0038&lt;/span&gt;  m_connectionShutdown                 : 000000d79a3c6750 (System.EventHandler&amp;lt;RabbitMQ.Client.ShutdownEventArgs&amp;gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;0040&lt;/span&gt;&lt;span&gt;  m_connectionUnblocked                : NULL
  &lt;/span&gt;&lt;span&gt;0048&lt;/span&gt;&lt;span&gt;  m_factory                            : 000000d79a3c2698 (RabbitMQ.Client.ConnectionFactory)
  &lt;/span&gt;&lt;span&gt;0050&lt;/span&gt;&lt;span&gt;  m_frameHandler                       : 000000d79a3c2bc0 (RabbitMQ.Client.Impl.SocketFrameHandler)
  &lt;/span&gt;&lt;span&gt;0058&lt;/span&gt;&lt;span&gt;  m_model0                             : 000000d79a3c3860 (RabbitMQ.Client.Framing.Impl.Model)
  &lt;/span&gt;&lt;span&gt;0060&lt;/span&gt;&lt;span&gt;  m_session0                           : 000000d79a3c35f0 (RabbitMQ.Client.Impl.MainSession)
  &lt;/span&gt;&lt;span&gt;0068&lt;/span&gt;&lt;span&gt;  m_sessionManager                     : 000000d79a3c6018 (RabbitMQ.Client.Impl.SessionManager)
  &lt;/span&gt;&lt;span&gt;0070&lt;/span&gt;  m_shutdownReport                     : 000000d79a3c3370 (RabbitMQ.Util.SynchronizedList&amp;lt;RabbitMQ.Client.ShutdownReportEntry&amp;gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;0078&lt;/span&gt;&lt;span&gt;  _heartbeatWriteTimer                 : 000000d79a3c61f0 (System.Threading.Timer)
  &lt;/span&gt;&lt;span&gt;0080&lt;/span&gt;&lt;span&gt;  _heartbeatReadTimer                  : 000000d79a3c6428 (System.Threading.Timer)
  &lt;/span&gt;&lt;span&gt;0088&lt;/span&gt;&lt;span&gt;  m_heartbeatRead                      : 000000d79a3c33a8 (System.Threading.AutoResetEvent)
  &lt;/span&gt;&lt;span&gt;0090&lt;/span&gt;&lt;span&gt;  m_heartbeatWrite                     : 000000d79a3c33f8 (System.Threading.AutoResetEvent)
  &lt;/span&gt;&lt;span&gt;0098&lt;/span&gt;  &amp;lt;ConsumerWorkService&amp;gt;&lt;span&gt;k__BackingField : 000000d79a3c3448 (RabbitMQ.Client.ConsumerWorkService)
  00a0  &lt;/span&gt;&amp;lt;KnownHosts&amp;gt;&lt;span&gt;k__BackingField          : NULL
  00a8  &lt;/span&gt;&amp;lt;ServerProperties&amp;gt;k__BackingField    : 000000d79a3c5468 (System.Collections.Generic.Dictionary&amp;lt;System.String,System.Object&amp;gt;&lt;span&gt;)
  00b0  m_missedHeartbeats                   : &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; (System.Int32)
  00b4  &lt;/span&gt;&amp;lt;FrameMax&amp;gt;k__BackingField            : &lt;span&gt;131072&lt;/span&gt;&lt;span&gt; (System.UInt32)
  00b8  m_heartbeat                          : &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt; (System.UInt16)
  00ba  m_closed                             : False (System.Boolean)
  00bb  m_running                            : True (System.Boolean)
  00bc  m_inConnectionNegotiation            : False (System.Boolean)
  00c0  m_id                                 : 000000d79a3c3280 1c8d8e96&lt;/span&gt;-0c6a-4c62-84b7-&lt;span&gt;9feb241b67ad (System.Guid)
  00d0  m_heartbeatTimeSpan                  : 000000d79a3c3290 &lt;/span&gt;&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;15&lt;/span&gt; (System.TimeSpan)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似的，其他的内存变量也可以看，帮助我们分析问题。&lt;/p&gt;
&lt;p&gt;找到问题的大致原因后，我们需要禁用异常捕获，退出调试，&lt;strong&gt;&lt;span&gt;如果直接关闭Windbg，此时附加调试的进程就被强制退出了，一定要注意，请使用下面的指令：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6. 禁用异常捕获 sxd clr&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;7. 退出调试 qd&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sxd  clr
qd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上就是跟大家分享的附加进程实时调试，总结一下套路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;F6 Attache进程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加载SOS, .loadby sos clr&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启用异常捕获 sxe clr&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行，捕获&amp;amp;查看异常 g  !pe&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查看异常所在线程堆栈!clrstack, 查看异常所在线程堆栈的参数和变量 !clrstack -a / !dso&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;禁用异常捕获 sxd clr&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;退出调试 qd&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;分享给大家。&lt;/p&gt;

&lt;p&gt;周国庆&lt;/p&gt;
&lt;p&gt;2018/11/4&lt;/p&gt;
</description>
<pubDate>Sun, 04 Nov 2018 23:03:00 +0000</pubDate>
<dc:creator>Eric zhou</dc:creator>
<og:description>上篇博文中给大家分享了使用Windbg分析线程阻塞问题： Windbg程序调试系列3-线程阻塞问题 本篇中我们继续，跟大家分享附加进程实时调试-Live Debugging。 先说一下使用Windbg</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tianqing/p/9905738.html</dc:identifier>
</item>
<item>
<title>Oracle之SQL优化专题02-稳固SQL执行计划的方法 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/9906932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/9906932.html</guid>
<description>&lt;p&gt;首先构建一个简单的测试用例来实际演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table emp as select * from scott.emp;
create table dept as select * from scott.dept;
create index idx_emp_empno on emp(empno);
create index idx_dept_deptno on dept(deptno);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试过程中查看真实执行计划的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set lines 1000 pages 1000
alter session set statistics_level = ALL;
Execute SQL;
select * from table(dbms_xplan.display_cursor(null,null,'allstats last'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正常的SQL执行，执行计划会走相应的索引：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--good SQL: 39dv3d8jkzyuw
select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7788;

--good xplan: 1725450077
SQL&amp;gt; select * from table(dbms_xplan.display_cursor(null,null,'allstats last'));

PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SQL_ID  39dv3d8jkzyuw, child number 0
-------------------------------------
select a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where
a.deptno = b.deptno and empno = 7788

Plan hash value: 1725450077

--------------------------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name            | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
--------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |                 |      1 |        |      1 |00:00:00.01 |       6 |      2 |
|   1 |  NESTED LOOPS                 |                 |      1 |      1 |      1 |00:00:00.01 |       6 |      2 |
|   2 |   NESTED LOOPS                |                 |      1 |      1 |      1 |00:00:00.01 |       5 |      2 |
|   3 |    TABLE ACCESS BY INDEX ROWID| EMP             |      1 |      1 |      1 |00:00:00.01 |       3 |      1 |
|*  4 |     INDEX RANGE SCAN          | IDX_EMP_EMPNO   |      1 |      1 |      1 |00:00:00.01 |       2 |      1 |
|*  5 |    INDEX RANGE SCAN           | IDX_DEPT_DEPTNO |      1 |      1 |      1 |00:00:00.01 |       2 |      1 |
|   6 |   TABLE ACCESS BY INDEX ROWID | DEPT            |      1 |      1 |      1 |00:00:00.01 |       1 |      0 |
--------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access(&quot;EMPNO&quot;=7788)
   5 - access(&quot;A&quot;.&quot;DEPTNO&quot;=&quot;B&quot;.&quot;DEPTNO&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;糟糕的SQL执行，执行计划走全表扫描（这里实验直接利用使用hint强制不走索引来模拟这种情况）:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--bad SQL: dqd10y7wqrg7f
select /*+ no_index(a idx_emp_empno) no_index(b idx_dept_deptno)*/a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7788;

--bad xplan: 1123238657
SQL&amp;gt; select * from table(dbms_xplan.display_cursor(null,null,'allstats last'));

PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SQL_ID  dqd10y7wqrg7f, child number 1
-------------------------------------
select /*+ no_index(a idx_emp_empno) no_index(b
idx_dept_deptno)*/a.empno, a.ename, b.dname, a.job, a.sal from emp a,
dept b where a.deptno = b.deptno and empno = 7788

Plan hash value: 1123238657

----------------------------------------------------------------------------------------------------------------
| Id  | Operation          | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
----------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |      1 |        |      1 |00:00:00.01 |       5 |       |       |          |
|*  1 |  HASH JOIN         |      |      1 |      1 |      1 |00:00:00.01 |       5 |  1214K|  1214K|  377K (0)|
|*  2 |   TABLE ACCESS FULL| EMP  |      1 |      1 |      1 |00:00:00.01 |       2 |       |       |          |
|   3 |   TABLE ACCESS FULL| DEPT |      1 |      4 |      4 |00:00:00.01 |       3 |       |       |          |
----------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access(&quot;A&quot;.&quot;DEPTNO&quot;=&quot;B&quot;.&quot;DEPTNO&quot;)
   2 - filter(&quot;EMPNO&quot;=7788)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设此时这些糟糕的SQL就是业务实际的SQL，且对应开发人员无法更改SQL文本（这里就是指无法去掉不走索引的hint），那么现在如何能将这些糟糕的SQL绑定成走索引的执行计划呢？&lt;br/&gt;糟糕的SQL清单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select /*+ no_index(a idx_emp_empno) no_index(b idx_dept_deptno)*/a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7788;

select /*+ no_index(a idx_emp_empno) no_index(b idx_dept_deptno)*/a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7900;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如何让其走索引？目前Oracle常见的2种稳固执行计划的方式：&lt;/p&gt;

&lt;p&gt;适用于Oracle 10g及以上版本。&lt;br/&gt;利用MOS文档215187.1提供的系列脚本中的coe_xfr_sql_profile.sql来稳固执行计划，只需要输入要调整SQL的SQL_ID和好的执行计划的plan_hash_value即可，脚本内容可参考：&lt;/p&gt;
&lt;p&gt;在本次演示实验中，就是将sql_id='dqd10y7wqrg7f'的SQL绑定好的plan_hash_value=1725450077，具体使用过程如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; @coe_xfr_sql_profile.sql

Parameter 1:
SQL_ID (required)

Enter value for 1: dqd10y7wqrg7f


PLAN_HASH_VALUE AVG_ET_SECS
--------------- -----------
     1123238657        .095

Parameter 2:
PLAN_HASH_VALUE (required)

Enter value for 2: 1725450077

Values passed to coe_xfr_sql_profile:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SQL_ID         : &quot;dqd10y7wqrg7f&quot;
PLAN_HASH_VALUE: &quot;1725450077&quot;
...
Execute coe_xfr_sql_profile_dqd10y7wqrg7f_1725450077.sql
on TARGET system in order to create a custom SQL Profile
with plan 1725450077 linked to adjusted sql_text.


COE_XFR_SQL_PROFILE completed.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后按照提示执行生成的&lt;code&gt;coe_xfr_sql_profile_dqd10y7wqrg7f_1725450077.sql&lt;/code&gt;脚本即可；&lt;br/&gt;需要特别注意的是：可以根据实际情况是否需要修改这个脚本中的force_match的值为true。&lt;br/&gt;本次的例子，就是没有使用到绑定变量，而需求是不仅让empno = 7788的条件走索引，还要让其他输入值，比如empno = 7900也同样走索引，那就需要修改这个force_match的值为true。稳固执行计划的效果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; select /*+ no_index(a idx_emp_empno) no_index(b idx_dept_deptno)*/a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7788;

     EMPNO ENAME      DNAME          JOB              SAL
---------- ---------- -------------- --------- ----------
      7788 SCOTT      RESEARCH       ANALYST         3000

SQL&amp;gt; select * from table(dbms_xplan.display_cursor(null,null,'allstats last'));

PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SQL_ID  dqd10y7wqrg7f, child number 0
-------------------------------------
select /*+ no_index(a idx_emp_empno) no_index(b
idx_dept_deptno)*/a.empno, a.ename, b.dname, a.job, a.sal from emp a,
dept b where a.deptno = b.deptno and empno = 7788

Plan hash value: 1725450077

-----------------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name            | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |                 |      1 |        |      1 |00:00:00.01 |       6 |
|   1 |  NESTED LOOPS                 |                 |      1 |      1 |      1 |00:00:00.01 |       6 |
|   2 |   NESTED LOOPS                |                 |      1 |      1 |      1 |00:00:00.01 |       5 |
|   3 |    TABLE ACCESS BY INDEX ROWID| EMP             |      1 |      1 |      1 |00:00:00.01 |       3 |
|*  4 |     INDEX RANGE SCAN          | IDX_EMP_EMPNO   |      1 |      1 |      1 |00:00:00.01 |       2 |
|*  5 |    INDEX RANGE SCAN           | IDX_DEPT_DEPTNO |      1 |      1 |      1 |00:00:00.01 |       2 |
|   6 |   TABLE ACCESS BY INDEX ROWID | DEPT            |      1 |      1 |      1 |00:00:00.01 |       1 |
-----------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access(&quot;EMPNO&quot;=7788)
   5 - access(&quot;A&quot;.&quot;DEPTNO&quot;=&quot;B&quot;.&quot;DEPTNO&quot;)

Note
-----
   - SQL profile coe_dqd10y7wqrg7f_1725450077 used for this statement&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;常用操作：&lt;/strong&gt;&lt;br/&gt;1)查询sql_profile&lt;br/&gt;可以通过查询dba_sql_profiles来确认数据库中的sql_profile：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from dba_sql_profiles;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2)删除sql_profile&lt;br/&gt;如果有一天不再需要这个sql_profile来稳固执行计划，可以这样删除sql_profile：&lt;br/&gt;exec dbms_sqltune.drop_sql_profile('name');&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exec dbms_sqltune.drop_sql_profile('coe_dqd10y7wqrg7f_1725450077');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3)清除SQL执行计划&lt;br/&gt;还可以清除共享池中指定SQL的执行计划：&lt;br/&gt;exec sys.dbms_shared_pool.purge('address,hash_value','c');&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; select sql_id, address, hash_value, plan_hash_value, sql_profile from v$sql where sql_id = 'dqd10y7wqrg7f';

SQL_ID        ADDRESS          HASH_VALUE PLAN_HASH_VALUE SQL_PROFILE
------------- ---------------- ---------- --------------- ----------------------------------------------------------------
dqd10y7wqrg7f 0000000076B909F8 4184587502      1123238657
dqd10y7wqrg7f 0000000076B909F8 4184587502      1123238657
dqd10y7wqrg7f 0000000076B909F8 4184587502      1725450077 coe_dqd10y7wqrg7f_1725450077

SQL&amp;gt; exec sys.dbms_shared_pool.purge('0000000076B909F8,4184587502','c');

PL/SQL procedure successfully completed.

SQL&amp;gt; select sql_id, address, hash_value, plan_hash_value, sql_profile from v$sql where sql_id = 'dqd10y7wqrg7f';

no rows selected&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;适用于Oracle 11g及以上版本。&lt;br/&gt;删除掉之前的sql_profile，尝试使用SPM来稳固执行计划，实际上，手工生成sql_plan_baseline的方式要更加灵活，但我实际用的比较少。&lt;br/&gt;查看sql_plan_baselines：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from dba_sql_plan_baselines;
select sql_handle, plan_name, origin, enabled, accepted, fixed from dba_sql_plan_baselines;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SPM稳固执行计划方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var temp number
--1.bad: sql_id &amp;amp; plan_hash_value
exec :temp := dbms_spm.load_plans_from_cursor_cache(sql_id =&amp;gt; '', plan_hash_value =&amp;gt; );
--2.good: sql_id &amp;amp; plan_hash_value &amp;amp; sql_handle
exec :temp := dbms_spm.load_plans_from_cursor_cache(sql_id =&amp;gt; '', plan_hash_value =&amp;gt; , sql_handle =&amp;gt; );
--3.drop bad plan_name
exec :temp := dbms_spm.drop_sql_plan_baseline(sql_handle =&amp;gt; '', plan_name =&amp;gt; '');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用上面的例子具体说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--1.bad: sql_id &amp;amp; plan_hash_value
SQL&amp;gt; var temp number
SQL&amp;gt; exec :temp := dbms_spm.load_plans_from_cursor_cache(sql_id =&amp;gt; 'dqd10y7wqrg7f', plan_hash_value =&amp;gt; 1123238657);
SQL&amp;gt;  select sql_handle, plan_name, origin, enabled, accepted, fixed from dba_sql_plan_baselines;

SQL_HANDLE                     PLAN_NAME                      ORIGIN         ENA ACC FIX
------------------------------ ------------------------------ -------------- --- --- ---
SQL_9c3626a309e5e8bd           SQL_PLAN_9sdj6nc4ybu5x96fd8705 MANUAL-LOAD    YES YES NO

--2.good: sql_id &amp;amp; plan_hash_value &amp;amp; sql_handle（上面查到的）
SQL&amp;gt; exec :temp := dbms_spm.load_plans_from_cursor_cache(sql_id =&amp;gt; '39dv3d8jkzyuw', plan_hash_value =&amp;gt;1725450077, sql_handle =&amp;gt; 'SQL_9c3626a309e5e8bd');

PL/SQL procedure successfully completed.

SQL&amp;gt;  select sql_handle, plan_name, origin, enabled, accepted, fixed from dba_sql_plan_baselines;

SQL_HANDLE                     PLAN_NAME                      ORIGIN         ENA ACC FIX
------------------------------ ------------------------------ -------------- --- --- ---
SQL_9c3626a309e5e8bd           SQL_PLAN_9sdj6nc4ybu5x2b78d17a MANUAL-LOAD    YES YES NO
SQL_9c3626a309e5e8bd           SQL_PLAN_9sdj6nc4ybu5x96fd8705 MANUAL-LOAD    YES YES NO

--3.drop bad plan_name
SQL&amp;gt; exec :temp := dbms_spm.drop_sql_plan_baseline(sql_handle =&amp;gt; 'SQL_9c3626a309e5e8bd', plan_name =&amp;gt; 'SQL_PLAN_9sdj6nc4ybu5x96fd8705');

PL/SQL procedure successfully completed.

SQL&amp;gt; select sql_handle, plan_name, origin, enabled, accepted, fixed from dba_sql_plan_baselines;

SQL_HANDLE                     PLAN_NAME                      ORIGIN         ENA ACC FIX
------------------------------ ------------------------------ -------------- --- --- ---
SQL_9c3626a309e5e8bd           SQL_PLAN_9sdj6nc4ybu5x2b78d17a MANUAL-LOAD    YES YES NO
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证稳固执行计划的效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; select /*+ no_index(a idx_emp_empno) no_index(b idx_dept_deptno)*/a.empno, a.ename, b.dname, a.job, a.sal from emp a, dept b where a.deptno = b.deptno and empno = 7788;

     EMPNO ENAME      DNAME          JOB              SAL
---------- ---------- -------------- --------- ----------
      7788 SCOTT      RESEARCH       ANALYST         3000

SQL&amp;gt; select * from table(dbms_xplan.display_cursor(null,null,'allstats last'));

PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SQL_ID  dqd10y7wqrg7f, child number 1
-------------------------------------
select /*+ no_index(a idx_emp_empno) no_index(b
idx_dept_deptno)*/a.empno, a.ename, b.dname, a.job, a.sal from emp a,
dept b where a.deptno = b.deptno and empno = 7788

Plan hash value: 1725450077

-----------------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name            | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |                 |      1 |        |      1 |00:00:00.01 |       6 |
|   1 |  NESTED LOOPS                 |                 |      1 |      1 |      1 |00:00:00.01 |       6 |
|   2 |   NESTED LOOPS                |                 |      1 |      1 |      1 |00:00:00.01 |       5 |
|   3 |    TABLE ACCESS BY INDEX ROWID| EMP             |      1 |      1 |      1 |00:00:00.01 |       3 |
|*  4 |     INDEX RANGE SCAN          | IDX_EMP_EMPNO   |      1 |      1 |      1 |00:00:00.01 |       2 |
|*  5 |    INDEX RANGE SCAN           | IDX_DEPT_DEPTNO |      1 |      1 |      1 |00:00:00.01 |       2 |
|   6 |   TABLE ACCESS BY INDEX ROWID | DEPT            |      1 |      1 |      1 |00:00:00.01 |       1 |
-----------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access(&quot;EMPNO&quot;=7788)
   5 - access(&quot;A&quot;.&quot;DEPTNO&quot;=&quot;B&quot;.&quot;DEPTNO&quot;)

Note
-----
   - SQL plan baseline SQL_PLAN_9sdj6nc4ybu5x2b78d17a used for this statement&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到SPM已经起作用了。但如果谓词条件换成7900，就会不起作用。我没有找到SPM中类似像sql_profile中force_match的参数，日常工作中也是使用sql_profile稳固执行计划多一些。&lt;br/&gt;另外注意dba_sql_plan_baselines中记录的执行计划对应的ACCEPTED和ENABLE的值都为YES，才可能会被SQL使用。&lt;br/&gt;&lt;strong&gt;常用操作：&lt;/strong&gt;&lt;br/&gt;select sql_handle, plan_name, origin, enabled, accepted, fixed from dba_sql_plan_baselines;&lt;br/&gt;1)将ENABLE的值设为&quot;YES&quot; or &quot;NO&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var temp number
exec :temp := dbms_spm.alter_sql_plan_baseline(sql_handle =&amp;gt; 'SQL_9c3626a309e5e8bd', plan_name =&amp;gt; 'SQL_PLAN_9sdj6nc4ybu5x96fd8705', attribute_name =&amp;gt; 'ENABLED', attribute_value =&amp;gt; 'YES');

var temp number
exec :temp := dbms_spm.alter_sql_plan_baseline(sql_handle =&amp;gt; 'SQL_9c3626a309e5e8bd', plan_name =&amp;gt; 'SQL_PLAN_9sdj6nc4ybu5x96fd8705', attribute_name =&amp;gt; 'ENABLED', attribute_value =&amp;gt; 'NO');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2)将ACCEPTED值设为&quot;YES&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var temp clob
exec :temp := dbms_spm.evolve_sql_plan_baseline(sql_handle =&amp;gt; 'SQL_9c3626a309e5e8bd', plan_name =&amp;gt; 'SQL_PLAN_9sdj6nc4ybu5x96fd8705', verify =&amp;gt; 'NO', commit =&amp;gt; 'YES');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：我这里测试(在11.2.0.4环境下)发现ACCEPTED值设为&quot;YES&quot;后，无法再设置成&quot;NO&quot;，而ENABLED的值可以自由设置为&quot;YES&quot; or &quot;NO&quot;。&lt;/p&gt;
</description>
<pubDate>Sun, 04 Nov 2018 19:32:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>首先构建一个简单的测试用例来实际演示： 测试过程中查看真实执行计划的方法： 正常的SQL执行，执行计划会走相应的索引： 糟糕的SQL执行，执行计划走全表扫描（这里实验直接利用使用hint强制不走索引来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/9906932.html</dc:identifier>
</item>
<item>
<title>Redis常用数据类型和事物以及并发 - palapala</title>
<link>http://www.cnblogs.com/ssskkk/p/9901974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ssskkk/p/9901974.html</guid>
<description>&lt;h3&gt;Redis数据类型&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;基本类型(String int)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如 set key value 、get key 等 所有命令都是按照 key value&lt;/p&gt;
&lt;p&gt;keys * 可以将全部数据列出，其中后面的 &quot; * &quot; 表示数据的匹配。&lt;/p&gt;
&lt;p&gt;setnx key value 不覆盖设置，返回0表示失败(原来这个key已经有值)，返回1表示成功。&lt;/p&gt;
&lt;p&gt;setex key time value 设置数据保存的有效时间(time 单位是秒) &lt;/p&gt;
&lt;p&gt;ttl key 查看当前数据的有效时间&lt;/p&gt;
&lt;p&gt;flushdb 清空仓库数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基本类型适合用户进行短期的数据存储&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Hash数据类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其保存的数据结构为 &quot;key=value&quot;&lt;/p&gt;
&lt;p&gt;举例：保存一个用户的用户名、真实姓名、密码，&lt;/p&gt;
&lt;p&gt;hset user-&lt;span&gt;admin&lt;/span&gt; &lt;span&gt;username&lt;/span&gt; &lt;span&gt;&lt;span&gt;admin&lt;/span&gt;   &lt;/span&gt;hset user-admin &lt;span&gt;name xiaoming&lt;/span&gt;   hset user-admin &lt;span&gt;password 123456&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;取得用户名)hget user-admin username&lt;/p&gt;
&lt;p&gt;取得真实姓名hget user-admin name&lt;/p&gt;
&lt;p&gt;取得密码 hget user-admin password&lt;/p&gt;
&lt;p&gt;有了Hash之后 Redis的数据类型可以和JAVA中VO匹配的上(都是key-value格式)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;hash类型存在的意义不大，因为基本类型做JSON存储也可以达到hash的效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;List数据类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;List是一个链表结构，链表结构的时间复杂度是n&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举例：创建一个List并设置若干个内容。lpush testList  test1 test2 test3(testList是集合的名字，后面的是集合存储的数据)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进行指定范围的链表数据输出(链表是不能通过index查询的) lrange testList 0 1 返回 &lt;span&gt;test3 test2 (栈 先进后出)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lrange testList 0 -1表示输出全部的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以利用List类型实现消息队列或者缓冲的功能，在实际开发之中有很多公司可能不直接使用消息队列中间件，而直接利用Redis代替&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Set 数据类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以实现集合的比对处理，列如可以实现数据的交集，并集，插集(比如 微博中 共同关注好友，可能关注等。。。)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举例 sadd user a b c d e(向集合user&lt;/span&gt;中&lt;span&gt;追加五个元素)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;列出所有元素 smembers &lt;span&gt;(set集合无序)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;删除某个元素 srem user a&lt;/p&gt;
&lt;p&gt;返回两个集合的差集合 sdiff set1 set2(返回几个set1和set2的差集)&lt;/p&gt;
&lt;p&gt;保存差集的运行结果到另一个集合 &lt;strong&gt;sdiffstore存储集合key 集合key1 集合key2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该类型支持集合的运算 可用在相似度检测，好友推荐等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SortedSet集合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该集合算是Set集合的扩展，该集合可以保存一个分数，&lt;strong&gt;这个分数的操作就可以作为数据的统计结果出现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;追加有序集合数据：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;zadd 集合key  分数 内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据增长：zincrby 集合key 增长分数 内容&lt;/p&gt;
&lt;p&gt;根据分数取得指定范围的数据 zrangebyscore 集合 开始分数 结束分数 withscores&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SotedSet主要进行数据的流式分析(利用分数分析数据，比如一个商品浏览了多少次)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Redis事物处理&lt;/h3&gt;
&lt;p&gt;Redis支持事物处理，但是这种事物处理本身是存在有设计缺陷的。&lt;/p&gt;
&lt;p&gt;打开事物：multi&lt;/p&gt;
&lt;p&gt;取消事物：discard&lt;/p&gt;
&lt;p&gt;提交事物：exec&lt;/p&gt;
&lt;p&gt;支持举例： Multi ; set i =10; discard；因为取消了事物所以 i的值不会被set成10 所以Redis是支持事物的。&lt;/p&gt;
&lt;p&gt;缺陷举例 ：Multi ; set i=10; incr name; exec; 因为 name属性不是int 所以会出现报错：ERR Value is not an integer。&lt;span&gt;但是 这种情况i=10;会被正确的执行 存到Redis里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Redis事物不完美也可以说不支持事物，因为Redis设计之初是不考虑事物的。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Redis乐观锁&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ssskkk/p/8673374.html&quot; target=&quot;_blank&quot;&gt;大家都知道Mysql利用版本号字段实现乐观锁。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Redis乐观锁的处理比较简单 利用watch关键字监听redis的一些键即可，不需要增加处理列(也就是平时所说的版本号)&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;事物1&lt;/td&gt;
&lt;td&gt;事物2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;watch id; 进行该数据的监听&lt;/td&gt;
&lt;td&gt;watch id;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Multi;&lt;/td&gt;
&lt;td&gt;Multi;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;set id 100&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; set id 200;&lt;/td&gt;
&lt;td&gt;exec;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;exec;返回nil，表示本次更新失败&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;此时由于第二个事物更新了原始数据 id，那么就表示该原始数据上的一个标记列发生了变化(类似于Mysql的版本号)，当第一个事物更新的时候，会返回nil表示本次更新失败。&lt;/p&gt;
&lt;h3&gt;Redis主从&lt;/h3&gt;
&lt;p&gt;Redis主从其实是为了数据备份(不同于MySQL  MySQL主从有读写分离的功能)。&lt;/p&gt;
&lt;p&gt;当数据做出任何处理操作的时候都进行即时的备份，这种设计在Redis里面叫做主从设计 从服务器只是做数据备份 除此之外 什么都不做。常用 一主二从制。&lt;/p&gt;
&lt;p&gt;配置(大致说明)：&lt;/p&gt;
&lt;p&gt;1）主服务器配置不需要做出任何变化，我不关心你有多少从服务器&lt;/p&gt;
&lt;p&gt;2）编辑redis--&amp;gt;conf下面 redis.conf配置文件  salveof masterip masterport &lt;/p&gt;
&lt;p&gt;3）在从服务器上设置 masterauth &quot;主服务器的密码&quot;&lt;/p&gt;
&lt;p&gt;4） ./redis-server redis.conf 启动Redsi&lt;/p&gt;
</description>
<pubDate>Sun, 04 Nov 2018 15:55:00 +0000</pubDate>
<dc:creator>palapala</dc:creator>
<og:description>Redis数据类型 基本类型(String int)： 如 set key value 、get key 等 所有命令都是按照 key value keys * 可以将全部数据列出，其中后面的 &amp;qu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ssskkk/p/9901974.html</dc:identifier>
</item>
<item>
<title>学好数据结构和算法 —— 线性表 - Mr.yang.localhost</title>
<link>http://www.cnblogs.com/mr-yang-localhost/p/9863897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mr-yang-localhost/p/9863897.html</guid>
<description>&lt;h2&gt;线性表&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;线性表表示一种线性结构的数据结构，顾名思义就是数据排成像一条线一样的结构，每个线性表上的数据只有前和后两个方向。比如：数组、链表、栈和队列都是线性表，今天我们分别来看看这些线性数据结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181031234032119-804718253.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;数组&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;数组是一种线性表数据结构，用&lt;span&gt;一组连续的内存空间来存储一组具有相同类型&lt;/span&gt;的数据。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存分布：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181103171856139-305193903.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;随机访问&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;连续内存空间存储相同类型的数据，这个特性支持了数组的随机访问特性，相同类型的数据占用的空间是固定的假设为data_size，第n个元素的地址可以根据公式计算出来：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;amp;a[n] = $a[0] + n * data_size&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;其中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;amp;a[n]：第n个元素的地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a[0]：第0个元素的地址（数组的地址）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;data_size：数组存储的元素的类型大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以访问数组里指定下标的任何一个元素，都可以直接访问对应的地址，不需要遍历数组，时间复杂度为O(1)。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;插入/删除低效&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了保证内存的连续性，插入或删除数据时如果不是在数组末尾操作，就需要做数据的搬移工作，数据搬移会使得数组插入和删除时候效率低下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;向数组里插入一个元素有三种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、向末尾插入一个元素，此时的时间复杂度为O(1)，对应最好时间复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、向数组开头插入一个元素，需要将所有元素依次向后挪一个位置，然后将元素插入开头位置，此时时间复杂度为O(n)，对应最坏时间复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、向数组中间位置插入一个元素，此时每个位置插入元素的概率都是一样的为1/n，平均复杂度为（1+2+3+…+n）/n = O(n)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果数组元素是没有顺序的（或不需要保证元素顺序），向数组中间位置插入一个元素x，只需要将插入位置的元素放到数组的末尾，然后将x插入，这时候不需要搬移元素，时间复杂度仍为O(1)，如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181102085059550-1166474746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样地，删除数据的时候，从开头删除，需要将后面n-1个元素往前搬移，对应的时间复杂度为O(n)；从末尾删除时间复杂度为O(1)；平均时间复杂度也是O(n)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果不需要保证数据的连续性，有两种方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、可以将末尾的数据搬移到删除点插入，删除末尾那个元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、删除的时候做标记，并不正真删除，等数组空间不够的时候，再进行批量删除搬移操作&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Java的ArrayList&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　很多编程语言都针对数组进行了封装，比如Java的ArrayList，可以将数组的很多操作细节封装起来（插入删除的搬移数据或动态扩容），可以参考ArrayList的扩容数据搬移方法，ArrayList默认size是10，如果空间不够了会先按1.5倍扩容（如果还不够就可能会用到最大容量）。所以在使用的时候如果事先知道数组的大小，可以一次性申请，这样可以免去自动扩容的性能损耗。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么时候选择使用编程语言帮我们封装的数组，什么时候直接使用数组呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、Java ArrayList不支持基本数据类型，需要封装为Integer、Long类才能使用。Autoboxing、Unboxing有一定的性能消耗。如果比较关注性能可以直接使用数组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、使用前已经能确认数据大小，并且操作比较简单可以使用数组&lt;/p&gt;
&lt;h2&gt;链表&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;比起数组，链表不需要连续内存空间，它通过指针将一组分别独立的内存空间串起来形成一条“链条”。&lt;span&gt;链表有很多种，如：单链表、双向链表、循环链表和双向循环链表。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　链表内存分布：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181103173637667-485639833.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;单链表&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如下图所示，链表的每一项我们称为&lt;span&gt;&lt;strong&gt;结点（node）&lt;/strong&gt;&lt;/span&gt;，为了将所有结点连接起来形成链表，结点除了需要记录数据之外，还需要记录下一个结点的地址，记录下一个结点地址的指针我们叫做&lt;strong&gt;&lt;span&gt;后继指针（next）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，第一个结点和最后一个结点比较特殊，第一个结点没有next指针指向它，称为&lt;span&gt;&lt;strong&gt;头结点&lt;/strong&gt;&lt;/span&gt;，最后一个结点next指针没有指向任何元素，称为&lt;span&gt;&lt;strong&gt;尾结点&lt;/strong&gt;&lt;span&gt;。头结点用来记录链表的基地址，有了它就可以顺着链子往下搜索每一个元素，如果遇到next指向null表示到达了链表的末尾。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181103172917032-1019525493.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在数组里插入或删除数据需要保证内存空间的连续性，需要做数据的搬移，但是链表里数据内存空间是独立的，插入删除只需要改变指针指向即可，所以链表的插入删除非常高效。如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181103173350117-164120734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;双向链表&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;单向链表每个结点只知道自己下一个结点是谁，是一条单向的“链条”，而在双向链表里每个结点既知道下一个结点，还知道前一个结点，相比单链表，双向链表每个结点多了一个前驱指针（prev）指向前一个结点的地址，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181103174105179-2139583123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为每个结点要额外的空间来保存前驱结点的地址，所以相同数据情况下，双向链表比单链表占用的空间更多。双向链表在找前驱结点时间复杂度为O(1)，插入删除都比单链表高效，典型的空间换时间的例子。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;循环链表&lt;/h3&gt;
&lt;p&gt;　　将一个单链表首尾相连就形成了一个环，这就是循环链表，循环链表里尾结点不在是null，而是指向头结点。当数据具有环形结构时候就可以使用循环链表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181104093821053-1725884755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;双向循环链表&lt;/h3&gt;
&lt;p&gt;　　与循环链表类似，尾结点指向头结点，同时每个结点除了保存自身数据，分别有一个前驱指针和后继指针，就形成了双向循环链表：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181104093054232-2123621829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;插入/删除比较&lt;/h3&gt;
&lt;h4&gt;在链表里插入数据(new_node)&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1、在P结点后插入数据&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
new_node-&amp;gt;next = p-&amp;gt;&lt;span&gt;next;
p&lt;/span&gt;-&amp;gt;next = new_node
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;此时时间复杂度为O(1)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、在P结点前插入数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要找到P结点的前驱结点，然后转化为在P的前驱结点之后插入数据。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;单链表需要从头遍历，当满足条件 pre-&amp;gt;next = p时，转化为再pre结点后插入数据，此时时间复杂度为O(n)遍；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;双链表只需要通过p-&amp;gt;pre即可找到前驱结点，时间复杂度为O(1)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、在值等于某个值的结点前/后插入数据&lt;/p&gt;
&lt;p&gt;需要遍历整个链表，找到这个值，然后在它前/后插入数据，此时时间复杂度为O(n)&lt;/p&gt;
&lt;h4&gt;在链表里删除数据&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1、删除P结点下一个结点&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
p-&amp;gt;next = p-&amp;gt;next-&amp;gt;next;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接将p后继结点指针指向p下下一个结点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、删除P结点前一个结点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;找到P结点前驱结点的前驱结点N，然后转化为删除N的后继结点&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;单链表需要遍历找到结点N，遍历时间复杂度为O(n)，然后删除N的一个后继结点，时间复杂度为O(1)，所以总的时间复杂度为O(n)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;双向链表直接找到结点N：p-&amp;gt;pre-&amp;gt;pre-&amp;gt;next = p，时间复杂度为O(1)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;3、在值等于某个值的结点前/后删除数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要遍历整个链表，找到这个值，然后在它前/后删除数据，此时时间复杂度为O(n)&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;栈&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;栈是一种后进者先出，先进者后出的线性数据结构，只允许在一端插入/删除数据。栈可以用数组来实现，也可以用链表来实现，用数组实现的叫顺序栈，用链表来实现是叫链式栈。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;栈的数组实现&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;数组来实现栈，插入和删除都发生在数组的末尾，所以不需要进行数据的搬移，但是如果发生内存不够需要进行扩容的时候，仍然需要进行数据搬移&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('44e3f223-dea5-4e2d-b4e9-bf9af75c9c96')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_44e3f223-dea5-4e2d-b4e9-bf9af75c9c96&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_44e3f223-dea5-4e2d-b4e9-bf9af75c9c96&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('44e3f223-dea5-4e2d-b4e9-bf9af75c9c96',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_44e3f223-dea5-4e2d-b4e9-bf9af75c9c96&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testStack() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         StringStack stack = &lt;span&gt;new&lt;/span&gt; StringStack(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             stack.push(&quot;hello&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(stack.push(&quot;dd&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         String item = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; ((item = stack.pop()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            System.out.println(item);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StringStack {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] items;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; StringStack(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.items = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[n];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.size =&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; push(String item) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.count == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.items[count++] =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String pop() {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.count == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.items[--&lt;span&gt;count];
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCount() {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getSize() {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;栈的链表实现&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;链表的实现有个小技巧，倒着创建一个链表来模拟栈结构，最后添加到链表的元素作为链表的头结点，如图：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181104175907294-1272057019.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('22587ee0-048b-4d0f-8d35-7398f83a1293')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_22587ee0-048b-4d0f-8d35-7398f83a1293&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_22587ee0-048b-4d0f-8d35-7398f83a1293&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('22587ee0-048b-4d0f-8d35-7398f83a1293',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_22587ee0-048b-4d0f-8d35-7398f83a1293&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LinkStack {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node top;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; push(String item) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Node node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(item);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(top == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             top =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         node.next =&lt;span&gt; top;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         top =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String pop() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (top == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         String name =&lt;span&gt; top.getName();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         top =&lt;span&gt; top.next;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node next;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(String name) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;数组实现的是一个固定大小的栈，当内存不够的时候，可以按照数组扩容方式实现栈的扩容，或是依赖于动态扩容的封装结构来实现栈的动态扩容。出栈的时间复杂度都是O(1)，入栈会有不同，如果是数组实现栈需要扩容，最好时间复杂度（不需要扩容的时候）是O(1)，最坏时间复杂度是O(n)，插入数据的时候，栈刚好满了需要进行扩容，假设扩容为原来的两倍，此时时间复杂度是O(n)，每n次时间复杂度为O(1)夹杂着一次时间复杂度为O(n)的扩容，那么均摊时间复杂度就是O(1)。&lt;/p&gt;
&lt;h3&gt;栈的应用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;函数调用栈&lt;/li&gt;
&lt;li&gt;java的拦截器&lt;/li&gt;
&lt;li&gt;表达式求解&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;队列&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;队列与栈类似，支持的操作也很相似，不过队列是先进先出的线性数据结构。日常生活中常常需要进行的排队就是队列，排在前面的人优先。队列支持两个操作：入队 enqueue 从队尾添加一个元素；出队 dequeue 从对列头部取一个元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和栈一样，队列也有顺序队列和链式队列分别对应数组实现的队列和链表实现的队列。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;数组实现队列&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;数组实现的队列是固定大小的队列，当队列内存不足时候，统一搬移数据整理内存。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('faed0325-c476-4c1b-b9f9-44462aab1f76')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_faed0325-c476-4c1b-b9f9-44462aab1f76&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_faed0325-c476-4c1b-b9f9-44462aab1f76&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('faed0325-c476-4c1b-b9f9-44462aab1f76',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_faed0325-c476-4c1b-b9f9-44462aab1f76&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ArrayQueue {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] items;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; head = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tail = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ArrayQueue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.items = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[n];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * 入队列（从队列尾部入）
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; enqueue(String item) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列满了&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.tail == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对列头部不在起始位置&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;搬移数据&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = head; i &amp;lt; tail; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 items[i - head] =&lt;span&gt; items[i];
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.tail = tail -&lt;span&gt; head;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.head = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         items[tail++] =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;     * 出队列（从队列头部出）
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String dequeue() {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tail) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.items[head++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;链表实现队列&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;链表尾部入队，从头部出队，如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181104180404960-1318024913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c9eeea3b-60ab-4afd-9fb1-bbcf76ab734c')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_c9eeea3b-60ab-4afd-9fb1-bbcf76ab734c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c9eeea3b-60ab-4afd-9fb1-bbcf76ab734c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c9eeea3b-60ab-4afd-9fb1-bbcf76ab734c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c9eeea3b-60ab-4afd-9fb1-bbcf76ab734c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LinkQueue {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node head;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node tail;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LinkQueue() { }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * 入队列
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; enqueue(String item) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         Node node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(item);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列为空&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.tail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.tail =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.head =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.tail.next =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.tail =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * 出队列
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String dequeue() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列为空&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         String name = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.head.getName();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.head = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.head.next;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.tail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node next;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(String name) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;循环队列&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;数组实现队列时，当队列满了，头部出队时候，会发生数据搬移，但是如果是一个首尾相连的环形结构，如下图，头部有空间，尾部到达7位置，再添加元素时候，tail到达环形的第一个位置（下标为0）不需要搬移数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181104231210577-1676306683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为空的判定条件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;head = tail&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;队列满了的判定条件：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;当head = 0，tail = 7&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当head = 1，tail = 0&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当head = 4，tail = 3&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;head = （tail + 1）% 8&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3baa9454-9827-4e55-b59d-e84099f1724e')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3baa9454-9827-4e55-b59d-e84099f1724e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3baa9454-9827-4e55-b59d-e84099f1724e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3baa9454-9827-4e55-b59d-e84099f1724e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3baa9454-9827-4e55-b59d-e84099f1724e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CircleQueue {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] items;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; head = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tail = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; CircleQueue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.items = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[n];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * 入队列（从队列尾部入）
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; enqueue(String item) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列满了&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == (&lt;span&gt;this&lt;/span&gt;.tail + 1)% &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         items[tail] =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         tail = (tail + 1) % &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * 出队列（从队列头部出）
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String dequeue() {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列为空&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tail) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         String item = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.items[head];
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         head = (head + 1) % &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img id=&quot;code_img_opened_8fec87a3-e41f-453c-b79b-237594b17ead&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8fec87a3-e41f-453c-b79b-237594b17ead',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div id=&quot;cnblogs_code_open_8fec87a3-e41f-453c-b79b-237594b17ead&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CircleQueue {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] items;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; head = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tail = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; CircleQueue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.items = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[n];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * 入队列（从队列尾部入）
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; enqueue(String item) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列满了&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == (&lt;span&gt;this&lt;/span&gt;.tail + 1)% &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         items[tail++] =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * 出队列（从队列头部出）
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String dequeue() {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列为空&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tail) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.items[head++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;阻塞队列&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;阻塞队列是指当头部没有元素的时候（对应队列为空），出队会阻塞直到有元素为止；或者队列满了，尾部不能再插入数据，直到有空闲位置了再插入。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;并发队列&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;线程安全的队列叫并发队列。dequeue和enqueue加锁或者使用CAS实现高效的并发。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 04 Nov 2018 15:40:00 +0000</pubDate>
<dc:creator>Mr.yang.localhost</dc:creator>
<og:description>线性表 线性表表示一种线性结构的数据结构，顾名思义就是数据排成像一条线一样的结构，每个线性表上的数据只有前和后两个方向。比如：数组、链表、栈和队列都是线性表，今天我们分别来看看这些线性数据结构。 数组</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mr-yang-localhost/p/9863897.html</dc:identifier>
</item>
<item>
<title>Paxos算法——前世 - 宁静方能致远</title>
<link>http://www.cnblogs.com/qing1376/p/9906631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing1376/p/9906631.html</guid>
<description>&lt;p&gt;    Paxos算法是基于消息传递且具有高度容错特性的一致性算法。我们将从一个简单的问题开始，逐步的改进我们的设计方案，最终得到Paxos，一个可以在逆境下工作的协议。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;一、客户端-服务器模型&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    我们从最小的分布式系统开始，在这个系统中，只有两个结点，客户端结点与服务端结点，客户端结点能够操作（存储或更新）远程服务器结点上的数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;算法1.1  朴素的客户端/服务器算法：客户端每次向服务器发送一条命令。&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    在存在消息丢失的消息传递模型中，该算法却不能很好的工作，客户端不能确认消息是否正确的被服务器所接受。因此我们需要对其进行一些小的改进。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;算法1.2 待确认的客户端/服务器算法&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    1.客户端向服务端发送一条请求命令消息。&lt;/p&gt;
&lt;p&gt;    2.服务端接受请求并回复确认信息。&lt;/p&gt;
&lt;p&gt;    3.客户端在一定的时间范围内，没有收到服务器端发送的请求确认信息的回复，则重新发送命令请求信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;该算法描述了，客户端在发送一条请求命令后，在收到服务端的确认回复前，是不会发送下一条请求命令。&lt;/li&gt;
&lt;li&gt;客户端在发送的过程中消息可能丢失，服务端在回复的确认消息时，消息也可能丢失，对于服务端确认消息的丢失情况，在到达一定超时时间后，客户端未收到确认回复，会重新发送消息，此时该消息已经被服务器端处理，所以我们需要有一种机制能够保证消息的幂等性。例如给消息加上序列号。&lt;/li&gt;
&lt;li&gt;该算法可以很容易的扩展到多服务器端的场景，客户端发送命令请求给每一个服务器端，当收到所有服务器的确认消息，就可以认为这条命令执行成功。&lt;/li&gt;
&lt;li&gt;如何处理多个客户端的场景？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    基于可变消息延迟模型我们可以得出如下定理，即消息的延迟时间是不定的，同一对结点的消息发送的时间延迟也是不同的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;定理1.1  如果算法在多个客户端与服务端运行，服务器收到的命令顺序可能是不同的，这会导致不一致的状态。&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;   &lt;/strong&gt;&lt;/em&gt;&lt;strong&gt; &lt;/strong&gt;假设在如下的场景中，存在客户端c1，c2 ，服务端 s1，s2.  服务端s1，s2存在相同的值x = 0。 如果此时 c1，向服务器s1，s2 发送 x = x + 1. 在同一时刻 c2 向服务器 s1，s2 发送 x = 2*x. 假设c1 先于 c2 到达 s1 ，则此时s1的状态值x为 2， 而 c2 先于 c1 到达 s2 ， 则此时 s2 的状态值x为 1. 导致集群的状态不一致。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;定义1.1  （状态复制）对于一组结点，如果所有结点都以相同的顺序执行命令序列 c1，c2，c3，c4……，则这组结点实现了状态复制&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态复制是分布式系统的基本特征&lt;/li&gt;
&lt;li&gt;因为单个系统天然实现状态复制，可以令单个服务器系统实现序列化器，自动对请求进行排序来分发命令，从而实现状态复制。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;算法1.3 借助单一的串行化器实现状态复制&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;    1. 所有的客户端将请求命令发送到串行化器&lt;/p&gt;
&lt;p&gt;    2.串行化器逐个处理客户端请求，并将客户端请求逐个发送给所有服务器&lt;/p&gt;
&lt;p&gt;    3.当串行化器接受到所有服务器的确认消息时，它将返回给对应客户端命令执行成功的消息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个想法有时也被成为主从复制。&lt;/li&gt;
&lt;li&gt;改算法存在单点故障。串行化器&lt;/li&gt;
&lt;li&gt;我们是否可以构造一个更分布式的方法来解决状态复制的问题。去掉串行化器。任何时刻最多只有一个结点可以发送请求命令，是否可以采用互斥或各自加锁的思想？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;算法 1.4 两阶段锁&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    阶段 1  ：&lt;/p&gt;
&lt;p&gt;          客户端向所有服务器请求获取锁&lt;/p&gt;
&lt;p&gt;    阶段 2: &lt;/p&gt;
&lt;p&gt;          if   客户端获得所有服务器的加锁请求 &lt;/p&gt;
&lt;p&gt;               客户端以可靠的方式向所有服务器发送命令请求，释放锁&lt;/p&gt;
&lt;p&gt;          else &lt;/p&gt;
&lt;p&gt;               客户端释放已经获取的锁，休眠一段时间，进入阶段 1 &lt;/p&gt;

&lt;ul&gt;&lt;li&gt;算法 1.4 是否能够很好的应对结点崩溃呢？在该算法中要求所有的服务器结点都必须能够正常的工作&lt;/li&gt;
&lt;li&gt;如果仅获取部分服务器的锁能否工作，获得过半数服务器的锁是否就足够了？&lt;/li&gt;
&lt;li&gt;如果超过两个以上的客户端试图获取超过半数服务器的锁，怎么应对死锁的问题，是否需要释放已经获取的服务器锁，如果客户端在释放锁之前就发生了故障，怎么办，是否需要一个与锁不同的概念。&lt;/li&gt;
&lt;/ul&gt;






</description>
<pubDate>Sun, 04 Nov 2018 15:29:00 +0000</pubDate>
<dc:creator>宁静方能致远</dc:creator>
<og:description>Paxos算法是基于消息传递且具有高度容错特性的一致性算法。我们将从一个简单的问题开始，逐步的改进我们的设计方案，最终得到Paxos，一个可以在逆境下工作的协议。 一、客户端-服务器模型 我们从最小的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qing1376/p/9906631.html</dc:identifier>
</item>
<item>
<title>netty源码解解析(4.0)-1 核心架构 - 自带buff</title>
<link>http://www.cnblogs.com/brandonli/p/9906508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brandonli/p/9906508.html</guid>
<description>&lt;p&gt;netty是java开源社区的一个优秀的网络框架。使用netty，我们可以迅速地开发出稳定，高性能，安全的，扩展性良好的服务器应用程序。netty封装简化了在服务器开发领域的一些有挑战性的问题：jdk nio的使用；多线程并发；扩展性。它还提供了多种应用层协议的支持：http/https/websock, protobuf, 自定义协议， 简化了服务器协议的开发。&lt;/p&gt;
&lt;p&gt;netty是一个基于事件驱动的框架，它把事件分成两种类型：输入事件(inbound)和输出事件(outbound)， 整个框架都是围绕事件处理进行设计的，以下是netty的核心架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/895062/201811/895062-20181104230105450-843583970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;上图中涉及到了netty的六个核心对象:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Channel&lt;/strong&gt;: 一个I/O操作的对象，所有的inbound事件都是由Channel产生，outbound事件最终都会有Channel处理(如果outbound事件没有被用户注册的handler丢弃的话)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ChannelPipeline&lt;/strong&gt;: 有一个ChannelPipeline实例属于一个Channel实例，它是事件传播的管道，从Channel实例接收inbound事件，把outbound事件提交给Channel。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ChannelHandlerContext&lt;/strong&gt;: 这是一个双向链表结构，它的多个实例组成了一个双向链表，并有ChannelPipeline负责维护。 在ChannelPipeline的默认实现中，这个链默认添加了Head和Tail节点， Head节点同时实现ChannelOutboundHandler和ChannelInboundHandler接口，Head节点比较特殊，它会最终把事件交给Channel处理。Tail节点实现了ChannelInboundHandler接口，使用Channel触发的inbound事件会首先传到这里处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ChannelHandler&lt;/strong&gt;: 这里是netty的扩展接口，也是真正实现服务器通讯协议和业务功能功能的地方。ChannelHandler有两种类型：处理输入事件的ChannelinboundHandler和处理输出事件的ChannelOutboundHandler。用户的ChannelHandler要实现这两个接口中的任意一个或全部。当用户向ChannelPipeline注册自己的ChannelHandler时，ChannelPipleline会创建一个相应的ChannelHandlerContext实例，并让这个实例持有用户注册的ChannelHandler实例。然后把这个实例添加到双向链表中。用户注册的ChannelHandler的类型决定了这个实例的类型，进而决定了这个实例能够处理的事件类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EventLoopGroup&lt;/strong&gt;: 在Channel上执行I/O的线程组，netty把这个线程组中的线程定义为I/O线程，后面会讲到，有些特定的事件必须在I/O线程中处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EventExecutorGroup&lt;/strong&gt;: 用来执行ChannelHandlerContext和ChannelHandler中回调方法的线程。在用户向ChannelPipeline中注册一个ChannelHanlder时，如果指定了一个EventExecutorGroup，那么它和它对应的ChannelHandlerContext都会在指定的EventExecutorGroup执行，否则，在Channel的EventLoopGroup中执行。&lt;/p&gt;

&lt;p&gt;以上是netty核心架构中的核心核心对象，netty提供的所有能力都是通过对这些核心对象的扩展实现的。例如:&lt;/p&gt;
&lt;p&gt;NioSocketChannel和NioServerSocketChannel扩展了Channel, NioEventLoopGroup扩展了EventLoopGroup, netty通过这一组扩展实现了对JDK NIO的封装。&lt;/p&gt;
&lt;p&gt;ProtoBufDecoer和ProtoBufEncoder扩展ChannelHandler实现了对potobuf协议的支持。&lt;/p&gt;
&lt;p&gt;HttpObjectDecoder和HttpObjectEncoder扩展ChannelHandler实现了对http协议的支持。&lt;/p&gt;
&lt;p&gt;此外开发者还可通过对EventLoopGroup和EventExecutorGroup扩展实现不一样的线程模型，满足特定业务场景的需求。&lt;/p&gt;
&lt;p&gt;还可以对ChannelPipleline和ChannelHandlerContext扩展实现自定义的事件传递和处理流程。&lt;/p&gt;

</description>
<pubDate>Sun, 04 Nov 2018 15:05:00 +0000</pubDate>
<dc:creator>自带buff</dc:creator>
<og:description>netty是java开源社区的一个优秀的网络框架。使用netty，我们可以迅速地开发出稳定，高性能，安全的，扩展性良好的服务器应用程序。netty封装简化了在服务器开发领域的一些有挑战性的问题：jdk</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/brandonli/p/9906508.html</dc:identifier>
</item>
<item>
<title>解开Future的神秘面纱之获取结果 - 猫毛·波拿巴</title>
<link>http://www.cnblogs.com/longfurcat/p/9906437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longfurcat/p/9906437.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在前面的两篇博文中，已经介绍利用FutureTask任务的执行流程，以及利用其实现的cancel方法取消任务的情况。本篇就来介绍下，线程任务的结果获取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用get方法获取程序运行结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我们知道利用Future接口的最重要的操作就是要获取任务的结果，而此操作对应的方法就是get。但是问题来了，如果我调用get方法的时候，任务还没有完成呢？答案就是，等它完成，当前线程将被阻塞，直到任务完成（&lt;span&gt;&lt;strong&gt;注意，这里说的完成，指的是任务结束，因为异常而结束也算&lt;/strong&gt;&lt;/span&gt;），get方法返回。主线程（&lt;span&gt;&lt;strong&gt;不是执行任务的线程&lt;/strong&gt;&lt;/span&gt;）才被唤醒，然后继续运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181104194821870-455650189.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;293&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;灵活的get方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;有人可能会问，如果我调用get方法的时候，任务离完成还需要很长时间，那么我主线程不是会浪费一些时间？是的，如果主线程比较忙的话，这样确实主线程的效率。不过还有一个有参的get方法，此方法以等待时长为参数，如果时长结束，任务还没完成，主线程将继续执行，然后会在之后的某个时间再来获取任务结果。（&lt;span&gt;&lt;strong&gt;当然如果主线程依赖这个任务结果才能继续执行，那么只能老老实实地等了&lt;/strong&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181104195310516-642052330.png&quot; alt=&quot;&quot; width=&quot;583&quot; height=&quot;345&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FutureTask的阻塞模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;要想了解get方法的具体实现，必须先弄清楚，它是如何阻塞的。前篇博文已经提到，FutureTask有类型为WaitNode字段waiters，实际上这个waiters引用的是一个以WaitNode为节点的单向链表的头节点。如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181104203628576-1941963329.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;waitNode类代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; final &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WaitNode {
    &lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt; Thread thread; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程&lt;/span&gt;
    &lt;span&gt;volatile&lt;/span&gt; WaitNode next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下一个节点
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数获取当前执行线程的引用&lt;/span&gt;
    WaitNode() { thread =&lt;span&gt; Thread.currentThread(); }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;WaitNode保留线程引用的作用是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案是用于任务完成后唤醒等待线程。当FutureTask执行完callable的run方法后，将执行finishCompletion方法通知所有等待线程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; finishCompletion() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历等待节点&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (WaitNode q; (q = waiters) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将FutureTask的waiters引用置null&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, waitersOffset, q, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) { 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒所有等待线程&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出节点对应的线程&lt;/span&gt;
                Thread t =&lt;span&gt; q.thread;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    q.thread &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    LockSupport.unpark(t); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒对应线程&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取下一个节点&lt;/span&gt;
                WaitNode next =&lt;span&gt; q.next;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                q.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; unlink to help gc&lt;/span&gt;
                q =&lt;span&gt; next;
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用钩子函数done，此为空方法，子类可根据需求进行实现&lt;/span&gt;
&lt;span&gt;    done();

    callable &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;       
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;线程的阻塞方式——park和unPark&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　park/unPark也是用于控制线程等待状态的。我们熟悉的，用于控制线程等待状态的还有wait/notify。wait/notify是某个对象的条件队列，要阻塞线程，或者说要加入等待队列，必须先获取对象的锁。&lt;/p&gt;
&lt;p&gt;       与wait()/notify不同的是，park和unpark直接操作线程，无需获取对象的锁，&lt;strong&gt;个人认为&lt;/strong&gt;&lt;span&gt;这是这里使用park/unPark，而不是wait/notifyAll的原因，因为获取锁需要额外的开销&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;get方法的具体实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下是FutureTask中get方法的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;&lt;span&gt;() throws InterruptedException, ExecutionException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前任务状态&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是NEW或者COMPLETING，也就是还没有结束，就调用awaitDone进行阻塞&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (s &amp;lt;=&lt;span&gt; COMPLETING)
        s &lt;/span&gt;= awaitDone(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;0L&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意，这里的参数，表示非超时等待，如果任务未结束，程序将一直卡在这里
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果awaitDone返回，也就是任务已经结束，根据任务状态，返回结果&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; report(s);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下是get方法中调用到的awaitDone的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; awaitDone(boolean timed, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nanos) throws InterruptedException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据超时时间，计算结束时间点&lt;/span&gt;
    final &lt;span&gt;long&lt;/span&gt; deadline = timed ? System.nanoTime() + nanos : &lt;span&gt;0L&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待节点&lt;/span&gt;
    WaitNode q = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否加入等待队列&lt;/span&gt;
    boolean queued = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里并不是通过自旋，使方法无法返回。而是利用自旋CAS, 改变状态。如果成功，一次就够了&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果此线程被中断，把从节点从等待队列中移除&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted()) {
            removeWaiter(q);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
        }

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果状态大于COMPLETING，也就是任务已结束，返回任务状态&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; COMPLETING) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                q.thread &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s == COMPLETING) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; cannot time out yet&lt;/span&gt;
            Thread.&lt;span&gt;yield&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次循环，q是null，创建节点&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (q == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            q &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaitNode();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果还未加入等待队列，就加入&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;queued)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;q.next = waiters 表达式的返回值 是左侧的值，也就是waiters
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;意思是，如果当前对象的waiters的值是waiters, 就将他赋值为q&lt;/span&gt;
            queued = UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, waitersOffset,
                                                 q.next &lt;/span&gt;=&lt;span&gt; waiters, q); 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是超时等待，则调用parkNanos, 线程将在指定时间后被唤醒&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (timed) {
            nanos &lt;/span&gt;= deadline -&lt;span&gt; System.nanoTime();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nanos &amp;lt;= &lt;span&gt;0L&lt;/span&gt;&lt;span&gt;) {
                removeWaiter(q);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
            }
            LockSupport.parkNanos(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, nanos);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是超时等待，且已经加入等待队列，这时候利用park将当前线程挂起&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            LockSupport.park(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很多人可能会觉得这个循环体，看着有点迷糊，我刚开始也看得头大。但是我们可以根据几种情境，来查看这几种情境下代码的执行情况。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：第二个for循环内，第二个if-else块是一个大块，每次只执行一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;几种执行情境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、当前线程成功加入等待队列，且被阻塞，一段时间后任务完成，线程被唤醒&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181104221820076-1800432781.png&quot; alt=&quot;&quot; width=&quot;526&quot; height=&quot;443&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、当前线程加入队列后，还没被阻塞，任务就已经完成了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181104221103059-1222612202.png&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;366&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、因为其他线程加入等待队列的影响，当前线程未能加入等待队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里说明一下，如果其他线程在此线程之前，比较接近的时间，加入了等待队列，由于内存可见性的原因，当前线程看到的waiters值没有及时改变，故与其实际值不同，CAS操作就将失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么一定要CAS成功？&lt;/strong&gt;答案是，如果不成功，出现线程安全问题，链表的结构就会一塌糊涂。这里不细谈。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181104222414443-266709163.png&quot; alt=&quot;&quot; width=&quot;509&quot; height=&quot;417&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据任务状态获取结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　我们已经知道，FutureTask有一个Object字段的outcome，也就是任务执行的结果。当任务完成后，会将结果赋值给它。以下是FutureTask的run方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务开始执行后，设置FutureTask的runner字段，指明执行它的线程&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (state != NEW ||!UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, runnerOffset,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, Thread.currentThread()))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取具体任务&lt;/span&gt;
        Callable&amp;lt;V&amp;gt; c =&lt;span&gt; callable;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; state ==&lt;span&gt; NEW) {
            V result;
            boolean ran; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务是否已被运行完&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;运行任务&lt;/span&gt;
                result =&lt;span&gt; c.call();
                ran &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
                result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果运行任务过程中出现异常，则ran=false 表示没有运行完成&lt;/span&gt;
                ran = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置异常 =&amp;gt; 将任务状态设置为异常，并将异常信息赋值给outcome, 也就是任务结果
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个方法会调用finishCompletion&lt;/span&gt;
&lt;span&gt;                setException(ex);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果运行完成，把结果赋值给outcome&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ran)
                &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;(result); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个方法会调用finishCompletion&lt;/span&gt;
&lt;span&gt;        }
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;既然线程已经&quot;完成&quot;当前任务，就放弃引用，防止影响它执行其他任务&lt;/span&gt;
        runner = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新获取任务状态&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt;=&lt;span&gt; INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由前文可知，当任务&quot;完成&quot;的时候，获取结果的线程将被唤醒。回到get方法，它将获取到任务的状态，并根据任务状态获取结果。也就是report方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; V report(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s) throws ExecutionException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取结果&lt;/span&gt;
    Object x =&lt;span&gt; outcome;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果任务正常完成&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; NORMAL)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;强制转换为对应类型并返回&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (V)x;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果任务状态为CANCELLED、INTERRUPTING、INTERRUPTED表明是通过cacel方法取消了
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回已取消异常&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (s &amp;gt;=&lt;span&gt; CANCELLED)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationException();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是因为异常中断的话，抛出具体异常信息&lt;/span&gt;
    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExecutionException((Throwable)x);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 04 Nov 2018 14:54:00 +0000</pubDate>
<dc:creator>猫毛&amp;#183;波拿巴</dc:creator>
<og:description>前言 在前面的两篇博文中，已经介绍利用FutureTask任务的执行流程，以及利用其实现的cancel方法取消任务的情况。本篇就来介绍下，线程任务的结果获取。 利用get方法获取程序运行结果 我们知道</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longfurcat/p/9906437.html</dc:identifier>
</item>
<item>
<title>对项目开发流程的思考和小结 - zzzzou</title>
<link>http://www.cnblogs.com/zzzlw/p/9906334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzzlw/p/9906334.html</guid>
<description>&lt;h3 id=&quot;最近在项目开发中遇到的问题&quot;&gt;最近在项目开发中遇到的问题&lt;/h3&gt;
&lt;p&gt;1、对要开发的产品的最终形态没有明确的了解，没有明确的目的性，导致多次返工，重新设计&lt;br/&gt;2、没有明确的开发顺序，开发的模块东一块西一块不流畅不连贯,导致模块之间耦合太高，代码散落多处难以继续开发和维护，&lt;br/&gt;3、没有系统设计结构图，没有区分数据层面、控制层面、业务层面、展示层面、交互层面、界面层面，不能随时了解当下的开发位置和进度，无法预计后续开发的时间和下一个合适的开发位置。&lt;br/&gt;4、代码写的过分冗余，不够优美，主要是因为没有写伪代码来说明一个函数中每一部分的逻辑以及逻辑上下的关系&lt;br/&gt;5、代码写的过分硬编码，不够抽象，当发现要抽象的时候，需要重新修改之前的编码&lt;br/&gt;6、没有考虑数据交互的结构设计，数据结构设计应该单独拎出来作为单独函数封装以便后续扩展&lt;br/&gt;7、花过多的时间在界面设计上，时间浪费在过多的样式调整上。&lt;br/&gt;8、每次编码没有写上测试的内容，开发进度被多次延误，不能保证代码的正确性，基础性的bug过多。&lt;br/&gt;仔细的梳理流程后，大致整理了如下几个步骤。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;第一部分分析和规划设计&quot;&gt;第一部分、分析和规划设计&lt;/h3&gt;
&lt;p&gt;如下2步，需要画图、笔记、文字记录、演算、推理、画流程图、画架构图&lt;/p&gt;
&lt;p&gt;1、选型、明确产品界面、交互设计、功能设计、模块区分，寻找相仿的产品上手体验、操作，感知功能的使用和交互的体验，目的是为了了解即将要做的产品有大致的模型,对产品模型了解的越细致越好&lt;/p&gt;
&lt;p&gt;2、分离架构，对产品从各个维度分离架构，从功能，目录，逻辑拆分，抽象，业务流的明确，数据流的流向，交互体验的设计，从整体拆分成局部，针对每个局部再继续拆分，从局部整合成系统，考虑整体和局部之间的相互影响关系&lt;/p&gt;
&lt;p&gt;循环这2步，最终得到一个产品系统，应该对产品系统非常了解，从整体到局部，从需求到逻辑，端到端的数据流向，交互体验设计，数据库表结构设计&lt;/p&gt;
&lt;h3 id=&quot;第二部分实施&quot;&gt;第二部分、实施&lt;/h3&gt;
&lt;p&gt;3、文档编写，按照系统的各个区域和子系统，编写对应的文档注释，说明此子系统的功能、大致逻辑、含有的接口。&lt;br/&gt;此外，流程应该按照先数据库层面 --&amp;gt; 逻辑控制层面 --&amp;gt; 数据展示层面 --&amp;gt; 交互体验层面 --&amp;gt; 界面设计层面的顺序来规划和思考。&lt;br/&gt;同时考虑扩展性的问题，子系统是否可插拔，组件之间是否强依赖，必要的时候完成架构层面大的抽象。&lt;br/&gt;文档需要大概明确此子系统模块的测试结果是什么，提前演算模块的测试步骤和结果，后续细化的代码必须要通过此测试要求。&lt;/p&gt;
&lt;p&gt;4、明确每一个子系统和组件需要使用到的工具、框架、第三方库、以及重要的语法或者类设计、或者编程技巧、或者设计模式等等。&lt;/p&gt;
&lt;p&gt;5、开发顺序确认，明确这个系统的各个部分的开发顺序，独立的子系统先开发，耦合依赖强烈的系统最后开发，简单的先开发，难的后开发。 规划好开发进度计划。&lt;br/&gt;先开发数据库层面的代码，再开发数据控制层面，再开发数据交互层面，再是数据展示，交互体验设计，界面开发应该放到最后，界面开发最花时间。&lt;/p&gt;
&lt;p&gt;6、伪代码编写，使用中文表达逻辑，加上必要的编程语法混合表达。&lt;br/&gt;伪代码的编写是必须的，而且伪代码要写到可以直接演算出代码结果的程度，即可以通过编写伪代码来几乎100%的确定是否符合模块测试的要求。&lt;br/&gt;伪代码必须要完成数据交互的结构设计&lt;br/&gt;伪代码必须要对函数有明确的定义和解释，可以说明此函数的作用&lt;/p&gt;
&lt;p&gt;7、编码，编码必须符合伪代码的逻辑，编码应该多次测试，慢步前进。&lt;br/&gt;注意编码的版本控制&lt;br/&gt;编码应该尽量保持优美的逻辑和语法使用&lt;br/&gt;编码的变量命名应该特别注意&lt;br/&gt;每一次的编码应该最低按照一个函数单元，即最小编码单位是一个函数，一旦决定编码，就至少完成一个函数单元，或者取消本次函数的编写。&lt;br/&gt;每个函数的完成，都必须要达到伪代码对此函数的定义和解释，注意高内聚和低耦合的问题。&lt;br/&gt;如果没有高内聚，要适当拆分逻辑和代码&lt;br/&gt;如果没有低耦合，要适当抽象代码，合并其他同类函数&lt;/p&gt;
&lt;p&gt;8、代码review，优化代码&lt;/p&gt;
&lt;p&gt;以上每一步，如果出现重大问题和困难，应该向上返回寻找解决方案，因为这些顺序有强烈的依赖性，所以向上找到源头重新设计规划。&lt;br/&gt;也正因为步骤之间的顺序强依赖性，后一步都强烈依赖于前一步，所以前面的步骤必须打好基础，才可以减少返工重新设计和规划的问题。&lt;br/&gt;不是每一步都必须要做到完美，也不是每一个项目都需要使用到每一步，就像PMP一样，是一个套路，需要合理按需使用，但是整体的规划到实施的逻辑是要保证的。&lt;br/&gt;多按照这种套路来完成目的，大部分的事件都在锻炼思考和规划设计能力，编码只是最后实现的一块而已。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;1、开发最小单元应该是一个函数&lt;br/&gt;2、慢步前进，多做测试&lt;br/&gt;3、先有数据，再有逻辑&lt;br/&gt;4、不要花太多时间在界面上&lt;br/&gt;5、伪代码非常重要，必须要写&lt;br/&gt;6、文档注释非常重要，必须要写&lt;br/&gt;7、数据库设计永远是第一步，每次修改、规划设计、增加功能、维护、都首先考虑数据库&lt;br/&gt;所有的代码都围绕着数据库的数据进行设计、开发&lt;br/&gt;8、编码应该是最后的实现手段，应该是最后的环节&lt;br/&gt;9、多思考，少编码，思考的越多，错误越少。&lt;br/&gt;10、适当的冗余和抽象&lt;/p&gt;
</description>
<pubDate>Sun, 04 Nov 2018 14:44:00 +0000</pubDate>
<dc:creator>zzzzou</dc:creator>
<og:description>最近在项目开发中遇到的问题 1、对要开发的产品的最终形态没有明确的了解，没有明确的目的性，导致多次返工，重新设计 2、没有明确的开发顺序，开发的模块东一块西一块不流畅不连贯,导致模块之间耦合太高，代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzzlw/p/9906334.html</dc:identifier>
</item>
<item>
<title>国内开源社区巨作AspectCore-Framework入门 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/9906349.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/9906349.html</guid>
<description>&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;前些天和张队(善友),lemon(浩洋),斌哥(项斌)等MVP大咖一块儿吃饭,大家聊到了lemon名下的AOP这个项目,我这小白听得一脸懵逼,后面回来做了一下功课,查了下资料,在lemon的Github上把这个项目学习了一下,收获颇丰,让我这个没有接触过AOP的Coder叹为观止,陷入了对lemon的深深崇拜,在这里把学习的新的体会分享给大家.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。&lt;/p&gt;
&lt;p&gt;有点深奥, 举个栗子&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224013955-233693881.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224014268-626447140.png&quot; alt=&quot;image&quot; width=&quot;63&quot; height=&quot;48&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果说之前做的一个系统专门给内部的服务提供接口的,因为是在内网中访问,所以就没有加上认证服务,现在这个系统要公开出来,同样的那套接口要给外部系统服务了,那么此时,就要进行认证,认证通过才能获取接口的数据.&lt;/p&gt;
&lt;p&gt;传统的做法是,修改每一个接口.这样就会造成代码改动过大,很恐怖.&lt;/p&gt;

&lt;p&gt;这个时候AOP就可以登场了,我们可以在这一类服务的前面,加上一个一系列上一刀,在切出来的裂缝里面插入认证方法.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224014847-1491667678.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224015171-2119034888.png&quot; alt=&quot;image&quot; width=&quot;604&quot; height=&quot;294&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然而,怎么插入这个切面是关键.AOP 实现会采用一些常见方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用预处理器（如 C++ 中的预处理器）添加源代码。&lt;/li&gt;
&lt;li&gt;使用后处理器在编译后的二进制代码上添加指令。&lt;/li&gt;
&lt;li&gt;使用特殊编译器在编译时添加代码。&lt;/li&gt;
&lt;li&gt;在运行时使用代码拦截器拦截执行并添加所需的代码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是常见还是后处理和代码拦截两种方式&lt;/p&gt;
&lt;ul readability=&quot;6.6210826210826&quot;&gt;&lt;li readability=&quot;6.8264462809917&quot;&gt;
&lt;p&gt;后处理，或者叫 静态织入&lt;/p&gt;
&lt;p&gt;指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强或静态织入。&lt;/p&gt;
&lt;p&gt;在dotnet 中一般在编译时通过在MSBiuld执行自定义的Build Task来拦截编译过程，在生成的程序集里插入自己的IL。&lt;/p&gt;
&lt;p&gt;dotnet 框架代表： &lt;a href=&quot;https://www.postsharp.net/aop.net&quot;&gt;PostSharp&lt;/a&gt;&lt;/p&gt;

&lt;/li&gt;
&lt;li readability=&quot;6.3994082840237&quot;&gt;
&lt;p&gt;代码拦截，或者叫 动态代理&lt;/p&gt;
&lt;p&gt;在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强或动态代理。&lt;/p&gt;
&lt;p&gt;在dotnet 中一般在运行时通过Emit技术生成动态程序集和动态代理类型从而对目标方法进行拦截。&lt;/p&gt;
&lt;p&gt;dotnet 框架代表： &lt;a href=&quot;https://github.com/castleproject/Core/blob/master/docs/dynamicproxy-introduction.md&quot;&gt;Castle DynamicProxy&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/dotnetcore/AspectCore-Framework&quot;&gt;AspectCore&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;引用&lt;/em&gt;&lt;/span&gt;&lt;a title=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/0.AOP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.md&quot; href=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/0.AOP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.md&quot;&gt;&lt;span&gt;&lt;em&gt;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/0.AOP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.md&lt;/em&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我这里直接应用AOP Demo中的一段代码来说说这个拦截.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomInterceptor : AbstractInterceptor
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task Invoke(AspectContext context, AspectDelegate next)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Before service call&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service threw an exception!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;After service call&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码中,其实执行到 await next(context)的时候,才会真正去调用那个被拦截的方法.&lt;/p&gt;
&lt;p&gt;这样,我们就可以灵活地在代码调用前,调用后做我们想做的事情了.甚至可以把代码包在一个try…catch...中来捕获异常.&lt;/p&gt;

&lt;p&gt;新建一个web应用程序后,从 Nuget 安装 &lt;code&gt;AspectCore.Extensions.DependencyInjection&lt;/code&gt; 包.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
PM&amp;gt;   Install-Package AspectCore.Extensions.DependencyInjection
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后.我们就可以来定义我们的拦截器了,我定义了一个这样的拦截器.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Invoke(AspectContext context, AspectDelegate next)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; logger = context.ServiceProvider.GetService&amp;lt;ILogger&amp;lt;AuthenticateInterceptor&amp;gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; apiRequest =&lt;span&gt; (ApiRequest) context.Parameters.FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (apiRequest == &lt;span&gt;null&lt;/span&gt; || apiRequest.Name != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    logger.LogWarning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unauthorized&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                logger.LogInformation(apiRequest.Message);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                logger&lt;/span&gt;?.LogWarning(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service threw an exception!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Finished service call&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当ApiRequest为空或者Name不等于admin的时候之家返回并记录未授权.&lt;/p&gt;
&lt;p&gt;否则,调用该调用的方法并记录ApiRequest中的Message.&lt;/p&gt;
&lt;p&gt;然后,我定义一个UserService.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; AspceptCoreDemo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IUserService
    {
        String GetUserName(ApiRequest req);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserService : IUserService
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetUserName(ApiRequest req)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (req == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The User Name is {req.Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; req.Name;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Controler中调用注入UserServce并调用该Service.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; AspceptCoreDemo.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IUserService _userService;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ValuesController(IUserService userService)
        {
            _userService &lt;/span&gt;=&lt;span&gt; userService;
        }

        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Post(ApiRequest req)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _userService.GetUserName(req);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注册IUserservice并在&lt;code&gt;ConfigureServices&lt;/code&gt;中配置创建代理类型的容器:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;span&gt;IServiceProvider&lt;/span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddSingleton&lt;/span&gt;&amp;lt;IUserService, UserService&amp;gt;&lt;span&gt;();
            services.AddMvc();
            services.AddDynamicProxy(config &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                config.Interceptors.AddTyped&lt;/span&gt;&amp;lt;AuthenticateInterceptor&amp;gt;&lt;span&gt;();
            });

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;span&gt;services.BuildAspectInjectorProvider();&lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是红色背景处,默认的ConfigureService返回类型是空的,我们要修改成为返回类型是IServiceProvider.&lt;/p&gt;

&lt;p&gt;我们在上面的ConfigureService配置的AuthenticateInterceptor默认情况下是全局的,即这里的IUserService它会拦截,当然如果新增了一个IRoleServce它也是会拦截的.&lt;/p&gt;
&lt;p&gt;我把程序运行起来用PostMan访问Api进行测试.下图是Post的数据和返回结果.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224016254-112870544.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224016893-1114921484.png&quot; alt=&quot;image&quot; width=&quot;673&quot; height=&quot;291&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说明接口是正常工作的,成功地把传过去的Name原样返回.&lt;/p&gt;
&lt;p&gt;那么拦截器有没有生效呢?我看看CMD的输出.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224017133-1099194467.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224018394-1964980047.png&quot; alt=&quot;image&quot; width=&quot;668&quot; height=&quot;137&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果我们修改一下Name不等于Admin,预期应该是返回空,并且日志打印出未授权,是不是这样呢?&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224019001-1470864175.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224019706-1484359376.png&quot; alt=&quot;image&quot; width=&quot;676&quot; height=&quot;309&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224019923-570865010.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224020565-135938875.png&quot; alt=&quot;image&quot; width=&quot;676&quot; height=&quot;99&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完美,与预期完全相同.&lt;/p&gt;
&lt;p&gt;可以发现,这正是我们在拦截器中所作的工作,说明拦截器对该UserService生效了.&lt;/p&gt;

&lt;p&gt;如果我们不想对所有Servce或是Method都拦截,只拦截指定的Servce或者Method呢?&lt;/p&gt;
&lt;p&gt;其实,我们是可以配置全局拦截器的作用域的.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
services.AddDynamicProxy(config =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支持通配符,只对IRole开头的Servce有效&lt;/span&gt;
                config.Interceptors.AddTyped&amp;lt;AuthenticateInterceptor&amp;gt;(Predicates.ForService(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IRole*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我用以上方法配置为该过滤器只对IRole开头的Servce有效,那么,当我们让问IUserServce时,该拦截器肯定是不会生效的,事实是不是这样呢?&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224021132-184437157.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224021836-1153902737.png&quot; alt=&quot;image&quot; width=&quot;673&quot; height=&quot;305&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;即使Name不是admin,结果也返回了,说明确实是没有生效的.&lt;/p&gt;
&lt;p&gt;还可以用以下方法指定过滤器作用于的Method.&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支持通配符,只对Name结尾的方法有效&lt;/span&gt;
config.Interceptors.AddTyped&amp;lt;AuthenticateInterceptor&amp;gt;(Predicates.ForMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;忽略配置有两种方法&lt;/p&gt;
&lt;p&gt;一种是为Service或者Method打上&lt;span&gt;[NonAspect]&lt;/span&gt; 标签,那个过滤器就不会对该处生效了.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IUserService
    {
        [NonAspect]
        String GetUserName(ApiRequest req);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时,即使Name不等于Admin,也是有结果返回会的.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224022415-3016207.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224023077-780369200.png&quot; alt=&quot;image&quot; width=&quot;565&quot; height=&quot;247&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说明此时配置器对GetUserName方法确实没有生效.&lt;/p&gt;

&lt;p&gt;另外一种是 全局忽略配置，亦支持通配符：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
services.AddDynamicProxy(config =&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;App1命名空间下的Service不会被代理&lt;/span&gt;
    config.NonAspectPredicates.AddNamespace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后一级为App1的命名空间下的Service不会被代理&lt;/span&gt;
    config.NonAspectPredicates.AddNamespace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*.App1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ICustomService接口不会被代理&lt;/span&gt;
    config.NonAspectPredicates.AddService(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ICustomService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后缀为Service的接口和类不会被代理&lt;/span&gt;
    config.NonAspectPredicates.AddService(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;命名为Query的方法不会被代理&lt;/span&gt;
    config.NonAspectPredicates.AddMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后缀为Query的方法不会被代理&lt;/span&gt;
    config.NonAspectPredicates.AddMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*Query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对拦截器中有get和set权限的属性标记&lt;code&gt;[AspectCore.Injector.FromContainerAttribute]&lt;/code&gt;特性，即可自动注入该属性.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[NonAspect]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthenticateInterceptor : AbstractInterceptor
    {
       &lt;span&gt; [FromContainer]
        &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; ILogger&amp;lt;AuthenticateInterceptor&amp;gt; Logger { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;/span&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;; }&lt;/span&gt;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Invoke(AspectContext context, AspectDelegate next)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; apiRequest =&lt;span&gt; (ApiRequest) context.Parameters.FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (apiRequest == &lt;span&gt;null&lt;/span&gt; || apiRequest.Name != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    Logger.LogWarning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unauthorized&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                Logger.LogInformation(apiRequest.Message);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                Logger&lt;/span&gt;?.LogWarning(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service threw an exception!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                Logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Finished service call&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以拦截器上下文&lt;code&gt;AspectContext&lt;/code&gt;可以获取当前Scoped的&lt;code&gt;ServiceProvider&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;利用该ServiceProvider来对依赖项赋值.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[NonAspect]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthenticateInterceptor : AbstractInterceptor
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Invoke(AspectContext context, AspectDelegate next)
        {
            &lt;/span&gt;
&lt;/pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; logger = context.ServiceProvider.GetService&amp;lt;ILogger&amp;lt;AuthenticateInterceptor&amp;gt;&amp;gt;&lt;/span&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;();&lt;/span&gt;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; apiRequest =&lt;span&gt; (ApiRequest) context.Parameters.FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (apiRequest == &lt;span&gt;null&lt;/span&gt; || apiRequest.Name != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    logger.LogWarning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unauthorized&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                logger.LogInformation(apiRequest.Message);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                logger&lt;/span&gt;?.LogWarning(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service threw an exception!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Finished service call&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本文只是对AsceptCore最简单的一套流程end to end 地进行了叙述,这还只是AsceptCore的冰山一角.在此向开发处如此牛逼AOP框架的小伙致敬!!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/6af89bc8gw1f8tys9l7h5j20a00a0wfd.jpg&quot; alt=&quot;â€œè§£é”å§¿åŠ¿â€çš„å›¾ç‰‡æœç´¢ç»“æžœ&quot;/&gt;&lt;/p&gt;

&lt;p&gt;欢迎访问&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/1.%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md&quot; href=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/1.%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md&quot;&gt;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/1.%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解锁更多新姿势!!!&lt;/p&gt;

&lt;p&gt;本博客Demo地址&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/liuzhenyulive/AspceptCoreDemo&quot; href=&quot;https://github.com/liuzhenyulive/AspceptCoreDemo&quot; target=&quot;_blank&quot;&gt;https://github.com/liuzhenyulive/AspceptCoreDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AsceptCore地址&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/1.%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md&quot; href=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/1.%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md&quot;&gt;https://github.com/dotnetcore/AspectCore-Framework&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 04 Nov 2018 14:40:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>前些天和张队(善友),lemon(浩洋),斌哥(项斌)等MVP大咖一块儿吃饭,大家聊到了lemon名下的AOP这个项目,我这小白听得一脸懵逼,后面回来做了一下功课,查了下资料,在lemon的Githu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/9906349.html</dc:identifier>
</item>
</channel>
</rss>