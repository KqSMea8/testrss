<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>邮件服务器的扩展 - MAX_T</title>
<link>http://www.cnblogs.com/wtang/p/8910836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wtang/p/8910836.html</guid>
<description>&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是个有趣的小项目.公司有不少系统是使用不同的语言写的,而有些语言调用smtp邮件服务器不是那么方便,那么我们的设想是写一个web app,提供一个POST的数据接口,能够接收email的信息.比如收件人地址,名字,邮件正文等,然后在web app内部再调用smtp服务器发送.公司内部其他系统想要发送邮件的话,只需要发送一个HTTP POST请求就好了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;br/&gt;使用express充当web server，创建路由。&lt;br/&gt;使用nodemailer创建smtp连接，发送邮件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;&lt;br/&gt;1. POST数据格式，有好几种，比如application/json, application/w-www/form-urlencoded. 所以在express中要添建相应的middleware来正确的解析提交的数据。&lt;/p&gt;
&lt;p&gt;2. 控制发送email的速度。通过POST接受到数据之后，不是马上发送，而是push到一个array中。然后再在一个同步的环境中，main process中，设置一个timer，间隔发送邮件。在nodejs编程特别要注意，因为好多都是异步的环境，在异步的环境下，是控制不住间隔发送的。&lt;/p&gt;
&lt;p&gt;3. 然后为了提高server接受request的能力，我写了nodejs cluster来fork了4个process来同时接受HTTP POST，但是后来想一想，这些事情可以使用反向代理服务器比如Nginx来做&lt;/p&gt;
&lt;p&gt;4. 因为这个程序是要部署到server上，一直运行的，所以一定要有logger，保存运行数据和错误处理。在Linux上有个deamon程序叫做forever可以帮助布置和收集console.log的日志。不然的话就要自己写一个logger，代替console.log，把日志写到log文件中。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Apr 2018 15:26:00 +0000</pubDate>
<dc:creator>MAX_T</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wtang/p/8910836.html</dc:identifier>
</item>
<item>
<title>Go实现海量日志收集系统(三) - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/8910761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/8910761.html</guid>
<description>&lt;p&gt;再次整理了一下这个日志收集系统的框，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201804/997599-20180422231355073-1014013387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次要实现的代码的整体逻辑为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201804/997599-20180422231418588-110139452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整代码地址为:&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;https://github.com/pythonsite/logagent&quot;&gt;https://github.com/pythonsite/logagent&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;etcd介绍&lt;/h2&gt;
&lt;p&gt;高可用的分布式key-value存储，可以用于配置共享和服务发现&lt;/p&gt;
&lt;p&gt;类似的项目：zookeeper和consul&lt;/p&gt;
&lt;p&gt;开发语言：go&lt;/p&gt;
&lt;p&gt;接口：提供restful的接口，使用简单&lt;/p&gt;
&lt;p&gt;实现算法：基于raft算法的强一致性，高可用的服务存储目录&lt;/p&gt;
&lt;p&gt;etcd的应用场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务发现和服务注册&lt;/li&gt;
&lt;li&gt;配置中心(我们实现的日志收集客户端需要用到)&lt;/li&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;li&gt;master选举&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;官网对etcd的有一个非常简明的介绍：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201804/997599-20180422231443082-628381928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;etcd搭建：&lt;br/&gt;下载地址：&lt;a href=&quot;https://github.com/coreos/etcd/releases/&quot;&gt;https://github.com/coreos/etcd/releases/&lt;/a&gt;&lt;br/&gt;根据自己的环境下载对应的版本然后启动起来就可以了&lt;/p&gt;
&lt;p&gt;启动之后可以通过如下命令验证一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@localhost etcd-v3.2.18-linux-amd64]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ./etcdctl set name zhaofan &lt;/span&gt;
&lt;span&gt;
zhaofan
[root@localhost etcd&lt;/span&gt;-v3.2.18-linux-amd64]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ./etcdctl get name&lt;/span&gt;
&lt;span&gt;zhaofan
[root@localhost etcd&lt;/span&gt;-v3.2.18-linux-amd64]&lt;span&gt;#&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;context 介绍和使用&lt;/h2&gt;
&lt;p&gt;其实这个东西翻译过来就是上下文管理，那么context的作用是做什么，主要有如下两个作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;控制goroutine的超时&lt;/li&gt;
&lt;li&gt;保存上下文数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过下面一个简单的例子进行理解：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;net/http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;io/ioutil&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)


type Result struct{
    r &lt;/span&gt;*&lt;span&gt;http.Response
    err error
}

func process(){
    ctx,cancel :&lt;/span&gt;= context.WithTimeout(context.Background(),2*&lt;span&gt;time.Second)
    defer cancel()
    tr :&lt;/span&gt;= &amp;amp;&lt;span&gt;http.Transport{}
    client :&lt;/span&gt;= &amp;amp;&lt;span&gt;http.Client{Transport:tr}
    c :&lt;/span&gt;= make(chan Result,1&lt;span&gt;)
    req,err :&lt;/span&gt;= http.NewRequest(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.google.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,nil)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http request failed,err:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,err)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;//&lt;span&gt; 如果请求成功了会将数据存入到管道中
    go func(){
        resp,err :&lt;/span&gt;=&lt;span&gt; client.Do(req)
        pack :&lt;/span&gt;=&lt;span&gt; Result{resp,err}
        c &lt;/span&gt;&amp;lt;-&lt;span&gt; pack
    }()

    select{
    case &lt;/span&gt;&amp;lt;-&lt;span&gt; ctx.Done():
        tr.CancelRequest(req)
        fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timeout!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    case res :&lt;/span&gt;= &amp;lt;-&lt;span&gt;c:
        defer res.r.Body.Close()
        out,_:&lt;/span&gt;=&lt;span&gt; ioutil.ReadAll(res.r.Body)
        fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server response:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,out)
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;

}

func main() {
    process()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写一个通过context保存上下文，代码例子如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;github.com/Go-zh/net/context&quot;
    &quot;fmt&quot;&lt;span&gt;
)

func add(ctx context.Context,a,b &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;) &lt;span&gt;int&lt;/span&gt;&lt;span&gt; {
    traceId :&lt;/span&gt;= ctx.Value(&quot;trace_id&quot;&lt;span&gt;).(string)
    fmt.Printf(&lt;/span&gt;&quot;trace_id:%v\n&quot;&lt;span&gt;,traceId)
    return a&lt;/span&gt;+&lt;span&gt;b
}

func calc(ctx context.Context,a, b &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;) &lt;span&gt;int&lt;/span&gt;&lt;span&gt;{
    traceId :&lt;/span&gt;= ctx.Value(&quot;trace_id&quot;&lt;span&gt;).(string)
    fmt.Printf(&lt;/span&gt;&quot;trace_id:%v\n&quot;&lt;span&gt;,traceId)
    &lt;/span&gt;//&lt;span&gt;再将ctx传入到add中
    return add(ctx,a,b)
}

func main() {
    &lt;/span&gt;//&lt;span&gt;将ctx传递到calc中
    ctx :&lt;/span&gt;= context.WithValue(context.Background(),&quot;trace_id&quot;,&quot;123456&quot;&lt;span&gt;)
    calc(ctx,&lt;/span&gt;20,30&lt;span&gt;)

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;结合etcd和context使用&lt;/h2&gt;
&lt;p&gt;关于通过go连接etcd的简单例子：(这里有个小问题需要注意就是etcd的启动方式，默认启动可能会连接不上，尤其你是在虚拟你安装，所以需要通过如下命令启动：&lt;br/&gt;./etcd --listen-client-urls&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;http://0.0.0.0:2371&quot;&gt;http://0.0.0.0:2371&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; --advertise-client-urls&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;http://0.0.0.0:2371&quot;&gt;http://0.0.0.0:2371&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; --listen-peer-urls&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;http://0.0.0.0:2381&quot;&gt;http://0.0.0.0:2381&lt;/a&gt;&lt;br/&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    etcd_client &lt;/span&gt;&quot;github.com/coreos/etcd/clientv3&quot;
    &quot;time&quot;
    &quot;fmt&quot;&lt;span&gt;
)

func main() {
    cli, err :&lt;/span&gt;=&lt;span&gt; etcd_client.New(etcd_client.Config{
        Endpoints:[]string{&lt;/span&gt;&quot;192.168.0.118:2371&quot;&lt;span&gt;},
        DialTimeout:&lt;/span&gt;5*&lt;span&gt;time.Second,
    })
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;connect failed,err:&quot;&lt;span&gt;,err)
        return
    }

    fmt.Println(&lt;/span&gt;&quot;connect success&quot;&lt;span&gt;)
    defer cli.Close()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面一个例子是通过连接etcd，存值并取值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;github.com/coreos/etcd/clientv3&quot;
    &quot;time&quot;
    &quot;fmt&quot;
    &quot;context&quot;&lt;span&gt;
)

func main() {
    cli,err :&lt;/span&gt;=&lt;span&gt; clientv3.New(clientv3.Config{
        Endpoints:[]string{&lt;/span&gt;&quot;192.168.0.118:2371&quot;&lt;span&gt;},
        DialTimeout:&lt;/span&gt;5*&lt;span&gt;time.Second,
    })
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;connect failed,err:&quot;&lt;span&gt;,err)
        return
    }
    fmt.Println(&lt;/span&gt;&quot;connect succ&quot;&lt;span&gt;)
    defer cli.Close()
    ctx,cancel :&lt;/span&gt;=&lt;span&gt; context.WithTimeout(context.Background(),time.Second)
    _,err &lt;/span&gt;= cli.Put(ctx,&quot;logagent/conf/&quot;,&quot;sample_value&quot;&lt;span&gt;)
    cancel()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;put failed,err&quot;&lt;span&gt;,err)
        return
    }
    ctx, cancel &lt;/span&gt;=&lt;span&gt; context.WithTimeout(context.Background(),time.Second)
    resp,err :&lt;/span&gt;= cli.Get(ctx,&quot;logagent/conf/&quot;&lt;span&gt;)
    cancel()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;get failed,err:&quot;&lt;span&gt;,err)
        return
    }
    for _,ev :&lt;/span&gt;=&lt;span&gt; range resp.Kvs{
        fmt.Printf(&lt;/span&gt;&quot;%s:%s\n&quot;&lt;span&gt;,ev.Key,ev.Value)
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于context官网也有一个例子非常有用，用于控制开启的goroutine的退出，代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;context&quot;
    &quot;fmt&quot;&lt;span&gt;
)

func main() {
    &lt;/span&gt;// gen generates integers in a separate goroutine &lt;span&gt;and&lt;/span&gt;
    //&lt;span&gt; sends them to the returned channel.
    &lt;/span&gt;// The callers &lt;span&gt;of&lt;/span&gt;&lt;span&gt; gen need to cancel the context once
    &lt;/span&gt;// they are done consuming generated integers &lt;span&gt;not&lt;/span&gt;&lt;span&gt; to leak
    &lt;/span&gt;//&lt;span&gt; the internal goroutine started by gen.
    gen :&lt;/span&gt;= func(ctx context.Context) &amp;lt;-chan &lt;span&gt;int&lt;/span&gt;&lt;span&gt; {
        dst :&lt;/span&gt;= make(chan &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)
        n :&lt;/span&gt;= 1&lt;span&gt;
        go func() {
            for {
                select {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &amp;lt;-&lt;span&gt;ctx.Done():
                    return &lt;/span&gt;// returning &lt;span&gt;not&lt;/span&gt;&lt;span&gt; to leak the goroutine
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; dst &amp;lt;-&lt;span&gt; n:
                    n&lt;/span&gt;++&lt;span&gt;
                }
            }
        }()
        return dst
    }

    ctx, cancel :&lt;/span&gt;=&lt;span&gt; context.WithCancel(context.Background())
    defer cancel() &lt;/span&gt;// cancel &lt;span&gt;when&lt;/span&gt;&lt;span&gt; we are finished consuming integers

    for n :&lt;/span&gt;=&lt;span&gt; range gen(ctx) {
        fmt.Println(n)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 5&lt;span&gt; {
            break
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于官网文档中的WithDeadline演示的代码例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main


import (
    &lt;/span&gt;&quot;context&quot;
    &quot;fmt&quot;
    &quot;time&quot;&lt;span&gt;
)

func main() {
    d :&lt;/span&gt;= time.Now().Add(50 *&lt;span&gt; time.Millisecond)
    ctx, cancel :&lt;/span&gt;=&lt;span&gt; context.WithDeadline(context.Background(), d)

    &lt;/span&gt;//&lt;span&gt; Even though ctx will be expired, it is good practice to call its
    &lt;/span&gt;// cancelation function in any &lt;span&gt;case&lt;/span&gt;&lt;span&gt;. Failure to do so may keep the
    &lt;/span&gt;// context &lt;span&gt;and&lt;/span&gt;&lt;span&gt; its parent alive longer than necessary.
    defer cancel()

    select {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &amp;lt;-time.After(1 *&lt;span&gt; time.Second):
        fmt.Println(&lt;/span&gt;&quot;overslept&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &amp;lt;-&lt;span&gt;ctx.Done():
        fmt.Println(ctx.Err())
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面的代码有了一个基本的使用，那么如果我们通过etcd来做配置管理，如果配置更改之后，我们如何通知对应的服务器配置更改，通过下面例子演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;github.com/coreos/etcd/clientv3&quot;
    &quot;time&quot;
    &quot;fmt&quot;
    &quot;context&quot;&lt;span&gt;
)

func main() {
    cli,err :&lt;/span&gt;=&lt;span&gt; clientv3.New(clientv3.Config{
        Endpoints:[]string{&lt;/span&gt;&quot;192.168.0.118:2371&quot;&lt;span&gt;},
        DialTimeout:&lt;/span&gt;5*&lt;span&gt;time.Second,
    })
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        fmt.Println(&lt;/span&gt;&quot;connect failed,err:&quot;&lt;span&gt;,err)
        return
    }
    defer cli.Close()
    &lt;/span&gt;//&lt;span&gt; 这里会阻塞
    rch :&lt;/span&gt;= cli.Watch(context.Background(),&quot;logagent/conf/&quot;&lt;span&gt;)
    for wresp :&lt;/span&gt;=&lt;span&gt; range rch{
        for _,ev :&lt;/span&gt;=&lt;span&gt; range wresp.Events{
            fmt.Printf(&lt;/span&gt;&quot;%s %q : %q\n&quot;&lt;span&gt;, ev.Type, ev.Kv.Key, ev.Kv.Value)
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现一个kafka的消费者代码的简单例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;github.com/Shopify/sarama&quot;
    &quot;strings&quot;
    &quot;fmt&quot;
    &quot;time&quot;&lt;span&gt;
)

func main() {
    consumer,err :&lt;/span&gt;= sarama.NewConsumer(strings.Split(&quot;192.168.0.118:9092&quot;,&quot;,&quot;&lt;span&gt;),nil)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;failed to start consumer:&quot;&lt;span&gt;,err)
        return
    }
    partitionList,err :&lt;/span&gt;= consumer.Partitions(&quot;nginx_log&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        fmt.Println(&lt;/span&gt;&quot;Failed to get the list of partitions:&quot;&lt;span&gt;,err)
        return
    }
    fmt.Println(partitionList)
    for partition :&lt;/span&gt;=&lt;span&gt; range partitionList{
        pc,err :&lt;/span&gt;= consumer.ConsumePartition(&quot;nginx_log&quot;&lt;span&gt;,int32(partition),sarama.OffsetNewest)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
            fmt.Printf(&lt;/span&gt;&quot;failed to start consumer for partition %d:%s\n&quot;&lt;span&gt;,partition,err)
            return
        }
        defer pc.AsyncClose()
        go func(partitionConsumer sarama.PartitionConsumer){
            for msg :&lt;/span&gt;=&lt;span&gt; range pc.Messages(){
                fmt.Printf(&lt;/span&gt;&quot;partition:%d Offset:%d Key:%s Value:%s&quot;&lt;span&gt;,msg.Partition,msg.Offset,string(msg.Key),string(msg.Value))
            }
        }(pc)
    }
    time.Sleep(time.Hour)
    consumer.Close()

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是上面的代码并不是最佳代码，因为我们最后是通过time.sleep等待goroutine的执行，我们可以更改为通过sync.WaitGroup方式实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;github.com/Shopify/sarama&quot;
    &quot;strings&quot;
    &quot;fmt&quot;
    &quot;sync&quot;&lt;span&gt;
)

var (
    wg sync.WaitGroup
)

func main() {
    consumer,err :&lt;/span&gt;= sarama.NewConsumer(strings.Split(&quot;192.168.0.118:9092&quot;,&quot;,&quot;&lt;span&gt;),nil)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;failed to start consumer:&quot;&lt;span&gt;,err)
        return
    }
    partitionList,err :&lt;/span&gt;= consumer.Partitions(&quot;nginx_log&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        fmt.Println(&lt;/span&gt;&quot;Failed to get the list of partitions:&quot;&lt;span&gt;,err)
        return
    }
    fmt.Println(partitionList)
    for partition :&lt;/span&gt;=&lt;span&gt; range partitionList{
        pc,err :&lt;/span&gt;= consumer.ConsumePartition(&quot;nginx_log&quot;&lt;span&gt;,int32(partition),sarama.OffsetNewest)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
            fmt.Printf(&lt;/span&gt;&quot;failed to start consumer for partition %d:%s\n&quot;&lt;span&gt;,partition,err)
            return
        }
        defer pc.AsyncClose()
        go func(partitionConsumer sarama.PartitionConsumer){
            wg.Add(&lt;/span&gt;1&lt;span&gt;)
            for msg :&lt;/span&gt;=&lt;span&gt; range partitionConsumer.Messages(){
                fmt.Printf(&lt;/span&gt;&quot;partition:%d Offset:%d Key:%s Value:%s&quot;&lt;span&gt;,msg.Partition,msg.Offset,string(msg.Key),string(msg.Value))
            }
            wg.Done()
        }(pc)
    }

    &lt;/span&gt;//&lt;span&gt;time.Sleep(time.Hour)
    wg.Wait()
    consumer.Close()

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_4&quot;&gt;将客户端需要收集的日志信息放到etcd中&lt;/h2&gt;
&lt;p&gt;关于etcd处理的代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;github.com/coreos/etcd/clientv3&quot;
    &quot;time&quot;
    &quot;github.com/astaxie/beego/logs&quot;
    &quot;context&quot;
    &quot;fmt&quot;&lt;span&gt;
)

var Client &lt;/span&gt;*&lt;span&gt;clientv3.Client
var logConfChan chan string


&lt;/span&gt;//&lt;span&gt; 初始化etcd
func initEtcd(addr []string,keyfmt string,timeout time.Duration)(err error){

    var keys []string
    for _,ip :&lt;/span&gt;=&lt;span&gt; range ipArrays{
        &lt;/span&gt;//keyfmt = /logagent/%s/&lt;span&gt;log_config
        keys &lt;/span&gt;=&lt;span&gt; append(keys,fmt.Sprintf(keyfmt,ip))
    }

    logConfChan &lt;/span&gt;= make(chan string,10&lt;span&gt;)
    logs.Debug(&lt;/span&gt;&quot;etcd watch key:%v timeout:%v&quot;&lt;span&gt;, keys, timeout)

    Client,err &lt;/span&gt;=&lt;span&gt; clientv3.New(clientv3.Config{
        Endpoints:addr,
        DialTimeout: timeout,
    })
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        logs.Error(&lt;/span&gt;&quot;connect failed,err:%v&quot;&lt;span&gt;,err)
        return
    }
    logs.Debug(&lt;/span&gt;&quot;init etcd success&quot;&lt;span&gt;)
    waitGroup.Add(&lt;/span&gt;1&lt;span&gt;)
    for _, key :&lt;/span&gt;=&lt;span&gt; range keys{
        ctx,cancel :&lt;/span&gt;= context.WithTimeout(context.Background(),2*&lt;span&gt;time.Second)
        &lt;/span&gt;//&lt;span&gt; 从etcd中获取要收集日志的信息
        resp,err :&lt;/span&gt;=&lt;span&gt; Client.Get(ctx,key)
        cancel()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
            logs.Warn(&lt;/span&gt;&quot;get key %s failed,err:%v&quot;&lt;span&gt;,key,err)
            continue
        }

        for _, ev :&lt;/span&gt;=&lt;span&gt; range resp.Kvs{
            logs.Debug(&lt;/span&gt;&quot;%q : %q\n&quot;&lt;span&gt;,  ev.Key, ev.Value)
            logConfChan &lt;/span&gt;&amp;lt;-&lt;span&gt; string(ev.Value)
        }
    }
    go WatchEtcd(keys)
    return
}

func WatchEtcd(keys []string){
    &lt;/span&gt;//&lt;span&gt; 这里用于检测当需要收集的日志信息更改时及时更新
    var watchChans []clientv3.WatchChan
    for _,key :&lt;/span&gt;=&lt;span&gt; range keys{
        rch :&lt;/span&gt;=&lt;span&gt; Client.Watch(context.Background(),key)
        watchChans &lt;/span&gt;=&lt;span&gt; append(watchChans,rch)
    }

    for {
        for _,watchC :&lt;/span&gt;=&lt;span&gt; range watchChans{
            select{
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; wresp := &amp;lt;-&lt;span&gt;watchC:
                for _,ev:&lt;/span&gt;=&lt;span&gt; range wresp.Events{
                    logs.Debug(&lt;/span&gt;&quot;%s %q : %q\n&quot;&lt;span&gt;, ev.Type, ev.Kv.Key, ev.Kv.Value)
                    logConfChan &lt;/span&gt;&amp;lt;-&lt;span&gt; string(ev.Kv.Value)
                }
            default:

            }
        }
        time.Sleep(time.Second)
    }
    waitGroup.Done()
}

func GetLogConf()chan string{
    return logConfChan
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样的这里增加对了限速的处理，毕竟日志收集程序不能影响了当前业务的性能，所以增加了limit.go用于限制速度：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;time&quot;
    &quot;sync/atomic&quot;
    &quot;github.com/astaxie/beego/logs&quot;&lt;span&gt;
)

type SecondLimit struct {
    unixSecond int64
    curCount int32
    limit int32
}

func NewSecondLimit(limit int32) &lt;/span&gt;*&lt;span&gt;SecondLimit {
    secLimit :&lt;/span&gt;= &amp;amp;&lt;span&gt;SecondLimit{
        unixSecond:time.Now().Unix(),
        curCount:&lt;/span&gt;0&lt;span&gt;,
        limit:limit,
    }
    return secLimit
}

func (s &lt;/span&gt;*SecondLimit) Add(count &lt;span&gt;int&lt;/span&gt;&lt;span&gt;) {
    sec :&lt;/span&gt;=&lt;span&gt; time.Now().Unix()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sec ==&lt;span&gt; s.unixSecond {
        atomic.AddInt32(&lt;/span&gt;&amp;amp;&lt;span&gt;s.curCount,int32(count))
        return
    }
    atomic.StoreInt64(&lt;/span&gt;&amp;amp;&lt;span&gt;s.unixSecond,sec)
    atomic.StoreInt32(&lt;/span&gt;&amp;amp;&lt;span&gt;s.curCount, int32(count))
}

func (s &lt;/span&gt;*&lt;span&gt;SecondLimit) Wait()bool {
    for {
        sec :&lt;/span&gt;=&lt;span&gt; time.Now().Unix()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sec == atomic.LoadInt64(&amp;amp;s.unixSecond)) &amp;amp;&amp;amp; s.curCount ==&lt;span&gt; s.limit {
            time.Sleep(time.Microsecond)
            logs.Debug(&lt;/span&gt;&quot;limit is running,limit:%d s.curCount:%d&quot;&lt;span&gt;,s.limit,s.curCount)
            continue
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sec != atomic.LoadInt64(&amp;amp;&lt;span&gt;s.unixSecond) {
            atomic.StoreInt64(&lt;/span&gt;&amp;amp;&lt;span&gt;s.unixSecond,sec)
            atomic.StoreInt32(&lt;/span&gt;&amp;amp;s.curCount,0&lt;span&gt;)
        }
        logs.Debug(&lt;/span&gt;&quot;limit is exited&quot;&lt;span&gt;)
        return &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;这次基本实现了日志收集的前半段的处理，后面将把日志扔到es中，并最终在页面上呈现&lt;/p&gt;

</description>
<pubDate>Sun, 22 Apr 2018 15:21:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/8910761.html</dc:identifier>
</item>
<item>
<title>智能指针之 auto_ptr - 还在</title>
<link>http://www.cnblogs.com/blog-yejy/p/8910071.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blog-yejy/p/8910071.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;C++的auto_ptr所做的事情，就是&lt;span&gt;动态分配对象以及当对象不再需要时自动执行清理&lt;/span&gt;，该智能指针在C++11中已经被弃用，&lt;/span&gt;&lt;span&gt;转而由unique_ptr替代，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那这次使用和实现，就具体讲一下auto_ptr被弃用的原因，（编译平台：Linux centos 7.0　编译器：gcc 4.8.5 )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先使用std::auto_ptr时，需要#include &amp;lt;memory&amp;gt;头文件，具体使用代码如下（文件名：&lt;/span&gt;test_ptr.cpp&lt;span&gt;）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

class Test
{
public:
        Test()
        {
                cout &amp;lt;&amp;lt; &quot;construct..&quot; &amp;lt;&amp;lt; endl;
        }
        
        ~Test() 
        {
                cout &amp;lt;&amp;lt; &quot;destruct..&quot; &amp;lt;&amp;lt; endl;
        }
};

void test()
{
        
}

int main()
{
        Test* p = new Test(); 
        auto_ptr&amp;lt;Test&amp;gt; ap(p);

        return 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行上述代码，我们可以看到，程序结束时，在堆上申请的对象，自动执行了析构函数，将内存释放了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@localhost code]# g++ -g -o autop test_ptr.&lt;span&gt;cpp&lt;/span&gt;&lt;span&gt; 
[root@localhost code]# .&lt;/span&gt;/&lt;span&gt;autop
construct..
destruct..
[root@localhost code]#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体实现代码如下，构造函数只实现了初始化构造和拷贝构造：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; template&amp;lt;typename T&amp;gt;
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; auto_pt
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;explicit&lt;/span&gt; auto_pt(T* p =&lt;span&gt; NULL):m_ptr(p)
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;         p =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;auto_ptr construct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;    }    
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     
&lt;span&gt; 15&lt;/span&gt;     auto_pt(auto_pt&amp;amp;&lt;span&gt; autoPtr):m_ptr(autoPtr.m_ptr)
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;         autoPtr.m_ptr =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;copy auto_ptr construct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     auto_pt&amp;amp; &lt;span&gt;operator&lt;/span&gt; = (auto_pt&amp;amp;&lt;span&gt; p)    
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt; != &amp;amp;&lt;span&gt;p)
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(m_ptr !=&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;                 &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; m_ptr;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;                 m_ptr =&lt;span&gt; p.m_ptr;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;                 p.m_ptr =&lt;span&gt; NULL;    
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         
&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;     ~&lt;span&gt;auto_pt()
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(m_ptr !=&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;auto_ptr destruct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;             &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; m_ptr;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             m_ptr =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;             
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;     T*&lt;span&gt; Get()
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_ptr;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt;     T&amp;amp; &lt;span&gt;operator&lt;/span&gt;*&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;m_ptr;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;     T* &lt;span&gt;operator&lt;/span&gt;-&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_ptr;    
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;     
&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;     T*&lt;span&gt; m_ptr;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    Test()
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;construct..&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;     
&lt;span&gt; 74&lt;/span&gt;     ~&lt;span&gt;Test()    
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;destruct..&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     
&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method()
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;welcome Test..&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; f(auto_pt&amp;lt;Test&amp;gt;&lt;span&gt;ap)
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;funtion f :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;     ap-&amp;gt;&lt;span&gt;method();
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;baseic test&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;     Test* p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test();
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address0 [%p]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; p &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     auto_pt&amp;lt;Test&amp;gt;&lt;span&gt; ap(p);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     
&lt;span&gt; 98&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address1 [%p]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; ap.Get()&amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address2 [%p]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;ap &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address3 [%p]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;(*ap) &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt;     ap.Get()-&amp;gt;&lt;span&gt;method();
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     (*&lt;span&gt;ap).method();
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;     ap-&amp;gt;&lt;span&gt;method();
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@localhost code]# g++ -o autop_test test.&lt;span&gt;cpp&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt; [root@localhost code]# ./&lt;span&gt;autop_test 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;construct..
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; address0 [%p]&lt;span&gt;0xb77010&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;auto_ptr construct
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; address1 [%p]&lt;span&gt;0xb77010&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; address2 [%p]&lt;span&gt;0x7ffe8b25f510&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; address3 [%p]&lt;span&gt;0xb77010&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;welcome Test..
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;welcome Test..
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;welcome Test..
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;auto_ptr destruct
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;destruct..
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; [root@localhost code]# 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　大概实现就是这样，基本和标准库差不多，除了另外两种类型的构造函数没有加进去&lt;/p&gt;
&lt;p&gt;　　那在我们使用及实现的过程中，发现这个auto_ptr在使用过程中会有如下风险，因此在C++11中已经不再使用，那在我们开发过程中，也最好不要再使用&lt;/p&gt;
&lt;p&gt;1. 两个auto_ptr指向同一块内存，造成多次释放&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if 2 object point one address, application will die&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; Test* p1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; auto_pt&amp;lt;Test&amp;gt;&lt;span&gt; ap1(p1);    
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; auto_pt&amp;lt;Test&amp;gt; ap2(p1);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 复制完成后，会将复制的对象置空，因此不能继续使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;*p=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; auto_pt&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;ap1(p);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; auto_pt&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;ap2=&lt;span&gt;ap1;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; (*ap1).method();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误，此时ap1只剩一个null指针在手了&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 函数形参使用值传递，会发生拷贝操作，导致ap1对象权限获取不到了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; f(auto_pt&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;ap)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     (*&lt;span&gt;ap).method();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;  
&lt;span&gt;6&lt;/span&gt; auto_pt&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;ap1(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;f(ap1);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; (*ap1).method();;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误，经过f(ap1)函数调用，ap1已经不再拥有任何对象了。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 22 Apr 2018 14:23:00 +0000</pubDate>
<dc:creator>还在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blog-yejy/p/8910071.html</dc:identifier>
</item>
<item>
<title>Android技术分享-文字转语音并朗读 - 代码之间</title>
<link>http://www.cnblogs.com/wangleiblog/p/8909837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangleiblog/p/8909837.html</guid>
<description>&lt;h2&gt;Android技术分享-文字转语音并朗读&lt;/h2&gt;
&lt;p&gt;最近在做一个项目，其中有一个功能是需要将文本转换成语音并播放出来。下面我将我的做法分享一下。&lt;/p&gt;
&lt;p&gt;非常令人开心的是，&lt;code&gt;Android&lt;/code&gt;系统目前已经集成了&lt;code&gt;TTS&lt;/code&gt;，提供了相关的库供我们进行调用，不必到处去搜寻第三方库，直接导入&lt;code&gt;android.speech.tts.TextToSpeech&lt;/code&gt;即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//导入TTS的包
import android.speech.tts.TextToSpeech;  
//定义一个tts对象
private TextToSpeech tts;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其次，要想实例化这个对象需要两个参数，一个是&lt;code&gt;Context&lt;/code&gt;对象,另一个是&lt;code&gt;TextToSpeech&lt;/code&gt;类对应的监听器对象：&lt;code&gt;OnLnitListener&lt;/code&gt;对象。一般&lt;code&gt;Context&lt;/code&gt;对象传入当前的&lt;code&gt;Activity&lt;/code&gt;，&lt;code&gt;OnLnitListener&lt;/code&gt;可以自己写类继承，并实现其方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//导入监听包
import android.speech.tts.TextToSpeech.OnInitListener;  

//初始化tts监听对象
tts = new TextToSpeech(this, OnInitListener);  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;OnLnitListener&lt;/code&gt;接口中只要是&lt;code&gt;onInit&lt;/code&gt;方法，其功能是对&lt;code&gt;tts&lt;/code&gt;对象进行初始化，设置一下语言，判断文字是否转换成功以及当前系统是否支持该语言。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Override  
public void onInit(int status){  
    // 判断是否转化成功  
    if (status == TextToSpeech.SUCCESS){  
        //默认设定语言为中文，原生的android貌似不支持中文。
        int result = tts.setLanguage(Locale.CHINESE);  
        if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED){  
            Toast.makeText(MainActivity.this, R.string.notAvailable, Toast.LENGTH_SHORT).show();  
        }else{
            //不支持中文就将语言设置为英文
            tts.setLanguage(Locale.US);
        }  
    }  
}  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后，只要在合适的时候调用tts转文字到语音的方法即可.&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
tts.speak(&quot;需要转化的文字&quot;, TextToSpeech.QUEUE_FLUSH, null);  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面是写的一个demo：&lt;/p&gt;
&lt;p&gt;MainActivity.java:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
 * Author: sandy
 * QQ技术交流群：439261058
 * 微信公众号：代码之间(codestravel)
**/
package com.example.ct_text2speechdemo;

import java.util.Locale;
import android.os.Bundle;
import android.app.Activity;
import android.speech.tts.TextToSpeech;
import android.speech.tts.TextToSpeech.OnInitListener;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

public class MainActivity extends Activity implements OnInitListener{
    //定义控件
    private Button speechButton;  
    private TextView speechText;  
    private TextToSpeech tts;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //初始化TTS
        tts = new TextToSpeech(this, this);
        //获取控件
        speechText = (TextView)findViewById(R.id.speechTextView);  
        speechButton = (Button)findViewById(R.id.speechButton);  
        //为button添加监听
        speechButton.setOnClickListener(new OnClickListener(){   
            @Override  
            public void onClick(View v){  
                // TODO Auto-generated method stub  
                tts.speak(speechText.getText().toString(), TextToSpeech.QUEUE_FLUSH, null);  
            }  
        });  
        
    }
    
    @Override  
    public void onInit(int status){  
        // 判断是否转化成功  
        if (status == TextToSpeech.SUCCESS){  
            //默认设定语言为中文，原生的android貌似不支持中文。
            int result = tts.setLanguage(Locale.CHINESE);  
            if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED){  
                Toast.makeText(MainActivity.this, R.string.notAvailable, Toast.LENGTH_SHORT).show();  
            }else{
                //不支持中文就将语言设置为英文
                tts.setLanguage(Locale.US);
            }  
        }  
    }  

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完整代码参见 &lt;a href=&quot;https://github.com/codestravel/CT_Android_demos/tree/master/CT_Text2SpeechDemo&quot; target=&quot;_blank&quot;&gt;https://github.com/codestravel/CT_Android_demos/tree/master/CT_Text2SpeechDemo&lt;/a&gt;&lt;a href=&quot;https://github.com/codestravel/CT_Android_demos/tree/master/CT_Text2SpeechDemo&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入qq技术交流群：439261058&lt;/p&gt;
&lt;p&gt;微信公众号：代码之间（codestravel）&lt;/p&gt;

</description>
<pubDate>Sun, 22 Apr 2018 13:55:00 +0000</pubDate>
<dc:creator>代码之间</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangleiblog/p/8909837.html</dc:identifier>
</item>
<item>
<title>【Python3.6+Django2.0+Xadmin2.0系列教程之三（入门篇-下）】学生信息管理系统 - 纵世科技</title>
<link>http://www.cnblogs.com/v88v/p/8909845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/v88v/p/8909845.html</guid>
<description>&lt;p&gt;上一篇我们已经初步的构建起了一个学生管理系统的模型，现在接着来继续完善它吧。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、上传图片/文件等资源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有时候需要添加一些附件，例如，&lt;span&gt;&lt;span&gt;新生刚入学，大家相互之间还不熟悉，希望能通过照片来加深印象，并且方便教学管理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;首先，对demo/urls.py文件进行改造，给urlpatterns添加static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
urlpatterns =&lt;span&gt; [
    path(r&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;, xadmin.site.urls),
] &lt;/span&gt;+ static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在demo/settings.py文件中添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
# 指定上传位置&lt;br/&gt;LOCATION = os.path.join(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Users&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;babybus&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;# 媒体文件根目录&lt;br/&gt;MEDIA_ROOT &lt;/span&gt;= os.path.join(LOCATION, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Media&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

ROOT_URL &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

MEDIA_URL &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/media/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上传图片涉及到路径的获取，在models.py文件中导入os模块&lt;/p&gt;

&lt;p&gt;在models.py文件的Students类中添加一个路径获取的方法及models.ImageField字段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_photo(self, filename):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; os.path.join(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;photo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s_%s_%s_%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (self.class_name, self.name, self.id, os.path.splitext(filename)[1]))
&lt;/pre&gt;
&lt;pre&gt;
photo = models.ImageField(verbose_name='照片', upload_to=get_photo, blank=True, null=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时同步一下数据库操作，这样页面就多出一个照片上传的选项了，选择好照片并保存：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/824940/201804/824940-20180422210032733-270553993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、筛选、过滤、排序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）筛选&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今年学校的录取率爆满，生源特别好，要在一个数据库中找到对应的学生，必然需要用到搜索功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改adminx.py文件，在StudentsAdmin类中添加:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
search_fields = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/824940/201804/824940-20180422212118793-991546427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;要是我们想通过班级或者学科来查找这个班级或者选修这门学科的所有学生，方法还会是一样的吗？我们先试试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
search_fields = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;class_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;subjects&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果，报错了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/824940/201804/824940-20180422212354712-304959810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是怎么回事呢？原来，我们搜的“班级”和“学科”这两个字段一个是外键一个是含有多对多关系，Student模型中的这两个字段名称并不是其实际名称，要在字段后加“__”两个下划线，然后再添加外键或多对多关系实际的字段名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
search_fields = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;class_name__class_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;subjects__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/824940/201804/824940-20180422212903862-1805569199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在妥妥的了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）过滤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果只想查看学生表中的男生或者女生的信息，那就用到了过滤功能：&lt;/p&gt;
&lt;p&gt;修改adminx.py文件，在StudentsAdmin类中添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
list_filter = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/824940/201804/824940-20180422213252169-439419509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3）排序：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果想让学生按某字段的顺序来排序，同样我们需要在adminx.py文件中的StudentsAdmin类中添加ordering选项：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;# 顺序排序&lt;br/&gt;ordering = ('age', 'name', )&lt;/p&gt;
&lt;p&gt;# 逆序排序，在前面加一个减号&quot;-&quot;，例如按年龄倒序排列&lt;/p&gt;
&lt;p&gt;ordering = ('-age',)&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这表示同时按照年龄和姓名字段来排序。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、定制网站信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们希望登录网站的时候，显示站点的名称，修改adminx.py文件，添加LoginViewAdmin类，并注册：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; xadmin.views.website &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LoginView

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoginViewAdmin(LoginView):
    title &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;学生信息管理系统&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;


xadmin.site.register(LoginView, LoginViewAdmin)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/824940/201804/824940-20180422214140818-362559964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;还可以继续修改，例如浏览器标题和左上角的网页标题以及页脚的版权信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; xadmin.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; CommAdminView
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GlobalSetting(CommAdminView):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 左上角及浏览器标题&lt;/span&gt;
    site_title = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;学生信息管理系统&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页脚版权信息&lt;/span&gt;
    site_footer = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Copyright © 2018 宝宝巴士&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;


xadmin.site.register(CommAdminView, GlobalSetting)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/824940/201804/824940-20180422214738485-672262954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 左侧边栏如果以后项目越来越多了，有一个归类会更好看些，也方便管理操作。这就需要在GlobalSetting类中添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
menu_style = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;accordion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/824940/201804/824940-20180422215113360-1728529702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;Xadmin入门就到此为止吧，在后续的博文中我会继续深入讲解Django+Xadmin的进阶用法和操作。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 22 Apr 2018 13:55:00 +0000</pubDate>
<dc:creator>纵世科技</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/v88v/p/8909845.html</dc:identifier>
</item>
<item>
<title>数据挖掘实战:数据质量检查 - hbsygfz</title>
<link>http://www.cnblogs.com/hbsygfz/p/8909761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hbsygfz/p/8909761.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;数据行业有一句很经典的话——“垃圾进，垃圾出”（Garbage in, Garbage out, GIGO），意思就是，如果使用的基础数据有问题，那基于这些数据得到的任何产出都是没有价值的。而对于数据分析挖掘而言，只有一份高质量的基础数据，才可能得到正确、有用的结论。本文主要介绍数据质量检查的基本思路和方法，并基于Python进行具体实现。&lt;br/&gt;另外，数据质量检查是数据治理中的一个重要课题，涉及内容广，由于笔者经验水平有限，本文不做涉及，只从分析挖掘中的数据质量检查工作说起。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;数据质量检查是在完成宽表数据开发后进行的，主要包括四个方面：重复值检查、缺失值检查、数据倾斜问题、异常值检查。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;重复值检查&quot;&gt;1. 重复值检查&lt;/h2&gt;
&lt;h3 id=&quot;什么是重复值&quot;&gt;1.1 什么是重复值&lt;/h3&gt;
&lt;p&gt;重复值的检查首先要明确一点，即重复值的定义。对于一份二维表形式的数据集来说，什么是重复值？主要有&lt;strong&gt;两个层次&lt;/strong&gt;：&lt;br/&gt;① 关键字段出现重复记录，比如主索引字段出现重复；&lt;br/&gt;② 所有字段出现重复记录。&lt;br/&gt;第一个层次是否是重复，必须从这份数据的业务含义进行确定。比如一张表，从业务上讲，一个用户应该只会有一条记录，那么如果某个用户出现了超过一条的记录，那么这就是重复值。第二个层次，就一定是重复值了。&lt;/p&gt;
&lt;h3 id=&quot;重复值产生的原因&quot;&gt;1.2 重复值产生的原因&lt;/h3&gt;
&lt;p&gt;重复值的产生主要有&lt;strong&gt;两个原因&lt;/strong&gt;，一是上游源数据造成的，二是数据准备脚本中的数据关联造成的。从数据准备角度来看，首先检查数据准备的脚本，判断使用的源表是否有重复记录，同时检查关联语句的正确性和严谨性，比如关联条件是否合理、是否有限定数据周期等等。&lt;br/&gt;比如：检查源表数据是否重复的SQL：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT MON_ID,COUNT(*),COUNT(DISTINCT USER_ID)
FROM TABLE_NAME
GROUP BY MON_ID;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是上游源数据出现重复，那么应该及时反映给上游进行修正；如果是脚本关联造成的，修改脚本，重新生成数据即可。&lt;br/&gt;还有一份情况，这份数据集是一份单独的数据集，并不是在数据仓库中开发得到的数据，既没有上游源数据，也不存在生成数据的脚本，比如公开数据集，那么如何处理其中的重复值？一般的处理方式就是直接删除重复值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pandas as pd
dataset = pd.read_excel(&quot;/labcenter/python/dataset.xlsx&quot;)
#判断重复数据
dataset.duplicated()    #全部字段重复是重复数据
dataset.duplicated(['col2'])    #col2字段重复是重复数据
#删除重复数据
dataset.drop_duplicates()     #全部字段重复是重复数据
dataset.drop_duplicates(['col2'])   #col2字段重复是重复数据&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;附：本文数据集：dataset.xlsx&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201804/554583-20180422214340421-1853854382.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;缺失值检查&quot;&gt;2. 缺失值检查&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;缺失值主要是指数据集中部分记录存在部分字段的信息缺失。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;缺失值出现的原因&quot;&gt;2.1 缺失值出现的原因&lt;/h3&gt;
&lt;p&gt;出现趋势值主要有&lt;strong&gt;三种原因&lt;/strong&gt;：&lt;br/&gt;① 上游源系统因为技术或者成本原因无法完全获取到这一信息，比如对用户手机APP上网记录的解析；&lt;br/&gt;② 从业务上讲，这一信息本来就不存在，比如一个学生的收入，一个未婚者的配偶姓名；&lt;br/&gt;③ 数据准备脚本开发中的错误造成的。&lt;br/&gt;第一种原因，短期内无法解决；第二种原因，数据的缺失并不是错误，无法避免；第三种原因，则只需通过查证修改脚本即可。&lt;br/&gt;缺失值的存在既代表了某一部分信息的丢失，也影响了挖掘分析结论的可靠性与稳定性，因此，必须对缺失值进行处理。&lt;br/&gt;&lt;strong&gt;如果缺失值记录数超过了全部记录数的50%，则应该从数据集中直接剔除掉该字段，尝试从业务上寻找替代字段；&lt;br/&gt;如果缺失值记录数没有超过50%，则应该首先看这个字段在业务上是否有替代字段，如果有，则直接剔除掉该字段，如果没有，则必须对其进行处理。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#查看哪些字段有缺失值   
dataset.isnull().any()    #获取含有NaN的字段
#统计各字段的缺失值个数
dataset.isnull().apply(pd.value_counts)
#删除含有缺失值的字段
nan_col = dataset.isnull().any()
dataset.drop(nan_col[nan_col].index,axis=1)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;缺失值的处理&quot;&gt;2.2 缺失值的处理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;缺失值的处理主要有两种方式：过滤和填充。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;缺失值的过滤&quot;&gt;（1）缺失值的过滤&lt;/h4&gt;
&lt;p&gt;直接删除含有缺失值的记录，总体上会影响样本个数，如果删除样本过多或者数据集本来就是小数据集时，这种方式并不建议采用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#删除含有缺失值的记录
dataset.dropna()&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;缺失值的填充&quot;&gt;（2）缺失值的填充&lt;/h4&gt;
&lt;p&gt;缺失值的填充主要&lt;strong&gt;三种方法&lt;/strong&gt;：&lt;br/&gt;&lt;strong&gt;① 方法一：使用特定值填充&lt;/strong&gt;&lt;br/&gt;使用缺失值字段的平均值、中位数、众数等统计量填充。&lt;br/&gt;优点：简单、快速&lt;br/&gt;缺点：容易产生数据倾斜&lt;br/&gt;&lt;strong&gt;② 方法二：使用算法预测填充&lt;/strong&gt;&lt;br/&gt;将缺失值字段作为因变量，将没有缺失值字段作为自变量，使用决策树、随机森林、KNN、回归等预测算法进行缺失值的预测，用预测结果进行填充。&lt;br/&gt;优点：相对精确&lt;br/&gt;缺点：效率低，如果缺失值字段与其他字段相关性不大，预测效果差&lt;br/&gt;&lt;strong&gt;③ 方法三：将缺失值单独作为一个分组，指定值进行填充&lt;/strong&gt;&lt;br/&gt;从业务上选择一个单独的值进行填充，使缺失值区别于其他值而作为一个分组，从而不影响算法计算。&lt;br/&gt;优点：简单，实用&lt;br/&gt;缺点：效率低&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#使用Pandas进行特定值填充
dataset.fillna(0)   #不同字段的缺失值都用0填充
dataset.fillna({'col2':20,'col5':0})    #不同字段使用不同的填充值
dataset.fillna(dataset.mean())   #分别使用各字段的平均值填充
dataset.fillna(dataset.median())     #分别使用个字段的中位数填充

#使用sklearn中的预处理方法进行缺失值填充(只适用于连续型字段)
from sklearn.preprocessing import Imputer
dataset2 = dataset.drop(['col4'],axis=1)
colsets = dataset2.columns
nan_rule1 = Imputer(missing_values='NaN',strategy='mean',axis=0)    #创建填充规则(平均值填充)
pd.DataFrame(nan_rule1.fit_transform(dataset2),columns=colsets)    #应用规则
nan_rule2 = Imputer(missing_values='median',strategy='mean',axis=0) #创建填充规则(中位数填充)
pd.DataFrame(nan_rule2.fit_transform(dataset2),columns=colsets)    #应用规则
nan_rule3 = Imputer(missing_values='most_frequent',strategy='mean',axis=0)  #创建填充规则(众数填充)
pd.DataFrame(nan_rule3.fit_transform(dataset2),columns=colsets)    #应用规则&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;数据倾斜问题&quot;&gt;3. 数据倾斜问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数据倾斜是指字段的取值分布主要集中在某个特定类别或者特定区间。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据倾斜问题的原因&quot;&gt;3.1 数据倾斜问题的原因&lt;/h3&gt;
&lt;p&gt;出现这一问题的&lt;strong&gt;原因主要有三种&lt;/strong&gt;：&lt;br/&gt;① 上游源数据存在问题；&lt;br/&gt;② 数据准备脚本的问题；&lt;br/&gt;③ 数据本身的分布就是如此。&lt;br/&gt;如果某个字段出现数据倾斜问题，必须首先排查上述第一、二种原因，如果都没有问题或者无法检查（如：单独的数据集），那么就要考虑这个字段对后续的分析建模是否有价值。一般来说，有严重的数据倾斜的字段对目标变量的区分能力很弱，对分析建模的价值不大，应该直接剔除掉。&lt;/p&gt;
&lt;h3 id=&quot;如何衡量数据的倾斜程度&quot;&gt;3.2 如何衡量数据的倾斜程度&lt;/h3&gt;
&lt;p&gt;衡量数据的倾斜程度，主要采用频数分析方法，但因数据类别的不同而有所差异：&lt;br/&gt;① 针对连续型字段，需要首先采用等宽分箱方式进行离散化，然后计算各分箱的记录数分布；&lt;br/&gt;② 针对离散型字段，直接计算各类别的记录数分布。&lt;br/&gt;一般来说，如果某个字段90%以上的记录数，主要集中在某个特定类别或者特定区间，那么这个字段就存在严重的数据倾斜问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#对于连续型变量进行等宽分箱
pd.value_counts(pd.cut(dataset['col3'],5))  #分成5箱
#对于离散型变量进行频数统计
pd.value_counts(dataset['col4'])&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;异常值检查&quot;&gt;4. 异常值检查&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;异常值是指数据中出现了处于特定分布、范围或者趋势之外的数据，这些数据一般会被成为异常值、离群点、噪音等。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;异常值产生的原因&quot;&gt;4.1 异常值产生的原因&lt;/h3&gt;
&lt;p&gt;异常值的产生主要有&lt;strong&gt;两类原因&lt;/strong&gt;：&lt;br/&gt;① 数据采集、生成或者传递过程中发生的错误；&lt;br/&gt;② 业务运营过程出现的一些特殊情况。&lt;br/&gt;将第一种原因产生的异常值称为&lt;strong&gt;统计上的异常&lt;/strong&gt;，这是错误带来的数据问题，需要解决；将第二种原因产生的异常值称为&lt;strong&gt;业务上的异常&lt;/strong&gt;，反映了业务运营过程的某种特殊结果，它不是错误，但需要深究，在数据挖掘中的一种典型应用就是异常检测模型，比如信用卡欺诈，网络入侵检测、客户异动行为识别等等。&lt;/p&gt;
&lt;h3 id=&quot;异常值的识别方法&quot;&gt;4.2 异常值的识别方法&lt;/h3&gt;
&lt;p&gt;异常值的识别方法主要有以下几种：&lt;/p&gt;
&lt;h4 id=&quot;极值检查&quot;&gt;（1）极值检查&lt;/h4&gt;
&lt;p&gt;主要检查字段的取值是否超出了合理的值域范围。&lt;br/&gt;&lt;strong&gt;① 方法一：最大值最小值&lt;/strong&gt;&lt;br/&gt;使用最大值、最小值进行判断。比如客户年龄的最大值为199岁，客户账单的最小费用为-20，这些都明显存在异常。&lt;br/&gt;&lt;strong&gt;② 方法二：3σ原则&lt;/strong&gt;&lt;br/&gt;如果数据服从正态分布，在3σ原则下，异常值被定义为与平均值的偏差超过了3倍标准差的值。这是因为，在正态分布的假设下，具体平均值3倍标准差之外的值出现的概率低于0.003，属于极个别的小概率事件。&lt;br/&gt;&lt;strong&gt;③ 方法三：箱线图分析&lt;/strong&gt;&lt;br/&gt;箱线图提供了识别异常的标准：异常值被定义为小于下四分位-1.5倍的四分位间距，或者大于上四分位+1.5倍的四分位间距的值。&lt;br/&gt;箱线图分析不要求数据服从任何分布，因此对异常值的识别比较客观。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#计算相关统计指标
statDF = dataset2.describe()  #获取描述性统计量
statDF.loc['mean+3std'] = statDF.loc['mean'] + 3 * statDF.loc['std']  #计算平均值+3倍标准差
statDF.loc['mean-3std'] = statDF.loc['mean'] - 3 * statDF.loc['std']  #计算平均值-3倍标准差
statDF.loc['75%+1.5dist'] = statDF.loc['75%'] + 1.5 * (statDF.loc['75%'] - statDF.loc['25%'])  #计算上四分位+1.5倍的四分位间距
statDF.loc['25%-1.5dist'] = statDF.loc['25%'] - 1.5 * (statDF.loc['75%'] - statDF.loc['25%'])  #计算下四分位-1.5倍的四分位间距
#获取各字段最大值、最小值
statDF.loc[['max','min']]
#判断取值是否大于平均值+3倍标准差
dataset3 = dataset2 - statDF.loc['mean+3std']
dataset3[dataset3&amp;gt;0]
#判断取值是否小于平均值-3倍标准差
dataset4 = dataset2 - statDF.loc['mean-3std']
dataset4[dataset4&amp;lt;0]
#判断取值是否大于上四分位+1.5倍的四分位间距
dataset5 = dataset2 - statDF.loc['75%+1.5dist']
dataset5[dataset5&amp;gt;0]
#判断取值是否小于下四分位-1.5倍的四分位间距
dataset6 = dataset2 - statDF.loc['25%-1.5dist']
dataset6[dataset6&amp;lt;0]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;记录数分布检查&quot;&gt;（2）记录数分布检查&lt;/h4&gt;
&lt;p&gt;主要检查字段的记录数分布是否超出合理的分布范围，包括三个指标：零值记录数、正值记录数、负值记录数。&lt;/p&gt;
&lt;h4 id=&quot;波动检查&quot;&gt;（3）波动检查&lt;/h4&gt;
&lt;p&gt;波动检查主要适用于有监督的数据，用于检查随着自变量的变化，因变量是否发生明显的波动情况。&lt;br/&gt;以上异常值的识别方法主要针对连续型的字段，而对于离散型的字段的异常识别主要通过检查类别出现是否出现了合理阈值外的数据，比如苹果终端型号字段，出现了“P20”的取值。&lt;/p&gt;
&lt;h3 id=&quot;异常值的处理&quot;&gt;4.3 异常值的处理&lt;/h3&gt;
&lt;p&gt;对于统计上的异常值的处理，主要采取两种方式：剔除或者替换。剔除是指直接将被标记为异常值的记录从数据集中删除掉，而替换是指将异常值用一个非异常值进行替换，比如边界值，或者有监督情况下的目标变量表征相似的某个值。&lt;br/&gt;对于业务上的异常值的处理，原则就是进行深入探索分析，查找出现这一特殊情况的根本原因。&lt;/p&gt;

&lt;h2 id=&quot;参考与感谢&quot;&gt;5.参考与感谢&lt;/h2&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://book.douban.com/subject/27608466/&quot;&gt;Python数据分析与数据化运营&lt;/a&gt;&lt;br/&gt;[2] &lt;a href=&quot;https://book.douban.com/subject/26677686/&quot;&gt;Python数据分析与数据挖掘实战&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Apr 2018 13:49:00 +0000</pubDate>
<dc:creator>hbsygfz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hbsygfz/p/8909761.html</dc:identifier>
</item>
<item>
<title>零开始：NetCore项目权限管理系统：基础框架搭建 - 付裕</title>
<link>http://www.cnblogs.com/fuyu-blog/p/8909779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fuyu-blog/p/8909779.html</guid>
<description>&lt;blockquote readability=&quot;13.79185520362&quot;&gt;
&lt;p&gt;有兴趣的同学可以一起做&lt;/p&gt;
&lt;p&gt;框架使用NetCore  RazorPages   数据库采用Mysql        ORM用的是SqlSugar&lt;/p&gt;
&lt;p&gt;喜欢NetCore的朋友，欢迎加群QQ：86594082&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/feiyit/SoaProJect&quot; target=&quot;_blank&quot;&gt;https://github.com/feiyit/SoaProJect&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我用的ORM不是EF   用了国人牛人写的SqlSugar   有兴趣的可以看下，非常好用  地址奉上：&lt;a href=&quot;http://www.codeisbug.com/&quot; target=&quot;_blank&quot;&gt;http://www.codeisbug.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新建一个空的解决方案，建立对应的解决方案文件夹&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/150330/201804/150330-20180422213721160-189337408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;FytSoa.Api  webApi服务&lt;/p&gt;
&lt;p&gt;FytSoa.Core  存放数据库操作对象，比如EF上下文或者其他ORM，以及保存数据库基础的模型&lt;/p&gt;
&lt;p&gt;FytSoa.Service  存放接口以及接口实现 &lt;/p&gt;
&lt;p&gt;FytSoa.Common 存放一些基础的工具类&lt;/p&gt;
&lt;p&gt;FytSoa.Extensions 存放一些对Core扩展的方法，如DI&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在FytSoa.Core添加sqlSugarCore的引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/150330/201804/150330-20180422221620825-1916470610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;再添加Mysql支持&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/150330/201804/150330-20180422222009234-816495228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在FytSoa.Core创建Orm连接数据库方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FytSoa.Core
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 数据库上下文
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DbContext()
        {
            Db &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SqlSugarClient(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionConfig()
            {
                ConnectionString &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server=localhost;database=fyt_ims;uid=root;pwd=123456;charset='utf8';SslMode=None&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                DbType &lt;/span&gt;=&lt;span&gt; DbType.MySql,
                IsAutoCloseConnection &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            });
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SqlSugarClient Db;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来处理事务多表查询和复杂的操作&lt;/span&gt;
&lt;span&gt;        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 数据库连接字符串应该是读取配置文件的，有兴趣的可以看我另一篇文章   &lt;a href=&quot;http://www.cnblogs.com/fuyu-blog/p/8906060.html&quot; target=&quot;_blank&quot;&gt;每天记录一点：NetCore获得配置文件 appsettings.json&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Apr 2018 13:47:00 +0000</pubDate>
<dc:creator>付裕</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fuyu-blog/p/8909779.html</dc:identifier>
</item>
<item>
<title>连载《一个程序猿的生命周期》-《发展篇》- 21.“中兴事件”反应出的价值偏差 - 一个程序猿的生命周期</title>
<link>http://www.cnblogs.com/blog470130547/p/8909593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blog470130547/p/8909593.html</guid>
<description>&lt;p&gt;&lt;span&gt;       “中兴事件”后国内大多数人像打了鸡血一样，站在道德的制高点进行分析、批判，大道理谁都懂。这种“道德制高点”到底是公德还是私德不好说，就像现在的鸡汤文章多了，谁也分不清是真鸡汤还是假鸡汤，相认绝大多数人只不是过是利用碎片时间发表言论的看客而已。事件过后，绝大多数人仍然照旧，被大城市的浮华掩盖了反思精神，一点反抗力都没有。我做过一些事情，不断的反思自己和感悟，以前有过思考，借“中兴事件”写写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;strong&gt;1.IT工程师的应用能力和开发能力&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          现在大数据比较火，使用Hadoop、Hive、Pig等开发的工具却比写框架的人工薪还高。就是说一个连C/S结构客户端都写不好的人，使用这些工具却能一个月多拿5000元。学校每年毕业学生，工作几年后能写好代码的人不多。面对这种情况又很难改变，可能大家说存在即合理，正所谓“人才”市场化，我无力反驳。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/691334/201804/691334-20180422211905954-801988272.png&quot; alt=&quot;&quot; width=&quot;344&quot; height=&quot;79&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       &lt;strong&gt;2.农民生产的产品&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         有些农民凭良心种植出来的好东西，仍然不会有更多的回报。当然这里有多方面因素，在此我举一个例子：真正山里散养的鸡蛋，卖给城里人，他们说这鸡蛋太小了。环境温度、不喂饲料、不吃配方，它只能这么小呀。原生态的东西就是这样的形状、这样的颜色、这样的味道，但是要符合市场化的需求，那只能通过其他方式实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       两个是典型的例子，这样的价值偏差是认知偏差造成的，认知偏差是价值观造成的。我们宣传用市场换技术嘛，核心技术没换来，市场却丢了；我们宣传造不如买，没有造好，也没有买来核心技术；传外国老太太和中国老太太的故事，结果看似过上了好生活，结果造成要么买不起房要么负债累累；我们宣传black猫和white猫，耗子是抓住了，最大的共同认知就在“钱”上拉到了一个水平线。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       上次和人家喝酒，老哥说你看人家美国说打叙利亚就打，你再看看我们搞的这些事*&amp;amp;&amp;amp;^%$$##@!@#$%^&amp;amp;***&amp;amp;%$#，我还和老哥扛上了。是的，我相信国家、公司、个人的发展会越来越好，不要羡慕美国。不过老哥说的身边的事也是事实，不管怎么样还是照常生活。要想改变这些，需要每个人都要提高认知。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;hr/&gt;&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div readability=&quot;6.241134751773&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个程序猿的生命周期 微信平台&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;口   号：职业交流，职业规划；面对现实，用心去交流、感悟。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号：iterlifetime&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;百木-ITer职业交流奋斗 群：141588103&lt;/strong&gt;   &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二维码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/691334/201606/691334-20160618075950167-974887453.jpg&quot; alt=&quot;&quot; width=&quot;120&quot; height=&quot;120&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 22 Apr 2018 13:21:00 +0000</pubDate>
<dc:creator>一个程序猿的生命周期</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blog470130547/p/8909593.html</dc:identifier>
</item>
<item>
<title>设计模式就该这么学：要走心才能遵循设计模式五大原则(第二篇) - 骑白马的菜鸟</title>
<link>http://www.cnblogs.com/zishengY/p/8885691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zishengY/p/8885691.html</guid>
<description>&lt;p&gt;　　本文作为《设计模式就该这么学》系列文章的第二篇，今天我们来聊一下设计模式中的五大原则！&lt;/p&gt;&lt;p&gt;　　设计模式(面向对象)五大原则可以简称为SOLID，SOLID是面向对象设计和编程(OOD&amp;amp;OOP)中几个重要编码原则(Programming Priciple)的首字母缩写，它目的就是为了写出&lt;strong&gt;可复用、可扩展、高内聚、低耦合&lt;/strong&gt;的代码。&lt;/p&gt;&lt;p&gt;当然原则只是战略层面的指导，没有代码能完全遵守着五大原则，要根据实际（zou）情况(xin)合理取舍。&lt;/p&gt;&lt;div readability=&quot;118.5&quot;&gt;
&lt;h2&gt;二、举个例子来介绍下五大原则&lt;/h2&gt;
&lt;p class=&quot;Post-Title&quot; data-reactid=&quot;33&quot;&gt;　　　以动物爬树来讲&lt;span&gt;&lt;strong&gt;单一原则&lt;/strong&gt;&lt;/span&gt;，用一个类描述这个场景&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
class Animal {
    public void breathe(string animal)
    {
        System.out.println(animal+&quot;爬树&quot;);
    }
}
class Program
{
    static void Main(string[] args)
    {
        Animal animal = new Animal();
        animal.breathe(&quot;猫&quot;);
        animal.breathe(&quot;蛇&quot;);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们发现不是所有动物都会爬树的，比如鸟就不会爬树，根据单一职责原则，我们将Animal类细分为爬树动物类和飞翔动物类，如下所示：　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 　　class SpeelAnimal
    {
        public void pashu(string animal)
        {
            System.out.println(animal+&quot;爬树&quot;);
        }
    }
    class FlyAnimal
    {
        public void fly(string animal)
        {
                System.out.println(animal + &quot;飞翔&quot;);
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            SpeelAnimal speelAnimal = new SpeelAnimal();
            speelAnimal.pashu(&quot;蛇&quot;);
            FlyAnimal flyAnimal = new FlyAnimal();
            flyAnimal.breathe(&quot;麻雀&quot;);
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　我们发现这样修改的花销很大，既要将原来的类分解，又要修改客户端。而直接修改Animal类虽然违背了单一职责原则，但花销小的多，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
class Animal
{
    public void action(string animal)
    {
        if (&quot;麻雀&quot;.Equals(animal))
        {
            System.out.println(animal + &quot;飞翔&quot;);
        }
        else {
            System.out.println(animal + &quot;攀爬&quot;);
        }
    }
}
class Program
{
    static void Main(string[] args)
    {
        Animal animal = new Animal();
        animal.action(&quot;蛇&quot;);
        animal.action(&quot;麻雀&quot;);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　可以看到，这样代码量少了很多，可还有一个问题，鸡会打鸣，而蛇不会，有一天需要增加鸡打鸣的方法，会发现又要直接修改上面的方法，这种修改直接在代码级别违背了单一职责原则，虽然修改起来最简单，但隐患最大。还有一种修改方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
　Animal
    {
        public void pashu(string animal)
        {
            System.out.println(animal+&quot;爬树&quot;);
        }

        public void fly(string animal)
        {
                System.out.println(animal + &quot;飞翔&quot;);
        }
        
        public call()
       {
                System.out.println(animal + &quot;鸣叫&quot;);
        }
    
    }
    class Program
    {
        static void Main(string[] args)
        {
            Animal animal = new Animal();
            animal.pashu(&quot;蛇&quot;);        
            animal.call(&quot;麻雀&quot;);
        }
    }    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然违背了单一职责原则，但在方法级别上却是符合单一职责原则的。那么在实际编程中，采用哪一种呢？我的原则是，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，才可以在方法级别违反单一职责原则。　&lt;/p&gt;
&lt;p&gt;　遵循单一职责的优点：&lt;br/&gt;1)降低类的复杂度，一个类只负责一项职责。&lt;br/&gt;2)提高类的可读性，可维护性&lt;br/&gt;3)降低变更引起的风险。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;开放封闭原则&lt;/strong&gt;&lt;/span&gt;这个没什么好说的，再来说说&lt;span&gt;&lt;strong&gt;里氏替换原则，&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;它其实有两种定义，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一种定义：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换为o2，程序P的行为没有发生变化，那么类型S是类型T的子类型。&lt;/p&gt;
&lt;p&gt;第二种定义：所有引用基类的地方必须透明的使用其子类的对象。第二种定义明确的说，只要父类能出现的地方子类也可以出现，而且替换为子类不会产生任何错误或异常，但是反过来就不行，有子类出现的地方，父类未必就能适应。由定义可知，在使用继承时，会遵循里氏替换原则，集成的好处自不必多说，代码共享，重用性高，但是在子类中尽量不要重写和重载父类的方法。为什么呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;继承是侵入性的，只要继承，就必须拥有父类的所有方法和属性&lt;/li&gt;
&lt;li&gt;降低了代码的灵活性，子类必须拥有父类的属性和方法，让子类有了一些约束&lt;/li&gt;
&lt;li&gt;增加了耦合性，当父类的常量，变量和方法被修改了，需要考虑子类的修改，这种修改可能带来非常糟糕的结果，要重构大量的代码。&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;Post-Title&quot; data-reactid=&quot;33&quot;&gt;　　　接下来以一个两数相减的小李子说明一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
class A{
    public int func1(int a,int b){
        return a-b;
    }
}
public class Client{
    public static void main(string[] args){
        A a=new A();
        System.out.println(&quot;100-50=&quot;+a.func1(100,50));
        System.out.println(&quot;100-80=&quot;+a.func1(100,80));
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　运行结果：&lt;/p&gt;
&lt;p&gt;100-50=50&lt;br/&gt;100-80=20&lt;/p&gt;
&lt;p&gt;后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
Class B &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; A{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; func1(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; func2(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func1(a,b)+100&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(string[] args){
        B a&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; B();
        System.out.println(&lt;/span&gt;&quot;100-50=&quot;+b.func1(100,50&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;100-80=&quot;+b.func1(100,80&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;100+20+100=&quot;+b.func2(100,20&lt;span&gt;));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;100-50=150&lt;br/&gt;100-80=180&lt;br/&gt;100+20+100=220&lt;/p&gt;
&lt;p&gt;我们发现原来运行正常的相减功能发生了错误，这就是因为重写A类中的方法导致。&lt;/p&gt;
&lt;p&gt;所以如果非要重写父类的方法，通用的做法是：原来的父类和子类&lt;strong&gt;都继承一个更通俗的基类&lt;/strong&gt;，原有的继承关系去掉，采用依赖，聚合，组合等关系代替&lt;/p&gt;
&lt;p&gt;接下来说说&lt;span&gt;&lt;strong&gt;依赖导致原则&lt;/strong&gt;&lt;span&gt;，它的定义是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高层模块不应该依赖低层模块，两者都应该依赖抽象&lt;/li&gt;
&lt;li&gt;抽象不应该依赖细节&lt;/li&gt;
&lt;li&gt;细节应该依赖抽象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;依赖倒置原则可以说是这里面最难用的一个原则了，那为什么我们还要要遵循依赖倒置原则？接下来以一个看视频的例子说明下问题，张三喜欢看douyin小视频&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/847059/201804/847059-20180422204036523-1013537181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Bibili类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bibili类{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读文学经典&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; watch(){
       System.out.println(&lt;/span&gt;&quot;看douyin视频&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 再来看张三类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;张三类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Zhangsan{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读文学经典&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; watch(douyin bili){
        bili.watch();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;场景类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client{
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(Strings[] args){
      Zhangsan zhangsan &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Zhangsan();
      douyin  bili &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; douyin ();
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;zhangsan看douyin视频&lt;/span&gt;
&lt;span&gt;      zhangsan.watch(bili);
   }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;张三看了一段时间的小视频时候，又想看电视机剧《白夜追凶》，发现这个只在优酷才能看，于是实现一个优酷类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Youku{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;看电视剧&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; watch(){
       System.out.println(&lt;/span&gt;&quot;看白夜追凶&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们再来看代码，发现张三类的read方法只与Bilibi类是强依赖，紧耦合关系，张三竟然阅读不了小说类。这与现实明显的是不符合的，代码设计的是有问题的。那么问题在那里呢？&lt;br/&gt;我们看张三类，此类是一个高层模块，并且是一个细节实现类，此类依赖的是一个Bilibi类，而Bilibi类也是一个细节实现类。这是不是就与我们说的依赖倒置原则相违背呢？依赖倒置原则是说我们的高层模块，实现类，细节类都应该是依赖与抽象，依赖与接口和抽象类。&lt;br/&gt;为了解决张三看电影的问题，我们根据依赖倒置原则先抽象一个阅读者接口,下面是完整的uml类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/847059/201804/847059-20180422205419042-57023883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;观看者接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Watcher{
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; watch(Watcher watch){
       watch.watch();
   }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;视频接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Video{
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;被观看&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; video();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再定义douyin类和Youku类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;douyin类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; douyin &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Watcher{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; watcher(){
       System.out.println(&lt;/span&gt;&quot;看douyin小视频&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Youku类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Youku &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Watcher{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; watcher(){
       System.out.println(&lt;/span&gt;&quot;看白夜追凶&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后实现张三类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;张三类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Zhasan &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Video{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;观看&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; watch(Video video){
        video.watch();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再让张三来看douyin视频和优酷电视剧《白夜追凶》&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client{
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(Strings[] args){
      Watcher zhansan &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Zhansan();
      Video douyin &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; douyin();
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;张三看douyin小视频&lt;/span&gt;
&lt;span&gt;      zhangsan.watch(douyin);

      Video youku &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Youku();
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;张三看douyin小视频&lt;/span&gt;
&lt;span&gt;      zhangsan.watch(youku);
   }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，张三是可以看douyin小视频，又可以看优酷电视剧《白夜追凶》了，目的达到了。&lt;/p&gt;
&lt;p&gt;为什么依赖抽象的接口可以适应变化的需求？这就要从接口的本质来说，接口就是把一些公司的方法和属性声明，然后具体的业务逻辑是可以在实现接口的具体类中实现的。所以我们当依赖对象是接口时，就可以适应所有的实现此接口的具体类变化。由此也可以看出依赖倒置原则用好可以减少类间的耦合性，提高系统的稳定，降低并行开发引起的风险，提高代码的可读性和可维护性。&lt;/p&gt;

&lt;p&gt;至此，设计模式的五大原则介绍完毕，接下来一篇文章我会以微信订阅号来讲观察者模式，同时会讲到实际应用的一个例子！&lt;/p&gt;

&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p class=&quot;Post-Title&quot; data-reactid=&quot;33&quot;&gt; 学习本就是一个不断模仿、练习、再到最后面自己原创的过程。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;虽然可能从来不能写出超越网上通类型同主题博文，但为什么还是要写？&lt;br/&gt;于自己而言，博文主要是自己总结。假设自己有观众，毕竟讲是最好的学（见下图）。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;于读者而言，笔者能在这个过程get到知识点，那就是双赢了。&lt;br/&gt;当然由于笔者能力有限，或许文中存在描述不正确，欢迎指正、补充！&lt;br/&gt;感谢您的阅读。如果本文对您有用，那么请点赞鼓励。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/847059/201804/847059-20180415130414994-55161475.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 22 Apr 2018 13:11:00 +0000</pubDate>
<dc:creator>骑白马的菜鸟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zishengY/p/8885691.html</dc:identifier>
</item>
<item>
<title>Entity Framework DBContext 增删改查深度解析 - SolidMango</title>
<link>http://www.cnblogs.com/pugang/p/8909414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pugang/p/8909414.html</guid>
<description>&lt;p&gt;&lt;span&gt;     　　&lt;strong&gt;&lt;span&gt;Entity Framework DBContext 增删改查深度解析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      有一段时间没有更新博客了，赶上今天外面下雨，而且没人约球，打算把最近对Entity Framework DBContext使用的心得梳理一下，早些时候在网上简单查过，对于最新版本的EF并没有类似的知识梳理类文章，希望对大家有所帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 不要Code first, 也不要DB first&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我为什么讨厌Code first和DB first呢？首先Code first是先写代码，数据库完全由代码生成，开发阶段尚可，一旦到了产品发布阶段，如果需要添加字段，我们总不能用 visual studio去生产环境上去更新数据库吧，听起来就很可怕。而且另外的一个问题自动是生成的数据库脚本也不可控，还不如自己提前设计好。DB first也好不了哪去，反向转过来的代码包含很多没有用的文件，而且数据库的更新还要重新走Model生成过程，简直无法理解为什么会有这样的设计。&lt;/span&gt;&lt;span&gt;说了这么多，怎么解决呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据库和领域模型分开设计，按照对应关系映射字段，使用自定义链接字串，既不使用领域模型生成数据库，也不用数据库生成领域模型，示例代码如下，&lt;/span&gt;&lt;span&gt;SQL Code 以 Destinations和TTable表为例：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE TABLE [DBO].[Destinations]
(
    [DestinationId] [&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;] PRIMARY KEY NOT NULL,
    [Name] [nvarchar](max) NULL,
    [Country] [nvarchar](max) NULL,
    [Description] [nvarchar](max) NULL,
    [Photo] [varbinary](max) NULL
）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;CREATE &lt;span class=&quot;s1&quot;&gt;TABLE [TTT]&lt;span class=&quot;s2&quot;&gt;.[TTable]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;[Id] [int] PRIMARY KEY &lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;NOT &lt;span class=&quot;s2&quot;&gt;NULL,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;[Name] [nvarchar]&lt;span class=&quot;s2&quot;&gt;(&lt;span class=&quot;s3&quot;&gt;max&lt;span class=&quot;s2&quot;&gt;) &lt;span class=&quot;s2&quot;&gt;NULL&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Model Class:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Model
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Destination
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DestinationId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Country { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Description { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] Photo { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Lodging&amp;gt; Lodgings { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Lodging
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; LodgingId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Owner { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsResort { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Destination Destination { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TTable
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Connect String:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;connectionStrings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;BAContext&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Data Source=(LocalDb)\MSSQLLocalDB;Initial Catalog=DataAccess.BreakAwayContext;Integrated Security=SSPI;&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;System.Data.SqlClient&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;connectionStrings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;DB Context:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data.Entity;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data.Entity.ModelConfiguration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Model;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DataAccess
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TTableConfiguration : EntityTypeConfiguration&amp;lt;TTable&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TTableConfiguration()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ToTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TTable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TTT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BreakAwayContext : DbContext
    {

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Configurations.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TTableConfiguration());
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BreakAwayContext(&lt;span&gt;string&lt;/span&gt; connString) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(connString)
        {
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Destination&amp;gt; Destinations { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Lodging&amp;gt; Lodgings { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;TTable&amp;gt; TTables { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2. 如果数据库的表的字段和领域模型的字段不对应，如何处理呢？比如本文的TTable表是在TTT  Schema下面的， 而其他表示设计在DBO下面，最方便的方式是使用fluent API, 具体代码如请参见 TTableConfiguration Class和 OnModelCreating()方法，可配置的粒度非常细，比如可以配置领域模型和数据库的哪个Schema的哪张表的哪一列对应，本文是将TTable 类的数据库表配置为了TTT  Schema下的TTable表，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TTableConfiguration : EntityTypeConfiguration&amp;lt;TTable&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TTableConfiguration()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ToTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TTable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TTT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;3. 增删该查自带事物支持，具体代码如下，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Insert()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; destination = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Destination
            {
                Country &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Description &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chs is the language package&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xsss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt; BreakAwayContext(ConfigurationManager.ConnectionStrings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BAContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ConnectionString))
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rt =&lt;span&gt; context.Destinations.Add(destination);
                context.SaveChanges();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rt.DestinationId;
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update(Destination destIn)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt; BreakAwayContext(ConfigurationManager.ConnectionStrings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BAContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ConnectionString))
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dest = context.Destinations.Where(a =&amp;gt; a.DestinationId ==&lt;span&gt; destIn.DestinationId).Single();
                dest.Name &lt;/span&gt;=&lt;span&gt; destIn.Name;
                context.SaveChanges();
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; destId)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt; BreakAwayContext(ConfigurationManager.ConnectionStrings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BAContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ConnectionString))
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; destination = &lt;span&gt;new&lt;/span&gt; Destination() { DestinationId =&lt;span&gt; destId };
                context.Destinations.Attach(destination);
                context.Destinations.Remove(destination);

                context.SaveChanges();
            }
        }


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Destination Query(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; destId)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt; BreakAwayContext(ConfigurationManager.ConnectionStrings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BAContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ConnectionString))
            {
                IQueryable&lt;/span&gt;&amp;lt;Destination&amp;gt; dest = context.Destinations.Where(a =&amp;gt; a.DestinationId ==&lt;span&gt; destId);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dest.Single();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;4. 如果需要多个操作同时成功或者失败，需要手动开启事务，具体代码如下，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TransactionOps()
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt; BreakAwayContext(ConfigurationManager.ConnectionStrings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BAContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ConnectionString))
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; dbContextTransaction =&lt;span&gt; context.Database.BeginTransaction())
                {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; destination = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Destination
                        {
                            Country &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                            Description &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chs is the language package&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                            Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xs2s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                        };

                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; destId =&lt;span&gt; context.Destinations.Add(destination);

                        context.SaveChanges();

                        context.Destinations.Attach(destId);
                        context.Destinations.Remove(destId);

                        context.SaveChanges();

                        dbContextTransaction.Commit();
                    }
                    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (System.Exception ex)
                    {
                        dbContextTransaction.Rollback();
                        System.Console.WriteLine(ex.ToString());
                    }
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;5. 分页查询是网站设计的常用功能，一个简单的真分页查询方法如下如下所示，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Destination&amp;gt; QueryPaging&amp;lt;TKey&amp;gt;(&lt;span&gt;int&lt;/span&gt; pageIndex, &lt;span&gt;int&lt;/span&gt; pageSize, Expression&amp;lt;Func&amp;lt;Destination, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; whereLambda, Expression&amp;lt;Func&amp;lt;Destination, TKey&amp;gt;&amp;gt;&lt;span&gt; orderBy)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt; BreakAwayContext(ConfigurationManager.ConnectionStrings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BAContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ConnectionString))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; context.Destinations.Where(whereLambda).OrderBy(orderBy).Skip((pageIndex - &lt;span&gt;1&lt;/span&gt;) *&lt;span&gt; pageSize).Take(pageSize).ToList();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文对最新版本的Entity Framework进行增删改查操作给出了详尽的解释，并且给出了数据库和领域模型代码分开设计的完整解决方案，同时介绍了手动数据库表和领域模型映射，数据库事务实现，分页查询等常用功能，希望对大家有所帮助。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 22 Apr 2018 12:50:00 +0000</pubDate>
<dc:creator>SolidMango</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pugang/p/8909414.html</dc:identifier>
</item>
</channel>
</rss>