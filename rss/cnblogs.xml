<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>也许CTO并不是终点——没有净土 - 上官日天</title>
<link>http://www.cnblogs.com/shangguanritian/p/9017743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shangguanritian/p/9017743.html</guid>
<description>&lt;p class=&quot;postTitle&quot;&gt;　　&lt;strong&gt;开篇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　不想做将军的士兵不是好士兵，这句话可以有很功利的理解方式，对应到我们自己很可能是：不想做CTO的程序员不是好程序员！几年前对这句话的理解与现在有很多不同，因为我现在已经是一名中小型公司的CTO了，这句话真实的理解方式其实应该是：我们每个程序员要有远大的梦想（理想），这个涉及到我们的格局，只有格局足够高了才能走的更远，如韩信受胯下之辱而不怒为例就是，后面受委屈的时间多着呢，忍得住才能走的更远，看得到远方也就不会为如今的愁苦困扰了，所以来个佛系三连：随便吧，就这样，也可以。&lt;/p&gt;
&lt;p&gt;　　一般来说，中小型公司（好的创业团队），研发人员基本为50-100人的配置，原则上不会让CTO统管产品、UI、运营等，如果你看见一个公司CTO会统管以上一切，很有可能他是产品出生、市场出生、运营出生、销售畜生，但就不会是技术出生，这个角色真正的称呼是COO。我这边团队大概在80人左右，也会有自己的产品，但是公司级业务都是统一的产品团队在握到手里，有时候老板是最大的产品经理，有时候市场是，更多的时候还是产品自己是，各个部门都有一个太极阴阳平衡在里面，如果这种平衡失衡的话，公司一般来说是走不远的，这里后面有章节会介绍到，这里不赘述。&lt;/p&gt;
&lt;p&gt;　　这个是CTO并不是终点系列，大家已经可以猜到，其实后面更多的是自己工作中的一些吐槽，或者说一些经验。人嘛，都需要一个发泄总结的平台于是便拿起了我这个尘封已久的账号，发点心得体会，反正没人知道我是谁，是否被喷，得失荣辱也就不重要了，下面逐一讨论，先来聊聊中小公司的CTO大概是些什么人吧。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;大公司的骨干&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一般来说，中小型公司的CTO，水平相当于阿里的P8左右，技术扎实，在某一个领域有自己的一块自留田，但这并不能说一个P7就一定能做CTO，有时候中小公司的CTO去阿里也到不了P8。大公司出来的工程师，以P7为例，进入一个团队，如果那个团队不是太差，一般来说招这样的人至少目标是让他做leader的，但稍微有点经验的负责人会让他做架构师观察一阵子，还真不是所有技术好的都能做leader，有时候能力越大，造成的伤害越大。因为每个人都有自己专精的一块领域，走出来其他的就恼火了，比如我是后端出生，对前端还有所了解，但是一旦涉及到了Native、Hybrid等就要开始头大，而前端又变得死快死快的，今天一个Vue，明天一个React，完了多平台产品Weex或者微信小程序平台各种爆炸，如果没有一个好的前端架构师（leader），根本扛不住；另一方面，前端出生的负责人，又会在后端程序拆分、业务梳理陷入困境，所以必须要一个相辅相成的人出现，才能弥补团队的不足。当然，我也认识一些大神，属于全通的类型，但是这些大神可能舞台就不是中小型公司了。&lt;/p&gt;
&lt;p&gt;　　一旦成为leader后，因为本来在自己领域其实就没有太多的窒碍了，你会越发的发现，为什么前端能做的是这么少？为什么服务器那么多问题不能解决？为什么Native能做的事情这么少？好一点的leader，在这个时候之前大公司的大格局、工程化、服务化等等思想就会燃起来了，如果本身执行力以及资源协调能力足够强的话，便会推动着整个研发团队往前走。这里必须强调的是强执行力以及落地能力，因为你如果出生前端那么这一波刷完，团队尝到甜头后，一定是前端团队会占据研发部门的主导地位，后端团队亦然。这里就非常体现两个方面的能力：&lt;/p&gt;
&lt;p&gt;　　1、跨部门协调能力、跨部门资源统合能力&lt;/p&gt;
&lt;p&gt;　　2、大局观，要懂得让利，要懂得分账，要懂的互相成就，特别是成就他人&lt;/p&gt;
&lt;p&gt;　　要做到这一切，需要你本身就很强（这里的积极性、态度什么的仅仅是个基础罢了），更重要的是，需要你口碑很好，至少人家要认可你，如果得不到其他团队的支持，一般来说什么事情都做不成的。&lt;/p&gt;
&lt;p&gt;　　好了，经过一轮刷存在感，并且真真实实的贡献，那么可以恭喜你了，中小团队没有那么多人才，也可以说，刚刚进入团队你就会发现身边的人单个看起来都还不错，但是合到一起为什么就是那么平庸，在这些平庸当中，你就说卓尔不群的，正常的情况下，该升职了，运气好就会成为总监之类的职位，后面持续努力的话，早晚成为实际的研发负责人，也就是CTO了。&lt;/p&gt;
&lt;p&gt;　　这里也有小伙伴说，一个萝卜一个坑，之前的CTO不走，你凭什么上位，其实真实的情况是，你的公司如果发展的不错，会有很多不错的子公司逐渐出现，而你从员工（架构师）到leader、从leader到中层干部（总监），正常速度都得一年半以上时间，而且这里请各位小白注意，这里是P7（最少优秀P6）的情况下，都得在公司打拼一年多的时间才能到中层，你在总监职位后信息量会有极大的不同，而且可以接触到最高管理层CEO的机会会大幅度增加，而你能做到中层必定本身实力不会太有问题，那么这种口碑便是你之后做CTO的关键了，还是那句话，你上位得多数人服气，就算是不喜欢你的人，都得服气。关于空降等话题，我们在后面继续展开，本篇不讨论。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;讨厌的人事物开始出现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　经过一连串的血拼，你杀出重围，做上了心爱的CTO职位，本以为可以高高兴兴庆祝登顶，但不好意思，你往往会发现：你所认为的结局可能只是一个开始。&lt;/p&gt;
&lt;p&gt;　　CTO难做，初期尤其难做，这种难做不仅是事情难做，更多的时候是心理难受，那真的是很难受啊！&lt;/p&gt;
&lt;p&gt;　　当我们做前后端或者Native开发的时候，往往只会关注自己这层，做前端的最多吐槽下后端接口傻逼，有点推动精神的就会想要去优化这一切；当我们做有理想的leader的时候便会更多的帮助其他团队、而当我们做总监的时候，我们会发现，尼玛为什么其他部门那么蠢？？？&lt;/p&gt;
&lt;p&gt;　　有些时候真的想用蠢来形容，跳出了研发的圈子，产品、UI、运营等部门会越来越多的接触，于是不省心的事情会接连发现，而每个公司每个部门绝对会有同一种情况：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;为什么公司会有那个毒瘤？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　对的，你没有看错，每个公司乃至每个团队都一定会有几个毒瘤，这里毒瘤一定会有一些共同的特点：&lt;/p&gt;
&lt;p&gt;　　1、强势，在工作上除非他需要求你，否则不会给你留面子，有时候他要求你也不会给你留名字，说话很生硬；&lt;/p&gt;
&lt;p&gt;　　2、小公主（绝不只是女人，有时候甚至是老板），睚眦必究，需要你哄着我，你不哄着我我就给你穿小鞋；&lt;/p&gt;
&lt;p&gt;　　3、纯傻逼+马屁精（HR居多），不做评论&lt;/p&gt;
&lt;p&gt;　　之前有人用了一张图表示彼此之间的关系：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/328620/201805/328620-20180508151739142-1820658075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在中小公司来说，CTO眼中的真实想法可能不是这样的，会有所不同：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/328620/201805/328620-20180508153939835-1603529598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　你会发现，你可能不被所有部门喜欢，同时你也不喜欢所有部门的负责人，正常情况下，各个部门的负责人都是严格筛选上来的，这些人都是人精，而这些人中有两种人最让人讨厌：&lt;/p&gt;
&lt;p&gt;　　1、强势的人（一般来说，强势的人自带小公主光环），虽然被所有的人不喜欢，但没人想惹。&lt;/p&gt;
&lt;p&gt;　　2、老板最喜欢的马屁精，没人敢惹。&lt;/p&gt;
&lt;p&gt;　　所以呢，出了研发的圈子，你就需要跟所有的以上打交道，而且这些人普遍是不认可你而你也不认可的人，你的资源统筹能力或者强执行落地能力一出了自己团队变得毫无意义，这里的两个主要原因是：&lt;/p&gt;
&lt;p&gt;　　1、目标不统一，你的目标不是我的目标，我为什么要成就你。&lt;/p&gt;
&lt;p&gt;　　2、主导性，这个事情可以做，但是需要我来主导。&lt;/p&gt;
&lt;p&gt;　　目标问题，需要CEO做很多工作都未必能达成一致，主导权这个东西更是谁都想摸一下，一般来说，我们总会高估自己，至少是局部高估。而部门负责人一定都是各种信息量很大的人，知道各个部门的一些问题，这个时候一些想做事的部门负责人往往会陷入，信息量与能力不对等，知道的太多，能做的太少，就会陷入极度忧虑。&lt;/p&gt;
&lt;p&gt;　　里面特别是胡乱强势+小公主组合，会极大的破坏部门之间的正常交流，导致业务停滞不前，这种消磨与内耗便是痛苦的根源，你要做事还需要去讨好各种小公主才能继续做事，那么便是真正受挫的开始，这个时候就要时刻念叨韩信韩信韩信，期待能解决问题了。&lt;/p&gt;
&lt;p&gt;　　更让人受挫的是，我们总会以为这个人情商低，哪个人蠢，有时候也在念叨，如此之人怎么可能成为这个职位的负责人，但是不要惊喜，不要意外，公司就是会存在这种人，各个职位都会出现，总有这样那样的契机让这种人出现在那个关键的职位，就算现在不出现，以后也一定会出现，当你在抱怨的时候，可能其他人正在抱怨你。&lt;/p&gt;
&lt;p&gt;　　你觉得你是CTO，是研发的负责人，在其他人看来，你不过是研发的负责人罢了，而职位越高，性格所带来的缺陷会越大，这种破坏力也就越大，整个这一切是无解的，想要走的更远，就必须接受你自己可能是个傻逼，你需要跟各种小公主共事的事实，所以，与君共勉吧。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;流程体系的重要性&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;　　创业之初，团队就10个人不到的时候，团队里面只有一个傻逼，而大家也愿意去迁就他，因为他是团队里面最累的人，也是团队压力最大的人，这个他就是我们所说的CEO了，小而美的团队总是存在的，我们有时候为了构造一个简单高效的流程体系，需要几波人不停的迭代，一到三年的打磨才能成型，这里举一个离职评价技术leader型人才是：&lt;/p&gt;
&lt;p&gt;　　1、技术很好，并且能带动团队的人&lt;/p&gt;
&lt;p&gt;　　2、能帮助团队行程技术体系的人&lt;/p&gt;
&lt;p&gt;　　3、能帮助公司行程流程体系的人&lt;/p&gt;
&lt;p&gt;　　第三个层次的人才是最高的，但往往是最容易被误解为无能的人，因为技术很好，带动团队1、2个月就能见效；保住团队建立技术体系需要稍微慢点，一年半载也会初步成型；但是建立流程体系这个事情，耗时费力，需要各个团队（研发、产品、UI、运营、市场）等等参与，参与的人多了，就需要所有的人都达成基本一致，不论你用什么手段，而这个过程至少得一年以上，有些团队形成这个体系花了三年的时间。&lt;/p&gt;
&lt;p&gt;　　这个美好的流程体系是维持我们工作净土的有力保证之一，这个体系建立难，破坏却非常容易，只需要：&lt;/p&gt;
&lt;p&gt;　　1、一两个总是跳出规范的人&lt;/p&gt;
&lt;p&gt;　　2、空降下来新人挑战体系，这个时候知道体系重要的人会极力的维护体系，却往往会被认为是在阻碍进步（优化体系和无视体系是两个情况）&lt;/p&gt;
&lt;p&gt;　　3、建立体系的人心灰意冷而离职，可能带来团队小范围崩塌&lt;/p&gt;
&lt;p&gt;　　生态体系是维持不同生命平衡的关键，而这个体系很多时候是很脆弱的，就如外来物种入侵一般，外来物种会打破生态平衡，我们常常说他破坏生态体系，事实上他破坏的是原有生态体系，而会建立新的生态体系，只不过这个生态体系因为自己的肆意妄为，很多时候会让原有的净地变得死气沉沉。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;心中的净土&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　程序员多数情况还是比较纯洁理想的生物，希望能把一个产品做好，希望能推动团队往前跑，而当成为技术负责人后，就会慢慢接受到各种绝望，这里所带来的打击可能是理念上的冲击。&lt;/p&gt;
&lt;p&gt;　　特别是大公司里面的程序员，往往是处于一个完善的流程体系之中，而因为体系将他们保护的很好，就算是遇到特别令人讨厌的产品或者UI都可以得到保护，在大公司的岁月，经常会发生程序喷产品的情况，虽然最后很多在大家看来傻逼一样的需求还是会上线，但是至少程序员是有一些选择的，而这个在很多创业团队中是比较奢侈的了。&lt;/p&gt;
&lt;p&gt;　　因为在大公司里面傻逼的产品经理，因为不用花时间学习算法、学习性能优化，他们在各种产品细节或者扯淡本事上绝逼比90%以上程序员能扯，偶尔会有一些祸害会进入了中小型公司后，那么不好意思，这个公司的噩梦可能需要开始了。&lt;/p&gt;
&lt;p&gt;　　这个产品会各种喷程序，各种说自己之前合作的程序多么多么好，然后会出各种傻逼需求，因为一般来说，中小型公司其实是非常欠缺具有架构能力的产品的，实话实说，这种产品还真只有大公司出的多，老板对这种产品架构师的辨别能力有限（事实上能找到好的技术架构师也是运气），于是可能会将一些扯犊子的产品搞进来做产品负责人，那么不好意思，地狱来临，而这个地狱持续的时间可能是怨声载道，程序员忍无可忍的半年，也可能是半年一年后，CEO想处理点什么，但是由于什么公司非常重要的节点而搁置，总而言之，遇到这个情况的公司技术心中的净土算是完蛋了。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;没有净土&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　前面已经说了，小而美的团队，简单高效的流程不是不存在，但是这个是很容易被打破的，恐怕，研发心中期望的净土是永远不存在的，对，那是永远不存在的！&lt;/p&gt;
&lt;p&gt;　　我这里体会过很多相关的情形，有时候忍耐着与一些非常讨厌的人合作，有些委屈自己能吃，团队的leader也能吃，但是一旦到了自己的核心员工被一些傻逼莫名其妙的欺负的时候，这个时候便有些不能忍了，但是你的不能忍是对现状没有任何正面的影响的，因为，这个是很多中小型公司的通病：&lt;/p&gt;
&lt;p&gt;　　研发团队是个成本部门，并没有自己的产品，也不带流水！&lt;/p&gt;
&lt;p&gt;　　因为这个根本原来，所以CTO在一个公司除非非常懂业务，有资深的行业知识，能很有话语权，能手握一块业务，但是这往往是不可能的，因为CTO多数时间去写代码了，行业知识这种枯燥的东西他们怎么可能太了解呢？&lt;/p&gt;
&lt;p&gt;　　谁了解的多，谁对细节有掌握，谁就对那件事情有话语权，然而我们都知道自己原则上不会在这个公司待太多的时间，所以丢掉技术无异于自绝后路，而事实上我们这类人写代码其实对团队带来的帮助，微乎其微，于是技术负责人就会陷入一种死循环，有些有自觉的负责人甚至会开始自责，因为，就是因为自己的不给力，就是因为自己团队做的不够好，才导致了团队在公司中话语权不够。&lt;/p&gt;
&lt;p&gt;　　可能有些朋友觉得我在这里耸人听闻，哎，其实你们看到哪个公司的CTO真的在公司中有决定性的话语权呢？哪个技术负责人又是真正的公司决策层的核心？在这个资本运作的市场中，做为一个CTO，你了解公司资本的走向吗，你了解为什么要收购一个公司吗，你看得懂财务报表吗？是的，这些都是非本专业的，我们除了技术，其实对其他方面一无所知，而高管会议时，你说的性能优化、模块重用、效率提升到底几人关注呢？恐怕很多同事连研发和IT都分不清吧，这个才是我们这群技术人该认清的情况。&lt;/p&gt;
&lt;p&gt;　　当然，话不可绝对，这个也许只是我们这里是这样，也许只是我认识的几个CTO们是这样，也希望有更好的存在，也希望有心中的净土存在......&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;打造流程体系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个因为这个情况，所以研发团队需要打造流程体系，规范各个部门，其实没有哪个行业就是让人省心的，你的生活中也总有让人不满意的地方，我们更多的时候需要学习着去改变这一切，试着寻找志同道合的人，一起去改变这一切，虽然有可能改着改着又完了，但是人生不正是这样的吗，钱难挣，屎难吃，难吃还是得吃&lt;/p&gt;

</description>
<pubDate>Wed, 09 May 2018 23:45:00 +0000</pubDate>
<dc:creator>上官日天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shangguanritian/p/9017743.html</dc:identifier>
</item>
<item>
<title>五月福利，吐血整理，重磅推荐，我坚信总有你需要的 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/9017739.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/9017739.html</guid>
<description>&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347292eb6416e6?w=1366&amp;amp;h=591&amp;amp;f=png&amp;amp;s=935242&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;大家都知道，从上个月开始，这个公号「compassblog」每月都会至少送出一次福利，并且这些福利涵盖学习资料、工具推荐、编程资源、抽奖送钱等等，当然啦，抽奖可以经常有，送钱的话可能需要那天发笔横财才会有。&lt;/p&gt;&lt;p&gt;好了，废话就讲这么多，开始进入今天的主题。鉴于大家现在的需求，这个月主要分享以下几个福利：&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;一、Chrome 插件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、谷歌访问助手&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347292edd52fc2?w=415&amp;amp;h=223&amp;amp;f=png&amp;amp;s=20162&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;相信大家看上图就已经知道「谷歌访问助手」这个插件是干嘛用的了，我们再看下图就完全明白这个插件可以帮助我们使用「Google 搜索引擎」「gmail 邮箱」「Chrome 商店」，当然啦，国外的网站基本也是访问不了的，但是相对于百度，这个搜索引擎可以明显提高我们搜索效率，不要觉得功能太少，这几个功能已经完全可以满足你做很多需求了，具体怎么用，应该就不需要我说了，毕竟这话题有些敏感。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347292ede7494b?w=333&amp;amp;h=258&amp;amp;f=png&amp;amp;s=22384&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;公众号后台回复「谷歌访问助手」获取这款插件及使用方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS：&lt;/strong&gt; 鉴于谷歌访问助手还是无法访问大量的国外网站问题，前面分享过一个（V）兔（P）子（N）在手机端访问，如果需要电脑端访问的，有我微信的可以微信我，没有我微信的，公号后台加我微信找我要，加我微信的，备注「来自公号」。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、油猴插件&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347292ee1a5880?w=985&amp;amp;h=586&amp;amp;f=png&amp;amp;s=134951&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;油猴插件英文名为「Tampermonkey」，这款插件就厉害了，超过 1000 万用户，各种功能，夸张点说它的功能只有你想不到的，没有它做不到的，它既可以让你看各大视频网站的 VIP 付费视频，阻止浏览器的各种弹窗，也可以让你直接在浏览器就可以下载百度云盘的大号文件，不再需要跳往百度云盘客户端才能下载，最重要的是它可以让你百度云盘不再限速，也可以直接加速播放视频等等。……&lt;/p&gt;
&lt;p&gt;如此强大的插件，如何使用呢？只需要在插件上添加一个脚本就可以，在 「https://greasyfork.org/zh-CN/scripts」 这个网站可以获取各种脚本，通过各种脚本，也能发现这个插件的各种功能，如下图所示：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347292ee77b888?w=1023&amp;amp;h=592&amp;amp;f=png&amp;amp;s=109707&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;公众号后台回复「油猴插件」获取这款插件及使用方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、Listen 1&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347292ee967d77?w=414&amp;amp;h=221&amp;amp;f=png&amp;amp;s=14752&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;是不是已经厌倦了各大音乐平台的各种广告，是不是对无法在一个平台上畅听所有音乐感到烦恼，那就用「Listen 1」这款插件吧，它基本可以帮你解决这个平台有的音乐那个平台却没有这种缺陷，非但让你不需要再装好几个音乐平台，你甚至可以把这些平台都卸了，相信「网易云音乐」「虾米音乐」「QQ 音乐」基本包含了你想听的所有音乐了，插件主页如下图所示：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347293151c9c53?w=956&amp;amp;h=590&amp;amp;f=png&amp;amp;s=529299&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;公众号后台回复「Listen1」获取这款插件及使用方法。&lt;/p&gt;
&lt;p&gt;好了，就先推荐这 3 款插件吧。Chrome 强大的功能之一就在于其具有强大的插件库，各种插件极其丰富，仅仅我目前经常使用到的插件就有十几个，包括印象笔记、Octotree、猫抓、翻译侠、sometric Contributions、网页截图等等，如下图所示，我打算后面找时间再写个「Chrome 插件推荐系列」文章，敬请期待。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347293209583bf?w=1285&amp;amp;h=494&amp;amp;f=png&amp;amp;s=80076&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;需要直接获取以上插件的，公众号后台回复「5月Chrome 插件」即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;二、编程资源&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、Java 就业班学习资源：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这套资料我个人觉得还不错，强烈推荐，前面也分享过，不过资源链接已经全部失效了，而且网上基本也在疯传了，不过为了让大家更加方便的获取资源，这里再分享一次，部分资料截图如下：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347293231d2797?w=1019&amp;amp;h=366&amp;amp;f=png&amp;amp;s=20805&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/163472932387258e?w=1057&amp;amp;h=241&amp;amp;f=png&amp;amp;s=10735&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;公众号后台回复「Java就业班」获取这套学习资料。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、Java 相关学习大礼包：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个 Java 相关的学习大礼包主要包括李兴华的 Java SE 以及 一些相关的 Java 电子书，这套资料我基本都看过，特别是视频，我基础看的就是这套视频，强烈推荐，部分资料截图如下：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347293239d2ff0?w=1040&amp;amp;h=374&amp;amp;f=png&amp;amp;s=22485&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;公众号后台回复「Java相关学习大礼包」获取这套学习资料。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、Python 从入门到项目全套视频教程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这套资源是网友分享过来的，我还没看过，部分视频截图如下：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/1634729349f0842f?w=1013&amp;amp;h=365&amp;amp;f=png&amp;amp;s=28557&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/163472934a7a95b3?w=1016&amp;amp;h=364&amp;amp;f=png&amp;amp;s=30662&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/163472934a8fe9ee?w=1005&amp;amp;h=358&amp;amp;f=png&amp;amp;s=28282&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;公众号后台回复「Python从入门到项目全套视频教程」获取这套学习资料。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要直接获取以上全部学习资源的，公众号后台回复「5月编程资源」即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS：&lt;/strong&gt; 如果链接失效，可加我微信索取学习资料，更多学习资料有待整理，敬请期待。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;三、高效工具&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、FSCapture：&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/163472934a9c71f0?w=479&amp;amp;h=368&amp;amp;f=png&amp;amp;s=17331&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;这是一款超级强大的集快速截图、录屏、标尺、放大镜、取色器、PDF 转换等功能于一身的高效工具，并且截图后也支持快速编辑与保存，最重要的是，这款工具的大小不到 1M ，支持各种快捷键，你非常值得拥有。&lt;/p&gt;
&lt;p&gt;公众号后台回复「FSCapture」获取这个工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、GifCam：&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/163472934c181ea3?w=368&amp;amp;h=269&amp;amp;f=png&amp;amp;s=4777&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;这是一款轻小便捷的 GIF 录制工具，有了它，你就可以不再需要通过转换的方式来制作 GIF 图片，或者说，当你想录制一段很小很短的无声演示小视频的时候，也可以使用这款工具。&lt;/p&gt;
&lt;p&gt;公众号后台回复「GifCam」获取这个工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、Snipaste：&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347293609016f2?w=455&amp;amp;h=521&amp;amp;f=png&amp;amp;s=27116&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;这款工具功能就比较专一，专注于快速截图，通过快捷键操作，它可以在你电脑的任何地方截图，并且截图这个功能与「FSCapture」这款工具非常相似，但是相对于「FSCapture」，它截图这个功能却显得更加的轻小快捷。&lt;/p&gt;
&lt;p&gt;公众号后台回复「Snipaste」获取这个工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、天若OCR：&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347293730da459?w=364&amp;amp;h=350&amp;amp;f=png&amp;amp;s=5763&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;相信大家都知道什么是 OCR 了，OCR 就是快速的将屏幕文字或者图片文字转换为可编写的文本，类似的工具很多，然而好用的却不多，而这款工具就是其中之一。更为强大的是，它还可以直接在线将转换后的文本翻译，这款工具非常强烈推荐大家使用，我经常使用的就是中英互译了，如下图所示：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/1634729373c3b94b?w=874&amp;amp;h=632&amp;amp;f=gif&amp;amp;s=1297825&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;美中不足的是，这款工具必须要有网络才能使用，不过没关系，如果你电脑经常是没有网络的状态却又需要 OCR 功能的，推荐使用「123 OCR」这款工具，尽管没有天若 OCR 好用，但是文本转换也非常的方便，都支持快捷键操作。&lt;/p&gt;
&lt;p&gt;公众号后台回复「OCR」获取这两款工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、Typora：&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/1634729373ac4315?w=786&amp;amp;h=593&amp;amp;f=png&amp;amp;s=40310&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;这是我目前用过最好用的 Markdown 编辑器了，实时预览，非常高效与便捷，具体我就不多作介绍了。&lt;/p&gt;
&lt;p&gt;公众号后台回复「Typora」获取这款工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要直接获取以上全部高效工具的，公众号后台回复「5月高效工具」即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS：&lt;/strong&gt; 接下来如果发现有什么好用的更加高效的工具，我也会持续推荐的呵呵呵。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;四、开源项目&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、Interview-Notebook：&lt;/strong&gt; 这个项目整理了丰富的技术面试需要掌握的基础知识，累计到发文前，已经有 21371 个 star 和 5620 个 fork 了，如果你准备深入编程或者说以后坚定往编程方向深究，又或者说想进入大厂工作的，推荐看看这个开源项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、free-programming-books-zh_CN：&lt;/strong&gt; 这个项目囊括各种免费的计算机编程类中文书籍，累计到发文前，已经有 32314 个 star 和 11693 个 fork 了，当然，除了中文版，还有英文版，是个很不错的开源项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、LearningNotes：&lt;/strong&gt; 这个项目包括各种计算机编程的面试基础知识和题库，当然我看的主要是 Java 部分和数据结构算法部分的，这个项目还囊括很多其他方向的基础知识，例如计算机网络、Android、读书笔记、面试经验等，累计到发文前，已经有 9022 个 star 和 3281 个 fork 了，也是个非常值得推荐的开源项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要获取以上开源项目的，公众号后台回复「5月开源项目」即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;五、教师资格面试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;分享，一个无穷无尽的话题。。。最近在准备高中的教师资格证面试，感觉面试买书没什么用，于是花重金买了套视频来复习，个人感觉这套视频非常不错，这里分享出来给大家，需要的自取即可，部分资料截图如下：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347293753b3374?w=1045&amp;amp;h=160&amp;amp;f=png&amp;amp;s=12567&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/163472938425eca1?w=1030&amp;amp;h=234&amp;amp;f=png&amp;amp;s=11836&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347293761e1be5?w=1035&amp;amp;h=367&amp;amp;f=png&amp;amp;s=21227&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;需要获取这套视频的，公众号后台回复「5月教师资格面试」即可。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;hr/&gt;&lt;center&gt;

&lt;/center&gt;

&lt;span&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/16347308557b88d0?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27341&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;/span&gt;</description>
<pubDate>Wed, 09 May 2018 23:32:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/9017739.html</dc:identifier>
</item>
<item>
<title>之于图片主色调提取算法 - cpuimage</title>
<link>http://www.cnblogs.com/cpuimage/p/9017732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cpuimage/p/9017732.html</guid>
<description>&lt;p&gt;图片颜色量化算法，&lt;/p&gt;
&lt;p&gt;又称之为图片主色调提取算法。&lt;/p&gt;
&lt;p&gt;也可以称之为调色板提取算法。&lt;/p&gt;
&lt;p&gt;比较常见的应用就是用于提取图片的主色调用于上色配色,&lt;/p&gt;
&lt;p&gt;当然也可以用于图像分割。&lt;/p&gt;

&lt;p&gt;算法的主要目的是从真彩色图像所能表现的大约16M中颜色中选取最代表性或者出现频率最高的256种颜色。&lt;/p&gt;
&lt;p&gt;维基百科：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Color_quantization&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Color_quantization&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关细节，请参阅维基百科。&lt;/p&gt;

&lt;p&gt;经典的例子有：&lt;/p&gt;

&lt;p&gt;色调窃取：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://lokeshdhakar.com/projects/color-thief/&quot; target=&quot;_blank&quot;&gt;http://lokeshdhakar.com/projects/color-thief/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比较有意思的做法就是用来做图片压缩，&lt;/p&gt;
&lt;p&gt;png格式中最高压缩比的算法就是基于颜色量化表实现的。&lt;/p&gt;
&lt;p&gt;相关项目：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kornelski/pngquant&quot; target=&quot;_blank&quot;&gt;https://github.com/kornelski/pngquant&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感兴趣的同学可以，翻翻相应的代码，温故而知新。&lt;/p&gt;

&lt;p&gt;常见的颜色量化算法有：&lt;/p&gt;
&lt;p&gt;中位切分法（Median cut）&lt;br/&gt;&lt;a href=&quot;http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/1994/9409/9409e/9409e.htm&quot; target=&quot;_blank&quot;&gt;Median-Cut Color Quantization&lt;/a&gt;&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;八叉树算法（Octree）&lt;br/&gt;&lt;a href=&quot;https://pdfs.semanticscholar.org/deaf/dd9782adb4f9211bf9743d5cc1bdad3753d2.pdf&quot; target=&quot;_blank&quot;&gt;A Simple Method for Color Quantization: Octree Quantization&lt;/a&gt;&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;聚类算法 (KMeans)&lt;br/&gt;&lt;a href=&quot;http://scikit-learn.org/stable/auto_examples/cluster/plot_color_quantization.html&quot; target=&quot;_blank&quot;&gt;Color Quantization using K-Means&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;直方图量化(Histogram)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pixelero.wordpress.com/2014/11/12/just-saying-hi-or-color-quantization-using-histogram/&quot; target=&quot;_blank&quot;&gt;Color Quantization using Histogram&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;神经网络(Neural-Net)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pdfs.semanticscholar.org/8af5/f783125b9485f688fe47c356676d14f4a811.pdf&quot; target=&quot;_blank&quot;&gt;Optimal Colour Quantization using Kohonen Neural Networks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当然算法还有很多，以及相关的变种。&lt;/p&gt;
&lt;p&gt; &lt;br/&gt; 曾经做过一个需求，想要从一个图片中找到它的主体颜色然后显示出来,&lt;/p&gt;
&lt;p&gt;要有两个输出，&lt;/p&gt;
&lt;p&gt;一个是颜色的文字描述，一个是颜色的RGB值。&lt;/p&gt;
&lt;p&gt;颜色的文字描述很好解决，参照项目:&lt;/p&gt;
&lt;p&gt;Name that Color:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://chir.ag/projects/name-that-color/&quot; target=&quot;_blank&quot;&gt;http://chir.ag/projects/name-that-color/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要思路是建表查表，这个也没啥好说了，简单粗暴。&lt;/p&gt;
&lt;p&gt;而重点在于精准地找到颜色的RGB值，&lt;/p&gt;
&lt;p&gt;这一点，恕我直言，&lt;/p&gt;
&lt;p&gt;以上提及到的算法，都不能很好地精准描述到颜色的RGB值。&lt;/p&gt;
&lt;p&gt;相关开源项目很多，谷歌一下，github一下 关键词 Color Quantization，&lt;/p&gt;
&lt;p&gt;如果不死心的同学可以去做下试验，这里就不展开说了。&lt;/p&gt;
&lt;p&gt;这个跟人的视觉感官有关，我们的视觉焦点跟实际的数字颜色有差别。&lt;/p&gt;
&lt;p&gt;举个例子，万绿丛中一点红。&lt;/p&gt;
&lt;p&gt;明显周围都是绿，那一点红就显得很耀眼。&lt;/p&gt;
&lt;p&gt;而如果采用均值也好，切分也好，分类也好。&lt;/p&gt;
&lt;p&gt;是很难很好的描述那个耀眼的颜色。&lt;/p&gt;
&lt;p&gt;有一段时间，清闲的时候总在思考，如何更好地找到那个合适的颜色值。&lt;/p&gt;
&lt;p&gt;最终我从算法的核心，量化的思想出发。&lt;/p&gt;
&lt;p&gt;我是不是可以采用过筛子的方式进行逐步逼近结果呢？&lt;/p&gt;
&lt;p&gt;这个时候颜色相关的基础知识就显得尤为重要。&lt;/p&gt;
&lt;p&gt;转换颜色空间，进行量化是否可行，例如采用HSL或HSV色域。&lt;/p&gt;
&lt;p&gt;这个也不展开科普了，需要补课的同学，移步维基:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4&quot; target=&quot;_blank&quot;&gt;https://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HSL和HSV都是一种将RGB色彩模型中的点在圆柱坐标系中的表示法。这两种表示法试图做到比RGB基于笛卡尔坐标系的几何结构更加直观。&lt;/p&gt;
&lt;p&gt;HSL即色相、饱和度、亮度（英语：Hue, Saturation, Lightness）。HSV即色相、饱和度、明度（英语：Hue, Saturation, Value），又称HSB，其中B即英语：Brightness。&lt;/p&gt;
&lt;p&gt;色相（H）是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。&lt;br/&gt;饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取0-100%的数值。&lt;br/&gt;明度（V），亮度（L），取0-100%。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/824862/201805/824862-20180510071236004-1744249369.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家观察一下这个图中的圆环。&lt;/p&gt;
&lt;p&gt;按照视觉感官来说，&lt;/p&gt;
&lt;p&gt;位于圆环中间的颜色区域就是视觉不敏感的地方。&lt;/p&gt;
&lt;p&gt;换句话来说，饱和度和亮度，我们都可以不考虑。&lt;/p&gt;
&lt;p&gt;只要考虑量化色相就可以基本得知颜色的分布。&lt;/p&gt;
&lt;p&gt;而量化的色相，还可以控制需要量化的精度，也就是，&lt;/p&gt;
&lt;p&gt;你可以针对色相进行进一步的细分。&lt;/p&gt;
&lt;p&gt;例如细分至1000等分，细分至10等分等等。&lt;/p&gt;
&lt;p&gt;这个就看具体需求了。&lt;/p&gt;
&lt;table class=&quot;wikitable&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th rowspan=&quot;2&quot;&gt;&lt;a title=&quot;颜色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E9%A2%9C%E8%89%B2&quot;&gt;名称&lt;/a&gt;&lt;/th&gt;
&lt;th rowspan=&quot;2&quot;&gt;&lt;a title=&quot;颜色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E9%A2%9C%E8%89%B2&quot;&gt;颜色&lt;/a&gt;&lt;/th&gt;
&lt;th colspan=&quot;3&quot;&gt;&lt;a class=&quot;mw-redirect&quot; title=&quot;RGB&quot; href=&quot;https://zh.wikipedia.org/wiki/RGB&quot;&gt;色光&lt;/a&gt;&lt;/th&gt;
&lt;th colspan=&quot;4&quot;&gt;&lt;a class=&quot;mw-redirect&quot; title=&quot;CMYK&quot; href=&quot;https://zh.wikipedia.org/wiki/CMYK&quot;&gt;色料&lt;/a&gt;&lt;/th&gt;
&lt;th colspan=&quot;3&quot;&gt;&lt;a class=&quot;mw-redirect&quot; title=&quot;HSV色彩属性模式&quot; href=&quot;https://zh.wikipedia.org/wiki/HSV%E8%89%B2%E5%BD%A9%E5%B1%9E%E6%80%A7%E6%A8%A1%E5%BC%8F&quot;&gt;色相&lt;/a&gt;&lt;/th&gt;
&lt;th rowspan=&quot;2&quot;&gt;&lt;a class=&quot;mw-redirect&quot; title=&quot;RGB&quot; href=&quot;https://zh.wikipedia.org/wiki/RGB&quot;&gt;代码&lt;/a&gt;&lt;/th&gt;
&lt;th rowspan=&quot;2&quot;&gt;&lt;a title=&quot;MS-DOS&quot; href=&quot;https://zh.wikipedia.org/wiki/MS-DOS&quot;&gt;MS-DOS&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Ｒ&lt;/th&gt;
&lt;th&gt;Ｇ&lt;/th&gt;
&lt;th&gt;Ｂ&lt;/th&gt;
&lt;th&gt;Ｃ&lt;/th&gt;
&lt;th&gt;Ｍ&lt;/th&gt;
&lt;th&gt;Ｙ&lt;/th&gt;
&lt;th&gt;Ｋ&lt;/th&gt;
&lt;th&gt;角度&lt;/th&gt;
&lt;th&gt;饱和&lt;/th&gt;
&lt;th&gt;明度&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;红色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E7%BA%A2%E8%89%B2&quot;&gt;红色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#FF0000&quot;&gt; &lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0°&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;#FF0000&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;黄色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E9%BB%84%E8%89%B2&quot;&gt;黄色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#FFFF00&quot;&gt; &lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;60°&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;#FFFF00&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a class=&quot;mw-redirect&quot; title=&quot;绿色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E7%BB%BF%E8%89%B2&quot;&gt;绿色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#00FF00&quot;&gt; &lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;120°&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;#00FF00&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;青色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E9%9D%92%E8%89%B2&quot;&gt;青色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#00FFFF&quot;&gt; &lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;180°&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;#00FFFF&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a class=&quot;mw-redirect&quot; title=&quot;蓝色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E8%93%9D%E8%89%B2&quot;&gt;蓝色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#0000FF&quot;&gt; &lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;240°&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;#0000FF&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a class=&quot;mw-redirect&quot; title=&quot;品红色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E5%93%81%E7%B4%85%E8%89%B2&quot;&gt;品红色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#FF00FF&quot;&gt; &lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;300°&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;#FF00FF&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;栗色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E6%A0%97%E8%89%B2&quot;&gt;栗色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#800000&quot;&gt; &lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;td&gt;0°&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;50%&lt;/td&gt;
&lt;td&gt;#800000&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a class=&quot;mw-redirect&quot; title=&quot;橄榄色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E6%A9%84%E6%AC%96%E8%89%B2&quot;&gt;橄榄色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#808000&quot;&gt; &lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;td&gt;60°&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;50%&lt;/td&gt;
&lt;td&gt;#808000&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a class=&quot;new&quot; title=&quot;深绿色（页面不存在）&quot; href=&quot;https://zh.wikipedia.org/w/index.php?title=%E6%B7%B1%E7%BB%BF%E8%89%B2&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;深绿色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#008000&quot;&gt; &lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;td&gt;120°&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;50%&lt;/td&gt;
&lt;td&gt;#008000&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a class=&quot;mw-redirect&quot; title=&quot;蓝绿色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E8%93%9D%E7%BB%BF%E8%89%B2&quot;&gt;蓝绿色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#008080&quot;&gt; &lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;td&gt;180°&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;50%&lt;/td&gt;
&lt;td&gt;#008080&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a class=&quot;mw-redirect&quot; title=&quot;深蓝色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E6%B7%B1%E8%97%8D%E8%89%B2&quot;&gt;深蓝色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#000080&quot;&gt; &lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;td&gt;240°&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;50%&lt;/td&gt;
&lt;td&gt;#000080&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;紫色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E7%B4%AB%E8%89%B2&quot;&gt;紫色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#800080&quot;&gt; &lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;td&gt;300°&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;50%&lt;/td&gt;
&lt;td&gt;#800080&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;白色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E7%99%BD%E8%89%B2&quot;&gt;白色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#FFFFFF&quot;&gt; &lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0°&lt;/td&gt;
&lt;td&gt;0%&lt;/td&gt;
&lt;td&gt;100%&lt;/td&gt;
&lt;td&gt;#FFFFFF&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a class=&quot;mw-redirect&quot; title=&quot;银色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E9%93%B6%E8%89%B2&quot;&gt;银色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#C0C0C0&quot;&gt; &lt;/td&gt;
&lt;td&gt;192&lt;/td&gt;
&lt;td&gt;192&lt;/td&gt;
&lt;td&gt;192&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;td&gt;0°&lt;/td&gt;
&lt;td&gt;0%&lt;/td&gt;
&lt;td&gt;75%&lt;/td&gt;
&lt;td&gt;#C0C0C0&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;灰色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E7%81%B0%E8%89%B2&quot;&gt;灰色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#808080&quot;&gt; &lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;td&gt;0°&lt;/td&gt;
&lt;td&gt;0%&lt;/td&gt;
&lt;td&gt;50%&lt;/td&gt;
&lt;td&gt;#808080&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;黑色&quot; href=&quot;https://zh.wikipedia.org/wiki/%E9%BB%91%E8%89%B2&quot;&gt;黑色&lt;/a&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#000000&quot;&gt; &lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;0°&lt;/td&gt;
&lt;td&gt;0%&lt;/td&gt;
&lt;td&gt;0%&lt;/td&gt;
&lt;td&gt;#000000&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
















&lt;p&gt;看这图表比较形象一些。&lt;/p&gt;
&lt;p&gt;重点关注角度这个值。&lt;/p&gt;
&lt;p&gt;相关的计算方式就不展开了。&lt;/p&gt;
&lt;p&gt;这个比较基础。&lt;/p&gt;
&lt;p&gt;经过实验，验证采用色相进行量化是比较适宜的。&lt;/p&gt;
&lt;p&gt;具体算法就不贴出来了。&lt;/p&gt;
&lt;p&gt;大概的算法思路如下：&lt;/p&gt;
&lt;p&gt;1.确定需要量化颜色的精度，(0-360) 或者(0-60) 稍微换算一下即可。&lt;/p&gt;
&lt;p&gt;2.按照量化的精度，对图像进行色相直方图统计(要更加精准的话可以加入亮度或饱和度的直方图，最好把Name that Color的RGB值也进行直方图统计) &lt;/p&gt;
&lt;p&gt;3.对直方图进行统计分析，排序以及平滑等&lt;/p&gt;
&lt;p&gt;4.通过2-3直方图进行评估确定对应的rgb值&lt;/p&gt;
&lt;p&gt;5.输出结果&lt;/p&gt;

&lt;p&gt;虽然可以完整地贴出示例代码，&lt;/p&gt;
&lt;p&gt;但是有时候，授人以鱼不如授人以渔。&lt;/p&gt;

&lt;p&gt;以上的思路，供有类似需求的同学参考之。&lt;/p&gt;

&lt;p&gt;若有其他相关问题或者需求也可以邮件联系俺探讨。&lt;/p&gt;
&lt;p&gt;邮箱地址是: &lt;br/&gt;gaozhihan@vip.qq.com&lt;/p&gt;

</description>
<pubDate>Wed, 09 May 2018 23:31:00 +0000</pubDate>
<dc:creator>cpuimage</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cpuimage/p/9017732.html</dc:identifier>
</item>
<item>
<title>【Java入门提高篇】Day16 Java异常处理（下） - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/9017577.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/9017577.html</guid>
<description>&lt;p&gt;　　今天继续讲解java中的异常处理机制，主要介绍Exception家族的主要成员，自定义异常，以及异常处理的正确姿势。&lt;/p&gt;
&lt;h2&gt;Exception家族&lt;/h2&gt;
&lt;p&gt;　　一图胜千言，先来看一张图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201805/1043143-20180509233457666-1737440693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　Exception这是一个父类，它有两个儿子，IOException和RuntimeException，每个儿子都很能生，所以它有着一堆的孙子，但其实，Exception家族还有一个大家伙，那就是Throwable，这是一个接口，看名字就知道意思，就是“可被抛出”嘛，它还有一个同父异母的哥哥，那就是Error，这家伙可厉害了，Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。catch语句里，不仅可以catch住Exception，还能catch住Error（什么？你真的打算catch Error？？程独秀同学，你先坐下。）一般情况下，是不能捕获Error的，对于这类错误，Java编译器不去检查他们。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议让程序终止。除非你有把握能正确处理，否则程独秀同学还是坐下吧（滑稽）。&lt;/p&gt;
&lt;h2&gt;Unchecked Exception和Checked Exception&lt;/h2&gt;
&lt;p&gt;　　你也许会一脸懵逼，？？？，这是啥？异常也是分派别的，Unchecked Exception表示“未检查异常“，Checked Exception自然就是”已检查异常“，派生于Error或者RuntimeException的异常称为unchecked异常，所有其他的异常成为checked异常。那问题来了，为啥要区分这两种异常？&lt;/p&gt;
&lt;p&gt;　　我们可以再看看上面那个图，可以看出，RuntimeException和Error都是由程序内部引发的错误，比如上一篇里所说的空指针和算术异常。而Checked Exception则大都是由外部因素导致的，如文件无法找到异常，这是虚拟机无法掌控的情况，当出现异常，虚拟机也只能一脸懵逼，不知道该如何是好，所以当有可能发生时，就必须要使用try..catch去捕获它，而对于Unchecked Exception 时，大部分是由于代码引发的，所以只要代码写的足够完善，是不会抛出这样的异常的，所以也不强制要求捕获。&lt;/p&gt;
&lt;p&gt;　　所以原因其实很简单，编译器将检查你是否为所有的已检查异常提供了异常处理机制，比如说我们使用Class.forName()来查找给定的字符串的class对象的时候，如果没有为这个方法提供异常处理，编译是无法通过的。已检查异常的意义就在于让你知道，这地方是有可能抛异常的，你要注意了，赶紧捕获了。&lt;/p&gt;
&lt;h2&gt;自定义异常&lt;/h2&gt;
&lt;p&gt;　　那么如何自定义一个异常呢？其实很简单，只需要继承Exception类就好了。看下面的栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyException &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Exception {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyException() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyException(String message) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(message);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyException(String message, Throwable cause) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(message, cause);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyException(Throwable cause) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(cause);
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; MyException(String message, Throwable cause, &lt;span&gt;boolean&lt;/span&gt; enableSuppression, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; writableStackTrace) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(message, cause, enableSuppression, writableStackTrace);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　MyException继承了Exception类，重写了构造函数，并没有加自己的逻辑，只是调用了父类的方法。你看，自定义一个异常其实很简单吧。看到这你也许又疑惑了，这尼玛好像就是给Exception换了个名字，有啥用？？？&lt;/p&gt;
&lt;p&gt;　　别急，别急，你忘了吗，Exception不仅是可以捕获的，还是可以主动抛出的，所以当遇到某些特定的情况时，我们就可以主动抛出异常，然后在调用时去捕获它，获取异常信息，如果直接用Exception的话，那么捕获的时候，会把所有的异常，该捕获不该捕获的都一起捕获了，那么就没法区分哪些是我们主动抛出来的异常了，这样就无法对那些异常进行特殊处理了。&lt;/p&gt;
&lt;h2&gt;异常处理的正确姿势　　&lt;/h2&gt;
&lt;p&gt;　　接下来要简单介绍一个实际使用中常用的异常处理方法——异常链化处理。&lt;/p&gt;
&lt;p&gt;　　在一些大型的，模块化的软件开发中，一旦一个地方发生异常，则如骨牌效应一样，将导致出现一连串的异常。假设B模块需要调用A模块的方法，如果A模块发生异常，则B也将不能完成而发生异常，但是B在抛出异常时，会将A的异常信息掩盖掉，这将使得异常的根源信息丢失。而使用异常的链化可以将多个模块的异常串联起来，使得异常信息不会丢失。&lt;/p&gt;
&lt;p&gt;　　异常链化就是用一个异常对象为参数构造新的异常对象。新的异对象将包含先前异常的信息。这项技术主要是异常类的一个带Throwable参数的函数来实现的。这个当做参数的异常，我们叫他根源异常（cause）。如果你细心一点的话，会发现上面的栗子里也有一个叫做cause的东西，没错，说的其实就是它，在new一个新的异常时，将之前的异常信息传入构造函数即可。下面再用一个简单的栗子进行说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(&lt;/span&gt;&quot;请输入2个加数&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; result;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            result &lt;/span&gt;=&lt;span&gt; add();
            System.out.println(&lt;/span&gt;&quot;结果:&quot;+&lt;span&gt;result);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 执行加法计算
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; add() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; result;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            List&lt;/span&gt;&amp;lt;Integer&amp;gt; nums =&lt;span&gt;getInputNumbers();
            result &lt;/span&gt;= nums.get(0)  + nums.get(1&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InputMismatchException immExp){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链化:以一个异常对象为参数构造新的异常对象。&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;计算失败&quot;&lt;span&gt;,immExp);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取输入的整数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Integer&amp;gt;&lt;span&gt; getInputNumbers() {
        List&lt;/span&gt;&amp;lt;Integer&amp;gt; nums = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        Scanner scan &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num1 =&lt;span&gt; scan.nextInt();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num2 =&lt;span&gt; scan.nextInt();
            nums.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(num1));
            nums.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(num2));
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InputMismatchException immExp){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; immExp;
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            scan.close();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nums;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;请输入2个加数
d d
java.lang.Exception: 计算失败
    at com.frank.chapter17.Test.add(Test.java:&lt;/span&gt;35&lt;span&gt;)
    at com.frank.chapter17.Test.main(Test.java:&lt;/span&gt;18&lt;span&gt;)
Caused by: java.util.InputMismatchException
    at java.util.Scanner.throwFor(Scanner.java:&lt;/span&gt;864&lt;span&gt;)
    at java.util.Scanner.next(Scanner.java:&lt;/span&gt;1485&lt;span&gt;)
    at java.util.Scanner.nextInt(Scanner.java:&lt;/span&gt;2117&lt;span&gt;)
    at java.util.Scanner.nextInt(Scanner.java:&lt;/span&gt;2076&lt;span&gt;)
    at com.frank.chapter17.Test.getInputNumbers(Test.java:&lt;/span&gt;47&lt;span&gt;)
    at com.frank.chapter17.Test.add(Test.java:&lt;/span&gt;31&lt;span&gt;)
    ... &lt;/span&gt;1 more
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，当输入的不是整数时，发生了异常，在getInputNumbers方法里没有处理这个异常，而是将它继续抛出，在add方法里捕获了异常之后，以该异常为构造参数，重新抛出了一个异常，从打印输出的信息可以看到，不仅仅有第二次抛出的异常信息，第一次的输出信息不匹配异常的详细信息也包含在了里面，衔接在Caused by之后，形成了一条异常链，这样可以方便我们更快的排查问题所在。&lt;/p&gt;
&lt;p&gt;　　至此，异常就讲解完毕了，希望能给大家带来一些启发和思考，如果觉得还算ok的话，记得动动小手点推荐，让更多人可以看到，也欢迎关注我的博客，会持续更新的。如果有什么讲的不好的地方。。。emmmmmm，你倒是来打我呀（逃）&lt;/p&gt;

</description>
<pubDate>Wed, 09 May 2018 17:59:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/9017577.html</dc:identifier>
</item>
<item>
<title>EntityFramework 6.x和EntityFramework Core插入数据探讨 - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/9017296.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/9017296.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;一直以来对EF和EF Core都是单独分开来写，从未以比较的形式来讲解，如果您既用过EF 6.x也用过用EF Core是否有了解过EF和EF Core在插入数据时和返回主键有何异同呢？本篇博客是坐在电脑旁本打算写写EF 6.x插入数据注意的问题，心想何不比较二者呢？我也是在探索中（边敲代码边写博客中），下面我们来看看。&lt;/p&gt;
&lt;h2&gt;EF 6.x和EF Core插入数据异同&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                ctx.Database.Log &lt;/span&gt;=&lt;span&gt; Console.WriteLine;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer()
                {
                    Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2752154844@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Orders &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;Order&amp;gt;&lt;span&gt;()
                    {
                       &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Order()
                       {
                           Code &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                           CreatedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                           ModifiedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                           Quantity &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,
                           Price &lt;/span&gt;=&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
                       }
                    }
                };
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述Customer和Order为一对多关系，Order实体中有Customer实体的外键，上述我们同时给Customer和Order赋了值，所以当我们插入Customer的同时Order表中也插入了数据，此时Order的CustomerId是Customer的主键，我们根本不需要为Order中的CustomerId显式赋值，这一点毋庸置疑。我想说的是如果两个表没有很强的关联关系，怎么说呢，换言之两个表没有配置所谓的关系又或许我们没有配置关系，一个表中列需要用到另外一个表的主键，那么这种的情况下，我们会以怎样的方式插入数据呢？实践是检验真理的唯一标准，下面我们来试试。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestA
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Other { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestB
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TestAId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Other { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity&lt;/span&gt;&amp;lt;TestA&amp;gt;&lt;span&gt;()
                .ToTable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestAs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .HasKey(p &lt;/span&gt;=&amp;gt;&lt;span&gt; p.Id)
                .Property(p &lt;/span&gt;=&amp;gt;&lt;span&gt; p.Other);

            modelBuilder.Entity&lt;/span&gt;&amp;lt;TestB&amp;gt;&lt;span&gt;()
               .ToTable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestBs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
               .HasKey(p &lt;/span&gt;=&amp;gt;&lt;span&gt; p.Id)
               .Property(p &lt;/span&gt;=&amp;gt;&lt;span&gt; p.Other);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述我们给出TestA和TestB，TestA和TestB没有任何关系，但是我们在插入TestB数据时需要得到Test的主键，那我们下面就进行如下数据添加。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                ctx.Database.Log &lt;/span&gt;=&lt;span&gt; Console.WriteLine;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testA = &lt;span&gt;new&lt;/span&gt; TestA() { Other = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;other&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                ctx.TestAs.Add(testA);
                ctx.SaveChanges();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testB = &lt;span&gt;new&lt;/span&gt; TestB() { Other = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;other&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TestAId =&lt;span&gt; testA.Id };
                ctx.TestBs.Add(testB);
                ctx.SaveChanges();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180510000758292-258910191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们看到提交后数据最终能够保存到数据库中，反观上述提交代码，我们首先是提交了TestA保存到数据库后然后拿到TestA的主键，然后再是提交TestB并保存到数据库中。那我们有没有考虑是否直接一次性提交呢，注释TestA提交，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                ctx.Database.Log &lt;/span&gt;=&lt;span&gt; Console.WriteLine;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testA = &lt;span&gt;new&lt;/span&gt; TestA() { Other = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;other&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                ctx.TestAs.Add(testA);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ctx.SaveChanges();&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; testB = &lt;span&gt;new&lt;/span&gt; TestB() { Other = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;other&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TestAId =&lt;span&gt; testA.Id };
                ctx.TestBs.Add(testB);
                ctx.SaveChanges();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180510001141972-1046025681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;WOW不行啊，下面我们来看看在EF Core中实现是不是可以，试试就知道了，别猜测。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            modelBuilder.Entity&amp;lt;TestA&amp;gt;(e =&amp;gt;&lt;span&gt;
            {
                e.ToTable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestAs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                e.HasKey(p &lt;/span&gt;=&amp;gt;&lt;span&gt; p.Id);
                e.Property(p &lt;/span&gt;=&amp;gt;&lt;span&gt; p.Other);
            });


            modelBuilder.Entity&lt;/span&gt;&amp;lt;TestB&amp;gt;(e =&amp;gt;&lt;span&gt;
            {
                e.ToTable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestBs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                e.HasKey(p &lt;/span&gt;=&amp;gt;&lt;span&gt; p.Id);
                e.Property(p &lt;/span&gt;=&amp;gt;&lt;span&gt; p.Other);
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testA = &lt;span&gt;new&lt;/span&gt; TestA() { Other = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;other&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                context.TestAs.Add(testA);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ctx.SaveChanges();&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; testB = &lt;span&gt;new&lt;/span&gt; TestB() { Other = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;other&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TestAId =&lt;span&gt; testA.Id };
                context.TestBs.Add(testB);
                context.SaveChanges();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180510002331824-749089346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果分两次提交那么无论是在EF 6.x还是EF Core中都是一样没有任何不同（在EF Core中没有测试也不用测试）。如果是一次性提交，此时在EF 6.x中的TestB中的TestAId为插入的是0，而EF Core中的TestB中的TestAId为-2147482647即INT类型最小值，至少找到了不同所在。Jeff自问自答的模式要来了，是不是就这样结束了呢？上述我们对TestA和TestB两个实体未配置任何关系，我们经过测试证明一次性提交并未达到我们预期，要是我们依然在不配置关系的前提下给出导航属性然后一次性提交呢，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestA
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Other { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestB
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TestAId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Other { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TestA TestA { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们在EF Core控制台再次运行上述代码看看，您思考下会不会将TestA中的主键添加进去呢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180510003154572-482892403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果您在EF 6.x中同样添加上述导航属性也是好使的，我就不测试了，那到此我们得出结论：&lt;span&gt;若两个实体未显式配置任何关系但一个表需要得到另外一个表的主键，无论是在EF 6.x还是在EF Core中进行一次性提交不好使，只是在EF 6.x中一个表需要得到另外一个表的主键为0，而在EF Core中却是INT类型最小值，若我们显式配置了导航属性，那么无论是在EF 6.x还是EF Core中一次性提交可达到我们预期。 &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;比较EF 6.x和EF Core插入数据返回主键&lt;/h2&gt;
&lt;p&gt;如果是主键为INT类型，默认情况无论是EF 6.x还是EF Core都将自动映射配置为自增长，要是我们显式配置了主键，那么对于EF 6.x和EF Core会有何不同呢？我们首先看看EF 6.x，如下（我们清除之前已提交数据）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                ctx.Database.Log &lt;/span&gt;=&lt;span&gt; Console.WriteLine;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testA = &lt;span&gt;new&lt;/span&gt; TestA() { Id = 1, Other = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;other&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                ctx.TestAs.Add(testA);
                ctx.SaveChanges();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180510005952185-2104438855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上述我们提交三次看出，压根不叼我们设置的值，那么我们看看生成的SQL语句是怎样的呢，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180510005915530-9683729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这下我们明白了此时通过scope_identity返回为当前会话和当前作用域中的TestA表生成的最新标识值。接下来我们来看看EF Core。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testA = &lt;span&gt;new&lt;/span&gt; TestA() { Id = &lt;span&gt;1&lt;/span&gt;, Other = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;other&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                context.TestAs.Add(testA);
                context.SaveChanges();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 当我们进行第二次提交后将抛出异常，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180510010744784-1657550638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们同样看看在EF Core中生成的SQL是怎样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180510010640796-397842443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来如此没有返回当前会话自增长值，同时我们知道不能显式插入值，那就是关闭了IDENTITY_Insert。所以我们得出结论：&lt;span&gt;在以INT作为主键且自增长时，在EF 6.x中能够显式给出值，而在EF Core中不能显式给定值即关闭了IDENTITY_Insert。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本节我们详细叙述了EF 6.x和EF Core中插入数据和返回主键的不同之处，虽然作用不大，可以作为了解，最近比较累，可能会停更一小段时间，好好休息一下，书出版了会及时告知同行关注者。&lt;/p&gt;
</description>
<pubDate>Wed, 09 May 2018 17:18:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CreateMyself/p/9017296.html</dc:identifier>
</item>
<item>
<title>JVM学习记录-垃圾回收算法 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/9000249.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/9000249.html</guid>
<description>&lt;h2&gt;简述&lt;/h2&gt;
&lt;p&gt;因为各个平台的虚拟机的垃圾收集器的实现各有不同，所以只介绍几个常见的垃圾收集算法。&lt;/p&gt;
&lt;p&gt;JVM中常见的垃圾收集算法有以下四种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标记-清除算法（Mark-Sweep）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复制算法（Copying）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标记整理算法(Mark-Compact)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分代收集算法（Generational Collecting）。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt; 标记-清除算法&lt;/h3&gt;
&lt;p&gt;标记-清除算法是现代垃圾回收算法的思想基础，主要分为两个阶段：&lt;strong&gt;标记&lt;/strong&gt;阶段和&lt;strong&gt;清除&lt;/strong&gt;阶段。首先根据可达分析算法，标记处可以回收的对象，标记完成后，进行清除阶段，将标记为可回收的对象进行清除。这个算法有两个弱点，一个弱点是效率问题，标记和清除效率都不高，另一弱点，也是最大的弱点就是会产生空间碎片。当内存中空间碎片过多时，在创建较大的对象过程中，无法分配出足够的联系内存空间，会不得以的出发一次垃圾回收动作。&lt;/p&gt;
&lt;p&gt;标记-清除算法执行过程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/772743/201805/772743-20180509224626934-195873962.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;复制算法&lt;/h3&gt;
&lt;p&gt;与标记-清除算法相比，复制算法是一种相对效率高的回收算法，它的核心思想是：&lt;strong&gt;将原有的内存空间划分为大小相等的两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活的对象复制到未使用的的内存块中，然后清除正在使用的内存块，然后交换两个内存的角色（即使用块变成未使用块，未使用块变成使用块）&lt;/strong&gt;。复制算法可以保证回收后没有空间碎片。但是复制算法的弱点是将系统可用内存折半，这个代价有些太大。&lt;/p&gt;
&lt;p&gt;执行过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/772743/201805/772743-20180509232644788-2036187235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在JVM的新生代（堆内存分为&lt;strong&gt;新生代&lt;/strong&gt;和&lt;strong&gt;老年代&lt;/strong&gt;）中就是使用的这种收集算法，在新生代中大部分对象都是“朝生夕死”，所以复制算法也不是非要按照对半平分内存，而是分为较大的一个&lt;strong&gt;Eden&lt;/strong&gt;空间和两个较小的&lt;strong&gt;Survivor&lt;/strong&gt;空间（from和to）,每次进行新生代回收时会将&lt;strong&gt;Eden区&lt;/strong&gt;和&lt;strong&gt;from Survivor区&lt;/strong&gt;还存活着的对象复制到&lt;strong&gt;to Survivor区&lt;/strong&gt;，然后清理掉&lt;strong&gt;Eden区&lt;/strong&gt;和f&lt;strong&gt;rom Survivor区&lt;/strong&gt;的可回收对象，如果&lt;strong&gt;to Survivor区&lt;/strong&gt;中没有足够的空间来接受还存活着的对象，则会把多余的对象放到老年代区。这种改进的（非平分内存）复制算法，既保证了空间的连续性，又避免了大量的内存空间的浪费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复制算法适用于新生代，是因为在新生代中，垃圾对象通常多于存活对象，这中情况适用复制算法效果会比较好。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;标记整理算法&lt;/h3&gt;
&lt;p&gt;复制算法的高效性，是因为新生代的存活对象多，垃圾对象少。但是在老年代中，常见的情况下大部分都是存活对象，如果依然只用复制算法，效率就会大大折扣。因为存活对象太多，复制的成本太高了。&lt;/p&gt;
&lt;p&gt;基于老年代的特点，产生了一种&lt;strong&gt;标记整理算法&lt;/strong&gt;，标记整理算法也是分两个阶段，&lt;strong&gt;标记阶段&lt;/strong&gt;和&lt;strong&gt;整理阶段&lt;/strong&gt;，标记阶段也是先标记出存活的对象，在整理阶段是将存活的对象都向内存的一端进行压缩移动，然后清理掉端边界以外的空间。&lt;/p&gt;
&lt;p&gt;标记整理算法执行过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/772743/201805/772743-20180510002856827-547001700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种算法既避免了产生空间碎片，又不需要将内存平分，因此效率还是可以的。&lt;/p&gt;
&lt;h3&gt;分代收集算法&lt;/h3&gt;
&lt;p&gt;当前的商业虚拟机都采用“分代收集算法”，其主要思想是：&lt;strong&gt;根据垃圾回收对象的特性，使用合适的算法进行回收。&lt;/strong&gt;基于这种思想，分代算法将堆内存分为特点鲜明的几块，根据每块的特点，选择适用的收集算法，进而提高回收效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在新生代时使用复制算法，在老年代时使用标记压缩算法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种分代算法在HotSpot虚拟机上使用，几乎所有的垃圾回收器都区分新生代和老年代。&lt;/p&gt;
</description>
<pubDate>Wed, 09 May 2018 16:39:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jimoer/p/9000249.html</dc:identifier>
</item>
<item>
<title>算法中处理平方数的坑 - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9017427.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9017427.html</guid>
<description>&lt;p&gt;&amp;#13;
                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt;&amp;#13;
                                    &lt;h4 class=&quot;modal-title&quot;&gt;&amp;#13;
                                        请完成人机识别验证&amp;#13;
                                    &lt;/h4&gt;&amp;#13;
                                &lt;/p&gt;
                                &lt;div class=&quot;modal-body&quot; readability=&quot;33&quot;&gt;
                                    
                                    &lt;p&gt;&amp;#13;
                                        &lt;span id=&quot;geetestLoading&quot;&gt; 验证码组件加载中,请稍后...&lt;/span&gt;&amp;#13;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            </description>
<pubDate>Wed, 09 May 2018 16:06:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=http%3A%2F%2Fwww.cnblogs.com%2Fdgwblog%2Fp%2F9017427.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
<item>
<title>RocketMQ源码 — 九、 RocketMQ延时消息 - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/9017426.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/9017426.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/sunshine-2015/p/9011446.html&quot;&gt;上一节&lt;/a&gt;消息重试里面提到了重试的消息可以被延时消费，其实除此之外，用户发送的消息也可以指定延时时间（更准确的说是延时等级），然后在指定延时时间之后投递消息，然后被consumer消费。阿里云的ons还支持定时消息，而且延时消息是直接指定延时时间，其实阿里云的延时消息也是定时消息的另一种表述方式，都是通过设置消息被投递的时间来实现的，但是Apache RocketMQ在版本4.2.0中尚不支持指定时间的延时，只能通过配置延时等级和延时等级对应的时间来实现延时。&lt;/p&gt;
&lt;p&gt;一个延时消息被发出到消费成功经历以下几个过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置消息的延时级别delayLevel&lt;/li&gt;
&lt;li&gt;producer发送消息&lt;/li&gt;
&lt;li&gt;broker收到消息在准备将消息写入存储的时候，判断是延时消息则更改Message的topic为延时消息队列的topic，也就是将消息投递到延时消息队列&lt;/li&gt;
&lt;li&gt;有定时任务从延时队列中读取消息，拿到消息后判断是否达到延时时间，如果到了则修改topic为原始topic。并将消息投递到原始topic的队列&lt;/li&gt;
&lt;li&gt;consumer像消费其他消息一样从broker拉取消息进行消费&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意：批量消息是不支持延时消息的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tips:下文中说到的延时队列可以理解为一个ConsumeQueue&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;producer发送延时消息&quot;&gt;producer发送延时消息&lt;/h2&gt;
&lt;p&gt;在producer中发送消息的时候，设置Message的delayLevel&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// org.apache.rocketmq.common.message.Message&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setDelayTimeLevel&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; level) {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;putProperty&lt;/span&gt;(MessageConst.&lt;span class=&quot;fu&quot;&gt;PROPERTY_DELAY_TIME_LEVEL&lt;/span&gt;, String.&lt;span class=&quot;fu&quot;&gt;valueOf&lt;/span&gt;(level));
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用上面的方法设置延时等级的时候，会向message添加&quot;DELAY&quot;属性，后面broker处理延时消息就是依赖该属性进行特别的处理。&lt;/p&gt;
&lt;p&gt;接下来发送消息的流程和正常发送消息的流程基本一致，只是会将该消息标记为延时消息类型&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#sendKernelImpl &lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (msg.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;__STARTDELIVERTIME&quot;&lt;/span&gt;) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || msg.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(MessageConst.&lt;span class=&quot;fu&quot;&gt;PROPERTY_DELAY_TIME_LEVEL&lt;/span&gt;) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
    context.&lt;span class=&quot;fu&quot;&gt;setMsgType&lt;/span&gt;(MessageType.&lt;span class=&quot;fu&quot;&gt;Delay_Msg&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;broker处理延时消息&quot;&gt;broker处理延时消息&lt;/h2&gt;
&lt;p&gt;broker收到延时消息和正常消息在前置的处理流程是一致的，对于延时消息的特殊处理体现在将消息写入存储（内存或文件）的时候&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// org.apache.rocketmq.store.CommitLog#putMessage&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; PutMessageResult &lt;span class=&quot;fu&quot;&gt;putMessage&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; MessageExtBrokerInner msg) {
    &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
    StoreStatsService storeStatsService = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;defaultMessageStore&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getStoreStatsService&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;// 拿到原始topic和对应的queueId&lt;/span&gt;
    String topic = msg.&lt;span class=&quot;fu&quot;&gt;getTopic&lt;/span&gt;();
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; queueId = msg.&lt;span class=&quot;fu&quot;&gt;getQueueId&lt;/span&gt;();

    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; tranType = MessageSysFlag.&lt;span class=&quot;fu&quot;&gt;getTransactionValue&lt;/span&gt;(msg.&lt;span class=&quot;fu&quot;&gt;getSysFlag&lt;/span&gt;());
    &lt;span class=&quot;co&quot;&gt;// 非事务消息和事务的commit消息才会进一步判断delayLevel&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (tranType == MessageSysFlag.&lt;span class=&quot;fu&quot;&gt;TRANSACTION_NOT_TYPE&lt;/span&gt;
        || tranType == MessageSysFlag.&lt;span class=&quot;fu&quot;&gt;TRANSACTION_COMMIT_TYPE&lt;/span&gt;) {
        &lt;span class=&quot;co&quot;&gt;// Delay Delivery&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (msg.&lt;span class=&quot;fu&quot;&gt;getDelayTimeLevel&lt;/span&gt;() &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
            &lt;span class=&quot;co&quot;&gt;// 纠正设置过大的level，就是delayLevel设置都大于延时时间等级的最大级&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (msg.&lt;span class=&quot;fu&quot;&gt;getDelayTimeLevel&lt;/span&gt;() &amp;gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;defaultMessageStore&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getScheduleMessageService&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getMaxDelayLevel&lt;/span&gt;()) {
                msg.&lt;span class=&quot;fu&quot;&gt;setDelayTimeLevel&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;defaultMessageStore&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getScheduleMessageService&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getMaxDelayLevel&lt;/span&gt;());
            }

            &lt;span class=&quot;co&quot;&gt;// 设置为延时队列的topic&lt;/span&gt;
            topic = ScheduleMessageService.&lt;span class=&quot;fu&quot;&gt;SCHEDULE_TOPIC&lt;/span&gt;;
            &lt;span class=&quot;co&quot;&gt;// 每一个延时等级一个queue，queueId = delayLevel - 1&lt;/span&gt;
            queueId = ScheduleMessageService.&lt;span class=&quot;fu&quot;&gt;delayLevel2QueueId&lt;/span&gt;(msg.&lt;span class=&quot;fu&quot;&gt;getDelayTimeLevel&lt;/span&gt;());

            &lt;span class=&quot;co&quot;&gt;// Backup real topic, queueId&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 备份原始的topic和queueId&lt;/span&gt;
            MessageAccessor.&lt;span class=&quot;fu&quot;&gt;putProperty&lt;/span&gt;(msg, MessageConst.&lt;span class=&quot;fu&quot;&gt;PROPERTY_REAL_TOPIC&lt;/span&gt;, msg.&lt;span class=&quot;fu&quot;&gt;getTopic&lt;/span&gt;());
            MessageAccessor.&lt;span class=&quot;fu&quot;&gt;putProperty&lt;/span&gt;(msg, MessageConst.&lt;span class=&quot;fu&quot;&gt;PROPERTY_REAL_QUEUE_ID&lt;/span&gt;, String.&lt;span class=&quot;fu&quot;&gt;valueOf&lt;/span&gt;(msg.&lt;span class=&quot;fu&quot;&gt;getQueueId&lt;/span&gt;()));
            &lt;span class=&quot;co&quot;&gt;// 更新properties&lt;/span&gt;
            msg.&lt;span class=&quot;fu&quot;&gt;setPropertiesString&lt;/span&gt;(MessageDecoder.&lt;span class=&quot;fu&quot;&gt;messageProperties2String&lt;/span&gt;(msg.&lt;span class=&quot;fu&quot;&gt;getProperties&lt;/span&gt;()));

            msg.&lt;span class=&quot;fu&quot;&gt;setTopic&lt;/span&gt;(topic);
            msg.&lt;span class=&quot;fu&quot;&gt;setQueueId&lt;/span&gt;(queueId);
        }
    }
    &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的SCHEDULE_TOPIC是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public static final String SCHEDULE_TOPIC = &quot;SCHEDULE_TOPIC_XXXX&quot;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个topic是一个特殊的topic，和正常的topic不同的地方是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不会创建TopicConfig，因为也不需要consumer直接消费这个topic下的消息&lt;/li&gt;
&lt;li&gt;不会将topic注册到namesrv&lt;/li&gt;
&lt;li&gt;这个topic的队列个数和延时等级的个数是相同的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;后面消息写入的过程和普通的又是一致的。&lt;/p&gt;
&lt;p&gt;上面将消息写入延时队列中了，接下来就是处理延时队列中的消息，然后重新发送回原始topic的队列中。&lt;/p&gt;
&lt;p&gt;在此之前先说明下至今还有疑问的一个个概念——delayLevel。这个概念和我们接下要需要用到的的类org.apache.rocketmq.store.schedule.ScheduleMessageService有关，这个类的字段delayLevelTable里面保存了具体的延时等级&lt;/p&gt;
&lt;p&gt;&lt;code&gt;private final ConcurrentMap&amp;lt;Integer /* level */, Long/* delay timeMillis */&amp;gt; delayLevelTable = new ConcurrentHashMap&amp;lt;Integer, Long&amp;gt;(32);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看下这个字段的初始化过程&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// org.apache.rocketmq.store.schedule.ScheduleMessageService#parseDelayLevel&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;parseDelayLevel&lt;/span&gt;() {
    HashMap&amp;lt;String, Long&amp;gt; timeUnitTable = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;String, Long&amp;gt;();
    &lt;span class=&quot;co&quot;&gt;// 每个延时等级延时时间的单位对应的ms数&lt;/span&gt;
    timeUnitTable.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;s&quot;&lt;/span&gt;, 1000L);
    timeUnitTable.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;m&quot;&lt;/span&gt;, 1000L * &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;);
    timeUnitTable.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;h&quot;&lt;/span&gt;, 1000L * &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt; * &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;);
    timeUnitTable.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;d&quot;&lt;/span&gt;, 1000L * &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt; * &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt; * &lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt;);

    &lt;span class=&quot;co&quot;&gt;// 延时等级在MessageStoreConfig中配置&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// private String messageDelayLevel = &quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;;&lt;/span&gt;
    String levelString = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;defaultMessageStore&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getMessageStoreConfig&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getMessageDelayLevel&lt;/span&gt;();
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;co&quot;&gt;// 根据空格将配置分隔出每个等级&lt;/span&gt;
        String[] levelArray = levelString.&lt;span class=&quot;fu&quot;&gt;split&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot; &quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; levelArray.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; i++) {
            String value = levelArray[i];
            String ch = value.&lt;span class=&quot;fu&quot;&gt;substring&lt;/span&gt;(value.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;() - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;// 时间单位对应的ms数&lt;/span&gt;
            Long tu = timeUnitTable.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(ch);

            &lt;span class=&quot;co&quot;&gt;// 延时等级从1开始&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; level = i + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (level &amp;gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;maxDelayLevel&lt;/span&gt;) {
                &lt;span class=&quot;co&quot;&gt;// 找出最大的延时等级&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;maxDelayLevel&lt;/span&gt; = level;
            }
            &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; num = Long.&lt;span class=&quot;fu&quot;&gt;parseLong&lt;/span&gt;(value.&lt;span class=&quot;fu&quot;&gt;substring&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, value.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;() - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));
            &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; delayTimeMillis = tu * num;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;delayLevelTable&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(level, delayTimeMillis);
    &lt;span class=&quot;co&quot;&gt;// 省略部分代码...&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个load方法在broker启动的时候DefaultMessageStore会调用来初始化延时等级。&lt;/p&gt;
&lt;p&gt;接下来就应该解决怎么处理延时消息队列中的消息的问题了。处理延时消息的服务是：ScheduleMessageService。&lt;/p&gt;
&lt;p&gt;还是broker启动的时候DefaultMessageStore会调用org.apache.rocketmq.store.schedule.ScheduleMessageService#start来启动处理延时消息队列的服务：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;() {

    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Map.&lt;span class=&quot;fu&quot;&gt;Entry&lt;/span&gt;&amp;lt;Integer, Long&amp;gt; entry : &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;delayLevelTable&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;entrySet&lt;/span&gt;()) {
        Integer level = entry.&lt;span class=&quot;fu&quot;&gt;getKey&lt;/span&gt;();
        Long timeDelay = entry.&lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;// 记录队列的处理进度&lt;/span&gt;
        Long offset = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;offsetTable&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(level);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; == offset) {
            offset = 0L;
        }

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (timeDelay != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;co&quot;&gt;// 每个延时队列启动一个定时任务来处理该队列的延时消息&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;timer&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DeliverDelayedMessageTimerTask&lt;/span&gt;(level, offset), FIRST_DELAY_TIME);
        }
    }

    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;timer&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduleAtFixedRate&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; TimerTask() {

        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;// 持久化offsetTable(保存了每个延时队列对应的处理进度offset)&lt;/span&gt;
                ScheduleMessageService.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;persist&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable e) {
                log.&lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;scheduleAtFixedRate flush exception&quot;&lt;/span&gt;, e);
            }
        }
    }, &lt;span class=&quot;dv&quot;&gt;10000&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;defaultMessageStore&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getMessageStoreConfig&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getFlushDelayOffsetInterval&lt;/span&gt;());
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DeliverDelayedMessageTimerTask是一个TimerTask，启动以后不断处理延时队列中的消息，直到出现异常则终止该线程重新启动一个新的TimerTask&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;executeOnTimeup&lt;/span&gt;() {
    &lt;span class=&quot;co&quot;&gt;// 找到该延时等级对应的ConsumeQueue&lt;/span&gt;
    ConsumeQueue cq =
        ScheduleMessageService.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;defaultMessageStore&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;findConsumeQueue&lt;/span&gt;(SCHEDULE_TOPIC,
            &lt;span class=&quot;fu&quot;&gt;delayLevel2QueueId&lt;/span&gt;(delayLevel));
    &lt;span class=&quot;co&quot;&gt;// 记录异常情况下一次启动TimerTask开始处理的offset&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; failScheduleOffset = offset;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (cq != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;co&quot;&gt;// 找到offset所处的MappedFile中offset后面的buffer&lt;/span&gt;
        SelectMappedBufferResult bufferCQ = cq.&lt;span class=&quot;fu&quot;&gt;getIndexBuffer&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;offset&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (bufferCQ != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; nextOffset = offset;
                &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
                ConsumeQueueExt.&lt;span class=&quot;fu&quot;&gt;CqExtUnit&lt;/span&gt; cqExtUnit = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ConsumeQueueExt.&lt;span class=&quot;fu&quot;&gt;CqExtUnit&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (; i &amp;lt; bufferCQ.&lt;span class=&quot;fu&quot;&gt;getSize&lt;/span&gt;(); i += ConsumeQueue.&lt;span class=&quot;fu&quot;&gt;CQ_STORE_UNIT_SIZE&lt;/span&gt;) {
                    &lt;span class=&quot;co&quot;&gt;// 下面三个字段信息是ConsumeQueue物理存储的信息&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; offsetPy = bufferCQ.&lt;span class=&quot;fu&quot;&gt;getByteBuffer&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getLong&lt;/span&gt;();
                    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sizePy = bufferCQ.&lt;span class=&quot;fu&quot;&gt;getByteBuffer&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getInt&lt;/span&gt;();
                    &lt;span class=&quot;co&quot;&gt;// 注意这个tagCode，不再是普通的tag的hashCode，而是该延时消息到期的时间&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; tagsCode = bufferCQ.&lt;span class=&quot;fu&quot;&gt;getByteBuffer&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getLong&lt;/span&gt;();
                    &lt;span class=&quot;co&quot;&gt;// 省略中间代码....&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; now = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
                    &lt;span class=&quot;co&quot;&gt;// 计算应该投递该消息的时间，如果已经超时则立即投递&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; deliverTimestamp = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;correctDeliverTimestamp&lt;/span&gt;(now, tagsCode);
                    &lt;span class=&quot;co&quot;&gt;// 计算下一个消息的开始位置，用来寻找下一个消息位置(如果有的话)&lt;/span&gt;
                    nextOffset = offset + (i / ConsumeQueue.&lt;span class=&quot;fu&quot;&gt;CQ_STORE_UNIT_SIZE&lt;/span&gt;);
                    &lt;span class=&quot;co&quot;&gt;// 判断延时消息是否到期&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; countdown = deliverTimestamp - now;

                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (countdown &amp;lt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                        MessageExt msgExt =
                            ScheduleMessageService.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;defaultMessageStore&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;lookMessageByOffset&lt;/span&gt;(
                                offsetPy, sizePy);

                        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (msgExt != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                                &lt;span class=&quot;co&quot;&gt;// 将消息恢复到原始消息的格式，恢复topic、queueId、tagCode等，清除属性&quot;DELAY&quot;&lt;/span&gt;
                                MessageExtBrokerInner msgInner = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;messageTimeup&lt;/span&gt;(msgExt);
                                PutMessageResult putMessageResult =
                                    ScheduleMessageService.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;defaultMessageStore&lt;/span&gt;
                                        .&lt;span class=&quot;fu&quot;&gt;putMessage&lt;/span&gt;(msgInner);

                                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (putMessageResult != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;
                                    &amp;amp;&amp;amp; putMessageResult.&lt;span class=&quot;fu&quot;&gt;getPutMessageStatus&lt;/span&gt;() == PutMessageStatus.&lt;span class=&quot;fu&quot;&gt;PUT_OK&lt;/span&gt;) {
                                    &lt;span class=&quot;co&quot;&gt;// 投递成功，处理下一个&lt;/span&gt;
                                    &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;;
                                } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                                    &lt;span class=&quot;co&quot;&gt;// XXX: warn and notify me&lt;/span&gt;
                                    log.&lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(
                                        &lt;span class=&quot;st&quot;&gt;&quot;ScheduleMessageService, a message time up, but reput it failed, topic: {} msgId {}&quot;&lt;/span&gt;,
                                        msgExt.&lt;span class=&quot;fu&quot;&gt;getTopic&lt;/span&gt;(), msgExt.&lt;span class=&quot;fu&quot;&gt;getMsgId&lt;/span&gt;());
                                    &lt;span class=&quot;co&quot;&gt;// 投递失败，结束当前task，重新启动TimerTask，从下一个消息开始处理，也就是说当前消息丢弃&lt;/span&gt;
                                    &lt;span class=&quot;co&quot;&gt;// 更新offsetTable中当前队列的offset为下一个消息的offset&lt;/span&gt;
                                    ScheduleMessageService.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;timer&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;(
                                        &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DeliverDelayedMessageTimerTask&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;delayLevel&lt;/span&gt;,
                                            nextOffset), DELAY_FOR_A_PERIOD);
                                    ScheduleMessageService.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;updateOffset&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;delayLevel&lt;/span&gt;,
                                        nextOffset);
                                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
                                }
                            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                                &lt;span class=&quot;co&quot;&gt;// 重新投递期间出现任何异常，结束当前task，重新启动TimerTask，从当前消息开始重试&lt;/span&gt;
                                &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;                                 * XXX: warn and notify me&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;                                 */&lt;/span&gt;
                                log.&lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(
                                    &lt;span class=&quot;st&quot;&gt;&quot;ScheduleMessageService, messageTimeup execute error, drop it. msgExt=&quot;&lt;/span&gt;
                                        + msgExt + &lt;span class=&quot;st&quot;&gt;&quot;, nextOffset=&quot;&lt;/span&gt; + nextOffset + &lt;span class=&quot;st&quot;&gt;&quot;,offsetPy=&quot;&lt;/span&gt;
                                        + offsetPy + &lt;span class=&quot;st&quot;&gt;&quot;,sizePy=&quot;&lt;/span&gt; + sizePy, e);
                            }
                        }
                    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                        ScheduleMessageService.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;timer&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;(
                            &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DeliverDelayedMessageTimerTask&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;delayLevel&lt;/span&gt;, nextOffset),
                            countdown);
                        ScheduleMessageService.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;updateOffset&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;delayLevel&lt;/span&gt;, nextOffset);
                        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
                    }
                } &lt;span class=&quot;co&quot;&gt;// end of for&lt;/span&gt;
                &lt;span class=&quot;co&quot;&gt;// 处理完当前MappedFile中的消息后，重新启动TimerTask，从下一个消息开始处理&lt;/span&gt;
                &lt;span class=&quot;co&quot;&gt;// 更新offsetTable中当前队列的offset为下一个消息的offset&lt;/span&gt;
                nextOffset = offset + (i / ConsumeQueue.&lt;span class=&quot;fu&quot;&gt;CQ_STORE_UNIT_SIZE&lt;/span&gt;);
                ScheduleMessageService.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;timer&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DeliverDelayedMessageTimerTask&lt;/span&gt;(
                    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;delayLevel&lt;/span&gt;, nextOffset), DELAY_FOR_A_WHILE);
                ScheduleMessageService.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;updateOffset&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;delayLevel&lt;/span&gt;, nextOffset);
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
            } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {

                bufferCQ.&lt;span class=&quot;fu&quot;&gt;release&lt;/span&gt;();
            }
        } &lt;span class=&quot;co&quot;&gt;// end of if (bufferCQ != null)&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// 如果根据offsetTable中的offset没有找到对应的消息(可能被删除了)，则按照当前ConsumeQueue的最小offset开始处理&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; cqMinOffset = cq.&lt;span class=&quot;fu&quot;&gt;getMinOffsetInQueue&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (offset &amp;lt; cqMinOffset) {
                failScheduleOffset = cqMinOffset;
                log.&lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;schedule CQ offset invalid. offset=&quot;&lt;/span&gt; + offset + &lt;span class=&quot;st&quot;&gt;&quot;, cqMinOffset=&quot;&lt;/span&gt;
                    + cqMinOffset + &lt;span class=&quot;st&quot;&gt;&quot;, queueId=&quot;&lt;/span&gt; + cq.&lt;span class=&quot;fu&quot;&gt;getQueueId&lt;/span&gt;());
            }
        }
    } &lt;span class=&quot;co&quot;&gt;// end of if (cq != null)&lt;/span&gt;
    
    ScheduleMessageService.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;timer&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DeliverDelayedMessageTimerTask&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;delayLevel&lt;/span&gt;,
        failScheduleOffset), DELAY_FOR_A_WHILE);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于上面的tagCode做一下特别说明，延时消息的tagCode和普通消息不一样：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;延时消息的tagCode：存储的是消息到期的时间&lt;/li&gt;
&lt;li&gt;非延时消息的tagCode：tags字符串的hashCode&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对延时消息的tagCode的特别处理是在下面这个方法中完成的，也就是在build ConsumeQueue信息的时候&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.apache.rocketmq.store.CommitLog#checkMessageAndReturnSize(java.nio.ByteBuffer, boolean, boolean)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;以上就是RocketMQ延时消息的实现方式，上面没有详说的是重试消息的延时是怎么实现的，其实就是在consumer将延时消息发送回broker的时候设置了（用户可以自己设置，如果没有自己设置默认是0）delayLevel，到了broker处理重试消息的时候如果delayLevel是0（也就是说是默认的延时等级）的时候会在原来的基础上加3，后面的处理就和上面说的延时消息一样了，存储的时候将消息投递到延时队列，等待延时到期后再重新投递到原始topic队列中等到consumer消费。&lt;/p&gt;
</description>
<pubDate>Wed, 09 May 2018 16:05:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/9017426.html</dc:identifier>
</item>
<item>
<title>爬虫之urllib.error模块 - 人生不如戏</title>
<link>http://www.cnblogs.com/fu-yong/p/9017400.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fu-yong/p/9017400.html</guid>
<description>&lt;h2&gt;error模块简介&lt;/h2&gt;
&lt;p&gt;我们在爬虫的时候发请求的时候难免出现错误，如访问不到服务器或者访问被禁止等等，&lt;/p&gt;
&lt;p&gt;出错了之后urllib将错误信息封装成了一个模块对象中，这个模块就叫error模块&lt;/p&gt;
&lt;h2&gt;error的分类&lt;/h2&gt;
&lt;p&gt;分为URLError和HTTPError。&lt;/p&gt;
&lt;p&gt;URLError是OSError的一个子类&lt;/p&gt;
&lt;p&gt;有以下错误的时候错误信息就会被封装在URLError里：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;无网络&lt;/li&gt;
&lt;li&gt;有网络但是由于种种原因导致服务器连接失败&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而如果能够连接服务器但是服务器返回了错误代码如404，403等等（400以上），那么催无信息就会被封装在HTTPError里&lt;/p&gt;
&lt;h2&gt;URLError与HttpError的区别和关系&lt;/h2&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;URLError封装的错误信息一般是由网络引起的，包括url错误&lt;/li&gt;
&lt;li&gt;HTTPError封装的错误信息一般是服务器返回了错误状态码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;URLError是OSERROR的子类，HTTPError是URLError的子类&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;使用方法&lt;/h2&gt;
&lt;p&gt;error类是在捕获错误信息的时候使用，而且一般我们也需要进行捕获，因为你很难确定访问请求一定不会出现错误&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from urllib import request
from urllib import error

url = 'http://baiduuuu.com'

try:
    res = request.Request(url)
    response = request.urlopen(res)

    print(response.read().decode())

except error.HTTPError as he:
    print(he)
    # print(he.reason)

except error.URLError as ue:
    print(ue)
    # print(ue.reason)

except Exception as e:
    print(e)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：由于HTTPError是URLError的子类，所以捕获的时候HTTPError要放在URLError的上面&lt;/p&gt;
</description>
<pubDate>Wed, 09 May 2018 15:56:00 +0000</pubDate>
<dc:creator>人生不如戏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fu-yong/p/9017400.html</dc:identifier>
</item>
<item>
<title>Ajax详解 - 疾风_lu</title>
<link>http://www.cnblogs.com/518894-lu/p/9016129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/518894-lu/p/9016129.html</guid>
<description>&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;有时我们在使用requests抓取数据时得到的返回结果会与浏览器中看到的内容不一致，这是因为requests只能得到原始的HTML文挡，而浏览器的页面是通过javascript处理数据后生成的，这些数据的来源可能是Ajax加载的；可能是包含在HTML文档中的，也有可能是javascript+特定的算法生成的。&lt;/p&gt;
&lt;p&gt;对于Ajax加载的页面：当你打开网站，原始页面中只会包含一部分数据，当这部分数据被加载后，会向服务器某个接口发送一个请求来请求数据，拿到数据后再由浏览器进行渲染得到小伙伴们看到的页面的全部内容（这里比如京东商场，当你搜索某个关键字时，会出现很多商品，当你的滚动条往下滑，商品信息才慢慢被加载出来！），而这个发送的请求就是Ajax&lt;/p&gt;
&lt;p&gt;1、What is Ajax?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload.soyohui.com/ueditor/20170918/soyohui59bf91b3e44ae.jpg&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;115&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：全称为：Asynchronous JavaScript and XML ，也就是异步加载的javascript 和 XML（通俗的讲：利用javascript在保证页面不被完全刷新、链接不改变的情况下于服务器交换数据并更新网页的一种方式）&lt;/p&gt;
&lt;p&gt;2、基本原理(具体详解请参考W3Cschool上面的内容)http://www.w3school.com.cn/ajax/index.asp（官网）&lt;/p&gt;
&lt;p&gt;工作流程：&lt;/p&gt;
&lt;p&gt;（1）、发送请求&lt;/p&gt;
&lt;p&gt;（2）、解析内容&lt;/p&gt;
&lt;p&gt;（3）、渲染网页得到结果&lt;/p&gt;
&lt;p&gt;下面我们来具体分析下整个过程：&lt;/p&gt;
&lt;p&gt;首先介绍下：XMLHttpRequest 对象&lt;/p&gt;
&lt;p&gt;所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。&lt;/p&gt;
&lt;p&gt;XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。&lt;/p&gt;
&lt;pre&gt;
var xmlhttp;
if (window.XMLHttpRequest)
  {// code for IE7+, Firefox, Chrome, Opera, Safari
  xmlhttp=new XMLHttpRequest();
  }
else
  {// code for IE6, IE5
  xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
  }
&lt;/pre&gt;
&lt;pre&gt;
xmlhttp.onreadystatechange=function()
  {
  if (xmlhttp.readyState==4 &amp;amp;&amp;amp; xmlhttp.status==200)
    {
    document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;
    }
  }
&lt;/pre&gt;
&lt;pre&gt;
xmlhttp.open(&quot;GET&quot;,&quot;demo_get.asp&quot;,true);
xmlhttp.send();
&lt;/pre&gt;
&lt;pre&gt;
&lt;br/&gt;在分析上述这段代码之前我们先了解下另两个概念：
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180509175901322-1643456511.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180509180037358-807968095.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
基于上述理论小伙伴们我们来分析下上述代码：&lt;br/&gt;1、首先我们定义了一个xmlhttp&lt;br/&gt;2、如果是IE7+, Firefox, Chrome, Opera, Safari浏览器，就将XMLHttpRequest赋给xmlhttp;如果是IE6, IE5浏览器就将ActiveXObject(&quot;Microsoft.XMLHTTP“）给&lt;br/&gt;xmlhttp&lt;br/&gt;3、当服务器返回响应时【(xmlhttp.readyState==4 &amp;amp;&amp;amp; xmlhttp.status==200)表示响应成功】，onreadystatechange属性被触发将id为myDiv中的内容改为服务器返回的内容&lt;br/&gt;xmlhttp.responseText&lt;br/&gt;4、这样整个htmL内容就被刷新了&lt;br/&gt;这就是整个Ajax请求、解析、渲染的过程
&lt;/pre&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;span&gt;下面小伙伴们咱们来爬取微博实战：&lt;br/&gt;首先随便选取一个微博账号：https://m.weibo.cn/u/3434671244（这里我随便选取了一个我的学生希望她不要介意）&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;本文小伙伴如有不了解请结合前面的requests库和urllib库详解&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; urllib.parse &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urlencode
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; requests.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ConnectionError
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; pymongo &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MongoClient
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; client =&lt;span&gt; MongoClient()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; db = client[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;weibo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; collection = db[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;weibo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; base_url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://m.weibo.cn/api/container/getIndex?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置请求头&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; headers =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Referer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ttps://m.weibo.cn/u/3434671244&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;m.weibo.cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;X-Requested-With&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;XMLHttpRequest&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_page(page):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     params=&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3434671244&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;containerid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1076033434671244&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:page,
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     url = base_url +&lt;span&gt; urlencode(params)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;异常捕获&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         response = requests.get(url,headers =&lt;span&gt; headers)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; response.status_code == 200&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; response.json()
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; ConnectionError as e:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;页面解析函数&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse_page(json):
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; json:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         items = json.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cards&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;下面这种写法小伙伴们学习了scrapy 框架就自然明白了,另外请大家学习pyquery的基本使用https://pythonhosted.org/pyquery/index.html#&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; items:
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             item = item.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mblog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             weibo =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             weibo[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = item.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             weibo[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = pq(item.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)).text().split()
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             weibo[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;attitudes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = item.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;attitudes_count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             weibo[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;comments&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = item.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;comments_count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             weibo[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;reposts&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = item.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;reposts_count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; weibo
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入mongodb数据库          &lt;/span&gt;
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; save_to_mongo(result):
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; collection.insert_one(result):
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;save successfully!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;主函数         &lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; page &lt;span&gt;in&lt;/span&gt; range(1,11&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         json =&lt;span&gt; get_page(page)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         results =&lt;span&gt; parse_page(json)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt;&lt;span&gt; results:
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            save_to_mongo(result)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;     main()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180509233718155-1897664124.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span/&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;/pre&gt;

</description>
<pubDate>Wed, 09 May 2018 15:38:00 +0000</pubDate>
<dc:creator>疾风_lu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/518894-lu/p/9016129.html</dc:identifier>
</item>
</channel>
</rss>