<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>java爬取博客园个人博客 - caryForJava</title>
<link>http://www.cnblogs.com/ccylovehs/p/9574084.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ccylovehs/p/9574084.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;近期本人在某云上购买了个人域名，本想着以后购买与服务器搭建自己的个人网站，由于需要筹备的太多，暂时先搁置了，想着先借用GitHub Pages搭建一个静态的站，搭建的过程其实也曲折，主要是域名地址配置把人搞废了，不过总的来说还算顺利，网站地址  https://chenchangyuan.cn（空博客，样式还挺漂亮的，后期会添砖加瓦）&lt;/p&gt;
&lt;p&gt;利用git+npm+hexo，再在github中进行相应配置，网上教程很多，如果有疑问欢迎评论告知。&lt;/p&gt;
&lt;p&gt;本人以前也是搞过几年java，由于公司的岗位职责，后面渐渐地被掰弯，现在主要是做前端开发。&lt;/p&gt;
&lt;p&gt;所以想利用java爬取文章，再将爬取的html转化成md（目前还未实现，欢迎各位同学指导）。&lt;/p&gt;
&lt;h2&gt;1.获取个人博客所有url&lt;/h2&gt;
&lt;p&gt;查看博客地址https://www.cnblogs.com/ccylovehs/default.html?page=1&lt;/p&gt;
&lt;p&gt;根据你自己写的博客数量进行遍历&lt;/p&gt;
&lt;p&gt;将博客的详情页地址存放在set集合中，详情页地址https://www.cnblogs.com/ccylovehs/p/9547690.html&lt;/p&gt;
&lt;h2&gt;2.详情页url生成html文件&lt;/h2&gt;
&lt;p&gt;遍历set集合，依次生成html文件&lt;/p&gt;
&lt;p&gt;文件存放在C://data//blog目录下，文件名由捕获组1生成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/996357/201809/996357-20180902154615043-905031145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.代码实现&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.blog.util;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStreamReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStreamWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.PrintStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.HttpURLConnection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URL;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.TreeSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.regex.Matcher;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.regex.Pattern;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Jack Chen
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BlogUtil {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * URL_PAGE：cnblogs url
     * URL_PAGE_DETAIL：详情页url
     * PAGE_COUNT：页数
     * urlLists：所有详情页url Set集合（防止重复）
     * p：匹配模式
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String URL_PAGE = &quot;https://www.cnblogs.com/ccylovehs/default.html?page=&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String URL_PAGE_DETAIL = &quot;https://www.cnblogs.com/ccylovehs/p/([0-9]+.html)&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PAGE_COUNT = 3&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Set&amp;lt;String&amp;gt; urlLists = &lt;span&gt;new&lt;/span&gt; TreeSet&amp;lt;String&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Pattern p =&lt;span&gt; Pattern.compile(URL_PAGE_DETAIL);
    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 1;i&amp;lt;=PAGE_COUNT;i++&lt;span&gt;) {
            getUrls(i);
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Iterator&amp;lt;String&amp;gt; i =&lt;span&gt; urlLists.iterator();i.hasNext();) {
            createFile(i.next());
        }
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; url
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; createFile(String url) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Matcher m &lt;/span&gt;=&lt;span&gt; p.matcher(url);
        m.find();
        String fileName &lt;/span&gt;= m.group(1&lt;span&gt;);
        String prefix &lt;/span&gt;= &quot;C://data//blog//&quot;&lt;span&gt;;
        File file &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(prefix +&lt;span&gt; fileName);
        PrintStream ps &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PrintStream(file);

        URL u &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; URL(url);
        HttpURLConnection conn &lt;/span&gt;=&lt;span&gt; (HttpURLConnection) u.openConnection();
        conn.connect();
        BufferedReader br &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(conn.getInputStream(), &quot;utf-8&quot;&lt;span&gt;));
        String str;
        
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((str = br.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            ps.println(str);
        }
        ps.close();
        br.close();
        conn.disconnect();
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; idx 
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; getUrls(&lt;span&gt;int&lt;/span&gt; idx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        URL u &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; URL(URL_PAGE+&quot;&quot;+&lt;span&gt;idx);
        HttpURLConnection conn &lt;/span&gt;=&lt;span&gt; (HttpURLConnection) u.openConnection();
        conn.connect();
        BufferedReader br &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(conn.getInputStream(), &quot;utf-8&quot;&lt;span&gt;));
        String str;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((str = br.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; != str &amp;amp;&amp;amp; str.contains(&quot;https://www.cnblogs.com/ccylovehs/p/&quot;&lt;span&gt;)) {
                Matcher m &lt;/span&gt;=&lt;span&gt; p.matcher(str);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(m.find()) {
                    System.out.println(m.group(&lt;/span&gt;1&lt;span&gt;));
                    urlLists.add(m.group());
                }
            }
        }
        br.close();
        conn.disconnect();
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.结语&lt;/h2&gt;
&lt;p&gt;如果觉得对您有用的话，麻烦动动鼠标给我一颗star，您的鼓励是我最大的动力&lt;/p&gt;
&lt;p&gt;https://github.com/chenchangyuan/getHtmlForJava&lt;/p&gt;
&lt;p&gt;由于不想一篇篇的手动生成md文件，下一步需要将html文件批量的转化成md文件，以便完善个人博客内容，未完待续~~~&lt;/p&gt;

</description>
<pubDate>Sun, 02 Sep 2018 07:54:00 +0000</pubDate>
<dc:creator>caryForJava</dc:creator>
<og:description>前言 近期本人在某云上购买了个人域名，本想着以后购买与服务器搭建自己的个人网站，由于需要筹备的太多，暂时先搁置了，想着先借用GitHub Pages搭建一个静态的站，搭建的过程其实也曲折，主要是域名地</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ccylovehs/p/9574084.html</dc:identifier>
</item>
<item>
<title>详解MariaDB数据库的索引 - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/9574013.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/9574013.html</guid>
<description>&lt;h2 id=&quot;什么是索引&quot;&gt;1.什么是索引&lt;/h2&gt;
&lt;p&gt;索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。&lt;/p&gt;
&lt;p&gt;更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。&lt;/p&gt;
&lt;h2 id=&quot;索引的类型&quot;&gt;2.索引的类型&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;1、普通索引
2、唯一性索引
3、主键索引（主索引）
4、复合索引&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;普通索引&quot;&gt;2.1. 普通索引&lt;/h3&gt;
&lt;p&gt;最基本的索引，不具备唯一性，就是加快查询速度&lt;/p&gt;
&lt;h4 id=&quot;创建普通索引&quot;&gt;2.1.1 创建普通索引&lt;/h4&gt;
&lt;p&gt;方法一：创建表时添加索引&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table 表名（
    列定义
    index 索引名称 （字段）
    index 索引名称 （字段）
）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：可以使用key关键字，也可以使用index关键字。索引名称，可以加也可以不加，不加使用字段名作为索引名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [book]&amp;gt; desc books;
+------------+------------------------------------------------+------+-----+---------+----------------+
| Field      | Type                                           | Null | Key | Default | Extra          |
+------------+------------------------------------------------+------+-----+---------+----------------+
| bId        | int(4)                                         | NO   | PRI | NULL    | auto_increment |
| bName      | varchar(255)                                   | YES  |     | NULL    |                |
| bTypeId    | enum('1','2','3','4','5','6','7','8','9','10') | YES  |     | NULL    |                |
| publishing | varchar(255)                                   | YES  |     | NULL    |                |
| price      | int(4)                                         | YES  |     | NULL    |                |
| pubDate    | date                                           | YES  |     | NULL    |                |
| author     | varchar(30)                                    | YES  |     | NULL    |                |
| ISBN       | varchar(255)                                   | YES  |     | NULL    |                |
+------------+------------------------------------------------+------+-----+---------+----------------+
8 rows in set (0.00 sec)

MariaDB [book]&amp;gt; create table demo(id int(4),name varchar(20),pwd varchar(20),index(pwd));
Query OK, 0 rows affected (0.08 sec)

MariaDB [book]&amp;gt; create table demo1(id int(4),name varchar(20),pwd varchar(20),key(pwd));
Query OK, 0 rows affected (0.01 sec)

MariaDB [book]&amp;gt; create table demo2(id int(4),name varchar(20),pwd varchar(20),key index_pwd(pwd));      # 为索引加上名称
Query OK, 0 rows affected (0.02 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;index和 key作用是相同的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;方法二：当表创建完成后，使用alter为表添加索引：&lt;br/&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter table 表名 add index 索引名称 （字段1，字段2.....）;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [book]&amp;gt; desc books;
+------------+------------------------------------------------+------+-----+---------+----------------+
| Field      | Type                                           | Null | Key | Default | Extra          |
+------------+------------------------------------------------+------+-----+---------+----------------+
| bId        | int(4)                                         | NO   | PRI | NULL    | auto_increment |
| bName      | varchar(255)                                   | YES  |     | NULL    |                |
| bTypeId    | enum('1','2','3','4','5','6','7','8','9','10') | YES  |     | NULL    |                |
| publishing | varchar(255)                                   | YES  |     | NULL    |                |
| price      | int(4)                                         | YES  |     | NULL    |                |
| pubDate    | date                                           | YES  |     | NULL    |                |
| author     | varchar(30)                                    | YES  |     | NULL    |                |
| ISBN       | varchar(255)                                   | YES  |     | NULL    |                |
+------------+------------------------------------------------+------+-----+---------+----------------+
8 rows in set (0.00 sec)

MariaDB [book]&amp;gt; alter table books add key (bName,bTypeId);
Query OK, 44 rows affected (0.01 sec)              
Records: 44  Duplicates: 0  Warnings: 0

MariaDB [book]&amp;gt; desc books;         # 可以看到在bName字段上添加的索引
+------------+------------------------------------------------+------+-----+---------+----------------+
| Field      | Type                                           | Null | Key | Default | Extra          |
+------------+------------------------------------------------+------+-----+---------+----------------+
| bId        | int(4)                                         | NO   | PRI | NULL    | auto_increment |
| bName      | varchar(255)                                   | YES  | MUL | NULL    |                |
| bTypeId    | enum('1','2','3','4','5','6','7','8','9','10') | YES  |     | NULL    |                |
| publishing | varchar(255)                                   | YES  |     | NULL    |                |
| price      | int(4)                                         | YES  |     | NULL    |                |
| pubDate    | date                                           | YES  |     | NULL    |                |
| author     | varchar(30)                                    | YES  |     | NULL    |                |
| ISBN       | varchar(255)                                   | YES  |     | NULL    |                |
+------------+------------------------------------------------+------+-----+---------+----------------+
8 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;查看索引&quot;&gt;2.1.2 查看索引&lt;/h4&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;desc 索引名(或索引字段)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [book]&amp;gt; desc demo;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int(4)      | YES  |     | NULL    |       |
| name  | varchar(20) | YES  |     | NULL    |       |
| pwd   | varchar(20) | YES  | MUL | NULL    |       |
+-------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

MariaDB [book]&amp;gt; desc demo1;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int(4)      | YES  |     | NULL    |       |
| name  | varchar(20) | YES  |     | NULL    |       |
| pwd   | varchar(20) | YES  | MUL | NULL    |       |
+-------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

MariaDB [book]&amp;gt; desc demo2;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int(4)      | YES  |     | NULL    |       |
| name  | varchar(20) | YES  |     | NULL    |       |
| pwd   | varchar(20) | YES  | MUL | NULL    |       |
+-------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

MariaDB [book]&amp;gt; desc books;
+------------+------------------------------------------------+------+-----+---------+----------------+
| Field      | Type                                           | Null | Key | Default | Extra          |
+------------+------------------------------------------------+------+-----+---------+----------------+
| bId        | int(4)                                         | NO   | PRI | NULL    | auto_increment |
| bName      | varchar(255)                                   | YES  | MUL | NULL    |                |
| bTypeId    | enum('1','2','3','4','5','6','7','8','9','10') | YES  |     | NULL    |                |
| publishing | varchar(255)                                   | YES  |     | NULL    |                |
| price      | int(4)                                         | YES  |     | NULL    |                |
| pubDate    | date                                           | YES  |     | NULL    |                |
| author     | varchar(30)                                    | YES  |     | NULL    |                |
| ISBN       | varchar(255)                                   | YES  |     | NULL    |                |
+------------+------------------------------------------------+------+-----+---------+----------------+
8 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：如果Key是MUL, 那么该列的值可以重复。该列是一个非唯一索引的前导列(第一列)或者是一个唯一性索引的组成部分但是可以含有空值NULL。&lt;/p&gt;
&lt;h4 id=&quot;删除索引&quot;&gt;2.1.3 删除索引&lt;/h4&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter table 表名 drop key 索引名(或字段名);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [book]&amp;gt; alter table demo drop key pwd;
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

MariaDB [book]&amp;gt; alter table demo1 drop key pwd;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

MariaDB [book]&amp;gt; alter table demo2 drop key index_pwd;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

MariaDB [book]&amp;gt; alter table books add key (bName,bTypeId);
Query OK, 44 rows affected (0.01 sec)              
Records: 44  Duplicates: 0  Warnings: 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;唯一索引&quot;&gt;2.2 唯一索引&lt;/h3&gt;
&lt;p&gt;与普通索引基本相同，但有一个区别：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;索引列的所有值都只能出现一次，即必须唯一，用来约束内容。
字段值只能出现一次时，应该加唯一索引。
唯一性允许有NULL值&amp;lt;允许为空&amp;gt;。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建唯一索引&quot;&gt;2.2.1 创建唯一索引&lt;/h4&gt;
&lt;p&gt;方法一：创建表时加唯一索引&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table 表名(
    列定义：
    unique key 索引名 （字段）;
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：常用在值不能重复的字段上，比如说用户名，电话号码，身份证号。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [book]&amp;gt; create table demo3(id int(4) auto_increment primary key,uName varchar(20),uPwd varchar(20),unique index(uName));
Query OK, 0 rows affected (0.07 sec)

MariaDB [book]&amp;gt; desc demo3;
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| id    | int(4)      | NO   | PRI | NULL    | auto_increment |
| uName | varchar(20) | YES  | UNI | NULL    |                |
| uPwd  | varchar(20) | YES  |     | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法二：修改表时加唯一索引&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter table 表名 add unique 索引名 (字段);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [book]&amp;gt; desc books;
+------------+------------------------------------------------+------+-----+---------+----------------+
| Field      | Type                                           | Null | Key | Default | Extra          |
+------------+------------------------------------------------+------+-----+---------+----------------+
| bId        | int(4)                                         | NO   | PRI | NULL    | auto_increment |
| bName      | varchar(255)                                   | YES  |     | NULL    |                |
| bTypeId    | enum('1','2','3','4','5','6','7','8','9','10') | YES  |     | NULL    |                |
| publishing | varchar(255)                                   | YES  |     | NULL    |                |
| price      | int(4)                                         | YES  |     | NULL    |                |
| pubDate    | date                                           | YES  |     | NULL    |                |
| author     | varchar(30)                                    | YES  |     | NULL    |                |
| ISBN       | varchar(255)                                   | YES  |     | NULL    |                |
+------------+------------------------------------------------+------+-----+---------+----------------+
8 rows in set (0.01 sec)

MariaDB [book]&amp;gt; alter table books add unique index_bName (bName);
Query OK, 43 rows affected (0.01 sec)              
Records: 43  Duplicates: 0  Warnings: 0

MariaDB [book]&amp;gt; desc books;
+------------+------------------------------------------------+------+-----+---------+----------------+
| Field      | Type                                           | Null | Key | Default | Extra          |
+------------+------------------------------------------------+------+-----+---------+----------------+
| bId        | int(4)                                         | NO   | PRI | NULL    | auto_increment |
| bName      | varchar(255)                                   | YES  | UNI | NULL    |                |
| bTypeId    | enum('1','2','3','4','5','6','7','8','9','10') | YES  |     | NULL    |                |
| publishing | varchar(255)                                   | YES  |     | NULL    |                |
| price      | int(4)                                         | YES  |     | NULL    |                |
| pubDate    | date                                           | YES  |     | NULL    |                |
| author     | varchar(30)                                    | YES  |     | NULL    |                |
| ISBN       | varchar(255)                                   | YES  |     | NULL    |                |
+------------+------------------------------------------------+------+-----+---------+----------------+
8 rows in set (0.02 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删除唯一索引&quot;&gt;2.2.2 删除唯一索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;alter table 表名 drop key 索引名(或字段名);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [book]&amp;gt; alter table books drop key index_bName;
Query OK, 43 rows affected (0.01 sec)              
Records: 43  Duplicates: 0  Warnings: 0

MariaDB [book]&amp;gt; desc books;
+------------+------------------------------------------------+------+-----+---------+----------------+
| Field      | Type                                           | Null | Key | Default | Extra          |
+------------+------------------------------------------------+------+-----+---------+----------------+
| bId        | int(4)                                         | NO   | PRI | NULL    | auto_increment |
| bName      | varchar(255)                                   | YES  |     | NULL    |                |
| bTypeId    | enum('1','2','3','4','5','6','7','8','9','10') | YES  |     | NULL    |                |
| publishing | varchar(255)                                   | YES  |     | NULL    |                |
| price      | int(4)                                         | YES  |     | NULL    |                |
| pubDate    | date                                           | YES  |     | NULL    |                |
| author     | varchar(30)                                    | YES  |     | NULL    |                |
| ISBN       | varchar(255)                                   | YES  |     | NULL    |                |
+------------+------------------------------------------------+------+-----+---------+----------------+
8 rows in set (0.01 sec)

MariaDB [book]&amp;gt; desc demo3;
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| id    | int(4)      | NO   | PRI | NULL    | auto_increment |
| uName | varchar(20) | YES  | UNI | NULL    |                |
| uPwd  | varchar(20) | YES  |     | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
3 rows in set (0.01 sec)

MariaDB [book]&amp;gt; alter table demo3 drop key uName;
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

MariaDB [book]&amp;gt; desc demo3;
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| id    | int(4)      | NO   | PRI | NULL    | auto_increment |
| uName | varchar(20) | YES  |     | NULL    |                |
| uPwd  | varchar(20) | YES  |     | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;主键索引&quot;&gt;2.3 主键索引&lt;/h3&gt;
&lt;p&gt;查询数据库，按主键查询是最快的，每个表只能有一个主键列，可以有多个普通索引列。&lt;/p&gt;
&lt;p&gt;主键列要求列的所有内容必须唯一，而索引列不要求内容必须唯一，但不允许为空&lt;/p&gt;
&lt;h4 id=&quot;创建主键索引&quot;&gt;2.3.1 创建主键索引&lt;/h4&gt;
&lt;p&gt;方法一：创建表创建主键索引&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [book]&amp;gt; create table demo4 (id int(4) not null auto_increment,name varchar(4) default null,primary key(id));
Query OK, 0 rows affected (0.02 sec)

MariaDB [book]&amp;gt; desc demo4;
+-------+------------+------+-----+---------+----------------+
| Field | Type       | Null | Key | Default | Extra          |
+-------+------------+------+-----+---------+----------------+
| id    | int(4)     | NO   | PRI | NULL    | auto_increment |
| name  | varchar(4) | YES  |     | NULL    |                |
+-------+------------+------+-----+---------+----------------+
2 rows in set (0.01 sec)

MariaDB [book]&amp;gt; show index from demo4;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| demo4 |          0 | PRIMARY  |            1 | id          | A         |           0 |     NULL | NULL   |      | BTREE      |         |               |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
1 row in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法二：创建表后添加&amp;lt;不推荐&amp;gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [book]&amp;gt; drop table demo4;
Query OK, 0 rows affected (0.01 sec)

MariaDB [book]&amp;gt; create table demo4 (id int(4) not null auto_increment primary key,name varchar(4) not null);
Query OK, 0 rows affected (0.02 sec)

MariaDB [book]&amp;gt; alter table demo4 change id id int(4) not null;
Query OK, 0 rows affected (0.03 sec)               
Records: 0  Duplicates: 0  Warnings: 0

MariaDB [book]&amp;gt; desc demo4;
+-------+------------+------+-----+---------+-------+
| Field | Type       | Null | Key | Default | Extra |
+-------+------------+------+-----+---------+-------+
| id    | int(4)     | NO   | PRI | NULL    |       |
| name  | varchar(4) | NO   |     | NULL    |       |
+-------+------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

MariaDB [book]&amp;gt; show index from demo4;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| demo4 |          0 | PRIMARY  |            1 | id          | A         |           0 |     NULL | NULL   |      | BTREE      |         |               |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
1 row in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删除主键索引&quot;&gt;2.3.2 删除主键索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [book]&amp;gt; alter table demo4 drop primary key;
Query OK, 0 rows affected (0.03 sec)               
Records: 0  Duplicates: 0  Warnings: 0

MariaDB [book]&amp;gt; desc demo4;
+-------+------------+------+-----+---------+-------+
| Field | Type       | Null | Key | Default | Extra |
+-------+------------+------+-----+---------+-------+
| id    | int(4)     | NO   |     | NULL    |       |
| name  | varchar(4) | NO   |     | NULL    |       |
+-------+------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

MariaDB [book]&amp;gt; show index from demo4;
Empty set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;主键索引，唯一性索引区别：主键索引不能有NULL，唯一性索引可以有空值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;复合索引&quot;&gt;2.4 复合索引&lt;/h3&gt;
&lt;p&gt;索引可以包含一个、两个或更多个列。两个或更多个列上的索引被称作复合索引&lt;/p&gt;
&lt;p&gt;例： 创建一个表存放服务器允许或拒绝的IP和port，但记录中IP和port要唯一。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [book]&amp;gt; create table firewall(host varchar(15) not null,port smallint(4) not null,access enum(&quot;deny&quot;,&quot;allow&quot;) not null,primary key(host,port)); # 用host和port列作复合索引
Query OK, 0 rows affected (0.11 sec)

MariaDB [book]&amp;gt; insert into firewall values(&quot;192.168.81.100&quot;,22,&quot;deny&quot;);
Query OK, 1 row affected (0.02 sec)

MariaDB [book]&amp;gt; select * from firewall;
+---------------+------+--------+
| host          | port | access |
+---------------+------+--------+
| 192.168.81.100 |   22 | deny   |
+---------------+------+--------+
1 row in set (0.00 sec)

MariaDB [book]&amp;gt; insert into firewall values(&quot;192.168.81.101&quot;,22,&quot;allow&quot;);
Query OK, 1 row affected (0.04 sec)

MariaDB [book]&amp;gt; insert into firewall values(&quot;192.168.81.100&quot;,22,&quot;deny&quot;);    # 插入数据时，IP和port要唯一，否则会报错
ERROR 1062 (23000): Duplicate entry '192.168.81.100-22' for key 'PRIMARY'
MariaDB [book]&amp;gt; select * from firewall;
+----------------+------+--------+
| host           | port | access |
+----------------+------+--------+
| 192.168.81.100  |   22 | deny   |
| 192.168.81.101 |   22 | allow  |
+----------------+------+--------+
2 rows in set (0.01 sec)

MariaDB [book]&amp;gt; desc firewall;              # 查看索引
+--------+----------------------+------+-----+---------+-------+
| Field  | Type                 | Null | Key | Default | Extra |
+--------+----------------------+------+-----+---------+-------+
| host   | varchar(15)          | NO   | PRI | NULL    |       |
| port   | smallint(4)          | NO   | PRI | NULL    |       |
| access | enum('deny','allow') | NO   |     | NULL    |       |
+--------+----------------------+------+-----+---------+-------+
3 rows in set (0.01 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;建表的时候如果加各种索引，顺序如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;create table 表名（字段定义，PRIMARYKEY  (`bId`),UNIQUE KEY `bi` (`bImg`),KEY `bn` (`bName`),KEY `ba` (`author`)）&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;全文索引-fulltext-index&quot;&gt;2.5 全文索引 (FULLTEXT INDEX)&lt;/h3&gt;
&lt;p&gt;全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术。&lt;/p&gt;
&lt;p&gt;它能够利用&quot;分词技术&quot;等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果&lt;/p&gt;
&lt;p&gt;mysql 在数据量较大的情况下，高并发连接的情况下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select 语句  where bName like '%网%'
使用% 和　_ 通配符进行查找，因为索引里面保存的是一堆指针，不会保存具体内容，只能进行全表扫描，造成数据库压力大&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全文索引只能用在varchar和text字段中&lt;/p&gt;
&lt;h4 id=&quot;创建全文索引&quot;&gt;2.5.1 创建全文索引&lt;/h4&gt;
&lt;p&gt;方法一：创建表时创建&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table 表名（
    列定义，
    fulltext key 索引名 （字段）;
）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法二：修改表时添加&lt;br/&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter table 表名 add fulltext 索引名 （字段）;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [book]&amp;gt; show create table books;
+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                                                                                                                                                                                                                                                                                                                                               |
+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| books | CREATE TABLE `books` (
  `bId` int(4) NOT NULL AUTO_INCREMENT,
  `bName` varchar(255) DEFAULT NULL,
  `bTypeId` enum('1','2','3','4','5','6','7','8','9','10') DEFAULT NULL,
  `publishing` varchar(255) DEFAULT NULL,
  `price` int(4) DEFAULT NULL,
  `pubDate` date DEFAULT NULL,
  `author` varchar(30) DEFAULT NULL,
  `ISBN` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`bId`)
) ENGINE=MyISAM AUTO_INCREMENT=45 DEFAULT CHARSET=utf8 |
+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)

MariaDB [book]&amp;gt; alter table books add fulltext index_bName (`bName`);
Query OK, 43 rows affected (0.04 sec)              
Records: 43  Duplicates: 0  Warnings: 0

MariaDB [book]&amp;gt; desc books;
+------------+------------------------------------------------+------+-----+---------+----------------+
| Field      | Type                                           | Null | Key | Default | Extra          |
+------------+------------------------------------------------+------+-----+---------+----------------+
| bId        | int(4)                                         | NO   | PRI | NULL    | auto_increment |
| bName      | varchar(255)                                   | YES  | MUL | NULL    |                |
| bTypeId    | enum('1','2','3','4','5','6','7','8','9','10') | YES  |     | NULL    |                |
| publishing | varchar(255)                                   | YES  |     | NULL    |                |
| price      | int(4)                                         | YES  |     | NULL    |                |
| pubDate    | date                                           | YES  |     | NULL    |                |
| author     | varchar(30)                                    | YES  |     | NULL    |                |
| ISBN       | varchar(255)                                   | YES  |     | NULL    |                |
+------------+------------------------------------------------+------+-----+---------+----------------+
8 rows in set (0.00 sec)

MariaDB [book]&amp;gt; alter table books drop key index_bName;
Query OK, 43 rows affected (0.03 sec)              
Records: 43  Duplicates: 0  Warnings: 0

MariaDB [book]&amp;gt; desc books;
+------------+------------------------------------------------+------+-----+---------+----------------+
| Field      | Type                                           | Null | Key | Default | Extra          |
+------------+------------------------------------------------+------+-----+---------+----------------+
| bId        | int(4)                                         | NO   | PRI | NULL    | auto_increment |
| bName      | varchar(255)                                   | YES  |     | NULL    |                |
| bTypeId    | enum('1','2','3','4','5','6','7','8','9','10') | YES  |     | NULL    |                |
| publishing | varchar(255)                                   | YES  |     | NULL    |                |
| price      | int(4)                                         | YES  |     | NULL    |                |
| pubDate    | date                                           | YES  |     | NULL    |                |
| author     | varchar(30)                                    | YES  |     | NULL    |                |
| ISBN       | varchar(255)                                   | YES  |     | NULL    |                |
+------------+------------------------------------------------+------+-----+---------+----------------+
8 rows in set (0.00 sec)

MariaDB [book]&amp;gt; alter table books add fulltext index_bName (`bName`,`publishing`);
Query OK, 43 rows affected (0.02 sec)              
Records: 43  Duplicates: 0  Warnings: 0

MariaDB [book]&amp;gt; desc books;
+------------+------------------------------------------------+------+-----+---------+----------------+
| Field      | Type                                           | Null | Key | Default | Extra          |
+------------+------------------------------------------------+------+-----+---------+----------------+
| bId        | int(4)                                         | NO   | PRI | NULL    | auto_increment |
| bName      | varchar(255)                                   | YES  | MUL | NULL    |                |
| bTypeId    | enum('1','2','3','4','5','6','7','8','9','10') | YES  |     | NULL    |                |
| publishing | varchar(255)                                   | YES  |     | NULL    |                |
| price      | int(4)                                         | YES  |     | NULL    |                |
| pubDate    | date                                           | YES  |     | NULL    |                |
| author     | varchar(30)                                    | YES  |     | NULL    |                |
| ISBN       | varchar(255)                                   | YES  |     | NULL    |                |
+------------+------------------------------------------------+------+-----+---------+----------------+
8 rows in set (0.01 sec)

MariaDB [book]&amp;gt; alter table books drop key index_bName;
Query OK, 43 rows affected (0.02 sec)              
Records: 43  Duplicates: 0  Warnings: 0

MariaDB [book]&amp;gt; desc books;
+------------+------------------------------------------------+------+-----+---------+----------------+
| Field      | Type                                           | Null | Key | Default | Extra          |
+------------+------------------------------------------------+------+-----+---------+----------------+
| bId        | int(4)                                         | NO   | PRI | NULL    | auto_increment |
| bName      | varchar(255)                                   | YES  |     | NULL    |                |
| bTypeId    | enum('1','2','3','4','5','6','7','8','9','10') | YES  |     | NULL    |                |
| publishing | varchar(255)                                   | YES  |     | NULL    |                |
| price      | int(4)                                         | YES  |     | NULL    |                |
| pubDate    | date                                           | YES  |     | NULL    |                |
| author     | varchar(30)                                    | YES  |     | NULL    |                |
| ISBN       | varchar(255)                                   | YES  |     | NULL    |                |
+------------+------------------------------------------------+------+-----+---------+----------------+
8 rows in set (0.00 sec)

MariaDB [book]&amp;gt; alter table books add fulltext index_bName (`publishing`);
Query OK, 43 rows affected (0.02 sec)              
Records: 43  Duplicates: 0  Warnings: 0

MariaDB [book]&amp;gt; desc books;
+------------+------------------------------------------------+------+-----+---------+----------------+
| Field      | Type                                           | Null | Key | Default | Extra          |
+------------+------------------------------------------------+------+-----+---------+----------------+
| bId        | int(4)                                         | NO   | PRI | NULL    | auto_increment |
| bName      | varchar(255)                                   | YES  |     | NULL    |                |
| bTypeId    | enum('1','2','3','4','5','6','7','8','9','10') | YES  |     | NULL    |                |
| publishing | varchar(255)                                   | YES  | MUL | NULL    |                |
| price      | int(4)                                         | YES  |     | NULL    |                |
| pubDate    | date                                           | YES  |     | NULL    |                |
| author     | varchar(30)                                    | YES  |     | NULL    |                |
| ISBN       | varchar(255)                                   | YES  |     | NULL    |                |
+------------+------------------------------------------------+------+-----+---------+----------------+
8 rows in set (0.01 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删除全文索引&quot;&gt;2.5.2 删除全文索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [book]&amp;gt; alter table books drop key index_bName;
Query OK, 39 rows affected (0.02 sec)              
Records: 39  Duplicates: 0  Warnings: 0&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;MySQL自带的全文索引只能用于数据库引擎为MyISAM的数据表，如果是其他数据引擎，则全文索引不会生效&lt;br/&gt;MySQL自带的全文索引只能对英文进行全文检索，目前无法对中文进行全文检索。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;索引设计原则&quot;&gt;3.索引设计原则&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;1、索引并非越多越好
2、数据量不大不需要建立索引
3、列中的值变化不多不需要建立索引 row id
4、经常排序（order by）和分组（group by）的列需要建立索引
5、唯一性约束对应使用唯一性索引&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;索引的优点&quot;&gt;4.索引的优点：&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;为了加快搜索速度，减少查询时间 。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;索引的缺点&quot;&gt;5.索引的缺点&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;1 索引是以文件存储的。如果索引过多，占磁盘空间较大。而且他影响： insert ,update ,delete 执行时间。
2索引中数据必须与数据表数据同步：如果索引过多，当表中数据更新的时候后，索引也要同步更新，这就降低了效率。&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 02 Sep 2018 07:36:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<og:description>1.什么是索引 索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。 更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/9574013.html</dc:identifier>
</item>
<item>
<title>React组件导入的两种方式(动态导入组件的实现) - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9573897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9573897.html</guid>
<description>&lt;h4 id=&quot;一-react组件两种导入方式&quot;&gt;一、 react组件两种导入方式&lt;/h4&gt;
&lt;p&gt;React组件可以通过两种方式导入另一个组件&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;import(常用)&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;import component from './component'&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;require&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;const component = require('./component')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;两种方式有什么区别?&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import component from './component'
// =&amp;gt; 
const component = require('./component')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;推荐统一规范一种导入方式,防止混乱&lt;br/&gt;当然,不同情况使用的方式也是不一样的.&lt;br/&gt;下面详细介绍两种导入方式对应的情况(注意这里不介绍按需加载,可看&lt;a href=&quot;https://www.cnblogs.com/soyxiaobi/p/9535292.html&quot; target=&quot;_blank&quot;&gt;《前端性能优化之按需加载》&lt;/a&gt;)&lt;/p&gt;
&lt;h4 id=&quot;二两种方式对应的-情况&quot;&gt;二、两种方式对应的 情况&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;import xxx from 'xxx'&lt;br/&gt;一般来说使用import就够了.但是要注意import需要放在定义组件的外部。这就导致&lt;span&gt;一个问题:&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果我需要通过动态路径动态加载组件(这里并非指按需加载),在class里面(ES6)语法使用import会报下面错误:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Module build failed: SyntaxError: 'import' and 'export' may only appear at the top level&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这时候使用require方法能很好解决&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;var xxx = require('xxx')&lt;br/&gt;这里需要注意的是:&lt;br/&gt;用&lt;code&gt;import&lt;/code&gt;引入的组件只需要&lt;strong&gt;export default&lt;/strong&gt;即可&lt;br/&gt;而通过&lt;code&gt;require&lt;/code&gt;引入的组件需要底部生命&lt;strong&gt;module.exports = component&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;用例子解释一下:&lt;br/&gt;需求场景: 现在有大量的子组件存放在对应文件夹(如下)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;firstComponent
    /index
secordComponent
    /index
thirdComponent
    /index
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是我在父组件每次只需加载其中一个即可,我不想一次性导入大量的子组件,然后加判断筛选出对应组件。这样代码可能会非常多、杂(比如我有20个子组件,那么我要写20个import);&lt;br/&gt;于是我通过require动态载入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//父组件
renderDetail(mode,pageType){
    let dynamicDetail = require(`../components/content/${pageType}/index`)
    return dynamicDetail
}

render(){
    //const { pageType } = this.props; 这里的pageType是判断加载哪个子组件的条件
    
    //我们先假设一个
    pageType = firstComponent;  //存在firstComponent这么一个文件夹里面有一个index.js组件
    
    let DynamicDetail = this.renderDetail(pageType);    //动态拿到这个组件
    
    return(
        &amp;lt;div className=&quot;detailWried&quot;&amp;gt;
            &amp;lt;DynamicDetail /&amp;gt;
        &amp;lt;/div&amp;gt;
    )
}

//子组件
import React from 'react'

export default class firstComponent extends React.Component{
    render(){
        return(
            &amp;lt;div&amp;gt;
                NavMenu
            &amp;lt;/div&amp;gt;
        )
    }
}

module.exports = firstComponent;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我就可以实现动态加载组件的功能了.把pageType替换成动态的即可,pageType的值则按照用户操作动态改变即可。例如用户选择第二个组件的时候:&lt;code&gt;pageTpey = secordComponent&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意这里可能会遇到一个问题:&lt;br/&gt;把require里面的路径替换成变量的话,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let path = `../../../../components/content/${mode}/children/${pageType}/index`
let dynamicDetail = require(path)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会报以下错&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//终端
Critical dependency: the request of a dependency is an expression

//浏览器
can't  require module'.'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在require使用字符串变量即可(字符串变量可真的是一个好方便东西)&lt;/p&gt;
&lt;p&gt;至此！两个导入组件的方式介绍完毕！&lt;br/&gt;扩展一下:&lt;/p&gt;
</description>
<pubDate>Sun, 02 Sep 2018 07:05:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>一、 react组件两种导入方式 React组件可以通过两种方式导入另一个组件 1. import(常用) 2. require 两种方式有什么区别? 提出的规范不同 import是ES6语法,reu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9573897.html</dc:identifier>
</item>
<item>
<title>跟厂长学PHP7内核（五）：深入分析生命周期的模块初始化阶段 - 了不起的厂长</title>
<link>http://www.cnblogs.com/enochzzg/p/9573674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enochzzg/p/9573674.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;上篇我们讲到了模块初始化阶段，并得知它是由&lt;code&gt;php_module_startup&lt;/code&gt;函数来实现的。该阶段的主要作用是初始化变量、常量；注册各种函数，比如工具、词法、语法函数等；解析配置文件；加载扩展；当然最重要的是计算出PHP二进制程序的路径，现在让我们来研究一下该函数都做了哪些工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;sapi_initialize_request_empty函数&quot;&gt;1、sapi_initialize_request_empty函数&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// main/SAPI.c
SAPI_API void sapi_initialize_empty_request(void)
{
    SG(server_context) = NULL;
    SG(request_info).request_method = NULL;
    SG(request_info).auth_digest = SG(request_info).auth_user = SG(request_info).auth_password = NULL;
    SG(request_info).content_type_dup = NULL;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个函数主要为前面定义的SG宏中的成员变量进行初始化。&lt;/p&gt;
&lt;h3 id=&quot;sapi_activate函数&quot;&gt;2、sapi_activate函数&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// main/SAPI.c
SAPI_API void sapi_activate(void)
{
    zend_llist_init(&amp;amp;SG(sapi_headers).headers, sizeof(sapi_header_struct), (void (*)(void *)) sapi_free_header, 0);
    SG(sapi_headers).send_default_content_type = 1;

    /*
    SG(sapi_headers).http_response_code = 200;
    */
    SG(sapi_headers).http_status_line = NULL;
    SG(sapi_headers).mimetype = NULL;
    SG(headers_sent) = 0;
    ZVAL_UNDEF(&amp;amp;SG(callback_func));
    SG(read_post_bytes) = 0;
    SG(request_info).request_body = NULL;
    SG(request_info).current_user = NULL;
    SG(request_info).current_user_length = 0;
    SG(request_info).no_headers = 0;
    SG(request_info).post_entry = NULL;
    SG(request_info).proto_num = 1000; /* Default to HTTP 1.0 */
    SG(global_request_time) = 0;
    SG(post_read) = 0;
    /* It's possible to override this general case in the activate() callback, if necessary. */
    if (SG(request_info).request_method &amp;amp;&amp;amp; !strcmp(SG(request_info).request_method, &quot;HEAD&quot;)) {
        SG(request_info).headers_only = 1;
    } else {
        SG(request_info).headers_only = 0;
    }
    SG(rfc1867_uploaded_files) = NULL;

    /* Handle request method */
    if (SG(server_context)) {
        if (PG(enable_post_data_reading)
        &amp;amp;&amp;amp;  SG(request_info).content_type
        &amp;amp;&amp;amp;  SG(request_info).request_method
        &amp;amp;&amp;amp; !strcmp(SG(request_info).request_method, &quot;POST&quot;)) {
            /* HTTP POST may contain form data to be processed into variables
             * depending on given content type */
            sapi_read_post_data();
        } else {
            SG(request_info).content_type_dup = NULL;
        }

        /* Cookies */
        SG(request_info).cookie_data = sapi_module.read_cookies();

        if (sapi_module.activate) {
            sapi_module.activate();
        }
    }
    if (sapi_module.input_filter_init) {
        sapi_module.input_filter_init();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数的前半部分主要还是对SG宏的成员变量进行初始化。后半部分先是调用了&lt;code&gt;sapi_module_struct&lt;/code&gt;内部实现的&lt;code&gt;activate&lt;/code&gt;函数，又调用了&lt;code&gt;input_filter_init&lt;/code&gt;函数，但是在CLI模式并没有实现这两个函数，只是返回了NULL。代码如下：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;NULL,                           /* activate */&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;php_output_startup函数&quot;&gt;3、php_output_startup函数&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//main/output.c
PHPAPI void php_output_startup(void)
{
    ZEND_INIT_MODULE_GLOBALS(output, php_output_init_globals, NULL);
    zend_hash_init(&amp;amp;php_output_handler_aliases, 8, NULL, NULL, 1);
    zend_hash_init(&amp;amp;php_output_handler_conflicts, 8, NULL, NULL, 1);
    zend_hash_init(&amp;amp;php_output_handler_reverse_conflicts, 8, NULL, reverse_conflict_dtor, 1);
    php_output_direct = php_output_stdout;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先来看&lt;code&gt;ZEND_INIT_MODULE_GLOBALS&lt;/code&gt;宏做了什么事情：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#define ZEND_INIT_MODULE_GLOBALS(module_name, globals_ctor, globals_dtor)   \
    globals_ctor(&amp;amp;module_name##_globals);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由代码得知，该宏只是做了一层替换，替换后的内容为：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;php_output_init_globals(&amp;amp;output_globals);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那&lt;code&gt;php_output_init_globals&lt;/code&gt;函数又做了什么呢？&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//main/output.c
static inline void php_output_init_globals(zend_output_globals *G)
{
    ZEND_TSRMLS_CACHE_UPDATE();
    memset(G, 0, sizeof(*G));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该函数通过&lt;code&gt;memset&lt;/code&gt;函数对&lt;code&gt;output_globals&lt;/code&gt;进行了内存相关的初始化，我们可以在&lt;code&gt;main/php_output.h&lt;/code&gt;中的155行找到它的宏定义OG。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//main/php_output.h
# define OG(v) (output_globals.v)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OG对应的结构体是&lt;code&gt;php_output_init_globals&lt;/code&gt;的入参&lt;code&gt;zend_output_globals&lt;/code&gt;，在这里花了些时间，因为没找到定义在哪里，最后发现它也是通过宏定义替换得来的，代码如下：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//main/php_output.h
ZEND_BEGIN_MODULE_GLOBALS(output)
    zend_stack handlers;
    php_output_handler *active;
    php_output_handler *running;
    const char *output_start_filename;
    int output_start_lineno;
    int flags;
ZEND_END_MODULE_GLOBALS(output)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看似是定义了一个结构体，但是代码中又出现了两个宏，我们再来瞅瞅这两个宏是干嘛的：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//Zend/zend_API.h
#define ZEND_BEGIN_MODULE_GLOBALS(module_name)      \
    typedef struct _zend_##module_name##_globals {
#define ZEND_END_MODULE_GLOBALS(module_name)        \
    } zend_##module_name##_globals;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来只是做了个替换而已，替换后的代码如下：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//这个是意淫出来的代码
typedef struct _zend_output_globals {
    zend_stack handlers;
    php_output_handler *active;
    php_output_handler *running;
    const char *output_start_filename;
    int output_start_lineno;
    int flags;
} zend_output_globals&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这才是&lt;code&gt;zend_output_globals&lt;/code&gt;最纯粹的定义，写的很是骚气，差点看断片。这样看来我们的OG宏对应的就是这个结构体了，姑且认为它是PHP输出相关的结构体。我们继续往下看：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;zend_hash_init(&amp;amp;php_output_handler_aliases, 8, NULL, NULL, 1);
zend_hash_init(&amp;amp;php_output_handler_conflicts, 8, NULL, NULL, 1);
zend_hash_init(&amp;amp;php_output_handler_reverse_conflicts, 8, NULL, reverse_conflict_dtor, 1);
php_output_direct = php_output_stdout;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来又对三个HashTable进行了初始化，初始化完成后，将&lt;code&gt;php_output_direct&lt;/code&gt;指针指向了&lt;code&gt;php_output_stdout&lt;/code&gt;函数。&lt;code&gt;php_output_stdout&lt;/code&gt;函数的作用是调用fwrite函数，输出字符串到stdout中。代码如下：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//main/output.c
static size_t php_output_stdout(const char *str, size_t str_len)
{
    fwrite(str, 1, str_len, stdout);
    return str_len;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;php_startup_ticks函数&quot;&gt;4、php_startup_ticks函数&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int php_startup_ticks(void)
{
    zend_llist_init(&amp;amp;PG(tick_functions), sizeof(struct st_tick_function), NULL, 1);
    return SUCCESS;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里又出现了一个PG宏，来看下它的定义&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;# define PG(v) (core_globals.v)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PG对应的结构体是&lt;code&gt;core_globals&lt;/code&gt;，&lt;code&gt;core_globals&lt;/code&gt;又对应&lt;code&gt;_php_core_globals&lt;/code&gt;，代码如下&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;extern ZEND_API struct _php_core_globals core_globals;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;php_core_globals顾名思义，就是php核心的全局变量，定义很多PHP相关的参数，比如内存上限、是否显示错误信息、上传文件大小限制、输入输出编码、禁用的函数等等，这里不再赘述，感兴趣的同学可以去看一下源码。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//main/php_globals.h
struct _php_core_globals {
    zend_bool implicit_flush;

    zend_long output_buffering;

    zend_bool sql_safe_mode;
    zend_bool enable_dl;

    char *output_handler;

    char *unserialize_callback_func;
    zend_long serialize_precision;

    zend_long memory_limit;
    zend_long max_input_time;

    zend_bool track_errors;
    zend_bool display_errors;
    zend_bool display_startup_errors;
    zend_bool log_errors;
    zend_long      log_errors_max_len;
    zend_bool ignore_repeated_errors;
    zend_bool ignore_repeated_source;
    zend_bool report_memleaks;
    char *error_log;

    char *doc_root;
    char *user_dir;
    char *include_path;
    char *open_basedir;
    char *extension_dir;
    char *php_binary;
    char *sys_temp_dir;

    char *upload_tmp_dir;
    zend_long upload_max_filesize;

    char *error_append_string;
    char *error_prepend_string;

    char *auto_prepend_file;
    char *auto_append_file;

    char *input_encoding;
    char *internal_encoding;
    char *output_encoding;

    arg_separators arg_separator;

    char *variables_order;

    HashTable rfc1867_protected_variables;

    short connection_status;
    short ignore_user_abort;

    unsigned char header_is_being_sent;

    zend_llist tick_functions;

    zval http_globals[6];

    zend_bool expose_php;

    zend_bool register_argc_argv;
    zend_bool auto_globals_jit;

    char *docref_root;
    char *docref_ext;

    zend_bool html_errors;
    zend_bool xmlrpc_errors;

    zend_long xmlrpc_error_number;

    zend_bool activated_auto_globals[8];

    zend_bool modules_activated;
    zend_bool file_uploads;
    zend_bool during_request_startup;
    zend_bool allow_url_fopen;
    zend_bool enable_post_data_reading;
    zend_bool report_zend_debug;

    int last_error_type;
    char *last_error_message;
    char *last_error_file;
    int  last_error_lineno;

    char *php_sys_temp_dir;

    char *disable_functions;
    char *disable_classes;
    zend_bool allow_url_include;
    zend_bool exit_on_timeout;
#ifdef PHP_WIN32
    zend_bool com_initialized;
#endif
    zend_long max_input_nesting_level;
    zend_long max_input_vars;
    zend_bool in_user_include;

    char *user_ini_filename;
    zend_long user_ini_cache_ttl;

    char *request_order;

    zend_bool mail_x_header;
    char *mail_log;

    zend_bool in_error_log;

#ifdef PHP_WIN32
    zend_bool windows_show_crt_warning;
#endif
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而&lt;code&gt;php_startup_ticks&lt;/code&gt;函数就是对PG宏的成员变量&lt;code&gt;tick_functions&lt;/code&gt;进行初始化。&lt;/p&gt;
&lt;h3 id=&quot;gc_globals_ctor函数&quot;&gt;5、gc_globals_ctor函数&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;ZEND_API void gc_globals_ctor(void)
{
    gc_globals_ctor_ex(&amp;amp;gc_globals);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里又出现了一个&lt;code&gt;gc_globals&lt;/code&gt;，PHP的全局变量就是多啊，在这里我们只要先记住它是PHP垃圾回收相关的结构体即可，后面我们做详细介绍。这段代码是对&lt;code&gt;gc_globals&lt;/code&gt;进行初始化。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//Zend/zend_gc.c
typedef struct _zend_gc_globals {
    zend_bool         gc_enabled;
    zend_bool         gc_active;
    zend_bool         gc_full;

    gc_root_buffer   *buf;              /* preallocated arrays of buffers   */
    gc_root_buffer    roots;            /* list of possible roots of cycles */
    gc_root_buffer   *unused;           /* list of unused buffers           */
    gc_root_buffer   *first_unused;     /* pointer to first unused buffer   */
    gc_root_buffer   *last_unused;      /* pointer to last unused buffer    */

    gc_root_buffer    to_free;          /* list to free                     */
    gc_root_buffer   *next_to_free;

    uint32_t gc_runs;
    uint32_t collected;

#if GC_BENCH
    uint32_t root_buf_length;
    uint32_t root_buf_peak;
    uint32_t zval_possible_root;
    uint32_t zval_buffered;
    uint32_t zval_remove_from_buffer;
    uint32_t zval_marked_grey;
#endif

} zend_gc_globals;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;zend_startup函数&quot;&gt;6、zend_startup函数&lt;/h3&gt;
&lt;h4 id=&quot;start_memory_manager&quot;&gt;6.1、start_memory_manager&lt;/h4&gt;
&lt;p&gt;初始化内存管理器，对结构体&lt;code&gt;alloc_globals&lt;/code&gt;进行初始化。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//Zend/zend_alloc.c
static void alloc_globals_ctor(zend_alloc_globals *alloc_globals)
{
#if ZEND_MM_CUSTOM
    char *tmp = getenv(&quot;USE_ZEND_ALLOC&quot;);

    if (tmp &amp;amp;&amp;amp; !zend_atoi(tmp, 0)) {
        alloc_globals-&amp;gt;mm_heap = malloc(sizeof(zend_mm_heap));
        memset(alloc_globals-&amp;gt;mm_heap, 0, sizeof(zend_mm_heap));
        alloc_globals-&amp;gt;mm_heap-&amp;gt;use_custom_heap = ZEND_MM_CUSTOM_HEAP_STD;
        alloc_globals-&amp;gt;mm_heap-&amp;gt;custom_heap.std._malloc = __zend_malloc;
        alloc_globals-&amp;gt;mm_heap-&amp;gt;custom_heap.std._free = free;
        alloc_globals-&amp;gt;mm_heap-&amp;gt;custom_heap.std._realloc = __zend_realloc;
        return;
    }
#endif
#ifdef MAP_HUGETLB
    tmp = getenv(&quot;USE_ZEND_ALLOC_HUGE_PAGES&quot;);
    if (tmp &amp;amp;&amp;amp; zend_atoi(tmp, 0)) {
        zend_mm_use_huge_pages = 1;
    }
#endif
    ZEND_TSRMLS_CACHE_UPDATE();
    alloc_globals-&amp;gt;mm_heap = zend_mm_init();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;virtual_cwd_startup&quot;&gt;6.2、virtual_cwd_startup&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;virtual_cwd_startup&lt;/code&gt;初始化了&lt;code&gt;cwd_globals&lt;/code&gt;，根据源码可以看出成员变量都与&lt;code&gt;realpath_cache&lt;/code&gt;有关，&lt;code&gt;realpath_cache&lt;/code&gt;是什么呢？我们平时在写代码的时候，经常会使用include、include_once、require、require_once等语句导入文件，如果每次使用这些语句都要去对应的目录中寻找目标文件，势必会降低性能，所以官方加入了缓存，以便PHP再次使用时不必到include_path中查找，加快PHP的执行速度。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//Zend/zend_virtual_cwd.c
typedef struct _virtual_cwd_globals {
    cwd_state cwd;
    zend_long                   realpath_cache_size;
    zend_long                   realpath_cache_size_limit;
    zend_long                   realpath_cache_ttl;
    realpath_cache_bucket *realpath_cache[1024];
} virtual_cwd_globals;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;zend_startup_extensions_mechanism&quot;&gt;6.3、zend_startup_extensions_mechanism&lt;/h4&gt;
&lt;p&gt;启动扩展机制，初始化&lt;code&gt;zend_extensions&lt;/code&gt;结构体&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int zend_startup_extensions_mechanism()
{
    /* Startup extensions mechanism */
    zend_llist_init(&amp;amp;zend_extensions, sizeof(zend_extension), (void (*)(void *)) zend_extension_dtor, 1);
    last_resource_number = 0;
    return SUCCESS;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;提供编译与执行入口&quot;&gt;6.4、提供编译与执行入口&lt;/h4&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;zend_compile_file = compile_file;
zend_execute_ex = execute_ex;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;zend_init_opcodes_handlers&quot;&gt;6.5、zend_init_opcodes_handlers&lt;/h4&gt;
&lt;p&gt;初始化Zend虚拟机的handler&lt;/p&gt;
&lt;h4 id=&quot;初始化cgeg&quot;&gt;6.6、初始化CG、EG&lt;/h4&gt;
&lt;p&gt;初始化CG(function_table)、CG(class_table)、CG(auto_globals)、EG(zend_constants)，这里不再赘述，我们后续讲解。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;GLOBAL_FUNCTION_TABLE = (HashTable *) malloc(sizeof(HashTable));
GLOBAL_CLASS_TABLE = (HashTable *) malloc(sizeof(HashTable));
GLOBAL_AUTO_GLOBALS_TABLE = (HashTable *) malloc(sizeof(HashTable));
GLOBAL_CONSTANTS_TABLE = (HashTable *) malloc(sizeof(HashTable));&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;ini_scanner_globals_ctor&quot;&gt;6.7、ini_scanner_globals_ctor&lt;/h4&gt;
&lt;p&gt;初始化&lt;code&gt;ini_scanner_globals&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;php_scanner_globals_ctor&quot;&gt;6.8、php_scanner_globals_ctor&lt;/h4&gt;
&lt;p&gt;初始化&lt;code&gt;language_scanner_globals&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;zend_set_default_compile_time_values&quot;&gt;6.9、zend_set_default_compile_time_values&lt;/h4&gt;
&lt;p&gt;设置了编译相关的配置&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//Zend/zend.c
static void zend_set_default_compile_time_values(void) /* {{{ */
{
    /* default compile-time values */
    CG(short_tags) = short_tags_default;
    CG(compiler_options) = compiler_options_default;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;egerror_reporting-e_all-e_notice&quot;&gt;6.10、EG(error_reporting) = E_ALL &amp;amp; ~E_NOTICE;&lt;/h4&gt;
&lt;p&gt;EG宏就是&lt;code&gt;executor_globals&lt;/code&gt;，Zend执行器相关的全局变量，在这里对我们熟知的&lt;code&gt;error_reporting&lt;/code&gt;进行配置。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//Zend/zend_globals.h
struct _zend_executor_globals {
    zval uninitialized_zval;
    zval error_zval;

    /* symbol table cache */
    zend_array *symtable_cache[SYMTABLE_CACHE_SIZE];
    zend_array **symtable_cache_limit;
    zend_array **symtable_cache_ptr;
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;zend_interned_strings_init&quot;&gt;6.11、zend_interned_strings_init&lt;/h4&gt;
&lt;p&gt;初始化内部字符串&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//Zend/zend_string.c
void zend_interned_strings_init(void)
{
#ifndef ZTS
    zend_string *str;

    zend_hash_init(&amp;amp;CG(interned_strings), 1024, NULL, _str_dtor, 1);
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;zend_startup_builtin_functions&quot;&gt;6.12、zend_startup_builtin_functions&lt;/h4&gt;
&lt;p&gt;初始化内部函数&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//Zend/zend_builtin_functions.c
int zend_startup_builtin_functions(void) /* {{{ */
{
    zend_builtin_module.module_number = 0;
    zend_builtin_module.type = MODULE_PERSISTENT;
    return (EG(current_module) = zend_register_module_ex(&amp;amp;zend_builtin_module)) == NULL ? FAILURE : SUCCESS;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;zend_register_standard_constants&quot;&gt;6.13、zend_register_standard_constants&lt;/h4&gt;
&lt;p&gt;注册常量，比如E_ERROR、E_WARNING、E_NOTICE、E_CORE_ERROR等。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//Zend/zend_constants.c
void zend_register_standard_constants(void)
{
    REGISTER_MAIN_LONG_CONSTANT(&quot;E_ERROR&quot;, E_ERROR, CONST_PERSISTENT | CONST_CS);
    REGISTER_MAIN_LONG_CONSTANT(&quot;E_RECOVERABLE_ERROR&quot;, E_RECOVERABLE_ERROR, CONST_PERSISTENT | CONST_CS);
    REGISTER_MAIN_LONG_CONSTANT(&quot;E_WARNING&quot;, E_WARNING, CONST_PERSISTENT | CONST_CS);
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;zend_register_auto_global&quot;&gt;6.14、zend_register_auto_global&lt;/h4&gt;
&lt;p&gt;将GLOBALS加入CG(auto_globals)&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//Zend/zend.c
zend_register_auto_global(zend_string_init(&quot;GLOBALS&quot;, sizeof(&quot;GLOBALS&quot;) - 1, 1), 1, php_auto_globals_create_globals);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;zend_init_rsrc_plist&quot;&gt;6.15、zend_init_rsrc_plist&lt;/h4&gt;
&lt;p&gt;初始化持久化符号表&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int zend_init_rsrc_plist(void)
{
    zend_hash_init_ex(&amp;amp;EG(persistent_list), 8, NULL, plist_entry_destructor, 1, 0);
    return SUCCESS;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;zend_init_exception_op&quot;&gt;6.16、zend_init_exception_op&lt;/h4&gt;
&lt;p&gt;初始化EG(exception_op)&lt;/p&gt;
&lt;h4 id=&quot;zend_init_call_trampoline_op&quot;&gt;6.17、zend_init_call_trampoline_op&lt;/h4&gt;
&lt;p&gt;初始化EG(call_trampoline_op)&lt;/p&gt;
&lt;h4 id=&quot;zend_ini_startup&quot;&gt;6.18、zend_ini_startup&lt;/h4&gt;
&lt;p&gt;初始化与php.ini解析相关的变量&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//Zend/zend_ini.c
ZEND_API int zend_ini_startup(void) /* {{{ */
{
    registered_zend_ini_directives = (HashTable *) malloc(sizeof(HashTable));

    EG(ini_directives) = registered_zend_ini_directives;
    EG(modified_ini_directives) = NULL;
    EG(error_reporting_ini_entry) = NULL;
    zend_hash_init_ex(registered_zend_ini_directives, 128, NULL, free_ini_entry, 1, 0);
    return SUCCESS;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;zend_register_list_destructors_ex函数&quot;&gt;7、zend_register_list_destructors_ex函数&lt;/h3&gt;
&lt;p&gt;初始化析构函数&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//Zend/zend_list.c
ZEND_API int zend_register_list_destructors_ex(rsrc_dtor_func_t ld, rsrc_dtor_func_t pld, const char *type_name, int module_number)
{
    zend_rsrc_list_dtors_entry *lde;
    zval zv;

    lde = malloc(sizeof(zend_rsrc_list_dtors_entry));
    lde-&amp;gt;list_dtor_ex = ld;
    lde-&amp;gt;plist_dtor_ex = pld;
    lde-&amp;gt;module_number = module_number;
    lde-&amp;gt;resource_id = list_destructors.nNextFreeElement;
    lde-&amp;gt;type_name = type_name;
    ZVAL_PTR(&amp;amp;zv, lde);

    if (zend_hash_next_index_insert(&amp;amp;list_destructors, &amp;amp;zv) == NULL) {
        return FAILURE;
    }
    return list_destructors.nNextFreeElement-1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;php_binary_init函数&quot;&gt;8、php_binary_init函数&lt;/h3&gt;
&lt;p&gt;获取PHP执行的二进制路径&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static void php_binary_init(void)
{
    char *binary_location;
#ifdef PHP_WIN32
    binary_location = (char *)malloc(MAXPATHLEN);
    if (GetModuleFileName(0, binary_location, MAXPATHLEN) == 0) {
        free(binary_location);
        PG(php_binary) = NULL;
    }
#else
    if (sapi_module.executable_location) {
        binary_location = (char *)malloc(MAXPATHLEN);
        if (!strchr(sapi_module.executable_location, '/')) {
            char *envpath, *path;
            int found = 0;
            ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;php_output_register_constants函数&quot;&gt;9、php_output_register_constants函数&lt;/h3&gt;
&lt;p&gt;初始化输出相关的预定义常量&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//main/output.c
PHPAPI void php_output_register_constants(void)
{
    REGISTER_MAIN_LONG_CONSTANT(&quot;PHP_OUTPUT_HANDLER_START&quot;, PHP_OUTPUT_HANDLER_START, CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;PHP_OUTPUT_HANDLER_WRITE&quot;, PHP_OUTPUT_HANDLER_WRITE, CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;PHP_OUTPUT_HANDLER_FLUSH&quot;, PHP_OUTPUT_HANDLER_FLUSH, CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;PHP_OUTPUT_HANDLER_CLEAN&quot;, PHP_OUTPUT_HANDLER_CLEAN, CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;PHP_OUTPUT_HANDLER_FINAL&quot;, PHP_OUTPUT_HANDLER_FINAL, CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;PHP_OUTPUT_HANDLER_CONT&quot;, PHP_OUTPUT_HANDLER_WRITE, CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;PHP_OUTPUT_HANDLER_END&quot;, PHP_OUTPUT_HANDLER_FINAL, CONST_CS | CONST_PERSISTENT);

    REGISTER_MAIN_LONG_CONSTANT(&quot;PHP_OUTPUT_HANDLER_CLEANABLE&quot;, PHP_OUTPUT_HANDLER_CLEANABLE, CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;PHP_OUTPUT_HANDLER_FLUSHABLE&quot;, PHP_OUTPUT_HANDLER_FLUSHABLE, CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;PHP_OUTPUT_HANDLER_REMOVABLE&quot;, PHP_OUTPUT_HANDLER_REMOVABLE, CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;PHP_OUTPUT_HANDLER_STDFLAGS&quot;, PHP_OUTPUT_HANDLER_STDFLAGS, CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;PHP_OUTPUT_HANDLER_STARTED&quot;, PHP_OUTPUT_HANDLER_STARTED, CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;PHP_OUTPUT_HANDLER_DISABLED&quot;, PHP_OUTPUT_HANDLER_DISABLED, CONST_CS | CONST_PERSISTENT);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;php_rfc1867_register_constants函数&quot;&gt;10、php_rfc1867_register_constants函数&lt;/h3&gt;
&lt;p&gt;注册文件上传相关的预定义常量&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//main/rfc1867.c
void php_rfc1867_register_constants(void) /* {{{ */
{
    REGISTER_MAIN_LONG_CONSTANT(&quot;UPLOAD_ERR_OK&quot;,         UPLOAD_ERROR_OK, CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;UPLOAD_ERR_INI_SIZE&quot;,   UPLOAD_ERROR_A,  CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;UPLOAD_ERR_FORM_SIZE&quot;,  UPLOAD_ERROR_B,  CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;UPLOAD_ERR_PARTIAL&quot;,    UPLOAD_ERROR_C,  CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;UPLOAD_ERR_NO_FILE&quot;,    UPLOAD_ERROR_D,  CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;UPLOAD_ERR_NO_TMP_DIR&quot;, UPLOAD_ERROR_E,  CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;UPLOAD_ERR_CANT_WRITE&quot;, UPLOAD_ERROR_F,  CONST_CS | CONST_PERSISTENT);
    REGISTER_MAIN_LONG_CONSTANT(&quot;UPLOAD_ERR_EXTENSION&quot;,  UPLOAD_ERROR_X,  CONST_CS | CONST_PERSISTENT);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;php_init_config函数&quot;&gt;11、php_init_config函数&lt;/h3&gt;
&lt;p&gt;初始化配置文件php.ini，并通过&lt;code&gt;zend_parse_ini_file&lt;/code&gt;解析。&lt;/p&gt;
&lt;h3 id=&quot;zend_register_standard_ini_entries函数&quot;&gt;12、zend_register_standard_ini_entries函数&lt;/h3&gt;
&lt;p&gt;初始化ini相关的变量&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void zend_register_standard_ini_entries(void) /* {{{ */
{
    int module_number = 0;

    REGISTER_INI_ENTRIES();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;php_startup_auto_globals函数&quot;&gt;13、php_startup_auto_globals函数&lt;/h3&gt;
&lt;p&gt;注册我们熟知的全局变量$_GET、$_POST、$_COOKIE等等&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//main/php_variables.c
void php_startup_auto_globals(void)
{
    zend_register_auto_global(zend_string_init(&quot;_GET&quot;, sizeof(&quot;_GET&quot;)-1, 1), 0, php_auto_globals_create_get);
    zend_register_auto_global(zend_string_init(&quot;_POST&quot;, sizeof(&quot;_POST&quot;)-1, 1), 0, php_auto_globals_create_post);
    zend_register_auto_global(zend_string_init(&quot;_COOKIE&quot;, sizeof(&quot;_COOKIE&quot;)-1, 1), 0, php_auto_globals_create_cookie);
    zend_register_auto_global(zend_string_init(&quot;_SERVER&quot;, sizeof(&quot;_SERVER&quot;)-1, 1), PG(auto_globals_jit), php_auto_globals_create_server);
    zend_register_auto_global(zend_string_init(&quot;_ENV&quot;, sizeof(&quot;_ENV&quot;)-1, 1), PG(auto_globals_jit), php_auto_globals_create_env);
    zend_register_auto_global(zend_string_init(&quot;_REQUEST&quot;, sizeof(&quot;_REQUEST&quot;)-1, 1), PG(auto_globals_jit), php_auto_globals_create_request);
    zend_register_auto_global(zend_string_init(&quot;_FILES&quot;, sizeof(&quot;_FILES&quot;)-1, 1), 0, php_auto_globals_create_files);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;php_startup_sapi_content_types函数&quot;&gt;14、php_startup_sapi_content_types函数&lt;/h3&gt;
&lt;p&gt;初始化针对不同内容类型的处理函数&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//main/php_content_types.c
int php_startup_sapi_content_types(void)
{
    sapi_register_default_post_reader(php_default_post_reader);
    sapi_register_treat_data(php_default_treat_data);
    sapi_register_input_filter(php_default_input_filter, NULL);
    return SUCCESS;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;php_register_internal_extensions_func函数&quot;&gt;15、php_register_internal_extensions_func函数&lt;/h3&gt;
&lt;p&gt;注册内部扩展函数&lt;/p&gt;
&lt;h3 id=&quot;php_register_extensions_bc函数&quot;&gt;16、php_register_extensions_bc函数&lt;/h3&gt;
&lt;p&gt;注册PHP的附加扩展&lt;/p&gt;
&lt;h3 id=&quot;zend_startup_modules函数&quot;&gt;17、zend_startup_modules函数&lt;/h3&gt;
&lt;p&gt;启动Zend模块&lt;/p&gt;
&lt;h3 id=&quot;zend_startup_extensions函数&quot;&gt;18、zend_startup_extensions函数&lt;/h3&gt;
&lt;p&gt;启动Zend扩展&lt;/p&gt;
&lt;h3 id=&quot;php_disable_functions函数&quot;&gt;19、php_disable_functions函数&lt;/h3&gt;
&lt;p&gt;对PHP的禁用函数进行设置&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static void php_disable_functions(void)
{
    char *s = NULL, *e;

    if (!*(INI_STR(&quot;disable_functions&quot;))) {
        return;
    }

    e = PG(disable_functions) = strdup(INI_STR(&quot;disable_functions&quot;));
    if (e == NULL) {
        return;
    }
    while (*e) {
        switch (*e) {
            case ' ':
            case ',':
                if (s) {
                    *e = '\0';
                    zend_disable_function(s, e-s);
                    s = NULL;
                }
                break;
            default:
                if (!s) {
                    s = e;
                }
                break;
        }
        e++;
    }
    if (s) {
        zend_disable_function(s, e-s);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;php_disable_classes函数&quot;&gt;20、php_disable_classes函数&lt;/h3&gt;
&lt;p&gt;对PHP的禁用类进行设置&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static void php_disable_classes(void)
{
    char *s = NULL, *e;

    if (!*(INI_STR(&quot;disable_classes&quot;))) {
        return;
    }

    e = PG(disable_classes) = strdup(INI_STR(&quot;disable_classes&quot;));

    while (*e) {
        switch (*e) {
            case ' ':
            case ',':
                if (s) {
                    *e = '\0';
                    zend_disable_class(s, e-s);
                    s = NULL;
                }
                break;
            default:
                if (!s) {
                    s = e;
                }
                break;
        }
        e++;
    }
    if (s) {
        zend_disable_class(s, e-s);
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 02 Sep 2018 06:09:00 +0000</pubDate>
<dc:creator>了不起的厂长</dc:creator>
<og:description>上篇我们讲到了模块初始化阶段，并得知它是由 函数来实现的。该阶段的主要作用是初始化变量、常量；注册各种函数，比如工具、词法、语法函数等；解析配置文件；加载扩展；当然最重要的是计算出PHP二进制程序的路</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enochzzg/p/9573674.html</dc:identifier>
</item>
<item>
<title>前端后台以及游戏中使用Google Protocol Buffer详解 - 酷玩时刻</title>
<link>http://www.cnblogs.com/zyw-205520/p/9549464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zyw-205520/p/9549464.html</guid>
<description>&lt;h3 id=&quot;前端后台以及游戏中使用google-protocol-buffer详解&quot;&gt;前端后台以及游戏中使用Google Protocol Buffer详解&lt;/h3&gt;
&lt;h4 id=&quot;什么是protobuf&quot;&gt;0、什么是protoBuf&lt;/h4&gt;
&lt;p&gt;protoBuf是一种灵活高效的独立于语言平台的结构化数据表示方法，与XML相比，protoBuf更小更快更简单。你可以用定义自己protoBuf的数据结构，用ProtoBuf编译器生成特定语言的源代码，如C++，Java，Python等，目前protoBuf对主流的编程语言都提供了支持,非常方便的进行序列化和反序列化。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;平台无关、语言无关。&lt;/li&gt;
&lt;li&gt;二进制、数据自描述。&lt;/li&gt;
&lt;li&gt;提供了完整详细的操作API。&lt;/li&gt;
&lt;li&gt;高性能 比xml要快20-100倍&lt;/li&gt;
&lt;li&gt;尺寸小 比xml要小3-10倍 高可扩展性&lt;/li&gt;
&lt;li&gt;数据自描述、前后兼容&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;下载protobuf的编译器&quot;&gt;1、下载protobuf的编译器&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/google/protobuf/releases&quot;&gt;目前最新版本为Protocol Buffers v3.5.1&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;配置环境变量&quot;&gt;2、配置环境变量&lt;/h4&gt;
&lt;p&gt;解压 &lt;code&gt;protoc-3.5.1-osx-x86_64.zip&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Mac 配置环境变量 &lt;code&gt;vi ~/.bash_profile&lt;/code&gt; 使其配置生效&lt;code&gt;source ~/.bash_profile&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;#protobuf
export PROTOBUF_HOME=/Users/Javen/Documents/dev/java/protobuf/protoc-3.5.1-osx-x86_64
export PATH=$PATH:$PROTOBUF_HOME/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Window 将bin添加到path 即可 例如:&lt;code&gt;D:\protobuf\protoc-3.5.1-win32\bin&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;本文在Mac环境下编写&lt;/code&gt; &lt;strong&gt;Mac&lt;/strong&gt;与&lt;strong&gt;window&lt;/strong&gt;命令唯一的区别就是需要将&lt;code&gt;protoc&lt;/code&gt;改成&lt;code&gt;protoc.exe&lt;/code&gt; 前提是需要添加环境变量。&lt;/p&gt;
&lt;h4 id=&quot;编写一个proto文件&quot;&gt;3、编写一个proto文件&lt;/h4&gt;
&lt;p&gt;文件保存为&lt;code&gt;chat.proto&lt;/code&gt; 此&lt;code&gt;proto&lt;/code&gt;文件摘自&lt;a href=&quot;https://gitee.com/tywo45/t-io&quot;&gt;&lt;strong&gt;t-io 让天下没有难开发的网络编程&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;protobuf&quot;&gt;
&lt;code&gt;syntax = &quot;proto3&quot;;
package com.im.common.packets;

option java_package = &quot;com.im.common.packets&quot;;  //设置java对应的package
option java_multiple_files = true; //建议设置为true，这样会每个对象放在一个文件中，否则所有对象都在一个java文件中

/**
 * 聊天类型
 */
enum ChatType {
    CHAT_TYPE_UNKNOW = 0;//未知
    CHAT_TYPE_PUBLIC = 1;//公聊
    CHAT_TYPE_PRIVATE = 2;//私聊
}
/**
 * 聊天请求
 */
message ChatReqBody {
    int64 time = 1;//消息发送时间
    ChatType type = 2; //聊天类型
    string text = 3; //聊天内容
    string group = 4; //目标组id
    int32 toId = 5; //目标用户id，
    string toNick = 6; //目标用户nick
}

/**
 * 聊天响应
 */
message ChatRespBody {
    int64 time = 1;//消息发送时间
    ChatType type = 2; //聊天类型
    string text = 3; //聊天内容
    int32 fromId = 4; //发送聊天消息的用户id
    string fromNick = 5; //发送聊天消息的用户nick
    int32 toId = 6; //目标用户id
    string toNick = 7; //目标用户nick
    string group = 8; //目标组id
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;编译器对其进行编译&quot;&gt;4、编译器对其进行编译&lt;/h4&gt;
&lt;h5 id=&quot;编译为java&quot;&gt;4.1 编译为Java&lt;/h5&gt;
&lt;p&gt;进入到项目的跟目录执行以下编译命名，&lt;code&gt;com/im/common/packets&lt;/code&gt;为&lt;code&gt;chat.proto&lt;/code&gt;中的包名,&lt;code&gt;chat.proto&lt;/code&gt;文件放在&lt;code&gt;com/im/common/packets&lt;/code&gt;下。&lt;/p&gt;
&lt;pre class=&quot;protobuf&quot;&gt;
&lt;code&gt;protoc  --java_out=./ com/im/common/packets/chat.proto&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;编译为js&quot;&gt;4.2 编译为JS&lt;/h5&gt;
&lt;pre class=&quot;protobuf&quot;&gt;
&lt;code&gt;protoc --js_out=import_style=commonjs,binary:. chat.proto&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行后会在当前文件夹中生成&lt;code&gt;chat_pb.js&lt;/code&gt; 文件，这里面就是&lt;code&gt;protobuf&lt;/code&gt;的API和一些函数。如果是&lt;code&gt;Node.js&lt;/code&gt; 就可以直接使用了，如果想在浏览器(前端)中使用&lt;code&gt;protobuf&lt;/code&gt;还需要做一些处理。&lt;/p&gt;
&lt;h4 id=&quot;前端使用protobuf处理步骤&quot;&gt;5、前端使用protobuf处理步骤&lt;/h4&gt;
&lt;h5 id=&quot;npm安装需要的库&quot;&gt;5.1 npm安装需要的库&lt;/h5&gt;
&lt;p&gt;在&lt;code&gt;chat_pb.js&lt;/code&gt;文件的同级目录下安装引用库&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;npm install -g require
npm install google-protobuf
npm install -g browserify&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;使用browserify对文件进行编译打包&quot;&gt;5.2 使用browserify对文件进行编译打包&lt;/h5&gt;
&lt;p&gt;编写脚本&lt;strong&gt;保存为exports.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var chatProto = require('./chat_pb');  
module.exports = {  
DataProto: chatProto  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;执行命令&lt;/strong&gt; &lt;code&gt;browserify exports.js &amp;gt; chat.js&lt;/code&gt;对&lt;code&gt;chat_pb.js&lt;/code&gt;文件进行编译打包生成&lt;code&gt;chat.js&lt;/code&gt;后就可以愉快的使用了。&lt;/p&gt;
&lt;h4 id=&quot;protobuf使用示例&quot;&gt;6、protobuf使用示例&lt;/h4&gt;
&lt;h5 id=&quot;前端javascript中使用protobuf&quot;&gt;6.1 前端(JavaScript)中使用protobuf&lt;/h5&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;script src=&quot;./chat.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var chatReqBody = new proto.com.im.common.packets.ChatReqBody();
    chatReqBody.setTime(new Date().getTime());
    chatReqBody.setText(&quot;测试&quot;);
    chatReqBody.setType(1);
    chatReqBody.setGroup(&quot;Javen&quot;);
    chatReqBody.setToid(666);
    chatReqBody.setTonick(&quot;Javen205&quot;);

    var bytes = chatReqBody.serializeBinary();  
    console.log(&quot;序列化为字节:&quot;+bytes);
    var data = proto.com.im.common.packets.ChatReqBody.deserializeBinary(bytes); 
    console.log(&quot;反序列化为对象:&quot;+data);  
    console.log(&quot;从对象中获取指定属性:&quot;+data.getTonick());
    console.log(&quot;对象转化为JSON:&quot;+JSON.stringify(data));  

&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;java中使用protobuf&quot;&gt;6.2 Java中使用protobuf&lt;/h5&gt;
&lt;p&gt;java中要用protobuf,protobuf与json相互转换，首先需要引入相关的jar，maven的pom坐标如下&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.google.protobuf&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;protobuf-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.5.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.googlecode.protobuf-java-format&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;protobuf-java-format&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void test() {
        try {
            JsonFormat jsonFormat = new JsonFormat();
            ChatRespBody.Builder builder = ChatRespBody.newBuilder();
            builder.setType(ChatType.CHAT_TYPE_PUBLIC);
            builder.setText(&quot;Javen 测试&quot;);
            builder.setFromId(1);
            builder.setFromNick(&quot;Javen&quot;);
            builder.setToId(110);
            builder.setToNick(&quot;Javen.zhou&quot;);
            builder.setGroup(&quot;Javen&quot;);
            builder.setTime(SystemTimer.currentTimeMillis());
            ChatRespBody chatRespBody = builder.build();
            //从protobuf转json
            String asJson = jsonFormat.printToString(chatRespBody);
            System.out.println(&quot;Object to json &quot;+asJson);
            
            byte[] bodybyte = chatRespBody.toByteArray();
            //解码是从byte[]转换为java对象
            ChatRespBody parseChatRespBody = ChatRespBody.parseFrom(bodybyte);
            asJson = jsonFormat.printToString(parseChatRespBody);
            System.out.println(&quot;bodybyte to json &quot;+asJson);
            
            //从json转protobuf
            ChatRespBody.Builder _builder = ChatRespBody.newBuilder();
            jsonFormat.merge(new ByteArrayInputStream(asJson.getBytes()), _builder);
            ChatRespBody _chatRespBody = _builder.build();
            asJson = jsonFormat.printToString(_chatRespBody);
            System.out.println(&quot;json to protobuf &quot;+asJson);
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;qq玩一玩中使用protobuf&quot;&gt;6.3 QQ玩一玩中使用protobuf&lt;/h5&gt;
&lt;p&gt;将&lt;code&gt;chat.js&lt;/code&gt;中的&lt;code&gt;var global = Function('return this')();&lt;/code&gt;修改为&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// var global = Function('return this')();

var global = (function(){
  return this;
})()
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
BK.Script.loadlib('GameRes://qqPlayCore.js');
BK.Script.loadlib('GameRes://tio/chat.js');

function test() {
    var ws = new BK.WebSocket(&quot;ws://127.0.0.1:9326?group=test&amp;amp;name=Javen&quot;);
    ws.onOpen = function(ws) {
        BK.Script.log(1, 0, &quot;onOpen.js&quot;);
        BK.Script.log(1, 0, &quot;1.readyState = &quot; + ws.getReadyState());

        var time = 0;
        BK.Director.ticker.add(function(ts, duration) {
            time = time + 1;
            if (time % 100 == 0) {
                // ws.send(&quot;phone test&quot; + time);
                var chatReqBody = new proto.com.im.common.packets.ChatReqBody();
                chatReqBody.setTime(new Date().getTime());
                chatReqBody.setText(&quot;phone test&quot; + time);
                chatReqBody.setType(1);
                chatReqBody.setGroup(&quot;test&quot;);
                var bytes = chatReqBody.serializeBinary();
                ws.send(bytes);
            }
        });
    };
    ws.onClose = function(ws) {
        BK.Script.log(1, 0, &quot;onClose.js&quot;);
        BK.Script.log(1, 0, &quot;1.readyState = &quot; + ws.getReadyState());
    };
    ws.onError = function(ws) {
        BK.Script.log(1, 0, &quot;onError.js&quot;);
        BK.Script.log(1, 0, &quot;1.readyState = &quot; + ws.getReadyState());
        BK.Script.log(&quot;onError.js.js getErrorCode:&quot; + ws.getErrorCode());
        BK.Script.log(&quot;onError.js getErrorString:&quot; + ws.getErrorString());
    };
    ws.onMessage = function(ws, event) {
        if (!event.isBinary) {
            var str = event.data.readAsString();
            BK.Script.log(1, 0, &quot;text = &quot; + str);
        } else {
            var buf = event.data;
            //将游标pointer重置为0
            buf.rewind();
            var ab = new ArrayBuffer(buf.length);
            var dv = new DataView(ab);
            while (!buf.eof) {
                dv.setUint8(buf.pointer, buf.readUint8Buffer());
            }
            var chatRespBody = proto.com.im.common.packets.ChatRespBody.deserializeBinary(ab);
            var msg = chatRespBody.getFromnick() + &quot; 说: &quot; + chatRespBody.getText();
            BK.Script.log(1, 0, &quot;text = &quot; + msg);
        }
    };
    ws.onSendComplete = function(ws) {
        BK.Script.log(1, 0, &quot;onSendComplete.js&quot;);
    };
    ws.connect();
}

test();&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;eget中使用protobuf&quot;&gt;6.4 Eget中使用protobuf&lt;/h5&gt;
&lt;h6 id=&quot;插件下载&quot;&gt;插件下载&lt;/h6&gt;
&lt;p&gt;egret有提供将&lt;code&gt;proto文件&lt;/code&gt;生成JS以及TS的工具&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install protobufjs -g
npm install @egret/protobuf -g&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;操作步骤&quot;&gt;操作步骤&lt;/h6&gt;
&lt;p&gt;1、在白鹭项目的根目录中新建&lt;code&gt;protobuf&lt;/code&gt;文件夹,再在&lt;code&gt;protobuf&lt;/code&gt;文件夹中新建&lt;code&gt;protofile&lt;/code&gt;文件夹&lt;/p&gt;
&lt;p&gt;2、将&lt;code&gt;proto&lt;/code&gt;文件放到&lt;code&gt;protofile&lt;/code&gt;文件夹中&lt;/p&gt;
&lt;p&gt;3、依次执行&lt;code&gt;pb-egret add&lt;/code&gt;、&lt;code&gt;pb-egret generate&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将会自动完成以下操作：&lt;/p&gt;
&lt;p&gt;1、在&lt;code&gt;tsconfig.json&lt;/code&gt;中的&lt;code&gt;include&lt;/code&gt;节点中添加&lt;code&gt;protobuf/**/*.d.ts&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、在&lt;code&gt;egretProperties.json&lt;/code&gt;中的&lt;code&gt;modules&lt;/code&gt;节点添加&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
&quot;name&quot;: &quot;protobuf-library&quot;,
&quot;path&quot;: &quot;protobuf/library&quot;
},
{
&quot;name&quot;: &quot;protobuf-bundles&quot;,
&quot;path&quot;: &quot;protobuf/bundles&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、在&lt;code&gt;protobuf&lt;/code&gt;文件夹中自动生成&lt;code&gt;bundles&lt;/code&gt;以及&lt;code&gt;library&lt;/code&gt;文件夹里面包含了我们需要的js以及ts&lt;/p&gt;
&lt;h6 id=&quot;项目中能使用&quot;&gt;项目中能使用&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;处理发送消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt; private sendReq(text:string,group:string){
        var chatReqBody = new com.im.common.packets.ChatReqBody();
        chatReqBody.time = new Date().getTime();
        chatReqBody.text = text;
        chatReqBody.type = com.im.common.packets.ChatType.CHAT_TYPE_PUBLIC;
        chatReqBody.group = group;
        let data = com.im.common.packets.ChatReqBody.encode(chatReqBody).finish();
        this.sendBytesData(data);
    }

    private sendBytesData(data:Uint8Array){
        this.socket.writeBytes(new egret.ByteArray(data));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;处理接收消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt; private onReceiveMessage(e:egret.Event):void {

        //创建 ByteArray 对象
        var byte:egret.ByteArray = new egret.ByteArray();
        //读取数据
        this.socket.readBytes(byte);
        let buffer = new Uint8Array(byte.buffer);
        let chatRespBody =  com.im.common.packets.ChatRespBody.decode(buffer);
        
        // this.trace(&quot;收到数据:&quot;+JSON.stringify(chatRespBody));
        this.trace(chatRespBody.fromNick+&quot; 说: &quot;+chatRespBody.text);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;cocos-creator中使用protobuf&quot;&gt;6.5 Cocos Creator中使用protobuf&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;Cocos Creator中使用protobuf与前端中使用protobuf操作步骤基本一样&lt;/strong&gt;，只是在&lt;strong&gt;Cocos Creator中需要将JS导入为插件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将&lt;strong&gt;5.2&lt;/strong&gt;中编译生成的JS导入到工程的脚本文件夹中，打开Cocos Creator就会提示您是否要将脚本设置为插件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180826140309135?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5d19qYXZh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/2018082614045044?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5d19qYXZh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;项目中能使用-1&quot;&gt;项目中能使用&lt;/h6&gt;
&lt;p&gt;与6.1前端中使用方式一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;start: function () {
        cc.log(&quot;start&quot;);
        let chatReqBody = new proto.com.im.common.packets.ChatReqBody();
        chatReqBody.setTime(new Date().getTime());
        chatReqBody.setText(&quot;测试&quot;);
        chatReqBody.setType(1);
        chatReqBody.setGroup(&quot;Javen&quot;);
        chatReqBody.setToid(666);
        chatReqBody.setTonick(&quot;Javen205&quot;);

        let bytes = chatReqBody.serializeBinary();
        cc.log(&quot;序列化为字节:&quot; + bytes);
        let data = proto.com.im.common.packets.ChatReqBody.deserializeBinary(bytes);
        cc.log(&quot;反序列化为对象:&quot; + data);
        cc.log(&quot;从对象中获取指定属性:&quot; + data.getTonick());
        cc.log(&quot;对象转化为JSON:&quot; + JSON.stringify(data));
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里如何使用protobuf就介绍完了，个人能力有限如有错误欢迎指正。你有更好的解决方案或者建议欢迎一起交流讨论，如有疑问欢迎留言。&lt;/p&gt;
</description>
<pubDate>Sun, 02 Sep 2018 05:26:00 +0000</pubDate>
<dc:creator>酷玩时刻</dc:creator>
<og:description>前端后台以及游戏中使用Google Protocol Buffer详解 0、什么是protoBuf protoBuf是一种灵活高效的独立于语言平台的结构化数据表示方法，与XML相比，protoBuf更</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zyw-205520/p/9549464.html</dc:identifier>
</item>
<item>
<title>JDK源码分析 – ArrayList - 仍是少年</title>
<link>http://www.cnblogs.com/ashleyboy/p/9573340.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ashleyboy/p/9573340.html</guid>
<description>&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;ArrayList类的申明&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;ArrayList是一个支持泛型的，底层通过数组实现的一个可以存任意类型的数据结构，源码中的定义如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArrayList&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractList&amp;lt;E&amp;gt;
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;implements&lt;/span&gt; List&amp;lt;E&amp;gt;&lt;span&gt;, RandomAccess, Cloneable, java.io.Serializable
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ArrayList类继承了AbstractList抽象类，AbstractList提供了List接口的默认实现&lt;/p&gt;
&lt;p&gt;ArrayList实现了以下几个接口：&lt;/p&gt;
&lt;p&gt;List&amp;lt;E&amp;gt;接口：约定List的操作规范，提供了一系列操作方法约定&lt;/p&gt;
&lt;p&gt;RandomAccess接口：该接口约定其实现类支持随机访问，即可以通过下标的方式访问其中的元素&lt;/p&gt;
&lt;p&gt;Cloneable接口：约定其实现类实例是可以被克隆的，通过调用Object.clone方法返回该对象的浅拷贝&lt;/p&gt;
&lt;p&gt;Serializable接口：约定其实现类实例可以被序列化和反序列化&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;ArrayList主要字段、属性说明&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    //&lt;/span&gt;&lt;span&gt; 版本号&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 8683452581122892189L&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 缺省容量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CAPACITY = 10&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 空对象数组&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object[] EMPTY_ELEMENTDATA =&lt;span&gt; {};
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 缺省空对象数组&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA =&lt;span&gt; {};
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 元素数组&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt;&lt;span&gt; Object[] elementData;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际元素大小，默认为0&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最大数组容量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中有个重要的属性elementData其作用是存放集合元素,这说明了ArrayList内部其实是通过数组实现的。其修饰符transient 表明这个字字段在序列化时被忽略不序列化。&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;ArrayList部分方法分析&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;构造函数&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;无参构造函数：初始化一个长度为0的空数组&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ArrayList() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.elementData =&lt;span&gt; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;ArrayList(int) 构造函数：初始化一个指定长度的数组&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; ArrayList(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化一个容量为initialCapacity的数组&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.elementData = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[initialCapacity];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (initialCapacity == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化空数组&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.elementData =&lt;span&gt; EMPTY_ELEMENTDATA;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果尝试初始化一个容量小于0的数组，则直接抛异常&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal Capacity: &quot;+
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                                           initialCapacity);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;ArrayList(Collection&amp;lt;? extends E&amp;gt;)构造函数：初始化化一个数据，并将参数集合中的元素复制到数组中&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; ArrayList(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt;&lt;span&gt; c) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将参数集合转化为数组，赋值到ArrayList内部存储属性上&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     elementData =&lt;span&gt; c.toArray();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((size = elementData.length) != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; c.toArray might (incorrectly) not return Object[] (see 6260652)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果elementData数组类型不是Object[],则重新将elementData中元素转为Object复制到elementData中&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (elementData.getClass() != Object[].&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             elementData = Arrays.copyOf(elementData, size, Object[].&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为空则返回空数组&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.elementData =&lt;span&gt; EMPTY_ELEMENTDATA;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码中为什么要再次判断？Collection类本身的toArray方法是返回Object[]类型数组，但是Java中如果子类如果继承Collection并重写了toArray方法，则返回的可能并不是Object[]类型数值，比如String[]等其他类型&lt;/p&gt;
&lt;h3&gt;Add(E e)、add(int index, E element)、addAll(Collection&amp;lt;? extends E&amp;gt; c) 、addAll(int index, Collection&amp;lt;? extends E&amp;gt; c)&lt;/h3&gt;
&lt;p&gt;ArrayList提供了这两个add操作方法，Add(E e)直接向素组末尾添加元素，add(int index, E element)向指定index索引处添加元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接向素组末尾添加元素&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断数组容量是否还可以添加，不够添加则扩充数组容量&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     ensureCapacityInternal(size + 1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Increments modCount!!
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将元素添加到数组末尾&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     elementData[size++] =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ensureCapacityInternal(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minCapacity) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ensureExplicitCapacity(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minCapacity) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于迭代器&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;期望的最小数组容量大于当前数组容量，则扩容&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (minCapacity - elementData.length &amp;gt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        grow(minCapacity);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算期望最小的素组容量&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; calculateCapacity(Object[] elementData, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; minCapacity) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DEFAULTCAPACITY_EMPTY_ELEMENTDATA空数组&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (elementData ==&lt;span&gt; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {  
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DEFAULT_CAPACITY=10，也就是说如果此时最小返回一个长度为10的数组&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Math.max(DEFAULT_CAPACITY, minCapacity);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; minCapacity;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;扩容&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; grow(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minCapacity) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前数组容量&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; oldCapacity =&lt;span&gt; elementData.length;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算新素组容量，为当前数组容量的1.5倍&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断新数组容量与期望数组容量大小，取值大的一方&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (newCapacity - minCapacity &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         newCapacity =&lt;span&gt; minCapacity;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MAX_ARRAY_SIZE =Integer.MAX_VALUE – 8= 2147483639
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果新数组容量大于2147483639，则使用扩展到最大Integer.MAX_VALUE &lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         newCapacity =&lt;span&gt; hugeCapacity(minCapacity);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将原数组中的元素拷贝到新素组中&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;        elementData =&lt;span&gt; Arrays.copyOf(elementData, newCapacity);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码注释已经写的很清楚了，add方法的逻辑是首选检查数组容量是否够用，如果容量不足，则进行扩容，扩容策略是如果原素组为空，则返回一个长度为10的数组，否则数组容量扩充到原素组的1.5倍，最终数组容量最大为Integer.Max_VALUE=2147483647&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//向指定索引处添加元素
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查指定索引合法性&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    rangeCheckForAdd(index);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     ensureCapacityInternal(size + 1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Increments modCount!!&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     System.arraycopy(elementData, index, elementData, index + 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                      size -&lt;span&gt; index);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     elementData[index] =&lt;span&gt; element;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     size++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;add(int index, E element)内部多了一个验证指定索引合法性逻辑，其他与add(E element)实现逻辑基本一致。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加集合&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addAll(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt;&lt;span&gt; c) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Object[] a =&lt;span&gt; c.toArray();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; numNew =&lt;span&gt; a.length;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否需要扩容&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     ensureCapacityInternal(size + numNew);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Increments modCount&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     System.arraycopy(a, 0&lt;span&gt;, elementData, size, numNew);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     size +=&lt;span&gt; numNew;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; numNew != 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addAll(&lt;span&gt;int&lt;/span&gt; index, Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt;&lt;span&gt; c) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    rangeCheckForAdd(index);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     Object[] a =&lt;span&gt; c.toArray();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; numNew =&lt;span&gt; a.length;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     ensureCapacityInternal(size + numNew);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Increments modCount&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; numMoved = size -&lt;span&gt; index;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (numMoved &amp;gt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         System.arraycopy(elementData, index, elementData, index +&lt;span&gt; numNew,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                         numMoved);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     System.arraycopy(a, 0&lt;span&gt;, elementData, index, numNew);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     size +=&lt;span&gt; numNew;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; numNew != 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;addAll方法实现逻辑与add方法基本相同&lt;/p&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;get(int index)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;get方法返回此列表中指定位置的元素，内部实现首先判断一下索引是否越界（居然没有判断小于0，实际上小于0时，数组读取也会抛异常），然后取出对应索引位置处的元素，另外由于ArrayList内部是用Object[]实现存储的，get(int index)返回泛型E，实际上elementData(index)内部实现将Object转为E&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; E get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证索引是否越界&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    rangeCheck(index);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; elementData(index);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rangeCheck(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (index &amp;gt;=&lt;span&gt; size)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexOutOfBoundsException(outOfBoundsMsg(index));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;set(int index,E element)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;set方法的功能是将指定索引处的元素修改为element值，并返回该位置原来的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; E set(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证索引合法性&lt;/span&gt;
&lt;span&gt;    rangeCheck(index);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取原来的值&lt;/span&gt;
    E oldValue =&lt;span&gt; elementData(index);
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;替换为目标值&lt;/span&gt;
    elementData[index] =&lt;span&gt; element;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;remove(int index)、remove(Object o)、removeAll(Collection&amp;lt;?&amp;gt; c)、removeIf(Predicate&amp;lt;? super E&amp;gt; filter)、removeRange(int fromIndex, int toIndex)&lt;/h3&gt;
&lt;p&gt;ArrayList提供了一系列删除元素的方法，下面分析一个基础的remove(int index):&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除指定索引处的元素&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; E remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验索引合法性&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    rangeCheck(index);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除操作影响数组列表结构，所以modCount自增1&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取将要删除的元素&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     E oldValue =&lt;span&gt; elementData(index);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要被移动的元素起始位置（该删除元素后面的元素都需要移动）&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; numMoved = size - index - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存在移动的元素，则所有元素都往前移动一个位置&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (numMoved &amp;gt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         System.arraycopy(elementData, index+1&lt;span&gt;, elementData, index,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                         numMoved);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于所有元素都向前移动了，最后一个空出来的位置设置为null&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     elementData[--size] = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; clear to let GC do its work
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回被删除的元素&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;IndexOf(Object o) 、lastIndexOf(Object o) &lt;/h3&gt;
&lt;p&gt;如果我们需要检查列表中某个元素的位置，则可以使用indexOf方法，此方法返回被检查元素在列表中第一次出现的下标，如果未找到该元素，则返回-1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找指定元素的索引&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; indexOf(Object o) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺序遍历数组，返回第一个出现位置的下标&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (elementData[i]==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(elementData[i]))
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不存在返回-1&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;lastIndexOf(Object o)返回指定元素在数组中最后一次出现的下标&lt;/p&gt;
&lt;h3&gt;iterator()、listIterator()、listIterator(int index)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;iterator()方法： 返回一个ArrayList中元素的迭代器，实现代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; iterator() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Itr();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Itr &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下一个要返回元素的索引&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; cursor;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; index of next element to return
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后一个返回元素的索引&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; lastRet = -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; index of last element returned; -1 if no such&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; expectedModCount =&lt;span&gt; modCount;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    Itr() {}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否还存在下一个元素&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; cursor !=&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验，在迭代器进行元素遍历期间如果修改数组长度，则抛出异常&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        checkForComodification();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; cursor;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; size)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         Object[] elementData = ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elementData;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; elementData.length)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向下一个元素&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         cursor = i + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回索引值为i处的元素，并将i赋值给lastRet:代表最后返回元素的索引&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (E) elementData[lastRet =&lt;span&gt; i];
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过迭代器删除元素，不会抛异常&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (lastRet &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        checkForComodification();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.remove(lastRet);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             cursor =&lt;span&gt; lastRet;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             lastRet = -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             expectedModCount =&lt;span&gt; modCount;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IndexOutOfBoundsException ex) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEachRemaining(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt;&lt;span&gt; consumer) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        Objects.requireNonNull(consumer);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; cursor;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; size) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; Object[] elementData = ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elementData;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; elementData.length) {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (i != size &amp;amp;&amp;amp; modCount ==&lt;span&gt; expectedModCount) {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             consumer.accept((E) elementData[i++&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; update once at end of iteration to reduce heap write traffic&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;         cursor =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;         lastRet = i - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        checkForComodification();
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkForComodification() {
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;迭代器的实际应用：&lt;/p&gt;
&lt;p&gt;　　1. 使用迭代器iterator遍历：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 　　　　Iterator&amp;lt;Integer&amp;gt; list=&lt;span&gt; array.iterator();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(list.hasNext()){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;array.add(4);  add() 和remove()会导致modCount发生变化,从而导致迭代过程中抛出异常&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; value =&lt;span&gt; it.next();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用迭代器提供的remove()方法避免抛异常，原因：迭代器的remove方法在删除元素之后对将ArrayList的modCount覆盖了迭代器类的expectedModCount&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;            it.remove();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;        
&lt;span&gt;8&lt;/span&gt; 　　}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.使用forEach遍历：反编译class文件可以发现其本质还是使用了iterator迭代器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　for&lt;/span&gt;&lt;span&gt;(Integer item : array){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;item.add()和item.remove()都将报错&lt;/span&gt;
&lt;span&gt;            System.out.println(value);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;listIterator()方法：返回返回ArrayList元素的列表迭代器，与Iterator迭代器相比，它还提供了向前遍历，增加元素，修改元素的操作，其实现代码如下&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; ListIterator&amp;lt;E&amp;gt;&lt;span&gt; listIterator() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ListItr(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ListItr &lt;span&gt;extends&lt;/span&gt; Itr &lt;span&gt;implements&lt;/span&gt; ListIterator&amp;lt;E&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     ListItr(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化游标&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         cursor =&lt;span&gt; index;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否存在上 一个元素&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasPrevious() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; cursor != 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回下一个将遍历的元素索引&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nextIndex() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cursor;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回前一个元素索引&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; previousIndex() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; cursor - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向前遍历：返回当前索引的上一个元素&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E previous() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验，在迭代器进行元素遍历期间如果修改数组长度，则抛出异常&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        checkForComodification();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算前一个元素索引&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = cursor - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         Object[] elementData = ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elementData;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; elementData.length)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;游标指向前一个元素&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         cursor =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;41　　　　　　&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回前一个元素&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (E) elementData[lastRet =&lt;span&gt; i];
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;      
&lt;span&gt;45&lt;/span&gt; 　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改当前位置的元素&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; set(E e) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (lastRet &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        checkForComodification();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.set(lastRet, e);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IndexOutOfBoundsException ex) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前位置新增元素&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(E e) {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        checkForComodification();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; cursor;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.add(i, e);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             cursor = i + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             lastRet = -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             expectedModCount =&lt;span&gt; modCount;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IndexOutOfBoundsException ex) {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后：&lt;span lang=&quot;EN-US&quot;&gt;ArrayList其实就是一个动态的&lt;span lang=&quot;EN-US&quot;&gt;Array，并且提供了一些便携的操作方法而已。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 02 Sep 2018 04:11:00 +0000</pubDate>
<dc:creator>仍是少年</dc:creator>
<og:description>ArrayList类的申明 ArrayList是一个支持泛型的，底层通过数组实现的一个可以存任意类型的数据结构，源码中的定义如下： ArrayList类继承了AbstractList抽象类，Abstr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ashleyboy/p/9573340.html</dc:identifier>
</item>
<item>
<title>JVM学习笔记——GC概述 - 薄峰</title>
<link>http://www.cnblogs.com/qbzf-Blog/p/9573334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qbzf-Blog/p/9573334.html</guid>
<description>&lt;p&gt;title: JVM学习笔记——GC概述&lt;br/&gt;date: 2018/9/2 12:05:00&lt;br/&gt;description: 最近开始着手JVM的学习，在这里把自己学习过程中的笔记分享出来，希望能帮到一些小伙伴，同时也是对自己的学习的一个梳理。&lt;/p&gt;
&lt;h2 id=&quot;gc概述&quot;&gt;GC概述&lt;/h2&gt;
&lt;p&gt;其实GC主要就是思考以下三件事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;哪些内存需要回收？&lt;/li&gt;
&lt;li&gt;什么时候回收？&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&quot;如何回收&quot;&gt;如何回收？&lt;br/&gt;&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&quot;哪些内存需要回收&quot;&gt;哪些内存需要回收&lt;/h4&gt;
主要针对Java堆和方法区，程序计数器、虚拟机栈、本地方法栈内存分配与回收具有确定性，所以不需要过多考虑GC的问题。&lt;br/&gt;其中方法区的回收主要针对以下两种：
&lt;ul&gt;&lt;li&gt;回收常量&lt;br/&gt;没有任何地方引用到该常量时，该常量将会被回收。&lt;/li&gt;
&lt;li&gt;回收无用类&lt;br/&gt;同时满足以下几个条件则视为“无用类”。
&lt;ul&gt;&lt;li&gt;Java堆中不存在任何该类的实例&lt;/li&gt;
&lt;li&gt;加载该类的ClassLoader已经被回收&lt;/li&gt;
&lt;li&gt;该类的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问到该类。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&quot;什么时候回收判断对象是否死去&quot;&gt;什么时候回收（判断对象是否“死去”）&lt;/h4&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;h5 id=&quot;引用计数算法&quot;&gt;引用计数算法&lt;/h5&gt;
为对象增加一个引用计数器，每有一次引用则计数器+1，失去一个引用则计数器-1。这种算法效率很高，实现也很简单，但是在相互引用的情况下，会出现无法回收的情况。例如：&lt;code&gt;a.instance = b; b.instance = a;&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;h5 id=&quot;可达性分析算法&quot;&gt;可达性分析算法&lt;/h5&gt;
&lt;p&gt;使用GC Roots作为起始点，当一个对象到GC Roots没有引用链路时（即不可达），则此时对象视为“死亡”。此方法也是现有JVM中常用的算法。&lt;br/&gt;GC Roots包括下面几种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;虚拟机栈（栈帧中的本地变量表）中引用的对象&lt;/li&gt;
&lt;li&gt;本地方法栈中Native方法引用的对象&lt;/li&gt;
&lt;li&gt;方法区中类静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;换句话来说，以上4中类型其实就是：类成员变量，类静态变量，常量，局部变量，只要某个对象不被以上4种类型关联到，那么该对象就是“已死”的，gc时就会被回收内存空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&quot;如何回收垃圾收集算法&quot;&gt;如何回收（垃圾收集算法）&lt;/h4&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li&gt;
&lt;h5 id=&quot;标记-清除算法mark-sweep&quot;&gt;标记-清除算法（Mark-Sweep）&lt;/h5&gt;
&lt;img src=&quot;https://i.imgur.com/FgacPmU.jpg&quot; alt=&quot;Mark-Sweep&quot;/&gt;&lt;br/&gt;它是最基础的算法，后续的算法都是针对它的缺点改进而生。它存在两个缺点：
&lt;ul&gt;&lt;li&gt;效率问题。标记与清除这两个过程效率都不高。&lt;/li&gt;
&lt;li&gt;空间问题。如图所示，清除后的内存空间是不规整的，会产生大量的内存碎片。大量的碎片会导致分配大对象时，找不到连续的内存空间而提前触发另一次GC。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;h5 id=&quot;复制算法copying&quot;&gt;复制算法（Copying）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/rVLcVCb.jpg&quot; alt=&quot;Copying&quot;/&gt;&lt;br/&gt;针对标记-清除的效率问题，复制算法将内存分为两块空间，每次只使用其中一块。当这块的内存空间用完时，将存活的对象移到另一块中，然后将已使用的内存空间一次性清理掉。这样做的好处是不会产生碎片，清除也是针对连续的空间做处理，只要移动堆指针就行。&lt;br/&gt;实际上在现在的虚拟机中，将这种算法应用在新生代。按照8：1：1的比例将内存分为三块，每次使用一块较大的与较小的其中一块，清理时将存活对象移到剩下的一块中，这样每次只会浪费10%的内存，由于新生代中的内存一般都是“朝生夕死”的，使用这种算法可以极大的提升效率。但是，不能保证每次清理时，剩下的一块空间能够存放所有的存活对象，所以这里会依赖其他内存空间（一般指老年代）进行分配担保（Handle Promotion）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;h5 id=&quot;标记-整理算法mark-compact&quot;&gt;标记-整理算法（Mark-Compact）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3v4hKEx.jpg&quot; alt=&quot;Mark-Compact&quot;/&gt;&lt;br/&gt;复制算法在对象存活率较高时，效率就会变低，所以针对高对象存活率的情况，就有人提出了该算法。标记的过程并没有变化，但标记后并不是进行“清除”，而是将存活的对象向一端进行移动整理，然后清除掉其余的空间。现代虚拟机常将这种算法在老年代中使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;h5 id=&quot;分代收集算法generational-collection&quot;&gt;分代收集算法（Generational Collection）&lt;/h5&gt;
&lt;p&gt;分代收集算法是根据对象的存活时间，将内存划分几块（一般分为新生代和老年代），这样就可以根据不同的内存区域特点采用不同的算法。针对新生代，使用复制算法，用少量的内存空间换来更大的效率；针对老年代，使用标记-整理或标记-清除来处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 02 Sep 2018 04:08:00 +0000</pubDate>
<dc:creator>薄峰</dc:creator>
<og:description>title: JVM学习笔记——GC概述 date: 2018/9/2 12:05:00 description: 最近开始着手JVM的学习，在这里把自己学习过程中的笔记分享出来，希望能帮到一些小伙伴</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qbzf-Blog/p/9573334.html</dc:identifier>
</item>
<item>
<title>py+selenium遇见IE，元素只有name属性【神奇解决】 - 怪盗积德</title>
<link>http://www.cnblogs.com/4wheel/p/9573262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/4wheel/p/9573262.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/span&gt;：当需要自动化测试某系统，而该系统只兼容IE8，怎么办？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IE8的问题：&lt;strong&gt;&lt;span&gt;IE8不支持&lt;span class=&quot;objectBox objectBox-text&quot;&gt;getElementByName，而属性中又没有ID，定位难度较大。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span class=&quot;objectBox objectBox-text&quot;&gt;IE8以下不兼容&lt;strong&gt;&lt;span class=&quot;objectBox objectBox-text&quot;&gt;getElementByName。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;objectBox objectBox-text&quot;&gt;百度找到的基本都是先定义一个getElementByName的函数先……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;objectBox objectBox-text&quot;&gt;然而&lt;span&gt;我发现另一种简单的方法，只有IE可以做到！！（百度没有的）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;objectBox objectBox-text&quot;&gt;全网首发！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;objectBox objectBox-text&quot;&gt;试验：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;objectBox objectBox-text&quot;&gt;简易html源码，给三个输入框赋值，观察火狐与IE！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/738267/201809/738267-20180902111513523-1581817522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;火狐测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/738267/201809/738267-20180902113243863-994773604.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IE测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/738267/201809/738267-20180902113420980-26619238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IE8无法用Name获取对象，所以报错&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;但&lt;span&gt;&lt;strong&gt;&lt;span&gt;经测试发现：只有IE，调用脚本时，当没有ID属性时，用getElemetById也可以获取到Name的属性！！！！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;其他浏览器就不行，只有IE！！！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 完美解决！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 02 Sep 2018 03:39:00 +0000</pubDate>
<dc:creator>怪盗积德</dc:creator>
<og:description>问题：当需要自动化测试某系统，而该系统只兼容IE8，怎么办？ IE8的问题：IE8不支持getElementByName，而属性中又没有ID，定位难度较大。 IE8以下不兼容getElementByN</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/4wheel/p/9573262.html</dc:identifier>
</item>
<item>
<title>项目微管理30 - 绩效 - 沙场秋点兵</title>
<link>http://www.cnblogs.com/dxy1982/p/9571357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dxy1982/p/9571357.html</guid>
<description>&lt;p&gt;绩效考核对于任何人都是非常重要的一件事，不过它同样也是最让人诟病的一件事，甚至很多激进的程序员会说：“什么狗屁绩效考核，只要是搞考核的公司，老子一律不去！”&lt;/p&gt;

&lt;p&gt;话糙理不糙，这个现象至少说明绩效考核已经惹得天怒人怨，甚至索尼的某高管都放言：“索尼之所以垮掉，都是绩效考核惹的祸”。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201809/109061-20180902105054892-249225378.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;绩效考核是把双刃剑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;不过即使是这样，现在每个公司还是紧紧的在抱住绩效考核的大腿不放，为什么呢？&lt;/p&gt;

&lt;p&gt;因为没有其它的选择！！！&lt;/p&gt;

&lt;p&gt;如果没有绩效考核，如何评定一个员工的贡献？依据什么来调整薪水？根据什么来发放年终奖？要提拔谁？要晋升谁？如果没有绩效考核的话，只能依靠主管自己主观上的判断，有些公司确实是这样，这个有多不靠谱就不用多说了。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201809/109061-20180902105251762-513753747.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;绩效考核就像一把双刃剑，大家其实也都知道！！！&lt;/p&gt;

&lt;p&gt;耍的好可以变成倚天神剑，遇神杀神，遇魔伏魔，大幅提高公司整体的执行力和效率，目前这种神一样的玩法很少看到。&lt;/p&gt;

&lt;p&gt;玩的不好就是破铜烂铁，在伤害员工的同时，也在深深的拖累着公司，一方面员工抱怨考核不客观，一方面公司抱怨考核没带来实际的改善，这种现象倒是到处可见。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201809/109061-20180902105119502-1384586616.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;对于如何进行绩效考核，据四代粗略的了解，整个江湖中主流上是两大流派。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;印象派的做法是考察“影响力”&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;第一大派是印象派。&lt;/p&gt;

&lt;p&gt;该派以Facebook, Google, Intel, Microsoft等实力相当强劲的选手为代表，这一派的考核以“影响力”为核心理念，全面考察一个人对于整个公司的影响力，根据影响力的高低定性的评定个人的贡献。&lt;/p&gt;

&lt;p&gt;如何去评定一个人的影响力呢？印象派的做法是360反馈。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201809/109061-20180902110258685-220308711.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;360嘛，就是360度，其实就代表全面的意思。360反馈的做法分为两步。&lt;/p&gt;

&lt;p&gt;第一步，自评。&lt;/p&gt;

&lt;p&gt;自评就是员工自己给自己一个在考评阶段内的评价。说是评价，其实都是在列举实际的例子，做了那些事，那些事做的好，这些都是事实，事实最有说服力。&lt;/p&gt;

&lt;p&gt;第二步，他评。&lt;/p&gt;

&lt;p&gt;就是收集其它相关同事，比如合作的测试团队的、合作的业务团队的、合作的其它开发团队的同事，对该员工的评价。这些他评的同事人选通常都是当前员工自己指定的，因为只有他自己才最清楚合作的人有哪些。当然评价的的内容还是一样的，都是举事实。&lt;/p&gt;

&lt;p&gt;在他评中，最重要的就是直属主管的评价，因为他非常了解当前员工的情况，他的评价会占相当大的比重。&lt;/p&gt;

&lt;p&gt;当这两步做完以后，直属主管核实所有的事例，然后综合给出优点和缺点的评价，然后根据团队的评估标准给一个等级评定结果。&lt;/p&gt;

&lt;p&gt;当然有的公司也会把当前员工所做的项目的重要性也考虑进去，提供一个权重值，最终再计算一个分数作为最终结果。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201809/109061-20180902105608836-2075933528.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;拿着这一堆数据和评价，直属主管就可以找员工谈天了，然后考评就结束了。&lt;/p&gt;

&lt;p&gt;全面列举事例，其实反映的就是这个员工对公司相关合作同事的影响力，所以你的人缘越好，做事越高调，成果越多，考评结果就会越好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;指标派的做法是考核“指标值”&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;第二大派是指标派。&lt;/p&gt;

&lt;p&gt;该派以阿里巴巴为典型的代表，其实大多数的实业和中小型公司都是这样的。这一派将“指标即考核”做为基本原理，根据每个人的指标数据来定量的评定个人的贡献。&lt;/p&gt;

&lt;p&gt;指标派一般都会深信数据的重要性，于是试图把所有的考核指标都数据化，使用一个相对直观的分数来代表，这样最终的考核结果就比较简单，直接把各项的得分加起来就可以了。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201809/109061-20180902105639785-696916940.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;比如四代接触到的一些数据化的例子：代码日提交行数，功能发现的Bug数目，修复的Bug数量，软件运行崩溃的次数，开发的功能点的数目，代码重用度，代码清晰度，代码的扩展性，使用的设计模式的数量，如果你觉得前几个还可以统计客观数据的话，那后面的就越来越扯淡了，数据都越来越模糊，分数怎么去定呢？&lt;/p&gt;

&lt;p&gt;除了这些项目上的数据，关键指标通常也会包括价值观指标，比如正直，热情，合作，创新等，他们都可以打分考评，虽然四代不知道如何给这些价值观定一个合适的分数。&lt;/p&gt;

&lt;p&gt;指标派实施考核的过程做的比较好的一般也是经历自评评分和主管评分两个阶段，自评就是按照指标数据给自己打分，主管评就是主管按照你的表现给你打分，最终的分数可能是一个均衡以后的结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;都是利益分配的方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;其实不管是两大派哪种做法，考评的结果都是将人分等级，比如常见的“2-7-1”分级，就是考核的目标是将人分成优秀，合格和不合格三种，这三种的比例就是优秀的人占总人数的2/10，合格的占7/10，垫底的占1/10。&lt;/p&gt;

&lt;div&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201809/109061-20180902105145685-157990356.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;固定了这个就可以来点实际的了：发钱！为了控制发钱的总量，所以必须要将人分级，发的多的必须是前面那20%，末尾的10%基本不发，有的甚至还会接受“末尾淘汰”的惩罚，实在是祸不单行。&lt;/p&gt;

&lt;p&gt;好的，终于说到最重要的利益分配了。在很多人的脑袋里，绩效考核的目的就在于此：绩效考核就是为了评定利益分配的比例。&lt;/p&gt;

&lt;p&gt;可是，一切真的是如此简单吗？&lt;/p&gt;
</description>
<pubDate>Sun, 02 Sep 2018 03:08:00 +0000</pubDate>
<dc:creator>沙场秋点兵</dc:creator>
<og:description>绩效那些事</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dxy1982/p/9571357.html</dc:identifier>
</item>
<item>
<title>设计模式四: 抽象工厂(Abstract Factory) - 罪恶斯巴克</title>
<link>http://www.cnblogs.com/walkinhalo/p/9573109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walkinhalo/p/9573109.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;抽象工厂模式是创建型模式的一种, 与工厂方法不同的是抽象工厂针对的是生产一组相关的产品, 即一个产品族.&lt;/p&gt;
&lt;p&gt;抽象工厂使用工厂方法模式来生产单一产品, 单一产品的具体实现分别属于不同的产品族. 抽象工厂即是对产品族的抽象.&lt;/p&gt;
&lt;p&gt;工厂类一般使用单例实现(工厂方法的工厂类也是如此)&lt;/p&gt;
&lt;h2 id=&quot;意图&quot;&gt;意图&lt;/h2&gt;
&lt;p&gt;定义了一个创建对象的接口，用于创建&lt;strong&gt;一组&lt;/strong&gt;相关的对象.&lt;/p&gt;
&lt;h2 id=&quot;类图&quot;&gt;类图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/794700/201809/794700-20180902105956437-260409611.png&quot; alt=&quot;抽象工厂&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;组装电脑需要CPU和内存, 对于Windows和Mac来说所需的是两个不同的系列产品, Windows用Windows系列的CPU,RAM, Mac用Mac系列的CPU,RAM;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用工厂模式,分别定义CPU,RAM相关的接口和实现&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 抽象产品,定义接口
public interface CPU {
}
public interface RAM {
}

// 抽象每个产品的工厂
public interface CPUFactory {
    CPU createCPU();
}
public interface RAMFactory {
    RAM createRAM();
}

// 实现具体产品
public class MacCPU implements CPU {
}
public class MacRAM implements RAM {
}
public class WindowsCPU implements CPU {
}
public class WindowsRAM implements RAM {
}

// 工厂方法具体实现
public class MacCPUFactory implements CPUFactory {
    public CPU createCPU() {
        return new MacCPU();
    }
}
public class MacRAMFactory implements RAMFactory {
    public RAM createRAM() {
        return new MacRAM();
    }
}
public class WindowsCPUFactory implements CPUFactory {
    public CPU createCPU() {
        return new WindowsCPU();
    }
}
public class WindowsRAMFactory implements RAMFactory {
    public RAM createRAM() {
        return new WindowsRAM();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;定义抽象工厂接口&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 抽象工厂接口
 */
public interface PCAbstractFactory {
    CPU createCPU();
    RAM createRAM();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;定义抽象工厂的实现&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Mac的工厂实现
 */
public class MacFactory implements PCAbstractFactory{
    public CPU createCPU() {
        return new MacCPUFactory().createCPU();
    }

    public RAM createRAM() {
        return new MacRAMFactory().createRAM();
    }
}

/**
 * Windows的工厂实现
 */
public class WindowsFactory implements PCAbstractFactory{
    public CPU createCPU() {
        return new WindowsCPUFactory().createCPU();
    }

    public RAM createRAM() {
        return new WindowsRAMFactory().createRAM();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;调用&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;PCAbstractFactory factory = new MacFactory();
CPU cpu = factory.createCPU();
RAM ram = factory.createRAM();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;优点: 1. 将产品的生产分离出来; 2. 易于改变产品系列; 3. 利于产品一致性,一次生产一系列产品&lt;/p&gt;
&lt;p&gt;缺点: 不利于新增产品,新增则抽象工厂及工厂实现类均要增加相关对象方法&lt;/p&gt;
</description>
<pubDate>Sun, 02 Sep 2018 03:01:00 +0000</pubDate>
<dc:creator>罪恶斯巴克</dc:creator>
<og:description>设计模式四: 抽象工厂(Abstract Factory) 简介 抽象工厂模式是创建型模式的一种, 与工厂方法不同的是抽象工厂针对的是生产一组相关的产品, 即一个产品族. 抽象工厂使用工厂方法模式来生</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walkinhalo/p/9573109.html</dc:identifier>
</item>
</channel>
</rss>