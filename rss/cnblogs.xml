<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用JavaMail发送邮件 - 奶BerBer</title>
<link>http://www.cnblogs.com/LexMoon/p/javamail.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LexMoon/p/javamail.html</guid>
<description>
&lt;p&gt;&lt;span&gt;使用JavaMail的API发送邮件~！&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.collections.CollectionUtils;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.log4j.Logger;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; javax.mail.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.mail.internet.AddressException;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.mail.internet.InternetAddress;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.mail.internet.MimeMessage;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.mail.internet.MimeUtility;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.UnsupportedEncodingException;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List; 
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MailService {
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String MAIL_SMTP_HOST=&quot;********@qq.com&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String MAIL_SMTP_PORT=&quot;465&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;465端口是为SMTPS（SMTP-over-SSL）协议服务开放的&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String MAIL_SENDER_MAIL=&quot;1325200471@qq.com&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String MAIL_SENDER_PASS=&quot;*******&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String MAIL_SENDER_NICKNAME=&quot;腾讯邮箱平台&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Logger logger = Logger.getLogger(MailService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;         MailService m = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MailService();
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         List&amp;lt;String&amp;gt; recipients = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;         l.add(&quot;***@alibaba-inc.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;         List&amp;lt;String&amp;gt; copyToRecipients = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         l1.add(&quot;***@alibaba-inc.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;             m.sendMail(&quot;title&quot;,&quot;content&quot;,recipients,copyToRecipients,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (MessagingException e) {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnsupportedEncodingException e) {
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;     * 初始化Session
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Session getMailSession(){
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;         Properties props = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt;         props.put(&quot;mail.smtp.host&quot;&lt;span&gt;, MAIL_SMTP_HOST);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         props.put(&quot;mail.smtp.port&quot;&lt;span&gt;, MAIL_SMTP_PORT);
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         props.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         props.put(&quot;mail.smtp.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;         Session session = Session.getDefaultInstance(props, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Authenticator() {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;             &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; PasswordAuthentication getPasswordAuthentication() {
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PasswordAuthentication(MAIL_SENDER_MAIL, MAIL_SENDER_PASS);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; session;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; title 邮件标题
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; content  邮件内容
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; recipients 收件人邮箱列表
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; copyToRecipients 抄送人邮箱列表
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; secretCopyToRecipients 密送人邮箱列表
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; MessagingException
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; UnsupportedEncodingException
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; sendMail(String title,String content,Collection&amp;lt;String&amp;gt;&lt;span&gt; recipients,
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                             Collection&amp;lt;String&amp;gt; copyToRecipients,Collection&amp;lt;String&amp;gt; secretCopyToRecipients) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; AddressException, MessagingException, UnsupportedEncodingException {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化收件人、抄送、密送邮箱列表&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;         List&amp;lt;InternetAddress&amp;gt; toAddresses =&lt;span&gt; parseStringToAddress(recipients);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         List&amp;lt;InternetAddress&amp;gt; ccAddresses =&lt;span&gt; parseStringToAddress(copyToRecipients);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         List&amp;lt;InternetAddress&amp;gt; bccAddresses =&lt;span&gt; parseStringToAddress(secretCopyToRecipients);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化邮件内容&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;         Message message = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MimeMessage(getMailSession());
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;         message.setFrom(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternetAddress(MAIL_SENDER_MAIL, MAIL_SENDER_NICKNAME));
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;         String subject = MimeUtility.encodeWord(title, &quot;UTF-8&quot;, &quot;Q&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置标题编码&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;        message.setSubject(subject);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         message.setContent(content, &quot;text/html; charset=utf-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 收件人&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;         message.setRecipients(Message.RecipientType.TO, toAddresses.toArray(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternetAddress[toAddresses.size()]));
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抄送&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;         message.setRecipients(Message.RecipientType.CC, ccAddresses.toArray(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternetAddress[ccAddresses.size()]));
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 密送&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;         message.setRecipients(Message.RecipientType.BCC, bccAddresses.toArray(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternetAddress[bccAddresses.size()]));
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;        message.saveChanges();
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;        Transport.send(message);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不报异常表示邮件发送成功&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt; &lt;span&gt;     * 将字符串类型的邮箱地址转成InternetAddress类型的邮箱地址
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; mailStrings
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; List&amp;lt;InternetAddress&amp;gt;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;InternetAddress&amp;gt; parseStringToAddress(Collection&amp;lt;String&amp;gt; mailStrings) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; AddressException {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(CollectionUtils.isEmpty(mailStrings)){
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.emptyList();
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         List&amp;lt;InternetAddress&amp;gt; addressList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;InternetAddress&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String mailString:mailStrings){
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             InternetAddress internetAddress =  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternetAddress(mailString);
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;            addressList.add(internetAddress);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; addressList;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; 
&lt;span&gt;120&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;在使用javamail进行邮件发送的时候，报错：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Could not connect to SMTP host: smtp.***.com, port: 465, response: -1
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;　　原因：&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; props.put(&quot;mail.smtp.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;　　扩展-邮件服务端口：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;25端口（SMTP）&lt;/span&gt;：25端口为SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）服务所开放的，是用于发送邮件。如今绝大多数邮件服务器都使用该协议。当你给别人发送邮件时，你的机器的某个动态端口（大于1024）就会与邮件服务器的25号端口建立一个连接，你发送的邮件就会通过这个连接传送到邮件服务器上，保存起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;109端口（POP2）&lt;/span&gt;：109端口是为POP2（Post Office Protocol Version 2，邮局协议2）服务开放的，是用于接收邮件的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;110端口（POP3）&lt;/span&gt;：110端口是为POP3（Post Office Protocol Version 3，邮局协议3）服务开放的，是用于接收邮件的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;143端口（IMAP）&lt;/span&gt;：143端口是为IMAP（INTERNET MESSAGE ACCESS PROTOCOL）服务开放的，是用于接收邮件的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;25&quot;&gt;
&lt;span readability=&quot;44&quot;&gt;目前POP3使用的比POP2广得多，POP2几乎被淘汰，也有某些服务器同时支持POP2和POP3协议。&lt;p&gt;客户端可以使用POP3协议来访问服务端的邮件服务，如今ISP的绝大多数邮件服务器都是使用POP3协议（极少用POP2协议）。&lt;/p&gt;&lt;p&gt;在使用邮件客户端程序的时候，会要求输入POP3服务器地址，默认情况下使用的就是110端口。&lt;/p&gt;&lt;p&gt;当你用邮件客户端（比如、Thunderbird、foxmail、MS Outlook Express以及各类邮件精灵）登录时，&lt;/p&gt;&lt;p&gt;你的机器就会自动用机器的某一个动态端口（大于1024）连接邮件服务器的110端口，服务器就把别人给你发的邮件（之前保存在邮件服务器上），&lt;/p&gt;&lt;p&gt;发送到你机器，这样你就可以看到你客户端工具上的收件箱里的新邮件了。

IMAP协议，和POP3协议一样是用来接收邮件的，但是它有它的特别和新颖之处，它是面向用户的，&lt;/p&gt;&lt;p&gt;它和POP3协议的主要区别是：用户可以不用把所有的邮件内容全部下载，而是只下载邮件标题和发件人等基本信息，&lt;/p&gt;&lt;p&gt;用户可以由标题等基本信息，去决定是否下载邮件全文，用户可以通过客户端的浏览器直接对服务器上的邮件进行操作&lt;/p&gt;&lt;p&gt;（比如：打开阅读全文、丢进垃圾箱、永久删除、整理到某文件夹下、归档、）。&lt;/p&gt;&lt;p&gt;再简单来说就是：浏览器用的IMAP协议（143端口）来为你接收邮件以及让你很方便的操作服务器上的邮件。&lt;/p&gt;&lt;p&gt;邮件客户端用的POP3协议（110端口）来为你接收邮件的全部信息和全文内容保存到你的本地机器成为一个副本，&lt;/p&gt;&lt;p&gt;你对邮件客户端上的副本邮件的任何操作都是在副本上，不干涉邮件服务器上为你保存的邮件原本。

上面介绍的SMTP协议、POP2协议、POP3协议、IMAP协议都是不安全的协议。&lt;/p&gt;&lt;p&gt;因考虑到网络安全的因素，下面给你介绍基于SSL（Secure Sockets Layer 安全套接层）协议的安全的邮件收发协议。&lt;/p&gt;&lt;p&gt;你的邮件在传输过程中可能被网络黑客截取邮件内容，如果你的邮件机密性非常强，不想被收件人以外的任何人和任何黑客截取，或者是涉及国家机密安全的，等等。&lt;/p&gt;&lt;p&gt;那么你的邮件就不该使用上述的三种协议进行收发。&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;若你采用SMTP协议发邮件，那么你发出的邮件从你的机器传到服务器的过程中，可能被黑客截取从而泄露。****若你采用POP2或者POP3协议收取邮件，那么你的邮件从服务器传至你当前机器的过程可能被黑客截取从而泄露。&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;465端口（SMTPS）&lt;/span&gt;：465端口是为SMTPS（SMTP-over-SSL）协议服务开放的，这是SMTP协议基于SSL安全协议之上的一种变种协议，它继承了SSL安全协议的非对称加密的高度安全可靠性，可防止邮件泄露。SMTPS和SMTP协议一样，也是用来发送邮件的，只是更安全些，防止邮件被黑客截取泄露，还可实现邮件发送者抗抵赖功能。防止发送者发送之后删除已发邮件，拒不承认发送过这样一份邮件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;995端口（POP3S）&lt;/span&gt;：995端口是为POP3S（POP3-over-SSL）协议服务开放的，这是POP3协议基于SSL安全协议之上的一种变种协议，它继承了SSL安全协议的非对称加密的高度安全可靠性，可防止邮件泄露。POP3S和POP3协议一样，也是用来接收邮件的，只是更安全些，防止邮件被黑客截取泄露，还可实现邮件接收方抗抵赖功能。防止收件者收件之后删除已收邮件，拒不承认收到过这样一封邮件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;993端口（IMAPS）&lt;/span&gt;：993端口是为IMAPS（IMAP-over-SSL）协议服务开放的，这是IMAP协议基于SSL安全协议之上的一种变种协议，它继承了SSL安全协议的非对称加密的高度安全可靠性，可防止邮件泄露。IMAPS和IMAP协议一样，也是用来接收邮件的，只是更安全些，防止邮件被黑客截取泄露，还可实现邮件接收方抗抵赖功能。防止收件者收件之后删除已收邮件，拒不承认收到过这样一封邮件。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 16:29:00 +0000</pubDate>
<dc:creator>奶BerBer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LexMoon/p/javamail.html</dc:identifier>
</item>
<item>
<title>day25_day27_Struts2_学习回顾 - 黑泽明军</title>
<link>http://www.cnblogs.com/chenmingjun/p/9256538.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/9256538.html</guid>
<description>&lt;h2 class=&quot;wmd-preview-section preview-content&quot;&gt;&lt;strong&gt;day25_01_学习回顾&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt; 1、Struts2框架在三层架构中哪部分进行的再优化？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;34&quot;&gt;        表现层、MVC模式。&lt;p&gt;&lt;strong&gt;2、Struts1和Struts2的一个显著区别是什么？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;36&quot;&gt;        Struts1的核心控制器是一个servlet。&lt;br/&gt;        Struts2的核心控制器是一个过滤器。&lt;p&gt;&lt;strong&gt;3、Struts2的编写步骤？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;45&quot;&gt;        1、拷贝必要jar包到classpath中（即拷贝jar包到WebRoot/WEB-INF/lib中），原则是：用哪个拷贝哪个。&lt;br/&gt;        2、at the top of classpath（在最顶层的构建路径）,建立一个默认名称为struts.xml的配置文件。在struts.xml文件中进行配置。&lt;br/&gt;        3、在web.xml中配置控制器。&lt;br/&gt;        4、建立动作类和动作方法。&lt;br/&gt;        5、建立一个访问视图的.jsp文件和结果视图页面。&lt;p&gt;&lt;strong&gt;4、Struts2的执行过程？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;34&quot;&gt;        tomcat启动，加载应用的web.xml --&amp;gt; tomcat实例化并初始化过滤器 --&amp;gt; 加载struts.xml配置文件 --&amp;gt;&lt;span class=&quot;Apple-converted-space&quot; readability=&quot;2&quot;&gt; &lt;br/&gt;        客户浏览器发送请求：hello.action --&amp;gt; 请求到达过滤器 --&amp;gt; 截取请求的动作名称hello，并从struts.xml中查找 --&amp;gt;&lt;br/&gt;        找到后，实例化HelloAction动作类，每次都会创建新的实例 --&amp;gt; 调用对应的sayHello()动作方法，方法有返回值 --&amp;gt; 根据返回值找对应的结果视图 --&amp;gt; 找到结果jsp页面 --&amp;gt; 响应浏览器，展示结果&lt;p&gt;&lt;strong&gt;5、Struts2的配置文件加载时机和加载顺序？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;47&quot;&gt;        Struts2的配置文件的加载时机：当应用被tomcat加载的时候，struts2的配置文件就已经被加载过了。&lt;br/&gt;        Struts2的配置文件的加载顺序：default.properties --&amp;gt; struts-default.xml --&amp;gt; struts-plugin.xml --&amp;gt; struts.xml --&amp;gt; struts.properties --&amp;gt; web.xml&lt;br/&gt;                                                           存的是常量　　拦截器、结果视图、默认的动作类　　插件　　 我们自己写的　　一般不用它　　 我们自己写的&lt;p&gt;        加载文件的顺序必须是web.xml文件先加载的，读到了里面配置了一个Struts的核心控制器--过滤器，&lt;br/&gt;        然后该过滤器的init方法才去执行，它在执行的时候会初始化一些常量、拦截器、结果视图、默认的动作类、插件、配置的属性，给对应的属性赋值。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;6、常量中struts.devMode是什么意思，如何配置？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;35&quot;&gt;        是否是开发模式。开发模式：改了配置文件，不需要重启。输出更多的错误信息。开发阶段建议为true。&lt;br/&gt;        &lt;p&gt;&lt;strong&gt;7、struts.xml配置文件中package的四个属性分别什么意思？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;43&quot;&gt;        name属性：指定包的名称&lt;br/&gt;        extends属性：指定当前包的父包。&lt;br/&gt;        abstract属性：把包声明为一个抽象包。抽象包就是用来被继承的。只有没有元素的包，才能被定义为抽象包。&lt;br/&gt;        namespace属性：名称空间。当指定了名称空间之后，访问路径就变成了：访问路径 = 名称空间 + 动作名称&lt;p&gt;&lt;strong&gt;8、访问带有名称空间的动作时，是如何查找的？例如： /user/abc/action1.action&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;41&quot;&gt;        先找名称空间 /user/abc 找不到，就找 /user ，找不到，就找 / ,找不到，就报错&lt;br/&gt;        有 /user/abc ，再在当前包找动作名称，找不到，就找默认的名称空间中的动作名称，找不到，就报错，其余以此类推&lt;br/&gt;        找到了，就执行。&lt;p&gt;&lt;strong&gt;9、action元素的三个属性什么意思？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;38&quot;&gt;        name属性：动作的名称。&lt;br/&gt;        class属性：指定动作类，即动作类全名。&lt;br/&gt;        method属性：指定要执行的动作方法，即动作类中的方法名称。&lt;p&gt;&lt;strong&gt;10、result元素的两个属性分别指的是什么？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;36&quot;&gt;        name属性：结果视图名称。&lt;br/&gt;        type属性：结果视图类型。&lt;p&gt;&lt;strong&gt;11、4个常用结果类型分别是什么？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;40&quot;&gt;        dispatcher：请求转发 ，是默认值（本动作下）&lt;br/&gt;        redirect：请求重定向（本动作下）&lt;br/&gt;        chain：请求转发到另一个动作&lt;br/&gt;        redirectAction：请求重定向到另一个动作&lt;p&gt;&lt;strong&gt;12、访问ServletAPI的两种方式？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;        第一种方式：使用的是ServletActionContext的对象（此种方式简单明了，推荐此种方式）&lt;br/&gt;        第二种方式：使用的是 依赖注入 的形式，把我们想要的对象注入进来，是由一个 ServletConfigInterceptor的拦截器 为我们做的。需要实现3个接口，实现其中的方法。&lt;/p&gt;

&lt;h2 id=&quot;wmd-preview-section-43982&quot; class=&quot;wmd-preview-section preview-content&quot;&gt;&lt;strong&gt; day25_02_学习回顾&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1、如何封装静态请求参数？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;41&quot;&gt;        在 struts.xml 配置文件中，通过参数注入的方式，给动作类的参数注入值。相当于调用的是该参数的 setter 方法 。&lt;br/&gt;        是由默认的 拦截器栈 中的一个 拦截器staticParams 来完成参数注入的。&lt;br/&gt;        示例： 张三&lt;p&gt;&lt;strong&gt;2、动作类和模型分开的动态封装请求参数，set和get方法是怎么调用的？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;32&quot;&gt;        getXxx&lt;br/&gt;        setXxx&lt;br/&gt;        getXxx&lt;br/&gt;        或者&lt;br/&gt;        getXxx&lt;br/&gt;        getXxx&lt;p&gt;&lt;strong&gt;3、使用模型驱动，动态封装请求参数的要求是什么？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;42&quot;&gt;        要想使用模型驱动，前提：必须使动作类和数据模型分开写。&lt;br/&gt;            1、动作类需要实现一个ModelDriver的接口，注意：该接口需要写泛型。&lt;br/&gt;            2、实现接口中的抽象方法getmodel()。&lt;br/&gt;            3、在使用模型驱动的时候，数据模型必须由我们自己来实例化。&lt;p&gt;&lt;strong&gt;4、实际开发中类型转换的两种情况是什么？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;39&quot;&gt;        实际开发中用户通过浏览器输入的数据都是字符串String或者字符串数组String[]。&lt;br/&gt;        写数据：（增、删、改）是String或String[]转换为其他类型。&lt;br/&gt;        读数据：（查）是其他类型转换为String。&lt;p&gt;&lt;strong&gt;5、Struts2中提供的常用类型转换分几类？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;38&quot;&gt;        3类：&lt;br/&gt;        1、基本数据类型 自动转换&lt;br/&gt;        2、日期类型：默认按照 本地日期格式 转换成（yyyy-MM--dd）&lt;br/&gt;        3、字符串数组：默认用 逗号+空格 ，连接成一个字符串&lt;p&gt;&lt;strong&gt;6、自定义类型转换器是如何注册的？（两种情况）&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;52&quot;&gt;        1、局部类型转换器，按照 属性 来注册的。&lt;br/&gt;            在属性所属的javabean包下新建：&lt;br/&gt;                javabean名称-conversion.properties 文件&lt;br/&gt;                要转换的属性名称=类型装换器的全类名&lt;br/&gt;                示例：birthday=com.itheima.web.converter.MyTypeConverter&lt;br/&gt;        2、全局类型转换器，按照 要转换的数据类型 来注册的。&lt;br/&gt;            在顶层目录下新建：&lt;br/&gt;                xwork-conversion.properties 文件&lt;br/&gt;                要转换的数据类型=类型转换器的全类名&lt;br/&gt;                示例：java.util.Date=com.itheima.converter.MyTypeConverter&lt;p&gt;&lt;strong&gt;7、如何解决编程式验证使得动作类中的全部动作方法都验证？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;37&quot;&gt;        1、使用 @SkipValidation 注解。&lt;br/&gt;        2、重新定义验证方法的名称，格式为：validate+动作名称，动作名称的首字母要大写哦！&lt;p&gt;&lt;strong&gt;8、声明式验证的分别可以基于什么？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;36&quot;&gt;        1、基于字段的声明式验证：验证谁 --&amp;gt; 怎么验证 --&amp;gt; 验证结果&lt;br/&gt;        2、基于验证器的声明式验证：怎么验证 --&amp;gt; 验证谁 --&amp;gt; 验证结果&lt;p&gt;&lt;strong&gt;9、命名声明式验证xml文件名的两种方式，有什么不同？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;        通过编写 验证规则 的 xml文件 。需要验证时，编写xml文件，不要验证时，就不编写。&lt;br/&gt;        1、针对动作类中的 所有动作方法 进行验证：&lt;br/&gt;            在动作类所在的包中，建立一个 ActionClassName-validation.xml 的文件&lt;br/&gt;            示例：UserAction-validation.xml&lt;br/&gt;        2、针对动作类中的 某个动作方法 进行验证：&lt;br/&gt;            在动作类所在的包中建立一个 xml文件 ，名称为 ActionClassName-ActionName-validation.xml 注意：是动作名称，不是动作方法名称&lt;br/&gt;            示例：UserAction-register-validation.xml&lt;/p&gt;


&lt;h2 class=&quot;wmd-preview-section preview-content&quot;&gt;&lt;strong&gt;day26_学习回顾&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、国际化的消息资源文件如何命名？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;37&quot;&gt;        主要文件名_语言代码_国家代码.properties&lt;br/&gt;        主要文件名.properties（默认资源包）&lt;p&gt;&lt;strong&gt;2、Struts2中全局范围的资源包、包范围的资源包和动作类范围的资源包，哪个加载优先级高？页面上如何读取指定的消息资源包？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;42&quot;&gt;        全局范围的资源包：message_en_US.properties&lt;br/&gt;        包范围的资源包：package_zh_CN.properties&lt;br/&gt;        动作范围的资源包：Demo1Action_zh_CN.properties&lt;br/&gt;        动作类范围的资源包的优先级最高。&lt;br/&gt;        页面上使用标签  读取指定的消息资源包。&lt;p&gt;&lt;strong&gt;3、Struts2中拦截器的执行时机？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;36&quot;&gt;        执行动作方法之前，正序执行拦截器。&lt;br/&gt;        执行结果视图之后，到序执行拦截器。&lt;p&gt;&lt;strong&gt;4、自定义拦截器的步骤是什么？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;        a、编写一个普通类，继承AbstractInterceptor类 或者 实现Interceptor接口 。重写其抽象的intercept方法。&lt;br/&gt;        b、在struts.xml中配置拦截器，注意拦截器必须先声明、再使用。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;5、多个拦截器如何确定执行顺序？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;39&quot;&gt;        单个拦截器的执行顺序：拦截器 --&amp;gt; 动作方法 --&amp;gt; 结果视图 --&amp;gt; 拦截器 --&amp;gt; 浏览器响应页面&lt;br/&gt;        当有多个拦截器的时候，是由使用顺序决定执行顺序，与声明顺序无关。&lt;p&gt;&lt;strong&gt;6、自定义拦截器除了继承AbstractInterceptor还可以继承哪个？另一个有什么好处？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;38&quot;&gt;        还可以 继承MethodFilterInterceptor 并且 重写doIntercept方法。&lt;br/&gt;        好处：在struts的配置文件中，通过参数注入的方式，配置需要拦截哪些方法，和需要放过哪些方法。&lt;p&gt;&lt;strong&gt;7、文件上传是哪个拦截器为我们做的？如何限定上传文件的大小和类型？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;43&quot;&gt;        是fileupload拦截器。&lt;br/&gt;        限定上传文件的大小：&lt;br/&gt;            1、在struts.xml中改变default.properties文件中的常量。常量是：maxSize&lt;br/&gt;            2、给Struts2默认的拦截器栈中的fileUpload拦截器注入参数。（此法行不通）&lt;p&gt;&lt;strong&gt;8、struts2中文件下载是由哪个结果类型完成的？需要我们提供什么参数？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;        Stream结果类型完成的。&lt;br/&gt;        我们需要给Stream结果类型注入的参数是：&lt;br/&gt;            1、contextType：文件的MIME类型&lt;br/&gt;            2、contextDisposition：文件的下载方式&lt;br/&gt;            3、inputName：字节输入流&lt;br/&gt; &lt;br/&gt;&lt;strong&gt;9、OGNL是什么？使用它能否访问普通方法？能否直接访问静态方法？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;39&quot;&gt;        OGNL：对象图导航语言。&lt;br/&gt;        能访问。&lt;br/&gt;        不能直接访问，需要开启允许静态方法访问的开关。开关名为：allowStaticMethodAccess&lt;p&gt;&lt;strong&gt;10、ActionContext和ValueStack什么时候创建？是否是线程安全的？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;36&quot;&gt;        每次动作访问时，就会创建。多例，是线程安全的。&lt;br/&gt;        因为每次把数据绑定到了线程局部变量(ThreadLocal)上。&lt;p&gt;&lt;strong&gt;11、ContextMap中的结构是什么样的？&lt;/strong&gt;&lt;br/&gt;    答：&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;        Context Map是OGNL的上下文，里面有两大部分组成：ActionContext + ValueStack&lt;br/&gt;        是一个Map集合中封装多个Map结合。&lt;/p&gt;
&lt;div class=&quot;wmd-preview-section preview-content&quot; readability=&quot;52&quot;&gt;&lt;br/&gt;&lt;hr/&gt;&lt;h2 class=&quot;wmd-preview-section preview-content&quot;&gt;&lt;strong&gt;day27_学习回顾&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、ActionContext是什么结构？里面都有哪些数据？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;2、ActionContext是如何保证数据线程安全的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;3、ValueStack是什么结构？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;4、默认栈顶元素是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;5、ValueStack的setValue和set方法分别什么意思？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;6、Struts2中，EL表达式是如何查找数据的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;7、iterator标签中var属性有什么作用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;8、#，$，%分别都有什么作用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;9、使用url标签中添加param标签是什么意思？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;10、模型驱动是如何帮我们封装请求参数的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;11、在struts2中，如何防止表单重复提交?&lt;/strong&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;p class=&quot;wmd-preview-section preview-content&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 02 Jul 2018 15:59:00 +0000</pubDate>
<dc:creator>黑泽明军</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/9256538.html</dc:identifier>
</item>
<item>
<title>小程序预备课--初探小程序 - console.log-zdf</title>
<link>http://www.cnblogs.com/zdf-xue/p/9256525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zdf-xue/p/9256525.html</guid>
<description>&lt;p&gt;    最近公司在整一个小程序的项目，在此期间学习了下小程序的开发,在这跟大家分享下；&lt;/p&gt;
&lt;p&gt;    进入今天的主题;本文将分为三个部分为大家讲解；第一部分是&lt;span&gt;小程序跳转小程序&lt;/span&gt;，第二部分是&lt;span&gt;小程序跳转H5&lt;/span&gt;，第三部分是&lt;span&gt;H5跳转小程序&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;    小程序之间互相跳转，使用wx.navigateToMiniProgram来实现，官方文档：&lt;a title=&quot;小程序官方文档&quot; href=&quot;https://mp.weixin.qq.com/debug/wxadoc/dev/api/navigateToMiniProgram.html&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/debug/wxadoc/dev/api/navigateToMiniProgram.html&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wx.navigateToMiniProgram({
  appId: &lt;/span&gt;''&lt;span&gt;,//小程序id
  path: &lt;/span&gt;'pages/index/index?id=123'&lt;span&gt;,//小程序跳转路径
  extraData: {
    foo: &lt;/span&gt;'bar'&lt;span&gt;
  },
  envVersion: &lt;/span&gt;'develop'&lt;span&gt;,
  success(res) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开成功&lt;/span&gt;
&lt;span&gt;  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    你以为这样就完事了？当然不是！两个小程序之间的跳转是有条件的，&lt;span&gt;打开同一公众号下关联的另一个小程序。如果没有关联同一个公众号，则无法成功打开另一小程序&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;    在这里lz要插播一句，有关小程序关联的规则了：&lt;/p&gt;
&lt;p&gt;    1.所有公众号都可以关联小程序。&lt;/p&gt;
&lt;p&gt;    2.一个公众号可关联10个同主体的小程序，3个不同主体的小程序。&lt;/p&gt;
&lt;p&gt;    3.一个小程序可关联3个公众号。&lt;/p&gt;
&lt;p&gt;    4.公众号一个月可新增关联小程序13次，小程序一个月可新增关联5次。&lt;/p&gt;
&lt;p&gt;    万事俱备，就可以愉快的跳转了；&lt;/p&gt;
&lt;p&gt;    小程序跳转H5（用包裹H5更合适），这个之前是没有方法的，但是微信还是给我们一个惊喜，&amp;lt;web-view&amp;gt;，有没有感觉很熟悉；这个方法使用是很简单的，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- wxml --&amp;gt;
&amp;lt;!-- 指向微信公众平台首页的web-view --&amp;gt;
&amp;lt;web-view src=&quot;https://mp.weixin.qq.com/&quot;&amp;gt;&amp;lt;/web-view&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    只要填写答应的src就好了，确定？当然不是，这里注意点就是在微信小程序开发者后台会有个&lt;span&gt;业务域名&lt;/span&gt;，我们应该配置下页面所对应的域名，这样我们的页面就能包裹在了小程序里面了；小程序API里还给了一系列的方法：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1003440/201807/1003440-20180702233800801-585648408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;lz遇到的需求是h5跳转到不同域名的落地页；按照之前的思路配置不同业务域名，但是这根本行不通，因为我们会有特别多的落地页，而且微信也只是提供了每个月业务域名修改次数限制，所以得另行他法。这里lz的做法是用iframe去嵌套每个落地页，还真能行得通·~具体做法是：&lt;/p&gt;
&lt;p&gt;包裹的h5在跳转时利用wx.miniProgram.navigateTo跳转到一个redirect小程序页面这里用&amp;lt;web-view&amp;gt;包裹嵌套iframe的配置业务域名的页面；这样就能够解决问题了。&lt;/p&gt;
&lt;p&gt;    H5跳转小程序，看到这你肯定会差异，这怎么可能，其实是可以通过讨巧的办法进行的，通过我们的好朋友-公众号去实现，我们可以拿到公众号推文消息的url，先从H5直接跳转过去，然后就可以从推文消息进去了；(公众号的图文消息，菜单栏都是可以绑定跳转到小程序的)&lt;/p&gt;
&lt;p&gt;　初探小程序，后续更新开发部分，菜鸟一枚，一起探讨交流；&lt;/p&gt;

</description>
<pubDate>Mon, 02 Jul 2018 15:52:00 +0000</pubDate>
<dc:creator>console.log-zdf</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zdf-xue/p/9256525.html</dc:identifier>
</item>
<item>
<title>函数式编程介绍 - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/9256503.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/9256503.html</guid>
<description>&lt;p&gt;本文将描述函数式编程的基本理论，从而让你理解什么是函数式编程，同时也会展示“函数式编程”和“面向对象”这两种不同风格的编程范式之间的区别。本文是函数式编程系列的入门篇，后续文章陆续会发出。&lt;/p&gt;
&lt;h2 id=&quot;什么是函数&quot;&gt;什么是函数&lt;/h2&gt;
&lt;p&gt;函数式编程背后的理论依据是数学，数学函数背后有一系列有意思的特点，而函数式编程语言则试图模拟这些特性。&lt;br/&gt;让我们先来看一个简单的数学函数：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;y =  x + 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个数学函数的意图是显而易见的，给定一个变量x然后返回x + 1, 上面的数学函数用C#来表示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int Add1(int x)
{
    return x + 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数学函数跟我们用命令式语言编写的函数相比有两个明显的区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同一个输入在数学函数里总能得到相同的返回值&lt;/li&gt;
&lt;li&gt;数学函数没有副作用&lt;/li&gt;
&lt;li&gt;输入值和输出值是不变的(&lt;code&gt;immutable&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这三个区别具体是什么意思呢？&lt;/p&gt;
&lt;h2 id=&quot;同一个输入在数学函数里总能得到相同的返回值&quot;&gt;同一个输入在数学函数里总能得到相同的返回值&lt;/h2&gt;
&lt;p&gt;在命令式语言(imperative programming)中，我们总是在函数内部做一些计算和处理，然后返回最终结果。在数学函数中没有计算和处理，你可以认为数学函数的返回值是对输入值的一一映射。上面提到的数学函数极端定义如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int Add1(int x)
{ 
   switch (x)
   {
   case 0: return 1;
   case 1: return 2;
   case 2: return 3;
   case 3: return 4;
   //...
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然现实环境中我们不会写出这样的代码，但是数学函数的思想是类似的，里面没有对事情的处理逻辑。&lt;br/&gt;关于命令式语言和声明式语言的区别看这里：&lt;a href=&quot;https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-programming&quot;&gt;命令式语言和声明式语言的区别&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;数学函数没有副作用&quot;&gt;数学函数没有副作用&lt;/h2&gt;
&lt;p&gt;数学函数所做的事就是根据每一个输入返回不同的输出，整个过程没有对输入值做任何改变，在返回输出的过程中也没有对其他的任何环境造成影响，在函数式语言里这样的函数被称为&lt;code&gt;纯函数&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;输入值和输出值是不变的&quot;&gt;输入值和输出值是不变的&lt;/h2&gt;
&lt;p&gt;immutable使得代码更加具有预测性，考虑下面的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int Add1(int x)
{
    x = 2;
    return x + 1;
}

public void InvokeAdd1()
{
    var x = 10;
    var y = Add1(x);

    Console.WriteLine($&quot;x={x}, y={y}&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你试图在&lt;code&gt;Add1&lt;/code&gt;函数中实现&lt;code&gt;y = x + 1&lt;/code&gt;，但是由于失误将x的值改为了2，从而导致了一个bug，immutable则强制你无法修改x的值，一旦初始化就不能再修改。显然C#默认是mutable的，但在常见的函数式语言中，变量声明式immutable的，比如在F#中将x初始化为6然后再修改为7会编译出错：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let x = 6
x &amp;lt;- 7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作为一个修炼命令式语言多年的开发者也许会内心充满疑问，无法修改变量真的靠谱？答案是肯定的，在后面的文章中将会展示这种用法。&lt;/p&gt;
&lt;h2 id=&quot;纯函数带来的好处&quot;&gt;纯函数带来的好处&lt;/h2&gt;
&lt;p&gt;看似不起眼的三个特点实际上会带来非常强大的益处，所以函数式编程语言则试图把这三个特性带到他们的设计当中。&lt;/p&gt;
&lt;p&gt;得益于纯函数的这种特点，对同一个输入无论你重复调用多次，都会返回同样的结果，并且没有副作用，因此：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有的调用可以使并行的。 加入你想用1到10000之间的数字去调用Add1函数，你可以把这些计算过程分配到10个不同的CPU上并行执行，由于所有的调用都是没有副作用的，所以你不需要使用命令式语言中的锁机制就能完成任务；&lt;/li&gt;
&lt;li&gt;懒加载成为现实，你可以在真正需要结果的时候去执行计算，因为你可以保证在任何时刻对同一个输入返回的结果总是相同的&lt;/li&gt;
&lt;li&gt;你可以对函数的计算结果进行缓存，因为相同的输入总能得到相同的结果，所以可以轻而易举的对函数增减缓存功能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;后续文章即将发出，请想了解函数式编程的童鞋支持并关注。&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 15:43:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/9256503.html</dc:identifier>
</item>
<item>
<title>Python学习：12.Python字符串格式化 - BD-ld-2017</title>
<link>http://www.cnblogs.com/liudi2017/p/9256511.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liudi2017/p/9256511.html</guid>
<description>&lt;p&gt;&lt;span&gt;字符串格式化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　讲解Python这么久，也没有讲解Python的字符串的格式化，那我们今天就来了解一下python字符串格式化的强大之处。&lt;/p&gt;
&lt;p&gt;　　首先我们先理解一下为什么要有字符串的格式化，就是为了方便字符串的拼接，如果不使用格式化就需要使用+号，使用+号的方式连接多个字符串比较繁琐，为了简化python代码以及减少创建多个字符串需要占用的内存空间，所以我们选择使用字符串格式化。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符串格式化的两种方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　百分号方式和format方式，百分号方式比较老，而format方式是比较先进的，企图替代古老的方式，目前两者共存，接下来我们就针对这两种方式进行讲解。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1.百分号方式&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name: %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是使用百分号方式输出变量的简单写法，百分号方式内部还有很多可选参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    %&lt;span&gt;[(name)][flags][width].[precision]typecode
    (name)            可选，用于选择指定的key
    flags             可选，可供选择的值有如下:
            &lt;/span&gt;+&lt;span&gt;         右对齐；正数前加正好，负数前加负号；
            &lt;/span&gt;-&lt;span&gt;         左对齐；正数前无符号，负数前加负号；
            空格       右 对齐；正数前加空格，负数前加负号；
            0         右对齐；正数前无符号，负数前加负号；用0填充空白处&lt;br/&gt;width             可选，占有宽度
    .precision        可选，小数点后保留的位数
    typecode          必选，可用参数如下：
            s，获取传入对象的__str__方法的返回值，并将其格式化到指定位置
            r，获取传入对象的__repr__方法的返回值，并将其格式化到指定位置
            c，整数：将数字转换成其unicode对应的值，10进制范围为 0 &lt;/span&gt;&amp;lt;= i &amp;lt;= 1114111（py27则只支持0-255&lt;span&gt;）；字符：将字符添加到指定位置
            o，将整数转换成 八  进制表示，并将其格式化到指定位置
            x，将整数转换成十六进制表示，并将其格式化到指定位置
            d，将整数、浮点数转换成 十 进制表示，并将其格式化到指定位置
            e，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（小写e）
            E，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（大写E）
            f，将整数、浮点数转换成浮点数表示，并将其格式化到指定位置（默认保留小数点后6位）
            F，同上
            g，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是e；）
            G，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是E；）
    &lt;/span&gt;*        %，当字符串中存在格式化标志时，需要用 %%&lt;span&gt;表示一个百分号
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;字符串里有占位符时需要写两个%&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来就直接上示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am %s age %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baba&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,16&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
i am baba age &lt;/span&gt;16


&amp;gt;&amp;gt;&amp;gt; s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am %(n1)s age %(n2)d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:29&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
i am alexsel age &lt;/span&gt;29
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;为占位符设置名字&lt;/span&gt;


&amp;gt;&amp;gt;&amp;gt; s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am %(n1)s age %(n1)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
i am alexsel age alexsel


&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am %(n1)+10s age %(n1)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加十个空格&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
i am    alexsel age alexsel


&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am %(n1)010s age %(n1)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}&lt;span&gt;#&lt;/span&gt;&lt;span&gt;右对齐&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
i am    alexsel age alexsel


&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am %(n1)+010d age %(n1)d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:19}&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用0右对齐&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
i am &lt;/span&gt;+000000019 age 19


&amp;gt;&amp;gt;&amp;gt; s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am %.2f age &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (1.2)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;两位小数点f默认6位&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
i am &lt;/span&gt;1.20&lt;span&gt; age


&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am %c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (250) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;转为unicode码对应的符号&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
i am ú&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用格式化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am alex
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am %s age %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 18&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am alexsel age &lt;/span&gt;18
&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am %(name)s age %(age)d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am alexsel age &lt;/span&gt;18
&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;percent %.2f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % 99.97623
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
percent &lt;/span&gt;99.98
&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am %(pp).2f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 123.425556&lt;span&gt;, }
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am &lt;/span&gt;123.43
&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am %.2f %%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (123.425556&lt;span&gt;,)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am &lt;/span&gt;123.43 %
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面进行字符串格式化的时候使用了字典的方式，这种字典形式的字符串格式化方法，有一个最大的好处就是，字典这个东西可以和json文件相互转换，所以，当配置文件使用字符串设置的时候，就显得相当方便。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.format格式化&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;format格式化相对于百分号格式化功能更加强大，一个简单的示例之后，我们来看看它的可选参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
s = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name:{:s}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(s)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;format书写格式以及可选参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[[fill]align][sign][#][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;][width][,][.precision][type]
        fill             【可选】空白处填充的字符
        align            【可选】对齐方式（需配合width使用）
        &lt;/span&gt;&amp;lt;&lt;span&gt;，               内容左对齐
        &lt;/span&gt;&amp;gt;&lt;span&gt;，               内容右对齐(默认)
        ＝，              内容右对齐，将符号放置在填充字符的左侧，且只对数字类型有效。 即使：符号&lt;/span&gt;+填充物+&lt;span&gt;数字
        &lt;/span&gt;^&lt;span&gt;，               内容居中
        sign             【可选】有无符号数字
        &lt;/span&gt;+&lt;span&gt;，               正号加正，负号加负；
         &lt;/span&gt;-&lt;span&gt;，              正号不变，负号加负；
        空格 ，           正号空格，负号加负；
        #                【可选】对于二进制、八进制、十六进制，如果加上#，会显示 0b&lt;/span&gt;/0o/&lt;span&gt;0x，否则不显示
        ，               【可选】为数字添加分隔符，如：&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;000&lt;/span&gt;,&lt;span&gt;000&lt;/span&gt;&lt;span&gt;
        width            【可选】格式化位所占宽度
        .precision       【可选】小数位保留精度
        type             【可选】格式化类型      &lt;/span&gt;***********&lt;span&gt;#在以下格式化前需加：
        传入” 字符串类型 “的参数
        s，                格式化字符串类型数据
        空白，            未指定类型，则默认是None，同s
        传入“ 整数类型 ”的参数
        b，                将10进制整数自动转换成2进制表示然后格式化
        c，                将10进制整数自动转换为其对应的unicode字符
        d，                十进制整数
        o，                将10进制整数自动转换成8进制表示然后格式化；
        x，                将10进制整数自动转换成16进制表示然后格式化（小写x）
        X，                将10进制整数自动转换成16进制表示然后格式化（大写X）
        传入“ 浮点型或小数类型 ”的参数
        e，             转换为科学计数法（小写e）表示，然后格式化；
        E，             转换为科学计数法（大写E）表示，然后格式化;
        f ，            转换为浮点型（默认小数点后保留6位）表示，然后格式化；
        F，             转换为浮点型（默认小数点后保留6位）表示，然后格式化；
        g，             自动在e和f中切换
        G，             自动在E和F中切换
        %，             显示百分比（默认显示小数点后6位）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用格式化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;143&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am {}, age {}, {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 18, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am seven, age &lt;/span&gt;18&lt;span&gt;, alex


&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am {}, age {}, {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(*[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 18, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am seven, age &lt;/span&gt;18&lt;span&gt;, alex


&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am {0}, age {1}, really {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 18&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am seven, age &lt;/span&gt;18&lt;span&gt;, really seven


&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am {0}, age {1}, really {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(*[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 18&lt;span&gt;])
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am seven, age &lt;/span&gt;18&lt;span&gt;, really seven


&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am {name}, age {age}, really {name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age=18&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am seven, age &lt;/span&gt;18&lt;span&gt;, really seven


&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am {name}, age {age}, really {name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(**{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ag&lt;/span&gt;
e&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 18})&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am seven, age &lt;/span&gt;18&lt;span&gt;, really seven


&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am {0[0]}, age {0[1]}, really {0[2]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format([1, 2, 3], [11, 22, 33&lt;span&gt;
])
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am &lt;/span&gt;1, age 2, really 3


&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am {:s}, age {:d}, money {:f}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 18, 88888.1&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am seven, age &lt;/span&gt;18, money 88888.100000


&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am {:s}, age {:d}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(*[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 18&lt;span&gt;])
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am seven, age &lt;/span&gt;18


&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am {name:s}, age {age:d}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age=18&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am seven, age &lt;/span&gt;18


&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i am {name:s}, age {age:d}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(**{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 18&lt;span&gt;})
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
i am seven, age &lt;/span&gt;18


&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numbers: {:b},{:o},{:d},{:x},{:X}, {:%}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(15, 15, 15, 15, 15, 1
5.87623, 2&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
numbers: &lt;/span&gt;1111,17,15,f,F, 1587.623000%


&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numbers: {:b},{:o},{:d},{:x},{:X}, {:%}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(15, 15, 15, 15, 15, 1
5.87623, 2&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
numbers: &lt;/span&gt;1111,17,15,f,F, 1587.623000%


&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numbers: {0:b},{0:o},{0:d},{0:x},{0:X}, {0:%}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(15&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
numbers: &lt;/span&gt;1111,17,15,f,F, 1500.000000%


&amp;gt;&amp;gt;&amp;gt; tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numbers: {num:b},{num:o},{num:d},{num:x},{num:X}, {num:%}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(num
&lt;/span&gt;=15&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tpl)
numbers: &lt;/span&gt;1111,17,15,f,F, 1500.000000%
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种格式使用起来都比较方便，但是我们可以选择功能比较强大的format进行学习，format字符串格式化主要使用的参数需要我们重点记忆。&lt;/p&gt;

</description>
<pubDate>Mon, 02 Jul 2018 15:43:00 +0000</pubDate>
<dc:creator>BD-ld-2017</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liudi2017/p/9256511.html</dc:identifier>
</item>
<item>
<title>TensorFlow学习笔记（六）循环神经网络 - 左手十字</title>
<link>http://www.cnblogs.com/zuoshoushizi/p/9243691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuoshoushizi/p/9243691.html</guid>
<description>


&lt;h2&gt;一、循环神经网络简介&lt;/h2&gt;
&lt;p&gt;　　循环神经网络的主要用途是处理和预测序列数据。循环神经网络刻画了一个序列当前的输出与之前信息的关系。从网络结构上，循环神经网络会记忆之前的信息，并利用之前的信息影响后面节点的输出。&lt;/p&gt;
&lt;p&gt;下图展示了一个典型的循环神经网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180629132602282-2091067140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;循环神经网络的一个重要的概念就是时刻。上图中循环神经网络的主体结构A的输入除了来自输入层的Xt，还有一个自身当前时刻的状态St。&lt;/p&gt;
&lt;p&gt;在每一个时刻，A会读取t时刻的输入Xt，并且得到一个输出Ht。同时还会得到一个当前时刻的状态St，传递给下一时刻t+1。&lt;/p&gt;
&lt;p&gt;因此，循环神经网络理论上可看作同一神经结构被无限重复的过程。（无限重复目前还是不可行的）&lt;/p&gt;
&lt;p&gt;将循环神经网络按照时间序列展开，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180629133843095-897160849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; xt是t时刻的输入&lt;/p&gt;
&lt;p&gt;St是t时刻的“记忆”，St = f（WSt-1 + Uxt），f是tanh等激活函数&lt;/p&gt;
&lt;p&gt;Ot 是t时刻的输出&lt;/p&gt;
&lt;p&gt;下图给出一个最简单的循环体或者叫记忆体的结构图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180629135559230-329735656.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图展示了一个循环神经网络的前向传播算法的具体计算过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180629135821543-1058634546.png&quot; alt=&quot;&quot; width=&quot;540&quot; height=&quot;321&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在得到前向传播计算结果之后，可以和其他网络类似的定义损失函数。神经网络的唯一区别在于它每一个时刻都有一个输出，所以循环神经网络的总损失为前面所有时刻的损失函数的总和。&lt;/p&gt;
&lt;p&gt;我们利用代码来实现这个简单的前向传播过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

X &lt;/span&gt;= [1,2&lt;span&gt;]
state &lt;/span&gt;= [0.0,0.0&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义不同输入部分的权重&lt;/span&gt;
w_cell_state = np.asarray([[0.1,0.2],[0.3,0.4&lt;span&gt;]])
w_cell_input &lt;/span&gt;= np.asarray([0.5,0.6&lt;span&gt;])
b_cell &lt;/span&gt;= np.asarray([0.1,-0.1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义输出层的权重&lt;/span&gt;
w_output = np.asarray([[0.1],[0.2&lt;span&gt;]])
b_output &lt;/span&gt;= 0.1
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;按照时间顺序执行循环神经网络的前向传播过程&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(X)):
    before_activetion &lt;/span&gt;= np.dot(state,w_cell_state) + X[i] * w_cell_input +&lt;span&gt; b_cell
    state &lt;/span&gt;=&lt;span&gt; np.tanh(before_activetion)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算当前时刻的最终输出&lt;/span&gt;
    final_output = np.dot(state,w_output) +&lt;span&gt; b_output
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出每一时刻的信息&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;before_activation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,before_activetion)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;state&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,state)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;final_output&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,final_output)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;二、长短时记忆网络（LSTM）结构&lt;/h2&gt;
&lt;p&gt;循环神经网络工作的关键点就是使用历史的信息来帮助当前的决策。循环神经网络能很好的利用传统的神经网络不能建模的信息，但同时，也带来了更大的挑战——长期依赖的问题。&lt;/p&gt;
&lt;p&gt;　　在有些问题中，模型仅仅需要短期内的信息来执行当前的任务。但同时也会有一些上下文场景更加复杂的情况。当间隔不断增大时，简单的循环神经网络可能会丧失学习到如此远的信息的能力。或者在复杂的语言场景中，有用的信息的间隔有大有小，长短不一，循环神经网络的性能也会受限。&lt;/p&gt;
&lt;p&gt;　　为了解决这类问题，设计了LSTM。与单一tanh循环结构不同，LSTM拥有三个门：“输入门”、“输出门”、“遗忘门”。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180630154235185-1750123778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180630154449226-2017305431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　LSTM靠这些“门”的结构信息有选择的影响循环神经网络中每个时刻的状态。所谓的“门”就是一个sigmod网络和一个按位做乘法的操作。当sigmod输出为1时，全部信息通过；为0时，信息无法通过。为了使循环神经网络更有效的保持长期记忆。“遗忘门“和”输入门”就至关重要。“遗忘门”就是让神经网络忘记之前没有用的信息。从当前的输入补充新的“记忆”是“输入门”作用。&lt;/p&gt;
&lt;p&gt;使用LSTM结构的循环神经网络的前向传播时一个比较复杂的计算过程。在TensorFlow中可以被很简单的实现。例如下面的伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义一个LSTM结构。TF通过一句简单的命令就可以定义一个LSTM循环体&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;LSTM中使用的变量也会自动声明&lt;/span&gt;
&lt;span&gt;
lstm &lt;/span&gt;=&lt;span&gt; tf.nn.rnn_cell.BasicLSTMCell(lstm_hidden_size)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将LSTM中的状态初始化问哦全0数组。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;BasicLSTMCell类提供了zero_state函数来生成全0 的初始状态&lt;/span&gt;
state =&lt;span&gt; lstm.zero_state(batch_size,tf.float32)
current_input &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义损失函数&lt;/span&gt;
loss = 0.0
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;虽然rnn理论上可以处理任意长度的序列，但是在训练时为了避免梯度消散的问题，会规定一个最大的循环长度num_temps&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_temps):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在第一个时刻声明LSTM结构中使用的变量，在之后的时刻都需要服用之前的定义好的变量。&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; i &amp;gt;&lt;span&gt; 0:
        tf.get_variable_scope().reuse_variables()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;每一步处理时间序列中的一个时刻&lt;/span&gt;
    lstm_output,state =&lt;span&gt; lstm(current_input,state)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将当前时刻LSTM结构的输出传入一个全连接层得到最后的输出&lt;/span&gt;
    final_output =&lt;span&gt; full_connected(lstm_output)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算当前时刻的输出的损失&lt;/span&gt;
    loss +=&lt;span&gt; calc_loss(final_output,expected_output)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;利用BP后向传播算法训练模型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、循环神经网络的变种&lt;/p&gt;
&lt;p&gt;1、双向循环神经网络和深层循环神经网络&lt;/p&gt;
&lt;p&gt;在经典的循环神经网络中，状态的传输时从前向后单向的。然而，在有些问题中，当前时刻的输出不仅和之前的状态有关，也和之后的转台有关。只是后就需要使用双向循环神经网络来解决此类问题。双向循环神经网络时由连个神经网络上下叠加在一起组成的。输出有这两个神经网络的转台共同决定的。下图展示了一个双向循环神经网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180630224936664-1664356469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;深层循环神经网络是循环神经网络的另外一种变体。为了增强模型的表达能力，可以将每一时刻上的循环体重复多次。深层循环神经网络在每一时刻上将循环体结构重复了多次。 每一层循环体中的参数是一致的，不同层的循环体参数可以不一致。TF提供了MultiRNNCell类来实现深层循环神经网络的前向传播过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180630230531884-2064172812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义一个基本的LSTM结构作为循环体的基础结构，深层循环神经网络也可以支持其他的循环提结构&lt;/span&gt;
lstm =&lt;span&gt; tf.nn.rnn_cell.BasicLSTMCell(lstm_size)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过MultiRNNCell类来实现深层循环神经网络中每一时刻的前向传播过程。其中。number_of_layers 表示了有多少层，也就是图&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;中从xi到hi需要经过多少个LSTM结构。&lt;/span&gt;
stacked_lstm = tf.nn.rnn_cell.MultiRNNCell([lstm]*&lt;span&gt;number_of_layers)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;和经典神经网络一样，可以通过zero_state函数获得初始状态。&lt;/span&gt;
state =&lt;span&gt; stacked_lstm.zero_state(batch_size,tf.float32)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算每一时刻的前向传播过程&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_steps):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i &amp;gt;&lt;span&gt; 0:
        tf.get_variable_scope().reuse_variables()
    stacked_lstm_output  ,state &lt;/span&gt;=&lt;span&gt; stacked_lstm(current_input,state)
    final_output &lt;/span&gt;=&lt;span&gt;  fully_connected(stacked_lstm_output)
    loss &lt;/span&gt;+=&lt;span&gt; calc_loss(final_output,expected_output)
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、循环神经网络的dropout&lt;/p&gt;
&lt;p&gt;　　dropout可以样循环神经网络更加的健壮。dropout一般只在不同层循环体之间使用。也就是说从t-1时刻传递到时刻t，RNN不会进行状态的dropout，而在同一时刻t，不同层循环体之间会使用dropout。&lt;/p&gt;
&lt;p&gt;在TF中，使用tf.nn.rnn_cell.DropoutWrapper类可以很容易实现dropout功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义LSTM结构&lt;/span&gt;
lstm  =&lt;span&gt; tf.nn.rnn_cell.BasicLSTMCell(lstm_size)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过DropoutWrapper来实现dropout功能。input_keep_drop参数用来控制输入的dropout的概率，output_keep_drop参数用来控制输出的dropout的概率，&lt;/span&gt;
dropout_lstm = tf.nn.rnn_cell.DropoutWrapper(lstm,input_keep_prob=0.5,output_keep_prob=0.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在使用了dropout的基础上定义深层RNN&lt;/span&gt;
stacked_lstm = tf.nn.rnn_cell.MultiRNNCell([dropout_lstm]* 5)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;四、循环神经网络的样例应用&lt;/p&gt;
&lt;p&gt;1、自然语言建模&lt;/p&gt;
&lt;p&gt;　　简单的说，语言模型的目的就是为了计算一个句子的出现概率。在这里把句子看成单词的序列S = （w1,w2,w3....wm），其中m为句子的长度，它的概率可以表示为&lt;/p&gt;
&lt;p&gt;P（S） = p（w1，w2,w3.....wm） = p(w1)p(w2|w1)p(w3|w1,w2)p(wm| w1,w2...wm)&lt;/p&gt;
&lt;p&gt;等式右边的每一项都是语言模型中的一个参数。为了估计这些参数的取值，常用的方法有n-gram、决策树、最大熵模型、条件随机场、神经网络模型。&lt;/p&gt;
&lt;p&gt;　　语言模型效果的好坏的常用的评价指标是复杂度（perplexity）。简单来说，perplexity刻画的就是通过某一语言模型估计一句话出现的概率。值越小越好。复杂度的计算公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201807/1224905-20180701120747752-398278763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面就利用语言模型来处理PTB数据集。&lt;/p&gt;
&lt;p&gt;为了让PTB数据集使用更方便，TF提供了两个函数来预处理PTB数据集。ptb_raw_data用来读取原始数据，并将原始数据的单词转化为单词ID，形成一个非常长的序列。ptb_iterator将序列按照某固定的长度来截断，并将数据组成batch。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用循环神经网络实现语言模型&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;111&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.models.rnn.ptb &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reader
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.contrib.legacy_seq2seq &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sequence_loss_by_example
DATA_PATH &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;path/to/ptb/data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
HIDDEN_SIZE &lt;/span&gt;= 200 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;隐藏层的规模&lt;/span&gt;
NUM_LAYERS = 2 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;DRNN中LSTM结构的层数&lt;/span&gt;
VOCAB_SIZE = 10000 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;词典规模，加上语句结束符和稀有单词结束符总共10000&lt;/span&gt;
LEARNING_RATE = 1.0&lt;span&gt;
TRAIN_BATCH_SIZE &lt;/span&gt;= 20  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练数据BATCH大小&lt;/span&gt;
TRAIN_NUM_STEPS = 35    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练数据截断长度&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;在测试的时候不需要使用截断&lt;/span&gt;
EVAL_BATCH_SIZE = EVAL_NUM_STEP = 1&lt;span&gt;
NUM_EPOCH &lt;/span&gt;= 2 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用训练数据的轮数&lt;/span&gt;
KEEP_DROP =0.5 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;节点不被dropout的概率&lt;/span&gt;
MAX_GRAD_NORM =5 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用于控制梯度膨胀的参数&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义一个PTBMODEL类来描述模型，方便维护循环神经网络中的状态&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PTBMODEL:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,batch_size,num_steps,is_training =&lt;span&gt; True):
        self.batch_size &lt;/span&gt;=&lt;span&gt; batch_size
        self.num_steps &lt;/span&gt;=&lt;span&gt; num_steps
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义输入层，维度为batch_size* num_steps&lt;/span&gt;
        self.input_data = tf.placeholder(tf.int32,shape=&lt;span&gt;[batch_size,num_steps])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义预期输出。它的维度和ptb_iterrattor输出的正确答案维度是一样的。&lt;/span&gt;
        self.targets =&lt;span&gt; tf.placeholder(tf.int32,[batch_size,num_steps])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义使用LSTM结构为循环体结构且使用dropout的深层循环神经网络&lt;/span&gt;
        lstm_cell =&lt;span&gt; tf.nn.rnn_cell.BasicLSTMCell(HIDDEN_SIZE)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; is_training:
            lstm_cell &lt;/span&gt;= tf.nn.rnn_cell.DropoutWrapper(lstm_cell,output_keep_prob=&lt;span&gt;KEEP_DROP)
        cell &lt;/span&gt;=&lt;span&gt; tf.nn.rnn_cell.MultiRNNCell(lstm_cell)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化初始状态&lt;/span&gt;
        self.initial_state =&lt;span&gt; cell.zero_state(batch_size,tf.float32)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将单词ID转换为单词向量，总共有VOCAB_SIZE个单词，每个单词向量的维度为HIDDEN_SIZE，所以embedding参数的维度为&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;VOCAB_SIZE*HIDDEN_SIZE&lt;/span&gt;
        embedding = tf.get_variable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;embedding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,[VOCAB_SIZE,HIDDEN_SIZE])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将原本batch_size * num_steps个单词ID转化为单词向量，转化后的输入层维度为batch_size * num_steps * HIDDEN_SIZE&lt;/span&gt;
        inputs =&lt;span&gt; tf.nn.embedding_lookup(embedding,self.input_data)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;只在训练时使用dropout&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; is_training:
            inputs  &lt;/span&gt;=&lt;span&gt; tf.nn.dropout(inputs,KEEP_DROP)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义输出列表，在这里现将不同时刻LSTM结构的输出收集起来，再通过一个全连接层得到最终输出&lt;/span&gt;
        output =&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;state 存储不同batch中LSTM的状态，并且初始化为0.&lt;/span&gt;
        state =&lt;span&gt; self.initial_state
        with tf.variable_scope(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RNN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; time_step  &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_steps):
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; time_step &amp;gt;&lt;span&gt; 0 :
                    tf.get_variable_scope().reuse_variables()
                cell_output,state &lt;/span&gt;=&lt;span&gt; cell(inputs[:,time_step,:],state)
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将当前输出加入输出队列&lt;/span&gt;
&lt;span&gt;                output.append(cell_output)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;把输出队列展开成[batch,hidden_size*num_steps]的形状，然后再reshape成【batch*num_steps,hidden_size】的形状。&lt;/span&gt;
        output = tf.reshape(tf.concat(output,1),[-1&lt;span&gt;,HIDDEN_SIZE])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将从LSTM中得到的输出再经过一个全连接层得到最后的预测结果，最终的预测结果在每一时刻上都是一个长度为VOCAB_SIZE的数组&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;经过SoftMax层之后表示下一个位置是不同单词的概率。&lt;/span&gt;
        weight = tf.get_variable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;weight&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,[HIDDEN_SIZE,VOCAB_SIZE])
        baias  &lt;/span&gt;=  tf.get_variable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bias&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,[VOCAB_SIZE])
        logits &lt;/span&gt;= tf.matmul(output,weight) +&lt;span&gt; baias
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义交叉熵损失函数&lt;/span&gt;
        loss  = sequence_loss_by_example([logits],[tf.reshape(self.targets,[-1&lt;span&gt;])],
                                                                   [tf.ones([batch_size&lt;/span&gt;*num_steps],dtype=&lt;span&gt;tf.float32)]
                                                                   )
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算得到每个batch的平均损失&lt;/span&gt;
        self.cost = tf.reduce_sum(loss)/&lt;span&gt;batch_size
        self.final_state &lt;/span&gt;=&lt;span&gt; state
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;只在训练模型是定义反向传播操作&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; is_training:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;

        trainable_variables &lt;/span&gt;=&lt;span&gt; tf.trainable_variables()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过clip_by_global_norm函数控制梯度的大小，避免梯度膨胀的问题&lt;/span&gt;
        grads,_ =&lt;span&gt; tf.clip_by_global_norm(tf.gradients(self.cost,trainable_variables),MAX_GRAD_NORM)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义优化方法&lt;/span&gt;
        optimizer =&lt;span&gt; tf.train.GradientDescentOptimizer(LEARNING_RATE)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义训练步骤&lt;/span&gt;
        self.train_op =&lt;span&gt; optimizer.apply_gradients(zip(grads,trainable_variables))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用给定的模型model在数据data上运行train_op并返回全部数据上的perplexity值&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run_epoch(session,model,data,train_op,output_log):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算perplexity的辅助变量&lt;/span&gt;
    total_costs = 0.0&lt;span&gt;
    iters &lt;/span&gt;=&lt;span&gt; 0
    state &lt;/span&gt;=&lt;span&gt; session.run(model.initial_state)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用当前数据训练或者测试模型&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; step ,(x,y) &lt;span&gt;in&lt;/span&gt;&lt;span&gt;  enumerate(reader.ptb_iterator( data,model.batch_size,model.num_steps)):
        cost,state,_ &lt;/span&gt;=&lt;span&gt; session.run([model.cost,model.final_output,model.train_op],{
            model.input_data:x,model.targets:y,
            model.initial_state:state
        })
        total_costs &lt;/span&gt;+=&lt;span&gt; cost
        iters &lt;/span&gt;+=&lt;span&gt; model.num_steps
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;只有在训练时输出日志&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; output_log &lt;span&gt;and&lt;/span&gt; step % 100 ==&lt;span&gt; 0:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;After %s steps ,perplexity is %.3f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(step,np.exp(total_costs/&lt;span&gt;iters)))

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回给定模型在给定数据上的perplexity&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; np.exp(total_costs/&lt;span&gt;iters)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(_):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取原始数据&lt;/span&gt;
    train_data,valid_data,test_data =&lt;span&gt; reader.ptb_raw_data(DATA_PATH)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义初始化函数&lt;/span&gt;
    initializer = tf.random_uniform_initializer(-0.05,0.05&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义训练用的循环神经网络模型&lt;/span&gt;
    with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;language_model&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,reuse=True,initializer=&lt;span&gt;initializer):
        train_model &lt;/span&gt;= PTBMODEL(TRAIN_BATCH_SIZE,TRAIN_NUM_STEPS,is_training=&lt;span&gt;True)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义评估用的循环神经网络模型&lt;/span&gt;
    with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;language_model&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,reuse=True,initializer=&lt;span&gt;initializer):
        eval_model &lt;/span&gt;= PTBMODEL(EVAL_BATCH_SIZE,EVAL_NUM_STEP,is_training=&lt;span&gt;False)
    with tf.Session() as sess:
        tf.global_variables_initializer().run()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用训练数据训练模型&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(NUM_EPOCH):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;In iteration:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(i+1&lt;span&gt;))
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在所有训练数据上训练RNN&lt;/span&gt;
&lt;span&gt;            run_epoch(sess,train_model,train_data,train_model.train_op,True)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用验证集评测模型效果&lt;/span&gt;
            valid_perplexity =&lt;span&gt; run_epoch(sess,eval_model,valid_data,tf.no_op(),False)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Epoch %s ,Validation perplexity :%.3f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(i+1&lt;span&gt;,valid_perplexity))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最后使用测试集验证模型效果&lt;/span&gt;
        test_perplexity =&lt;span&gt; run_epoch(sess,eval_model,valid_data,tf.no_op(),False)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TEST perplexity :%.3f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(test_perplexity))

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    tf.app.run()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 四、时间序列预测&lt;/p&gt;
&lt;p&gt; 　　怎么用循环神经网络来预测正弦函数，可利用TF的高级封装--TFLearn.&lt;/p&gt;
&lt;p&gt;　　1、使用TFLearn自定义模型&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn  &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cross_validation
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; datasets
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; metrics
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.contrib.learn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models,Estimator,SKCompat
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.contrib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; layers,framework
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入TFLearn&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;自定义模型，对于给定的输入数据以及其对应的正确答案，返回在这些输入上的预测值、损失值以及训练步骤&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; my_model(feature,target):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将预测的模型转换为one-hot编码的形式，因为共有三个类别，所以向量长度为3.经过转化后，三个个类别（1，0，0），（0，1，0），（0，0，1）&lt;/span&gt;
    target = tf.one_hot(target,3,1&lt;span&gt;,0)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义模型以及其在给定数据上的损失函数。TFLearn通过logistic_regression封装了一个单层全链接神经网络&lt;/span&gt;
    logits,loss =&lt;span&gt; models.logistic_regression(feature,target)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建模型的优化器，并得到优化步骤&lt;/span&gt;
    train_op = layers.optimize_loss(loss,   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;损失函数&lt;/span&gt;
                                    framework.get_global_step(), &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取训练步数并在训练时更新&lt;/span&gt;
                                    optimizer=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Adagrad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义优化器&lt;/span&gt;
                                    learning_rate=0.1 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义学习率&lt;/span&gt;
&lt;span&gt;                                    )
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回在给定数据上的预测结果、损失值以及优化步骤&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; tf.argmax(logits,1&lt;span&gt;) ,loss,train_op

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加载iris数据集，并划分为训练集合和测试集合&lt;/span&gt;
iris  =&lt;span&gt; datasets.load_iris()
x_train,x_test,y_train,y_test &lt;/span&gt;= cross_validation.train_test_split(iris.data,iris.target,test_size=0.2,random_state=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对自定义的模型进行封装&lt;/span&gt;
classifier =Estimator(model_fn=&lt;span&gt;my_model)
classifier &lt;/span&gt;=&lt;span&gt; SKCompat(classifier)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用封装好的模型和训练数据执行100轮的迭代&lt;/span&gt;
classifier.fit(x_train,y_train,steps=100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用训练好的模型进行预测&lt;/span&gt;
y_predicted =&lt;span&gt; classifier.predict(x_test)



&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算模型的准确度&lt;/span&gt;
score  =&lt;span&gt; metrics.accuracy_score(y_test,y_predicted)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Accuracy: %.2f %%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(score * 100))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、预测正选函数&lt;/p&gt;
&lt;p&gt;　　因为标准的RNN预测的是离散值，所以程序需要将连续的sin函数曲线离散化。&lt;/p&gt;
&lt;p&gt;　　每个SAMPLE_ITERVAL对sin函数进行一次采样，采样得到的序列就是sin函数离散化之后的结果&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib as mpl
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot as plt
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.contrib.learn.python.learn.estimators.estimator &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SKCompat

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; TensorFlow的高层封装TFLearn&lt;/span&gt;
learn =&lt;span&gt; tf.contrib.learn

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 神经网络参数&lt;/span&gt;
HIDDEN_SIZE = 30  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; LSTM隐藏节点个数&lt;/span&gt;
NUM_LAYERS = 2  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; LSTM层数&lt;/span&gt;
TIMESTEPS = 10  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 循环神经网络截断长度&lt;/span&gt;
BATCH_SIZE = 32  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; batch大小&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据参数&lt;/span&gt;
TRAINING_STEPS = 3000  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 训练轮数&lt;/span&gt;
TRAINING_EXAMPLES = 10000  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 训练数据个数&lt;/span&gt;
TESTING_EXAMPLES = 1000  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 测试数据个数&lt;/span&gt;
SAMPLE_GAP = 0.01  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 采样间隔&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; generate_data(seq):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 序列的第i项和后面的TIMESTEPS-1项合在一起作为输入，第i+TIMESTEPS项作为输出&lt;/span&gt;
    X =&lt;span&gt; []
    y &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(seq) - TIMESTEPS - 1&lt;span&gt;):
        X.append([seq[i:i &lt;/span&gt;+&lt;span&gt; TIMESTEPS]])
        y.append([seq[i &lt;/span&gt;+&lt;span&gt; TIMESTEPS]])
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; np.array(X, dtype=np.float32), np.array(y, dtype=&lt;span&gt;np.float32)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; LSTM结构单元&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; LstmCell():
    lstm_cell &lt;/span&gt;=&lt;span&gt; tf.contrib.rnn.BasicLSTMCell(HIDDEN_SIZE)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lstm_cell


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; lstm_model(X, y):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用多层LSTM，不能用lstm_cell*NUM_LAYERS的方法，会导致LSTM的tensor名字都一样&lt;/span&gt;
    cell = tf.contrib.rnn.MultiRNNCell([LstmCell() &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(NUM_LAYERS)])

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将多层LSTM结构连接成RNN网络并计算前向传播结果&lt;/span&gt;
    output, _ = tf.nn.dynamic_rnn(cell, X, dtype=&lt;span&gt;tf.float32)
    output &lt;/span&gt;= tf.reshape(output, [-1&lt;span&gt;, HIDDEN_SIZE])

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过无激活函数的全联接层计算线性回归，并将数据压缩成一维数组的结构&lt;/span&gt;
    predictions = tf.contrib.layers.fully_connected(output, 1&lt;span&gt;, None)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将predictions和labels调整为统一的shape&lt;/span&gt;
    y = tf.reshape(y, [-1&lt;span&gt;])
    predictions &lt;/span&gt;= tf.reshape(predictions, [-1&lt;span&gt;])

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算损失值&lt;/span&gt;
    loss =&lt;span&gt; tf.losses.mean_squared_error(predictions, y)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建模型优化器并得到优化步骤&lt;/span&gt;
    train_op =&lt;span&gt; tf.contrib.layers.optimize_loss(
        loss,
        tf.train.get_global_step(),
        optimizer&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Adagrad&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        learning_rate&lt;/span&gt;=0.1&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; predictions, loss, train_op


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用sin生成训练和测试数据集&lt;/span&gt;
test_start = TRAINING_EXAMPLES *&lt;span&gt; SAMPLE_GAP
test_end &lt;/span&gt;= (TRAINING_EXAMPLES + TESTING_EXAMPLES) *&lt;span&gt; SAMPLE_GAP
train_X, train_y &lt;/span&gt;=&lt;span&gt; generate_data(
    np.sin(np.linspace(0, test_start, TRAINING_EXAMPLES, dtype&lt;/span&gt;=&lt;span&gt;np.float32)))
test_X, test_y &lt;/span&gt;=&lt;span&gt; generate_data(
    np.sin(
        np.linspace(test_start, test_end, TESTING_EXAMPLES, dtype&lt;/span&gt;=&lt;span&gt;np.float32)))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 建立深层循环网络模型&lt;/span&gt;
regressor = SKCompat(learn.Estimator(model_fn=lstm_model, model_dir=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;model/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用fit函数训练模型&lt;/span&gt;
regressor.fit(train_X, train_y, batch_size=BATCH_SIZE, steps=&lt;span&gt;TRAINING_STEPS)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用训练好的模型对测试集进行预测&lt;/span&gt;
predicted = [[pred] &lt;span&gt;for&lt;/span&gt; pred &lt;span&gt;in&lt;/span&gt;&lt;span&gt; regressor.predict(test_X)]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算rmse作为评价指标&lt;/span&gt;
rmse = np.sqrt(((predicted - test_y)**2).mean(axis=&lt;span&gt;0))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mean Square Error is: %f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (rmse[0]))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对预测曲线绘图，并存储到sin.jpg&lt;/span&gt;
fit =&lt;span&gt; plt.figure()
plot_predicted &lt;/span&gt;= plt.plot(predicted,label = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;predicted&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plot_test &lt;/span&gt;= plt.plot(test_y,label = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;real_sin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.legend([plot_predicted, plot_test], [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;predicted&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;real_sin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

plt.savefig(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sin.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 02 Jul 2018 15:23:00 +0000</pubDate>
<dc:creator>左手十字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuoshoushizi/p/9243691.html</dc:identifier>
</item>
<item>
<title>性能测试day01_性能基本概念 - ~泪小白~</title>
<link>http://www.cnblogs.com/leixiaobai/p/9256363.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leixiaobai/p/9256363.html</guid>
<description>&lt;p&gt;　　其实第一次接触性能是15年的时候，懵懵懂懂的被领导拉去做第一次做性能压测，如今有机会重新听一下云层大大讲解性能，于是打算以此博客记录下整个学习的过程，如若有不同意见者可以在下面留言指出，也欢迎大家一起来探讨性能测试。&lt;/p&gt;
&lt;p&gt;      进入今天的主题，今天的主要目的就是构建整体的思想，那么第一个问题来了，什么是性能测试？简单的来讲是不是就是性价比测试（这个本质上来讲是不是就是对比单位价格内的处理能力），性价比准确的来讲又是软硬件的投入对TPS的影响。&lt;/p&gt;
&lt;p&gt;请看下图的一个思路过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1064304/201807/1064304-20180702215036799-961469590.png&quot; alt=&quot;&quot; width=&quot;1388&quot; height=&quot;419&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　什么是性能问题？时间性价比的问题，具体到我们系统来讲是不是就是访问量的问题？&lt;/p&gt;
&lt;p&gt;　　那性能测试做什么呢？目前来讲有两种，第一种是证明满足需求的过程（性能需求-&amp;gt;验证需求-&amp;gt;给出结论），第二种是获取相关指标提供决策（设定方案-&amp;gt;获取指标-&amp;gt;决策判断依据），大部分人可能都是第一种。&lt;/p&gt;
&lt;p&gt;　　测试系统满足性能需求需要经历的阶段如下：&lt;/p&gt;
&lt;p&gt;　　　　　　1.性能需求是啥？（大部分性能问题没法做就是需求问题没弄清楚）&lt;/p&gt;
&lt;p&gt;　　　　　　2.测试方式是啥？（第一点性能方案的设计，第二点就是工具方法）&lt;/p&gt;
&lt;p&gt;　　　　　　3.结果怎么收集？（监控命令和监控平台如：zabbix、普罗米修斯）&lt;/p&gt;
&lt;p&gt;　　　　　　4.报告怎么编写？&lt;/p&gt;
&lt;p&gt;　　所以说性能测试就是为了验证在一定环境下系统满足性能需求的测试，主要验证性能指标（响应时间、吞吐量、资源利用率）。&lt;/p&gt;
&lt;p&gt;　　由于网上对这几个性能指标众说纷纭，而且不一定准确，这边来重新梳理下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;响应时间：分为事务响应时间（做一件事情所产生的所有时间开销，包括前后的等待时间等）和平均响应时间（某一个时间段内的响应时间分布趋势，这里有有两个点，一个是时间段的长度还有个就是时间段的位置；TPS也不一定是每秒的事务个数，取决于工具切的时间段），一般用平均响应时间作为参考依据而不是事务响应时间。&lt;/li&gt;
&lt;li&gt;吞吐量：是否以秒为单位以及单位下事务分布的情况？工具求出来的TPS不能完全以秒为单位！&lt;/li&gt;
&lt;li&gt;资源利用率：占用资源的百分比（可能存在某个节点的瓶颈但总占用率不高，例如多核CPU中的一个占用很高）和数量制（不太明确的总量，比如IO的处理能力（每秒字节数。不是百分比），以数量来表达，此时我们就需要了解每个计数器的概念和表达方式）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总的来讲，根据这些数据了解系统的工作情况，最终给出分析调优的建议和总结报告，而分析调优的建议则取决于自身的眼界，所以说性能测试是一项需要掌握知识面非常广的测试项目。（千万别放弃哈！）&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 15:15:00 +0000</pubDate>
<dc:creator>~泪小白~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leixiaobai/p/9256363.html</dc:identifier>
</item>
<item>
<title>浮动与浮动的清除 - SoulDee</title>
<link>http://www.cnblogs.com/souldee/p/9256260.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/souldee/p/9256260.html</guid>
<description>&lt;h2 id=&quot;一浮动&quot;&gt;一、浮动&lt;/h2&gt;
&lt;p&gt;说浮动就必须提及一下文档流，HTML当中的元素按照从左到右，从上到下的顺序进行排列称之为文档流，也就是正常排列。&lt;/p&gt;
&lt;p&gt;而浮动是什么呢？浮动会让元素脱离文档流，假如A元素浮动了，原本排在该元素之后的元素发现A元素不在这个文档流了，就会无视它往上接到A元素前面的元素之后(PS:但是文字并不会无视它，还会环绕A元素，也就是A元素没有脱离文字流，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1359286/201807/1359286-20180702214000955-524538997.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而如果使用position的绝对定位会连文字流也脱离文档流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1359286/201807/1359286-20180702214219688-744311001.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;浮动的好处当然是布局了，例如通过浮动来形成三列布局，文字环绕等等。但是浮动也有一个问题，那就是会导致高度的塌陷，就像上面的图片显示，父元素的高度塌陷了，并没有将浮动的子元素包裹进去，这样子就会造成布局上的错误。&lt;/p&gt;
&lt;h2 id=&quot;二bfc&quot;&gt;二、BFC&lt;/h2&gt;
&lt;p&gt;什么是BFC？BFC是Block Formatting Context的缩写，也就是&lt;code&gt;块级格式化上下文&lt;/code&gt;，创建BFC有以下情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;float的值不为none。&lt;/li&gt;
&lt;li&gt;overflow的值不为visible。&lt;/li&gt;
&lt;li&gt;display的值为table-cell, table-caption, inline-block中的任何一个。&lt;/li&gt;
&lt;li&gt;position的值不为relative和static。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;BFC的特性就是包裹浮动的元素。按照我的理解，当你创建BFC之后元素就会把里面的东西视为自己的东西，包括浮动元素，然后创建一个私有领域给包裹进来。此外BFC还有还有如下特性。&lt;/p&gt;
&lt;p&gt;1.让原本会叠加的上下外边距叠加无效。将想要边距失效的两个盒子分别放入一个父盒子，然后为父盒子创建BFC。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1359286/201807/1359286-20180702221214995-1055365897.png&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1359286/201807/1359286-20180702221221844-1168897249.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.创建BFC的元素将不会围绕浮动元素，图中文字用p标签包裹并创建BFC，右上角浮动元素，可以看见文字并没有环绕浮动元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1359286/201807/1359286-20180702222127466-1411057661.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三-清除浮动的方法&quot;&gt;三、 清除浮动的方法&lt;/h2&gt;
&lt;p&gt;清除浮动方法大致有两类，一类是&lt;code&gt;clear:both | left | right&lt;/code&gt; ,另一类则是创建&lt;code&gt;BFC&lt;/code&gt;,细分又可以分为多种。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过在浮动元素末尾添加一个空的标签例如并设置样式为&lt;code&gt;clear:both | left | right&lt;/code&gt; ，其他标签br等亦可。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;parent&quot;&amp;gt;
    &amp;lt;div class=&quot;child&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div style=&quot;clear: both;&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：简单。&lt;/p&gt;
&lt;p&gt;缺点：增加了额外的标签，并且很显然这并不符合语义化。&lt;/p&gt;
&lt;p&gt;*使用 br标签和其自身的 html属性，br 有 &lt;code&gt;clear=all | left | right | none；&lt;/code&gt;的属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;parent&quot;&amp;gt;
    &amp;lt;div class=&quot;child&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;br clear='all'&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：简单代码量少，比空标签语义化稍好。&lt;/p&gt;
&lt;p&gt;缺点：同上。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;code&gt;::after&lt;/code&gt;伪元素(万金油方法)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ps:由于IE6-7不支持&lt;code&gt;:after&lt;/code&gt;，使用`&lt;code&gt;zoom:1&lt;/code&gt;触发&lt;code&gt;hasLayout&lt;/code&gt;。其实是通过 content 在元素的后面生成了内容为空的块级元素&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.clearfix:after {
    content:&quot;&quot;;
    display:block;
    height:0;
    visibility:hidden;//这一条可以省略，证明请看原文精益求精部分
    clear:both; 
}
.clearfix {
    zoom:1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：结构和语义化完全正确,代码量居中。&lt;/p&gt;
&lt;p&gt;缺点：复用方式不当会造成代码量增加。&lt;/p&gt;
&lt;p&gt;伪元素还有一种写法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 用display:table 是为了避免外边距margin重叠导致的margin塌陷, 内部元素默认会成为 table-cell 单元格的形式
.clearfix:before, .clearfix:after {
    content:&quot;&quot;;
    display:table;
}
.clearfix:after{
    clear:both;
    overflow:hidden;
}
.clearfix{
    zoom:1; 
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;父元素设置 &lt;code&gt;overflow：hidden&lt;/code&gt;,(PS:在IE6中还需要触发 hasLayout ，例如 &lt;code&gt;zoom:1&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点：不存在结构和语义化问题，代码量极少。&lt;/p&gt;
&lt;p&gt;缺点：由于hidden的原因，当内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素，还会导致中键失效（鼠标中键）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;父元素设置 &lt;code&gt;overflow：auto&lt;/code&gt; 属性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点：同上&lt;/p&gt;
&lt;p&gt;缺点：多个嵌套后，会有bug，详情看原文。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;父元素也浮动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点：代码少&lt;/p&gt;
&lt;p&gt;缺点：总不能一直浮动到body吧。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;父元素设置&lt;code&gt;display:table&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点：结构语义化完全正确，代码量极少。&lt;/p&gt;
&lt;p&gt;缺点：会造成盒模型的改变。&lt;/p&gt;
&lt;p&gt;其余的参考上面如何创建BFC。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.iyunlu.com/view/css-xhtml/55.html&quot;&gt;那些年我们一起清除过的浮动&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/pigtail/archive/2013/01/23/2871627.html&quot;&gt;关于Block Formatting Context－－BFC和IE的hasLayout&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NzE0MjQ2Mw==&amp;amp;mid=2652493490&amp;amp;idx=1&amp;amp;sn=8015c7e1eafb5b4920124d9bdeeeebea&amp;amp;chksm=bd33fc628a447574e547ca35bf832f9a096f9e35ffdef62a6374140f2711bb3639b300804202&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=0316bCgK2ZqaVHBMtUTikw6D#rd&quot;&gt;理解CSS布局和BFC&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 14:47:00 +0000</pubDate>
<dc:creator>SoulDee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/souldee/p/9256260.html</dc:identifier>
</item>
<item>
<title>PHP内核之旅-6.垃圾回收机制 - jackson0714</title>
<link>http://www.cnblogs.com/jackson0714/p/php6.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackson0714/p/php6.html</guid>
<description>&lt;p&gt;回收PHP 内核之旅系列&lt;/p&gt;


&lt;p&gt;只有使用引用计数的变量才需要回收。引用计数就是用来标记变量的引用次数的。&lt;/p&gt;
&lt;p&gt;当有新的变量zval指向value时，计数器加1，当变量zval销毁时，计数器减一。当引用计数为0时，表示此value没有被任何变量指向，可以对value进行释放。&lt;/p&gt;
&lt;p&gt;下面的例子说明引用计数的是如何变化的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
$x = array(); //array这个value被变量$x引用1次，refcount = 1
$y = $x; //array这个value被变量$x,$y分别引用1次，refcount = 2
$z = $y; //array这个value被变量$x,$y,$z分别引用1次，refcount = 3
unset($y); //array这个value被变量$x,$z分别引用1次，refcount = 2，$y被销毁了，没有引用array这个value
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用引用计数的类型有以下几种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;string、array、object、resource、reference&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;note&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;下面的表格说明了只有type_flag为以下8种类型且IS_TYPE_REFOUNTED=true的变量才使用引用计数&lt;/p&gt;
&lt;table dir=&quot;ltr&quot; border=&quot;2&quot; frame=&quot;vsides&quot; rules=&quot;all&quot; align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;strong&gt;type_flag&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;IS_TYPE_REFCOUNTED&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1        &lt;/td&gt;
&lt;td&gt;simple types&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;string&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;interned string&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;array&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;immutable array&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;6&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;object&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;7&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;resource&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;8&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;reference&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2&gt;1.正常回收场景：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;a.自动回收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在zval断开value的指向时，如果发现refcount=0则会直接释放value。&lt;/p&gt;
&lt;p&gt;　　　　断开value指向的情形：&lt;/p&gt;
&lt;p&gt;　　　　（1）修改变量时会断开原有value的指向&lt;/p&gt;
&lt;p&gt;　　　　（2）函数返回时会释放所有的局部变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b.主动回收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　unset()函数&lt;/p&gt;
&lt;h2&gt;2.垃圾回收场景：&lt;/h2&gt;
&lt;p&gt;当因循环引用导致无法释放的变量称为&lt;span&gt;&lt;strong&gt;垃圾&lt;/strong&gt;&lt;/span&gt;，用垃圾回收器进行回收。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;（1）如果一个变量value的refcount减一之后等于0，此value可以被释放掉，不属于垃圾。垃圾回收器不会处理。&lt;/p&gt;
&lt;p&gt;（2）如果一个变量value的refcount减一之后还是大于0，此value被认为不能被释放掉，可能成为一个垃圾。&lt;/p&gt;
&lt;p&gt;（3）垃圾回收器会将可能的垃圾收集起来，等达到一定数量后开始启动垃圾鉴定程序，把真正的垃圾释放掉。&lt;/p&gt;
&lt;p&gt;（4）收集的时机是refount减少时。&lt;/p&gt;
&lt;p&gt;（5）收集到的垃圾保存到一个buffer缓冲区中。&lt;/p&gt;
&lt;p&gt;（6）垃圾只会出现在array、object类型中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;1.垃圾是如何回收的&lt;/h2&gt;
&lt;p&gt;垃圾收集器收集的可能垃圾到达一定数量后，启动垃圾鉴定、回收程序。&lt;/p&gt;
&lt;h2&gt;2.垃圾鉴定&lt;/h2&gt;
&lt;p&gt;垃圾是由于成员引用自身导致的，那么就对value的refcount减一操作，如果value的refount变为了0，则表明其引用全部来自自身成员，value属于垃圾。&lt;/p&gt;
&lt;h2&gt;3.垃圾回收的步骤&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/414640/201806/414640-20180620195053392-44636031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;note&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;步骤一：遍历垃圾回收器的buffer缓冲区，把value标为灰色，把value的成员的refount-1，标为白色。&lt;/p&gt;
&lt;p&gt;步骤二：遍历垃圾回收器的buffer缓冲区，如果value的 refcount等于0，则认为是垃圾，标为白色；如果不等于0，则表示还有外部的引用，不是垃圾，将refcount+1还原回去，标为黑色。&lt;/p&gt;
&lt;p&gt;步骤三：遍历垃圾回收器的buffer缓冲区，将value为非白色的节点从buffer中删除，最终buffer缓冲区中都是真正的垃圾。&lt;/p&gt;
&lt;p&gt;步骤四：遍历垃圾回收器的buffer缓冲区，释放此value。&lt;/p&gt;
&lt;/div&gt;

&lt;h2&gt;1.垃圾管家&lt;/h2&gt;
&lt;p&gt;_zend_gc_globals 对垃圾进行管理，收集到的可能成为垃圾的value就保存在这个结构的buf中，称为垃圾缓存区。&lt;/p&gt;
&lt;p&gt;文件路劲：\Zend\zend_gc.h&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e29b1dee-fe6c-478c-9fce-ddfa43a6efa2')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e29b1dee-fe6c-478c-9fce-ddfa43a6efa2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e29b1dee-fe6c-478c-9fce-ddfa43a6efa2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e29b1dee-fe6c-478c-9fce-ddfa43a6efa2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e29b1dee-fe6c-478c-9fce-ddfa43a6efa2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;typedef struct _zend_gc_globals {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     zend_bool         gc_enabled; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否启用GC&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     zend_bool         gc_active; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否处于垃圾检查中&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     zend_bool         gc_full; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存区是否已满&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     gc_root_buffer   *buf; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;预分配的垃圾缓存区，用于保存可能成为垃圾的value&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     gc_root_buffer    roots; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向buf中最新加入的一个可能垃圾&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     gc_root_buffer   *unused; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向buf中没有使用的buffer&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     gc_root_buffer   *first_unused; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向第一个没有使用的buffer&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     gc_root_buffer   *last_unused; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向最后一个没有使用的buffer&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     gc_root_buffer    to_free; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;待释放的垃圾&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     gc_root_buffer   *next_to_free; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下指向下一个待释放的垃圾&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     uint32_t gc_runs; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计GC运行次数&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     uint32_t collected; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计已回收的垃圾数&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;if GC_BENCH&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    uint32_t root_buf_length;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    uint32_t root_buf_peak;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    uint32_t zval_possible_root;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    uint32_t zval_buffered;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    uint32_t zval_remove_from_buffer;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    uint32_t zval_marked_grey;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;endif&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     gc_additional_buffer *&lt;span&gt;additional_buffer;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; } zend_gc_globals;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;_zend_gc_globals&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;h2&gt;2.垃圾管家初始化&lt;/h2&gt;
&lt;p&gt;（1）php.ini解析后调用gc_init()初始垃圾管家_zend_gc_globals &lt;/p&gt;
&lt;p&gt;文件路径：\Zend\zend_gc.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('eba99e6e-2ca5-4cca-bd61-40418ea68879')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_eba99e6e-2ca5-4cca-bd61-40418ea68879&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_eba99e6e-2ca5-4cca-bd61-40418ea68879&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('eba99e6e-2ca5-4cca-bd61-40418ea68879',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_eba99e6e-2ca5-4cca-bd61-40418ea68879&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;ZEND_API void gc_init(void)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (GC_G(buf) == &lt;span&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; GC_G(gc_enabled)) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         GC_G(buf) = (gc_root_buffer*) malloc(&lt;span&gt;sizeof&lt;/span&gt;(gc_root_buffer) * GC_ROOT_BUFFER_MAX_ENTRIES);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;GC_ROOT_BUFFER_MAX_ENTRIES=10001&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         GC_G(last_unused) = &amp;amp;&lt;span&gt;GC_G(buf)[GC_ROOT_BUFFER_MAX_ENTRIES];
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        gc_reset();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;gc_init&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;（2）gc_init()函数里面调用gc_reset()函数初始化变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1ea541d2-b204-4670-b340-c993449fa45d')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_1ea541d2-b204-4670-b340-c993449fa45d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1ea541d2-b204-4670-b340-c993449fa45d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1ea541d2-b204-4670-b340-c993449fa45d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1ea541d2-b204-4670-b340-c993449fa45d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;ZEND_API void gc_reset(void)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     GC_G(gc_runs) = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     GC_G(collected) = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     GC_G(gc_full) = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     GC_G(roots).&lt;span&gt;next&lt;/span&gt; = &amp;amp;&lt;span&gt;GC_G(roots);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     GC_G(roots).&lt;span&gt;prev&lt;/span&gt; = &amp;amp;&lt;span&gt;GC_G(roots);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     GC_G(to_free).&lt;span&gt;next&lt;/span&gt; = &amp;amp;&lt;span&gt;GC_G(to_free);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     GC_G(to_free).&lt;span&gt;prev&lt;/span&gt; = &amp;amp;&lt;span&gt;GC_G(to_free);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     GC_G(unused) = &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     GC_G(first_unused) = &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     GC_G(last_unused) = &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     GC_G(additional_buffer) = &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;gc_reset&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3.判断是否需要收集&lt;/h2&gt;
&lt;p&gt;（1）在销毁一个变量时就会判断是否需要收集。调用i_zval_ptr_dtor()函数&lt;/p&gt;
&lt;p&gt;文件路径：Zend\zend_variables.h&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b8ec44f4-3129-4d87-8973-773ef776e6d1')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_b8ec44f4-3129-4d87-8973-773ef776e6d1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b8ec44f4-3129-4d87-8973-773ef776e6d1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b8ec44f4-3129-4d87-8973-773ef776e6d1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b8ec44f4-3129-4d87-8973-773ef776e6d1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; zend_always_inline void i_zval_ptr_dtor(zval *&lt;span&gt;zval_ptr ZEND_FILE_LINE_DC)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Z_REFCOUNTED_P(zval_ptr)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;type_flags &amp;amp; IS_TYPE_REFCOUNTED&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         zend_refcounted *ref =&lt;span&gt; Z_COUNTED_P(zval_ptr);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!--GC_REFCOUNT(ref)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;refcount - 1 之后等于0，则不是垃圾，正常回收&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            _zval_dtor_func(ref ZEND_FILE_LINE_RELAY_CC);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果refcount - 1 之后仍然大于0，垃圾管家进行收集&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            gc_check_possible_root(ref);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;i_zval_ptr_dtor&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;（2）如果refcount减一后，refcount等于0，则认为不是垃圾，释放此value&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d522d3b8-e524-4e15-acd6-fc8a62557d8f')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_d522d3b8-e524-4e15-acd6-fc8a62557d8f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d522d3b8-e524-4e15-acd6-fc8a62557d8f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d522d3b8-e524-4e15-acd6-fc8a62557d8f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d522d3b8-e524-4e15-acd6-fc8a62557d8f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件路径：\Zend\zend_variables.c&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; ZEND_API void ZEND_FASTCALL _zval_dtor_func(zend_refcounted *&lt;span&gt;p ZEND_FILE_LINE_DC)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (GC_TYPE(p)) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &lt;span&gt;IS_STRING&lt;/span&gt;:
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; IS_CONSTANT:&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 zend_string *str = (zend_string*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                CHECK_ZVAL_STRING_REL(str);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                zend_string_free(str);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &lt;span&gt;IS_ARRAY&lt;/span&gt;:&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 zend_array *arr = (zend_array*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                zend_array_destroy(arr);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; IS_CONSTANT_AST:&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 zend_ast_ref *ast = (zend_ast_ref*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;                 zend_ast_destroy_and_free(ast-&amp;gt;&lt;span&gt;ast);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 efree_size(ast, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(zend_ast_ref));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &lt;span&gt;IS_OBJECT&lt;/span&gt;:&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 zend_object *obj = (zend_object*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                zend_objects_store_del(obj);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &lt;span&gt;IS_RESOURCE&lt;/span&gt;:&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 zend_resource *res = (zend_resource*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; destroy resource &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                zend_list_free(res);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; IS_REFERENCE:&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 zend_reference *ref = (zend_reference*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;                 i_zval_ptr_dtor(&amp;amp;ref-&amp;gt;&lt;span&gt;val ZEND_FILE_LINE_RELAY_CC);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 efree_size(ref, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(zend_reference));
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;default&lt;/span&gt;:
&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;_zval_dtor_func&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;（3）如果refcount减一后，refcount大于0，则认为value可能是垃圾，垃圾管家进行收集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e0074413-019b-4a95-8cbc-61e036162ff5')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e0074413-019b-4a95-8cbc-61e036162ff5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e0074413-019b-4a95-8cbc-61e036162ff5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e0074413-019b-4a95-8cbc-61e036162ff5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e0074413-019b-4a95-8cbc-61e036162ff5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; \\文件路径：\Zend\zend_gc.&lt;span&gt;h
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; zend_always_inline void gc_check_possible_root(zend_refcounted *&lt;span&gt;ref)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (GC_TYPE(ref) ==&lt;span&gt; IS_REFERENCE) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         zval *zv = &amp;amp;((zend_reference*)ref)-&amp;gt;&lt;span&gt;val;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Z_REFCOUNTED_P(zv)) { 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            Z_TYPE_FLAGS 与 IS_TYPE_REFCOUNTED 与运算后，不等于0，则会被释放掉
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            Z_REFCOUNTED_P --&amp;gt; ((Z_TYPE_FLAGS(zval) &amp;amp; IS_TYPE_REFCOUNTED) != 0)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            Z_TYPE_FLAGS(zval) --&amp;gt; (zval).u1.v.type_flags
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            IS_TYPE_REFCOUNTED -&amp;gt; 1&amp;lt;&amp;lt;2 (0100)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         ref = Z_COUNTED_P(zv); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Z_COUNTED_P --&amp;gt; (zval).value.counted  GC头部&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (UNEXPECTED(GC_MAY_LEAK(ref))) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         gc_possible_root(ref); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;垃圾管家收集可能的垃圾&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;gc_check_possible_root&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt; 4.收集垃圾&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c9d36c16-2769-49bb-9f59-47821a85fc44')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_c9d36c16-2769-49bb-9f59-47821a85fc44&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c9d36c16-2769-49bb-9f59-47821a85fc44&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c9d36c16-2769-49bb-9f59-47821a85fc44',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c9d36c16-2769-49bb-9f59-47821a85fc44&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;\\&lt;/span&gt;&lt;span&gt;文件路径：\Zend\zend_gc.c&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; ZEND_API &lt;span&gt;void&lt;/span&gt; ZEND_FASTCALL gc_possible_root(zend_refcounted *&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     gc_root_buffer *&lt;span&gt;newRoot;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (UNEXPECTED(CG(unclean_shutdown)) ||&lt;span&gt; UNEXPECTED(GC_G(gc_active))) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     ZEND_ASSERT(GC_TYPE(&lt;span&gt;ref&lt;/span&gt;) == IS_ARRAY || GC_TYPE(&lt;span&gt;ref&lt;/span&gt;) == IS_OBJECT); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有数组和对象才会出现循环引用的产生的垃圾，所以只需要收集数组类型和对象类型的垃圾&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     ZEND_ASSERT(EXPECTED(GC_REF_GET_COLOR(&lt;span&gt;ref&lt;/span&gt;) == GC_BLACK)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只收集颜色为GC_BLACK的变量&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     ZEND_ASSERT(!GC_ADDRESS(GC_INFO(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    GC_BENCH_INC(zval_possible_root);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     newRoot = GC_G(unused); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿出unused指向的节点&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (newRoot) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果拿出的节点是可用的，则将unused指向下一个节点&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         GC_G(unused) = newRoot-&amp;gt;&lt;span&gt;prev;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (GC_G(first_unused) != GC_G(last_unused)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果unused没有可用的，且first_unused还没有推进到last_unused，则表示buf缓存区中还有可用的节点&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         newRoot = GC_G(first_unused); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿出first_unused指向的节点&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         GC_G(first_unused)++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;first_unused指向下一个节点&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;buf缓存区已满，启动垃圾鉴定、垃圾回收&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!GC_G(gc_enabled)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果未启用垃圾回收，则直接返回&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         GC_REFCOUNT(&lt;span&gt;ref&lt;/span&gt;)++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        gc_collect_cycles();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         GC_REFCOUNT(&lt;span&gt;ref&lt;/span&gt;)--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (UNEXPECTED(GC_REFCOUNT(&lt;span&gt;ref&lt;/span&gt;)) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             zval_dtor_func(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (UNEXPECTED(GC_INFO(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;))) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         newRoot =&lt;span&gt; GC_G(unused);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;newRoot) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; ZEND_GC_DEBUG
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;GC_G(gc_full)) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 fprintf(stderr, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GC: no space to record new root candidate\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 GC_G(gc_full) = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         GC_G(unused) = newRoot-&amp;gt;&lt;span&gt;prev;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;     GC_TRACE_SET_COLOR(&lt;span&gt;ref&lt;/span&gt;, GC_PURPLE); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将插入的变量标为紫色，防止重复插入
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将该节点在buf数组中的位置保存到了gc_info中，当后续value的refcount变为了0，
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要将其从buf中删除时可以知道该value保存在哪个gc_root_buffer中&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;     GC_INFO(&lt;span&gt;ref&lt;/span&gt;) = (newRoot - GC_G(buf)) |&lt;span&gt; GC_PURPLE; 
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     newRoot-&amp;gt;&lt;span&gt;ref&lt;/span&gt; = &lt;span&gt;ref&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入roots链表头部&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;     newRoot-&amp;gt;next =&lt;span&gt; GC_G(roots).next;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     newRoot-&amp;gt;prev = &amp;amp;&lt;span&gt;GC_G(roots);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     GC_G(roots).next-&amp;gt;prev =&lt;span&gt; newRoot;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     GC_G(roots).next =&lt;span&gt; newRoot;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    GC_BENCH_INC(zval_buffered);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    GC_BENCH_INC(root_buf_length);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    GC_BENCH_PEAK(root_buf_peak, root_buf_length);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;gc_possible_root&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;5.释放垃圾&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1163b70e-4d04-44d5-83da-5fc4bf13e2be')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_1163b70e-4d04-44d5-83da-5fc4bf13e2be&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1163b70e-4d04-44d5-83da-5fc4bf13e2be&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1163b70e-4d04-44d5-83da-5fc4bf13e2be',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1163b70e-4d04-44d5-83da-5fc4bf13e2be&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; ZEND_API &lt;span&gt;int&lt;/span&gt; zend_gc_collect_cycles(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (GC_G(roots).next != &amp;amp;&lt;span&gt;GC_G(roots)) {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         gc_root_buffer *current, *next, *&lt;span&gt;orig_next_to_free;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         zend_refcounted *&lt;span&gt;p;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;        gc_root_buffer to_free;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         uint32_t gc_flags = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;         gc_additional_buffer *&lt;span&gt;additional_buffer_snapshot;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; ZEND_GC_DEBUG
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;        zend_bool orig_gc_full;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (GC_G(gc_active)) {
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt;         GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Collecting cycles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         GC_G(gc_runs)++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;         GC_G(gc_active) = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;         GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Marking roots&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;        gc_mark_roots();
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;         GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Scanning roots&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;        gc_scan_roots();
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; ZEND_GC_DEBUG
&lt;span&gt; 29&lt;/span&gt;         orig_gc_full =&lt;span&gt; GC_G(gc_full);
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         GC_G(gc_full) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;         GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Collecting roots&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         additional_buffer_snapshot =&lt;span&gt; GC_G(additional_buffer);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         count = gc_collect_roots(&amp;amp;&lt;span&gt;gc_flags);
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; ZEND_GC_DEBUG
&lt;span&gt; 37&lt;/span&gt;         GC_G(gc_full) =&lt;span&gt; orig_gc_full;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;         GC_G(gc_active) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (GC_G(to_free).next == &amp;amp;&lt;span&gt;GC_G(to_free)) {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; nothing to free &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;             GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nothing to free&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Copy global to_free list into local list &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;         to_free.next =&lt;span&gt; GC_G(to_free).next;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         to_free.prev =&lt;span&gt; GC_G(to_free).prev;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         to_free.next-&amp;gt;prev = &amp;amp;&lt;span&gt;to_free;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         to_free.prev-&amp;gt;next = &amp;amp;&lt;span&gt;to_free;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Free global list &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;         GC_G(to_free).next = &amp;amp;&lt;span&gt;GC_G(to_free);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         GC_G(to_free).prev = &amp;amp;&lt;span&gt;GC_G(to_free);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;         orig_next_to_free =&lt;span&gt; GC_G(next_to_free);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; ZEND_GC_DEBUG
&lt;span&gt; 60&lt;/span&gt;         orig_gc_full =&lt;span&gt; GC_G(gc_full);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         GC_G(gc_full) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (gc_flags &amp;amp;&lt;span&gt; GC_HAS_DESTRUCTORS) {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Calling destructors&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Remember reference counters before calling destructors &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;             current =&lt;span&gt; to_free.next;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (current != &amp;amp;&lt;span&gt;to_free) {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                 current-&amp;gt;refcount = GC_REFCOUNT(current-&amp;gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                 current = current-&amp;gt;&lt;span&gt;next;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; 
&lt;span&gt; 74&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Call destructors &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;             current =&lt;span&gt; to_free.next;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (current != &amp;amp;&lt;span&gt;to_free) {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                 p = current-&amp;gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                 GC_G(next_to_free) = current-&amp;gt;&lt;span&gt;next;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (GC_TYPE(p) ==&lt;span&gt; IS_OBJECT) {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                     zend_object *obj = (zend_object*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!(GC_FLAGS(obj) &amp;amp;&lt;span&gt; IS_OBJ_DESTRUCTOR_CALLED)) {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                         GC_TRACE_REF(obj, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;calling destructor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                         GC_FLAGS(obj) |=&lt;span&gt; IS_OBJ_DESTRUCTOR_CALLED;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (obj-&amp;gt;handlers-&amp;gt;&lt;span&gt;dtor_obj
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                          &amp;amp;&amp;amp; (obj-&amp;gt;handlers-&amp;gt;dtor_obj !=&lt;span&gt; zend_objects_destroy_object
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                           || obj-&amp;gt;ce-&amp;gt;&lt;span&gt;destructor)) {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                             GC_REFCOUNT(obj)++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                             obj-&amp;gt;handlers-&amp;gt;&lt;span&gt;dtor_obj(obj);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                             GC_REFCOUNT(obj)--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                 current =&lt;span&gt; GC_G(next_to_free);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Remove values captured in destructors &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;             current =&lt;span&gt; to_free.next;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (current != &amp;amp;&lt;span&gt;to_free) {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 GC_G(next_to_free) = current-&amp;gt;&lt;span&gt;next;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (GC_REFCOUNT(current-&amp;gt;&lt;span&gt;ref&lt;/span&gt;) &amp;gt; current-&amp;gt;&lt;span&gt;refcount) {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                     gc_remove_nested_data_from_buffer(current-&amp;gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;, current);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                 current =&lt;span&gt; GC_G(next_to_free);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Destroy zvals &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;         GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Destroying zvals&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         GC_G(gc_active) = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         current =&lt;span&gt; to_free.next;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (current != &amp;amp;&lt;span&gt;to_free) {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             p = current-&amp;gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             GC_G(next_to_free) = current-&amp;gt;&lt;span&gt;next;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;             GC_TRACE_REF(p, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;destroying&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (GC_TYPE(p) ==&lt;span&gt; IS_OBJECT) {
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;                 zend_object *obj = (zend_object*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt;                 EG(objects_store).object_buckets[obj-&amp;gt;handle] =&lt;span&gt; SET_OBJ_INVALID(obj);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;                 GC_TYPE(obj) =&lt;span&gt; IS_NULL;
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!(GC_FLAGS(obj) &amp;amp;&lt;span&gt; IS_OBJ_FREE_CALLED)) {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                     GC_FLAGS(obj) |=&lt;span&gt; IS_OBJ_FREE_CALLED;
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (obj-&amp;gt;handlers-&amp;gt;&lt;span&gt;free_obj) {
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                         GC_REFCOUNT(obj)++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;                         obj-&amp;gt;handlers-&amp;gt;&lt;span&gt;free_obj(obj);
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;                         GC_REFCOUNT(obj)--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;                 SET_OBJ_BUCKET_NUMBER(EG(objects_store).object_buckets[obj-&amp;gt;&lt;span&gt;handle], EG(objects_store).free_list_head);
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;                 EG(objects_store).free_list_head = obj-&amp;gt;&lt;span&gt;handle;
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;                 p = current-&amp;gt;&lt;span&gt;ref&lt;/span&gt; = (zend_refcounted*)(((&lt;span&gt;char&lt;/span&gt;*)obj) - obj-&amp;gt;handlers-&amp;gt;&lt;span&gt;offset);
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (GC_TYPE(p) ==&lt;span&gt; IS_ARRAY) {
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                 zend_array *arr = (zend_array*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;                 GC_TYPE(arr) =&lt;span&gt; IS_NULL;
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt;                 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; GC may destroy arrays with rc&amp;gt;1. This is valid and safe. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt; &lt;span&gt;                HT_ALLOW_COW_VIOLATION(arr);
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; 
&lt;span&gt;140&lt;/span&gt; &lt;span&gt;                zend_hash_destroy(arr);
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;             current =&lt;span&gt; GC_G(next_to_free);
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; 
&lt;span&gt;145&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Free objects &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;         current =&lt;span&gt; to_free.next;
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (current != &amp;amp;&lt;span&gt;to_free) {
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;             next = current-&amp;gt;&lt;span&gt;next;
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;             p = current-&amp;gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (EXPECTED(current &amp;gt;= GC_G(buf) &amp;amp;&amp;amp; current &amp;lt; GC_G(buf) +&lt;span&gt; GC_ROOT_BUFFER_MAX_ENTRIES)) {
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;                 current-&amp;gt;prev =&lt;span&gt; GC_G(unused);
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;                 GC_G(unused) =&lt;span&gt; current;
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt;            efree(p);
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;             current =&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; 
&lt;span&gt;158&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (GC_G(additional_buffer) !=&lt;span&gt; additional_buffer_snapshot) {
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;             gc_additional_buffer *next = GC_G(additional_buffer)-&amp;gt;&lt;span&gt;next;
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;            efree(GC_G(additional_buffer));
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;             GC_G(additional_buffer) =&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; 
&lt;span&gt;164&lt;/span&gt;         GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Collection finished&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;         GC_G(collected) +=&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;         GC_G(next_to_free) =&lt;span&gt; orig_next_to_free;
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; ZEND_GC_DEBUG
&lt;span&gt;168&lt;/span&gt;         GC_G(gc_full) =&lt;span&gt; orig_gc_full;
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;170&lt;/span&gt;         GC_G(gc_active) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; 
&lt;span&gt;173&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;zend_gc_collect_cycles&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;PHP7内核剖析&lt;/p&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.030303030303&quot;&gt;
&lt;p&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/jackson0714/&quot; target=&quot;_blank&quot;&gt;Jackson0714&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/jackson0714/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/jackson0714/&lt;/a&gt;&lt;br/&gt;关于作者：专注于微软平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/jackson0714&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; onclick=&quot;votePost(5111347,'Digg')&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 02 Jul 2018 14:02:00 +0000</pubDate>
<dc:creator>jackson0714</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackson0714/p/php6.html</dc:identifier>
</item>
<item>
<title>一张脑图说清 Nginx 的主流程 - 轩脉刃</title>
<link>http://www.cnblogs.com/yjf512/p/9255975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjf512/p/9255975.html</guid>
<description>&lt;p&gt;这个脑图在 &lt;a href=&quot;https://github.com/its-tech/nginx-1.14.0-research/tree/master/docs&quot;&gt;nginx-1.14.0-research&lt;/a&gt; 上。这是我在研究nginx的http模块的时候画的。基本上把 Nginx 主流程（特别是 HTTP 的部分）的关键函数和关键设置画了下来，了解了这个脑图，就对整个 Nginx 的主流程有了定性的了解了。&lt;/p&gt;
&lt;p&gt;Nginx 的启动过程分为两个部分，一个部分是读取配置文件，做配置文件中配置的一些事情（比如监听端口等）。第二个部分是形成 Master-Worker 的多进程模型。这两个过程就是 Nginx 代码中最重要的两个函数：&lt;code&gt;ngx_init_cycle&lt;/code&gt; 和 &lt;code&gt;ngx_master_process_cycle&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-6-29/29766630.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ngx_init_cycle 是 Nginx 中最重要的函数，没有之一。我们可以想想，如果我们写一个和 Nginx 一样的 Web 服务，我们会怎么做？我们大致的思路一定是解析配置文件，把配置文件存入到一个数据结构中，然后根据数据结构，进行端口监听。是的，差不多，Nginx 就是这么一个流程。不过 Nginx 里面有个模块的概念，所有的功能都是用模块的方式进行加载的。&lt;/p&gt;
&lt;h2 id=&quot;nginx-的模块&quot;&gt;Nginx 的模块&lt;/h2&gt;
&lt;p&gt;Nginx 的模块分为几类，这几类分别为 Core，Event，Conf，Http，Mail。看名字就知道 Core 模块是最重要的。模块是什么意思呢？它包含一堆命令（cmd）和命令对应的处理函数（cmd-&amp;gt;handler），我们根据配置文件中的配置（token）就知道这个配置是属于哪个模块的哪个命令，然后调用命令对应的处理函数来处理或者设置我们的服务。&lt;/p&gt;
&lt;p&gt;这几类模块中，Core 模块是 Nginx 启动的时候一定会加载的，其他的模块，只有在解析配置的时候，遇到了这个模块的命令，才会加载对应的模块。&lt;br/&gt;这个也是体现了 Nginx 按需加载的理念。（昨天还和小组成员讨论，如果我们写的话，可能就会先把所有模块都加载，然后根据配置文件进行匹配，这样可能 Nginx 的启动过程和进程资源就变大了）。&lt;/p&gt;
&lt;p&gt;模块的另一个问题是我这个 Nginx 最多有哪些模块的能力呢？这个是编译的时候就决定了，Nginx 的编译过程可以参考这篇&lt;a href=&quot;https://www.cnblogs.com/yjf512/p/9177562.html&quot;&gt;文章&lt;/a&gt; 。我们可以不用管./configure 的时候的具体内容，但是我们最关注的就是 &lt;code&gt;objs/ngx_modules.c&lt;/code&gt; 这个编译出来的文件，里面有个&lt;code&gt;ngx_modules&lt;/code&gt;全局变量，这个变量里面就存放了我们这次编译的 Nginx 最多可以支持的模块。&lt;/p&gt;
&lt;p&gt;模块的结构是我们需要关注的另外一个问题。 Nginx 中模块的结构叫做&lt;code&gt;ngx_module_s&lt;/code&gt;（你或许会看到&lt;code&gt;ngx_module_t&lt;/code&gt;，其实就是&lt;code&gt;struct ngx_moudle_s&lt;/code&gt;的缩写）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-6-29/26236212.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面有个结构&lt;code&gt;*ctx&lt;/code&gt;，对于不同的模块类型，这个&lt;code&gt;ctx&lt;/code&gt;指向的结构是不一样的，我们这里最主要是研究 HTTP 类型的模块，所以我们就记得 HTTP 模块指向的结构是&lt;code&gt;ngx_http_module_t&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-6-29/79112482.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;主流程&quot;&gt;主流程&lt;/h2&gt;
&lt;p&gt;了解了 Nginx 的模块概念，我们再回到&lt;code&gt;ngx_init_cycle&lt;/code&gt;函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-6-29/63307342.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个函数里面做了几个事情:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ngx_cycle_modules&lt;/code&gt;，它本质就是把&lt;code&gt;objs/ngx_modules.c&lt;/code&gt;里面的全局变量拷贝到&lt;code&gt;cycle&lt;/code&gt;这个全局变量里面&lt;/li&gt;
&lt;li&gt;调用了每个 Core 类型模块的&lt;code&gt;create_conf&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ngx_conf_parse&lt;/code&gt; 解析配置文件，调用每个Core 类型模块的&lt;code&gt;init_conf&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;调用了每个 Core 类型模块的&lt;code&gt;init_conf&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ngx_open_listening_sockets&lt;/code&gt; 打开配置文件中设置的监听端口和IP&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ngx_init_modules&lt;/code&gt; 调用每个加载模块的&lt;code&gt;init_module&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;create_conf&lt;/code&gt;是创建一些模块需要初始化的结构，但是这个结构里面并没有具体的值。&lt;code&gt;init_conf&lt;/code&gt;是往这些初始化结构里面填写配置文件中解析出来的信息。&lt;/p&gt;
&lt;p&gt;其中的&lt;code&gt;ngx_conf_parse&lt;/code&gt;是真正解析配置文件的。&lt;/p&gt;
&lt;p&gt;在代码&lt;code&gt;ngx_open_listening_sockets&lt;/code&gt;里面我们看到熟悉的bind，listen的命令。所以 Nginx 是如何多个进程同时监听一个80端口的？本质是启动了一个master进程，在&lt;code&gt;ngx_init_cycle&lt;/code&gt;里面监听了端口，然后在&lt;code&gt;ngx_master_process_cycle&lt;/code&gt;里面 fork 出来多个 worker 子进程。&lt;/p&gt;
&lt;h2 id=&quot;ngx_conf_parse&quot;&gt;ngx_conf_parse&lt;/h2&gt;
&lt;p&gt;这个函数是非常非常重要的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-6-29/56409966.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它的逻辑，就是这两步，首先使用函数&lt;code&gt;ngx_conf_read_token&lt;/code&gt;先循环逐行逐字符查找，看匹配的字符，获取出&lt;code&gt;cmd&lt;/code&gt;, 然后去所有的模块查找对应的&lt;code&gt;cmd&lt;/code&gt;,调用那个查找后的&lt;code&gt;cmd-&amp;gt;set&lt;/code&gt;方法。用Http模块举例子，我们的配置文件中一定有且只有一个关键字叫http&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http{

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先解析这个配置的时候发现了&lt;code&gt;http&lt;/code&gt;这个关键字，然后去各个模块匹配，发现&lt;code&gt;ngx_http_module&lt;/code&gt;这个模块包含了&lt;code&gt;http&lt;/code&gt;命令。它对应的set方法是&lt;code&gt;ngx_http_block&lt;/code&gt;。这个方法就是http模块非常重要的方法了。当然，这里顺带提一下，event模块也有类似的方法，&lt;code&gt;ngx_events_block&lt;/code&gt;。它具体做的事情就是解析&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;event epoll&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的命令，并创建出事件驱动的模型。&lt;/p&gt;
&lt;h2 id=&quot;ngx_http_block&quot;&gt;ngx_http_block&lt;/h2&gt;
&lt;p&gt;这个函数是&lt;code&gt;http&lt;/code&gt;模块加载的时候最重要的函数，首先，它会遍历&lt;code&gt;modules.c&lt;/code&gt;中的所有 http 模块，还记得上文说的，HTTP 模块结构&lt;code&gt;ngx_module_s&lt;/code&gt;中的&lt;code&gt;**ctx&lt;/code&gt; 指向的是 &lt;code&gt;ngx_http_module&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-7-2/24841255.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第一步模块对三个层级的回调&quot;&gt;第一步，模块对三个层级的回调&lt;/h3&gt;
&lt;p&gt;它内部有这个 HTTP 模块定义的，在各个层级（http，server，location）所需要加载回调的方法。&lt;/p&gt;
&lt;p&gt;我们这里再附带说一下 HTTP 的三个层级，这三个层级对应我们配置文件里面的三个不同的 Block 语句。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http {
  server {
    listen       80;
    location {
      root   html;
      index  index.html;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这三个层次里面的命令有可能会有重复，有冲突。比如，root这个命令，在 location 中可以有，在 server 中也可以有，如果赋值不一致的化，是上层覆盖下层，还是下层覆盖上层（当然大部分都是下层覆盖上层）。这个就在具体的模块定义的&lt;code&gt;ngx_http_module&lt;/code&gt;结构中定义了 &lt;code&gt;create_main_conf&lt;/code&gt;, &lt;code&gt;create_srv_conf&lt;/code&gt;,...,&lt;code&gt;merge_srv_conf&lt;/code&gt;等方法。这些方法的调用就是在&lt;code&gt;ngx_http_block&lt;/code&gt;方法的第一步进行调用的。&lt;/p&gt;
&lt;h3 id=&quot;第二步设置连接回调和请求监听回调&quot;&gt;第二步，设置连接回调和请求监听回调&lt;/h3&gt;
&lt;p&gt;第二步是调用方法&lt;code&gt;ngx_http_optimize_servers&lt;/code&gt;。它对配置文件中的所有listening的端口和IP进行监听设置。记住，这里只是进行回调的设置，具体的&lt;code&gt;listening&lt;/code&gt;和&lt;code&gt;binding&lt;/code&gt;操作不是在&lt;code&gt;ngx_conf_parse&lt;/code&gt;中，而是在&lt;code&gt;ngx_open_listening_sockets&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-7-2/69227664.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个XMind中有标注（xxx时候回调）的分支就是只有在事件回调的时候会进行调用，不是在&lt;code&gt;ngx_conf_parse&lt;/code&gt;的时候调用的。&lt;/p&gt;
&lt;p&gt;我们再仔细看看这个脑图中的流程，在conf_parse的时候，我实际上只对HTTP连接的时候设置了一个回调函数（ngx_http_init_connection）。在有HTTP连接上来的时候，才会设置读请求的回调（ngx_http_wait_request_handler）。在这个回调，才是真正的解析 HTTP 请求的请求头，请求体等。nginx 中著名的11阶段就是在这个地方进行一个个步骤进行调用的。&lt;/p&gt;
&lt;p&gt;这里说一下回调。nginx 是由各种各样的回调组合起来的。回调就需要要求有一个事件驱动机制。在nginx中，这个事件驱动机制也是一个模块，event 模块。在编译的时候，编译程序会判断你的系统支持哪些事件驱动，比如我的是centos，支持的是epoll，在配置文件配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;event epoll;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后，就用这个epoll事件驱动监听IO事件。其他模块和事件驱动的交互就是通过&lt;code&gt;ngx_add_event&lt;/code&gt;进行事件监听和回调的。&lt;/p&gt;
&lt;p&gt;http请求由于可能请求体或者返回体比较大，所以不一定会在一个事件中完成，为了整体的 nginx 高效，http 模块在处理 http请求的时候，处理完成了一个event回调函数之后，如果没有处理完成整个HTTP，就会在event中继续注册一个回调，然后把处理权和资源都交给事件驱动中心。等待事件驱动下一次触发回调。&lt;/p&gt;
&lt;h3 id=&quot;第三步初始化定义-http-的11个处理阶段&quot;&gt;第三步，初始化定义 HTTP 的11个处理阶段&lt;/h3&gt;
&lt;p&gt;HTTP请求在nginx中会经过11个处理阶段和他们的checker方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NGX_HTTP_POST_READ_PHASE阶段（ngx_http_core_generic_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_SERVER_REWRITE_PHASE阶段（ngx_http_rewrite_handler）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_FIND_CONFIG_PHASE阶段（ngx_http_core_find_config_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_REWRITE_PHASE阶段（ngx_http_rewrite_handler）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_POST_REWRITE_PHASE阶段（ngx_http_core_post_rewrite_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_PREACCESS_PHASE阶段（ngx_http_core_generic_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_ACCESS_PHASE阶段（ngx_http_core_access_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_POST_ACCESS_PHASE阶段（ngx_http_core_post_access_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_TRY_FILES_PHASE阶段（ngx_http_core_try_files_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_CONTENT_PHASE阶段（ngx_http_core_content_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_LOG_PHASE阶段（ngx_http_log_module中的ngx_http_log_handler）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;就像把大象放冰箱需要几步，处理 HTTP 需要11步，这11个步骤，有的是处理配置文件，有的是处理rewrite，有的是处理权限，有的是处理日志。所以，如果我们要自己开发一个http模块，我们就需要定义我们这个http模块处理http请求的这11个阶段（当然并不是这11个阶段都可以被自定义的，有的阶段是不能被自定义模块设置的）。然后当一个请求进来的时候，就按照顺序把请求经过所有模块的这11个阶段。&lt;/p&gt;
&lt;p&gt;这里所谓的经过这些11个阶段本质上就是调用他们的 checker 方法。这些checker方法除了最后一个 NGX_HTTP_LOG_NGX_HTTP_LOG_PAHSE 是在 ngx_http_log_module 里面之外，其他的都是在 http 的 core 模块中定义好了。&lt;/p&gt;
&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;
&lt;p&gt;这里其他的函数调用就没有特别需要注意的了。&lt;/p&gt;
&lt;h2 id=&quot;ngx_http_wait_request_handler&quot;&gt;ngx_http_wait_request_handler&lt;/h2&gt;
&lt;p&gt;我们继续跟着&lt;code&gt;ngx_http_optimize_servers&lt;/code&gt;,&lt;code&gt;ngx_http_init_listening&lt;/code&gt;,&lt;code&gt;ngx_http_add_listening&lt;/code&gt;,&lt;code&gt;ngx_http_init_connection&lt;/code&gt; 进入到处理http请求内容的函数里面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-7-2/8260342.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个函数先调用recv将http请求的数据获取到，然后调用&lt;code&gt;ngx_http_create_request&lt;/code&gt;创建了 HTTP 的请求结构体。&lt;/p&gt;
&lt;p&gt;首先nginx处理的是HTTP的第一行，就是&lt;code&gt;HTTP 1.0 GET&lt;/code&gt;, 从这一行，HTTP 会获取到协议，方法等。接着再调用&lt;code&gt;ngx_http_process_request_line&lt;/code&gt;一行一行处理请求头。&lt;code&gt;ngx_http_read_request_header&lt;/code&gt;，&lt;code&gt;ngx_http_process_request_headers&lt;/code&gt;。处理完成 http header 头之后，&lt;code&gt;ngx_http_process_request&lt;/code&gt; 再接着进行后续的处理&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ngx_http_process_request&lt;/code&gt; 设置了读和写的handler，并且把监听事件从epoll事件驱动队列中拿出来（ngx_http_block_reading），就代表这个时候是阻塞做事件处理的事情。然后再调用&lt;code&gt;ngx_http_core_run_phases&lt;/code&gt;来让请求经过那11个阶段。&lt;/p&gt;
&lt;p&gt;其实并不是所有请求都需要读取整个HTTP请求体。比如你只是获取一个css文件，nginx在11个阶段中的配置读取阶段就不会再继续读取HTTP的body了。但是如果是一个fastcgi请求，在http_fastcgi的模块中，就会进入到NGX_HTTP_CONTENT_PHASE阶段，在这个阶段，它做的一个事情就是循环读取读缓存区的数据，直到读取完毕，然后进行处理，再返回结构。&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 13:49:00 +0000</pubDate>
<dc:creator>轩脉刃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yjf512/p/9255975.html</dc:identifier>
</item>
</channel>
</rss>