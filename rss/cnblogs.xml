<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>lnmp+coreseek实现站内全文检索(安装篇) - 浪子编程走四方</title>
<link>http://www.cnblogs.com/qqblog/p/9813904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qqblog/p/9813904.html</guid>
<description>&lt;h2 id=&quot;coreseek安装与简单实用&quot;&gt;coreseek安装与简单实用&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;安装环境&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;系统环境
&lt;ul&gt;&lt;li&gt;centos7.2&lt;/li&gt;
&lt;li&gt;1核2G&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;软件环境
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;安装mmseg&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;更新依赖包和安装编译环境&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;yum -y install m4 autoconf automake libtool
yum -y install gcc gcc-c++ wget
yum -y install mysql-devel&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;安装coreseek&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;tar -xzvf coreseek-3.2.14.tar.gz
cd coreseek-3.2.14
cd mmseg-3.2.14/
./bootstrap
./configure --prefix=/usr/local/mmseg3
make
make install

cd ../csft-3.2.14/
sh buildconf.sh
./configure --prefix=/usr/local/coreseek --without-python --without-unixodbc --with-mmseg --with-mmseg-includes=/usr/local/mmseg3/include/mmseg/ --with-mmseg-libs=/usr/local/mmseg3/lib/ --with-mysql --host=arm
make
make install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;在安装csft的过程中出现了三种错误情况，错误情况如下错误记录，可以参考修改即可&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;配置coreseek配置文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;配置文件主要修改的几个地方如下，具体的修改信息请参见 &lt;strong&gt;coreseek配置文件&lt;/strong&gt; 目录的进行配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;source src1 
{     
type = mysql                                #数据库类型
sql_host = localhost                    # MySQL主机IP
sql_user = root                             # MySQL用户名
sql_pass = 123                          # MySQL密码
sql_db   =  test                        # MySQL数据库
sql_port = 3306                     # MySQL端口
sql_sock = /tmp/mysql.sock              #如果是linux下需要开启，指定sock文件
sql_query_pre = SET NAMES UTF8      # MySQL检索编码
sql_query_pre = SET SESSION query_cache_type=OFF    #关闭缓存
sql_query   = \                             #获取数据的SQL语句 
SELECT id, title, content FROM post
#sql_attr_uint = group_id               #对排序字段进行注释
#sql_attr_timestamp = date_added       #对排序字段进行注释
sql_query_info      = SELECT * FROM post WHERE id=$id
}                                           #这行不需要修改
source srclthrottled:srcl               #继承主数据源
主数据源索引:
index text1
{   
source = src1                           #索引源声明
charset_type = utf-8                #数据编码(设置成utf8)
charset_table =                     #上面指定了utf-8，这里需要开启
}
增量索引
index testlstemmed:test1        #先进行注释
index distl                         #分布式也注释掉
索引器设置
indexer 
{ 
mem_limit = 256M # 内存大小限制 默认是 32M, 推荐为 256M 
}                                       #其他用默认即可
sphinx服务进程searchd的相关配置
searchd {
}                                       #全部用默认的就可以了&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了上述的配置项外还需要单独配置几项(如果你是安装的sphinx则进行上述配置即可，如果是coreseek则还需要配置下述内容)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;index test1
{
#stopwords                      = G:\data\stopwords.txt
#wordforms                      = G:\data\wordforms.txt
#exceptions                         = /data/exceptions.txt
#charset_type                       = sbcs
添加下面这两行，意思是把中文分词加入到配置文件中
charset_type        = zh_cn.utf-8
charset_dictpath    = /usr/local/mmseg/etc/    #你安装mmseg的目录
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;数据库操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 创建数据库
create database test;
// 创建数据表
userinfo | CREATE TABLE `userinfo` (
  `id` int(4) NOT NULL AUTO_INCREMENT,
  `name` varchar(10) NOT NULL,
  `age` int(3) NOT NULL,
  `sex` enum('女','男') NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4
// 插入数据
INSERT INTO `userinfo` VALUES (1,'张三',12,'女'),(2,'李四',13,'男'),    
(3,'小明',12,'女'),(4,'小红',13,'女'),(5,'小四',12,'女'),(6,'章泽天',13,'女');
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;创建索引数据(indexer)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 第一次创建索引
/usr/local/coreseek/bin/indexer -c /usr/local/coreseek/etc/csft.conf --all
// 第二次创建所以(当我们第一次创建索引之后，对数据表做了新的操作再按照上面的方式生成索引是会多增加一个参数)
/usr/local/coreseek/bin/indexer -c /usr/local/coreseek/etc/csft.conf  -rotate option&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果上述的操作执行正确，则会提示如下信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Coreseek Fulltext 3.2 [ Sphinx 0.9.9-release (r2117)]
Copyright (c) 2007-2011,
Beijing Choice Software Technologies Inc (http://www.coreseek.com)

 using config file '/usr/local/coreseek/etc/csft.conf'...
WARNING: no such index '-rotate', skipping.
WARNING: no such index 'option', skipping.
total 0 reads, 0.000 sec, 0.0 kb/call avg, 0.0 msec/call avg
total 0 writes, 0.000 sec, 0.0 kb/call avg, 0.0 msec/call avg&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;测试索引数据(search)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;/usr/local/coreseek/bin/search '小'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正常情况下会出现下述信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Coreseek Fulltext 3.2 [ Sphinx 0.9.9-release (r2117)]
Copyright (c) 2007-2011,
Beijing Choice Software Technologies Inc (http://www.coreseek.com)

 using config file '/usr/local/coreseek/etc/csft.conf'...
index 'test1': query '小 ': returned 3 matches of 3 total in 0.004 sec

displaying matches:
1. document=3, weight=1
2. document=4, weight=1
3. document=5, weight=1

words:
1. '小': 3 documents, 3 hits&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;启动searchd服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该服务是可以在/usr/local/coreseek/etc/csft.conf文件中的searchd配置项中配置，默认服务的端口已经配置，可以不单独做配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 启动服务
/usr/local/coreseek/bin/searchd -c /usr/local/coreseek/etc/csft.conf
// 检测服务启动情况
[root@test ~]# netstat -anp | grep 9312
tcp        0      0 0.0.0.0:9312            0.0.0.0:*               LISTEN      31672/searchd&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;创建测试代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试代码可以参见分享文件中的 &lt;strong&gt;测试代码&lt;/strong&gt; 目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;require './api/sphinxapi.php';
$sphinx = new SphinxClient();
$sphinx-&amp;gt;SetServer('127.0.0.1', 9312);
$sphinx-&amp;gt;SetArrayResult(true);
$sphinx-&amp;gt;SetMatchMode(SPH_MATCH_ALL);
$sphinx-&amp;gt;SetSortMode(SPH_SORT_RELEVANCE);
$result = $sphinx-&amp;gt;query('小', '*');
var_dump($result);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询出的结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array(10) {
  [&quot;error&quot;]=&amp;gt;
  string(0) &quot;&quot;
  [&quot;warning&quot;]=&amp;gt;
  string(0) &quot;&quot;
  [&quot;status&quot;]=&amp;gt;
  int(0)
  [&quot;fields&quot;]=&amp;gt;
  array(3) {
    [0]=&amp;gt;
    string(4) &quot;name&quot;
    [1]=&amp;gt;
    string(3) &quot;age&quot;
    [2]=&amp;gt;
    string(3) &quot;sex&quot;
  }
  [&quot;attrs&quot;]=&amp;gt;
  array(0) {
  }
  [&quot;matches&quot;]=&amp;gt;
  array(3) {
    [0]=&amp;gt;
    array(3) {
      [&quot;id&quot;]=&amp;gt;
      int(2)
      [&quot;weight&quot;]=&amp;gt;
      string(1) &quot;1&quot;
      [&quot;attrs&quot;]=&amp;gt;
      array(0) {
      }
    }
    [1]=&amp;gt;
    array(3) {
      [&quot;id&quot;]=&amp;gt;
      int(3)
      [&quot;weight&quot;]=&amp;gt;
      string(1) &quot;1&quot;
      [&quot;attrs&quot;]=&amp;gt;
      array(0) {
      }
    }
    [2]=&amp;gt;
    array(3) {
      [&quot;id&quot;]=&amp;gt;
      int(4)
      [&quot;weight&quot;]=&amp;gt;
      string(1) &quot;1&quot;
      [&quot;attrs&quot;]=&amp;gt;
      array(0) {
      }
    }
  }
  [&quot;total&quot;]=&amp;gt;
  string(1) &quot;3&quot;
  [&quot;total_found&quot;]=&amp;gt;
  string(1) &quot;3&quot;
  [&quot;time&quot;]=&amp;gt;
  string(5) &quot;0.003&quot;
  [&quot;words&quot;]=&amp;gt;
  array(1) {
    [&quot;小&quot;]=&amp;gt;
    array(2) {
      [&quot;docs&quot;]=&amp;gt;
      string(1) &quot;3&quot;
      [&quot;hits&quot;]=&amp;gt;
      string(1) &quot;3&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;coreseek错误记录&quot;&gt;coreseek错误记录&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;安装coerseek问题一&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;cd ../csft-3.2.14/      

sh buildconf.sh

./configure --prefix=/usr/local/coreseek --without-python --without-unixodbc --with-mmseg --with-mmseg-includes=/usr/local/mmseg3/include/mmseg/ --with-mmseg-libs=/usr/local/mmseg3/lib/ --with-mysql --host=arm

 vi src/sphinxexpr.cpp  #然后将所有的T val = ExprEval ( this-&amp;gt;m_pArg, tMatch ).....修改为T val =this-&amp;gt;ExprEval ( this-&amp;gt;m_pArg, tMatch )，共有三处。&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;安装coreseek错误二&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;make[2]: *** [tokenizer_zhcn.o] Error 1
make[2]: Leaving directory `/home/zyf/zyfwork/csft3.1b3/src’
make[1]: *** [all] Error 2
make[1]: Leaving directory `/home/zyf/zyfwork/csft3.1b3/src’
make: *** [all-recursive] Error 1

/usr/local/sphinx/src/sphinx.cpp:15557: undefined reference to `libiconv_open’
libsphinx.a(sphinx.o)(.text+0x53a01):/usr/local/sphinx/src/sphinx.cpp:15575: undefined
reference to `libiconv’
libsphinx.a(sphinx.o)(.text+0x53a28):/usr/local/sphinx/src/sphinx.cpp:15581: undefined
reference to `libiconv_close’
collect2: ld returned 1 exit status
make[2]: * [indexer] Error 1
make[2]: Leaving directory `/usr/local/sphinx/src’
make[1]: * [all] Error 2
make[1]: Leaving directory `/usr/local/sphinx/src’
make: * [all-recursive] Error 1


修改 configure 文件把 #define USE_LIBICONV 0 最后的数值由1改为0&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;安装coreseek问题三&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;db_interface_mysql.h:32:25: 致命错误：mysql/mysql.h：没有那个文件或目录
// ubuntu系统解决方案
sudo apt-get install libmysqlclient-dev
// centos7解决方案
sudo yum install mysql-devel&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;参考链接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/mungo/article/details/50126505?_t_t_t=0.09047716166802755&quot;&gt;参考链接一&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/houbin99999/article/details/73558090&quot;&gt;参考链接二&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qq_35118483/article/details/78410987&quot;&gt;参考链接三&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;coreseek额外说明&quot;&gt;coreseek额外说明&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;安装路径&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;/usr/local/coreseek&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;配置目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;/usr/local/coreseek/etc/&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;执行程序目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;/usr/local/coreseek/bin/&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;配置文件说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进入配置目录，你会找到如下几个文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-rw-r--r--. 1 root root   905 10月 13 21:27 example.sql
-rw-r--r--. 1 root root 18954 10月 13 21:27 sphinx.conf.dist
-rw-r--r--. 1 root root   956 10月 13 21:27 sphinx-min.conf.dist&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将sphinx.conf.dist文件复制一份名为csft.conf即可.其余文件可以不管.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;执行程序说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进入执行程序目录可以看到如下几个文件,具体参考请见&lt;a href=&quot;http://sphinxsearch.com/docs/current.html&quot;&gt;sphinx文档&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-rwxr-xr-x. 1 root root 7032560 10月 13 21:27 indexer // 生成索引程序
-rwxr-xr-x. 1 root root 6650552 10月 13 21:27 indextool // 调试程序
-rwxr-xr-x. 1 root root 6740544 10月 13 21:27 search  // 搜索程序
-rwxr-xr-x. 1 root root 7970448 10月 13 21:27 searchd  // 提供客户端查询索引服务
-rwxr-xr-x. 1 root root 6370256 10月 13 21:27 spelldump // 提取字典内容&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;分享文件目录说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;├── api.zip // coreseek类文件(该文件和测试代码目录下的api.zip是一样的)
├── coreseek-3.2.14.tar.gz // coreseek安装程序文件
├── coreseek配置文件 
│   └── csft.conf // 上述 配置coreseek配置文件 步骤中提交到的配置文件
├── 测试代码 
│   ├── api.zip
│   └── index.php // 测试代码
└── 测试数据库
    └── test.sql // 测试数据库&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 18 Oct 2018 15:28:00 +0000</pubDate>
<dc:creator>浪子编程走四方</dc:creator>
<og:description>coreseek安装与简单实用 安装环境 系统环境 centos7.2 1核2G 软件环境 coreseek 3.2.14</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qqblog/p/9813904.html</dc:identifier>
</item>
<item>
<title>PHP 对象基础知识 - itabel</title>
<link>http://www.cnblogs.com/it-abel/p/9813877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/it-abel/p/9813877.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最近开始重新学习对象知识，其实也算是初步深入学习对象和设计模式，希望自己会坚持下去，保持更新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;初识php对象&quot;&gt;初识PHP对象&lt;/h2&gt;
&lt;p&gt;还记得，刚开始学习 PHP 的时候，学到到方法和对象时有一个很大的疑问，对象与方法相比较那么麻烦（需要设置属性，给属性赋值，实例化类，调用）为什么还要用对象呢？随着逐步的深入才发现，自己之前的想法是有多可笑，下面给一个简单的示例。&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;function get_max($val_1, $val_2)
{
   return $val_1 &amp;gt; $val_2 ? $val_1 : $val_2;
}

$max = get_max(23,34);
echo $max;

echo '&amp;lt;br&amp;gt;======================这是华丽的分隔符======================&amp;lt;br&amp;gt;';

// 类
class Test
{
    // 属性
    public $val_1;

    public $val_2;

    // 类的方法
    public function __construct($val_1, $val_2)
    {
        $this-&amp;gt;val_1 = $val_1;
        $this-&amp;gt;val_2 = $val_2;
    }

    public function get_max()
    {
        return $this-&amp;gt;val_1 &amp;gt; $this-&amp;gt;val_2 ? $this-&amp;gt;val_1 : $this-&amp;gt;val_2;
    }
}

// 实例化类，$test 是由类 Test 生成的对象
$test = new Test(83, 34);
echo $test-&amp;gt;get_max();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到使用对象比单纯的方法多了很多代码，但是为什么还要使用对象呢，我们下一节详细介绍，别走开，往下看&lt;/p&gt;
&lt;h2 id=&quot;为什么使用对象&quot;&gt;为什么使用对象&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;什么是对象？什么是类？很多人会把两个搞混淆，我们可以把类看做一个工厂，产出的产品就是对象，也就是对象是类的实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个类通常包含属性、方法。举个🌰：有一个生产面包的机器（类），生成面包需要一些材料（属性），材料包含面粉、鸡蛋、水（不熟悉）。有了材料就可以运作生成面包了，这时机器会把准备好的材料放一起处理（方法）生成面包。&lt;/p&gt;
&lt;p&gt;关键字也是很重要的概念，用来决定声明的属性或方法的可见性，包含： public、protected、private。一个属性或方法设置为 public 就代表无论在对象内还是对象外都可以被使用，比如面包机里如果有一个搅拌机（仅限如果），如果这个搅拌机设置为public，则这个搅拌机可以被任何品牌的面包机使用。如果设置为 protected，则只能在同品牌的面包机中使用（继承的类）。如果设置为private则只能被自己用。&lt;/p&gt;
&lt;p&gt;回到上节问题，对比方法，问什么使用对象？因为方便，没错真的方便。因为对象有以下几个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;封装性&lt;/li&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;多态&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;封装性&quot;&gt;封装性&lt;/h3&gt;
&lt;p&gt;封装：顾名思义，就是把类的属性和方法封装起来，设置权限（public|protected|private），如下：&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;class Test
{
    public $val_1;

    protected $val_2;

    public function __construct($val_1, $val_2)
    {
        $this-&amp;gt;val_1 = $val_1;
        $this-&amp;gt;val_2 = $val_2;
    }

    protected function get_max()
    {
        return $this-&amp;gt;val_1 &amp;gt; $this-&amp;gt;val_2 ? $this-&amp;gt;val_1 : $this-&amp;gt;val_2;
    }
}

$test = new Test(83, 34);
echo $test-&amp;gt;get_max();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;封装的好处是安全、可控。&lt;br/&gt;以上代码因为引用了 protected 声明的方法，因此会报如下的错误&lt;br/&gt;Fatal error: Uncaught Error: Call to protected method StudyDesignMode\Test::get_max() from context '' in ...&lt;/p&gt;
&lt;h3 id=&quot;继承&quot;&gt;继承&lt;/h3&gt;
&lt;p&gt;同样顾名思义，就是继承分类的方法或属性，只能继承 public | protected 关键字声明的方法或属性。继承的主要作用是多个不同的类都需要同样的一个方法，可以使用继承。比如多个网站页面（每个页面都是单独的类）都需要验证是否登录，这时候可以定义一个父类，里面验证是否登录，再由需要验证登录的类继承，这样就不需要每个类都写一次验证。&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;class Test
{
    private $val_1;

    private $val_2;

    protected function set_value($val_1, $val_2)
    {
        $this-&amp;gt;val_1 = $val_1;
        $this-&amp;gt;val_2 = $val_2;
    }

    protected function getMax()
    {
        return $this-&amp;gt;val_1 &amp;gt; $this-&amp;gt;val_2 ? $this-&amp;gt;val_1 : $this-&amp;gt;val_2;
    }

    protected function getMin()
    {
        return $this-&amp;gt;val_1 &amp;gt; $this-&amp;gt;val_2 ? $this-&amp;gt;val_2 : $this-&amp;gt;val_1;
    }
}

class TestSub extends Test
{
    public function __construct($val_1, $val_2)
    {
        $this-&amp;gt;set_value($val_1, $val_2);
    }

    // 简单功能测试
    public function printMaxValue()
    {
        echo $this-&amp;gt;getMax();
    }

    public function printMinValue()
    {
        echo $this-&amp;gt;getMin();
    }
}

$test = new TestSub(83, 34);
echo '&amp;lt;br&amp;gt;======================这是华丽的分隔符 获取最大值======================&amp;lt;br&amp;gt;';
echo $test-&amp;gt;printMaxValue();
echo '&amp;lt;br&amp;gt;======================这是华丽的分隔符 获取最小值======================&amp;lt;br&amp;gt;';
echo $test-&amp;gt;printMinValue();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;br/&gt;======================这是华丽的分隔符 获取最大值======================&lt;br/&gt;83&lt;br/&gt;======================这是华丽的分隔符 获取最小值======================&lt;br/&gt;34&lt;/p&gt;
&lt;h3 id=&quot;多态&quot;&gt;多态&lt;/h3&gt;
&lt;p&gt;就是让具有继承关系的不同类对象重写类中的方法（两个类中有相同名称的方法），典型的应用是抽象类（abstract）和接口类(interface)。如下：&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;abstract class Vehicle
{
    abstract public function run();
}

class Car extends Vehicle
{
    public function run()
    {
        echo '速度100';
    }
}

class Bicycle extends Vehicle
{
    public function run()
    {
        echo '速度15';
    }
}

$car = new Car();
echo $car-&amp;gt;run();
echo '&amp;lt;br&amp;gt;======================这是华丽的分隔符======================&amp;lt;br&amp;gt;';
$bicycle = new Bicycle();
echo $bicycle-&amp;gt;run();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;br/&gt;速度100&lt;br/&gt;======================这是华丽的分隔符======================&lt;br/&gt;速度15&lt;/p&gt;
</description>
<pubDate>Thu, 18 Oct 2018 15:19:00 +0000</pubDate>
<dc:creator>itabel</dc:creator>
<og:description>最近开始重新学习对象知识，其实也算是初步深入学习对象和设计模式，希望自己会坚持下去，保持更新。本篇文章介绍了 PHP 对象的基础知识和三大特性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/it-abel/p/9813877.html</dc:identifier>
</item>
<item>
<title>Android基于jenkins全自动构建打包---------Windows版本（Android，Jenkins，360加固，Email，QRcode，参数构建，蒲公英） - 一粒代碼</title>
<link>http://www.cnblogs.com/pmokj/p/9809241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pmokj/p/9809241.html</guid>
<description>&lt;p&gt;&lt;span&gt; Android打包喝咖啡系列（Windows版）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这篇博客主要讲述的内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、windows上部署Jenkins &lt;a title=&quot;Jenkins&quot; href=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot;&gt;https://jenkins.io&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、基于SVN或Git &lt;a title=&quot;Jenkins测试APP&quot; href=&quot;https://github.com/Codetroupe/JenKinsTestAPP&quot; target=&quot;_blank&quot;&gt;https://github.com/Codetroupe/JenKinsTestAPP&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、Android项目参数化自动构建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4、自动&lt;/span&gt;&lt;span&gt;将APK上传至蒲公英 &lt;a title=&quot;蒲公英&quot; href=&quot;https://www.pgyer.com/&quot; target=&quot;_blank&quot;&gt;https://www.pgyer.com&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　  &lt;span&gt;5、自动发Email到指定邮箱提示构建结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　6、自动本地360插件加固apk包&lt;a title=&quot;360加固助手&quot; href=&quot;http://jiagu.360.cn/&quot; target=&quot;_blank&quot;&gt;http://jiagu.360.cn&lt;/a&gt;&lt;/span&gt;　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面开始正式内容，惯例先上一张界面图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018224622637-996923916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;第一步：windows上部署Jenkins并配置环境&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;1、打开官网&lt;a title=&quot;Jenkins&quot; href=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot;&gt;https://jenkins.io&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;　　&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;点击download，建议下载左边的稳定版，右边的踩过坑，莫名其妙报了个错，然后重装。选择windows版下载，得到一个安装程序，安装完成后自动开启服务&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;输入&lt;span&gt;&lt;a title=&quot;本地链接&quot; href=&quot;http://localhost:8080/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://localhost:8080&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;按着顺序，输入密钥，然后点击推荐插件，静静等待一段时间。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018111336700-1493516415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;当你进入下面这个页面的时候，就部署成功了，输入账号密码，admin的密码好像也是admin，我这里自己设置了账号Test&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018112030576-996780334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;登录账号&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018112341098-906760238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;2、配置环境变量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;好了，这步开始要认真看了，不然很容易GG ，先不要急着创建项目，我们先配置一些环境变量&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;a、安装插件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;em&gt;&lt;span&gt;点击&lt;/span&gt;&lt;/em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018113149781-1204314298.png&quot; alt=&quot;&quot;/&gt;----&amp;gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018113306404-1363262275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;em&gt;&lt;span&gt;安装插件：&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;a class=&quot;display-name&quot; href=&quot;http://wiki.jenkins.io/display/JENKINS/Build+Name+Setter+Plugin&quot;&gt;build-name-setter&lt;/a&gt;      &lt;em&gt;&lt;span&gt;作用：修改构建名称&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;a class=&quot;display-name&quot; href=&quot;http://wiki.jenkins-ci.org/display/JENKINS/Description+Setter+Plugin&quot;&gt;description setter plugin&lt;/a&gt;  　&lt;span&gt;&lt;em&gt;作用：修改构建目录的描述&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;a class=&quot;display-name&quot; href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Email-ext+Template+Plugin&quot;&gt;Email Extension Template Plugin&lt;/a&gt; 　　&lt;em&gt;&lt;span&gt;作用：Email模板编辑&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;a class=&quot;display-name&quot; href=&quot;https://wiki.jenkins.io/display/JENKINS/Locale+Plugin&quot;&gt;Locale plugin&lt;/a&gt;  　　&lt;em&gt;&lt;span&gt;作用：修改Jenkins默认语言&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;a class=&quot;display-name&quot; href=&quot;http://wiki.jenkins-ci.org/display/JENKINS/Timestamper&quot;&gt;Timestamper&lt;/a&gt;  　　&lt;em&gt;&lt;span&gt;作用：动态获取时间&lt;/span&gt;&lt;/em&gt;&lt;a class=&quot;display-name&quot; href=&quot;http://wiki.jenkins-ci.org/display/JENKINS/Timestamper&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;a class=&quot;display-name&quot; href=&quot;https://wiki.jenkins.io/display/JENKINS/Upload+Pgyer+Plugin&quot;&gt;Upload to pgye&lt;/a&gt;&lt;span&gt;r&lt;/span&gt;  　　&lt;em&gt;&lt;span&gt;作用：将APK上传到蒲公英&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;b、系统设置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　　　&lt;span&gt;&lt;em&gt;&lt;span&gt;点击&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018114331779-860910454.png&quot; alt=&quot;&quot;/&gt;----&amp;gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018114355908-982161754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;&lt;em&gt;&lt;span&gt;　如下图：&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　　　Date and Time Pattern　时间的显示格式（构建参数的时候需要用到）&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　　　环境变量分别是：&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　　　　　360加固插件的根目录（这个是360加固插件的目录，本机电脑上也要配环境变量。如果你不喜欢用360，那就换成你喜欢的就可以了，注意一定要可以使用DOS命令行进行加固的插件，这里是用DOS命令行进行apk加固，如何配置账号密码和加固渠道去官网查看就可以，讲得很详细）&lt;a title=&quot;360加固助手&quot; href=&quot;http://jiagu.360.cn/#/global/help/164&quot; target=&quot;_blank&quot;&gt;http://jiagu.360.cn/#/global/help/164&lt;/a&gt;  跟着教程先本地打包一次，确定配置是否成功，再继续进行下面步骤&lt;a title=&quot;360加固助手&quot; href=&quot;http://jiagu.360.cn/&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　　　　　SDK的根目录（目录位置不知道的可以从Android studio查看，快捷键Ctrl+shift+Alt+s）&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　　　　　java根目录&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　　　Default Language 这个是Jenkins语言设置。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018114608569-1960782537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　&lt;em&gt;&lt;span&gt;系统管理员的邮箱一定要设置，这是个坑，要是不设置，你的邮箱怎么配置都不会触发，Jenkins URL则是访问地址安装的时候会要求设置，我这里是设置成本机电脑ip，这样局域网内别的电脑也可以访问。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018115221515-284224627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;下面是邮箱设置，根据如图所示设置应该没什么问题，SMTP server根据你的邮箱服务器来设置即可&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018115555936-1086006658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018115644173-1161170739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;邮件模板，这个模板的信息基本够用。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
标题：&lt;br/&gt;[Jenkins构建通知]$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS!&lt;span&gt;

内容：
(邮件由Jenkins自动发出，请勿回复&lt;/span&gt;~)&amp;lt;br&amp;gt;&lt;span&gt;
项目名称：$PROJECT_NAME&lt;/span&gt;&amp;lt;br&amp;gt;&lt;span&gt;
构建编号：$BUILD_NUMBER&lt;/span&gt;&amp;lt;br&amp;gt;&lt;span&gt;
构建状态：$BUILD_STATUS&lt;/span&gt;&amp;lt;br&amp;gt;&lt;span&gt;
触发原因：${CAUSE}&lt;/span&gt;&amp;lt;br&amp;gt;&lt;span&gt;
构建地址：&lt;/span&gt;&amp;lt;A HREF=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${HUDSON_URL}/job/${PROJECT_NAME}/${BUILD_NUMBER}/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;${HUDSON_URL}/job/${PROJECT_NAME}/${BUILD_NUMBER}/&amp;lt;/A&amp;gt;&amp;lt;br&amp;gt;&lt;span&gt;
构建输出日志：&lt;/span&gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${HUDSON_URL}/job/${PROJECT_NAME}/${BUILD_NUMBER}/console&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;${HUDSON_URL}/job/${PROJECT_NAME}/${BUILD_NUMBER}/console&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;&lt;span&gt;
下载地址：&lt;/span&gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.pgyer.com/projectname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.pgyer.com/projectname&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&lt;/span&gt;
二维码下载：&amp;lt;img src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.pgyer.com/app/qrcode/projectname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;&amp;lt;br&amp;gt;&lt;span&gt;
最近修改：&lt;/span&gt;&amp;lt;br&amp;gt;${CHANGES, showPaths=&lt;span&gt;false&lt;/span&gt;, format=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%a：\&quot;%m\&quot;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, pathFormat=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n\t- %p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;好了，到这里系统设置就配置完成了，点击应用，保存&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;&lt;strong&gt;c、全局工具配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;点击&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018113149781-1204314298.png&quot; alt=&quot;&quot;/&gt;--&amp;gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018140824446-803996813.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;只需要配置Gradle即可，我配置的是Android Studio默认使用的Gradle&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018140912789-1186581126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;&lt;em&gt;&lt;span&gt;到这步为止，环境的配置准备就完成了，环境配置其实挺简单，没什么复杂的地方，细心一点不要漏了地方就可以了。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 　　&lt;strong&gt;&lt;span&gt;第二步：创建项目，测试构建结果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　a、创建项目&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;em&gt;&lt;span&gt;回到首页，点击&lt;/span&gt;&lt;/em&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018142927272-164928594.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;创建一个自由风格的软件项目，命名为JenkinsTestApp&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018143051657-1127209215.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;点击确定，进入项目配置页面&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　首先配置源码管理，如果你使用我的github的源码，那么不需要输入账号密码，只需要复制git链接即可，如果是私有库，则点击add可以增加账号密码凭据，只输入username和password即可&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018143345927-1896793341.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;span&gt;然后配置构建，选择Invoke Gradle script&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018143641629-2079000660.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;根据图示内容配置，gradle-4.4即刚刚在全局工具里配置的Gradle&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　 点击展开Tasks，然后输入&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;clean
assembleDebug
&lt;/span&gt;--&lt;span&gt;stacktrace
&lt;/span&gt;--debug
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;span&gt;输入完上面内容后，展开高级内容，勾选&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018144446145-1618581679.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;windows一定要勾选，不然构建失败，这个选项就相当于Android Studio的Gradle的缓存目录，如果项目多，懒得勾选，则可以在第一步的系统设置中的环境变量中配置GRADLE_USER_HOME环境，本地找个文件夹即可（最好使用Android Studio的Gradle默认缓存目录）&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018151326991-1567480441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　&lt;em&gt;&lt;span&gt;点击应用，保存，然后点击&lt;/span&gt;&lt;/em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018144141394-226525783.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;即可进行构建，如图构建成功，可以进去查看日志，或者到工作空间去查看生成的apk包，我的工作空间的目录 D:\Software\Jenkins\workspace\JenkinsTestApp\app\build\outputs\apk\debug，可以看到我构建了4次才构建成功，因为第一次忘记勾选缓存目录，第二次是构建release，没有注入签名文件的参数，后面会慢慢叙说，第三次次忘记去除debug构建的&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;signingConfigs&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;嗯，到了这里，基本用Jenkins对Android项目打包是基本实现了。不是新建一份Android项目上传到git就可以打包的，需要进行一定的配置，具体自己可以查看我github上的源码，有注释也算是比较清晰。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018151423362-234237929.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;em&gt;　　&lt;span&gt;这时候你可能会想了，前面配置的环境和搭建的Email模板和360加固怎么都没用上，先不用着急，有阶段性的成功，才有继续下去的动力，想想我之前刚开始弄的时候，这部分都被搞得一脸懵，看一些博客，不是写漏了一些关键点，就是不附带参考源码，这让人很是烦躁，总是差这么一点点，然后自己慢慢找慢慢推敲，对会弄的人来说，他们的教程是都很好的，我现在回去看，一眼都能get到点，但是对初次接手Jenkins的人来说，真是很无奈，我想我这篇博客应该算是清晰的了。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;span&gt;　　好，我们继续往下看。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;&lt;strong&gt;b、参数化构建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;这一部分还是很好玩的，参数构建我觉得是个比较神奇的东西，回到项目配置的General勾选参数化构建过程&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018153230848-1162365303.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;点击添加参数，我用到的参数如下：（这里可以自己熟悉了以后，不断地添加参数构建，完善项目）&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　名称：BUILD_TYPE&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　选项：&lt;/em&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;debug release  （注意选项参数要回车换行）&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　&lt;em&gt;这个是选择release版构建还是debug版构建使用&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018153409301-710529016.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　名称：JENKINS_TIME&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　默认值：$BUILD_TIMESTAMP   （这是调用Jenkins环境变量的语法）&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　&lt;/em&gt;这个是包名的时间戳，就是在环境变量里勾选的插件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018153428951-1159821188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;名称：IS_JENKINS&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　默认值：true&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　&lt;em&gt;如描述，这个参数方便Jenkins打包或者手动打包&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018153545536-168624524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　名称：APP_VERSION  /  JENKINS_BUILD_NUMBER&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　默认值：1.0.$BUILD_NUMBER  /   $BUILD_NUMBER    (调用环境变量的构建序号)&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　&lt;em&gt;这两个参数分别是APP的版本号和代码版本号&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018153706701-139191520.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;span&gt;名称：APP_STORE_FILE_DIR  /  APP_STORE_PASSWORD&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　默认值：D:\AndroidProject\key\JenKinsTestKey.jks  /  kk123456&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　这两个参数分别是签名文件所在的路径和签名文件的密码（签名文件生成应该不用说了，搜都能搜出一大把了）&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018154448853-1390761926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;名称：APP_KEY_ALIAS  /  APP_KEY_PASSWORD&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　默认值：test1  /  kk123456&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　这两个参数是签名文件子文件名称和子文件密码&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018154726281-1192601865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;em&gt;&lt;span&gt;　名称：REINFORCE_FOR_360&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　选项：2  1  （注意选项参数要回车换行）&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;span&gt;这个参数表示是否启动360加固APP&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018154938689-991660529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;span&gt;名称：APK_NAME　　&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　  默认值：JenkinsTestApp&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;用于获取构建生成的包的名字，需要和重命名的包名一致，不然无法找到文件（后面有详细说明）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018180121325-1675945261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　&lt;span&gt;&lt;em&gt;&lt;span&gt;参数配置完成，可以自己持续添加自己需要的参数，也可以自己更改参数名称，但是更改的参数名称要和Android项目中gradle.properties文件中的参数名对应，有些需要默认参数，签名文件为了安全尽量不要填写默认密码&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#是否是Jenkins打包
IS_JENKINS &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
#Jenkins打包时间戳
JENKINS_TIME &lt;/span&gt;= ''&lt;span&gt;
#APP版本号
APP_VERSION&lt;/span&gt;= 1.0.0&lt;span&gt;
#APP代码版本号
JENKINS_BUILD_NUMBER &lt;/span&gt;= 1&lt;span&gt;
#APP签名文件信息
APP_KEY_PASSWORD &lt;/span&gt;= &quot;&quot;&lt;span&gt;
APP_STORE_PASSWORD &lt;/span&gt;= &quot;&quot;&lt;span&gt;
APP_KEY_ALIAS &lt;/span&gt;= &quot;&quot;&lt;span&gt;
APP_STORE_FILE_DIR&lt;/span&gt;=&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;span&gt;在构建中，把Tasks中的Debug改成${BUILD_TYPE}调用刚刚配置的参数，勾选Pass all job paramenters as Project properties 把参数注入到项目中&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018165853682-461204911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;点击应用，保存，会发现项目首页的立即构建变成了Build with Parameters，点击则出现右侧参数列表，选择release尝试构建。不出意外，构建成功，这里就不截图了。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018161055765-1828415817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;&lt;em&gt;&lt;span&gt;到此为止，参数化构建就已经部署成功了，分为debug模式和release模式，其他模式自己可以添加&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;&lt;em&gt;&lt;span&gt;我们继续优化一下项目配置结构&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　丢弃旧的构建，如图所示&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018172126478-155428664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;&lt;em&gt;触发构建器&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　每隔10分钟检查资源库是否有提交更新，有更新则进行构建&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
*/10 * * * *
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018172222949-135723886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;span&gt;构建环境&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　  修改构建列表的名称，便于观察&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#${BUILD_NUMBER}_${BUILD_TYPE}_V-${APP_VERSION}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018172358431-418470741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;c、360加固apk&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;em&gt;&lt;span&gt;360加固APK是根据自己写的一个.bat文件，然后通过Jenkins调用进行加固，写的时候可以说是呕心沥血了，因为不熟练.bat的编写格式，踩了很多坑&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　首先在构建中加入执行Windows批处理命令&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　调用参数的方式有点区别，在Jenkins调用变量参数用$xxxx  Windows批处理命令则用%xxxxxx%&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　下列调用的都是上面定义的参数，其中&lt;/span&gt;&lt;span&gt;%WORKSPACE%是默认环境变量的 工作空间目录&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
jenkins_apk_doing.bat %BUILD_TYPE% %JENKINS_BUILD_NUMBER% %APP_VERSION% %JENKINS_TIME% %REINFORCE_FOR_360% %WORKSPACE% %APK_NAME%
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018195722077-1578165715.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;哈哈，应该没有人会以为这一句命令代码就可以执行360加固了吧，下面开始重头戏&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　找到360加固插件的根目录D:\Software\jiagu，创建一个text文档命名jenkins_apk_doing，然后把后缀改成 .bat，然后用记事本打开输入下面代码&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@echo off

SET typed&lt;/span&gt;=%&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
SET num&lt;/span&gt;=%&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
SET ver&lt;/span&gt;=%&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
SET time&lt;/span&gt;=%&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
SET or&lt;/span&gt;=%&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
SET dir&lt;/span&gt;=%&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
SET projectname&lt;/span&gt;=%&lt;span&gt;7&lt;/span&gt;&lt;span&gt;

echo param[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] =%&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
echo param[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] =%&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
echo param[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] =%&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
echo param[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] =%&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
echo param[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] =%&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
echo param[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] =%&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
echo param[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] =%&lt;span&gt;7&lt;/span&gt;&lt;span&gt;

cd &lt;/span&gt;/d %~&lt;span&gt;dp0 

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; %or%==&lt;span&gt;1&lt;/span&gt; &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; todoingreinforce 
echo.
exit


:todoingreinforce
start D:\Software\jiagu\java\bin\java &lt;/span&gt;-jar jiagu.jar -jiagu %dir%\app\build\outputs\apk\%typed%\%projectname%-%typed%-v%ver%#%num%-%time%.apk D:\Software\StrengthenedAPK\ -autosign -&lt;span&gt;automulpkg
echo.
exit   &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　如果看不太懂，没关系，只要把路径改一改就可以了，注意有个地址是D:\Software\StrengthenedAPK\这是我D盘目录下的文件夹，是用来放加固好的APK文件的，如果你看了360加固助手官方文档，应该基本看得懂start后面的语句，也就是DOS命令下执行加固的命令，有了这个文件以后就可以进行360加固打包了，去试一下吧，构建完以后在&lt;em&gt;D:\Software\StrengthenedAPK\（需要手动创建文件夹）目录下应该是有加固好的apk文件了&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;em&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018215241477-1006918256.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 　　&lt;span&gt;&lt;strong&gt;d、将APK包上传到蒲公英&lt;a title=&quot;蒲公英&quot; href=&quot;https://www.pgyer.com/&quot; target=&quot;_blank&quot;&gt;https://www.pgyer.com&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　 　　&lt;em&gt;&lt;span&gt;注册账号，登录&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　　　点击&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018215848392-39041750.png&quot; alt=&quot;&quot;/&gt;---&amp;gt;&lt;/span&gt;&lt;/em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018215904382-1311585695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　&lt;span&gt;&lt;em&gt;&lt;span&gt;获取API KEY 和 USER KEY&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018220007272-869954286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;span&gt;然后将Key填入对应的空格&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　scandir：${WORKSPACE}\app\build\outputs\apk\${BUILD_TYPE}&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　file wildcard：${APK_NAME}-${BUILD_TYPE}-v${APP_VERSION}#${JENKINS_BUILD_NUMBER}-${JENKINS_TIME}.apk&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018220150027-860442291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;span&gt;点击应用，然后保存构建，即可上传到蒲公英，就是这么简单，构建成功后查看日志&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018221035009-1436197060.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;span&gt;可以获取应用页面，拿到二维码链接和下载链接，也可以去蒲公英查看&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt; 　蒲公英会生成一个专属页面，可以查看标签去获取二维码链接和下载链接&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018221247495-75726310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;span&gt;拿到二维码链接和下载链接以后，就可以修改描述页面和构建名称了&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　在构建和操作中添加Set build description&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;img  src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.pgyer.com/app/qrcode/xxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt; &amp;lt;br&amp;gt;下载地址：&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.pgyer.com/app/qrcode/xxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;APK下载链接&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018221733740-387132220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;span&gt;现在再去进行构建，你就会发现有很美观的界面了，看吧，已经有二维码了，可以直接扫码安装测试&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018222508832-1428427248.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;e、构建完成后发邮件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;在构建后操作添加Editable Email Notification，默认部分不需要更改，因为内容在配置系统设置的时候已经配置好，如果要动态增加接收人的邮箱，在Project Recipient List 中加入邮箱即可用 ，隔开，点击底部的Advanced Settings设置触发条件。即可发送邮件到指定邮箱。可以根据自己的需要配置邮箱触发事件，如果不配置则不会发送邮箱&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018222757478-1541715042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018223048833-1193096315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;span&gt;点击应用保存，然后进行构建，一段时间后，就能收到邮件了，如果你是局域网电脑打开邮件，就可以直接访问构建日志和构建目录了，这样其他开发者也可以看到结果，不用自己去看是否构建完成。点击构建就可以喝咖啡了（虽然我不喝咖啡）。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1173105/201810/1173105-20181018223901328-1847068820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;span&gt;好了，到这里全部内容就写完了，写了大概半天的时间，出博客挺快的，自己琢磨了大概一周，遇到各种坑，希望对大家有帮助，大家看完试着搭建一下，然后有坑可以留言一下，可以把构建次数发一下，我看下你们构建了几次才完全成功，看吧，我重新构建都构建了20次。说明确实很多东西容易忽略，Jenkins搭起来以后就不需要自己去处理签名文件什么的，一次搭建以后都方便用，顺带提一下，蒲公英免费版做测试还是很不错的，要是商用，就自己测试一下吧，我是有时候会上传失败，多点几次也可以上传上去。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;版权所有，如有转载请注明出处，谢谢&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Oct 2018 15:04:00 +0000</pubDate>
<dc:creator>一粒代碼</dc:creator>
<og:description>Android基于Jenkins根据svn提交目录，自动构建，自动发送邮件，自动生成下载链接和二维码，自动用360加固助手进行加固</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pmokj/p/9809241.html</dc:identifier>
</item>
<item>
<title>【完整版】切比雪夫定理的证明 - 黑山雁</title>
<link>http://www.cnblogs.com/xjtu-blacksmith/p/9813663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjtu-blacksmith/p/9813663.html</guid>
<description>&lt;h2 id=&quot;导言&quot;&gt;导言&lt;/h2&gt;
&lt;blockquote readability=&quot;3.953488372093&quot;&gt;
&lt;p&gt;说明： &lt;a href=&quot;https://www.cnblogs.com/xjtu-blacksmith/p/8398395.html&quot;&gt;原文档&lt;/a&gt;已更新为此文档！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里分享的是一个有关积分的初等可积性的&lt;strong&gt;切比雪夫定理&lt;/strong&gt;的证明过程，其中包含了对初等函数的定义、对阿贝尔积分的一些初步探讨、刘维尔的一个初等可积判断定理和最终切比雪夫关于二项微分式积分&lt;strong&gt;初等可积性&lt;/strong&gt;的定理。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;切比雪夫定理&lt;/strong&gt;：设&lt;span class=&quot;math display&quot;&gt;\[\int x^m(a+bx^n)^p\mathrm{d}x\]&lt;/span&gt;为一个二项微分式积分，其中&lt;span class=&quot;math inline&quot;&gt;\(p,m,n\)&lt;/span&gt;均为有理数，则其可表示为初等函数的充要条件是&lt;span class=&quot;math inline&quot;&gt;\(p,\frac{m+1}{n},\frac{m+1}{n}+p\)&lt;/span&gt;中至少一个为&lt;strong&gt;整数&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章来自前苏联盖·伊·德林费尔特所著的《&lt;em&gt;普通数学分析教程补篇&lt;/em&gt;》第六章，原书的中译本出版于1960年，后来一直未尝再版。（&lt;em&gt;网上可下载到电子书&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;积分的初等可积性是分析内容中一个比较古典的课题，不过随着一些现代元素的引入（例如微分代数之类的）而又发出新的光芒。可能由于这些方面的古典问题较早就已经探讨清楚了（该解决的都解决了，没解决的也知道只能解决到哪一个程度，比如说已经知道不存在有效判别一个积分是否初等可积的方法，但是对一些特定类型的积分已经研究的比较透彻），国内目前几乎找不到有关于这一问题的比较初等的书籍（至多只能找到从现代观点出发的那种，普通的数学爱好者根本无法阅读）。&lt;/p&gt;
&lt;p&gt;我是在做谢惠民的数学分析习题时看到书中提到这一本书，去阅读过后感到原书的翻译非常晦涩（我个人认为原书的翻译水平实在让一般人无法接受），因而前段时间花了一些功夫，反复阅读这一章节几次，基本上理解清楚了相关内容。我个人认为这是目前国内能找到的仅有的一份可供&lt;strong&gt;低年级大学生&lt;/strong&gt;或&lt;strong&gt;非数学专业学生&lt;/strong&gt;阅读理解的关于初等可积性理论的文章，因而认为其颇有一些价值，故自己把原文重述一遍（读者可&lt;a href=&quot;https://pan.baidu.com/s/1pMax3Gf&quot;&gt;点此下载&lt;/a&gt;原版书籍与我的调整版本做对比，便知原来的翻译的确有许多不可取之处），并加上一些必要的注解，方便读者阅读体会。&lt;/p&gt;
&lt;p&gt;另外，我对其中的某些证明过程之理解可能存在偏差，恳请读者指出并联系我改正，本人将十分感激。希望此文可对读者的数学知识提扩展有一定帮助，也希望这一内容能给读者带来乐趣。&lt;/p&gt;
&lt;p&gt;欢迎分享这份文档。&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;源码一并附上（&lt;em&gt;虽然其实没用什么很复杂的代码&lt;/em&gt;）。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;这一章，我们将遵循N.G.Chebotarev（契巴塔廖夫）的方法,证明关于形如&lt;br/&gt;\begin{equation}&lt;br/&gt;\int R(x,y)\mathrm{d}x\label{e1}&lt;br/&gt;\end{equation} 的积分的某些古典定理,式中&lt;span class=&quot;math inline&quot;&gt;\(y=y(x)\)&lt;/span&gt;为 &lt;strong&gt;代数函数&lt;/strong&gt;  ,&lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt;是关于&lt;span class=&quot;math inline&quot;&gt;\(x,y\)&lt;/span&gt;的有理函数.&lt;/p&gt;
&lt;p&gt;型&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e1})}\)&lt;/span&gt;的积分叫做&lt;strong&gt;Abel积分&lt;/strong&gt;.特别,形如&lt;br/&gt;\begin{equation}\label{e2}\int R(x,\sqrt{ax^2+bx+c})\mathrm{d}x,\end{equation}&lt;br/&gt;\begin{equation}\label{e3}\int x^m(a+bx^n)^p\mathrm{d}x\end{equation}&lt;br/&gt;的积分都是Abel积分.&lt;/p&gt;
&lt;p&gt;要记住,积分&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e2})}\)&lt;/span&gt;借助&lt;strong&gt;Euler变换&lt;/strong&gt; 总可以划归为有理函数的积分.所以,积分&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e2})}\)&lt;/span&gt;一定能表示为初等函数.&lt;/p&gt;
&lt;p&gt;积分&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e3})}\)&lt;/span&gt;称为&lt;strong&gt;二项微分式积分&lt;/strong&gt;,也可用初等函数来表示,前提是数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p,\frac{m+1}{n},\frac{m+1}{n}+p\]&lt;/span&gt; 之中至少有一个是整数.而P.L.Chebyshev的古典定理乃是:&quot;若三数&lt;span class=&quot;math inline&quot;&gt;\(p,\frac{m+1}{n},\frac{m+1}{n}+p\)&lt;/span&gt;都不是整数,则积分(3)不能表示为初等函数&quot;.&lt;/p&gt;
&lt;p&gt;我们的主要目标就是要来证明这个定理.&lt;/p&gt;
&lt;h3 id=&quot;关于初等函数&quot;&gt;1 关于初等函数&lt;/h3&gt;
&lt;p&gt;我们把&lt;strong&gt;初等函数&lt;/strong&gt;理解为独立变量&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;与函数&lt;span class=&quot;math inline&quot;&gt;\(\ln \omega_i(x),i=1,2,\cdots,k\)&lt;/span&gt;的代数函数,其中&lt;span class=&quot;math inline&quot;&gt;\(\omega_i(x)\)&lt;/span&gt;也是代数函数,但可以是复的.&lt;br/&gt;显然.函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[x^m,\quad(a_1x^{m_1}+a_2x^{m_2}+\cdots+a_kx^{m_k})^p,\quad\ln{\frac{a_1x^{m_1}+a_2x^{m_2}+\cdots+a_kx^{m_k}}{b_1x^{n_1}+b_2x^{n_2}+\cdots+b_qx^{n_q}}}\]&lt;/span&gt;&lt;br/&gt;都是初等函数,但设其中所有指数都是有理数.不过,我们可以证明,函数&lt;span class=&quot;math display&quot;&gt;\[\arcsin x,\quad\arccos x,\quad\arctan x,\quad\textrm{arccot} x\]&lt;/span&gt;也是初等函数.实际上,从关系式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\sin t=\frac{e^{it}-e^{-it}}{2i}=x\]&lt;/span&gt; 得出 &lt;span class=&quot;math display&quot;&gt;\[\begin{aligned} e^{it} &amp;amp;= ix+\sqrt{1-x^2} \\ t = \arcsin x &amp;amp;= -i\ln(ix+\sqrt{1-x^2})\end{aligned}\]&lt;/span&gt; 而从关系式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\tan t=\frac{e^{it}-e^{-it}}{i(e^{it}+e^{-it})}=x\]&lt;/span&gt; 得到&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{aligned} e^{2it} &amp;amp;= \frac{1+ix}{1-ix} = \frac{(1+ix)^2}{1+x^2}\\ t &amp;amp;= \arctan x = -\frac{i}{2}\ln\frac{(1+ix)^2}{1+x^2}.\end{aligned}\]&lt;/span&gt;&lt;br/&gt;(从而证明了&lt;span class=&quot;math inline&quot;&gt;\(\arcsin x\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(\arctan x\)&lt;/span&gt;是初等函数.)显然,没有必要再去证明&lt;span class=&quot;math inline&quot;&gt;\(\arccos x\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(\textrm{arccot} x\)&lt;/span&gt;的初等性.&lt;/p&gt;
&lt;h3 id=&quot;abel积分的分类&quot;&gt;2 Abel积分的分类&lt;/h3&gt;
&lt;p&gt;我们把Abel积分写成这样的形式: \begin{equation}\label{e4}\int_a^x R(t,y(t))\mathrm{d}t.\end{equation}&lt;/p&gt;
&lt;p&gt;同时,我们还对Abel积分作如下分类:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;取遍所有可能的值时,积分&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e4})}\)&lt;/span&gt;都有限,那么称这个积分为&lt;strong&gt;第一类Abel积分&lt;/strong&gt;.例如,积分&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\int_0^x \frac{\mathrm{d}t}{\sqrt{1+t^4}}\]&lt;/span&gt; 就是第一类Abel积分.&lt;/li&gt;
&lt;li&gt;如果当积分&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e4})}\)&lt;/span&gt;的上限取某些值,如取 &lt;span class=&quot;math display&quot;&gt;\[a_1,a_2,\cdots,a_k\]&lt;/span&gt;&lt;br/&gt;时,积分的值为无穷大,并且该积分还可在任意一个&lt;span class=&quot;math inline&quot;&gt;\(x=a_i\)&lt;/span&gt;的邻域内展开为关于&lt;span class=&quot;math inline&quot;&gt;\(x-a_i\)&lt;/span&gt;的幂级数,这样的幂级数中仅有有限个负指数项,那么称这个积分是&lt;strong&gt;第二类Abel积分&lt;/strong&gt;.例如,积分&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\int_0^x \frac{\mathrm{d}t}{(1-t^2)^\frac{3}{2}}=-1+\frac{1}{\sqrt{1-x^2}}\]&lt;/span&gt;&lt;br/&gt;就是一个第二类Abel积分.特别地,如果一个第二类Abel积分仅有&lt;strong&gt;一个&lt;/strong&gt;使其值为无穷大的点(即&lt;span class=&quot;math inline&quot;&gt;\(k=1\)&lt;/span&gt;),那么称其为&lt;strong&gt;基本的第二类Abel积分&lt;/strong&gt;.例如,积分&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\int_0^x\frac{\mathrm{d}t}{\sqrt{(1-t)^3}}=2(\frac{1}{\sqrt{1-x}}-1)\]&lt;/span&gt;&lt;br/&gt;是一个基本的第二类Abel积分.&lt;/li&gt;
&lt;li&gt;如果积分&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e4})}\)&lt;/span&gt;具有对数奇点,则称其为&lt;strong&gt;第三类Abel积分&lt;/strong&gt;.例如,积分&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\int_0^x\frac{t\mathrm{d}t}{1+t^2}=\frac{1}{2}\ln(1+x^2)\]&lt;/span&gt;&lt;br/&gt;在&lt;span class=&quot;math inline&quot;&gt;\(x=\pm i,x=\infty\)&lt;/span&gt;时有对数奇点,故其是第三类Abel积分.特别的,如果一个第三类Abel积分只具有两个对数奇点,则称其为一个&lt;strong&gt;基本的第三类Abel积分&lt;/strong&gt;.(可以证明,对于第三类Abel积分,其至少有&lt;strong&gt;两个&lt;/strong&gt;对数奇点.)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面的一个定理说明了这一分类方法的意义:&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;定理1&lt;/strong&gt;. 每一个Abel积分,一定能够用有限个第一类Abel 积分,有限个基本的第二类Abel积分和有限个基本的第三类Abel 积分来&lt;strong&gt;线性地&lt;/strong&gt;表示.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此处我们不打算证明这个定理.&lt;/p&gt;
&lt;h3 id=&quot;有理函数体及其扩张&quot;&gt;3 有理函数体及其扩张&lt;/h3&gt;
&lt;p&gt;变量&lt;span class=&quot;math inline&quot;&gt;\(x,y,\cdots\)&lt;/span&gt;的一切有理函数的全体,称为关于&lt;span class=&quot;math inline&quot;&gt;\(x,y,\cdots\)&lt;/span&gt;的&lt;strong&gt;有理函数体&lt;/strong&gt;(简称&lt;strong&gt;体&lt;/strong&gt;),并记作&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[k(x,y,\cdots).\]&lt;/span&gt;&lt;br/&gt;如果元素&lt;span class=&quot;math inline&quot;&gt;\(z(x,y,\cdots)\)&lt;/span&gt;不属于&lt;span class=&quot;math inline&quot;&gt;\(k(x,y,\cdots)\)&lt;/span&gt;,那么系数取自&lt;span class=&quot;math inline&quot;&gt;\(k(x,y,\cdots)\)&lt;/span&gt;&lt;br/&gt;的一切关于&lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt;的有理函数的全体,就称为体&lt;span class=&quot;math inline&quot;&gt;\(k(x,y,\cdots)\)&lt;/span&gt;关于&lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt;的一个&lt;strong&gt;代数扩张&lt;/strong&gt;,并用&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[k(x,y,\cdots;z)\]&lt;/span&gt;&lt;br/&gt;来表示.这样所得到的体,又可以添加新的元素进行代数扩张.一个代数扩张可简称为一个&lt;strong&gt;扩张&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;另外,我们称一个扩张&lt;span class=&quot;math inline&quot;&gt;\(k(x,y,\cdots;z)\)&lt;/span&gt;是&lt;strong&gt;简单代数&lt;/strong&gt;的,如果&lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt;满足如下的&lt;strong&gt;不可约方程&lt;/strong&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[f(z)=A_0z^n+A_1z^{n-1}+\cdots+A_{n-1}z+A_n=0,\]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(f(z)\)&lt;/span&gt;是不可约的(即不能表示为&lt;span class=&quot;math inline&quot;&gt;\(f(z)=f_1(z)\cdot f_2(z)\)&lt;/span&gt;的形式),&lt;span class=&quot;math inline&quot;&gt;\(A_i\)&lt;/span&gt;属于&lt;span class=&quot;math inline&quot;&gt;\(k(x,y,\cdots)\)&lt;/span&gt;且不全为零.&lt;/p&gt;
&lt;p&gt;在代数函数论中可以证明:&lt;/p&gt;
&lt;blockquote readability=&quot;26&quot;&gt;
&lt;p&gt;&lt;strong&gt;定理2&lt;/strong&gt;. 体&lt;span class=&quot;math inline&quot;&gt;\(k(x,y,\cdots)\)&lt;/span&gt;的任何有限的代数扩张&lt;span class=&quot;math inline&quot;&gt;\(k(x,y,\cdots;z_1,z_2,\cdots,z_m)\)&lt;/span&gt;一定是&lt;strong&gt;单纯扩张&lt;/strong&gt;.也就是说,对体&lt;span class=&quot;math inline&quot;&gt;\(k(x,y,\cdots)\)&lt;/span&gt;添加不可约方程&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{cases} f_1(z)&amp;amp;=0 \\ f_2(z)&amp;amp;=0 \\ \cdots \\ f_m(z)&amp;amp;=0 \end{cases}\]&lt;/span&gt;&lt;br/&gt;的根&lt;span class=&quot;math inline&quot;&gt;\(z_1,z_2,\cdots,z_m\)&lt;/span&gt;,总是可以等价于添加一个不可约方程&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[f(z)=0\]&lt;/span&gt;&lt;br/&gt;的所有根,该方程的根即为&lt;span class=&quot;math inline&quot;&gt;\(z_1,z_2,\cdots,z_m\)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们只用一个初等的例子来验证这个定理.设对体&lt;span class=&quot;math inline&quot;&gt;\(k(x)\)&lt;/span&gt;添加元素&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{x},\sqrt{1+x}\)&lt;/span&gt;进行扩张得到&lt;span class=&quot;math inline&quot;&gt;\(k(x;\sqrt{x},\sqrt{1+x})\)&lt;/span&gt;.而&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{x},\sqrt{1+x}\)&lt;/span&gt;是不可约方程&lt;br/&gt;\begin{equation}\label{x1}&lt;br/&gt;\begin{cases}&lt;br/&gt;z^2-x&amp;amp;=0\&lt;br/&gt;z^2-(x+1)&amp;amp;=0&lt;br/&gt;\end{cases}\end{equation} 的根.又由于有关系式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{1}{\sqrt{x}+\sqrt{1+x}}=\sqrt{x+1}-\sqrt{x}\]&lt;/span&gt; 成立,那么只要令&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[u=\sqrt{x}+\sqrt{1+x},\]&lt;/span&gt; 就可以算得 &lt;span class=&quot;math display&quot;&gt;\[\begin{cases} \sqrt{x+1}&amp;amp;=\frac{1}{2}(u+\frac{1}{u}),\\ \sqrt{x}&amp;amp;=\frac{1}{2}(u-\frac{1}{u}). \end{cases}\]&lt;/span&gt; 另外,很容易验证&lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt;是不可约方程 \begin{equation}\label{x2}&lt;br/&gt;u^4-2(1+2x)u^2+1=0\end{equation}&lt;br/&gt;的根,故通过以上的步骤我们就将原来用两个不可约方程&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{x1})}\)&lt;/span&gt;的根表示的扩张,化归为一个不可约方程&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{x2})}\)&lt;/span&gt;的根表示的扩张.&lt;/p&gt;
&lt;h3 id=&quot;liouville定理&quot;&gt;4 Liouville定理&lt;/h3&gt;
&lt;p&gt;Liouville证明了下面一个命题的正确性&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;&lt;strong&gt;定理3&lt;/strong&gt;. （&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{Liouville}\)&lt;/span&gt;）&lt;br/&gt;若Abel积分&lt;br/&gt;\begin{equation}\label{e5}\int_a^x R(x,y(x))\mathrm{d}x\end{equation}&lt;br/&gt;可以表示为初等函数,那么一定有&lt;br/&gt;\begin{equation}\label{e6}\int_a^x R(x,y(x))\mathrm{d}x=\omega_0(x)+\sum_{r=1}^{k}a_r\ln\omega_r(x),\end{equation}&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\omega_0(x),\omega_1(x),\omega_2(x),\cdots,\omega_k(x)\)&lt;/span&gt; 为&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的代数函数（此处不假定其属于体&lt;span class=&quot;math inline&quot;&gt;\(k(x,y)\)&lt;/span&gt;）, &lt;span class=&quot;math inline&quot;&gt;\(a_0,a_1,\cdots,a_k\)&lt;/span&gt;为常数.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt;. 设 \begin{equation}\label{e7}&lt;br/&gt;\int_a^x R(x,y(x))\mathrm{d}x=\Phi(x,\ln\omega_1,\cdots,\ln\omega_k).\end{equation}&lt;br/&gt;我们假设&lt;span class=&quot;math inline&quot;&gt;\(x,\ln\omega_1,\cdots,\ln\omega_k\)&lt;/span&gt; 这些变量间不成立形如&lt;br/&gt;\begin{equation}\label{e8}&lt;br/&gt;\Psi(x,\ln\omega_1,\cdots,\ln\omega_k)=0\end{equation}&lt;br/&gt;的代数关系式.否则,我们可以通过删去其中的一些&lt;span class=&quot;math inline&quot;&gt;\(\ln\omega_i\)&lt;/span&gt;,来使得这一条件最终成立.&lt;/p&gt;
&lt;p&gt;现在,设以上的&quot;非相关&quot;条件已然成立.对等式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e7})}\)&lt;/span&gt;求&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的偏导数,即可得到&lt;br/&gt;\begin{equation}\label{e9}&lt;br/&gt;R(x,y(x))=\frac{\partial\Phi}{\partial x}+\frac{\partial\Phi}{\partial\ln\omega_1}\frac{\omega'_1}{\omega_1}+\cdots+\frac{\partial\Phi}{\partial\ln\omega_k}\frac{\omega'_k}{\omega_k}\end{equation}&lt;br/&gt;这时可以看见,在等式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e9})}\)&lt;/span&gt;中竟然已经成立了形如等式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e8})}\)&lt;/span&gt;的关系,这说明等式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e9})}\)&lt;/span&gt;一定是关于各个变量&lt;span class=&quot;math inline&quot;&gt;\(\ln\omega_i(i=1,\cdots,k)\)&lt;/span&gt;的恒等式 .所以,将等式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e9})}\)&lt;/span&gt;对&lt;span class=&quot;math inline&quot;&gt;\(\ln\omega_i(i=1,\cdots,k)\)&lt;/span&gt;分别求导后,便可以得到&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{aligned} 0&amp;amp;=\frac{\partial^2\Phi}{\partial x \partial\ln\omega_i}+\frac{\partial^2\Phi}{\partial\ln\omega_1\partial\ln\omega_i}\frac{\omega'_1}{\omega_1}+\cdots+\frac{\partial^2\Phi}{\partial\ln\omega_k\partial\ln\omega_i}\frac{\omega'_k}{\omega_k}\\ &amp;amp;=\frac{\mathrm{d}}{\mathrm{d}x}(\frac{\partial\Phi}{\partial\ln\omega_i}).\quad(i=1,\cdots,k)\end{aligned}\]&lt;/span&gt;&lt;br/&gt;这样一来,便有&lt;br/&gt;\begin{equation}\label{e10}&lt;br/&gt;\frac{\partial\Phi}{\partial\ln\omega_i}=a_i(=\mbox{常数})\quad(i=1,\cdots,k).\end{equation}&lt;br/&gt;可以证明等式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e10})}\)&lt;/span&gt;一定是恒等式.否则,其就将给出一个形如条件&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e8})}\)&lt;/span&gt; 的等式,而我们已经假设过这种情况不会出现.&lt;/p&gt;
&lt;p&gt;由&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e10})}\)&lt;/span&gt;中的&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个等式,即可解出&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e6})}\)&lt;/span&gt;的形式. (积分回去就可以了.)▌&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;此外,还有这样一个结论:&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;定理4&lt;/strong&gt;. 在等式&lt;span class=&quot;math inline&quot;&gt;\(（\ref{e6}）\)&lt;/span&gt;中,函数&lt;span class=&quot;math inline&quot;&gt;\(\omega_0,\omega_1,\cdots,\omega_k\)&lt;/span&gt;一定都是有理函数体&lt;span class=&quot;math inline&quot;&gt;\(k(x,y)\)&lt;/span&gt;的函数.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt;. 这里,我们假设函数 &lt;span class=&quot;math display&quot;&gt;\[\omega_0,\omega_1,\omega_2,\cdots,\omega_k\]&lt;/span&gt;&lt;br/&gt;中的部分或全部不属于体&lt;span class=&quot;math inline&quot;&gt;\(k(x,y)\)&lt;/span&gt;,那么我们就可以把这些函数添加到体&lt;span class=&quot;math inline&quot;&gt;\(k(x,y)\)&lt;/span&gt;&lt;br/&gt;中,从而构成一个有限扩张.根据&lt;strong&gt;定理2&lt;/strong&gt;,这就相当于一个扩张&lt;span class=&quot;math inline&quot;&gt;\(k(x,y;z)\)&lt;/span&gt;,其中的&lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt;满足体&lt;span class=&quot;math inline&quot;&gt;\(k(x,y)\)&lt;/span&gt;上的一个不可约方程&lt;br/&gt;\begin{equation}\label{e11}&lt;br/&gt;F(x,y;z)=0\end{equation} 而其根 &lt;span class=&quot;math display&quot;&gt;\[z_1,z_2,\cdots,z_m\]&lt;/span&gt; 即为函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\omega_0,\omega_1,\omega_2,\cdots,\omega_k\]&lt;/span&gt;&lt;br/&gt;中那些不在体&lt;span class=&quot;math inline&quot;&gt;\(k(x,y)\)&lt;/span&gt;内的函数.由方程&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e11})}\)&lt;/span&gt;可以解出&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;关于&lt;span class=&quot;math inline&quot;&gt;\(x,z\)&lt;/span&gt;的表达式 \begin{equation}\label{e12}&lt;br/&gt;y=\varphi(x,z).\end{equation} 由于方程&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e11})}\)&lt;/span&gt;是不可约的,因此差&lt;span class=&quot;math inline&quot;&gt;\(y-\varphi(x,z)\)&lt;/span&gt;一定能被表达式&lt;span class=&quot;math inline&quot;&gt;\(F(x,y,z)\)&lt;/span&gt;除尽.因此便可以推出 \begin{equation}\label{e13}&lt;br/&gt;y=\varphi(x,z_1)=\varphi(x,z_2)=\cdots=\varphi(x,z_m).\end{equation} 设&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\omega_i=\psi_i(x,z),\]&lt;/span&gt; 那么如果记&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\omega_{i,r}=\psi_i(x,z_r)(r=1,2,\cdots,m),\]&lt;/span&gt;&lt;br/&gt;则根据式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e13})}\)&lt;/span&gt;及等式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\int_a^x R\mathrm{d}x=\omega_0+a_1\ln\omega_1+\cdots+a_k\ln\omega_k,\]&lt;/span&gt;&lt;br/&gt;就有等式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\int_a^x R\mathrm{d}x=\omega_{0,r}+a_1\ln\omega_{1,r}+\cdots+a_k\ln\omega_{k,r}(r=1,2,\cdots,m)\]&lt;/span&gt;&lt;br/&gt;成立  .将上面的&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个等式相加并取平均值,便可得到 &lt;span class=&quot;math display&quot;&gt;\[\label{y1} \int_a^xR\mathrm{d}x=\frac{1}{m}\left(\sum_{r=1}^m\omega_{0,r}+a_1\ln\prod_{r=1}^m\omega_{1,r}+\cdots+a_k\ln\prod_{r=1}^m\omega_{k,r}\right).\]&lt;/span&gt;&lt;br/&gt;可以注意到,上面的表达式中,函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\sum_{r=1}^m\omega_{0,r},\prod_{r=1}^m\omega_{1,r},\cdots,\prod_{r=1}^m\omega_{k,r}\]&lt;/span&gt;&lt;br/&gt;都是方程式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e11})}\)&lt;/span&gt;的根的对称函数.所以根据熟知的代数学定理 ,这些对称函数可以用方程&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e11})}\)&lt;/span&gt;的系数(&lt;span class=&quot;math inline&quot;&gt;\(x,y\)&lt;/span&gt;的有理函数)来直接有理的表示出来.&lt;/p&gt;
&lt;p&gt;由此,便得到 &lt;span class=&quot;math display&quot;&gt;\[\omega_0,\omega_1,\cdots,\omega_k\]&lt;/span&gt;&lt;br/&gt;确实是体&lt;span class=&quot;math inline&quot;&gt;\(k(x,y)\)&lt;/span&gt;中的函数  .▌&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;除此以外,还可以证明关于表达式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e6})}\)&lt;/span&gt;中各函数线性组合的系数之间的一个结果:&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;strong&gt;定理5&lt;/strong&gt;. 在关系式&lt;br/&gt;\begin{equation}\label{e14}\int_a^x R(x,y(x))\mathrm{d}x=\omega_0(x)+\sum_{r=1}^{k}a_r\ln\omega_r(x)\end{equation}&lt;br/&gt;中,各个函数之间线性组合的系数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[a_1,a_2,\cdots,a_k\]&lt;/span&gt;&lt;br/&gt;是“&lt;strong&gt;有理线性无关&lt;/strong&gt;”的,也就是说不存在&lt;span class=&quot;math inline&quot;&gt;\(m_1,m_2,\cdots,m_k\in\mathbb{Q}\)&lt;/span&gt;不全为零,使得关系&lt;br/&gt;\begin{equation}\label{e15}&lt;br/&gt;a_1m_1+a_2m_2+\cdots+a_km_k=0\end{equation}&lt;br/&gt;成立.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt;. 假如对于关系式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e14})}\)&lt;/span&gt;,仍然有线性关系&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e15})}\)&lt;/span&gt;成立,那么就可以由等式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e15})}\)&lt;/span&gt; 得到  \begin{equation}\label{e16}&lt;br/&gt;a_1=-\frac{a_2}{m_1}m_2-\frac{a_3}{m_1}m_3-\cdots--\frac{a_k}{m_1}m_k,\end{equation}&lt;br/&gt;将这个关系回代于等式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e14})}\)&lt;/span&gt;即有 \begin{equation}\label{e17}&lt;br/&gt;\int_a^xR(x,y(x))\mathrm{d}x=\omega_0+\frac{a_2}{m_1}\ln\frac{\omega_2^{m_1}}{\omega_1^{m_2}}+\cdots+&lt;br/&gt;\frac{a_k}{m_1}\ln\frac{\omega_k^{m_1}}{\omega_1^{m_k}}.\end{equation}&lt;/p&gt;
&lt;p&gt;如果适当的调整记号,等式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e17})}\)&lt;/span&gt;便具有形式&lt;br/&gt;\begin{equation}\label{e18}\int_a^xR(x,y(x))\mathrm{d}x=\omega_0+b_1\ln\tilde{\omega_1}+\cdots b_{k-1}\ln\tilde{\omega}_{k-1},\end{equation}&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\tilde{\omega_i}\)&lt;/span&gt;是代数函数,因为&lt;span class=&quot;math inline&quot;&gt;\(m_i\)&lt;/span&gt; 都是有理数.假如现在的这些系数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[b_1,b_2,\cdots,b_{k-1}\]&lt;/span&gt;&lt;br/&gt;之间已经不存在形如等式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e15})}\)&lt;/span&gt;的相关性,那么就已经实现了证明.否则,可再实行有限次 如上面这样的操作,使得等式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e15})}\)&lt;/span&gt;最终不能成立.▌&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;联系到之前有关于Abel积分分类的内容,我们还可以得到这样几个命题.这些命题将能够帮助我们最终证明切比雪夫的定理.&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;定理6&lt;/strong&gt;. 若一个Abel积分&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\int R(x,y(x))\mathrm{d}x\]&lt;/span&gt;&lt;br/&gt;可表示为初等函数,即有等式&lt;span class=&quot;math inline&quot;&gt;\((\ref{e6})\)&lt;/span&gt;成立,那么每一个使得函数&lt;span class=&quot;math inline&quot;&gt;\(\omega_1,\cdots,\omega_k\)&lt;/span&gt;中至少一个函数变为&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;或无穷大的点&lt;span class=&quot;math inline&quot;&gt;\(x_0\)&lt;/span&gt;都是这个Abel积分的对数奇点.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt;. 设题目中的Abel积分能够表示为初等函数,重新抄录一遍等式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e6})}\)&lt;/span&gt;: \begin{equation}\label{e19}&lt;br/&gt;\int_a^x R(x,y)\mathrm{d}x=\omega_0(x)+a_1\ln\omega_1(x)+\cdots+a_k\ln\omega_k(x),\end{equation}&lt;br/&gt;并设&lt;span class=&quot;math inline&quot;&gt;\(\omega_1(x)\)&lt;/span&gt;在某一点&lt;span class=&quot;math inline&quot;&gt;\(x_0\)&lt;/span&gt;处变为0.不失一般性,我们设&lt;span class=&quot;math inline&quot;&gt;\(x_0=0\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;由于&lt;span class=&quot;math inline&quot;&gt;\(\omega_1(x)\)&lt;/span&gt;是代数函数,所以就有 &lt;span class=&quot;math display&quot;&gt;\[\omega_1(x)=x^{m_1}\varphi_1(x),\mbox{其中}\varphi_1(x)\neq0(\neq\infty),\]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(m_1\in\mathbb{Q}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;完全同样,&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\omega_i(x)=x^{m_i}\varphi_i(x),\mbox{其中}\varphi_i(x)\neq0(\neq\infty)(i&amp;gt; 1),\]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(m_i\in\mathbb{Q}\)&lt;/span&gt;(它们可以部分,甚至全部等于0).同时,&lt;span class=&quot;math inline&quot;&gt;\(\varphi_i(x)(i=1,2,\cdots,k))\)&lt;/span&gt;均为代数函数.&lt;/p&gt;
&lt;p&gt;这样,将上面的&quot;分拆&quot;代入到等式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{e19})}\)&lt;/span&gt;中便有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\int_a^x R(t,y(t))\mathrm{d}t=\omega_0(x)+(a_1m_1+\cdots+a_km_k)\ln x+\sum_{i=1}^k a_i\ln\varphi_i(x).\]&lt;/span&gt;&lt;br/&gt;根据&lt;strong&gt;定理5&lt;/strong&gt;,一定有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[a_1m_1+a_2m_2+\cdots+a_km_k\neq0.\]&lt;/span&gt;&lt;br/&gt;除此以外,我们还知道&lt;span class=&quot;math inline&quot;&gt;\(\omega_0(x)\)&lt;/span&gt;是一个代数函数,其一定没有对数奇点.由此便知,&lt;span class=&quot;math inline&quot;&gt;\(x_0\)&lt;/span&gt;是这个Abel积分的对数奇点.▌&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;到这里,我们可以证明两条关键的命题:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;定理7&lt;/strong&gt;. 第一类Abel积分一定不能表示为初等函数.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt;. 根据定义,第一类Abel积分总是有界的.由&lt;strong&gt;定理6&lt;/strong&gt;可知,如果其能够表示为一个初等函数,那么其被初等函数表达出来的式子里必须不能含有对数项(否则将会与有界性矛盾).以上可知,第一类Abel积分如果能被初等表示出来,那么其一定是体&lt;span class=&quot;math inline&quot;&gt;\(k(x,y)\)&lt;/span&gt;的元素 .但是我们又知道,体&lt;span class=&quot;math inline&quot;&gt;\(k(x,y)\)&lt;/span&gt;中的函数除了常数函数以外都必然是无界的 ,因而这里又发生了矛盾.所以,第一类Abel积分不能被表示为初等函数.▌&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;定理8&lt;/strong&gt;. 若第二类Abel积分能被表示为初等函数,则该积分一定是&lt;span class=&quot;math inline&quot;&gt;\(k(x,y)\)&lt;/span&gt;中的元素.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明方法与前一命题完全相同,只不过最后一句话不要罢了.&lt;/p&gt;
&lt;h3 id=&quot;p.l.chebyshev定理&quot;&gt;5 P.L.Chebyshev定理&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;定理9&lt;/strong&gt;. （&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{Chebyshev}\)&lt;/span&gt;） 若三数 &lt;span class=&quot;math display&quot;&gt;\[p,\frac{m+1}{n},\frac{m+1}{n}+p\]&lt;/span&gt;&lt;br/&gt;都不是整数,则积分 \begin{equation}\label{f1}\int x^m(a+bx^n)^p\mathrm{d}x\end{equation} 不能表示为初等函数.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt;. 我们注意到,积分&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{f1})}\)&lt;/span&gt;可以改写为下面这样一种形式: \begin{equation}\label{f2}&lt;br/&gt;\int x^{-r}(x+1)^{-s}\mathrm{d}\end{equation}&lt;span class=&quot;math display&quot;&gt;\[x\]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(0&amp;lt;r&amp;lt;1,0&amp;lt;s&amp;lt;1\)&lt;/span&gt;.改写的方法是,在&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{f1})}\)&lt;/span&gt;中令&lt;span class=&quot;math inline&quot;&gt;\(z=x^n\)&lt;/span&gt;便可得到 &lt;span class=&quot;math display&quot;&gt;\[\begin{aligned} \int x^m(x^n+1)^p\mathrm{d}x&amp;amp;=\frac{1}{n}\int z^{\frac{m+1}{n}-1}(z+1)^p\mathrm{d}z\\ &amp;amp;=\frac{1}{n}\int z^{-r}(z+1)^{-s}\mathrm{d}z. \end{aligned}\]&lt;/span&gt; 此外我们还知道,可以通过下面的关系式 &lt;span class=&quot;math display&quot;&gt;\[\begin{cases} (-r+1)\int z^{-r}(z+1)^{-s}\mathrm{d}z=\\ \qquad\qquad z^{-r+1}(z+1)^{-s+1}+(r+s-2)\int z^{-r+1}(z+1)^{-s}\mathrm{d}z,\\ z^{-r+1}(z+1)^{-s+1}=\\ \qquad\qquad(s-1)\int z^{r-1}(z+1)^{-s}\mathrm{d}z+(2-r-s)\int z^{-r}(z+1)^{-s+1}\mathrm{d}z \end{cases}\]&lt;/span&gt;&lt;br/&gt;来将对应位置的&lt;span class=&quot;math inline&quot;&gt;\(r,s\)&lt;/span&gt;增大1或减小1,由此即可以通过若干次调整使得积分号下函数满足&lt;span class=&quot;math inline&quot;&gt;\(0&amp;lt;r&amp;lt;1,0&amp;lt;s&amp;lt;1\)&lt;/span&gt;.&lt;br/&gt;现在考察两种可能的情况.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(r+s&amp;gt;1\)&lt;/span&gt;.在此情况下,当&lt;span class=&quot;math inline&quot;&gt;\(x\rightarrow0\)&lt;/span&gt;(因为&lt;span class=&quot;math inline&quot;&gt;\(r&amp;lt;1\)&lt;/span&gt;),&lt;span class=&quot;math inline&quot;&gt;\(x\rightarrow-1\)&lt;/span&gt;(因为&lt;span class=&quot;math inline&quot;&gt;\(s&amp;lt;1\)&lt;/span&gt;)以及&lt;span class=&quot;math inline&quot;&gt;\(x\rightarrow\infty\)&lt;/span&gt;(因为&lt;span class=&quot;math inline&quot;&gt;\(r+s&amp;gt;1\)&lt;/span&gt;)&lt;br/&gt;时,积分皆保持有界,因此积分&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{f1})}\)&lt;/span&gt;在此条件下为第一类Abel积分.根据&lt;strong&gt;定理7&lt;/strong&gt;,积分&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{f1})}\)&lt;/span&gt;一定不能表示为初等函数.&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(r+s&amp;lt;1\)&lt;/span&gt;.像刚才讨论过的情形一样,当&lt;span class=&quot;math inline&quot;&gt;\(x\rightarrow0\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(x\rightarrow-1\)&lt;/span&gt;时,积分都是有界的.注意到&lt;span class=&quot;math inline&quot;&gt;\(|x|&amp;lt;1\)&lt;/span&gt;时有展开式&lt;br/&gt;\begin{equation}\label{f3}&lt;br/&gt;\int x^{-r}(x+1)^{-s}\mathrm{d}x=\frac{1}{1-r}x^{1-r}-\frac{s}{2-r}x^{2-r}+\cdots\end{equation}&lt;br/&gt;成立,而当&lt;span class=&quot;math inline&quot;&gt;\(|x|&amp;gt;1\)&lt;/span&gt;时也有展开式 &lt;span class=&quot;math display&quot;&gt;\[\begin{aligned} \int x^{-r}(x+1)^{-s}\mathrm{d}x&amp;amp;=\int x^{-r-s}(1+x^{-1})^s\mathrm{d}x\\ &amp;amp;=\frac{1}{1-r-s}x^{1-r-s}+\frac{s}{r+s}x^{-r-s}+\cdots \end{aligned}\]&lt;/span&gt; 成立.因此,我们可以确信,表达式 \begin{equation}\label{f4}&lt;br/&gt;x^{s+r-1}\int x^{-r}(x+1)^{-s}\mathrm{d}x\end{equation}&lt;br/&gt;也保持有界.积分&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{f2})}\)&lt;/span&gt;在这种情况下是第二类Abel积分  ,于是根据&lt;strong&gt;定理8&lt;/strong&gt;,如果其能够被初等表示出来,则一定是一个代数函数.但是表达式&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{f4})}\)&lt;/span&gt;却一定不能被表示为代数函数,因为代数函数无界而这个表达式有界.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此可知,当条件中的三个数均不为整数时,积分&lt;span class=&quot;math inline&quot;&gt;\(\mbox{(\ref{f1})}\)&lt;/span&gt;一定不能被表示为初等函数.到此,Chebychev定理完全证明.▌&lt;/p&gt;
</description>
<pubDate>Thu, 18 Oct 2018 14:59:00 +0000</pubDate>
<dc:creator>黑山雁</dc:creator>
<og:description>导言 说明：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xjtu-blacksmith/p/9813663.html</dc:identifier>
</item>
<item>
<title>Python爬虫之诗歌接龙 - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/9813142.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/9813142.html</guid>
<description>&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;  本文将展示如何利用Python爬虫来实现诗歌接龙。&lt;br/&gt;  该项目的思路如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;利用爬虫爬取诗歌，制作诗歌语料库；&lt;/li&gt;
&lt;li&gt;将诗歌分句，形成字典：键（key）为该句首字的拼音，值（value）为该拼音对应的诗句，并将字典保存为pickle文件；&lt;/li&gt;
&lt;li&gt;读取pickle文件，编写程序，以exe文件形式运行该程序。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  该项目实现的诗歌接龙，规则为下一句的首字与上一句的尾字的拼音（包括声调）一致。下面将分步讲述该项目的实现过程。&lt;/p&gt;
&lt;h3 id=&quot;诗歌语料库&quot;&gt;诗歌语料库&lt;/h3&gt;
&lt;p&gt;  首先，我们利用Python爬虫来爬取诗歌，制作语料库。爬取的网址为：&lt;a href=&quot;https://www.gushiwen.org%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%A6%82%E4%B8%8B/&quot; class=&quot;uri&quot;&gt;https://www.gushiwen.org，页面如下&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-afbe9ededacfb249.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;爬取的诗歌&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于本文主要为试了展示该项目的思路，因此，只爬取了该页面中的唐诗三百首、古诗三百、宋词三百、宋词精选，一共大约1100多首诗歌。为了加速爬虫，采用并发实现爬虫，并保存到poem.txt文件。完整的Python程序如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
import requests
from bs4 import BeautifulSoup
from concurrent.futures import ThreadPoolExecutor, wait, ALL_COMPLETED

# 爬取的诗歌网址
urls = ['https://so.gushiwen.org/gushi/tangshi.aspx',
        'https://so.gushiwen.org/gushi/sanbai.aspx',
        'https://so.gushiwen.org/gushi/songsan.aspx',
        'https://so.gushiwen.org/gushi/songci.aspx'
        ]

poem_links = []
# 诗歌的网址
for url in urls:
    # 请求头部
    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36'}
    req = requests.get(url, headers=headers)

    soup = BeautifulSoup(req.text, &quot;lxml&quot;)
    content = soup.find_all('div', class_=&quot;sons&quot;)[0]
    links = content.find_all('a')

    for link in links:
        poem_links.append('https://so.gushiwen.org'+link['href'])

poem_list = []
# 爬取诗歌页面
def get_poem(url):
    #url = 'https://so.gushiwen.org/shiwenv_45c396367f59.aspx'
    # 请求头部
    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36'}
    req = requests.get(url, headers=headers)
    soup = BeautifulSoup(req.text, &quot;lxml&quot;)
    poem = soup.find('div', class_='contson').text.strip()
    poem = poem.replace(' ', '')
    poem = re.sub(re.compile(r&quot;\([\s\S]*?\)&quot;), '', poem)
    poem = re.sub(re.compile(r&quot;（[\s\S]*?）&quot;), '', poem)
    poem = re.sub(re.compile(r&quot;。\([\s\S]*?）&quot;), '', poem)
    poem = poem.replace('!', '！').replace('?', '？')
    poem_list.append(poem)

# 利用并发爬取
executor = ThreadPoolExecutor(max_workers=10)  # 可以自己调整max_workers,即线程的个数
# submit()的参数： 第一个为函数， 之后为该函数的传入参数，允许有多个
future_tasks = [executor.submit(get_poem, url) for url in poem_links]
# 等待所有的线程完成，才进入后续的执行
wait(future_tasks, return_when=ALL_COMPLETED)

# 将爬取的诗句写入txt文件
poems = list(set(poem_list))
poems = sorted(poems, key=lambda x:len(x))
for poem in poems:
    poem = poem.replace('《','').replace('》','') \
               .replace('：', '').replace('“', '')
    print(poem)
    with open('F://poem.txt', 'a') as f:
        f.write(poem)
        f.write('\n')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该程序爬取了1100多首诗歌，并将诗歌保存至poem.txt文件，形成我们的诗歌语料库。当然，这些诗歌并不能直接使用，需要清理数据，比如有些诗歌标点不规范，有些并不是诗歌，只是诗歌的序等等，这个过程需要人工操作，虽然稍显麻烦，但为了后面的诗歌分句效果，也是值得的。&lt;/p&gt;
&lt;h3 id=&quot;诗歌分句&quot;&gt;诗歌分句&lt;/h3&gt;
&lt;p&gt;  有了诗歌语料库，我们需要对诗歌进行分句，分句的标准为：按照结尾为。？！进行分句，这可以用正则表达式实现。之后，将分句好的诗歌写成字典：键（key）为该句首字的拼音，值（value）为该拼音对应的诗句，并将字典保存为pickle文件。完整的Python代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
import pickle
from xpinyin import Pinyin
from collections import defaultdict

def main():
    with open('F://poem.txt', 'r') as f:
        poems = f.readlines()

    sents = []
    for poem in poems:
        parts = re.findall(r'[\s\S]*?[。？！]', poem.strip())
        for part in parts:
            if len(part) &amp;gt;= 5:
                sents.append(part)

    poem_dict = defaultdict(list)
    for sent in sents:
        print(part)
        head = Pinyin().get_pinyin(sent, tone_marks='marks', splitter=' ').split()[0]
        poem_dict[head].append(sent)

    with open('./poemDict.pk', 'wb') as f:
        pickle.dump(poem_dict, f)

main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看一下该pickle文件（poemDict.pk）的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-dbea3b7563b96e0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;pickle文件的内容（部分）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，一个拼音可以对应多个诗歌。&lt;/p&gt;
&lt;h3 id=&quot;诗歌接龙&quot;&gt;诗歌接龙&lt;/h3&gt;
&lt;p&gt;  读取pickle文件，编写程序，以exe文件形式运行该程序。&lt;br/&gt;  为了能够在编译形成exe文件的时候不出错，我们需要改写xpinyin模块的_&lt;em&gt;init_&lt;/em&gt;.py文件，将该文件的全部代码复制至mypinyin.py，并将代码中的下面这句代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;data_path = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                             'Mandarin.dat')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改写为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;data_path = os.path.join(os.getcwd(), 'Mandarin.dat')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就完成了mypinyin.py文件。&lt;br/&gt;  接下来，我们需要编写诗歌接龙的代码（Poem_Jielong.py），完整代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pickle
from mypinyin import Pinyin
import random
import ctypes

STD_INPUT_HANDLE = -10
STD_OUTPUT_HANDLE = -11
STD_ERROR_HANDLE = -12

FOREGROUND_DARKWHITE = 0x07  # 暗白色
FOREGROUND_BLUE = 0x09  # 蓝色
FOREGROUND_GREEN = 0x0a  # 绿色
FOREGROUND_SKYBLUE = 0x0b  # 天蓝色
FOREGROUND_RED = 0x0c  # 红色
FOREGROUND_PINK = 0x0d  # 粉红色
FOREGROUND_YELLOW = 0x0e  # 黄色
FOREGROUND_WHITE = 0x0f  # 白色

std_out_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)

# 设置CMD文字颜色
def set_cmd_text_color(color, handle=std_out_handle):
    Bool = ctypes.windll.kernel32.SetConsoleTextAttribute(handle, color)
    return Bool

# 重置文字颜色为暗白色
def resetColor():
    set_cmd_text_color(FOREGROUND_DARKWHITE)

# 在CMD中以指定颜色输出文字
def cprint(mess, color):
    color_dict = {
                  '蓝色': FOREGROUND_BLUE,
                  '绿色': FOREGROUND_GREEN,
                  '天蓝色': FOREGROUND_SKYBLUE,
                  '红色': FOREGROUND_RED,
                  '粉红色': FOREGROUND_PINK,
                  '黄色': FOREGROUND_YELLOW,
                  '白色': FOREGROUND_WHITE
                 }
    set_cmd_text_color(color_dict[color])
    print(mess)
    resetColor()

color_list = ['蓝色','绿色','天蓝色','红色','粉红色','黄色','白色']

# 获取字典
with open('./poemDict.pk', 'rb') as f:
    poem_dict = pickle.load(f)

#for key, value in poem_dict.items():
    #print(key, value)

MODE = str(input('Choose MODE(1 for 人工接龙, 2 for 机器接龙): '))

while True:
    try:
        if MODE == '1':
            enter = str(input('\n请输入一句诗或一个字开始：'))
            while enter != 'exit':
                test = Pinyin().get_pinyin(enter, tone_marks='marks', splitter=' ')
                tail = test.split()[-1]
                if tail not in poem_dict.keys():
                    cprint('无法接这句诗。\n', '红色')
                    MODE = 0
                    break
                else:
                    cprint('\n机器回复：%s'%random.sample(poem_dict[tail], 1)[0], random.sample(color_list, 1)[0])
                    enter = str(input('你的回复：'))[:-1]

            MODE = 0

        if MODE == '2':
            enter = input('\n请输入一句诗或一个字开始：')

            for i in range(10):
                test = Pinyin().get_pinyin(enter, tone_marks='marks', splitter=' ')
                tail = test.split()[-1]
                if tail not in poem_dict.keys():
                    cprint('------&amp;gt;无法接下去了啦...', '红色')
                    MODE = 0
                    break
                else:
                    answer = random.sample(poem_dict[tail], 1)[0]
                    cprint('（%d）--&amp;gt; %s' % (i+1, answer), random.sample(color_list, 1)[0])
                    enter = answer[:-1]

            print('\n（*****最多展示前10回接龙。*****）')
            MODE = 0

    except Exception as err:
        print(err)
    finally:
        if MODE not in ['1','2']:
            MODE = str(input('\nChoose MODE(1 for 人工接龙, 2 for 机器接龙): '))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在整个项目的结构如下（Mandarin.dat文件从xpinyin模块对应的文件夹下复制过来）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-9a60fa94cdfa633d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;项目文件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;切换至该文件夹，输入以下命令即可生成exe文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pyinstaller -F Poem_jielong.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的exe文件为Poem_jielong.exe，位于该文件夹的dist文件夹下。为了能够让exe成功运行，需要将poemDict.pk和Mandarin.dat文件复制到dist文件夹下。&lt;/p&gt;
&lt;h3 id=&quot;测试运行&quot;&gt;测试运行&lt;/h3&gt;
&lt;p&gt;  运行Poem_jielong.exe文件，页面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-3a2dd5405707ba15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;exe文件开始页面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本项目的诗歌接龙有两种模式，一种为人工接龙，就是你先输入一句诗或一个字，然后就是计算机回复一句，你回复一句，负责诗歌接龙的规则；另一种模式为机器接龙，就是你先输入一句诗或一个字，机器会自动输出后面的接龙诗句（最多10个）。&lt;br/&gt;  先测试人工接龙模式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-2e9ad0a59ae45dbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;人工接龙&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  再测试机器接龙模式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-1c078b672568384d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;机器接龙&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;  该项目的Github地址为：&lt;a href=&quot;https://github.com/percent4/Shicijielong&quot; class=&quot;uri&quot;&gt;https://github.com/percent4/Shicijielong&lt;/a&gt; 。&lt;br/&gt;  感谢阅读，欢迎大家交流~~&lt;/p&gt;
&lt;p&gt;注意：本人现已开通微信公众号： Python爬虫与算法（微信号为：easy_web_scrape）， 欢迎大家关注哦~~&lt;/p&gt;
</description>
<pubDate>Thu, 18 Oct 2018 13:02:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<og:description>Python爬虫之诗歌接龙</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jclian91/p/9813142.html</dc:identifier>
</item>
<item>
<title>React绑定事件动态化的实现方法 - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9813008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9813008.html</guid>
<description>&lt;h3&gt;&lt;span&gt;一、什么是绑定事件&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;1.1 事件&lt;/span&gt;&lt;/h4&gt;
&lt;br/&gt;我这里指的事件一般指的是React自带的触发事件,我这里先简单举例几个
&lt;pre&gt;
&lt;code&gt;onClick         //鼠标点击
onMouseEnter    //鼠标滑进
onMouseLeave    //鼠标滑出&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;&lt;span&gt;1.2 绑定事件&lt;/span&gt;&lt;/h4&gt;
&lt;br/&gt;一般有三种绑定事件的方法:
&lt;pre&gt;
&lt;code&gt;/*
* 1. constructor函数里统一bind
*/
constructor(arg){
    super(arg)
    
    this.handleChange = this.handleChange.bind(this)
    //...
}

&amp;lt;input onChange={this.handleChange} /&amp;gt;

/*
* 2. 箭头函数
*/
//2.1 方式1
handleChange(){
    //xxx
}

&amp;lt;input onChange={ () =&amp;gt; this.handleChange()} /&amp;gt;

//2.2 方式2
handleChange = () =&amp;gt; {
    //xxx
}

&amp;lt;input onChange={this.handleChange} /&amp;gt;

/*
* 3. 属性内绑定
*/
handleChange(){
    //xxx
}

&amp;lt;input onChange={this.handleChange.bind(this)} /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要详细地了解这几种React绑定事件的区别及如何选择,可以看我这篇文章:&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/soyxiaobi/p/9737234.html&quot; target=&quot;_blank&quot;&gt;《每日质量NPM包事件绑定_bindme(详解React的this)》&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;二、动态化&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;2.1 什么是动态化&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;动态化在我理解里就是具有可控性,能节省代码空间.比如ES6常用字符串模板就是实现动态化的一种方式&lt;/p&gt;
&lt;p&gt;举个栗子:&lt;br/&gt;如果我想输出3个数据('mock1', 'mock2', 'mock3').&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log('mock1')
console.log('mock2')
console.log('mock3')&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;let arr = ['mock1', 'mock2', 'mock3']

arr.map( item =&amp;gt; {
    console.log(`动态输出${item}`)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然,这个例子动态化的作用并不明显,我们直接看react事件动态化例子吧&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.2 React事件动态化&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;前面介绍了react的事件绑定方法。虽然在普通react语法中,我们不经常涉及到事件动态化,但是像一个渲染类的组件中(例如&lt;code&gt;antd table&lt;/code&gt;等等),就会经常使用的了&lt;/p&gt;
&lt;p&gt;还是栗子: 我要拥有三个除了绑定事件以外其余一模一样的button。分别绑定&lt;code&gt;save&lt;/code&gt;、&lt;code&gt;restart&lt;/code&gt;、&lt;code&gt;delete&lt;/code&gt;事件.我们一般会这么写&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;button onClick={ () =&amp;gt; this.handleSave() }&amp;gt;保存&amp;lt;/button&amp;gt;

&amp;lt;button onClick={ () =&amp;gt; this.handleRestart() }&amp;gt;重启&amp;lt;/button&amp;gt;

&amp;lt;button onClick={ () =&amp;gt; this.handleDelete() }&amp;gt;删除&amp;lt;/button&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这么写当然没问题,但是一来代码比较多,不美观.二来遇到&lt;code&gt;antd table&lt;/code&gt;这类render属性的,写这么多容易混乱,所以休整一下,如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const action = {
  'Save': '保存',
  'Stop': '停止实例',
  'Restart': '重启实例'
}

{
    Object.keys(action).map( item =&amp;gt; (
        &amp;lt;button key={item} onClick={ () =&amp;gt; this[`handle${item}`]() } &amp;gt;{action[item]}&amp;lt;/button&amp;gt;
    ))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181018203418430-1725996776.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;界面丑是丑了一点,但是非常实用呀！&lt;/p&gt;
&lt;p&gt;比如antd的table&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let columns = [{
  title: '操作',
  dataIndex: 'action',
  key: 'action',
  render: action =&amp;gt; (
    &amp;lt;span&amp;gt;
      {
        Object.keys(action).map( item =&amp;gt; &amp;lt;span 
          key={item} 
          onClick={ () =&amp;gt; this[`handle${item}`]() }&amp;gt;{action[item]}&amp;lt;/span&amp;gt;)
      }
    &amp;lt;/span&amp;gt;
  )
}]

let datalist = [action: {
  'Save': '保存',
  'Stop': '停止实例',
  'Restart': '重启实例'
}]

&amp;lt;Table
  columns={columns}
  dataSource={datalist}
/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 18 Oct 2018 12:39:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>一、什么是绑定事件 1.1 事件 我这里指的事件一般指的是React自带的触发事件,我这里先简单举例几个 1.2 绑定事件 一般有三种绑定事件的方法: 如果想要详细地了解这几种React绑定事件的区别</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9813008.html</dc:identifier>
</item>
<item>
<title>Toast源码深度分析 - 潇湘剑雨yc</title>
<link>http://www.cnblogs.com/yc211/p/9812809.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yc211/p/9812809.html</guid>
<description>一行代码调用，十分方便，但是这样存在一种弊端。
&lt;ul&gt;&lt;li&gt;使用中遇到的问题：例如，当点击有些按钮，需要吐司进行提示时；快速连续点击了多次按钮，Toast就触发了多次。系统会将这些Toast信息提示框放到队列中，等前一个Toast信息提示框关闭后才会显示下一个Toast信息提示框。可能导致Toast就长时间关闭不掉了。又或者我们其实已在进行其他操作了，应该弹出新的Toast提示，而上一个Toast却还没显示结束&lt;/li&gt;
&lt;/ul&gt;&lt;pre data-source-line=&quot;72&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;Toast&lt;span class=&quot;hljs-selector-class&quot;&gt;.makeText(&lt;span class=&quot;hljs-selector-tag&quot;&gt;this,&quot;&lt;span class=&quot;zh-hans&quot;&gt;吐司&quot;,&lt;span class=&quot;hljs-selector-tag&quot;&gt;Toast&lt;span class=&quot;hljs-selector-class&quot;&gt;.LENGTH_SHORT)&lt;span class=&quot;hljs-selector-class&quot;&gt;.show();
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 18 Oct 2018 12:00:00 +0000</pubDate>
<dc:creator>潇湘剑雨yc</dc:creator>
<og:description>目录介绍 1.最简单的创建方法 1.1 Toast构造方法 1.2 最简单的创建 1.3 简单改造避免重复创建 1.4 为何会出现内存泄漏 1.5 吐司是系统级别的 2.源码分析 2.1 Toast(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yc211/p/9812809.html</dc:identifier>
</item>
<item>
<title>优先队列的应用 C++实现 - 弱冠</title>
<link>http://www.cnblogs.com/kwebi/p/9811990.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kwebi/p/9811990.html</guid>
<description>&lt;h3 id=&quot;优先队列的应用-c实现&quot;&gt;优先队列的应用 C++实现&lt;/h3&gt;
&lt;p&gt;优先队列可以用堆来实现, 堆底层可以用数组表示，&lt;br/&gt;通过索引关系，可以表示成一颗二叉完全树&lt;/p&gt;
&lt;p&gt;C++的STL提供了相应的容器适配器&lt;br/&gt;包含在&lt;code&gt;queue&lt;/code&gt;头文件中&lt;/p&gt;
&lt;p&gt;下面通过一道题来看如何使用它&lt;/p&gt;
&lt;h4 id=&quot;给定一个字符串请将字符串里的字符按照出现的频率降序排列&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sort-characters-by-frequency/description/&quot;&gt;给定一个字符串，请将字符串里的字符按照出现的频率降序排列。&lt;/a&gt;&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;string frequencySort(string s) {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，统计字符出现的频率，通过map容器可以很简单的统计出来&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;map&amp;lt;char, int&amp;gt; mp;

for (auto e : s)
{
    ++mp[e];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们需要构建一个优先队列，而且要指定优先队列的排序方式&lt;br/&gt;因此我们定义了一个自己的结构体, 并定义了&lt;code&gt;&amp;lt;&lt;/code&gt;操作符(降序定义小于号，升序大于号)，&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct Node
{
    Node(const pair&amp;lt;char, int&amp;gt; &amp;amp;val) : p(val) {}
    pair&amp;lt;char, int&amp;gt; p;
};

bool operator&amp;lt;(const Node &amp;amp;a, const Node &amp;amp;b)
{
    return a.p.second &amp;lt; b.p.second;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把键值对放入优先队列中&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;priority_queue&amp;lt;Node, vector&amp;lt;Node&amp;gt;, less&amp;lt;Node&amp;gt;&amp;gt; pq;
for (auto e : mp)
{
    pq.push(make_pair(e.first, e.second));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要用的时候，依次取出来就是了，每次取出的都是里面最大(或最小)的&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;string res;
while (!pq.empty())
{
    for (int i = 0; i &amp;lt; pq.top().p.second; ++i)
        res.push_back(pq.top().p.first);
    pq.pop();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有好几个类似的题，都可以用这种方式解决&lt;/p&gt;
&lt;p&gt;比如 :&lt;/p&gt;
&lt;h4 id=&quot;下面是堆的实现-还是建议掌握的&quot;&gt;下面是堆的实现, 还是建议掌握的&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;vector&amp;gt;
using namespace std;

template &amp;lt;class T&amp;gt;
class Heap
{
  public:
    Heap(size_t maxElems)
    {
        h = new HeapStruct;
        h-&amp;gt;Elems = new T[maxElems + 1];
        h-&amp;gt;Capacity = maxElems;
        h-&amp;gt;size = 0;
    }
    ~Heap()
    {
        destroy();
    }
    void insert(T x)
    {
        size_t i;
        if (isFull())
        {
            return;
        }
        for (i = ++h-&amp;gt;size; i / 2 &amp;gt; 0 &amp;amp;&amp;amp; h-&amp;gt;Elems[i / 2] &amp;gt; x; i /= 2)
        {
            h-&amp;gt;Elems[i] = h-&amp;gt;Elems[i / 2];
        }
        h-&amp;gt;Elems[i] = x;
    }
    T deleteMin()
    {
        size_t i, child;
        T minElems, lastElems;
        if (isEmpty())
            return h-&amp;gt;Elems[0];
        minElems = h-&amp;gt;Elems[1];
        lastElems = h-&amp;gt;Elems[h-&amp;gt;size--];
        for (i = 1; i * 2 &amp;lt;= h-&amp;gt;size; i = child)
        {
            child = i * 2;
            if (child != h-&amp;gt;size &amp;amp;&amp;amp; h-&amp;gt;Elems[child + 1] &amp;lt; h-&amp;gt;Elems[child])
                ++child;
            if (lastElems &amp;gt; h-&amp;gt;Elems[child])
                h-&amp;gt;Elems[i] = h-&amp;gt;Elems[child];
            else
                break;
        }
        h-&amp;gt;Elems[i] = lastElems;
        return minElems;
    }
    bool isFull()
    {
        return h-&amp;gt;size == h-&amp;gt;Capacity;
    }
    bool isEmpty()
    {
        return h-&amp;gt;size == 0;
    }
    T findMin()
    {
        return h-&amp;gt;Elems[1];
    }

  private:
    void destroy()
    {
        delete h-&amp;gt;Elems;
        delete h;
    }
    void makeEmpty() {}

    struct HeapStruct
    {
        size_t Capacity;
        size_t size;
        T *Elems;
    };
    HeapStruct* h;
};&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 18 Oct 2018 09:51:00 +0000</pubDate>
<dc:creator>弱冠</dc:creator>
<og:description>优先队列的应用 C++实现 优先队列可以用堆来实现, 堆底层可以用数组表示， 通过索引关系，可以表示成一颗二叉完全树 C++的STL提供了相应的容器适配器 包含在 头文件中 下面通过一道题来看如何使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kwebi/p/9811990.html</dc:identifier>
</item>
<item>
<title>实例！用软件风险分析来实施测试 - Vincent83</title>
<link>http://www.cnblogs.com/yingyingja/p/9811627.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yingyingja/p/9811627.html</guid>
<description>&lt;p&gt;　　在开发新的软件系统过程中，由于存在许多不确定因素，软件开发失败的风险是客观存在的。因此，风险分析对于软件项目管理是决定性的。风险分析实际上就是贯穿在软件工程过程中的一系列风险管理步骤，其中包括：风险识别、风险估计、风险管理策略、风险解决和风险监督等。&lt;/p&gt;
&lt;p&gt;　　要理解风险分析，我们首先要理解‘风险’这个名词。用汉语的逻辑去对这个词做一个通俗性解释，可以这么展开：&lt;strong&gt;风险=“一个不好的事情可能会发生”&lt;/strong&gt;。这里要注意这句话里的两个要素：一是“可能”，即这是一种可能性的预测，他不是真实已经发生的或者100%一定发生了的事；二是“不好的事”，站在软件产品质量的角度而言，就是质量的一个瑕疵、问题。&lt;/p&gt;
&lt;p&gt;　　那么总结一下，对于软件产品而言，产品的风险就是软件产品可能会有质量问题的情况（更直白一点就是，产品可能会有缺陷）。&lt;/p&gt;
&lt;p&gt;　　我们引用ISTQB对于产品风险定义：&lt;/p&gt;
&lt;p&gt;　　在软件或系统中的潜在失效部分（即将来可能发生不利事件或危险）称之为产品风险，因为它们对产品质量而言是一个风险，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　故障频发的软件交付使用；&lt;/li&gt;
&lt;li&gt;　　软件/硬件对个人或公司造成潜在损害的可能性；&lt;/li&gt;
&lt;li&gt;　　劣质的软件特性（比如功能性、可靠性、易用性和性能等） ；&lt;/li&gt;
&lt;li&gt;　　低劣的数据完整性和质量（例如：数据迁移问题、数据转换问题、数据传输问题、违反数 据标准问题）；&lt;/li&gt;
&lt;li&gt;　　软件没有实现既定的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　那么为什么我们研发的软件产品会有风险存在呢？其实问这个问题就等同于问’为什么软件产品可能会有缺陷呢‘？其实这个问题的本质就在于’&lt;strong&gt;人都是会犯错误的&lt;/strong&gt;‘这样一个论断的成立。基于这个论断我们又可以推论出：’&lt;strong&gt;因为人都会犯错误，所以人开发出来的软件也就可能带有错误&lt;/strong&gt;‘。这些在研发过程中我们犯的错误，遗留在产品中，就是缺陷；缺陷存在的可能性，就是产品风险。&lt;/p&gt;
&lt;p&gt;　　我们还可以更具体的去讨论，哪些因素，可能导致我们研发软件时更容易在产品中遗留错误：&lt;/p&gt;
&lt;p&gt;　　① 产品大小/代码量：工作量越大，那么我们就越有可能犯错。&lt;/p&gt;
&lt;p&gt;　　② 技术因素：未曾使用过的新技术都存在风险。包括未使用过的新型硬件、支持软件，缺乏标准与规范的非传统的开发方法等。技术过时也是风险。技术风险一般难于改正。&lt;/p&gt;
&lt;p&gt;　　③ 开发环境：适用的开发工具不足、不可靠、使用不方便等因素，都会降低开发效率。&lt;/p&gt;
&lt;p&gt;　　④ 组织规模和人员经验：比如人手不足，人员经验不丰富，都有可能带来产品风险。&lt;/p&gt;
&lt;p&gt;　　⑤ 客户因素：表现在客户需求经常矛盾，不了解客户的特殊需要，客户不了解项目中采用的新技术，且双方又难于沟通等。&lt;/p&gt;

&lt;p&gt;　　所以，既然软件产品的风险是客观存在的，我们就要采取必要手段对风险进行处理，于是就引出了我们今天的课题，’&lt;strong&gt;风险分析&lt;/strong&gt;‘。&lt;/p&gt;
&lt;p&gt;　　首先描述一下风险分析的步骤，一般而言我们可以认为风险分析包括以下部分内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　风险识别　　想要控制风险，我们首先要知道有哪些风险，不然谈何控制？&lt;/li&gt;
&lt;li&gt;　　风险评估　　知道了有哪些风险，其次我们要判断风险有多大，有多严重&lt;/li&gt;
&lt;li&gt;　　风险缓解　　知道了风险有哪些和他的严重程度，我们就要想办法去缓解和规避风险&lt;/li&gt;
&lt;li&gt;　　风险管理　　最后我们要对风险进行管理，达到风控的目标&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　理论说了这么多，下面用一个简单的实际例子来诠释风险分析的过程。&lt;/p&gt;
&lt;p&gt;　　我还是拿上一篇《&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/yingyingja/p/9803542.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;实例！软件缺陷数据度量和分析&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》中的COTS项目为例，这个项目情况是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;该项目为一个COTS产品的定制性二次开发项目&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;项目周期计划为4个月，实际完成时间为6个月&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;项目是一个总体人员不到10人的小型项目&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;采用持续集成，高速迭代的研发方式&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;第一步：列出软件的所有功能和特性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　根据项目相关人员对本项目的调研，我们列出了以下的软件功能模块和特性：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;所有主功能：订单支付模块、用户管理模块、后台管理模块、浏览展示模块、用户评价子系统、活动模块、促销管理模块&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　质量专项问题：功能性问题、性能问题、界面问题、易用性问题、安全性问题、计算错误、描述错误&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　用表格来展示就是这样的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181018164807905-1245208453.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　所有我们列出来的这些条目，就是所谓的“风险项目”。&lt;/p&gt;
&lt;p&gt;　　那么风险识别这件事，在项目里应该由谁来做呢？一般情况下，风险分析的过程除了有专家的参与，更是一种集体智慧的体现，也就是说项目所有利益相关方，都应该参与到风险分析的过程中。在风险识别这个动作上，头脑风暴是一种可行的方法（即与会各方各抒己见，提出自己认为产品可能有的风险项）。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第二步：对每个风险项目做出风险等级评估&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在风险评估过程中，我们要对上个阶段列出的风险项目做出评估，得出风险高低大小的一个排序。&lt;/p&gt;
&lt;p&gt;　　这里我们要考虑风险的两个维度：风险发生的可能性大小，以及风险如果发生，带来的影响范围和严重程度有多大。&lt;/p&gt;
&lt;p&gt;　　我们首先用定性的方法对风险进行评估，采用风险评估矩阵来指导我们的评估过程：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181018165924571-88248669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们将前一阶段得出的风险项目列表进行两个维度的风险判断，得出如下结果：每一个风险项我们都从两个维度给他’高、中、低‘的判断：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181018170042241-1210461899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么这个填表过程是由谁来执行呢？答案仍然是集体智慧。风险评估会议要求各项目利益相关方参与，项目团队的成员，包括客户（如果可能的话）每个个体都可能在评估过程中表达自己在某一方面最权威的意见。打个比方说，上面表单里的’订单支付模块‘的影响范围，最适合对他进行评估的可能就是：客户、需求人员和测试工程师；而对于’后台管理系统‘的风险概率，最适合对他进行评估的可能是：开发组长或者对应的开发人员，以此类推。&lt;/p&gt;
&lt;p&gt;　　得到这个评估表，我们使用先前的风险评估矩阵对他进行排序和整理，就得出以下结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181018171350329-814148078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　进一步：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181018171419391-1823214486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到此为止我们就完成了定性风险评估的过程。&lt;/p&gt;
&lt;p&gt;　　不过这种定性分析还没有能够很细致的展示各风险项之间更细节的风险等级，比如上图标注红色，风险等级为高的三个项目，他们之间的排序我们并不能确定。&lt;/p&gt;
&lt;p&gt;　　所以我们可以改为采用更为细致的一种定量分析，比如我们把’高、中、低‘这样的指标转换为’3，2，1‘这样的得分系统，可以得出如下结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181018171711648-556009433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，通过得分相加（采用发生概率和影响范围两个指标相乘是一种更合理的做法）这样的形式，我们得出了更为细致的风险等级划分。&lt;/p&gt;
&lt;p&gt;　　实际上我们还可以更进一步细化，比如对于所有风险项的发生概率，我们可以结合其产生原因进行去量化分析：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181018171949580-88996939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　对于风险的影响范围，我们从相关风险的使用频率和问题的严重程度去进行量化：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181018172629611-949305187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样再从两个维度去对这个表格做一个运算，不管是用相加还是相乘的策略，我们就能得出更准确的一个风险排序。&lt;/p&gt;
&lt;p&gt;　　当然风险评估除了矩阵法，还有一些其他的方法我们就不一一阐述了。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;第三步：定义风险缓解措施&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;既然我们已经得到风险由高到底的一个风险结果，那么我们就要实施一些措施，对这些风险进行规避和缓解。&lt;/p&gt;
&lt;p&gt;　　这里我们可以有很多种思路：比如将更有经验的开发人员投入到风险高的领域里面去，或者向风险高的领域投入更多的人手，等等。&lt;/p&gt;
&lt;p&gt;　　还有就是：进行&lt;strong&gt;基于风险的测试。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;实际上，&lt;strong&gt;软件测试活动，本身就可以被认为是一种风险控制措施&lt;/strong&gt;。试想一下，我们测试团队，对于一个软件进行测试，发现了缺陷进行汇报，并督促开发团队去修复和解决问题。这是不是已经直观的降低了产品的风险？这个论断显然是成立的。而测试活动通过其反馈作用，去达到过程改进的效果，也可以更进一步的帮助项目去规避风险。&lt;/p&gt;
&lt;p&gt;　　那么基于风险的测试应该怎么去组织呢？我们就是用风险分析的结果报告，去指导我们测试的开展，具体而言可以有如下措施：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　基于风险确定测试优先级&lt;/li&gt;
&lt;li&gt;　　基于风险确定测试完备性&lt;/li&gt;
&lt;li&gt;　　基于风险确定测试资源分配&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　这样的一些措施要基于我们测试的几个基本原则：&lt;/p&gt;
&lt;p&gt;　　1.　　“测试是不可能穷尽的” - 既然测试不可能穷尽，那么我们就应该优先去测试风险高的部分，把低的部分放到后续去做，如果时间不允许甚至有部分低风险的部分不测。&lt;/p&gt;
&lt;p&gt;　　2.　　“缺陷具有集群性” - 即所谓的20%的模块有80%的bug，那么我们通过将风险可能性高的部分去准备更完备的测试（比如更多的测试用例覆盖，更多的执行轮次，更多的执行时间）和更有经验的人员，就可以实现软件质量的快速上升。&lt;/p&gt;

&lt;p&gt;　　最后要注意：&lt;strong&gt;风险分析不是一个一次性的工作&lt;/strong&gt;，我们要通过在项目实际研发过程中得到的信息和反馈，对风险等级进行调整，比如调高和调低风险等级。一个实际的例子是：我们在项目开始时，将某一个风险项目定为了高级，因此这个风险项引起了团队的重视。从而在后续工作开展过程中，团队投入了更多的资源和力量，导致最终测试阶段可能反而在这个模块里面没有发现太多问题。&lt;/p&gt;
&lt;p&gt;　　所以我们测试活动的产出和收集到的信息要用来对风险评估结果进行持续的反馈和调整更新，并根据调整后的风险等级继续指导测试。&lt;/p&gt;
</description>
<pubDate>Thu, 18 Oct 2018 09:48:00 +0000</pubDate>
<dc:creator>Vincent83</dc:creator>
<og:description>在开发新的软件系统过程中，由于存在许多不确定因素，软件开发失败的风险是客观存在的。因此，风险分析对于软件项目管理是决定性的。风险分析实际上就是贯穿在软件工程过程中的一系列风险管理步骤，其中包括：风险识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yingyingja/p/9811627.html</dc:identifier>
</item>
<item>
<title>kubernetes学习14—Dashboard搭建和认证 - 阿龙along</title>
<link>http://www.cnblogs.com/along21/p/9811860.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/along21/p/9811860.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;一、介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　Kubernetes Dashboard&lt;span&gt;是&lt;/span&gt;&lt;span&gt;Kubernetes&lt;/span&gt;&lt;span&gt;集群的&lt;span&gt;&lt;strong&gt;基于&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Web&lt;/span&gt;&lt;span&gt;的通用&lt;/span&gt;&lt;span&gt;UI&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。它允许&lt;strong&gt;用户管理在群集中运行的应用程序并对其进行故障排除，以及管理群集本身&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;二、搭建&lt;/span&gt;dashboard&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;1、编写yaml文件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;借鉴&lt;a href=&quot;https://github.com/kubernetes/dashboard&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;，修改了image的下载地址和pod的一些配置&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[root@master ~]# vim dashboard.yaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Filename: dashboard.yaml
# Revision: 1.0
# Date: 2018/10/18
# Author: along
# Description: Build kubernetes dashboard

# ------------------- Dashboard Secret ------------------- #

apiVersion: v1
kind: Secret
metadata:
  labels:
    k8s-app: kubernetes-dashboard
  name: kubernetes-dashboard-certs
  namespace: kube-system
type: Opaque

---
# ------------------- Dashboard Service Account ------------------- #

apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    k8s-app: kubernetes-dashboard
  name: kubernetes-dashboard
  namespace: kube-system

---
# ------------------- Dashboard Role &amp;amp; Role Binding ------------------- #

kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: kubernetes-dashboard-minimal
  namespace: kube-system
rules:
  # Allow Dashboard to create 'kubernetes-dashboard-key-holder' secret.
- apiGroups: [&quot;&quot;]
  resources: [&quot;secrets&quot;]
  verbs: [&quot;create&quot;]
  # Allow Dashboard to create 'kubernetes-dashboard-settings' config map.
- apiGroups: [&quot;&quot;]
  resources: [&quot;configmaps&quot;]
  verbs: [&quot;create&quot;]
  # Allow Dashboard to get, update and delete Dashboard exclusive secrets.
- apiGroups: [&quot;&quot;]
  resources: [&quot;secrets&quot;]
  resourceNames: [&quot;kubernetes-dashboard-key-holder&quot;, &quot;kubernetes-dashboard-certs&quot;]
  verbs: [&quot;get&quot;, &quot;update&quot;, &quot;delete&quot;]
  # Allow Dashboard to get and update 'kubernetes-dashboard-settings' config map.
- apiGroups: [&quot;&quot;]
  resources: [&quot;configmaps&quot;]
  resourceNames: [&quot;kubernetes-dashboard-settings&quot;]
  verbs: [&quot;get&quot;, &quot;update&quot;]
  # Allow Dashboard to get metrics from heapster.
- apiGroups: [&quot;&quot;]
  resources: [&quot;services&quot;]
  resourceNames: [&quot;heapster&quot;]
  verbs: [&quot;proxy&quot;]
- apiGroups: [&quot;&quot;]
  resources: [&quot;services/proxy&quot;]
  resourceNames: [&quot;heapster&quot;, &quot;http:heapster:&quot;, &quot;https:heapster:&quot;]
  verbs: [&quot;get&quot;]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: kubernetes-dashboard-minimal
  namespace: kube-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: kubernetes-dashboard-minimal
subjects:
- kind: ServiceAccount
  name: kubernetes-dashboard
  namespace: kube-system

---
# ------------------- Dashboard Deployment ------------------- #

kind: Deployment
apiVersion: apps/v1beta2
metadata:
  labels:
    k8s-app: kubernetes-dashboard
  name: kubernetes-dashboard
  namespace: kube-system
spec:
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      k8s-app: kubernetes-dashboard
  template:
    metadata:
      labels:
        k8s-app: kubernetes-dashboard
    spec:
      containers:
      - name: kubernetes-dashboard
        image: mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.0
        ports:
        - containerPort: 8443
          protocol: TCP
        args:
          - --auto-generate-certificates
          # Uncomment the following line to manually specify Kubernetes API server Host
          # If not specified, Dashboard will attempt to auto discover the API server and connect
          # to it. Uncomment only if the default does not work.
          # - --apiserver-host=http://my-address:port
        volumeMounts:
        - name: kubernetes-dashboard-certs
          mountPath: /certs
          # Create on-disk volume to store exec logs
        - mountPath: /tmp
          name: tmp-volume
        livenessProbe:
          httpGet:
            scheme: HTTPS
            path: /
            port: 8443
          initialDelaySeconds: 30
          timeoutSeconds: 30
      volumes:
      - name: kubernetes-dashboard-certs
        secret:
          secretName: kubernetes-dashboard-certs
      - name: tmp-volume
        emptyDir: {}
      serviceAccountName: kubernetes-dashboard
      # Comment the following tolerations if Dashboard must not be deployed on master
      tolerations:
      - key: node-role.kubernetes.io/master
        effect: NoSchedule

---
# ------------------- Dashboard Service ------------------- #

kind: Service
apiVersion: v1
metadata:
  labels:
    k8s-app: kubernetes-dashboard
  name: kubernetes-dashboard
  namespace: kube-system
spec:
  type: NodePort
  ports:
    - port: 443
      targetPort: 8443
      nodePort: 30000
  selector:
    k8s-app: kubernetes-dashboard&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;2、apply yaml文件，搭建dashboard&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;[root@master ~]# kubectl apply -f dashboard.yaml&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;secret&lt;/strong&gt;/kubernetes-dashboard-certs created&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;serviceaccount&lt;/strong&gt;/kubernetes-dashboard created&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;role&lt;/strong&gt;.rbac.authorization.k8s.io/kubernetes-dashboard-minimal created&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rolebinding&lt;/strong&gt;.rbac.authorization.k8s.io/kubernetes-dashboard-minimal created&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;deployment&lt;/strong&gt;.apps/kubernetes-dashboard created&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;service&lt;/strong&gt;/kubernetes-dashboard created&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;3、查看验证&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;pod&lt;/span&gt;&lt;span&gt;已经创建成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl get pods -n kube-system |grep dashboard&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;kubernetes-dashboard&lt;/strong&gt;-68bf55748d-4zzph   1/1       Running   0          2m&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;span&gt;也已经创建成功，并且有映射端口，此时已经可以登录了，但是无法登录，因为没有认证&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl get svc -n kube-system&lt;/p&gt;
&lt;p&gt;NAME                   TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)         AGE&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;kubernetes-dashboard&lt;/strong&gt;   NodePort    10.97.55.246   &amp;lt;none&amp;gt;        &lt;strong&gt;443:30000&lt;/strong&gt;/TCP   2m&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;三、&lt;/span&gt;dashboard与kubernetes集群的认证，方案一：令牌认证&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;（1）有两种认证方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　口令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　kubeconfig&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）并且在认证的时候，还可以管理限制&lt;/span&gt;dashboard&lt;span&gt;用户的权限；为了让大家进一步理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在方案一：口令认证时，&lt;/span&gt;dashboard&lt;span&gt;用户的权限设为对所有名称空间都有&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;的权限；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在方案二：&lt;/span&gt;kubeconfig&lt;span&gt;认证时，&lt;/span&gt;&lt;span&gt;dashboard&lt;/span&gt;&lt;span&gt;用户的权限设为只对&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;名称空间有&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;权限；&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1、授权，对所有名称空间都有admin的权限&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）创建&lt;/span&gt;&lt;span&gt;serviceaccount&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl create&lt;strong&gt; serviceaccount&lt;/strong&gt; dashboard-serviceaccount -n kube-system&lt;/p&gt;
&lt;p&gt;serviceaccount/dashboard-serviceaccount created&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）创建&lt;/span&gt;&lt;span&gt;clusterrolebinding&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用&lt;/span&gt;&lt;strong&gt;clusterrolebinding&lt;/strong&gt;&lt;span&gt;绑定&lt;/span&gt;cluster-admin&lt;span&gt;的&lt;/span&gt;&lt;strong&gt;clusterrole&lt;/strong&gt;&lt;span&gt;和&lt;/span&gt;dashboard-serviceaccount&lt;span&gt;的&lt;/span&gt;&lt;span&gt;serviceaccount&lt;/span&gt;&lt;span&gt;，这样&lt;/span&gt;&lt;span&gt;dashboard-serviceaccount&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;serviceaccount&lt;/span&gt;&lt;span&gt;就在所有名称空间有了&lt;/span&gt;&lt;span&gt;kubernetes&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl create &lt;strong&gt;clusterrolebinding&lt;/strong&gt; dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-serviceaccount&lt;/p&gt;
&lt;p&gt;clusterrolebinding.rbac.authorization.k8s.io/dashboard-cluster-admin created&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2、获取令牌&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）在&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;中查找&lt;/span&gt;&lt;span&gt;dashboard-serviceaccount&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl get &lt;strong&gt;secret&lt;/strong&gt; -n kube-system |grep dashboard-serviceaccount-token&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dashboard-serviceaccount-token-nz7xd&lt;/strong&gt;             kubernetes.io/service-account-token   3         4m&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）查看&lt;/span&gt;&lt;span&gt;dashboard-serviceaccount&lt;/span&gt;&lt;span&gt;中的口令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl &lt;strong&gt;describe&lt;/strong&gt; secret dashboard-serviceaccount-token-nz7xd -n kube-system&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Name:         dashboard-serviceaccount-token-&lt;span&gt;nz7xd
Namespace:    kube&lt;/span&gt;-&lt;span&gt;system
Labels:       &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
Annotations:  kubernetes.io&lt;/span&gt;/service-account.name=dashboard-&lt;span&gt;serviceaccount
              kubernetes.io&lt;/span&gt;/service-account.uid=2af6061f-d1f0-11e8-&lt;span&gt;8059&lt;/span&gt;-&lt;span&gt;005056277243&lt;/span&gt;&lt;span&gt;

Type:  kubernetes.io&lt;/span&gt;/service-account-&lt;span&gt;token

Data
&lt;/span&gt;====&lt;span&gt;
ca.crt:     &lt;/span&gt;&lt;span&gt;1025&lt;/span&gt;&lt;span&gt; bytes
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;:  &lt;span&gt;11&lt;/span&gt;&lt;span&gt; bytes
token:      &lt;strong&gt;eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtc2VydmljZWFjY291bnQtdG9rZW4tbno3eGQiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLXNlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiMmFmNjA2MWYtZDFmMC0xMWU4LTgwNTktMDA1MDU2Mjc3MjQzIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmUtc3lzdGVtOmRhc2hib2FyZC1zZXJ2aWNlYWNjb3VudCJ9.BAJVarqum57S_KepqOgcS1IimNEmDilhu4tIiWQKxaz0o5TKyXBZ5YqN3ZS5tJNQbLvDS6LuRRXdvH&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-MeKQnUpg08OhYDg1u9XE3Oygr7YF5Ad7yBw4czpPPN6iIJZ5qQJ8laOfPRb8qYVbR0R4MONin08lhzrkLBkRLwhAVJ_6zXXB9vaJLU9asTyA4YmDAZZi06zkYeeO8Rhqr2-Yeu4Ya7miLYVRv_ioqDlkqGEf6ILUriPjeJHohIEbgdslRXTnxgwkt2Uwsv3QRFKF2CisSBSW7P-9muuCrzSb2xQVop7WbAUyROdUuqQFmSON2UC0643e_iEW5DBaAAGQxbw&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;3、网页通过令牌登录&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）使用&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;协议打开&lt;/span&gt;https://192.168.130.103:30000&lt;span&gt;（任意节点的&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;都可以）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入&lt;/span&gt;dashboard-serviceaccount&lt;span&gt;的口令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201810/1216496-20181018173250169-2046932206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）打开成功，并且对所有名称空间都有&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201810/1216496-20181018173313188-276792646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;四、&lt;/span&gt;dashboard与kubernetes集群的认证，方案二：configing认证&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;1、授权，只&lt;/strong&gt;&lt;strong&gt;对default名称空间有admin的权限&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）创建&lt;/span&gt;&lt;span&gt;serviceaccount&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl create &lt;strong&gt;serviceaccount&lt;/strong&gt; def-ns-dashboard-sa -n default&lt;/p&gt;
&lt;p&gt;serviceaccount/def-ns-dashboard-sa created&lt;/p&gt;
&lt;p&gt;（2）创建rolebinding&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;rolebinding&lt;span&gt;绑定&lt;/span&gt;&lt;span&gt;cluster-admin&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;clusterrole&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;def-ns-dashboard&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;serviceaccount&lt;/span&gt;&lt;span&gt;，这样&lt;/span&gt;&lt;span&gt;def-ns-dashboard&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;serviceaccount&lt;/span&gt;&lt;span&gt;就只有&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;这一个名称空间&lt;/span&gt;的admin权限&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl create &lt;strong&gt;rolebinding&lt;/strong&gt; def-ns-dashboard-rb --clusterrole=cluster-admin --serviceaccount=default:def-ns-dashboard-sa&lt;/p&gt;
&lt;p&gt;rolebinding.rbac.authorization.k8s.io/def-ns-dashboard-rb created&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2、获取令牌&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;（1）在secret中查找def-ns-dashboard-sa&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl get secret&lt;/p&gt;
&lt;p&gt;NAME                              TYPE                                  DATA      AGE&lt;/p&gt;
&lt;p&gt;def-ns-dashboard-sa-token-b8plm   kubernetes.io/service-account-token   3         1m&lt;/p&gt;
&lt;p&gt;（2）查看def-ns-dashboard-sa中的口令&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl describe secret def-ns-dashboard-sa-token-b8plm&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Name:         def-ns-dashboard-sa-token-&lt;span&gt;b8plm
Namespace:    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;
Labels:       &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
Annotations:  kubernetes.io&lt;/span&gt;/service-account.name=def-ns-dashboard-&lt;span&gt;sa
              kubernetes.io&lt;/span&gt;/service-account.uid=8b040303-d287-11e8-be88-&lt;span&gt;005056277243&lt;/span&gt;&lt;span&gt;

Type:  kubernetes.io&lt;/span&gt;/service-account-&lt;span&gt;token

Data
&lt;/span&gt;====&lt;span&gt;
ca.crt:     &lt;/span&gt;&lt;span&gt;1025&lt;/span&gt;&lt;span&gt; bytes
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;:  &lt;span&gt;7&lt;/span&gt;&lt;span&gt; bytes
token:      &lt;strong&gt;eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZi1ucy1kYXNoYm9hcmQtc2EtdG9rZW4tYjhwbG0iLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmLW5zLWRhc2hib2FyZC1zYSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjhiMDQwMzAzLWQyODctMTFlOC1iZTg4LTAwNTA1NjI3NzI0MyIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZi1ucy1kYXNoYm9hcmQtc2EifQ.VqAgyqN8_F4mjawWtZ5TzvFioKA50u4MUL_4ypBxWrr&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-XU8TciM8EX1OcGm9vAjUW_m5QZangS7VW3rVYPcqKMqaYKE8vN-l9wTC5CzTnxPHMghTx8sTTkPWnqHt7C7v8cVRNfeRAWygWMp1B8Chx5pAK2l9t095uZy_w59qFQdoAKeAcxiH5K6kz9sx8VwEXVr9nRH8bFqvtr3yXCdYo2e2qSQXOpNddlyrEOYXrIUlamNyImgcbfkNLV0Qkt5sdfSLSJdaB2opLWD8pST88m73r6KG2c_aMmyZ7mTCUeNd1BwCOnLSto4V2xPXCtHA6ELvB5afh9irpCj4e5VgPw&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;3、定义一个kubeconfig认证文件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）在一个新的&lt;/span&gt;&lt;span&gt;kubeconfig&lt;/span&gt;&lt;span&gt;文件下，创建一个集群&lt;/span&gt;&lt;strong&gt;dashboard&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl config &lt;strong&gt;set-cluster&lt;/strong&gt; &lt;strong&gt;dashboard&lt;/strong&gt; --certificate-authority=/etc/kubernetes/pki/ca.crt --server=&quot;https://192.168.130.103:6443&quot; --embed-certs=true&lt;strong&gt; --kubeconfig=/root/def-ns-dashboard.conf&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cluster &quot;dashboard&quot; set.&lt;/p&gt;

&lt;p&gt;/root/def-ns-dashboard.conf &lt;span&gt;文件已经生成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@master ~]# ll /root/def-ns-dashboard.conf&lt;/p&gt;
&lt;p&gt;-rw------- 1 root root 1568 Oct 18 13:36 /root/def-ns-dashboard.conf&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）使用&lt;/span&gt;&lt;span&gt;def-ns-dashboard-sa&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;serviceaccount&lt;/span&gt;&lt;span&gt;，创建一个用户&lt;/span&gt;&lt;strong&gt;def-ns-dashboard-user&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl config &lt;strong&gt;set-credentials def-ns-dashboard-user&lt;/strong&gt; --kubeconfig=/root/def-ns-dashboard.conf &lt;strong&gt;--token=&lt;/strong&gt;eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZi1ucy1kYXNoYm9hcmQtc2EtdG9rZW4tYjhwbG0iLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmLW5zLWRhc2hib2FyZC1zYSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjhiMDQwMzAzLWQyODctMTFlOC1iZTg4LTAwNTA1NjI3NzI0MyIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZi1ucy1kYXNoYm9hcmQtc2EifQ.VqAgyqN8_F4mjawWtZ5TzvFioKA50u4MUL_4ypBxWrr-XU8TciM8EX1OcGm9vAjUW_m5QZangS7VW3rVYPcqKMqaYKE8vN-l9wTC5CzTnxPHMghTx8sTTkPWnqHt7C7v8cVRNfeRAWygWMp1B8Chx5pAK2l9t095uZy_w59qFQdoAKeAcxiH5K6kz9sx8VwEXVr9nRH8bFqvtr3yXCdYo2e2qSQXOpNddlyrEOYXrIUlamNyImgcbfkNLV0Qkt5sdfSLSJdaB2opLWD8pST88m73r6KG2c_aMmyZ7mTCUeNd1BwCOnLSto4V2xPXCtHA6ELvB5afh9irpCj4e5VgPw&lt;/p&gt;
&lt;p&gt;User &quot;def-ns-dashboard-user&quot; set.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）在这个&lt;/span&gt;&lt;span&gt;kubeconfig&lt;/span&gt;&lt;span&gt;文件下，创建一个上下文关系&lt;/span&gt;&lt;strong&gt;def-ns-dashboard-user@dashboard&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl config &lt;strong&gt;set-context def-ns-dashboard-user@dashboard&lt;/strong&gt; --cluster=dashboard --user=def-ns-dashboard-user --kubeconfig=/root/def-ns-dashboard.conf&lt;/p&gt;
&lt;p&gt;Context &quot;def-ns-dashboard-user@dashboard&quot; created.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）在这个&lt;/span&gt;&lt;span&gt;kubeconfig&lt;/span&gt;&lt;span&gt;文件下，使用&lt;/span&gt;&lt;strong&gt;def-ns-dashboard-user@dashboard&lt;/strong&gt;&lt;span&gt;这个上下文关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl config &lt;strong&gt;use-context&lt;/strong&gt; def-ns-dashboard-user@dashboard --kubeconfig=/root/def-ns-dashboard.conf&lt;/p&gt;
&lt;p&gt;Switched to context &quot;def-ns-dashboard-user@dashboard&quot;.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;5&lt;span&gt;）通过&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;查看验证&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@master ~]# kubectl config view --kubeconfig=/root/def-ns-dashboard.conf&lt;/p&gt;
&lt;p&gt;apiVersion: v1&lt;/p&gt;
&lt;p&gt;clusters:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;- cluster&lt;/span&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    certificate-authority-data: REDACTED&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    server: https://192.168.130.103:6443&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  name: dashboard&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;contexts:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;- context&lt;/strong&gt;&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    cluster: dashboard&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    user: def-ns-dashboard-user&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  name: def-ns-dashboard-user@dashboard&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;current-context&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;: def-ns-dashboard-user@dashboard&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;kind: Config&lt;/p&gt;
&lt;p&gt;preferences: {}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;users&lt;/span&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- name: def-ns-dashboard-user&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  user:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    token:&lt;/strong&gt; eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZi1ucy1kYXNoYm9hcmQtc2EtdG9rZW4tYjhwbG0iLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmLW5zLWRhc2hib2FyZC1zYSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjhiMDQwMzAzLWQyODctMTFlOC1iZTg4LTAwNTA1NjI3NzI0MyIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZi1ucy1kYXNoYm9hcmQtc2EifQ.VqAgyqN8_F4mjawWtZ5TzvFioKA50u4MUL_4ypBxWrr-XU8TciM8EX1OcGm9vAjUW_m5QZangS7VW3rVYPcqKMqaYKE8vN-l9wTC5CzTnxPHMghTx8sTTkPWnqHt7C7v8cVRNfeRAWygWMp1B8Chx5pAK2l9t095uZy_w59qFQdoAKeAcxiH5K6kz9sx8VwEXVr9nRH8bFqvtr3yXCdYo2e2qSQXOpNddlyrEOYXrIUlamNyImgcbfkNLV0Qkt5sdfSLSJdaB2opLWD8pST88m73r6KG2c_aMmyZ7mTCUeNd1BwCOnLSto4V2xPXCtHA6ELvB5afh9irpCj4e5VgPw&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;4、网页通过kubeconfig登录&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）将&lt;/span&gt;&lt;span&gt;/root/def-ns-dashboard.conf&lt;/span&gt; &lt;span&gt;文件上传到&lt;/span&gt;&lt;span&gt;windows&lt;/span&gt;&lt;span&gt;机器上，把&lt;/span&gt;&lt;span&gt;/root/def-ns-dashboard.conf&lt;/span&gt;&lt;span&gt;这个&lt;/span&gt;&lt;span&gt;kubeconfig&lt;/span&gt;&lt;span&gt;文件导入到登录时的页面，就可以成功登录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201810/1216496-20181018174239929-627923209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）登录成功，但是只有&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;这个名称空间的&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201810/1216496-20181018174248339-1874725258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;至此，我们已经成功搭建了&lt;/span&gt;dashboard&lt;span&gt;；并且完成了对&lt;/span&gt;&lt;span&gt;K8S&lt;/span&gt;&lt;span&gt;集群的认证；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以通过&lt;/span&gt;dashboard&lt;span&gt;创建和管理&lt;/span&gt;&lt;span&gt;Pod&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;span&gt;、存储卷&lt;/span&gt;&lt;span&gt;... ...&lt;/span&gt; &lt;span&gt;这里就不再演示了。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 18 Oct 2018 09:47:00 +0000</pubDate>
<dc:creator>阿龙along</dc:creator>
<og:description>一、介绍 Kubernetes Dashboard是Kubernetes集群的基于Web的通用UI。它允许用户管理在群集中运行的应用程序并对其进行故障排除，以及管理群集本身。 二、搭建dashboar</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/along21/p/9811860.html</dc:identifier>
</item>
</channel>
</rss>