<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Ubuntu配置完全教程 - jiangyx</title>
<link>http://www.cnblogs.com/Jiangyx/p/8011605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jiangyx/p/8011605.html</guid>
<description>&lt;p&gt;最近将旧电脑换成了Ubuntu系统，在网上找了许多优化和配置教程，今天整理一份完整的教程给大家分享&lt;/p&gt;

&lt;h2 id=&quot;卸载libreoffice&quot;&gt;卸载LibreOffice&lt;/h2&gt;
&lt;p&gt;libreoffice事ubuntu自带的开源office软件，体验效果不如windows上的office，于是选择用WPS来替代（wps的安装后面会提到）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get remove libreoffice-common&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;删除amazon的链接&quot;&gt;删除Amazon的链接&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get remove unity-webapps-common&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;删除不常用的软件&quot;&gt;删除不常用的软件&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot
&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get remove gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku  landscape-client-ui-install
&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get remove onboard deja-dup&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;切换软件源&quot;&gt;切换软件源&lt;/h2&gt;
&lt;p&gt;在设置--软件和更新里--下载自--其他站点--中国--&lt;a href=&quot;http://mirrors.aliyun.com/ubuntu&quot; class=&quot;uri&quot;&gt;http://mirrors.aliyun.com/ubuntu&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;将所有软件源和软件更新到最新&quot;&gt;将所有软件源和软件更新到最新&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get update
&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get upgrade&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;安装gdebi&quot;&gt;安装GDebi&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get install gdebi&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完以后再安装ded包就可以右键打开方式--gdebi&lt;/p&gt;
&lt;h2 id=&quot;wps&quot;&gt;WPS&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://community.wps.cn/download/&quot;&gt;WPS&lt;/a&gt; 官网下载即可&lt;/p&gt;
&lt;h2 id=&quot;搜狗输入法&quot;&gt;搜狗输入法&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pinyin.sogou.com/linux/?r=pinyin&quot;&gt;搜狗拼音官网&lt;/a&gt;下载安装。&lt;/p&gt;
&lt;p&gt;在系统设置-&amp;gt;语言中选择&lt;strong&gt;fcitx&lt;/strong&gt;后重启即可使用搜狗拼音&lt;/p&gt;
&lt;h2 id=&quot;网易云音乐&quot;&gt;网易云音乐&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://music.163.com/#/download&quot;&gt;网易云音乐官网&lt;/a&gt;下载安装即可&lt;/p&gt;
&lt;h2 id=&quot;vim编辑器&quot;&gt;VIM编辑器&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get install vim&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;git&quot;&gt;GIT&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo apt-get intsall git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完成后进行GIT的设置&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;git config --global user.name &quot;youname&quot; # 设置GIT的账号
git config --global user.email &quot;youeamil@email.com&quot; # 设置GIT的邮箱&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在设置完成后进行GIT的SSH设置&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;
eval &quot;$(ssh-agent -s)&quot;
ssh-add ~/.ssh/id_rsa&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在本机生成SSH密匙后将生成的密匙添加到GITHUB上&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo apt-get install xclip
xclip -sel clip &amp;lt; ~/.ssh/id_rsa.pub
# 进入GITHUB密匙添加页进行密匙添加&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后测试是否SSH可以链接成功&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh -T git@github.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果出现以下文字，代表操作成功&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Hi username! You've successfully authenticated, but GitHub does not&lt;br/&gt;provide shell access.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;typora&quot;&gt;Typora&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# optional, but recommended
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE
# add Typora's repository
sudo add-apt-repository 'deb http://typora.io linux/'
sudo apt-get update
# install typora
sudo apt-get install typora&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;sublime-text-3&quot;&gt;Sublime Text 3&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo add-apt-repository ppa:webupd8team/sublime-text-3
sudo apt-get update      
sudo apt-get install sublime-text&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完后进行输入注册码进行激活&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;—– BEGIN LICENSE —–&lt;br/&gt;TwitterInc&lt;br/&gt;200 User License&lt;br/&gt;EA7E-890007&lt;br/&gt;1D77F72E 390CDD93 4DCBA022 FAF60790&lt;br/&gt;61AA12C0 A37081C5 D0316412 4584D136&lt;br/&gt;94D7F7D4 95BC8C1C 527DA828 560BB037&lt;br/&gt;D1EDDD8C AE7B379F 50C9D69D B35179EF&lt;br/&gt;2FE898C4 8E4277A8 555CE714 E1FB0E43&lt;br/&gt;D5D52613 C3D12E98 BC49967F 7652EED2&lt;br/&gt;9D2D2E61 67610860 6D338B72 5CF95C69&lt;br/&gt;E36B85CC 84991F19 7575D828 470A92AB&lt;/p&gt;
&lt;p&gt;—— END LICENSE ——&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sublime插件推荐&lt;/p&gt;
&lt;blockquote readability=&quot;70&quot;&gt;
&lt;p&gt;Package Control 功能：安装包管理&lt;/p&gt;
&lt;p&gt;Emmet 功能：编码快捷键&lt;/p&gt;
&lt;p&gt;JSFormat 功能：Javascript的代码格式化插件&lt;/p&gt;
&lt;p&gt;LESS 功能：LESS高亮插件&lt;/p&gt;
&lt;p&gt;Less2CSS 功能：编译Less&lt;/p&gt;
&lt;p&gt;Alignment 功能：”=”号对齐&lt;/p&gt;
&lt;p&gt;sublime-autoprefixer 功能：CSS添加私有前缀&lt;/p&gt;
&lt;p&gt;Clipboard History 功能：粘贴板历史记录&lt;/p&gt;
&lt;p&gt;Bracket Highlighter 功能：代码匹配&lt;/p&gt;
&lt;p&gt;Git 功能：git管理&lt;/p&gt;
&lt;p&gt;jQuery 功能：jQ函数提示&lt;/p&gt;
&lt;p&gt;DocBlockr 功能：生成优美注释&lt;/p&gt;
&lt;p&gt;ColorPicker 功能：调色板&lt;/p&gt;
&lt;p&gt;ConvertToUTF8 功能：文件转码成utf-8&lt;/p&gt;
&lt;p&gt;AutoFileName 功能：快捷输入文件名&lt;/p&gt;
&lt;p&gt;Nodejs 功能：node代码提示&lt;/p&gt;
&lt;p&gt;Trailing spaces 功能：检测并一键去除代码中多余的空格&lt;/p&gt;
&lt;p&gt;FileDiffs 功能：强大的比较代码不同工具&lt;/p&gt;
&lt;p&gt;GBK Encoding Support 功能：中文识别&lt;/p&gt;
&lt;p&gt;All Autocomplete 搜索所有打开的文件来寻找匹配的提示词。&lt;/p&gt;
&lt;p&gt;SublimeCodeIntel 全功能的 Sublime Text 代码自动完成引擎&lt;/p&gt;
&lt;p&gt;CTags 方法跳转&lt;/p&gt;
&lt;p&gt;Autoprefixer 自动分析你的css文件，解析出新的css文件，可以配置你要兼容的浏览器，不过这个插件要在之前安装nodejs&lt;/p&gt;
&lt;p&gt;BracketHighlighter 配置文件的高亮设置，让你的代码有不同的颜色区分该插件提供配对标签，或大括号或字符引号的配对高亮显示，&lt;/p&gt;
&lt;p&gt;BufferScroll 你可以轻松书写一个文件多个位置了&lt;/p&gt;
&lt;p&gt;ChineseLocalization 语言包&lt;/p&gt;
&lt;p&gt;Color Highlighter 颜色功能还是很爽的，找了好久&lt;/p&gt;
&lt;p&gt;CSS Comments&lt;/p&gt;
&lt;p&gt;CSS Format&lt;/p&gt;
&lt;p&gt;CSS3&lt;/p&gt;
&lt;p&gt;HTML-CSS-JS Prettify&lt;/p&gt;
&lt;p&gt;JavaScript Completions&lt;/p&gt;
&lt;p&gt;Pretty JSON 格式化json&lt;/p&gt;
&lt;p&gt;SideBarEnhancements 增强右键菜单文件操作功能&lt;/p&gt;
&lt;p&gt;SublimeLinter 代码校验插件，支持多种语言，这个是主插件，如果想检测特定的文件需要单独下载&lt;/p&gt;
&lt;p&gt;SublimeLinter-jshint 这个就是单独的插件，上面的一个分支&lt;/p&gt;
&lt;p&gt;SublimeTmpl 　创建常用文件初始模板，必须html,css,js模板&lt;/p&gt;
&lt;p&gt;Tag HTML/XML标签缩进、补全和校验&lt;/p&gt;
&lt;p&gt;Themr&lt;/p&gt;
&lt;/blockquote&gt;


&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo apt-get install unity-tweak-tool &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;flatabulous主题&quot;&gt;Flatabulous主题&lt;/h2&gt;
&lt;p&gt;Flatabulous主题是一款ubuntu下扁平化主题&lt;/p&gt;
&lt;p&gt;执行以下命令安装Flatabulous主题&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo add-apt-repository ppa:noobslab/themes
sudo apt-get update
sudo apt-get install flatabulous-theme&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该主题有配套的图标&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo add-apt-repository ppa:noobslab/icons
sudo apt-get update
sudo apt-get install ultra-flat-icons&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完成后，打开unity-tweak-tool软件，修改主题和图标&lt;/p&gt;
&lt;p&gt;进入Theme，修改为Flatabulous&lt;/p&gt;
&lt;p&gt;此界面下进入Icons栏，修改为Ultra-flat&lt;/p&gt;
&lt;h2 id=&quot;终端&quot;&gt;终端&lt;/h2&gt;
&lt;p&gt;终端采用zsh和oh-my-zsh&lt;/p&gt;
&lt;p&gt;首先，安装zsh&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo apt-get install zsh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们需要下载 oh-my-zsh 项目来帮我们配置 zsh，采用wget安装&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;zsh 基本已经配置完成,你需要一行命令就可以切换到 zsh 模式&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chsh -s /usr/local/bin/zsh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果显示无效，则可以&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;vi ~/.bashrc
# 在文件末尾加上bash -c zsh&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;nodejs&quot;&gt;NodeJS&lt;/h2&gt;
&lt;p&gt;在Node官网下载最新的稳定版并解压到一个文件夹&lt;/p&gt;
&lt;p&gt;之后将其移动到通用的软件安装目录&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo mv node-v4.4.4-linux-x64 /opt/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建软链接npm 和 node 命令到系统命令&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo ln -s /opt/node-v4.4.4-linux-x64/bin/node /usr/local/bin/node
sudo ln -s /opt/node-v4.4.4-linux-x64/bin/npm /usr/local/bin/npm&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cnpm安装&quot;&gt;CNPM安装&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org
sudo ln -s /opt/node-v4.4.4-linux-x64/bin/cnpm /usr/local/bin/cnpm&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;yarn安装&quot;&gt;YARN安装&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm install -g yarn
sudo ln -s /opt/node-v4.4.4-linux-x64/bin/yarn /usr/local/bin/yarn&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;java&quot;&gt;JAVA&lt;/h2&gt;
&lt;p&gt;去官网下载JDK解压到文件夹中，并将其移动到/opt/下&lt;/p&gt;
&lt;p&gt;接着配置JAVA的环境变量&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo gedit  /etc/profile 打开 /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在文件尾加上&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;export JAVA_HOME=/opt/jdk1.8.0_45
export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$CLASSPATH
export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后刷新环境变量&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo source /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;pycharm&quot;&gt;Pycharm&lt;/h2&gt;
&lt;p&gt;以Pycharm安装为例&lt;/p&gt;
&lt;p&gt;首先先去官网下载最新的Pycharm&lt;/p&gt;
&lt;p&gt;下载完成后解压并移动到/opt/下&lt;/p&gt;
&lt;p&gt;最后为其创建快捷方式&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd /usr/share/applications/
sudo vim Pycharm.desktop&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里必须得用root权限sudo才能写入，然后在文件中写入以下内容&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[Desktop Entry]
Type=Application
Name=Pycharm
GenericName=Pycharm3
Comment=Pycharm3:The Python IDE
Exec=sh /opt/pycharm/bin/pycharm.sh
Icon=/opt/pycharm/bin/pycharm.png
Terminal=pycharm
Categories=Pycharm&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着在将创建的快捷方式拖动到侧边栏即可&lt;/p&gt;
</description>
<pubDate>Sat, 09 Dec 2017 07:26:00 +0000</pubDate>
<dc:creator>jiangyx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jiangyx/p/8011605.html</dc:identifier>
</item>
<item>
<title>Android APP 性能优化的一些思考 - cryAllen</title>
<link>http://www.cnblogs.com/cr330326/p/8011523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cr330326/p/8011523.html</guid>
<description>&lt;p&gt;说到 Android 系统手机，大部分人的印象是用了一段时间就变得有点卡顿，有些程序在运行期间莫名其妙的出现崩溃，打开系统文件夹一看，发现多了很多文件，然后用手机管家 APP 不断地进行清理优化 ，才感觉运行速度稍微提高了点，就算手机在各种性能跑分软件面前分数遥遥领先，还是感觉无论有多大的内存空间都远远不够用。相信每个使用 Android 系统的用户都有过以上类似经历，确实，Android 系统在流畅性方面不如 IOS 系统，为何呢，明明在看手机硬件配置上时，Android 设备都不会输于 IOS 设备，甚至都强于它，关键是在于软件上。造成这种现象的原因是多方面的，简单罗列几点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其实近年来，随着 Android 版本不断迭代，Google 提供的Android 系统已经越来越流畅，目前最新发布的版本是 &lt;strong&gt;Android 8.0 Oreo&lt;/strong&gt; 。但是在国内大部分用户用的 Android 手机系是各大厂商定制过的版本，往往不是最新的原生系统内核，可能绝大多数还停留在 Android 5.0 系统上，甚至 Android 6.0 以上所占比例还偏小，更新存在延迟性。&lt;/li&gt;
&lt;li&gt;由于 Android 系统源码是开放的，每个人只要遵从相应的协议，就可以对源码进行修改，那么国内各个厂商就把基于 Android 源码改造成自己对外发布的系统，比如我们熟悉的小米手机 Miui 系统、华为手机 EMUI 系统、Oppo 手机 ColorOS 系统等。由于每个厂商都修改过 Android 原生系统源码，这里面就会引发一个问题，那就是著名的&lt;strong&gt;Android 碎片化&lt;/strong&gt;问题，本质就是不同 Android 系统的应用兼容性不同，达不到一致性。&lt;/li&gt;
&lt;li&gt;由于存在着各种 &lt;strong&gt;Android 碎片化和兼容性&lt;/strong&gt;问题，导致 Android 开发者在开发应用时需要对不同系统进行适配，同时每个 Android 开发者的开发水平参差不齐，写出来的应用性能也都存在不同类型的问题，导致用户在使用过程中用户体验感受不同，那么有些问题用户就会转化为 Android 系统问题，进而影响对Android 手机的评价。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;性能优化&quot;&gt;性能优化&lt;/h3&gt;
&lt;p&gt;今天想说的重点是&lt;strong&gt;Android APP&lt;/strong&gt; 性能优化，也就是在开发应用程序时应该注意的点有哪些，如何更好地提高用户体验。一个好的应用，除了要有吸引人的功能和交互之外，在性能上也应该有高的要求，即时应用非常具有特色，在产品前期可能吸引了部分用户，但是用户体验不好的话，也会给产品带来不好的口碑。那么一个好的应用应该如何定义呢？主要有以下三方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;业务/功能&lt;/li&gt;
&lt;li&gt;符合逻辑的交互&lt;/li&gt;
&lt;li&gt;优秀的性能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;众所周知，Android 系统作为以移动设备为主的操作系统，硬件配置是有一定的限制的，虽然配置现在越来越高级，但仍然无法与 PC 相比，在 CPU 和内存上使用不合理或者耗费资源多时，就会碰到内存不足导致的稳定性问题、CPU 消耗太多导致的卡顿问题等。&lt;/p&gt;
&lt;p&gt;面对问题时，大家想到的都是联系用户，然后查看日志，但殊不知有关性能类问题的反馈，原因也非常难找，日志大多用处不大，为何呢？因为性能问题大部分是非必现的问题，问题定位很难复现，而又没有关键的日志，当然就无法找到原因了。这些问题非常影响用户体验和功能使用，所以了解一些性能优化的一些解决方案就显得很重要了，并在实际的项目中优化我们的应用，进而提高用户体验。&lt;/p&gt;
&lt;h3 id=&quot;四个方面&quot;&gt;四个方面&lt;/h3&gt;
&lt;p&gt;可以把用户体验的性能问题主要总结为4个类别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;流畅&lt;/li&gt;
&lt;li&gt;稳定&lt;/li&gt;
&lt;li&gt;省电、省流量&lt;/li&gt;
&lt;li&gt;安装包小&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;性能问题的主要原因是什么，原因有相同的，也有不同的，但归根到底，不外乎内存使用、代码效率、合适的策略逻辑、代码质量、安装包体积这一类问题，整理归类如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/331079/201712/331079-20171209150132105-1412677189.png&quot; alt=&quot;性能优化图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，打造一个高质量的应用应该以4个方向为目标：快、稳、省、小。&lt;/p&gt;
&lt;p&gt;快：使用时避免出现卡顿，响应速度快，减少用户等待的时间，满足用户期望。&lt;/p&gt;
&lt;p&gt;稳：减低 crash 率和 ANR 率，不要在用户使用过程中崩溃和无响应。&lt;/p&gt;
&lt;p&gt;省：节省流量和耗电，减少用户使用成本，避免使用时导致手机发烫。&lt;/p&gt;
&lt;p&gt;小：安装包小可以降低用户的安装成本。&lt;/p&gt;
&lt;p&gt;要想达到这4个目标，具体实现是在右边框里的问题：卡顿、内存使用不合理、代码质量差、代码逻辑乱、安装包过大，这些问题也是在开发过程中碰到最多的问题，在实现业务需求同时，也需要考虑到这点，多花时间去思考，如何避免功能完成后再来做优化，不然的话等功能实现后带来的维护成本会增加。&lt;/p&gt;
&lt;h3 id=&quot;卡顿优化&quot;&gt;卡顿优化&lt;/h3&gt;
&lt;p&gt;Android 应用启动慢，使用时经常卡顿，是非常影响用户体验的，应该尽量避免出现。卡顿的场景有很多，按场景可以分为4类：UI 绘制、应用启动、页面跳转、事件响应，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/331079/201712/331079-20171209150149902-275982147.png&quot; alt=&quot;卡顿场景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这4种卡顿场景的根本原因可以分为两大类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;界面绘制。主要原因是绘制的层级深、页面复杂、刷新不合理，由于这些原因导致卡顿的场景更多出现在 UI 和启动后的初始界面以及跳转到页面的绘制上。&lt;/li&gt;
&lt;li&gt;数据处理。导致这种卡顿场景的原因是数据处理量太大，一般分为三种情况，一是数据在处理 UI 线程，二是数据处理占用 CPU 高，导致主线程拿不到时间片，三是内存增加导致 GC 频繁，从而引起卡顿。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;引起卡顿的原因很多，但不管怎么样的原因和场景，最终都是通过设备屏幕上显示来达到用户，归根到底就是显示有问题，所以，要解决卡顿，就要先了解 Android 系统的显示原理。&lt;/p&gt;
&lt;h5 id=&quot;android系统显示原理&quot;&gt;Android系统显示原理&lt;/h5&gt;
&lt;p&gt;Android 显示过程可以简单概括为：Android 应用程序把经过测量、布局、绘制后的 surface 缓存数据，通过 SurfaceFlinger 把数据渲染到显示屏幕上， 通过 Android 的刷新机制来刷新数据。也就是说应用层负责绘制，系统层负责渲染，通过进程间通信把应用层需要绘制的数据传递到系统层服务，系统层服务通过刷新机制把数据更新到屏幕上。&lt;/p&gt;
&lt;p&gt;我们都知道在 Android 的每个 View 绘制中有三个核心步骤：Measure、Layout、Draw。具体实现是从 ViewRootImp 类的performTraversals() 方法开始执行，Measure 和 Layout都是通过递归来获取 View 的大小和位置，并且以深度作为优先级，可以看出层级越深、元素越多、耗时也就越长。&lt;/p&gt;
&lt;p&gt;真正把需要显示的数据渲染到屏幕上，是通过系统级进程中的 SurfaceFlinger 服务来实现的，那么这个SurfaceFlinger 服务主要做了哪些工作呢？如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;响应客户端事件，创建 Layer 与客户端的 Surface 建立连接。&lt;/li&gt;
&lt;li&gt;接收客户端数据及属性，修改 Layer 属性，如尺寸、颜色、透明度等。&lt;/li&gt;
&lt;li&gt;将创建的 Layer 内容刷新到屏幕上。&lt;/li&gt;
&lt;li&gt;维持 Layer 的序列，并对 Layer 最终输出做出裁剪计算。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;既然是两个不同的进程，那么肯定是需要一个跨进程的通信机制来实现数据传递，在 Android 显示系统中，使用了 Android 的匿名共享内存：SharedClient，每一个应用和 SurfaceFlinger 之间都会创建一个SharedClient ，然后在每个 SharedClient 中，最多可以创建 31 个 SharedBufferStack，每个 Surface 都对应一个 SharedBufferStack，也就是一个 Window。&lt;/p&gt;
&lt;p&gt;一个 SharedClient 对应一个Android 应用程序，而一个 Android 应用程序可能包含多个窗口，即 Surface 。也就是说 SharedClient 包含的是 SharedBufferStack的集合，其中在显示刷新机制中用到了双缓冲和三重缓冲技术。最后总结起来显示整体流程分为三个模块：应用层绘制到缓存区，SurfaceFlinger 把缓存区数据渲染到屏幕，由于是不同的进程，所以使用 Android 的匿名共享内存 SharedClient 缓存需要显示的数据来达到目的。&lt;/p&gt;
&lt;p&gt;除此之外，我们还需要一个名词：FPS。FPS 表示每秒传递的帧数。在理想情况下，60 FPS 就感觉不到卡，这意味着每个绘制时长应该在16 ms 以内。但是 Android 系统很有可能无法及时完成那些复杂的页面渲染操作。Android 系统每隔 16ms 发出 VSYNC 信号，触发对 UI 进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需的 60FPS。如果某个操作花费的时间是 24ms ，系统在得到 VSYNC 信号时就无法正常进行正常渲染，这样就发生了丢帧现象。那么用户在 32ms 内看到的会是同一帧画面，这种现象在执行动画或滑动列表比较常见，还有可能是你的 Layout 太过复杂，层叠太多的绘制单元，无法在 16ms 完成渲染，最终引起刷新不及时。&lt;/p&gt;
&lt;h5 id=&quot;卡顿根本原因&quot;&gt;卡顿根本原因&lt;/h5&gt;
&lt;p&gt;根据Android 系统显示原理可以看到，影响绘制的根本原因有以下两个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;绘制任务太重，绘制一帧内容耗时太长。&lt;/li&gt;
&lt;li&gt;主线程太忙，根据系统传递过来的 VSYNC 信号来时还没准备好数据导致丢帧。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;绘制耗时太长，有一些工具可以帮助我们定位问题。主线程太忙则需要注意了，主线程关键职责是处理用户交互，在屏幕上绘制像素，并进行加载显示相关的数据，所以特别需要避免任何主线程的事情，这样应用程序才能保持对用户操作的即时响应。总结起来，主线程主要做以下几个方面工作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UI 生命周期控制&lt;/li&gt;
&lt;li&gt;系统事件处理&lt;/li&gt;
&lt;li&gt;消息处理&lt;/li&gt;
&lt;li&gt;界面布局&lt;/li&gt;
&lt;li&gt;界面绘制&lt;/li&gt;
&lt;li&gt;界面刷新&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除此之外，应该尽量避免将其他处理放在主线程中，特别复杂的数据计算和网络请求等。&lt;/p&gt;
&lt;h5 id=&quot;性能分析工具&quot;&gt;性能分析工具&lt;/h5&gt;
&lt;p&gt;性能问题并不容易复现，也不好定位，但是真的碰到问题还是需要去解决的，那么分析问题和确认问题是否解决，就需要借助相应的的调试工具，比如查看 Layout 层次的 Hierarchy View、Android 系统上带的 GPU Profile 工具和静态代码检查工具 Lint 等，这些工具对性能优化起到非常重要的作用，所以要熟悉，知道在什么场景用什么工具来分析。&lt;/p&gt;
&lt;p&gt;1，Profile GPU Rendering&lt;/p&gt;
&lt;p&gt;在手机开发者模式下，有一个卡顿检测工具叫做：Profile GPU Rendering，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/331079/201712/331079-20171209150217730-754884569.png&quot; alt=&quot;Profile GPU Rendering&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它的功能特点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个图形监测工具，能实时反应当前绘制的耗时&lt;/li&gt;
&lt;li&gt;横轴表示时间，纵轴表示每一帧的耗时&lt;/li&gt;
&lt;li&gt;随着时间推移，从左到右的刷新呈现&lt;/li&gt;
&lt;li&gt;提供一个标准的耗时，如果高于标准耗时，就表示当前这一帧丢失&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2，TraceView&lt;/p&gt;
&lt;p&gt;TraceView 是 Android SDK 自带的工具，用来分析函数调用过程，可以对 Android 的应用程序以及 Framework 层的代码进行性能分析。它是一个图形化的工具，最终会产生一个图表，用于对性能分析进行说明，可以分析到每一个方法的执行时间，其中可以统计出该方法调用次数和递归次数，实际时长等参数维度，使用非常直观，分析性能非常方便。&lt;/p&gt;
&lt;p&gt;3，Systrace UI 性能分析&lt;/p&gt;
&lt;p&gt;Systrace 是 Android 4.1及以上版本提供的性能数据采样和分析工具，它是通过系统的角度来返回一些信息。它可以帮助开发者收集 Android 关键子系统，如 surfaceflinger、WindowManagerService 等 Framework 部分关键模块、服务、View系统等运行信息，从而帮助开发者更直观地分析系统瓶颈，改进性能。Systrace 的功能包括跟踪系统的 I/O 操作、内核工作队列、CPU 负载等，在 UI 显示性能分析上提供很好的数据，特别是在动画播放不流畅、渲染卡等问题上。&lt;/p&gt;
&lt;h5 id=&quot;优化建议&quot;&gt;优化建议&lt;/h5&gt;
&lt;p&gt;1，布局优化&lt;/p&gt;
&lt;p&gt;布局是否合理主要影响的是页面测量时间的多少，我们知道一个页面的显示测量和绘制过程都是通过递归来完成的，多叉树遍历的时间与树的高度h有关，其时间复杂度 O(h)，如果层级太深，每增加一层则会增加更多的页面显示时间，所以布局的合理性就显得很重要。&lt;/p&gt;
&lt;p&gt;那布局优化有哪些方法呢，主要通过减少层级、减少测量和绘制时间、提高复用性三个方面入手。总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;减少层级。合理使用 RelativeLayout 和 LinerLayout，合理使用Merge。&lt;/li&gt;
&lt;li&gt;提高显示速度。使用 ViewStub，它是一个看不见的、不占布局位置、占用资源非常小的视图对象。&lt;/li&gt;
&lt;li&gt;布局复用。可以通过 标签来提高复用。&lt;/li&gt;
&lt;li&gt;尽可能少用wrap_content。wrap_content 会增加布局 measure 时计算成本，在已知宽高为固定值时，不用wrap_content 。&lt;/li&gt;
&lt;li&gt;删除控件中无用的属性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2，避免过度绘制&lt;/p&gt;
&lt;p&gt;过度绘制是指在屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的 UI 结构中，如果不可见的 UI 也在做绘制的操作，就会导致某些像素区域被绘制了多次，从而浪费了多余的 CPU 以及 GPU 资源。&lt;/p&gt;
&lt;p&gt;如何避免过度绘制呢，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;布局上的优化。移除 XML 中非必须的背景，移除 Window 默认的背景、按需显示占位背景图片&lt;/li&gt;
&lt;li&gt;自定义View优化。使用 canvas.clipRect()来帮助系统识别那些可见的区域，只有在这个区域内才会被绘制。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3，启动优化&lt;/p&gt;
&lt;p&gt;通过对启动速度的监控，发现影响启动速度的问题所在，优化启动逻辑，提高应用的启动速度。启动主要完成三件事：UI 布局、绘制和数据准备。因此启动速度优化就是需要优化这三个过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UI 布局。应用一般都有闪屏页，优化闪屏页的 UI 布局，可以通过 Profile GPU Rendering 检测丢帧情况。&lt;/li&gt;
&lt;li&gt;启动加载逻辑优化。可以采用分布加载、异步加载、延期加载策略来提高应用启动速度。&lt;/li&gt;
&lt;li&gt;数据准备。数据初始化分析，加载数据可以考虑用线程初始化等策略。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4，合理的刷新机制&lt;/p&gt;
&lt;p&gt;在应用开发过程中，因为数据的变化，需要刷新页面来展示新的数据，但频繁刷新会增加资源开销，并且可能导致卡顿发生，因此，需要一个合理的刷新机制来提高整体的 UI 流畅度。合理的刷新需要注意以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尽量减少刷新次数。&lt;/li&gt;
&lt;li&gt;尽量避免后台有高的 CPU 线程运行。&lt;/li&gt;
&lt;li&gt;缩小刷新区域。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;5，其他&lt;/p&gt;
&lt;p&gt;在实现动画效果时，需要根据不同场景选择合适的动画框架来实现。有些情况下，可以用硬件加速方式来提供流畅度。&lt;/p&gt;
&lt;h3 id=&quot;内存优化&quot;&gt;内存优化&lt;/h3&gt;
&lt;p&gt;在 Android 系统中有个垃圾内存回收机制，在虚拟机层自动分配和释放内存，因此不需要在代码中分配和释放某一块内存，从应用层面上不容易出现内存泄漏和内存溢出等问题，但是需要内存管理。Android 系统在内存管理上有一个 Generational Heap Memory 模型，内存回收的大部分压力不需要应用层关心， Generational Heap Memory 有自己一套管理机制，当内存达到一个阈值时，系统会根据不同的规则自动释放系统认为可以释放的内存，也正是因为 Android 程序把内存控制的权力交给了 Generational Heap Memory，一旦出现内存泄漏和溢出方面的问题，排查错误将会成为一项异常艰难的工作。除此之外，部分 Android 应用开发人员在开发过程中并没有特别关注内存的合理使用，也没有在内存方面做太多的优化，当应用程序同时运行越来越多的任务，加上越来越复杂的业务需求时，完全依赖 Android 的内存管理机制就会导致一系列性能问题逐渐呈现，对应用的稳定性和性能带来不可忽视的影响，因此，解决内存问题和合理优化内存是非常有必要的。&lt;/p&gt;
&lt;h5 id=&quot;android内存管理机制&quot;&gt;Android内存管理机制&lt;/h5&gt;
&lt;p&gt;Android 应用都是在 Android 的虚拟机上运行，应用 程序的内存分配与垃圾回收都是由虚拟机完成的。在 Android 系统，虚拟机有两种运行模式：Dalvik 和 ART。&lt;/p&gt;
&lt;p&gt;1，Java对象生命周期&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/331079/201712/331079-20171209150256089-889660521.png&quot; alt=&quot;Java对象生命周期&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般Java对象在虚拟机上有7个运行阶段：&lt;/p&gt;
&lt;p&gt;创建阶段-&amp;gt;应用阶段-&amp;gt;不可见阶段-&amp;gt;不可达阶段-&amp;gt;收集阶段-&amp;gt;终结阶段-&amp;gt;对象空间重新分配阶段&lt;/p&gt;
&lt;p&gt;2，内存分配&lt;/p&gt;
&lt;p&gt;在 Android 系统中，内存分配实际上是对堆的分配和释放。当一个 Android 程序启动，应用进程都是从一个叫做 Zygote 的进程衍生出来，系统启动 Zygote 进程后，为了启动一个新的应用程序进程，系统会衍生 Zygote 进程生成一个新的进程，然后在新的进程中加载并运行应用程序的代码。其中，大多数的 RAM pages 被用来分配给Framework 代码，同时促使 RAM 资源能够在应用所有进程之间共享。&lt;/p&gt;
&lt;p&gt;但是为了整个系统的内存控制需要，Android 系统会为每一个应用程序都设置一个硬性的 Dalvik Heap Size 最大限制阈值，整个阈值在不同设备上会因为 RAM 大小不同而有所差异。如果应用占用内存空间已经接近整个阈值时，再尝试分配内存的话，就很容易引起内存溢出的错误。&lt;/p&gt;
&lt;p&gt;3，内存回收机制&lt;/p&gt;
&lt;p&gt;我们需要知道的是，在 Java 中内存被分为三个区域：Young Generation(年轻代)、Old Generation(年老代)、Permanent Generation(持久代)。最近分配的对象会存放在 Young Generation 区域。对象在某个时机触发 GC 回收垃圾，而没有回收的就根据不同规则，有可能被移动到 Old Generation，最后累积一定时间在移动到 Permanent Generation 区域。系统会根据内存中不同的内存数据类型分别执行不同的 GC 操作。GC 通过确定对象是否被活动对象引用来确定是否收集对象，进而动态回收无任何引用的对象占据的内存空间。但需要注意的是频繁的 GC 会增加应用的卡顿情况，影响应用的流畅性，因此需要尽量减少系统 GC 行为，以便提高应用的流畅度，减小卡顿发生的概率。&lt;/p&gt;
&lt;h5 id=&quot;内存分析工具&quot;&gt;内存分析工具&lt;/h5&gt;
&lt;p&gt;做内存优化前，需要了解当前应用的内存使用现状，通过现状去分析哪些数据类型有问题，各种类型的分布情况如何，以及在发现问题后如何发现是哪些具体对象导致的，这就需要相关工具来帮助我们。&lt;/p&gt;
&lt;p&gt;1，Memory Monitor&lt;/p&gt;
&lt;p&gt;Memory Monitor 是一款使用非常简单的图形化工具，可以很好地监控系统或应用的内存使用情况，主要有以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;显示可用和已用内存，并且以时间为维度实时反应内存分配和回收情况。&lt;/li&gt;
&lt;li&gt;快速判断应用程序的运行缓慢是否由于过度的内存回收导致。&lt;/li&gt;
&lt;li&gt;快速判断应用是否由于内存不足导致程序崩溃。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2，Heap Viewer&lt;/p&gt;
&lt;p&gt;Heap Viewer 的主要功能是查看不同数据类型在内存中的使用情况，可以看到当前进程中的 Heap Size 的情况，分别有哪些类型的数据，以及各种类型数据占比情况。通过分析这些数据来找到大的内存对象，再进一步分析这些大对象，进而通过优化减少内存开销，也可以通过数据的变化发现内存泄漏。&lt;/p&gt;
&lt;p&gt;3，Allocation Tracker&lt;/p&gt;
&lt;p&gt;Memory Monitor 和 Heap Viewer 都可以很直观且实时地监控内存使用情况，还能发现内存问题，但发现内存问题后不能再进一步找到原因，或者发现一块异常内存，但不能区别是否正常，同时在发现问题后，也不能定位到具体的类和方法。这时就需要使用另一个内存分析工具 Allocation Tracker，进行更详细的分析， Allocation Tracker 可以分配跟踪记录应用程序的内存分配，并列出了它们的调用堆栈，可以查看所有对象内存分配的周期。&lt;/p&gt;
&lt;p&gt;4，Memory Analyzer Tool(MAT)&lt;/p&gt;
&lt;p&gt;MAT 是一个快速，功能丰富的 Java Heap 分析工具，通过分析 Java 进程的内存快照 HPROF 分析，从众多的对象中分析，快速计算出在内存中对象占用的大小，查看哪些对象不能被垃圾收集器回收，并可以通过视图直观地查看可能造成这种结果的对象。&lt;/p&gt;
&lt;h5 id=&quot;常见内存泄漏场景&quot;&gt;常见内存泄漏场景&lt;/h5&gt;
&lt;p&gt;如果在内存泄漏发生后再去找原因并修复会增加开发的成本，最好在编写代码时就能够很好地考虑内存问题，写出更高质量的代码，这里列出一些常见的内存泄漏场景，在以后的开发过程中需要避免这类问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;资源性对象未关闭。比如Cursor、File文件等，往往都用了一些缓冲，在不使用时，应该及时关闭它们。&lt;/li&gt;
&lt;li&gt;注册对象未注销。比如事件注册后未注销，会导致观察者列表中维持着对象的引用。&lt;/li&gt;
&lt;li&gt;类的静态变量持有大数据对象。&lt;/li&gt;
&lt;li&gt;非静态内部类的静态实例。&lt;/li&gt;
&lt;li&gt;Handler临时性内存泄漏。如果Handler是非静态的，容易导致 Activity 或 Service 不会被回收。&lt;/li&gt;
&lt;li&gt;容器中的对象没清理造成的内存泄漏。&lt;/li&gt;
&lt;li&gt;WebView。WebView 存在着内存泄漏的问题，在应用中只要使用一次 WebView，内存就不会被释放掉。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除此之外，内存泄漏可监控，常见的就是用LeakCanary 第三方库，这是一个检测内存泄漏的开源库，使用非常简单，可以在发生内存泄漏时告警，并且生成 leak tarce 分析泄漏位置，同时可以提供 Dump 文件进行分析。&lt;/p&gt;
&lt;h5 id=&quot;优化内存空间&quot;&gt;优化内存空间&lt;/h5&gt;
&lt;p&gt;没有内存泄漏，并不意味着内存就不需要优化，在移动设备上，由于物理设备的存储空间有限，Android 系统对每个应用进程也都分配了有限的堆内存，因此使用最小内存对象或者资源可以减小内存开销，同时让GC 能更高效地回收不再需要使用的对象，让应用堆内存保持充足的可用内存，使应用更稳定高效地运行。常见做法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对象引用。强引用、软引用、弱引用、虚引用四种引用类型，根据业务需求合理使用不同，选择不同的引用类型。&lt;/li&gt;
&lt;li&gt;减少不必要的内存开销。注意自动装箱，增加内存复用，比如有效利用系统自带的资源、视图复用、对象池、Bitmap对象的复用。&lt;/li&gt;
&lt;li&gt;使用最优的数据类型。比如针对数据类容器结构，可以使用ArrayMap数据结构，避免使用枚举类型，使用缓存Lrucache等等。&lt;/li&gt;
&lt;li&gt;图片内存优化。可以设置位图规格，根据采样因子做压缩，用一些图片缓存方式对图片进行管理等等。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;稳定性优化&quot;&gt;稳定性优化&lt;/h3&gt;
&lt;p&gt;Android 应用的稳定性定义很宽泛，影响稳定性的原因很多，比如内存使用不合理、代码异常场景考虑不周全、代码逻辑不合理等，都会对应用的稳定性造成影响。其中最常见的两个场景是：Crash 和 ANR，这两个错误将会使得程序无法使用，比较常用的解决方式如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提高代码质量。比如开发期间的代码审核，看些代码设计逻辑，业务合理性等。&lt;/li&gt;
&lt;li&gt;代码静态扫描工具。常见工具有Android Lint、Findbugs、Checkstyle、PMD等等。&lt;/li&gt;
&lt;li&gt;Crash监控。把一些崩溃的信息，异常信息及时地记录下来，以便后续分析解决。&lt;/li&gt;
&lt;li&gt;Crash上传机制。在Crash后，尽量先保存日志到本地，然后等下一次网络正常时再上传日志信息。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;耗电优化&quot;&gt;耗电优化&lt;/h3&gt;
&lt;p&gt;在移动设备中，电池的重要性不言而喻，没有电什么都干不成。对于操作系统和设备开发商来说，耗电优化一致没有停止，去追求更长的待机时间，而对于一款应用来说，并不是可以忽略电量使用问题，特别是那些被归为“电池杀手”的应用，最终的结果是被卸载。因此，应用开发者在实现需求的同时，需要尽量减少电量的消耗。&lt;/p&gt;
&lt;p&gt;在 Android5.0 以前，在应用中测试电量消耗比较麻烦，也不准确，5.0 之后专门引入了一个获取设备上电量消耗信息的 API:Battery Historian。Battery Historian 是一款由 Google 提供的 Android 系统电量分析工具，和Systrace 一样，是一款图形化数据分析工具，直观地展示出手机的电量消耗过程，通过输入电量分析文件，显示消耗情况，最后提供一些可供参考电量优化的方法。&lt;/p&gt;
&lt;p&gt;除此之外，还有一些常用方案可提供：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;计算优化，避开浮点运算等。&lt;/li&gt;
&lt;li&gt;避免 WaleLock 使用不当。&lt;/li&gt;
&lt;li&gt;使用 Job Scheduler。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;安装包大小优化&quot;&gt;安装包大小优化&lt;/h3&gt;
&lt;p&gt;应用安装包大小对应用使用没有影响，但应用的安装包越大，用户下载的门槛越高，特别是在移动网络情况下，用户在下载应用时，对安装包大小的要求更高，因此，减小安装包大小可以让更多用户愿意下载和体验产品。&lt;/p&gt;
&lt;p&gt;常用应用安装包的构成，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/331079/201712/331079-20171209150321105-761685022.png&quot; alt=&quot;应用安装包构成&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中我们可以看到：&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;assets文件夹。存放一些配置文件、资源文件，assets不会自动生成对应的 ID，而是通过 AssetManager 类的接口获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;res。res 是 resource 的缩写，这个目录存放资源文件，会自动生成对应的 ID 并映射到 .R 文件中，访问直接使用资源 ID。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;META-INF。保存应用的签名信息，签名信息可以验证 APK 文件的完整性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;AndroidManifest.xml。这个文件用来描述 Android 应用的配置信息，一些组件的注册信息、可使用权限等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;classes.dex。Dalvik 字节码程序，让 Dalvik 虚拟机可执行，一般情况下，Android 应用在打包时通过 Android SDK 中的 dx 工具将 Java 字节码转换为 Dalvik 字节码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;resources.arsc。记录着资源文件和资源 ID 之间的映射关系，用来根据资源 ID 寻找资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;减少安装包大小的常用方案&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码混淆。使用proGuard 代码混淆器工具，它包括压缩、优化、混淆等功能。&lt;/li&gt;
&lt;li&gt;资源优化。比如使用 Android Lint 删除冗余资源，资源文件最少化等。&lt;/li&gt;
&lt;li&gt;图片优化。比如利用 AAPT 工具对 PNG 格式的图片做压缩处理，降低图片色彩位数等。&lt;/li&gt;
&lt;li&gt;避免重复功能的库，使用 WebP图片格式等。&lt;/li&gt;
&lt;li&gt;插件化。比如功能模块放在服务器上，按需下载，可以减少安装包大小。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;性能优化不是更新一两个版本就可以解决的，是持续性的需求，持续集成迭代反馈。在实际的项目中，在项目刚开始的时候，由于人力和项目完成时间限制，性能优化的优先级比较低，等进入项目投入使用阶段，就需要把优先级提高，但在项目初期，在设计架构方案时，性能优化的点也需要提早考虑进去，这就体现出一个程序员的技术功底了。&lt;/p&gt;
&lt;p&gt;什么时候开始有性能优化的需求，往往都是从发现问题开始，然后分析问题原因及背景，进而寻找最优解决方案，最终解决问题，这也是日常工作中常会用到的处理方式。&lt;/p&gt;
</description>
<pubDate>Sat, 09 Dec 2017 07:05:00 +0000</pubDate>
<dc:creator>cryAllen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cr330326/p/8011523.html</dc:identifier>
</item>
<item>
<title>C#爬虫系列（一）——国家标准全文公开系统 - 马洪彪</title>
<link>http://www.cnblogs.com/mahongbiao/p/8011467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mahongbiao/p/8011467.html</guid>
<description>&lt;p&gt;网上有很多Python爬虫的帖子，不排除很多培训班借着AI的概念教Python，然后爬网页自然是其中的一个大章节，毕竟做算法分析没有大量的数据怎么成。&lt;/p&gt;
&lt;p&gt;C#相比Python可能笨重了些，但实现简单爬虫也很便捷。网上有不少爬虫工具，通过配置即可实现对某站点内容的抓取，出于定制化的需求以及程序员重复造轮子的习性，我也做了几个标准公开网站的爬虫。&lt;/p&gt;
&lt;p&gt;在学习的过程中，爬网页的难度越来越大，但随着问题的一一攻克，学习到的东西也越来越多，从最初简单的GET，到POST，再到模拟浏览器填写表单、提交表单，数据解析也从最初的字符串处理、正则表达式处理，到HTML解析。一个NB的爬虫需要掌握的知识不少，HTTP请求、响应，HTML DOM解析，正则表达式匹配内容，多线程、数据库存储，甚至有些高级验证码的处理都得AI。&lt;/p&gt;
&lt;p&gt;当然，爬爬公开标准不是那么难，比如国家标准全文公开系统。&lt;/p&gt;
&lt;p&gt;整个过程需要爬以下页面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;列表页&lt;/li&gt;
&lt;li&gt;详细信息页&lt;/li&gt;
&lt;li&gt;文件下载页&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;需要处理的技术问题有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HTTP请求&lt;/li&gt;
&lt;li&gt;正则表达式&lt;/li&gt;
&lt;li&gt;HTML解析&lt;/li&gt;
&lt;li&gt;SqlLite数据库存储&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先查看到标准分GB和GB/T两类，地址分别为：&lt;/p&gt;
&lt;p&gt;http://www.gb688.cn/bzgk/gb/std_list_type?p.p1=1&amp;amp;p.p90=circulation_date&amp;amp;p.p91=desc&lt;/p&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;p&gt;http://www.gb688.cn/bzgk/gb/std_list_type?p.p1=2&amp;amp;p.p90=circulation_date&amp;amp;p.p91=desc。&lt;/p&gt;
&lt;p&gt;从中可以看出，GET请求的查询字符串参数p1值为1和2分别查询到GB和GB/T。因此，要获取到标准列表，向以上地址发送GET请求即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
HttpWebRequest httprequst =&lt;span&gt; (HttpWebRequest)WebRequest.Create(Url);
HttpWebResponse webRes &lt;/span&gt;=&lt;span&gt; (HttpWebResponse)httprequst.GetResponse();
 &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (System.IO.Stream stream =&lt;span&gt; webRes.GetResponseStream())
{
     &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (System.IO.StreamReader reader = &lt;span&gt;new&lt;/span&gt; StreamReader(stream,         System.Text.Encoding.GetEncoding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))
     {
         content &lt;/span&gt;=&lt;span&gt; reader.ReadToEnd();
     }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;标准共N多页，查看第二页标准列表，地址更改为：&lt;/p&gt;
&lt;p&gt;http://www.gb688.cn/bzgk/gb/std_list_type?r=0.7783908698326173&amp;amp;page=2&amp;amp;pageSize=10&amp;amp;p.p1=1&amp;amp;p.p90=circulation_date&amp;amp;p.p91=desc。&lt;/p&gt;
&lt;p&gt;由此可见page参数指定了分页列表的当前页数，据此，循环请求即可获取到所有的标准列表信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/378857/201712/378857-20171209142006074-837337348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;获取到标准列表后，下一步我需要获取到标准的详细信息页，从详细信息页中抓取更多的标准说明信息，例如标准的发布单位、归口单位等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/378857/201712/378857-20171209142640933-730322639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看标准详细页URL，其值为：&lt;/p&gt;
&lt;p&gt;http://www.gb688.cn/bzgk/gb/newGbInfo?hcno=9E5467EA1922E8342AF5F180319F34A0。&lt;/p&gt;
&lt;p&gt;可以看出每个标准有个GUID值，在列表页面中点击按钮“查看详细”，转到详细页。实现这个跳转的方式，最简单的是HTML超链接，此外还可以是JS脚本，甚至是POST数据到服务器。不同的链接方式，自然需要不同的抓取方式，因此需要查看列表页源码来分析该站点的实现方式并找到对应的处理方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/378857/201712/378857-20171209143149636-876558148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过分析源码，可以看到在点击标准号时，通过JS的showInfo函数打开详细页面，由于JS方法传递的ID即为详细页面的参数ID，因此没必要去模拟onclick执行JS函数，直接解析到该GUID，GET请求详细页面即可。解析该GUID值，可以通过正则表达式方便的抓取到。&lt;/p&gt;
&lt;p&gt;获取到详细信息页面后，要解析其中的内容，此时使用正则表达式解析就比较费劲了，可以采用HTML解析。C#解析HTML的第三方类库有不少，选择其中一款即可，HtmlAgilityPack或Winista.HtmlParser都是比较好用的。&lt;/p&gt;

&lt;p&gt;解析到标准详细信息后，还需要进一步获取到标准PDF文件，分析详细页面可以看到标准文件下载页面路径为：&lt;/p&gt;
&lt;p&gt;http://c.gb688.cn/bzgk/gb/showGb?type=download&amp;amp;hcno=9E5467EA1922E8342AF5F180319F34A0&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/378857/201712/378857-20171209143905386-672498884.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进一步分析PDF文件的URL为：&lt;/p&gt;
&lt;p&gt;http://c.gb688.cn/bzgk/gb/viewGb?hcno=9E5467EA1922E8342AF5F180319F34A0。&lt;/p&gt;
&lt;p&gt;仍然是那个GUID值，因此可以直接GET请求该地址即可下载标准PDF文件。&lt;/p&gt;
&lt;p&gt;至此标准的属性信息和标准PDF文件都可以下载到了，然后需要将这些信息存储起来。存储为SQL Server、Oracle自然比较笨重，即使Excel和Access也不大友好，推荐此类临时存储可以使用SqlLite。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('72dd17cc-a32d-4f79-a287-6eabafdfd8a2')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_72dd17cc-a32d-4f79-a287-6eabafdfd8a2&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_72dd17cc-a32d-4f79-a287-6eabafdfd8a2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('72dd17cc-a32d-4f79-a287-6eabafdfd8a2',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_72dd17cc-a32d-4f79-a287-6eabafdfd8a2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;string&lt;/span&gt; connectionString = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Data Source=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + dbBasePath + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StandardDB.db;Version=3;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
m_dbConnection &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SQLiteConnection(connectionString);
m_dbConnection.Open();
SQLiteCommand command &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SQLiteCommand(sql, m_dbConnection);
command.ExecuteNonQuery();
m_dbConnection.Close();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 09 Dec 2017 06:49:00 +0000</pubDate>
<dc:creator>马洪彪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mahongbiao/p/8011467.html</dc:identifier>
</item>
<item>
<title>Python资料汇总（建议收藏） - 鸿鹄当高远</title>
<link>http://www.cnblogs.com/jukaiit/p/8011454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jukaiit/p/8011454.html</guid>
<description>&lt;p&gt;整理汇总，内容包括长期必备、入门教程、练手项目、学习视频。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/4af700024656afc89446&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;一、长期必备。&lt;/p&gt;
&lt;p&gt;1. StackOverflow，是疑难解答、bug排除必备网站，任何编程问题请第一时间到此网站查找。&lt;/p&gt;
&lt;p&gt;https://stackoverflow.com/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/4af6000256962ec39e33&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. github，是源码学习、版本控制不可缺少的网站，找源码学习请第一时间到此网站，fork之后自己维护。&lt;/p&gt;
&lt;p&gt;https://github.com/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/4afb0000178f9dc445ab&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. Awesome Python 最全的python资源，没有之一，绝对不容错过的python资源大全。&lt;/p&gt;
&lt;p&gt;https://github.com/vinta/awesome-python&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/4af600025eae5981f6a0&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. Awesome Python 的中文翻译&lt;/p&gt;
&lt;p&gt;https://github.com/jobbole/awesome-python-cn&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/4af50005e47089330a50&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5. python中文学习大本营http://www.pythondoc.com/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/4afa0001eb9598f84c5c&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6. 伯乐在线网站http://python.jobbole.com/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9.pstatp.com/large/4afa0001ec3c80552b49&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;二、入门教程&lt;/p&gt;
&lt;p&gt;1. 笨方法学python，最受欢迎的python入门教程。边学边撸的教程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/4af700025ea37abb913f&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 简明python教程，简明是最大的特点&lt;/p&gt;
&lt;p&gt;http://old.sebug.net/paper/python/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/4afa0001f9fdc4b3ae58&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. python菜鸟教程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9.pstatp.com/large/4af600027009840634a5&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 廖雪峰的python教程，重点讲述python和其它语言的不同，适合有其它语言基础的朋友。&lt;/p&gt;
&lt;p&gt;三、练手项目&lt;/p&gt;
&lt;p&gt;1. 自写一个分布式爬虫。比如爬取知乎全站/头条全站/豆瓣全站等等，任何一个你想爬取的网站。完成之后获得如下技能。用爬虫项目练手实在能学习许多知识。&lt;/p&gt;
&lt;p&gt;1.1. http协议知识，能学会如何封装http请求包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/4af8000267a09575c6d3&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.2. redis/mongo/mysql等各种数据库知识。nosql和sql的知识有多重要就不用多说了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/4af700026ac1332191a6&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.3. scrapy爬虫神器的知识&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/4afb00003354d6b35c44&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.4 反爬虫知识。&lt;/p&gt;
&lt;p&gt;比如验证码识别，javascript混淆与还原，加密与解密，ajax异步请求，更换代理ip等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9.pstatp.com/large/4af6000277844c6ee335&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.5.谷歌开发人员工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/4a330004d82b18cdf8d2&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 人工智能方向，分别用k近邻、svm、神经网络等各种机器学习的方法识别mnist。这是人工智能的入门项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/4afa000205c1072f8afd&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 数据分析方向。[使用 Spark 和 D3.js 分析航班大数据]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/4af800026ec39a77b659&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 25个练手项目由易到难，代码量从几十行到几千行，在实验环境里保证可以全部完成。&lt;/p&gt;
&lt;p&gt;http://www.360doc.com/content/16/0314/09/1513309_542022647.shtml&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/4af600027c4f0e8c9486&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/4af600027c6be6c47cdf&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;四、视频教程。&lt;/p&gt;
&lt;p&gt;http://bbs.itheima.com/thread-336964-1-1.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/4af8000275b3aca5f9f7&quot; alt=&quot;python资料汇总（建议收藏）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;转  IT老友&lt;/p&gt;
</description>
<pubDate>Sat, 09 Dec 2017 06:44:00 +0000</pubDate>
<dc:creator>鸿鹄当高远</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jukaiit/p/8011454.html</dc:identifier>
</item>
<item>
<title>【MySQL疑难杂症】如何将树形结构存储在数据库中（方案二 Path Enumeration） - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/8010973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/8010973.html</guid>
<description>&lt;p&gt;　　今天来介绍把树形结构存入数据库的第二种方法——路径枚举法。&lt;/p&gt;
&lt;p&gt;　　还是借用上一篇的栗子，为了方便大家查阅，我把图又原样搬过来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1043143/201712/1043143-20171209105637359-1698437053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　需要回答的问题依旧是这样几个：&lt;/p&gt;
&lt;p&gt;　　1.查询小天的直接上司。&lt;/p&gt;
&lt;p&gt;　　2.查询老宋管理下的直属员工。&lt;/p&gt;
&lt;p&gt;　　3.查询小天的所有上司。&lt;/p&gt;
&lt;p&gt;　　4.查询老王管理的所有员工。&lt;/p&gt;
&lt;p&gt;方案二、 Path Enumeration 路径枚举法，记录下根节点到每个子节点的路径。&lt;/p&gt;
&lt;p&gt;　　先创建表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE TABLE employees2(
eid INT,
ename VARCHAR(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;),
position VARCHAR(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;),
path VARCHAR(&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;)
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后插入数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1043143/201712/1043143-20171209111120292-431364431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在我们来回答一下之前的问题：&lt;/p&gt;
&lt;p&gt;　　1.查询小天的直接上司。&lt;/p&gt;
&lt;p&gt;　　在上一个解决方案中能轻而易举做到的事情，在这个方案中却有些麻烦了，因为需要对path字段进行字符串处理，去掉“/”+自身id才是直接上司的path值。又开始一顿骚操作：&lt;/p&gt;
&lt;p&gt;　　SELECT e1.eid,e1.ename FROM employees2 e1,employees2 e2 WHERE e2.ename = '小天' AND e1.path = REPLACE(e2.path,CONCAT('/',e2.eid),'');&lt;/p&gt;
&lt;p&gt;　　好像这个操作还不够sao，2333，结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1043143/201712/1043143-20171209133621808-266016495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.查询老宋管理下的直属员工。&lt;/p&gt;
&lt;p&gt;　　怎么查管理下的直属员工呢？那就要用模糊查询了：&lt;/p&gt;
&lt;p&gt;　　SELECT e2.eid,e2.ename FROM employees2 e1,employees2 e2 WHERE e1.ename = '老宋' AND e2.path REGEXP CONCAT(e1.path,'/[0-9]{1,}$');&lt;/p&gt;
&lt;p&gt;　　这里用了正则匹配，匹配所有path符合规则的记录，结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1043143/201712/1043143-20171209135222167-149575084.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3.查询小天的所有上司。&lt;/p&gt;
&lt;p&gt;　　SELECT e1.eid,e1.ename FROM employees2 e1,employees2 e2 WHERE e2.ename='小天' AND e2.path like concat(e1.path,'/%');&lt;/p&gt;
&lt;p&gt;　　这里就能体现这种存储结构的优势了。不看效率的话，还是很方便的。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1043143/201712/1043143-20171209141334261-2050111779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4.查询老王管理的所有员工。&lt;/p&gt;
&lt;p&gt;　　SELECT e2.eid,e2.ename FROM employees2 e1,employees2 e2 WHERE e1.ename='老王' AND e2.path like concat(e1.path,'/%');&lt;/p&gt;
&lt;p&gt;　　看吧，查起来就so easy了。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1043143/201712/1043143-20171209141458933-57495167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　不用像之前那样写一大段存储过程了，简单粗暴。&lt;/p&gt;
&lt;p&gt;　　小结一下，存储路径的方式在进行多级查询的时候十分方便，而在查询直接上下级的时候稍微复杂一点。还有一个很明显的缺点，那就是path的大小是指定的，所以理论上是不能进行无限层级的存储的，path值设置的越大，浪费的空间就越多。&lt;/p&gt;
&lt;p&gt;　　至此，本篇介绍完毕，之后还会介绍其他方法，欢迎大家继续关注！&lt;/p&gt;

</description>
<pubDate>Sat, 09 Dec 2017 06:18:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/8010973.html</dc:identifier>
</item>
<item>
<title>浅谈canvas绘画王者荣耀--雷达图 - 车大棒</title>
<link>http://www.cnblogs.com/chedabang/p/8011321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chedabang/p/8011321.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-275638d71519a34a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;：&lt;br/&gt;一日晚上下班的我静静的靠在角落上听着歌，这时&quot;滴!滴!&quot;手机上传来一阵qq消息。原来我人在问王者荣耀的雷达图在页面上如何做出来的，有人回答用canvas绘画。那么问题来了，已经好久没有使用canvas绘画了东西。&lt;br/&gt;&lt;strong&gt;SO&lt;/strong&gt;，就想自己画一个canvas雷达图，顺便重新回顾一下canvas的知识点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;聊天记录当中的雷达图不是特别清楚，所以我这边截图了自己的一个战绩雷达图。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-5b7f70cd9c8ba7df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;王者荣耀截图&quot;/&gt;&lt;br/&gt;是不是有被我的战绩吓到了，害不害怕！&lt;br/&gt;好了扯远了，让我们回到正题上来。&lt;br/&gt;通过截图上面的雷达图基本主体是一个正六边形，每个顶点则配有相应的文字说明。&lt;br/&gt;然后就是中间红色区域部分则由对角线上的点，连成一圈填充构成。因此这里我们称它为数据填充区&lt;br/&gt;所以这个雷达图我们分为三步来完成。&lt;br/&gt;①正六边形&lt;br/&gt;②数据填充区&lt;br/&gt;③绘制文本&lt;/p&gt;

&lt;p&gt;在绘画这个正六边形的时候，先让我们对于这个正六边形进行简单的数学分析。&lt;br/&gt;这里先用画板画一个正六变形，然后进行切割并切角。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-2829c491837aca91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;六边形.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是吧，借用以前高中还是初中的数学，正六边形的内角和&lt;code&gt;720°&lt;/code&gt;，那么每一个对角就是&lt;code&gt;120°&lt;/code&gt;。在已知对角线的长度。那么通过&lt;code&gt;sin60°&lt;/code&gt;，&lt;code&gt;cos60°&lt;/code&gt;一类的，那个可以求出各个三角形的边长。&lt;/p&gt;
&lt;p&gt;可是问题来了，这里我们要计算的是各个坐标点。而canvas的坐标轴是从左上角算（0，0）原点的单象限坐标轴。假设六边形的中心点是（250，250）、对角线的长度是100*2，那么按照三角函数推断：&lt;br/&gt;&lt;code&gt;bottom-center&lt;/code&gt;坐标：&lt;code&gt;（250, 250 + 100）&lt;/code&gt;&lt;br/&gt;&lt;code&gt;bottom-left&lt;/code&gt;坐标：&lt;code&gt;（250 - 100*sin(60°), 250+100*cos(60°)）&lt;/code&gt;&lt;br/&gt;&lt;code&gt;top-left&lt;/code&gt;坐标：&lt;code&gt;（250 - 100*sin(60°), 250-100*cos(60°)）&lt;/code&gt;&lt;br/&gt;&lt;code&gt;top-center&lt;/code&gt;坐标：&lt;code&gt;（250, 250 - 100）&lt;/code&gt;&lt;br/&gt;&lt;code&gt;top-right&lt;/code&gt;坐标：&lt;code&gt;（250 + 100*sin(60°), 250-100*cos(60°)）&lt;/code&gt;&lt;br/&gt;&lt;code&gt;bottom-right&lt;/code&gt;的坐标：&lt;code&gt;（250 + 100*sin(60°), 250+100*cos(60°)）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-aeece3521ba158be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;坐标是出来了，但是一个点一个点去绘画是不是有点太low了！&lt;br/&gt;肿么办？&lt;br/&gt;啦啦啦啦！&lt;br/&gt;那么就到了我们找规律的时间来了！&lt;/p&gt;
&lt;p&gt;但是在找规律的同时，为毛中心点的&lt;code&gt;X&lt;/code&gt;轴和别人不一样，为毛一会加一会减。&lt;/p&gt;
&lt;p&gt;所以当思考各坐标点参数的规律的时候，让先回顾以前的&lt;strong&gt;函数角度图表&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-63b72d5f149daeb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;函数角度图表.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看完这个函数参照图之后，让我再次修改一下6个点的书写方式。&lt;br/&gt;&lt;code&gt;bottom-center&lt;/code&gt;坐标：&lt;code&gt;（250 + 100*sin(0°), 250 + 100*cos(0°)）&lt;/code&gt;&lt;br/&gt;&lt;code&gt;bottom-left&lt;/code&gt;坐标：&lt;code&gt;（250 + 100*sin(300°), 250+100*cos(300°)）&lt;/code&gt;&lt;br/&gt;&lt;code&gt;top-left&lt;/code&gt;坐标：&lt;code&gt;（250 + 100*sin(240°), 250-100*cos(240°)）&lt;/code&gt;&lt;br/&gt;&lt;code&gt;top-center&lt;/code&gt;坐标：&lt;code&gt;（250 +100*sin(180°), 250 + 100*cos(180°)）&lt;/code&gt;&lt;br/&gt;&lt;code&gt;top-right&lt;/code&gt;坐标：&lt;code&gt;（250 + 100*sin(120°), 250-100*cos(120°)）&lt;/code&gt;&lt;br/&gt;&lt;code&gt;bottom-right&lt;/code&gt;的坐标：&lt;code&gt;（250 + 100*sin60°), 250+100*cos(60°)）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个时候再看组坐标数据点，是不是感觉有点意思！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-506c1a4b0459b33c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么这个时候我们便可以通过一个for循环，用一个数组把这6个坐标点给记录下来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var pointArr = [];
for (var i = 0; i &amp;lt; 6; i++) {
        pointArr[i] = {};
       pointArr[i].x = 250 + 100 * Math.sin(60 * i);
        pointArr[i].y = 250 + 100* Math.cos(60 * i);
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;前面既然，将正六边形的坐标点通过一个for循环解析出来。那么就是代码绘画正六边形了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;style&amp;gt;
        canvas {
            display: block;
            width: 500px;
            height: 500px;
        }
&amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;canvas class=&quot;radar&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
    var canvas = document.getElementsByClassName('radar')[0];
    canvas.width = 500;
    canvas.height = 500;
    var ctx = canvas.getContext('2d');
    ctx.save();
    ctx.strokeStyle = '#888888';  // 设置线条颜色
    var lineArr = [];
    var rAngle = Math.PI * 2 / 6;  // 算出每一个内角和
    console.log(rAngle);
    var rCenter = 250;  // 确定中心点
    var curR = 100;   // 确定半径长度
    ctx.beginPath();
    for (var i = 0; i &amp;lt; 6; i++) {
        lineArr[i] = {};
        lineArr[i].y = rCenter + curR * Math.cos(rAngle * i);
        lineArr[i].x = rCenter + curR * Math.sin(rAngle * i);
        ctx.lineTo(lineArr[i].x, lineArr[i].y);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-992f4fcadaac97ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;绘画的六边形.png&quot;/&gt;&lt;br/&gt;啦啦啦！！！一个正六边形就这么的画出来。&lt;br/&gt;&lt;strong&gt;备注：&lt;/strong&gt;这里rAngle这里是很灵活的，如果说画18正边形，就除以18，然后for循环18次就ok了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-a1688189af67e363.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;正18边形.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哈哈！！感觉发现了新大陆了！绘制正多边形的貌似可以按照这个规律来！！&lt;/p&gt;

&lt;p&gt;既然前面有一个数组存储各个坐标点，所以让每个对角线对角点直线想连就ok了！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ctx.strokeStyle = '#e8ddc7';  // PS吸管那么一吸
    ctx.save();
    ctx.beginPath();
    // for (var j = 0; j &amp;lt; 3; j++) {
    //     ctx.lineTo(lineArr[j].x, lineArr[j].y);
    //     ctx.lineTo(lineArr[j+3].x, lineArr[j+3].y);
    //     ctx.stroke();
    // }
    for (var j = 0; j &amp;lt; 3; j++) {
        ctx.moveTo(lineArr[j].x, lineArr[j].y);
        ctx.lineTo(lineArr[j + 3].x, lineArr[j + 3].y);
        ctx.stroke();
    }
    ctx.closePath();
    ctx.restore();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-c80251413136d2e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;

&lt;p&gt;关于数据填充区，也就是雷达图当中，不规则的红色半透明的六边形。其实就是就可以看做中心点，到各个边角点之间线段为一区间这。之后就是将这个区间分成若干份，你占这个这个区间多少份，满份就是边角点，零份就是原点。&lt;/p&gt;
&lt;p&gt;观察前面的雷达图当中，B等级大概占据某个等级的50%左右。而B前面还有等级A、S。&lt;br/&gt;所以当S等级时候，可以看作区间 / 1。&lt;br/&gt;B等级看作区间 / 2, 那么A就是 区间 / 1.5.&lt;br/&gt;以此类推就可以得出剩下 C 就是区间 / 2.5、D：区间/ 3&lt;/p&gt;
&lt;p&gt;这里我就不用for循环书写了，直接偷懒手写一个对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 绘制数据区域
var letterData = {
        'S': 1,
        'A': 1.5,
        'B': 2,
        'C': 2.5,
        'D': 3
    }
ctx.save();
ctx.beginPath();
for (var i = 0; i &amp;lt; 6; i++) {
        lineArr[i].yEnd = rCenter + curR * Math.cos(rAngle * i) / (letterData[rData[i][1]]);
        lineArr[i].xEnd = rCenter + curR * Math.sin(rAngle * i) / (letterData[rData[i][1]]);
        ctx.lineTo(lineArr[i].xEnd, lineArr[i].yEnd); 
        console.log(lineArr);
 }
ctx.closePath();
ctx.stroke();
ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; 
ctx.fill();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-3aa96b9ac338177f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;雷达图能力区域&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当我们回归到前面的截图发现，需要单独把数据填充区域的的各个点位置给加强，并把边角用更深的线条的描绘出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ctx.lineWidth = 2;  //设置数据填充区域的线条颜色
ctx.strokeStyle = '#dd3f26';  //设置填充区域的颜色
var point = 3; //设置数据填充区域的小圆点大小
for (var i = 0; i &amp;lt; 6; i++) {
        ctx.beginPath();
        ctx.arc(lineArr[i].xEnd, lineArr[i].yEnd, point, 0, Math.PI * 2); 
        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
        ctx.fill();
        console.log(lineArr);
    }
    ctx.restore();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-59f2b5ad2d2a2206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;修饰完成数据区域&quot;/&gt;&lt;/p&gt;

&lt;p&gt;王者荣耀雷达文本是需要绘制两点，&lt;br/&gt;①用黑色16px字体绘制各点描述点&lt;br/&gt;②用红色30px字体绘制各点能力级别&lt;/p&gt;
&lt;p&gt;但是估计看到绘制文本，估计有的小伙伴就会说。不是有数组的存储各个边角的坐标，直接一个for循环依次根据各个点绘画出来不就OK了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; // 绘制文本
    var rData = [
        ['生存', 'S'],
        ['经济', 'S'],
        ['输出', 'S'],
        ['KDA', 'B'],
        ['打野', 'B'],
        ['推进', 'S']
    ]
    ctx.save();
    ctx.font = '16px Microsoft Yahei';  //设置字体
    ctx.fillStyle = '#000';  // 颜色
    for (var i = 0; i &amp;lt; 6; i++) {
        var y = rCenter + curR * Math.cos(rAngle * i);
        var x = rCenter + curR * Math.sin(rAngle * i);
        ctx.fillText(rData[i][0], x, y);
    }
    ctx.restore();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器最终显示的视觉效果：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-8825829295cae96a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-53c6408d608488b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;惊不惊喜&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是觉得很惊喜，这里&lt;code&gt;输出&lt;/code&gt;、&lt;code&gt;经济&lt;/code&gt;位置勉强还行，但是剩下的文字位置就偏差了许多了。所以在绘制文字的时候，还得针对文字的坐标位置进行相应的调整。&lt;/p&gt;

&lt;p&gt;既然直接调用坐标的位置会出问题，那么让根据上文中的图片文字的规则简单分析。&lt;br/&gt;①如果&lt;code&gt;X轴&lt;/code&gt; == 中心点，那么就判断&lt;code&gt;Y轴&lt;/code&gt;。比中心点大文字下移一点，反之文字上移一点。&lt;br/&gt;②如果&lt;code&gt;X轴&lt;/code&gt; &amp;lt; 中心点，那么文字X轴位置就左移动一点,反正右移动距离。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; // 绘制文本
    ctx.save();
    var fontSize = 16;
    ctx.font =  fontSize + 'px Microsoft Yahei';
    ctx.textBaseline=&quot;middle&quot;; //设置基线参考点
    ctx.textAlign=&quot;center&quot;;  // 文本居中
    ctx.fillStyle = '#000';
    for (var i = 0; i &amp;lt; 6; i++) {
        var y = rCenter + curR * Math.cos(rAngle * i);
        var x = rCenter + curR * Math.sin(rAngle * i);
        console.log(Math.sin(rAngle * i))
        var s_width = ctx.measureText(rData[i][0]).width; //获取当前绘画的字体宽度
        if ( x == rCenter) {
            if (y &amp;gt; rCenter ) {
                ctx.fillText(rData[i][0], x - s_width/2, y + fontSize);
            } else {
                ctx.fillText(rData[i][0], x - s_width/2, y - fontSize);
            }
        } else if ( x &amp;gt; rCenter) {
            console.log(rData[i][0]);
            ctx.fillText(rData[i][0], x + s_width*1.5, y);
        } else {
             ctx.fillText(rData[i][0], x - s_width*1.5, y);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-51d2fb9e11ac8c9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;调整好的样式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里多了好几个不常用的属性，下面就是介绍这些属性的特点：&lt;br/&gt;&lt;code&gt;ctx.textBaseline&lt;/code&gt;: 设置或返回在绘制文本时使用的当前文本基线&lt;br/&gt;说到基线，各位童鞋想一想咱们以前英文练习本，上面有着一条条线条&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-47164e89996c5ebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;英语练习本&quot;/&gt;&lt;/p&gt;
&lt;p&gt;瞬间回忆到当年被罚抄英语单词的岁月，一把辛酸泪呀。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-5c95a2ba1de5ad57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网页设计字体也有一个基线的存在，因此canvas的基线点就是直接从坐标点划出一条横线基线。&lt;br/&gt;这里从网络上截图一张，通过设置基线参考位置，看看文本所在位置的改变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-7e813cca3730a0da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片来自网络&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctx.textAlign&lt;/code&gt;: 这个文本水平居中，不过和CSS当中的居中不一样的是，他是从坐标点划出一条竖线分割文本的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-6d9173fa9f115baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片来自网络&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctx.measureText&lt;/code&gt; : 返回包含指定文本宽度的对象。&lt;/p&gt;
&lt;p&gt;通俗一点的就是说，就是获取你绘制文本的宽度。假设一排文字内容为'Hello World'， size为16px大小文本。在这里高度都是16px稳定不变，这样canvas画其他元素对这个位置只需要&lt;code&gt;Y轴&lt;/code&gt;移动这个文本的'size'大小就可以避免覆盖到上面。&lt;/p&gt;
&lt;p&gt;但是如果要&lt;code&gt;X&lt;/code&gt;轴去移动位置,你根本不知道'Hello World'这串文本的长度。那么这个时候就需要ctx.measureText这个方法，获取当前你绘制文本的宽度。&lt;/p&gt;

&lt;p&gt;既然前面已经介绍了描述的绘画方法，那么依葫芦画瓢。让我们一并开始绘制能力级别的文本。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 绘制文本
    ctx.save();
    var fontSize = 16;
    var maxfontSize = 30;
    ctx.font =  fontSize + 'px Microsoft Yahei';
    ctx.textBaseline=&quot;middle&quot;;
    ctx.textAlign=&quot;center&quot;;
    for (var i = 0; i &amp;lt; 6; i++) {
        var y = rCenter + curR * Math.cos(rAngle * i);
        var x = rCenter + curR * Math.sin(rAngle * i);
        console.log(Math.sin(rAngle * i))
        var s_width = ctx.measureText(rData[i][0]).width;
        if ( x == rCenter) {
            if (y &amp;gt; rCenter ) {
                ctx.fillText(rData[i][0], x - s_width/2, y + fontSize);
            } else {
                ctx.fillText(rData[i][0], x - s_width/2, y - fontSize);
            }
        } else if ( x &amp;gt; rCenter) {
            console.log(rData[i][0]);
            ctx.fillText(rData[i][0], x + s_width*1.5, y);
        } else {
             ctx.fillText(rData[i][0], x - s_width*1.5, y);
        }
    }
    ctx.restore();
    ctx.save(); 
// 绘制等级
    ctx.font = '30px Microsoft Yahei bold';
    ctx.fillStyle = '#d7431f';
    ctx.textBaseline=&quot;middle&quot;;
    ctx.textAlign=&quot;center&quot;;
    for (var i = 0; i &amp;lt; 6; i++) {
        var y = rCenter + curR * Math.cos(rAngle * i);
        var x = rCenter + curR * Math.sin(rAngle * i);
        var M_width = ctx.measureText(rData[i][1]).width;
        if ( x == rCenter) {
            if (y &amp;gt; rCenter ) {
                ctx.fillText(rData[i][1], x + M_width/2, y + fontSize);
            } else {
                ctx.fillText(rData[i][1], x + M_width/2, y - fontSize);
            }
        } else if ( x &amp;gt; rCenter) {
            console.log(rData[i][0]);
            ctx.fillText(rData[i][1], x + M_width, y);
        } else {
             ctx.fillText(rData[i][1], x - M_width, y);
        }
    }
    ctx.restore();
    ctx.save();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;页面最终效果：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-bddeb0559053c83b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;最终的效果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-43412db048a7a9d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;

&lt;p&gt;好了！以上就是鄙人对于canvas绘画一点简单理解与复习了，其中也回顾了一些canvas基本属性点。后续如何用canvas玩出各种花样就看各位看官自己了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小贴士：&lt;/strong&gt;&lt;br/&gt;在使用&lt;code&gt;ctx.measureText&lt;/code&gt;这个方法的时候需要注意一下。这个方法在宽度参考对象也跟当前绘画环境的font-size有关联的。&lt;/p&gt;
&lt;p&gt;打个比方说，在绘制描述的文本的时候。font-size设置是16px，那么ctx.measureText('输出').width 是32。&lt;br/&gt;那么在绘制能力等级的时候，font-size设置是32，那么ctx.measureText('输出').width 就不再是32了而是64或者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;贴士2：&lt;/strong&gt;&lt;br/&gt;这里顺便帮做设计朋友推广他的一个微信H5视频案例，全程水墨画武侠风，画工炒鸡棒棒。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-d706c6727fc0b618.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-e890f20a736b0556.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外前面&lt;code&gt;loading动画&lt;/code&gt;宝剑出鞘css3部分，利用极少&lt;code&gt;transform3d&lt;/code&gt;代码完成。感兴趣的童鞋可以微信扫一扫，看一下运动轨迹就心中估计就能猜出运行的的css3代码了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-460f93e8db2499a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;微信体验地址&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原创文章，文笔有限，才疏学浅，文中若有不正之处，再次再次再次欢迎各位啪啪的打脸赐教。（有句话说的好，重要的词得说三遍。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2064035-61c901fbbbeb06b4.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我是车大棒！我为我自己……emmmmmmm，今天就不自己带眼了，为朋友插眼吧！&lt;/p&gt;
</description>
<pubDate>Sat, 09 Dec 2017 06:00:00 +0000</pubDate>
<dc:creator>车大棒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chedabang/p/8011321.html</dc:identifier>
</item>
<item>
<title>Carbondata源码系列（二）文件格式详解 - 岑玉海</title>
<link>http://www.cnblogs.com/cenyuhai/p/7191291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cenyuhai/p/7191291.html</guid>
<description>&lt;p&gt;在上一章当中，写了文件的生成过程。这一章主要讲解文件格式（V3版本）的具体细节。&lt;/p&gt;

&lt;p&gt;字典文件的作用是在存储的时候将字符串等类型转换为int类型，好处主要有两点：&lt;/p&gt;
&lt;p&gt;1、减少存储占用空间&lt;/p&gt;
&lt;p&gt;2、用在需要group by的字段上比较合适，可以减少计算时的shuffle的数据量。&lt;/p&gt;
&lt;p&gt;每一个字典列都有对应的三种文件.dict, .sortindex, .dictmeta文件，输出格式都是thrift格式&lt;/p&gt;
&lt;h2&gt;1.1 .dict文件&lt;/h2&gt;
&lt;p&gt;字典的值每满1000就作为一个chunk输出一次，具体的类是ColumnDictionaryChunk&lt;/p&gt;
&lt;p&gt;相关参数：&lt;/p&gt;
&lt;p&gt;carbon.dictionary.chunk.size&lt;/p&gt;
&lt;h2&gt;1.2 .sortindex文件&lt;/h2&gt;
&lt;p&gt;把字段的值sort了一下之后，计算出每个值的sortIndex和invertedIndex，具体的类是ColumnSortInfo&lt;/p&gt;
&lt;p&gt;1、List&amp;lt;SortIndex&amp;gt;，记录着每个字典值的surrogate，从1开始&lt;/p&gt;
&lt;p&gt;2、List&amp;lt;SortInvertedIndex&amp;gt;，记录着每个字典surrogate在数组中的位置，从1开始&lt;/p&gt;
&lt;p&gt;它们的关系如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
      sortIndex[i] =&lt;span&gt; dictionarySortModel.getKey();
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the array index starts from 0 therefore -1 is done to avoid wastage
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; of 0th index in array and surrogate key starts from 1 there 1 is added to i
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; which is a counter starting from 0&lt;/span&gt;
      sortIndexInverted[dictionarySortModel.getKey() - &lt;span&gt;1&lt;/span&gt;] = i + &lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设字典值是beijing，shenzhen，shanghai&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;城市&lt;/td&gt;
&lt;td&gt;surrogate&lt;/td&gt;
&lt;td&gt;sortIndex&lt;/td&gt;
&lt;td&gt;invertIndex&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;beijing&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;shenzhen&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;shanghai&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;1.3 .dictmeta文件&lt;/h2&gt;
&lt;p&gt;该文件主要记录字典的以下属性，具体的类是ColumnDictionaryChunkMeta&lt;/p&gt;
&lt;p&gt;1、最小key&lt;/p&gt;
&lt;p&gt;2、最大的key&lt;/p&gt;
&lt;p&gt;3、开始offset&lt;/p&gt;
&lt;p&gt;4、结束offset&lt;/p&gt;
&lt;p&gt;5、chunk的数量&lt;/p&gt;

&lt;h2&gt;2.1 数据块的组成部分&lt;/h2&gt;
&lt;p&gt;CarbonRow在sort阶段会被分成3个部分:&lt;/p&gt;
&lt;p&gt;1、字典列&lt;/p&gt;
&lt;p&gt;2、非字典维度列和高基数列&lt;/p&gt;
&lt;p&gt;3、度量值列&lt;/p&gt;
&lt;p&gt;在写入的时候，先写入到TablePage里，TablePage会把数据拆分成4部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; one vector to make it efficient for sorting&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ColumnPage[] dictDimensionPages;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ColumnPage[] noDictDimensionPages;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ComplexColumnPage[] complexDimensionPages;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ColumnPage[] measurePages;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 每个TablePage都会记录以下几个Key：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[][] currentNoDictionaryKey;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MDK start key&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] startKey;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MDK end key&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] endKey;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; startkey for no dictionary columns&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[][] noDictStartKey;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; endkey for no diciotn&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[][] noDictEndKey;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; startkey for no dictionary columns after packing into one column&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] packedNoDictStartKey;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; endkey for no dictionary columns after packing into one column&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] packedNoDictEndKey;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据在一行一行写到TablePage之后，最后会做一次统一的编码，详细的方法请看TablePage的encode方法。&lt;/p&gt;
&lt;p&gt;Page的meta信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt; DataChunk2 buildPageMetadata(ColumnPage inputPage, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] encodedBytes)
      throws IOException {
    DataChunk2 dataChunk &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataChunk2();
    dataChunk.setData_page_length(encodedBytes.length);
    fillBasicFields(inputPage, dataChunk);
    fillNullBitSet(inputPage, dataChunk);
    fillEncoding(inputPage, dataChunk);
    fillMinMaxIndex(inputPage, dataChunk);
    fillLegacyFields(dataChunk);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataChunk;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个blocket的阈值是64MB，一个blocket包括N个TablePage，当写满一个TablePage之后，就把blocket写入到文件当中。&lt;/p&gt;
&lt;p&gt;carbondata的BTree索引，是一个记录着每个Blocklet的mdk的startKey和endKey，以及Blocklet当中所有TablePage的列的最大最小值&lt;/p&gt;
&lt;p&gt;那么数据文件的详细格式，基本和官网上介绍的是一致的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/477362/201712/477362-20171209133320902-966253135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.2 What is MDK&lt;/h2&gt;
&lt;p&gt;mdk和hbase的rowkey是一个性质的，详细可以看下面这张图，排序方式跟hbase没有任何区别。但是carbondata的mdk只能是字典列，如果我没有设置字典列的话，只是设置了SORT_COLUMN，Carbondata的过滤只是靠列的最大最小值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/477362/201712/477362-20171203161449663-1474929043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;索引文件以.carbonindex结尾&lt;/p&gt;
&lt;p&gt;索引文件包括三个部分：索引头，索引两部分&lt;/p&gt;
&lt;p&gt;索引头包括：&lt;/p&gt;
&lt;p&gt;1、文件格式版本(当前版本是V3)&lt;/p&gt;
&lt;p&gt;2、Segment信息（有多少列，列的基数）&lt;/p&gt;
&lt;p&gt;3、列的信息&lt;/p&gt;
&lt;p&gt;4、bucket ID&lt;/p&gt;

&lt;p&gt;索引信息包括以下信息：&lt;/p&gt;
&lt;p&gt;1、Blocket的记录数&lt;/p&gt;
&lt;p&gt;2、数据文件名&lt;/p&gt;
&lt;p&gt;3、Blocket的meta信息offset&lt;/p&gt;
&lt;p&gt;3、BlockletIndex (BTree索引，包含blocket的startKey、endKey，以及每一列的最大最小值，这个前面已经讲过了)&lt;/p&gt;
&lt;p&gt;4、BlocketInfo（记录数，每个TablePage的offset，每个TablePage的长度，维度列dimension_offsets的起始位置，度量值measure_offsets的起始位置，有多少个TablePagenumber_number_of_pages）&lt;/p&gt;

&lt;p&gt;索引文件的信息在文件的footer当中也是存在的，在carbondata1.2当中索引文件还是有很多个，感觉有点多余。&lt;/p&gt;
&lt;p&gt;到carbondata1.3会被合并成一个文件，这样就能大大缩短启动的时候加载索引的开销。&lt;/p&gt;


&lt;p&gt;岑玉海&lt;/p&gt;
&lt;p&gt;转载请注明出处，谢谢！&lt;/p&gt;


</description>
<pubDate>Sat, 09 Dec 2017 05:41:00 +0000</pubDate>
<dc:creator>岑玉海</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cenyuhai/p/7191291.html</dc:identifier>
</item>
<item>
<title>【Win 10 应用开发】将墨迹保存到图像的两种方法 - 东邪独孤</title>
<link>http://www.cnblogs.com/tcjiaan/p/8010845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tcjiaan/p/8010845.html</guid>
<description>&lt;p&gt;IT界最近这几年，各种乱七八糟的东西不断出现，其中能用在实际工作与生活中的，大概也就那么几个。Web 前端也冒出各种框架，这就为那些喜欢乱用框架的公司提供了很好的机会，于是造成很多项目体积越来越庞大，越来越难维护。一切变得越来越没有标准，所以，很多公司在招聘码农时就特能乱写，还要求你精通 AA，BB，CC，DD，EE，FF，GG……甚至有的不下二三十项要求。老周觉得这些公司基本上是神经病，先不说世界没有人能精通那么多东西，就算真有人能精通那么多，那估计这个人也活不久了，早晚得累死的。&lt;/p&gt;
&lt;p&gt;实际上，Web 前端你能学会三样东西就够了——HTML、CSS、JS，其他纯属娱乐。&lt;/p&gt;
&lt;p&gt;所以，学习编程的话，你抓几个有代表性地学就好了，比如C/C++，.net，PHP，Java 这些，其余的嘛，现学现用，用完就扔。你要是想让自己变成高手的话，那你就必须挑一个方向，纵向深度发展。什么都学等于什么都不通，学乱七八糟的东西是成不了高手的。就拿黑客这一活儿来说，只有第一代，第二代黑客比较强，后面的基本是菜鸟，一代不如一代。没办法，浮躁的时代，IT业也不可幸免的。&lt;/p&gt;

&lt;p&gt;好了，上面的都是P话，下面老周开始说正题，今天咱们谈谈如何将电子墨迹保存到图像。在近年来出现的各种花拳绣腿技术中，电子墨迹还算是有实用价值的东西。还有触控、虚拟化这些，也有一定的用途。人工智障倒是可有可无，可作为辅助，但不太可靠，最起码它代替不了人脑（笨蛋例外），我估计将来搞艺术可能吃香，毕竟机器是不懂艺术的。普工可能会大量失业，因为他们做的事情可以让机器做了（主要是重复性，机械性的工作）。&lt;/p&gt;
&lt;p&gt;拿笔写字是人的本能，千万不要鼠标键盘用多了连笔都拿不动（这已经是“鼠标手”的轻度症状了，不及时治疗，以后会很难看的）。科技再发达，人类的本能绝不能丢，就好比哪天你连穿衣吃饭都不会了，那你活该饿死。&lt;/p&gt;
&lt;p&gt;本文就介绍两种比较简单的方法：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种是运用 win 2D 封装的功能来完成。老周做的那个“练字神器”应用就是用这种方法保存你的书法作品的，其中的宣纸纸纹原理也很简单，就是分层绘制，首先在底层绘制纸张的纹理图案，然后再把墨迹绘制到底纹之上即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二种不需要借助其他 Nuget 上的库，只要使用 1709 最新的 API 就能实现。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;先说第一种方案。&lt;/p&gt;
&lt;p&gt;为了演示，老周就做简单一点。下面 XAML 代码在界面上声明了一个 InkCanvas ，用来收集输入的墨迹，然后一个 Button ，点击后选择文件路径，然后保存为 png 图片。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{ThemeResource ApplicationPageBackgroundThemeBrush}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition &lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;=&quot;auto&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;InkCanvas &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;inkcv&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;=&quot;保存墨迹&quot;&lt;/span&gt;&lt;span&gt; Click&lt;/span&gt;&lt;span&gt;=&quot;OnClick&quot;  Grid.Row=&quot;1&quot; Margin=&quot;2,9.5&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着，你要打开 nuget 管理器，向项目添加 Win 2D 的引用。这个老周不多说了，你懂怎么操作的。&lt;/p&gt;
&lt;p&gt;如果你绘制的墨迹图像需要在界面上显示，可以用 CanvasControl 控件，然后处理 Draw 事件，如果不需要在界面上显示，例如这个例子，我们是直接保存为图像文件的，所以不需要在界面上添加 CanvasControl 元素了。&lt;/p&gt;
&lt;p&gt;前面在写 UI Composition 的文章时，老周曾用过 Win 2D 做演示，负责绘制操作的是 CanvasDrawingSession 类，其中，你会发现，它有一个方法叫 DrawInk，对的，我们用的就是它，它可以把我们从用户输入收集到的墨迹绘制下来。它有两个重载，其中一个是指定是否绘制成高对比度模式。&lt;/p&gt;
&lt;p&gt;好，理论上的屁话不多说，我直接上代码，你一看就懂的。&lt;/p&gt;
&lt;p&gt;不过，在页面类的构造函数中，我们得先设置一下书写的参数，比如笔触大小、颜色等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MainPage()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.InitializeComponent();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 支持笔，手触，鼠标输入&lt;/span&gt;
            inkcv.InkPresenter.InputDeviceTypes = Windows.UI.Core.CoreInputDeviceTypes.Mouse | Windows.UI.Core.CoreInputDeviceTypes.Pen |&lt;span&gt; Windows.UI.Core.CoreInputDeviceTypes.Touch;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设定笔迹颜色为红色&lt;/span&gt;
            InkDrawingAttributes data = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InkDrawingAttributes();
            data.Color &lt;/span&gt;=&lt;span&gt; Colors.Red;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 笔触大小&lt;/span&gt;
            data.Size = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Size(15d, 15d);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 忽略笔的倾斜识别，毕竟只有新型的笔才有这感应&lt;/span&gt;
            data.IgnoreTilt = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新参数&lt;/span&gt;
&lt;span&gt;            inkcv.InkPresenter.UpdateDefaultDrawingAttributes(data);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;随后就可以处理 Button 的 Click 事件了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnClick(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有输入墨迹，那就别浪费 CPU 时间了&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(inkcv.InkPresenter.StrokeContainer.GetStrokes().Any() == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 选择保存文件&lt;/span&gt;
            FileSavePicker picker = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileSavePicker();
            picker.FileTypeChoices.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PNG 图像&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            picker.SuggestedFileName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sample&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            picker.SuggestedStartLocation &lt;/span&gt;=&lt;span&gt; PickerLocationId.Desktop;
            StorageFile file &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; picker.PickSaveFileAsync();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (file == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 建一个在内存中用的画板（不显示在 UI 上）
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取共享的 D2D 设备引用&lt;/span&gt;
            CanvasDevice device =&lt;span&gt; CanvasDevice.GetSharedDevice();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图像大小与 InkCanvas 控件大小相同&lt;/span&gt;
            &lt;span&gt;float&lt;/span&gt; width = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)inkcv.ActualWidth;
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; height = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)inkcv.ActualHeight;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DPI 为 96&lt;/span&gt;
            &lt;span&gt;float&lt;/span&gt; dpi =&lt;span&gt; 96f;
            CanvasRenderTarget drawtarget &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CanvasRenderTarget(device, width, height, dpi);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始作画&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; drawSession =&lt;span&gt; drawtarget.CreateDrawingSession())
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们上面设置了用的是红笔
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了生成图片后看得清楚
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把墙刷成白色&lt;/span&gt;
&lt;span&gt;                drawSession.Clear(Colors.White);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 画墨迹&lt;/span&gt;
&lt;span&gt;                drawSession.DrawInk(inkcv.InkPresenter.StrokeContainer.GetStrokes());
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存到输出文件&lt;/span&gt;
            &lt;span&gt;await&lt;/span&gt; drawtarget.SaveAsync(&lt;span&gt;await&lt;/span&gt; file.OpenAsync(FileAccessMode.ReadWrite), CanvasBitmapFileFormat.Png, &lt;span&gt;1.0f&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放资源&lt;/span&gt;
&lt;span&gt;            drawtarget.Dispose();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行应用后，随便写点啥上去。如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/367389/201712/367389-20171209115503480-1587010160.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后点击按钮，保存一下。生成的图片如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/367389/201712/367389-20171209115620542-699768355.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 好，第一种方案完结，接下来咱们用第二种方案。&lt;/p&gt;
&lt;p&gt;这是 1709 （秋季创作者更新）的新功能。新的 SDK 中增加了一个 CoreInkPresenterHost 类（位于 Windows.UI.Input.Inking.Core 命名空间），使用这类，你可以不需要 InkCanvas 控件，你可以把墨迹接收图面放到任意的 XAML 元素上。因为该类公开一个 RootVisual 属性，注意它不是指向 XAML 可视化元素，而是 ContainerVisual 对象。这是 UI Composition 中的容器类。&lt;/p&gt;
&lt;p&gt;老周前不久刚写过一堆与 UI Composition 有关的文章，如果你不了解相关内容，可以看老周前面的烂文。通过前面对 UI Composition 的学习，我们知道，可以将可视化对象添加到任意 XAML 可视化元素上。对，这个 CoreInkPresenterHost 类就是运用了这个特点，使得墨迹收集可以脱离 InkCanvas 控件，以后，你爱在哪个元素上收集墨迹都行，比如，你想让用户可以对图像进行涂鸦，你就可以把这个类放到 Image 元素上。&lt;/p&gt;
&lt;p&gt;P话少说，咱们来点干货。下面的例子，其界面和前一个例子相似，只是没有用上 InkCanvas 控件，而只是声明了个 Border 元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{ThemeResource ApplicationPageBackgroundThemeBrush}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition &lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;=&quot;auto&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;bd&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; BorderThickness&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; BorderBrush&lt;/span&gt;&lt;span&gt;=&quot;Green&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;4,8&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;保存墨迹&quot;&lt;/span&gt;&lt;span&gt; Click&lt;/span&gt;&lt;span&gt;=&quot;OnClick&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后切换到代码文件，在页面类的构造函数中，进行一下初始化。初始化的东西挺多，包括用 Compositor 创建用来承载墨迹的容器 Visual ，以及设置笔触参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        CoreInkPresenterHost inkHost = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MainPage()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.InitializeComponent();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组装一个 UI，把一个可视化容器放到 Border 上&lt;/span&gt;
            Visual bdvisual =&lt;span&gt; ElementCompositionPreview.GetElementVisual(bd);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; compositor =&lt;span&gt; bdvisual.Compositor;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个容器&lt;/span&gt;
           &lt;strong&gt; ContainerVisual inkContainer =&lt;span&gt; compositor.CreateContainerVisual();
            &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时因为各元素的宽度和高度都为0，所以用动画来更新容器的大小&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; expressAnimate =&lt;span&gt; compositor.CreateExpressionAnimation();
            expressAnimate.Expression &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bd.Size&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            expressAnimate.SetReferenceParameter(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, bdvisual);
            inkContainer.StartAnimation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Size&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, expressAnimate);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置容器与 Border 关联&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;            ElementCompositionPreview.SetElementChildVisual(bd, inkContainer);

            &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理墨迹收集关联&lt;/span&gt;
            &lt;strong&gt;inkHost = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CoreInkPresenterHost();
            inkHost.RootVisual &lt;/span&gt;=&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; inkContainer;
&lt;/strong&gt;            inkHost.InkPresenter.InputDeviceTypes &lt;/span&gt;= Windows.UI.Core.CoreInputDeviceTypes.Mouse | Windows.UI.Core.CoreInputDeviceTypes.Pen |&lt;span&gt; Windows.UI.Core.CoreInputDeviceTypes.Touch;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置笔触参数&lt;/span&gt;
            InkDrawingAttributes attrib = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InkDrawingAttributes();
            attrib.Color &lt;/span&gt;=&lt;span&gt; Colors.SkyBlue;
            attrib.Size &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Size(15f, 15f);
            attrib.IgnoreTilt &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新参数&lt;/span&gt;
&lt;span&gt;            inkHost.InkPresenter.UpdateDefaultDrawingAttributes(attrib);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建了容器 Visual 后，记得要通过 CoreInkPresenterHost 对象的 RootVisual 属性来关联。当然你不能忘了把这个 visual 加到 Border 的子元素序列上。&lt;/p&gt;
&lt;p&gt;现在处理 Click 事件，用 RenderTargetBitmap 类，把 Border 的内容画出来，这样会连同它上面的墨迹也一起画出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个类可以绘制 XAML 元素，以前介绍过&lt;/span&gt;
            RenderTargetBitmap rtarget = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RenderTargetBitmap();
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; rtarget.RenderAsync(bd);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后用图像编码器写入文件就行了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取像素数据&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; pxBuffer = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; rtarget.GetPixelsAsync();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始为图像编码&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; stream = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; outFile.OpenAsync(FileAccessMode.ReadWrite))
            {
                BitmapEncoder encoder &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; BitmapEncoder.CreateAsync(BitmapEncoder.PngEncoderId, stream);
                encoder.SetPixelData(BitmapPixelFormat.Bgra8, BitmapAlphaMode.Premultiplied, (&lt;/span&gt;&lt;span&gt;uint&lt;/span&gt;)rtarget.PixelWidth, (&lt;span&gt;uint&lt;/span&gt;&lt;span&gt;)rtarget.PixelHeight, 96d, 96d, pxBuffer.ToArray());
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; encoder.FlushAsync();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完整的事件处理代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnClick(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (inkHost.InkPresenter.StrokeContainer.GetStrokes().Any() == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            FileSavePicker picker &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileSavePicker();
            picker.FileTypeChoices.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PNG 图像文件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            picker.SuggestedFileName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sample&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            StorageFile outFile &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; picker.PickSaveFileAsync();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (outFile == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个类可以绘制 XAML 元素，以前介绍过&lt;/span&gt;
            RenderTargetBitmap rtarget = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RenderTargetBitmap();
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; rtarget.RenderAsync(bd);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取像素数据&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; pxBuffer = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; rtarget.GetPixelsAsync();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始为图像编码&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; stream = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; outFile.OpenAsync(FileAccessMode.ReadWrite))
            {
                BitmapEncoder encoder &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; BitmapEncoder.CreateAsync(BitmapEncoder.PngEncoderId, stream);
                encoder.SetPixelData(BitmapPixelFormat.Bgra8, BitmapAlphaMode.Premultiplied, (&lt;/span&gt;&lt;span&gt;uint&lt;/span&gt;)rtarget.PixelWidth, (&lt;span&gt;uint&lt;/span&gt;&lt;span&gt;)rtarget.PixelHeight, 96d, 96d, pxBuffer.ToArray());
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; encoder.FlushAsync();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好，完事了，现在运行一下，直接中 Border 元素上写点东东。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/367389/201712/367389-20171209124228058-523148467.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后点击底部的按钮保存为图片，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/367389/201712/367389-20171209124307402-82687961.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;


&lt;p&gt;OK，本文就扯到这里了，开饭，不然饭菜凉了。&lt;/p&gt;

</description>
<pubDate>Sat, 09 Dec 2017 04:44:00 +0000</pubDate>
<dc:creator>东邪独孤</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tcjiaan/p/8010845.html</dc:identifier>
</item>
<item>
<title>《Linux命令行与shell脚本编程大全》第二十二章 gawk进阶 - xcywt</title>
<link>http://www.cnblogs.com/xcywt/p/8011052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xcywt/p/8011052.html</guid>
<description>&lt;p&gt;gawk是一门功能丰富的编程语言，你可以通过它所提供的各种特性来编写好几程序处理数据。 &lt;/p&gt;
&lt;h2&gt;22.1 使用变量&lt;/h2&gt;
&lt;p&gt;gawk编程语言支持两种不同类型的变量：&lt;/p&gt;
&lt;p&gt;内建变量和自定义变量&lt;/p&gt;

&lt;h3&gt;22.1.1 内建变量&lt;/h3&gt;
&lt;p&gt;gawk程序使用内建变量来引用程序数据里的一些特殊功能&lt;/p&gt;

&lt;p&gt;1.字段和记录分隔符变量&lt;/p&gt;
&lt;p&gt;数据字段变量：允许你使用美元符和字段在该记录中的位置值来引用记录对应的字段。&lt;/p&gt;
&lt;p&gt;要引用第一个字段就用变量$1，第二个就用$2,….以此类推。&lt;/p&gt;

&lt;p&gt;数据字段是由分隔符来划定的。默认字段分隔符是一个空白字符，也就是空格或者制表符。&lt;/p&gt;

&lt;p&gt;有一组内建变量用于控制gawk如何处理输入输出数据中的字段和记录，见下表：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;149&quot;&gt;
&lt;p&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;419&quot;&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;149&quot;&gt;
&lt;p&gt;&lt;strong&gt;FIELDWIDTHS&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;419&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;有空格分隔的一列数字，定义每个数据字段的确切宽度&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;149&quot;&gt;
&lt;p&gt;&lt;strong&gt;FS&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;419&quot;&gt;
&lt;p&gt;输入字段分隔符&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;149&quot;&gt;
&lt;p&gt;&lt;strong&gt;RS&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;419&quot;&gt;
&lt;p&gt;输入记录分隔符&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;149&quot;&gt;
&lt;p&gt;&lt;strong&gt;OFS&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;419&quot;&gt;
&lt;p&gt;输出字段分隔符&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;149&quot;&gt;
&lt;p&gt;&lt;strong&gt;ORS&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;419&quot;&gt;
&lt;p&gt;输出记录分隔符&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;1）print命令会自动将OFS变量的值放置在输出中的每个字段间。&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;blockquote readability=&quot;52&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;cat data1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data11,data12,data13,data14&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data21,data22,data23,data24&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data31,data32,data33,data34&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data41,data42,data43,data44&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data51,data52,data53,data54&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk 'BEGIN{FS=&quot;,&quot;; OFS=&quot;-&quot;} {print $1,$2,$3}' data1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data11-data12-data13&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data21-data22-data23&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data31-data32-data33&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data41-data42-data43&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data51-data52-data53&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk 'BEGIN{FS=&quot;,&quot;; OFS=&quot;&amp;lt;--&amp;gt;&quot;} {print $1,$2,$3}' data1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data11&amp;lt;--&amp;gt;data12&amp;lt;--&amp;gt;data13&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data21&amp;lt;--&amp;gt;data22&amp;lt;--&amp;gt;data23&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data31&amp;lt;--&amp;gt;data32&amp;lt;--&amp;gt;data33&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data41&amp;lt;--&amp;gt;data42&amp;lt;--&amp;gt;data43&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data51&amp;lt;--&amp;gt;data52&amp;lt;--&amp;gt;data53&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2） FIELDWIDTHS变量允许你不依靠字段分割符来读取记录。一旦这是了FILEDWIDTFS变量，gawk就会忽略FS变量。&lt;/p&gt;
&lt;p&gt;警告：一旦设定了FIELDWIDTHS变量的值，就不能再改变了。这种方法并不适用于变长的字段&lt;/p&gt;

&lt;p&gt;有写数据没有指定分隔符，而是放在特定的列，这时候就可以用FIELDWIDTHS了：&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;cat data2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1005.3246782.37&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;115-2.343324.08&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;05828.3452433.1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk 'BEGIN{FIELDWIDTHS=&quot;3 5 2 5&quot;} {print $1,$2,$3,$4}' data2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;100 5.324 67 82.37&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;115 -2.34 33 24.08&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;058 28.34 52 433.1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3）RS和ORS定义了gawk程序如何处理数据流中的字段。默认这两个都是换行符&lt;/p&gt;
&lt;p&gt;默认的RS表明，输入数据流中的每行新文本就是一条新记录&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;cat data3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;kobe bryant&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;24 Los Lakers&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;Los, road34&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;99038&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;Paul Gaoso&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;15 los Lakers&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;Los, road 38&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;23123&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk 'BEGIN{FS=&quot;\n&quot;;RS=&quot;&quot;} {print $1, $4}' data3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;kobe bryant 99038&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Paul Gaoso 23123&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk 'BEGIN{FS=&quot;\n&quot;;RS=&quot;&quot;} {print $1, $2}' data3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;kobe bryant 24 Los Lakers&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Paul Gaoso 15 los Lakers&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面的例子中，4行才是一条记录，所以指定FS=”\n”&lt;/p&gt;
&lt;p&gt;每行只是一个字段。&lt;/p&gt;
&lt;p&gt;如何判断一个新的数据行的开始：解决方法计算RS变量设为空。然后在数据记录之间留一个空白行。gawk会把每个空白行当做一个记录分隔符。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认的字段分隔符是空格，记录分割符是换行符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上面的例子把字段分割符改成了换行符，记录分隔符编程了空白行（RS=””&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2. 数据变量&lt;/p&gt;
&lt;p&gt;还有一些其他的内建变量：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot;&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;ARGC&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;当前命令行参数个数&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;ARGIND&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;当前文件在ARGV的位置&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;ARGV&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;包含命令行参数的数组&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;CONVFMT&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;数字的转换格式，模式是%.6 g&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;ENVIRON&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;当前shell环境变量及其值组成的关联数组&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;ERRNO&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;当读取或关闭文件发生错误时的系统错误号&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;FILENAME&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;用作输入数据的数据文件的文件名&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;FNR&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;当前数据文件的数据行数&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;IGNORECASE&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;设成非零值，忽略gawk命令中出现的字符串的字符大小写&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;NF&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;数据文件中的字段总数&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;NR&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;已处理的输入记录数&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;OFMT&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;数字的输出格式，默认值%.6 g&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;RLENGTH&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;由match函数所匹配的字符串的长度&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;140&quot;&gt;
&lt;p&gt;&lt;strong&gt;RSTART&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;由match函数所匹配的字符串的起始位置&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;实例1：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk 'BEGIN{print ARGC,ARGV[1]}' data2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2 data2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk 'BEGIN{print ENVIRON[&quot;HOME&quot;]}'&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;/home/xcy&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk 'BEGIN{print ENVIRON[&quot;HOME&quot;]; print ENVIRON[&quot;PATH&quot;]}'&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;/home/xcy&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/sbin/:/usr/bin:/usr/sbin:/home/xcy/Bt_A7/Bt_A7/gcc-linaro-arm-linux-gnueabihf-4.9-2014.09_linux/bin&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; ENVIRON[“HOME”] 从系统中提取HOME环境变量的值。&lt;/p&gt;

&lt;p&gt;例子2：&lt;/p&gt;
&lt;p&gt;当要在gawk程序中跟踪数据字段和记录时，变量FNR，NF和NR就非常方便了。&lt;/p&gt;
&lt;p&gt;NF变量可以在你不知道具体位置的情况下指定记录中的最后一个数据字段：&lt;/p&gt;
&lt;p&gt;$gawk ‘BEGIN{FS=”:”; OFS=”:”} {print $1, $NF}’ /etc/passwd&lt;/p&gt;
&lt;p&gt;假设NF为7，那么相当于是$7。打印最后一个字段&lt;/p&gt;

&lt;p&gt;例子3：&lt;/p&gt;
&lt;p&gt;FNR变量含有当前数据文件中已处理过的记录数&lt;/p&gt;
&lt;p&gt;NR变量则含有已处理过的记录总数&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk 'BEGIN{FS=&quot;,&quot;} {print $1,&quot;FNR=&quot;FNR}' data1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data11 FNR=1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data21 FNR=2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data31 FNR=3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data41 FNR=4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data51 FNR=5&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk 'BEGIN{FS=&quot;,&quot;} {print $1,&quot;FNR=&quot;FNR, &quot;NR=&quot;NR} END{print &quot;There were &quot;,&lt;strong&gt;NR&lt;/strong&gt;,&quot; recordes&quot;}' data1 data1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data11 FNR=1 NR=1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data21 FNR=2 NR=2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data31 FNR=3 NR=3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data41 FNR=4 NR=4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data51 FNR=5 NR=5&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data11 FNR=1 NR=6&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data21 FNR=2 NR=7&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data31 FNR=3 NR=8&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data41 FNR=4 NR=9&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data51 FNR=5 NR=10&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;There were  10  recordes&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当处理第2个文件时，FNR又被置成1了，但是NR还是继续增加的。&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1）在shell脚本中使用gawk时，应该将gawk的命令放到不同的行，便于理解和阅读&lt;/p&gt;
&lt;p&gt;2）如果在不同的shell脚本中使用了相同的gawk脚本，应该把gawk放在一个单独的文件中。再用-f参数去引用它。&lt;/p&gt;


&lt;h3&gt;22.1.2自定义变量&lt;/h3&gt;
&lt;p&gt;变量名可以是字母下划线开头，还可以有数字。并且变量名区分大小写&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;在脚本中给变量赋值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以对变量进行修改，可以进行数学运算&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk '&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; BEGIN{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; test=&quot;hahaha, i am test&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; print test}'&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;hahaha, i am test&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk '&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;BEGIN{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;test=&quot;hahaha, i am test&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;print test&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; test=156&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; print test&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; }'&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;hahaha, i am test&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;156&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk '&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; BEGIN{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; x=4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; x=x*3+4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; print x&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; }'&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;16&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt; &lt;strong&gt;在命令行上给变量赋值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也可以用gawk命令行来给程序中的变量赋值。这允许你在正常的代码之外赋值。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;cat script&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;BEGIN{FS=&quot;,&quot;}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{print $n}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk -f script n=3 data1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data13&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data23&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data33&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data43&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data53&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面可以给n进行赋值，改变脚本的行为。&lt;/p&gt;
&lt;p&gt;这样可以在不改变脚本代码的情况下就能改变脚本的行为&lt;/p&gt;
&lt;p&gt;上面这样存在的问题是设置的变量在代码的BEGIN部分不可用&lt;/p&gt;

&lt;p&gt;解决方法，用-v参数。它允许你在BEGIN代码之前设定变量，要放在脚本代码之前。&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;cat script2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;BEGIN{print &quot;The starting value is&quot;,n; FS=&quot;,&quot;}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{print $n}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk &lt;strong&gt;-v&lt;/strong&gt; n=4 -f script2 data1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The starting value is 4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data14&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data24&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data34&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data44&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;data54&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;22.2 处理数组&lt;/h2&gt;
&lt;p&gt;gawk编程语言使用关联数组提供数组功能&lt;/p&gt;
&lt;p&gt;关联数组跟数字数组不同之处在于它的索引值可以是任意文本字符串。&lt;/p&gt;
&lt;p&gt;不需要用连续的数字来标识数组元素。关联数组用各种字符串来引用值&lt;/p&gt;
&lt;p&gt;每个索引字符串都必须能够唯一标识赋给它的数据元素&lt;/p&gt;

&lt;h3&gt;22.2.1 定义数组变量&lt;/h3&gt;
&lt;p&gt;用标准赋值语句来定义数组变量。格式如下：&lt;/p&gt;
&lt;p&gt;var[index]=element&lt;/p&gt;
&lt;p&gt;var是变量名，index是关联数组的索引值 element是数据元素值&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;这里要加双引号，数字不用加，字符串需要加&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk '                     &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;BEGIN{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;nba[&quot;kobe&quot;]=&quot;bryant&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;nba[&quot;cp3&quot;]=&quot;paul&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;print nba[&quot;kobe&quot;]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;print nba[&quot;cp3&quot;]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;}'&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;bryant&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;paul&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;#&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;还可以进行数学运算。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk '&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; BEGIN{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; arr[1]=99&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; arr[2]=77&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; total=arr[1] + arr[2]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; print &quot;total =&quot;,total&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;gt; }'&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;total = 176&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h3&gt;22.2.2 遍历数组变量&lt;/h3&gt;
&lt;p&gt;关联数组的索引可以是任何东西&lt;/p&gt;
&lt;p&gt;遍历数组可以用for语句的一种特殊形式：&lt;/p&gt;
&lt;p&gt;for (var in array)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;  statements&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这个for语句会在每次循环时都将关联数组array的下一个索引值赋值给变量var，然后执行一遍statements&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;cat script3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;BEGIN{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;var[&quot;a&quot;]=&quot;hahah&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;var[&quot;b&quot;]=2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;var[&quot;c&quot;]=&quot;yutong keche&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;var[&quot;d&quot;]=4&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;for (test in var)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         print &quot;Index:&quot;,test,&quot; - Value:&quot;,var[test]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;gawk -f script3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Index: a  - Value: hahah&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Index: b  - Value: 2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Index: c  - Value: yutong keche&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Index: d  - Value: 4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;22.2.3删除数组变量&lt;/h3&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;p&gt;delete array[index]&lt;/p&gt;
&lt;p&gt;删除以后就没办法再用它来提取元素值了。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xcy@xcy-virtual-machine:~/shell/22zhang$&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;cat script4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;BEGIN{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;var[&quot;a&quot;]=&quot;hahah&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;var[&quot;b&quot;]=2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;var[&quot;c&quot;]=&quot;yutong keche&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;for (test in var)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;         print &quot;old: Index:&quot;,test,&quot; - Value:&quot;,var[test]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;print &quot;Now,delete array:&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;delete var[&quot;c&quot;]&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;for (test in var)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 09 Dec 2017 03:51:00 +0000</pubDate>
<dc:creator>xcywt</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xcywt/p/8011052.html</dc:identifier>
</item>
<item>
<title>【微服务】之四：轻松搞定SpringCloud微服务-负载均衡Ribbon - 千万之路刚开始</title>
<link>http://www.cnblogs.com/hyhnet/p/8011029.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hyhnet/p/8011029.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;对于任何一个高可用高负载的系统来说，负载均衡是一个必不可少的名称。在大型分布式计算体系中，某个服务在单例的情况下，很难应对各种突发情况。因此，负载均衡是为了让系统在性能出现瓶颈或者其中一些出现状态下可以进行分发业务量的解决方案。在SpringCloud 体系当中，加入了Netflix公司的很多优秀产品，其中一个就是针对于服务端进行负载均衡的Ribbon。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本系列博文目录&quot;&gt;本系列博文目录&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/hyhnet/p/7998751.html&quot;&gt;【微服务】之三：轻松搞定SpringCloud微服务目录&lt;/a&gt;&lt;br/&gt;本系列为连载文章，阅读本文之前强烈建议您先阅读前面几篇。&lt;/p&gt;
&lt;h2 id=&quot;相关简介&quot;&gt;相关简介&lt;/h2&gt;
&lt;h3 id=&quot;负载均衡简介&quot;&gt;负载均衡简介&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;：英文名称为&lt;strong&gt;Load Balance&lt;/strong&gt;， 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。&lt;br/&gt;负载均衡带来的好处很明显：&lt;/p&gt;
&lt;h3 id=&quot;ribbon简介&quot;&gt;Ribbon简介&lt;/h3&gt;
&lt;p&gt;Ribbon是Netflix开源的一款用于客户端软负载均衡的工具软件。Spring Cloud对Ribbon进行了一些封装以更好的使用Spring Boot的自动化配置理念。&lt;/p&gt;
&lt;h3 id=&quot;spring-cloud-ribbon-简介&quot;&gt;Spring Cloud Ribbon 简介&lt;/h3&gt;
&lt;p&gt;Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。&lt;/p&gt;
&lt;h2 id=&quot;开始起飞&quot;&gt;开始起飞&lt;/h2&gt;
&lt;p&gt;起飞之前，先说明一下，本项目前几篇文章中已经构建了相关子项目包括：注册中心、配置中心。本文中继续可以使用。&lt;/p&gt;
&lt;h3 id=&quot;创建两个服务器&quot;&gt;创建两个服务器&lt;/h3&gt;
&lt;p&gt;需要创建两个一模一样的服务器，让客户端按照不同的机制进行分发，达到负载均衡的效果。我们约定两个子项目名称：&lt;br/&gt;&lt;strong&gt;cloud-hyh-service-1&lt;/strong&gt; 端口号：8071&lt;br/&gt;&lt;strong&gt;cloud-hyh-service-2&lt;/strong&gt; 端口号：8072&lt;br/&gt;对于服务名称设置一样：&lt;strong&gt;cloud-service&lt;/strong&gt; ，其他业务都一样，可以复制。【端口号不一样】&lt;/p&gt;
&lt;h4 id=&quot;pom.xml文件配置&quot;&gt;pom.xml文件配置&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-eureka&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span class=&quot;kw&quot;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;服务器一参数配置&quot;&gt;服务器一参数配置&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode yml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;co&quot;&gt;#服务注册中心配置&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;eureka:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;client:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;service-url:&lt;/span&gt;
      &lt;span class=&quot;fu&quot;&gt;defaultZone:&lt;/span&gt; http://localhost:8081/eureka/
  &lt;span class=&quot;fu&quot;&gt;instance:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;appname:&lt;/span&gt; cloud-service
    &lt;span class=&quot;fu&quot;&gt;lease-renewal-interval-in-seconds:&lt;/span&gt; 1

&lt;span class=&quot;fu&quot;&gt;server:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;port:&lt;/span&gt; 8071

&lt;span class=&quot;fu&quot;&gt;spring:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;application:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;name:&lt;/span&gt; cloud-service
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;服务器二参数配置&quot;&gt;服务器二参数配置&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode yml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;co&quot;&gt;#服务注册中心配置&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;eureka:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;client:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;service-url:&lt;/span&gt;
      &lt;span class=&quot;fu&quot;&gt;defaultZone:&lt;/span&gt; http://localhost:8081/eureka/
  &lt;span class=&quot;fu&quot;&gt;instance:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;appname:&lt;/span&gt; cloud-service

&lt;span class=&quot;fu&quot;&gt;server:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;port:&lt;/span&gt; 8072

&lt;span class=&quot;fu&quot;&gt;spring:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;application:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;name:&lt;/span&gt; cloud-service&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：与配置一其实基本一样，只不过将端口号配置成 8072&lt;/p&gt;
&lt;h4 id=&quot;服务器入口配置application.yml&quot;&gt;服务器入口配置Application.yml&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Description : &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Author hanyahong&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Date 2017/12/7- 17:35&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@EnableDiscoveryClient&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ServiceTwoApplication {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        SpringApplication.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;(ServiceTwoApplication.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;新建测试api类&quot;&gt;新建测试API类&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Description :测试RibbonTest API&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Author hanyahong&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Date 2017/12/7- 17:40&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RestController&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;st&quot;&gt;&quot;/ribbon&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RibbonTestApi {

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 获取博客名称API&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;相关信息&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;, method = RequestMethod.&lt;span class=&quot;fu&quot;&gt;GET&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getMyBlogNameApi&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;千万之路刚开始-www.hanyahong.com-beijing&quot;&lt;/span&gt;+&lt;span class=&quot;st&quot;&gt;&quot;该服务器端口号：8071&quot;&lt;/span&gt;;
    }
}


备注：两台服务器，除了返回的服务器端口号 &lt;span class=&quot;dv&quot;&gt;8071&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8072&lt;/span&gt;不同之外，其他都相同，就是为了看到效果。&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;创建测试客户端&quot;&gt;创建测试客户端&lt;/h3&gt;
&lt;p&gt;创建一个子项目，cloud-hyh-ribbon-client ,主要用来测试ribbon客户端负载。&lt;/p&gt;
&lt;h4 id=&quot;pom文件配置&quot;&gt;pom文件配置&lt;/h4&gt;
&lt;p&gt;在pom文件中加入以下依赖：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-eureka&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span class=&quot;kw&quot;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;kw&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;配置文件application配置&quot;&gt;配置文件application配置&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode yml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;eureka:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;client:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;service-url:&lt;/span&gt;
      &lt;span class=&quot;fu&quot;&gt;defaultZone:&lt;/span&gt; http://localhost:8081/eureka/
  &lt;span class=&quot;fu&quot;&gt;instance:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;appname:&lt;/span&gt; ribbon-client

&lt;span class=&quot;fu&quot;&gt;server:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;port:&lt;/span&gt; 8092

&lt;span class=&quot;fu&quot;&gt;spring:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;application:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;name:&lt;/span&gt; ribbon-client&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;配置子项目启动类&quot;&gt;配置子项目启动类&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Description :启动类，示范负载均衡服务器&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Author hanyahong&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Date 2017/12/7- 17:00&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@EnableDiscoveryClient&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RibbonServiceApplication {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {

        SpringApplication.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;(RibbonServiceApplication.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, args);
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * Spring提供的用于访问Rest服务的客户端&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * @return&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@LoadBalanced&lt;/span&gt;
    RestTemplate &lt;span class=&quot;fu&quot;&gt;restTemplate&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RestTemplate&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;RestTemplate&lt;/strong&gt;是Spring提供的用于访问Rest服务的客户端。RestTemplate提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率。调用RestTemplate的默认构造函数，RestTemplate对象在底层通过使用java.net包下的实现创建HTTP 请求，可以通过使用ClientHttpRequestFactory指定不同的HTTP请求方式。&lt;br/&gt;ClientHttpRequestFactory接口主要提供了两种实现方式，一种是SimpleClientHttpRequestFactory，使用J2SE提供的方式（既java.net包提供的方式）创建底层的Http请求连接，还有一种方式是使用HttpComponentsClientHttpRequestFactory方式，底层使用HttpClient访问远程的Http服务，使用HttpClient可以配置连接池和证书等信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;mailto:**@LoadBalanced*&quot;&gt;**@LoadBalanced*&lt;/a&gt;* 注解加在RestTemplate上面，这个注解会自动构造LoadBalancerClient接口的实现类并注册到Spring容器中。&lt;/p&gt;
&lt;h4 id=&quot;创建接口api&quot;&gt;创建接口API&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Description : 测试客户端负载均衡的接口API&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Author hanyahong&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Date 2017/12/7- 18:01&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RestController&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;st&quot;&gt;&quot;/test&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestRibbonApi {
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 注入RestTemplate&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    RestTemplate restTemplate;


    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;st&quot;&gt;&quot;/blog/name&quot;&lt;/span&gt; ,method = RequestMethod.&lt;span class=&quot;fu&quot;&gt;GET&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;testGetNameOfBlog&lt;/span&gt;(){
        String url=&lt;span class=&quot;st&quot;&gt;&quot;http://CLOUD-SERVICE/ribbon/name&quot;&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; restTemplate.&lt;span class=&quot;fu&quot;&gt;getForObject&lt;/span&gt;(url,String.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：这个代码中 url 设置的是 上面提到的服务器的服务名。&lt;/p&gt;
&lt;h3 id=&quot;启动项目群进行测试&quot;&gt;启动项目群进行测试&lt;/h3&gt;
&lt;p&gt;经过全面的配置，服务器全面配置完毕，包括一个注册中心、一个配置中心、两个相同配置的服务器、一台测试客户端负载均衡的测试服务器。&lt;br/&gt;启动成功以后会在注册中心看到。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-058efd484f6769a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过访问客户端地址：&lt;a href=&quot;http://localhost:8092/test/name&quot; class=&quot;uri&quot;&gt;http://localhost:8092/test/name&lt;/a&gt; 就可以访问。效果如下：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-08aecadef807486f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;刷新一次：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-1e35fb73a783a1bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此所有配置成功。测试结果也成功。&lt;/p&gt;
&lt;h2 id=&quot;本文源码&quot;&gt;本文源码&lt;/h2&gt;
&lt;p&gt;Github源码：&lt;a href=&quot;https://github.com/hanyahong/spring-cloud-microservice&quot; class=&quot;uri&quot;&gt;https://github.com/hanyahong/spring-cloud-microservice&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 09 Dec 2017 03:43:00 +0000</pubDate>
<dc:creator>千万之路刚开始</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hyhnet/p/8011029.html</dc:identifier>
</item>
</channel>
</rss>