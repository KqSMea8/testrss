<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Ijkplayer播放器源码分析之音视频输出(二)——音频篇 - HarlanC</title>
<link>http://www.cnblogs.com/harlanc/p/9693983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/harlanc/p/9693983.html</guid>
<description>&lt;p&gt;这篇文章的ijkplayer音频源码研究我们还是选择Android平台，它的音频解码是不支持硬解的，音频播放使用的API是OpenSL ES或AudioTrack。&lt;/p&gt;
&lt;h2 id=&quot;opensl-es-audiotrack&quot;&gt;OpenSL ES &amp;amp; AudioTrack&lt;/h2&gt;
&lt;p&gt;什么是OpenSL ES？下面来自官网的说明：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;OpenSL ES™ is a royalty-free, cross-platform, hardware-accelerated audio API tuned for embedded systems. It provides a standardized, high-performance, low-latency method to access audio functionality for developers of native applications on embedded mobile multimedia devices, enabling straightforward cross-platform deployment of hardware and software audio capabilities, reducing implementation effort, and promoting the market for advanced audio.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见OpenGL ES是专门为嵌入式设备设计的音频API，所以不适合在PC上使用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AudioTrack&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;AudioTrack是专门为Android应用提供的java API，显然也不适合在PC上使用。&lt;/p&gt;
&lt;p&gt;使用AudioTrack API来输出音频就需要把音频数据从java层拷贝到native层。而OpenSL ES API是Android NDK提供的native接口，它可以在native层直接获取和处理数据，因此为了提高效率，应该使用OpenSL ES API。通过如下java接口设置音频输出API：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;opensles&quot;, 0);
  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Ijkplayer使用&lt;a href=&quot;https://github.com/Bilibili/jni4android.git&quot;&gt;jni4android&lt;/a&gt;来为AudioTrack的java API自动生成JNI native代码。&lt;/p&gt;
&lt;p&gt;我们尽量选择底层的代码来进行研究，因此本篇文章梳理一遍OpenSL ES API在ijkplayer中的使用。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;h3 id=&quot;创建播放器音频输出对象&quot;&gt;创建播放器音频输出对象&lt;/h3&gt;
&lt;p&gt;调用如下函数生成音频输出对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SDL_Aout *SDL_AoutAndroid_CreateForOpenSLES()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建并初始化Audio Engine：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//创建
SLObjectItf slObject = NULL;
ret = slCreateEngine(&amp;amp;slObject, 0, NULL, 0, NULL, NULL);
CHECK_OPENSL_ERROR(ret, &quot;%s: slCreateEngine() failed&quot;, __func__);
opaque-&amp;gt;slObject = slObject;
//初始化
ret = (*slObject)-&amp;gt;Realize(slObject, SL_BOOLEAN_FALSE);
CHECK_OPENSL_ERROR(ret, &quot;%s: slObject-&amp;gt;Realize() failed&quot;, __func__);
//获取SLEngine接口对象slEngine
SLEngineItf slEngine = NULL;
ret = (*slObject)-&amp;gt;GetInterface(slObject, SL_IID_ENGINE, &amp;amp;slEngine);
CHECK_OPENSL_ERROR(ret, &quot;%s: slObject-&amp;gt;GetInterface() failed&quot;, __func__);
opaque-&amp;gt;slEngine = slEngine;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开音频输出设备：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//使用slEngine打开输出设备
SLObjectItf slOutputMixObject = NULL;
const SLInterfaceID ids1[] = {SL_IID_VOLUME};
const SLboolean req1[] = {SL_BOOLEAN_FALSE};
ret = (*slEngine)-&amp;gt;CreateOutputMix(slEngine, &amp;amp;slOutputMixObject, 1, ids1, req1);
CHECK_OPENSL_ERROR(ret, &quot;%s: slEngine-&amp;gt;CreateOutputMix() failed&quot;, __func__);
opaque-&amp;gt;slOutputMixObject = slOutputMixObject;
//初始化
ret = (*slOutputMixObject)-&amp;gt;Realize(slOutputMixObject, SL_BOOLEAN_FALSE);
CHECK_OPENSL_ERROR(ret, &quot;%s: slOutputMixObject-&amp;gt;Realize() failed&quot;, __func__);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将上述创建的OpenSL ES相关对象保存到SDL_Aout_Opaque中。&lt;/p&gt;
&lt;p&gt;设置播放器音频输出对象的回调函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aout-&amp;gt;free_l       = aout_free_l;
aout-&amp;gt;opaque_class = &amp;amp;g_opensles_class;
aout-&amp;gt;open_audio   = aout_open_audio;
aout-&amp;gt;pause_audio  = aout_pause_audio;
aout-&amp;gt;flush_audio  = aout_flush_audio;
aout-&amp;gt;close_audio  = aout_close_audio;
aout-&amp;gt;set_volume   = aout_set_volume;
aout-&amp;gt;func_get_latency_seconds = aout_get_latency_seconds;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置并创建音频播放器&quot;&gt;配置并创建音频播放器&lt;/h3&gt;
&lt;p&gt;通过如下函数进行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static int aout_open_audio(SDL_Aout *aout, const SDL_AudioSpec *desired, SDL_AudioSpec *obtained)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;21&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;配置数据源&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; SLDataLocator_AndroidSimpleBufferQueue loc_bufq = {
 SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE,
 OPENSLES_BUFFERS
 };

 SLDataFormat_PCM *format_pcm = &amp;amp;opaque-&amp;gt;format_pcm;
 format_pcm-&amp;gt;formatType       = SL_DATAFORMAT_PCM;
 format_pcm-&amp;gt;numChannels      = desired-&amp;gt;channels;
 format_pcm-&amp;gt;samplesPerSec    = desired-&amp;gt;freq * 1000; // milli Hz

 format_pcm-&amp;gt;bitsPerSample    = SL_PCMSAMPLEFORMAT_FIXED_16;
 format_pcm-&amp;gt;containerSize    = SL_PCMSAMPLEFORMAT_FIXED_16;
 switch (desired-&amp;gt;channels) {
     case 2:
         format_pcm-&amp;gt;channelMask  = SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT;
         break;
     case 1:
         format_pcm-&amp;gt;channelMask  = SL_SPEAKER_FRONT_CENTER;
     break;
     default:
     ALOGE(&quot;%s, invalid channel %d&quot;, __func__, desired-&amp;gt;channels);
     goto fail;
 }
 format_pcm-&amp;gt;endianness       = SL_BYTEORDER_LITTLEENDIAN;

 SLDataSource audio_source = {&amp;amp;loc_bufq, format_pcm};&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;配置数据管道&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; SLDataLocator_OutputMix loc_outmix = {
 SL_DATALOCATOR_OUTPUTMIX,
 opaque-&amp;gt;slOutputMixObject
 };
 SLDataSink audio_sink = {&amp;amp;loc_outmix, NULL};&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;其它参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; const SLInterfaceID ids2[] = { SL_IID_ANDROIDSIMPLEBUFFERQUEUE, SL_IID_VOLUME, SL_IID_PLAY };
 static const SLboolean req2[] = { SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE };&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;创建播放器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; ret = (*slEngine)-&amp;gt;CreateAudioPlayer(slEngine, &amp;amp;slPlayerObject, &amp;amp;audio_source,
                         &amp;amp;audio_sink, sizeof(ids2) / sizeof(*ids2),
                         ids2, req2);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;获取相关接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  //获取seek和play接口
  ret = (*slPlayerObject)-&amp;gt;GetInterface(slPlayerObject, SL_IID_PLAY, &amp;amp;opaque-&amp;gt;slPlayItf);
  CHECK_OPENSL_ERROR(ret, &quot;%s: slPlayerObject-&amp;gt;GetInterface(SL_IID_PLAY) failed&quot;, __func__);
  //音量调节接口
  ret = (*slPlayerObject)-&amp;gt;GetInterface(slPlayerObject, SL_IID_VOLUME, &amp;amp;opaque-&amp;gt;slVolumeItf);
  CHECK_OPENSL_ERROR(ret, &quot;%s: slPlayerObject-&amp;gt;GetInterface(SL_IID_VOLUME) failed&quot;, __func__);
  //获取音频输出的BufferQueue接口
  ret = (*slPlayerObject)-&amp;gt;GetInterface(slPlayerObject, SL_IID_ANDROIDSIMPLEBUFFERQUEUE, &amp;amp;opaque-&amp;gt;slBufferQueueItf);
  CHECK_OPENSL_ERROR(ret, &quot;%s: slPlayerObject-&amp;gt;GetInterface(SL_IID_ANDROIDSIMPLEBUFFERQUEUE) failed&quot;, __func__);      &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置回调函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;回调函数并不传递音频数据，它只是告诉程序：我已经准备好接受处理（播放）数据了。这时候就可以调用Enqueue向BufferQueue中插入音频数据了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    ret = (*opaque-&amp;gt;slBufferQueueItf)-&amp;gt;RegisterCallback(opaque-&amp;gt;slBufferQueueItf, aout_opensles_callback, (void*)aout);
    CHECK_OPENSL_ERROR(ret, &quot;%s: slBufferQueueItf-&amp;gt;RegisterCallback() failed&quot;, __func__);          
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此回调函数每执行一次Dequeue会被执行一次。&lt;/p&gt;
&lt;h3 id=&quot;音频数据的处理&quot;&gt;音频数据的处理&lt;/h3&gt;
&lt;p&gt;音频数据的处理为典型的生产者消费者模型，解码线程解码出音频数据插入到队列中，音频驱动程序取出数据将声音播放出来。&lt;/p&gt;
&lt;p&gt;audio_thread函数为音频解码线程主函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static int audio_thread(void *arg){

 do {
    ffp_audio_statistic_l(ffp);
    if ((got_frame = decoder_decode_frame(ffp, &amp;amp;is-&amp;gt;auddec, frame, NULL)) &amp;lt; 0)//从PacketQueue中取出pakcet并进行解码，生成一帧数据
    ...
    if (!(af = frame_queue_peek_writable(&amp;amp;is-&amp;gt;sampq)))
        goto the_end;

    af-&amp;gt;pts = (frame-&amp;gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&amp;gt;pts * av_q2d(tb);
    af-&amp;gt;pos = frame-&amp;gt;pkt_pos;
    af-&amp;gt;serial = is-&amp;gt;auddec.pkt_serial;
    af-&amp;gt;duration = av_q2d((AVRational){frame-&amp;gt;nb_samples, frame-&amp;gt;sample_rate});

    av_frame_move_ref(af-&amp;gt;frame, frame);
    frame_queue_push(&amp;amp;is-&amp;gt;sampq);//将帧数据插入帧队列 FrameQueue

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;aout_thread_n 为音频输出线程主函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static int aout_thread_n(SDL_Aout *aout){
...
    SDL_LockMutex(opaque-&amp;gt;wakeup_mutex);
    //如果没有退出播放&amp;amp;&amp;amp;（当前播放器状态为暂停||插入音频BufferQueue中的数据条数大于OPENSLES_BUFFERS）
    if (!opaque-&amp;gt;abort_request &amp;amp;&amp;amp; (opaque-&amp;gt;pause_on || slState.count &amp;gt;= OPENSLES_BUFFERS)) {
    //不知道为什么if下面又加了一层while??
        while (!opaque-&amp;gt;abort_request &amp;amp;&amp;amp; (opaque-&amp;gt;pause_on || slState.count &amp;gt;= OPENSLES_BUFFERS)) {
            //如果此时为非暂停状态，将播放器状态置为PLAYING
            if (!opaque-&amp;gt;pause_on) {
                (*slPlayItf)-&amp;gt;SetPlayState(slPlayItf, SL_PLAYSTATE_PLAYING);
            }
            //如果暂停或者队列中数据过多，这里都会等待一个条件变量，并将过期时间置为1秒，应该是防止BufferQueue中的数据不再快速增加
            SDL_CondWaitTimeout(opaque-&amp;gt;wakeup_cond, opaque-&amp;gt;wakeup_mutex, 1000);
            SLresult slRet = (*slBufferQueueItf)-&amp;gt;GetState(slBufferQueueItf, &amp;amp;slState);
            if (slRet != SL_RESULT_SUCCESS) {
                ALOGE(&quot;%s: slBufferQueueItf-&amp;gt;GetState() failed\n&quot;, __func__);
                SDL_UnlockMutex(opaque-&amp;gt;wakeup_mutex);
            }
            //暂停播放
            if (opaque-&amp;gt;pause_on)
                (*slPlayItf)-&amp;gt;SetPlayState(slPlayItf, SL_PLAYSTATE_PAUSED);
        }
        //恢复播放
        if (!opaque-&amp;gt;abort_request &amp;amp;&amp;amp; !opaque-&amp;gt;pause_on) {
            (*slPlayItf)-&amp;gt;SetPlayState(slPlayItf, SL_PLAYSTATE_PLAYING);
        }
    }
    ...
    next_buffer = opaque-&amp;gt;buffer + next_buffer_index * bytes_per_buffer;
    next_buffer_index = (next_buffer_index + 1) % OPENSLES_BUFFERS;
    //调用回调函数生成插入到BufferQueue中的数据
    audio_cblk(userdata, next_buffer, bytes_per_buffer);
    //如果需要刷新BufferQueue数据，则清除数据，何时需要清理数据？？解释在下面
    if (opaque-&amp;gt;need_flush) {
        (*slBufferQueueItf)-&amp;gt;Clear(slBufferQueueItf);
        opaque-&amp;gt;need_flush = false;
    }
    //不知道为什么会判断两次？？

    if (opaque-&amp;gt;need_flush) {
        ALOGE(&quot;flush&quot;);
        opaque-&amp;gt;need_flush = 0;
        (*slBufferQueueItf)-&amp;gt;Clear(slBufferQueueItf);
    } else {
    //最终将数据插入到BufferQueue中。
    slRet = (*slBufferQueueItf)-&amp;gt;Enqueue(slBufferQueueItf, next_buffer, bytes_per_buffer);
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是为条件变量opaque-&amp;gt;wakeup_cond 发送signal的几个函数，目的是让输出线程快速响应&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;static void aout_opensles_callback(SLAndroidSimpleBufferQueueItf caller, void *pContext)&lt;/li&gt;
&lt;li&gt;static void aout_close_audio(SDL_Aout *aout)&lt;/li&gt;
&lt;li&gt;static void aout_pause_audio(SDL_Aout *aout, int pause_on)&lt;/li&gt;
&lt;li&gt;static void aout_flush_audio(SDL_Aout *aout)&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;static void aout_set_volume(SDL_Aout *aout, float left_volume, float right_volume)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;第一个为音频播放器的BufferQueue设置的回调函数，每从队列中取出一条数据执行一次，这个可以理解，队列中去除一条数据，立刻唤醒线程Enqueue数据。&lt;/li&gt;
&lt;li&gt;第二个为关闭音频播放器的时候调用的函数，立马退出线程。&lt;/li&gt;
&lt;li&gt;第三个为暂停/播放音频播放器函数，马上设置播放器状态。&lt;/li&gt;
&lt;li&gt;第四个为清空BufferQueue时调用的函数，立刻唤醒线程Enqueue数据。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第五个为设置音量函数，马上设置音量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过调用如下函数生成插入到BufferQueue中的数据 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static void sdl_audio_callback(void *opaque, Uint8 *stream, int len){
       ...
        if (is-&amp;gt;audio_buf_index &amp;gt;= is-&amp;gt;audio_buf_size) {
        //如果buffer中没有数据了，生成新数据。
               audio_size = audio_decode_frame(ffp);
       ...     
       
        if (!is-&amp;gt;muted &amp;amp;&amp;amp; is-&amp;gt;audio_buf &amp;amp;&amp;amp; is-&amp;gt;audio_volume == SDL_MIX_MAXVOLUME)
            //直接拷贝到stream
            memcpy(stream, (uint8_t *)is-&amp;gt;audio_buf + is-&amp;gt;audio_buf_index, len1);
        else {
            memset(stream, 0, len1);
            if (!is-&amp;gt;muted &amp;amp;&amp;amp; is-&amp;gt;audio_buf)
            //进行音量调整和混音
                SDL_MixAudio(stream, (uint8_t *)is-&amp;gt;audio_buf + is-&amp;gt;audio_buf_index, len1, is-&amp;gt;audio_volume);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成新数据的函数不是对音频数据进行解码，而是对帧数据进行了二次处理，对音频进行了必要的重采样或者变速变调。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static int audio_decode_frame(FFPlayer *ffp){
    ...
    //重采样
    len2 = swr_convert(is-&amp;gt;swr_ctx, out, out_count, in, af-&amp;gt;frame-&amp;gt;nb_samples);
    ...
    //音频变速变调
    int ret_len = ijk_soundtouch_translate(is-&amp;gt;handle, is-&amp;gt;audio_new_buf, (float)(ffp-&amp;gt;pf_playback_rate), (float)(1.0f/ffp-&amp;gt;pf_playback_rate),
                resampled_data_size / 2, bytes_per_sample, is-&amp;gt;audio_tgt.channels, af-&amp;gt;frame-&amp;gt;sample_rate);
    ...
    //最后将数据保存到audio_buf中
     is-&amp;gt;audio_buf = (uint8_t*)is-&amp;gt;audio_new_buf;
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后一个比较让人困惑的问题是何时才会清理BufferQueue，看一下清理的命令是在何时发出的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static void sdl_audio_callback(void *opaque, Uint8 *stream, int len)
{
    ...
         if (is-&amp;gt;auddec.pkt_serial != is-&amp;gt;audioq.serial) {
        is-&amp;gt;audio_buf_index = is-&amp;gt;audio_buf_size;
        memset(stream, 0, len);
        // stream += len;
        // len = 0;
        SDL_AoutFlushAudio(ffp-&amp;gt;aout);
        break;
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它是在音频输出线程中获取即将插入到BufferQueue的音频数据，调用回调函数时发出的，发出的条件如上所示，其中pkt_serial 为从PacketQueue队列中取出的需要解码的packet的serial，serial为当前PacketQueue队列的serial。也就是说，如果两者不等，就需要清理BufferQueue。这里的serial是要保证前后数据包的连续性，例如发生了Seek，数据不连续，就需要清理旧数据。&lt;/p&gt;
&lt;p&gt;注：在播放器中的VideoState成员中，audioq和解码成员auddec中的queue是同一个队列。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;decoder_init(&amp;amp;is-&amp;gt;auddec, avctx, &amp;amp;is-&amp;gt;audioq, is-&amp;gt;continue_read_thread);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;结束语&quot;&gt;结束语&lt;/h3&gt;
&lt;p&gt;笔者从头到尾把和音频输出相关的自认为重要的源码做了一些解释和记录，有些细节没有去深入研究。以后有时间慢慢学习。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_6240123301016pvk.html&quot;&gt;音频的相关知识&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/feeb107b6657&quot;&gt;AAC 到 PCM 音频解码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wkw1125/article/details/63807128&quot;&gt;SoundTouch实现音频变速变调&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/2b8d2de9a47b&quot;&gt;Android音频开发之OpenSL ES&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/c8847fdfe776&quot;&gt;浅聊OpenSL ES音频开发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43295650&quot;&gt;ffplay packet queue分析&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 23 Sep 2018 23:15:00 +0000</pubDate>
<dc:creator>HarlanC</dc:creator>
<og:description>Ijkplayer播放器源码分析之音视频输出(二)——音频篇 这篇文章的ijkplayer音频源码研究我们还是选择Android平台，它的音频解码是不支持硬解的，音频播放使用的API是OpenSL E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/harlanc/p/9693983.html</dc:identifier>
</item>
<item>
<title>ZooKeeper 分布式锁 - -Finley-</title>
<link>http://www.cnblogs.com/Finley/p/9694637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Finley/p/9694637.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/Finley/p/9164204.html&quot;&gt;Redis分布式锁&lt;/a&gt;一文中， 作者介绍了如何使用Redis开发分布式锁。&lt;/p&gt;
&lt;p&gt;Redis分布式锁具有轻量高吞吐量的特点，但是一致性保证较弱。我们可以使用Zookeeper开发分布式锁，来满足对高一致性的要求。&lt;/p&gt;

&lt;p&gt;Zookeeper 节点具有一些性质可以帮助我们开发分布式锁:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;临时节点: 客户端可以创建临时节点，当客户端会话终止或超时后Zookeeper会自动删除临时节点。该特性可以用来避免死锁。&lt;/li&gt;
&lt;li&gt;触发器: 当节点的状态发生改变时，Zookeeper会通知监听相应事件的客户端。该特性可以用来实现阻塞等待加锁。&lt;/li&gt;
&lt;li&gt;有序节点: 客户端可以在某个节点下创建子节点，Zookeeper会根据子节点数量自动生成整数序号，类似于数据库的自增主键。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一种比较容易想到的分布式锁实现方案是:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;检查锁节点是否已经创建，若未创建则尝试创建一个临时节点&lt;/li&gt;
&lt;li&gt;若临时节点创建成功说明已成功加锁。若持有锁的客户端崩溃或网络异常无法维持Session，锁节点会被删除不会产生死锁。&lt;/li&gt;
&lt;li&gt;若临时节点创建失败说明加锁失败，等待加锁。watch锁节点exists事件，当接收到节点被删除的通知后再次尝试加锁。&lt;/li&gt;
&lt;li&gt;因为Zookeeper中的Watch是一次性的，若再次尝试加锁失败，需要重新设置Watch。&lt;/li&gt;
&lt;li&gt;操作完成后，删除锁节点释放锁。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;该方案存在的问题是，当锁被释放时Zookeeper需要通知大量订阅了该事件的客户端，这种现象称为&quot;惊群现象&quot;或&quot;羊群效应&quot;。&lt;/p&gt;
&lt;p&gt;惊群现象对Zookeeper正常提供服务非常不利，因此实践中通常采取另一种方案:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个永久节点作为锁节点，试图加锁的客户端在锁节点下创建临时顺序节点。Zookeeper会保证子节点的有序性。&lt;/li&gt;
&lt;li&gt;若锁节点下id最小的节点是为当前客户端创建的节点，说明当前客户端成功加锁。&lt;/li&gt;
&lt;li&gt;否则加锁失败，订阅上一个顺序节点。当上一个节点被删除时，当前节点为最小，说明加锁成功。&lt;/li&gt;
&lt;li&gt;操作完成后，删除锁节点释放锁。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;该方案每次锁释放时只需要通知一个客户端，避免惊群现象发生。&lt;/p&gt;
&lt;p&gt;该方案的特征是优先排队等待的客户端会先获得锁，这种锁称为公平锁。而锁释放后，所有客户端重新竞争锁的方案称为非公平锁。&lt;/p&gt;

&lt;p&gt;本节作者将使用Zookeeper官方Java API实现一个简单的公平锁。&lt;/p&gt;
&lt;p&gt;使用Maven进行依赖管理，项目依赖 Zookeeper 官方 java sdk 和 apache commons-lang3工具包:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.zookeeper&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;zookeeper&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.4.5&amp;lt;/version&amp;gt;
    &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击查看&lt;a href=&quot;https://gitee.com/hdt3213/codes/j6197ktapelwvqg3subz544&quot;&gt;完整代码&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package zk;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.apache.commons.lang3.StringUtils;
import org.apache.zookeeper.*;

/**
 * @author finley
 */
public class ZKLock {

    private ZooKeeper zk;

    private String basePath;

    private String lockPath;

    private static final byte[] LOCK_DATA = &quot;&quot;.getBytes();

    // zk 为客户端连接实例, basePath 为锁节点路径，我们将在 basePath 下创建顺序子节点
    public ZKLock(ZooKeeper zk, String basePath) {
        // 按照 zk 的路径规则，以'/'开始，不得以'/'结束
        if (basePath.endsWith(&quot;/&quot;) || !basePath.startsWith(&quot;/&quot;)) {
            throw new IllegalArgumentException(&quot;base path must start with '/', and must not end with '/'&quot;);
        }
        this.zk = zk;
        this.basePath = basePath;
    }

    // 检测 basePath 节点是否存在, 若不存在则创建
    private void ensureBasePath() throws KeeperException, InterruptedException {
        if (zk.exists(basePath, false) == null) {
            // basePath 不存在，进行创建
            List&amp;lt;String&amp;gt; pathParts = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(basePath.split(&quot;/&quot;))); // 将路径处理为节点列表
            pathParts.remove(0); //因为 basePath 以'/'开始, pathParts[0] 一定是空串，将其移除

            // 自底向上，寻找路径中最后一个存在的节点
            int last = 0;
            for (int i = pathParts.size() - 1; i &amp;gt;= 0; i--) {
                String path = &quot;/&quot; + StringUtils.join(pathParts.subList(0, i), '/');
                if (zk.exists(path, false) != null) {
                    last = i;
                    break;
                }
            }

            // 从最后一个存在的节点开始，依次创建节点
            for (int i = last; i &amp;lt; pathParts.size(); i++) {
                String path = &quot;/&quot; + StringUtils.join(pathParts.subList(0, i + 1), '/');
                try {
                    zk.create(path, LOCK_DATA, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
                } catch (KeeperException.NodeExistsException ignore) {} // may created by other thread
            }

        }
    }

    // 阻塞直至加锁成功
    public void lock() throws KeeperException, InterruptedException {
        ensureBasePath();

        // 在 basePath 下创建临时顺序子节点
        String lockPath = zk.create(basePath + &quot;/lock_&quot;, LOCK_DATA, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);

        System.out.println(Thread.currentThread().getName() + &quot; create: &quot; + lockPath);

        // 循环检查加锁是否成功
        while(true) {
            // 取出 basePath 中所有节点并找到最小子节点
            // 因为顺序子节点总是递增的，新创建的节点一定比当前 lockPath 更大，所以 create 和 getChildren 两个操作不保持原子性不会出现异常
            List&amp;lt;String&amp;gt; children = zk.getChildren(basePath,false);
            Collections.sort(children);
            String minNode = children.get(0);

            // 当前线程创建了最小子节点，加锁成功
            if (StringUtils.isNotBlank(lockPath) &amp;amp;&amp;amp; StringUtils.isNotBlank(minNode) &amp;amp;&amp;amp; StringUtils.equals(lockPath, basePath + &quot;/&quot; + minNode) {
                this.lockPath = lockPath; // 加锁成功，写入锁路径
                return;
            }

            // 加锁失败，设置 watch
            String watchNode = null;
            String node = lockPath.substring(lockPath.lastIndexOf(&quot;/&quot;) + 1);
            for (int i = children.size() - 1; i &amp;gt;= 0; i--) {
                String child = children.get(i);
                if (child.compareTo(node) &amp;lt; 0) {
                    watchNode = child;
                    break;
                }
            }

            // 找到需要监视的节点，设置 watch
            if (watchNode != null) {
                System.out.println(Thread.currentThread().getName() + &quot; watch: &quot; + watchNode);

                String watchPath = basePath + &quot;/&quot; + watchNode;
                
                // 监视 getData 而非 exists 的原因是: 在获取子节点和设置 watch 这段时间内，被监视的节点可能已被删除(锁释放/持有者崩溃)
                // exists 监视会成功设置，但永远不会触发NodeDeleted事件(顺序子节点序号自增，不会复用使用过的序号)。本方法会无限制等待下去
                // 若被监视节点已删除，getData 会抛出异常，避免线程浪费时间等待

                // 该调用中的 watch 回调当事件发生时会在另一个线程中执行
                try {
                    zk.getData(watchPath, event -&amp;gt; {
                        if(event.getType() == Watcher.Event.EventType.NodeDeleted) {
                            // 主线程会调用 this.wait()
                            // fixme: 这里有一个bug，若事件类型不是 NodeDeleted 应进行处理。分布式锁不会产生这种情况，可能是其它客户端操作所致
                            synchronized (this) {
                                notifyAll();
                            }
                        }
                    }, null);
                } catch(KeeperException.NoNodeException e) {
                    // 因为上一个节点被删除导致 getData watch 失败，进入下一个次循环，重新检查自己是否已持有锁
                    continue;
                }
        

                synchronized (this) {
                    // 等待被 watch 唤醒，唤醒后进入下一次循环，重新检查确认自己已持有锁
                    wait();
                    System.out.println(Thread.currentThread().getName() + &quot; notified&quot;);
                }
            }
        }    

    }

    // 释放锁
    public void unlock() throws KeeperException, InterruptedException {
        // 加锁成功时会将锁路径写入 lockPath
        if (StringUtils.isNotBlank(lockPath)) {
            zk.delete(lockPath, -1); // 删除锁记录释放锁
        } else {
            throw new IllegalStateException(&quot;don't has lock&quot;); // 未设置锁记录说明本线程未持有锁
        }
    }

    public static void main(String[] args) {
        int concurrent = 10;
        ExecutorService service = Executors.newFixedThreadPool(concurrent);
        for (int i = 0; i &amp;lt; concurrent; i++) {
            service.execute(() -&amp;gt; {
                // 为保证各线程独立的持有锁，每个线程应持有独立的 zookeeper 会话
                ZooKeeper zk;
                try {

                    zk = new ZooKeeper(&quot;localhost:2181&quot;, 6000, watchedEvent -&amp;gt; {
                        if (Watcher.Event.KeeperState.SyncConnected == watchedEvent.getState())
                            System.out.println(&quot;connection is established...&quot;);
                    });

                    ZKLock lock = new ZKLock(zk, &quot;/test/node1&quot;);

                    lock.lock();
                    System.out.println(Thread.currentThread().getName() + &quot;  acquire success&quot;);

                    Thread.sleep(1000);
                    System.out.println(&quot;do sth, thread: &quot; + Thread.currentThread().getName());

                    lock.unlock();
                    System.out.println(Thread.currentThread().getName() + &quot;  release success&quot;);

                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
        }
        service.shutdown();
    }

}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Cruator 是一个 Zookeeper 工具集, 提供了包括分布式锁在内的常用应用的封装，本文以 Cruator 的分布式锁实现源码为例进行分析。&lt;/p&gt;
&lt;p&gt;使用maven安装依赖:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;curator-recipes&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.0.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写加锁代码:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ZkLock {

    public static void main(String[] args) throws Exception {
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
        CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;localhost:2181&quot;, retryPolicy);
        client.start();

        // 锁节点为 /curator/mutex
        InterProcessMutex mutex = new InterProcessMutex(client, &quot;/curator/mutex&quot;);
        try {
            // 尝试加锁
            mutex.acquire();
            // 完成业务
            System.out.println(&quot;foo bar&quot;);
        } finally {
            // 释放锁
            mutex.release();
            client.close();
        }

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来分析&lt;code&gt;InterProcessMutex.acquire()&lt;/code&gt;的实现:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Acquire the mutex - blocking until it's available. Note: the same thread
 * can call acquire re-entrantly. Each call to acquire must be balanced by a call
 * to {@link #release()}
 *
 * @throws Exception ZK errors, connection interruptions
*/
@Override
public void acquire() throws Exception
{
    if ( !internalLock(-1, null) )
    {
        throw new IOException(&quot;Lost connection while trying to acquire lock: &quot; + basePath);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来看&lt;code&gt;internalLock&lt;/code&gt;方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private boolean internalLock(long time, TimeUnit unit) throws Exception
{
    Thread currentThread = Thread.currentThread();

    // threadData 是一个 ConcurrentMap, 记录各线程锁的状态
    LockData lockData = threadData.get(currentThread);
    if ( lockData != null ) // lockData 不为空， 说明线程已经持有锁
    {
        // 重入锁，重入计数器增加
        lockData.lockCount.incrementAndGet();
        return true;
    }

    // internals.attemptLock 完成实际的访问Zookeeper获取锁的操作
    String lockPath = internals.attemptLock(time, unit, getLockNodeBytes());
    if ( lockPath != null )
    {
        LockData newLockData = new LockData(currentThread, lockPath);
        threadData.put(currentThread, newLockData);
        return true;
    }

    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析实际执行加锁操作的&lt;code&gt;internals.attemptLock&lt;/code&gt;方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String attemptLock(long time, TimeUnit unit, byte[] lockNodeBytes) throws Exception
{
    final long      startMillis = System.currentTimeMillis();
    final Long      millisToWait = (unit != null) ? unit.toMillis(time) : null;
    final byte[]    localLockNodeBytes = (revocable.get() != null) ? new byte[0] : lockNodeBytes;
    int             retryCount = 0;

    String          ourPath = null;
    boolean         hasTheLock = false;
    boolean         isDone = false;

    // 自旋加锁
    while ( !isDone )
    {
        isDone = true;

        try
        {
            // 在锁节点下创建临时顺序节点
            ourPath = driver.createsTheLock(client, path, localLockNodeBytes);
            // 等待自己的节点成为最小的节点，即加锁成功
            hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);
        }
        catch ( KeeperException.NoNodeException e )
        {
            // 当 session 超时会抛出异常，根据重试策略直接进行重试 
            if ( client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper()) )
            {
                isDone = false;
            }
            else
            {
                throw e;
            }
        }
    }

    if ( hasTheLock )
    {
        return ourPath;
    }

    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先阅读&lt;code&gt;StandardLockInternalsDriver.createsTheLock()&lt;/code&gt; 源码:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public String createsTheLock(CuratorFramework client, String path, byte[] lockNodeBytes) throws Exception
{
    String ourPath;
    if ( lockNodeBytes != null )
    {
        ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, lockNodeBytes);
    }
    else
    {
        ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);
    }
    return ourPath;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建临时顺序节点, 不再赘述。&lt;/p&gt;
&lt;p&gt;接下来查看&lt;code&gt;internalLockLoop&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;while ( (client.getState() == CuratorFrameworkState.STARTED) &amp;amp;&amp;amp; !haveTheLock )
{
    // 获得所有子节点，按序号升序排列
    List&amp;lt;String&amp;gt;        children = getSortedChildren();

    // 判断自己是否为序号最小的节点
    String              sequenceNodeName = ourPath.substring(basePath.length() + 1); // +1 to include the slash
    PredicateResults    predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases);
    if ( predicateResults.getsTheLock() )
    {
        haveTheLock = true;
    }
    else
    {
        // 获得前一个节点的路径
        String  previousSequencePath = basePath + &quot;/&quot; + predicateResults.getPathToWatch();

        // 监听前一个节点并进行wait(), 当锁被释放时会通过notifyall() 唤醒
        synchronized(this)
        {
            try 
            {
                // 使用getData()而非exists()监听器的原因是:
                // 若此时前一个节点已被删除exists()仍会成功设置，但不可能被触发(顺序节点不会再次使用前一个节点的序号)。这会使方法浪费时间等待，也属于Zookeeper资源浪费
                // 若前一个节点被删除getData() 会抛出异常
                client.getData().usingWatcher(watcher).forPath(previousSequencePath);

                // 若设置了等待时间
                if ( millisToWait != null )
                {
                    millisToWait -= (System.currentTimeMillis() - startMillis);
                    startMillis = System.currentTimeMillis();
                    if ( millisToWait &amp;lt;= 0 )
                    {
                        doDelete = true;    // timed out - delete our node
                        break;
                    }
                    // 等待指定的时间
                    wait(millisToWait);
                }
                else
                {
                    // 永远等待
                    wait();
                }
            }
            catch ( KeeperException.NoNodeException e ) 
            {
                // getData() 抛出此异常说明前一个节点已被删除, 重新尝试获取锁。
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 23 Sep 2018 21:43:00 +0000</pubDate>
<dc:creator>-Finley-</dc:creator>
<og:description>Zookeeper 分布式锁原理与实现、Curator Zookeeper 分布式锁源码分析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Finley/p/9694637.html</dc:identifier>
</item>
<item>
<title>Android安全防护防护———加密算法 - 家磷</title>
<link>http://www.cnblogs.com/huangjialin/p/9694488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjialin/p/9694488.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;摘要&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这篇文章本来早就应该写了，但是由于项目一直开发新的需求，就拖后了。现在有时间了，必须得写了。现在Android应用程序对安全防范这方面要求越来越高了。特别是金融行业，如果金融app没有没有做好相应安全处理，那些很容易被一些Hacker（黑客）所攻击。并不是说做了这些安全防范，这个应用就百分之百的安全的。只是说能够尽可能加大破解难度。也许有些开发者或者企业觉得。我们公司的app，数据量这些少，会有那个黑客吃饱了没事做来破解啊。又不是支付宝，或者其他那些用户量很多的应用。如果是这样想的话，那只能说目光短浅了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Android应用常用的加密算法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果说按加密的内容是否可以还原，可以分为可逆加密和非可逆加密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非可逆加密&lt;/strong&gt;：也就是说加密后的数据是不能还原成原来的数据。比如MD5加密  加密一个密码：123456     加密后成: afabsbfbabf437hfbbff73(结果并不一定是这个，只是举例)。也就是说加密后的结果afabsbfbabf437hfbbff73是不能够在解密出123456这个值的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可逆加密&lt;/strong&gt;：可逆加密有一个公钥和一个私钥，通过公钥进行数据的加密，通过私钥进行解密。代表有：RSA，AES。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对称加密和非对称加密&lt;/strong&gt;：可逆加密根据其使用加解密是否使用同一个密钥又分为对称加密（加解密使用同一个密钥）和非对称加密（加解密的密钥分开）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;MD5&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;MD5的特点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1、压缩性：任意长度的数据，算出来的MD5值的长度都是固定。&lt;/p&gt;
&lt;p&gt;2、容易计算性：从原始数据计算出MD5值是很容易的。&lt;/p&gt;
&lt;p&gt;3、抗修改性：愿数据只要有一点点的改动，得到的MD5差别都是很大的。&lt;/p&gt;
&lt;p&gt;4、强抗碰撞性：从原数据计算出来的MD5，想要找到一个具有相同的MD5,非常难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MD5的应用场景&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1、一致性验证（比如下载某个文件，不知道文件是否下载完成，可以MD5进行校验。加密文件比较耗时，需要放到子线程中）&lt;/p&gt;
&lt;p&gt;2、密码的存储（如登陆注册这些，账号密码会保存到sp中，直接就保存到账号密码的MD5值就好了。这样也可以避免服务器权限者知道这个密码）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MD5的简单使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先写一个MD5的工具类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.huangjialin.md5test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.UnsupportedEncodingException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.security.MessageDigest;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.security.NoSuchAlgorithmException;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * Created by huangjialin on 2018/9/4.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Utils {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String md5(String content) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] hash = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             hash = MessageDigest.getInstance(&quot;MD5&quot;).digest(content.getBytes(&quot;UTF-8&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchAlgorithmException e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnsupportedEncodingException e) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         StringBuilder stringBuilder = &lt;span&gt;new&lt;/span&gt; StringBuilder(hash.length * 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; b: hash) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ((b &amp;amp; 0xFF) &amp;lt; 0x10&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 stringBuilder.append(&quot;0&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             stringBuilder.append(Integer.toHexString(b &amp;amp; 0xFF&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; stringBuilder.toString();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单的解释一下上面的，首先是通过MessageDigest.getInstance(“MD5”)来获取到MessageDigest这个类，这个类是java自带的一个加密类，然后通过调用digest()方法来的获取到加密后的字节数组。该方法传入的参数是byte[] input 所以还需要将字符串转化为byte[]。得到加密后的字节数组以后，将他们转换成16禁止的字符串，然后拼接起来就可以了。&lt;/p&gt;
&lt;p&gt;然后直接调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;         * MD5加密
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         button.setOnClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; View.OnClickListener() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;  
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;                 String md5_123456abc = Utils.md5(&quot;123456abc&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;                 String md5_huangjialin = Utils.md5(&quot;huangjialin&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;                 Log.i(&quot;huangjialin&quot;,&quot;    md5_123456abc算出的MD5值是：    &quot; +&lt;span&gt; md5_123456abc);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;                 Log.i(&quot;huangjialin&quot;,&quot;    md5_huangjialin算出的MD5值是：   &quot; +&lt;span&gt; md5_huangjialin);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得出的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 09-20 15:33:12.208 7352-7352/com.example.huangjialin.md5test I/&lt;span&gt;huangjialin:     md5_123456abc算出的MD5值是：    df10ef8509dc176d733d59549e7dbfaf
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; 09-20 15:33:12.208 7352-7352/com.example.huangjialin.md5test I/huangjialin:     md5_huangjialin算出的MD5值是：   08e768954478c8669619d7d087db0070
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里说一句题外话：Log输出日志有很多种如Log.i();Log.d()等等，但是现在有些手机厂商直接就把等级较低的日志给屏蔽掉，所以有些日志输出在有些手机可以看到，有些手机没有看到。解决办法就是换输出等级较高的就OK了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;RSA&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RSA是现在比较流行的一种非对称加密的，它需要一对密钥（公钥和私钥）公钥进行加密，私钥进行解密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RSA的加密原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、随机选择两个大的质数P和Q，P不等于Q，计算出结果：N = P*Q；&lt;/p&gt;
&lt;p&gt;2、选择一个大于1，小于N的自然数E，E必须和（P-1）*（Q-1）互素。&lt;/p&gt;
&lt;p&gt;3、用公式计算出D：D*E = mod（P-1）*（Q-1）&lt;/p&gt;
&lt;p&gt;4、销毁P和Q&lt;/p&gt;
&lt;p&gt;最终得到的N，E就是公钥，D就是私钥了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RSA加解密步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、甲方生成密钥对（公钥和私钥，公钥用来加密数据，私钥自己保留，用来解密数据）&lt;/p&gt;
&lt;p&gt;2、甲方使用私钥加密数据，然后用私钥对加密后的数据签名，并把这些放送给乙方，乙方使用公钥，签名来验证带解密数据是否有效，如果有效就使用公钥对数据进行解密&lt;/p&gt;
&lt;p&gt;3、乙方使用公钥加密数据，向甲方发送经过加密后的数据，甲方或者加密数据后，就可以通过私钥进行解密了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RSA使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目中一些敏感的数据，比如身份证号，银行卡，等相关信息可通过加密后在传给服务器，服务器使用私钥进行解密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RSA密钥对生成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RSA的密钥对生成方式有两种&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;      初始化KeyPairGenerator类，并获取到公钥和私钥
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] publicKeyByte;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] prvateKtyByte;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getKey() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(“RSA”);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;KeyPairGenerator类是java专门提供生成密钥对的一个类。&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             keyPairGenerator.initialize(1024); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置密钥对的大小&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             KeyPair keyPair =&lt;span&gt; keyPairGenerator.generateKeyPair();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             PrivateKey privateKey = keyPair.getPrivate();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取私钥&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             PublicKey publicKey = keyPair.getPublic();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取公钥&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             prvateKtyByte = privateKey.getEncoded();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私钥对应的字节数组&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             publicKeyByte = publicKey.getEncoded(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;公钥对应的字节数组&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchAlgorithmException e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然上面这种生成密钥对的方式，基本很少会在项目中使用使用，用得比较多的还是第二中方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二种是通过OpenSSl工具生成密钥对&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种生成密钥对的方式需要安装OpenSSl。这里就不说具体怎么安装了。这里简单的说一下生成密钥对所需要的一些命令&lt;/p&gt;
&lt;p&gt; 使用命令生成私钥：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; genrsa -out rsa_private_key.pem 1024
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这条命令是让openssl随机生成一份私钥，长度为1024&lt;/p&gt;
&lt;p&gt;使用命令生成公钥：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; rsa -in rsa_private_key.pem -out rsa_public_key.pem -pubout
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令成功以后，就会在openSSL下的bin目录下生成公钥和私钥，然后就可以进行加密和解密了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;加密&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 加密
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     @RequiresApi(api =&lt;span&gt; Build.VERSION_CODES.O)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] encryption(String content) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] result = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             Cipher cipher = Cipher.getInstance(&quot;RSA&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             X509EncodedKeySpec x509EncodedKeySpec = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; X509EncodedKeySpec(publicKeyByte);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             PublicKey publicKey =&lt;span&gt; keyFactory.generatePublic(x509EncodedKeySpec);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             result =&lt;span&gt; cipher.doFinal(content.getBytes());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             Log.i(&quot;huangjialin&quot;, &quot;----&amp;gt;  &quot; +&lt;span&gt; Base64.getEncoder().encodeToString(result));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchAlgorithmException e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchPaddingException e) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidKeySpecException e) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidKeyException e) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BadPaddingException e) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalBlockSizeException e) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;解密&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 解密
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     @RequiresApi(api =&lt;span&gt; Build.VERSION_CODES.O)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; decryption() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         Cipher cipher = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             cipher = Cipher.getInstance(&quot;RSA&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;私钥需要通过PKCS8EncodedKeySpec来读取&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             PKCS8EncodedKeySpec keySpec = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PKCS8EncodedKeySpec(prvateKtyByte);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成私钥&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             PrivateKey privateKey =&lt;span&gt; keyFactory.generatePrivate(keySpec);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            cipher.init(Cipher.DECRYPT_MODE, privateKey);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String content = &quot;123456&quot;;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] input = encryption(&quot;123456&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] result =&lt;span&gt; cipher.doFinal(input);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             Log.i(&quot;huangjialin&quot;, &quot;--解密--&amp;gt;  &quot; + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(result));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Assert.assertTrue(content.equals(new String(result)));&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchAlgorithmException e) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchPaddingException e) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BadPaddingException e) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalBlockSizeException e) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidKeyException e) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidKeySpecException e) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然上面的代码是我写测试用的，真正项目中，还得封装好，把它弄成工具类，进行调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AES&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AES是一个对称加密，也就是说使用AES进行加密和解密，他们使用的密钥都是一样的。AES加密算法是密码学中的高级加密标准，又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析并使用。同时AES他的算法加密强度大，执行效率很高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AES使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、由于AES是对称加密，加解密都是使用同一个密钥，所以说在项目中一些敏感的数据需要保存到本地。可以先同AES的密钥进行加密，需要用的使用，将数据取出来再进行解密。&lt;/p&gt;
&lt;p&gt;2、可以进行对一些敏感数据进行加密，然后在传递给服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AES使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Android7.0之前可以这样获取到密钥&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; SecretKey generateKey(String seed) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取秘钥生成器&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过种子初始化&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         SecureRandom secureRandom = SecureRandom.getInstance(&quot;SHA1PRNG&quot;, &quot;Crypto&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         secureRandom.setSeed(seed.getBytes(&quot;UTF-8&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         keyGenerator.init(128&lt;span&gt;, secureRandom);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成秘钥并返回&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; keyGenerator.generateKey();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是在Android7.0之后就不支持了，移除了Crypto。当然也这种获取密钥方式在7.0之后Google也给出了解决方案，但是官方并不建议这样来获取。具体的可以看这里。&lt;a href=&quot;https://android-developers.googleblog.com/2016/06/security-crypto-provider-deprecated-in.html&quot;&gt;https://android-developers.googleblog.com/2016/06/security-crypto-provider-deprecated-in.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方给出的是另一种方式，并不需要获取密钥，而是定义密码的形式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.huangjialin.md5test;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.Bundle;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.support.v7.app.AppCompatActivity;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.util.Base64;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.util.Log;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Button;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.EditText;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.TextView;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.crypto.Cipher;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.crypto.SecretKey;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.crypto.spec.SecretKeySpec;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AppCompatActivity {
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; EditText edittext;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Button button, jiami, jiemi;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; TextView textView;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; SecretKey secretKey;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bytes;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String content = &quot;huangjialin,我是要加密的数据&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     String password = &quot;huangji黄家磷&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;        setContentView(R.layout.activity_main);
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt;         edittext =&lt;span&gt; findViewById(R.id.edittext);
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         button =&lt;span&gt; findViewById(R.id.button);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         textView =&lt;span&gt; findViewById(R.id.textview);
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         jiami =&lt;span&gt; findViewById(R.id.jiami);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         jiemi =&lt;span&gt; findViewById(R.id.jiemi);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;         Log.i(&quot;huagjialin&quot;, &quot;--加密的数据-- &amp;gt; &quot; +&lt;span&gt; content);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;         * 获取密钥
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; button.setOnClickListener(new View.OnClickListener() {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;            public void onClick(View v) {
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;                try {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;                    secretKey = generateKey(&quot;huangjiain&quot;);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;                } catch (Exception e) {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;        });&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;         * 加密
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt;         jiami.setOnClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; View.OnClickListener() {
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v) {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                     bytes =&lt;span&gt; encrypt(content, password);
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                     String str = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(bytes);
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                     Log.i(&quot;huagjialin&quot;, &quot;--加密后的数据-- &amp;gt; &quot; +&lt;span&gt; Base64.decode(str,Base64.DEFAULT));
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;         * 解密
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt;         jiemi.setOnClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; View.OnClickListener() {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v) {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                     &lt;span&gt;byte&lt;/span&gt;[] by =&lt;span&gt; decrypt(bytes, password);
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                     String string = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(by);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                     Log.i(&quot;huagjialin&quot;, &quot;--解密后的数据-- &amp;gt; &quot; +&lt;span&gt; string);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;     * 另一种加密形式
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] encrypt(String content, String password) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建AES秘钥&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;         SecretKeySpec key = &lt;span&gt;new&lt;/span&gt; SecretKeySpec(password.getBytes(), &quot;AES/CBC/PKCS5PADDING&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建密码器&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt;         Cipher cipher = Cipher.getInstance(&quot;AES&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化加密器&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;        cipher.init(Cipher.ENCRYPT_MODE, key);
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加密&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; cipher.doFinal(content.getBytes(&quot;UTF-8&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt; &lt;span&gt;     * 解密
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] decrypt(&lt;span&gt;byte&lt;/span&gt;[] content, String password) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建AES秘钥&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt;         SecretKeySpec key = &lt;span&gt;new&lt;/span&gt; SecretKeySpec(password.getBytes(), &quot;AES/CBC/PKCS5PADDING&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建密码器&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt;         Cipher cipher = Cipher.getInstance(&quot;AES&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化解密器&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt; &lt;span&gt;        cipher.init(Cipher.DECRYPT_MODE, key);
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解密&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cipher.doFinal(content);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 09-20 21:12:36.394 15933-15933/com.example.huangjialin.md5test I/huagjialin: --加密的数据-- &amp;gt;&lt;span&gt; huangjialin,我是要加密的数据
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 09-20 21:12:39.561 15933-15933/com.example.huangjialin.md5test I/huagjialin: --加密后的数据-- &amp;gt;&lt;span&gt; [B@d62495e
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 09-20 21:12:41.829 15933-15933/com.example.huangjialin.md5test I/huagjialin: --解密后的数据-- &amp;gt; huangjialin,我是要加密的数据
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上就是我们比较常用的几种加密的一些内容。好了，这篇内容就到这，文中如果错误，麻烦大神指教，共同进步&lt;/p&gt;

</description>
<pubDate>Sun, 23 Sep 2018 17:10:00 +0000</pubDate>
<dc:creator>家磷</dc:creator>
<og:description>摘要 这篇文章本来早就应该写了，但是由于项目一直开发新的需求，就拖后了。现在有时间了，必须得写了。现在Android应用程序对安全防范这方面要求越来越高了。特别是金融行业，如果金融app没有没有做好相</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjialin/p/9694488.html</dc:identifier>
</item>
<item>
<title>高并发第十一弹:J.U.C -AQS(AbstractQueuedSynchronizer) 组件:Lock,ReentrantLock,ReentrantReadWriteLock,StampedLock - 爱呼吸的鱼</title>
<link>http://www.cnblogs.com/aihuxi/p/9694445.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aihuxi/p/9694445.html</guid>
<description>&lt;p&gt;既然说到J.U.C 的AQS(AbstractQueuedSynchronizer)   不说 Lock 是不可能的.不过实话来说,一般 JKD8 以后我一般都不用Lock了.毕竟sychronized 的效率已经很高了.Lock在我的实际开发中的需求很少,但还是需要了解一下的.&lt;/p&gt;
&lt;h2&gt;JAVA的两种锁&lt;/h2&gt;
&lt;h3&gt;ReentrantLock与synchronized的区别&lt;/h3&gt;
&lt;p&gt;　　可重入性：两者的锁都是可重入的，差别不大，有线程进入锁，计数器自增1，等下降为0时才可以释放锁&lt;/p&gt;
&lt;p&gt;　　锁的实现：synchronized是基于JVM实现的（用户很难见到，无法了解其实现），ReentrantLock是JDK实现的,其实就是我们敲代码实现的。&lt;/p&gt;
&lt;p&gt;　　性能区别：在最初的时候，二者的性能差别差很多，当synchronized引入了偏向锁、轻量级锁（自选锁）后，二者的性能差别不大，官方推荐synchronized（写法更容易、在优化时其实是借用了ReentrantLock的CAS技术，试图在用户态就把问题解决，避免进入内核态造成线程阻塞）&lt;/p&gt;
&lt;p&gt;功能区别：&lt;/p&gt;
&lt;p&gt;　　（1）便利性：synchronized更便利，它是由编译器保证加锁与释放。ReentrantLock是需要手动释放锁，所以为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。&lt;/p&gt;
&lt;p&gt;　　（2）锁的细粒度和灵活度，ReentrantLock优于synchronized &lt;/p&gt;
&lt;h3&gt;ReentrantLock独有的功能&lt;/h3&gt;
&lt;p&gt;　　可以指定是公平锁还是非公平锁，sync只能是非公平锁。（所谓公平锁就是先等待的线程先获得锁）&lt;/p&gt;
&lt;p&gt;　　提供了一个Condition类，可以分组唤醒需要唤醒的线程。不像是synchronized要么随机唤醒一个线程，要么全部唤醒。&lt;/p&gt;
&lt;p&gt;　　提供能够中断等待锁的线程的机制，通过lock.lockInterruptibly()实现，这种机制 ReentrantLock是一种自选锁，通过循环调用CAS操作来实现加锁。性能比较好的原因是避免了进入内核态的阻塞状态。&lt;/p&gt;
&lt;h3&gt;建议(纯个人粗见):&lt;/h3&gt;
&lt;p&gt;　　除非需要用Lock的3个独有的功能,为了安全和省心一点还是用synchronized吧.最后会有一个 Lock和synchronized和Atomic的性能对比.也可以作为参考&lt;/p&gt;
&lt;p&gt;那还是回归主题&lt;/p&gt;
&lt;h3&gt;怎么使用ReentrantLock呢&lt;/h3&gt;
&lt;p&gt;　　构造方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span class=&quot;memberNameLink&quot;&gt;&lt;a&gt;　　ReentrantLock&lt;/a&gt;()&lt;/span&gt;&lt;/code&gt;创建一个 &lt;code&gt;ReentrantLock&lt;/code&gt;的实例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span class=&quot;memberNameLink&quot;&gt;&lt;a&gt;　　ReentrantLock&lt;/a&gt;(boolean fair) &lt;/span&gt;&lt;/code&gt;根据给定的公平政策创建一个 &lt;code&gt;ReentrantLock&lt;/code&gt;的实例。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建锁&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用锁&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method() {
    lock.lock();
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
       .......
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        lock.unlock();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基本方法&lt;/p&gt;
&lt;p&gt;基本使用 上面也有了   看一下Condition的使用&lt;/p&gt;
&lt;h3&gt;Condition的使用&lt;/h3&gt;
&lt;div class=&quot;block&quot; readability=&quot;83.265073425586&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;因素出&lt;code&gt;Object&lt;/code&gt;监视器方法（ &lt;a&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; ， &lt;a&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt;和&lt;a&gt;&lt;code&gt;notifyAll&lt;/code&gt;&lt;/a&gt; ）成不同的对象，以得到具有多个等待集的每个对象，通过将它们与使用任意的组合的效果&lt;a title=&quot;java.util.concurrent.locks中的接口&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;个&lt;/a&gt;实现。 &lt;code&gt;Lock&lt;/code&gt;替换&lt;code&gt;synchronized&lt;/code&gt;方法和语句的使用， &lt;code&gt;Condition&lt;/code&gt;取代了对象监视器方法的使用。
&lt;p&gt;条件（也称为&lt;em&gt;条件队列&lt;/em&gt;或&lt;em&gt;条件变量&lt;/em&gt; ）为一个线程暂停执行（“等待”）提供了一种方法，直到另一个线程通知某些状态现在可能为真。 因为访问此共享状态信息发生在不同的线程中，所以它必须被保护，因此某种形式的锁与该条件相关联。 等待条件的关键属性是它&lt;em&gt;原子地&lt;/em&gt;释放相关的锁并挂起当前线程，就像&lt;code&gt;Object.wait&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;Condition&lt;/code&gt;实例本质上绑定到一个锁。 要获得特定&lt;code&gt;Condition&lt;/code&gt;实例的&lt;a title=&quot;java.util.concurrent.locks中的接口&quot;&gt;Condition&lt;/a&gt;实例，请使用其&lt;a&gt;&lt;code&gt;newCondition()&lt;/code&gt;&lt;/a&gt;方法。&lt;/p&gt;
&lt;p&gt;例如，假设我们有一个有限的缓冲区，它支持&lt;code&gt;put&lt;/code&gt;和&lt;code&gt;take&lt;/code&gt;方法。 如果在一个空的缓冲区尝试一个&lt;code&gt;take&lt;/code&gt; ，则线程将阻塞直到一个项目可用; 如果&lt;code&gt;put&lt;/code&gt;试图在一个完整的缓冲区，那么线程将阻塞，直到空间变得可用。 我们希望在单独的等待集中等待&lt;code&gt;put&lt;/code&gt;线程和&lt;code&gt;take&lt;/code&gt;线程，以便我们可以在缓冲区中的项目或空间可用的时候使用仅通知单个线程的优化。 这可以使用两个&lt;a title=&quot;java.util.concurrent.locks中的接口&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;实例来实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BoundedBuffer {
   &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
   &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Condition notFull  =&lt;span&gt; lock.newCondition(); 
   &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Condition notEmpty =&lt;span&gt; lock.newCondition(); 

   &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Object[] items = &lt;span&gt;new&lt;/span&gt; Object[100&lt;span&gt;];
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; putptr, takeptr, count;

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; put(Object x) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
     lock.lock(); &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
       &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (count ==&lt;span&gt; items.length)
         notFull.await();
       items[putptr] &lt;/span&gt;=&lt;span&gt; x;
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (++putptr == items.length) putptr = 0&lt;span&gt;;
       &lt;/span&gt;++&lt;span&gt;count;
       notEmpty.signal();
     } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; { lock.unlock(); }
   }

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object take() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
     lock.lock(); &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
       &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (count == 0&lt;span&gt;)
         notEmpty.await();
       Object x &lt;/span&gt;=&lt;span&gt; items[takeptr];
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (++takeptr == items.length) takeptr = 0&lt;span&gt;;
       &lt;/span&gt;--&lt;span&gt;count;
       notFull.signal();
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
     } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; { lock.unlock(); }
   }
 } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是一个更明晰的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    ReentrantLock reentrantLock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
    Condition condition &lt;/span&gt;= reentrantLock.newCondition();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建condition
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程1&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            reentrantLock.lock();
            log.info(&lt;/span&gt;&quot;wait signal&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;            condition.await();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        log.info(&lt;/span&gt;&quot;get signal&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
&lt;span&gt;        reentrantLock.unlock();
    }).start();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程2&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
        reentrantLock.lock();
        log.info(&lt;/span&gt;&quot;get lock&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;3000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        condition.signalAll();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送信号&lt;/span&gt;
        log.info(&quot;send signal&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
&lt;span&gt;        reentrantLock.unlock();
    }).start();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出过程讲解：&lt;/p&gt;
&lt;p&gt;1、线程1调用了reentrantLock.lock()，线程进入AQS等待队列，输出1号log&lt;/p&gt;
&lt;p&gt;2、接着调用了awiat方法，线程从AQS队列中移除，锁释放，直接加入condition的等待队列中&lt;/p&gt;
&lt;p&gt;3、线程2因为线程1释放了锁，拿到了锁，输出2号log&lt;/p&gt;
&lt;p&gt;4、线程2执行condition.signalAll()发送信号，输出3号log&lt;/p&gt;
&lt;p&gt;5、condition队列中线程1的节点接收到信号，从condition队列中拿出来放入到了AQS的等待队列,这时线程1并没有被唤醒。&lt;/p&gt;
&lt;p&gt;6、线程2调用unlock释放锁，因为AQS队列中只有线程1，因此AQS释放锁按照从头到尾的顺序，唤醒线程1 7、线程1继续执行，输出4号log，并进行unlock操作。&lt;/p&gt;
&lt;h3&gt;ReentrantReadWriteLock的使用&lt;/h3&gt;
&lt;p&gt;在没有任何读写锁的时候才可以取得写入锁(悲观读取，容易写线程饥饿)，也就是说如果一直存在读操作，那么写锁一直在等待没有读的情况出现，这样我的写锁就永远也获取不到，就会造成等待获取写锁的线程饥饿。 平时使用的场景并不多。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, Data&amp;gt; map = &lt;span&gt;new&lt;/span&gt; TreeMap&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantReadWriteLock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantReadWriteLock();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Lock readLock = lock.readLock();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读锁&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Lock writeLock = lock.writeLock();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写锁

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加读锁&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Data get(String key) {
        readLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map.get(key);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            readLock.unlock();
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加写锁&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Data put(String key, Data value) {
        writeLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map.put(key, value);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            writeLock.unlock();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;StampedLock&lt;/h3&gt;
&lt;p&gt;好文章:&lt;a href=&quot;http://www.importnew.com/14941.html&quot; target=&quot;_blank&quot;&gt;StampedLock将是解决同步问题的新宠&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;blockList&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;block&quot; readability=&quot;9.3982808022923&quot;&gt;介绍: 一种基于能力的锁，具有三种模式用于控制读/写访问。 StampedLock的状态由版本和模式组成。 锁定采集方法返回一个表示和控制相对于锁定状态的访问的印记; 这些方法的“尝试”版本可能会返回特殊值为零以表示获取访问失败。 锁定释放和转换方法要求邮票作为参数，如果它们与锁的状态不匹配则失败。 这三种模式是：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;写作。&lt;/strong&gt; 方法&lt;a&gt;&lt;code&gt;writeLock()&lt;/code&gt;&lt;/a&gt;可能阻止等待独占访问，返回可以在方法&lt;a&gt;&lt;code&gt;unlockWrite(long)&lt;/code&gt;&lt;/a&gt;中使用的&lt;a&gt;邮票&lt;/a&gt;来释放锁定。 不定时的和定时版本&lt;code&gt;tryWriteLock&lt;/code&gt; ，还提供。 当锁保持写入模式时，不能获得读取锁定，并且所有乐观读取验证都将失败。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读。&lt;/strong&gt; 方法&lt;a&gt;&lt;code&gt;readLock()&lt;/code&gt;&lt;/a&gt;可能阻止等待非独占访问，返回可用于方法&lt;a&gt;&lt;code&gt;unlockRead(long)&lt;/code&gt;&lt;/a&gt;释放锁的&lt;a&gt;戳记&lt;/a&gt; 。 不定时的和定时版本&lt;code&gt;tryReadLock&lt;/code&gt; ，还提供。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;乐观阅读&lt;/strong&gt; 方法&lt;a&gt;&lt;code&gt;tryOptimisticRead()&lt;/code&gt;&lt;/a&gt;只有当锁当前未保持在写入模式&lt;a&gt;时才&lt;/a&gt;返回非零标记。 方法&lt;a&gt;&lt;code&gt;validate(long)&lt;/code&gt;&lt;/a&gt;返回true，如果在获取给定的邮票时尚未在写入模式中获取锁定。 这种模式可以被认为是一个非常弱的版本的读锁，可以随时由作家打破。 对简单的只读代码段使用乐观模式通常会减少争用并提高吞吐量。 然而，其使用本质上是脆弱的。 乐观阅读部分只能读取字段并将其保存在局部变量中，以供后验证使用。 以乐观模式读取的字段可能会非常不一致，因此只有在熟悉数据表示以检查一致性和/或重复调用方法&lt;code&gt;validate()&lt;/code&gt;时，使用情况才适用。 例如，当首次读取对象或数组引用，然后访问其字段，元素或方法之一时，通常需要这样的步骤。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;JDK上提供的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Point {
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; x, y;
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; StampedLock sl = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StampedLock();
   &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; move(&lt;span&gt;double&lt;/span&gt; deltaX, &lt;span&gt;double&lt;/span&gt; deltaY) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; an exclusively locked method&lt;/span&gt;
     &lt;span&gt;long&lt;/span&gt; stamp =&lt;span&gt; sl.writeLock();
     &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
       x &lt;/span&gt;+=&lt;span&gt; deltaX;
       y &lt;/span&gt;+=&lt;span&gt; deltaY;
     } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
       sl.unlockWrite(stamp);
     }
   }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面看看乐观读锁案例&lt;/span&gt;
   &lt;span&gt;double&lt;/span&gt; distanceFromOrigin() { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; A read-only method&lt;/span&gt;
     &lt;span&gt;long&lt;/span&gt; stamp = sl.tryOptimisticRead(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得一个乐观读锁&lt;/span&gt;
     &lt;span&gt;double&lt;/span&gt; currentX = x, currentY = y; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将两个字段读入本地局部变量&lt;/span&gt;
     &lt;span&gt;if&lt;/span&gt; (!sl.validate(stamp)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查发出乐观读锁后同时是否有其他写锁发生？&lt;/span&gt;
        stamp = sl.readLock(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有，我们再次获得一个读悲观锁&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          currentX &lt;/span&gt;= x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将两个字段读入本地局部变量&lt;/span&gt;
          currentY = y; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将两个字段读入本地局部变量&lt;/span&gt;
        } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
           sl.unlockRead(stamp);
        }
     }
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.sqrt(currentX * currentX + currentY *&lt;span&gt; currentY);
   }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面是悲观读锁案例&lt;/span&gt;
   &lt;span&gt;void&lt;/span&gt; moveIfAtOrigin(&lt;span&gt;double&lt;/span&gt; newX, &lt;span&gt;double&lt;/span&gt; newY) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; upgrade
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Could instead start with optimistic, not read mode&lt;/span&gt;
     &lt;span&gt;long&lt;/span&gt; stamp =&lt;span&gt; sl.readLock();
     &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
       &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (x == 0.0 &amp;amp;&amp;amp; y == 0.0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环，检查当前状态是否符合&lt;/span&gt;
         &lt;span&gt;long&lt;/span&gt; ws = sl.tryConvertToWriteLock(stamp); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将读锁转为写锁&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt; (ws != 0L) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是确认转为写锁是否成功&lt;/span&gt;
           stamp = ws; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果成功 替换票据&lt;/span&gt;
           x = newX; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行状态改变&lt;/span&gt;
           y = newY; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行状态改变&lt;/span&gt;
           &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
         }
         &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不能成功转换为写锁&lt;/span&gt;
           sl.unlockRead(stamp); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们显式释放读锁&lt;/span&gt;
           stamp = sl.writeLock(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显式直接进行写锁 然后再通过循环再试&lt;/span&gt;
&lt;span&gt;         }
       }
     } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
       sl.unlock(stamp); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放读锁或写锁&lt;/span&gt;
&lt;span&gt;     }
   }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定；&lt;/li&gt;
&lt;li&gt;ReentrantLock、ReentrantReadWriteLock,、StampedLock都是对象层面的锁定，要保证锁定一定会被释放，就必须将unLock()放到finally{}中；&lt;/li&gt;
&lt;li&gt;StampedLock 对吞吐量有巨大的改进，特别是在读线程越来越多的场景下；&lt;/li&gt;
&lt;li&gt;StampedLock有一个复杂的API，对于加锁操作，很容易误用其他方法;&lt;/li&gt;
&lt;li&gt;当只有少量竞争者的时候，synchronized是一个很好的通用的锁实现;&lt;/li&gt;
&lt;li&gt;当线程增长能够预估，ReentrantLock是一个很好的通用的锁实现;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;StampedLock 可以说是Lock的一个很好的补充，吞吐量以及性能上的提升足以打动很多人了，但并不是说要替代之前Lock的东西，毕竟他还是有些应用场景的，起码API比StampedLock容易入手.&lt;/p&gt;

&lt;h3&gt;锁的选择&lt;/h3&gt;
&lt;p&gt;1、当只有少量竞争者，使用synchronized&lt;/p&gt;
&lt;p&gt;2、竞争者不少但是线程增长的趋势是能预估的，使用ReetrantLock&lt;/p&gt;
&lt;p&gt;3、synchronized不会造成死锁，jvm会自动释放死锁。 &lt;/p&gt;
&lt;h3&gt;下面有一个例子 关闭 synchronized ,reentrantLock,Atomic的性能对比&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;&lt;img id=&quot;code_img_closed_b9dd26e3-6d0f-49ab-ba92-9e406a5298ee&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b9dd26e3-6d0f-49ab-ba92-9e406a5298ee&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b9dd26e3-6d0f-49ab-ba92-9e406a5298ee&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;95&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.rong.juc;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.BrokenBarrierException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.CyclicBarrier;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutorService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicInteger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicLong;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReentrantLock;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 * @ClassName: ReentrantLockDemo
 * @Description:TODO(这里用一句话描述这个类的作用)
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: rongbo
 * @date: 2018年9月23日 下午10:57:27
 * 
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReentrantLockTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt; round, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threadNum, CyclicBarrier cyclicBarrier) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SyncTest(&quot;Sync&quot;&lt;span&gt;, round, threadNum, cyclicBarrier).testTime();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LockTest(&quot;Lock&quot;&lt;span&gt;, round, threadNum, cyclicBarrier).testTime();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; AtomicTest(&quot;Atom&quot;&lt;span&gt;, round, threadNum, cyclicBarrier).testTime();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; round = 10000 * (i + 1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; threadNum = 5 * (i + 1&lt;span&gt;);
            CyclicBarrier cb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CyclicBarrier(threadNum * 2 + 1&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;==========================&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;round:&quot; + round + &quot; thread:&quot; +&lt;span&gt; threadNum);
            test(round, threadNum, cb);

        }
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; SyncTest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; TestTemplate {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SyncTest(String _id, &lt;span&gt;int&lt;/span&gt; _round, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _threadNum, CyclicBarrier _cb) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(_id, _round, _threadNum, _cb);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * synchronized关键字不在方法签名里面，所以不涉及重载问题
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.countValue;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sumValue() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.countValue += preInit[index++ %&lt;span&gt; round];
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; LockTest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; TestTemplate {
    ReentrantLock lock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; LockTest(String _id, &lt;span&gt;int&lt;/span&gt; _round, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _threadNum, CyclicBarrier _cb) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(_id, _round, _threadNum, _cb);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * synchronized关键字不在方法签名里面，所以不涉及重载问题
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; getValue() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            lock.lock();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.countValue;
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; sumValue() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            lock.lock();
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.countValue += preInit[index++ %&lt;span&gt; round];
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; AtomicTest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; TestTemplate {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AtomicTest(String _id, &lt;span&gt;int&lt;/span&gt; _round, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _threadNum, CyclicBarrier _cb) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(_id, _round, _threadNum, _cb);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * synchronized关键字不在方法签名里面，所以不涉及重载问题
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.countValueAtmoic.get();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; sumValue() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.countValueAtmoic.addAndGet(&lt;span&gt;super&lt;/span&gt;.preInit[indexAtomic.get() %&lt;span&gt; round]);
    }
}

&lt;/span&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestTemplate {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String id;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; round;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threadNum;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; countValue;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; AtomicLong countValueAtmoic = &lt;span&gt;new&lt;/span&gt; AtomicLong(0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] preInit;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; AtomicInteger indexAtomic = &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);
    Random r &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Random(47&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务栅栏，同批任务，先到达wait的任务挂起，一直等到全部任务到达制定的wait地点后，才能全部唤醒，继续执行&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; CyclicBarrier cb;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TestTemplate(String _id, &lt;span&gt;int&lt;/span&gt; _round, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _threadNum, CyclicBarrier _cb) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; _id;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.round =&lt;span&gt; _round;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.threadNum =&lt;span&gt; _threadNum;
        cb &lt;/span&gt;=&lt;span&gt; _cb;
        preInit &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[round];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; preInit.length; i++&lt;span&gt;) {
            preInit[i] &lt;/span&gt;= r.nextInt(100&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sumValue();

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 对long的操作是非原子的，原子操作只针对32位 long是64位，底层操作的时候分2个32位读写，因此不是线程安全
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getValue();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testTime() {
        ExecutorService se &lt;/span&gt;=&lt;span&gt; Executors.newCachedThreadPool();
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.nanoTime();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同时开启2*ThreadNum个数的读写线程&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; threadNum; i++&lt;span&gt;) {
            se.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; round; i++&lt;span&gt;) {
                        sumValue();
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每个线程执行完同步方法后就等待&lt;/span&gt;
                    &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        cb.await();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (InterruptedException |&lt;span&gt; BrokenBarrierException e) {
                        e.printStackTrace();
                    }

                }
            });
            se.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

                    getValue();
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每个线程执行完同步方法后就等待&lt;/span&gt;
&lt;span&gt;                        cb.await();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BrokenBarrierException e) {
                        e.printStackTrace();
                    }

                }
            });
        }

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前统计线程也wait,所以CyclicBarrier的初始值是threadNum*2+1&lt;/span&gt;
&lt;span&gt;            cb.await();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BrokenBarrierException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所有线程执行完成之后，才会跑到这一步&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; duration = System.nanoTime() -&lt;span&gt; start;
        System.out.println(id &lt;/span&gt;+ &quot; = &quot; +&lt;span&gt; duration);

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;老电脑 ,性能很差&lt;/p&gt;
&lt;p&gt;结果:&lt;/p&gt;
&lt;p&gt;==========================&lt;br/&gt;round:10000 thread:5&lt;br/&gt;Sync = 4578771&lt;br/&gt;Lock = 6079408&lt;br/&gt;Atom = 2358938&lt;br/&gt;==========================&lt;br/&gt;round:20000 thread:10&lt;br/&gt;Sync = 10253723&lt;br/&gt;Lock = 6668266&lt;br/&gt;Atom = 3977932&lt;br/&gt;==========================&lt;br/&gt;round:30000 thread:15&lt;br/&gt;Sync = 19530498&lt;br/&gt;Lock = 13254122&lt;br/&gt;Atom = 11142416&lt;br/&gt;==========================&lt;br/&gt;round:40000 thread:20&lt;br/&gt;Sync = 31596091&lt;br/&gt;Lock = 24663350&lt;br/&gt;Atom = 18504161&lt;br/&gt;==========================&lt;br/&gt;round:50000 thread:25&lt;br/&gt;Sync = 55158877&lt;br/&gt;Lock = 36521455&lt;br/&gt;Atom = 32352693&lt;/p&gt;

&lt;h3&gt;StampedLock 和ReentrantLock的对比&lt;/h3&gt;
&lt;p&gt;就刚刚 个例子 自己试一下吧..还是需要自动动手后才 记得住的 Q_Q&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 23 Sep 2018 16:49:00 +0000</pubDate>
<dc:creator>爱呼吸的鱼</dc:creator>
<og:description>ReentrantLock与synchronized的区别 ReentrantReadWriteLock的使用 锁的选择</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aihuxi/p/9694445.html</dc:identifier>
</item>
<item>
<title>centos7 node升级及git clone 报401错误的解决办法 - whyuyan</title>
<link>http://www.cnblogs.com/whyuyan/p/9694370.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whyuyan/p/9694370.html</guid>
<description>&lt;p&gt;&amp;#13;
                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt;&amp;#13;
                                    &lt;h4 class=&quot;modal-title&quot;&gt;&amp;#13;
                                        请完成人机识别验证&amp;#13;
                                    &lt;/h4&gt;&amp;#13;
                                &lt;/p&gt;
                                &lt;div class=&quot;modal-body&quot; readability=&quot;33&quot;&gt;
                                    
                                    &lt;p&gt;&amp;#13;
                                        &lt;span id=&quot;geetestLoading&quot;&gt; 验证码组件加载中,请稍后...&lt;/span&gt;&amp;#13;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            </description>
<pubDate>Sun, 23 Sep 2018 16:17:00 +0000</pubDate>
<dc:creator>whyuyan</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fwhyuyan%2Fp%2F9694370.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
<item>
<title>论文笔记：IRGAN：A Minimax Game for Unifying Generative and Discriminative Information - PilgrimHui</title>
<link>http://www.cnblogs.com/liaohuiqiang/p/9694277.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liaohuiqiang/p/9694277.html</guid>
<description>&lt;p&gt;&lt;strong&gt;2017 SIGIR&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;简单介绍&quot;&gt;简单介绍&lt;/h3&gt;
&lt;p&gt;IRGAN将GAN用在信息检索（Information Retrieval）领域，通过GAN的思想将生成检索模型和判别检索模型统一起来，对于生成器采用了基于策略梯度的强化学习来训练，在三种典型的IR任务上（四个数据集）得到了更显著的效果。&lt;/p&gt;
&lt;h3 id=&quot;生成式和判别式的检索模型&quot;&gt;生成式和判别式的检索模型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;生成式检索模型（query -&amp;gt; document）&lt;/strong&gt;认为query和document之间存在潜在的生成过程，其缺点在于很难利用其它相关的信息，比如链接数，点击数等document和document之间的相关数据。&lt;br/&gt;&lt;strong&gt;判别式检索模型（query+document -&amp;gt; relevance）&lt;/strong&gt;同时考虑query和document作为特征，预测它们的相关性，其缺点在于缺乏获取有用特征的方法。&lt;/p&gt;
&lt;h3 id=&quot;gan&quot;&gt;GAN&lt;/h3&gt;
&lt;p&gt;GAN里面的生成器和判别器通过相互博弈来完成工作，举例来说，我们要生成动漫人物头像，如下两个图所示。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;训练判别器&lt;/strong&gt;：初代的生成器Generator0会生成很模糊的动漫头像，这个时候我们把Generator0产生的头像作为0标签，真实的头像作为1标签丢入到初代的判别器Discriminator0中训练，得到新一代判别器Discriminator1，这个判别器能够辨认真实头像和Generator0产生的假头像，如果输入是一个真实头像，Discriminator1会输出1，如果输入是一个Generator0生成的头像，Discriminator1会输出0。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;训练生成器&lt;/strong&gt;：然后，我们训练Generator0，目标是使得Discriminator1判断生成器生成的头像为真实头像（输出标签为1），以这个为目标训练得到的Generator1能够成功骗过Discriminator1。对于Discriminator1，如果输入是一个Generator1生成的头像，它会输出1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;迭代博弈&lt;/strong&gt;：上面两个步骤就完成了一次博弈，接着会不断迭代这个博弈，Discriminator1会进化成Discriminator2能够成功分辨Generator1产生的是假头像（输出0标签），然后Generator1为了骗过Discriminator2又会进化成Generator2。不断迭代这个过程，最后就能生成一些逼真的动漫人物头像。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180923234959819-603304185.png&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180923234615481-1195790087.png&quot;/&gt;&lt;h3 id=&quot;irgan&quot;&gt;IRGAN&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;可以利用GAN的思想，把两种检索模型结合起来，克服它们的缺点。如下图所示。&lt;/li&gt;
&lt;li&gt;以生成式检索模型作为生成器，输入query，我们选取相关的document，构成数据对，作为生成数据。&lt;/li&gt;
&lt;li&gt;以判别式检索模型作为判别器，用一个打分score来表示判别器的判别能力，判别器越能区分生成数据和真实数据（即输入生成数据时输出0，输入真实数据时输出1），则判别能力越强。&lt;/li&gt;
&lt;li&gt;根据生成器生成的固定数据和真实数据，训练判别器。然后固定判别器，训练生成器使得判别器的判别能力最小化（即输入生成数据时也输出1）。这样完成一次博弈，迭代多次博弈不断训练。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180923234627141-1891348825.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;从极大似然法mle到gan再到irgan&quot;&gt;从极大似然法（MLE）到GAN再到IRGAN&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;传统的生成问题&lt;/strong&gt;：给定一个数据集D，我们构建一个模型，模型产生的数据分布q(x)可以拟合真实的数据分布p(x)，我们希望真实的数据在我们学到的模型上有一个很高的概率密度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最小化KL散度&lt;/strong&gt;：如下式所示，其实这个过程就是在最小化交叉熵。因为真实数据分布不变，信息熵不变，可以看作是在最小化相对熵（KL散度）。这几个熵我在另一篇博文&lt;a href=&quot;https://www.cnblogs.com/liaohuiqiang/p/7673681.html&quot;&gt;信息熵，交叉熵和相对熵&lt;/a&gt;中有介绍。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\max_{q} \frac {1}{|D|} \sum_{x \in D} log \ q(x) \approx \max_{q} E_{x \sim q(x)} [log \ q(x)] = \min_q \int_{x} p(x) \ log \frac {1}{q(x)}\]&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;不对称问题&lt;/strong&gt;：这样一个广为使用方法有个不对称的问题，对于KL散度，当p(x)&amp;gt;0而q(x)趋近于0时会产生一个高损失，这没有问题，但是当q(x)&amp;gt;0而p(x)趋近于0时候，损失却趋近于0，这与我们的目的不相符。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\underbrace{\int_{x} p(x) \ log \frac {1}{q(x)}}_{\text{交叉熵}} - \underbrace{\int_{x} p(x) \ log \frac {1}{p(x)}}_{\text{信息熵}} = \underbrace{\int_{x} p(x) \ log \frac {p(x)}{q(x)})}_{相对熵KL(p||q)}\]&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;不一致问题&lt;/strong&gt;：还有一个缺点就是，我们实际做的事情和我们希望的事情并不一致，我们实际做的是让真实的数据在我们学习的模型上有一个很高的概率密度，也就是&lt;span class=&quot;math inline&quot;&gt;\(\max_q E_{x \sim p(x)}[log \ q(x)]\)&lt;/span&gt;（实际的训练评估中我们通过&lt;span class=&quot;math inline&quot;&gt;\(\max_{q} \frac {1}{|D|} \sum_{x \in D} log \ q(x)\)&lt;/span&gt; 来approximate这个式子）。但是我们希望做的事情是让生成的数据接近真实数据，也就是生成的数据在真实的分布上有一个很高的概率密度，也就是&lt;span class=&quot;math inline&quot;&gt;\(\max_q E_{x \sim q(x)}[log \ p(x)]\)&lt;/span&gt;，但是这件事情我们是做不到的，因为我们并不知道真实数据的分布，我们没法计算p(x)，如果知道真实数据的分布我们就不用做这件事了。当然，q(x)等于p(x)时这两个式子就是一样的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GAN&lt;/strong&gt;：上面提到的一个难点是我们没有办法计算p(x)，不知道真实数据的分布长什么样，但是在GAN里面可以构建一个判别器来判别一个数据是真实的还是生成的。同时GAN最小化的不是KL散度，而是JS散度，这就解决了不对称的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从MLE到GAN&lt;/strong&gt;：MLE就是模型已定，参数未知，找出一组参数使得模型产生出观测数据的概率最大。用GAN里面的Generator（可以不局限于特定模型比如高斯分布）可以得到一个general的模型。利用GAN里面的Discriminator可以调整模型使得观测数据的概率最大。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从GAN到IRGAN&lt;/strong&gt;：IRGAN就是把GAN的技术用到信息检索中，IRGAN和GAN的不同点在于IRGAN生成器是输入query然后从已有的document中选取，而GAN是用随机噪音进行生成的。因为IRGAN生成的数据是离散的（需要对documents进行采样），所以需要使用基于策略梯度的强化学习来训练生成器。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;公式&quot;&gt;公式&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;最小化最大化&lt;/strong&gt;：前面提到，整个训练就是生成器和判别器博弈的过程，如下图中的式子，先进行一个最大化训练一个判别能力强的判别器，然后做一个最小化来训练一个能骗过判别器的生成器。不断迭代这个过程。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180923234636647-2067750191.png&quot;/&gt;&lt;br/&gt;&lt;hr/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JS散度&lt;/strong&gt;：对式子进行最大化后（训练判别器）得到的这个式子其实是一个JS散度，衡量生成数据和真实数据的分布。然后对JS散度进行最小化（训练生成器）就可以使生成数据逼近真实数据。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180923234645675-1851599928.png&quot;/&gt;&lt;br/&gt;&lt;hr/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;训练判别器&lt;/strong&gt;：最大化这个式子，使用sample的方法，发现其实就是一个逻辑回归的二分类问题。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180923234655042-1142625643.png&quot;/&gt;&lt;br/&gt;&lt;hr/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;训练生成器&lt;/strong&gt;：因为IRGAN里面最后是从document池中进行采样，可能softmax概率改变一点点，采样的结果并不会产生变化，这样难以进行梯度的传递更新，所以使用基于策略梯度的强化学习来训练。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180923234702248-1428182519.png&quot;/&gt;&lt;br/&gt;&lt;hr/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标函数的改进&lt;/strong&gt;：训练生成器的时候，考虑到目标函数在一开始下降地比较慢，做了一下修改。于是最后得到的策略梯度也发生了变化，奖赏项变成了判别器输出的log，这也很直观，强化学习要让奖赏越来越大，这里刚好就是让判别器的输出越大越好（接近1，让判别器以为生成的数据是真实的）。后面考虑到log使得训练不稳定，于是把log也去掉了。最后为了让奖赏有正有负，做了一个乘2减1的修正。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180923234712084-1854399598.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;实验&quot;&gt;实验&lt;/h3&gt;
&lt;p&gt;如下几个图所示，其中s(x)表示生成器和判别器的公式。&lt;br/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180923234719054-45804117.png&quot;/&gt;&lt;br/&gt;&lt;hr/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180923234723754-1250576633.png&quot;/&gt;&lt;br/&gt;&lt;hr/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180923234728757-1171402418.png&quot;/&gt;</description>
<pubDate>Sun, 23 Sep 2018 15:58:00 +0000</pubDate>
<dc:creator>PilgrimHui</dc:creator>
<og:description>IRGAN，发表于SIGIR-2017，信息检索领域的一篇论文，将GAN的技术应用到信息检索上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liaohuiqiang/p/9694277.html</dc:identifier>
</item>
<item>
<title>wordcount--realized by c - 余赛赛</title>
<link>http://www.cnblogs.com/yusaisai/p/9694306.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yusaisai/p/9694306.html</guid>
<description>&lt;p&gt;gitee地址：&lt;a title=&quot;gitee地址&quot; href=&quot;https://gitee.com/yusaisai/wordcount&quot; target=&quot;_blank&quot;&gt;https://gitee.com/yusaisai/wordcount&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;1需要说明&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;1.1 概要&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;wc接收一个文本文件，并统计这个文本文件中的信息（行数、字数等）&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;1.2 基本功能&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;wc.exe -c file.c //返回文件 file.c 的字符数&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;wc.exe -w file.c //返回文件 file.c 的单词总数&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;wc.exe -l file.c //返回文件 file.c 的总行数&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;wc.exe -o outputFile.txt file.c //将结果输出到指定文件outputFile.txt&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;注意：&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;空格，水平制表符，换行符，均算字符。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;由空格或逗号分割开的都视为单词，且不做单词的有效性校验，例如：thi#,that视为用逗号隔开的2个单词。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;-c, -w, -l参数可以共用同一个输入文件，形如：wc.exe –w –c file.c 。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;-o 必须与文件名同时使用，且输出文件必须紧跟在-o参数后面，不允许单独使用-o参数&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;2 基本思路&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;2.1 接受参数&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;参数的形式有两种：长选项、短选项，选项间可以组合，长选项用空格隔开各个参数&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;例： &lt;span class=&quot;md-html-inline&quot;&gt;&lt;code&gt;wc.exe --word --charater file.c&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;短选项可以多个直接叠加或者，也像长选项一样分开写&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;例： &lt;span class=&quot;md-html-inline&quot;&gt;&lt;code&gt;wc.exe -wc file.c&lt;/code&gt; &lt;span class=&quot;md-html-inline&quot;&gt;&lt;code&gt;wc.exe -w -c file.c&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;对于一个命令行程序，它可以接受来自命令行的参数。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;c语言的main函数中有两个参数：&lt;span class=&quot;md-html-inline&quot;&gt;&lt;code&gt;int main (int argc, char *argv[])&lt;/code&gt;，这两个参数就是用于这个参数的输入。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;argc 一个整数，代表有多少个命令行参数，在此注意两个点&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;1、 参数间是用空格格开的；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;2、程序名是第一个参数。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;argv[i]是一个指针，指向第i个参数的首地址&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;理解了以上的两人个参数就简单了，只需要做一些基本的字符串处理就可以了。&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;2.2.1 -h参数&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;这个参数单独说是因为这个参数不能和别的参数混用，所以我在程序里面是单独写的，一开始就判断是否用户需要的是help帮助，如果是的话，那么完全不必要再运行程序（打开文件），直接exit中止进程。&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;2.2.2 -w -c -l 参数&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;这三个参数都是一个路数：&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;1、打开文件；&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;2、判断要做的操作；&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;3、执行操作。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;它们间只有步骤3是不同的，所以有理由把3写成不同的函数，再由2判断执行哪个。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;有一些细节问题是可以考虑的。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;比如，因为单复数的关系，有一行/个 单词/字母，应该是不同的表达（是否有s）&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;额外就是判断一个单词的算法也是值得考虑的问题，我的想法是，如果这个&lt;/p&gt;

</description>
<pubDate>Sun, 23 Sep 2018 15:57:00 +0000</pubDate>
<dc:creator>余赛赛</dc:creator>
<og:description>wc.exe 编写说明 gitee地址：https://gitee.com/yusaisai/wordcount 1需要说明 1.1 概要 wc接收一个文本文件，并统计这个文本文件中的信息（行数、字数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yusaisai/p/9694306.html</dc:identifier>
</item>
<item>
<title>通过wireshark抓包来讲解HTTP中Connection: keep-alive头部的作用 - CLAYJJ</title>
<link>http://www.cnblogs.com/CLAYJJ/p/9694067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CLAYJJ/p/9694067.html</guid>
<description>&lt;p&gt;今天周末时间，有空给大家讲解一个小知识点，即HTTP的keep-alive头部。我使用wireshark来抓取网络包来在实战中讲解。希望能让大家更容易、更直观的理解！&lt;/p&gt;
&lt;p&gt;HTTP中keep-alive头部的作用是为保持TCP连接，这样可以复用TCP连接不需要为每个HTTP请求都建立一个单独的TCP连接。这样既可以节省操作系统资源，也能够保持HTTP请求的高效性。&lt;/p&gt;
&lt;p&gt;我们通过wireshark抓的包来分析一下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;下面的例子中128.14.154.105是HTTP服务器，192.168.1.6是客户端。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当服务器处理完一个HTTP请求时，会主动发起断开连接，如下图所示（四次挥手）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/922229/201809/922229-20180923220114330-1970454242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当服务器最后发送一个ACK包后进入TIME_WAIT状态，此状态将会持续2MSL（Maximum Segment Lifetime）,一个MSL一般为2分钟，所以TIME_WAIT一般持续4分钟。在此期间还是可以接受客户端的数据的。&lt;/p&gt;
&lt;p&gt;此时客户端为了复用TCP连接，将会发送一个心跳包（keep-alive）来保持连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/922229/201809/922229-20180923220948274-488639894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的例子中，共发送了2次心跳包。如果在此期间还没有新的HTTP请求那么服务器会再次主动断开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/922229/201809/922229-20180923221504808-754749704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此后，客户端不会再发送心跳包了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在最后给大家说下，为什么主动发起断开连接的一方在发送最后一个ACK包后需要进入TIME_WAIT状态2MSL&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）我们先假设发送完最后一个ACK包后直接断开的话，如果由于某种原因对端没有收到的话，对端会再次发送一个FIN包（TCP的重传机制），由于此时另一端已经关闭了对应的socket，所以TCP协议栈会&lt;/p&gt;
&lt;p&gt;发送一个RST包。这个包表示的是一种错误。（比如，请求的TCP连接的端口没有在监听状态下），那么TCP连接就是因错误而被迫断开，所以TCP中工作没有正常完成。&lt;/p&gt;
&lt;p&gt;2）第二个原因是让老的重复包在网络中消失，解释一下这句话的意思：如果我们的TCP断开之后，立马有一个新的TCP连接和之前的连接的IP和端口都一样的话，那么残留在网络中的包到达后会被误解为是新的&lt;/p&gt;
&lt;p&gt;连接中的包。这样就会出现问题。如果我们使用了TIME_WAIT，在这个状态下是不允许建立新的IP和端口都一样的TCP连接的，而且它会维持2MSL时间， 这足够让网络中的旧包消失掉。&lt;/p&gt;

&lt;p&gt;最后欢迎大家评论指正！^_^&lt;/p&gt;

</description>
<pubDate>Sun, 23 Sep 2018 14:43:00 +0000</pubDate>
<dc:creator>CLAYJJ</dc:creator>
<og:description>今天周末时间，有空给大家讲解一个小知识点，即HTTP的keep-alive头部。我使用wireshark来抓取网络包来在实战中讲解。希望能让大家更容易、更直观的理解！ HTTP中keep-alive头</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CLAYJJ/p/9694067.html</dc:identifier>
</item>
<item>
<title>Qt编写自定义控件属性设计器 - 飞扬青云</title>
<link>http://www.cnblogs.com/feiyangqingyun/p/9694025.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feiyangqingyun/p/9694025.html</guid>
<description>&lt;p&gt;以前做.NET开发中，.NET直接就集成了属性设计器，VS不愧是宇宙第一IDE，你能够想到的都给你封装好了，用起来不要太爽！因为项目需要自从全面转Qt开发已经6年有余，在工业控制领域，有一些应用场景需要自定义绘制一些控件满足特定的需求，比如仪器仪表、组态等，而且需要直接用户通过属性设计的形式生成导出控件及界面数据，下次导入使用，要想从内置控件或者自定义控件拿到对应的属性方法等，首先联想到的就是反射，Qt反射对应的类叫QMetaObject，着实强大，其实整个Qt开发框架也是超级强大的，本人自从转为Qt开发为主后，就深深的爱上了她，在其他跨平台的GUI开发框架平台面前，都会被Qt秒成渣，Qt的跨平台性是毋庸置疑的，几十兆的内存存储空间即可运行，尤其是嵌入式linux这种资源相当紧张的情况下，Qt的性能发挥到极致。&lt;/p&gt;
&lt;p&gt;接下来我们就一步步利用QMetaObject类和QtPropertyBrower（第三方开源属性设计器）来实现自己的控件属性设计器，其中包含了所见即所得的控件属性控制，以及xml数据的导入导出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：获取控件的属性名称集合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有继承自QObject类的类，都有元对象，都可以通过这个QObject类的元对象&lt;em&gt;metaObject&lt;/em&gt;()获取属性+事件+方法等。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
QPushButton *btn = new QPushButton;
const QMetaObject *metaobject = btn-&amp;gt;metaObject();
int count = metaobject-&amp;gt;propertyCount();
for (int i = 0; i &amp;lt; count; ++i) {
    QMetaProperty metaproperty = metaobject-&amp;gt;property(i);
    const char *name = metaproperty.name();
    QVariant value = btn-&amp;gt;property(name);
    qDebug() &amp;lt;&amp;lt; name &amp;lt;&amp;lt; value;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印输出如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
objectName QVariant(QString, &quot;&quot;)
modal QVariant(bool, false)
windowModality QVariant(int, 0)
enabled QVariant(bool, true)
geometry QVariant(QRect, QRect(0,0 640x480))
frameGeometry QVariant(QRect, QRect(0,0 639x479))
normalGeometry QVariant(QRect, QRect(0,0 0x0))
省略后面很多…
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到打印了很多父类的属性，这些基本上我们不需要的，那怎么办呢，放心，Qt肯定帮我们考虑好了，该propertyOffset上场了。metaObject-&amp;gt;propertyOffset()表示出了父类外，自己类本身属性的偏移位置即索引开始的位置，这下就好办了。&lt;/p&gt;
&lt;p&gt;代码改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
QPushButton *btn = new QPushButton;
const QMetaObject *metaobject = btn-&amp;gt;metaObject();
int count = metaobject-&amp;gt;propertyCount();
int index = metaobject-&amp;gt;propertyOffset();
for (int i = index; i &amp;lt; count; ++i) {
    QMetaProperty metaproperty = metaobject-&amp;gt;property(i);
    const char *name = metaproperty.name();
    QVariant value = btn-&amp;gt;property(name);
    qDebug() &amp;lt;&amp;lt; name &amp;lt;&amp;lt; value;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是将i的起始位置改为偏移位置即可。&lt;/p&gt;
&lt;p&gt;打印输出如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
autoDefault QVariant(bool, false)
default QVariant(bool, false)
flat QVariant(bool, false)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个过滤非常有用，因为真实用到的大部分应用场景都是控件类本身的属性，而不是父类的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：将控件类绑定到属性设计器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拿到了控件的属性是第一步，接下来就是需要拿到属性所关联的方法等，这里省略，因为QtPropertyBrower这个屌爆了的第三方开源的属性设计器，全部给我们写好了，可以查看Qt帮助文档或者QMetaObject的头文件看到，QMetaObject提供了哪些接口去获取或使用这些元信息。比如classInfo获取类的信息、enumerator获取枚举值信息、method获取方法，property获取属性、superClass获取父类的名称等。&lt;/p&gt;
&lt;p&gt;QtPropertyBrower中提供了ObjectController类，该类继承自QWidget，这样的话我们在界面上拖一个QWidget控件，鼠标右键提升为ObjectController即可。&lt;/p&gt;
&lt;p&gt;这个轮子造的不要太好，我们只需要一行代码就可以让所有属性自动罗列到属性设计器中，代码是&lt;strong&gt;ui&lt;/strong&gt;-&amp;gt;&lt;strong&gt;objectController&lt;/strong&gt;-&amp;gt;setObject(btn);&lt;/p&gt;
&lt;p&gt;看下效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63094/201809/63094-20180923222804734-43705225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里是不是很兴奋呢，任意控件都可以这样来展示自己的属性。在右侧动态更改属性会立即应用生效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：获取自定义控件的插件的所有控件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来这一步才是最关键的一步，以上举例是Qt自带控件的，如果是自定义控件插件比如就一个DLL文件呢，怎么办？放心，办法肯定是有的。&lt;/p&gt;
&lt;p&gt;该插件类QPluginLoader上场了。通过QPluginLoader载入后的实例，通过QDesignerCustomWidgetCollectionInterface类获取插件容器,然后逐个遍历容器找出单个插件，包括获得类名+图标。&lt;/p&gt;
&lt;p&gt; 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void frmMain::openPlugin(const QString &amp;amp;fileName)
{
    qDeleteAll(listWidgets);
    listWidgets.clear();
    listNames.clear();
    ui-&amp;gt;listWidget-&amp;gt;clear();
    //加载自定义控件插件集合信息,包括获得类名+图标
    QPluginLoader loader(fileName);
    if (loader.load()) {
        QObject *plugin = loader.instance();
        //获取插件容器,然后逐个遍历容器找出单个插件
        QDesignerCustomWidgetCollectionInterface *interfaces = qobject_cast&amp;lt;QDesignerCustomWidgetCollectionInterface *&amp;gt;(plugin);
        if (interfaces)  {
            listWidgets = interfaces-&amp;gt;customWidgets();
            int count = listWidgets.count();
            for (int i = 0; i &amp;lt; count; i++) {
                QIcon icon = listWidgets.at(i)-&amp;gt;icon();
                QString className = listWidgets.at(i)-&amp;gt;name();
                QListWidgetItem *item = new QListWidgetItem(ui-&amp;gt;listWidget);
                item-&amp;gt;setText(className);
                item-&amp;gt;setIcon(icon);
                listNames &amp;lt;&amp;lt; className;
            }
        }
        //获取所有插件的类名
        const QObjectList objList = plugin-&amp;gt;children();
        foreach (QObject *obj, objList) {
            QString className = obj-&amp;gt;metaObject()-&amp;gt;className();
            //qDebug() &amp;lt;&amp;lt; className;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63094/201809/63094-20180923222923548-714419166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步：实例化new出控件并放到窗体。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拿到了所有的控件，前面还有个对应控件的小图标，是不是又有点小激动呢，接下来就是怎么双击或者拖动该控件到界面上立马实例化一个控件出来。上一步我们将所有控件放到了一个链表变量&lt;strong&gt;listWidgets&lt;/strong&gt;中，该变量在头文件中定义如下：&lt;/p&gt;
&lt;p&gt;QList&amp;lt;QDesignerCustomWidgetInterface *&amp;gt; &lt;strong&gt;listWidgets&lt;/strong&gt;; &lt;/p&gt;
&lt;p&gt;这里写了个函数，传入列表中控件的索引，即该类的索引位置，和控件默认要放置的坐标，即可在主界面生成该控件。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void frmMain::newWidget(int row, const QPoint &amp;amp;point)
{
    //列表按照同样的索引生成的,所以这里直接对该行的索引就行
    QWidget *widget = listWidgets.at(row)-&amp;gt;createWidget(ui-&amp;gt;centralwidget);
    widget-&amp;gt;move(point);
    widget-&amp;gt;resize(widget-&amp;gt;sizeHint());
    //实例化选中窗体跟随控件一起
    newSelect(widget);
    //立即执行获取焦点以及设置属性
    widgetPressed(widget);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第五步：动态绑定控件到设计器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一步就比较轻松了，上面提到过，直接获取当前界面上选中的是哪个控件，遍历可以得到，然后设置object到属性设计器控件即可。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void frmMain::clearFocus()
{
    //将原有焦点窗体全部设置成无焦点
    foreach (SelectWidget *widget, selectWidgets) {
        widget-&amp;gt;setDrawPoint(false);
    }
} 

void frmMain::widgetPressed(QWidget *widget)
{
    //清空所有控件的焦点
    clearFocus();
    //设置当前按下的控件有焦点
    foreach (SelectWidget *w, selectWidgets) {
        if (w-&amp;gt;getWidget() == widget) {
            w-&amp;gt;setDrawPoint(true);
            break;
        }
    }
    //设置自动加载该控件的所有属性
    ui-&amp;gt;objectController-&amp;gt;setObject(widget);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第六步：导入导出控件属性到xml文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一步比较难，本人也是花了好几个小时才搞定，前后折腾了好多次，因为遇到好几个棘手的问题，比如有些自定义控件中其实里边封装了Qt自带的控件例如QPushButton等，如果遍历控件设计窗体的所有控件，也会把该控件也遍历进去，所以要做过滤处理。&lt;/p&gt;
&lt;p&gt;导入xml数据自动生成控件代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void frmMain::openFile(const QString &amp;amp;fileName)
{
    //打开文件
    QFile file(fileName);
    if (!file.open(QFile::ReadOnly | QFile::Text)) {
        return;
    }

    //将文件填充到dom容器
    QDomDocument doc;
    if (!doc.setContent(&amp;amp;file)) {
        file.close();
        return;
    }
    file.close();
    //先清空原有控件
    QList&amp;lt;QWidget *&amp;gt; widgets = ui-&amp;gt;centralwidget-&amp;gt;findChildren&amp;lt;QWidget *&amp;gt;();
    qDeleteAll(widgets);
    widgets.clear();
    //先判断根元素是否正确
    QDomElement docElem = doc.documentElement();
    if (docElem.tagName() == &quot;canvas&quot;) {
        QDomNode node = docElem.firstChild();
        QDomElement element = node.toElement();
        while(!node.isNull()) {
            QString name = element.tagName();
            //存储坐标+宽高
            int x, y, width, height;
            //存储其他自定义控件属性
            QList&amp;lt;QPair&amp;lt;QString, QVariant&amp;gt; &amp;gt; propertys;
            //节点名称不为空才继续
            if (!name.isEmpty()) {
                //遍历节点的属性名称和属性值
                QDomNamedNodeMap attrs = element.attributes();
                for (int i = 0; i &amp;lt; attrs.count(); i++) {
                    QDomNode n = attrs.item(i);
                    QString nodeName = n.nodeName();
                    QString nodeValue = n.nodeValue();
                    //qDebug() &amp;lt;&amp;lt; nodeName &amp;lt;&amp;lt; nodeValue;
                    //优先取出坐标+宽高属性,这几个属性不能通过setProperty实现
                    if (nodeName == &quot;x&quot;) {
                        x = nodeValue.toInt();
                    } else if (nodeName == &quot;y&quot;) {
                        y = nodeValue.toInt();
                    } else if (nodeName == &quot;width&quot;) {
                        width = nodeValue.toInt();
                    } else if (nodeName == &quot;height&quot;) {
                        height = nodeValue.toInt();
                    } else {
                        propertys.append(qMakePair(nodeName, QVariant(nodeValue)));
                    }
                }
            }
            //qDebug() &amp;lt;&amp;lt; name &amp;lt;&amp;lt; x &amp;lt;&amp;lt; y &amp;lt;&amp;lt; width &amp;lt;&amp;lt; height;
            //根据不同的控件类型实例化控件
            int count = listWidgets.count();
            for (int i = 0; i &amp;lt; count; i++) {
                QString className = listWidgets.at(i)-&amp;gt;name();
                if (name == className) {
                    QWidget *widget = listWidgets.at(i)-&amp;gt;createWidget(ui-&amp;gt;centralwidget);

                    //逐个设置自定义控件的属性
                    int count = propertys.count();
                    for (int i = 0; i &amp;lt; count; i++) {
                        QPair&amp;lt;QString, QVariant&amp;gt; property = propertys.at(i);
                        widget-&amp;gt;setProperty(property.first.toLatin1().constData(), property.second);
                    }
                    //设置坐标+宽高
                    widget-&amp;gt;setGeometry(x, y, width, height);
                    //实例化选中窗体跟随控件一起
                    newSelect(widget);
                    break;
                }
            }
            //移动到下一个节点
            node = node.nextSibling();
            element = node.toElement();
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导出所有控件到xml文件代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void frmMain::saveFile(const QString &amp;amp;fileName)
{
    QFile file(fileName);
    if (!file.open(QFile::WriteOnly | QFile::Text | QFile::Truncate)) {
        return;
    }
    //以流的形式输出文件
    QTextStream stream(&amp;amp;file);
    //构建xml数据
    QStringList list;
    //添加固定头部数据
    list &amp;lt;&amp;lt; &quot;&amp;lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&amp;gt;&quot;;
    list &amp;lt;&amp;lt; QString(&quot;&amp;lt;canvas width=\&quot;%1\&quot; height=\&quot;%2\&quot;&amp;gt;&quot;)
         .arg(ui-&amp;gt;centralwidget-&amp;gt;width()).arg(ui-&amp;gt;centralwidget-&amp;gt;height());
    //从容器中找到所有控件,根据控件的类名保存该类的所有属性
    QList&amp;lt;QWidget *&amp;gt; widgets = ui-&amp;gt;centralwidget-&amp;gt;findChildren&amp;lt;QWidget *&amp;gt;();
    foreach (QWidget *w, widgets) {
        const QMetaObject *metaObject = w-&amp;gt;metaObject();
        QString className = metaObject-&amp;gt;className();
        QStringList values;
        //如果当前控件的父类不是主窗体则无需导出,有些控件有子控件无需导出
        if (w-&amp;gt;parent() != ui-&amp;gt;centralwidget || className == &quot;SelectWidget&quot;) {
            continue;
        }
        //metaObject-&amp;gt;propertyOffset()表示当前控件的属性开始索引,0开始的是父类的属性
        int index = metaObject-&amp;gt;propertyOffset();
        for (int i = index; i &amp;lt; metaObject-&amp;gt;propertyCount(); i++) {
            QMetaProperty p = metaObject-&amp;gt;property(i);
            QString nodeName = p.name();
            QVariant nodeValue = p.read(w);
            //枚举值要特殊处理,需要以字符串形式写入,不然存储到配置文件数据为int
            if (p.isEnumType()) {
                QMetaEnum enumValue = p.enumerator();
                nodeValue = enumValue.valueToKey(nodeValue.toInt());
            }
            QString temp = nodeValue.toString().toLocal8Bit().constData();
            values &amp;lt;&amp;lt; QString(&quot;%1=\&quot;%2\&quot;&quot;).arg(nodeName).arg(temp);
            //qDebug() &amp;lt;&amp;lt; nodeName &amp;lt;&amp;lt; nodeValue;
        }
        //逐个添加界面上的控件的属性
        QString str = QString(&quot;\t&amp;lt;%1 x=\&quot;%2\&quot; y=\&quot;%3\&quot; width=\&quot;%4\&quot; height=\&quot;%5\&quot; %6/&amp;gt;&quot;)
                      .arg(className).arg(w-&amp;gt;x()).arg(w-&amp;gt;y()).arg(w-&amp;gt;width()).arg(w-&amp;gt;height()).arg(values.join(&quot; &quot;));
        list &amp;lt;&amp;lt; str;
    }
    //添加固定尾部数据
    list &amp;lt;&amp;lt; &quot;&amp;lt;/canvas&amp;gt;&quot;;
    //写入文件
    QString data = list.join(&quot;\n&quot;);
    stream &amp;lt;&amp;lt; data;
    file.close();}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　xml数据格式效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63094/201809/63094-20180923223212606-1899107717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63094/201809/63094-20180923223223479-1621112591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后分享一些自己整理好的Qt开发过程中的小技巧，Qt武林秘籍。&lt;/p&gt;
&lt;p&gt;1：当编译发现大量错误的时候，从第一个看起，一个一个的解决，不要急着去看下一个错误，往往后面的错误都是由于前面的错误引起的，第一个解决后很可能都解决了。&lt;/p&gt;
&lt;p&gt;2：定时器是个好东西，学会好使用它，有时候用QTimer::singleShot可以解决意想不到的问题。&lt;/p&gt;
&lt;p&gt;3：打开creator，在构建套件的环境中增加MAKEFLAGS=-j8，可以不用每次设置多线程编译。珍爱时间和生命。&lt;/p&gt;
&lt;p&gt;4：如果你想顺利用QtCreator部署安卓程序，首先你要在AndroidStudio 里面配置成功，把坑全部趟平。&lt;/p&gt;
&lt;p&gt;5：很多时候找到Qt对应封装的方法后，记得多看看该函数的重载，多个参数的，你会发现不一样的世界，有时候会恍然大悟，原来Qt已经帮我们封装好了。&lt;/p&gt;
&lt;p&gt;6：可以在pro文件中写上标记版本号+ico图标&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
VERSION             = 2018.7.25
win32:RC_ICONS      = main0.ico 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7：管理员运行程序，限定在MSVC编译器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
QMAKE_LFLAGS += /MANIFESTUAC:\&quot;level=\'requireAdministrator\' uiAccess=\'false\'\&quot; #以管理员运行
QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,\&quot;5.01\&quot; #VS2013 在XP运行 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8：运行文件附带调试输出窗口，有时候程序双击了没有反应，这样可以很方便的知道哪里出了问题。&lt;/p&gt;
&lt;p&gt;CONFIG += console pro &lt;/p&gt;
&lt;p&gt;9：绘制平铺背景QPainter::drawTiledPixmap&lt;/p&gt;
&lt;p&gt;绘制圆角矩形QPainter::drawRoundedRect(),而不是QPainter::drawRoundRect(); &lt;/p&gt;
&lt;p&gt;10：移除旧的样式&lt;/p&gt;
&lt;p&gt;style()-&amp;gt;unpolish(ui-&amp;gt;btn);&lt;/p&gt;
&lt;p&gt;重新设置新的该控件的样式。&lt;/p&gt;
&lt;p&gt;style()-&amp;gt;polish(ui-&amp;gt;btn); &lt;/p&gt;
&lt;p&gt;11：获取类的属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
const QMetaObject *metaobject = object-&amp;gt;metaObject();
int count = metaobject-&amp;gt;propertyCount();
for (int i = 0; i &amp;lt; count; ++i) {
    QMetaProperty metaproperty = metaobject-&amp;gt;property(i);
    const char *name = metaproperty.name();
    QVariant value = object-&amp;gt;property(name);
    qDebug() &amp;lt;&amp;lt; name &amp;lt;&amp;lt; value;
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;12：Qt内置图标封装在QStyle中，总共七十多个，可以直接拿来用。&lt;/p&gt;
&lt;p&gt;QStyle :: SP_TitleBarMenuButton &lt;/p&gt;
&lt;p&gt;13：根据操作系统位数判断加载&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
win32 {
    contains(DEFINES, WIN64) {
        DESTDIR = $${PWD}/../../bin64
    } else {
        DESTDIR = $${PWD}/../../bin32
    }
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;14：Qt5增强了很多安全性验证，如果出现setGeometry: Unable to set geometry，请将该控件的可见移到加入布局之后。&lt;/p&gt;
&lt;p&gt;15：可以将控件A添加到布局，然后控件B设置该布局，这种灵活性大大提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
QPushButton *btn = new QPushButton;
btn-&amp;gt;resize(30, ui-&amp;gt;lineEdit-&amp;gt;height());
QHBoxLayout *layout = new QHBoxLayout(ui-&amp;gt;lineEdit);
layout-&amp;gt;setMargin(0);
layout-&amp;gt;addStretch();
layout-&amp;gt;addWidget(btn);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;16：对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat。&lt;/p&gt;
&lt;p&gt;17：巧妙的使用findChildren可以查找该控件下的所有子控件。findChild为查找单个。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
//查找指定类名objectName的控件
QList&amp;lt;QWidget *&amp;gt; widgets = parentWidget.findChildren&amp;lt;QWidget *&amp;gt;(&quot;widgetname&quot;);
//查找所有QPushButton
QList&amp;lt;QPushButton *&amp;gt; allPButtons = parentWidget.findChildren&amp;lt;QPushButton *&amp;gt;();
//查找一级子控件,不然会一直遍历所有子控件
QList&amp;lt;QPushButton *&amp;gt; childButtons = parentWidget.findChildren&amp;lt;QPushButton *&amp;gt;(QString(), Qt::FindDirectChildrenOnly);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;18：巧妙的使用inherits判断是否属于某种类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
QTimer *timer = new QTimer;         // QTimer inherits QObject
timer-&amp;gt;inherits(&quot;QTimer&quot;);          // returns true
timer-&amp;gt;inherits(&quot;QObject&quot;);         // returns true
timer-&amp;gt;inherits(&quot;QAbstractButton&quot;); // returns false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;19：使用弱属性机制，可以存储临时的值用于传递判断。 &lt;/p&gt;
&lt;p&gt;20：如果遇到问题搜索Qt方面找不到答案，试着将关键字用JAVA C# android打头，你会发现别有一番天地，其他人很可能做过！&lt;/p&gt;
</description>
<pubDate>Sun, 23 Sep 2018 14:34:00 +0000</pubDate>
<dc:creator>飞扬青云</dc:creator>
<og:description>以前做.NET开发中，.NET直接就集成了属性设计器，VS不愧是宇宙第一IDE，你能够想到的都给你封装好了，用起来不要太爽！因为项目需要自从全面转Qt开发已经6年有余，在工业控制领域，有一些应用场景需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feiyangqingyun/p/9694025.html</dc:identifier>
</item>
<item>
<title>Entitiy Framework Core中使用ChangeTracker持久化实体修改历史 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9693970.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9693970.html</guid>
<description>&lt;p&gt;在我们的日常开发中，有时候需要记录数据库表中值的变化, 这时候我们通常会使用触发器或者使用关系型数据库中临时表(Temporal Table)或数据变更捕获(Change Data Capture)特性来记录数据库表中字段的值变化。原文的作者Gérald Barré讲解了如何使用Entity Freamwork Core上下文中的ChangeTracker来获取并保存实体的变化记录。&lt;/p&gt;
&lt;blockquote readability=&quot;1.140350877193&quot;&gt;
&lt;p&gt;原文链接 &lt;a href=&quot;https://www.meziantou.net/2017/08/14/entity-framework-core-history-audit-table&quot;&gt;Entity Framework Core: History / Audit table&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ChangeTracker是Entity Framework Core记录实体变更的核心对象(这一点和以前版本的Entity Framework一致)。当你使用Entity Framework Core进行获取实体对象、添加实体对象、删除实体对象、更新实体对象、附加实体对象等操作时，ChangeTracker都会记录下来对应的实体引用和对应的实体状态。&lt;br/&gt;我们可以通过&lt;code&gt;ChangeTracker.Entries()&lt;/code&gt;方法, 获取到当前上下文中使用的所有实体对象, 以及每个实体对象的状态属性State。&lt;/p&gt;
&lt;p&gt;Entity Framework Core中可用的实体状态属性有以下几种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Detached&lt;/li&gt;
&lt;li&gt;Unchanged&lt;/li&gt;
&lt;li&gt;Deleted&lt;/li&gt;
&lt;li&gt;Modified&lt;/li&gt;
&lt;li&gt;Added&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以如果我们要记录实体的变更，只需要从ChangeTracker中取出所有Added, Deleted, Modified状态的实体, 并将其记录到一个日志表中即可。&lt;/p&gt;

&lt;p&gt;我们以下面这个例子为例。&lt;br/&gt;当前我们有一个顾客表Customer和一个日志表Audit, 其对应的实体对象及Entity Framework上下文如下：&lt;/p&gt;
&lt;h4 id=&quot;audit.cs&quot;&gt;Audit.cs&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    [Table(&quot;Audit&quot;)]
    public class Audit
    {
        [Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Id { get; set; }

        public string TableName { get; set; }

        public DateTime DateTime { get; set; }

        public string KeyValues { get; set; }

        public string OldValues { get; set; }

        public string NewValues { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;customer.cs&quot;&gt;Customer.cs&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    [Table(&quot;Customer&quot;)]
    public class Customer
    {
        [Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Id { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;samplecontext.cs&quot;&gt;SampleContext.cs&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    public class SampleContext : DbContext
    {
        public SampleContext()
        {

        }

        public DbSet&amp;lt;Customer&amp;gt; Customers { get; set; }

        public DbSet&amp;lt;Audit&amp;gt; Audits { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们希望当执行以下代码之后, 在Audit表中产生如下数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    class Program
    {
        static void Main(string[] args)
        {
            using (var context = new SampleContext())
            {
                // Insert a row
                var customer = new Customer();
                customer.FirstName = &quot;John&quot;;
                customer.LastName = &quot;doe&quot;;
                context.Customers.Add(customer);
                context.SaveChangesAsync().Wait();

                // Update the first customer
                customer.LastName = &quot;Doe&quot;;
                context.SaveChangesAsync().Wait();

                // Delete the customer
                context.Customers.Remove(customer);
                context.SaveChangesAsync().Wait();
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201809/65831-20180923221903307-121244645.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;复写上下文savechangeasync方法&quot;&gt;复写上下文SaveChangeAsync方法&lt;/h2&gt;
&lt;p&gt;首先我们添加一个AuditEntry类, 来生成变更记录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class AuditEntry
    {
        public AuditEntry(EntityEntry entry)
        {
            Entry = entry;
        }

        public EntityEntry Entry { get; }
        public string TableName { get; set; }
        public Dictionary&amp;lt;string, object&amp;gt; KeyValues { get; } = new Dictionary&amp;lt;string, object&amp;gt;();
        public Dictionary&amp;lt;string, object&amp;gt; OldValues { get; } = new Dictionary&amp;lt;string, object&amp;gt;();
        public Dictionary&amp;lt;string, object&amp;gt; NewValues { get; } = new Dictionary&amp;lt;string, object&amp;gt;();
        public List&amp;lt;PropertyEntry&amp;gt; TemporaryProperties { get; } = new List&amp;lt;PropertyEntry&amp;gt;();

        public bool HasTemporaryProperties =&amp;gt; TemporaryProperties.Any();

        public Audit ToAudit()
        {
            var audit = new Audit();
            audit.TableName = TableName;
            audit.DateTime = DateTime.UtcNow;
            audit.KeyValues = JsonConvert.SerializeObject(KeyValues);
            audit.OldValues = OldValues.Count == 0 ? null : JsonConvert.SerializeObject(OldValues);
            audit.NewValues = NewValues.Count == 0 ? null : JsonConvert.SerializeObject(NewValues);
            return audit;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;代码解释&quot;&gt;代码解释&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;Entry属性表示变更的实体&lt;/li&gt;
&lt;li&gt;TableName属性表示实体对应的数据库表名&lt;/li&gt;
&lt;li&gt;KeyValues属性表示所有的主键值&lt;/li&gt;
&lt;li&gt;OldValues属性表示当前实体所有变更属性的原始值&lt;/li&gt;
&lt;li&gt;NewValues属性表示当前实体所有变更属性的新值&lt;/li&gt;
&lt;li&gt;TemporaryProperties属性表示当前实体所有由数据库生成的属性集合&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后我们打开SampleContext.cs, 复写方法SaveChangeAsync代码如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public override async Task&amp;lt;int&amp;gt; SaveChangesAsync(bool acceptAllChangesOnSuccess, CancellationToken cancellationToken = default(CancellationToken))
    {
        var auditEntries = OnBeforeSaveChanges();
        var result = await base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
        await OnAfterSaveChanges(auditEntries);
        return result;
    }
    
    private List&amp;lt;AuditEntry&amp;gt; OnBeforeSaveChanges()
    {
        throw new NotImplementedException();
    }

    private Task OnAfterSaveChanges(List&amp;lt;AuditEntry&amp;gt; auditEntries)
    {
        throw new NotImplementedException();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;代码解释-1&quot;&gt;代码解释&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;这里我们添加了2个方法&lt;code&gt;OnBeforeSaveChange()&lt;/code&gt;和&lt;code&gt;OnAfterSaveChanges&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OnBeforeSaveChanges&lt;/code&gt;是用来获取所有需要记录的实体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OnAfterSaveChanges&lt;/code&gt;是为了获得实体中数据库生成列的新值(例如自增列, 计算列)并持久化变更记录, 这一步必须放置在调用父类&lt;code&gt;SaveChangesAsync&lt;/code&gt;之后，因为只有持久化之后，才能获取自增列和计算列的新值。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;OnBeforeSaveChange&lt;/code&gt;方法之后，&lt;code&gt;OnAfterSaveChanges&lt;/code&gt;方法之前, 我们调用父类的&lt;code&gt;SaveChangesAsync&lt;/code&gt;来保存实体变更。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后我们来修改&lt;code&gt;OnBeforeSaveChanges&lt;/code&gt;方法, 代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private List&amp;lt;AuditEntry&amp;gt; OnBeforeSaveChanges()
    {
        ChangeTracker.DetectChanges();
        var auditEntries = new List&amp;lt;AuditEntry&amp;gt;();
        foreach (var entry in ChangeTracker.Entries())
        {
            if (entry.Entity is Audit || entry.State == EntityState.Detached || entry.State == EntityState.Unchanged)
                continue;
    
            var auditEntry = new AuditEntry(entry);
            auditEntry.TableName = entry.Metadata.Relational().TableName;
            auditEntries.Add(auditEntry);
    
            foreach (var property in entry.Properties)
            {
                if (property.IsTemporary)
                {
                    // value will be generated by the database, get the value after saving
                    auditEntry.TemporaryProperties.Add(property);
                    continue;
                }
    
                string propertyName = property.Metadata.Name;
                if (property.Metadata.IsPrimaryKey())
                {
                    auditEntry.KeyValues[propertyName] = property.CurrentValue;
                    continue;
                }
    
                switch (entry.State)
                {
                    case EntityState.Added:
                        auditEntry.NewValues[propertyName] = property.CurrentValue;
                        break;
    
                    case EntityState.Deleted:
                        auditEntry.OldValues[propertyName] = property.OriginalValue;
                        break;
    
                    case EntityState.Modified:
                        if (property.IsModified)
                        {
                            auditEntry.OldValues[propertyName] = property.OriginalValue;
                            auditEntry.NewValues[propertyName] = property.CurrentValue;
                        }
                        break;
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;代码解释-2&quot;&gt;代码解释&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ChangeTracker.DetectChanges()&lt;/code&gt;是强制上下文再做一次变更检查&lt;/li&gt;
&lt;li&gt;由于Audit表也在ChangeTracker的管理中, 所以在&lt;code&gt;OnBeforeSaveChanges&lt;/code&gt;方法中，我们需要将Audit表的实体排除掉，否则会出现死循环&lt;/li&gt;
&lt;li&gt;这里我们只需要操作所有Added, Modified, Deleted状态的实体，所以Detached和Unchanged状态的实体需要排除掉&lt;/li&gt;
&lt;li&gt;ChangeTracker中记录的每个实体都有一个&lt;code&gt;Properties&lt;/code&gt;集合，里面记录的每个实体所有属性的状态, 如果某个属性被修改了，则该属性的&lt;code&gt;IsModified&lt;/code&gt;是true.&lt;/li&gt;
&lt;li&gt;实体属性Property对象中的&lt;code&gt;IsTemporary&lt;/code&gt;属性表明了该字段是不是数据库生成的。 我们将所有数据库生成的属性放到了&lt;code&gt;TemplateProperties&lt;/code&gt;集合中，供&lt;code&gt;OnAfterSaveChanges&lt;/code&gt;方法遍历&lt;/li&gt;
&lt;li&gt;我们可以通过Property对象的&lt;code&gt;Metadata.IsPrimaryKey()&lt;/code&gt;方法来获得当前字段是不是主键字段&lt;/li&gt;
&lt;li&gt;Property对象的CurrentValue属性表示当前字段的新值，OriginalValue属性表示当前字段的原始值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后我们修改一下&lt;code&gt;OnAfterSaveChanges&lt;/code&gt;, 代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private Task OnAfterSaveChanges(List&amp;lt;AuditEntry&amp;gt; auditEntries)
    {
        if (auditEntries == null || auditEntries.Count == 0)
            return Task.CompletedTask;


        foreach (var auditEntry in auditEntries)
        {
            // Get the final value of the temporary properties
            foreach (var prop in auditEntry.TemporaryProperties)
            {
                if (prop.Metadata.IsPrimaryKey())
                {
                    auditEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
                }
                else
                {
                    auditEntry.NewValues[prop.Metadata.Name] = prop.CurrentValue;
                }
            }

            // Save the Audit entry
            Audits.Add(auditEntry.ToAudit());
        }

        return SaveChangesAsync();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;代码解释-3&quot;&gt;代码解释&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;在&lt;code&gt;OnBeforeSaveChanges&lt;/code&gt;中，我们记录下了当前实体所有需要数据库生成的属性。 在调用父类的&lt;code&gt;SaveChangesAsync&lt;/code&gt;方法, 我们可以获取通过property的&lt;code&gt;CurrentValue&lt;/code&gt;属性获得到这些数据库生成属性的新值&lt;/li&gt;
&lt;li&gt;记录下新值，之后我们生成变更实体记录Audit，并添加到上下文中，再次调用SaveChangesAsync方法，将其持久化&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;这个方案中，整个数据库持久化并不在一个原子事务中，我们都知道Entity Framework的SaveChangesAsync方法是自带事务的，但是调用2次SaveChangeAsync就不是一个事务作用域了，可能出现实体保存成功，Audit实体保存失败的情况&lt;/li&gt;
&lt;li&gt;由于调用了2次SaveChangeAsync方法，所以Audit实体中的DateTime属性并不能确切的反映保存实体操作的真正时间, 中间间隔了第一次SaveChangeAsync花费的时间(个人认为在&lt;code&gt;OnBeforeSaveChanges&lt;/code&gt;中就可以生成这个DateTime让时间更精确一些)&lt;/li&gt;
&lt;li&gt;如果所有实体属性值都是预生成的，非数据库生成的，作者这个方案还是非常好的，但是如果有数据库自增列或计算列, 还是使用关系型数据库中临时表(Temporal Table)或数据变更捕获(Change Data Capture)特性比较合理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/lamondlu/EntityFrameworkCoreAuditSample&quot;&gt;本篇源代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 23 Sep 2018 14:33:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>背景介绍 在我们的日常开发中，有时候需要记录数据库表中值的变化, 这时候我们通常会使用触发器或者使用关系型数据库中临时表(Temporal Table)或数据变更捕获(Change Data Capt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9693970.html</dc:identifier>
</item>
</channel>
</rss>