<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>第四次大作业-用户调研及结论 - 17级软件工程1班5组</title>
<link>http://www.cnblogs.com/hustsoftware1701/p/8138313.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hustsoftware1701/p/8138313.html</guid>
<description>&lt;p&gt;　　最近，小组同学们在紧张的复习期间，抽出时间完成了第二阶段的任务：对于博客网的用户调研，并总结分析得出结论。以下，将从4个部分去展示这一次的小组工作，分别是&lt;/p&gt;
&lt;p&gt;　　1对象的背景和需求&lt;/p&gt;
&lt;p&gt;　　2对面使用产品&lt;/p&gt;
&lt;p&gt;　　3使用过程&lt;/p&gt;
&lt;p&gt;　　4分析和建议&lt;/p&gt;
&lt;p&gt;然后最后部分是总结相关。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;对象的背景和需求&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　本次采访对象是一位计算机专业的同学,在几年前曾在老师的推荐下使用过博客园产品,注册了账号想通过阅读博客上的相关知识提高自己的专业技能,后来因为觉得一直要寻找自己需要的博客很麻烦,以及部分自身原因,就搁置了使用博客园学习的计划。&lt;/p&gt;
&lt;p&gt;　　对象的需求是重新使用博客园产品，查找自己需要的知识。同时体验班级博客的功能，查找同学和查看班级动态。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;对象使用产品&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;采访对象正在使用博客园产品：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1278710/201712/1278710-20171228233118694-133448729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;使用过程&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　(1)由于被采访对象在之前就注册过博客园的帐号，因此直接使用当初注册的账户进行登录。但在登录时却遇到了问题，该同学尝试在用户名栏填入邮箱地址，以及输入密码进行验证后进行登录，系统却提示：用户名不存在！但是该同学十分确定自己当初就是使用这个邮箱地址进行的注册，输入的密码也绝对是正确的，不明白为何会出现这种情况。&lt;/p&gt;
&lt;p&gt;于是我告诉她，博客园仅支持通过用户名进行登录，所以要输入当初注册时填写的用户名。同学表示很无奈：“当初注册时系统一直提示用户名重复，最后随便输入了一串字符才注册成功，随便输的我哪能记得那么清楚？”我回答可以找回用户名的。同学哀怨：“怎么这么麻烦！登录淘宝系统的时候输手机号用户名支付宝帐号都能登录，这个怎么只能输入用户名！”&lt;/p&gt;
&lt;p&gt;在点击“找回”链接后，在页面中又输入了自己的邮箱地址，系统提示“用户名已经发至您的邮箱。”然后同学登录邮箱这才找到了自己的用户名，登录成功了。光是登录就花费了五六分钟。&lt;/p&gt;
&lt;p&gt; 　　(2)登录进入主页后，该同学想找一篇关于SSH框架的博文，在“找一找”中搜索“SSH”后，出现了66499篇博文，同学一下子选择困难症了，不知道从何看起。我说你可以选择查看被推荐数高的。同学：“那我按被推荐数由高到低排序吧！应该点哪排序？”我：“好像没有这个功能。”同学：“淘宝都能按销量排序。博客就不能加一个按推荐数排序的功能吗？要不然我一个个的对比多麻烦。”&lt;/p&gt;
&lt;p&gt;　　(3)该同学想要搜索另一位同学并关注，但是找了半天没找到搜索人的按钮，每次搜索出来的都是相关博客。最后在点击关注 “0”后跳转的页面右下角才看到有搜索园友的按钮。&lt;/p&gt;
&lt;p&gt;　　(4)该同学点击关注园友后，想要查看园友所在的班级，但是却无法在其个人中心找到所属班级，也没有“该园友未加入班级”的提示。后来她在主页点击班级按钮后发现有搜索框，我让她输入“软件测试”，结果中有显示我们的班级，也能看到班级中有哪些学生。原来博客园仅支持通过班级找园友，而不能通过园友得知该园友所在的班级。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;分析与建议&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　（1）    既然是通过邮箱来和用户进行绑定，能否也能使用邮箱地址进行登录，而不是一定要使用注册时的用户名。毕竟邮箱地址不会被忘记，而用户名很容易被遗忘。&lt;/p&gt;
&lt;p&gt;　　（2）    一个用户两个昵称（登录名称和显示名称），很容易让人混淆，有点画蛇添足。能否合二为一便于用户记忆？&lt;/p&gt;
&lt;p&gt;　　（3）    搜索自己想找的园友实在是很麻烦，能否把查找园友按钮放在主界面的一个板块？&lt;/p&gt;
&lt;p&gt;　　（4）    能否设置查看自己所关注的园友所在班级的功能？&lt;/p&gt;

&lt;p&gt;　　经过以上工作，我们对博客园产品的评价是(c)一般。除了这个定性结论，还给出定量结论如表3-1所示。其中每栏的评分标准是：满分10分,良好8分,及格6分，较差3分，聊胜于无1分,很差-3分。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;表3-1 定量分析&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;104&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;142&quot;&gt;
&lt;p&gt;类别&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;402&quot;&gt;
&lt;p align=&quot;center&quot;&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;63&quot;&gt;
&lt;p&gt;评分&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td rowspan=&quot;6&quot; valign=&quot;top&quot; width=&quot;104&quot;&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;功能&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;142&quot;&gt;
&lt;p&gt;核心功能&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;402&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;发表博文、搜索查看博文、评价博文等功能良好&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;63&quot;&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;142&quot;&gt;
&lt;p&gt;细节&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;402&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;如设置两个昵称，很多余&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;63&quot;&gt;
&lt;p&gt;-3&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;142&quot;&gt;
&lt;p&gt;用户体验&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;402&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;没有不断弹出的广告，按钮设置不太合理&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;63&quot;&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;142&quot;&gt;
&lt;p&gt;辅助功能&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;402&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;可以在个人中心查看新闻、招聘信息等&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;63&quot;&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;142&quot;&gt;
&lt;p&gt;差异化功能&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;402&quot;&gt;
&lt;p&gt;班级功能的设置&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;63&quot;&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;142&quot;&gt;
&lt;p&gt;系统的效能&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;402&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;启动速度快，能快速响应用户请求&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;63&quot;&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td rowspan=&quot;3&quot; valign=&quot;top&quot; width=&quot;104&quot;&gt;

&lt;p align=&quot;center&quot;&gt;体验&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;142&quot;&gt;
&lt;p&gt;软件的适应性&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;402&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;断网时无法使用，没有鼠标不能流畅操作&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;63&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;142&quot;&gt;
&lt;p&gt;成长性&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;402&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;未设置记住用户的选择的功能&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;63&quot;&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;142&quot;&gt;
&lt;p&gt;用户有控制权&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;402&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;用户的操作有误时，系统有部分提示&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;63&quot;&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;104&quot;&gt;
&lt;p align=&quot;center&quot;&gt;其它&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;142&quot;&gt;
&lt;p&gt;界面美观度&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;402&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;搜索博文的结果界面不够简洁&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;63&quot;&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Thu, 28 Dec 2017 15:33:00 +0000</pubDate>
<dc:creator>17级软件工程1班5组</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hustsoftware1701/p/8138313.html</dc:identifier>
</item>
<item>
<title>SQL Server-聚焦ROW_NUMBER VS TOP N性能 - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/8138248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/8138248.html</guid>
<description>&lt;p&gt;抱歉各位，从八月份开始一直在着手写EntityFramework 6.x和EntityFramework Core 2.0的书籍写作，所以最近一直遗漏了对博客的管理，后面会着手于写SQL Server、EntityFramework Core和.NET Core方面的博客。我们知道如果需要查询前N行数据，除了可以利用TOP N进行查询外，同样也可以利用ROW_NUMBER来达到同样的效果，那么二者使用哪个性能会更好呢？下面我们来比较下。&lt;/p&gt;
&lt;h2&gt;ROW_NUMBER VS TOP N&lt;/h2&gt;
&lt;p&gt;我们利用AdventureWorks2012示例库中的Production.Product表来进行演示，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DBCC&lt;/span&gt;&lt;span&gt; DROPCLEANBUFFERS()
&lt;/span&gt;&lt;span&gt;DBCC&lt;/span&gt;&lt;span&gt; FREEPROCCACHE()
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt;ROW_NUMBER QUERY&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; ProductID
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; ProductID, ROW_NUMBER() &lt;span&gt;OVER&lt;/span&gt; (&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; ProductID) &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; RN
    &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; Production.Product
    ) &lt;/span&gt;&lt;span&gt;AS&lt;/span&gt;&lt;span&gt; T
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; T.RN &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; TOP N QUERY&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; 
    &lt;span&gt;TOP&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt; ProductID
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; Production.Product
&lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt; ProductID
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201712/589642-20171228224331491-373195070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所知，对于这两个查询计划的成本是一样的，都为50%。 如果我们要检查在两个聚集索引扫描操作符中读取的估计行数，那么我们会注意到两者都显示相同的值，即100。可以说聚集索引扫描的估计和实际行数是相同的都是100，如下。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201712/589642-20171228224514959-1767680874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是就以此说明二者性能是一样的呢？稍等片刻，接下来我们将查询基数再设置大一点看看，比如1000而不再是100，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DBCC&lt;/span&gt;&lt;span&gt; DROPCLEANBUFFERS()
&lt;/span&gt;&lt;span&gt;DBCC&lt;/span&gt;&lt;span&gt; FREEPROCCACHE()
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;STATISTICS&lt;/span&gt; IO &lt;span&gt;ON&lt;/span&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;STATISTICS&lt;/span&gt; TIME &lt;span&gt;ON&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;ROW_NUMBER QUERY&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; ProductID
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; ProductID, ROW_NUMBER() &lt;span&gt;OVER&lt;/span&gt; (&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; ProductID) &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; RN
    &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; Production.Product
    ) &lt;/span&gt;&lt;span&gt;AS&lt;/span&gt;&lt;span&gt; T
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; T.RN &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;1000&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; TOP N QUERY&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; 
    &lt;span&gt;TOP&lt;/span&gt; &lt;span&gt;1000&lt;/span&gt;&lt;span&gt; ProductID
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; Production.Product
&lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt; ProductID
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201712/589642-20171228224807194-1395725417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从如上截图可以看出，使用ROW_NUMBER进行查询的速度要明显快于TOP N，即29%和71%。 但是，我们还需要在等一下，因为我们在这里看到的成本只是估计成本。 如果操作的估算不准确，那么查询计划估算成本也将不准确。 接下来我们检查两个计划中的聚集索引扫描的属性：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201712/589642-20171228225844366-2138348276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201712/589642-20171228230047850-2137391052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，使用ROW_NUMBER查询的估计行数为100，而实际数量为504，查询计划的估计成本是基于估计的行数所计算得来，即100。我们还是不能够相信估计的计划成本。 我们再来看看统计数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201712/589642-20171228230222147-1590272510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过上面的统计，我们可以根据统计数据而做出最终决定，而不是比较执行计划的估计成本。TOP N的查询性能优于ROW_NUMBER。 &lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;从上比较TOP N和ROW_NUMBER的查询得知，查询计划所得到的成本并不是判断性能的最终依据，只是基础性的判断，我们最终还得集合IO和TIME等来综合判断性能差异。&lt;/p&gt;
</description>
<pubDate>Thu, 28 Dec 2017 15:10:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CreateMyself/p/8138248.html</dc:identifier>
</item>
<item>
<title>Delphi中的RectTracker - 原创 - 呆呆大虾</title>
<link>http://www.cnblogs.com/popapa/p/DXRectTracker.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/popapa/p/DXRectTracker.html</guid>
<description>&lt;p&gt;本文算是副产品，正品是利用FFmpeg从任意视频中生成GIF片段的小程序，写完了就发。&lt;br/&gt;因为要对视频画面进行框选，再生成GIF，所以得有个框选的控件，可Delphi里没有啊，只好自己写一个了。&lt;/p&gt;
&lt;h3 id=&quot;声明&quot;&gt;声明&lt;/h3&gt;
&lt;p&gt;本文参考的是盒子网的&lt;a href=&quot;http://www.2ccc.com/article.asp?articleid=4138&quot;&gt;RectTracker&lt;/a&gt;，原作者署名xwwaw，发布于2007年5月28日。主要的修改之处是增加了边框检测，因为我觉得让选框超出父控件是不合逻辑的。&lt;br/&gt;最开始参考的是Anthony Scott的&lt;a href=&quot;https://torry.net/authorsmore.php?id=532&quot;&gt;TStretchHandle&lt;/a&gt;，可是怎么改都不好用，遂放弃。以下是TStretchHandle的网站介绍截图：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/704105/201712/704105-20171227214752285-1466849522.png&quot;/&gt;&lt;br/&gt;是的，你没看错！TStretchHandle v.2.0在Windows 3.1和Windows 95下测试通过！看到这2个词，我瞬间石化。顿时想起了毕业前去光盘市场淘了张Windows 95的预览版，想着去了工作单位也许能用的上。结果上了班才发现，干活的是Sco Unix，办公还都是Windows 3.2，而且品牌机全都自带操作系统。&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/704105/201712/704105-20171227220518988-1169003129.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是recttracker&quot;&gt;什么是RectTracker&lt;/h2&gt;
&lt;p&gt;直译是“橡皮筋”，窃以为不好理解，还是称其为框选控件，说白了就是在屏幕上画个虚线框供选中区域，8个方向都有可以拉伸的控制柄，类似QQ的屏幕截图功能。在MFC里有个CRectTracker可用，可参考&lt;a href=&quot;http://blog.csdn.net/yueashuxia/article/details/47258231&quot;&gt;CRectTracker源码学习笔记&lt;/a&gt;。&lt;br/&gt;在微软官方的文档&lt;a href=&quot;https://msdn.microsoft.com/library/64f6hkde.aspx&quot;&gt;GetHandleMask&lt;/a&gt;里，8个控制柄是有编号的：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/704105/201712/704105-20171227214949160-1491200765.png&quot;/&gt;&lt;br/&gt;当然我们就不必这么讲究了。&lt;/p&gt;
&lt;h2 id=&quot;主要思路&quot;&gt;主要思路&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;覆盖Paint方法：画框，包括画8个控制柄（小黑块）&lt;/li&gt;
&lt;li&gt;响应WMMouseMove消息：修改光标形状，边界检测（不论移动还是拉伸都不超出父控件），最小尺寸检测&lt;/li&gt;
&lt;li&gt;响应WMLButtonDown消息：开始拖动&lt;/li&gt;
&lt;li&gt;响应WMLButtonUp消息：停止拖动&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;常量&quot;&gt;常量&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;const
  DefaultSize=65;            //默认的控件大小
  DefaultHandleSize=5;  //默认的控制柄大小  
  DefaultBorderWidth=1;//默认的边框宽度（暂时没用，因为超过1就画不出虚线框）&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;主要成员变量&quot;&gt;主要成员变量&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;TDXRectTracker = class(TGraphicControl)
private
  FDragging: boolean;      //是否处于拖动状态（鼠标左键保持按下）
  FHandleSize: integer;    //控制柄大小
  FBorderWidth: integer;  //边框宽度（暂时没用）
  FMinSize: integer;         //控件最小尺寸
  FTrackerType: TMousePosType;  //当前控件拖动类型
  FX,FY: integer;             //当前光标位置（相对于本控件，在拖动状态下可能是负值）&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;paint方法&quot;&gt;Paint方法&lt;/h3&gt;
&lt;p&gt;一图解千惑：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/704105/201712/704105-20171228221229225-1057278437.png&quot;/&gt;&lt;br/&gt;绘制8个控制柄和虚线框还是简单的。但是有一点，如果Pen.Width&amp;gt;1，是无法绘制出虚线的，不知哪位高人能解。&lt;/p&gt;
&lt;h3 id=&quot;wmlbuttondown消息处理&quot;&gt;WMLButtonDown消息处理&lt;/h3&gt;
&lt;p&gt;在收到鼠标左键按下的消息时，表示要启动拖动状态，为后续的WMMouseMove消息处理做准备。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  FDragging:= true;     //启动拖动状态
  Fx:= Message.XPos;  //记录光标当前横位置
  Fy:= Message.YPos;  //记录光标当前纵位置
  FTrackerType:= GetMousePos(Fx, Fy);  //根据光标位置设置鼠标光标类型
  inherited;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本控件全部区域都是可拖动范围，所以鼠标左键按下即表示要开始拖动。如果鼠标位于控制柄上，表示要拉伸边框；如果鼠标位于控件内部，表示要移动整个控件；如果鼠标位于控件之外，则不会接收到鼠标左键按下事件。&lt;/p&gt;
&lt;h3 id=&quot;wmlbuttonup消息处理&quot;&gt;WMLButtonUp消息处理&lt;/h3&gt;
&lt;p&gt;在收到鼠标左键抬起的消息时，表示拖动状态结束，做状态清理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  FDragging:= false;
  Fx:= -1;
  Fy:= -1;
  FTrackerType:= mpOutBox;
  inherited;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;wmmousemove消息&quot;&gt;WMMouseMove消息&lt;/h3&gt;
&lt;p&gt;本控件最“重”的处理就是在MouseMove消息上了。为了能在鼠标拖动边框或整个控件时，能实时显示位置，必须计算出目标位置。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据WMLButtonDown消息处理时记录的光标初始值（Fx, Fy）计算偏移量（dx, dy）；&lt;/li&gt;
&lt;li&gt;根据WMLButtonDown消息处理时记录的拖动类型（FTrackerType）计算控件外框相对于父控件的坐标值（x1, x2, y1, y2）；&lt;/li&gt;
&lt;li&gt;修正控件外框坐标，将控件限制在父控件的Client区域内部，拖动或者拉伸均不能越界。且拉伸也不能小于最小尺寸（FMinSize）；&lt;/li&gt;
&lt;li&gt;根据当前光标位置，设置鼠标光标形状。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以下是最关键的计算控件外框坐标的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  case FTrackerType of
    mpLeft:
      begin
        inc(x1, dx);
      end;
    mpRight:
      begin
        inc(x2, dx);
        Fx:= Message.XPos;
      end;
    mpTop:
      begin
        inc(y1, dy);
      end;
    mpBottom:
      begin
        inc(y2, dy);
        Fy:= Message.YPos;
      end;
    mpLeftTop:
      begin
        inc(x1, dx);
        inc(y1, dy);
      end;
    mpRightBottom:
      begin
        inc(x2, dx);
        inc(y2, dy);
        Fx:= Message.XPos;
        Fy:= Message.YPos;
      end;
    mpLeftBottom:
      begin
        inc(x1, dx);
        inc(y2, dy);
        Fy:= message.YPos;
      end;
    mpRightTop:
      begin
        inc(x2, dx);
        inc(y1, dy);
        Fx:= message.XPos;
      end;
    mpInBox:  //只是移动，不做拉伸
      begin
        inc(x1, dx);
        inc(y1, dy);
        inc(x2, dx);
        inc(y2, dy);
      end;
  end;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，WMMouseMove消息带入的是相对于父控件的坐标，光标坐标（message.XPos, message.YPos）可能会小于0，也可能会大于当前控件的Width及Height值。因为在鼠标保持按下状态时，即使光标位置移出了当前控件的边界，控件仍然会接收到WMMouseMove消息。向左向上移出，坐标就会出现负值。向下向右移出，坐标则会大于当前控件的Width及Height值。以下是示意图：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/704105/201712/704105-20171228221550897-38923510.png&quot;/&gt;&lt;br/&gt;中间是子控件，外围是父控件。&lt;/p&gt;
&lt;h3 id=&quot;源码&quot;&gt;源码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/popapa/DXRectTracker.zip&quot;&gt;DXRectTracker.zip&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Dec 2017 14:20:00 +0000</pubDate>
<dc:creator>呆呆大虾</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/popapa/p/DXRectTracker.html</dc:identifier>
</item>
<item>
<title>《Office 365 开发入门指南》公开邀请试读，欢迎反馈 - 陈希章</title>
<link>http://www.cnblogs.com/chenxizhang/p/8137924.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxizhang/p/8137924.html</guid>
<description>&lt;p&gt;终于等来了这一天，可以为我的这本新书画上一个句号。我记得是在今年的2月份从西雅图回来之后，就萌发了要为中国的Office 365开发人员写一些东西并最终能帮到更多中国用户的想法，而从2月26日正式写下了&lt;a href=&quot;https://www.linkedin.com/pulse/office-365-%E5%BC%80%E5%8F%91%E6%A6%82%E8%A7%88%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%92%8C%E6%95%99%E7%A8%8B-%E5%B8%8C%E7%AB%A0-%E9%99%88/&quot;&gt;第一篇&lt;/a&gt;，到今天正好是整整十个月了。&lt;/p&gt;
&lt;p&gt;十个月的时间，赶一赶的话孩子都可以生一个了。多少个夜晚和周末的时间，如果不是怀着对客户的热爱、对公司的认可、对领导的眷恋和对技术的追求，我都不知道要怎么坚持下来。饶是如此，12月份中旬的时候一看Quota，还有将近五分之一的缺口，于是跺脚咬牙赌气发狠一口气写出来，基本达到了让自己满意的程度。此时此刻，一方面因为终于在设定的时间内完成了年初定下的小目标而高兴，另一方面又有丑媳妇到时候也该见公婆的忐忑心情。但无论如何，我是决意要以这篇结束语给自己一个交代，至于写得好与不好，完全是读者说了算，我也顾不了这么多了。&lt;/p&gt;

&lt;p&gt;这本书的写作过程也挺有意思的，我其实是在github上面创建了一个&lt;a href=&quot;https://github.com/chenxizhang/office365dev&quot;&gt;代码库&lt;/a&gt;，然后用markdown这种新式的标记语言编写的。使用github来托管源文件，因为它可以帮我做版本控制，随时可以比对和修改，甚至恢复到一个特定的版本。下图有不少数据，例如大家最终看到的是39篇文章，每篇平均2500字左右，与此同时前后一共有300多次的提交（commit）。使用github还有一个好处，是它直接可以连接到一个电子书的平台（gitbook），它可以自动生成目录和所有页面，并且支持电子版本的导出。&lt;/p&gt;
&lt;blockquote readability=&quot;3.7924528301887&quot;&gt;
&lt;p&gt;我此前有一篇文章，分享了一些写作经验，请参考 &lt;a href=&quot;https://www.linkedin.com/pulse/%E6%88%91%E5%88%86%E4%BA%AB%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%86%99%E4%BD%9C%E7%BB%8F%E9%AA%8C-%E5%B8%8C%E7%AB%A0-%E9%99%88/&quot;&gt;我分享给大家的个人写作经验&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://media.licdn.com/mpr/mpr/AAMAAwDGAAgAAQAAAAAAAAufAAAAJDQyYTE0NWVjLTU3YjYtNDU3OS05ZjAxLTI4ZTAxNDFjYjlhOA.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本书的内容不仅基本完整覆盖了Office 365开发的四大方向（Microsoft Graph，Office Add-in, SharePoint Add-in，Office 365 Connector），而且还包括了其他一些有意义的话题，例如有针对人工智能的话题，有商业应用平台的话题（Power Apps，Microsoft Flow，Power BI等）。对我来说，写作本书的过程也是一个非常好的学习过程，不断地思考和推敲，大纲有几次大的调整，尤其是Office Add-in这部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://media.licdn.com/mpr/mpr/AAMAAwDGAAgAAQAAAAAAAA1SAAAAJGRmYzg2MjNjLTA4OTctNDA5Mi05Mjc0LTk4ZjA2YWRmOThjOA.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本书的在线地址有两个，欢迎大家阅读并提供宝贵的反馈意见。这两个平台都支持给我留言，我会及时回复，并且在必要的时候还会对内容进行修订。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://aka.ms/office365devguide&quot;&gt;https://aka.ms/office365devguide&lt;/a&gt; 这个地址目前指向了博客园上面我的专栏地址。我是2005年开始在博客园开始写技术文章，至今已经坚持超过12年，截至今天随笔已经达到1321篇。博客园的访问速度非常快，搜索引擎友好性也很高，如果大家有意写博客文章，我强烈推荐使用博客园（&lt;a href=&quot;http://www.cnblogs.com/&quot;&gt;http://www.cnblogs.com/&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://chenxizhang.gitbooks.io/office365devguide/content/&quot;&gt;https://chenxizhang.gitbooks.io/office365devguide/content/&lt;/a&gt; 这是我开始写这个系列时发表的位置，对于这种有目录结构的书来说，它的阅读体验会好于博客园。这是一个国外的在线写书平台。它支持使用 markdown 进行编写，而且与github能天然集成，与此同时它能自动生成电子书（pdf，mobi，epub等三种格式）。除了访问速度容易受到一些不可描述的原因影响，这个平台堪称完美。所以，在本书写作的后期，我手工地将每一篇文章复制一份到了博客园，以便于国内用户的访问。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本书的电子版本可以通过下面三个地址下载&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/pdf/book/chenxizhang/office365devguide&quot;&gt;https://www.gitbook.com/download/pdf/book/chenxizhang/office365devguide&lt;/a&gt; (PDF版本，可以在PC或Mac等设备上面使用，有最佳的阅读体验）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/mobi/book/chenxizhang/office365devguide&quot;&gt;https://www.gitbook.com/download/mobi/book/chenxizhang/office365devguide&lt;/a&gt; （MOBI版本，可以直接在Kindle中阅读）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/epub/book/chenxizhang/office365devguide&quot;&gt;https://www.gitbook.com/download/epub/book/chenxizhang/office365devguide&lt;/a&gt;（EPUB版本，可以在其他电子阅读器上面使用）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;请注意，离线版本的体积将近90MB，所以请在有无线网络的情况下下载。&lt;/p&gt;
&lt;p&gt;【请注意】收到不少朋友反馈说下载速度慢，一方面是因为体积较大，一方面是因为上面的网址是在国外的。大家如果需要电子版，请发邮件给&lt;a href=&quot;mailto:office365devguide@xizhang.com&quot;&gt;office365devguide@xizhang.com&lt;/a&gt;，我将统一发送。谢谢支持。&lt;/p&gt;

&lt;p&gt;要感谢的人其实真的挺多的，包括家人的理解，领导和同事的鼓励，还有四大平台的支持（&lt;strong&gt;微软中国Office 365&lt;/strong&gt;官方公众号，&lt;strong&gt;微软中国MSDN&lt;/strong&gt;官方公众号，&lt;strong&gt;微软商业视角&lt;/strong&gt;官方公众号，&lt;strong&gt;ExcelHome&lt;/strong&gt;官方公众号），最后还有技术社区中很多认识和不认识的朋友的肯定，这些都给了我很大的动力，并对这本书的最终面世起到了决定性的作用。&lt;/p&gt;
&lt;p&gt;关于本书的反馈和交流，你还可以通过邮件和我取得联系：&lt;a href=&quot;http://mailto:office365devguide@xizhang.com/&quot;&gt;office365devguide@xizhang.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Dec 2017 13:46:00 +0000</pubDate>
<dc:creator>陈希章</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenxizhang/p/8137924.html</dc:identifier>
</item>
<item>
<title>从列表到详情，没你想的那么简单 - 大转转FE</title>
<link>http://www.cnblogs.com/zhuanzhuanfe/p/8137503.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuanzhuanfe/p/8137503.html</guid>
<description>&lt;h4&gt;前言&lt;/h4&gt;
&lt;p&gt;本文先假设我们使用的是 &lt;code&gt;vue + vuex + vue-router&lt;/code&gt; 的情况来展开讨论，&lt;code&gt;React&lt;/code&gt; 全家桶的情况应该类似。&lt;/p&gt;
&lt;p&gt;在日常的前端研发中，我们经常会遇到如题的场景：比如从商品列表进入商品详情，从订单列表进入订单详情。先看一个 &lt;code&gt;demo&lt;/code&gt;~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhuanzhuanfe/articles/blob/master/zhangchen/image/from_list_to_detail_1.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/zhuanzhuanfe/articles/raw/master/zhangchen/image/from_list_to_detail_1.gif&quot; alt=&quot;Alt text&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看起来是不是还算丝滑流畅，跟客户端效果较为接近~&lt;/p&gt;
&lt;h4&gt;正文开始&lt;/h4&gt;
&lt;p&gt;很多同学应该会说，这不是很容易么，用 &lt;code&gt;vue-router&lt;/code&gt; + &lt;a href=&quot;https://router.vuejs.org/zh-cn/advanced/transitions.html&quot; rel=&quot;nofollow&quot;&gt;transition&lt;/a&gt; 就好啦。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-text-html-basic&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;transition name=&quot;custom-classes-transition&quot;&lt;span&gt;
    :enter&lt;/span&gt;-active-class=&quot;`animated ${transitionEnter}`&quot;&lt;span&gt;
    :leave&lt;/span&gt;-active-class=&quot;`animated ${transitionLeave}`&quot;&amp;gt;
    &amp;lt;router-view/&amp;gt;
  &amp;lt;/transition&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  data: () &lt;/span&gt;=&amp;gt;&lt;span&gt; ({
    transitionEnter: &lt;/span&gt;''&lt;span&gt;,
    transitionLeave: &lt;/span&gt;''&lt;span&gt;
  }),
  watch: {
    &lt;/span&gt;'$route'&lt;span&gt; (to, from) {
      const toDepth &lt;/span&gt;= to.path.split('/'&lt;span&gt;).length
      const fromDepth &lt;/span&gt;= from.path.split('/'&lt;span&gt;).length
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (toDepth &amp;lt;&lt;span&gt; fromDepth) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.transitionEnter = 'slideInLeft'
        &lt;span&gt;this&lt;/span&gt;.transitionLeave = 'slideOutRight'&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.transitionEnter = 'slideInRight'
        &lt;span&gt;this&lt;/span&gt;.transitionLeave = 'slideOutLeft'&lt;span&gt;
      }
    }
  }
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;如上所示，&lt;code&gt;slide&lt;/code&gt; 的动画使用 &lt;a href=&quot;https://daneden.github.io/animate.css/&quot; rel=&quot;nofollow&quot;&gt;animated.css&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-scss&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;style lang='scss'&amp;gt;&lt;span&gt;
$use&lt;/span&gt;-slideInLeft: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
$use&lt;/span&gt;-slideInRight: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
$use&lt;/span&gt;-slideOutLeft: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
$use&lt;/span&gt;-slideOutRight: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
import &lt;/span&gt;&quot;node_modules/animate-sass/animate&quot;&lt;span&gt;;
.animated {
  top: &lt;/span&gt;0&lt;span&gt;;
  width: &lt;/span&gt;100%&lt;span&gt;;
  height: &lt;/span&gt;100%&lt;span&gt;;
  animation&lt;/span&gt;-&lt;span&gt;duration: calc(300ms);
}
.slideOutRight, .slideOutLeft {
  position: fixed;
}
&lt;/span&gt;&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;然后定义好 &lt;code&gt;router&lt;/code&gt; 的路径规则，笔者采用 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/05/restful_api.html&quot; rel=&quot;nofollow&quot;&gt;restful&lt;/a&gt; 的方式命名。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Router({
  routes: [{ &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 商品列表&lt;/span&gt;
    path: '/'&lt;span&gt;,
    name: &lt;/span&gt;'auctionroom'&lt;span&gt;,
    component: () &lt;/span&gt;=&amp;gt; import('app/auction-room/room/app.vue'&lt;span&gt;)
  }, {       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 商品详情&lt;/span&gt;
    path: ':activityId'&lt;span&gt;,
    name: &lt;/span&gt;'auctionroom-item'&lt;span&gt;,
    component: () &lt;/span&gt;=&amp;gt; import('app/auction-room/item/app.vue'&lt;span&gt;)
  }]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;真这么容易就能完成需求么？&lt;/p&gt;
&lt;h4&gt;墓碑元素和路由守卫&lt;/h4&gt;
&lt;p&gt;实际情况是，我们在进入详情页之前，并没有拿到详情的数据！一般都会选择在 &lt;code&gt;vue&lt;/code&gt; 组件实例生命周期的 &lt;a href=&quot;https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&quot; rel=&quot;nofollow&quot;&gt;created&lt;/a&gt; 钩子，获取对应的后端数据接口。&lt;/p&gt;
&lt;p&gt;而这个过程跟 &lt;code&gt;transition&lt;/code&gt; 的动画是并行的，会出现右侧页面还未拿到数据就划入屏幕的情况。如大家所想，我们会尽量让数据源表现的像现实世界遇到的，比如有网络延迟等等。&lt;/p&gt;
&lt;p&gt;在这种情况发生时，其实是需要放置一个墓碑条目占位在对应位置，等到数据取到后墓碑条目会被实际内容替代。这样设计的原因是，我们希望墓碑元素在被实际数据替代前可以有一个漂亮的过渡，而不是出现那种生硬的或者让人迷失的效果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhuanzhuanfe/articles/blob/master/zhangchen/image/from_list_to_detail_1.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/zhuanzhuanfe/articles/raw/master/zhangchen/image/from_list_to_detail_1.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先略这个丑陋的墓碑，实际情况的墓碑元素应该是有设计的，在很多新闻客户端如今日头条中会见到~&lt;/p&gt;
&lt;p&gt;比起这一种方案，更常见的方式是在导航完成前获取数据，使用 &lt;code&gt;router&lt;/code&gt; 的 &lt;a href=&quot;https://router.vuejs.org/zh-cn/advanced/data-fetching.html&quot; rel=&quot;nofollow&quot;&gt;beforeRouteEnter&lt;/a&gt; 钩子。这个方式固然不错，但同样有潜在的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒。&lt;/li&gt;
&lt;li&gt;不！能！获取组件实例 &lt;code&gt;this&lt;/code&gt;，因为当守卫执行前，组件实例还没被创建&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;vuex + keep-alive 和返回刷新&lt;/h4&gt;
&lt;p&gt;其实在渲染详情的时候，我们在当前列表已经有了一个商品的 &lt;code&gt;Collection&lt;/code&gt;，一般是个数组。那为什么不能在进入详情时，使用当前已有的数据做填充呢？详情页将这些数据立即渲染，然后再通过接口获取其余部分的数据，等完整数据获取之后再回填到页面上~&lt;/p&gt;
&lt;p&gt;采用这个方案，我们必须引入 vuex , 才能在多个页面组件之间传递数据(耗时&amp;lt;10毫秒)，而无需等待网络响应(ajax耗时 &amp;gt; 50毫秒)。同时依赖后端接口对于列表和详情的处理须保持一致，即详情接口的字段只可能 ≥ 列表接口的字段。&lt;/p&gt;
&lt;p&gt;这也是目前笔者使用的，代码大致如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;goDetail () {
  const {activityId} &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;.$store.commit('AUCTION_DETAIL', &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$props)
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$router.push({
    name: &lt;/span&gt;'auctionroom-item'&lt;span&gt;,
    params: { activityId }})
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;OK，进入的逻辑兼顾了流畅的动画同时并行了数据的异步获取，那么新的问题又来了！我们需要考虑另一种情况：如果用户在列表页下翻了很多次，那么进入详情页再返回，定位得保持不变吧，怎么解决？&lt;/p&gt;
&lt;h5&gt;分页VS无限滚动&lt;/h5&gt;
&lt;p&gt;关于分页，最常见的2种模式就是页码分页或使用滚动条，这块在产品设计界也经常被拿出来讨论，找了2篇人人都是产品经理的文章，有兴趣的同学可以延伸阅读。&lt;/p&gt;
&lt;p&gt;比较简单的结论可归纳为，页码则适用于那些用户在寻找特定信息的搜索结果列表页以及那些用户的浏览记录比较重要的场合，后者适用于向Twitter等那些用户重在消费无限的信息流而并不常搜寻特定的信息的应用，或者说前者多见于 &lt;code&gt;PC&lt;/code&gt; 端，后者多见于 &lt;code&gt;H5&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果是页码的模式，那么返回就不再是问题了，因为翻页信息通常会携带在页面&lt;code&gt;url&lt;/code&gt;中，返回时我们只需要刷新当前页面的信息就可以了。问题这次的项目是后者，产品同学无法接受进入详情的回退让用户重新回顶部~&lt;/p&gt;
&lt;h5&gt;引入 keep-alive&lt;/h5&gt;
&lt;p&gt;要解决这个问题，需要使用 &lt;code&gt;vue&lt;/code&gt; 的一个特性 &lt;a href=&quot;https://cn.vuejs.org/v2/api/#keep-alive&quot; rel=&quot;nofollow&quot;&gt;keep-alive&lt;/a&gt;，使用原理：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;包裹动态组件时会缓存组件实例，而不是销毁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keep-alive&lt;/code&gt; 内路由切换时会调用 &lt;code&gt;activated&lt;/code&gt; 和 &lt;code&gt;deactivated&lt;/code&gt; 这两个钩子&lt;/li&gt;
&lt;li&gt;套在 &lt;code&gt;router-view&lt;/code&gt; 外面，受到影响的范围就是 &lt;code&gt;router-view&lt;/code&gt; 里面的路由跳转。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用后会导致 &lt;code&gt;created&lt;/code&gt; 可能不被调用，需要把一些逻辑移到 &lt;code&gt;activated&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;针对不需要保留状态的情况，可以在 &lt;code&gt;deactivated&lt;/code&gt; 中调用 &lt;code&gt;$destroy()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;返回不刷新的问题解决了，但是产品同学又带来了新的问题，比如用户如果在详情页操作了！比如从订单列表进入详情后，更改了订单状态，那么列表页需要刷新这一条数据。&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;vuex&lt;/code&gt; 同样可以解决这个问题，在详情页的 &lt;code&gt;deactivated&lt;/code&gt; 钩子更新列表中对应的该条数据，同样依赖后端对于详情和列表接口描述订单采用同样的数据格式，代码大致如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;deactivated () {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$store.commit('AUCTION_LIST_INDEX', &lt;span&gt;this&lt;/span&gt;.index, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$data)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
最终效果如下：
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhuanzhuanfe/articles/blob/master/zhangchen/image/from_list_to_detail_2.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/zhuanzhuanfe/articles/raw/master/zhangchen/image/from_list_to_detail_2.gif&quot; alt=&quot;Alt text&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于订单这种，只有用户自己操作的数据，用这个方式就能满足需求。但对于商品、竞拍品这类，用户访问时间内有大量数据更新的情况，该方案其实不太完美~&lt;/p&gt;
&lt;p&gt;我们或许需要在列表页中缓存当前可视区域的页码，可以使用 &lt;a href=&quot;https://github.com/wangdahoo/vue-scroller&quot;&gt;vue-scroller&lt;/a&gt;，然后在返回时刷新当前可视区域的数据。然而这就完了吗？你或许还是太天真！&lt;/p&gt;
&lt;h4&gt;无尽滚动的复杂度&lt;/h4&gt;
&lt;p&gt;做过 &lt;code&gt;android、ios、react-native&lt;/code&gt; 开发的同学或许都知道大名鼎鼎的 &lt;code&gt;ListView、ScrollView、RecyclerView&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或许 Web 端一般没有类似的需求，但其实你也应该知道，DOM节点越多，内存占用越高。我们或许需要在可视区域内，复用列表节点，回收看不见的节点，但为了保持滚动条不因为内容回收导致的塌陷而变化， 还需要对他们做合并。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhuanzhuanfe/articles/blob/master/zhangchen/image/from_list_to_detail_3.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/zhuanzhuanfe/articles/raw/master/zhangchen/image/from_list_to_detail_3.gif&quot; alt=&quot;Alt text&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我就不做过多的拆解，掘金上有一篇来自 Google 大神的译文和一篇对应的引申：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/58a3c81e128fe10058c57a8b&quot; rel=&quot;nofollow&quot;&gt;[译] 无尽滚动的复杂度 -- 来自 Google 大神的拆解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/58b545f0b123db005734634e&quot; rel=&quot;nofollow&quot;&gt;设计无限滚动下拉加载，实践高性能页面真谛&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/zhuanzhuanfe/articles/blob/master/zhangchen/image/from_list_to_detail_2.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/zhuanzhuanfe/articles/raw/master/zhangchen/image/from_list_to_detail_2.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;据文中观察，在真正产品线上使用这项技术的还比较少。可能是因为实现复杂度和收益比并不很高。但是，淘宝移动端检索页面实现了类似的思想。如下图，&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhuanzhuanfe/articles/blob/master/zhangchen/image/from_list_to_detail_3.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/zhuanzhuanfe/articles/raw/master/zhangchen/image/from_list_to_detail_3.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;借用：当你想提供一个高性能的有良好用户体验的功能时，可能技术上一个简单的问题，就会演变成复杂问题的。这篇文章便是一个例证。随着 “Progressive Web Apps” 逐渐成为移动设备的一等公民（会吗？），高性能的良好体验会变得越来越重要。开发者也必须持续的研究使用一些模式来应对性能约束。这些设计的基础当然都是成熟的技术为根本。&lt;/p&gt;
&lt;p&gt;我的看法：其实这种优化为什么不是浏览器去做！？&lt;/p&gt;
&lt;p&gt;最后做个小广告，转转优品手机&lt;code&gt;帮卖&lt;/code&gt;，让您高价卖掉自个的旧手机~ 如果对您有帮助，还请转发到朋友圈~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 如果你喜欢我们的文章，关注我们的公众号和我们互动吧。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1203274/201709/1203274-20170929105350169-1798795184.jpg&quot; alt=&quot;&quot; width=&quot;344&quot; height=&quot;344&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Dec 2017 11:48:00 +0000</pubDate>
<dc:creator>大转转FE</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuanzhuanfe/p/8137503.html</dc:identifier>
</item>
<item>
<title>小白的Python之路 day4 装饰器前奏 - 钱多多的妖孽人生</title>
<link>http://www.cnblogs.com/ManyQian/p/8137462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ManyQian/p/8137462.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一.定义：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.装饰器本质是函数，语法都是用def去定义的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（函数的目的：他需要完成特定的功能）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.装饰器的功能：就是装饰其他函数（就是为其他函数添加附加功能）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二.原则：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1. 不能修改被装饰的函数的源代码&lt;/p&gt;
&lt;p&gt;　　2. 不能修改被修饰的函数的调用方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三. 实现装饰器知识储备：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　1.函数即“变量” &lt;span&gt; (先定义，再调用)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2.高阶函数&lt;/p&gt;
&lt;p&gt;　　3.嵌套函数&lt;/p&gt;
&lt;p&gt;　　4.匿名函数   样式 （calc = lambde x:x*3 ）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;高阶函数 + 嵌套函数 =》 装饰器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 函数即“变量”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　(1). python的内存机制&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div id=&quot;highlighter_9371&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;div class=&quot;container&quot;&gt;

&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;x &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt; &lt;code class=&quot;python value&quot;&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;def&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;test():&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;pass&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　　　 以上一个变量一个函数在内存中的表现形式如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201712/1274477-20171227223713113-140775993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　 在python解释器中，有一个概念叫做&lt;span&gt;引用基数&lt;/span&gt;，那什么叫引用基数呐，就是比方说，x=1,它会先在内存当中把1这个值试试在在的存放下来，这个x其实就是1的门牌号，也是对1的一次引用。python什么时候把这个1这个屋子清空呐？它会等到1所对应的门牌号都没有了，就会把1这里面的东西给清掉，这个也是python的内存回收机制，就是靠这种方式回收的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　(2). del清理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　那我们用什么清理呐？用del去&lt;span&gt;清理门牌号&lt;/span&gt;，就是对1的值引用的变量，del  x就表示清理掉1对应的x的门牌号。如果x没有被del，则x永远不还被删除，除非程序结束了，不然永远不会被删除。del删除的不是1，只是把门牌号x删除了，只是定期刷新时，发现1没有被其他门牌号引用了，才会被清掉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　(3). 函数在内存的表现形式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们先通过四个例子来解释一下：&lt;/p&gt;
&lt;p&gt;　　①&lt;span&gt;bar函数&lt;span&gt;没有定义&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;#bar函数没有定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;def foo():&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;line number2 index1 alt1&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python functions&quot;&gt;    print&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;in the foo&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;bar()&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;




&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;Error:name 'bar'is not defined&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201712/1274477-20171227230024238-718739668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　②bar函数&lt;span&gt;在foo函数之后定义&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_548154&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;9&quot;&gt;

&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;def&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;foo():&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python functions&quot;&gt;print&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;in the foo&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;bar()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;def&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;bar():&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python functions&quot;&gt;print&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;in the bar&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;foo()&lt;/code&gt;&lt;/p&gt;


&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;the foo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;the bar&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; 　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201712/1274477-20171227231048378-347313433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　③bar函数是&lt;span&gt;在foo函数之前定义&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_685901&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;9&quot;&gt;

&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;def&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;bar():&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python functions&quot;&gt;print&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;in the bar&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;def&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;foo():&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python functions&quot;&gt;print&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;in the foo&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;bar()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;foo()&lt;/code&gt;&lt;/p&gt;


&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;the foo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;the bar&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; 　　显然，两种写法效果是一样的，那我们来看看第四种情况。&lt;/p&gt;
&lt;p&gt;　　④bar函数&lt;span&gt;在foo函数调用之后声明&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_284417&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;18&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;22&quot;&gt;

&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;def&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;foo():&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python functions&quot;&gt;print&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;in the foo&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;bar()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;foo()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;def&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;bar():&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python functions&quot;&gt;print&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;in the bar&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;


&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;Traceback (most recent call last):&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;the foo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;python functions&quot;&gt;File&lt;/code&gt; &lt;code class=&quot;python string&quot;&gt;&quot;D:/PycharmProjects/pyhomework/day4/装饰器/函数即变量.py&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;, line &lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;31&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;&amp;lt;module&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;foo()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;python functions&quot;&gt;File&lt;/code&gt; &lt;code class=&quot;python string&quot;&gt;&quot;D:/PycharmProjects/pyhomework/day4/装饰器/函数即变量.py&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;, line &lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;29&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;foo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;bar()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;NameError: name &lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'bar'&lt;/code&gt; &lt;code class=&quot;python keyword&quot;&gt;is&lt;/code&gt; &lt;code class=&quot;python keyword&quot;&gt;not&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;defined  &lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.高阶函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;满足下面条件之一就可以称为高阶函数:&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;a.把一个函数名当做实参传给另一个函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　b.返回值中包含函数名(调用函数体)&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;63&quot;&gt;
&lt;p&gt;&lt;strong&gt;1、把一个函数名当做实参传给另外一个函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用：在不修改被装饰函数源代码的情况下为其添加功能&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_208790&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;def&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;bar():&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;time.sleep(&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python functions&quot;&gt;print&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;in the bar&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;def&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;test1(func):&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python functions&quot;&gt;print&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(func)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;start_time &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;time.time()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;func()   #run bar&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;stop_time &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;time.time()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python functions&quot;&gt;print&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;the func run the is %s&quot;&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;%&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(stop_time&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;start_time))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;test1(bar)  &lt;/code&gt;&lt;/p&gt;


&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;&amp;lt;function bar at &lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;0x0000000000A7D378&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;&amp;gt;  &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;the bar&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;the func run the &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;is&lt;/code&gt; &lt;code class=&quot;python value&quot;&gt;2.9912972450256348&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、返回值中包括函数名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用：不修改函数调用方式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_38377&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;import&lt;/code&gt;  &lt;code class=&quot;python plain&quot;&gt;time&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;def&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;bar():&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;time.sleep(&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python functions&quot;&gt;print&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;in the bar&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;def&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;test2(func):&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python functions&quot;&gt;print&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(func)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;func   &lt;/code&gt;&lt;/p&gt;


&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;bar &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;test2(bar) &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;bar()  &lt;/code&gt;&lt;/p&gt;


&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;&amp;lt;function bar at &lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;0x0000000000B6D378&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;&amp;gt;  &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;the bar&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;




</description>
<pubDate>Thu, 28 Dec 2017 11:39:00 +0000</pubDate>
<dc:creator>钱多多的妖孽人生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ManyQian/p/8137462.html</dc:identifier>
</item>
<item>
<title>游戏随笔之游戏资源池的设计 - zblade</title>
<link>http://www.cnblogs.com/zblade/p/8134121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zblade/p/8134121.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　很久没有更新了，今天给大家写一篇游戏资源池的相关文章，就当作2017年的最后一篇文章吧。 转载请标明出处：&lt;a href=&quot;http://www.cnblogs.com/zblade/&quot;&gt;http://www.cnblogs.com/zblade/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、游戏项目中的资源池&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;在一款游戏中，随着游戏的进行，我们会不断的创建和销毁一些角色，比如我们玩一款射击游戏，我们需要不断的发射子弹，一般的情况下，我们会不断的创建子弹，然后发射出去，在击中物体后销毁。分析整个设计的过程，我们会不断的创建子弹，然后发射出去，最后销毁它。这儿，其实就可以引入资源池的概念来解决子弹的反复创建和销毁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果只是反复的创建和销毁子弹，那么每次的性能点主要在子弹的创建上，在场景中有较多角色频繁操作射击的时候，不断执行创建，会带来性能的较大消耗，从而让游戏卡帧。如果我们把这些子弹预先创建出来，塞入到一个弹夹，然后每次在射击发射子弹的时候，从预先创建的弹夹中取出来发射，每次在销毁的时候，又将其还原到弹夹中，这样循环反复的利用，可以避免每次射击子弹的时候的创建操作带来的性能消耗。将弹夹拓展一步，就是资源池的概念了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、不同设计下的资源池&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　1、简单lua版本的资源池&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;基于前文子弹的阐述，我就写一个简单版本的资源池的lua版本，首先，是资源池的定义：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; BulletPool:initialize()
    &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;缓存子弹的table&lt;/span&gt;
    self.mBulletPool =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　是不是觉得很简单，是的，lua版本的资源池可以只需要用一个table就简单的表示，接下来，我们只需要维护好这个table即可。首先是取子弹的接口：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; BulletPool:GetBullet()
      &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;如果没有定义，则执行一次兜底定义&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; self.mBulletPool &lt;span&gt;then&lt;/span&gt;&lt;span&gt; 
           self.mBulletPool &lt;/span&gt;=&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;end&lt;/span&gt;
    &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 如果池子里面没有可以取的了，则返回nil&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;(self.mBulletPool) == &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
           &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
    &lt;span&gt;end&lt;/span&gt;

    &lt;span&gt;local&lt;/span&gt; bulletObj = self.mBulletPool[#&lt;span&gt;self.mBulletPool]
    &lt;/span&gt;&lt;span&gt;table.remove&lt;/span&gt;(self.mBulletPool, #&lt;span&gt;self.mBulletPool)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bulletObj
&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　有了设计的接口，接下来，我们可以继续设计归还的接口，所谓有借有还再借不难，不能只从池子里面取，不归还，那池子早晚会干涸的 :D&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; BulletPool:InsertBullet(bullet)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; bullet &lt;span&gt;then&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; self.mBulletPool &lt;span&gt;then&lt;/span&gt;&lt;span&gt;
        self.mBulletPool &lt;/span&gt;=&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;end&lt;/span&gt;
    &lt;span&gt;--&lt;/span&gt;&lt;span&gt;子弹归还前的释放操作，可以不在意这一步操作&lt;/span&gt;
&lt;span&gt;    bullet:Release()
    &lt;/span&gt;&lt;span&gt;table.insert&lt;/span&gt;&lt;span&gt;(self.mBulletPool, bullet)
&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　好了，有了整体的获取和归还的操作，池子的基本接口就有了，有的同学会说，如果我们想重置一遍池子怎么办？那就再写一个清除池子的操作吧 :b&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; BulletPool:Release()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt; &lt;span&gt;pairs&lt;/span&gt;(self.mBulletPool) &lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        v:Release()  
    &lt;/span&gt;&lt;span&gt;end&lt;/span&gt;
    
    &lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt; &lt;span&gt;pairs&lt;/span&gt;(self.mBulletPool) &lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        self.mBulletPool[k] &lt;/span&gt;= &lt;span&gt;nil&lt;/span&gt;
   &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这下接口都有了，让我们来应用这些接口吧 ：D&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      首先给角色挂载一个子弹的资源池的获取接口吧：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;获取接口&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Character:GetBullet()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BulletPool:GetBullet()
&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;塞入接口&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Character:RemoveBullet(bullet)
    BulletPool:InsertBullet(bullet)
&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　因为每个角色都会射出一堆的子弹，所以我们是直接挂在角色身上，就不在整个场景管理器中去管理子弹了，可以通过场景管理器的更新来执行角色的更新，从而执行所有子弹的更新，这样每个角色的子弹更新和角色更新一致。这种设计模式下，不会出现先更新角色，然后再更新子弹的带来的一些问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　有了这两个接口，下面就是让角色调用这2个接口：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;获取子弹&lt;/span&gt;
&lt;span&gt;local&lt;/span&gt; bullet =&lt;span&gt; mChar:GetBullet()
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;没有则新建，有则重新初始化相关参数&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; bullet == &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;&lt;span&gt; 
    bullet &lt;/span&gt;=&lt;span&gt; Bullet:new(...)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    bullet:initialize(...)
&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;塞入到角色身上的一个table中维护&lt;/span&gt;
&lt;span&gt;mChar:AddBullet()


...
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;移除子弹，比较简单&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; bullet:Update() &lt;span&gt;then&lt;/span&gt;&lt;span&gt; 
    mChar:RemoveBullet(bullet)
&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　到这儿，我们完成了一个简单的lua版本的资源池的设计和实现，通过这几个接口，对资源池有一个简单的入门理解了。接下来，我们进一步编写一个c#版本的资源池吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　2、C#版本的资源池&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;　   在有了lua版本的资源池入门之后，接下来我们可以进一步的设计一个c#版本的资源池了。在unity的c#中，会有各种各样的资源需要资源池来进行管理，所以我们不能单独的做某个类的资源池了，我们需要引入泛型来指代各种类型的资源池。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先写一个简单的资源池，就实现一个获取和归还接口吧：&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ObjectPool&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt; T:&lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用一个列表来代替lua中的table，用作资源池&lt;/span&gt;
    LinkedList&amp;lt;T&amp;gt; objs = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;T&amp;gt;&lt;span&gt;();
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T GetObject()
    {
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(objs.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
       {
           T obj &lt;/span&gt;=&lt;span&gt; objs.Last.Value;
           objs.RemoveLast();
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
     }

     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ReturnObj(T obj)
     {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(obj != &lt;span&gt;null&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)
        {
           obj.AddLast(obj);
        }
     }  
}&lt;/span&gt;    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　有了简化版本的资源池，我们可以进一步的拓展这个池子的设计。首先，我们可以将链表改为堆栈，用一个栈来代替链表，相对会比较容易控制，只需要管理入栈和出栈即可。其次，在池子已经被榨干，取完的时候，前面是直接返回一个null，我们可以继续拓展，在没有的时候，就进行一次创建操作，这个可以通过委托来实现，在池子的初始化的时候就注册相关的委托。同理，进一步的拓展出取完后的操作和归还释放时的操作委托，这样就把我们前面lua中归还池子时候释放子弹的操作封装为一个事件。说完思路，下面让我们开始吧：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ObjectPool&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt; T:&lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;堆栈&lt;/span&gt;
   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; StackT&amp;gt;&lt;span&gt; m_stack;
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;事件&lt;/span&gt;
   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Func&amp;lt;T&amp;gt;&lt;span&gt;   m_ActionOnCreate;
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Action&amp;lt;T&amp;gt;&lt;span&gt; m_ActionOnGet;
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Action&amp;lt;T&amp;gt;&lt;span&gt; m_ActionOnRelease;
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; ObjectPool(Func&amp;lt;T&amp;gt; actionOnCreate, Action&amp;lt;T&amp;gt; actionOnGet, Action&amp;lt;T&amp;gt;&lt;span&gt; actionOnRelease)
    {
            m_stack                 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;T&amp;gt;&lt;span&gt;();
            m_ActionOnCreate  &lt;/span&gt;=&lt;span&gt; actionOnCreate;
            m_ActionOnGet       &lt;/span&gt;=&lt;span&gt; actionOnGet;
            m_ActionOnRelease &lt;/span&gt;=&lt;span&gt; actionOnRelease;
     }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取接口&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T Get()
    {
          T obj;
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(m_stack.Count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
          {
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行构建操作&lt;/span&gt;
              obj =&lt;span&gt; m_ActionOnCreate();
          }
          &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
           {
              obj &lt;/span&gt;=&lt;span&gt; m_stack.Pop();
           }
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行回调&lt;/span&gt;
           &lt;span&gt;if&lt;/span&gt;(m_AcitonOnGet != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
           {
              m_ActionOnGet(obj);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
     }
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放接口&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Release(T obj)
    {
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(m_ActionOnRelease != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
       {
           m_ActionOnRelease(obj);
       }
       m_stack.Push(obj);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;clear接口&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; Clear()
    {
       m_stack.Clear();
    }
}   &lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;　　写到这儿，一个基本的资源池的构建算是完成了，大家可以在这个版本的基础上进一步的衍生出资源池的使用，比如给资源池的对象添加一个计时的功能，当资源计时超过一定的时间后，就将其从资源池中去除，避免资源池不断扩大。诸如此类种种，都是后续可以操作的，好了，这篇文章就写到这儿，也祝提前祝大家2018年新年快乐！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Dec 2017 11:30:00 +0000</pubDate>
<dc:creator>zblade</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zblade/p/8134121.html</dc:identifier>
</item>
<item>
<title>用Azure AD 实现Web 应用身份认证的Multi-Factor Authentication(MFA) - MeowMeow</title>
<link>http://www.cnblogs.com/meowmeow/p/8087229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/meowmeow/p/8087229.html</guid>
<description>&lt;p&gt; 　　首先我们需要一个AAD的管理员账户并且登录Azure Portal，在左边的服务菜单栏选定 “Azure Active Directory”。&lt;/p&gt;
&lt;div class=&quot;trans-verified-button-small&quot; dir=&quot;ltr&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228180718397-731101482.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;　　接下来在AAD注册我们的Web应用.这是一个部署在本地电脑上的Web应用，登录url是http://localhost:8080/adal4jsample/。 点击“新应用程序注册”，输入以下信息并点击创建&lt;/p&gt;
&lt;div class=&quot;trans-verified-button-small&quot; dir=&quot;ltr&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228180902100-149367563.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;


&lt;div class=&quot;trans-verified-button-small&quot; dir=&quot;ltr&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228181009819-209311951.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;　　创建成功后需要把注册好的的应用程序 ID记录下来，在接下来的应用程序的配置里需要使用这个ID，另外“需要使用用户分配”这个选项记得要选“是”&lt;/p&gt;
&lt;div class=&quot;trans-verified-button-small&quot; dir=&quot;ltr&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228181434475-1426645971.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;　　此外，还需要设置 回复url，这个url也可以由Web应用的开发提供&lt;/p&gt;
&lt;div class=&quot;trans-verified-button-small&quot; dir=&quot;ltr&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228181726866-1880318860.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;还需要配置启用访问权限&lt;/p&gt;
&lt;div class=&quot;trans-verified-button-small&quot; dir=&quot;ltr&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228181856991-1331000010.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;最后要配置一个秘钥 （添加秘钥的时候必须记录下秘钥值，不然之后再回到页面秘钥值就被隐藏起来）&lt;/p&gt;

&lt;div class=&quot;trans-verified-button-small&quot; dir=&quot;ltr&quot; readability=&quot;8&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228182043741-560402885.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;对了，还需要记下订阅的tenant id。这个大家用powershell或者azure cli登录一下就知道了&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;trans-verified-button-small&quot; dir=&quot;ltr&quot;&gt;
&lt;ul&gt;&lt;li&gt;Web应用的配置&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;　　 集成AAD的代码（示范代码可以从以下url下载 https://github.com/Azure-Samples/active-directory-java-webapp-openidconnect//archive/complete.zip）使用了Java 库 ADAL4J，这个库用来实现发送SignIn/SignOut的request，管理用户 session，获取用户信息，源代码可以https://github.com/AzureAD/azure-activedirectory-library-for-java获取。&lt;/p&gt;

&lt;p&gt;        在这个示范代码里所需的改动如下：&lt;/p&gt;

&lt;div class=&quot;trans-verified-button-small&quot; dir=&quot;ltr&quot; readability=&quot;43&quot;&gt;
&lt;ol&gt;&lt;li&gt;在\src\main\webapp\WEB-INF\web.xml里修改authority（必须如下图所示）,tenant （上文提到的tenant id）,client_id（上文提到的应用程序ID）,secret_key（上文创建的秘钥值）的值 。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;改动前：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228182807538-1202732796.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;改动后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228183658881-1056587168.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2. 在\src\main\java\microsoft\aad\adal4jsample\AadController.java里修改方法 getUsernamesFromGraph&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228184019881-677650604.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3. 在\src\main\java\microsoft\aad\adal4jsample\BasciFilter.java里把“graph.windows.net”修改为“graph.chinacloudapi.cn”&lt;/p&gt;

&lt;p&gt;全部完成后打包编译，mvn package ，把war包部署到本机的tomcat，在browser里输入http://localhost:8080/adal4jsample，得到以下页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228184139397-715538758.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击secure page，页面跳转到中国的Azure AD做身份鉴权，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228184425803-736542757.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入用户名和密码后登陆Web应用的主页如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228184502272-1424365812.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;配置MFA&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来我们要做的事情是在Azure AD里添加web应用的用户，assign用户到web应用并且开启MFA&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;span&gt;在注册了Web应用的AAD 目录里添加用户MFAuser&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228184619553-7109817.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;em&gt;选择“Enable Multi-Factor Authentication&quot; 选项，这里我们还会收到一个临时的password&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228184711006-244750051.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;span&gt;进入应用程序页面中我们上文注册的Web 应用，把新创建的用户assign给Web应用&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228184825741-492857657.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;span&gt;打开浏览器，输入http://localhost:8080/adal4jsample/，页面跳转到中国AAD做身份认证，&lt;em&gt;输入新建的用户名和临时密码，页面显示要求配置MFA&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228185137038-1482842132.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;span&gt;AAD MFA可以配置电话，短信，移动device等多种选项，我们选择Authentication Phone和Send me a code by text message&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228185302069-2081305119.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;之后，手机会收到一个来自国外的短消息，用里面的code就可以完成最后的verify步骤&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228185336850-1908017189.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;span&gt;重新打开浏览器，输入http://localhost:8080/adal4jsample/，页面跳转到中国AAD做身份认证，这次只需要给出用户名，手机会收到验证码&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228185356584-1203906067.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;span&gt;输入验证码后，身份验证成功，登陆系统正常&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024893/201712/1024893-20171228185427163-207282766.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码化的AAD用户和MFA配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;既然AAD被当做一个Web应用的终端用户数据库，那用户数据的添加，删除以及MFA的配置这些task需要有一个编程接口来实现&lt;/p&gt;
&lt;p&gt;小伙伴试验了一下，目前只找到了powershell的实现：（。&lt;/p&gt;

&lt;p&gt;eg. Import MSONLINE V1的模块(https://docs.microsoft.com/en-us/powershell/module/msonline/?view=azureadps-1.0)即可实现。代码如下&lt;/p&gt;
&lt;div class=&quot;trans-verified-button-small&quot; dir=&quot;ltr&quot; readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
Import-&lt;span&gt;Module MSOnline 
$username&lt;/span&gt;=&lt;span&gt;’xxxxxx’ 
$password&lt;/span&gt;=&lt;span&gt;’yyyyyyyy’ 
$securepassword&lt;/span&gt;=Convertto-&lt;span&gt;SecureString –String $password –AsPlainText –force 
$credentials&lt;/span&gt;=New-&lt;span&gt;object&lt;/span&gt;&lt;span&gt; System.Management.Automation.PSCredential $username,$securepassword 
Connect&lt;/span&gt;-&lt;span&gt;MsolService –Credential $credentials 
$users &lt;/span&gt;= Get-msoluser -All | &lt;span&gt;where&lt;/span&gt; {$_.UserPrincipalName -like &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*zzzzzz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;} 
$mfausers &lt;/span&gt;= $users | &lt;span&gt;select&lt;/span&gt; DisplayName,@{N=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Email&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;E={$_.UserPrincipalName}},@{N=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;StrongAuthenticationRequirements&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;E={($_.StrongAuthenticationRequirements.State)}} | Sort-&lt;span&gt;Object StrongAuthenticationRequirements 
$nostrong &lt;/span&gt;= $mfausers | Where-Object StrongAuthenticationRequirements -like &lt;span&gt;''&lt;/span&gt; | Select-&lt;span&gt;Object DisplayName,Email,StrongAuthenticationRequirements 
$auth &lt;/span&gt;= New-Object -&lt;span&gt;TypeName Microsoft.Online.Administration.StrongAuthenticationRequirement 
$auth.RelyingParty &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 
$auth.State &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Enabled&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 
$auth.RememberDevicesNotIssuedBefore &lt;/span&gt;= (Get-&lt;span&gt;Date) 
$nostrong &lt;/span&gt;| Foreach {Set-MsolUser -UserPrincipalName $_.Email -StrongAuthenticationRequirements $auth}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 最后提醒一下，电话和短信平台都在海外，所以都是通话和短消息英语&lt;/p&gt;
&lt;/div&gt;



</description>
<pubDate>Thu, 28 Dec 2017 10:58:00 +0000</pubDate>
<dc:creator>MeowMeow</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/meowmeow/p/8087229.html</dc:identifier>
</item>
<item>
<title>redis基础二 - 天宇之游</title>
<link>http://www.cnblogs.com/cwp-bg/p/8137273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwp-bg/p/8137273.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前面已经学习了redis的基本的命令行操作和数据类型，下面开始redis一些有趣的功能。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;订阅和发布机制&quot;&gt;订阅和发布机制&lt;/h2&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;定义：发布者相当于电台，订阅者相当于客户端，客户端发到频道的消息，将会被推送到所有订阅此频道的客户端；客户端不需要主动去获取消息，只需要订阅频道，这个频道的内容就会被推送过来；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;作用:发布者和订阅者的解耦合可以带来更大的扩展性和更加动态的网络拓扑;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;相关命令&quot;&gt;相关命令&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# 订阅消息
subscribe 频道1 频道2   # 此时redis客户端会一直处于监听频道的状态，一有消息就处理；
# 取消订阅
unsubcribe 频道1 ...   # 如果不写频道名称，则取消所有的订阅；

# 推送消息
publish 频道1 消息内容&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重点说明&quot;&gt;重点说明&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;发布订阅机制一般使用在对同一个redis实例来说，实现类似于生产者消费者模式；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在主从集群中，master发布的消息可以推送到slave中，但slave中的消息不能推送到master中；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;订阅发布机制的不足：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果消息接收方不能及时处理推送的消息，消息会在缓存队列中，会导致缓存占用的空间越来越大，最终导致redis崩溃；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;发布的消息推送存在即时性,但网络一般是不稳定的，对于客户端来说，如果出现了断网的现象，那么接收的消息就会丢失，所以发布订阅模式不能用在对数据完整性要求高的场合；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;简单的主从复制配置&quot;&gt;简单的主从复制配置&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;定义：一台redis服务器可以作为一个master，在其下面可以有多个slave，每个slave又可以作为一个master，从而可以构建庞大的redis数据库集群；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;配置方法&quot;&gt;配置方法&lt;/h3&gt;
&lt;p&gt;方式一：修改配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 设置主服务器的配置，绑定固定的ip
sudo vi redis.conf
bind 服务器的ip

# 设置从服务器的ip
sudo vi redis.conf
bind 服务器的ip
slaveof 主服务器的ip 主服务器redis端口     # 注意，ip与端口之间使用空格分割

# 分别启动主从redis，主服务器redis负责写，也可以读；从服务器只能读，不能写；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方式二：使用命令行的方式动态设置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 从服务器连接主服务器
slaveof host port 
# 从服务器断开主服务器
slaveof no one &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重要说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;从服务器与主服务器进行初始连接时，从服务器会丢弃所有的旧数据，然后载入主服务器的数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;redis不支持主主复制，也就是说不可以两个redis相互设置对方为主服务器，虽然不会报错，但性能方面，以及对客户端的请求都可能出现问题；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;redis复制的启动过程&quot;&gt;redis复制的启动过程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当主服务器收到从服务器发送的复制请求的时候，主服务器执行的动作有：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;等待从服务器的命令进入--&amp;gt;执行bgsave，创建快照文件；使用缓存区记录bgsave命令执行后所有的写命令--&amp;gt;快照文件创建完毕后，向服务器发送快照文件--&amp;gt;发送快照文件完毕后向从服务器发送缓存区的写命令--&amp;gt;完毕后每收到一个写命令就向从服务器发送&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从服务器相应的动作有：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;连接主服务器,发送sync命令--&amp;gt;等待响应--&amp;gt;丢弃所有的旧数据，载入主服务器的快照文件--&amp;gt;完成快照文件的解释，开始接受命令请求--&amp;gt;执行从主服务器发送的所有的写命令；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：redis支持主从链，即从服务器还可以有从服务器，但是从服务器A复制从服务器B的过程和从服务器B复制主服务器是有区别的；从服务器B向从服务器A发送完毕快照文件后，会先断开与从服务器A的连接，从服务器A需要重新连接并且请求同步；&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis的事务&quot;&gt;redis的事务&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;redis有像关系型数据库一样的事务机制来保证多条命令作为原子操作；事务中的命令要么全执行，要么全不执行；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;事务的完整过程：开始事务--&amp;gt;命令进入缓存--&amp;gt;执行事务;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;事务的基本使用&quot;&gt;事务的基本使用&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# 开启一个事务
multi      # 提交命令后，redis会将后面的操作保存起来
# 提交事务
exec   # 提交命令后，redis会执行前面保存的所有的命令

# 取消事务
discard   # 如果书写命令队列的过程中需要取消事务时使用&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;redis事务中在写命令队列的时候，如果中间发生了语法错误，并且redis报了错，那么这个事务所有的命令都会取消执行；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt; lpush list a b c 
(integer) 3
&amp;gt; multi
OK
&amp;gt; lpush list d
QUEUED
&amp;gt; lpuxh list f
(error) ERR unknown command 'lpuxh'
&amp;gt; lrange list 0 10
QUEUED
&amp;gt; exec
(error) EXECABORT Transaction discarded because of previous errors.
&amp;gt; lrange list 0 10
1) &quot;c&quot;
2) &quot;b&quot;
3) &quot;a&quot;

# 所有的命令都没有执行&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;但有一些错误redis在执行之前并不能感知，这时redis会执行所有的的命令，客户端必须自己处理错误；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt; lpush li blue red green
(integer) 3
&amp;gt; multi
OK
&amp;gt; get li
QUEUED
&amp;gt; lpush li white
QUEUED
&amp;gt; exec
1) (error) WRONGTYPE Operation against a key holding the wrong kind of value
2) (integer) 4
&amp;gt; lrange li 0 10
1) &quot;white&quot;
2) &quot;green&quot;
3) &quot;red&quot;
4) &quot;blue&quot;

# 所有的命令都执行了，只不过有的命令执行失败&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意点&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;redis的开启事务是将命令暂时保存在一个队列里，执行时依次操作；如果命令队列有一条出现语法错误，整个事务创建会失败；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;redis没有提供事务的回滚功能，客户端必须自己处理失败的命令；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;事务锁&quot;&gt;事务锁&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# 基本命令
watch key key ..   # 监控键值

# 取消对所有键的监控
unwatch &lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;由于redis的事务中的命令其实是缓存队列，并且redis可以防止在事务的执行过程中有其他的命令插入，即具有隔离性；但是在多个客户端进行并发操作时存在数据无法同步的问题；如客户端A、B同时操作键key的值加一，预期结果为增加2，实际可能只有1.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为了解决这个问题，redis引入了watch监控键；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt; watch num 
OK
&amp;gt; set num 7
OK
&amp;gt; multi
OK
&amp;gt; set num 5
QUEUED
&amp;gt; exec
(nil)
&amp;gt; get num
&quot;7&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;可以看到事务并没有执行成功，wetch可以监控键，如果在监控后，键的值发生了改变，那么redis后面与这个键相关的事务操作将会失败，同时在exec执行后，键的监控会被取消；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意：无论监控多少个键或事务中有没有与该键相关的命令，在最近的一个执行了exec，无论事务执行有没有成功，watch监控的所有键都将会取消，后面的事务不再受影响。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：使用watch监控实现并发修改键值，如果事务被取消，需要手动重新执行事务；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以上可知，redis实现的是类似乐观锁（即预期并发时没有出现竞争修改同一个键值的状况)，这种情况在并发量低时影响不大，但是高并发时几乎肯定出现竞争，并发修改键值程序重试的次数越来越多，资源被白白浪费，需要使用其他的方法实现悲观锁机制，这点后面会继续研究；&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 28 Dec 2017 10:50:00 +0000</pubDate>
<dc:creator>天宇之游</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cwp-bg/p/8137273.html</dc:identifier>
</item>
<item>
<title>基于百度理解与交互技术实现机器问答 - linbin524</title>
<link>http://www.cnblogs.com/linbin524/p/8136799.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linbin524/p/8136799.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们都知道现在聊天对话机器是一个很有意思的东西，比如说苹果siri，比如说微软的小冰。&lt;/p&gt;
&lt;p&gt;聊天对话机器的应用场景也很广泛，比如说：银行的自助办卡机器人、展会讲解解说等等。&lt;/p&gt;

&lt;p&gt;我们对机器人说句话，机器人从听取，到语义识别，认知转换，到最后调出我们所想要的东西，这个过程看似简单，其实内藏许多黑科技，让我们来一一解析一下。&lt;/p&gt;

&lt;p&gt;1、我们对机器人说句话：我想看一下今天的天气？&lt;/p&gt;
&lt;p&gt;技术实现：不论是语音、文字，机器首先要采集到我们的问题，语音还需要语音转换的一个过程，且内容转换结果必须准确，否则就有点像不同语言体系的人在对话，有种鸡同鸭讲的感觉，结果肯定也是一个大坑了。&lt;/p&gt;

&lt;p&gt;2、语义识别&lt;/p&gt;
&lt;p&gt;技术实现：通常这个阶段，已经将内容转换为一段文字，程序会对文字进行分词，结合关键字截取拼接语义（这里需要AI的训练）&lt;/p&gt;
&lt;p&gt;3、认知转换&lt;/p&gt;
&lt;p&gt;技术实现：上述的那就话中，&lt;span&gt;今天是个关键词，天气是个关键词，&lt;span&gt;  在训练库中需要提炼词槽，将可能语句尽可能提供给机器人&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;4、调用结果&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当认知转换完成后，需要对关键词进行规则判断，比如说， 想看 + 今天+ 天气，组成时候，自动调用查询天气接口&lt;/p&gt;

&lt;p&gt;上述的结果，更多需要我们对机器人进行训练，让它学习，要不然结果肯定不是那么友好的。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、技术需求&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;通过文字输入问题，动态理解转化，识别内容，进行机器解答和语音提示。&lt;/p&gt;
&lt;p&gt;PS：上述的需求基本可以理解为你叫机器人做一件事，机器人领悟，按照你的要求执行。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进阶：可以采用语音输入，转换为文字，之后的序列一样。（需要阵列麦克风）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、技术选型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、采用C# winform 作为程序主题&lt;/p&gt;
&lt;p&gt;2、采用win7 TTS 作为语音朗读功能&lt;/p&gt;
&lt;p&gt;3、采用百度理解交互技术 UNIT 作为识别基础&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、新建winform 窗体&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228165432850-1471393333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、添加TTS，引用System.Speech&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228165517413-2091858180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、进行 语音朗读测试&lt;/p&gt;

&lt;p&gt;SpeechSynthesizer voice = new SpeechSynthesizer(); //创建语音实例&lt;br/&gt;voice.Rate = 2; //设置语速,[-10,10]&lt;br/&gt;voice.Volume = 100; //设置音量,[0,100]&lt;br/&gt;voice.SpeakAsync(“您好！”); //播放指定的字符串,这是异步朗读&lt;/p&gt;

&lt;p&gt;&lt;span&gt;PS:有些win7 系统TTS 有问题，需要自己百度查找，下载TTS 进行安装。目前上述支持中文，输入英文，只会念字母，因为需要朗读类别做转换，详细请百度speech 操作。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; 4、结合百度理解与交互技术&lt;/p&gt;

&lt;p&gt;百度提供的sdk 目前只支持android 和IOS，但有提供http API，所以笔者采用C#实现了。&lt;/p&gt;
&lt;p&gt;先去官网注册成为百度开发者。&lt;/p&gt;

&lt;p&gt;（1） 创建应用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228170645272-1810681728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （2） 创建场景，场景编号是后面需要用到的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228170747053-1547177342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（3）新建单元，官方提供对话单元和问答单元，我们选择创建对话单元&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228170957053-2071167592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;（4）、对对话单元进行配置，新建词藻&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228180208022-212385640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;新建词藻&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228180351209-75296610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 词藻词典有自定义的，也有系统的，本文中选择系统通用的。也可以下载自定义模板，写入自己的自定义词典&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228180503944-1580597305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这个对话单元中，有文本回复和执行函数，我们这里选文本回复&lt;/p&gt;
&lt;p&gt;触发的规则：会话规则中，上述的词藻已填充，那么文本内容才会出现&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228180634881-606794009.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存完成，后再次新建对话单元，主要说明介绍我们的公司&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228181522834-1613657621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt; 跳转到数据中心，进行新建对话样本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228181452084-251491790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt; 添加&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228181348819-2005978860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 依法将公司介绍关键词添加&lt;/p&gt;

&lt;p&gt;来的训练与验证板块&lt;/p&gt;
&lt;p&gt;输入打开菜单，一开始输入，可能得到错误答案，你要 @UNIT 纠正意图与词槽，手动将关键词和意图、取词、词藻匹配上&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228182147741-1065755297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 完成后的结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228181838413-777294458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）、&lt;/p&gt;
&lt;p&gt;配置基本参数&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 理解与交互技术UNIT 
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigUnit
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Api key
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String clientId = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 百度云中开通对应服务应用的 Secret Key&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String clientSecret = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;场景Id&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; clientSceneId = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;部分解析实体model&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; BaiduAIAPI.Model.UnitModel
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UnitModel
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; log_id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; error_code { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; error_msg { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UnitResult result { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsSuccess { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; returnSay { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UnitResult
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; session_id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;UnitAction_list&amp;gt; action_list { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; schema { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; qu_res { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UnitAction_list
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; action_id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; action_type { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; arg_list { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; code_actions { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; confidence { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; exe_status { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; main_exe { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; say { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; hint_list { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 其余的model 还没补充完整
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UnitSchema {


    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;错误信息定义&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; BaiduAIAPI.Type
{
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaiduUnitType
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetErrorCodeToDescription(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; errorCode)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; errorDecrition = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (errorCode)
            {

                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务器内部错误，请再次请求， 如果持续出现此类错误，请通过QQ群（224994340）联系技术支持团队。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务暂不可用，请再次请求， 如果持续出现此类错误，请通过QQ群（224994340）或工单联系技术支持团队。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调用的API不存在，请检查后重新尝试。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;集群超限额。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无权限访问该用户数据。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IAM鉴权失败，建议用户参照文档自查生成sign的方式是否正确，或换用控制台中ak sk的方式调用。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;每天请求量超限额。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QPS超限额。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请求总量超限额。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无效的access_token参数，请检查后重新尝试。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;access token无效。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;access token过期。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;282004&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请求参数格式不正确。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;282900&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;必传字段为空。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;282901&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    errorDecrition &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;场景ID校验失败，请确认console中app和场景是否关联了：https://console.bce.baidu.com/ai/#/ai/unit/app/list。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;282902&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    errorDecrition &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UNIT环境启动中，请稍后再试；如果持续出现此类错误，请通过QQ群（224994340）联系技术支持团队。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;282903&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    errorDecrition &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UNIT系统异常；如果持续出现此类错误，请通过QQ群（224994340）联系技术支持团队。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    
                        
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;282000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务器内部错误，如果您使用的是高精度接口，报这个错误码的原因可能是您上传的图片中文字过多，识别超时导致的，建议您对图片进行切割后再识别，其他情况请再次请求， 如果持续出现此类错误，请通过QQ群（631977213）或工单联系技术支持团队。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
             
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;: errorDecrition = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未知的错误！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; errorDecrition;

        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;封装的接口方法&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.UI.WebControls;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; AOP.Common;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; BaiduAIAPI.Model.UnitModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; BaiduAIAPI.Type;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; BaiduAIAPI.UNIT
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UnderstandingAndInteractiveTechnology
    {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; unit对话接口&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; UnitModel Unit_Utterance(&lt;span&gt;string&lt;/span&gt; token, &lt;span&gt;string&lt;/span&gt; sceneId, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; query)
        {
            UnitModel result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnitModel();
            &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 基础校验
            &lt;span&gt;string&lt;/span&gt; error = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(token))
            {
                error &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token不能为空！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(sceneId))
            {
                error &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;场景编号不能为空！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(query))
            {
                error &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;询问问题不能为空！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(error))
            {
                result.error_msg &lt;/span&gt;=&lt;span&gt; error;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
            }
            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

            &lt;span&gt;string&lt;/span&gt; host = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://aip.baidubce.com/rpc/2.0/solution/v1/unit_utterance?access_token=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; token;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{\&quot;scene_id\&quot;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + sceneId + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,\&quot;query\&quot;:\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + query + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;, \&quot;session_id\&quot;:\&quot;\&quot;}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; json格式 &lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; tempResult =&lt;span&gt; HttpRequestHelper.Post(host, str);


             result&lt;/span&gt;=Json.ToObject&amp;lt;UnitModel&amp;gt;&lt;span&gt;(tempResult);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(result.error_code))
            {
                result.error_msg &lt;/span&gt;=&lt;span&gt; BaiduUnitType.GetErrorCodeToDescription(result.error_code);
                result.IsSuccess &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                result.IsSuccess &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                result.returnSay &lt;/span&gt;= result.result.action_list[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].say;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先用单元测试结果：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; BaiduAIAPI;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; BaiduAIAPI.UNIT;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.VisualStudio.TestTools.UnitTesting;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; AIAPIUnitTestProject.BaiduAIAPI
{
    [TestClass]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaiduUnitTest
    {
        [TestMethod]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestChat()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; accessTokenModel =&lt;span&gt; Access_Token.GetAccessToken(ConfigUnit.clientId, ConfigUnit.clientSecret);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (accessTokenModel.IsSuccess)
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; queryString = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;今天天气怎么样？&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tempUnitResult =&lt;span&gt; UnderstandingAndInteractiveTechnology.Unit_Utterance(accessTokenModel.SuccessModel.access_token, ConfigUnit.clientSceneId, queryString);

              

            }

        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;确定接口没有问题，结合到我们的Demo程序中，界面代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Forms;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Speech.Synthesis;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; BaiduAIAPI;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; BaiduAIAPI.UNIT;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; BaiduAIAPI.Model.UnitModel;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SpeechDemo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Form1 : Form
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Form1()
        {
            InitializeComponent();


        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button1_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tb_YourSay.Text.Trim() == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
            {

                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请你输入你要说的话！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            UnitModel result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnitModel();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; accessTokenModel =&lt;span&gt; Access_Token.GetAccessToken(ConfigUnit.clientId, ConfigUnit.clientSecret);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (accessTokenModel.IsSuccess)
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; queryString =&lt;span&gt; tb_YourSay.Text.Trim();
                result &lt;/span&gt;=&lt;span&gt; UnderstandingAndInteractiveTechnology.Unit_Utterance(accessTokenModel.SuccessModel.access_token, ConfigUnit.clientSceneId, queryString);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                result.returnSay &lt;/span&gt;=&lt;span&gt; result.error_msg;
            }
            tb_RobotSay.Text &lt;/span&gt;=&lt;span&gt; result.returnSay;
            SpeechSynthesizer voice &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SpeechSynthesizer();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建语音实例&lt;/span&gt;
            voice.Rate = &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置语速,[-10,10]&lt;/span&gt;
            voice.Volume = &lt;span&gt;100&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置音量,[0,100]&lt;/span&gt;
&lt;span&gt;           
            voice.SpeakAsync(result.returnSay);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;播放指定的字符串,这是异步朗读&lt;/span&gt;
&lt;span&gt;          

        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;结果展示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/580722/201712/580722-20171228183142631-1143377004.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;评价&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;理解和交互需要做大量的对话样本和语言交互纠错，才可以实现相对比较精准的回答。&lt;/p&gt;

</description>
<pubDate>Thu, 28 Dec 2017 10:35:00 +0000</pubDate>
<dc:creator>linbin524</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linbin524/p/8136799.html</dc:identifier>
</item>
</channel>
</rss>