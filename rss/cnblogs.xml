<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Framework框架解析（1）- 从图书馆示例来看xml文件的加载过程 - knock_小新</title>
<link>http://www.cnblogs.com/konck/p/9961121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/konck/p/9961121.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;这个系列是我阅读Spring源码后的一个总结，会从Spring Framework框架的整体结构进行分析，不会先入为主的讲解IOC或者AOP的原理，如果读者有使用Spring的经验再好不过。鉴于每个人对源码阅读角度的不同，如果文中存在理解有误的地方希望读者能够及时提出，共同进步。文章所分析的源码基于5.0.8版本，但使用老版本理解起来问题也不大，因为在框架整体架构上变化并不多。&lt;/p&gt;
&lt;p&gt;如果你使用Spring的时间足够长，相信在最初的开发过程中你一定使用过xml文件来加载各中bean。虽然现在基本都会通过配置文件类或者注解来进行加载，但使用xml也有它的优点，这种方式对代码的侵入性最小，而且配置第三方bean也比较方便。这篇文章通过一个图书馆的例子来讲解xml最原始的加载过程，将加载过程中涉及到的各个模块比做图书馆的各个元素，希望能加深你对Spring框架的理解。&lt;/p&gt;
&lt;p&gt;图书馆和Spring有许多相似的地方，将图书馆比做bean工厂，从图书馆借书相当于getBean的过程，将图书馆买的书放入图书馆的过程可以类比注册bean(registerBeanDefinition)的过程，而生产图书的过程又可以类比实例化BeanDefinition的过程，是不是很相似？这里我会使用下面一段比较原始的代码来分步讲解这一过程。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ClassPathResource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);
DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory); 
reader.loadBeanDefinitions(resource);
Object beanObject = factory.getBean(&quot;beanName&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;classpathresource与resource&quot;&gt;ClassPathResource与Resource&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ClassPathResource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一行代码比较简单，它通过一个xml文件初始化了一个Resource，相当于对xml文件做了一个包装，方便以后将xml文件转换为BeanDefinition。可以将这一过程想象成现在的图书还是一堆木头，而将这些木头搅拌成木浆只是为了后面更方便的获取制作图书的原料而已。&lt;/p&gt;
&lt;p&gt;从源码角度来说ClassPathResource继承自Resource接口，是Spring中对资源的抽象，所有需要使用的资源在Spring中都被抽象为Resource，它提供了一系列操作资源的方法，比如获取资源的名称，资源是否存在等等。Resource接口又继承了InputStreamSource接口，在InputStreamSource中，提供了一个核心方法，这个方法将资源转换成InputStream方便后期操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface InputStreamSource {
    InputStream getInputStream() throws IOException;
}

public interface Resource extends InputStreamSource {
    boolean exists();

    URL getURL() throws IOException;

    String getFilename();

    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;beanfactorybeandefinition与defaultlistablebeanfactory&quot;&gt;BeanFactory、BeanDefinition与DefaultListableBeanFactory&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;DefaultListableBeanFactory factory = new DefaultListableBeanFactory();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DefaultListableBeanFactory就比较重要了，它是一个Bean工厂，相当于图书馆，所有的书都在DefaultListableBeanFactory中，而借书，买书的过程都需要通过DefaultListableBeanFactory来操作。&lt;/p&gt;
&lt;p&gt;DefaultListableBeanFactory首先是BeanFactory接口的一个实现，BeanFactory定义了通过名称和类型获取Bean的一系列方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface BeanFactory {
    Object getBean(String name) throws BeansException;

    &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) throws BeansException;

    boolean containsBean(String name);

    ......
}

public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory
        implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次从DefaultListableBeanFactory的定义还可以看到，它在继承BeanFactory接口的基础上，还实现了BeanDefinitionRegistry接口。BeanDefinitionRegistry的核心功能是对Bean的注册，注册是干嘛呢？通过图书馆来对比，BeanFactory的getBean相当于从图书馆借书，那么这些书是哪来的呢？就是通过BeanDefinitionRegistry的registerBeanDefinition方法，它相当于把书放入图书馆，而DefaultListableBeanFactory就相当于图书馆本身了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface BeanDefinitionRegistry extends AliasRegistry {
    void registerBeanDefinition(String beanName, BeanDefinition beanDefinition);

    void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;

    BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;

    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在BeanDefinitionRegistry的定义中还有涉及到一个关键接口：BeanDefinition，上面说BeanDefinitionRegistry相当于把书放入图书馆，那么具体图书在图书馆中怎么表示呢？这就是BeanDefinition。BeanDefinition是Bean在Spring中的抽象，也就是说每一个Bean在Spring中都对应一个BeanDefinition，它提供了与Bean相对应的属性，并提供了操作Bean的方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {
    void setBeanClassName(@Nullable String beanClassName);

    String getBeanClassName();

    void setScope(@Nullable String scope);

    String getScope();

    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;beandefinitionreaderbeandefinitiondocumentreader与xmlbeandefinitionreader&quot;&gt;BeanDefinitionReader、BeanDefinitionDocumentReader与XmlBeanDefinitionReader&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory); 
reader.loadBeanDefinitions(resource);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还是通过图书馆来类比：图书馆是（DefaultListableBeanFactory），把书（BeanDefinition）放入图书馆的能力对应（BeanDefinitionRegistry），从图书馆拿编号后的书的能力对应（BeanFactory），书的原材料对应（ClassPathResource），现在就缺把书的原材料（ClassPathResource）变成一本本书（BeanDefinition），并将它放入图书馆中了。那么谁来将原材料（ClassPathResource）变成书（BeanDefinition）并放入到图书馆（DefaultListableBeanFactory）中呢？这就是XmlBeanDefinitionReader的工作了。这一过程可以通过以下源码来分析：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader{}
public abstract class AbstractBeanDefinitionReader implements EnvironmentCapable, BeanDefinitionReader{}

public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) {
    super(registry);
}

protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) {
    ......
    this.registry = registry;
    ......
}

public interface BeanDefinitionReader {
    BeanDefinitionRegistry getRegistry();

    ResourceLoader getResourceLoader();

    int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException;
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先XmlBeanDefinitionReader实现了BeanDefinitionReader接口，BeanDefinitionReader定义了一个关键方法loadBeanDefinitions(Resource resource)，这个方法将resource装载到BeanDefinitionRegistry中，BeanDefinitionRegistry通过XmlBeanDefinitionReader的构造方法传入。具体loadBeanDefinitions又是怎么做的呢？再来继续查看源代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
    ......
        //通过InputStreamSource接口的定义的getInputStream方法获取InputStream
        InputStream inputStream = encodedResource.getResource().getInputStream();
        try {
            //将InputStream包装成InputSource
            InputSource inputSource = new InputSource(inputStream);
            if (encodedResource.getEncoding() != null) {
                inputSource.setEncoding(encodedResource.getEncoding());
            }
            //将Source装载到BeanDefinitionRegistry中
            return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
        }
        finally {
            inputStream.close();
        }
    ......
}

protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
        throws BeanDefinitionStoreException {
    ......
    try {
        //将Source包装成Document
        Document doc = doLoadDocument(inputSource, resource);
        //将Document装载到BeanDefinitionRegistry中
        return registerBeanDefinitions(doc, resource);
    }
    ......
}

public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
    //这里创建了一个DefaultBeanDefinitionDocumentReader
    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
    int countBefore = getRegistry().getBeanDefinitionCount();

    //调用DefaultBeanDefinitionDocumentReader的registerBeanDefinitions方法将将Document装载到BeanDefinitionRegistry中
    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
    return getRegistry().getBeanDefinitionCount() - countBefore;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先将Resource转换为EncodedResource，然后通过getInputStream获取InputStream，调用doLoadBeanDefinitions方法来装载资源，在doLoadBeanDefinitions方法中，首先将Resource包装成Document方便操作元素节点，然后把解析并装载Document的功能委托了给BeanDefinitionDocumentReader，这里使用了一个默认的DefaultBeanDefinitionDocumentReader实现。那么可以想象DefaultBeanDefinitionDocumentReader中做了两件事：将Document解析为BeanDefinitions，然后将BeanDefinitions装载到BeanDefinitionRegistry中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
    this.readerContext = readerContext;
    logger.debug(&quot;Loading bean definitions&quot;);
    //从Document中获取到Element
    Element root = doc.getDocumentElement();

    //具体的解析过程
    doRegisterBeanDefinitions(root);
}

protected void doRegisterBeanDefinitions(Element root) {
    ......
    //前置解析，默认为空，可以重写
    preProcessXml(root);
    //具体的解析xml并注入到过程
    parseBeanDefinitions(root, this.delegate);
    //后置解析，默认为空，可以重写
    postProcessXml(root);
    ......
}

protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    ......
    parseDefaultElement(ele, delegate);
    ......
}

private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
    //解析&quot;import&quot;节点
    if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
        importBeanDefinitionResource(ele);
    }
    //解析&quot;alias&quot;节点
    else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
        processAliasRegistration(ele);
    }
    //解析&quot;bean&quot;节点
    else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
        processBeanDefinition(ele, delegate);
    }
    //解析&quot;beans&quot;节点
    else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
        // recurse
        doRegisterBeanDefinitions(ele);
    }
}

protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
    //将元素包装成BeanDefinitionHolder，方便操作BeanDefinition
    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
    if (bdHolder != null) {
        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
        try {
            //具体的注入方法
            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
        }
        ......
    }
}

public static void registerBeanDefinition(
        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
        throws BeanDefinitionStoreException {
    ......
    //通过BeanDefinitionRegistry将元素注入到DefaultListableBeanFactory中
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟之前猜测的一样，首先通过parseBeanDefinitions方法将所有的xml节点分步解析，之后将解析后的节点包装成BeanDefinitionHolder对象，最后通过BeanDefinitionRegistry的registerBeanDefinition方法将元素注入到BeanDefinitionRegistry中。&lt;/p&gt;
&lt;p&gt;整个解析到注入过程非常复杂，我只列出了核心步骤，从中可以看到XmlBeanDefinitionReader是怎么一步步将xml中的Bean节点变为BeanDefinition并放入到DefaultListableBeanFactory中的。还是用图书馆来类比：首先将原材料（ClassPathResource）变成纸张（Document），然后将纸张（Document）通过书籍制造工厂（BeanDefinitionDocumentReader）组装成一本本书籍（BeanDefinition），然后书籍制造工厂（BeanDefinitionDocumentReader）将一本本书籍（BeanDefinition）送到图书馆（DefaultListableBeanFactory），而XmlBeanDefinitionReader就扮演了这一整个过程的组合功能。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;至此，整个图书馆功能就齐全了，原材料可以造书，书可以放入图书馆，并且你也可以很方便的从图书馆借书。可以说Spring设计理念也在这一过程中得到体现，它将Bean的解析，Bean的定义，Bean的生产以及Bean的获取每一步都单独抽离开来，互不干扰，最后通过DefaultListableBeanFactory将它们整合到一起供用户使用。怎么说呢，这一过程回过头来并没有什么神奇的地方，但能清晰的将每个功能都抽象出来本身就需要非常好的抽象设计能力，而对这一过程的反复阅读与分析，一定能让你在设计抽象能力上有一定的提升。&lt;/p&gt;
&lt;p&gt;看完后你觉得这一过程类比是否恰当呢？如果你有更贴近生活的例子，不妨留言一起探讨，共同进步。说完DefaultListableBeanFactory，在下一篇文章中将会讲讲ApplicationContext接口，并对它的部分实现类做一个简单分析。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《Spring揭秘》&lt;/li&gt;
&lt;li&gt;《Spring源码深度解析》&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 14 Nov 2018 23:17:00 +0000</pubDate>
<dc:creator>knock_小新</dc:creator>
<og:description>引言 这个系列是我阅读Spring源码后的一个总结，会从Spring Framework框架的整体结构进行分析，不会先入为主的讲解IOC或者AOP的原理，如果读者有使用Spring的经验再好不过。鉴于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/konck/p/9961121.html</dc:identifier>
</item>
<item>
<title>Linux 桌面玩家指南：13. 使用 Git 及其 和 Eclipse 的集成 - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/LinuxDesktop013.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/LinuxDesktop013.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用&lt;code&gt;$&lt;/code&gt;标记数学公式的开始和结束。如果某条评论中出现了两个&lt;code&gt;$&lt;/code&gt;，MathJax 会将两个&lt;code&gt;$&lt;/code&gt;之间的内容按照数学公式进行排版，从而导致评论区格式混乱。如果大家的评论中用到了&lt;code&gt;$&lt;/code&gt;，但是又不是为了使用数学公式，就请使用&lt;code&gt;\$&lt;/code&gt;转义一下，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想从头阅读该系列吗？下面是传送门：&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;我是通过阅读《Pro Git》这本书学习 Git 的，我读的时候还是第一版的英文版，现在已经出第二版了，而且英文版和中文版都有。英文第二版的地址是 &lt;a href=&quot;https://git-scm.com/book/en/v2&quot; class=&quot;uri&quot;&gt;https://git-scm.com/book/en/v2&lt;/a&gt;，中文第二版的地址是&lt;a href=&quot;https://git-scm.com/book/zh/v2&quot; class=&quot;uri&quot;&gt;https://git-scm.com/book/zh/v2&lt;/a&gt;。想看第一版的话把地址中的&lt;code&gt;v2&lt;/code&gt;改成&lt;code&gt;v1&lt;/code&gt;就可以了。如果哪天突然链接打不开了，也别着急，记住《Pro Git》这个招牌，使用搜索引擎很快就能找到它。&lt;/p&gt;
&lt;h2 id=&quot;git-是什么&quot;&gt;Git 是什么&lt;/h2&gt;
&lt;p&gt;Git 是一个版本控制系统，它可以保存工作文件的所有修订版本。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。&lt;/p&gt;
&lt;p&gt;Git 的特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Git是分布式的版本控制系统，它没有中心服务器的概念（虽然实际开发中可以建一个中心服务器），每一台开发机器上都保存完整的历史记录；但是它有本地代码仓库和远程代码仓库的概念（不然怎么多人协作？），而且可以追踪多个远程仓库。&lt;/li&gt;
&lt;li&gt;Git 在没有网的情况下也可以工作。Git在本地磁盘上保存有项目的完整历史，Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。所以 Git 能够非常快地建立分支和合并分支，并具有强大的跟踪分支和切换分支的能力。大部分操作看起来瞬间完成。有网的时候，再向远程仓库 push 一下就行了。&lt;/li&gt;
&lt;li&gt;Git 一般只添加数据。你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。一旦你提交数据到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面是我简化了的 Git 使用小结，图片都来源于《Pro Git》第一版。&lt;/p&gt;
&lt;p&gt;每一个项目都应该有一个工作目录（Working directory），我们可以自己建一个目录，然后把这个目录里面的代码用 Git 管理起来（使用&lt;code&gt;git init&lt;/code&gt;命令和&lt;code&gt;git add&lt;/code&gt;命令），也可以通过&lt;code&gt;git clone&lt;/code&gt;命令从别的地方克隆一个项目过来自动生成一个工作目录。在工作目录中的文件就是当前编辑和修改的文件，如果是新建立的目录或新克隆来的目录，工作目录中的文件就是该项目最新的状态。Git 是在本地保存有所有的历史记录和分支记录的，这些内容都在工作目录的&lt;code&gt;.git&lt;/code&gt;目录中，称之为本地仓库（local repository）。当切换分支或查看以前的历史版本时，工作目录中的文件自动改变（这才是重点，工作无需切换目录，目录中的文件会自动切换）。工作目录中的文件有三种状态：已修改（modified）、已暂存（staged）、已提交（committed）。修改后的文件可以先加入暂存区域，一次工作结束后一起提交。&lt;/p&gt;
&lt;p&gt;Git是分布式的，没有中心服务器的概念，但实际工作中仍然可以把代码仓库放到一台大家都可以访问的服务器上，做实际的中心服务器使用（仅在小团队时使用此工作流程，原因后面详述）。在本地机器上工作完后，使用&lt;code&gt;git push&lt;/code&gt;命令把仓库推送到服务器上，换一个地方换一台机器后，只需要&lt;code&gt;git clone&lt;/code&gt;一下，又可以获得所有的代码（包含所有的历史记录及分支）继续工作。服务器故障也没问题，因为每一个工作的机器上都保存有完整的代码仓库，所以从不用担心代码丢失。没有网络也没有关系，在本地机器上照样可以提交（&lt;code&gt;git commit&lt;/code&gt;），因为整个仓库就在自己的机器上，当有网络时，&lt;code&gt;git push&lt;/code&gt;一下就可以了。&lt;/p&gt;
&lt;p&gt;Git有远程仓库（remote repository）的概念，而且可以管理很多个远程仓库，远程仓库可以是服务器，也可以是别人的个人计算机（但一般没有人这么用），每一个远程仓库都有一个简短的名字和一个地址，最开始用&lt;code&gt;git clone&lt;/code&gt;克隆代码的那个远程仓库别名往往默认为 origin，自己添加的远程仓库可以随意指定别名，当然所有的远程仓库都可以随意修改别名。可以从远程仓库获取代码（&lt;code&gt;git fetch&lt;/code&gt;命令或&lt;code&gt;git pull&lt;/code&gt;命令），也可以把自己的代码推送到远程仓库（&lt;code&gt;git push&lt;/code&gt;命令，需要写权限）。&lt;/p&gt;
&lt;p&gt;既然 Git 即可以随便从远程仓库获取代码，又可以把自己的代码推送到远程仓库，那么当多人协作时，岂不会乱套吗？解决这个问题的，就是 Git 的必杀之技——创建分支及分支合并。&lt;/p&gt;
&lt;p&gt;首先，随着一次次的提交，在本地代码库中形成一个主分支，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201609/16576-20160930204910531-113702076.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有时为了开发新特性，随时可以开一个新分支，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201609/16576-20160930204934610-1246833284.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新分支和主分支之间可以随意切换，随着分支的发展，形式如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201609/16576-20160930205011235-941718527.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主分支也可以向前发展，如下：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201609/16576-20160930205030235-273157597.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终，当新分支代码很稳定以后，可以将其合并到主分支，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201609/16576-20160930205053828-906117986.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而能够防止多人协作时出现混乱的关键就在于，当从远程仓库 clone 代码库到本地或 fetch 代码库到本地时，远程分支的标记并不等于本地分支的标记。从远程 clone 一个代码库到本地后，其 master 分支有两个标记，一个标记为 origin/master 表示远程库中的 master 分支，一个标记为 master，表示本地的 master 分支。如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201609/16576-20160930205246797-1037597449.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以想象，由于别人的工作，远程仓库中的 master 分支肯定会向前继续移动，但是在下次联网之前，该 origin/master 标记不会移动。而本地的 master 标记继续向前移动。&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201609/16576-20160930205319313-2034782602.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直到下次联网，使用&lt;code&gt;git fetch&lt;/code&gt;命令将远程仓库的内容取回本地，origin/master 标记才会改变位置，这时，看起来就像是两个分支，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201609/16576-20160930205406703-1430558200.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，将 origin/master 分支合并到 master 分支中（使用&lt;code&gt;git merge&lt;/code&gt;命令），本地代码库又一次变成了一个单一的 master 分支，继续向前开发，并可以将它 push 到远程仓库，供别人使用。&lt;/p&gt;
&lt;p&gt;Git冲突的处理完全靠人工完成。（从逻辑上讲，机器也不可能完美处理冲突。）比如一个小型团队一起工作，他们可以设置一个服务器用于保存远程 Git 仓库，然后每个人工作之前先从该远程仓库 fetch 代码，接着工作，工作完成后，先在本地提交，最后 push 到远程仓库。但是当一个人 push 的时候，已经有人在他之前 push 了，如果他们工作在同一个分支，就会出现冲突。解决冲突的办法就是先把别人 push 的内容再次 fetch 下来，合并分支，然后再 push。&lt;/p&gt;
&lt;p&gt;通过前面对git原理的了解，可以分析得出使用Git时有以下几种工作流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个人单干，不需要考虑冲突，随时可以开分支、合并分支和切换分支，随时可以本地提交。如果为了防止代码丢失，可以开一个服务器，每次工作完成就 push 到服务器上；&lt;/li&gt;
&lt;li&gt;小型团队合作，如前所述，开一个服务器保存代码仓库，然后所有的人把该服务器当成远程仓库，工作之前先 fetch，工作之后再 push。如果有冲突，则先 fetch，合并分支解决冲突后再 push。如果团队人数太多，每个人都向该服务器 push，那冲突该是有多少？有可能一个开发者第一次向服务器 push 的时候，有人在他之前已经 push 过了，他只好先 fetch，手工合并解决冲突，可等他再次 push 的时候，发现又有人再他之前已经 push 了，于是他只好再做一次解决冲突的流程，可是如果在他工作的时候，又有人 push 了呢？这也是之前讲的该工作流程只适合小型开发团队的原因。&lt;br/&gt;以上流程经过适当修改也可以供大型团队使用，那就是将团队分组，每个组的成员共用一个服务器当远程仓库，组长合并了该组的工作成果后，再push到另一个服务器当总的远程仓库，这样就可以大大减少冲突的数量，减少工作量。&lt;/li&gt;
&lt;li&gt;开源项目的合作，在这种情况下，每个人都把自己的仓库暴露在互联网上。开源项目的组织者或负责人将所有人的仓库设为远程仓库，并把有意义的工作合并到主分支，然后发布官方的 Git 仓库。每个开发者从官方仓库 fetch 代码后，完成自己的工作，然后再把它 push 到互联网上自己的仓库，等着项目负责人将自己的工作整合到官方仓库中。如果项目负责人不干了，改人了，只要还有人继续开发，该项目就可以继续下去。碰到团队比较大的情况，也可以进行分组。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Git 服务器的建设也相当简单，因为 Git 支持以 SSH、HTTP 等协议传输数据，如果需要对服务器有写权限，就开通 SSH 服务吧，设一个账户供所有人访问 Git 仓库即可。如果只需要读权限，使用任何一个 HTTP 服务器均可。关于 Git 服务器的建设，请自行参考官方文档。如果是个人的、开源的项目，可以使用 Github 网站提供的服务，直接存储在互联网上。（Github 私人仓库是要收钱的。）&lt;/p&gt;
&lt;h2 id=&quot;在-eclipse-中使用-git&quot;&gt;在 Eclipse 中使用 Git&lt;/h2&gt;
&lt;p&gt;得益于 Eclipse 中的 EGit 插件，在 Eclipse 中使用 Git 非常简单。任何一个项目，都可以使用快捷菜单中的 &quot;Team&quot; -&amp;gt; &quot;Share Project&quot; 将文件交给版本控制软件管理，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005093117160-1764911049.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在最流行的版本控制软件当然是非 Git 莫属了。Eclipse 会提示我们创建一个 Git 仓库（Repository）。Eclipse 中的项目（Project）是一个比较小的概念，它不能等同于 Git 中的工作目录（Working Directory），Git 中也没有项目的概念，但是在 Git 的工作目录中管理多个文件夹是没有什么问题的，而 Eclipse 中的项目就是一个文件夹，所以，在 Git 的一个工作目录中管理多个 Project 是没有问题的。因此，只有 Eclipse 的工作区（Workspace）才等同于 Git 中的工作目录（Working Directory）。而 Git 的仓库（Repository）一般是放在 Git 工作目录中的一个&lt;code&gt;.git&lt;/code&gt;目录，考虑到 Eclipse 的工作区（Workspace）中本来就已经包含了很多元数据，再在里面创建一个&lt;code&gt;.git&lt;/code&gt;目录，并且在里面存放 Git 的数据容易引起混乱，因此最好是把 Git 的工作目录和仓库创建在 Eclipse 的 Workspace 之外。幸好，Eclipse 支持这样的功能。如下图，点击 &quot;Create&quot; 按钮，创建一个 Git 仓库，这里输入的路径&lt;code&gt;/home/youxia/git/samples&lt;/code&gt;其实是一个工作目录：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005093151082-855613349.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从下图可以看出，工作目录为&lt;code&gt;/home/youxia/git/samples&lt;/code&gt;，Git 的仓库为&lt;code&gt;/home/youxia/git/samples/.git&lt;/code&gt;，原本在 Workspace 中的项目 JavaIODemo 被自动移到了&lt;code&gt;/home/youxia/git/samples&lt;/code&gt;目录中：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005093237598-593709678.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以使用 Navigator 视图查看项目中所有的文件，没有被 Git 跟踪的文件其图标中显示一个小问号。可以使用 &quot;Ignore&quot; 菜单项让 Git 忽略对某些文件的跟踪，比如源代码编译后产生的类文件，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005093308489-1686050053.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 &quot;Add to Index&quot; 菜单项让 Git 对那些需要进行版本控制的文件进行跟踪，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005093334192-1764259302.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进行提交，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005093405098-1583158135.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提交时需输入 Commit Message，并指定 Author 和 Committer，可以查看此次提交涉及哪些文件。如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005093432426-1620797410.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;已提交的文件其图标又会发生变化，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005093525223-943380217.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看一下在一个仓库中管理多个项目。再创建两个项目，JaasDemo 和 SecurityDemo，点击菜单项 &quot;Share Project&quot;，在弹出的对话框中，不再选择创建仓库，而是选择现有的仓库，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005093553004-1863682620.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;操作完成后，这三个项目都被同一个 Git 仓库所管理。再有更多的项目都可以添加到这个仓库中。我在 Github 中注册了一个账号，youxia 这个用户名已经被占用了，所以我只能用 youxia-cn，cn 代表中国，其实这个账号挺好记的。然后，我又创建了一个 samples 仓库，用来存放我博客中写的源代码。以后大家需要参看我的源代码的时候，只需要访问 &lt;a href=&quot;https://github.com/youxia-cn/samples&quot; class=&quot;uri&quot;&gt;https://github.com/youxia-cn/samples&lt;/a&gt; 就可以了。&lt;/p&gt;
&lt;p&gt;最后，把我本地的仓库推送（Push）到 Github 中，如下三图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005093637223-1342454593.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005093649989-2046710344.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005093718676-180381290.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;clonepull-和-fetch&quot;&gt;Clone、Pull 和 Fetch&lt;/h2&gt;
&lt;p&gt;从远程仓库中获取数据的方法有多种。如果是第一次获取远程仓库，可以使用&lt;code&gt;git clone&lt;/code&gt;命令。在 Eclipse 中，需要使用 &quot;File&quot; -&amp;gt; &quot;Import&quot; 功能。下面换一台电脑，这台电脑安装的是 Ubuntu 系统，启动 Eclipse，点击菜单 &quot;File&quot; -&amp;gt; &quot;Import&quot;，获取刚才存放在 Github 中的项目，在弹出的对话框中输入正确的 URL 后，一路 Next，如下动图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005110317645-1588320691.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以使用 &quot;Show in History&quot; 和 &quot;Show in Repositories View&quot; 查看仓库的详细信息，如下两图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005110446129-1607607273.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005110456942-8941209.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从远程仓库获取数据还可以使用&lt;code&gt;git pull&lt;/code&gt;命令，其对应的 GUI 操作界面如下：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005110543645-2009691334.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，它会让你选择是将远程仓库中的分支 Merge 到本地的当前分支还是将本地的当前分支 Rebase 到远程仓库中的分支。使用 Pull 功能时，分支的 Merge 和 Rebase 是自动进行的，所以如果没有准备好的话，不要轻易使用。&lt;/p&gt;
&lt;p&gt;安全的做法是使用&lt;code&gt;git fetch&lt;/code&gt;命令从远程仓库获取数据。Fetch 过来的分支不会自动合并，你可以切换到这些分支进行查看，然后手工进行合并。其操作界面如下：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005111020957-1852763213.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;checkoutresetmerge-和-rebase&quot;&gt;Checkout、Reset、Merge 和 Rebase&lt;/h2&gt;
&lt;p&gt;前面介绍过，随着 Git 一次次的提交，会形成一个主分支，除此之外，还可以创建新的分支。通过&lt;code&gt;git branch&lt;/code&gt;命令创建新分支，通过&lt;code&gt;git checkout&lt;/code&gt;命令切换分支。在 Git 中，有一个&lt;code&gt;HEAD&lt;/code&gt;指针总是指向当前正在工作的分支，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005211747707-1751742101.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果切换分支，&lt;code&gt;HEAD&lt;/code&gt;指针也会随着移动，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005211905973-453077713.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时，还可以使用&lt;code&gt;git reset&lt;/code&gt;命令改变&lt;code&gt;HEAD&lt;/code&gt;指针的指向，以达到撤销操作的目的。随意改变&lt;code&gt;HEAD&lt;/code&gt;指针的指向是危险的，特别是使用&lt;code&gt;git reset&lt;/code&gt;命令的&lt;code&gt;--hard&lt;/code&gt;选项的话，它会使我们的部分工作丢失。在《Pro Git》的第二版中专门有一节“重置揭秘”对该命令及其涉及的原理进行了论述。在 GUI 中使用 Reset 也是非常简单的，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005213046707-1931786081.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而分支的合并又有两种方式，Merge 和 Rebase。Merge 比较简单，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005213258551-210983764.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在图中有两个分支 origin 和 mywork，origin 做了提交 C3 和 C4，mywork 做了提交 C5 和 C6。如果将这两个分支合并的话，就会产生提交 C7，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005213459301-1823665727.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是如果使用 Rebase 就不一样了，如果把 mywork 分支 Rebase 到 origin 上，就相当于把 C5 和 C6 中针对 C2 所做的修改在 C4 上重演一次，产生了 C5' 和 C6' 两次提交，而原有的 C5 和 C6 会被丢弃，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201610/16576-20161005213709176-53203650.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，Reset 和 Rebase 都是比较危险的命令，有引起数据丢失的风险。但是在 Git 中，只要是曾经 Commit 过的数据，都是可以找回来的，可以参考《Pro Git》中“维护与数据恢复”这一节（第一版位于第 9 章，第二版位于第 10 章）。另外，《Pro Git》提到，对于已经公开发布到远程仓库中的代码，不要使用 Rebase，否则会引起版本库的混乱。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;GUI 界面的使用没有什么困难的，难的是理解 Git 中的概念，比如 Push、Pull、Clone、Fetch、Checkout、Reset、Merge、Rebase 什么的。学习 Git 最好的办法，当然是认真阅读《Pro Git》这本宝典。除了使用 GUI，最好也能多敲一下命令行，这样对 Git 会有更加深入的了解。&lt;/p&gt;
&lt;h2 id=&quot;求打赏&quot;&gt;求打赏&lt;/h2&gt;
&lt;p&gt;我对这次写的这个系列要求是非常高的：首先内容要有意义、够充实，信息量要足够丰富；其次是每一个知识点要讲透彻，不能模棱两可含糊不清；最后是包含丰富的截图，让那些不想装 Linux 系统的朋友们也可以领略到 Linux 桌面的风采。如果我的努力得到大家的认可，可以扫下面的二维码打赏一下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180831154735325-1276475036.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2018年11月15日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Wed, 14 Nov 2018 23:05:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>特别说明： 要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用 标记数学公式的开始和结束。如果某条评论中出现了两个 ，MathJax 会将两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop013.html</dc:identifier>
</item>
<item>
<title>python包导入细节 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9961372.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9961372.html</guid>
<description>&lt;h2 id=&quot;包导入格式&quot;&gt;包导入格式&lt;/h2&gt;
&lt;p&gt;导入模块时除了使用模块名进行导入，还可以使用目录名进行导入。例如，在sys.path路径下，有一个dir1/dir2/mod.py模块，那么在任意位置处都可以使用下面这种方式导入这个模块。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import dir1.dir2.mod
from dir1.dir2.mod import XXX&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个实际一点的示例，设置PYTHONPATH环境变量为&lt;code&gt;d:\pypath&lt;/code&gt;，然后在此目录下创建以上目录和mod.py文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set PYTHONPATH=&quot;D:\pypath&quot;
mkdir d:\pypath\dir1\dir2
echo print(&quot;mod.py&quot;) &amp;gt;d:\pypath\dir1\dir2\mod.py
echo x=3 &amp;gt;&amp;gt;d:\pypath\dir1\dir2\mod.py

# 进入交互式python
&amp;gt;&amp;gt;&amp;gt; import dir1.dir2.mod
mod.py
&amp;gt;&amp;gt;&amp;gt; dir1.dir2.mod.x
3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注1：在python3.3版本及更高版本是可以导入成功的，但是在python3.3之前的版本将失败，因为缺少&lt;code&gt;__init__.py&lt;/code&gt;文件，稍后会解释该文件&lt;br/&gt;注2：顶级目录dir1必须位于sys.path列出的路径搜索列表下&lt;/p&gt;
&lt;p&gt;如果输出dir1和dir2，将会看到它们的是模块对象，且是&lt;strong&gt;名称空间&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import dir1.dir2.mod
mod.py

&amp;gt;&amp;gt;&amp;gt; dir1
&amp;lt;module 'dir1' (namespace)&amp;gt;

&amp;gt;&amp;gt;&amp;gt; dir1.dir2
&amp;lt;module 'dir1.dir2' (namespace)&amp;gt;

&amp;gt;&amp;gt;&amp;gt; dir1.dir2.mod
&amp;lt;module 'dir1.dir2.mod' from 'd:\\pypath\\dir1\\dir2\\mod.py'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种&lt;code&gt;模块+名称空间&lt;/code&gt;的形式就是包(严格地说是包的一种形式)，也就是说dir1是包，dir2也是包，这种方式是包的导入形式。包主要用来组织它里面的模块。&lt;/p&gt;
&lt;p&gt;从上面的结果也可以看出，&lt;strong&gt;包也是模块，所以能使用模块的地方就能使用包&lt;/strong&gt;。例如下面的代码，可以像导入模块一样直接导入包dir2，包和模块的区别在于它们的组织形式不一样，模块可能位于包内，仅此而已。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import dir1.dir2
from dir1 import dir2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，导入dir1.dir2.mod时，它声明的模块变量名为dir1，而不是dir1.dir2.mod，但是导入的对象却包含了3个模块：dir1、dir1.dir2以及dir1.dir2.mod。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'dir1']

&amp;gt;&amp;gt;&amp;gt; for key in sys.modules:
...     if key.startswith(&quot;dir1&quot;):
...             print(key,&quot;:&quot;,sys.modules[key])
...
dir1 : &amp;lt;module 'dir1' (namespace)&amp;gt;
dir1.dir2 : &amp;lt;module 'dir1.dir2' (namespace)&amp;gt;
dir1.dir2.mod : &amp;lt;module 'dir1.dir2.mod' from 'd:\\pypath\\dir1\\dir2\\mod.py'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;init__.py文件&quot;&gt;__init__.py文件&lt;/h2&gt;
&lt;p&gt;上面的dir1和dir1.dir2目前是空包，或者说是空模块(再一次强调，包就是模块)。但并不意味着它们对应的模块对象是空的，因为模块是对象，只要是对象就会有属性。例如，dir1包有如下属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dir(dir1)
['__doc__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'dir2']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之所以称为空包，是因为它们现在仅提供了包的组织功能，而且它们是目录，而不像py文件一样，是实实在在的可以编写模块代码的地方。换句话说，包现在是目录文件，而不是真正的模块文件。&lt;/p&gt;
&lt;p&gt;为了让包&quot;真正的&quot;成为模块，需要在每个包所代表的目录下加入一个&lt;code&gt;__init__.py&lt;/code&gt;文件，它表示让这个目录格式的模块(也就是包)像py文件一样可以写模块代码，只不过这些模块代码是写入&lt;code&gt;__init__.py&lt;/code&gt;中的。当然，模块文件中允许没有任何内容，所以&lt;code&gt;__init__.py&lt;/code&gt;文件也可以是空文件，它仅表示让包成为真正的模块文件。&lt;/p&gt;
&lt;p&gt;每次导入包的时候，如果有&lt;code&gt;__init__.py&lt;/code&gt;文件，将&lt;strong&gt;会自动执行这个文件中的代码，就像模块文件一样，事实上它就是让目录代表的包变成模块的，甚至可以说它就是包所对应的模块文件&lt;/strong&gt;(见下面示例)，所以也可以认为&lt;code&gt;__init__.py&lt;/code&gt;是包的初始化文件。在python3.3之前，这个文件必须存在，否则就会报错，因为它不认为目录是有效的模块。&lt;/p&gt;
&lt;p&gt;现在，在dir1和dir2下分别创建空文件&lt;code&gt;__init__.py&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type nul&amp;gt;d:\pypath\dir1\__init__.py
type nul&amp;gt;d:\pypath\dir1\dir2\__init__.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在目录的层次格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;λ tree /f d:\pypath
D:\PYPATH
└─dir1
    │  __init__.py
    └─dir2
            mod.py
            __init__.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再去执行导入操作，并输出包dir1和dir2。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import dir1.dir2.mod
mod.py

&amp;gt;&amp;gt;&amp;gt; dir1
&amp;lt;module 'dir1' from 'd:\\pypath\\dir1\\__init__.py'&amp;gt;

&amp;gt;&amp;gt;&amp;gt; dir1.dir2
&amp;lt;module 'dir1.dir2' from 'd:\\pypath\\dir1\\dir2\\__init__.py'&amp;gt;

&amp;gt;&amp;gt;&amp;gt; dir1.dir2.mod
&amp;lt;module 'dir1.dir2.mod' from 'd:\\pypath\\dir1\\dir2\\mod.py'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从输出结果中不难看出，包dir1和dir1.dir2是模块，且它们的模块文件是各自目录下的&lt;code&gt;__init__.py&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;实际上，&lt;strong&gt;包分为两种：名称空间模块、普通模块&lt;/strong&gt;。名称空间包是没有&lt;code&gt;__init__.py&lt;/code&gt;文件的，普通包是有&lt;code&gt;__init__.py&lt;/code&gt;文件的。无论是哪种，它都是模块。&lt;/p&gt;

&lt;h3 id=&quot;init__.py写什么内容&quot;&gt;__init__.py写什么内容&lt;/h3&gt;
&lt;p&gt;既然包是模块，而&lt;code&gt;__init__.py&lt;/code&gt;文件是包的模块文件，这个文件中应该写入什么代码？答案是可以写入任何代码，我们只需把它当作一个模块对待就可以。不过，包既然是用来组织模块的，真正的功能性属性应该尽量写入到它所组织的模块文件中(也就是示例中的mod.py)。&lt;/p&gt;
&lt;p&gt;但有一项&lt;code&gt;__all__&lt;/code&gt;是应该在&lt;code&gt;__init__.py&lt;/code&gt;文件中定义的，它是一个列表，用来控制&lt;code&gt;from package import *&lt;/code&gt;使用&lt;code&gt;*&lt;/code&gt;导入哪些模块文件。这里的&lt;code&gt;*&lt;/code&gt;并非像想象中那样会导入包中的所有模块文件，而是只导出&lt;code&gt;__all__&lt;/code&gt;列表中指定的模块文件。&lt;/p&gt;
&lt;p&gt;例如，在dir1.dir2包下有mod1.py、mod2.py、mod3.py和mod4.py，如果在&lt;code&gt;dir2/__init__.py&lt;/code&gt;文件中写入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;__all__ = [&quot;mod1&quot;, &quot;mod2&quot;, &quot;mod3&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from dir1.dir2 import *&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不会导入mod4，而是只导入mod1-mod3。&lt;/p&gt;
&lt;p&gt;如果不设置&lt;code&gt;__all__&lt;/code&gt;，则&lt;code&gt;from dir1.dir2 import *&lt;/code&gt;不会导入该包下的任何模块，但会导入dir1和dir1.dir2。&lt;/p&gt;

&lt;h2 id=&quot;path__属性&quot;&gt;__path__属性&lt;/h2&gt;
&lt;p&gt;严格地说，只有当某个模块设置了&lt;code&gt;__path__&lt;/code&gt;属性时，才算是包，否则只算是模块。这是包的绝对严格定义。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__path__&lt;/code&gt;属性是一个路径列表(可迭代对象即可，但通常用列表)，和&lt;code&gt;sys.path&lt;/code&gt;类似，该列表中定义了该包的初始化模块文件&lt;code&gt;__init__.py&lt;/code&gt;的路径。&lt;/p&gt;
&lt;p&gt;只要导入的是一个包(无论是名称空间包还是普通包)，首先就会设置该属性，默认导入目录时该属性会初始化当前目录，然后去该属性列出的路径下搜索&lt;code&gt;__init__.py&lt;/code&gt;文件对包进行初始化。默认情况下由于&lt;code&gt;__init__.py&lt;/code&gt;文件后执行，在此文件中可以继续定义或修改&lt;code&gt;__path__&lt;/code&gt;属性，使得python会去找其它路径下的&lt;code&gt;__init__.py&lt;/code&gt;对模块进行初始化。&lt;/p&gt;
&lt;p&gt;以下是默认初始化后的&lt;code&gt;__path__&lt;/code&gt;值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import dir1.dir2
&amp;gt;&amp;gt;&amp;gt; dir1.dir2.__path__
['d:\\pypath\\dir1\\dir2']

&amp;gt;&amp;gt;&amp;gt; import dir1.dir3
&amp;gt;&amp;gt;&amp;gt; dir1.dir3
&amp;lt;module 'dir1.dir3' (namespace)&amp;gt;
&amp;gt;&amp;gt;&amp;gt; dir1.dir3.__path__
_NamespacePath(['d:\\pypath\\dir1\\dir3'])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般来说，几乎不会设置&lt;code&gt;__path__&lt;/code&gt;属性。&lt;/p&gt;

&lt;h2 id=&quot;导入示例&quot;&gt;导入示例&lt;/h2&gt;
&lt;p&gt;import和from导入时有多种语法可用，这两个语句的导入方式和导入普通模块的方式是一样的：import导入时需要使用前缀名称去引用，from导入时是赋值到当前程序的同名全局变量中。如果不了解，请看前一篇文章：&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9955485.html&quot;&gt;python模块导入细节&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;假设现在有如下目录结构，且d:\pypath位于sys.path列表中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ tree -f d:\pypath
d:\pypath
└── dir1
    ├── __init__.py
    └── dir2
        ├── __init__.py
        └── mod.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只导入包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import dir1             # 导入包dir1
import dir1.dir2        # 导入包dir1.dir2
from dir1 import dir2   # 导入包dir1.dir2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导入某个模块：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import dir1.dir2.mod
from dir1.dir2 import mod&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果&lt;code&gt;dir2/__init__.py&lt;/code&gt;中设置了&lt;code&gt;__all__&lt;/code&gt;，则下面的导入语句会导入已设置的模块：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from dir1.dir2 import *&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，只支持上面这种&lt;code&gt;from...import *&lt;/code&gt;语法，不支持&lt;code&gt;import *&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;导入模块中的属性，比如变量x：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from dir1.dir2.mod import x&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;相对路径导入&quot;&gt;相对路径导入&lt;/h2&gt;
&lt;p&gt;注：如果允许，不要使用相对路径导入，很容易出错，特别是对新手而言。使用绝对路径导入，并将包放在sys.path的某个路径下就可以。&lt;/p&gt;
&lt;p&gt;假设现在有如下目录结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ tree -f d:\pypath
d:\pypath
└── dir1
    ├── __init__.py
    ├── dir4
    │   ├── __init__.py
    │   ├── c2.py
    │   └── c1.py
    ├── dir3
    │   ├── __init__.py
    │   ├── b3.py
    │   ├── b2.py
    │   └── b1.py
    └── dir2
        ├── __init__.py
        ├── a4.py
        ├── a3.py
        ├── a2.py
        └── a1.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在dir1.dir2.a1模块文件中想要导入dir1.dir3.b2模块，可以在a1.py中使用下面两种方式导入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import dir1.dir3.b2
from dir1.dir2. import b2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的导入方式是使用绝对路径进行导入的，只要使用绝对路径，都是从sys.path开始搜索的。例如，上面是从sys.path下搜索dir1，再依次搜索dir1.dir3.b2。&lt;/p&gt;
&lt;p&gt;python还支持包的相对路径的导入，只要使用&lt;code&gt;.&lt;/code&gt;或&lt;code&gt;..&lt;/code&gt;即可，就像操作系统上的相对路径一样。使用相对路径导入时不会搜索sys.path。&lt;/p&gt;
&lt;p&gt;相对路径导入方式只有&lt;code&gt;from...import&lt;/code&gt;支持，&lt;code&gt;import&lt;/code&gt;语句不支持，且只有使用&lt;code&gt;.&lt;/code&gt;或&lt;code&gt;..&lt;/code&gt;的才算是相对路径，&lt;strong&gt;否则就是绝对路径，就会从sys.path下搜索&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，在a1.py中导入dir1.dir3.b2：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from ..dir3 import b2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，必须不能直接&lt;code&gt;python a1.py&lt;/code&gt;执行这个文件，这样会报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    from ..dir3 import b2
ValueError: attempted relative import beyond top-level package&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;报错原因稍后解释。现在在交互式模式下导入，或者使用&lt;code&gt;python -m dir1.dir2.a1&lt;/code&gt;的方式执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import dir1.dir2.a1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下几个示例都如此测试。&lt;/p&gt;
&lt;p&gt;在a1.py中导入包dir3：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from .. import dir3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在a1.py中导入dir1.dir2.a2，也就是同目录下的a2.py：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from . import a2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导入模块的属性，如变量x：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from ..dir3.b2 import x
from .a2 import x&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;相对路径导入陷阱&quot;&gt;相对路径导入陷阱&lt;/h3&gt;
&lt;p&gt;前面说过一个相对路径导入时的错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    from ..dir3 import b2
ValueError: attempted relative import beyond top-level package&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dir3明明在dir1下，在路径相对上，dir3确实是a1.py的&lt;code&gt;../dir3&lt;/code&gt;，但执行&lt;code&gt;python a1.py&lt;/code&gt;为什么会报错？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from ..dir3 import b2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为文件系统路径并不真的代表包的相对路径，当在dir1/a1.py中使用&lt;code&gt;..dir3&lt;/code&gt;，python并不知道包dir1的存在，因为没有将它导入，没有声明为模块变量，同样，也不知道dir2的存在，仅仅只是根据语句直到了dir3的存在。但因为使用了相对路径，不会搜索sys.path，所以它的相对路径边界只在本文件。所以，下面的导入也是错误的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from . import a2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，更标准的解释是，当py文件作为可执行程序文件执行时，它所在的模块名为&lt;code&gt;__main__&lt;/code&gt;，即&lt;code&gt;__name__&lt;/code&gt;为&lt;code&gt;__main__&lt;/code&gt;，但它并非一个包，而是一个模块文件，对它来说没有任何相对路径可言。&lt;/p&gt;
&lt;p&gt;解决方法是显式导入它们的父包，让python记录它的存在，只有这样才能使用&lt;code&gt;..&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python -m dir1.dir2.a2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有几个常见的相对路径导入错误:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from .a3 import x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ModuleNotFoundError: No module named '__main__.a3'; '__main__' is not a package&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原因是一样的，py文件作为可执行程序文件执行时，它所在的模块名为&lt;code&gt;__main__&lt;/code&gt;，它并非一个包。&lt;/p&gt;
&lt;p&gt;最后，建议在条件允许的情况下，使用绝对路径导入，而不是相对路径。&lt;/p&gt;

&lt;h2 id=&quot;使用别名导入&quot;&gt;使用别名导入&lt;/h2&gt;
&lt;p&gt;通过包的导入方式也支持别名。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from dir1.dir2.a2 import x as xx
print(xx)

import dir1.dir2.a2 as a2
print(a2.x)

from dir1.dir2 import a2 as a22
print(a22.x)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 14 Nov 2018 17:29:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>包导入格式 导入模块时除了使用模块名进行导入，还可以使用目录名进行导入。例如，在sys.path路径下，有一个dir1/dir2/mod.py模块，那么在任意位置处都可以使用下面这种方式导入这个模块。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9961372.html</dc:identifier>
</item>
<item>
<title>[UWP]使用Popup构建UWP Picker - HHChaos</title>
<link>http://www.cnblogs.com/hhchaos/p/9961249.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhchaos/p/9961249.html</guid>
<description>&lt;p&gt;在上一篇博文《&lt;a href=&quot;https://www.cnblogs.com/hhchaos/p/9925745.html&quot;&gt;[UWP]不那么好用的ContentDialog&lt;/a&gt;》中我们讲到了ContentDialog在复杂场景下使用的几个令人头疼的弊端。那么，就让我们在这篇博文里开始愉快的造轮子之旅吧！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先要向大家说明：这篇博文主要还是写的构建Picker时的思考过程，如果不感兴趣的，可以直接略过这篇，阅读下一篇《&lt;a href=&quot;https://www.cnblogs.com/hhchaos/p/9961258.html&quot;&gt;[UWP]如何使用Picker实现一个简单的ColorPicker弹窗&lt;/a&gt;》。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先针对上篇文章中讲到的ContentDialog的几个缺点，先来梳理一下我们对新的弹窗层组件的需求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;能实现正常Dialog的弹出关闭流程（必须的，不然怎么来替代ContentDialog？）；&lt;/li&gt;
&lt;li&gt;可以支持同时弹出多层弹窗（解决ContentDialog的弊病）；&lt;/li&gt;
&lt;li&gt;适用于MVVM框架，提供给ViewModel层调用接口（越简单越友好越好，松耦合）；&lt;/li&gt;
&lt;li&gt;友好的返回值（方便调用方直接获取想要的结果）；&lt;/li&gt;
&lt;li&gt;要实现ContentDialog类似的可定制化能力（弹出位置，自定义UI,动画等）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面的文章里，为了方便描述，我把实现上诉功能的新弹窗层组件称之为Picker（类似于UWP文件选择器的叫法）。&lt;/p&gt;
&lt;p&gt;简化一下需求，我们的Picker主要有三个功能规划：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Picker的调用呈现方式为弹出一个类似于ContentDialog的弹窗，但是可以多层级的调用（即多层弹窗）；&lt;/li&gt;
&lt;li&gt;Picker的业务逻辑实现层遵循共同的调用约束（即实现Picker定义的相关接口），基于此约束实现的MVVM页均可实现Picker的调用方式；&lt;/li&gt;
&lt;li&gt;实现Picker约束的相关类本身实现独立的Pick功能（即调用后返回特定类型值）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们简单的类比下，上面对Picker的功能规划其实有点类似于Windows系统中的文件查看逻辑。&lt;/p&gt;
&lt;p&gt;在Windows系统中，可以处理某类格式文件（例如.mp4文件）的程序可以向系统申明支持该格式，当系统需要处理这类文件时（例如双击打开.mp4文件），将会调用这个程序（或者询问用户使用哪一个支持该类文件的程序）来处理该文件。&lt;/p&gt;
&lt;p&gt;有了明确的功能规划，我们就可以来思考如何实现了。&lt;/p&gt;
&lt;h4 id=&quot;如何实现picker的界面层呈现&quot;&gt;如何实现Picker的界面层呈现&lt;/h4&gt;
&lt;p&gt;我们已经说过了，ContentDialog的内部实现其实是依赖Popup，因此我们同样可以用Popup来承载Picker的界面显示。&lt;/p&gt;
&lt;p&gt;Popup本身是一个非常基础的组件（UWP中另外一个常用的组件Flyout也是基于Popup实现的），它在UWP应用的可视化树中是处于最顶层的（PopupRoot），且呈现在应用最前面（可以理解为具有最大值的ZIndex）。基于Popup我们可以实现很多不依赖程序主界面的UI功能，并且不受ContentDialog只能同时显示一个的限制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1239018/201811/1239018-20181115001333567-552058678.png&quot; alt=&quot;可视化树&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样的话就非常简单了，我们可以构建一个ObjectPicker类，它提供类似ContentDialog类中ShowAsync的方法，调用此方法时创建一个新的Popup，然后将我们要显示的界面元素作为其Child添加到界面上（实际上，结合MVVM框架逻辑，我们使用Frame装载目标页面），在用户完成Pick操作后关闭Popup,并且返回操作结果。&lt;/p&gt;
&lt;p&gt;呈现过程的核心，三句代码足以：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    var popup = new Popup();
    //ToDo 装载Picker界面
    popup.IsOpen = true;
    //ToDo 处理Pick交互操作
    popup.IsOpen = false;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，涉及到具体实现时，由于我们要考虑到界面呈现的UI交互、位置及动画，实际代码会更多一点。&lt;/p&gt;
&lt;p&gt;ObjectPicker类只负责呈现目标页面，它不负责处理任何的业务逻辑。&lt;/p&gt;
&lt;h4 id=&quot;如何实现picker的业务逻辑&quot;&gt;如何实现Picker的业务逻辑&lt;/h4&gt;
&lt;p&gt;在我们的规划中，Picker的实际业务逻辑是在Picker页面的逻辑层代码，即ViewModel层中实现的。这样的话，什么时候Picker可以关闭是由其ViewModel决定的。为了使ViewModel的处理结果可以通知到Picker，我们需要让实现Picker功能的ViewModel遵循一个共同的约束。&lt;/p&gt;
&lt;p&gt;我们定义这样一个泛型接口：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IObjectPicker&amp;lt;T&amp;gt;
{
    event EventHandler&amp;lt;ObjectPickedEventArgs&amp;lt;T&amp;gt;&amp;gt; ObjectPicked;
    event EventHandler Canceled;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中T代表这个ViewModel支持的Pick对象类型，当用户完成Pick操作时触发ObjectPicked事件，用户取消Pick操作时触发Canceled事件，ObjectPicker类将在Show的时候注册这两个事件来接受ViewModel的处理结果。&lt;/p&gt;
&lt;h4 id=&quot;如何优雅的调用picker&quot;&gt;如何优雅的调用Picker&lt;/h4&gt;
&lt;p&gt;当我们实现了一个Picker以后，如何来调用它呢？使用最简单的方法，直接在需要调用Picker的地方new一个ObjectPicker，然后调用ShowAsync来获取返回值？&lt;/p&gt;
&lt;p&gt;这看起来没什么问题，但是实际应用中，我们的Picker可能有很多个（文字输入框，颜色选取器等）。我们希望有一个类似于Windows系统注册表的服务，它提供：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不同类型的Picker注册接口及管理；&lt;/li&gt;
&lt;li&gt;提供简单友好的Picker调用接口，并且返回Pick结果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样的话，我们可以简单的实现一个ObjectPickerService，通过它，我们的调用逻辑会非常的简单：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var pickRet = await pickerService.PickSingleObjectAsync&amp;lt;Color&amp;gt;(typeof(TestColorPickerViewModel).FullName);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子可以在我的开源项目HHChaosToolkit中的Picker部分看到（&lt;a href=&quot;https://github.com/HHChaos/HHChaosToolkit&quot;&gt;GitHub链接点这里&lt;/a&gt;），同时也是我的下篇博文的主要内容。&lt;/p&gt;
&lt;p&gt;这篇文章到这里就结束了，主要还是讲如何构建Picker组件的思考过程，以及我基于对MVVM结构的理解，如何来梳理Picker的架构。下一篇文章我将结合例子介绍一下Picker的实例实现及其调用流程。&lt;/p&gt;
&lt;p&gt;写这篇博文着实有些难产，如果有什么地方写的不够好，或者难以理解，欢迎大家指正！谢谢阅读！&lt;/p&gt;
</description>
<pubDate>Wed, 14 Nov 2018 16:16:00 +0000</pubDate>
<dc:creator>HHChaos</dc:creator>
<og:description>在上一篇博文《</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhchaos/p/9961249.html</dc:identifier>
</item>
<item>
<title>salesforce lightning零基础学习(八) Aura Js 浅谈一: Component篇 - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/9892767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/9892767.html</guid>
<description>&lt;p&gt;我们在开发lightning的时候，常常会在controller.js中写 component.get('v.label'), component.set('v.label','xxValue');&lt;/p&gt;
&lt;p&gt;小伙伴肯定有疑问这些方法是怎么定义的，lightning到底有多少已经声明的方法可供我们使用，此篇主要讲述aura framework为我们提供的 component的js的主要方法。&lt;/p&gt;
&lt;p&gt;本人salesforce环境切换到lightning，URL为：https://zero-zhang-dev-ed.lightning.force.com。&lt;/p&gt;
&lt;p&gt;每个人的URL不同，URL 保留到force.com，然后添加一下URL: /auradocs/reference.app 即可看到aura的文档，aura文档里面给我们提供了aura framework 所有的支持的标签的描述以及使用，js的描述以及使用等等。此篇我们只是对 component的js进行说明，其他感兴趣的可以自行查看。&lt;/p&gt;
&lt;p&gt; 点击JavaScript API, 切换到 Component，可以查看到 Aura提供的所有的方法，常用的部分方法描述如下：&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201811/910966-20181104232855614-963060668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. set (String key, Object value)：&lt;/strong&gt;此方法最为常见了，对 attribute 设置值的引用。&lt;/p&gt;
&lt;p&gt;eg: component.set(&quot;v.testAttribute&quot;,&quot;hello lightning&quot;) : 此赋值逻辑代表 对 testAttribute 这个attribute 赋值，内容为“hello lightning”; 此方法通常用于对attribute赋值，这里不多做举例；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.get(String key)：&lt;/strong&gt;此方法也是最为常见的，使用属性语法返回引用的值。通常有两种用法：&lt;/p&gt;
&lt;p&gt;　　1)component.get(&quot;v.testAttribute&quot;): 此逻辑代表获取当前component中attribute名称为testAttribute的值；&lt;/p&gt;
&lt;p&gt;　　2)componnet.get(&quot;c.testAction&quot;): 此逻辑代表获取后台apex controller中的 testAction方法，用于和后台交互操作；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.find(&lt;small class=&quot;params&quot; data-aura-rendered-by=&quot;631:1713;a&quot;&gt;&lt;span class=&quot;paramType&quot; data-aura-rendered-by=&quot;637:1713;a&quot;&gt;String &lt;span class=&quot;paramType&quot; data-aura-rendered-by=&quot;641:1713;a&quot;&gt;| &lt;span class=&quot;paramType&quot; data-aura-rendered-by=&quot;645:1713;a&quot;&gt;Object name&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/small&gt;)：&lt;/strong&gt;此方法用于通过local id 获取到指定的 component。我们知道lightning每个元素都默认有一个属性:aura:id， 此属性用来标记这个组件元素的local id，理论上local id是唯一的，但是实际操作中可以不唯一，所以find这个方法返回值可以有多种形式，如果 component中针对所查的local id有不止一个，则返回一个数组来盛接，如果有一个，则直接返回当前元素，如果不存在，则直接返回undefined；&lt;/p&gt;
&lt;p&gt; eg: component.find(&quot;helloWorld&quot;): 此逻辑代表获取 component 中local id为helloWorld的组件元素，如果不存在则返回undefined；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.getLocalId():&lt;/strong&gt; 此方法用于获取组件元素的local id, 此方法通常用于通过事件获取事件的元素组件以后，获取元素组件的local id;&lt;/p&gt;
&lt;p&gt;eg: TestComponent.cmp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;Global_Id&quot;&lt;/span&gt;&lt;span&gt; aura:id&lt;/span&gt;&lt;span&gt;=&quot;Local_Id&quot;&lt;/span&gt;&lt;span&gt; label&lt;/span&gt;&lt;span&gt;=&quot;Get Local Id&quot;&lt;/span&gt;&lt;span&gt; 
                      onclick&lt;/span&gt;&lt;span&gt;=&quot;{!c.getLocalId}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Controller.js 端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;({
    getLocalId : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; button =&lt;span&gt; event.getSource();
        console.log(button.getLocalId());
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5. getGlobalId():&lt;/strong&gt; 此方法用于获取组件元素的global id, 此方法通常用于事件获取事件元素组件以后，获取元素组件的global id;&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;p&gt;将上面的方法改成 getGlobalId即可；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;({
    getGlobalId : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; button =&lt;span&gt; event.getSource();
        console.log(button.getGlobalId());
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;6.getName()：&lt;/strong&gt;此方法用来获取当前的组件元素的名称。例如上面的TestComponent.cmp， 当我们在getGlobalId 增加 console.log(component.getName());时会打印出TestComponent；&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;7.getEvent(String eventName)：&lt;/strong&gt;通过component中注册的事件名称获取事件的实例化对象；&lt;small class=&quot;params&quot; data-aura-rendered-by=&quot;810:1721;a&quot;&gt;&lt;br/&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;我们假设 component 中注册了一个事件 testEvent , 它对应了一个handler名字为 testHandler,当我们点击某个button时，会触发后台的方法,此方法用于获取到事件对象并触发此事件，执行此事件对应的handler；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
testButtonHandler : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component,event,helper) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testEvent = component.getEvent('testEvent'&lt;span&gt;);
    testEvent.setParam(&lt;/span&gt;'testEventParam','testValue'&lt;span&gt;);
    testEvent.fire();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-aura-rendered-by=&quot;930:1721;a&quot;&gt;&lt;strong&gt;8.getReference(String key)：&lt;/strong&gt;此方法通常用于动态创建component时使用，通过属性语法返回这个值的一个实体引用。比如动态创建 button时，我们想让他的handler为controller.js中已有的一个方法testHandler作为handler，我们就可以使用 getReference('testHandler')获取到这个方法的实体引用，在$A.createComponent我们在对这个进行demo。除了可以经常用于动态创建component，我们也可以在addEventHandler进行使用，下面的函数会有此种方式的demo；&lt;/p&gt;
&lt;p data-aura-rendered-by=&quot;930:1721;a&quot;&gt;&lt;strong&gt;9.addEventHandler (String event, function handler, String phase, Boolean includeFacets)：&lt;/strong&gt;动态的创建事件的handler，此方法有几个参数：&lt;/p&gt;
&lt;p data-aura-rendered-by=&quot;930:1721;a&quot;&gt;event: event的名字，这个名字需要和 aura:registerEvent名字保持一致；&lt;/p&gt;
&lt;p data-aura-rendered-by=&quot;930:1721;a&quot;&gt;handler：针对这个事件想要动态处理的handler，此handler可以有两种方式，一种是通过 component.getReference方法使用现有的handler，另外一种是通过异步方法块去执行handler部分；&lt;/p&gt;
&lt;p data-aura-rendered-by=&quot;930:1721;a&quot;&gt;phase：Bubble / Capture, 对这部分不了解的可以参看：&lt;a href=&quot;https://www.cnblogs.com/zero-zyq/p/9313371.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/zero-zyq/p/9313371.html&lt;/a&gt;&lt;/p&gt;
&lt;p data-aura-rendered-by=&quot;930:1721;a&quot;&gt;includeFacets：如果设置为true，则尝试捕捉通过facet生成的元素的事件；&lt;/p&gt;
&lt;p data-aura-rendered-by=&quot;930:1721;a&quot;&gt; 我们在&lt;a href=&quot;https://www.cnblogs.com/zero-zyq/p/9313371.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/zero-zyq/p/9313371.html&lt;/a&gt;有过demo测试过多层元素套用情况下事件阶段的展示，我们将eventBubblingEmitterController.js进行代码修改：使用动态创建事件handler方式进行创建，当按照事件执行排序执行到eventBubblingEmitter.component时，会执行testEventHandler方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;({
    fireEvent : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(cmp) {
        cmp.addEventHandler(&lt;/span&gt;'bubblingEvent', cmp.getReference('c.testEventHandler'&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cmpEvent = cmp.getEvent(&quot;bubblingEvent&quot;&lt;span&gt;);
        cmpEvent.fire();
    },
    testEventHandler : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(cmp) {
        console.log(&lt;/span&gt;'test event handler'&lt;span&gt;);
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;执行效果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201811/910966-20181114230919824-1288402218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;总结：&lt;/strong&gt;此篇只是简单的描述了Aura Framework中的Component对象常用的方法，其他的方法感兴趣的自行查看，篇中有错误的内容欢迎指出，不懂得欢迎留言。&lt;/p&gt;
</description>
<pubDate>Wed, 14 Nov 2018 15:57:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<og:description>我们在开发lightning的时候，常常会在controller.js中写 component.get('v.label'), component.set('v.label</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/9892767.html</dc:identifier>
</item>
<item>
<title>如何通过 Scrapyd + ScrapydWeb 简单高效地部署和监控分布式爬虫项目 - my8100</title>
<link>http://www.cnblogs.com/my8100/p/scrapydweb.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/my8100/p/scrapydweb.html</guid>
<description>&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;需求分析&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;初级用户：
&lt;ul&gt;&lt;li&gt;只有一台开发主机&lt;/li&gt;
&lt;li&gt;能够通过 Scrapyd-client 打包和部署 Scrapy 爬虫项目，以及通过 Scrapyd JSON API 来控制爬虫，感觉&lt;strong&gt;命令行操作太麻烦&lt;/strong&gt;，希望能够通过浏览器直接部署和运行项目&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;专业用户：
&lt;ul&gt;&lt;li&gt;有 N 台云主机，通过 Scrapy-Redis 构建分布式爬虫&lt;/li&gt;
&lt;li&gt;希望集成身份认证&lt;/li&gt;
&lt;li&gt;希望在页面上直观地查看所有云主机的运行状态&lt;/li&gt;
&lt;li&gt;希望能够自由选择部分云主机，&lt;strong&gt;一键部署和运行爬虫项目，实现集群管理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;希望自动执行日志分析，以及爬虫进度可视化&lt;/li&gt;
&lt;li&gt;希望在出现特定类型的异常日志时能够及时通知用户，包括自动停止当前爬虫任务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;安装和配置&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;所有主机都已经安装和启动 Scrapyd&lt;/li&gt;
&lt;li&gt;开发主机或任一台主机安装 ScrapydWeb：  &lt;span class=&quot;cnblogs_code&quot;&gt;pip &lt;span&gt;install&lt;/span&gt; scrapydweb&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;运行命令  &lt;span class=&quot;cnblogs_code&quot;&gt;scrapydweb -h&lt;/span&gt; ，将在当前工作目录生成 &lt;a href=&quot;https://github.com/my8100/scrapydweb/blob/master/scrapydweb/default_settings.py&quot; target=&quot;_blank&quot;&gt;scrapydweb_settings.py&lt;/a&gt; 配置文件&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;启用 HTTP 基本认证
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ENABLE_AUTH =&lt;span&gt; True
USERNAME &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
PASSWORD &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;添加 Scrapyd server，支持字符串和元组两种配置格式，支持添加认证信息和分组/标签
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
SCRAPYD_SERVERS =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'username:password@localhost:6801#group',&lt;/span&gt;
    (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6801&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;group&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;通过运行命令  &lt;span class=&quot;cnblogs_code&quot;&gt;scrapydweb&lt;/span&gt;  启动 ScrapydWeb&lt;/li&gt;
&lt;/ol&gt;&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt; &lt;/h2&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;访问 Web UI&lt;/h2&gt;
&lt;p&gt;通过浏览器访问 &lt;a href=&quot;http://127.0.0.1:5000/&quot; target=&quot;_blank&quot;&gt;http://127.0.0.1:5000&lt;/a&gt;，输入认证信息登录&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Overview 页面自动输出所有 Scrapyd server 的运行状态&lt;/li&gt;
&lt;li&gt;通过分组和过滤可以自由选择若干台 Scrapyd server，调用 Scrapyd 提供的所有 JSON API，&lt;strong&gt;实现一次点击，批量执行&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201811/892328-20181114231107879-1504449511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt; &lt;/h2&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;部署项目&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;支持指定若干台 Scrapyd server 部署项目&lt;/li&gt;
&lt;li&gt;通过配置  &lt;span class=&quot;cnblogs_code&quot;&gt;SCRAPY_PROJECTS_DIR&lt;/span&gt;  指定 Scrapy 项目开发目录，&lt;em&gt;ScrapydWeb&lt;/em&gt; 将自动列出该路径下的所有项目，自动打包和部署指定项目&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201811/892328-20181114231243157-50215385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果 &lt;em&gt;ScrapydWeb&lt;/em&gt; 并非运行于当前开发主机，除了支持上传常规的 egg 文件，也可以将整个项目文件夹添加到 zip/tar/tar.gz 压缩文件后直接上传即可&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201811/892328-20181114231322068-56497660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;运行爬虫&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;通过下拉框直接选择 project，version 和 spider&lt;/li&gt;
&lt;li&gt;支持传入 Scrapy settings 和 spider arguments&lt;/li&gt;
&lt;li&gt;同样支持指定若干台 Scrapyd server 运行爬虫&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201811/892328-20181114231535163-575321436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;日志分析和可视化&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;ScrapydWeb&lt;/em&gt; &lt;strong&gt;默认在后台定时自动读取和分析 Scrapy log 文件并生成 Stats 页面&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201811/892328-20181114231643789-1289704513.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;爬虫进度可视化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201811/892328-20181114231724110-694327864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt;邮件通知&lt;/h2&gt;
&lt;ol&gt;&lt;li readability=&quot;-1.5&quot;&gt;配置邮箱认证信息
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
SMTP_SERVER = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;smtp.qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
SMTP_PORT &lt;/span&gt;= 465&lt;span&gt;
SMTP_OVER_SSL &lt;/span&gt;=&lt;span&gt; True
SMTP_CONNECTION_TIMEOUT &lt;/span&gt;= 10&lt;span&gt;

FROM_ADDR &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;username@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
EMAIL_PASSWORD &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
TO_ADDRS &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;设置邮件工作时间和定时通知间隔，以下示例为：每隔1小时或某一任务完成时，并且当前时间是工作日的9点，12点和17点，ScrapydWeb &lt;strong&gt;&lt;strong&gt;将会发送邮件告知当前运行任务的统计信息&lt;/strong&gt;&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
EMAIL_WORKING_DAYS = [1, 2, 3, 4, 5&lt;span&gt;]
EMAIL_WORKING_HOURS &lt;/span&gt;= [9, 12, 17&lt;span&gt;]
ON_JOB_RUNNING_INTERVAL &lt;/span&gt;= 3600&lt;span&gt;
ON_JOB_FINISHED &lt;/span&gt;= True
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;基于后台定时执行日志分析，ScrapydWeb &lt;strong&gt;提供多种 log 类型触发器及其阈值设置&lt;/strong&gt;，包括 'CRITICAL', 'ERROR', 'WARNING', 'REDIRECT', 'RETRY', 'IGNORE'等。以下示例为：当发现3条或3条以上的 critical 级别的 log 时自动停止当前任务，如果当前时间在邮件工作时间内，则同时发送通知邮件。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
LOG_CRITICAL_THRESHOLD = 3&lt;span&gt;
LOG_CRITICAL_TRIGGER_STOP &lt;/span&gt;=&lt;span&gt; True
LOG_CRITICAL_TRIGGER_FORCESTOP &lt;/span&gt;=&lt;span&gt; False
...
LOG_IGNORE_TRIGGER_FORCESTOP &lt;/span&gt;= False
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-7&quot;&gt;Github 开源&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/my8100/scrapydweb&quot; target=&quot;_blank&quot;&gt;my8100 / scrapydweb&lt;/a&gt; 更多实用功能正在开发中，欢迎 Star 和提交 Issue&lt;/p&gt;

</description>
<pubDate>Wed, 14 Nov 2018 15:26:00 +0000</pubDate>
<dc:creator>my8100</dc:creator>
<og:description>需求分析 初级用户： 只有一台开发主机 能够通过 Scrapyd-client 打包和部署 Scrapy 爬虫项目，以及通过 Scrapyd JSON API 来控制爬虫，感觉命令行操作太麻烦，希望能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/my8100/p/scrapydweb.html</dc:identifier>
</item>
<item>
<title>MongoDB添加仲裁节点报错replica set IDs do not match办法 - 洲渚皓月掩映</title>
<link>http://www.cnblogs.com/chou1214/p/9961094.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chou1214/p/9961094.html</guid>
<description>&lt;p&gt;背景:由于历史原因，某个MongoDB副本集只有一主一从双节点，无法满足自动故障转移要求，需要配置一个仲裁节点。&lt;/p&gt;
&lt;p&gt;原有节点192.168.10.20:27017,192.168.10.21:27017，现在准备在20上配置一个新节点27018当做仲裁&lt;/p&gt;

&lt;p&gt;在当前主节点上执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
repset:PRIMARY&amp;gt; cfg={_id:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;repset&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, members:[{_id:&lt;span&gt;0&lt;/span&gt;, host:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.10.20:27017&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, priority:&lt;span&gt;1&lt;/span&gt;},{_id:&lt;span&gt;2&lt;/span&gt;, host:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.10.21:27017&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, priority:&lt;span&gt;2&lt;/span&gt;}, {_id:&lt;span&gt;3&lt;/span&gt;, host:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.10.20:27018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, arbiterOnly:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;}]};

repset:PRIMARY&lt;/span&gt;&amp;gt; rs.reconfig(cfg)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1287962/201811/1287962-20181114230932472-798112339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显示配置是成功的，接着用命令查看副本集状态时，发现仲裁节点不可用，报错信息replica set IDs do not match。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
repset:PRIMARY&amp;gt; rs.status()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1287962/201811/1287962-20181114230655757-1329131161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网上的各种文档都是说①查看副本集的名称是否一致 ②把节点上的数据全都删掉。&lt;/p&gt;
&lt;p&gt;我在确认副本集配置名称一致后，删除仲裁节点的数据时发现：1、通过客户端是无法删除副本集配置集合；2、删除底层物理文件会导致Mongod进程启动失败。&lt;/p&gt;
&lt;p&gt;在仔细回想initiate一次性副本集配置的操作时，发现配置后，只启动了一个客户端。我的猜想是会不会是因为我启动了仲裁节点的客户端，仲裁节点生成了单独的副本集ID。&lt;/p&gt;
&lt;p&gt;于是我将副本集的配置文件db、log、Mongodb.conf全都删除，并重新命令启动MongoD进程后，直接在当前Primary节点按之前的操作添加仲裁节点后，发现仲裁节点已正常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1287962/201811/1287962-20181114231923585-2138158830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;结论：目前只是证实了我的猜想，还没找到官方的说法。&lt;/p&gt;
&lt;p&gt;在添加副本集节点的时候，新增的节点在启动服务后，&lt;span&gt;一定不要连接客户端，否则新增节点会生成另外的副本集ID，虽然副本集名称一致，但是IDs不一致会报错。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 14 Nov 2018 15:25:00 +0000</pubDate>
<dc:creator>洲渚皓月掩映</dc:creator>
<og:description>背景:由于历史原因，某个MongoDB副本集只有一主一从双节点，无法满足自动故障转移要求，需要配置一个仲裁节点。 原有节点192.168.10.20:27017,192.168.10.21:27017</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chou1214/p/9961094.html</dc:identifier>
</item>
<item>
<title>Linux Ubuntu系统之PPP拨号经验分享 - 文刚技术博客</title>
<link>http://www.cnblogs.com/xifarm/p/9961015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xifarm/p/9961015.html</guid>
<description>&lt;p&gt;近期，工作需要，我负责开发PPP拨号模块。&lt;br/&gt;说起拨号，算算时间，我已经做过2次了, 暴露年龄了，呵呵。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;第一次是刚毕业做的PPOE拨号，给电信做拨号软件，在河北石家庄工作过一段时间，基于windows xp。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;第二次是在移动网优，3G手机路测，即著名的TD-SCDMA，基于AT指令控制手机驱动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这次，是用的PPPD拨号，在Linux系统下。&lt;br/&gt;pppd 拨号模块，Linux系统是自带的, 就像windows下自带的RAS拨号一样，打印机等很多应用需要通过拨号方式进行通信的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Ubuntu 14.04.5 LTS (GNU/Linux 3.13.0-161-generic x86_64)&lt;br/&gt;pppd 2.4.5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文档，配置4个文件：&lt;/p&gt;
&lt;p&gt;/etc/ppp/peers/myvpn 账号信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;remotename myvpn
linkname myvpn 
ipparam myvpn
pty &quot;pptp *** --nolaunchpppd --loglevel 0&quot;
lock
nodeflate
name ***
usepeerdns
require-mppe
noauth
require-mppe-128
defaultroute
mtu 1416 #特别关键！！！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/etc/ppp/chap-secrets VPN用户名密码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/etc/ppp/options 默认设置项&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;lcp-echo-failure 10 # (from /etc/ppp/options)
lcp-echo-interval 10 # (from /etc/ppp/options)
lock
crtscts
nodeflate
persist
asyncmap 0
noauth
hide-password
noipx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/etc/ppp/options.pptp 设置项&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;lock
noauth
refuse-pap
refuse-eap
refuse-chap
refuse-mschap
nobsdcomp
nodeflate
require-mppe-128
ipparam myvpn
defaultroute&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;个人总结的技巧：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一定要升级python3.4 --&amp;gt; python3.7?&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我开始很纠结Python版本，代码开发是Python3.7最新版，而Ubuntu自带的是Python 3.4, 故想办法升级python3.7，如果在本地网速很快，这个不是什么难事，1小时工作量。&lt;/p&gt;
&lt;p&gt;但是，远程链接SSH，VPS服务器在国外，网速卡的厉害，本来1小时工作，忙乎了一个上午才搞定，升级到python3.6 + pip3 。 但是一想，我还有n个服务器呢，故晚上加班把代码降级为pyhon 3.4，这样部署就方便多了 -- 非原则问题，不要在环境上折腾太久，条条大路通罗马嘛。&lt;/p&gt;
&lt;p&gt;这个事情，给我很大的启示：不要做战略的矮子，再勤劳的执行力, 团队的效率也上不来的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平衡、成本、决策！&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;部署python程序，background job running&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;windows开发C#很多年，除了前几年做Unity3D开发的游戏APP（含VR、AR），这些都是有GUI界面的，而在Linux下，第一个门槛就是无UI界面。&lt;br/&gt;调试程序通过，部署后，我关闭ssh下班了，吃完饭，远程ssh，怎么我的python程序不见了，惊讶不已，才***行代码，而且我写的是 while true 循环，不可能自己退出啊。&lt;br/&gt;nohup python3 main.py &amp;amp;&lt;br/&gt;ps ax | grep py&lt;/p&gt;
&lt;p&gt;上网搜索，多亏google，很快就明白了，SSH通过22端口，开启了一个“session”，一般，如你执行 python3 main.py，随着SSH Session结束，Linux会kill这个process的。 而这个PPP拨号程序需要作为一个长时间运行的，故需要用 nohup 和 &amp;amp; 关键字，这样当你退出ssh，这个程序会驻留系统。&lt;/p&gt;
&lt;p&gt;那么问题来了，查询运行的process，常用的 ps all就是不灵了。&lt;/p&gt;
&lt;p&gt;要用 ps ax | grep py 才可以。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;linux常用工具工具&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[ ] vi 编辑器，linux运维必备神器！&lt;/li&gt;
&lt;li&gt;[ ] cat /var/log/syslog | grep pppd #输出mylog.log, search pppd&lt;/li&gt;
&lt;li&gt;[ ] cat /var/log/syslog | tail -n 100 #输出mylog.log 文件最后100行&lt;/li&gt;
&lt;li&gt;[ ] egrep -v '#|^ *$' /etc/ppp/options #正则，列出配置文件起作用的&lt;/li&gt;
&lt;li&gt;[ ] * &quot;&amp;gt;&quot; /var/log/syslog #clear syslog&lt;/li&gt;
&lt;li&gt;[ ] * dhclient -v -4 : refresh network #重新获得IP.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;参考文档：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://superuser.com/questions/949520/wvdial-ppp0-and-setting-default-route-automatically&quot; class=&quot;uri&quot;&gt;https://superuser.com/questions/949520/wvdial-ppp0-and-setting-default-route-automatically&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://askubuntu.com/questions/891393/vpn-pptp-in-ubuntu-16-04-not-working&quot; class=&quot;uri&quot;&gt;https://askubuntu.com/questions/891393/vpn-pptp-in-ubuntu-16-04-not-working&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/simonshi/archive/2010/04/23/1718984.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/simonshi/archive/2010/04/23/1718984.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 14 Nov 2018 15:04:00 +0000</pubDate>
<dc:creator>文刚技术博客</dc:creator>
<og:description>Linux Ubuntu系统之PPP拨号经验分享</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xifarm/p/9961015.html</dc:identifier>
</item>
<item>
<title>T-SQL基础（二）之关联查询 - 雪飞鸿</title>
<link>http://www.cnblogs.com/Cwj-XFH/p/9960822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Cwj-XFH/p/9960822.html</guid>
<description>&lt;p&gt;在上篇博文中介绍了&lt;a href=&quot;https://www.cnblogs.com/Cwj-XFH/p/9898835.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;T-SQL查询的基础知识&lt;/a&gt;，本篇主要介绍稍微复杂的查询形式。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;表运算符&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;表运算符的作用是把为其提供的表作为输入，经过逻辑查询处理，返回一个表结果。SQL Server支持四个表运算符：JOIN、APPLY、PIVOT、UNPIVOT，其中JOIN是标准SQL中的运算符，APPLY、PIVOT和UNPIVOT是T-SQL的扩展。&lt;/p&gt;
&lt;p&gt;JOIN：联接查询时使用&lt;/p&gt;
&lt;p&gt;APPLY：用于FROM子句中，分为&lt;code&gt;CROSS APPLY&lt;/code&gt;和&lt;code&gt;OUTER APPLY&lt;/code&gt;两种形式&lt;/p&gt;
&lt;p&gt;PIVOT：用于行转列&lt;/p&gt;
&lt;p&gt;UNPIVOT：用于列传行&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;联接查询&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;联接查询分为外联接、内联接、交叉联接，三者的区别在于如何应用逻辑查询处理阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;交叉联接仅应用一个阶段——笛卡尔乘积；&lt;/li&gt;
&lt;li&gt;内联接应用两个阶段——笛卡尔乘积和基于谓词&lt;code&gt;ON&lt;/code&gt;的筛选；&lt;/li&gt;
&lt;li&gt;外联结应用三个极端——笛卡尔乘积，基于谓词&lt;code&gt;ON&lt;/code&gt;的筛选，添加外部行；&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;内部行 &amp;amp; 外部行&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;内部行指的是基于谓词ON与另一侧匹配的行，外部行则是未匹配的行，外部行用NULL进行填充。内联接结果集仅保留内部行，外联接结果集返回内部行和外部行。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;笛卡尔乘积&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;将一个输入表的每一行与另一个表的所有行匹配，即，&lt;em&gt;&lt;em&gt;如果一张表有m行a列，另一张表n行b列，笛卡尔乘积后得到的表有m&lt;/em&gt;n行，a+b列&lt;/em&gt;*。由此可以看出，对于数据量较大的表进行关联的话，会得到一张数据量更大的表，会有可能造成内存溢出的。&lt;/p&gt;
&lt;p&gt;以下是网络上关于笛卡尔乘积的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;21.674876847291&quot;&gt;
&lt;p&gt;在数学中，两个集合X和Y的&lt;a href=&quot;http://www.baike.com/wiki/%E7%AC%9B%E5%8D%A1%E5%84%BF&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;笛卡儿&lt;/a&gt;积（Cartesian product），又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员。假设集合A=a, b，集合B=0, 1, 2，则两个集合的笛卡尔积为(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)。类似的例子有，如果A表示某学校学生的集合，B表示该学校所有课程的集合，则A与B的笛卡尔积表示所有可能的选课情况。A表示所有声母的集合，B表示所有韵母的集合，那么A和B的笛卡尔积就为所有可能的汉字全拼。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UserInfo;
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;CROSS&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; dbo.UAddress;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;得到结果集如下：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1687&quot; data-height=&quot;577&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784150/201811/784150-20181114222338003-365389404.jpg&quot; alt=&quot;&quot; width=&quot;1541&quot; height=&quot;527&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;交叉联接&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;SQL中使用&lt;code&gt;CROSS JOIN&lt;/code&gt;语句进行交叉联接查询，在逻辑处理上，交叉联接是最为简单的联接类型，它只获取表的笛卡尔乘积。&lt;/p&gt;
&lt;p&gt;交叉联接两种写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 使用CROSS JOIN，推荐使用这种方式&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;CROSS&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; dbo.UAddress;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 不使用CROSS JOIN&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt; dbo.UserInfo,dbo.UAddress;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;&lt;span&gt;内联接&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;SQL中使用&lt;code&gt;INNER JOIN...ON...&lt;/code&gt;语句进行内联接查询，&lt;code&gt;INNER&lt;/code&gt;关键字可选。内联接的逻辑处理分为两步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成笛卡尔乘积&lt;/li&gt;
&lt;li&gt;根据谓词&lt;code&gt;ON&lt;/code&gt;对笛卡尔乘积进行筛选&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与交叉联接一样，内联接有两种写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 使用JOIN，推荐使用这种方式&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress
&lt;/span&gt;&lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UserInfo.UAddressId &lt;span&gt;=&lt;/span&gt;&lt;span&gt; UAddress.Id;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 不使用JOIN，与交叉联接类似，但比交叉联接多了WHERE条件&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress,dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; UserInfo.UAddressId &lt;span&gt;=&lt;/span&gt; UAddress.Id;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;&lt;span&gt;外联接&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;外联接分为左外联接：&lt;code&gt;LEFT OUT JOIN&lt;/code&gt;、右外联接：&lt;code&gt;RIGHT OUT JOIN&lt;/code&gt;和全联接：&lt;code&gt;FULL OUT JOIN&lt;/code&gt;，其中，&lt;code&gt;OUT&lt;/code&gt;关键字是可选的。相比于交叉联接和内联接，外联接则最为复杂。外联接逻辑处理分为三步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取表的笛卡尔乘积&lt;/li&gt;
&lt;li&gt;根据谓词&lt;code&gt;ON&lt;/code&gt;对笛卡尔乘积进行筛选&lt;/li&gt;
&lt;li&gt;添加外部行数据到结果集中&lt;/li&gt;
&lt;/ol&gt;&lt;h6&gt;&lt;span&gt;&lt;strong&gt;LEFT JOIN &amp;amp; RIGHT JOIN&lt;/strong&gt;&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;code&gt;LEFT JOIN&lt;/code&gt;获取的结果集中保留了左表（LEFT JOIN左侧的表）中的所有数据，及右表中满足筛选条件的数据。右表中不满足筛选条件的空行（外部行）则用NULL值填充。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RIGHT JOIN&lt;/code&gt;与&lt;code&gt;LEFT JOIN&lt;/code&gt;作用相反。&lt;/p&gt;
&lt;p&gt;示例代码如下，表UserInfo中有4条数据，表UAddress中有三条数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress
&lt;/span&gt;&lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UserInfo.UAddressId &lt;span&gt;=&lt;/span&gt;&lt;span&gt; UAddress.Id;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress
&lt;/span&gt;&lt;span&gt;RIGHT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UserInfo.UAddressId &lt;span&gt;=&lt;/span&gt; UAddress.Id;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查询结果如下：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1704&quot; data-height=&quot;317&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784150/201811/784150-20181114222428538-1396316484.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h6&gt;&lt;span&gt;&lt;strong&gt;FULL JOIN&lt;/strong&gt;&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;code&gt;FULL JOIN&lt;/code&gt;的结果是取&lt;code&gt;LEFT JOIN&lt;/code&gt;和&lt;code&gt;RIGHT JOIN&lt;/code&gt;查询结果集的并集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress
&lt;/span&gt;&lt;span&gt;FULL&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UserInfo.UAddressId &lt;span&gt;=&lt;/span&gt; UAddress.Id;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查询结果如下：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1680&quot; data-height=&quot;189&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784150/201811/784150-20181114222446651-362619890.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;ON &amp;amp; WHERE&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;前面说到：内联接结果集仅保留内部行，外联接结果集返回内部行和外部行。换句话说，外联接中&lt;code&gt;ON&lt;/code&gt;子句的作用是进行表之间关联，如果外联接需要对结果集做进一步的筛选的话不能使用&lt;code&gt;ON...AND...&lt;/code&gt;语句，而要使用&lt;code&gt;WHERE&lt;/code&gt;条件。示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 内联接使用ON...AND...筛选数据&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt; dbo.UserInfo &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; UI
&lt;/span&gt;&lt;span&gt;JOIN&lt;/span&gt; dbo.UAddress &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; UA
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UA.Id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; UI.UAddressId 
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 获取Name为xfh的数据&lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt; UI.Name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xfh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 外联接使用ON...AND...筛选数据&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt; dbo.UserInfo &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; UI
&lt;/span&gt;&lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; dbo.UAddress &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; UA
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UA.Id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; UI.UAddressId 
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 获取Name为xfh的数据，无效&lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt; UI.Name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xfh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 外联接使用WHERE对结果集进行筛选&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt; dbo.UserInfo &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; UI
&lt;/span&gt;&lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; dbo.UAddress &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; UA
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UA.Id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; UI.UAddressId 
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; UI.Name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xfh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1674&quot; data-height=&quot;479&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784150/201811/784150-20181114222501427-1054588470.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;复合联接&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;复合联接是指谓词涉及表中多个字段的联接，即，关联条件使用&lt;code&gt;ON...AND...&lt;/code&gt;的形式。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;自联接&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;同一张表的多个实例之间相互联接，称为自联接。所有基本联接类型（内联接、外联接、交叉联接）支持。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt; dbo.UserInfo &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; U1 
&lt;/span&gt;&lt;span&gt;CROSS&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; dbo.UserInfo &lt;span&gt;AS&lt;/span&gt; U2;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;自联接中要为表名指定别名，否则结果集中的列名都将不明确。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;相等联接 &amp;amp; 不等联接&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;当联接条件使用相等运算符时称为相等联接，否则称为不等联接：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; WJChi;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 相等联接&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress
&lt;/span&gt;&lt;span&gt;FULL&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UserInfo.UAddressId &lt;span&gt;=&lt;/span&gt;&lt;span&gt; UAddress.Id;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 不等联接&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.UAddress
&lt;/span&gt;&lt;span&gt;FULL&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; dbo.UserInfo 
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; UserInfo.UAddressId &lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt; UAddress.Id;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;&lt;span&gt;多联接查询&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;超过两张表进行关联查询即为多联接查询。通常，当SQL中出现多个表运算符时，从左到右进行逻辑处理，前一个联接的结果会作为下一个联接的左侧输入。SQL Server也常常出于优化查询的目的，在实际处理查询过程中对联接进行重新排序，但这不会影响到处理结果集的正确性。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不建议超过三张表进行关联，过多的表关联会使SQL变得复杂，难以维护且影响性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;过多的表联接会让SQL逻辑变得复杂，对查询性能产生负面影响，且难以维护。&lt;/p&gt;
&lt;p&gt;SQL（任何代码）的书写应将语义清晰作为第一追求，而不是为了“炫技”写一些别人难以理解的代码。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;StackOverflow&lt;/a&gt;中扣出的一张图片，可以概述外联接和内联接查询：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;600&quot; data-height=&quot;472&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784150/201811/784150-20181114222517893-698130486.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Cwj-XFH/p/9898835.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;T-SQL基础（一）之简单查询&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;What is the difference between “INNER JOIN” and “OUTER JOIN”?&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 14 Nov 2018 14:25:00 +0000</pubDate>
<dc:creator>雪飞鸿</dc:creator>
<og:description>在上篇博文中介绍了T-SQL查询的基础知识，本篇主要介绍稍微复杂的查询形式。 表运算符 表运算符的作用是把为其提供的表作为输入，经过逻辑查询处理，返回一个表结果。SQL Server支持四个表运算符：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Cwj-XFH/p/9960822.html</dc:identifier>
</item>
<item>
<title>【.NET Core项目实战-统一认证平台】第五章 网关篇-自定义缓存Redis - 金焰的世界</title>
<link>http://www.cnblogs.com/jackcao/p/9960788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackcao/p/9960788.html</guid>
<description>&lt;blockquote readability=&quot;6.8396946564885&quot;&gt;
&lt;p&gt;上篇文章我们介绍了2种网关配置信息更新的方法和扩展Mysql存储，本篇我们将介绍如何使用Redis来实现网关的所有缓存功能，用到的文档及源码将会在GitHub上开源，每篇的源代码我将用分支的方式管理，本篇使用的分支为&lt;code&gt;course3&lt;/code&gt;。&lt;br/&gt;附文档及源码下载地址：[&lt;strong&gt;&lt;a href=&quot;https://github.com/jinyancao/CtrAuthPlatform/tree/course3&quot; class=&quot;uri&quot;&gt;https://github.com/jinyancao/CtrAuthPlatform/tree/course3&lt;/a&gt;&lt;/strong&gt;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;网关的一个重要的功能就是缓存，可以对一些不常更新的数据进行缓存，减少后端服务开销，默认&lt;code&gt;Ocelot&lt;/code&gt;实现的缓存为本地文件进行缓存，无法达到生产环境大型应用的需求，而且不支持分布式环境部署，所以我们需要一个满足大型应用和分布式环境部署的缓存方案。&lt;a href=&quot;https://redis.io/&quot;&gt;Redis&lt;/a&gt;应该是当前应用最广泛的缓存数据库，支持5种存储类型，满足不同应用的实现，且支持分布式部署等特性，所以缓存我们决定使用Redis作为缓存实现。&lt;/p&gt;
&lt;p&gt;本文将介绍使用&lt;code&gt;CSRedisCore&lt;/code&gt;来实现&lt;code&gt;Redis&lt;/code&gt;相关操作，至于为什么选择&lt;code&gt;CSRedisCore&lt;/code&gt;，可参考文章&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9947905.html&quot;&gt;[.NET Core开发者的福音之玩转Redis的又一傻瓜式神器推荐]&lt;/a&gt;,里面详细的介绍了各种Redis组件比较及高级应用，并列出了不同组件的压力测试对比，另外也附&lt;code&gt;CSRedisCore作者交流QQ群：8578575&lt;/code&gt;，使用中有什么问题可以直接咨询作者本人。&lt;/p&gt;

&lt;p&gt;首先本地安装&lt;code&gt;Redis&lt;/code&gt;和管理工具&lt;a href=&quot;https://redisdesktop.com/download&quot;&gt;Redis Desktop Manager&lt;/a&gt;,本文不介绍安装过程，然后&lt;code&gt;NuGet&lt;/code&gt;安装 &lt;code&gt;CSRedisCore&lt;/code&gt;,现在开始我们重写&lt;code&gt;IOcelotCache&amp;lt;T&amp;gt;&lt;/code&gt;的实现，新建&lt;code&gt;InRedisCache.cs&lt;/code&gt;文件。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Ctr.AhphOcelot.Configuration;
using Ocelot.Cache;
using System;
using System.Collections.Generic;
using System.Text;

namespace Ctr.AhphOcelot.Cache
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-11-14
    /// 使用Redis重写缓存
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
    public class InRedisCache&amp;lt;T&amp;gt; : IOcelotCache&amp;lt;T&amp;gt;
    {
        private readonly AhphOcelotConfiguration _options;
        public InRedisCache(AhphOcelotConfiguration options)
        {
            _options = options;
            CSRedis.CSRedisClient csredis;
            if (options.RedisConnectionStrings.Count == 1)
            {
                //普通模式
                csredis = new CSRedis.CSRedisClient(options.RedisConnectionStrings[0]);
            }
            else
            {
                //集群模式
                //实现思路：根据key.GetHashCode() % 节点总数量，确定连向的节点
                //也可以自定义规则(第一个参数设置)
                csredis = new CSRedis.CSRedisClient(null, options.RedisConnectionStrings.ToArray());
            }
            //初始化 RedisHelper
            RedisHelper.Initialization(csredis);
        }

        /// &amp;lt;summary&amp;gt;
        /// 添加缓存信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;key&quot;&amp;gt;缓存的key&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;value&quot;&amp;gt;缓存的实体&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;ttl&quot;&amp;gt;过期时间&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;region&quot;&amp;gt;缓存所属分类，可以指定分类缓存过期&amp;lt;/param&amp;gt;
        public void Add(string key, T value, TimeSpan ttl, string region)
        {
            key = GetKey(region, key);
            if (ttl.TotalMilliseconds &amp;lt;= 0)
            {
                return;
            }
            RedisHelper.Set(key, value.ToJson(), (int)ttl.TotalSeconds); 
        }

        
        public void AddAndDelete(string key, T value, TimeSpan ttl, string region)
        {
            Add(key, value, ttl, region);
        }

        /// &amp;lt;summary&amp;gt;
        /// 批量移除regin开头的所有缓存记录
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;region&quot;&amp;gt;缓存分类&amp;lt;/param&amp;gt;
        public void ClearRegion(string region)
        {
            //获取所有满足条件的key
            var data= RedisHelper.Keys(_options.RedisKeyPrefix + &quot;-&quot; + region + &quot;-*&quot;);
            //批量删除
            RedisHelper.Del(data);
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取执行的缓存信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;key&quot;&amp;gt;缓存key&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;region&quot;&amp;gt;缓存分类&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public T Get(string key, string region)
        {
            key= GetKey(region, key);
            var result = RedisHelper.Get(key);
            if (!String.IsNullOrEmpty(result))
            {
                return result.ToObject&amp;lt;T&amp;gt;();
            }
            return default(T);
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取格式化后的key
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;region&quot;&amp;gt;分类标识&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;key&quot;&amp;gt;key&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        private string GetKey(string region,string key)
        {
            return _options.RedisKeyPrefix + &quot;-&quot; + region + &quot;-&quot; + key;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现所有缓存相关接口，是不是很优雅呢？实现好缓存后，我们需要把我们现实的注入到网关里，在&lt;code&gt;ServiceCollectionExtensions&lt;/code&gt;类中，修改注入方法。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 添加默认的注入方式，所有需要传入的参数都是用默认值
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;builder&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public static IOcelotBuilder AddAhphOcelot(this IOcelotBuilder builder, Action&amp;lt;AhphOcelotConfiguration&amp;gt; option)
{
    builder.Services.Configure(option);
    //配置信息
    builder.Services.AddSingleton(
        resolver =&amp;gt; resolver.GetRequiredService&amp;lt;IOptions&amp;lt;AhphOcelotConfiguration&amp;gt;&amp;gt;().Value);
    //配置文件仓储注入
    builder.Services.AddSingleton&amp;lt;IFileConfigurationRepository, SqlServerFileConfigurationRepository&amp;gt;();
    //注册后端服务
    builder.Services.AddHostedService&amp;lt;DbConfigurationPoller&amp;gt;();
    //使用Redis重写缓存
    builder.Services.AddSingleton&amp;lt;IOcelotCache&amp;lt;FileConfiguration&amp;gt;, InRedisCache&amp;lt;FileConfiguration&amp;gt;&amp;gt;();
            builder.Services.AddSingleton&amp;lt;IOcelotCache&amp;lt;CachedResponse&amp;gt;, InRedisCache&amp;lt;CachedResponse&amp;gt;&amp;gt;();
    return builder;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;奈斯，我们使用&lt;code&gt;Redis&lt;/code&gt;实现缓存已经全部完成，现在开始我们在网关配置信息增加缓存来测试下，看缓存是否生效，并查看是否存储在&lt;code&gt;Redis&lt;/code&gt;里。&lt;/p&gt;
&lt;p&gt;为了验证缓存是否生效，修改测试服务&lt;code&gt;api/values/{id}&lt;/code&gt;代码，增加服务器时间输出。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[HttpGet(&quot;{id}&quot;)]
public ActionResult&amp;lt;string&amp;gt; Get(int id)
{
    return id+&quot;-&quot;+DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加新的测试路由脚本，然后增加缓存策略,缓存60秒，缓存分类&lt;code&gt;test_ahphocelot&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;mssql&quot;&gt;
&lt;code&gt;--插入路由测试信息 
insert into AhphReRoute values(1,'/ctr/values/{id}','[ &quot;GET&quot; ]','','http','/api/Values/{id}','[{&quot;Host&quot;: &quot;localhost&quot;,&quot;Port&quot;: 9000 }]',
'','','{ &quot;TtlSeconds&quot;: 60, &quot;Region&quot;: &quot;test_ahphocelot&quot; }','','','','',0,1);
--插入网关关联表
insert into dbo.AhphConfigReRoutes values(1,2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们测试访问网关地址&lt;code&gt;http://localhost:7777/api/values/1&lt;/code&gt;,过几十秒后继续访问，结果如下。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201811/1529926-20181114221938006-875126809.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出来，缓存已经生效，1分钟内请求都不会路由到服务端，再查询下redis缓存数据，发现缓存信息已经存在，然后使用&lt;code&gt;Redis Desktop Manager&lt;/code&gt;查看Redis缓存信息是否存在，奈斯，已经存在，说明已经达到我们预期目的。&lt;/p&gt;

&lt;p&gt;前面几篇已经介绍了网关的数据库存储，并介绍了网关的2种更新方式，但是如果网关集群部署时，采用接口更新方式，无法直接更新所有集群端配置数据，那如何实现集群配置信息一致呢？前面介绍了redis缓存，可以解决当前遇到的问题，我们需要重写内部配置文件提取仓储类，使用redis存储。&lt;/p&gt;
&lt;p&gt;我们首先使用&lt;code&gt;redis&lt;/code&gt;实现&lt;code&gt;IInternalConfigurationRepository&lt;/code&gt;接口，每次请求配置信息时直接从redis存储，避免单机缓存出现数据无法更新的情况。&lt;code&gt;RedisInternalConfigurationRepository&lt;/code&gt;代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Ctr.AhphOcelot.Configuration;
using Ocelot.Configuration;
using Ocelot.Configuration.Repository;
using Ocelot.Responses;
using System;
using System.Collections.Generic;
using System.Text;

namespace Ctr.AhphOcelot.Cache
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-11-14
    /// 使用redis存储内部配置信息
    /// &amp;lt;/summary&amp;gt;
    public class RedisInternalConfigurationRepository : IInternalConfigurationRepository
    {
        private readonly AhphOcelotConfiguration _options;
        private IInternalConfiguration _internalConfiguration;
        public RedisInternalConfigurationRepository(AhphOcelotConfiguration options)
        {
            _options = options;
            CSRedis.CSRedisClient csredis;
            if (options.RedisConnectionStrings.Count == 1)
            {
                //普通模式
                csredis = new CSRedis.CSRedisClient(options.RedisConnectionStrings[0]);
            }
            else
            {
                //集群模式
                //实现思路：根据key.GetHashCode() % 节点总数量，确定连向的节点
                //也可以自定义规则(第一个参数设置)
                csredis = new CSRedis.CSRedisClient(null, options.RedisConnectionStrings.ToArray());
            }
            //初始化 RedisHelper
            RedisHelper.Initialization(csredis);
        }

        /// &amp;lt;summary&amp;gt;
        /// 设置配置信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;internalConfiguration&quot;&amp;gt;配置信息&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public Response AddOrReplace(IInternalConfiguration internalConfiguration)
        {
            var key = _options.RedisKeyPrefix + &quot;-internalConfiguration&quot;;
            RedisHelper.Set(key, internalConfiguration.ToJson());
            return new OkResponse();
        }

        /// &amp;lt;summary&amp;gt;
        /// 从缓存中获取配置信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public Response&amp;lt;IInternalConfiguration&amp;gt; Get()
        {
            var key = _options.RedisKeyPrefix + &quot;-internalConfiguration&quot;;
            var result = RedisHelper.Get&amp;lt;InternalConfiguration&amp;gt;(key);
            if (result!=null)
            {
                return new OkResponse&amp;lt;IInternalConfiguration&amp;gt;(result);
            }
            return new OkResponse&amp;lt;IInternalConfiguration&amp;gt;(default(InternalConfiguration));
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;redis实现后，然后在&lt;code&gt;ServiceCollectionExtensions&lt;/code&gt;里增加接口实现注入。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;builder.Services.AddSingleton&amp;lt;IInternalConfigurationRepository, RedisInternalConfigurationRepository&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后启动网关测试，可以发现网关配置信息已经使用redis缓存了，可以解决集群部署后无法同步更新问题。&lt;/p&gt;

&lt;p&gt;实际项目使用过程中，可能会遇到需要立即清除缓存数据，那如何实现从网关清除缓存数据呢？在上篇中我们介绍了接口更新网关配置的说明，缓存的更新也是使用接口的方式进行删除，详细代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace Ocelot.Cache
{
    [Authorize]
    [Route(&quot;outputcache&quot;)]
    public class OutputCacheController : Controller
    {
        private readonly IOcelotCache&amp;lt;CachedResponse&amp;gt; _cache;

        public OutputCacheController(IOcelotCache&amp;lt;CachedResponse&amp;gt; cache)
        {
            _cache = cache;
        }

        [HttpDelete]
        [Route(&quot;{region}&quot;)]
        public IActionResult Delete(string region)
        {
            _cache.ClearRegion(region);
            return new NoContentResult();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以先拉去授权，获取授权方式请参考上一篇，然后使用&lt;code&gt;HTTP DELETE&lt;/code&gt;方式，请求删除地址，比如删除前面的测试缓存接口，可以请求&lt;code&gt;http://localhost:7777/CtrOcelot/outputcache/test_ahphocelot&lt;/code&gt;地址进行删除，可以使用&lt;code&gt;PostMan&lt;/code&gt;进行测试，测试结果如下。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201811/1529926-20181114222005940-876664921.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行成功后可以删除指定的缓存记录，且立即生效，完美的解决了我们问题。&lt;/p&gt;

&lt;p&gt;本篇我们介绍了使用redis缓存来重写网关的所有缓存模块，并把网关配置信息也存储到redis里，来解决集群部署的问题，如果想清理缓存数据，通过网关指定的授权接口即可完成，完全具备了网关的缓存的相关模块的需求。&lt;/p&gt;
&lt;p&gt;下一篇开始我们开始介绍针对不同客户端设置不同的权限来实现自定义认证，敬请期待，后面的课程会越来越精彩，也希望大家多多支持。&lt;/p&gt;
</description>
<pubDate>Wed, 14 Nov 2018 14:20:00 +0000</pubDate>
<dc:creator>金焰的世界</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackcao/p/9960788.html</dc:identifier>
</item>
</channel>
</rss>