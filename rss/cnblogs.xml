<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java垃圾回收手册翻译 - 什么是垃圾回收 - pyx0</title>
<link>http://www.cnblogs.com/pyx0/p/9222356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pyx0/p/9222356.html</guid>
<description>&lt;h3 id=&quot;java垃圾回收手册翻译---什么是垃圾回收&quot;&gt;Java垃圾回收手册翻译 - 什么是垃圾回收&lt;/h3&gt;
&lt;p&gt;初看之下，垃圾回收应该要做其名称之事 - 找到和丢掉垃圾。然而事实上它正好做着相反的事，垃圾回收会记录所有仍在使用中的对象，然后将其他标记为垃圾。谨记这点，我们开始挖掘更多Java虚拟机如何实现被称为垃圾回收的自动化内存回收过程的细节。&lt;/p&gt;
&lt;p&gt;为了避免一头扎进细节，我们从头开始，解释垃圾回收的一般性质以及核心概念和方法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;免责声明：本手册关注于Oracle Hotspot和OpenJDK的表现，其他运行时甚至其他虚拟机，比如jRockit或IBM J9，会在某些方面有不同于本手册所涵盖的表现。&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;手动内存管理&quot;&gt;手动内存管理&lt;/h4&gt;
&lt;p&gt;在开始现代形式的垃圾回收内容之前，我们先快速回顾一下那些需要手动显示分配和释放数据内存的日子。那时候如果你忘记释放内存，你将不能重用那块内存。这部分内存会被声明到但是没有使用，这种场景叫做内存泄漏。&lt;/p&gt;
&lt;p&gt;下面是一个用C语言写的使用手动内存管理的简单例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int send_request() {
    size_t n = read_size();
    int *elements = malloc(n * sizeof(int));

    if(read_elements(n, elements) &amp;lt; n) {
        // elements not freed!
        return -1;
    }

    // …

    free(elements)
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如我们所见，非常容易忘记释放内存。相比于现在，内存泄漏在过去是更加常见的问题。你只能通过修复代码才能真正的对付它们。因此，一个更好的方法是将回收不用的内存的工作自动化，整体消除可能产生的人为错误。这个自动化操作叫做垃圾回收（简称GC）。&lt;/p&gt;
&lt;h4 id=&quot;智能指针&quot;&gt;智能指针&lt;/h4&gt;
&lt;p&gt;一种自动化操作的方式是通过使用析构函数。例如，我们使用C++中的向量&lt;em&gt;vector&lt;/em&gt;做上一个例子中同样的事，它会在离开其作用域时自动的调用其析构函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int send_request() {
    size_t n = read_size();
    vector&amp;lt;int&amp;gt; elements = vector&amp;lt;int&amp;gt;(n);

    if(read_elements(elements.size(), &amp;amp;elements[0]) &amp;lt; n) {
        return -1;
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是再更复杂的情况中，尤其是在多个线程中共享对象时，仅仅使用析构函数并不够。这就引出了垃圾回收最简单的形式：引用计数。对每个对象，你只需要知道它有多少次被引用到，并且当这个计数达到零时这个对象就可以安全的被回收。一个众所周知的例子是C++中的共享指针&lt;em&gt;shared pointers&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int send_request() {
    size_t n = read_size();
    auto elements = make_shared&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;();

    // read elements

    store_in_cache(elements);

    // process elements further

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，为了避免下次函数调用时再去读这个元素&lt;em&gt;elements&lt;/em&gt;，我们可能想要缓存他们。在这个例子中，就不能再当向量&lt;em&gt;vector&lt;/em&gt;离开作用域时销毁它。因此，我们使用共享指针&lt;em&gt;shared_ptr&lt;/em&gt;，它记录引用到它的数量，当你使用它传值时计数增加，同时当它离开作用域时计数减少。一旦引用的计数降到零，共享指针&lt;em&gt;shared_ptr&lt;/em&gt;就会自动地删除下面的向量。&lt;/p&gt;
&lt;p&gt;TBC...&lt;/p&gt;
</description>
<pubDate>Sun, 24 Jun 2018 15:54:00 +0000</pubDate>
<dc:creator>pyx0</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pyx0/p/9222356.html</dc:identifier>
</item>
<item>
<title>Python学习：10.Python装饰器讲解（一） - BD-ld-2017</title>
<link>http://www.cnblogs.com/liudi2017/p/9222353.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liudi2017/p/9222353.html</guid>
<description>&lt;p&gt;&lt;span&gt;情景介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一天，在你正在努力加班的时候，老板给交给你了一个任务，就是在这段代码里将所有函数开始输出一个‘hello’最后输出当前时间，再输出一个“end”，这段代码里包含了大量的函数，你会怎么做？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    
    
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    
    
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f3():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    
    
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f4():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

...
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刚拿到这个任务，我们可能想着这样做，在每个函数中添加相应的输出语句，这样就能完成任务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; datetime

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;datetime.datetime.now()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
　　
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;datetime.datetime.now()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f3():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;datetime.datetime.now()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f4():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;datetime.datetime.now()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
...
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到我们进行实施的时候我们发现这样写，太麻烦，每一个函数最后都要添加一遍，于是，我们就想到了另一个方法，就是写一个函数，添加在每个函数中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; datetime

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hel():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(datetime.datetime.now())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    hel()


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    hel()


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f3():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    hel()

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f4():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    hel()

...
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是我们发现在开始输出的hello还是要添加在每个函数中，这样还是麻烦，为了解决这个问题就要讲讲装饰器了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;装饰器介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单装饰器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　就将开始那个问题来使用装饰器解决一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; datetime

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hel(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; inner():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        r &lt;/span&gt;=&lt;span&gt; func()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(datetime.datetime.now())
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner


@hel
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

@hel
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

@hel
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f3():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

@hel
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f4():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proces d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

f1()
f2()
f3()
f4()


执行结果：
hello
proces a
&lt;/span&gt;2018-06-24 18:03:21.903651&lt;span&gt;
end
hello
proces b
&lt;/span&gt;2018-06-24 18:03:21.915651&lt;span&gt;
end
hello
proces c
&lt;/span&gt;2018-06-24 18:03:21.915651&lt;span&gt;
end
hello
proces d
&lt;/span&gt;2018-06-24 18:03:21.915651&lt;span&gt;
end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是不是使用装饰器相对于之前的写法简单。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;针对上面的代码进行解析：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　装饰器符号“@”属于语法糖，@修饰符必须出现在函数定义前一行，将下面的函数的名作为参数，不允许和函数定义在同一行。&lt;/p&gt;
&lt;p&gt;　　在上面的代码中，func就是指f1、f2、f3、f4函数，以f1为例，将f1函数作为参数传入hel函数中，在hel函数中再定义一个inner()函数，在inner函数中，首先执行一个print('hello'),在执行f1函数兵将返回值赋值给r，接下来输出时间以及end，最后返回r，inner函数的最后返回inner函数，当我们执行f1函数的时候，就相当于执行了inner函数，并且可以可以拿到f1函数的返回值。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用装饰器传递参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　上面使用的装饰器中，传入的函数没有带参数，当需要修饰的函数带有参数，我们就在装饰器中的inner函数添加相应的参数，在inner函数里面调用func函数的时候，再次传入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hel(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; inner(name):
        r &lt;/span&gt;=&lt;span&gt; func(name)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bye&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner

@hel
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)

name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
f1(name)


输出结果：
hello
alexsel
bye&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然这样我们就解决了参数的问题，但是我们这次传入的参数仅仅是字符串，如果是更加复杂的参数怎么办，这时候我们可以使用我们之前学习函数时候用到的一些可以接收多种类型的参数，*args，**kwargs，使用这两个参数之后我们可以接收任何类型的参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hel(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; inner(*args,**&lt;span&gt;kwargs):
        r &lt;/span&gt;= func(*args,**&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bye&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner

@hel
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)

name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
f1(name)


输出结果：
hello
alexsel
bye&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里，简单的装饰器就讲完了，装饰器还有更高级的用法，下一篇，装饰器二会继续给大家讲解装饰器。&lt;/p&gt;
</description>
<pubDate>Sun, 24 Jun 2018 15:53:00 +0000</pubDate>
<dc:creator>BD-ld-2017</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liudi2017/p/9222353.html</dc:identifier>
</item>
<item>
<title>Java设计模式学习记录-单例模式 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/9218997.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/9218997.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;已经介绍和学习了两个创建型模式了，今天来学习一下另一个非常常见的创建型模式，单例模式。&lt;/p&gt;
&lt;p&gt;单例模式也被称为单件模式（或单体模式），主要作用是控制某个类型的实例数量是一个，而且只有一个。&lt;/p&gt;
&lt;h2&gt;单例模式&lt;/h2&gt;
&lt;h3&gt;单例模式的实现方式&lt;/h3&gt;
&lt;p&gt; 实现单例模式的方式有很多种，大体上可以划分为如下两种。&lt;/p&gt;
&lt;h4&gt;外部方式&lt;/h4&gt;
&lt;p&gt;在使用某些全局对象时，做一些“try-Use”的工作。就是如果要使用的这个全局对象不存在，就自己创建一个，把它放到全局的位置上；如果本来就有，则直接拿来使用。&lt;/p&gt;
&lt;h4&gt;内部实现方式&lt;/h4&gt;
&lt;p&gt;类型自己控制正常实例的数量，无论客户程序是否尝试过了，类型自己自己控制只提供一个实例，客户程序使用的都是这个现成的唯一实例。&lt;/p&gt;
&lt;p&gt;目前随着集群、多核技术的普遍应用，想通过简单的类型内部控制失效真正的Singleton越来越难，试图通过经典单例模式实现分布式环境下的“单例”并不现实。所以目前介绍的这个单例是有语义限制的。&lt;/p&gt;
&lt;h3&gt;单例模式的特点&lt;/h3&gt;
&lt;p&gt;虽然单例模式也属于创建型模式，淡水它是有自己独特的特点的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单例类只有一个实例。&lt;/li&gt;
&lt;li&gt;单例类自行创建该实例，在该类内部创建自身的实例对象。&lt;/li&gt;
&lt;li&gt;向整个系统公开这个实例接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有需要注意的一点，单例模式只关心类实例的创建问题，并不关心具体的业务功能。&lt;/p&gt;
&lt;h3&gt;单例模式的范围&lt;/h3&gt;
&lt;p&gt;目前Java里面实现的单例是一个ClassLoader及其子ClassLoader的范围。因为ClassLoader在装载饿汉式实现的单例类时，会响应地创建一个类的实例。这也说明，如果一个虚拟机里有多个ClassLoader（虽然说ClassLoader遵循双亲委派模型，但是也会有父加载器处理不了，然后自定义的加载器执行类加载的情况。），而且这些ClassLoader都装载着某一个类的话，就算这个类是单例，它也会产生很多个实例。如果一个机器上有多个虚拟机，那么每个虚拟机里面都应该至少有一个这个类的实例，也就是说整个机器上就有很多个实例，更不会是单例了。&lt;/p&gt;
&lt;p&gt;还有一点再次强调，目前讨论的单例范围不适用于集群环境。&lt;/p&gt;
&lt;h4&gt;单例模式的类型&lt;/h4&gt;
&lt;h4&gt;饿汉式单例&lt;/h4&gt;
&lt;p&gt;饿汉式单例是指在类被加载的时候，唯一实例已经被创建。&lt;/p&gt;
&lt;p&gt;如下代码的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 饿汉式单例模式
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HungrySingleton {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 定义一个静态变量用来存储实例，在类加载的时候创建，只会创建一次。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HungrySingleton hungrySingleton = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HungrySingleton();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 私有化构造方法，禁止外部创建实例。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; HungrySingleton(){
        System.out.println(&lt;/span&gt;&quot;创建实例&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 外部获取唯一实例的方法
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; HungrySingleton getInstance(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hungrySingleton;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;懒汉式单例&lt;/h4&gt;
&lt;p&gt;懒汉式单例是指在类加载的时候不创建单例的对象，只有在第一次使用的时候创建，并且在第一次创建后，以后不再创建该类的实例。&lt;/p&gt;
&lt;p&gt;如下代码的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 懒汉式单例
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LazySingleton {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 定义一个静态变量用来存储实例。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; LazySingleton lazySingleton = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 私有化构造方法，禁止外部创建实例。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; LazySingleton(){}

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 外部获取唯一实例的方法&lt;br/&gt;* 当发现没有初始化的时候，才初始化静态变量。
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LazySingleton getInstance(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;==&lt;span&gt;lazySingleton){
            lazySingleton &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LazySingleton();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lazySingleton;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;登记式单例&lt;/h4&gt;
&lt;p&gt;登记式单例实际上维护的是一组单例类的实例，将这些实例存在在一个登记薄（例如Map）中，使用已经登记过的实例，直接从登记簿上返回，没有登记的，则先登记，后返回。&lt;/p&gt;
&lt;p&gt;如下代码例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 登记式单例
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RegisterSingleton {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建一个登记簿，用来存放所有单例对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String,RegisterSingleton&amp;gt; registerBook = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 私有化构造方法，禁止外部创建实例
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; RegisterSingleton(){}

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 注册实例
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name 登记簿上的名字
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; registerSingleton 登记簿上的实例
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerInstance(String name,RegisterSingleton registerSingleton){

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;registerBook.containsKey(name)){
            registerBook.put(name,registerSingleton);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取实例，如果在未注册时调用将返回null
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name 登记簿上的名字
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RegisterSingleton getInstance(String name){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; registerBook.get(name);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于饿汉式的单例在类加载的时候就创建了一个实例，所以这个实例一直都不会变，因此也是线程安全的。但是懒汉式单例就不是线程安全的了，在懒汉式单例中有可能会出现两个线程创建了两个不同的实例，因为懒汉式单例中的getInstance()方法不是线程安全的。所以如果想让懒汉式变成线程安全的，需要在getInstance()方法中加锁。&lt;/p&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
   /**
     *&lt;span&gt; 外部获取唯一实例的方法
     &lt;/span&gt;*&lt;span&gt; 当发现没有被初始化的时候，才初始化静态变量
     &lt;/span&gt;* @&lt;span&gt;return&lt;/span&gt;
     */
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; LazySingleton getInstance(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;==&lt;span&gt;lazySingleton){
            lazySingleton &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LazySingleton();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lazySingleton;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这样增加的资源消耗，延迟加载的效果虽然达到了，但是在使用的时候资源消耗确更大了，所以不建议这样用。既要实现线程安全，又要保证延迟加载。基于这样的问题就出现了另一种方式的单例模式，&lt;strong&gt;静态内部类式单例&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;静态内部类式单例&lt;/h4&gt;
&lt;p&gt;静态内部类式单例饿汉式和懒汉式的结合。&lt;/p&gt;
&lt;p&gt;如下代码例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 内部静态类式单例
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StaticClassSingleton {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 私有化构造方法，禁止外部创建实例。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; StaticClassSingleton(){
        System.out.println(&lt;/span&gt;&quot;创建实例了&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 私有静态内部类，只能通过内部调用。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SingleClass{
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; StaticClassSingleton singleton = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StaticClassSingleton();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 外部获取唯一实例的方法
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; StaticClassSingleton getInstance(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SingleClass.singleton;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;双重检查加锁式单例&lt;/h4&gt;
&lt;p&gt;上面静态内部类的方式通过结合饿汉式和懒汉式来实现了即延迟加载了又线程安全了。下面也来介绍另一种即实现了延迟加载有保证了线程安全的方式的单例。&lt;/p&gt;
&lt;p&gt;如下代码例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 双重检查加锁式单例
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DoubleCheckLockSingleton {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 静态变量，用来存放实例。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DoubleCheckLockSingleton doubleCheckLockSingleton = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 私有化构造方法，禁止外部创建实例。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; DoubleCheckLockSingleton(){}

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 双重检查加锁的方式保证线程安全又能获得到唯一实例
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; DoubleCheckLockSingleton getInstance(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先检查实例是否已经存在，不存在则进入代码块&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; doubleCheckLockSingleton){
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (DoubleCheckLockSingleton.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于synchronized也是重入锁，即一个线程有可能多次进入到此同步块中如果第一次进入时已经创建了实例，那么第二次进入时就不创建了。&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;==&lt;span&gt;doubleCheckLockSingleton){
                    doubleCheckLockSingleton &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DoubleCheckLockSingleton();
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; doubleCheckLockSingleton;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上所示，所谓“双重检查加锁”机制，并不是每次进入getInstance()方法都需要加锁，而是当进入方法后，先检查实例是否已经存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块后，再次检查实例是否已经存在，如果不存在，就在同步块中创建一个实例，这是第二重检查。这个过程是只需要同步一次的。&lt;/p&gt;
&lt;p&gt;还需要注意的一点是，在使用“双重检查加锁”时，需要在变量上使用关键字volatile，这个关键字的作用是，&lt;strong&gt;被volatile修饰的变量的值不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确地处理该变量&lt;/strong&gt;。可能不了解Java内存模式的朋友不太好理解这句话的意思，可以去看看（&lt;a title=&quot;JVM学习记录-Java内存模型（一）&quot; href=&quot;http://www.cnblogs.com/jimoer/p/9108779.html&quot; target=&quot;_blank&quot;&gt;JVM学习记录-Java内存模型（一）&lt;/a&gt;，&lt;a title=&quot;JVM学习记录-Java内存模型（二）&quot; href=&quot;http://www.cnblogs.com/jimoer/p/9109781.html&quot; target=&quot;_blank&quot;&gt;JVM学习记录-Java内存模型（二）&lt;/a&gt;）了解一下Java内存模型，我简单说明一下，volatile这个关键字可以保证每个线程操作的变量都会被其他线程所看到，就是说如果第一个线程已经创建了实例，但是把创建的这个实例只放在了自己的这个线程中，其他线程是看不到的，这个时候如果其他线程再去判断实例是否已经存在了实例的时候，发现没有还是没有实例就会又创建了一个实例，然后也放在了自己的线程中，如果这样的话我们写的单例模式就没意义了。在JDK1.5以前的版本中对volatile的支持存在问题，可能会导致“双重检查加锁”失败，所以如果要使用“双重检查加锁”式单例，只能使用JDK1.5以上的版本。&lt;/p&gt;
&lt;h4&gt;枚举式单例 &lt;/h4&gt;
&lt;p&gt;在JDK1.5中引入了一个新的特性，枚举，通过枚举来实现单例，在目前看来是最佳的方法了。Java的枚举类型实质上是功能齐全的类，因此可以有自己的属性和方法。&lt;/p&gt;
&lt;p&gt;还是通过代码示例来解释吧。&lt;/p&gt;
&lt;p&gt;如下代码例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
/**
 *&lt;span&gt; 单元素枚举实现单例模式
 &lt;/span&gt;*/
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; EnumSingleton {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 必须是单元素，因为一个元素就是一个实例。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    INSTANCE;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 测试方法1
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomeThing() {

        System.out.println(&lt;/span&gt;&quot;#####测试方法######&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 测试方法2
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSomeThing(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;获得到了一些内容&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面例子中EnumSingleton.INSTANCE就可以获得到想要的实例了,调用单例的方法可以种EnumSingleotn.INSTANCE.doSomeThing()等方法。&lt;/p&gt;
&lt;p&gt;下面来看看枚举是如何保证单例的：&lt;/p&gt;
&lt;p&gt;首先枚举的构造方法明确是私有的，在使用枚举实例时会执行构造方法，同时每个枚举实例都是static final类型的，表明枚举实例只能被赋值一次，这样在类初始化的时候就会把实例创建出来，这也说明了枚举单例，其实是饿汉式单例方式。这样就用最简单的代码既保证了线程安全，又保证了代码的简洁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还有一点很值得注意的是，枚举实现的单例保证了序列化后的单例安全。除了枚举式的单例，其他方式的单例，都可能会通过反射或反序列化来创建多个实例。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以在使用单例的时候最好的办法就是用枚举的方式。既简洁又安全。&lt;/strong&gt;&lt;/p&gt;




</description>
<pubDate>Sun, 24 Jun 2018 15:37:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jimoer/p/9218997.html</dc:identifier>
</item>
<item>
<title>请不要在JDK7及以上用Json-lib了 - 大魔王mAysWINd</title>
<link>http://www.cnblogs.com/mayswind/p/9222245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mayswind/p/9222245.html</guid>
<description>&lt;p&gt;&lt;strong&gt;【Json-lib 介绍】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Json-lib 是以前 Java 常用的一个 Json 库，最后的版本是 2.4，分别提供了 JDK 1.3 和 1.5 的支持，最后更新时间是 2010年12月14日。虽然已经很多年不维护了，但在搜索引擎上搜索 &quot;Java Json&quot; 等相关的关键词发现好像一直还有人在介绍和使用这个库。项目官网是 &lt;a href=&quot;http://json-lib.sourceforge.net/&quot; target=&quot;_blank&quot;&gt;http://json-lib.sourceforge.net/&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【一句话结论】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Json-lib 在通过字符串解析每一个 Json 对象时，会对当前解析位置到字符串末尾进行 substring 操作，由于 JDK7 及以上的 substring 会完整拷贝截取后的内容，所以当遇到较大的 Json 数据并且含有较多对象时，会进行大量的字符数组复制操作，导致了大量的 CPU 和内存消耗，甚至严重的 Full GC 问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【问题分析】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某天发现线上生产服务器有不少 Full GC 问题，排查发现产生 Full GC 时某个老接口量会上涨，但这个接口除了解析 Json 外就是将解析后的数据存储到了缓存中，遂怀疑跟接口请求参数大小有关，打日志发现确实有比一般请求大得多的 Json 数据，但也只有 1MB 左右。为了简化这个问题，编写如下的性能测试代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('64f6d1cb-67e9-4eab-904a-3d2ceaa5d82a')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_64f6d1cb-67e9-4eab-904a-3d2ceaa5d82a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_64f6d1cb-67e9-4eab-904a-3d2ceaa5d82a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('64f6d1cb-67e9-4eab-904a-3d2ceaa5d82a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_64f6d1cb-67e9-4eab-904a-3d2ceaa5d82a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package net.mayswind;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import net.sf.json.JSONObject;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import org.apache.commons.io.FileUtils;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import java.io.File;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public class JsonLibBenchmark {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     public static &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws Exception {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         String data = FileUtils.readFileToString(&lt;span&gt;new&lt;/span&gt; File(&quot;Z:\\data.json&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         benchmark(data, 5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     private static &lt;span&gt;void&lt;/span&gt; benchmark(String data, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; count; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             JSONObject root =&lt;span&gt; JSONObject.fromObject(data);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; elapsedTime = System.currentTimeMillis() -&lt;span&gt; startTime;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         System.out.println(String.format(&quot;count=%d, elapsed time=%d ms, avg cost=%f ms&quot;, count, elapsedTime, (&lt;span&gt;double&lt;/span&gt;) elapsedTime /&lt;span&gt; count));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上述代码执行后平均每次解析需要 7秒左右才能完成，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/495906/201806/495906-20180624232012882-1633950142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试用的 Json 文件，“...” 处省略了 34,018 个相同内容，整个 Json 数据中包含了 3万多个 Json 对象，实际测试的数据如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;data&quot;&lt;span&gt;:
    [
        {
            &lt;/span&gt;&quot;foo&quot;: 0123456789&lt;span&gt;,
            &lt;/span&gt;&quot;bar&quot;: 1234567890&lt;span&gt;
        },
        {
            &lt;/span&gt;&quot;foo&quot;: 0123456789&lt;span&gt;,
            &lt;/span&gt;&quot;bar&quot;: 1234567890&lt;span&gt;
        },
        ...
    ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/495906/201806/495906-20180624225245997-230790501.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 Java Mission Control 记录执行的情况，如下图所示，可以看到分配了大量 char[] 数组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/495906/201806/495906-20180624225055079-265312679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;翻看相关源码，其中 JSONObject._fromJSONTokener 方法主要内容如下所示。可以看到其在代码一开始就匹配是否为 &quot;null&quot; 开头。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private static JSONObject _fromJSONTokener(JSONTokener tokener, JsonConfig jsonConfig) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;strong&gt;tokener.matches(&quot;null.*&quot;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;)&lt;/strong&gt;) {
            fireObjectStartEvent(jsonConfig);
            fireObjectEndEvent(jsonConfig);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JSONObject(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (tokener.nextClean() != '{'&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; tokener.syntaxError(&quot;A JSONObject text must begin with '{'&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            fireObjectStartEvent(jsonConfig);
            Collection exclusions &lt;/span&gt;=&lt;span&gt; jsonConfig.getMergedExcludes();
            PropertyFilter jsonPropertyFilter &lt;/span&gt;=&lt;span&gt; jsonConfig.getJsonPropertyFilter();
            JSONObject jsonObject &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; JSONObject();&lt;br/&gt;...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而 matches 方法更是直接用 substring 截取当前位置到末尾的字符串，然后进行正则匹配。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
public &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; matches(String pattern) {
    String str &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.mySource.substring(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.myIndex);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; RegexpUtils.getMatcher(pattern).matches(str);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;字符串 substring 会传入字符数组、起始位置和截取长度创建一个新的 String 对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
public String substring(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; beginIndex) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (beginIndex &amp;lt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringIndexOutOfBoundsException(beginIndex);
    }
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; subLen = value.length -&lt;span&gt; beginIndex;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subLen &amp;lt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringIndexOutOfBoundsException(subLen);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (beginIndex == 0) ? &lt;span&gt;this&lt;/span&gt; : &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(value, beginIndex, subLen);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 JDK7 及以上，调用该构造方法时在最后一行会复制一遍截取后的数据，这也是导致整个问题的关键所在了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
public String(&lt;span&gt;char&lt;/span&gt; value[], &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (offset &amp;lt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringIndexOutOfBoundsException(offset);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;lt;= 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;lt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringIndexOutOfBoundsException(count);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (offset &amp;lt;=&lt;span&gt; value.length) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value = &quot;&quot;&lt;span&gt;.value;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Note: offset or count might be near -1&amp;gt;&amp;gt;&amp;gt;1.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (offset &amp;gt; value.length -&lt;span&gt; count) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; StringIndexOutOfBoundsException(offset +&lt;span&gt; count);
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value = &lt;strong&gt;Arrays.copyOfRange(value, offset, offset+&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;count)&lt;/strong&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 24 Jun 2018 15:33:00 +0000</pubDate>
<dc:creator>大魔王mAysWINd</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mayswind/p/9222245.html</dc:identifier>
</item>
<item>
<title>go语言之行--接口(interface)、反射(reflect)详解 - W-D</title>
<link>http://www.cnblogs.com/wdliu/p/9222283.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wdliu/p/9222283.html</guid>
<description>&lt;h2&gt;一、interface简介&lt;/h2&gt;
&lt;p&gt;interface(接口)是golang最重要的特性之一，Interface类型可以定义一组方法，但是这些不需要实现。并且interface不能包含任何变量。&lt;/p&gt;
&lt;p&gt;简单的说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;interface是方法的集合&lt;/li&gt;
&lt;li&gt;interface是一种类型，并且是指针类型&lt;/li&gt;
&lt;li&gt;interface的更重要的作用在于多态实现&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;interface定义&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
type  接口名称 &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
method1 (参数列表) 返回值列表
method2 (参数列表) 返回值列表
...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;interface使用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;接口的使用不仅仅针对结构体，自定义类型、变量等等都可以实现接口。&lt;/li&gt;
&lt;li&gt;如果一个接口没有任何方法，我们称为空接口，由于空接口没有方法，所以任何类型都实现了空接口。&lt;/li&gt;
&lt;li&gt;要实现一个接口，必须实现该接口里面的所有方法。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义接口&lt;/span&gt;
type Skills &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    Running()
    Getname() &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;

}

type Student &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    Name &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    Age &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现接口&lt;/span&gt;
func (p Student) Getname() &lt;span&gt;string&lt;/span&gt;{   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现Getname方法&lt;/span&gt;
&lt;span&gt;    fmt.Println(p.Name )
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p.Name
}

func (p Student) Running()  {   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现 Running方法&lt;/span&gt;
    fmt.Printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s running&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,p.Name)
}
func main()  {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; skill Skills
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; stu1 Student
    stu1.Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    stu1.Age &lt;/span&gt;= &lt;span&gt;22&lt;/span&gt;&lt;span&gt;
    skill &lt;/span&gt;=&lt;span&gt; stu1
    skill.Running()  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用接口&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;wd running&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;多态&lt;/h3&gt;
&lt;p&gt;上面提到了，go语言中interface是实现多态的一种形式，所谓多态，就是一种事物的多种形态，与python中类的多态是一致的。&lt;/p&gt;
&lt;p&gt;同一个interface，不同的类型实现，都可以进行调用，它们都按照统一接口进行操作。&lt;/p&gt;
&lt;p&gt;在上面的示例中，我们增加一个Teacher结构体，同样实现接口进行说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

type Skills &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    Running()
    Getname() &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;

}

type Student &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    Name &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    Age &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;
}


type Teacher &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    Name &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    Salary &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;
}

func (p Student) Getname() &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现Getname方法&lt;/span&gt;
&lt;span&gt;    fmt.Println(p.Name )
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p.Name
}

func (p Student) Running()  {   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现 Running方法&lt;/span&gt;
    fmt.Printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s running&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,p.Name)
}


func (p Teacher) Getname() &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现Getname方法&lt;/span&gt;
&lt;span&gt;    fmt.Println(p.Name )
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p.Name
}

func (p Teacher) Running()  {   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现 Running方法&lt;/span&gt;
    fmt.Printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n%s running&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,p.Name)
}
func main()  {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; skill Skills
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; stu1 Student
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; t1 Teacher
    t1.Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    stu1.Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    stu1.Age &lt;/span&gt;= &lt;span&gt;22&lt;/span&gt;&lt;span&gt;
    skill &lt;/span&gt;=&lt;span&gt; stu1
    skill.Running()
    skill &lt;/span&gt;=&lt;span&gt; t1
    t1.Running()
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;wd running
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;wang running&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;接口嵌套&lt;/h3&gt;
&lt;p&gt;go语言中的接口可以嵌套，可以理解我继承，子接口拥有父接口的所有方法，并且想要使用该子接口的话，必须将父接口和子接口的所有方法都实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
type Skills &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    Running()
    Getname() &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;

}

type Test &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    sleeping()
    Skills   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承Skills&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;类型转换&lt;/h3&gt;
&lt;p&gt;由于接口是一般类型，当我们使用接口时候可能不知道它是那个类型实现的，基本数据类型我们有对应的方法进行类型转换，当然接口类型也有类型转换。&lt;/p&gt;
&lt;p&gt;当然我们也可以用这个方式来进行类型的判断。&lt;/p&gt;
&lt;p&gt;转换方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; s &lt;span&gt;int&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; x &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;

x &lt;/span&gt;=&lt;span&gt; s
y , ok :&lt;/span&gt;= x.(&lt;span&gt;int&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将interface 转为int,ok可省略 但是省略以后转换失败会报错，true转换成功，false转换失败, 并采用默认值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

func main()  {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{}

    s :&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    x &lt;/span&gt;=&lt;span&gt; s
    y,ok :&lt;/span&gt;= x.(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)
    z,ok1 :&lt;/span&gt;= x.(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;)
    fmt.Println(y,ok)
    fmt.Println(z,ok1)
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0 false
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;WD true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;判断类型示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

type Student &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    Name &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
}

func TestType(items ...&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{}) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k, v :=&lt;span&gt; range items {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; v.(type) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;:
        fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type is string, %d[%v]\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, k, v)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt;:
        fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type is bool, %d[%v]\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, k, v)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;:
        fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type is int, %d[%v]\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, k, v)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; float32, float64:
        fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type is float, %d[%v]\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, k, v)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Student:
        fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type is Student, %d[%v]\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, k, v)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; *&lt;span&gt;Student:
        fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type is Student, %d[%p]\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, k, v)
        }
}
}

func main() {
 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; stu Student
TestType(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, stu,&lt;span&gt;3.3&lt;/span&gt;&lt;span&gt;)
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;type is string, 0[WD]
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;type is int, 1[100]
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;type is Student, 2[{}]
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;type is float, 3[3.3]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二、反射reflect&lt;/h2&gt;
&lt;p&gt;反射是程序执行时检查其所拥有的结构。尤其是类型的一种能力。这是元编程的一种形式。它同一时候也是造成混淆的重要来源。&lt;/p&gt;
&lt;p&gt;每一个语言的反射模型都不同（同一时候很多语言根本不支持反射，python通过hasattr方法实现）&lt;/p&gt;
&lt;p&gt;go语言中的反射通过refect包实现，reflect包实现了运行时反射，允许程序操作任意类型的对象。&lt;/p&gt;
&lt;p&gt;在介绍反射之前先说明下reflect包中的两个数据类Type和Value。&lt;/p&gt;
&lt;h3&gt;Type&lt;/h3&gt;
&lt;p&gt;Type：Type类型用来表示一个go类型。&lt;/p&gt;
&lt;p&gt;不是所有go类型的Type值都能使用所有方法。请参见每个方法的文档获取使用限制。在调用有分类限定的方法时，应先使用Kind方法获知类型的分类。调用该分类不支持的方法会导致运行时的panic。&lt;/p&gt;
&lt;p&gt;获取Type对象的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
func TypeOf(i &lt;span&gt;interface&lt;/span&gt;{}) Type
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reflect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

func main() {
    str :&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    res_type :&lt;/span&gt;=&lt;span&gt; reflect.TypeOf(str)
    fmt.Println(res_type) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;reflect.Type中方法&lt;/h3&gt;
&lt;p&gt;通用方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通用方法&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) String() &lt;span&gt;string&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 t 类型的字符串描述，不要通过 String 来判断两种类型是否一致。&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) Name() &lt;span&gt;string&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 t 类型在其包中定义的名称，未命名类型则返回空字符串。&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) PkgPath() &lt;span&gt;string&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 t 类型所在包的名称，未命名类型则返回空字符串。&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) Kind() reflect.Kind &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 t 类型的类别。&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) Size() uintptr &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 t 类型的值在分配内存时的大小，功能和 unsafe.SizeOf 一样。&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) Align() &lt;span&gt;int&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 t 类型的值在分配内存时的字节对齐值。&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) FieldAlign() &lt;span&gt;int&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 t 类型的值作为结构体字段时的字节对齐值。&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) NumMethod() &lt;span&gt;int&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 t 类型的方法数量。&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) Method() reflect.Method  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据索引获取 t 类型的方法，如果方法不存在，则 panic。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 t 是一个实际的类型，则返回值的 Type 和 Func 字段会列出接收者。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 t 只是一个接口，则返回值的 Type 不列出接收者，Func 为空值。&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) MethodByName(&lt;span&gt;string&lt;/span&gt;) (reflect.Method, &lt;span&gt;bool&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据名称获取 t 类型的方法。&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) Implements(u reflect.Type) &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断 t 类型是否实现了 u 接口。&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) ConvertibleTo(u reflect.Type) &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断 t 类型的值可否转换为 u 类型。&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) AssignableTo(u reflect.Type) &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断 t 类型的值可否赋值给 u 类型。&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) Comparable() &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断 t 类型的值可否进行比较操作&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;####注意对于：数组、切片、映射、通道、指针、接口 &lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; (t *rtype) &lt;span&gt;Elem&lt;/span&gt;() reflect.Type &lt;span&gt;// 获取元素类型、获取指针所指对象类型，获取接口的动态类型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reflect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

type Skills &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    reading()
    running()
}

type Student &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    Name &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    Age   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;

}

func (self Student) runing(){
    fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s is running\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,self.Name)
}
func (self Student) reading(){
    fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s is reading\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ,self.Name)
}
func main() {
    stu1 :&lt;/span&gt;= Student{Name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Age:&lt;span&gt;22&lt;/span&gt;&lt;span&gt;}
    inf :&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt;(Skills)
    stu_type :&lt;/span&gt;=&lt;span&gt; reflect.TypeOf(stu1)
    inf_type :&lt;/span&gt;= reflect.TypeOf(inf).Elem()   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 特别说明，引用类型需要用Elem()获取指针所指的对象类型&lt;/span&gt;
    fmt.Println(stu_type.String())  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;main.Student&lt;/span&gt;
    fmt.Println(stu_type.Name()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Student&lt;/span&gt;
    fmt.Println(stu_type.PkgPath()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;
    fmt.Println(stu_type.Kind()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;
    fmt.Println(stu_type.Size())  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;
    fmt.Println(inf_type.NumMethod())  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
    fmt.Println(inf_type.Method(&lt;span&gt;0&lt;/span&gt;),inf_type.Method(&lt;span&gt;0&lt;/span&gt;).Name)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {reading main func() &amp;lt;invalid Value&amp;gt; 0} reading&lt;/span&gt;
    fmt.Println(inf_type.MethodByName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reading&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{reading main func() &amp;lt;invalid Value&amp;gt; 0} true&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数值&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) Bits() &lt;span&gt;int&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取数值类型的位宽，t 必须是整型、浮点型、复数型&lt;/span&gt;

------------------------------

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数组&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) Len() &lt;span&gt;int&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取数组的元素个数&lt;/span&gt;

------------------------------

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 映射&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) Key() reflect.Type &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取映射的键类型&lt;/span&gt;

------------------------------

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通道&lt;/span&gt;
&lt;span&gt;

func (t &lt;/span&gt;*rtype) ChanDir() reflect.ChanDir &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取通道的方向&lt;/span&gt;

------------------------------

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结构体&lt;/span&gt;
&lt;span&gt;

func (t &lt;/span&gt;*rtype) NumField() &lt;span&gt;int&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取字段数量&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) Field(&lt;span&gt;int&lt;/span&gt;) reflect.StructField  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据索引获取字段&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) FieldByName(&lt;span&gt;string&lt;/span&gt;) (reflect.StructField, &lt;span&gt;bool&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据名称获取字段&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) FieldByNameFunc(match func(&lt;span&gt;string&lt;/span&gt;) &lt;span&gt;bool&lt;/span&gt;) (reflect.StructField, &lt;span&gt;bool&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据指定的匹配函数 math 获取字段&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) FieldByIndex(index []&lt;span&gt;int&lt;/span&gt;) reflect.StructField  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据索引链获取嵌套字段&lt;/span&gt;

------------------------------

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数&lt;/span&gt;
&lt;span&gt;

func (t &lt;/span&gt;*rtype) NumIn() &lt;span&gt;int&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取函数的参数数量&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) In(&lt;span&gt;int&lt;/span&gt;) reflect.Type &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据索引获取函数的参数信息&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) NumOut() &lt;span&gt;int&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取函数的返回值数量&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) Out(&lt;span&gt;int&lt;/span&gt;) reflect.Type &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据索引获取函数的返回值信息&lt;/span&gt;
&lt;span&gt;
func (t &lt;/span&gt;*rtype) IsVariadic() &lt;span&gt;bool&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断函数是否具有可变参数。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有可变参数，则 t.In(t.NumIn()-1) 将返回一个切片。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reflect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

type Skills &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    reading()
    running()
}

type Student &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    Name &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    Age   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;

}

func (self Student) runing(){
    fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s is running\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,self.Name)
}
func (self Student) reading(){
    fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s is reading\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ,self.Name)
}
func main() {
    stu1 :&lt;/span&gt;= Student{Name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Age:&lt;span&gt;22&lt;/span&gt;&lt;span&gt;}
    stu_type :&lt;/span&gt;=&lt;span&gt; reflect.TypeOf(stu1)
    fmt.Println(stu_type.NumField())  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
    fmt.Println(stu_type.Field(&lt;span&gt;0&lt;/span&gt;))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{Name  string  0 [0] false}&lt;/span&gt;
    fmt.Println(stu_type.FieldByName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{{Age  int  16 [1] false} true&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Value&lt;/h3&gt;
&lt;p&gt;不是所有go类型值的Value表示都能使用所有方法。请参见每个方法的文档获取使用限制。在调用有分类限定的方法时，应先使用Kind方法获知该值的分类。调用该分类不支持的方法会导致运行时的panic。&lt;/p&gt;
&lt;p&gt;Value为go值提供了反射接口，获取Value对象方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 func ValueOf(i &lt;span&gt;interface&lt;/span&gt;{}) Value
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
str := &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
val :&lt;/span&gt;=&lt;span&gt; reflect.ValueOf(str)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;reflect.Value方法&lt;/h3&gt;
&lt;p&gt;注意：以下所有方法中的v是reflect.Value返回的值。&lt;/p&gt;
&lt;p&gt;reflect.Value.Kind()：获取变量类别，返回常量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7c569b8c-d429-4066-a00f-a3536f66b114')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_7c569b8c-d429-4066-a00f-a3536f66b114&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7c569b8c-d429-4066-a00f-a3536f66b114&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7c569b8c-d429-4066-a00f-a3536f66b114',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7c569b8c-d429-4066-a00f-a3536f66b114&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt;&lt;span&gt; (
        Invalid Kind &lt;/span&gt;=&lt;span&gt; iota
        Bool
        Int
        Int8
        Int16
        Int32
        Int64
        Uint
        Uint8
        Uint16
        Uint32
        Uint64
        Uintptr
        Float32
        Float64
        Complex64
        Complex128
        Array
        Chan
        Func
        Interface
        Map
        Ptr
        Slice
        String
        Struct
        UnsafePointer
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;常量类型&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reflect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

func main() {
    str :&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    val :&lt;/span&gt;=&lt;span&gt; reflect.ValueOf(str).Kind()
    fmt.Println(val)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用于获取值方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
func (v Value) Int() int64 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取int类型值，如果 v 值不是有符号整型，则 panic。&lt;/span&gt;
&lt;span&gt;
func (v Value) Uint() uint64 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取unit类型的值，如果 v 值不是无符号整型（包括 uintptr），则 panic。&lt;/span&gt;
&lt;span&gt;
func (v Value) Float() float64 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取float类型的值，如果 v 值不是浮点型，则 panic。&lt;/span&gt;
&lt;span&gt;
func (v Value) Complex() complex128 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取复数类型的值，如果 v 值不是复数型，则 panic。&lt;/span&gt;
&lt;span&gt;
func (v Value) Bool() &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取布尔类型的值，如果 v 值不是布尔型，则 panic。&lt;/span&gt;
&lt;span&gt;
func (v Value) Len() &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 v 值的长度，v 值必须是字符串、数组、切片、映射、通道。&lt;/span&gt;
&lt;span&gt;
func (v Value) Cap() &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 v 值的容量，v 值必须是数值、切片、通道。&lt;/span&gt;
&lt;span&gt;
func (v Value) Index(i &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;) reflect.Value &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 v 值的第 i 个元素，v 值必须是字符串、数组、切片，i 不能超出范围。&lt;/span&gt;
&lt;span&gt;
func (v Value) Bytes() []&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取字节类型的值，如果 v 值不是字节切片，则 panic。&lt;/span&gt;
&lt;span&gt;
func (v Value) Slice(i, j &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;) reflect.Value &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 v 值的切片，切片长度 = j - i，切片容量 = v.Cap() - i。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; v 必须是字符串、数值、切片，如果是数组则必须可寻址。i 不能超出范围。&lt;/span&gt;
&lt;span&gt;
func (v Value) Slice3(i, j, k &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;) reflect.Value  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 v 值的切片，切片长度 = j - i，切片容量 = k - i。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; i、j、k 不能超出 v 的容量。i &amp;lt;= j &amp;lt;= k。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; v 必须是字符串、数值、切片，如果是数组则必须可寻址。i 不能超出范围。&lt;/span&gt;
&lt;span&gt;
func (v Value) MapIndex(key Value) reflect.Value &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据 key 键获取 v 值的内容，v 值必须是映射。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果指定的元素不存在，或 v 值是未初始化的映射，则返回零值（reflect.ValueOf(nil)）&lt;/span&gt;
&lt;span&gt;
func (v Value) MapKeys() []reflect.Value &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 v 值的所有键的无序列表，v 值必须是映射。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 v 值是未初始化的映射，则返回空列表。&lt;/span&gt;
&lt;span&gt;
func (v Value) OverflowInt(x int64) &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断 x 是否超出 v 值的取值范围，v 值必须是有符号整型。&lt;/span&gt;
&lt;span&gt;
func (v Value) OverflowUint(x uint64) &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断 x 是否超出 v 值的取值范围，v 值必须是无符号整型。&lt;/span&gt;
&lt;span&gt;
func (v Value) OverflowFloat(x float64) &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断 x 是否超出 v 值的取值范围，v 值必须是浮点型。&lt;/span&gt;
&lt;span&gt;
func (v Value) OverflowComplex(x complex128) &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断 x 是否超出 v 值的取值范围，v 值必须是复数型。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置值方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
func (v Value) SetInt(x int64)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置int类型的值&lt;/span&gt;
&lt;span&gt;
func (v Value) SetUint(x uint64)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置无符号整型的值&lt;/span&gt;
&lt;span&gt;
func (v Value) SetFloat(x float64) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置浮点类型的值&lt;/span&gt;
&lt;span&gt;
func (v Value) SetComplex(x complex128) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置复数类型的值&lt;/span&gt;
&lt;span&gt;
func (v Value) SetBool(x &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置布尔类型的值&lt;/span&gt;
&lt;span&gt;
func (v Value) SetString(x &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置字符串类型的值&lt;/span&gt;
&lt;span&gt;
func (v Value) SetLen(n &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置切片的长度，n 不能超出范围，不能为负数。&lt;/span&gt;
&lt;span&gt;
func (v Value) SetCap(n &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置切片的容量&lt;/span&gt;
&lt;span&gt;
func (v Value) SetBytes(x []&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置字节类型的值&lt;/span&gt;
&lt;span&gt;
func (v Value) SetMapIndex(key, val reflect.Value) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置map的key和value，前提必须是初始化以后，存在覆盖、不存在添加&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;##########结构体相关：&lt;/span&gt;
func (v Value) NumField() &lt;span&gt;int&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取结构体字段（成员）数量&lt;/span&gt;
&lt;span&gt;
func (v Value) Field(i &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;) reflect.Value  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据索引获取结构体字段&lt;/span&gt;
&lt;span&gt;
func (v Value) FieldByIndex(index []&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;) reflect.Value &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据索引链获取结构体嵌套字段&lt;/span&gt;
&lt;span&gt;
func (v Value) FieldByName(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;) reflect.Value &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据名称获取结构体的字段，不存在返回reflect.ValueOf(nil)&lt;/span&gt;
&lt;span&gt;
func (v Value) FieldByNameFunc(match func(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;) &lt;span&gt;bool&lt;/span&gt;) Value &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据匹配函数 match 获取字段,如果没有匹配的字段，则返回零值（reflect.ValueOf(nil)）


&lt;/span&gt;&lt;span&gt;########通道相关：&lt;/span&gt;
func (v Value) Send(x reflect.Value)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送数据（会阻塞），v 值必须是可写通道。&lt;/span&gt;
&lt;span&gt;
func (v Value) Recv() (x reflect.Value, ok &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收数据（会阻塞），v 值必须是可读通道。&lt;/span&gt;
&lt;span&gt;
func (v Value) TrySend(x reflect.Value) &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试发送数据（不会阻塞），v 值必须是可写通道。&lt;/span&gt;
&lt;span&gt;
func (v Value) TryRecv() (x reflect.Value, ok &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试接收数据（不会阻塞），v 值必须是可读通道。&lt;/span&gt;
&lt;span&gt;
func (v Value) Close() &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭通道


&lt;/span&gt;&lt;span&gt;########函数相关&lt;/span&gt;
func (v Value) Call(&lt;span&gt;in&lt;/span&gt; []Value) (r []Value) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过参数列表 in 调用 v 值所代表的函数（或方法）。函数的返回值存入 r 中返回。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要传入多少参数就在 in 中存入多少元素。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Call 即可以调用定参函数（参数数量固定），也可以调用变参函数（参数数量可变）。&lt;/span&gt;
&lt;span&gt;
func (v Value) CallSlice(&lt;/span&gt;&lt;span&gt;in&lt;/span&gt; []Value) []Value &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用变参函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例一：获取和设置普通类型的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reflect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

func main() {
    str :&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    age :&lt;/span&gt;= &lt;span&gt;11&lt;/span&gt;&lt;span&gt;
    fmt.Println(reflect.ValueOf(str).String()) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取str的值，结果wd&lt;/span&gt;
    fmt.Println(reflect.ValueOf(age).Int())   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取age的值，结果age&lt;/span&gt;
    str2 := reflect.ValueOf(&amp;amp;str)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取Value类型&lt;/span&gt;
    str2.Elem().SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置值&lt;/span&gt;
    fmt.Println(str2.Elem(),age) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;jack 11&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例二：简单结构体操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reflect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

type Skills &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    reading()
    running()
}

type Student &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    Name &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    Age   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;

}

func (self Student) runing(){
    fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s is running\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,self.Name)
}
func (self Student) reading(){
    fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s is reading\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ,self.Name)
}
func main() {
    stu1 :&lt;/span&gt;= Student{Name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Age:&lt;span&gt;22&lt;/span&gt;&lt;span&gt;}
    stu_val :&lt;/span&gt;= reflect.ValueOf(stu1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取Value类型&lt;/span&gt;
    fmt.Println(stu_val.NumField()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
    fmt.Println(stu_val.Field(&lt;span&gt;0&lt;/span&gt;),stu_val.Field(&lt;span&gt;1&lt;/span&gt;)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;wd 22&lt;/span&gt;
    fmt.Println(stu_val.FieldByName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;
    stu_val2 := reflect.ValueOf(&amp;amp;&lt;span&gt;stu1).Elem()   
    stu_val2.FieldByName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).SetInt(&lt;span&gt;33&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置字段值 ，结果33&lt;/span&gt;
&lt;span&gt;    fmt.Println(stu1.Age)
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例三：通过反射调用结构体中的方法，通过reflect.Value.Method(i int).Call()或者reflect.Value.MethodByName(name string).Call()实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reflect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

type Student &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    Name &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    Age &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;
}

func (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; *Student) SetName(name &lt;span&gt;string&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Name =&lt;span&gt; name
    fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set name %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Name )
}

func (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; *Student) SetAge(age &lt;span&gt;int&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Age =&lt;span&gt; age
    fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set age %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,age )
}

func (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; *Student) String() &lt;span&gt;string&lt;/span&gt;&lt;span&gt; {
    fmt.Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Name)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Name
}

func main() {
    stu1 :&lt;/span&gt;= &amp;amp;Student{Name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Age:&lt;span&gt;22&lt;/span&gt;&lt;span&gt;}
    val :&lt;/span&gt;= reflect.ValueOf(stu1)       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取Value类型，也可以使用reflect.ValueOf(&amp;amp;stu1).Elem() &lt;/span&gt;
    val.MethodByName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Call(nil)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用String方法&lt;/span&gt;

    &lt;span&gt;params&lt;/span&gt; := make([]reflect.Value, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;params&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;] = reflect.ValueOf(&lt;span&gt;18&lt;/span&gt;&lt;span&gt;)
    val.MethodByName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SetAge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Call(&lt;span&gt;params&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过名称调用方法&lt;/span&gt;

    &lt;span&gt;params&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;] = reflect.ValueOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)   
    val.Method(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;).Call(&lt;span&gt;params&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过方法索引调用&lt;/span&gt;
&lt;span&gt;
    fmt.Println(stu1.Name,stu1.Age)
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this is wd
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;set age 18
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;set name jack
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jack 18&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 24 Jun 2018 15:31:00 +0000</pubDate>
<dc:creator>W-D</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wdliu/p/9222283.html</dc:identifier>
</item>
<item>
<title>用R处理一组数据的三种方式 - Allen Lee</title>
<link>http://www.cnblogs.com/allenlooplee/p/9222173.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/allenlooplee/p/9222173.html</guid>
<description>&lt;p&gt;USArrests是R附带的一个数据集，现在我们需要创建一个factor向量urbancat，如果UrbanPop列的某个值在中位数之上，就把urbancat对应位置的值设为1，否则设为0。&lt;/p&gt;

&lt;p&gt;这种数据处理任务实在太简单了，一个for循环就能搞定。首先，我们计算一下UrbanPop的中位数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
urbanPop.median &amp;lt;- median(USArrests$UrbanPop)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，用rep函数初始化一个等长的urbancat向量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
urbancat &amp;lt;- rep(x = 0, times = length(USArrests$UrbanPop))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着，用for循环为urbancat设置对应位置的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
for (i in 1:length(urbancat)) {
  if (USArrests$UrbanPop[i] &amp;gt; urbanPop.median) {
      urbancat[i] &amp;lt;- 1
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码对于拥有命令式编程背景的同学来说是非常亲切自然的。值的提醒的是，如果urbancat的长度有可能为0，那么使用1:length(urbancat)可能会有非预期结果（你可以试一下），这个时候我们建议把1:length(urbancat)换成seq_along(urbancat)。&lt;/p&gt;

&lt;p&gt;对于拥有函数式编程背景的同学，可以使用purrr的map函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
library(purrr)
urbancat &amp;lt;- map_dbl(USArrests$UrbanPop, function(x) if (x &amp;gt; urbanPop.median) 1 else 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;map_dbl会在应用你传入的匿名函数之后以double向量的方式返回结果。如果你喜欢用formula，也可以把匿名函数换成formula：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
urbancat &amp;lt;- map_dbl(USArrests$UrbanPop, ~ if (.x &amp;gt; urbanPop.median) 1 else 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的.x表示map_dbl传给你的UrbanPop列的某个值。&lt;/p&gt;

&lt;p&gt;在接触R之前，我基本上都会选择FP的做法，但在接触R之后，我被它的向量化运算以及通过逻辑值取子集（logical subsetting）的做法深深吸引：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
urbancat[USArrests$UrbanPop &amp;gt; urbanPop.median] &amp;lt;- 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;USArrests$UrbanPop是一个向量，而urbanPop.median是一个值，因为R默认支持向量化运算，所以拿USArrests$UrbanPop和urbanPop.median比较会自动转化成拿USArrests$UrbanPop里的每个值和urbanPop.median，得到一个和USArrests$UrbanPop等长的由逻辑值（T和F）组成的向量（F F T F T ......）。当我们用这个逻辑值向量去索引urbancat时，就会取出逻辑值为T的对应元素，这个时候，结合赋值运算就可以把这些元素都设为1了。&lt;/p&gt;

&lt;p&gt;最后，要把urbancat变成factor向量，你可以修改for循环或者map函数，但在R里，你只需把urbancat传给factor函数就行了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
urbancat &amp;lt;- factor(urbancat)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Ruby之父松本行弘在他的《松本行弘的程序世界》里说过，“在语言学领域里，有一个Sapir-Whirf假说，认为语言可以影响说话者的思想。也就是说，语言的不同，造成了思想的不同。程序员由于使用的编程语言不同，他的思考方法和编写出来的代码都会受到编程语言的很大影响。”而这番话可以很好地概括我此时的感受。&lt;/p&gt;
</description>
<pubDate>Sun, 24 Jun 2018 15:25:00 +0000</pubDate>
<dc:creator>Allen Lee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/allenlooplee/p/9222173.html</dc:identifier>
</item>
<item>
<title>图像检索(2):均值聚类-构建BoF - Brook_icv</title>
<link>http://www.cnblogs.com/wangguchangqing/p/9222267.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangguchangqing/p/9222267.html</guid>
<description>&lt;p&gt;在图像检索时，通常首先提取图像的局部特征，这些局部特征通常有很高的维度（例如，sift是128维），有很多的冗余信息，直接利用局部特征进行检索，效率和准确度上都不是很好。这就需要重新对提取到的局部特征进行编码，以便于匹配检索。&lt;br/&gt;常用的局部特征编码方法有三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BoF&lt;/li&gt;
&lt;li&gt;VLAD&lt;/li&gt;
&lt;li&gt;FV&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文主要介绍基于k-means聚类算法的&lt;code&gt;BoF&lt;/code&gt;的实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BoF的原理&lt;/li&gt;
&lt;li&gt;k均值聚类概述&lt;/li&gt;
&lt;li&gt;使用OpenCV实现的BoF&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;bof&quot;&gt;BoF&lt;/h3&gt;
&lt;p&gt;该方法源自于文本处理的词袋模型。Bag-of-words model (BoW model) 最早出现在NLP和IR领域. 该模型忽略掉文本的语法和语序, 用一组无序的单词(words)来表达一段文字或一个文档. 近年来, BoW模型被广泛应用于计算机视觉中. 与应用于文本的BoW类比, 图像的特征(feature)被当作单词(Word).&lt;/p&gt;
&lt;p&gt;例如下面的句子：&lt;br/&gt;&lt;code&gt;John likes to watch movies. Mary likes too. John also likes to watch football games.&lt;/code&gt;&lt;br/&gt;就可以构建一个词典&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;John&quot;: 1, &quot;likes&quot;: 2, &quot;to&quot;: 3, &quot;watch&quot;: 4, &quot;movies&quot;: 5, &quot;also&quot;: 6, &quot;football&quot;: 7, &quot;games&quot;: 8, &quot;Mary&quot;: 9, &quot;too&quot;: 10}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该字典中包含10个单词, 每个单词有唯一索引, 注意它们的顺序和出现在句子中的顺序没有关联. 根据这个字典, 我们能将上述两句话重新表达为下述两个向量:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[1, 2, 1, 1, 1, 0, 0, 0, 1, 1]  [1, 1, 1, 1, 0, 1, 1, 1, 0, 0]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个向量共包含10个元素, 其中第i个元素表示字典中第i个单词在句子中出现的次数。&lt;br/&gt;统计词频的时候有两种方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;词集模型（set of words model) 将每个词出现与否作为特征，忽略词出现的次数，这种模型得到的向量只有0和1两个值；&lt;/li&gt;
&lt;li&gt;词袋模型（bag of words model）要统计词出现的次数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;特征词袋(BoF，Bag Of Feature)借鉴文本处理的词袋（BoW，Bag Of Bag)算法，将图像表示成视觉关键词的统计直方图。就像上面对文本的处理一样，提取文本中出现单词组成词汇表，这里关键是得到图像库的“词汇表”。为了得到图像库的“词汇表&quot;,通常对提取到的图像特征进行聚类，得到一定个数的簇。这些聚类得到的簇，就是图像的”词汇“，可以称为视觉词（Visual Word）。聚类形成的簇，可以使用聚类中心来描述，所以，&lt;strong&gt;视觉词&lt;/strong&gt;指的是图像的局部区域特征（如纹理，特征点）经过聚类形成的聚类中心。&lt;/p&gt;
&lt;p&gt;有了视觉词的集合后，就可以将一幅图像表示为&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;维的向量（&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;为聚类中心的个数，也就是视觉词的个数），向量的每个分量表示某个视觉词在图像中出现的次数。&lt;/p&gt;
&lt;p&gt;构建图像的&lt;code&gt;BoF&lt;/code&gt;的步骤如下：以SIFT特征为例&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;SIFT特征提取&lt;/strong&gt; 提取训练集中所有图像的SIFT特征，设有&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;幅图像，共得到&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;个SIFT特征。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构建视觉词汇表&lt;/strong&gt; 对提取到的&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;个SIFT特征进行聚类，得到&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;个聚类中心，组成图像的&lt;em&gt;视觉词汇表&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图像的视觉词向量表示&lt;/strong&gt;，统计每幅图像中视觉词汇的出现的次数，得到图像的特征向量。在检索时，该特征向量就代表该幅图像。统计时，计算图像中提取到的SIFT特征点到各个视觉词（聚类中心）的距离，将其归类到聚类最近的视觉词中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以聚类在构建&lt;code&gt;BoF&lt;/code&gt;是很重要的一步，接下来简单的介绍下聚类的基本知识以及最常用的聚类算法&lt;code&gt;k-means&lt;/code&gt;算法。&lt;/p&gt;
&lt;h3 id=&quot;聚类概述&quot;&gt;聚类概述&lt;/h3&gt;
&lt;p&gt;聚类(Clustering)是一种无监督学习算法，其目的是将数据集中的样本划分为若干个不相交的子集，每个子集称为一个簇(Cluster)。聚类的时候并不关心某一类是什么，只根据数据的相似性，将数据划分到不同的组中。每个组内的成员具有相似的性质。&lt;/p&gt;
&lt;p&gt;聚类算法说白了就是给你一大堆点的坐标（维度可以是很高），然后通过一个向量的相似性准则（通常是距离，比如欧拉距离），然后把相近的点放在一个集合里面，归为一类。&lt;/p&gt;
&lt;p&gt;更正式的说，假设有样本集 &lt;span class=&quot;math inline&quot;&gt;\(D = \{x_1,x_2,\dots,x_m\}\)&lt;/span&gt;有&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个无标记的样本，每个样本可以使用一个&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;维特征向量表示：&lt;span class=&quot;math inline&quot;&gt;\(x_i = (x_{i1};x_{i2};\dots;x_{in})\)&lt;/span&gt;,根据相似的准则，将集合&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;划分为&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个不相交的簇&lt;span class=&quot;math inline&quot;&gt;\(\{C_l|l = 1,2,\dots,k\}\)&lt;/span&gt;。每个簇可以用其聚类中心来描述&lt;span class=&quot;math inline&quot;&gt;\(\lambda_l = (x_{l1},x_{l2},\dots,x_{ln}),l = 1,2,\dots,k\)&lt;/span&gt;.&lt;/p&gt;
&lt;h4 id=&quot;相似性度量距离计算&quot;&gt;相似性度量（距离计算）&lt;/h4&gt;
&lt;p&gt;两个向量的相似性，通常可以使用距离度量，距离越大，相似性越小；距离越小，相似性越大。给定两个样本&lt;span class=&quot;math inline&quot;&gt;\(x = (x_1,x_2,\dots,x_n), y = (y_1,y_x,\dots,y_n)\)&lt;/span&gt;，常用的距离计算有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;欧氏距离 Euclidean distance，这个应该是最有名的了。&lt;span class=&quot;math inline&quot;&gt;\(dist = \|x_i-y_i\|_2 \sqrt{\sum_{i=1}^n(x_i - y_i)^2}\)&lt;/span&gt;,欧氏距离也是一种&lt;span class=&quot;math inline&quot;&gt;\(l_2\)&lt;/span&gt;范数。&lt;/li&gt;
&lt;li&gt;曼哈顿距离 Manhattan distance,也被称为城市街区距离。&lt;span class=&quot;math inline&quot;&gt;\(dist = \|x_i-y_i\|_1= \sum_{i=1}^n\|x_i -y_i|\)&lt;/span&gt;,曼哈顿距离也是&lt;span class=&quot;math inline&quot;&gt;\(l_1\)&lt;/span&gt;范数。&lt;/li&gt;
&lt;li&gt;切比雪夫距离 Chebyshev distance,&lt;span class=&quot;math inline&quot;&gt;\(dist = max(|x_i - y_i|)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上三种距离可以统称为闵可夫斯基距离 Minkowski distance,&lt;span class=&quot;math inline&quot;&gt;\(dist = (\sum_{i=1}^n|x_i-y_i|^p)^{\frac{1}{p}}\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(p=1\)&lt;/span&gt;为曼哈顿距离&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(p=2\)&lt;/span&gt;为欧氏距离&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(p\to\infty\)&lt;/span&gt;为切比雪夫距离。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，度量两个向量相似性的方法还有很多种，这里只列举了最常用的，在均值聚类算法中经常的使用的是欧氏距离和曼哈顿距离。&lt;/p&gt;
&lt;h4 id=&quot;k-means&quot;&gt;k-means&lt;/h4&gt;
&lt;p&gt;聚类算法可以分为三类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原型聚类，此类算法假设聚类结构能够通过一组原型描述，这里原型指的是样本空间中具有代表性的点。&lt;/li&gt;
&lt;li&gt;密度距离，该类算法假设聚类结构能够通过样本分布的紧密程度来确定。&lt;/li&gt;
&lt;li&gt;层次聚类，在不同的层次对数据集进行划分，从而形成树形的聚结构。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;均值聚类是原型聚类的一种，它使用簇内的均值向量来描述每个簇，假设给定的样本集&lt;span class=&quot;math inline&quot;&gt;\(D = \{x_1,x_2,\dots,x_m\}\)&lt;/span&gt;,得到&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个簇，&lt;span class=&quot;math inline&quot;&gt;\(C = {C_1,C_2,\dots,C_k}\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;means算法的目标是使，簇内样本到簇的质心（簇内的均值向量）距离最小&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ E = \sum_{i=1}^k\sum_{x\in C_i}\|x-u_i\|_2^2,u_i = \frac{1}{|C_i|}\sum x\in C_i \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(u_i\)&lt;/span&gt;是簇&lt;span class=&quot;math inline&quot;&gt;\(C_i\)&lt;/span&gt;的均值向量。&lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;就表示了簇内样本围绕着均值向量（簇的中心）的紧密程度，&lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;越小则簇内样本相似度越高。&lt;br/&gt;要使得&lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;的值最小，是一个NP难题，因此均值聚类使用贪心策略，通过迭代的方法来求解最优解。&lt;/p&gt;
&lt;h4 id=&quot;lioyds-algorithm&quot;&gt;Lioyd's Algorithm&lt;/h4&gt;
&lt;p&gt;均值聚类算法多数是基于Lioyd's Algorithm，其流程很简单。首先，随机的确定&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个初始点作为各个簇的质心。然后将数据集中每个点分配到与其最近的质心代表的簇中。然后更新各个簇的质心为该簇所有向量的均值。具体表示如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;创建k个点作为起始质心（通常随机选择）
当任意一个点所在的簇发生变化时
    对数据集中的每个数据点
        对每个质心
            计算质心与数据点之间的距离
        将数据点分配到与其最近的簇中
    对每个簇，计算簇中所有点的均值作为新的质心&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;k-means算法有两个输入参数簇的个数&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;以及初始的簇的质心&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;簇的个数&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;通常可以使用“肘点法”，通过最小化&lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;来确定&lt;/li&gt;
&lt;li&gt;对于初始的质心的选择，可以随机确定或者使用&lt;code&gt;k-means++&lt;/code&gt;来确定&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;vlfeat以及opencv实现&quot;&gt;vlfeat以及OpenCV实现&lt;/h4&gt;
&lt;h5 id=&quot;vlfeat&quot;&gt;vlfeat&lt;/h5&gt;
&lt;p&gt;vlfeat实现了三种的k-means算法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Lioyd's Algorithm&lt;/li&gt;
&lt;li&gt;Elkan's Algorithm 使用三角形不等式对Lioyd算法的一种优化，提高了其计算的速度，本质上两者是一样的。&lt;/li&gt;
&lt;li&gt;ANN Algorithm 适用于大规模的数据集（百万级）簇的个数成百上千&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以使用如下代码来初始化k-means算法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;VlKMeans * fkmeans = vl_kmeans_new(VL_TYPE_FLOAT, VlDistanceL2);
vl_kmeans_set_algorithm(fkmeans, VlKMeansElkan);
vl_kmeans_init_centers_with_rand_data(fkmeans,data,data_dim,data_num,k);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先设置聚类时的数据类型为&lt;code&gt;float&lt;/code&gt;，相似性度量使用&lt;code&gt;l2&lt;/code&gt;距离也就是欧氏距离；接着设置使用的算法为是&lt;code&gt;Elkan&lt;/code&gt;，并且使用随机的方法确定&lt;code&gt;k&lt;/code&gt;个簇的中心。&lt;br/&gt;初始化完成后，使用如下代码进行聚类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vl_kmeans_cluster(fkmeans, data, data_dim, data_num, k);  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要指定数据，数据的维度，数据的个数以及簇的中心，这里需要注意的是数据的维度。聚类数据的维度指的是，一个数据有几个分量组成。例如，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一幅灰度图像，其聚类的对象是像素的像素值。灰度图，一个像素只有一个分量，则灰度图聚类数据的维度就是1维。&lt;/li&gt;
&lt;li&gt;RGB图像，一个像素有RGB三个分量组成，则其聚类数据的维度就是3维。&lt;/li&gt;
&lt;li&gt;sift描述子，一个sift描述子是128维的向量，则其聚类数据的维度就是128维。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;opencv&quot;&gt;OpenCV&lt;/h5&gt;
&lt;p&gt;相较于vlfeat，OpenCV中的&lt;code&gt;kmeans&lt;/code&gt;则更易于调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
double cv::kmeans(InputArray data,
    int     K,
    InputOutputArray    bestLabels,
    TermCriteria    criteria,
    int     attempts,
    int     flags,
    OutputArray     centers = noArray() 
)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;data 数据集，每一行代表数据集中的一个样本&lt;/li&gt;
&lt;li&gt;k 聚类形成簇的个数&lt;/li&gt;
&lt;li&gt;bestLabels 数据集中每个样本在簇的index&lt;/li&gt;
&lt;li&gt;criteria 迭代终止的条件。&lt;/li&gt;
&lt;li&gt;attempts 算法执行的次数&lt;/li&gt;
&lt;li&gt;flags 初始质心的指定方法，&lt;code&gt;KMEANS_RANDOM_CENTERS&lt;/code&gt; 随机指定；&lt;code&gt;KMEANS_PP_CENTERS&lt;/code&gt;k-means++；&lt;code&gt;KMEANS_USE_INITIAL_LABELS&lt;/code&gt;算法第一次执行时，使用用户提供的初始质心；第二次及以后的执行使用随机或者半随机的方式初始化质心&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在OpenCV中&lt;code&gt;TermCriteria&lt;/code&gt;表示迭代算法结束的两种条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;达到了迭代的次数&lt;/li&gt;
&lt;li&gt;迭代产生的结果达到了指定的精度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该类的初始化需要三个参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;type 有三种选择&lt;code&gt;COUNT, EPS or COUNT + EPS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;maxCount 最大的迭代次数&lt;/li&gt;
&lt;li&gt;epsilon 精度&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;构建bof&quot;&gt;构建BoF&lt;/h3&gt;
&lt;p&gt;在上一篇文章&lt;a href=&quot;https://www.cnblogs.com/wangguchangqing/p/9176103.html&quot; title=&quot;图像检索(1): 再论SIFT-基于vlfeat实现&quot;&gt;图像检索(1): 再论SIFT-基于vlfeat实现&lt;/a&gt;中实现了&lt;code&gt;SIFT&lt;/code&gt;特征点的提取，这里再对提取到的特征点进行聚类，构建图像集的视觉词汇表。&lt;/p&gt;
&lt;p&gt;基于SIFT特征构建BoF的步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提取sift特征点&lt;/li&gt;
&lt;li&gt;聚类生成视觉词汇表 Visual Vocabulary&lt;/li&gt;
&lt;li&gt;统计视觉词在每张图像中出现的频率，形成BoF&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于OpenCV的实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void bof_encode(const string &amp;amp;image_folder,int k,vector&amp;lt;Mat&amp;gt; &amp;amp;bof) {

    vector&amp;lt;string&amp;gt; image_file_list;
    get_file_name_list(image_folder,image_file_list);

    // 提取图像的sift
    vector&amp;lt;Mat&amp;gt; descriptor_list;
    Ptr&amp;lt;xfeatures2d::SIFT&amp;gt; sift = xfeatures2d::SIFT::create();
    for(const string &amp;amp; file: image_file_list){
        cout &amp;lt;&amp;lt; &quot;Extracte sift feature #&quot; &amp;lt;&amp;lt; file &amp;lt;&amp;lt; endl;
        vector&amp;lt;KeyPoint&amp;gt; kpts;
        Mat des;
        Mat img = imread(file);
        CV_Assert(!img.empty());
        sift-&amp;gt;detectAndCompute(img,noArray(),kpts,des);
        descriptor_list.push_back(des);
    }

    // 将各个图像的sift特征组合到一起
    Mat descriptor_stack;
    vconcat(descriptor_list,descriptor_stack);

    // 聚类
    Mat cluster_centers;
    vector&amp;lt;int&amp;gt; labels;
    kmeans(descriptor_stack,k,labels,TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 
        10, 1.0),3, KMEANS_RANDOM_CENTERS,cluster_centers);

    // labels已经得到了每个样本（特征点）所属的簇，需要进行统计得到每一张图像的BoF
    int index = 0;
    for(Mat img : descriptor_list){
        // For all keypoints of each image 
        auto cluster = new int[k];
        for(int i = 0; i &amp;lt; img.rows; i ++){
            cluster[labels[index]] ++;
            index ++;
        }

        Mat mat(1,k,CV_32S);
        auto ptr = mat.ptr&amp;lt;int&amp;gt;(0);
        mempcpy(ptr,cluster,sizeof(int) * k);

        bof.push_back(mat);
        delete cluster;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提取特征点后，需要将得到的sift的特征描述子组合到一起，进行聚类，需要用到函数&lt;code&gt;vconcat&lt;/code&gt;,该函数在y方向上将&lt;code&gt;Mat&lt;/code&gt;组合在一起，需要各个&lt;code&gt;Mat&lt;/code&gt;的列是一样，组合得到的&lt;code&gt;Mat&lt;/code&gt;仍然有相同的列；同样的函数&lt;code&gt;hconcat&lt;/code&gt;在水平方向上组合&lt;code&gt;Mat&lt;/code&gt;，组合得到的&lt;code&gt;Mat&lt;/code&gt;的行保持不变。&lt;/p&gt;
&lt;p&gt;在聚类后可以得到所有图像的各个sift特征所属的簇，上述代码的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // labels已经得到了每个样本（特征点）所属的簇，需要进行统计得到每一张图像的BoF
    int index = 0;
    for(Mat img : descriptor_list){
        // For all keypoints of each image 
        auto cluster = new int[k];
        for(int i = 0; i &amp;lt; img.rows; i ++){
            cluster[labels[index]] ++;
            index ++;
        }

        Mat mat(1,k,CV_32S);
        auto ptr = mat.ptr&amp;lt;int&amp;gt;(0);
        mempcpy(ptr,cluster,sizeof(int) * k);

        bof.push_back(mat);
        delete cluster;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是统计每张图像中,各个Visual Word的个数。这样一幅图像就可以使用一个&lt;code&gt;K&lt;/code&gt;维的向量表示。&lt;/p&gt;
</description>
<pubDate>Sun, 24 Jun 2018 15:22:00 +0000</pubDate>
<dc:creator>Brook_icv</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangguchangqing/p/9222267.html</dc:identifier>
</item>
<item>
<title>C语言单元测试框架--EmbedUnit - 啊哈彭</title>
<link>http://www.cnblogs.com/pingwen/p/9222024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pingwen/p/9222024.html</guid>
<description>&lt;p data-source-line=&quot;2&quot;&gt;Embedded Unit是个纯标准c构建的单元测试框架，主要用在嵌入式c的单体测试上，其主要特点是不依赖于任何C的标准库，所有的对象都是静态分配。&lt;/p&gt;
&lt;p data-source-line=&quot;2&quot;&gt;最早这个项目托管在SourceForge上（&lt;a href=&quot;https://sourceforge.net/projects/embunit&quot;&gt;https://sourceforge.net/projects/embunit&lt;/a&gt; ），目前在GitHub也有多个拷贝。&lt;/p&gt;

&lt;h2 id=&quot;21-断言&quot; data-source-line=&quot;6&quot;&gt;2.1 断言&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; TEST_ASSERT_NULL(pointer)\&lt;span&gt;
    TEST_ASSERT_MESSAGE(pointer &lt;/span&gt;== NULL,#pointer &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; was not null.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; TEST_ASSERT_NOT_NULL(pointer)\&lt;span&gt;
    TEST_ASSERT_MESSAGE(pointer &lt;/span&gt;!= NULL,#pointer &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; was null.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; TEST_ASSERT_MESSAGE(condition, message)\
    &lt;span&gt;if&lt;/span&gt; (condition) {} &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {TEST_FAIL(message);}
    
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; TEST_ASSERT(condition)\
    &lt;span&gt;if&lt;/span&gt; (condition) {} &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {TEST_FAIL(#condition);}

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; TEST_FAIL(message)\
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;) {} &lt;span&gt;else&lt;/span&gt; {addFailure(message,__LINE__,__FILE__);&lt;span&gt;return&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;23&quot;&gt;TEST_ASSERT_NULL依赖TEST_ASSERT_MESSAGE，TEST_ASSERT_MESSAGE依赖TEST_FAIL，TEST_FAIL依赖addFailure。&lt;br/&gt;所以一般的错误断言，会使用addFailure来完成错误处理，其原型如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; addFailure(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *msg, &lt;span&gt;long&lt;/span&gt; line, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;file) 
{
    TestResult_addFailure(result_, (Test&lt;/span&gt;*)self_, (&lt;span&gt;char&lt;/span&gt;*)msg, line, (&lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)file);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; TestResult_addFailure(TestResult* self,Test* test,&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* msg,&lt;span&gt;int&lt;/span&gt; line,&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; file)
{
    self&lt;/span&gt;-&amp;gt;failureCount++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (self-&amp;gt;&lt;span&gt;listener) {
        TestListner_addFailure(self&lt;/span&gt;-&amp;gt;&lt;span&gt;listener, test, msg, line, file);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;39&quot;&gt;在TestResult_addFailure中对错误case的总数进行计数，而错误消息由TestListner_addFailure负责。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TestRunner_addFailure(TestListner* self,Test* test,&lt;span&gt;char&lt;/span&gt;* msg,&lt;span&gt;int&lt;/span&gt; line,&lt;span&gt;char&lt;/span&gt;*&lt;span&gt; file)
{
    stdimpl_print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    stdimpl_print(Test_name(root_));
    stdimpl_print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    stdimpl_print(Test_name(test));
    {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;16&lt;/span&gt;&lt;span&gt;];
        stdimpl_print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        stdimpl_print(file);
        stdimpl_print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        stdimpl_itoa(line, buf, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
        stdimpl_print(buf);
        stdimpl_print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    stdimpl_print(msg);
    stdimpl_print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;22-测试case管理&quot; data-source-line=&quot;63&quot;&gt;2.2 测试case管理&lt;/h2&gt;
&lt;p data-source-line=&quot;64&quot;&gt;EmbedUnit在测试的管理方面，主要使用了2个编程技术，一是结构体数组、二是函数指针。EmbedUnit可以说是C语言模块化开发的教材，在宏定义、函数指针、结构体对象方面的应用十分精妙。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
TestRef CounterTest_tests(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    EMB_UNIT_TESTFIXTURES(fixtures) {
        new_TestFixture(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testInit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,testInit),
        new_TestFixture(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testSetValue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,testSetValue),
        new_TestFixture(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testInc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,testInc),
        new_TestFixture(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testDec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,testDec),
        new_TestFixture(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testClr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,testClr),
    };
    EMB_UNIT_TESTCALLER(CounterTest,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CounterTest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,setUp,tearDown,fixtures);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (TestRef)&amp;amp;&lt;span&gt;CounterTest;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;80&quot;&gt;EMB_UNIT_TESTFIXTURES(fixtures)很奇怪的C语言写法，但是如果展开后就很明了恍然大悟。&lt;/p&gt;
&lt;blockquote data-source-line=&quot;82&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; EMB_UNIT_TESTFIXTURES(fixtures) \
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; TestFixture    fixtures[] = 
    
&lt;span&gt;#define&lt;/span&gt; new_TestFixture(name,test)\&lt;span&gt;
    {\
        name,\
        test,\
    }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;93&quot;&gt;fixtures就是一个数组而已，static const TestFixture fixtures[]。new_TestFixture就是一个大括号。&lt;br/&gt;然后是关键的一句EMB_UNIT_TESTCALLER，这个函数把上面的数组fixtures[]加入到测试case组，组名叫做CounterTest。 而测试case的个数由sizeof(fixtures)/sizeof(fixtures[0])来直接计算出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; EMB_UNIT_TESTCALLER(caller,name,sup,tdw,fixtures) \
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; TestCaller caller = new_TestCaller(name,sup,tdw,&lt;span&gt;sizeof&lt;/span&gt;(fixtures)/&lt;span&gt;sizeof&lt;/span&gt;(fixtures[&lt;span&gt;0&lt;/span&gt;]),(TestFixture*)fixtures)
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;101&quot;&gt;继续深入，new_TestCaller是一个宏定义，展开后扩展为一个TestCaller类型的结构体。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; new_TestCaller(name,sup,tdw,numberOfFixtuers,fixtuers)\&lt;span&gt;
    {\
        (TestImplement&lt;/span&gt;*)&amp;amp;&lt;span&gt;TestCallerImplement,\
        name,\
        sup,\
        tdw,\
        numberOfFixtuers,\
        fixtuers,\
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;114&quot;&gt;其结构体定义为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; __TestCaller        TestCaller;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; __TestCaller*    TestCallerRef;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;downward compatible&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; __TestCaller {
    TestImplement&lt;/span&gt;*&lt;span&gt; isa;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;name;
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;(*setUp)(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;(*tearDown)(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; numberOfFixtuers;
    TestFixture    &lt;/span&gt;*&lt;span&gt;fixtuers;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;129&quot;&gt;上面的写法非常精妙，值得在项目中学习，第一用宏定义展开结构体很好的包装了细节。第二结构体类型的使用，不直接用结构体定义名称__TestCaller，而进行转换用typedef重新定义为TestCaller，在很大的程度上起到接口隔离的效果。&lt;br/&gt;到目前为止，已经构成了一个完整的测试组，包括setUp，tearDown，fixtuers，测试环境准备、现场清理、待测函数三个因素已经具备。CounterTest类型为TestCaller，被返回传递给测试执行函数。&lt;/p&gt;
&lt;h2 id=&quot;23测试的执行&quot; data-source-line=&quot;132&quot;&gt;2.3测试的执行&lt;/h2&gt;
&lt;p data-source-line=&quot;133&quot;&gt;测试的执行得从测试组开始说起，测试组保证了测试例程以及其运行相关的结构数据。 测试的执行从TestRunner_runTest(CounterTest_tests())开始。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; TestRunner_runTest(Test*&lt;span&gt; test)
{
    root_ &lt;/span&gt;=&lt;span&gt; test;
    Test_run(test, &lt;/span&gt;&amp;amp;&lt;span&gt;result_);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;143&quot;&gt;对Test_run进行追踪。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; Test_run(s,r)            ((Test*)s)-&amp;gt;isa-&amp;gt;run(s,r)

&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; __Test {
    TestImplement&lt;/span&gt;*&lt;span&gt; isa;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;151&quot;&gt;测试组的执行时从Test_run开始的，参数是Test* test和TestResult result_，与其说TestImplement* isa被转成(Test*)类型，不如说取出了TestCaller结构体的第一个元素，然后调用了run函数指针。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; __TestImplement    TestImplement;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; __TestImplement*    TestImplementRef;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;downward compatible&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

typedef &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;*(*TestNameFunction)(&lt;span&gt;void&lt;/span&gt;*&lt;span&gt;);
typedef &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;(*TestRunFunction)(&lt;span&gt;void&lt;/span&gt;*,TestResult*&lt;span&gt;);
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(*TestCountTestCasesFunction)(&lt;span&gt;void&lt;/span&gt;*&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; __TestImplement {
    TestNameFunction name;
    TestRunFunction run;
    TestCountTestCasesFunction countTestCases;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;167&quot;&gt;这是一路漫长的C面向对象写法，虽然看起来结构整齐，但是逻辑上绕了很多弯。分析如下。&lt;br/&gt;1)isa-&amp;gt;run的来源&lt;br/&gt;TestCaller中的isa来源于定义测试组时候的结构体展开。 TestCallerImplement是一个全局的变量。 在TestCaller 内部，TestCallerImplement是一个全局的变量是其第一个元素，类型为(TestImplement*)，也叫做Test类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;const&lt;/span&gt;&lt;span&gt; TestImplement TestCallerImplement;

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; new_TestCaller(name,sup,tdw,numberOfFixtuers,fixtuers)\&lt;span&gt;
    {\
        (TestImplement&lt;/span&gt;*)&amp;amp;&lt;span&gt;TestCallerImplement,\
        name,\
        sup,\
        tdw,\
        numberOfFixtuers,\
        fixtuers,\
    }
    
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; __Test {
    TestImplement&lt;/span&gt;*&lt;span&gt; isa;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;187&quot;&gt;2）函数的调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; __TestImplement {
    TestNameFunction name;
    TestRunFunction run;
    TestCountTestCasesFunction countTestCases;
};

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; TestImplement TestCallerImplement =&lt;span&gt; {
    (TestNameFunction)            TestCaller_name,
    (TestRunFunction)            TestCaller_run,
    (TestCountTestCasesFunction)TestCaller_countTestCases,
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;202&quot;&gt;所以isa-&amp;gt;run就是调用TestCaller_run函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;void&lt;/span&gt;(*TestRunFunction)(&lt;span&gt;void&lt;/span&gt;*,TestResult*&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; TestCaller_run(TestCaller* self,TestResult*&lt;span&gt; result)
{
    TestCase cs &lt;/span&gt;= new_TestCase(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    cs.setUp&lt;/span&gt;= self-&amp;gt;&lt;span&gt;setUp;
    cs.tearDown    &lt;/span&gt;= self-&amp;gt;&lt;span&gt;tearDown;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;self-&amp;gt;numberOfFixtuers; i++&lt;span&gt;) {
        cs.name    &lt;/span&gt;= self-&amp;gt;&lt;span&gt;fixtuers[i].name;
        cs.runTest    &lt;/span&gt;= self-&amp;gt;&lt;span&gt;fixtuers[i].test;
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;run test&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Test_run(&lt;/span&gt;&amp;amp;&lt;span&gt;cs,result);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;221&quot;&gt;更具isa-&amp;gt;run(s,r)，可以知道，s就是TestCaller 类型的CounterTest变量，只不过在函数调用时候被截取了第一个元素，转换成了（TestImplement *）类型。&lt;br/&gt;r就是static TestResult result_，用来记录测试结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; __TestResult {
    unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt;&lt;span&gt; runCount;
    unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt;&lt;span&gt; failureCount;
    TestListner&lt;/span&gt;*&lt;span&gt; listener;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;230&quot;&gt;到目前为止，所有的测试都从Test_run(test, &amp;amp;result_)跳转到测执行函数。&lt;/p&gt;
&lt;p data-source-line=&quot;232&quot;&gt;3）函数的执行&lt;br/&gt;在TestCaller_run中，Test_run负责执行具体的函数体。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;self-&amp;gt;numberOfFixtuers; i++&lt;span&gt;) {
        cs.name    &lt;/span&gt;= self-&amp;gt;&lt;span&gt;fixtuers[i].name;
        cs.runTest    &lt;/span&gt;= self-&amp;gt;&lt;span&gt;fixtuers[i].test;
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;run test&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Test_run(&lt;/span&gt;&amp;amp;&lt;span&gt;cs,result);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;242&quot;&gt;cs.runTest = self-&amp;gt;fixtuers[i].test负责找到具体的case，Test_run负责执行测试，将其展开。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; Test_run(s,r)            ((Test*)s)-&amp;gt;isa-&amp;gt;run(s,r)
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;246&quot;&gt;此处的s是指测试case cs，源于TestCase cs = new_TestCase(0,0,0,0)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; __TestCase    TestCase;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; __TestCase*    TestCaseRef;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;compatible embUnit1.0&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; __TestCase {
    TestImplement&lt;/span&gt;*&lt;span&gt; isa;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;name;
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;(*setUp)(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;(*tearDown)(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;(*runTest)(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;260&quot;&gt;而此处的((Test*)s)-&amp;gt;isa-&amp;gt;run(s,r)，其中run函数指向谁呢？玄机在TestCase cs = new_TestCase(0,0,0,0); new_TestCase 的第一个元素就是TestCaseImplement。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; __TestCase {
    TestImplement&lt;/span&gt;*&lt;span&gt; isa;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;name;
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;(*setUp)(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;(*tearDown)(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;(*runTest)(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
};

&lt;/span&gt;&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;const&lt;/span&gt;&lt;span&gt; TestImplement TestCaseImplement;

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; new_TestCase(name,setUp,tearDown,runTest)\&lt;span&gt;
    {\
        (TestImplement&lt;/span&gt;*)&amp;amp;&lt;span&gt;TestCaseImplement,\
        name,\
        setUp,\
        tearDown,\
        runTest,\
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;281&quot;&gt;这个原型为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; __TestImplement {
    TestNameFunction name;
    TestRunFunction run;
    TestCountTestCasesFunction countTestCases;
};

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; TestImplement TestCaseImplement =&lt;span&gt; {
    (TestNameFunction)            TestCase_name,
    (TestRunFunction)            TestCase_run,
    (TestCountTestCasesFunction)TestCase_countTestCases,
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;295&quot;&gt;测试函数执行，就是TestRunFunction run所指的TestCase_run函数。前面已经由cs.runTest = self-&amp;gt;fixtuers[i].test这一句找到函数的应用，然后self-&amp;gt;runTest()就是执行该测试函数。&lt;/p&gt;
&lt;p data-source-line=&quot;295&quot;&gt;由于不依靠任何c标准库，所以没有longjmp这样的长跳转，那么测试出错如何进行返回呢？诀窍就在addFailure函数的时机、以及下面几个PUSH和POP上，共同完成局部变量和全局的result之间的信息传递。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; TestCase_run(TestCase* self,TestResult*&lt;span&gt; result)
{
    TestResult_startTest(result, (Test&lt;/span&gt;*&lt;span&gt;)self);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (self-&amp;gt;&lt;span&gt;setUp) {
        self&lt;/span&gt;-&amp;gt;&lt;span&gt;setUp();
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (self-&amp;gt;&lt;span&gt;runTest) {
        TestResult&lt;/span&gt;* wr =result_;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;push&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        TestCase&lt;/span&gt;* ws = self_;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;push&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        result_ &lt;/span&gt;=&lt;span&gt; result;
        self_ &lt;/span&gt;=&lt;span&gt; self;
        self&lt;/span&gt;-&amp;gt;&lt;span&gt;runTest();
        result_ &lt;/span&gt;= wr;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;pop&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        self_ &lt;/span&gt;= ws;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;pop&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (self-&amp;gt;&lt;span&gt;tearDown) {
        self&lt;/span&gt;-&amp;gt;&lt;span&gt;tearDown();
    }
    TestResult_endTest(result, (Test&lt;/span&gt;*&lt;span&gt;)self);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面演示了一个EmbedUnit的测试工程，包含三个方面：&lt;br/&gt;1. 写测试例子&lt;br/&gt;比如static void testInit(void)。&lt;br/&gt;2. 构成测试组&lt;br/&gt;比如TestRef CounterTest_tests(void)。返回(TestRef)&amp;amp;CounterTest变量。&lt;br/&gt;3. 调用框架执行全部测试&lt;br/&gt;main函数里面流程的就是测试框架的执行流程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
TestRef CounterTest_tests(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
TestRef PersonTest_tests(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main (&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    TestRunner_start();
        TestRunner_runTest(CounterTest_tests());
        TestRunner_runTest(PersonTest_tests());
    TestRunner_end();
    getchar();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

TestRef CounterTest_tests(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    EMB_UNIT_TESTFIXTURES(fixtures) {
        new_TestFixture(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testInit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,testInit),
        new_TestFixture(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testSetValue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,testSetValue),
    };
    EMB_UNIT_TESTCALLER(CounterTest,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CounterTest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,setUp,tearDown,fixtures);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (TestRef)&amp;amp;&lt;span&gt;CounterTest;
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testInit(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    TEST_ASSERT_EQUAL_INT(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, Counter_value(counterRef));
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testSetValue(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    Counter_setValue(counterRef,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    TEST_ASSERT_EQUAL_INT(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, Counter_value(counterRef));

    Counter_setValue(counterRef,&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    TEST_ASSERT_EQUAL_INT(&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, Counter_value(counterRef));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 24 Jun 2018 14:21:00 +0000</pubDate>
<dc:creator>啊哈彭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pingwen/p/9222024.html</dc:identifier>
</item>
<item>
<title>docker--从仓库下载镜像到推送自己的项目到仓库步骤详解 - 姚红</title>
<link>http://www.cnblogs.com/yaohong/p/9221800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaohong/p/9221800.html</guid>
<description>&lt;p&gt;       怎样从仓库下载的镜像，变成容器，并在容器中制作项目，再将容器变成镜像，然后将镜像推送到仓库？&lt;/p&gt;
&lt;h2&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1024482/201806/1024482-20180624221706973-605720972.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;

&lt;h2&gt;一：从官网下载镜像&lt;/h2&gt;
&lt;p&gt;       官方的&lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot;&gt;https://hub.docker.com/&lt;/a&gt;提供了数十万个镜像提供大家下载&lt;/p&gt;
&lt;p&gt;       以拉取个人公有centos7.3镜像为例：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024482/201806/1024482-20180624165152043-980323546.png&quot; alt=&quot;&quot; width=&quot;677&quot; height=&quot;203&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　拉取方式为&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# docker pull 用户/仓库：标签&lt;br/&gt;》docker pull kennyyaohong/public:centos7.3
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 二：进行项目&lt;/h2&gt;
&lt;h3&gt;1.启动容器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# -it 以交互模式启动一个容器
#--name  命名容器
#-d  后台运行容器，并返回容器ID
#docker run  -it  --name    定义容器名        -d 镜像名：标签      
》docker run -it  --name container_centos7.3 -d kennyyaohong/public:centos7.3 
&lt;/pre&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
》docker ps
&lt;/pre&gt;
&lt;p&gt;CONTAINER ID           IMAGE                                        NAMES                      COMMAND     CREATED           STATUS           PORTS     &lt;br/&gt;4bd480b4ac28    kennyyaohong/public:centos7.3    container_centos7.3          &quot;/bin/bash&quot;  4 seconds ago     Up 3 seconds &lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;2.进入容器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#exec ：在运行的容器中执行命令
#-d :分离模式: 在后台运行
#-i :即使没有附加也保持STDIN 打开
#-t :分配一个伪终端&lt;br/&gt;》docker exec -ti container_centos7.3 /bin/bash
[root@d3dfc0a17d1a /]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.进行项目&lt;/h3&gt;
&lt;p&gt;进入docker进行要开展的项目&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@4bd480b4ac28 /]# mkdir project
[root@4bd480b4ac28 /]# cd project/
[root@4bd480b4ac28 project]# ls
[root@4bd480b4ac28 project]# vi test.sh
[root@4bd480b4ac28 project]# sh test.sh 
hello
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三：将容器变成镜像&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;

&lt;p&gt;&lt;strong&gt;#-a :&lt;/strong&gt;提交的镜像作者；&lt;/p&gt;
&lt;p&gt;#&lt;strong&gt;-c :&lt;/strong&gt;使用Dockerfile指令来创建镜像；&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;#-m :&lt;/strong&gt;提交时的说明文字；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#-p :&lt;/strong&gt;在commit时，将容器暂停。&lt;/p&gt;
&lt;p&gt;#     docker    commit    -m  “提交说明文字”    -a        “作者”                        要提交的容器名                 提交后的镜像名：提交后的镜像tag名         &lt;/p&gt;

&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
》docker commit -m &quot;my_project&quot; -a &quot;kennyyaohong&quot; container_centos7.3  myproject_centos7.3:centos7.3
sha256:e12a9ec48ab76d4114e4d80293eb994bafb5d49e974143766d08ab9f74a2d193
&lt;br/&gt;#容器变为镜像后的&lt;br/&gt;host-172-17-17-115:~ # docker images;
REPOSITORY                               TAG                 IMAGE ID            CREATED             SIZE
myproject_centos7.3                      centos7.3           e12a9ec48ab7        2 seconds ago       258MB
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;四：将镜像推入仓库&lt;/h2&gt;
&lt;p&gt;　1.重新定义标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#docker  tag  镜像id       要推入仓库的用户名/要推入的仓库名:新定义的tag 
》docker tag e12a9ec48ab7 kennyyaohong/public:myproject_centos7.3
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#docker push      要推入仓库的用户名/要推入的仓库名:镜像标签
&lt;/pre&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
》docker push kennyyaohong/public:myproject_centos7.3
The push refers to a repository [docker.io/kennyyaohong/public]
193b0484e158: Layer already exists 
34e7b85d83e4: Layer already exists 
myproject_centos7.3: digest: sha256:5ffa998f3fc91e965d3b2e65ceefbc30a0bce49359058fba39e9386206a84bdc size: 948
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024482/201806/1024482-20180624191658280-2041145310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



</description>
<pubDate>Sun, 24 Jun 2018 14:21:00 +0000</pubDate>
<dc:creator>姚红</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaohong/p/9221800.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：并行接口NAND互操作性标准(JEDEC-JESD230) - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/9221808.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/9221808.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是&lt;strong&gt;JESD230标准&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　众所周知，最早也最流行的Raw NAND接口标准是ONFI标准，痞子衡在 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/9152535.html&quot;&gt;并行接口NAND标准(ONFI)及SLC Raw NAND简介&lt;/a&gt; 里详细介绍过ONFI 1.0，很多知名NAND大厂都是ONFI标准的制定者，但发展到高速DDR NAND的时候出现了一个与ONFI分庭抗礼的标准Toggle DDR，这个Toggle DDR标准是由Samsung和Toshiba两家共同推出的，这两家NAND的产能占据全球70%，所以Toggle DDR标准不容忽视。眼看着这两大NAND标准要打起来，微电子行业的标准权威JEDEC组织出来打圆场了，JEDEC也制定了一套Raw NAND标准，即本文的主角JESD230标准，该标准的目的主要是为了融合ONFI和Toggle两大标准。痞子衡今天就为大家介绍一下JESD230标准。&lt;/p&gt;
&lt;h3 id=&quot;一jesd230标准由来&quot;&gt;一、JESD230标准由来&lt;/h3&gt;
&lt;p&gt;　　在讲JESD230标准之前有必要先简要介绍一下ONFI以及Toggle DDR标准，ONFI组织成立于2006年，该组织于2006年12月发布了ONFI 1.0标准（仅针对50MB/s低速异步模式NAND），ONFI标准从此便成为了Raw NAND事实上的标准，ONFI标准一直指导着Raw NAND接口技术的发展，到了2012年9月，ONFI标准已经发展到了3.1（可支持400MB/s（NV-DDR2）高速同步模式NAND）。再说到Samsung和Toshiba联盟，这两家在2007年签署了NAND技术互换授权协议，并于2010年6月正式推出Toggle DDR 1.0接口标准的NAND产品，在这样的背景下JEDEC组织站出来与ONFI组织合作并于2012年10月推出JESD230标准第一个版本，从此JESD230标准便与ONFI、Toggle DDR标准同步发展，其对应关系可见下表：&lt;/p&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;时间&lt;/th&gt;
&lt;th&gt;JEDEC标准&lt;/th&gt;
&lt;th&gt;对应ONFI标准&lt;/th&gt;
&lt;th&gt;对应Toggle DDR标准&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2012.10&lt;/td&gt;
&lt;td&gt;JESD230&lt;/td&gt;
&lt;td&gt;ONFI 3.1&lt;/td&gt;
&lt;td&gt;Toggle DDR 2.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2013.08&lt;/td&gt;
&lt;td&gt;JESD230A&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;ONFI 3.2&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2014.07&lt;/td&gt;
&lt;td&gt;JESD230B&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2016.11&lt;/td&gt;
&lt;td&gt;JESD230C&lt;/td&gt;
&lt;td&gt;ONFI 4.0&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　现在说回JESD230标准，其全名是NAND Flash Interface Interoperability，从全称可见JESD230是NAND接口的一种补充协议，我们再来看一下JESD230官方Scope：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;This document defines a standard NAND flash device interface interoperability standard that provides means for a system to be designed that can support Asynchronous SDR, Synchronous DDR and Toggle DDR NAND flash devices that are interoperable between JEDEC and ONFI member implementations. This standard was jointly developed by JEDEC and the Open NAND Flash Interface Workgroup (ONFI).&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　从Scope可以看出，JESD230主要是对Asynchronous SDR, Synchronous DDR and Toggle DDR NAND设备互操作性方面进行了规范。&lt;/p&gt;
&lt;h3 id=&quot;二jesd230标准概要&quot;&gt;二、JESD230标准概要&lt;/h3&gt;
&lt;p&gt;　　让我们从分析JESD230与ONFI区别的角度来概要了解JESD230，就以最新的JESD230C与ONFI 4.0对比着来分析吧，ONFI 4.0手册共315页，而JESD230C仅有60页，可见JESD230标准补充的内容相比ONFI原规范内容是少很多的。下面我们仅从软件驱动设计的角度（命令集、参数表）来看两者区别：&lt;br/&gt;　　首先从命令集角度来看两者区别，下图是JESD230C与ONFI 4.0命令集对比，根据对比我们可以发现，两者命令基本是兼容的，只是JESD230多了Toggle Mode下的一些Multi-plane相关命令的第二种实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://odox9r8vg.bkt.clouddn.com/image/cnblogs/jesd230_cmd_vs_onfi.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再从参数表角度来看两者区别，下图是JESD230C与ONFI 4.0参数表对比（仅截取部分），ONFI参数表是256bytes，而JESD230参数表是512bytes，关于具体byte定义两者有很多相似之处，其中对于AC特性尤其是速度等级定义，两者是一致，这是互操作性的保证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://odox9r8vg.bkt.clouddn.com/image/cnblogs/jesd230_para_table_vs_onfi.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至此，JESD230标准痞子衡便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;[1]. &lt;a href=&quot;http://www.expreview.com/17963.html&quot;&gt;关于SSD的二三事，NAND闪存的一些常识&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Jun 2018 13:26:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/henjay724/p/9221808.html</dc:identifier>
</item>
</channel>
</rss>