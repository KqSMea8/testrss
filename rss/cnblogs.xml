<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>iOS学习——iOS原生实现二维码扫描 - mukekeheart</title>
<link>http://www.cnblogs.com/mukekeheart/p/8556600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mukekeheart/p/8556600.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　最近项目上需要开发扫描二维码进行签到的功能，主要用于开会签到的场景，所以为了避免作弊，我们再开发时只采用直接扫描的方式，并且要屏蔽从相册读取图片，此外还在二维码扫描成功签到时后台会自动上传用户的当前地点，如何自动定位获取用户的当前地点在上一篇随笔&lt;span&gt;&lt;strong&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/mukekeheart/p/8549322.html&quot;&gt;&lt;span&gt;iOS学习——自动定位&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;中已经讲过了，本文就简单地说一下如何利用iOS原生的模块实现二维码的扫描。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　二维码扫描是很多应用都会实现的功能，比较著名的第三方开源库是Google出品的&lt;a href=&quot;https://link.jianshu.com/?t=https://github.com/zxing/zxing&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ZXing&lt;/a&gt;，其的OC的移植版本是&lt;a href=&quot;https://link.jianshu.com/?t=https://github.com/TheLevelUp/ZXingObjC&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ZXingObjc&lt;/a&gt;。iOS系统原生的二维码扫描模块是在iOS7之后推出的，它主要是利用iOS设备的后置摄像头进行实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;要调用系统的摄像头识别二维码，我们需要导入系统的AVFoundation库。使用系统的摄像头，我们一般的需要以下五个对象：一个后置摄像头设备（AVCaptureDevice）、一个输入（AVCaptureDeviceInput）、一个输出（AVCaptureMetadataOutput）、一个协调控制器（AVCaptureSession）、一个预览层（AVCaptureVideoPreviewLayer），此外为了更好的体验效果，我们加入了缩放手势，在进行二维码扫描的时候可以手动进行缩放扫描区域，以获得更好的扫描效果。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@interface&lt;/span&gt; CJScanQRCodeViewController () &amp;lt;AVCaptureMetadataOutputObjectsDelegate&amp;gt;&lt;span&gt;

@property (strong, nonatomic) AVCaptureDevice &lt;/span&gt;* device; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;捕获设备，默认后置摄像头&lt;/span&gt;
@property (strong, nonatomic) AVCaptureDeviceInput * input; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入设备&lt;/span&gt;
@property (strong, nonatomic) AVCaptureMetadataOutput * output;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出设备，需要指定他的输出类型及扫描范围&lt;/span&gt;
@property (strong, nonatomic) AVCaptureSession * session; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AVFoundation框架捕获类的中心枢纽，协调输入输出设备以获得数据&lt;/span&gt;
@property (strong, nonatomic) AVCaptureVideoPreviewLayer * previewLayer;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;展示捕获图像的图层，是CALayer的子类&lt;/span&gt;
&lt;span&gt;
@property (strong, nonatomic) UIPinchGestureRecognizer &lt;/span&gt;*pinchGes;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缩放手势&lt;/span&gt;
@property (assign, nonatomic) CGFloat scanRegion_W;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二维码正方形扫描区域的宽度，根据不同机型适配&lt;/span&gt;

&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　首先，我们是需要进行对我们的一些设备进行配置，比喻需要用到自动定位，就需要对定位信息进行配置，接着对二维码扫描的相关设备进行配置，然后对我们的缩放手势进行设置，都配置完之后，直接开始启动二维码扫描就可以了，成功扫码并识别到信息时候会调用对应的 &lt;span class=&quot;cnblogs_code&quot;&gt;AVCaptureMetadataOutputObjectsDelegate&lt;/span&gt; 代理的 &lt;span class=&quot;cnblogs_code&quot;&gt;- (&lt;span&gt;void&lt;/span&gt;)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection&lt;/span&gt; 方法进行后期处理，我们需要实现代理的该方法，在其中编写我们需要的功能逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewDidLoad {
    [super viewDidLoad];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页面标题&lt;/span&gt;
    self.title = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;扫一扫&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置定位信息&lt;/span&gt;
&lt;span&gt;    [self configLocation];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置二维码扫描&lt;/span&gt;
&lt;span&gt;    [self configBasicDevice];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置缩放手势&lt;/span&gt;
&lt;span&gt;    [self configPinchGes];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始启动&lt;/span&gt;
&lt;span&gt;    [self.session startRunning];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　关于二维码扫描设备的配置流程，一般地，我们先将需要的五大设备进行初始化，然后需要进行对应的设置没具体的设置流程和方法见下面的代码和注释。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)configBasicDevice{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认使用后置摄像头进行扫描,使用AVMediaTypeVideo表示视频&lt;/span&gt;
    self.device =&lt;span&gt; [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备输入 初始化&lt;/span&gt;
    self.input =&lt;span&gt; [[AVCaptureDeviceInput alloc]initWithDevice:self.device error:nil];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备输出 初始化，并设置代理和回调，当设备扫描到数据时通过该代理输出队列，一般输出队列都设置为主队列，也是设置了回调方法执行所在的队列环境&lt;/span&gt;
    self.output =&lt;span&gt; [[AVCaptureMetadataOutput alloc]init];
    [self.output setMetadataObjectsDelegate:self queue:dispatch_get_main_queue()];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;会话 初始化，通过 会话 连接设备的 输入 输出，并设置采样质量为 高&lt;/span&gt;
    self.session =&lt;span&gt; [[AVCaptureSession alloc]init];
    [self.session setSessionPreset:AVCaptureSessionPresetHigh];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;会话添加设备的 输入 输出，建立连接&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ([self.session canAddInput:self.input]) {
        [self.session addInput:self.input];
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ([self.session canAddOutput:self.output]) {
        [self.session addOutput:self.output];
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定设备的识别类型 这里只指定二维码识别这一种类型 AVMetadataObjectTypeQRCode
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定识别类型这一步一定要在输出添加到会话之后，否则设备的课识别类型会为空，程序会出现崩溃&lt;/span&gt;
&lt;span&gt;    [self.output setMetadataObjectTypes:@[AVMetadataObjectTypeQRCode]];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置扫描信息的识别区域，本文设置正中央的一块正方形区域，该区域宽度是scanRegion_W
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里考虑了导航栏的高度，所以计算有点麻烦，识别区域越小识别效率越高，所以不设置整个屏幕&lt;/span&gt;
    CGFloat navH =&lt;span&gt; self.navigationController.navigationBar.bounds.size.height;
    CGFloat viewH &lt;/span&gt;= ZYAppHeight -&lt;span&gt; navH;
    CGFloat scanViewH &lt;/span&gt;=&lt;span&gt; self.scanRegion_W;
    [self.output setRectOfInterest:CGRectMake((ZYAppWidth&lt;/span&gt;-scanViewH)/(&lt;span&gt;2&lt;/span&gt;*ZYAppWidth), (viewH-scanViewH)/(&lt;span&gt;2&lt;/span&gt;*viewH), scanViewH/ZYAppWidth, scanViewH/&lt;span&gt;viewH)];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;预览层 初始化，self.session负责驱动input进行信息的采集，layer负责把图像渲染显示
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;预览层的区域设置为整个屏幕，这样可以方便我们进行移动二维码到扫描区域,在上面我们已经对我们的扫描区域进行了相应的设置&lt;/span&gt;
    self.previewLayer =&lt;span&gt; [[AVCaptureVideoPreviewLayer alloc]initWithSession:self.session];
    self.previewLayer.frame &lt;/span&gt;= CGRectMake(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, ZYAppWidth, ZYAppHeight);
    self.previewLayer.videoGravity &lt;/span&gt;=&lt;span&gt; AVLayerVideoGravityResizeAspectFill;
    [self.view.layer addSublayer:self.previewLayer];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扫描框 和扫描线的布局和设置，模拟正在扫描的过程，这一块加不加不影响我们的效果，只是起一个直观的作用&lt;/span&gt;
    TNWCameraScanView *clearView =&lt;span&gt; [[TNWCameraScanView alloc]initWithFrame:self.view.frame navH:navH];
    [self.view addSubview:clearView];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扫描框下面的信息label布局&lt;/span&gt;
    UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(&lt;span&gt;0&lt;/span&gt;, (viewH+scanViewH)/&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;10.0f&lt;/span&gt;, ZYAppWidth, &lt;span&gt;20.0f&lt;/span&gt;&lt;span&gt;)];
    label.text &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;扫一扫功能仅用于会议签到&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    label.font &lt;/span&gt;= FONT(&lt;span&gt;15.0f&lt;/span&gt;&lt;span&gt;);
    label.textColor &lt;/span&gt;=&lt;span&gt; [UIColor whiteColor];
    label.textAlignment &lt;/span&gt;=&lt;span&gt; NSTextAlignmentCenter;
    [self.view addSubview:label];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　接下来我们看一下如何配置我们的缩放手势，这个相对而言就很简单了，我们直接在self.view上添加一个缩放手势，并在对应的方法中对我们的相机设备的焦距进行修改就达到了缩放的目的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)configPinchGes{
    self.pinchGes &lt;/span&gt;=&lt;span&gt; [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(pinchDetected:)];
    [self.view addGestureRecognizer:self.pinchGes];
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)pinchDetected:(UIPinchGestureRecognizer*&lt;span&gt;)recogniser{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_device){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对手势的状态进行判断&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (recogniser.state ==&lt;span&gt; UIGestureRecognizerStateBegan){
        _initScale &lt;/span&gt;=&lt;span&gt; _device.videoZoomFactor;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相机设备在改变某些参数前必须先锁定，直到改变结束才能解锁&lt;/span&gt;
    NSError *error =&lt;span&gt; nil;
    [_device lockForConfiguration:&lt;/span&gt;&amp;amp;error]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;锁定相机设备&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;error) {
        CGFloat zoomFactor; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缩放因子&lt;/span&gt;
        CGFloat scale =&lt;span&gt; recogniser.scale;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (scale &amp;lt; &lt;span&gt;1.0f&lt;/span&gt;&lt;span&gt;) {
            zoomFactor &lt;/span&gt;= self.initScale - pow(self.device.activeFormat.videoMaxZoomFactor, &lt;span&gt;1.0f&lt;/span&gt; -&lt;span&gt; recogniser.scale);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            zoomFactor &lt;/span&gt;= self.initScale + pow(self.device.activeFormat.videoMaxZoomFactor, (recogniser.scale - &lt;span&gt;1.0f&lt;/span&gt;) / &lt;span&gt;2.0f&lt;/span&gt;&lt;span&gt;);
        }
        zoomFactor &lt;/span&gt;= MIN(&lt;span&gt;15.0f&lt;/span&gt;&lt;span&gt;, zoomFactor);
        zoomFactor &lt;/span&gt;= MAX(&lt;span&gt;1.0f&lt;/span&gt;&lt;span&gt;, zoomFactor);
        _device.videoZoomFactor &lt;/span&gt;=&lt;span&gt; zoomFactor;
        [_device unlockForConfiguration];
    }
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;最后，我们需要重写代理的回调方法，实现我们在成功识别二维码之后要实现的功能逻辑。这样我们的二维码扫描功能就完成了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#pragma&lt;/span&gt; mark - AVCaptureMetadataOutputObjectsDelegate
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后置摄像头扫描到二维码的信息&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *&lt;span&gt;)connection{
    [self.session stopRunning];   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;停止扫描&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ([metadataObjects count] &amp;gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组中包含的都是AVMetadataMachineReadableCodeObject 类型的对象，该对象中包含解码后的数据&lt;/span&gt;
        AVMetadataMachineReadableCodeObject *qrObject =&lt;span&gt; [metadataObjects lastObject];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到扫描内容在这里进行个性化处理&lt;/span&gt;
        NSString *result =&lt;span&gt; qrObject.stringValue;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析数据进行处理并实现相应的逻辑
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代码省略&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 13 Mar 2018 06:33:00 +0000</pubDate>
<dc:creator>mukekeheart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mukekeheart/p/8556600.html</dc:identifier>
</item>
<item>
<title>面试那点事儿 - 麦机长</title>
<link>http://www.cnblogs.com/Autumoon/p/8556284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Autumoon/p/8556284.html</guid>
<description>&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// Description: 原作于2016年9月24日。&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 面试就像月经，很烦，但总要经历；&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 面试就像月经，麻烦一阵，轻松一阵，过一阵又来；&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 面试就像月经，月经来了就放心了，面试过了就消停了。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1462017-bc308506befebdfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;你先别问我什么问题，先说说你打算给我多少钱？&quot;/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;你先别问我什么问题，先说说你打算给我多少钱？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近很想聊聊面试，因为我经历过很多面试，也面过许多人，这里面有愉快的、有不愉快的、有越聊越明白的、有越面越迷茫的……工作10年了，人和事也算经历过不少，鄙人差不多也有资格掰扯掰扯IT圈面试那些破事儿了。&lt;/p&gt;
&lt;p&gt;面试最重要的是什么？心态！（废话，干什么都是心态最重要。）大学快毕业那会儿吧，最迷茫。回头看学校，自诩为算是学得比较明白的；向前看企业，又感觉自己啥也不会。那时候投简历的心情就像自己是块案板上的猪肉，任人指指点点，感兴趣的面无表情问一句“这坨怎么卖？”，不感兴趣的看都懒得看你一眼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1462017-e1aec53769f5f3f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;你以为你是Gilfoyle的时候，往往别人眼里你顶多算个巴基斯坦丹泽尔。&quot;/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;你以为你是Gilfoyle的时候，往往别人眼里你顶多算个巴基斯坦丹泽尔。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我记得那个阶段我最有趣的经历就是去招聘会，看花了眼也不知道自己该投哪儿，就和哥们儿一圈一圈地转着，路过一个展位，听到面试官问一个女生“你能介绍一下Linux吗？”那个女生支支吾吾地说了几句大概“Linux没有我们常用的图形界面、操作都是靠命令……”之类东拼西凑的道听途说，面试官显然不为姿色所动。我寻思虽然没打算去做Linux相关的工作（那时候感觉搞开源跟要饭的没啥区别，微软地上铺的都是24K金砖），但是仗着我实际玩过一阵儿，去瞎白活几句怎么也比她强。别说还真把面试官俩眼珠子给聊亮了，让我去公司复试，可惜复试完才知道是家培训机构，还不是让我去做老师，而是要我交钱当学生。我记得当时好像要交两万多，培训八个月，帮推荐但不保证就业。没去，丢不起那人也交不起那钱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1462017-f6c2841ae729ca2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;流汗和着火是真的，其它都是童话。&quot;/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;流汗和着火是真的，其它都是童话。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后来在一家很小的创业公司干了11天，感觉就像过了一年，然后集体被裁了。996算什么，当年我们玩儿的可是每天10点上班，夜里2点半跟美国交接完工作才下班，一周工作六天。具体做了些什么记不清了，印象最深刻的就是每天下午看到窗外渐红的夕阳，心里默默地告诉自己：“今天时间过了一半了！”被裁之后我睡了个懒觉，起来写了篇心得，然后又过上了不知何去何从的混沌日子。结果这篇心得被北京一家公司的部门经理看到，留言问我愿不愿意去她们公司看看，我也没报啥希望，就问来回火车票给报不，她说给报，我就来了。我这人吧，太实诚，你说给一家素不相识的公司省什么钱呀，当时就觉得不能仗着东家给报路费就可劲儿造，扛一宿硬座也没事儿，还能看看书多准备准备。结果书倒是带了几本，一路上尽跟那帮睡不着觉的夜猫子唠闲嗑了。第二天早上6点半我就到了公司楼下的肯德基，假模假式把书拿出来，喝了点儿可乐眯了会儿。那天好像是星期天，本来不上班，CEO和CTO可能被我的千里投奔所感动，一大早专门跑到公司来面我。差不过面了一上午，感觉后背都微微冒汗了，很多问题自己感觉答得并不理想，结果人走了狗屎运拦都拦不住，免试用直接转正，工资是低了点儿，反正我拿他当跳板，他剥削我积累原始资金，各取所需。再说，好歹我毕业直接来了帝都，来了再说呗。&lt;/p&gt;
&lt;p&gt;那次之所以能成，我后来想想，很可能是因为本来就抱着旅游的心态来面的，既不高傲也不卑畏，知无不言，言无不实。我没有问过为什么要我，不过说真的我也很喜欢面试的时候应聘者是这样的表现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1462017-188982a295a40bfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;群众的眼睛是雪亮的，你正不正常一看就知道。&quot;/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;群众的眼睛是雪亮的，你正不正常一看就知道。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实不管面试官还是应聘者，都最好不要表现得自惭形秽或者不可一世，任何一种偏离不卑不亢的表现都会让对方感觉很不舒服，毕竟面试是刚刚建立认知和互信的开始，陌生人之间的包容度显然比不得朋友之间，人家不欠你一个饭碗，反过来讲，你也不缺他那碗饭。比如我曾经面过一个某985的研究生，简历写得感觉他来了我就没饭吃了。不知道是心虚还是高傲，在我对他技术能力作出判断之前就发现他总在有意无意地提他的导师，不止一两次地说他导师是微软MVP，业界多么牛之类的。他技术偏硬件，本来我是抱着不懂就问的态度来面他的，结果被他这么说反而不爽了，导师牛跟你有多大关系，更何况国内理工科研究生教育怎么回事大家没吃过猪肉还没见过猪跑？（我还见过某211学了7年计算机，写不清楚逻辑判断的，不过人家态度好，我还是招来实习了，这是后话。）其实我一般不轻易出手，但是看他没有见好就收的意思，逮着个机会就问他导师叫啥，他说了个名儿我不认识，又问哪一年的MVP，他说10年的，我说：“哦，我08年的，前面的认识一些，后面的就不care了。”然后就再没听到他提过导师。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1462017-dfa53bc69d23bcdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;有些人最擅长就是装，却始终饿不死，你说气不气人！&quot;/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;有些人最擅长就是装，却始终饿不死，你说气不气人！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;装可能是人类的一种天性，每个人都有表现欲，环境的诱发作用也很强，就像在外企开会一句话不带俩英文单词这会开得就不算圆满，总觉得纯汉语说着拗口，哪怕背后其实你是反感中英夹杂的。但是装要装得恰到好处，所以说学点儿表演没啥坏处。我之前还遇到过一个面我的CTO，聊那些没有标准答案的问题的时候，他总会在你的答案上强加一些没有营养的观点以展现出魔高一丈的气势，不过人家是主场，你也不好意思直接拍案而起。由他去吧，年纪轻轻混到CTO，过于谦卑恐怕比处处打压更难服众，将来眼睛干点儿、脖子硬点儿、肚子大点儿再洗白就是了。面试结果不理想，心中难免会产生不被认可的挫败感，但不要被这种情绪所左右。面试就像相亲，感觉很重要，酒逢知己千杯少，话不投机半句多。有的时候技术平台虽然一样，但你擅长的领域和这家公司的聚焦点不太契合，难免双方关注的问题域区别比较大，不代表你不够好；有的时候可能对方早上地铁挤得不爽，非要找个人出气，周围的不敢得罪，你就成了最合适的目标；哪怕遇到真是自己准备不充分被人挖到短处也没什么大不了，回去好好补补，从此相忘于江湖也就罢了。&lt;/p&gt;
&lt;p&gt;随着从业经历的增加，渐渐的，面试的时候就不会像刚走出校门那样任人摆弄，更多了几分从容，也从被挑选转变为双向考察。有些人会隔个两三年面几家公司，不为跳槽，就为了找个人来检验一下自己的缺失。刚有资格做面试官的时候，难免按耐不住小激动总想千方百计虐对方一番，几次之后自己心态自然也就平和了许多（肯定也有一条道虐到黑的），也会把面试当做是一次相互切磋、共同进步的机会，若能通过面试认识几位技术上的挚友，岂不快哉？&lt;/p&gt;
&lt;p&gt;我不喜欢问一些模棱两可的烧脑问题，比如西雅图一天的汽油消耗量或者井盖为什么是圆的，矫情！相比面过我的，我自认为我的手法还算有人性：一台能上网的笔记本，一款常用的IDE，一道编程题，会议室里20分钟安静编程时间（应届生30分钟），然后从代码发散聊开。我不喜欢笔试题，大部分笔试题其实工作中根本用不上；更不喜欢用笔写代码，哪家公司还像几十年前那样排队等机时？当然，用笔写代码有用笔写代码的考察点，只是我更看重思维敏捷和工作效率。你可以说用笔写能看出一个人基本功是不是扎实，我想说咱都走出校门了还是把学究那一套还给学究吧，把记忆的部分交给编辑器的智能补全，让你的大脑多一些思考的空间吧，你还真以为牛人是拿记事本写代码呀！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1462017-d25e9e867c646d0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;是驴子是马，拉出来遛遛。&quot;/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;是驴子是马，拉出来遛遛。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提到牛人就忍不住顺便插一句我对牛人的定义，我见过为数不多真正能称为牛人的人都有一个共性，就是能迅速简化复杂的问题，有些方法和程度甚至让你叹为观止。那些拿记事本写hello world的，除非是条件所迫，否则只能叫奇技淫巧。说到这里也要禁不住劝刚出道的新人们别动不动就叫谁大神，可着这960万平方公里的国土面积就没几个真的大神，不信你掰着手指头好好去翻翻，现在流行的开发框架和插件，有几个出自龙的传人？处处主动抬高别人，把自己放在一个卑微的位置，且不说你是否真的了解他，最大的问题就是容易被动。以前“美女”是个令人神往的词，后来满大街的服装店都叫人美女帅哥的时候，就没啥意思了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1462017-dc4fae2b76915d37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;不光要写得出来，还要聊得清楚思路。&quot;/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;不光要写得出来，还要聊得清楚思路。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但就是这样——注意，是一台能上网的笔记本哦，我只能点到这儿了——还是有很多人半个小时才刚写了个函数声明。当然，我不会在这个时候就直接送客，毕竟我卡壳的时候也希望对方多一些宽容和理解。那就来聊聊思路吧，白板上写点儿伪代码也是可以的。从这里我发现一个现象：社招的工作头衔越大越傲，校招的学校名气越大越狂。狂傲跟实力无关，与内心相连——甭管行不行，爷就这态度。我记得曾经有个比较资深的开发来面，我接的驾，老朽眼拙没看清他研究生是工作几年后再读的，就问工作经历中间空了两年是在做什么，他说：“不写了吗，读研究生去了。”对不起，纵然您是颗蒸不烂、煮不熟、锤不扁、炒不爆，响当当的铜豌豆，老子也能让你比窦娥还冤！尽管他问啥都知道，有什么用，必须挂。要说我嫉贤妒能未免太狭隘了，从组织的角度来说把这种不合群的狂人招进来，我等众土鳖就草也吃不香、奶也挤不出，你还能指望活儿都他全干了？所以面试就这样，就算是牛神下凡，要不要也不是被面的说了算。世上本没有公平，喊“人人平等”的多了，还是不公平。&lt;/p&gt;
&lt;p&gt;也不绝对，我曾经面过一位，技术娴熟、思维敏捷、态度谦和，很可惜碰巧名额被紧急冻结，他等不了就去了微软，不然跟高手一起共事，想必我还能跟着长进不少。前面我提到过一个学了7年计算机，写不明白逻辑判断的研究生来实习，不为别的，就为她态度好，不会就是不会，跟导师没啥关系。我寻思她是那一拨面的七八个里面态度最好，最谦虚肯学的，如果能带上道，我不也有成就感嘛。只可惜事与愿违，也不知后来她是否如愿进了国企，眨眼便是经年。&lt;/p&gt;
&lt;p&gt;可能我比较注意一些旁枝别叶的细节，比如当我发觉坐我对面的面试官或应聘者眼神是不停飘移的，我就感觉不舒服，有时候我也会把正视对方作为一种考查方式，看看对方是否自信、是否活跃。之前就遇到过，面试官水平在我之上，双方聊得也比较开心，可就是他说话的时候始终不敢正眼看人，按我的理解就是内心不够强大且杂念太多，我不愿将来在这样的主儿手底下干活，所以不管猎头怎么画饼，最后还是算了。程序员终日跟计算机打交道，你要不是张屏幕脸都显得不务正业，难免多数人交谈的时候含蓄腼腆而常常眼睛盯着别处，这样的人一起共事问题不大，毕竟人家斜着看但不会把代码歪着写，可如果是将来的领导，我劝你有条件的话还是尽量找个更强的人，挣快钱就算了，否则长远来看容易把你给耽误了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1462017-d2ba0221e7fec07e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;要问我该如何准备面试？好好睡一觉先！&quot;/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;要问我该如何准备面试？好好睡一觉先！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;罗里吧嗦扯了一大堆没用的，自己一觉醒来看着都像鸡肋，发出去怕砸了招牌，删了又感觉舍不得。写得不像鸡汤，也教不了诸位做人的道理，实在对不起大家。想来想去既然写了还是发吧，不敢说以飨读者，能以娱观众也算值了。&lt;/p&gt;
</description>
<pubDate>Tue, 13 Mar 2018 06:02:00 +0000</pubDate>
<dc:creator>麦机长</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Autumoon/p/8556284.html</dc:identifier>
</item>
<item>
<title>《Master Bitcoin》学习笔记02——比特币的交易模型 - 香哥</title>
<link>http://www.cnblogs.com/BrotherXiang/p/8556175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BrotherXiang/p/8556175.html</guid>
<description>&lt;h2&gt;模型基本描述&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　前面一篇&lt;a href=&quot;http://www.cnblogs.com/BrotherXiang/p/8546570.html&quot; target=&quot;_blank&quot;&gt;学习笔记01&lt;/a&gt;提到了一个交易模型（第三章的内容），在第五章中，除了对这个模型做个详细介绍之外，其实和我上一篇理解的交易模型差不多，一个交易包含输入与输出，比特币是在各个地址之间转移，不想中心化系统例如银行有个服务器，记录了每个人的账户，账户这个结构体包含：交易记录，账户余额等一切信息，但是在比特币交易网络这种去中心化的体系中，比特币的交易记录，一个账户拥有多少比特币等信息存储在了区块链中，要像银行账户一样，查询自己账户的相关信息，只能通过查区块链中的区块获取，就像从数据库里查询数据一样，就像下面比特币的交易模型描述。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345048/201803/1345048-20180313105015629-1726280351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　模型图有几个重点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;个人可用的比特币是以账单形式存在的，在发起交易时，查询区块链中个人可用账单（账单输出账户是你），使用账单来支付相应比特币，产生输出，实际上，是比特币在比特币地址之间的转移。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;本次交易的输入就是&lt;/strong&gt;&lt;strong&gt;上次交易&lt;/strong&gt;&lt;strong&gt;输出&lt;/strong&gt;，比特币账户（地址）查询余额和交易，就是对区块链里账单里对你账户输出的查询（上图中，对A可支配比特币的查询账单输出：退给A的金额，对B可支配比特币的查询账单输出：转账给B的金额）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;本次交易的输入可以只有一张账单的输出（如果这张账单上的比特币足够），也可以包含几张账单的输出（几张账单加起来比特币&amp;gt;=此次需要支付金额），注意到，上面的&amp;gt;=比交付，因为不太可能利用已有账单完全无误差地凑出本次需支付对应金额，因为账单里的输出金额是不可拆分的，只能利用账单来支付，要将银行里控制的个人账户余额（一串数字）与比特币个人账户余额（账户下的账单输出）区分开来。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;生成的账单三中有给矿工的奖励，这个奖励是你自定的，给不给，给多少都行，这个奖励影响的是交易的优先级，奖励越多，越能尽早地将账单加入区块链中，以保证交易的完成。账单将会被保存在矿工的矿池中，按照奖励优先级来处理账单。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;交易输出的锁定与解锁（重点）——锁定脚本与解锁脚本&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　上面提到了，一个账户可支配的比特币来源于账单的输出，而账单是公开的，每个比特币账户都能知道这笔交易以及交易的输出，那么怎么保证输出只有对应的比特币的账户能用呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　比特币的锁机制是通过一种&lt;strong&gt;类Forth语言脚本&lt;/strong&gt;来，该脚本语言是种非图灵完备的语言，什么是图灵完备的语言呢，当一门编程语言在不限制内存和不限制时间下，能够解决所有问题，就称为图灵完备的，例如：C/C++，JAVA都是图灵完备语言，反之就是图灵非完备，比特币脚本里没有循环，所以这个脚本不能解决：在满足某种条件下退出循环，否则无限制地循环的问题。&lt;strong&gt;比特币的脚本语言是一种简单、低级的语言&lt;/strong&gt;，它的很多功能已经被编译成立二进制文件，即使我们不了解这种语言，只要能够调用接口就行了，或者可以直接使用C/C++，JAVA这样的语言来完成锁定和解锁的功能。那么为什么不直接用C++等图灵完备的语言呢？这是出于安全考虑的，因为C++，JAVA等语言与内存、操作系统等运行环境，息息相关，而比特币脚本不需要任何运行环境都能运行，这就能抵抗基于内存的攻击或者其他透过系统漏洞的攻击（书上是这样解释的，我觉得，比特币脚本更像一串机器语言的0-1串，由于低级机器语言的限制，很难进行高级编程，同样的，也保证了安全性，因为0-1机器语言很难入侵更改）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　下面是锁定脚本与解锁脚本的例子，以说明锁的交互机制。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;假设这笔交易为A向B支付比特币&lt;/strong&gt;，在交易双方完成交易，生成账单时（非矿工加的解锁和锁定脚本），A向这个账单加上了锁定脚本，这个锁定脚本包含B的比特币地址C，因为B只公开了经过对公钥HASH后的比特币地址C，因为HASH函数的性质，比特币网络上的任何人，都不能通过C逆向得到B的公钥，也就是说，只有B知道自己的公钥能够构建解锁脚本，即只有B的公钥，才能通过HASH运算出地址C，只有能运算出地址C的比特币账户，才能支配这笔比特币。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;脚本语言运行&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　该脚本语言仅由常数以及操作构成，从前往后遍历脚本，若遇到常数，则将常数入栈，若遇到操作，根据操作的具体要求，对栈顶元素进行弹出，或者弹出两个元素进行运算，再入栈，当一句脚本运行完毕后，仅只剩下栈顶元素，其取值为True\False，很清楚地，True代表验证成功，代表执行脚本的用户具有该账单输出比特币的支配权，用户能够使用该账单作为下笔交易（账单）的输入，下面是个具体例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345048/201803/1345048-20180313130238725-624760526.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345048/201803/1345048-20180313130322372-1589557168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;锁定/解锁脚本类型&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1）P2PKH (Pay-to-Public-Key-Hash)——比特币网络上大多数交易都属于此类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;解锁脚本&lt;/span&gt;，&lt;span&gt;锁定脚本&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345048/201803/1345048-20180313131341159-1550189755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345048/201803/1345048-20180313131615466-1353086471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345048/201803/1345048-20180313131639444-1879340424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）P2PK（Pay-to-Public-Key）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　写成收款方的公钥，收款方通过自己的私钥生成相应公钥来获取支配权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345048/201803/1345048-20180313132032829-915506053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）P2SH（Pay-to-Script-Hash）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个脚本类型用于多重签名才能支付，比如，一个公司的账户，由5个人支配，但只要有2个人以上的签名就能进行比特币支付。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们考虑使用2）的方式来写多重签名命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345048/201803/1345048-20180313132504487-192295275.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　就是说，再使用上图方式多重签名的时候，需要将所有人的公钥都加在锁定脚本里，因为Attorney Public Key时是所有人的公钥运算的结果，而Public Key（公钥）有260bit长，这样下来，在人很多的情况下，甚至会使锁定脚本容量超过账单本身，而且这样的脚本也难以维护，并暴露所有人之间的联系（尽管比特币地址是匿名的）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　P2SH很好地解决了这个问题，P2SH分为除了锁定脚本、解锁脚本之外，多出了赎回脚本：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345048/201803/1345048-20180313133209195-239112529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用方法是分两步：①使用赎回脚本确认用户能在属于定义好的群组；②使用解锁脚本解锁（Sig1 Sig2是2个群组用户的签名）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345048/201803/1345048-20180313133346449-106121601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 13 Mar 2018 05:40:00 +0000</pubDate>
<dc:creator>香哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BrotherXiang/p/8556175.html</dc:identifier>
</item>
<item>
<title>.NET中的线程与异步（笔记） - KAnts</title>
<link>http://www.cnblogs.com/ants/p/8555692.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ants/p/8555692.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;翻出了之前记录的笔记，基本涵盖了.NET中线程和异步的相关概念。可以提供一个学习的方向。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;线程类型&lt;/h3&gt;
&lt;p&gt;工作者线程&lt;br/&gt;IO线程&lt;/p&gt;
&lt;h3&gt;线程池&lt;/h3&gt;
&lt;p&gt;全局队列（QueueUserWorkItem、Timer总是放入全局）&lt;br/&gt;本地队列&lt;/p&gt;
&lt;h4&gt;工作者线程调度流程&lt;/h4&gt;
&lt;p&gt;如果本地队列有任务，则调度本地队列&lt;br/&gt;如果本地队列没有任务则去其它工作者线程中调度&lt;br/&gt;如果所有工作者线程本地队列都没有任务则去全局队列取任务调度&lt;br/&gt;如果全局队列也没有任务则睡眠等待&lt;br/&gt;如果睡眠了太长时间则自己醒来销毁自己&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从全局队列取到本地队列采用 FIFO 算法&lt;br/&gt;从本地队列取出时，采用 LIFO 算法&lt;br/&gt;子任务、嵌套任务会被分配在线程的局部队列中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;线程的开销&lt;/h3&gt;
&lt;h4&gt;上下文切换&lt;/h4&gt;
&lt;h3&gt;数据&lt;/h3&gt;
&lt;p&gt;AsyncLocal&lt;br/&gt;ThreadLocal&lt;br/&gt;ExecutionContext&lt;br/&gt;SynchronizationContext（抽象的内容，基于ExecutionContext）&lt;/p&gt;
&lt;h4&gt;参考资料&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/pfxteam/2012/06/15/executioncontext-vs-synchronizationcontext/&quot;&gt;https://blogs.msdn.microsoft.com/pfxteam/2012/06/15/executioncontext-vs-synchronizationcontext/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/9562836/whats-the-meaning-of-usetaskfriendlysynchronizationcontext&quot;&gt;http://stackoverflow.com/questions/9562836/whats-the-meaning-of-usetaskfriendlysynchronizationcontext&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/gg598924.aspx&quot;&gt;https://msdn.microsoft.com/en-us/magazine/gg598924.aspx&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Timer&lt;/h3&gt;
&lt;p&gt;所有的Timer只有一个线程，调度具体任务时使用线程池&lt;br/&gt;避免重复执行，使用Change方法&lt;/p&gt;
&lt;h3&gt;伪共享&lt;/h3&gt;
&lt;p&gt;因为不同的内核访问一个内核的cache发生的问题 [StructLayout(LayoutKind.Explicit)] [FieldOffset(64)]&lt;/p&gt;
&lt;h3&gt;异步模型&lt;/h3&gt;
&lt;h4&gt;APM（异步编程模型）&lt;/h4&gt;
&lt;p&gt;BeginXXX、EndXXX&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HTTP(RFC 2616) 客户端应用程序到一个服务器的并发连接数不应超过2个。&lt;br/&gt;FCL强制了这个规则，除非重新指定&quot;ServicePointManager.DefaultConnectionLimit&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;FileStream&lt;/h3&gt;
&lt;p&gt;指定 FileOptions.Asynchronous 尽量使用 BeginRead，否则尽量使用Read&lt;br/&gt;&lt;code&gt;章节：27.8.8&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;异步编程模型&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/384997/201803/384997-20180313115542074-1221547550.png&quot;&gt;&lt;img width=&quot;244&quot; height=&quot;138&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/384997/201803/384997-20180313115542297-314051837.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;线程同步&lt;/h3&gt;
&lt;h4&gt;类库和线程安全&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;FCL法则&lt;/strong&gt;&lt;br/&gt;静态方法保证线程安全&lt;br/&gt;实例方法不保证&lt;/p&gt;
&lt;h4&gt;基元用户模式和内核模式&lt;/h4&gt;
&lt;h5&gt;用户模式&lt;/h5&gt;
&lt;p&gt;在硬件中发生&lt;br/&gt;线程将一直在cpu上运行，称作“活锁”&lt;/p&gt;
&lt;h5&gt;内核模式&lt;/h5&gt;
&lt;p&gt;在操作系统中发生&lt;br/&gt;windows会堵塞线程使它不再浪费cpu时间&lt;br/&gt;线程将一直堵塞，称作“死锁”&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;windows操作系统检测不到一个线程在一个基元用户模式中构造上堵塞了。所以线程池不会创建一个新的线程来替换这种临时堵塞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;活锁浪费cpu时间和内存，死锁只浪费内存 同时使用称作：混合模式构造&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;用户模式构造&lt;/h4&gt;
&lt;h5&gt;易失构造&lt;/h5&gt;
&lt;p&gt;它包含一个简单的数据类型的变量上执行原子性的读或写操作&lt;/p&gt;
&lt;h5&gt;互锁构造&lt;/h5&gt;
&lt;p&gt;它包含一个简单的数据类型的变量上执行原子性的读和写操作&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;相关FCL类型&lt;br/&gt;1.Interlocked&lt;br/&gt;2.SpinWait&lt;br/&gt;3.SpinLock&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;内核模式构造&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;相关FCL类型&lt;br/&gt;WaitHandle&lt;br/&gt;EventWaitHandle&lt;br/&gt;AutoResetEvent&lt;br/&gt;ManualResetEvent&lt;br/&gt;Semaphore&lt;br/&gt;Mutex&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;混合模式构造&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;相关FCL类型&lt;br/&gt;ManualResetEventSlim&lt;br/&gt;SemaphoreSlim&lt;br/&gt;CountdownEvent（与SemaphoreSlim相反） Monitor&lt;br/&gt;Barrier（多线程协调）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;lock Monitor&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;Task优势&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;任务使用的内存比线程少的多，创建和销毁所需的时间也少的多（复用线程）&lt;/li&gt;
&lt;li&gt;线程池根据可用CPU数量自动伸缩任务规模&lt;/li&gt;
&lt;li&gt;每个任务完成一个阶段后，运行的任务线程回到线程池，以便在那里接受新任务&lt;/li&gt;
&lt;li&gt;线程池是站在整个进程的高度观察任务，所以，它能更好的调度这些任务，减少进程中的线程数，并减少上下文切换&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 13 Mar 2018 03:56:00 +0000</pubDate>
<dc:creator>KAnts</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ants/p/8555692.html</dc:identifier>
</item>
<item>
<title>UNDO及MVCC、崩溃恢复 - GeaoZhang</title>
<link>http://www.cnblogs.com/geaozhang/p/8555660.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geaozhang/p/8555660.html</guid>
<description>&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;0、undo物理存储研究&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　1&amp;gt;ibdata第五个数据块（系统事务表）中存储着128个undo段的段头块的地址&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　2&amp;gt;每一个undo段头块有1024行，两行记录一个事务，一共可以记录512个事务&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　3&amp;gt;一个数据行中存放XID、rollpointr&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　4&amp;gt;一个数据行被修改&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　1.新的事务ID&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　2.新的rollpointr&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　3.修改后数据&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　上面三部分数据都会进入到回滚块中。详细见：&lt;a href=&quot;http://www.cnblogs.com/geaozhang/p/8555660.html#tran&quot;&gt;事务工作流程&lt;/a&gt;……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113510/201803/1113510-20180313104019164-1104387171.png&quot; alt=&quot;&quot; width=&quot;680&quot; height=&quot;378&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;一、UNDO特性&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1、避免脏读&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　1&amp;gt;在操作任何数据之前，首先将数据备份到undo页中，然后再进行数据的修改；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　2&amp;gt;不能看到其他会话未提交的数据；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　3&amp;gt;当要读取被修改数据页数据行时，会指向备份在undo页中的数据，而避免脏读。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2、事务的回滚&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　undo最基本的作用是rollback，旧数据先放到undo里面存放，等rollback时候再将undo里面的数据回滚回来。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3、DML不阻塞读&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　提高并发，如果别的用户正在修改某数据页，事务没有提交，现需要读该数据页，发现事务没有提交，就根据数据行上的rollpointer找到原来的数据（在undo页上），结合该数据页将数据返给用户。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;4、MVCC（一致性读）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　多版本控制Multiversion Concurrency Control&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;5、崩溃恢复（回滚）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　自动回滚未提交事务；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　redo前滚，undo回滚，未提交事务主动回滚，未提交事务信息在事务槽里写着。数据库在运行期间，突然崩了，数据库启动之后，需要redo前滚，就会有很多未提交的事务（事务的会话断了，不可能继续完成了，就需要对未提交事务回滚了 ）也滚回来了：读取未提交事务事务槽信息，把未提交事务回滚。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;二、事务工作流程：存储结构&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1、分配一个事务ID，事务ID依次递增&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2、分配一个事务槽，将事务信息写入事务槽中&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3、开始修改数据行，数据行中存储事务ID、修改前数据所使用的回滚块地址&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;4、回滚块中存放修改前的数据&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;5、属于一个事务的各个回滚块链接起来&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;6、回滚段段头块中的地址指向回滚块链表中的最后一个回滚块&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;7、一个回滚块只能存放一个事务的数据&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;8、事务提交就是在事务槽中将事务状态改成已提交&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113510/201803/1113510-20180313104238150-200248585.png&quot; alt=&quot;&quot; width=&quot;725&quot; height=&quot;485&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;三、MVCC原理机制&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;理解不深&lt;/span&gt;（转自：http://www.cnblogs.com/chenpingzhao/p/5065316.html）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1、MVCC的几个特点：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　1&amp;gt;每行数据都存在一个版本，每次数据更新时都更新该版本&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　2&amp;gt;修改时Copy出当前版本随意修改，各个事务之间无干扰&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　3&amp;gt;保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　也就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2、非阻塞读Innodb的实现方式：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　4&amp;gt;事务以排他锁的形式修改原始数据&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　5&amp;gt;把修改前的数据存放于undo log，通过回滚指针与主数据关联&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　6&amp;gt;修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3、区别理解&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　二者最本质的区别是，当修改数据时是否要排他锁定；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　Innodb的实现真算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。但理想的MVCC是难以实现的，当事务仅修改一行记录使用理想的MVCC模式是没有问题的，可以通过比较版本号进行回滚；但当事务影响到多行数据时，理想的MVCC据无能为力了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二提交是目前这种场景保证一致性的唯一手段。二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;四、崩溃恢复&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　redo前滚、undo回滚……&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1、两个保证&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　1&amp;gt;数据库保证所有已提交事务的redolog都写入到了redo logfile中&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　2&amp;gt;数据库保证所有脏块的redolog都早redo logfile中，只有脏块写入磁盘以后，redo log才能被覆盖&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　结论：redo log有足够的能力将该有的脏块都构造出来&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2、redo log如何确定使用哪些日志来构造脏块&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　1&amp;gt;起点：checkpoint开始&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　1.innodb buffer pool中存在一条flush list链表&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　2.这个链表最旧的那一端对应的redo log就是将来数据库崩溃恢复redolog前滚的起点&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　3.clean线程周期性的将需要flush list最旧的那一个脏块对应的redo log地址写入到ibdata中&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　2&amp;gt;终点：redo log current最后一条日志&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3、崩溃恢复的过程&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;第一个阶段是&lt;span&gt;前滚&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　前滚对应的redo log的启动和终点已经确定：redolog不害怕多跑，因为redolog有版本，数据块有版本，如果redolog比数据块还要旧，就采用空跑的方式&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;第二个阶段是&lt;span&gt;回滚&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　崩溃时没有提交的事务也会被回滚回来，这些事务都属于死事务，因为这些事务对应的用户会话已经结束，后续读到对应的数据块，发现数据块上有未提交事务，读取未提交事务对应的事务信息，发现已经是死事务，主动回滚这个数据块；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　碰到死事务对应的数据块，谁使用谁回滚。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;五、大事务、长事务&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1、长事务的危害&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　开始一个事务，长时间不提交，所有的数据都需要undo去保存，可能产生很多undo数据，而且还不能被清空覆盖，一直保存到该事务提交。很严重。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2、大事务的危害&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　修改批量的数据，占用过多的undo页（产生undo数据主要是delete产生的，但MySQL对delete做了优化，添加deleted_flag标志位，减少delete对undo的使用），所以危害不是很大，而且正常的事务场景也不会出现大事务。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3、如何判断大事务和长事务&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　mysql&amp;gt; desc information_schema.INNODB_TRX;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;关键参数：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　1.&lt;span&gt;trx_started&lt;/span&gt;：事务开始的时间，如果时间较当前差很远说明是长事务&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　2.&lt;span&gt;trx_rows_modified&lt;/span&gt;：事务修改的行数量，如果值很大说明是大事务&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　3.&lt;span&gt;trx_mysql_thread_id&lt;/span&gt;：该事务所对应的线程id(kill线程清理事务)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;4、解决棘手的大事务、长事务&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　处理大事务：kill -9 mysql_process_id：处理大事务，就直接干掉mysql实例，不会主动去回滚所以速度块，然后重启。（除非迫不得已，否则不那么干，生产环境重启服务器是天大的事情）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　处理长事务：如果开始的时间不是很长，并且行数不是很多，直接kill掉该事务所在的线程。（在数据库里kill，可能反应慢）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;六、UNDO的优化处理&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1、实现undo分离&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　在MySQL5.5以及之前，除了数据量自然增长之外，一旦出现大事务，其所使用的undo log占用的空间就会一直在ibdata1里面存在，即使这个事务已经关闭。&lt;/span&gt;&lt;span&gt;随着数据库上线时间越来越长，ibdata1文件会越来越大，物理备份文件越来越大……&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　MySQL 5.6增加了如下参数，可以把undo log从ibdata1移出来单独存放。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mysql&lt;span&gt;&amp;gt;&lt;/span&gt; show variables &lt;span&gt;like&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%undo%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------------------------+------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Variable_name            &lt;span&gt;|&lt;/span&gt; Value      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------------------------+------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; innodb_max_undo_log_size &lt;span&gt;|&lt;/span&gt; &lt;span&gt;1073741824&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; innodb_undo_directory    &lt;span&gt;|&lt;/span&gt; ./         &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; innodb_undo_log_truncate &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; innodb_undo_logs         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;128&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; innodb_undo_tablespaces  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------------------------+------------+&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; warning (&lt;span&gt;0.00&lt;/span&gt; sec)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1&amp;gt; &lt;span&gt;innodb_undo_directory&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　指定单独存放undo表空间的目录，默认为.（即datadir），可以设置相对路径或者绝对路径。该参数实例初始化之后虽然不可直接改动，但是可以通过先停库，修改配置文件，然后移动undo表空间文件的方式去修改该参数；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2&amp;gt; &lt;span&gt;innodb_undo_tablespaces&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　指定单独存放的undo表空间个数，例如如果设置为3，则undo表空间为undo001、undo002、undo003，每个文件初始大小默认为10M。该参数实例初始化之后不可改动；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3&amp;gt; &lt;span&gt;innodb_undo_logs&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　指定回滚段的个数(早期版本该参数名字是innodb_rollback_segments)，默认128个。每个回滚段可同时支持1024个在线事务。这些回滚段会平均分布到各个undo表空间中。该变量可以动态调整，但是物理上的回滚段不会减少，只是会控制用到的回滚段的个数。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;操作undo分离：实际使用方面，在初始化实例之前，我们只需要设置innodb_undo_tablespaces参数(建议大于等于3)即可将undo log设置到单独的undo表空间中。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2、在线收缩undo表空间&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　MySQL 5.7引入了新的参数，&lt;span&gt;innodb_undo_log_truncate&lt;/span&gt;，开启后可在线收缩拆分出来的undo表空间，支持动态设置。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　1&amp;gt;实现在线收缩undo的条件&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　1.innodb_undo_tablespaces&amp;gt;=2：因为truncate undo表空间时，该文件处于inactive状态，如果只有1个undo表空间，那么整个系统在此过程中将处于不可用状态；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　2.innodb_undo_logs&amp;gt;=35(默认128)：因为在MySQL 5.7中，第一个undo log永远在共享表空间中，另外32个undo log分配给了临时表空间(即ibtmp1)，至少还有2个undo log才能保证2个undo表空间中每个里面至少有1个undo log；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　2&amp;gt;满足以上2个条件后&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　innodb_undo_log_truncate=ON，即可开启undo表空间的自动truncate&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　1.&lt;span&gt;innodb_max_undo_log_size&lt;/span&gt;：undo表空间文件超过此值即标记为可收缩，默认1G，truncate之后空间缩小到10M；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　2.&lt;span&gt;innodb_purge_rseg_truncate_frequency&lt;/span&gt;：指定purge操作被唤起多少次之后才释放rollback segments。当undo表空间里面的rollback segments被释放时，undo表空间才会被truncate。(最大是128，最小是1，默认为128)该参数越小，undo表空间被尝试truncate的频率越高。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 13 Mar 2018 03:54:00 +0000</pubDate>
<dc:creator>GeaoZhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geaozhang/p/8555660.html</dc:identifier>
</item>
<item>
<title>标注-CRF条件随机场理论的介绍 - 道之有道</title>
<link>http://www.cnblogs.com/sxzhou/p/8555586.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sxzhou/p/8555586.html</guid>
<description>&lt;p&gt;&lt;br/&gt;&lt;span&gt;条件随机场conditional random field，给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型。特点是假设输出随机变量构成马尔可夫随机场。条件随机场可用于不同的预测问题。主要的&lt;strong&gt;线性链&lt;/strong&gt;条件随机场，是对输入序列对输出序列预测的判别模型，形成为对数线性模型，学习方法常为极大似然估计或正则化极大似然估计，可应用于标注问题，2001年Lafferty提出。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;首先放一个链接：&lt;a href=&quot;https://www.jianshu.com/p/55755fc649b1&quot;&gt;轻松理解CRF&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;理解：&lt;a href=&quot;http://blog.csdn.net/xiangyong58/article/details/51381477&quot;&gt;http://blog.csdn.net/xiangyong58/article/details/51381477&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;probabilistic undirected graphical model，又称为马尔可夫随机场（Markov random filed）是一个由无向图表示的联合概率分布。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;1.1 模型定义&quot;&gt;&lt;span&gt;1.1 模型定义&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图graph&lt;/strong&gt;由&lt;strong&gt;结点（node）&lt;/strong&gt;和连接结点的&lt;strong&gt;边（edge）&lt;/strong&gt;组成的集合。结点记作ν，边e，结点集合V，边集合E，图记作（V，E），无向图指的是没有方向。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;概率图模型（probabilistic graphical model）是由图表示的概率模型。设联合概率分布P(Y)，Y是一组随机变量，由无向图G(V,E)表示概率分布,即在图中，ν表示一个随机变量Yν，Y=Yν；边e表示随机变量的依赖关系。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;给定一个联合概率分布P(Y)和表示它的无向图G，首先定义无向图表示的随机变量之间存在的成对马尔可夫性（pairwise Markov property），局部马尔可夫性（local Markov property）和全局马尔可夫性（global Markov property）。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;pairwise Markov property：&lt;/strong&gt;G图上任意两个没有连接的结点μ和ν对应的随机变量Yμ，Yν，其他结点用O表示，对应的随机变量为Yo，则成对Markov property指的是给定随机变量组Yo条件下随机变量Yμ，Yν是条件独立的，即&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114954459-1978876522.jpg&quot; alt=&quot;&quot; width=&quot;332&quot; height=&quot;26&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;local Markov property：&lt;/strong&gt;设ν是G的任意一个结点，W是与ν有边连接的所有结点，O是与ν和W以外的其他所有结点，那么本定义指的是给定随机变量组Yw条件下随机变量Yν与随机变量组Yo是独立的，即&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114954654-724825610.jpg&quot; alt=&quot;&quot; width=&quot;337&quot; height=&quot;26&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在P(Yo|Yw)&amp;gt;0时，等价于&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114954889-1363372389.jpg&quot; alt=&quot;&quot; width=&quot;219&quot; height=&quot;30&quot;/&gt;（做除法即可得到）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;global Markov property：&lt;/strong&gt;设结点集合A，B是在无向图G中被结点集合C分开的任意结点集合，本定义是指给定随机变量组Yc条件下随机变量组YA和YB是条件独立的，即&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114955373-316608384.png&quot; alt=&quot;&quot; width=&quot;351&quot; height=&quot;34&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;概率无向图模型的定义：&lt;/strong&gt;设有联合概率分布P(Y)，由无向图G=(V,E)表示，在图G中结点表示随机变量，边表示随机变量之间的依赖关系。如果联合概率分布P(Y)满足成对，局部或全局马尔可夫性就称为马尔可夫随机场（Markov random filed）。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;目标：给定马尔可夫随机场希望求得其概率，那么如果将整体的联合概率分布写成若干联合概率的乘积形式，也就是将联合概率进行因子分解。而概率无向图模型最大的特点就是易于因子分解。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;1.2 因子分解&quot;&gt;&lt;span&gt;1.2 因子分解&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;团与最大团：&lt;/strong&gt;无向图中任何两个结点均有边连接的结点子集称为团（clique）；若C是无向图G的一个团，并且不能再加进任何一个G的结点使其称为更大的一个团，则称C为最大团（maximal clique）。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;因子分解（factorization）：&lt;/strong&gt;将概率无向图的联合概率分布表示为其最大团上的随机变量函数的乘积形式的操作。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;给定概率无向图模型，设为G，C为G上最大团，Yc表示C对应的随机变量，那么概率无向图模型的联合概率分布P(Y)，可写作最大团C上函数&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114955722-1576975640.jpg&quot; alt=&quot;&quot; width=&quot;44&quot; height=&quot;16&quot;/&gt;的乘积形式：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114956048-645903691.jpg&quot; alt=&quot;&quot; width=&quot;167&quot; height=&quot;47&quot;/&gt;，其中Z是规范化因子（normalization factor）&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114956292-1142343838.png&quot; alt=&quot;&quot; width=&quot;120&quot; height=&quot;38&quot;/&gt;保证了P(Y)构成一个概率分布；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;函数&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114955722-1576975640.jpg&quot; alt=&quot;&quot; width=&quot;44&quot; height=&quot;16&quot;/&gt;称为&lt;strong&gt;势函数（potential function）&lt;/strong&gt;，要求势函数必须为严格正的，因此常定义为指数函数：&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114956530-528676409.png&quot; alt=&quot;&quot; width=&quot;146&quot; height=&quot;20&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114956841-151940207.jpg&quot; alt=&quot;&quot; width=&quot;602&quot; height=&quot;197&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;条件随机场（conditional random field，CRF）&lt;/strong&gt;：给定随机变量X条件下，随机变量Y的马尔可夫随机场。&lt;strong&gt;这里主要介绍线性链上特殊的条件随机场——线性链条件随机场（linear chain conditional random field）&lt;/strong&gt;。这是，条件概率模型P(Y|X)中&lt;strong&gt;Y是输出变量，表示标记序列；&lt;/strong&gt;X是输入变量表示需要标注的观测序列。也把&lt;strong&gt;标记序列称为状态序列&lt;/strong&gt;。学习时，利用训练数据集通过极大似然估计或正则化极大似然估计得到条件概率模型&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114957144-2134170851.png&quot; alt=&quot;&quot; width=&quot;67&quot; height=&quot;26&quot;/&gt;；预测时，对于给定的输入序列x，求出条件概率&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114957355-1176185184.png&quot; alt=&quot;&quot; width=&quot;51&quot; height=&quot;19&quot;/&gt;最大的输出序列Y hat。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;条件随机场数学定义：&lt;/strong&gt;设X，Y是随机变量，P(Y|X)是给定X条件下Y的条件概率分布。若随机变量Y构成一个由无向图G=(V,E),表示的马尔可夫随机场，即&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114957719-68565069.jpg&quot; alt=&quot;&quot; width=&quot;347&quot; height=&quot;32&quot;/&gt;对任意结点ν成立，则称&lt;strong&gt;条件概率分布P(Y|X)为条件随机场&lt;/strong&gt;，w~ν表示在图G中与结点ν有边连接的所有结点w，&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114958133-1321261940.png&quot; alt=&quot;&quot; width=&quot;42&quot; height=&quot;13&quot;/&gt;表示结点ν以外的所有结点，Yν，Yμ，Yw表示结点ν，μ，w对应的随机变量。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;线性链条件随机场数学定义：&lt;/strong&gt;设X=(X1,X2,…,Xn)，Y=(Y1,Y2,…,Yn)均为线性链表示的随机变量序列，若给定随机变量序列X条件下，随机变量序列Y的条件概率分布P(Y|X)构成条件随机场，即满足马尔可夫性：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114958540-223569243.png&quot; alt=&quot;&quot; width=&quot;374&quot; height=&quot;30&quot;/&gt;，i=1,2,…n(i=1和i=n时只考虑单边)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;则&lt;strong&gt;称P(Y|X)为线性链条件随机场&lt;/strong&gt;。标注问题中，X表示输入观测序列，Y表示对应的输出标记序列或状态序列。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;2.2 条件随机场的参数化形式&quot;&gt;&lt;span&gt;2.2 条件随机场的参数化形式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;由线性链的特点可知，其最大团为相邻的结点，由因子分解定理可知P(Y|X)可以因子分解。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;线性链条件随机场的参数化形式&lt;/strong&gt;：设P(Y|X)为线性链条件随机场，则在随机变量X取值为x条件下，随机变量Y取值为y条件概率形式为：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114959126-184166193.jpg&quot; alt=&quot;&quot; width=&quot;342&quot; height=&quot;43&quot;/&gt;其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114959473-1345013951.jpg&quot; alt=&quot;&quot; width=&quot;338&quot; height=&quot;41&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;式中tk和sl是特征函数，λk和μl是对应的权值，Z(x)是规范化因子，求和是在所有可能的输出序列上进行。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;本式为线性链条件概率随机场模型的基本形式&lt;/strong&gt;，表示给定输入序列x，对输出序列y预测的条件概率。tk是定义在边上的特征函数，称为&lt;strong&gt;转移特征&lt;/strong&gt;，依赖于当前和前一个位置；sl是定义在结点上特征函数，称为&lt;strong&gt;状态特征&lt;/strong&gt;，依赖于当前特征。tk和sl都依赖于位置，是局部特征。通常，特征函数tk和sl取值为1 or 0；当满足特征条件时取1，否则为0；&lt;strong&gt;条件随机场完全由特征函数tk和sl及对应的权值λk和μl确定。&lt;/strong&gt;线性链条件随机场也是对数线性模型（log linear model）。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;2.3 条件随机场的简化形式&quot;&gt;&lt;span&gt;2.3 条件随机场的简化形式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;条件随机场的原始公式中&lt;strong&gt;同一特征在各个位置都有定义，可以对同一特征在各个位置求和&lt;/strong&gt;，将局部特征函数转化为一个全局特征函数，这样就可以将条件随机场写成权值向量和特征向量的内积形式，即条件随机场的简化形式。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;首先将转移特征和状态特征及其权值用统一符号表示，设K1个转移特征，K2个状态特征，K=K1+K2，记&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114959750-1932269074.jpg&quot; alt=&quot;&quot; width=&quot;441&quot; height=&quot;54&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对转移和状态特征在各个位置i求和，记作，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313114959954-1634955114.jpg&quot; alt=&quot;&quot; width=&quot;385&quot; height=&quot;45&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;用wk表示权值，即&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115000402-1238551340.jpg&quot; alt=&quot;&quot; width=&quot;279&quot; height=&quot;51&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;条件随机场可表示为&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115000650-2016819351.jpg&quot; alt=&quot;&quot; width=&quot;229&quot; height=&quot;44&quot;/&gt;，&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115000883-557868379.jpg&quot; alt=&quot;&quot; width=&quot;203&quot; height=&quot;45&quot;/&gt;；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;若w表示权值向量，即&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115001080-1708802628.png&quot; alt=&quot;&quot; width=&quot;209&quot; height=&quot;33&quot;/&gt;；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;若F(y,x)表示全局特征向量，即&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115001279-861164446.png&quot; alt=&quot;&quot; width=&quot;352&quot; height=&quot;28&quot;/&gt;；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;则&lt;strong&gt;条件随机场写成w和F的内积形式：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115001482-639935629.png&quot; alt=&quot;&quot; width=&quot;194&quot; height=&quot;43&quot;/&gt;，其中&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115001748-1906480065.jpg&quot; alt=&quot;&quot; width=&quot;208&quot; height=&quot;36&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;2.4 条件随机场的矩阵形式&quot;&gt;&lt;span&gt;2.4 条件随机场的矩阵形式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Pw(y|x)表示对给定观测序列x，相应的标记序列y的条件概率，引进特殊的起点和终点状态标记y0=start，yn+1=stop，这时Pw可通过矩阵形式表示。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对观测序列x的每一个位置i=1,2，…，n+1,定义一个m阶矩阵（m是标记yi的取值个数）：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115001998-1095056265.jpg&quot; alt=&quot;&quot; width=&quot;290&quot; height=&quot;155&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;因此，给定观测序列x，标记序列y的非规范化概率通过n+1个矩阵的乘积&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115002567-1892264333.png&quot; alt=&quot;&quot; width=&quot;150&quot; height=&quot;28&quot;/&gt;表示，于是，条件概率Pw为：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115003053-1073857330.png&quot; alt=&quot;&quot; width=&quot;291&quot; height=&quot;47&quot;/&gt;，Zw(x)是规范化因子&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115003456-1598040745.jpg&quot; alt=&quot;&quot; width=&quot;268&quot; height=&quot;26&quot;/&gt;；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;注意：规范化因子是从start到stop通过状态的所有路径y1y2.。。yn的非规范化概率&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115003722-1961721438.png&quot; alt=&quot;&quot; width=&quot;127&quot; height=&quot;24&quot;/&gt;之和。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;条件随机场概率计算问题是给定条件随机场P(Y|X)，输入序列x和输出序列y，计算条件概率P(Yi=yi|x),P(Yi-1=yi-1|x)以及相应的数学期望。为了计算方便，引入前向-后向向量，递归地计算以上概率问题及期望值——&lt;strong&gt;前向-后向算法。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;3.1 前向-后向算法&quot;&gt;&lt;span&gt;3.1 前向-后向算法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对每个指标i=0，1，…, n+1,定义前向向量αi(x):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115004071-1536573984.jpg&quot; alt=&quot;&quot; width=&quot;210&quot; height=&quot;53&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;递推公式为：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115004427-957073090.jpg&quot; alt=&quot;&quot; width=&quot;514&quot; height=&quot;28&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;又可以表示为&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115004757-930400423.jpg&quot; alt=&quot;&quot; width=&quot;221&quot; height=&quot;31&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115005072-516888502.png&quot; alt=&quot;&quot; width=&quot;84&quot; height=&quot;25&quot;/&gt;表示在位置i标记是yi并且到位置i的前部分标记序列的非规范化概率，yi可取的值由m个，所以αi(x)是m维向量（m是yi的取值个数）。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;同样，对每个指标i=0,1,…,n+1，定义后向向量βi(x):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115005326-1687013392.jpg&quot; alt=&quot;&quot; width=&quot;274&quot; height=&quot;54&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;递推公式：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115005505-1133599038.jpg&quot; alt=&quot;&quot; width=&quot;354&quot; height=&quot;33&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;又可以表示为：&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115005830-770640835.jpg&quot; alt=&quot;&quot; width=&quot;171&quot; height=&quot;28&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;βi(yi|x)表示在位置i的标记为yi并且从i+1到n的后半部分标记序列的非规范化概率。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;由前向-后向向量得到&lt;strong&gt;规范化因子：&lt;/strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115006104-327154815.png&quot; alt=&quot;&quot; width=&quot;261&quot; height=&quot;34&quot;/&gt;，&lt;strong&gt;1&lt;/strong&gt;是元素均为1的m维列向量。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;3.2 概率计算&quot;&gt;&lt;span&gt;3.2 概率计算&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;标记序列在位置i是标记yi的条件概率和位置i-1与i是标记yi-1和yi的条件概率为：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115006442-971744856.png&quot; alt=&quot;&quot; width=&quot;290&quot; height=&quot;52&quot;/&gt;；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115006723-307797591.jpg&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;53&quot;/&gt;；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115006918-1548432057.png&quot; alt=&quot;&quot; width=&quot;117&quot; height=&quot;20&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;3.3 期望值的计算&quot;&gt;&lt;span&gt;3.3 期望值的计算&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;利用前向-后向向量可以计算特征函数关于联合分布P(X,Y)和条件P(Y|X)的数学期望。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;特征函数fk关于条件分布P(Y|X)的数学期望是&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115007254-655375111.jpg&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;89&quot;/&gt;，k=1,2,3…,K,其中&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115007466-1759265759.png&quot; alt=&quot;&quot; width=&quot;123&quot; height=&quot;23&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;假设经验分布为&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115007646-726697468.jpg&quot; alt=&quot;&quot; width=&quot;39&quot; height=&quot;20&quot;/&gt;,特征函数fk关于联合分布P(X,Y)的数学期望是&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115007888-283007837.jpg&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;151&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对于转移特征：&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115008148-29570958.jpg&quot; alt=&quot;&quot; width=&quot;466&quot; height=&quot;26&quot;/&gt;；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对于状态特征：&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115008465-1360221177.png&quot; alt=&quot;&quot; width=&quot;306&quot; height=&quot;24&quot;/&gt;，同理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;学习算法指的是&lt;strong&gt;给定条件随机场估计条件随机场模型参数&lt;/strong&gt;。CRF实际上是定义在时序数据上对数线性模型，学习算法包括：极大似然估计，正则化极大似然估计。具体的优化实现算法是改进的IIS，GD，及拟牛顿法。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;4.1 改进的迭代尺度法IIS&quot;&gt;&lt;span&gt;4.1 改进的迭代尺度法IIS&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;已知训练集可知经验概率分布&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115008917-516087966.jpg&quot; alt=&quot;&quot; width=&quot;67&quot; height=&quot;27&quot;/&gt;通过极大化训练数据的对数似然函数来求模型参数。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;训练数据对数似然函数为&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115009485-77134393.jpg&quot; alt=&quot;&quot; width=&quot;429&quot; height=&quot;39&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代入Pw的等式得，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115010063-1669798673.jpg&quot; alt=&quot;&quot; width=&quot;403&quot; height=&quot;152&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;改进的迭代尺度法&lt;/strong&gt;通过迭代的方法不断优化对数似然函数该变量的下界，达到极大化对数似然函数的目的。假设模型的当前参数向量为&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115010548-872526877.jpg&quot; alt=&quot;&quot; width=&quot;175&quot; height=&quot;26&quot;/&gt;，向量的增量为&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115010846-364024202.jpg&quot; alt=&quot;&quot; width=&quot;160&quot; height=&quot;27&quot;/&gt;，更新参数向量为w+δ=(w1+δ1,…,wk+δk)T，在每次迭代过程中，IIS通过依次求解L得到&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115011045-1571035932.png&quot; alt=&quot;&quot; width=&quot;138&quot; height=&quot;23&quot;/&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;关于&lt;strong&gt;转移特征tk的更新方程&lt;/strong&gt;为&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115011358-13929447.jpg&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;138&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;关于&lt;strong&gt;状态特征sl更新方程&lt;/strong&gt;为&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115011584-194221508.jpg&quot; alt=&quot;&quot; width=&quot;467&quot; height=&quot;146&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其中，T是所有数据(x,y)中出现所有特征数总和&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115011775-756574660.jpg&quot; alt=&quot;&quot; width=&quot;338&quot; height=&quot;47&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;条件随机场模型学习的改进的迭代尺度算法：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115012031-442186332.jpg&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;452&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;问题：T为所有数据(x,y)的特征总数，对不同的数据(x,y)可能取值不同，为了处理这个问题，定义松弛特征：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115012228-1546619751.jpg&quot; alt=&quot;&quot; width=&quot;284&quot; height=&quot;52&quot;/&gt;，S是一个常数， 通常选择S要 足够大，使得s(x,y)&amp;gt;=0。这时总特征总数取S。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;那么，对于转移特征tk，δk的更新方程是&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115012556-73571151.jpg&quot; alt=&quot;&quot; width=&quot;360&quot; height=&quot;42&quot;/&gt;，&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115012747-1693140488.png&quot; alt=&quot;&quot; width=&quot;124&quot; height=&quot;43&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115013132-1869364830.jpg&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;48&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对状态特征sl，δk的更新方程是&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115013348-1738767555.jpg&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;46&quot;/&gt;，&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115013671-1116221216.jpg&quot; alt=&quot;&quot; width=&quot;161&quot; height=&quot;48&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115014027-240951122.jpg&quot; alt=&quot;&quot; width=&quot;407&quot; height=&quot;51&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;以上称为&lt;strong&gt;算法S&lt;/strong&gt;。在S中需要使常数S取足够大，这样每步的迭代增量向量会变大，算法收敛会变慢。因此&lt;strong&gt;算法T将解决这个问题&lt;/strong&gt;。算法T对每个观测序列x计算其特征总数的最大值T(x),&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115014289-1403701124.png&quot; alt=&quot;&quot; width=&quot;139&quot; height=&quot;28&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;利用前向-后向递推公式，得T(x)=t.两个更新方程为：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115014529-1910465068.jpg&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;188&quot;/&gt;，&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115014922-1160695417.jpg&quot; alt=&quot;&quot; width=&quot;399&quot; height=&quot;188&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;there，ak,t是特征tk的期待值，δk=logβk（βk是上述方程唯一的实根，可用牛顿法求得）；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;bl,t是特征sl的期待值，δl=logγl（γl是上述方程唯一的实根，可用牛顿法求得）；&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;4.2 拟牛顿法&quot;&gt;&lt;span&gt;4.2 拟牛顿法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对于条件随机场模型：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115015147-331098139.jpg&quot; alt=&quot;&quot; width=&quot;279&quot; height=&quot;113&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;学习的优化目标函数是：&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115015332-82397934.jpg&quot; alt=&quot;&quot; width=&quot;473&quot; height=&quot;42&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其梯度函数是：&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115015526-1645389998.jpg&quot; alt=&quot;&quot; width=&quot;248&quot; height=&quot;34&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;BFGS算法：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115015847-1271481296.jpg&quot; alt=&quot;&quot; width=&quot;626&quot; height=&quot;438&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;条件随机场的预测问题是给定条件随机场P(Y|X)和输入序列（观测序列）x，求条件概率最大的输出序列（标记序列）y*，对观测序列进行标注。条件随机场的预测算法是&lt;strong&gt;维特比算法&lt;/strong&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;目标：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115016155-1789204012.jpg&quot; alt=&quot;&quot; width=&quot;242&quot; height=&quot;167&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;于是，CRF预测问题成为求非规范概率最大的最优路径问题&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115016440-2076223738.jpg&quot; alt=&quot;&quot; width=&quot;140&quot; height=&quot;30&quot;/&gt;，这里，路径表示标记序列。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其中，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115016664-940192650.jpg&quot; alt=&quot;&quot; width=&quot;399&quot; height=&quot;122&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;只需计算非规范概率而不必求解概率。为了求解最优路径将上式max修改为&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115016938-36224509.jpg&quot; alt=&quot;&quot; width=&quot;186&quot; height=&quot;41&quot;/&gt;，其中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115017146-12502500.jpg&quot; alt=&quot;&quot; width=&quot;552&quot; height=&quot;32&quot;/&gt;是&lt;strong&gt;局部特征向量。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;讲解&lt;strong&gt;维特比算法：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;首先位置1的各个标记j=1,2,3,..,m的非规范化概率：&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115017393-911168691.jpg&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;29&quot;/&gt;；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;递推公式，求得位置i的各个标记j=1,2,3,…,m的非规范概率，同时记录非规范化概率最大值的路径：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115017593-1297865467.jpg&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;36&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115017780-115326297.jpg&quot; alt=&quot;&quot; width=&quot;546&quot; height=&quot;34&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;直到i=n时终止。这时求得&lt;strong&gt;非规范化概率最大值&lt;/strong&gt;是&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115017959-2078452987.jpg&quot; alt=&quot;&quot; width=&quot;249&quot; height=&quot;38&quot;/&gt;；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;最优路径的终点：&lt;/strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115018141-1026362748.jpg&quot; alt=&quot;&quot; width=&quot;159&quot; height=&quot;35&quot;/&gt;；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;由终点回溯：&lt;/strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115018374-1429306302.png&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;26&quot;/&gt;；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;求得最优路径&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115018539-439675377.jpg&quot; alt=&quot;&quot; width=&quot;184&quot; height=&quot;28&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;条件随机场的维特比算法：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690773/201803/690773-20180313115018944-689609171.jpg&quot; alt=&quot;&quot; width=&quot;550&quot; height=&quot;459&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结：CRF模型主要是对含有序列的信息打上标签，尤其是词性标注；这里主要理解CRF的主要工作过程，IIS，拟牛顿法，Viterbi算法都是常见的通用算法，可用于解决很多问题，理解即可。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 13 Mar 2018 03:50:00 +0000</pubDate>
<dc:creator>道之有道</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sxzhou/p/8555586.html</dc:identifier>
</item>
<item>
<title>掌握这些知识，你的python水平能更上一层楼 - 卿哥聊技术</title>
<link>http://www.cnblogs.com/huashao1985/p/8548470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huashao1985/p/8548470.html</guid>
<description>&lt;p&gt;今天讲一些python中的高级用法，有助于大家更好的使用python这门语言。今天讲的这些知识是层层递进的关系，前面是后面的铺垫。&lt;/p&gt;
&lt;h2&gt;函数可变参数*args和**kwargs&lt;/h2&gt;
&lt;p&gt;python支持固定参数，默认参数，也和很多其他语言一样支持可变参数，只不过python支持的可变参数分为两种，*args是tuple，里面可以有任意多个element（包括0个）。**kwargs则是当你需要指定key word时需要用到的参数类型。&lt;/p&gt;
&lt;p&gt;先考虑*args的情况，先看函数定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;def&lt;/span&gt; take_any_args(*&lt;span&gt;args):
...     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type of args:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str(type(args)))
...     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value of args:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str(args))
... 
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; take_any_args(1&lt;span&gt;)
type of args:&lt;/span&gt;&amp;lt;type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tuple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;
value of args:(&lt;/span&gt;1&lt;span&gt;,)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; take_any_args(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
type of args:&lt;/span&gt;&amp;lt;type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tuple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;
value of args:(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; take_any_args()
type of args:&lt;/span&gt;&amp;lt;type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tuple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;
value of args:()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; take_any_args([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
type of args:&lt;/span&gt;&amp;lt;type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tuple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;
value of args:([&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看参数提取：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; print_args(*&lt;span&gt;args):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; arg &lt;span&gt;in&lt;/span&gt;&lt;span&gt; args:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(arg)

print_args(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; print_all(*args, **&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; arg &lt;span&gt;in&lt;/span&gt;&lt;span&gt; args:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(arg)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; key, value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; kwargs.items():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{} -&amp;gt; {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(key, value))

print_all(&lt;/span&gt;1, 2&lt;span&gt;)
print_all(a&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
red
blue
green
1
2
a -&amp;gt; red
c -&amp;gt; green
b -&amp;gt; blue
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面看看为什么需要**kwargs, 对于上面的print_args, 下面这种添加了keyword的调用方式会出错，所以就有了**kwargs的用武之地：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; def print_args(*args):
...     for arg in args:
...         print arg
... 
&amp;gt;&amp;gt;&amp;gt; print_args(a=1,b=2)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: print_args() got an unexpected keyword argument 'a'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;**kwargs的本质其实是dict，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; def print_kwargs(**kwargs):
...     for key,value in kwargs.items():
...         print(&quot;{}-&amp;gt;{}&quot;.format(key,value))
... 
&amp;gt;&amp;gt;&amp;gt; print_kwargs(a=&quot;lalala&quot;,b=&quot;papapa&quot;)
a-&amp;gt;lalala
b-&amp;gt;papapa
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常再使用的时候都是二者合起来使用，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; print_all(*args, **&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; arg &lt;span&gt;in&lt;/span&gt;&lt;span&gt; args:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(arg)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; key, value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; kwargs.items():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{} -&amp;gt; {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(key, value))

print_all(&lt;/span&gt;1, 2&lt;span&gt;)
print_all(a&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, c=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1
2
a -&amp;gt; red
c -&amp;gt; green
b -&amp;gt; blue
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的知识大家差不多应该都知道，下面这种Unpacking的用法很多人都不太了解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; sample_function(a,b,c):
...     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{},{},{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).format(a,b,c)
... 
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; input = (1,2,3&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; sample_function(1,2,3&lt;span&gt;)
&lt;/span&gt;1,2,3
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;和上面的方法等效&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; sample_function(*&lt;span&gt;input)
&lt;/span&gt;1,2,3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;unpack 使用kwargs，记住keyword要和函数声明时的变量名一致才行，否则会报错&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; sample_function(a,b,c):
...     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a-&amp;gt;{},b-&amp;gt;{},c-&amp;gt;{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(a,b,c))
... 
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; input = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:1,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:2,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:3&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; sample_function(**&lt;span&gt;input)
a&lt;/span&gt;-&amp;gt;1,b-&amp;gt;2,c-&amp;gt;3
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;与上面方法等效&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; sample_function(a=input[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],b=input[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],c=input[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
a&lt;/span&gt;-&amp;gt;1,b-&amp;gt;2,c-&amp;gt;3
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;lambda function&lt;/h2&gt;
&lt;p&gt;在python 中所有的东西都是object，不管是int也好，list也好都是object。函数也是object。这个概念很重要。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(n):
...     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n+1&lt;span&gt;
... 
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; id(f)
&lt;/span&gt;4374076184
&amp;gt;&amp;gt;&amp;gt; g =&lt;span&gt; f
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt; g(2&lt;span&gt;)
&lt;/span&gt;3
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; id(g)
&lt;/span&gt;4374076184
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的g和f所指向的object是同一个object&lt;/p&gt;
&lt;p&gt;下面思考这样一个问题，如果 numbers = [&quot;10&quot;, &quot;3&quot;, &quot;40&quot;, &quot;14&quot;, &quot;5&quot;], 让你找出最大值怎么找？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; max(numbers)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这显然不对，因为max默认按照字母顺序排序了，所以需要额外提供排序信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; max(numbers, key=&lt;span&gt;int)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;int 就是一个function，然后看看如果用lambda function表示就是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; max(numbers, key=&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x:int(x))
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再举一个例子, 下面是几个人的年龄，性别，地址，请找出年纪最大的人：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; person_zhangsan = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 40, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;home&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;beijing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; person_lisi = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 35, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;home&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hangzhou&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; person_wangwu = { &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 21, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;home&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chongqing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; people =&lt;span&gt; [person_zhangsan, person_lisi, person_wangwu]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; max(people, key=&lt;span&gt;lambda&lt;/span&gt; x:x[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 40, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;home&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;beijing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;python在operator中提供了itemgetter这个函数，它起到的作用和lambda function一样，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt; operator &lt;span&gt;import&lt;/span&gt;&lt;span&gt; itemgetter
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; max(people, key=itemgetter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 40, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;home&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;beijing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对比一下我还是更喜欢lambda function的定义，简洁明了&lt;/p&gt;
&lt;h2&gt;Decorator 装饰器&lt;/h2&gt;
&lt;p&gt;最长见的decorator的user case是什么？答：retry。 比如网络restful request碰到不稳定的server或者说server给你返回了5XX，你要不要retry。&lt;/p&gt;
&lt;p&gt;一开始可能你的code长这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
URL &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://example.com/api&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_items():
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; requests.get(URL + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/items&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然你还会有很多get function，比如get_apple, get_banana, get_orange, ...&lt;/p&gt;
&lt;p&gt;实际部署之后发现server不稳定，不定期返回500，你就要加retry&lt;/p&gt;
&lt;p&gt;如果只有一个get_items，你可能会这么写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;第二版，加入retry&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_items():
    NUM_RETRY &lt;/span&gt;= 3&lt;span&gt;
    current_retry &lt;/span&gt;=&lt;span&gt; 0
    resp &lt;/span&gt;=&lt;span&gt; None
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        resp &lt;/span&gt;= requests.get(URL + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/items&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rest.status_code/100 == 5 &lt;span&gt;and&lt;/span&gt; current_retry &amp;lt; NUM_RETRY&lt;span&gt;:
            current_retry &lt;/span&gt;+= 1
            &lt;span&gt;continue&lt;/span&gt;
        &lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; resp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可是每一个fucntion都要改，是不是很累。。。&lt;/p&gt;
&lt;p&gt;下面decorator隆重登场，decorator的本质是一个function。这个function的parameter有且仅有一个就是一个function object，返回值则是另一个不同的function&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;比如已经有了一个普通function&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; some_function(arg1,arg2,arg3):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;此处省略20行&lt;/span&gt;
&lt;span&gt;
some_function &lt;/span&gt;= some_decorator(some_function)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等效于&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@some_decorator
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; some_function(arg1,arg2,arg3):
      &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;......&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面举一个decorator的例子，logging decorator&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; logfuncname(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;function name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(*args, **&lt;span&gt;kwargs)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; wrapper
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; @logfuncname
... &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; some_func(n):
...     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n+1&lt;span&gt;
... 
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt; some_func(3&lt;span&gt;)
function name: some_func
&lt;/span&gt;4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上所示，logfuncname就是一个decorator，它的input是func，return了一个wrapper function。&lt;/p&gt;
&lt;p&gt;下面我们回到一开始retry那个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;第三版，定义decorator&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; retry(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **&lt;span&gt;kwargs):
        NUM_RETRY &lt;/span&gt;= 3&lt;span&gt;
        current_retry &lt;/span&gt;=&lt;span&gt; 0
        resp &lt;/span&gt;=&lt;span&gt; None
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            resp &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rest.status_code/100 == 5 &lt;span&gt;and&lt;/span&gt; current_retry &amp;lt; NUM_RETRY&lt;span&gt;:
                current_retry &lt;/span&gt;+= 1
                &lt;span&gt;continue&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; resp
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper

@retry
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_items():
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; requests.get(URL + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/items&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后get_apple, get_banana, get_orange 什么的上面加上@retry就可以了&lt;/p&gt;
&lt;p&gt;接下来问题来了，如果有另一个decorator也想用上怎么办？&lt;/p&gt;
&lt;p&gt;decorator是可以叠加的，比如下面的例子，注意上下顺序就是decorator从左到右的顺序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@add2
@multi3
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo(n):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n + 1

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;相当于foo = add2(multi3(foo))&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;那么foo(3)就是14&lt;/span&gt;
&lt;span&gt;
@multi3
@add2
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo(n):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n + 1

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;相当于foo = multi3(add2(foo))&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;那么foo(3)就是18&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想要改变retry的次数怎么办，比如get_apple想要retry 3次，但是get_banana想要retry 5次怎么办？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;第四版，定义带参数的decorator&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; retry(num_retry):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator(func):
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **&lt;span&gt;kwargs):
            current_retry &lt;/span&gt;=&lt;span&gt; 0
            resp &lt;/span&gt;=&lt;span&gt; None
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
                resp &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rest.status_code/100 == 5 &lt;span&gt;and&lt;/span&gt; current_retry &amp;lt;&lt;span&gt; num_retry:
                    current_retry &lt;/span&gt;+= 1
                    &lt;span&gt;continue&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; resp
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decorator
    

@retry(&lt;/span&gt;3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_items():
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; requests.get(URL + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/items&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里其实用到了一个&lt;strong&gt;closure&lt;/strong&gt;的概念，就是外层函数的参数在里层函数里是可见的，而里层函数的参数在外层不可见（当然这里也不需要）。&lt;/p&gt;
&lt;h2&gt;Decorator在flask中的实现原理&lt;/h2&gt;
&lt;p&gt;下面我们来看看flask中decorator是怎么实现的，简而言之：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebApp:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):&lt;br/&gt;#初始化routes
        self.routes &lt;/span&gt;=&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; route(self, param):
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator(func):&lt;br/&gt;#定义decorator时为routes赋值key/value
            self.routes[param] &lt;/span&gt;=&lt;span&gt; func
            &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **&lt;span&gt;kwargs):
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(*args, **&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decorator
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self, param):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;br/&gt;#get时根据key返回value
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.routes[param]()
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; KeyError:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERROR - no such page&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt; app =&lt;span&gt; WebApp()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; @app.route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
... &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
...     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Index Page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
...
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; @app.route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/contact/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
... &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; contact():
...     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Contact Page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
...
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; app.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Index Page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; app.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/contact/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Contact Page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; app.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/no-such-page/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ERROR - no such page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 13 Mar 2018 03:44:00 +0000</pubDate>
<dc:creator>卿哥聊技术</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huashao1985/p/8548470.html</dc:identifier>
</item>
<item>
<title>Angular和Vue.js 深度对比 - 葡萄城控件技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/angular_vs_vue.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/angular_vs_vue.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201803/139239-20180313094417689-1152363867.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Vue.js 是开源的 JavaScript 框架，能够帮助开发者构建出美观的 Web 界面。当和其它网络工具配合使用时，Vue.js 的优秀功能会得到大大加强。如今，已有许多开发人员开始使用 Vue.js 来取代 Angular 和 React.js  。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;那么对于 Angular 和 React.js ，开发者该如何选择呢？&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;下面我们会对这两种框架进行介绍和深度对比。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot;&gt;Vue.js&lt;/a&gt; 是前 Google 员工 Evan You 的开发的，并于2014年发布，现已获得了超过57,000个 GitHub star。许多开发人员都大力推荐 Vue，因为它很容易学习。如果你有深厚的 HTML、CSS 和 JavaScript 基础，那么学习 Vue.js 只需几个小时。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Vue 对开发人员最有吸引力的地方是：它的新颖、轻便，而且复杂性很少甚至没有。Vue 不但非常灵活简单，而且还非常强大，同时还提供双向数据绑定功能，就像 Angular 和 React 的虚拟 DOM 功能一样。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Vue 可以帮助开发人员以任何想要的方式来构建应用程序，这是 Angular 做不到的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;作为一个跨平台的，高度进步的框架，Vue 成为了许多需要创建单页应用程序的开发人员的首选。在用于开发 Web 应用程序的典型 MVC 体系结构中，Vue 充当了 View，这意味着它可以让开发者看到数据的显示部分。除了上面提到的基本功能之外，Vue 还有许多其它优秀功能。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;我们来看看这些：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1. 容易使用&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如果你一直在使用其它框架，那么你可以轻松使用 Vue，因为 Vue 的核心库专注于 View 层，你可以轻松地将其与第三方库进行整合并与现有项目一起使用。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2. 轻便&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;由于 Vue 主要关注于 ViewModel 或双向数据绑定，因此 Vue 很轻便。Vue 也具有十分基础的文档。Vue 用做 View 层，意味着开发者可以将它用作页面中的亮点功能，比起全面的 SPA，Vue 提供了更好的选择。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3. 学习曲线很低&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;熟悉 HTML 的开发人员会发现 Vue 的学习曲线很低，同时对于经验较少的开发人员和初学者来说，也能够快速地学习和理解 Vue。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4. 双向绑定&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Vue 提供了 v-model 指令（用于更新用户输入事件的数据），使得在表单输入和结构元素上实现双向绑定变得很容易。它可以选择正确的方式来更新输入类型相关的元素。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;5. 虚拟 DOM&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;由于 Vue 是基于 &lt;span&gt;Snabbdom &lt;/span&gt;的轻量级虚拟 DOM 实现，因此 Vue 的性能有些许的提升。这是虚拟 DOM 的主要新功能之一，开发者可以直接进行更新。当你需要在实际的 DOM 中进行更改时，只需执行一次这样的更新功能。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;6. 基于 HTML 模板的语法  &lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Vue 允许开发者直接将渲染的 DOM 绑定到底层的Vue实例数据上。这是一个很有用的功能，因为它可以让开发者扩展基本的 HTML 元素，来保存可复用的代码。&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://angularjs.org/&quot; target=&quot;_blank&quot;&gt;Angular&lt;/a&gt; 是一个功能齐全的框架，支持 Model-View-Controller 编程结构，非常适合构建动态的单页网络应用程序。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;谷歌在2009年开发出了 Angular 并对其提供支持，Angular 包含一个基于标准 JavaScript 和 HTML 的 JS 代码库。Angular 设计的最初目的是作为一个使设计者能够与后端和前端进行交互的工具。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; 以下是 Angular 的部分最好的功能：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1. Model-View-ViewModel（MVVM）&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;为了构建客户端Web应用程序，Angular 将原始 MVC 软件设计模式背后的基本原理结合在一起。然而，Angular 没有实现传统意义上的 MVC，而是实现了  &lt;a href=&quot;https://dzone.com/articles/angularjs-tutorial-lesson-1&quot; target=&quot;_blank&quot;&gt;MVVM 即 Model-View-ViewModel 模式&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2. 依赖注入&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Angular 带有内置的依赖注入子系统功能，这使得应用程序易于开发和测试。依赖注入允许开发者通过请求来获得依赖关系，而不是搜索依赖关系。这对开发人员非常有帮助。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3. 测试&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在 Angular 中，可以单独对控制器和指令进行单元测试。Angular 允许开发人员进行端到端和单元测试运行器设置，这意味着也可以从用户角度进行测试。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4. 跨浏览器兼容&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Angular 的一个有趣功能是，框架中编写的应用程序在多个浏览器都能运行良好。Angular 可以自动处理每个浏览器所需的代码。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;5. 指令&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Angular 的&lt;a href=&quot;https://www.w3schools.com/angular/angular_directives.asp&quot; target=&quot;_blank&quot;&gt;指令（用于渲染指令的DOM模板）&lt;/a&gt;  可用于创建自定义的 HTML 标记。这些是 DOM 元素上的标记，因为开发者可以扩展指令词汇表并制作自己的指令，或将它们转换为可重用组件。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;6. Deep Linking&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;由于 Angular 主要用于制作单页应用程序，因此必须利用 Deep Linking 功能才能在同一页面上加载子模板。Deep Linking 的目的是为了查看位置 URL 并安排它映射到页面的当前状态。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Deep Linking 功能通过查看页面状态并将用户带到特定内容，而不是从主页中遍历应用程序来设置 URL。Deep Linking 允许所有主要搜索引擎，可以轻松的搜索网络应用程序。  &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;究竟哪个框架是最好的 - Angular 还是 Vue？下面我们通过以下几点来深入研究：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;学习曲线&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在学习曲线方面，Vue.js 的学习和理解相对简单，而 Angular 则需要时间去习惯。开发人员认为这两个框架对于项目来说都很棒，但开发者中的大多数人更喜欢使用 Vue，因为当将 Vuex 添加到项目中时，Vue 更加简单并且可以很好地扩展  。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;尽管 Vue 和 Angular 的一些语法类似，比如 API 和设计（这是因为 Vue 实际上是从 Angular 的早期开发阶段中获得启发的），但 Vue 一直致力于在一些对于 Angular 来说很困难的方面提升自己 。开发者可以在几个小时内用 Vue.js 构建一个特别的应用程序，但是这对 Angular 来说是不可能的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;灵活性&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Angular 是独立的，这意味着你的应用程序应该有一定的构造方式。Vue 则更加宽泛，Vue 为创建应用程序提供了模块化，灵活的解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;很多时候，Vue 被认为是一个库而不是框架。默认情况下，Vue 不包含路由器，HTTP 请求服务等。开发者必须安装所需的“插件”。Vue 非常灵活并且可以与大多数开发者想要使用的库兼容。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;不过，也有开发人员更喜欢 Angular，因为 Angular 为其应用程序的整体结构提供了支持。这有助于节省编码时间。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;文档对象模型（DOM）&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Vue 通过最少量的组件重新渲染，可以将模板预编译为纯 JavaScript。这个虚拟 DOM 允许进行大量的优化，这是 Vue 和 Angular 之间的主要区别。Vue 允许使用更简单的编程模型，而 Angular 则以跨浏览器兼容的方式操作 DOM。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;速度/性能&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;虽然 Angular 和 Vue 都提供了很高的性能，但由于 Vue 的虚拟 DOM 实现的重量较轻，所以可以说 Vue 的速度/性能略微领先。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;更简单的编程模型使 Vue 能够提供更好的性能。Vue 可以在没有构建系统的情况下使用，因为开发者可以将其包含在 HTML 文件中。这使得 Vue 易于使用，从而提高了性能。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Angular 可能会很慢的原因是它使用脏数据检查，这意味着 Angularmonitors 会持续查看变量是否有变化。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;双向数据绑定&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;这两个框架均支持双向数据绑定，但与 Vue.js 相比，Angular 的双向绑定更加复杂。Vue 中的双向数据绑定非常简单，而在 Angular 中，数据绑定更加简单。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如果你希望通过以最简单的方式来制作 Web 应用程序，那么你应该选择 Vue。如果你的 Javascript 基础不是太强大，或者有严格的开发截止日期，Vue 将是一个很好的选择。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如果你的前端是 Laravel，那么请选择 Vue。Laravel 社区的开发者认为 Vue 是他们最喜欢的框架。Vue 将总处理时间缩短了50％，并释放了服务器上的空间。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如果是开发小规模应用或者开发时不喜欢受约束，请选择Vue。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如果你很熟悉 ES5 Javascript 和 HTML，那么请使用 Vue 完成你的项目。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如果你想要在浏览器中编译模板并且使用其简单性，使用独立版本的Vue会很好。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如果你打算构建性能关键型SPA或需要功能范围的 CSS，Vue 的单文件组件会非常完美。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如果你需要构建大型复杂的应用程序，那么应该选择 Angular，因为 Angular 为客户端应用程序开发提供了一个完整而全面的解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;对于希望处理客户端和服务器端模式的开发人员来说，Angular 是一个不错的选择。开发人员喜欢 Angular 的主要原因是 Angular 能够使他们专注于任何类型的设计，无论是 jQuery 调用还是 DOM 配置干扰。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;对于开发人员创建具有多个组件和复杂需求的 Web 应用程序，Angular 也同样适用。当你选择Angular 时，本地开发人员会发现更容易理解应用程序功能和编码结构。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如果你想在新项目中选择现有组件，也可以选择 Angular，因为你只需复制和粘贴代码即可。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Angular 可以使用双向数据绑定功能来管理 DOM 和模型之间的同步。这使 Angular 成为了 Web 应用程序开发的强有力的工具。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;希望制作更轻更快的Web应用程序的开发人员可以利用 Angular 中的 MVC 结构和独立的逻辑和数据组件，这有助于加速开发过程。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;分析 Vue 和 Angular 的代码很有趣。包含标记，样式和行为的代码可以帮助开发者构建高效且可重用的接口。在 Angular 中，控制器和指令等实体包含在模块中，而 Vue 的模块中包含组件逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Vue &lt;/strong&gt;&lt;strong&gt;组件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  Vue.extend({ 
    data: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(){ &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {...} }, 
    created: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {...}, 
    ready: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {...}, 
    components: {...}, 
    methods: {...}, 
    watch: {...} 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(other props excluded) &lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Angular &lt;/strong&gt;&lt;strong&gt;模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
angular.module(‘myModule’, […]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Angular 中的 Directive 更加强大。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Vue &lt;/strong&gt;&lt;strong&gt;指令&lt;/strong&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Vue.directive('my-directive'&lt;span&gt;, {
       bind: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {...}, 
      update: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (newValue, oldValue) {...}, 
      unbind: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {...}
  });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Angular&lt;/strong&gt; &lt;strong&gt;指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
myModule.directive('directiveName', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (injectables) { 
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; { 
            restrict: &lt;/span&gt;'A'&lt;span&gt;, 
            template: &lt;/span&gt;'&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;'&lt;span&gt;, 
            controller: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() { ... },
             compile: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {...},
             link: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() { ... } 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(other props excluded) };&lt;/span&gt;
            });
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;由于 Vue.js 受 Angular 启发，也借用了 Angular 的模板语法。因此循环，这两个框架的插值和条件的语法都非常相似。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;下面给出代码片段：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Vue &lt;/strong&gt;&lt;strong&gt;插值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
{{myVariable}} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;角插值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
{{myVariable}}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Vue &lt;/strong&gt;&lt;strong&gt;循环&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;v-repeat&lt;/span&gt;&lt;span&gt;=&quot;items&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;item-{{$index}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{{myProperty}}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Angular &lt;/strong&gt;&lt;strong&gt;循环&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;ng-repeat&lt;/span&gt;&lt;span&gt;=&quot;item in items&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;item-{{$index}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; 
{{item.myProperty}}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Vue &lt;/strong&gt;&lt;strong&gt;条件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;myVar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-show&lt;/span&gt;&lt;span&gt;=&quot;myVar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;角度条件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ng-if&lt;/span&gt;&lt;span&gt;=&quot;myVar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ng-show&lt;/span&gt;&lt;span&gt;=&quot;myVar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Vue.js 的编码使得页面渲染变得非常简单。事实上，Vue.js 更像是一个库而不是框架，因为它不提供 Angular 的所有功能。开发者将不得不依赖 Vue.js 的第三方代码，而 Angular 提供了 HTTP 请求服务或路由器等功能。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2017年6月8日发布了 Vue.js &lt;a href=&quot;https://github.com/vuejs/vue/releases/tag/v2.3.4&quot; target=&quot;_blank&quot;&gt;v2.3.4&lt;/a&gt;的最新稳定版本 。在此版本之前，还有13个版本。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/angular/angular.js/releases/tag/v1.6.4&quot; target=&quot;_blank&quot;&gt;Angular 4&lt;/a&gt;  于2017年3月发布。早期版本为 Angular 1和2，没有 Angular 3。Angular 的第5版于2017年11月发布。第6版预计将于2018年3月发布，第7版预计将于2018年9月/ 10月发布。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Vue.js 是轻量级的开发框架，很适合开发小规模灵活的 Web 应用程序；而 Angular 尽管学习曲线较为陡峭，但却是构建完整复杂应用的好选择。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原文链接：https://dzone.com/articles/comparing-progressive-javascript-frameworks-angula&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;转载请注明出自：葡萄城控件&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/powertoolsteam/p/angular2_vs_angular4.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Angular2 VS Angular4 深度对比：特性、性能&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/powertoolsteam/p/angular_react.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Angular vs React 最全面深入对比&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/powertoolsteam/p/Angular_Wijmo.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;开放才能进步！Angular和Wijmo一起走过的日子&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 13 Mar 2018 03:31:00 +0000</pubDate>
<dc:creator>葡萄城控件技术团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/powertoolsteam/p/angular_vs_vue.html</dc:identifier>
</item>
<item>
<title>近期安卓与IOS招聘面试有感 - WangLei_ClearHeart</title>
<link>http://www.cnblogs.com/leipDao/p/8473959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leipDao/p/8473959.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、&lt;span&gt;&lt;span&gt;你总是想一步登天，却不知道路是一步步走出来的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;大概是放年假前一个月开始招聘吧，陆陆续续到目前为止安卓面试10几个，IOS面试了15个左右，本以为很好招聘的，没想到没有一个合适的，要求本不高只想基础扎实一些，但是就这一条基础扎实是真的难，一个Java多线程中wait()与sleep()区别，notify()与notifyAll()就没有说的特别清楚的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;面试这种印象比较深的有一个小姑娘，如下对话：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我：“安卓有过培训经历吗？”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;小姑娘：“没有”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我：“主要通过什么方式学习的啊？”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;小姑娘：“看书，找一些小Demo看源码学习，平时自己也写一写小Demo”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我：“哦，看些什么书籍？”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;小姑娘：“《深入理解JVM》”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我曹，吓我一跳，立马镇住我了，心想赶紧转移话题，这部分我可不太熟悉，虽然了解过，不过人家都深入了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我：“先问你几个简单的问题吧，说说String,Stringbuilder,StringBuffer有什么区别？”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;小姑娘：“噼里啪啦说了一顿，说的驴唇不对马嘴。。。。。。。”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我：“再问一个啊，安卓中事件传递机制熟悉吧，控件设置onTouch监听事件，返回true，&lt;span&gt;&lt;span&gt;onClick&lt;/span&gt;&lt;/span&gt;事件还会执行吗？返回false呢？”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;小姑娘的回答正好相反。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我：“记不清楚了吧，没关系，谈一下Serializable和Parcelable序列化的区别？”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;小姑娘：“这个不太清楚”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;后续又问了很多java基础的东西，基本没有一个回答的特别好，最后我鼓起勇气问那你说说你看的深入理解JVM吧。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;小姑娘：“JVM比较深，这部分我刚看，不是太了解”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;此刻的我，你应该知道是什么心情了，整体下来给我的感觉是基础及其不扎实，还要追求看似高大上的玩意，包括后来面试的都有这个问题，并且问题都是基础不扎实，为什么基础不扎实非要追求貌似高大上的技术，就为了面试的时候唬住面试官？殊不知你只是唬住你自己玩而已。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;曾经的我有一段时间也追求看似时髦的技术，研究之后发现无一例外都是由最基础的技术一点点演变而来，后来潜心把基础弄扎实，再看一些框架的东西就很好理解了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请静下心来先把基础学扎实，再想飞的多高，否则终有一天你会摔得很惨。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、再说培训&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;基本上我第一个问题都会问有没有培训班经历，我一点不鄙视培训班，我在乎的是持续学习能力，这个行业是需要有持续学习能力的，培训班出来的就没有持续学习能力吗？当然不是，培训班出来的也有很多工作特别出色的，一般如果不是计算机相关行业的学生是通过培训进入这个行业的我就会对其持续学习能力打上大大的问号？面试者中有几个不着边专业转到IT行业的，尤其一个哥们说对IOS特别感兴趣，本身是水利专业，基本上我问的很多基础性问题都没答上来，最后估计哥们受不了了说看这行业工资高才通过培训进入的，好吧，无语。。。。。。。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、你眼中的&quot;大神&quot;没那么神&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;技术行业总是充满各种大神，比如最传奇的大神：阿里的&quot;多隆&quot;。记得看一段采访有一句话印象深刻：“其实我一开始都不知道java是什么，就只好慢慢学，后来就全部搞懂了”大概意思是这样，人家口中的慢慢学是“多隆”大神至今带孩子去少年宫，闲暇时间都会拿出电脑解决问题。试问有几个能做到如此，在我们羡慕各种“大神”的时候，试着去了解一下别人背后的努力，也许你付出同样的努力，比你心中的“大神”更神。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、为什么你难以静下来潜心研究&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这个问题我思考了很久，直到合伙创业失败我似乎找到了我自己对这个问题的答案，先说答案：是现今社会大环境的问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从国内大环境来说，中国近10年的高速发展造就一批批富豪，还记得16年的“大众创业，万众创新”吗，没错，我那就那一批辞职合伙创业的分子之一，前几年充斥着各种一个APP融资几百万，几千万的新闻，各种培训机构大批培训相应&quot;人才&quot;，高薪就业家常便饭，我认识的几个大学学习文学，化学相关专业都去培训出来就1万+工资，试想这样一个环境，有几个安下心来潜心学习的？过年回家，发现我们那高利贷有点疯狂，有个亲戚借钱给高利贷机构自己就等着每月的利息，不上班了，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;周围人发现没什么问题，有钱的就很多这样操作的。让那些努力工作的人就觉得我努力工作一个月不如人家的利息，试想一下大部分人在那种环境下接下来会怎&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;么做？再比如去年的房地产行业，以上只是从大环境分析了一下，并不把责任推卸给社会等，我更觉得这也许是社会发展的一个必经阶段吧，希望在这个阶段有更多人能静下心来潜心研究。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;以上BB了一顿，有些观点也许和您的不同，可以交流，无需开喷，欢迎留言发表您的看法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 13 Mar 2018 02:09:00 +0000</pubDate>
<dc:creator>WangLei_ClearHeart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leipDao/p/8473959.html</dc:identifier>
</item>
<item>
<title>Nginx负载均衡——基础功能 - 米粒人生</title>
<link>http://www.cnblogs.com/minirice/p/8553778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minirice/p/8553778.html</guid>
<description>&lt;p&gt;熟悉Nginx的小伙伴都知道，Nginx是一个非常好的负载均衡器。除了用的非常普遍的Http负载均衡，Nginx还可以实现Email,FastCGI的负载均衡，甚至可以支持基于Tcp/UDP协议的各种应用的负载均衡(比如MySQL,DNS等)。这些功能分别在Nginx的不同模块实现了。负载均衡可以看成Nginx对外提供的一种服务。&lt;/p&gt;
&lt;p&gt;我们先来简单介绍下Nginx负载均衡的基本的功能。并且，我们在下面的介绍中会同时罗列Nginx Plus(Nginx的扩展板，部分功能收费)&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;在多个应用程序实例之间做负载平衡是一种常用的优化资源利用、最大化吞吐量、减少延迟和确保容错配置的技术。而使用Nginx可以作为一个高效的Http负载均衡器将流量分摊到各个服务器上，从而改善性能，增加扩展性和可靠性。&lt;/p&gt;
&lt;h2 id=&quot;简单配置&quot;&gt;简单配置&lt;/h2&gt;
&lt;p&gt;负载均衡的基本配置十分的简单，在基本配置上，你可以添加更多的指令来满足自己个性化的需求。&lt;br/&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http {
    upstream myapp1 {
        server srv1.example.com;
        server srv2.example.com;
        server srv3.example.com;
    }

    server {
        listen 80;

        location / {
            proxy_pass http://myapp1;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面，所有的请求都将被代理到服务器组myapp1上，myapp1上有三台服务器srv1-srv3，这三台服务器将要分摊请求。如果没有指定负载均衡方法，那么默认的方法是round-robin。&lt;br/&gt;在nginx中，HTTP，HTTPS，FastCGI，uwsgi，SCGI都可以做反向代理，并且可以做负载均衡，上面的例子是http的。要使用https的负载均衡，简单的将http改为https即可。&lt;/p&gt;
&lt;h2 id=&quot;负载均衡的常用算法&quot;&gt;负载均衡的常用算法&lt;/h2&gt;
&lt;p&gt;负载均衡的方法，&lt;br/&gt;就是Http请求如何被分配到各个服务器上的算法。常用的负载均衡的常用算法有以下种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Round‑Robin 默认的方法，也是最简单的一种。即Http请求按照服务器列表罗列的顺序一次进行分配；&lt;/li&gt;
&lt;li&gt;Least Connections 在这种方式下，每个请求被发送到当下具有最小有效连接数的服务器上，当然权重也会被考虑进去。比如当下有三台服务器A/B/C，当下各自的连接数是100/200/300，那么下一个请求过来就会被分配到A服务器进行处理&lt;/li&gt;
&lt;li&gt;Hash 用户定义一个Hash的Key值，比如IP或者URL，将这个Hash的Key和服务器做一次映射，每次请求过来都会按照这个映射被分配到同一台服务器&lt;/li&gt;
&lt;li&gt;IP Hash (仅适用于Http负载均衡的情况)，根据客户端IP的前三个字节(比如IP是10.25.2.10那么就拿10.25.2做映射)来分配请求，这个和上一种类似&lt;/li&gt;
&lt;li&gt;Least Time 即最少时间。新的请求将被发往拥有最快响应时间和最少连接数的上游服务器。这是Nginx Plus才具有的方式&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;最少连接算法&quot;&gt;最少连接算法&lt;/h2&gt;
&lt;p&gt;即Least Connections这种算法。最少连接，顾名思义，就是当下谁的连接数最少请求就然该谁来处理。这是一种相对公平的方式，防止某些服务器负载过重，将请求分配到相对“清闲”的服务器上去。基本的配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;upstream myapp1 {
        least_conn;
        server srv1.example.com;
        server srv2.example.com;
        server srv3.example.com;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要指定least_conn指令。&lt;/p&gt;
&lt;h2 id=&quot;session一致性问题&quot;&gt;Session一致性问题&lt;/h2&gt;
&lt;p&gt;如果负载均衡采用round-robin或者least-connected算法，同一个客户端发送过来的不同请求就有可能被不同的server处理，这种情形下就不能保证两次请求session的一致性。&lt;br/&gt;为了解决这个问题，可以采用第三种负载均衡的算法，那就是ip-hash。有了IP哈希，将客户端的IP和服务器组列表的几个服务器之间建立一种对应关系，那么每个客户端的每次请求就只能被分配到一台server上面，从而保证session的一致性。ip-hash的方式配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;upstream myapp1 {
    ip_hash;
    server srv1.example.com;
    server srv2.example.com;
    server srv3.example.com;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;负载均衡权重&quot;&gt;负载均衡权重&lt;/h2&gt;
&lt;p&gt;说是负载&quot;均衡&quot;，但是不是说每个server的分配的请求是完全一样。前面讨论的各个服务器组，里面的各个server其实是地位平等、利益均沾。事实上，由于每个server的特性可能不一样，有些server硬件条件好，稳定性高，理应多处理些请求，相反另一些不太稳定的server就应该适当的少分配请求。我们可以为这些server分配不同的权重，来定义它们在处理请求时所扮演角色的重要性。权重用指令weight来表示，权重高表示选择的几率更大，权重低表示选中的几率更小，权重为0表示始终不选用。以round-robin算法为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;upstream myapp1 {
        server srv1.example.com weight=3;
        server srv2.example.com;
        server srv3.example.com;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没有weight指令的默认其为1。如果有5个请求过来，理想情况下srv1就能接到3个，srv2和srv3各一个。&lt;/p&gt;
&lt;h2 id=&quot;服务器健康检查&quot;&gt;服务器健康检查&lt;/h2&gt;
&lt;p&gt;反向代理的各种实现(如http/https/FastCGI)还可以对各个server做健康检查。如果请求一个server错误(如返回500，究竟如何才为“失效”，在Nginx Plus中做了扩展)，nginx就将这个server标记为失效的，在接下来一段时间的请求中就会避免选择这台server。究竟这端时间要多长才合适？有max_fails和fail_timeout参数来定义。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;max_fails&lt;/code&gt;&lt;br/&gt;默认是1，表示在fail_timeout时间内，有多少次对某个server的访问失败，就算作这台server的正式失效(你总要给人家多表现几次的机会撒)，默认情况下就是1次；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;fail_timeout&lt;/code&gt;&lt;br/&gt;默认是10s，有两层含义，一就是为max_fails指令限定一个时间范围，二就是如果server已经被标记为失效，那么过了这个时间后，你就应该分配个请求去试探下这个server，是否已经可用了（你总的给人家重新做人的机会）。如果还是不可用，那么此server继续被标记为失效的server，如果已经可用了那么就重新标记为活跃，在接下来的请求中，继续按照round-robin/ip-hash等算法和权重给它分配请求，和平常无异。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了这些指令之外proxy_next_upstream, backup, down, 和 keepalive 也针对负载均衡功能做了不同的限定。&lt;/p&gt;
&lt;p&gt;以上这些功能是基本是Nginx的免费版本提供的，其实负载均衡里可以说的话题还多着呢。我们下篇文章中谈谈Nginx Plus提供的更为丰富的负载均衡的功能。&lt;/p&gt;
</description>
<pubDate>Tue, 13 Mar 2018 01:45:00 +0000</pubDate>
<dc:creator>米粒人生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minirice/p/8553778.html</dc:identifier>
</item>
</channel>
</rss>