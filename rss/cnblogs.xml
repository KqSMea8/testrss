<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于TCP协议的项目架构之Socket流传输的实现 - 我心自在</title>
<link>http://www.cnblogs.com/10158wsj/p/8215047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/10158wsj/p/8215047.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;项目背景&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　  &lt;/strong&gt;&lt;span&gt;某银行的影像平台由于使用时间长，服务器等配置原因，老影像系统满足不了现在日益增长的数据量的需求，所以急需要升级改造。传统的影像平台使用的是Oracle数据库和简单的架构来存储数据（视频、图片等），所以很难满足现在的业务需求，其中最主要的就是存储下载等速度的影响，综合考虑之后，我们给出了升级改造方案，基于Http协议的数据传输和基于TCP协议的数据传输，按照行方的要求需要用TCP协议，我们最终采用的是Socket网络传输的方案。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;TCP&lt;/strong&gt;&lt;strong&gt;协议介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，TCP层位于IP层之上，应用层之下的中间层，不同主机的应用层之间经常需要可靠的、像管道一样的连接，但IP层不需要提供这样的机制，而是提供不可靠的包交换。当应用层向TCP层发送用于网间传输的、用8位字节标示的数据流，TCP会把数据流分割为适当长度的报文段，之后TCP把数据包传给IP层，由它来通过网络将包传输给接收端的实体TCP层。TCP是因特网中的传输层协议，使用3次握手协议建立连接。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Socket&lt;/h2&gt;
&lt;p&gt;        &lt;span&gt;TCP通信是严格区分客户端与服务端的，在通信时，必须先由客户端去连接服务器才能实现通信，服务器端不可以主动连接客户端，并且服务器要事先启动，等待客户端的连接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        在JDK中提供了两个类用于实现TCP程序，一个是ServerSocket类，用于表示服务器，一个是Socket类，用于表示客户端。通信时，首先创建代表服务器端的ServerSocket对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的Socket对象向服务器端发出连接请求，服务器端响应请求，两者建立连接，开始通信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        下面是我们通过Socket建立的模型，是多线程的，首先看服务端代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * socket服务端
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 我心自在
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Log logger=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程池&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService executor =&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 静态块，初始化
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        logger&lt;/span&gt;=LogFactory.getLog(SocketMain.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程池&lt;/span&gt;
        executor = Executors.newFixedThreadPool(Integer.parseInt(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertiesUtil().
                getProperties(&lt;/span&gt;&quot;config.properties&quot;).getProperty(&quot;UserThreads&quot;&lt;span&gt;)));
        }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 主程序入口
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ServerSocket server &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Socket socket &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        PropertiesUtil PropertiesUtil &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertiesUtil();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动Socket服务端&lt;/span&gt;
    server=newServerSocket(Integer.parseInt(PropertiesUtil.getProperties(&quot;config.properties&quot;&lt;span&gt;)
                    .getProperty(&lt;/span&gt;&quot;port&quot;&lt;span&gt;)));
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多线程接收客户端请求&lt;/span&gt;
                socket =&lt;span&gt; server.accept();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (socket != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    executor.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Controller(socket));
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            logger.error(&lt;/span&gt;&quot;Main IO异常：&quot;+&lt;span&gt;e.getMessage(),e);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (server != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    server.close();
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (socket != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    socket.close();
                }
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                logger.error(&lt;/span&gt;&quot;Main流关闭异常：&quot;+&lt;span&gt;e.getMessage(),e);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面是业务处理类，支持多线程，主要用来处理业务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SocketController &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Socket socket;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Log logger=LogFactory.getLog(SocketController.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SocketController(Socket socket) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.socket =&lt;span&gt; socket;
    }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取文件流&lt;/span&gt;
        String requestMethod=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Map&lt;/span&gt;&amp;lt;String,Object&amp;gt; getMethAndNumMap=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Map&lt;/span&gt;&amp;lt;String,Object&amp;gt; jsonMap=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        BufferedInputStream  bis &lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;; 
        OutputStream ops &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        BufferedWriter bw &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        BufferedOutputStream bos &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Document doc&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String XMLString&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            bis&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedInputStream (socket.getInputStream());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取输出流&lt;/span&gt;
            ops =&lt;span&gt; socket.getOutputStream();
            bos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedOutputStream(ops);
            bw &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedWriter(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OutputStreamWriter(ops));
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] fileinfo=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[256&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                bis.read(fileinfo);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e1){
                logger.error(&lt;/span&gt;&quot;流读取异常....&quot;+&lt;span&gt;e1.getMessage(),e1);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(fileinfo!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                fileInfoString&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(fileinfo).trim();
            }
            jsonMap&lt;/span&gt;=&lt;span&gt;JSONUtil.jsonToMap(fileInfoString);
            requestMethod&lt;/span&gt;=(String) jsonMap.get(&quot;requestMethod&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(requestMethod==&lt;span&gt;null&lt;/span&gt;||&quot;&quot;&lt;span&gt;.equals(requestMethod))) {
                    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (requestMethod){ 
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;login&quot;&lt;span&gt;:
                        Login.login(XMLString,bw,doc);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;登录接口&lt;/span&gt;
                        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;XXXX&quot;&lt;span&gt;:
                        XXX.xxx();
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求方法错误&lt;/span&gt;
&lt;span&gt;
                    }
                }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnknownHostException e) {
            logger.error(&lt;/span&gt;&quot;Socket未知端口：&quot;+&lt;span&gt;e.getMessage(),e);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            logger.error(&lt;/span&gt;&quot;Controller读流流异常：&quot;+&lt;span&gt;e.getMessage(),e);
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bw!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    bw.flush();
                    bw.close();
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ops!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    ops.close();
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bos!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    bos.close();
                }
                bis.close();
                socket.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                logger.error(&lt;/span&gt;&quot;socket关闭异常：&quot;+&lt;span&gt;e.getMessage(),e);
            }
        }
    }
        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;这里只贴出了部分代码，做个参考，基本思想就是，通过输入流接到客户端发送过来的报文，然后进行解析，为什么统一用字节流接受呢，因为我们的文件上传分两部分，一部分是文件信息，一部分是文件流，所以为了方便，统一使用字节流接收，根据字节流中的请求接口方法，调用对应的接口方法，完成业务处理。因为客户端的报文有两种，一种是XML类型的报文，另外一种是json格式的报文，这里只贴出了部分json格式的代码。差的只是一个XML的解析，解析方式很多，就不再赘述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是客户端代码，以登录为例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoginTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        String xml &lt;/span&gt;= 
                &quot;&amp;lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&amp;gt;&quot;
                    + &quot;&amp;lt;root&amp;gt;&quot;
                        + &quot;&amp;lt;requestMethod&amp;gt;login&amp;lt;/requestMethod&amp;gt;&quot;
                        + &quot;&amp;lt;userinfo&amp;gt;&quot;
                            + &quot;&amp;lt;loginname&amp;gt;test&amp;lt;/loginname&amp;gt;&quot;    
                            + &quot;&amp;lt;passwd&amp;gt;dmd1dnZndXY=&amp;lt;/passwd&amp;gt;&quot;
                        + &quot;&amp;lt;/userinfo&amp;gt;&quot;    
                    + &quot;&amp;lt;/root&amp;gt;&quot;&lt;span&gt;;
        Socket socket&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        BufferedWriter bw&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        BufferedReader br&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            socket&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Socket(&lt;span&gt;new&lt;/span&gt; ConfigUtil().getValue(&quot;ipAddress&quot;&lt;span&gt;), 
                    Integer.parseInt(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ConfigUtil().getValue(&quot;port&quot;&lt;span&gt;)));
            bw&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; BufferedWriter(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OutputStreamWriter(socket.getOutputStream()));
            bw.write(xml);
            bw.newLine();
            bw.flush();
            br&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(socket.getInputStream()));
            System.out.println(&lt;/span&gt;&quot;服务器返回报文：&quot;+&lt;span&gt;br.readLine());
            bw.close();
            br.close();
            socket.close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnknownHostException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }
    }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;客户端代码非常简单，基本就是以流的形式发送报文，发送到客户端，完成请求，收到服务器响应后，关闭连接，完成一次请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以上只是一个简单的Socket通信模型，具体项目中涉及到很多内容，这里无法一一列举。大致思路我们就是通过Socket通信，获取客户端发送过来的报文，然后对报文进行解析，根据请求方法，调用不同的业务接口，处理不同的业务，我们的业务包括对影像资料的增删改查，文件根据不同的大小存在大数据集群中，小文件存入Hbase，大文件存入HDFS，然后根据不同的场景去查询删除或者更新。这里边涉及到的存索引，用到了Elasticsearch5.4，用来做高级检索查询。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Jan 2018 14:42:00 +0000</pubDate>
<dc:creator>我心自在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/10158wsj/p/8215047.html</dc:identifier>
</item>
<item>
<title>用 Identity Server 4 (JWKS 端点和 RS256 算法) 来保护 Python web api - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/8270677.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/8270677.html</guid>
<description>&lt;p&gt;目前正在使用asp.net core 2.0 (主要是web api)做一个项目, 其中一部分功能需要使用js客户端调用python的pandas, 所以需要建立一个python 的 rest api, 我暂时选用了hug, 官网在这: &lt;a href=&quot;http://www.hug.rest/&quot; target=&quot;_blank&quot;&gt;http://www.hug.rest/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;目前项目使用的是identity server 4, 还有一些web api和js client.&lt;/p&gt;
&lt;p&gt;项目的早期后台源码: &lt;a href=&quot;https://github.com/solenovex/asp.net-core-2.0-web-api-boilerplate&quot; target=&quot;_blank&quot;&gt;https://github.com/solenovex/asp.net-core-2.0-web-api-boilerplate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面开始配置identity server 4, 我使用的是windows.&lt;/p&gt;

&lt;p&gt;在 authorization server项目中的配置文件添加红色部分, 这部分就是python hug 的 api:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;ApiResource&amp;gt;&lt;span&gt; GetApiResources()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;ApiResource&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApiResource(SalesApiSettings.ApiName, SalesApiSettings.ApiDisplayName) {
                    UserClaims &lt;/span&gt;=&lt;span&gt; { JwtClaimTypes.Name, JwtClaimTypes.PreferredUserName, JwtClaimTypes.Email }
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;purchaseapi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;采购和原料库API&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
                    UserClaims &lt;/span&gt;=&lt;span&gt; { JwtClaimTypes.Name, JwtClaimTypes.PreferredUserName, JwtClaimTypes.Email }
                },
                &lt;/span&gt;&lt;span&gt;new ApiResource(&quot;hugapi&quot;, &quot;Hug API&quot;) {
                    UserClaims =&lt;/span&gt;&lt;span&gt;&lt;span&gt; { JwtClaimTypes.Name, JwtClaimTypes.PreferredUserName, JwtClaimTypes.Email }
                }&lt;/span&gt;
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sales JavaScript Client&lt;/span&gt;
                &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;=&lt;span&gt; SalesApiSettings.ClientId,
                    ClientName &lt;/span&gt;=&lt;span&gt; SalesApiSettings.ClientName,
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.Implicit,
                    AllowAccessTokensViaBrowser &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    AccessTokenLifetime &lt;/span&gt;= &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,
                    AllowOfflineAccess &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    RedirectUris &lt;/span&gt;=           { $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Startup.Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;MLH:SalesApi:ClientBase&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}/login-callback&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Startup.Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;MLH:SalesApi:ClientBase&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}/silent-renew.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    PostLogoutRedirectUris &lt;/span&gt;= { Startup.Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MLH:SalesApi:ClientBase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] },
                    AllowedCorsOrigins &lt;/span&gt;=     { Startup.Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MLH:SalesApi:ClientBase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] },
                    AlwaysIncludeUserClaimsInIdToken &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    AllowedScopes &lt;/span&gt;=&lt;span&gt;
                    {
                        IdentityServerConstants.StandardScopes.OpenId,
                        IdentityServerConstants.StandardScopes.Profile,
                        IdentityServerConstants.StandardScopes.Email,
                        SalesApiSettings.ApiName,
                        &lt;/span&gt;&lt;span&gt;&quot;hugapi&quot;&lt;/span&gt;&lt;span&gt;
                    }
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;添加 hugapi, 与authorization server配置对应.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
        authority: &lt;/span&gt;'http://localhost:5000'&lt;span&gt;,
        client_id: &lt;/span&gt;'sales'&lt;span&gt;,
        redirect_uri: &lt;/span&gt;'http://localhost:4200/login-callback'&lt;span&gt;,
        response_type: &lt;/span&gt;'id_token token'&lt;span&gt;,
        scope: &lt;/span&gt;'openid profile salesapi &lt;span&gt;hugapi&lt;/span&gt; email'&lt;span&gt;,
        post_logout_redirect_uri: &lt;/span&gt;'http://localhost:4200'&lt;span&gt;,

        silent_redirect_uri: &lt;/span&gt;'http://localhost:4200/silent-renew.html'&lt;span&gt;,
        automaticSilentRenew: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        accessTokenExpiringNotificationTime: &lt;/span&gt;4&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; silentRequestTimeout:10000,&lt;/span&gt;
        userStore: &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebStorageStateStore({ store: window.localStorage })
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;(可选) 安装virtualenv:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip install virtualenv
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在某个地方建立一个目录:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mkdir hugapi &amp;amp;&amp;amp; cd hugapi
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建立虚拟环境:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
virtualenv venv
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;激活虚拟环境:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
venv\Scripts\activate
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后大约这样显示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201801/986268-20180111210921019-2038418755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装hug:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip install hug
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时, 参考一下hug的文档. 然后建立一个简单的api. 建立文件main.py:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; hug

@hug.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; root():
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Welcome home!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
hug -f main.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果好用:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201801/986268-20180111211520144-212249182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后还需要安装这些:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip install cryptography pyjwt hug_middleware_cors
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中pyjwt是一个可以encode和decode JWT的库, 如果使用RS256算法的话, 还需要安装cryptography. &lt;/p&gt;
&lt;p&gt;而hug_middleware_cors是hug的一个跨域访问中间件(因为js客户端和这个api不是在同一个域名下).&lt;/p&gt;
&lt;p&gt;添加需要的引用:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; hug
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; jwt
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; jwt.algorithms &lt;span&gt;import&lt;/span&gt;&lt;span&gt; get_default_algorithms
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; hug_middleware_cors &lt;span&gt;import&lt;/span&gt; CORSMiddleware
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后正确的做法是通过Authorization Server的discovery endpoint来找到jwks_uri,&lt;/p&gt;
&lt;p&gt;identity server 4 的discovery endpoint的地址是:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:5000/.well-known/openid-configuration&quot; target=&quot;_blank&quot;&gt;http://localhost:5000/.well-known/openid-configuration&lt;/a&gt;, 里面能找到各种节点和信息:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201801/986268-20180111213116847-1816235446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但我还是直接写死这个jwks_uri吧:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
response = urllib.request.urlopen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost:5000/.well-known/openid-configuration/jwks&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
still_json &lt;/span&gt;= json.dumps(json.loads(response.read())[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;keys&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][0])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;identity server 4的jwks_uri, 里面是public key, 它的结构是这样的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201801/986268-20180111212418676-1175973269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而我使用jwt库, 的参数只能传入一个证书的json, 也可就是keys[0].&lt;/p&gt;
&lt;p&gt;所以上面的最后一行代码显得有点.......&lt;/p&gt;
&lt;p&gt;如果使用python-jose这个库会更简单一些, 但是在我windows电脑上总是安装失败, 所以还是凑合用pyjwt吧.&lt;/p&gt;
&lt;p&gt;然后让hug api使用cors中间件:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
api = hug.API(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
api.http.add_middleware(CORSMiddleware(api))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后是hug的authentication部分:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; token_verify(token):
    token &lt;/span&gt;= token.replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bearer &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
    rsa &lt;/span&gt;= get_default_algorithms()[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RS256&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    cert &lt;/span&gt;=&lt;span&gt; rsa.from_jwk(still_json)
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        result &lt;/span&gt;= jwt.decode(token, cert, algorithms=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RS256&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], audience=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hugapi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; jwt.DecodeError:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; False

token_key_authentication &lt;/span&gt;= hug.authentication.token(token_verify)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过rsa.from_jwk(json) 就会得到key (certificate), 然后通过jwt.decode方法可以把token进行验证并decode, 算法是RS256, 这个方法要求如果token里面包含了aud, 那么方法就需要要指定audience, 也就是hugapi.&lt;/p&gt;
&lt;p&gt;最后修改api 方法, 加上验证:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@hug.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, requires=&lt;span&gt;token_key_authentication)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; root():
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Welcome home!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后运行 hug api:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
hug &lt;span&gt;-f&lt;/span&gt; main.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;端口应该是8000.&lt;/p&gt;
&lt;p&gt;运行js客户端,登陆, 并调用这个hug api http://localhost:8000/home:&lt;/p&gt;
&lt;p&gt;(我的js客户端是angular5的, 这个没法开源, 公司财产, 不过配置oidc-client还是很简单的, 使用)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201801/986268-20180111213407676-75532577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;返回200, 内容是: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201801/986268-20180111213443051-377576137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看一下hug的log:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201801/986268-20180111213532519-1875115961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;token被正确验证并解析了. 所以可以进入root方法了.&lt;/p&gt;

&lt;p&gt;其他的python api框架, 都是同样的道理.&lt;/p&gt;
&lt;p&gt;可以使用这个例子自行搭建 &lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4.Samples/tree/release/Quickstarts/7_JavaScriptClient&quot; target=&quot;_blank&quot;&gt;https://github.com/IdentityServer/IdentityServer4.Samples/tree/release/Quickstarts/7_JavaScriptClient &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方还有一个nodejs api的例子: &lt;a href=&quot;https://github.com/lyphtec/idsvr4-node-jwks&quot; target=&quot;_blank&quot;&gt;https://github.com/lyphtec/idsvr4-node-jwks&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Jan 2018 13:44:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/8270677.html</dc:identifier>
</item>
<item>
<title>2017 年的 人生 hard 模式终于结束了，2018年回归初心 - SmallW</title>
<link>http://www.cnblogs.com/erbingbing/p/8269602.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erbingbing/p/8269602.html</guid>
<description>&lt;h3 id=&quot;年的-人生-hard-模式终于结束了2018年回归初心&quot;&gt;2017 年的 人生 hard 模式终于结束了，2018年回归初心&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;2017年对于我个人来讲， 毫不夸张的说 算是近十年来除了高考那一年，最最惊心动魄的一年了，没有之一。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;开篇&quot;&gt;》》》开篇 :&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;2017年年底的时候，朋友圈中 18岁的晒照片风，想想自己也已经毕业三年有余，这三年多的 职业发展，人生过渡，人情来往等等。在2017年这一年中也都算是有了一个全新的体验和心得，笔者会在后面的文章中描写清楚。


话说这一年中经历了，跳槽、跳槽失败、猎头、再次面试、试用期、买房、贷款... 由于这些事情的出现的时间线上的高度重合。 身心上来说都是无比巨累的，上面说到的每一件事情 都可以大说特说一天一夜。 太过于曲折，以至于到了难受的地步。好在，经历了这些起起伏伏反而觉得内心开阔了很多，也是看开了很多。

从一个 道系少年  转变成 佛系大叔&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;跳槽&quot;&gt;》》》跳槽 :&lt;/h4&gt;
&lt;p&gt;记一次失败跳槽经历后有感，写给年轻的朋友，希望少走弯路。&lt;/p&gt;
&lt;p&gt;跳槽 这个 事情 对于很多人来说 特别是程序员 都是 万年不变的话题，因为在这个时代里面，跳槽无疑是涨工资来的最快的渠道没有之一。因为在一家正常的公司里面虽然会有阳光普照的机会，但是那也只是当前薪资的 5% 左右的上浮，根本抵不上房贷利率上浮啊！&lt;/p&gt;
&lt;p&gt;Tips : 为什么说是这个 时代，因为我之前跳槽的时候我爸妈都会问我最近在哪家公司。 可能给他们的影响就是我每个月都在跳槽一样。。。 不过也没办法，在他们那代人眼里，一份稳定的体制内的工作比什么都体面，但是当下的这个时代不学习，不变通。不跳槽都很难有一个较高的薪资（这个是我在 2017年 年初的时候的看法，但是下接下来的几个月里就彻底改变了我对于跳槽这个事情的整个看法）&lt;/p&gt;
&lt;p&gt;Tips : 记住这里的正常是指 公司里面有条款会告诉你，我们每个年 几月份 会有一次阳光普照的 工资普涨。至于不正常的公司那就太多了，根本就不会有涨工资的机会，除非呆的时间久了，自己主动去和 leader 去谈涨薪，否则根本不会有涨薪的。&lt;/p&gt;
&lt;p&gt;好，上面说到了那么多的废话，我们回归跳槽的正题，那么问题来了 :&lt;/p&gt;
&lt;p&gt;1）我为什么要跳槽？&lt;br/&gt;2）如何跳槽？&lt;br/&gt;3）跳槽之后会开心么？&lt;br/&gt;4）跳槽失败以后怎么办？&lt;/p&gt;
&lt;h5 id=&quot;我为什么要跳槽&quot;&gt;1）我为什么要跳槽？&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;1）我为什么跳槽？  每当自己内心有这个想法的时候，一定要问自己这个问题，我为什么要跳槽？
我们总结一下 跳槽的几个主要原因： 
    a) 觉得薪资不够  
    b) 觉得公司发展前途不明朗（可能发不出工资）
    c) 想去做大事情，而现公司无法满足自己的报复
    d) 觉得自己的 leader、上司、boss 是傻逼
    e) 换城市发展
    f) 想去BTA 等一线大厂拓展视野

以上就是 总结出来的 跳槽的几大原因，往往 涉及到 money and feeling 的原因 占到了绝大部分。

再问问自己 为什么要跳槽？  是不是到了 非跳不可的地步？

为什么笔者 重复问这个问题， 因为很多同学其实并没有一个明确的 职业规划，走哪儿打哪儿，很乱。

笔者之前就是这样子，但是在 遭遇了 失败的经历之后，都是血的教训教育了自己。 下面一个章节就会介绍到这里。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;跳槽-失败&quot;&gt;》》》跳槽 失败 :&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;记第一次 失败的跳槽经历： 

起因： 2017年3月份 开年的时候，公司开始了不正常的裁员。 一个创业公司开始裁员是一个很难判断的事情，但是八九不离十就是 公司融资出现了问题， 必须要通过裁员来保证公司正常的资金链运转。

当时我们组就被划分了一个 裁员名额，然后最近入职的一位新同事就被 裁掉了，公司也是赔了 N + 1

经历了这个，觉得公司的发展前景不明朗，再加上笔者当初来深圳的主要一个原因是想着能够进 鹅厂。

于是乎， 就投了 鹅厂简历并向老东家递出了辞呈。 然后就是准备 鹅厂的面试。当接到来自鹅厂的面试邀请电话的时候内心还是非常激动了，感觉这是离自己梦想最近的一次~

然后就和 鹅厂的 HR 通过电话进行 面试时间预约，鹅厂面试时间还是比较人性化的，一般都会安排在下班时间，可能HR 也深知大家跳槽都不容易，所以就安排在了下班时间。

第一面是 用人小组的组长面试，技术面。  基础部分很多~ 但是不会的地方面试官也会给出思路引导，很好的面试体验。

第二面是 那个小组组长的 经理。 然后还是技术面。基础部分不会过问很多往往就是 很发散性质的 问题，算法等等

第三面是 一个 鹅厂 T4 的大神。 基本上也是会问到技术，但是更多层面的是 会问到你关于这个行业的认知， 技术行业也好，你所面试的小组所做的业务 行业也罢，都会问到。

第四面  终极HR面。 注意为什么要用终极这个词语，因为Hr 具备一票否决权。 笔者也就是挂在了这位资深HR 手里了， 最后因为加了面试官的微信 通过微信而得知， HR 认为我跳槽太过频繁，不太稳定 而 否决了我。  内心还是比较难受~

经历了上面这波操作，小伙伴儿们 是否还会觉得频繁跳槽是涨薪资的最佳渠道？&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;好了今天先写到这里-先回家晚上再继续&quot;&gt;好了，今天先写到这里~ 先回家，晚上再继续~&lt;/h5&gt;
</description>
<pubDate>Thu, 11 Jan 2018 12:34:00 +0000</pubDate>
<dc:creator>SmallW</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/erbingbing/p/8269602.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core Web API下事件驱动型架构的实现（二）：事件处理器中对象生命周期的管理 - dax.net</title>
<link>http://www.cnblogs.com/daxnet/p/8270480.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daxnet/p/8270480.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;http://www.cnblogs.com/daxnet/p/8082694.html&quot; target=&quot;_blank&quot;&gt;上文&lt;/a&gt;中，我介绍了事件驱动型架构的一种简单的实现，并演示了一个完整的事件派发、订阅和处理的流程。这种实现太简单了，百十行代码就展示了一个基本工作原理。然而，要将这样的解决方案运用到实际生产环境，还有很长的路要走。今天，我们就研究一下在事件处理器中，对象生命周期的管理问题。&lt;/p&gt;
&lt;p&gt;事实上，不仅仅是在事件处理器中，我们需要关心对象的生命周期，在整个ASP.NET Core Web API的应用程序里，我们需要理解并仔细推敲被注册到IoC容器中的服务，它们的生命周期应该是个怎样的情形，这也是服务端应用程序设计必须认真考虑的内容。因为如果生命周期管理不合理，程序申请的资源无法合理释放，最后便会带来内存泄漏、程序崩溃等各种问题，然而这样的问题对于服务端应用程序来说，是非常严重的。&lt;/p&gt;
&lt;p&gt;记得在上一篇文章的结束部分，我给大家留下一个练习，就是让大家在CustomerCreatedEventHandler事件处理器的HandleAsync方法中，填入自己的代码，以便对获得的事件消息做进一步的处理。作为本文的引子，我们首先将这部分工作做完，然后再进一步分析生命周期的问题。&lt;/p&gt;

&lt;p&gt;Event Store是CQRS体系结构模式中最为重要的一个组成部分，它的主要职责就是保存发生于领域模型中的领域事件，并对事件数据进行归档。当仓储需要获取领域模型对象时，Event Store也会配合快照数据库一起，根据领域事件的发生顺序，逐步回放并重塑领域模型对象。事实上，Event Store的实现是非常复杂的，虽然从它的职责上来看并不算太复杂，然而它所需要解决的事件同步、快照、性能、消息派发等问题，使得CQRS体系结构的实现变得非常复杂。在实际应用中，已经有一些比较成熟的框架和工具集，能够帮助我们在CQRS中很方便地实现Event Store，比如GetEventStore就是一个很好的开源Event Store框架，它是基于.NET开发的，在微软官方的&lt;a href=&quot;https://github.com/dotnet-architecture/eShopOnContainers&quot; target=&quot;_blank&quot;&gt;eShopOnContainers&lt;/a&gt;说明文档中，也提到了这个框架，推荐大家上他们的官网（&lt;a title=&quot;https://eventstore.org/&quot; href=&quot;https://eventstore.org/&quot;&gt;https://eventstore.org/&lt;/a&gt;）了解一下。在这里我们就先不深入研究Event Store应该如何实现，我们先做一个简单的Event Store，以便展示我们需要讨论的问题。&lt;/p&gt;
&lt;p&gt;延续着上一版的代码库（&lt;a title=&quot;https://github.com/daxnet/edasample/tree/chapter_1&quot; href=&quot;https://github.com/daxnet/edasample/tree/chapter_1&quot;&gt;https://github.com/daxnet/edasample/tree/chapter_1&lt;/a&gt;），我们首先在EdaSample.Common.Events命名空间下，定义一个IEventStore的接口，这个接口非常简单，仅仅包含一个保存事件的方法，代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp;&quot;&gt;
public interface IEventStore : IDisposable
{
    Task SaveEventAsync&amp;lt;TEvent&amp;gt;(TEvent @event)
        where TEvent : IEvent;
}
&lt;/pre&gt;
&lt;p&gt;SaveEventAsync方法仅有一个参数：由泛型类型TEvent绑定的@event对象。泛型约束表示SaveEventAsync方法仅能接受IEvent接口及其实现类型的对象作为参数传入。接口定义好了，下一步就是实现这个接口，对传入的事件对象进行保存。为了实现过程的简单，我们使用Dapper，将事件数据保存到SQL Server数据库中，来模拟Event Store对事件的保存操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Note：为什么IEventStore接口的SaveEventAsync方法签名中，没有CancellationToken参数？严格来说，支持async/await异步编程模型的方法定义上，是需要带上CancellationToken参数的，以便调用方请求取消操作的时候，方法内部可以根据情况对操作进行取消。然而有些情况下取消操作并不是那么合理，或者方法内部所使用的API并没有提供更深层的取消支持，因此也就没有必要在方法定义上增加CancellationToken参数。在此处，为了保证接口的简单，没有引入CancellationToken的参数。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们实现这个接口，并用Dapper将事件数据保存到SQL Server中。出于框架设计的考虑，我们新建一个Net Standard Class Library项目，在这个新的项目中实现IEventStore接口，这么做的原因已经在上文中介绍过了。代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp;&quot;&gt;
public class DapperEventStore : IEventStore
{
    private readonly string connectionString;

    public DapperEventStore(string connectionString)
    {
        this.connectionString = connectionString;
    }

    public async Task SaveEventAsync&amp;lt;TEvent&amp;gt;(TEvent @event) where TEvent : IEvent
    {
        const string sql = @&quot;INSERT INTO [dbo].[Events] 
([EventId], [EventPayload], [EventTimestamp]) 
VALUES 
(@eventId, @eventPayload, @eventTimestamp)&quot;;
        using (var connection = new SqlConnection(this.connectionString))
        {
            await connection.ExecuteAsync(sql, new
            {
                eventId = @event.Id,
                eventPayload = JsonConvert.SerializeObject(@event),
                eventTimestamp = @event.Timestamp
            });
        }
    }

    #region IDisposable Support
    // 此处省略
    #endregion
}
&lt;/pre&gt;
&lt;p&gt;IDisposable接口的实现部分暂且省略，可以看到，实现还是非常简单的：通过构造函数传入数据库的连接字符串，在SaveEventAsyc方法中，基于SqlConnection对象执行Dapper的扩展方法来完成事件数据的保存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Note: 此处使用了JsonConvert.SerializeObject方法来序列化事件对象，也就意味着DapperEventStore程序集需要依赖Newtonsoft.Json程序集。虽然在我们此处的案例中不会有什么影响，但这样做会造成DapperEventStore对Newtonsoft.Json的强依赖，这样的依赖关系不仅让DapperEventStore变得不可测试，而且Newtonsoft.Json将来未知的变化，也会影响到DapperEventStore，带来一些不确定性和维护性问题。更好的做法是，引入一个IMessageSerializer接口，在另一个新的程序集中使用Newtonsoft.Json来实现这个接口，同时仅让DapperEventStore依赖IMessageSerializer，并在应用程序启动时，将Newtonsoft.Json的实现注册到IoC容器中。此时，IMessageSerializer可以被Mock，DapperEventStore就变得可测试了；另一方面，由于只有那个新的程序集会依赖Newtonsoft.Json，因此，Newtonsoft.Json的变化也仅仅会影响那个新的程序集，不会对框架主体的其它部分造成任何影响。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;EventStore实现好了，接下来，我们将其用在CustomerCreatedEventHandler中，以便将订阅的CustomerCreatedEvent保存下来。&lt;/p&gt;

&lt;p&gt;保存事件数据的第一步，就是在ASP.NET Core Web API的IoC容器中，将DapperEventStore注册进去。这一步是非常简单的，只需要在Startup.cs的ConfigureServices方法中完成即可。代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [6];&quot;&gt;
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();

    services.AddTransient&amp;lt;IEventHandler, CustomerCreatedEventHandler&amp;gt;();
    services.AddTransient&amp;lt;IEventStore&amp;gt;(serviceProvider =&amp;gt; new DapperEventStore(Configuration[&quot;mssql:connectionString&quot;]));
    services.AddSingleton&amp;lt;IEventBus, PassThroughEventBus&amp;gt;();
}
&lt;/pre&gt;
&lt;p&gt;注意我们使用的是services.AddTransient方法来注册DapperEventStore，我们希望应用程序在每次请求IEventStore实例时，都能获得一个新的DapperEventStore的实例。&lt;/p&gt;
&lt;p&gt;接下来，打开CustomerCreatedEventHandler.cs文件，在构造函数中加入对IEventStore的依赖，然后修改HandleAsync方法，在该方法中使用IEventStore的实例来完成事件数据的保存。代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [3,7,15];&quot;&gt;
public class CustomerCreatedEventHandler : IEventHandler&amp;lt;CustomerCreatedEvent&amp;gt;
{
    private readonly IEventStore eventStore;

    public CustomerCreatedEventHandler(IEventStore eventStore)
    {
        this.eventStore = eventStore;
    }

    public bool CanHandle(IEvent @event)
        =&amp;gt; @event.GetType().Equals(typeof(CustomerCreatedEvent));

    public async Task&amp;lt;bool&amp;gt; HandleAsync(CustomerCreatedEvent @event, CancellationToken cancellationToken = default)
    {
        await this.eventStore.SaveEventAsync(@event);
        return true;
    }

    public Task&amp;lt;bool&amp;gt; HandleAsync(IEvent @event, CancellationToken cancellationToken = default)
        =&amp;gt; CanHandle(@event) ? HandleAsync((CustomerCreatedEvent)@event, cancellationToken) : Task.FromResult(false);
}
&lt;/pre&gt;
&lt;p&gt;OK，代码修改完毕，测试一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201801/119825-20180111203227566-1357400818.png&quot;&gt;&lt;img width=&quot;982&quot; height=&quot;156&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2017.cnblogs.com/blog/119825/201801/119825-20180111203227801-1750158673.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看看数据库中客户信息是否已经创建：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201801/119825-20180111203227988-1297760314.png&quot;&gt;&lt;img width=&quot;500&quot; height=&quot;215&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2017.cnblogs.com/blog/119825/201801/119825-20180111203228191-1925462763.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看看数据库中事件数据是否已经保存成功：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201801/119825-20180111203228394-382938228.png&quot;&gt;&lt;img width=&quot;728&quot; height=&quot;277&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2017.cnblogs.com/blog/119825/201801/119825-20180111203228801-1750284295.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OK，数据全部保存成功。&lt;/p&gt;
&lt;p&gt;然而，事情真的就这么简单么？No。在追踪了IEventStore实例（也就是DapperEventStore）的生命周期后，你会发现，问题没有想象的那么简单。&lt;/p&gt;

&lt;p&gt;在使用services.AddTransient/AddScoped/AddSingleton/AddScoped这些方法对服务进行注册时，使用不同的方法也就意味着选择了不同的对象生命周期。在此我们也不再深入讨论每种方法之间的差异，&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection&quot; target=&quot;_blank&quot;&gt;微软官方有详细的文档&lt;/a&gt;和demo（抱歉我没有贴出中文链接，因为机器翻译的缘故，实在有点不堪入目），如果对ASP.NET Core的IoC容器不熟悉的话，建议先了解一下官网文章的内容。在上面我稍微提了一下，我们是用AddTransient方法来注册DapperEventStore的，因为我们希望在每次使用IEventStore的时候，都会有一个新的DapperEventStore被创建。现在，让我们来验证一下，看情况是否果真如此。&lt;/p&gt;
&lt;h2&gt;日志的使用&lt;/h2&gt;
&lt;p&gt;追踪程序执行的最有效的方式就是使用日志。在我们的场景中，使用基于文件的日志会更合适，因为这样我们可以更清楚地看到程序的执行过程以及对象的变化过程。同样，我不打算详细介绍如何在ASP.NET Core Web API中使用日志，微软官网同样有着非常详尽的文档来介绍这些内容。在这里，我简要地将相关代码列出来，以介绍如何启用基于文件的日志系统。&lt;/p&gt;
&lt;p&gt;首先，在Web API服务的项目上，添加对Serilog.Extensions.Logging.File的nuget包，使用它能够非常方便地启用基于文件的日志。然后，打开Program.cs文件，添加ConfigureLogging的调用：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [3,4,5,6];&quot;&gt;
public static IWebHost BuildWebHost(string[] args) =&amp;gt;
    WebHost.CreateDefaultBuilder(args)
        .ConfigureLogging((context, lb) =&amp;gt;
        {
            lb.AddFile(LogFileName);
        })
        .UseStartup&amp;lt;Startup&amp;gt;()
        .Build();
&lt;/pre&gt;
&lt;p&gt;此处LogFileName为本地文件系统中的日志文件文件名，为了避免权限问题，我将日志写入C:\Users\&amp;lt;user&amp;gt;\appdata\local目录下，因为我的Web API进程是由当前登录用户启动的，所以写在这个目录下不会有权限问题。如果今后我们把Web API host在IIS中，那么启动IIS服务的用户需要对日志所在的目录具有写入的权限，日志文件才能被正确写入，这一点是需要注意的。&lt;/p&gt;
&lt;p&gt;好了，现在可以使用日志了，先试试看。在Startup类的构造函数中，加入ILoggerFactory参数，并在构造函数执行时获取ILogger实例，然后在ConfigureServices调用中输出一些内容：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [3,5,8,15,23];&quot;&gt;
public class Startup
{
    private readonly ILogger logger;

    public Startup(IConfiguration configuration, ILoggerFactory loggerFactory)
    {
        Configuration = configuration;
        this.logger = loggerFactory.CreateLogger&amp;lt;Startup&amp;gt;();
    }

    public IConfiguration Configuration { get; }

    public void ConfigureServices(IServiceCollection services)
    {
        this.logger.LogInformation(&quot;正在对服务进行配置...&quot;);

        services.AddMvc();

        services.AddTransient&amp;lt;IEventHandler, CustomerCreatedEventHandler&amp;gt;();
        services.AddTransient&amp;lt;IEventStore&amp;gt;(serviceProvider =&amp;gt; 
            new DapperEventStore(Configuration[&quot;mssql:connectionString&quot;]));
        services.AddSingleton&amp;lt;IEventBus, PassThroughEventBus&amp;gt;();
        this.logger.LogInformation(&quot;服务配置完成，已注册到IoC容器！&quot;);
    }

    // 其它方法暂时省略
}
&lt;/pre&gt;
&lt;p&gt;现在重新启动服务，然后查看日志文件，发现日志可以被正确输出：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201801/119825-20180111203229004-58693432.png&quot;&gt;&lt;img width=&quot;681&quot; height=&quot;59&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2017.cnblogs.com/blog/119825/201801/119825-20180111203229222-1475893066.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来，使用类似的方式，向PassThroughEventBus的构造函数和Dispose方法中加入一些日志输出，在CustomersController的Create方法中、CustomerCreatedEventHandler的构造函数和HandleAsync方法中、DapperEventStore的构造函数和Dispose方法中也加入一些日志输出，以便能够观察当新的客户信息被创建时，Web API的执行过程。限于文章篇幅，就不在此一一贴出各方法中加入日志输出的代码了，大家可以根据本文最后所提供的源代码链接来获取源代码。简单地举个例子吧，比如对于DapperEventStore，我们通过构造函数注入ILogger的实例：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [4,7,11];&quot;&gt;
public class DapperEventStore : IEventStore
{
    private readonly string connectionString;
    private readonly ILogger logger;

    public DapperEventStore(string connectionString,
        ILogger&amp;lt;DapperEventStore&amp;gt; logger)
    {
        this.connectionString = connectionString;
        this.logger = logger;
        logger.LogInformation($&quot;DapperEventStore构造函数调用完成。Hash Code：{this.GetHashCode()}.&quot;);
    }
    // 其它函数省略
}
&lt;/pre&gt;
&lt;p&gt;这样一来，在DapperEventStore的其它方法中，就可以通过logger来输出日志了。&lt;/p&gt;
&lt;h2&gt;发现问题&lt;/h2&gt;
&lt;p&gt;同样，再次运行Web API，并通过Powershell发起一次创建客户信息的请求，然后打开日志文件，整个程序的执行过程基本上就一目了然了：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201801/119825-20180111203229582-1164225715.png&quot;&gt;&lt;img width=&quot;1113&quot; height=&quot;403&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2017.cnblogs.com/blog/119825/201801/119825-20180111203229832-1627049555.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从上面的日志内容可以得知，当应用程序正常退出时，由IoC容器托管的PassThroughEventBus和DapperEventStore都能够被正常Dispose，目前看来没什么问题，因为资源可以正常释放。现在让我们重新启动Web API，连续发送两次创建客户信息的请求，再次查看日志，我们得到了下面的内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201801/119825-20180111203230144-1223723197.png&quot;&gt;&lt;img width=&quot;1120&quot; height=&quot;595&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2017.cnblogs.com/blog/119825/201801/119825-20180111203230472-97143277.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从上面的日志内容可以看到，在Web API的整个运行期间，CustomerCreatedEventHandler仅被构造了一次，而且在每次处理CustomerCreatedEvent事件的时候，都是使用同一个DapperEventStore实例来保存事件数据。也就是说，CustomerCreatedEventHandler和DapperEventStore在整个Web API服务的生命周期中，有且仅有一个实例，它们是Singleton的！然而，在进行系统架构的时候，我们应该尽量保证较短的对象生命周期，以免因为状态的不一致性导致不可回滚的错误出现，这也是架构设计中的一种最佳实践。虽然目前我们的DapperEventStore在程序正常退出的时候能够被Dispose掉，但如果DapperEventStore使用了非托管资源，并且非托管资源并没有很好地管理自己的内存呢？久而久之，DapperEventStore就产生了内存泄漏点，慢慢地，Web API就会出现内存泄漏，系统资源将被耗尽。假如Web API被部署在云中，应用程序监控装置（比如AWS的Cloud Watch）就会持续报警，并强制服务断线，整个系统的可用性就无法得到保障。所以，我们更期望DapperEventStore能够正确地实现C#的Dispose模式，在Dispose方法中合理地释放资源，并且仅在需要使用DapperEventStore时候才去构建它，用完就及时Dispose，以保证资源的合理使用。这也就是为什么我们使用services.AddTransient方法来注册CustomerCreatedEventHandler以及DapperEventStore的原因。&lt;/p&gt;
&lt;p&gt;然而，事实却并非如此。究其原因，就是因为PassThroughEventBus是单例实例，它的生命周期是整个Web API服务。而在PassThroughEventBus的构造函数中，CustomerCreatedEventHandler被作为参数传入，于是，PassThroughEventBus产生了对CustomerCreatedEventHandler的依赖，而连带地也产生了对DapperEventStore的依赖。换句话说，在整个应用程序运行的过程中，IoC框架完全没有理由再去创建新的CustomerCreatedEventHandler以及DapperEventStore的实例，因为事件处理器作为强引用被注册到PassThroughEventBus中，而PassThroughEventBus至始至终没有变过！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：为什么PassThroughEventBus可以作为单例注册到IoC容器中？因为它提供了无状态的全局性的基础结构层服务：事件总线。在PassThroughEventBus的实现中，这种全局性体现得不明显，我们当然可以每一次HTTP请求都创建一个新的PassThroughEventBus来转发事件消息并作处理。然而，在今后我们要实现的基于RabbitMQ的事件总线中，如果我们还是每次HTTP请求都创建一个新的消息队列，不仅性能得不到保证，而且消息并不能路由到新创建的channel上。注意：我们将其注册成单例，一个很重要的依据是由于它是无状态的，但即使如此，我们也要注意在应用程序退出的时候，合理Dispose掉它所占用的资源。当然，在这里，ASP.NET Core的IoC机制会帮我们解决这个问题（因为我注册了PassThroughEventBus，但我没有显式调用Dispose方法，我仍然能从日志中看到“PassThroughEventBus已经被Dispose”的字样），然而有些情况下，ASP.NET Core不会帮我们做这些，就需要我们自己手工完成。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OMG！由于构造函数注入，使得对象之间产生了依赖关系，从而影响到了它们的生命周期，这可怎么办？既然问题是由依赖引起的，那么就需要想办法解耦。&lt;/p&gt;
&lt;h2&gt;解耦！解决事件处理器对象生命周期问题&lt;/h2&gt;
&lt;p&gt;经过分析，我们需要解除PassThroughEventBus对各种EventHandler的直接依赖。因为PassThroughEventBus是单例的，那么由它引用的所有组件也只可能具有相同的生命周期。然而，这样的解耦又该如何做呢？将EventHandler封装到另一个类中？结果还是一样，PassThroughEventBus总会通过某种对象关系，来间接引用到EventHandler上，造成EventHandler全局唯一。&lt;/p&gt;
&lt;p&gt;或许，应该要有另一套生命周期管理体系来管理EventHandler的生命周期，使得每当PassThroughEventBus需要使用EventHandler对所订阅的事件进行处理的时候，都会通过这套体系来请求新的EventHandler实例，这样一来，PassThroughEventBus也就不再依赖于某个特定的实例了，而仅仅是引用了各种EventHandler在新的生命周期管理体系中的注册信息。每当需要的时候，PassThroughEventBus都会将事件处理器的注册信息传给新的管理体系，然后由这套新的体系来维护事件处理器的生命周期。&lt;/p&gt;
&lt;p&gt;通过阅读微软官方的eShopOnContainers案例代码后，证实了这一想法。在案例中，有如下代码：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [6];&quot;&gt;
// namespace Microsoft.eShopOnContainers.BuildingBlocks.EventBusRabbitMQ
private async Task ProcessEvent(string eventName, string message)
{
    if (_subsManager.HasSubscriptionsForEvent(eventName))
    {
        using (var scope = _autofac.BeginLifetimeScope(AUTOFAC_SCOPE_NAME))
        {
            var subscriptions = _subsManager.GetHandlersForEvent(eventName);
            foreach (var subscription in subscriptions)
            {
                if (subscription.IsDynamic)
                { 
                    var handler = scope.ResolveOptional(subscription.HandlerType) as IDynamicIntegrationEventHandler;
                    dynamic eventData = JObject.Parse(message);
                    await handler.Handle(eventData);
                }
                else
                {
                    var eventType = _subsManager.GetEventTypeByName(eventName);
                    var integrationEvent = JsonConvert.DeserializeObject(message, eventType);
                    var handler = scope.ResolveOptional(subscription.HandlerType);
                    var concreteType = typeof(IIntegrationEventHandler&amp;lt;&amp;gt;).MakeGenericType(eventType);
                    await (Task)concreteType.GetMethod(&quot;Handle&quot;).Invoke(handler, new object[] { integrationEvent });
                }
            }
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;可以看到，高亮的这一行，通过Autofac创建了一个新的LifetimeScope，在这个Scope中，通过eventName来获得一个subscription对象（也就是EventHandler的注册信息），进而通过scope的ResolveOptional调用来获得新的EventHandler实例。基本过程就是这样，目前也不需要纠结IDynamicIntegrationEventHandler是干什么用的，也不需要纠结为什么要使用dynamic来保存事件数据。重点是，autofac的BeginLifetimeScope方法调用创建了一个新的IoC Scope，在这个Scope中解析（resolve）了新的EventHandler实例。在eShopOnContainer案例中，EventBusRabbitMQ的设计是特定的，必须依赖于Autofac作为依赖注入框架。或许这部分设计可以进一步改善，使得EventBusRabbitMQ不会强依赖于Autofac。&lt;/p&gt;
&lt;p&gt;接下来，我们会引入一个新的概念：事件处理器执行上下文，使用类似的方式来解决对象生命周期问题。&lt;/p&gt;

&lt;p&gt;事件处理器执行上下文（Event Handler Execution Context, EHEC）为事件处理器提供了一个完整的生命周期管理机制，在这套机制中，事件处理器及其引用的对象资源可以被正常创建和正常销毁。现在让我们一起看看，如何在EdaSample的案例代码中使用事件处理器执行上下文。&lt;/p&gt;
&lt;p&gt;事件处理器执行上下文的接口定义如下，当然，这部分接口是放在EdaSample.Common.Events目录下，作为消息系统的框架代码提供给调用方：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp;&quot;&gt;
public interface IEventHandlerExecutionContext
{
    void RegisterHandler&amp;lt;TEvent, THandler&amp;gt;()
        where TEvent : IEvent
        where THandler : IEventHandler&amp;lt;TEvent&amp;gt;;

    void RegisterHandler(Type eventType, Type handlerType);

    bool HandlerRegistered&amp;lt;TEvent, THandler&amp;gt;()
        where TEvent : IEvent
        where THandler : IEventHandler&amp;lt;TEvent&amp;gt;;

    bool HandlerRegistered(Type eventType, Type handlerType);

    Task HandleEventAsync(IEvent @event, CancellationToken cancellationToken = default);
}
&lt;/pre&gt;
&lt;p&gt;这个接口主要包含三种方法：注册事件处理器、判断事件处理器是否已经注册，以及对接收到的事件消息进行处理。整个结构还是非常清晰简单的。现在需要实现这个接口。根据上面的分析，这个接口的实现是需要依赖于IoC容器的，目前简单起见，我们仅使用微软ASP.NET Core标准的Dependency Injection框架来实现，当然，也可以使用Autofac，取决于你怎样去实现上面这个接口。需要注意的是，由于该接口的实现是需要依赖于第三方组件的（在这里是微软的Dependency Injection框架），因此，最佳做法是新建一个类库，并引用EdaSample.Common程序集，并在这个新的类库中，依赖Dependency Injection框架来实现这个接口。&lt;/p&gt;
&lt;p&gt;以下是基于Microsoft.Extensions.DependencyInjection框架来实现的事件处理器执行上下文完整代码，这里有个兼容性问题，就是构造函数的第二个参数：serviceProviderFactory。在Microsoft.Extensions.DependencyInjection框架2.0版本之前，IServiceCollection.BuildServiceProvider方法的返回类型是IServiceProvider，但从2.0开始，它的返回类型已经从IServiceProvider接口，变成了ServiceProvider类。这里引出了框架设计的另一个原则，就是&lt;strong&gt;依赖较低版本的.NET Core，以便获得更好的兼容性&lt;/strong&gt;。如果我们的EdaSample是使用.NET Core 1.1开发的，那么当下面这个类被直接用在ASP.NET Core 2.0的项目中时，如果不通过构造函数参数传入ServiceProvider创建委托，而是直接在代码中使用registry.BuildServiceProvider调用，就会出现异常。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp;&quot;&gt;
public class EventHandlerExecutionContext : IEventHandlerExecutionContext
{
    private readonly IServiceCollection registry;
    private readonly Func&amp;lt;IServiceCollection, IServiceProvider&amp;gt; serviceProviderFactory;
    private readonly ConcurrentDictionary&amp;lt;Type, List&amp;lt;Type&amp;gt;&amp;gt; registrations = new ConcurrentDictionary&amp;lt;Type, List&amp;lt;Type&amp;gt;&amp;gt;();

    public EventHandlerExecutionContext(IServiceCollection registry, 
        Func&amp;lt;IServiceCollection, IServiceProvider&amp;gt; serviceProviderFactory = null)
    {
        this.registry = registry;
        this.serviceProviderFactory = serviceProviderFactory ?? (sc =&amp;gt; registry.BuildServiceProvider());
    }

    public async Task HandleEventAsync(IEvent @event, CancellationToken cancellationToken = default(CancellationToken))
    {
        var eventType = @event.GetType();
        if (this.registrations.TryGetValue(eventType, out List&amp;lt;Type&amp;gt; handlerTypes) &amp;amp;&amp;amp;
            handlerTypes?.Count &amp;gt; 0)
        {
            var serviceProvider = this.serviceProviderFactory(this.registry);
            using (var childScope = serviceProvider.CreateScope())
            {
                foreach(var handlerType in handlerTypes)
                {
                    var handler = (IEventHandler)childScope.ServiceProvider.GetService(handlerType);
                    if (handler.CanHandle(@event))
                    {
                        await handler.HandleAsync(@event, cancellationToken);
                    }
                }
            }
        }
    }

    public bool HandlerRegistered&amp;lt;TEvent, THandler&amp;gt;()
        where TEvent : IEvent
        where THandler : IEventHandler&amp;lt;TEvent&amp;gt;
        =&amp;gt; this.HandlerRegistered(typeof(TEvent), typeof(THandler));

    public bool HandlerRegistered(Type eventType, Type handlerType)
    {
        if (this.registrations.TryGetValue(eventType, out List&amp;lt;Type&amp;gt; handlerTypeList))
        {
            return handlerTypeList != null &amp;amp;&amp;amp; handlerTypeList.Contains(handlerType);
        }

        return false;
    }

    public void RegisterHandler&amp;lt;TEvent, THandler&amp;gt;()
        where TEvent : IEvent
        where THandler : IEventHandler&amp;lt;TEvent&amp;gt;
        =&amp;gt; this.RegisterHandler(typeof(TEvent), typeof(THandler));

    public void RegisterHandler(Type eventType, Type handlerType)
    {
        Utils.ConcurrentDictionarySafeRegister(eventType, handlerType, this.registrations);
        this.registry.AddTransient(handlerType);
    }
}
&lt;/pre&gt;
&lt;p&gt;好了，事件处理器执行上下文就定义好了，接下来就是在我们的ASP.NET Core Web API中使用。为了使用IEventHandlerExecutionContext，我们需要修改事件订阅器的接口定义，并相应地修改PassThroughEventBus以及Startup.cs。代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [4,5,6,14,16,23,27,33,34,35,36,37,38,39,40,41,74,75,76,86];&quot;&gt;
// IEventSubscriber
public interface IEventSubscriber : IDisposable
{
    void Subscribe&amp;lt;TEvent, TEventHandler&amp;gt;()
        where TEvent : IEvent
        where TEventHandler : IEventHandler&amp;lt;TEvent&amp;gt;;
}

// PassThroughEventBus
public sealed class PassThroughEventBus : IEventBus
{
    private readonly EventQueue eventQueue = new EventQueue();
    private readonly ILogger logger;
    private readonly IEventHandlerExecutionContext context;

    public PassThroughEventBus(IEventHandlerExecutionContext context,
        ILogger&amp;lt;PassThroughEventBus&amp;gt; logger)
    {
        this.context = context;
        this.logger = logger;
        logger.LogInformation($&quot;PassThroughEventBus构造函数调用完成。Hash Code：{this.GetHashCode()}.&quot;);

        eventQueue.EventPushed += EventQueue_EventPushed;
    }

    private async void EventQueue_EventPushed(object sender, EventProcessedEventArgs e)
        =&amp;gt; await this.context.HandleEventAsync(e.Event);

    public Task PublishAsync&amp;lt;TEvent&amp;gt;(TEvent @event, CancellationToken cancellationToken = default)
        where TEvent : IEvent
            =&amp;gt; Task.Factory.StartNew(() =&amp;gt; eventQueue.Push(@event));

    public void Subscribe&amp;lt;TEvent, TEventHandler&amp;gt;()
        where TEvent : IEvent
        where TEventHandler : IEventHandler&amp;lt;TEvent&amp;gt;
    {
        if (!this.context.HandlerRegistered&amp;lt;TEvent, TEventHandler&amp;gt;())
        {
            this.context.RegisterHandler&amp;lt;TEvent, TEventHandler&amp;gt;();
        }
    }

    #region IDisposable Support
    private bool disposedValue = false; // To detect redundant calls
    void Dispose(bool disposing)
    {
        if (!disposedValue)
        {
            if (disposing)
            {
                this.eventQueue.EventPushed -= EventQueue_EventPushed;
                logger.LogInformation($&quot;PassThroughEventBus已经被Dispose。Hash Code:{this.GetHashCode()}.&quot;);
            }

            disposedValue = true;
        }
    }
    public void Dispose() =&amp;gt; Dispose(true);

    #endregion
}

// Startup.cs
public void ConfigureServices(IServiceCollection services)
{
    this.logger.LogInformation(&quot;正在对服务进行配置...&quot;);

    services.AddMvc();

    services.AddTransient&amp;lt;IEventStore&amp;gt;(serviceProvider =&amp;gt; 
        new DapperEventStore(Configuration[&quot;mssql:connectionString&quot;], 
            serviceProvider.GetRequiredService&amp;lt;ILogger&amp;lt;DapperEventStore&amp;gt;&amp;gt;()));

    var eventHandlerExecutionContext = new EventHandlerExecutionContext(services, 
        sc =&amp;gt; sc.BuildServiceProvider());
    services.AddSingleton&amp;lt;IEventHandlerExecutionContext&amp;gt;(eventHandlerExecutionContext);
    services.AddSingleton&amp;lt;IEventBus, PassThroughEventBus&amp;gt;();

    this.logger.LogInformation(&quot;服务配置完成，已注册到IoC容器！&quot;);
}

// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    var eventBus = app.ApplicationServices.GetRequiredService&amp;lt;IEventBus&amp;gt;();
    eventBus.Subscribe&amp;lt;CustomerCreatedEvent, CustomerCreatedEventHandler&amp;gt;();

    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }

    app.UseMvc();
}
&lt;/pre&gt;
&lt;p&gt;代码修改完成后，再次执行Web API，并发送两次（或多次）创建客户的请求，然后查看日志，我们发现，每次请求都会使用新的事件处理器去处理接收到的消息，在保存消息数据时，会使用新的DapperEventStore来保存数据，而保存完成后，会及时将DapperEventStore dispose掉：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201801/119825-20180111203231597-1387985552.png&quot;&gt;&lt;img width=&quot;1251&quot; height=&quot;678&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2017.cnblogs.com/blog/119825/201801/119825-20180111203232222-1117097855.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文篇幅比较长，或许你没有太多耐心将文章读完。但我尽量将问题分析清楚，希望提供给读者的内容是详细的、有理有据的。文章中黑体部分是在设计过程中的一些思考和需要注意的地方，希望能够给读者在工作和学习之中带来启发和收获。总而言之，对象生命周期的管理，在服务端应用程序中是非常重要的，需要引起足够的重视。在下文中，我们打算逐步摆脱PassThroughEventBus，基于RabbitMQ来实现消息总线的基础结构。&lt;/p&gt;

&lt;p&gt;本系列文章的源代码在&lt;a href=&quot;https://github.com/daxnet/edasample&quot;&gt;https://github.com/daxnet/edasample&lt;/a&gt;这个Github Repo里，通过不同的release tag来区分针对不同章节的源代码。本文的源代码请参考chapter_2这个tag，如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201801/119825-20180111203232707-1201562260.png&quot;&gt;&lt;img width=&quot;496&quot; height=&quot;475&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2017.cnblogs.com/blog/119825/201801/119825-20180111203233019-305497763.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Jan 2018 12:33:00 +0000</pubDate>
<dc:creator>dax.net</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daxnet/p/8270480.html</dc:identifier>
</item>
<item>
<title>Factom(公证通)--基于区块链的存证系统 - 王的博客</title>
<link>http://www.cnblogs.com/cnblogs-wangzhipeng/p/8270075.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnblogs-wangzhipeng/p/8270075.html</guid>
<description>&lt;p&gt;　　Factom这个Solution在2014年的时候就已经推出了，现在已经2018年了，我才来写这一篇分析文章可能有些迟了，但是它是十分具有参考价值的。因为现阶段来开区块链虽然炒得火热--养猫、养狗、草泥马之类的，但是真正成熟的应用比较少，有很多连基本的链平台都没有开发完全。而bitcoin作为区块链的1.0时代的代表，也是区块链行业的标杆存在，它的生态是最完整的--矿池、钱包、交易所。但是相对于区块链2.0Ethereum来讲功能就比较单一了，它的智能合约--公钥脚本功能单一，不是图灵完备的。基于bitcoin开发的应用就比较少，而ethereum上面的应用就多达800多个（养猫应该是最火的了）。&lt;/p&gt;
&lt;p&gt;　　但bitcoin不是说不能基于它去做一些事情，它也有一些扩展协议可以让bitcoin Blockchain来发挥更大的作用，比如说 OP_RETRUN 扩展交易。而Factom就是基于这个协议，如果换做此时此刻的话，Factom的创始人可能会选择更加方便的Ethereum，而不是Bitcoin，但在14年的时候以太坊还不是很成熟，而Bitcoin则更加的稳定可靠，时至今日Bitcoin很少会因为本身的漏洞而造成财产损失，大多数都是因为交易所遭受攻击而导致大量的Bitcoin被黑客盗取。这一点一要归功于 pow这个被人‘诟病’的协议，二、它没有支持图灵完备的智能合约，功能单一也有好处，有时越简单粗暴的越可靠，像以太坊就因为智能合约sdk的漏洞造成过两次大规模的ether泄露。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、Bitcoin的 OP_RETRUN协议介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　OP_RETURN是一个脚本操作码，用于将事务输出标记为无效。由于任何带有OP_RETURN的输出可证明是不可靠的，OP_RETURN输出可以用来烧毁比特币。&lt;/p&gt;
&lt;p&gt;　　比特币社区的许多成员认为使用OP_RETURN是不负责任的，部分原因是比特币旨在为金融交易提供记录，而不是任意数据的记录。此外，对于外部大规模复制数据存储的需求本质上是无限的，这一点显而易见。尽管如此，与在区块链中存储数据的一些其他方式相比，OP_RETURN具有不会创建虚假UTXO条目的优势。 从比特币核心版本0.9.0： 这种变化并不意味着将数据存储在区块链中。 OP_RETURN类型的交易请求创建了一个可证明的可修剪txo，以避免数据存储方案（其中一些已经部署）将诸如图像之类的任意数据存储为永远不可用的TX输出，从而膨胀了比特币的UTXO数据库。 在区块链中存储任意数据仍然是一个坏主意，在其他地方存储非货币数​​据的成本更低，效率更高。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、Factom的基本原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在阐述基本原理之前，我先说几个有关于Factom的关键词：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Factoids ： factom发行的代币，使用factom的服务时要消耗代币，而且不可以交易。&lt;/p&gt;
&lt;p&gt;Entry Credits：提交Entry时要消耗 Credits，而Credits是用Factoids换取的，可以交易。&lt;/p&gt;
&lt;p&gt;Entry：提交到Factom上存储的文件&lt;/p&gt;
&lt;p&gt;Entry Block：记录Entry完整性（Hash值）证明的区块&lt;/p&gt;
&lt;p&gt;Directory Block：记录Entry Block块完整性（Hash值）证明的区块&lt;/p&gt;
&lt;p&gt;ChainID：APPlication的账本ID&lt;/p&gt;
&lt;p&gt;APPlication：基于Factom服务开发的应用&lt;/p&gt;
&lt;p&gt;Federated Servers：用来管理运行Factom的分布式服务集群&lt;/p&gt;
&lt;p&gt;Auditing Servers：审查节点，这些审查节点负责审查Federated Servers的生成的账本是否合法&lt;/p&gt;
&lt;p&gt;看到这，你想必应该猜测到了，Factom是有自己的账本--chain的，不光Factom有每一个App都有自己对应的chain。&lt;/p&gt;
&lt;p&gt;factom存证充分的利用了Merkle Hash tree，它的最基本原理就是： 首先将一段时间内上传的数据都纳入到Merkle Hash tree（间接或者直接）；然后每隔10min中Root Hash加入到OP_RETRUN交易中，锚定到bitcoin区块链。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1178663/201801/1178663-20180111200553004-1212298716.png&quot; alt=&quot;&quot; width=&quot;766&quot; height=&quot;418&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　稍微了解过bitcoin原理的老铁应该都知道Merkle tree的精妙之处--假定root hash是正确的，则在不知道其他叶子节点的情况下，仍然能证明单个叶子结点的完整性。这样做的好处就是你可以不需要关心其他叶子结点（在Bitcoin中是Utxo，在factom中是Entry数据），也能证明自己的完整性，有老铁可能就问了这么费劲干啥？咋不直接把Entry的Hash锚定到Bitcoin上？贵啊！现在一个Bitcoin市值$14,000左右，矿工费最低要0.0009(不同矿池收费标注不同)，而且十分钟才能添加一块，还要等待6个块确认，不说矿工费开销大，效率也低啊。利用Merkle tree可以上传最少的数据 32bytes（上面说过一个OP_RETURN最多40），同时又能证明大量的数据完整性，何乐而不为？&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1178663/201801/1178663-20180111200628551-1866418461.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt; 本图将Factom大致的逻辑关系已经呈现的很清楚了：&lt;/p&gt;
&lt;p&gt;1.APP的运营者先去Factom上买Factoids，然后将Factoids兑换成Entry Credit&lt;/p&gt;
&lt;p&gt;2.APP将数据提交到Factom Servers，加入该APP对应的Entry Chain&lt;/p&gt;
&lt;p&gt;3.将 当前周期内上传 Entry 打包成 EntryBlocks（白皮书上显示 1min钟生成一个块）；&lt;/p&gt;
&lt;p&gt;4.将 当前周期内生成的EntryBlocks 打包成 Directory Blocks；&lt;/p&gt;
&lt;p&gt;5.间隔一段时间（白皮书显示是10min，正好是比特币生成区块的平均时间）将未锚定的Diretory Blocks加入到一个Merkle tree中（按照白皮书说法应该是10块）；&lt;/p&gt;
&lt;p&gt;6.将root hash 锚定到Bitcoin中&lt;/p&gt;
&lt;p&gt;APP参照了中本聪在bitcoin白皮书中提到的SPV原理，只要关心和自己相关的数据就好了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、Factom的组织架构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Factom整个架构体系中有三层，如下：&lt;/p&gt;
&lt;p&gt;APPLication&lt;/p&gt;
&lt;p&gt;---------------------------------------&lt;/p&gt;
&lt;p&gt;FACTOM Server| Audis Server&lt;/p&gt;
&lt;p&gt;---------------------------------------&lt;/p&gt;
&lt;p&gt;BItcoin Miners&lt;/p&gt;
&lt;p&gt;Factom 的账本有四层，如下：&lt;/p&gt;
&lt;p&gt;APP Entry Chains | FactorId Chain | Credit Chain&lt;/p&gt;
&lt;p&gt;------------------------------------------------------&lt;/p&gt;
&lt;p&gt;Entry Blocks&lt;/p&gt;
&lt;p&gt;------------------------------------------------------&lt;/p&gt;
&lt;p&gt;Directory Blocks&lt;/p&gt;
&lt;p&gt;-----------------------------------------------------&lt;/p&gt;
&lt;p&gt;Bitcoin Blocks&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.1 我们先按照架构体系来说：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;APPlication ：由开发者开发面向用户的应用，它们都使用了Factom的服务来做数据存储证明。我们下面描述一下APP加入Factom的过程：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;setup 0： 一个APP在初始化加入Factom体系时候做的第一件事就是充钱（不充钱你怎么能变强？），你将公钥发送给Factom Server，Factom Server会分配给你一笔 Factoids，这笔交易会记录在FactorId Chain中。&lt;/p&gt;
&lt;p&gt;setup 1 ： 服务器 会向你反馈一个Entry 确认信息， 同时会向外广播这个确认信息（我们前面说过factom 是有一个分布式服务集群的）&lt;/p&gt;
&lt;p&gt;setup2：APP用Factoids换取Entry Credit， 服务器会将这笔交易记录在Credit Chain中，同时向外广播。&lt;/p&gt;
&lt;p&gt;setup3：APP上传第一个实体Entry（初始化，里面包含着你自己定义的Entry校验规则的Hash值，或其他细则），服务器会帮你创建一个对应ChainId的账本，同时扣除相应的Credit，向外广播消息。&lt;/p&gt;
&lt;p&gt;ps： ChainId ID是由APP自己定义的ChainName的Hash值。&lt;/p&gt;
&lt;p&gt;　　　创建后提交一个Entry的过程就是setup 1~3的过程，当然客户端看起来就这么简单，在服务端就复杂多了。&lt;span&gt;同时这里面我们要重点强调的是，Factom服务器不负责校验Entry 数据的合法性，数据的合法性是在APP这一端校验的。我们可以在创建账本的时候将校验规则（比如一个审计程序）的Hash加入到第一个Entry中，这个审计程序在APP运行，这样就能屏蔽掉那些无效的Entry。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Factom Servers： factom有一个分布式的服务集群，每一个服务器都会负责一维护部分APP的账本，同时将更新同步到其他服务器中。Factom中服务器有两种类型，一种是记账服务器，一种是审查服务器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　我们来讲一下servers的工作过程，首先介绍几个关键词：&lt;/p&gt;
&lt;p&gt;　　　　process list： 每一个服务器都要维护一个list，这个列表里面存储着本服务器和其他服务器负责的chain。　　&lt;/p&gt;
&lt;p&gt;　　　　Weighted Number of Entry Credits： 根据消费的Credits计算出投票权重用于选择Factom Server&lt;/p&gt;
&lt;p&gt;              Weighted Number of Entries：根据Entry计算出投票权重用于选择Factom Server。&lt;/p&gt;
&lt;p&gt;　　Factom  Servers一个记录周期如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt; 所有服务器重设其进程列表（Process List）为空。&lt;/li&gt;
&lt;li&gt;用户通与其Entry信用的积分（Entry Credit）相关的公钥提交付款&lt;/li&gt;
&lt;li&gt;根据用于支付的公钥，轮值服务器接受该付款。&lt;/li&gt;
&lt;li&gt;该服务器向网络广播该支付被接受。&lt;/li&gt;
&lt;li&gt;用户看到支付被接受， 然后提交Entry。&lt;/li&gt;
&lt;li&gt;根据Entry的ChainID，其中一台服务器把Entry加入其进程列表，并添加进入到相应链的区块中（如果这是该链的第一个Entry, 那就创建这个新链）。&lt;/li&gt;
&lt;li&gt;服务器对网络广播该Entry的确认，内容含有Entry在Process list 中的位置（Index) + Hash(Entry)（链接到Entry付款）+ Hash(process list)。&lt;/li&gt;
&lt;li&gt;所有其他服务器更新该服务器的process list，验证该列表，并更新该链的区块。&lt;/li&gt;
&lt;li&gt;只要用户可以验证到相关的 process list 中包含自己的提交的数据Entry，那么他们就可以有相当的信心相信它会被成功地被录入到Factom上。&lt;/li&gt;
&lt;li&gt;在一分钟结束时，所有服务器确认process list 的 高度，揭示一个确定性的秘密数值（该值为一个Reverse Hash 值，即一条较长的，连续的区块链哈希值的原像值），还有被处理区块的一系列哈希值（将与 process list 中的最后一项相匹配）。&lt;/li&gt;
&lt;li&gt;那一分钟的目录区块（Directory Block）是由所有服务器中定义的所有Entry区块（Entry Block）组合到一起建造而生成的。因此，每个服务器都拥有所有的Entry区块（Entry Block），所有的目录区块（Directory Block），和所有Entry（all Entries）。&lt;/li&gt;
&lt;li&gt;使用Reverse Hash值的集合来创造一个种子，为下一轮的ChainIDs重新分配服务器。&lt;/li&gt;
&lt;li&gt;在完成10个目录区块后，请执行以下操作：
&lt;ol&gt;&lt;li&gt;对最后一分钟的Entry块创建梅克尔根（Merkle Root），按ChainID排序。&lt;/li&gt;
&lt;li&gt;创建最后一分钟的目录区块，并计算其梅克尔根（Merkle Root）。&lt;/li&gt;
&lt;li&gt;用10个目录区块的梅克尔根（Merkle Root）创建一个锚定。&lt;/li&gt;
&lt;li&gt;用服务器的反向哈希值集合来创建一个种子，再用其选择下一个服务器来把锚定写到比特币区块链&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;.重复。 （又从第1部开始循环）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 　　Factom 为了防止腐败发生，所以它的Servers集群中记账的服务器是会不断变化的，每隔4个小时进行一次选举，由user投票来决定哪些服务器能够成为Factom的记账服务器，用户投票的权重是根据Weighted Number of Entry Credits和Weighted Number of Entries计算出来的，所有的服务器都会参选最后进行一个排名，然后选择前n名成为Federated Servers 其余的为Auditing Servers。 为了防止被选择的服务器发生故障，每隔四秒就要广播心跳包（Entry 确认信息），如果一台服务器没有收到 X 的心跳包就会发送一个SFM信息认为X是故障的，如果大多数（没有给出阈值）认为X服务器是故障的，那么X服务器就会降级，由第n+1名服务器升级为Federated Servers，X 降级为Auditing Servers。&lt;/p&gt;
&lt;p&gt;ps0：大家可能会困惑既然合法性校验放在了client side，那么Auditing Servers有个卵用？Auditing Servers 有两个作用： 一、审查Federated Servers生成块是否符合规则；二、为Entry 提供存在性证明（Proof of existence）（这是从Factom社区里面得到的回复）。&lt;/p&gt;
&lt;p&gt;ps1：Weighted Number of Entry Credits： 加权最近六个月购入的入场券数量（每月购买金额，当月加权6次，前5次加权等） ；Weighted Number of Entries： 加权最近六个月使用的条目数量（每月使用的条目数量，当前月份加权6个，前一个加权5个）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bitcoin miner：这一层我就不多说了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　上面就是按照体系架构来讲述一下它工作的基本流程，Factom的实现比较复杂。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.2 我们再按照账本层次来说：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Directory Blocks&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　目录块中引用的每个Entry块占用64个字节（两个32字节散列，Entry Block的ChainID和Merkle根）。一百万个这样的条目将导致一组目录块大小约为64MB。如果平均的每个Entry Block有5个Entry，64 MB的Directory Blocks将提供500万个不同&lt;span&gt;Entry的高级管理。&lt;/span&gt;Factom服务器收集Entry Block的Merkle根并将它们打包到目录块中。十个连续的目录块通过Merkle树散列，Merkle根被记录在比特币区块链中。这允许区块链的最小扩展，并且仍然允许通过比特币散列权限保护分类账。将Merkle根加入比特币区块链的过程称为“锚定”。有关更多详细信息，请参阅“附录：比特币时间戳”部分。从带宽和存储的角度来看，输入到目录块中的数据是最昂贵的。如果Factom用户希望在链中找到数据，那么他们需要从账本创建时开始的所有目录块。会增加目录块大小的Active 包括 APP chain 的创建和首次更新。这些Active将 APP 程序细化账本规则的 花费 进行了公示。相比记录一个Entry，APP必须要花费更多的Entry积分来执行这些特殊的Active，这样可以阻止目录块的膨胀。也就是说实际上Directory block中记录的是一个map&amp;lt;chainId, Entry Block Merkle Root Hash&amp;gt;的表。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1178663/201801/1178663-20180111200714019-850336118.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;Entry Blocks&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　Entry Block Later 是系统中的第二层级。APP 将拥有各自的ChainID。在 Entry Blocks 里，APP可以ChainID为线索扩展搜索所有相关的条目。每个目录块中包含的chainId 都会有一个更新的Entry Block。Entry Block包含上传的Entry的散列值。Entry的哈希证明了数据的存在，同时也充当在分布式哈希表（DHT）网络中查找Entry的Key。 （更多细节参见“Factom点对点网络Entry Block 有意不包含 Entry 本身。这使得Entry Block 很小。从Entry Block 中分离 Entry 还可以使审计人员更容易审计。审核员可以在一个单独的链中，这个链用来记录那些来自普通链中的被批准或被拒绝的Entry。审核员可以在其Entry中增加拒绝的理由。如果应用程序信任审核员，他们可以交叉引用审核员批准或拒绝每个Entry，而不需要知道Entry是什么。然后应用程序将只尝试下载通过审计的Entry。多个审计人员可以引用相同的Entry，并且条目将只在分布式散列表（DHT）上存在一次。预计条目将比散列占用的仅仅32个字节大得多。要忽略的事物列表不一定要让应用程序忽略完整的对象。输入块包含与ChainID相关的所有可能的输入项。如果一个Entry没有在Entry Block中被引用，那么可以假定它不存在，这允许应用程序证明是否定的。&lt;/p&gt;
&lt;p&gt;ps：现在Factom并未构建起DHT存储，他们准备和IPFS进行合作来存储文件。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1178663/201801/1178663-20180111200730301-2095186272.png&quot; alt=&quot;&quot; width=&quot;608&quot; height=&quot;628&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　记录是被用户创建并提交到Factom的。通过散列和编码信息，用户可以确保记录的隐私性。如果编码或隐藏数据是不必要的话，那么记录可以替换成为纯文本。通过记录一份文档的一段哈希值，Factom可以提供基本的发布证明(proof of publication)。稍后, 人们可以生成文档的哈希值, 并和之前链块记录的哈希值进行比对, 来判断文档是否是当初发布的那个版本。这在数据的处理可以有很大的灵活性，可以出现类似超链接的东西。数据还可以更庞大，但不能过于庞大.，因为数据越大需要付的费用也越多。这和比特币比较相似，超过100兆字节的比特币转账数据是可能发生的，但需要支付更多的转账费用。Factom可以处理比比特币网络里大得多的数据，由于比特币的完整节点需扫描完整的区块链数据，所以区块链体积不能太大。在Factom中完整节点只需要扫描最高级的目录区块(Directory Block), 并不需要扫描全部的链块数据。如果人不对链数据感兴趣的话，完全可以忽略它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ps:Factom实际上到底有没有存储这些Entry 链接的文件尚未得知，我在社区中询问但是没有得到解答。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1178663/201801/1178663-20180111200756254-2054423930.png&quot; alt=&quot;&quot; width=&quot;598&quot; height=&quot;619&quot;/&gt;&lt;/div&gt;
&lt;p&gt;最后给大家上一个总体的账本结构图，如下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1178663/201801/1178663-20180111200812988-634858251.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;567&quot;/&gt;&lt;/div&gt;
&lt;p&gt;参考网址：&lt;/p&gt;
&lt;div&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;https://www.factom.com/devs/docs/guide/factom-white-paper-1-0&lt;/li&gt;
&lt;li&gt;http://www.8btc.com/factombaipishu&lt;/li&gt;
&lt;li&gt;https://en.bitcoin.it/wiki/OP_RETURN&lt;/li&gt;
&lt;li&gt;https://www.cnblogs.com/fengzhiwu/p/5524324.html&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;---------------------------------------------------分割线-----------------------------------------------------&lt;/p&gt;

&lt;p&gt;　　以上的内容一部分来自我自己从白皮书中的翻译，一部分引用于上面的网址，其中还有一些不确定性，我在注释中已经指出，如果哪位老铁知道答案的话请在评论区留言，我会及时改正。下面我阐述一个自己并不成熟的观点，就是基于pow链的存证系统有多大价值？我们知道现在数据存证常用的是数字签名，既可以保证数据的完整性，又能保证数据的合法性。最多我再多云备份几份，你这个存证系统到底有什么存在的必要？　　&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;从密码学破解的角度来看，篡改Factom中的Hash证明要比篡改签名难度等级要高。因为Factom锚定到了bitcoin上，这是一种信任的传递，你如果要想篡改出来一个合法的Hash证明首先要从bitcoin区块下手。而且随着时间的推移，后续块的增多篡改的难度越大，这相比从公钥推导出私钥的难度要更大！（当然这是在私钥没有被窃取的条件下，如果你的用户私钥被窃取，或者说你的Factom账号被窃取，你仍然可以去篡改Entry的Hash证明。）　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是，从现阶段来看，这两者都是基本“零”可能。然而当量子计算机出现的时候情况就不一样了，量子计算理论上可以暴力破解非对称加密，虽然格密码理论上能够抵御量子计算，但现有的PKI体系还是难免会收到冲击。而这个时候Factom的作用就体现出来了，你可以去破解ecc和rsa的证书去伪造证明，但是你依然很难篡改Bitcoin账本。因为区块链账本是靠强大的hash算力保护的，而量子计算机在破解hash算法上并没有什么优势，所以伪造区块依旧很难，只要是已经存在的账本正确性依旧难以动摇。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;附，量子计算机维基百科：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;历史&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;26.763636363636&quot;&gt;　　随着&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6&quot;&gt;&lt;span&gt;计算机科学&lt;/span&gt;&lt;/a&gt;的发展，&lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=%E5%8F%B2%E8%92%82%E8%8A%AC%C2%B7%E5%A8%81%E6%96%AF%E7%B4%8D&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;span&gt;史蒂芬·威斯纳&lt;/span&gt;&lt;/a&gt;在1969年最早提出“基于量子力学的计算设备”。而关于“基于量子力学的信息处理”的最早文章则是由&lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=%E4%BA%9E%E6%AD%B7%E5%B1%B1%E5%A4%A7%C2%B7%E8%B1%AA%E5%8B%92%E5%A4%AB&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;span&gt;亚历山大·豪勒夫&lt;/span&gt;&lt;/a&gt;（1973）、帕帕拉维斯基（1975）、&lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=%E7%BE%85%E9%A6%AC%C2%B7%E5%8D%B0%E6%88%88%E7%99%BB&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;span&gt;罗马·印戈登&lt;/span&gt;&lt;/a&gt;（1976）和&lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=%E5%B0%A4%E9%87%8C%C2%B7%E9%A6%AC%E5%B0%BC&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;span&gt;尤里·马尼&lt;/span&gt;&lt;/a&gt;（1980）年发表&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA#cite_note-2&quot;&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA#cite_note-3&quot;&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA#cite_note-4&quot;&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;/a&gt; &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA#cite_note-5&quot;&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;/a&gt;。史蒂芬·威斯纳的文章发表于1983年&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA#cite_note-6&quot;&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;/a&gt;。1980年代一系列的研究使得量子&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA&quot;&gt;&lt;span&gt;计算机&lt;/span&gt;&lt;/a&gt;的理论变得丰富起来。1982年，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E8%B2%BB%E6%9B%BC&quot;&gt;&lt;span&gt;理查德·费曼&lt;/span&gt;&lt;/a&gt;在一个著名的演讲中提出利用量子体系实现通用计算的想法。紧接着1985年&lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=%E5%A4%A7%E8%A1%9B%C2%B7%E6%9D%9C%E6%96%AF&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;span&gt;大卫·杜斯&lt;/span&gt;&lt;/a&gt;提出了&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E5%9C%96%E9%9D%88%E6%A9%9F&quot;&gt;&lt;span&gt;量子图灵机&lt;/span&gt;&lt;/a&gt;模型&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA#cite_note-7&quot;&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;/a&gt;。人们研究量子计算机最初很重要的一个出发点是探索通用计算机的计算极限。当使用计算机模拟&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90&quot;&gt;&lt;span&gt;量子&lt;/span&gt;&lt;/a&gt;现象时，因为庞大的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B8%8C%E7%88%BE%E4%BC%AF%E7%89%B9%E7%A9%BA%E9%96%93&quot;&gt;&lt;span&gt;希尔伯特空间&lt;/span&gt;&lt;/a&gt;而数据量也变得庞大。一个完好的模拟所需的运算时间则变得相当长，甚至是不切实际的天文数字。理查德·费曼当时就想到如果用量子系统所构成的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F&quot;&gt;&lt;span&gt;计算机&lt;/span&gt;&lt;/a&gt;来模拟量子现象则运算时间可大幅度减少，从而量子计算机的概念诞生。半导体靠控制&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%A9%8D%E9%AB%94%E9%9B%BB%E8%B7%AF&quot;&gt;&lt;span&gt;集成电路&lt;/span&gt;&lt;/a&gt;来记录及运算信息，量子计算机则希望控制原子或小分子的状态，记录和运算信息。&lt;/div&gt;
&lt;div readability=&quot;17.018844221106&quot;&gt;　　量子计算机在1980年代多处于理论推导状态。1994年&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BD%BC%E5%BE%97%C2%B7%E7%A7%80%E7%88%BE&quot;&gt;&lt;span&gt;彼得·秀尔&lt;/span&gt;&lt;/a&gt;（Peter Shor）提出&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%A7%80%E7%88%BE%E6%BC%94%E7%AE%97%E6%B3%95&quot;&gt;&lt;span&gt;量子质因数分解算法&lt;/span&gt;&lt;/a&gt;后&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA#cite_note-8&quot;&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;/a&gt;，证明量子计算机能做出&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0&quot;&gt;&lt;span&gt;离散对数&lt;/span&gt;&lt;/a&gt;运算&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA#cite_note-9&quot;&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;/a&gt;，而且速度远胜传统电脑。因为量子不像&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8D%8A%E5%B0%8E%E9%AB%94&quot;&gt;&lt;span&gt;半导体&lt;/span&gt;&lt;/a&gt;只能记录0与1，可以同时表示多种状态。如果把半导体比喻成单一乐器，量子计算机就像交响乐团，一次运算可以处理多种不同状况，因此，一个40比特的量子计算机，就能在很短时间内解开1024位电脑花上数十年解决的问题。因其对于现在通行于银行及网络等处的&lt;a href=&quot;https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95&quot;&gt;&lt;span&gt;RSA加密算法&lt;/span&gt;&lt;/a&gt;可以破解而构成威胁之后，量子计算机变成了热门的话题，除了理论之外，也有不少学者着力于利用各种量子系统来实现量子计算机。&lt;/div&gt;
&lt;p&gt;&lt;span&gt;基本概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;传统计算机即对输入信号序列按一定算法进行变换的机器，其算法由计算机的内部逻辑电路实现。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;输入态和输出态都是传统信号，用&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6&quot;&gt;&lt;span&gt;量子力学&lt;/span&gt;&lt;/a&gt;的语言来描述，也即是：其输入态和输出态都是某一力学量的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%AC%E5%BE%81%E6%80%81&quot;&gt;&lt;span&gt;本征态&lt;/span&gt;&lt;/a&gt;。如输入二进制序列用量子记号 0110110，用量子记号则为| 0110110&amp;gt; 。所有的输入态均相互&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4&quot;&gt;&lt;span&gt;正交&lt;/span&gt;&lt;/a&gt;。对传统计算机不可能输入如下&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%80%81%E5%8F%A0%E5%8A%A0%E5%8E%9F%E7%90%86&quot;&gt;&lt;span&gt;叠加态&lt;/span&gt;&lt;/a&gt;：c1 |0110110&amp;gt; + c2|1001001&amp;gt;&lt;/li&gt;
&lt;li&gt;传统计算机内部的每一步变换都演化为正交态，而一般的量子变换没有这个性质，因此，传统计算机中的变换（或计算）只对应一类特殊集。&lt;/li&gt;
&lt;/ol&gt;&lt;div readability=&quot;11.217391304348&quot;&gt;量子计算机分别对传统计算机的限制作了推广。量子计算机的输入用一个具有有限&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%83%BD%E7%BA%A7&quot;&gt;&lt;span&gt;能级&lt;/span&gt;&lt;/a&gt;的量子系统来描述，如二能级系统（称为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E4%BD%8D%E5%85%83&quot;&gt;&lt;span&gt;量子比特&lt;/span&gt;&lt;/a&gt;（qubits）），量子计算机的变换（即量子计算）包括所有可能的正变换。&lt;/div&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;量子计算机的输入态和输出态为一般的叠加态，其相互之间通常不正交；&lt;/li&gt;
&lt;li&gt;量子计算机中的变换为所有可能的正变换。得出输出态之后，量子计算机对输出态进行一定的测量，给出计算结果;&lt;/li&gt;
&lt;/ol&gt;&lt;div readability=&quot;11.097744360902&quot;&gt;传统计算是一类特殊的量子计算，量子计算对传统计算作了极大的扩充，其最本质的特征为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%80%81%E5%8F%A0%E5%8A%A0%E5%8E%9F%E7%90%86&quot;&gt;&lt;span&gt;量子叠加性&lt;/span&gt;&lt;/a&gt;和&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E7%9B%B8%E5%B9%B2%E6%80%A7&quot;&gt;&lt;span&gt;量子相干性&lt;/span&gt;&lt;/a&gt;。量子计算机对每一个叠加分量实现的变换相当于一种经典计算，所有这些传统计算同时完成，并按一定的概率振幅叠加起来，给出量子计算机的输出结果。这种计算称为量子并行计算。&lt;/div&gt;





</description>
<pubDate>Thu, 11 Jan 2018 11:04:00 +0000</pubDate>
<dc:creator>王的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cnblogs-wangzhipeng/p/8270075.html</dc:identifier>
</item>
<item>
<title>关于javascript代码优化的8点建议 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8006285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8006285.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　本文将详细介绍JS编程风格的几个要点&lt;/p&gt;

&lt;h3&gt;松耦合&lt;/h3&gt;
&lt;p&gt;　　当修改一个组件而不需要更改其他组件时，就做到了松耦合&lt;/p&gt;
&lt;p&gt;　　1、将JS从CSS中抽离：不要使用CSS表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//不好的做法
.box{width: expression(document.body.offsetWidth + ’px')}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、将CSS从JS中抽离：通过JS修改CSS样式时，使用className或classList，不要逐条修改style样式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//不好的做法一
ele.style.color = 'red';
ele.style.left= '10px';
//不好的做法二
ele.style.cssText ='color:red;left:10px;';&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.reveal{color:red;left:10px;}
//好的做法一
ele.className += 'reveal';
//好的做法二
ele.classList.add('reveal');&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、将JS从HTML中抽离：从JS文件放入外置文件中&lt;/p&gt;
&lt;p&gt;　　4、将HTML从JS中抽离：不要在innerHTML中拼接DOM结构，而是使用字符串模板，如handlerbars&lt;/p&gt;

&lt;h3&gt;全局变量&lt;/h3&gt;
&lt;p&gt;　　创建全局变量被认为是糟糕的实践，尤其在团队开发的大背景下更是问题多多。随着代码量的增长，全局变量会导致一些非常重要的可维护性难题，全局变量越多，引入错误的概率会变得越高&lt;/p&gt;
&lt;p&gt;　　一般而言，有如下三种解决办法&lt;/p&gt;
&lt;p&gt;　　1、零全局变量&lt;/p&gt;
&lt;p&gt;　　实现方法是使用一个立即调用函数&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/5731016.html&quot; target=&quot;_blank&quot;&gt;IIFE&lt;/a&gt;并将所有脚本放置其中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(function(){
  var doc = win.document;
})(window);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种模式的使用场景有限，只要代码需要被其他的代码所依赖，或者需要在运行中被不断扩展或修改，就不能使用这种方式&lt;/p&gt;
&lt;p&gt;　　2、单全局变量和&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/8253544.html#anchor5&quot; target=&quot;_blank&quot;&gt;命名空间&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　依赖尽可能少的全局变量，即只创建一个全局变量，使用单变量模式，如YUI或jQuery&lt;/p&gt;
&lt;p&gt;　　单全局变量，即所创建的这个唯一全局对象名是独一无二的，并将所有的功能代码都挂载到这个全局对象上。因此，每个可能的全局变量，都成为唯一全局变量的属性，从而不会创建多个全局变量&lt;/p&gt;
&lt;p&gt;　　命名空间是简单的通过全局对象的单一属性表示的功能性分组。比如Y.DOM下的所有方法都是和DOM操作相关的，Y.Event下的所有方法都是和事件相关的。常见的约定是每个文件中都通过新的全局对象来声明自己的命名空间&lt;/p&gt;
&lt;p&gt;　　3、使用&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/7272324.html&quot; target=&quot;_blank&quot;&gt;模块&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　模块是一种通用的功能片段，它并没有创建新的全局变量或命名空间。相反，所有的这些代码都存放于一个表示执行一个任务或发布一个接口的单函数中。可以用一个名称来表示这个模块，同样这个模块可以依赖其他模块&lt;/p&gt;

&lt;h3&gt;事件处理&lt;/h3&gt;
&lt;p&gt;　　将事件处理相关的代码和事件环境耦合在一起，导致可维护性很糟糕&lt;/p&gt;
&lt;p&gt;　　1、隔离应用逻辑&lt;/p&gt;
&lt;p&gt;　　将应用逻辑从所有事件处理程序中抽离出来是一种最佳实践，将应用逻辑和事件处理的代码拆分开来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//不好的做法
function handleClick(event){
  var popup = document.getElementById('popup');
  popup.style.left = event.clientX + 'px';
  popup.style.top = event.clientY + 'px';
  popup.className = 'reveal';
}
addListener(element,'click',handleClick);

//好的做法
var MyApplication = {
  handleClick: function(event){
    this.showPopup(event);
  },
  showPopup: function(event){
    var popup = document.getElementById('popup');
    popup.style.left = event.clientX + 'px';
    popup.style.top = event.clientY + 'px';
    popup.className = 'reveal';
  }
};
addListener(element,'click',function(event){
  MyApplication.handleClick(event);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、不要分发事件对象&lt;/p&gt;
&lt;p&gt;　　应用逻辑不应当依赖于event对象来正确完成功能，方法接口应该表明哪些数据是必要的。代码不清晰就会导致bug。最好的办法是让事件处理程序使用event对象来处理事件，然后拿到所有需要的数据传给应用逻辑&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//改进的做法
var MyApplication = {
  handleClick: function(event){
    this.showPopup(event.clientX,event.clientY);
  },
  showPopup: function(x,y){
    var popup = document.getElementById('popup');
    popup.style.left = x + 'px';
    popup.style.top = y + 'px';
    popup.className = 'reveal';
  }
};
addListener(element,'click',function(event){
  MyApplication.handleClick(event);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当处理事件时，最好让事件程序成为接触到event对象的唯一的函数。事件处理程序应当在进入应用逻辑之前针对event对象执行任何必要的操作，包括阻止事件冒泡，都应当直接包含在事件处理程序中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//改进的做法
var MyApplication = {
  handleClick: function(event){
    event.preventDefault();
    event.stopPropagation();
    this.showPopup(event.clientX,event.clientY);
  },
  showPopup: function(x,y){
    var popup = document.getElementById('popup');
    popup.style.left = x + 'px';
    popup.style.top = y + 'px';
    popup.className = 'reveal';
  }
};
addListener(element,'click',function(event){
  MyApplication.handleClick(event);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;配置数据&lt;/h3&gt;
&lt;p&gt;　　代码无非是定义一些指令的集合让计算机来执行。我们常常将数据传入计算机，由指令对数据进行操作，并最终产生一个结果。当不得不修改数据时，可能会带来一些不必要的风险。应当将关键数据从代码中抽离出来 &lt;/p&gt;
&lt;p&gt;　　配置数据是指导在应用中写死的值，且将来可能会被修改，包括如下内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1、URL
2、需要展现给用户的字符串
3、重复的值
4、配置项
5、任何可能发生变更的值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是未处理配置数据的做法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//不好的做法
function validate(value){
  if(!value){
    alert('Invalid value');
    location.href=&quot;/errors/invalid.php&quot;;
  }
}
function toggleSelected(element){
  if(hasClass(element,'selected')){
    removeClass(element,'selected');
  }else{
    addClass(element,'selected');
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面代码中将配置数据保存在了config对象中，config对象的每个属性都保存了一个数据片段，每个属性名都有前缀，用以表明数据的类型(MSG表示展现给用户的信息，URL表示网络地址，CSS表示这是一个className)。当然，也可以将整个config对象放到单独的文件中，这样对配置数据的修改可以完全和使用这个数据的代码隔离开来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//好的做法
var config = {
  MSG_INVALID_VALUE: 'Invalid value',
  URL_INVALID:'/errors/invalid.php',
  CSS_SELECTED:'selected'
}
function validate(value){
  if(!value){
    alert(config.MSG_INVALID_VALUE);
    location.href=config.URL_INVALID;
  }
}
function toggleSelected(element){
  if(hasClass(element,config.CSS_SELECTED)){
    removeClass(element,config.CSS_SELECTED);
  }else{
    addClass(element,config.CSS_SELECTED);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;选择器优化&lt;/h3&gt;
&lt;p&gt;　　将选择器选择到的元素作为对象的静态属性集中到一个地方统一管理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;initializeElements: function() {
    var eles = app.Eles;
    for (var name in eles) {
        if (eles.hasOwnProperty(name)) {
            this[name] = $(eles[name]);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是一个例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//好的做法&lt;br/&gt;app.Eles = {
    widgetDiv: &quot;.left-widget div&quot;,
    inputResize: '.input-resize',
    hr: '.hr',
    txt: '.input-group-btn button',
    cus: '#paper-type-cus',
    hid: '#hidden',
    mainCon: '#mainCon',
    rulerX: '.ruler-x',
    rulerY: '.ruler-y',
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;函数优化&lt;/h3&gt;
&lt;p&gt;【提炼函数】&lt;/p&gt;
&lt;p&gt;　　在javascript开发中，大部分时间都在与函数打交道，所以希望这些函数有着良好的命名，函数体内包含的逻辑清晰明了。如果一个函数过长，不得不加上若干注释才能让这个函数显得易读一些，那这些函数就很有必要进行重构&lt;/p&gt;
&lt;p&gt;　　如果在函数中有一段代码可以被独立出来，那最好把这些代码放进另外一个独立的函数中。这是一种很常见的优化工作，这样做的好处主要有以下几点&lt;/p&gt;
&lt;p&gt;　　1、避免出现超大函数&lt;/p&gt;
&lt;p&gt;　　2、独立出来的函数有助于代码复用&lt;/p&gt;
&lt;p&gt;　　3、独立出来的函数更容易被覆写&lt;/p&gt;
&lt;p&gt;　　4、独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用&lt;/p&gt;
&lt;p&gt;　　比如在一个负责取得用户信息的函数里面，还需要打印跟用户信息有关的log，那么打印log的语句就可以被封装在一个独立的函数里：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
var getUserInfo =&lt;span&gt; function(){
    ajax( 'http:// xxx.com/userInfo'&lt;span&gt;, function( data ){
        console.log( 'userId: ' +&lt;span&gt; data.userId );
        console.log( 'userName: ' +&lt;span&gt; data.userName );
        console.log( 'nickName: ' +&lt;span&gt; data.nickName );
    });
};
//改成：
var getUserInfo =&lt;span&gt; function(){
    ajax( 'http:// xxx.com/userInfo'&lt;span&gt;, function( data ){
        printDetails( data );
    });
};
var printDetails =&lt;span&gt; function( data ){
    console.log( 'userId: ' +&lt;span&gt; data.userId );
    console.log( 'userName: ' +&lt;span&gt; data.userName );
    console.log( 'nickName: ' +&lt;span&gt; data.nickName );
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【尽量减少参数数量】&lt;/p&gt;
&lt;p&gt;　　如果调用一个函数时需要传入多个参数，那这个函数是让人望而生畏的，必须搞清楚这些参数代表的含义，必须小心翼翼地把它们按照顺序传入该函数。在实际开发中，向函数传递参数不可避免，但应该尽量减少函数接收的参数数量。下面举个非常简单的示例。有一个画图函数draw，它现在只能绘制正方形，接收了3个参数，分别是图形的width、heigth以及square：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
var draw = function(width,height,square){};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但实际上正方形的面积是可以通过width和height计算出来的，于是我们可以把参数square从draw函数中去掉：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
var draw =&lt;span&gt; function( width, height ){
    var square = width *&lt;span&gt; height;
};&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　假设以后这个draw函数开始支持绘制圆形，需要把参数width和height换成半径radius，但图形的面积square始终不应该由客户传入，而是应该在draw函数内部，由传入的参数加上一定的规则计算得来。此时，可以使用策略模式，让draw函数成为一个支持绘制多种图形的函数&lt;/p&gt;
&lt;p&gt;【传递对象参数代替过长的参数列表】 &lt;/p&gt;
&lt;p&gt;　　有时候一个函数有可能接收多个参数，而参数的数量越多，函数就越难理解和使用。使用该函数的人首先得搞明白全部参数的含义，在使用的时候，还要小心翼翼，以免少传了某个参数或者把两个参数搞反了位置。如果想在第3个参数和第4个参数之中增加一个新的参数，就会涉及许多代码的修改，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
var setUserInfo =&lt;span&gt; function( id, name, address, sex, mobile, qq ){
    console.log( 'id= ' +&lt;span&gt; id );
    console.log( 'name= ' +&lt;span&gt;name );
    console.log( 'address= ' +&lt;span&gt; address );
    console.log( 'sex= ' +&lt;span&gt; sex );
    console.log( 'mobile= ' +&lt;span&gt; mobile );
    console.log( 'qq= ' +&lt;span&gt; qq );
};
setUserInfo( 1314, 'xiaohuochai', 'beijing', 'male', '150********', 121631835 );&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这时可以把参数都放入一个对象内，然后把该对象传入setUserInfo函数，setUserInfo函数需要的数据可以自行从该对象里获取。现在不用再关心参数的数量和顺序，只要保证参数对应的key值不变就可以了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    var setUserInfo =&lt;span&gt; function( obj ){
        console.log( 'id= ' +&lt;span&gt; obj.id );
        console.log( 'name= ' +&lt;span&gt; obj.name );
        console.log( 'address= ' +&lt;span&gt; obj.address );
        console.log( 'sex= ' +&lt;span&gt; obj.sex );
        console.log( 'mobile= ' +&lt;span&gt; obj.mobile );
        console.log( 'qq= ' +&lt;span&gt; obj.qq );
    };
    setUserInfo({
        id: 1314&lt;span&gt;,
        name: 'xiaohuochai'&lt;span&gt;,
        address: 'beijing'&lt;span&gt;,
        sex: 'male'&lt;span&gt;,
        mobile: '150********'&lt;span&gt;,
        qq: 121631835&lt;span&gt;
    });&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;条件优化&lt;/h3&gt;
&lt;p&gt;【合并条件片段】&lt;/p&gt;
&lt;p&gt;　　如果一个函数体内有一些条件分支语句，而这些条件分支语句内部散布了一些重复的代码，那么就有必要进行合并去重工作。假如有一个分页函数paging，该函数接收一个参数currPage，currPage表示即将跳转的页码。在跳转之前，为防止currPage传入过小或者过大的数字，要手动对它的值进行修正，详见如下伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
var paging =&lt;span&gt; function( currPage ){
    if ( currPage &amp;lt;= 0&lt;span&gt; ){
        currPage = 0&lt;span&gt;;
        jump( currPage ); // 跳转
    }else if ( currPage &amp;gt;=&lt;span&gt; totalPage ){
        currPage =&lt;span&gt; totalPage;
        jump( currPage ); // 跳转
    }else&lt;span&gt;{
        jump( currPage ); // 跳转
&lt;span&gt;    }
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，负责跳转的代码jump(currPage)在每个条件分支内都出现了，所以完全可以把这句代码独立出来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
var paging =&lt;span&gt; function( currPage ){
    if ( currPage &amp;lt;= 0&lt;span&gt; ){
        currPage = 0&lt;span&gt;;
    }else if ( currPage &amp;gt;=&lt;span&gt; totalPage ){
        currPage =&lt;span&gt; totalPage;
    }
    jump( currPage ); // 把jump 函数独立出来
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【把条件分支语句提炼成函数】&lt;/p&gt;
&lt;p&gt;　　在程序设计中，复杂的条件分支语句是导致程序难以阅读和理解的重要原因，而且容易导致一个庞大的函数。假设现在有一个需求是编写一个计算商品价格的getPrice函数，商品的计算只有一个规则：如果当前正处于夏季，那么全部商品将以8折出售。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
var getPrice =&lt;span&gt; function( price ){
    var date = new&lt;span&gt; Date();
    if ( date.getMonth() &amp;gt;= 6 &amp;amp;&amp;amp; date.getMonth() &amp;lt;= 9 ){ // 夏天
        return price * 0.8&lt;span&gt;;
    }
    return&lt;span&gt; price;
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　观察这句代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
date.getMonth()&amp;gt;=6&amp;amp;&amp;amp;date.getMonth()&amp;lt;=9
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这句代码要表达的意思很简单，就是判断当前是否正处于夏天（7~10月）。尽管这句代码很短小，但代码表达的意图和代码自身还存在一些距离，阅读代码的人必须要多花一些精力才能明白它传达的意图。其实可以把这句代码提炼成一个单独的函数，既能更准确地表达代码的意思，函数名本身又能起到注释的作用。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
var isSummer =&lt;span&gt; function(){
    var date = new&lt;span&gt; Date();
    return date.getMonth() &amp;gt;= 6 &amp;amp;&amp;amp; date.getMonth() &amp;lt;= 9&lt;span&gt;;
};

var getPrice =&lt;span&gt; function( price ){
    if ( isSummer() ){ // 夏天
        return price * 0.8&lt;span&gt;;
    }
    return&lt;span&gt; price;
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【提前让函数退出代替嵌套条件分支】&lt;/p&gt;
&lt;p&gt;　　许多程序员都有这样一种观念：“每个函数只能有一个入口和一个出口。”现代编程语言都会限制函数只有一个入口。但关于“函数只有一个出口”，往往会有一些不同的看法。下面这段伪代码是遵守“函数只有一个出口的”的典型代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
var del =&lt;span&gt; function( obj ){
    var&lt;span&gt; ret;
    if ( !obj.isReadOnly ){ // 不为只读的才能被删除
        if ( obj.isFolder ){ // 如果是文件夹
            ret =&lt;span&gt; deleteFolder( obj );
        }else if ( obj.isFile ){ // 如果是文件
            ret =&lt;span&gt; deleteFile( obj );
        }
    }
    return&lt;span&gt; ret;
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　嵌套的条件分支语句绝对是代码维护者的噩梦，对于阅读代码的人来说，嵌套的if、else语句相比平铺的if、else，在阅读和理解上更加困难。嵌套的条件分支往往是由一些深信“每个函数只能有一个出口的”程序员写出的。但实际上，如果对函数的剩余部分不感兴趣，那就应该立即退出。引导阅读者去看一些没有用的else片段，只会妨碍他们对程序的理解&lt;/p&gt;
&lt;p&gt;　　于是可以挑选一些条件分支，在进入这些条件分支之后，就立即让这个函数退出。要做到这一点，有一个常见的技巧，即在面对一个嵌套的if分支时，可以把外层if表达式进行反转。重构后的del函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
var del =&lt;span&gt; function( obj ){
    if ( obj.isReadOnly ){ // 反转if 表达式
        return&lt;span&gt;;
    }
    if&lt;span&gt; ( obj.isFolder ){
        return&lt;span&gt; deleteFolder( obj );
    }
    if&lt;span&gt; ( obj.isFile ){
        return&lt;span&gt; deleteFile( obj );
    }
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;循环优化&lt;/h3&gt;
&lt;p&gt;【合理使用循环】&lt;/p&gt;
&lt;p&gt;　　在函数体内，如果有些代码实际上负责的是一些重复性的工作，那么合理利用循环不仅可以完成同样的功能，还可以使代码量更少。下面有一段创建XHR对象的代码，为了简化示例，只考虑版本9以下的IE浏览器，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
var createXHR =&lt;span&gt; function(){
    var&lt;span&gt; xhr;
    try&lt;span&gt;{
        xhr = new ActiveXObject( 'MSXML2.XMLHttp.6.0'&lt;span&gt; );
    }catch&lt;span&gt;(e){
        try&lt;span&gt;{
            xhr = new ActiveXObject( 'MSXML2.XMLHttp.3.0'&lt;span&gt; );
        }catch&lt;span&gt;(e){
            xhr = new ActiveXObject( 'MSXML2.XMLHttp'&lt;span&gt; );
        }
    }
    return&lt;span&gt; xhr;
};
var xhr =&lt;span&gt; createXHR();&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面灵活地运用循环，可以得到跟上面代码一样的效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
//下面我们灵活地运用循环，可以得到跟上面代码一样的效果：
var createXHR =&lt;span&gt; function(){
    var versions= [ 'MSXML2.XMLHttp.6.0ddd', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp'&lt;span&gt; ];
    for ( var i = 0, version; version = versions[ i++&lt;span&gt; ]; ){
        try&lt;span&gt;{
            return new&lt;span&gt; ActiveXObject( version );
        }catch&lt;span&gt;(e){
        }
    }
};
var xhr = createXHR();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【用return退出多重循环】&lt;/p&gt;
&lt;p&gt;　　假设在函数体内有一个两重循环语句，需要在内层循环中判断，当达到某个临界条件时退出外层的循环。大多数时候会引入一个控制标记变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
var func =&lt;span&gt; function(){
    var flag = false&lt;span&gt;;
    for ( var i = 0; i &amp;lt; 10; i++&lt;span&gt; ){
        for ( var j = 0; j &amp;lt; 10; j++&lt;span&gt; ){
            if ( i * j &amp;gt;30&lt;span&gt; ){
                flag = true&lt;span&gt;;
                break&lt;span&gt;;
            }
        }
        if ( flag === true&lt;span&gt; ){
            break&lt;span&gt;;
        }
    }
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第二种做法是设置循环标记：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
var func =&lt;span&gt; function(){
    outerloop:
    for ( var i = 0; i &amp;lt; 10; i++&lt;span&gt; ){
        innerloop:
        for ( var j = 0; j &amp;lt; 10; j++&lt;span&gt; ){
            if ( i * j &amp;gt;30&lt;span&gt; ){
                break&lt;span&gt; outerloop;
            }
        }
    }
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这两种做法无疑都让人头晕目眩，更简单的做法是在需要中止循环的时候直接退出整个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
var func =&lt;span&gt; function(){
    for ( var i = 0; i &amp;lt; 10; i++&lt;span&gt; ){
        for ( var j = 0; j &amp;lt; 10; j++&lt;span&gt; ){
            if ( i * j &amp;gt;30&lt;span&gt; ){
                return&lt;span&gt;;
            }
        }
    }
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当然用return直接退出方法会带来一个问题，如果在循环之后还有一些将被执行的代码呢？如果提前退出了整个方法，这些代码就得不到被执行的机会：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
var func =&lt;span&gt; function(){
    for ( var i = 0; i &amp;lt; 10; i++&lt;span&gt; ){
        for ( var j = 0; j &amp;lt; 10; j++&lt;span&gt; ){
            if ( i * j &amp;gt;30&lt;span&gt; ){
                return&lt;span&gt;;
            }
        }
    }
    console.log( i ); // 这句代码没有机会被执行
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为了解决这个问题，可以把循环后面的代码放到return后面，如果代码比较多，就应该把它们提炼成一个单独的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
var print =&lt;span&gt; function( i ){
    console.log( i );
};
var func =&lt;span&gt; function(){
    for ( var i = 0; i &amp;lt; 10; i++&lt;span&gt; ){
        for ( var j = 0; j &amp;lt; 10; j++&lt;span&gt; ){
            if ( i * j &amp;gt;30&lt;span&gt; ){
                return&lt;span&gt; print( i );
            }
        }
    }
};&lt;br/&gt;func();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 11 Jan 2018 10:12:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8006285.html</dc:identifier>
</item>
<item>
<title>用Vue自己造个组件轮子，以及实践背后带来的思考 - 闰土大叔</title>
<link>http://www.cnblogs.com/running-runtu/p/8269302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/8269302.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/701424/201801/701424-20180111185150285-611927890.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;首先，向大家说声抱歉。由于之前的井底之蛙，误认为Vue.js还远没有覆盖到二三线城市的互联网小厂里。现在我错了，从我司的前端技术选型之路便可见端倪。以太原为例，已经有不少公司陆续开始采用Vue.js作为他们公司前端的技术栈，前后端分离正搞得热火朝天，还有更多的公司正在来时的路上。所以说，还在校的童鞋和仍在培训的萌新们，Vue已经成为现在前端的标配技能之一，为防止掉队，跟着闰土大叔学起来吧。&lt;/p&gt;
&lt;p&gt;接下来，正文从这开始~&lt;/p&gt;
&lt;p&gt;先来了解下当前的行业背景：&lt;/p&gt;
&lt;p&gt;随着SPA、前后端分离的技术架构在业界越来越流行，前端的业务复杂度也越来越高，导致前端开发者需要管理的内容，承担的职责越来越多，这一切，使得业界对前端开发方案的思考多了很多，以react、vue等框架为代表推动的组件化开发模式越来越被开发者认可，这种模式极大的降低了我们开发与维护的成本。&lt;/p&gt;
&lt;p&gt;最近一段时间，我也在研究Vue，在网上看了那么多基于Vue的组件，何不自己也来造个小轮子，有了这个想法后，撸子袖子就是干。本文提供代码仅仅是提供而已，重要的是思路。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用Vue造个组件轮子吧-闰土大叔&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input-number &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;value&quot;&lt;/span&gt;&lt;span&gt; :max&lt;/span&gt;&lt;span&gt;=&quot;20&quot;&lt;/span&gt;&lt;span&gt; :min&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;input-number&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; isValueNumber(value){
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;(^-?[0-9]+\.{1}\d+$)|(^-?[1-9][0-9]*$)|(^-?0{1}$)&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;).test(value &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;input-number&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;    template:`
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input-number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;                      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; &lt;br/&gt;　　　　　　　　　　　　　　　　　　　:value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;currentValue&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　@change&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;handleChange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; &lt;br/&gt;　　　　　　　　　　　　　　　　　　　ref&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; &lt;br/&gt;　　　　　　　　　　　　　　　　　　　@keydown&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;show($event)&lt;/span&gt;&lt;span&gt;&quot;/&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;                      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button @click&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;handleDown&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; :disabled&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;currentValue &amp;lt;= min&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;-&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;button&amp;gt;&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;                      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button @click&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;handleUp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; :disabled&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;currentValue &amp;gt;= max&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;+&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;button&amp;gt;&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;div&amp;gt;&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;             `,
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;    props:{
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;        max:{
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;            type:Number,
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;             &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:Infinity
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        min:{
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;            type:Number,
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;             &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Infinity
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;        value:{
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;            type:Number,
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;             &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;        step:{
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;            type:Number,
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    data: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;            currentValue: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;    watch:{
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;        currentValue:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val){
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$emit(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,val);
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;        value:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val){
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.updateValue(val);
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;    methods:{
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        handleDown: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentValue &lt;/span&gt;&lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.min) &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentValue &lt;/span&gt;&lt;span&gt;-=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.step;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;        handleUp: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentValue &lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.max) &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentValue &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.step;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        updateValue:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val){
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(val &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.max) val &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.max;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(val &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.min) val &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.min;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentValue &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;        handleChange:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; val &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; event.target.value.trim();
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; max &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.max;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; min &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.min;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isValueNumber(val)){
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;                val &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Number(val);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentValue &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(val &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; max){
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentValue &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; max;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(val &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; min){
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentValue &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; min;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;                event.target.value &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentValue;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;        show:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(ev){
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;            console.log(ev.keyCode)
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(ev.keyCode &lt;/span&gt;&lt;span&gt;==&lt;/span&gt; &lt;span&gt;38&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handleUp();
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(ev.keyCode &lt;/span&gt;&lt;span&gt;==&lt;/span&gt; &lt;span&gt;40&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handleDown();
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;    mounted:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.updateValue(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].focus();
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;    el:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;    data:{
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;        value:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你掌握了Vue的组件知识，相关的指令、事件，花点时间你也可以造出这么个入门级的小轮子。如果这篇文章只是单纯的贴出组件轮子代码那也太easy了。接下来，抛出造轮子实践背后带来的一些思考。&lt;/p&gt;
&lt;p&gt;第一问：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;vue 已经挂载的组件怎么初始化里面的data?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;能问出这个问题的童鞋，说明你已经迷上了Vue。按照源码里讲的，vue将数据绑定到组件的原理分为三个步骤： 当实例化一个Vue构造函数，会执行 Vue 的 init 方法，在 init 方法中主要执行三部分内容，一是初始化环境变量，二是处理 Vue 组件数据，三是解析挂载组件。以上三部分内容构成了 Vue 的整个执行过程。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二问：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;vue 注册组件为什么要必须发生在根实例初始化前？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/701424/201801/701424-20180111165130207-733783997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可能你已经熟读Vue官方API文档，但是这个问题你考虑过么。如果在Vue根实例初始化之后才注册组件会发生什么？如果你有兴趣，我可以等你实践30秒再说我的想法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/701424/201801/701424-20180111163722707-1729960922.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;30秒时间到了，在等你的时候，我又实践了一遍。是的，报错了。大意是，未知的自定义元素：&amp;lt;input-number&amp;gt; - 你是否正确注册了组件？对于递归组件，请确保提供name选项。&lt;/p&gt;
&lt;p&gt;我曾翻阅过官网API文档，也曾阅览过相关的书籍，但里面都是简单的提了一句：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/701424/201801/701424-20180111164532347-82710222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个问题无解么，不是的。其实你仔细想想报错信息，你应该会泯然一笑，说的通俗点，这就像坐高铁，买了票才能上。因为实例化的时候会尝试找这个组件，你不提前注册就找不到了。如果硬要深究，只能去看源码了。&lt;/p&gt;
&lt;p&gt;第三问：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这个数字输入框组件网上很常见，在此基础上你有做什么扩展么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;是的，与网上的数字输入框组件不同的，我做了两个扩展。&lt;/p&gt;
&lt;p&gt;第一个扩展：input框自动获取焦点，在输入框聚焦时，监听键盘上下按键的操作，相当于加1或者减1。&lt;/p&gt;
&lt;p&gt;实现的思路，在input输入框上定义一个ref为input引用，然后在模板渲染完毕之后，在mounted钩子里，通过$refs查找到对应的ID：input，然后focus。获取完焦点之后，接下来就是如何监听键盘上下按键的操作。首先，我们通过keydown事件绑定一个show()方法，里面传一个$event参数，然后在子组件的methods选项内创建一个show方法。我们都知道，键盘上的上键对应的keyCode码是38，下键对应的是40。 有了这个之后，我们做一个条件判断（上加下减），如果event的keyCode码为38，就调用handleUp()方法，如果是40，就调用handleDown()方法。至此，监听键盘上下键的按下进而操作input数值的扩展完成。&lt;/p&gt;
&lt;p&gt;第二个扩展：给组件增加一个控制步伐的prop——step，比如设置为10，点击加号按钮，一次增加10。&lt;/p&gt;
&lt;p&gt;继续说说我的思路，这个就相对来说比较简单了，首先在props选项内定义一个step对象，类型设置为Number，默认值设置为5。然后将methods里面的handleDown和handleUp里面将 this.currentValue +/-= （具体的数值）替换为 this.step。相当于进一步封装了它的可用性。至此，所有扩展完成。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;自己曾经求职面试前端，因不会Vue框架而被淘汰，而且不止一次，也曾因此赋闲半年在家。所以，事不过三，我要抓紧时间学会它，以及它的全家桶。有原则有危机感的人，往往都是之前吃过大亏的人。他们知道犯错误的代价，所以不敢触碰这个红线。愿我走过的路踩过的坑，你们不会再踩一遍，才会哭着鼻子记住这个教训。以铜为镜,可以正衣冠;以人为镜,可以明得失。在之后的日子里，我还会继续更新vue相关的文章，愿我们都做一个爱思考的孩子。前端路上，we are not alone。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt; 想了解我的更多动态？欢迎关注我的公众号：闰土大叔，或者添加我的个人微信号：wxd91traveler，期待与你发生一段纯纯的友谊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/701424/201801/701424-20180111183848832-1222735455.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Jan 2018 09:45:00 +0000</pubDate>
<dc:creator>闰土大叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/8269302.html</dc:identifier>
</item>
<item>
<title>SQL Server扩充表字段长度，引发的意外KILLED/ROLLBACK - 神雕爱大侠</title>
<link>http://www.cnblogs.com/sdadx/p/8269241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdadx/p/8269241.html</guid>
<description>&lt;p&gt;  　这一段时间，因为系统升级，新系统产生的数据长度，比原来的数据长度要长，所以说要扩充一下字段长度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; TableName &lt;span&gt;alter&lt;/span&gt; &lt;span&gt;column&lt;/span&gt; ColumnName &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;)    --修改字段长度sql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在执行的时候，有这样一个情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如Student表的Name字段长度是nvarchar(50),&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假如想变成nvarchar(100)，这种情况，立刻能执行成功。　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假如想变成nvarchar(20)，这种情况，会执行很久。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有一些表没啥问题，但是有一个表数据量较大，差不多有1亿多，执行时间太长，还把所有数据表给锁住了（如下图）。不过这种情况数据还能用语句查询。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/662616/201801/662616-20180111164955863-501923931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;①我就查询出这个语句的spid。之后kill掉。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;   session_id, r.status, r.start_time, r.command, s.&lt;span&gt;text&lt;/span&gt;&lt;span&gt;, r.wait_time, r.cpu_time, 
r.total_elapsed_time, r.reads, r.writes, r.logical_reads, r.transaction_isolation_level 
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; sys.dm_exec_requests r 
&lt;/span&gt;&lt;span&gt;CROSS&lt;/span&gt;&lt;span&gt; APPLY sys.dm_exec_sql_text(r.sql_handle) s
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; R.STATUS&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;running&lt;/span&gt;&lt;span&gt;'&lt;p&gt;kill 75&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/662616/201801/662616-20180111165341363-916015044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;②但是连续kill了好几遍，依然没啥效果，还是提示锁住。所有就继续看下spid为75的状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　方法1：&lt;/strong&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; spid, blocked,waittime,lastwaittype,dbid,last_batch,open_tran,hostprocess,cmd &lt;span&gt;from&lt;/span&gt; sysprocesses &lt;span&gt;where&lt;/span&gt; spid &lt;span&gt;=&lt;/span&gt; &lt;span&gt;75&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/662616/201801/662616-20180111165901597-1438672579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 　　方法2：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; master;    
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;    
&lt;span&gt;EXEC&lt;/span&gt; sp_who &lt;span&gt;'&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;指定process_id;    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/662616/201801/662616-20180111170149957-1341474218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 两种方法查询出来的都是KILLED/ROLLBACK,表示，现在数据在回滚。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;③查询一下，数据的回滚状态。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;KILL&lt;/span&gt; &lt;span&gt;75&lt;/span&gt; &lt;span&gt;WITH&lt;/span&gt; STATUSONLY; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/662616/201801/662616-20180111170622254-510579561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查了一下，这个情况要等好久，有的等两三天的都有，最好的解决办法无非是&lt;span&gt;重启。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----------------------------------------------------解决办法------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 网上找了好久，找了找到了一篇结决办法。&lt;/p&gt;
&lt;p&gt;1.查询出处于阻塞的sql线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_9be7ea76-15ba-4dc0-9b74-e4dc2a969113&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9be7ea76-15ba-4dc0-9b74-e4dc2a969113&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9be7ea76-15ba-4dc0-9b74-e4dc2a969113&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt;
&lt;span&gt;TRANSACTION&lt;/span&gt;
&lt;span&gt;ISOLATION&lt;/span&gt;
&lt;span&gt;LEVEL&lt;/span&gt;
&lt;span&gt;READ&lt;/span&gt;
&lt;span&gt;UNCOMMITTED&lt;/span&gt;

&lt;span&gt;SELECT&lt;/span&gt;

&lt;span&gt;db_id&lt;/span&gt;(&lt;span&gt;DB_NAME&lt;/span&gt;(er.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;database_id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;)) &lt;span&gt;[&lt;/span&gt;&lt;span&gt;DBID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;

,er.&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;session_id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;SessionID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;

,er.&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;command&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;CommandType&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;

,est.&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;StatementText&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;

,er.&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;status&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;

,&lt;/span&gt;&lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;DECIMAL&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), er.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;percent_complete&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;) &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Complete_Percent&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;

,&lt;/span&gt;&lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;DECIMAL&lt;/span&gt;(&lt;span&gt;38&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), er.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;total_elapsed_time&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;60000.00&lt;/span&gt;) &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;ElapsedTime_m&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;

,&lt;/span&gt;&lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;DECIMAL&lt;/span&gt;(&lt;span&gt;38&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), er.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;estimated_completion_time&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;60000.00&lt;/span&gt;) &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;EstimatedCompletionTime_m&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;

,er.&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;last_wait_type&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;LastWait&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;

,er.&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;wait_resource&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;CurrentWait&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;
sys.dm_exec_requests
&lt;/span&gt;&lt;span&gt;AS&lt;/span&gt;&lt;span&gt; er

&lt;/span&gt;&lt;span&gt;INNER&lt;/span&gt;
&lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt;
sys.dm_exec_sessions
&lt;/span&gt;&lt;span&gt;AS&lt;/span&gt; es &lt;span&gt;ON&lt;/span&gt; er.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;session_id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; es.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;session_id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;CROSS&lt;/span&gt;&lt;span&gt;
APPLY sys.dm_exec_sql_text(er.&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;sql_handle&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;) est

&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; er.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;command&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;like&lt;/span&gt;
&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Killed%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;2.查到spid是75，根据spid查询出来系统进程hostprocess为20540。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_b39c447e-c817-4842-bf76-e6c5f953b25c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b39c447e-c817-4842-bf76-e6c5f953b25c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b39c447e-c817-4842-bf76-e6c5f953b25c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; spid, blocked,waittime,lastwaittype,dbid,last_batch,open_tran,hostprocess,cmd &lt;span&gt;from&lt;/span&gt; sysprocesses &lt;span&gt;where&lt;/span&gt; spid &lt;span&gt;=&lt;/span&gt; &lt;span&gt;69&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/662616/201801/662616-20180111172031222-1516784167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.在执行这条语句的机器上，用cmd命令查询出来。&lt;/p&gt;
&lt;p&gt;tasklist|findstr 进程号&lt;/p&gt;
&lt;p&gt;如：tasklist|findstr 75&lt;/p&gt;
&lt;p&gt; 4.cmd中根据进程名称杀死进程&lt;/p&gt;
&lt;p&gt; taskkill /f /t /im 进程名称&lt;/p&gt;
&lt;p&gt;如：taskkill /f /t /im /svchost.exe&lt;/p&gt;

&lt;p&gt;如果不行，只有等，或者重启了。&lt;/p&gt;

&lt;p&gt;参考文章：1.&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/kerrycode/p/5981763.html&quot;&gt;&lt;span&gt;SQL Server会话KILL不掉，一直处于KILLED /ROLLBACK状态情形浅析&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                  2. &lt;a href=&quot;http://bbs.csdn.net/topics/230027789&quot; target=&quot;_blank&quot;&gt;数据库某个进程一直处在KILLED/ROLLBACK&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　    3.&lt;a href=&quot;http://blog.sina.com.cn/s/blog_611f224f0100r511.html&quot; target=&quot;_blank&quot;&gt;百度 谷歌 新浪 执行 SQL 出现 Lock request time out period exceeded.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　　&lt;a href=&quot;http://blogs.lostincreativity.com/sqldba/transaction-rollback-in-progress-estimated-rollback-completion-0-estimated-time-remaining-0-seconds/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://lostincreativity.com/website/Content/Images/logo/sqldbalogo.png&quot; alt=&quot;SQL DBA思想的一些Ramblings&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;title text_overflow&quot;&gt;　　　　    &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Jan 2018 09:39:00 +0000</pubDate>
<dc:creator>神雕爱大侠</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sdadx/p/8269241.html</dc:identifier>
</item>
<item>
<title>apidoc快速生成在线文档，apidoc生成静态文件的生成规则以及原理分析 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/8249960.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/8249960.html</guid>
<description>&lt;p&gt;在老大的指引下，需要将系统的json文件格式转换成apidoc的json格式，也就是json格式的重组，但是这个apidoc的生成格式是不固定的，因为apidoc有自己一套的生成规则，我需要研究一下是怎么生成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、官方基础栗子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、理解apidoc生成静态文档的结构解读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、深入理解一下apidoc生成原理以及规则&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、apidoc基础栗子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;全局安装apidoc&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install apidoc -g
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1、首先建立文件目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111153536316-790625906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、需要你在input文件夹里面写上你的js部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180109094438207-1219943073.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个是栗子的js部分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
  @api {get} /user/:id Request User information
  @apiName GetUser
  @apiGroup User
 
  @apiParam {Number} id Users unique ID.

  @apiSuccess {String} firstname Firstname of the User.
  @apiSuccess {String} lastname  Lastname of the User.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;



 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
  @api {post} /user/:id Create User information
  @apiName CreateUser
  @apiGroup User
 
  @apiParam {Number} id Users unique ID.

  @apiSuccess {String} data
  @apiSuccess {String} data.firstname Firstname of the User.
  @apiSuccess {String} data.first.lastname  Lastname of the User.

  @apiSuccessExample {json} Success-Response:
 *     HTTP/1.1 200 OK
 *     {
 *       &quot;firstname&quot;: &quot;John&quot;,
 *       &quot;lastname&quot;: &quot;Doe&quot;
 *     }
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3、新建apidoc.json文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;apidoc.json栗子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{ 
  &lt;/span&gt;&quot;name&quot;: &quot;example&quot;&lt;span&gt;, 
  &lt;/span&gt;&quot;version&quot;: &quot;0.1.0&quot;&lt;span&gt;, 
  &lt;/span&gt;&quot;description&quot;: &quot;apiDoc basic example&quot;&lt;span&gt;, 
  &lt;/span&gt;&quot;title&quot;: &quot;Custom apiDoc browser title&quot;&lt;span&gt;, 
  &lt;/span&gt;&quot;url&quot; : &quot;https://api.github.com/v1&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、在myapp文件夹下面运行&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
apidoc -i myapp/ -o apidoc/ -t mytemplate/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;官网原文：Creates an apiDoc of all files within dir &lt;code&gt;myapp/&lt;/code&gt;, uses template from dir &lt;code&gt;mytemplate/&lt;/code&gt; and put all output to dir &lt;code&gt;apidoc/&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-i  是输入文件的路径 ，  -o 是输出文件的路径，   -t是使用模板的路径（可缺省）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180109095056988-1352825810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打开output文件夹，发现生成一个apidoc在线文档，直接打开html就可以看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180109095438785-1001509915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打开html文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180109095621363-91345607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、理解apidoc生成静态文档的结构解读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个静态的文档很漂亮的生成了，但是实际控制这个现实的是api_data.js和api_project.js。但是实际上的数据显示是由api_data.json和api_project.json这两个json文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以在支持将其他json格式转换成&lt;/strong&gt;api_data.json和&lt;strong&gt;api_project.json&lt;/strong&gt;，把apidoc生成的这两个文件进行替换，然后替换js文件，直接生产静态文档。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以看一下api_data.json格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111151906441-328350695.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对比一下&lt;strong&gt;api_data.js格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111151955707-1793667753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显就能看出来，就是在api_data.json的基础上，封装成了一层，加上&lt;strong&gt;define({ &quot;api&quot;: api_data.json});&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;api_project.json和api_project.js也是使用相同的方法封装的。&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、深入理解一下apidoc生成原理以及规则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;apidoc设计到如下的参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111154421722-1895770981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）第一个是@api&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@api是必须的，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@api {method} path [title]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111154901426-1757683041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;method    包括请求的方式：get，post，put，delete，等&lt;/p&gt;
&lt;p&gt;path  表示请求的路径。&lt;/p&gt;
&lt;p&gt;title  （可选项）表示分组的解释，导航。&lt;/p&gt;
&lt;p&gt;对应的静态页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111155849051-728147629.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）@apiDefine&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@apiDefine name [title] [description]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表示的是：嵌入在api块或api中的文档块&lt;/p&gt;
&lt;p&gt;没有找到对应的页面&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）@apiDeprecated&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
@apiDeprecated [text]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;标志位api方法的反对（不对）的地方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111163407926-496904765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）@apiDescription&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示的是描述。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
@apiDescription text
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111163853941-2072416300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面上显示的是：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111163924176-1807138729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;（5）@apiError和&lt;/strong&gt;@apiErrorExample&lt;/p&gt;
&lt;p&gt;表示的错误返回的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@apiError [(group)] [{type}] field [description]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111165610129-684694648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面的显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111165702504-1085818399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（6）@apiGroup&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个是必填项，表示的分组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111165936738-456266362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面显示的是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111170016129-1162241329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（7）@apiHeader&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示的是：传递给API头部的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@apiHeader [(group)] {type} [field=defaultValue] [description]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111171620707-1425493461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现：@&lt;strong&gt;apiHeader与@apiParam用法显示上很像，但是在生成的api_data.json所在的树形结构不一致。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111172016597-1112584875.png&quot; alt=&quot;&quot;/&gt;，上面的红框是@apiHeader生成的，下面的红框是@apiParam生成的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;（8）@apiParam&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 表示的：传递给API方法的参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111172326301-1141052332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面显示的是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111172403566-1886966275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;（9）@apiParamExample&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示的是：参数实例&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111172659847-220888828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面上的显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111172724566-140928523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; （10）@apiSuccess和@apiSuccessExample&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示的是：成功返回的参数。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111172906410-2071064520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面上的显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180111172954941-2082519347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;目前主要用到了这10多个参数，还是够完成老大要求的任务。&lt;/p&gt;

</description>
<pubDate>Thu, 11 Jan 2018 09:36:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/8249960.html</dc:identifier>
</item>
<item>
<title>Go同步和异步执行多个任务封装(Runner和RunnerAsync) - 雪山飞猪</title>
<link>http://www.cnblogs.com/chenqionghe/p/8269556.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqionghe/p/8269556.html</guid>
<description>&lt;p&gt;同步适合多个连续执行的，每一步的执行依赖于上一步操作，异步执行则和任务执行顺序无关(如从10个站点抓取数据)&lt;/p&gt;

&lt;h2&gt;支持返回超时检测，系统中断检测&lt;/h2&gt;
&lt;p&gt;错误常量定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
//超时错误
var ErrTimeout = errors.New(&quot;received timeout&quot;)

//操作系统系统中断错误
var ErrInterrupt = errors.New(&quot;received interrupt&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package task

import (
    &quot;os&quot;
    &quot;time&quot;
    &quot;os/signal&quot;
    &quot;sync&quot;
)

//异步执行任务
type Runner struct {
    //操作系统的信号检测
    interrupt chan os.Signal

    //记录执行完成的状态
    complete chan error

    //超时检测
    timeout &amp;lt;-chan time.Time

    //保存所有要执行的任务,顺序执行
    tasks []func(id int) error

    waitGroup sync.WaitGroup

    lock sync.Mutex

    errs []error
}

//new一个Runner对象
func NewRunner(d time.Duration) *Runner {
    return &amp;amp;Runner{
        interrupt: make(chan os.Signal, 1),
        complete:  make(chan error),
        timeout:   time.After(d),
        waitGroup: sync.WaitGroup{},
        lock:      sync.Mutex{},
    }
}

//添加一个任务
func (this *Runner) Add(tasks ...func(id int) error) {
    this.tasks = append(this.tasks, tasks...)
}

//启动Runner，监听错误信息
func (this *Runner) Start() error {

    //接收操作系统信号
    signal.Notify(this.interrupt, os.Interrupt)

    //并发执行任务
    go func() {
        this.complete &amp;lt;- this.Run()
    }()

    select {
    //返回执行结果
    case err := &amp;lt;-this.complete:
        return err
        //超时返回
    case &amp;lt;-this.timeout:
        return ErrTimeout
    }
}

//异步执行所有的任务
func (this *Runner) Run() error {
    for id, task := range this.tasks {
        if this.gotInterrupt() {
            return ErrInterrupt
        }

        this.waitGroup.Add(1)
        go func(id int) {
            this.lock.Lock()

            //执行任务
            err := task(id)
            //加锁保存到结果集中
            this.errs = append(this.errs, err)

            this.lock.Unlock()
            this.waitGroup.Done()
        }(id)
    }
    this.waitGroup.Wait()

    return nil
}

//判断是否接收到操作系统中断信号
func (this *Runner) gotInterrupt() bool {
    select {
    case &amp;lt;-this.interrupt:
        //停止接收别的信号
        signal.Stop(this.interrupt)
        return true
        //正常执行
    default:
        return false
    }
}

//获取执行完的error
func (this *Runner) GetErrs() []error {
    return this.errs
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;使用方法　　　　&lt;/h2&gt;
&lt;p&gt;Add添加一个任务，任务为接收int类型的一个闭包&lt;/p&gt;
&lt;p&gt;Start开始执行伤，返回一个error类型，nil为执行完毕, ErrTimeout代表执行超时，ErrInterrupt代表执行被中断(类似Ctrl + C操作)&lt;/p&gt;

&lt;h2&gt;测试示例代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package task

import (
    &quot;testing&quot;
    &quot;time&quot;
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;runtime&quot;
)

func TestRunnerAsync_Start(t *testing.T) {

    //开启多核
    runtime.GOMAXPROCS(runtime.NumCPU())

    //创建runner对象，设置超时时间
    runner := NewRunnerAsync(8 * time.Second)
    //添加运行的任务
    runner.Add(
        createTaskAsync(),
        createTaskAsync(),
        createTaskAsync(),
        createTaskAsync(),
        createTaskAsync(),
        createTaskAsync(),
        createTaskAsync(),
        createTaskAsync(),
        createTaskAsync(),
        createTaskAsync(),
        createTaskAsync(),
        createTaskAsync(),
        createTaskAsync(),
    )

    fmt.Println(&quot;同步执行任务&quot;)

    //开始执行任务
    if err := runner.Start(); err != nil {
        switch err {
        case ErrTimeout:
            fmt.Println(&quot;执行超时&quot;)
            os.Exit(1)
        case ErrInterrupt:
            fmt.Println(&quot;任务被中断&quot;)
            os.Exit(2)
        }
    }

    t.Log(&quot;执行结束&quot;)

}

//创建要执行的任务
func createTaskAsync() func(id int) {
    return func(id int) {
        fmt.Printf(&quot;正在执行%v个任务\n&quot;, id)
        //模拟任务执行,sleep两秒
        //time.Sleep(1 * time.Second)
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;执行结果&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
同步执行任务
正在执行0个任务
正在执行1个任务
正在执行2个任务
正在执行3个任务
正在执行4个任务
正在执行5个任务
正在执行6个任务
正在执行7个任务
正在执行8个任务
正在执行9个任务
正在执行10个任务
正在执行11个任务
正在执行12个任务
        runnerAsync_test.go:49: 执行结束
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; &lt;/h2&gt;

&lt;h2&gt;支持返回超时检测，系统中断检测&lt;/h2&gt;
&lt;p&gt;实现代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package task

import (
    &quot;os&quot;
    &quot;time&quot;
    &quot;os/signal&quot;
    &quot;sync&quot;
)

//异步执行任务
type Runner struct {
    //操作系统的信号检测
    interrupt chan os.Signal

    //记录执行完成的状态
    complete chan error

    //超时检测
    timeout &amp;lt;-chan time.Time

    //保存所有要执行的任务,顺序执行
    tasks []func(id int) error

    waitGroup sync.WaitGroup

    lock sync.Mutex

    errs []error
}

//new一个Runner对象
func NewRunner(d time.Duration) *Runner {
    return &amp;amp;Runner{
        interrupt: make(chan os.Signal, 1),
        complete:  make(chan error),
        timeout:   time.After(d),
        waitGroup: sync.WaitGroup{},
        lock:      sync.Mutex{},
    }
}

//添加一个任务
func (this *Runner) Add(tasks ...func(id int) error) {
    this.tasks = append(this.tasks, tasks...)
}

//启动Runner，监听错误信息
func (this *Runner) Start() error {

    //接收操作系统信号
    signal.Notify(this.interrupt, os.Interrupt)

    //并发执行任务
    go func() {
        this.complete &amp;lt;- this.Run()
    }()

    select {
    //返回执行结果
    case err := &amp;lt;-this.complete:
        return err
        //超时返回
    case &amp;lt;-this.timeout:
        return ErrTimeout
    }
}

//异步执行所有的任务
func (this *Runner) Run() error {
    for id, task := range this.tasks {
        if this.gotInterrupt() {
            return ErrInterrupt
        }

        this.waitGroup.Add(1)
        go func(id int) {
            this.lock.Lock()

            //执行任务
            err := task(id)
            //加锁保存到结果集中
            this.errs = append(this.errs, err)

            this.lock.Unlock()
            this.waitGroup.Done()
        }(id)
    }
    this.waitGroup.Wait()

    return nil
}

//判断是否接收到操作系统中断信号
func (this *Runner) gotInterrupt() bool {
    select {
    case &amp;lt;-this.interrupt:
        //停止接收别的信号
        signal.Stop(this.interrupt)
        return true
        //正常执行
    default:
        return false
    }
}

//获取执行完的error
func (this *Runner) GetErrs() []error {
    return this.errs
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;使用方法　　　　&lt;/h2&gt;
&lt;p&gt;Add添加一个任务，任务为接收int类型，返回类型error的一个闭包&lt;/p&gt;
&lt;p&gt;Start开始执行伤，返回一个error类型，nil为执行完毕, ErrTimeout代表执行超时，ErrInterrupt代表执行被中断(类似Ctrl + C操作)&lt;/p&gt;
&lt;p&gt;getErrs获取所有的任务执行结果&lt;/p&gt;

&lt;h2&gt;测试示例代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package task

import (
    &quot;testing&quot;
    &quot;time&quot;
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;runtime&quot;
)

func TestRunner_Start(t *testing.T) {
    //开启多核心
    runtime.GOMAXPROCS(runtime.NumCPU())

    //创建runner对象，设置超时时间
    runner := NewRunner(18 * time.Second)
    //添加运行的任务
    runner.Add(
        createTask(),
        createTask(),
        createTask(),
        createTask(),
        createTask(),
        createTask(),
        createTask(),
        createTask(),
        createTask(),
        createTask(),
        createTask(),
        createTask(),
        createTask(),
        createTask(),
    )

    fmt.Println(&quot;异步执行任务&quot;)

    //开始执行任务
    if err := runner.Start(); err != nil {
        switch err {
        case ErrTimeout:
            fmt.Println(&quot;执行超时&quot;)
            os.Exit(1)
        case ErrInterrupt:
            fmt.Println(&quot;任务被中断&quot;)
            os.Exit(2)
        }
    }

    t.Log(&quot;执行结束&quot;)

    t.Log(runner.GetErrs())

}

//创建要执行的任务
func createTask() func(id int) error {
    return func(id int) error {
        fmt.Printf(&quot;正在执行%v个任务\n&quot;, id)
        //模拟任务执行,sleep
        //time.Sleep(1 * time.Second)
        return nil
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
异步执行任务
正在执行2个任务
正在执行1个任务
正在执行4个任务
正在执行3个任务
正在执行6个任务
正在执行5个任务
正在执行9个任务
正在执行7个任务
正在执行10个任务
正在执行13个任务
正在执行8个任务
正在执行11个任务
正在执行12个任务
正在执行0个任务
        runner_test.go:49: 执行结束
        runner_test.go:51: [&amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt;]
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Thu, 11 Jan 2018 09:33:00 +0000</pubDate>
<dc:creator>雪山飞猪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenqionghe/p/8269556.html</dc:identifier>
</item>
</channel>
</rss>