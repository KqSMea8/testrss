<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>爬虫系列（1）-----python爬取猫眼电影top100榜 - Niucas_MAO</title>
<link>http://www.cnblogs.com/PiPifamily/p/8727852.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PiPifamily/p/8727852.html</guid>
<description>&lt;p&gt;对于Python初学者来说，爬虫技能是应该是最好入门，也是最能够有让自己有成就感的，今天在整理代码时，整理了一下之前自己学习爬虫的一些代码，今天先上一个简单的例子，手把手教你入门Python爬虫，爬取猫眼电影TOP100榜信息，将涉及到基础爬虫架构中的HTML下载器、HTML解析器、数据存储器三大模块。&lt;/p&gt;&lt;p&gt;step2：简单的分析一下网页的源代码，找到我们要爬取的相关信息，以及信息在html源码中的位置，确定我们的正则表达式；&lt;/p&gt;&lt;div readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_one_req(url):
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        data&lt;/span&gt;=urllib.request.urlopen(url).read().decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; urllib.error.URLError as e:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(e,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e.code)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(e,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reason&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(e.reason)
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse__one_html(data):
    pat&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p class=&quot;name&quot;&amp;gt;&amp;lt;a.*?data-val=.*?&amp;gt;(.*?)&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;.*?主演：(.*?)\s&amp;lt;/p&amp;gt;.*?上映时间：(.*?)&amp;lt;/p&amp;gt;.*?integer&quot;&amp;gt;(.*?)&amp;lt;/i&amp;gt;.*?fraction&quot;&amp;gt;(.*?)&amp;lt;/i&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    res&lt;/span&gt;=&lt;span&gt;re.compile(pat,re.S).findall(data)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;42&quot;&gt;
&lt;pre&gt;
    df=open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F:/top100.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置要爬取的页数i&lt;/span&gt;
        url=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://maoyan.com/board/4?offset=0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+str(i*10&lt;span&gt;)
        data&lt;/span&gt;=&lt;span&gt;get_one_req(url)
        res&lt;/span&gt;=&lt;span&gt;parse__one_html(data)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(res)):
            item&lt;/span&gt;=&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;编号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:str(i)+&lt;span&gt;str(j),
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:res[j][0],
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;主演&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:res[j][1].strip(),&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除空字符&lt;/span&gt;
                    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;上映时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:res[j][2&lt;span&gt;],
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;评分&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:res[j][3]+res[j][4&lt;span&gt;]
                    }
            df.write(json.dumps(item,ensure_ascii&lt;/span&gt;=False)+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;注意编码 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.error
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json

url&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://maoyan.com/board/4?offset=0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;模拟浏览器&lt;/span&gt;
headers=(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user-agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 BIDUBrowser/8.7 Safari/537.36&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
opener&lt;/span&gt;=&lt;span&gt;urllib.request.build_opener()
opener.addheaders&lt;/span&gt;=[headers]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加报头&lt;/span&gt;
urllib.request.install_opener(opener)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置opner全局化,这样就可以直接调用urllib.request.urlopen()&lt;/span&gt;&lt;span&gt;
#
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_one_req(url):
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        data&lt;/span&gt;=urllib.request.urlopen(url).read().decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; urllib.error.URLError as e:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(e,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e.code)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(e,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reason&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e.reason)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse__one_html(data):
    pat&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p class=&quot;name&quot;&amp;gt;&amp;lt;a.*?data-val=.*?&amp;gt;(.*?)&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;.*?主演：(.*?)\s&amp;lt;/p&amp;gt;.*?上映时间：(.*?)&amp;lt;/p&amp;gt;.*?integer&quot;&amp;gt;(.*?)&amp;lt;/i&amp;gt;.*?fraction&quot;&amp;gt;(.*?)&amp;lt;/i&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    res&lt;/span&gt;=&lt;span&gt;re.compile(pat,re.S).findall(data)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
    
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    df&lt;/span&gt;=open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F:/top100.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置要爬取的页数i&lt;/span&gt;
        url=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://maoyan.com/board/4?offset=0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+str(i*10&lt;span&gt;)
        data&lt;/span&gt;=&lt;span&gt;get_one_req(url)
        res&lt;/span&gt;=&lt;span&gt;parse__one_html(data)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(res)):
            item&lt;/span&gt;=&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;编号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:str(i)+&lt;span&gt;str(j),
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:res[j][0],
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;主演&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:res[j][1].strip(),&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除空字符&lt;/span&gt;
                    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;上映时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:res[j][2&lt;span&gt;],
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;评分&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:res[j][3]+res[j][4&lt;span&gt;]
                    }
            df.write(json.dumps(item,ensure_ascii&lt;/span&gt;=False)+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;注意编码 &lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;df.close()&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print('第'+str(i+1)+'页的内容是：',res)&lt;/span&gt;
    
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; ==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()
        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后保存的文件内容如下，大家也可以保存为.csv格式，这样比较方便后期的数据分析和处理。&lt;/p&gt;&lt;div readability=&quot;165&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
{&quot;第1页的内容是：名称&quot;: &quot;霸王别姬&quot;, &quot;主演&quot;: &quot;张国荣,张丰毅,巩俐&quot;, &quot;上映时间&quot;: &quot;1993-01-01(中国香港)&quot;, &quot;评分&quot;: &quot;9.6&quot;}
{&quot;第1页的内容是：名称&quot;: &quot;肖申克的救赎&quot;, &quot;主演&quot;: &quot;蒂姆·罗宾斯,摩根·弗里曼,鲍勃·冈顿&quot;, &quot;上映时间&quot;: &quot;1994-10-14(美国)&quot;, &quot;评分&quot;: &quot;9.5&quot;}
{&quot;第1页的内容是：名称&quot;: &quot;罗马假日&quot;, &quot;主演&quot;: &quot;格利高利·派克,奥黛丽·赫本,埃迪·艾伯特&quot;, &quot;上映时间&quot;: &quot;1953-09-02(美国)&quot;, &quot;评分&quot;: &quot;9.1&quot;}
{&quot;第1页的内容是：名称&quot;: &quot;这个杀手不太冷&quot;, &quot;主演&quot;: &quot;让·雷诺,加里·奥德曼,娜塔莉·波特曼&quot;, &quot;上映时间&quot;: &quot;1994-09-14(法国)&quot;, &quot;评分&quot;: &quot;9.5&quot;}
{&quot;第1页的内容是：名称&quot;: &quot;泰坦尼克号&quot;, &quot;主演&quot;: &quot;莱昂纳多·迪卡普里奥,凯特·温丝莱特,比利·赞恩&quot;, &quot;上映时间&quot;: &quot;1998-04-03&quot;, &quot;评分&quot;: &quot;9.5&quot;}
{&quot;第1页的内容是：名称&quot;: &quot;教父&quot;, &quot;主演&quot;: &quot;马龙·白兰度,阿尔·帕西诺,詹姆斯·凯恩&quot;, &quot;上映时间&quot;: &quot;1972-03-24(美国)&quot;, &quot;评分&quot;: &quot;9.3&quot;}
{&quot;第1页的内容是：名称&quot;: &quot;龙猫&quot;, &quot;主演&quot;: &quot;日高法子,坂本千夏,糸井重里&quot;, &quot;上映时间&quot;: &quot;1988-04-16(日本)&quot;, &quot;评分&quot;: &quot;9.2&quot;}
{&quot;第1页的内容是：名称&quot;: &quot;唐伯虎点秋香&quot;, &quot;主演&quot;: &quot;周星驰,巩俐,郑佩佩&quot;, &quot;上映时间&quot;: &quot;1993-07-01(中国香港)&quot;, &quot;评分&quot;: &quot;9.2&quot;}
{&quot;第1页的内容是：名称&quot;: &quot;千与千寻&quot;, &quot;主演&quot;: &quot;柊瑠美,入野自由,夏木真理&quot;, &quot;上映时间&quot;: &quot;2001-07-20(日本)&quot;, &quot;评分&quot;: &quot;9.3&quot;}
{&quot;第1页的内容是：名称&quot;: &quot;魂断蓝桥&quot;, &quot;主演&quot;: &quot;费雯·丽,罗伯特·泰勒,露塞尔·沃特森&quot;, &quot;上映时间&quot;: &quot;1940-05-17(美国)&quot;, &quot;评分&quot;: &quot;9.2&quot;}
{&quot;第2页的内容是：名称&quot;: &quot;喜剧之王&quot;, &quot;主演&quot;: &quot;周星驰,莫文蔚,张柏芝&quot;, &quot;上映时间&quot;: &quot;1999-02-13(中国香港)&quot;, &quot;评分&quot;: &quot;9.2&quot;}
{&quot;第2页的内容是：名称&quot;: &quot;乱世佳人&quot;, &quot;主演&quot;: &quot;费雯·丽,克拉克·盖博,奥利维娅·德哈维兰&quot;, &quot;上映时间&quot;: &quot;1939-12-15(美国)&quot;, &quot;评分&quot;: &quot;9.1&quot;}
{&quot;第2页的内容是：名称&quot;: &quot;天空之城&quot;, &quot;主演&quot;: &quot;寺田农,鹫尾真知子,龟山助清&quot;, &quot;上映时间&quot;: &quot;1992&quot;, &quot;评分&quot;: &quot;9.1&quot;}
{&quot;第2页的内容是：名称&quot;: &quot;大闹天宫&quot;, &quot;主演&quot;: &quot;邱岳峰,毕克,富润生&quot;, &quot;上映时间&quot;: &quot;1965-12-31&quot;, &quot;评分&quot;: &quot;9.0&quot;}
{&quot;第2页的内容是：名称&quot;: &quot;辛德勒的名单&quot;, &quot;主演&quot;: &quot;连姆·尼森,拉尔夫·费因斯,本·金斯利&quot;, &quot;上映时间&quot;: &quot;1993-12-15(美国)&quot;, &quot;评分&quot;: &quot;9.2&quot;}
{&quot;第2页的内容是：名称&quot;: &quot;音乐之声&quot;, &quot;主演&quot;: &quot;朱丽·安德鲁斯,克里斯托弗·普卢默,埃琳诺·帕克&quot;, &quot;上映时间&quot;: &quot;1965-03-02(美国)&quot;, &quot;评分&quot;: &quot;9.0&quot;}
{&quot;第2页的内容是：名称&quot;: &quot;剪刀手爱德华&quot;, &quot;主演&quot;: &quot;约翰尼·德普,薇诺娜·瑞德,黛安娜·维斯特&quot;, &quot;上映时间&quot;: &quot;1990-12-06(美国)&quot;, &quot;评分&quot;: &quot;8.8&quot;}
{&quot;第2页的内容是：名称&quot;: &quot;春光乍泄&quot;, &quot;主演&quot;: &quot;张国荣,梁朝伟,张震&quot;, &quot;上映时间&quot;: &quot;1997-05-30(中国香港)&quot;, &quot;评分&quot;: &quot;9.2&quot;}
{&quot;第2页的内容是：名称&quot;: &quot;美丽人生&quot;, &quot;主演&quot;: &quot;罗伯托·贝尼尼,尼可莱塔·布拉斯基,乔治·坎塔里尼&quot;, &quot;上映时间&quot;: &quot;1997-12-20(意大利)&quot;, &quot;评分&quot;: &quot;9.3&quot;}
{&quot;第2页的内容是：名称&quot;: &quot;黑客帝国&quot;, &quot;主演&quot;: &quot;基努·里维斯,凯瑞-安·莫斯,劳伦斯·菲什伯恩&quot;, &quot;上映时间&quot;: &quot;2000-01-14&quot;, &quot;评分&quot;: &quot;9.0&quot;}
{&quot;第3页的内容是：名称&quot;: &quot;海上钢琴师&quot;, &quot;主演&quot;: &quot;蒂姆·罗斯,普路特·泰勒·文斯,比尔·努恩&quot;, &quot;上映时间&quot;: &quot;1998-10-28(意大利)&quot;, &quot;评分&quot;: &quot;9.2&quot;}
{&quot;第3页的内容是：名称&quot;: &quot;指环王3：王者无敌&quot;, &quot;主演&quot;: &quot;伊利亚·伍德,伊恩·麦克莱恩,丽芙·泰勒&quot;, &quot;上映时间&quot;: &quot;2004-03-15&quot;, &quot;评分&quot;: &quot;9.2&quot;}
{&quot;第3页的内容是：名称&quot;: &quot;加勒比海盗&quot;, &quot;主演&quot;: &quot;约翰尼·德普,凯拉·奈特莉,奥兰多·布鲁姆&quot;, &quot;上映时间&quot;: &quot;2003-11-21&quot;, &quot;评分&quot;: &quot;8.9&quot;}
{&quot;第3页的内容是：名称&quot;: &quot;哈利·波特与魔法石&quot;, &quot;主演&quot;: &quot;丹尼尔·雷德克里夫,鲁伯特·格林特,艾玛·沃森&quot;, &quot;上映时间&quot;: &quot;2002-01-26&quot;, &quot;评分&quot;: &quot;9.1&quot;}
{&quot;第3页的内容是：名称&quot;: &quot;射雕英雄传之东成西就&quot;, &quot;主演&quot;: &quot;张国荣,林青霞,梁朝伟&quot;, &quot;上映时间&quot;: &quot;1993-02-05(中国香港)&quot;, &quot;评分&quot;: &quot;8.9&quot;}
{&quot;第3页的内容是：名称&quot;: &quot;无间道&quot;, &quot;主演&quot;: &quot;刘德华,梁朝伟,黄秋生&quot;, &quot;上映时间&quot;: &quot;2003-09-05&quot;, &quot;评分&quot;: &quot;9.1&quot;}
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Fri, 06 Apr 2018 07:26:00 +0000</pubDate>
<dc:creator>Niucas_MAO</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PiPifamily/p/8727852.html</dc:identifier>
</item>
<item>
<title>详解JavaScript对象继承方式 - 雨霖月寒</title>
<link>http://www.cnblogs.com/jofun/p/8727814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jofun/p/8727814.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、对象冒充&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其原理如下：构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可使 Parent 构造函数&lt;br/&gt;成为 Children 的方法，然后调用它。Children 就会收到 Parent 的构造函数中定义的属性和方法。例如，用下面的方式定义 Parent 和 Children：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
]&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父类构造函数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Parent = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name){
&lt;/span&gt;&lt;span&gt;    this&lt;/span&gt;.name =&lt;span&gt; name;

&lt;/span&gt;&lt;span&gt;    this&lt;/span&gt;.sayHi = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        console.log(&lt;/span&gt;&quot;Hi! &quot; + &lt;span&gt;this&lt;/span&gt;.name + &quot;.&quot;&lt;span&gt;);
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子类构造函数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Children = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name){
&lt;/span&gt;&lt;span&gt;    this&lt;/span&gt;.method =&lt;span&gt; Parent;
&lt;/span&gt;&lt;span&gt;    this&lt;/span&gt;.method(name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现继承的关键&lt;/span&gt;
&lt;span&gt;    delete&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.method;

&lt;/span&gt;&lt;span&gt;    this&lt;/span&gt;.getName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; Parent(&quot;john&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = &lt;span&gt;new&lt;/span&gt; Children(&quot;joe&quot;&lt;span&gt;);

p.sayHi(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： Hi! john.&lt;/span&gt;
c.sayHi(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： Hi! joe.&lt;/span&gt;
c.getName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： jo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;原理：就是把 Parent 构造函数放到 Children 构造函数里面执行一次。那为什么不直接执行，非要转个弯把 Parent 赋值给 Children 的 method 属性再执行呢？&lt;br/&gt;这跟 this 的指向有关，在函数内 this 是指向 window 的。当将 Parent 赋值给 Children 的 method 时, this 就指向了 Children 类的实例。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、原型链继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众所周知，JavaScript 是一门基于原型的语言，在 JavaScript 中 prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父类构造函数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Parent = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;    this&lt;/span&gt;.name = &quot;john&quot;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;    this&lt;/span&gt;.sayHi = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        console.log(&lt;/span&gt;&quot;Hi! &quot; + &lt;span&gt;this&lt;/span&gt;.name + &quot;.&quot;&lt;span&gt;);
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子类构造函数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Children = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};

Children.prototype &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Parent(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现继承的关键&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Parent();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Children();

p.sayHi(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： Hi! john.&lt;/span&gt;
c.sayHi(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： Hi! john.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;注意：调用 Parent 的构造函数，没有给它传递参数。这在原型链中是标准做法。要确保构造函数没有任何参数。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、使用 call 或 applay 方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个方法是与对象冒充方法最相似的方法，因为它也是通过改变了 this 的指向而实现继承:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父类构造函数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Parent = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name){
&lt;/span&gt;&lt;span&gt;    this&lt;/span&gt;.name =&lt;span&gt; name;

&lt;/span&gt;&lt;span&gt;    this&lt;/span&gt;.sayHi = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        console.log(&lt;/span&gt;&quot;Hi! &quot; + &lt;span&gt;this&lt;/span&gt;.name + &quot;.&quot;&lt;span&gt;);
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子类构造函数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Children = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name){
    Parent.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现继承的关键&lt;/span&gt;

&lt;span&gt;    this&lt;/span&gt;.getName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; Parent(&quot;john&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = &lt;span&gt;new&lt;/span&gt; Children(&quot;joe&quot;&lt;span&gt;);

p.sayHi(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： Hi! john.&lt;/span&gt;
c.sayHi(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： Hi! john.&lt;/span&gt;
c.getName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： joe&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;apply 方法本人就不举列了，它和 call 方法的区别在于它的第二个参数必须是数组。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、混合方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象冒充的主要问题是必须使用构造函数方式，这不是最好的选择。不过如果使用原型链，就无法使用带参数的构造函数了。如何选择呢？答案很简单，两者都用。&lt;br/&gt;在 JavaScript 中创建类的最好方式是用构造函数定义属性，用原型定义方法。这种方式同样适用于继承机制：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父类构造函数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Parent = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name){
&lt;/span&gt;&lt;span&gt;    this&lt;/span&gt;.name =&lt;span&gt; name;
};

Parent.prototype.sayHi &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;Hi! &quot; + &lt;span&gt;this&lt;/span&gt;.name + &quot;.&quot;&lt;span&gt;);
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子类构造函数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Children = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name, age){
    Parent.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现继承的关键&lt;/span&gt;
&lt;span&gt;    this&lt;/span&gt;.age =&lt;span&gt; age;
};

Children.prototype &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Parent(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现继承的关键&lt;/span&gt;
&lt;span&gt;
Children.prototype.getAge &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age);
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; Parent(&quot;john&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = &lt;span&gt;new&lt;/span&gt; Children(&quot;joe&quot;,30&lt;span&gt;);

p.sayHi(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： Hi! john.&lt;/span&gt;
c.sayHi(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： Hi! joe.&lt;/span&gt;
c.getAge(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： 30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;五、使用Object.create 方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Object.create 方法会使用指定的原型对象及其属性去创建一个新的对象:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父类构造函数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Parent = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name){
&lt;/span&gt;&lt;span&gt;    this&lt;/span&gt;.name =&lt;span&gt; name;
};

Parent.prototype.sayHi &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;Hi! &quot; + &lt;span&gt;this&lt;/span&gt;.name + &quot;.&quot;&lt;span&gt;);
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子类构造函数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Children = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name, age){
    Parent.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现继承的关键&lt;/span&gt;
&lt;span&gt;    this&lt;/span&gt;.age =&lt;span&gt; age;
};

Children.prototype &lt;/span&gt;= Object.create(Parent.prototype); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现继承的关键&lt;/span&gt;
Children.prototype.constructor = children; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; @&lt;/span&gt;
&lt;span&gt;
Children.prototype.getAge &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age);
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; Parent(&quot;john&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = &lt;span&gt;new&lt;/span&gt; Children(&quot;joe&quot;,30&lt;span&gt;);

p.sayHi(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： Hi! john.&lt;/span&gt;
c.sayHi(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： Hi! joe.&lt;/span&gt;
c.getAge(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： 30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;@ 当执行 Children.prototype = Object.create(Parent.prototype) 这个语句后，Children 的 constructor 就被改变为 Parent ,因此需要将 Children.prototype.constructor 重&lt;br/&gt;新指定为 Children 自身。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、extends 关键字实现继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个是 ES6 的语法糖，下面看下es6实现继承的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Parent {
  constructor(name, age) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
  }
}

class Children extends Parent {
  constructor(name, age, job) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.job = job; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里会报错&lt;/span&gt;
&lt;span&gt;    super(name, age);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.job = job; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正确&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面代码中，子类的&lt;code&gt;constructor&lt;/code&gt;方法没有调用&lt;code&gt;super&lt;/code&gt;之前，就使用&lt;code&gt;this&lt;/code&gt;关键字，结果报错，而放在&lt;code&gt;super&lt;/code&gt;方法之后就是正确的。子类&lt;code&gt;Children&lt;/code&gt;的构造函数之中的&lt;code&gt;super()&lt;/code&gt;，代表调用父类Parent的构造函数。这是必须的，否则 JavaScript 引擎会报错。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意，&lt;code&gt;super&lt;/code&gt;虽然代表了父类Parent的构造函数，但是返回的是子类Children的实例，即&lt;code&gt;super&lt;/code&gt;内部的&lt;code&gt;this&lt;/code&gt;指的是Children，因此&lt;code&gt;super()&lt;/code&gt;在这里相当于Parent&lt;code&gt;.prototype.constructor.call(this)&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 06 Apr 2018 07:15:00 +0000</pubDate>
<dc:creator>雨霖月寒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jofun/p/8727814.html</dc:identifier>
</item>
<item>
<title>python装饰器 - 嵌动初心(aaron)</title>
<link>http://www.cnblogs.com/cjaaron/p/8727554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjaaron/p/8727554.html</guid>
<description>&lt;p&gt;在我们的软件产品升级时，常常需要给各个函数新增功能，而在我们的软件产品中，相同的函数可能会被调用上百次，这种情况是很常见的，如果我们一个个的修改，那我们的码农岂不要挂掉了(有人就说了 ，你笨呀，修改函数定义不就行了！同学，你醒醒吧，如果要新加的功能会修改参数，或者返回值呢？)。这个时候，就是我们装饰器大显神通的时候了。装饰器就可以实现，在不改变原函数的调用形式下（即函数的透明化处理），给函数新增功能的作用。如何实现，以及实现原理，下文会详解。&lt;/p&gt;

&lt;p&gt;装饰器，顾名思义就是起装饰的作用，既然是装饰，那么被装饰的对象是啥样就是啥样，不能有丝毫改变。&lt;span&gt;在这里，我们写装饰器就是必须把握不能修改被修饰函数的源代码这条铁律。&lt;span&gt;如何遵循这条铁律，我们还需还需做一些铺垫，必须先要了解三个概念，如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;函数名即“变量”&lt;/h2&gt;
&lt;p&gt;在python中，函数名其实就像是c语言的函数指针，代表的是我们的函数地址，只有解释器获取到这个地址，它才会去执行这块内存的代码。因此，本质上，函数名就和不同变量没什么区别，只不过函数名和普通变量所指代的那块内存的使用方式不同罢了，这些都是底层解释器的机制所决定的，对于程序猿来说，都是透明的，所以，我们可以认为两者是没有区别的。&lt;/p&gt;
&lt;h2&gt;高阶函数&lt;/h2&gt;
&lt;p&gt;　　什么是高阶函数其实很简单，把握两个原则就好：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;形式参数有函数名&lt;/li&gt;
&lt;li&gt;返回值有函数名&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只要满足这两个原则之一，就可以称之为是高阶函数。翻回头来看，这里出现了我们上面说的函数名，仔细体会一下，我们在这里不就是把其当成实参看待的吗？&lt;/p&gt;
&lt;h2&gt;嵌套函数&lt;/h2&gt;
&lt;p&gt;什么是嵌套函数其实也非常简单，把握一个原则就好：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在一个函数的函数体中去定义另一个函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这里需要强调的是，函数定义时是不会执行函数体的，就和定义变量是不会去读取变量里的内容一样。这一点至关重要，对于我们理解装饰器实现原理非常有帮助。&lt;/p&gt;

&lt;p&gt;有了上文的铺垫，在现在来详解一下如何写装饰器，就好理解多了。&lt;/p&gt;
&lt;h2&gt;装饰器本质&lt;/h2&gt;
&lt;p&gt;　　其实装饰器本质上就是一个函数，它也具有函数名，参数和返回值。但在python中，我们用“@auth”来表示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
@auth        # 其等价于：func = auth(func)
def func():
    print(&quot;func called&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个示例就是python中如何修饰func函数的格式，当然我们还没有实现我们的装饰器函数。我们要注意的是注释里写的内容，我们可以看出：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;装饰器函数其实是一个高阶函数(参数和返回值都为函数名)。&lt;/li&gt;
&lt;li&gt;“auth(func)”是在调用我们的装饰器函数，即装饰器函数的函数体会被执行，一定要记好这一点。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;设计思路&lt;/h2&gt;
&lt;p&gt;装饰器即然是个函数，又有上述介绍的等价关系，那我们就可以这样设计我们的装饰器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在我们装饰器的函数体内去定义一个新的函数，在这个新定义的函数内去调用被修饰的函数，与此同时，在被修饰的函数的上下文去添加新功能。最后，利用装饰器函数的返回值返回我们新定义函数的函数名。&lt;/li&gt;
&lt;li&gt;由此可以知道，“func = auth(func)”中的返回值func表示的就是在装饰器中新定义的函数的函数名。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前面做了大量的铺垫，就是想在这里揭示装饰器的实现机制，其实没什么什么的，很简单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;装饰器机制改变了被修饰函数的函数名表示的地址数据。&lt;/span&gt;说白了就是，被修饰前，函数名代表的是A内存块；被修饰后，函数名代表的是B内存块；只不过，在执行B内存块时，会调用A内存块罢了。B内存块中的代码就是我们新加的功能。&lt;span&gt;而这种机制的实现，使用了“高阶函数”和“嵌套函数”的机制。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;最终的效果就是，但在调用被修饰过的函数时，其实调用的不是原来的内存块，而是修饰器新申请的内存块。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;第一步：设计装饰器函数&lt;/h2&gt;
&lt;p&gt;装饰器函数定义跟普通函数定义没什么区别，关键是函数体怎么写的问题。这里，为了便于理解，先用无参数的装饰器函数说明。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#装饰器函数定义格式
def deco(func):
    '''函数体...'''
return func
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;这里说的无参数，指的是没有除了“func”之外的参数&lt;/li&gt;
&lt;li&gt;难点是函数体的编写，下面的示例先告诉你为什么要有第二步：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
#使用语法糖@来装饰函数，相当于“myfunc = deco(myfunc)”
def deco(func):
    print(&quot;before myfunc() called.&quot;)
    func()
    print(&quot;after myfunc() called.&quot;)
    return func

@deco
def myfunc():
    print(&quot;myfunc() called.&quot;)

myfunc()
myfunc()

#output：
before myfunc() called.
myfunc() called.
after myfunc() called.
myfunc() called.
myfunc() called. 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由输出结果可以看出，我们的装饰器并没有生效。别跟我说装饰器只生效了一次，那是大家忽略了“@deco”的等效机制。解释到“@deco”时，会解释成“myfunc = deco(myfunc)”。注意了，前面我提到了，这里其实在调用deco函数的，因此，deco的函数体会被执行。所以output的前三行并不是调用myfunc函数时产生的效果，那有怎能说装饰器生效了一次呢？第二步就是解决装饰器没生效的问题的。&lt;/p&gt;
&lt;h2&gt;第二步：包装被修饰函数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#基本格式
def deco(func):
    def _deco()
       #新增功能
       #...
       #...
       func()  #别修饰函数调用
    return_deco
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 下面给出个示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
#使用内嵌包装函数来确保每次新函数都被调用，
#内嵌包装函数的形参和返回值与原函数相同，装饰函数返回内嵌包装函数对象

def deco(func):
    def _deco():
        print(&quot;before myfunc() called.&quot;)
        func()
        print(&quot;after myfunc() called.&quot;)
        # 不需要返回func，实际上应返回原函数的返回值
    return _deco

@deco
def myfunc():
    print(&quot;myfunc() called.&quot;)
    return 'ok'

myfunc()

#output:
before myfunc() called.
myfunc() called.
after myfunc() called.
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;  第三步：被修饰函数参数和返回值透明化处理&lt;/h2&gt;
&lt;p&gt;当完成了第二步时，其实装饰器已经完成了主要部分，下面就是对被修饰函数的参数和返回值的处理。这样才能真正实现装饰器的铁律。话不多说，直接上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#基本格式
def deco(func):
    def _deco(*args, **kwargs)  #参数透明化
       #新增功能
       #...
       #...
       res = func(*args, **kwargs)  #别修饰函数调用
       return res  #返回值透明化
    return_deco
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面的分析知：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;参数透明化：当我们在调用被装饰后的函数时，其实调用的时这里的_deco函数。那么，我们就给_deco函数加上可变参数，并把得到的可变参数传递给func函数不就可以了。&lt;/li&gt;
&lt;li&gt;返回值透明化：和参数透明化同理，给_deco函数定义返回值，并返回func的返回值就可以了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　透明化处理就是这么简单！至此，我们的装饰器编写完成。给个示例吧：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
#对带参数的函数进行装饰，
#内嵌包装函数的形参和返回值与原函数相同，装饰函数返回内嵌包装函数对象

def deco(func):
    def _deco(*agrs, **kwagrs):
        print(&quot;before myfunc() called.&quot;)
        ret = func(*agrs, **kwagrs)
        print(&quot;  after myfunc() called. result: %s&quot; % ret)
        return ret
    return _deco

@deco
def myfunc(a, b):
    print(&quot; myfunc(%s,%s) called.&quot; % (a, b))
    return a + b

print(&quot;sum=&quot;,myfunc(1, 2))
print(&quot;sum=&quot;,myfunc(3, 4))

#output:
before myfunc() called.
 myfunc(1,2) called.
  after myfunc() called. result: 3
sum= 3
before myfunc() called.
 myfunc(3,4) called.
  after myfunc() called. result: 7
sum= 7
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;带参数装饰器&lt;/h2&gt;
&lt;p&gt;装饰器即然也是函数，那么我们也可以给其传递参数。我这里说的是：“@auth(auth_type = 'type1')”这中形式哟。先上个代码吧：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#基本格式
def deco(deco_type)
    def _deco(func):
        def __deco(*args, **kwargs)  #参数透明化
           #新增功能
           #...
           #...
           print(&quot;deco_type:&quot;,deco_type)  #使用装饰器参数
           res = func(*args, **kwargs)  #别修饰函数调用
           return res  #返回值透明化
        return __deco
    return _deco        
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;说白了，就是在原来的装饰器的基础上再在最外层套一个deco函数，并用其来接收装饰器参数。由于是在最外层套了一个函数，那么这个函数的形参的作用范围就是函数体内部，所以里面的函数定义中随便用啦，就这么任性。&lt;/li&gt;
&lt;li&gt;那怎么理解解释器的解析过程呢？在这里，只要我们明白一点就好，那就是：&lt;span&gt;“@auth(auth_type = 'type1')”等价于“func = auth(auth_type = 'type1')(func)”&lt;/span&gt;。解释器会先翻译“auth(auth_type = 'type1')”，再将其返回值(假设给了_func这个不存在的函数名)当作函数指针，这里的_func函数名代表的是_deco，然后再去执行“func = _func(func)”，而这个func函数名代表的其实就是__deco。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至此，就达到了通过装饰器来传参的目的。给个示例吧：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
#让装饰器带参数，
#和上一示例相比在外层多了一层包装。
#装饰函数名实际上应更有意义些

def deco(deco_type):
    def _deco(func):
        def __deco(*args, **kwagrs):
            print(&quot;before %s called [%s].&quot; % (func.__name__, deco_type))
            func(*args, **kwagrs)
            print(&quot;  after %s called [%s].&quot; % (func.__name__, deco_type))
        return __deco
    return _deco

@deco(&quot;mymodule&quot;)
def myfunc():
    print(&quot; myfunc() called.&quot;)

@deco(&quot;module2&quot;)
def myfunc2():
    print(&quot; myfunc2() called.&quot;)

myfunc()
myfunc2()

#output:
before myfunc called [mymodule].
 myfunc() called.
  after myfunc called [mymodule].
before myfunc2 called [module2].
 myfunc2() called.
  after myfunc2 called [module2].
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;多重装饰器修饰函数&lt;/h2&gt;
&lt;p&gt;如果说，我上面说的内容都理解了，那么这个东东，就太简单不过了。不就是把我们的是装饰器当中被修饰的函数，对它进行装饰吗？但我在这里还想说的是，我们换个角度看问题。我们的关注点放在原来的被修饰的函数上，就会发现，NB呀，我可以给它添加若干个功能撒。给个示例吧：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
def deco(deco_type):
    def _deco(func):
        def __deco(*args, **kwagrs):
            print(&quot;before %s called [%s].&quot; % (func.__name__, deco_type))
            func(*args, **kwagrs)
            print(&quot;  after %s called [%s].&quot; % (func.__name__, deco_type))
        return __deco
    return _deco

@deco(&quot;module1&quot;)
@deco(&quot;mymodule&quot;)
def myfunc():
    print(&quot; myfunc() called.&quot;)

@deco(&quot;module2&quot;)
def myfunc2():
    print(&quot; myfunc2() called.&quot;)

myfunc()

#output：
before __deco called [module1].
before myfunc called [mymodule].
 myfunc() called.
  after myfunc called [mymodule].
  after __deco called [module1].
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注意结果哟，@deco(&quot;module1&quot;),来修饰的deco(&quot;mymdule&quot;)的，和我们想的是一样的，完美！&lt;/p&gt;
</description>
<pubDate>Fri, 06 Apr 2018 05:39:00 +0000</pubDate>
<dc:creator>嵌动初心(aaron)</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjaaron/p/8727554.html</dc:identifier>
</item>
<item>
<title>什么是KMP算法？KMP算法推导 - im向北</title>
<link>http://www.cnblogs.com/imxiangbei/p/8727536.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imxiangbei/p/8727536.html</guid>
<description>
&lt;p&gt;花了大概3天时间，了解，理解，推理KMP算法，这里做一次总结！希望能给看到的人带来帮助！！&lt;/p&gt;

&lt;p&gt;在主串Str中查找模式串Pattern的方法中，有一种方式叫KMP算法&lt;/p&gt;
&lt;p&gt;KMP算法是在模式串字符与主串字符匹配失配时，利用已经匹配的模式串字符子集的最大块对称性，让模式串尽量后移的算法。&lt;/p&gt;

&lt;p&gt;这里有3个概念：失配，已经匹配的模式串子集，块对称性&lt;/p&gt;
&lt;h2&gt;失配和隐含信息&lt;/h2&gt;
&lt;p&gt;在模式串的字符与主串字符比较的过程中，字符相等就是匹配，字符不等就是失配；&lt;/p&gt;
&lt;p&gt;隐含信息是，&lt;span&gt;失配之前，都是匹配&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在主串S[0，100]中查找模式串P[0，6]，从下标0开始查找，在下标为5的位置失配，记为P[0，5]失配，则有&lt;/p&gt;
&lt;p&gt;P[5]!=S[5]，又有S[0，4]=P[0，4]&lt;/p&gt;
&lt;p&gt;则P[0,4]都是匹配的！&lt;/p&gt;
&lt;h2&gt;已经匹配的模式串子集&lt;/h2&gt;
&lt;p&gt;接上一例，模式串是P[0，6]，而P[0，4]都是匹配的，所以，已经匹配的模式串子集有&lt;/p&gt;
&lt;p&gt;Pcs={ P[0，4]，P[0，3]，P[0，2]，P[0，1]，P[0] }&lt;/p&gt;

&lt;h2&gt;什么是块对称性？&lt;/h2&gt;
&lt;p&gt;块对称性，就是字符串前缀，后缀重叠；&lt;/p&gt;
&lt;p&gt;比如： a b c d a b c&lt;/p&gt;
&lt;p&gt;前缀：除了最后一个字母外，所有的前缀子集；&lt;/p&gt;
&lt;p&gt;如： a，ab，abc，abcd，abcda，abcdab&lt;/p&gt;
&lt;p&gt;后缀：除了第一个字母外，所有的后缀子集&lt;/p&gt;
&lt;p&gt;如： bcdabc，cdabc，dabc，abc，bc，c&lt;/p&gt;
&lt;p&gt;这里前缀abc和后缀abc重合&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1304923/201804/1304923-20180406132208242-1427924801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以把这个重合看做，相对于绿块对称，所以叫它块对称性&lt;/p&gt;
&lt;p&gt;块对称有很多种；比如：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1304923/201804/1304923-20180406132219979-286992715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;咦？大家都在一水平排，怎么有一个飞起来了？&lt;/p&gt;

&lt;p&gt;飞起来那个将在&lt;strong&gt;利用最大快对称性&lt;/strong&gt; 小节讲解。&lt;/p&gt;
&lt;h2&gt;块有什么特点？&lt;/h2&gt;
&lt;p&gt;特点：&lt;span&gt;拥有块对称性的字符串至少有2块对称重合的的部分&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;分析，对称是修饰，重合是关键。而且重合的是前缀和后缀。&lt;/p&gt;
&lt;h2&gt;如何利用块对称性？&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1304923/201804/1304923-20180406132325779-1453897592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;模式串如图，如果模式串和主串Str匹配的过程中，在l这失配即P[0，7]失配，你会怎样？&lt;/p&gt;
&lt;p&gt;分析，&lt;/p&gt;
&lt;p&gt;第一，模式串的P[0，6]和主串放入S[0，6]是完全匹配的&lt;/p&gt;
&lt;p&gt;第二，P[0，6]串是块对称的！&lt;/p&gt;
&lt;p&gt;因为P[0，6]刚好有块对称性，我可以把前缀abc移动到后缀abc的位置，然后让d与主串去匹配，这样就利用快对称性了对吧？&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1304923/201804/1304923-20180406132344217-274709936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;总结，可以在P[7]失配时，看失配字符的最大前缀P[0，6]是否有块对称性，如果有，我们就可以向右移动模式串，让左边的重合前缀移动到右边的重合后缀，再让模式串和主串比较！&lt;/p&gt;
&lt;h2&gt;利用最大块对称性？什么意思？&lt;/h2&gt;
&lt;p&gt;什么是KMP算法小节里，说KMP是在模式串与主串匹配失配时，利用已经匹配的模式串子集的最大块对称性，尽量让模式串右移！这里的利用最大块对称性是什么意思？&lt;/p&gt;
&lt;p&gt;这里&lt;span&gt;利用最大块对称性意味着可能发生递归&lt;/span&gt;！&lt;/p&gt;
&lt;p&gt;把上个案例的d换成k，如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1304923/201804/1304923-20180406132355494-774333521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;KMP算法会预先计算出模式串所有前缀子集中哪些前缀有块对称性，在这些有块对称性的前缀的后一个字符失配时，利用其块对称性；&lt;/p&gt;
&lt;p&gt;比如本例中P[0，6]有块对称性，那么在P[0，7]也就是l失配时，&lt;/p&gt;
&lt;p&gt;会先利用P[0，6]的块对称性，即P[0，2]和P[4，6]相遇于字符P[3]块对称，&lt;/p&gt;
&lt;p&gt;如果不行，会看P[0，2]块对称重合的部分有没有块对称性，&lt;/p&gt;
&lt;p&gt;有，就利用；以此类推，一直递归到没有块对称性为止。&lt;/p&gt;
&lt;h2&gt;块对称长度的意义-编程&lt;/h2&gt;
&lt;p&gt;第一次移动中，3是什么？块对称重合长度，也是下次开始比较的位置！&lt;/p&gt;
&lt;p&gt;第二次移动中，1是什么？块对称重合长度，也是下次开始比较的位置！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1304923/201804/1304923-20180406132417349-1857343599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;单独的块对称性是没有意义的，块对称性必须结合上失配，才能利用块对称性！&lt;/p&gt;
&lt;p&gt;所以，应该计算出Pattern所有前缀子集失配时的块对称性！放到一个叫next[]数组的地方！&lt;/p&gt;
&lt;p&gt;如何计算呢？&lt;/p&gt;
&lt;p&gt;next数组是计算失配时的块对称性，&lt;/p&gt;
&lt;p&gt;当第1个字符失配时，压根就没有前缀后缀的说法，所以有next[0]是不存在块对称性的，记为next[0]=-1；&lt;/p&gt;

&lt;p&gt;当第2个字符失配时，它的子集只有1个字符，也是没有前缀后缀，没有块对称性，所以记为next[1]=0；&lt;/p&gt;

&lt;p&gt;再看图，对于值k，已有p0 p1, ..., pk-1 = pj-k pj-k+1, ..., pj-1，则有next[j] = k。&lt;/p&gt;
&lt;p&gt;next[j] = k代表了什么呢？&lt;/p&gt;
&lt;p&gt;代表在Pj之前，有长度为k的块对称性，有2个长度为k的重合部分。&lt;/p&gt;


&lt;p&gt;总结一下，前提条件如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;条件1.next[0]是不存在的，next[1]=0&lt;/strong&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;条件2.对于下标值k，已有p0 p1, ..., pk-1 = pj-k pj-k+1, ..., pj-1，则有next[j] = k&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;next[]数组是从0开始被初始的，如果我们能推导出next[j+1] = 什么，是不是就可以计算出next[]数组？ 是吧&lt;/p&gt;
&lt;p&gt;下面来推导next[j+1]&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1304923/201804/1304923-20180406132438635-1977095724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;已知：&lt;/p&gt;
&lt;p&gt;p0 p1, ..., pk-1 = pj-k pj-k+1, ..., pj-1，==》 next[j] = k&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果pk与pj匹配&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;则有p0 p1, ..., pk-1,pk = pj-k pj-k+1, ..., pj-1pj，==》 next[j+1] = k+1;&lt;/p&gt;
&lt;p&gt;原来有2个长度为k的对称重合部分，pk与pj匹配后，2个长度为k对称重合的部分又有了1对字符重合，所以有next[j+1]=k+1；&lt;/p&gt;

&lt;p&gt;再看图，next[j]=k，当pj失配时，下一次用pk去和主串匹配；所以next[j]的实际意义是，当pj失配时，下一次应该用哪个字符去和主串匹配！！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;条件3&lt;/strong&gt;.next[ ]数组的值就是当次失配时，下一次匹配的位置！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果pk与pj不匹配&lt;/strong&gt;，next[j+1]=?&lt;/p&gt;
&lt;p&gt;next[j+1]的实际意义是，p[0，j+1]的pj+1失配时，p[0，j]的块对称重合长度，也是下一次匹配时应该用模式串的哪个字符与主串匹配，哪个字符的下标就是next[j+1]。&lt;/p&gt;
&lt;p&gt;具体详参&lt;strong&gt;块对称长度的意义-编程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下一次用哪个字符比较呢？&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1304923/201804/1304923-20180406132516723-836092682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;设&lt;span&gt;a1=p0 p1,...,pk-1，a2=pj-k pj-k+1,...,pj-1；a1==a2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当pk与pj不匹配时，不能用a1替换a2，如图绿叉；&lt;/p&gt;
&lt;p&gt;因为a2是离与主串最近的部分，所以这时候应该分析a2是否有块对称性，&lt;/p&gt;
&lt;p&gt;如果a2有块对称性，那么a1也有块对称性，如图绿框；&lt;/p&gt;
&lt;p&gt;所以，&lt;span&gt;这时应该分析p[0，k]的块对称性，也就是next[k]&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;设x1与x2关于绿框对称；&lt;/p&gt;
&lt;p&gt;x3与x4关于绿框对称；&lt;/p&gt;
&lt;p&gt;那么把x1移动到x4的位置，是不是就可以最大利用上；&lt;/p&gt;
&lt;p&gt;所以next[j+1]=next[k]；&lt;/p&gt;

&lt;p&gt;总结一下&lt;/p&gt;
&lt;p&gt;If ( p[k] == p[j] )  next[j+1]=k+1&lt;/p&gt;
&lt;p&gt;else next[k+1]= next[k]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/v_july_v/article/details/7041827&quot;&gt;https://blog.csdn.net/v_july_v/article/details/7041827&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.codeceo.com/kmp-next-array.html&quot;&gt;http://www.codeceo.com/kmp-next-array.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/21474082&quot;&gt;https://www.zhihu.com/question/21474082&lt;/a&gt;  next数组推导&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yearn520/article/details/6729426&quot;&gt;https://blog.csdn.net/yearn520/article/details/6729426&lt;/a&gt; next数组推到原则&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.xahkbg.com/&quot;&gt;https://www.xahkbg.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;KMP中，计算目标查询串T的next[]数组是关键；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24274982&quot;&gt;https://zhuanlan.zhihu.com/p/24274982&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yearn520/article/details/6729426&quot;&gt;https://blog.csdn.net/yearn520/article/details/6729426&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/c-cloud/p/3224788.html&quot;&gt;http://www.cnblogs.com/c-cloud/p/3224788.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24649304&quot;&gt;https://zhuanlan.zhihu.com/p/24649304&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 06 Apr 2018 05:29:00 +0000</pubDate>
<dc:creator>im向北</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imxiangbei/p/8727536.html</dc:identifier>
</item>
<item>
<title>【深度学习】深入理解ReLU(Rectifie Linear Units)激活函数 - 郭耀华</title>
<link>http://www.cnblogs.com/guoyaohua/p/8727509.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoyaohua/p/8727509.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;0.1  一般激活函数有如下一些性质：&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;非线性&lt;/strong&gt;&lt;/span&gt;： 当激活函数是线性的，一个两层的神经网络就可以基本上逼近所有的函数。但如果激活函数是恒等激活函数的时候，即f(x)=x，就不满足这个性质，而且如果MLP(多层感知机)使用的是恒等激活函数，那么其实整个网络跟单层神经网络是等价的；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;可微性&lt;/strong&gt;&lt;/span&gt;： 当优化方法是基于梯度的时候，就体现了该性质；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;单调性&lt;/strong&gt;&lt;/span&gt;： 当激活函数是单调的时候，单层网络能够保证是凸函数；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;f(x)≈x&lt;/strong&gt;&lt;/span&gt;： 当激活函数满足这个性质的时候，如果参数的初始化是随机的较小值，那么神经网络的训练将会很高效；如果不满足这个性质，那么就需要详细地去设置初始值；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;输出值的范围&lt;/strong&gt;&lt;/span&gt;： 当激活函数输出值是有限的时候，基于梯度的优化方法会更加稳定，因为特征的表示受有限权值的影响更显著；当激活函数的输出是无限的时候，模型的训练会更加高效，不过在这种情况小，一般需要更小的Learning Rate。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;0.2  传统Sigmoid系激活函数&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/678029/201504/241221240623467.png&quot; alt=&quot;&quot; width=&quot;438&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;
&lt;p&gt;传统神经网络中最常用的两个激活函数，Sigmoid系（Logistic-Sigmoid、Tanh-Sigmoid）被视为神经网络的核心所在。&lt;/p&gt;
&lt;p&gt;从数学上来看，非线性的&lt;span&gt;Sigmoid函数对中央区的信号增益较大，对两侧区的信号增益小&lt;/span&gt;，在信号的特征空间映射上，有很好的效果。&lt;/p&gt;
&lt;p&gt;从神经科学上来看，中央区酷似神经元的兴奋态，两侧区酷似神经元的抑制态，因而在神经网络学习方面，可以将重点特征推向中央区，将非重点特征推向两侧区。&lt;/p&gt;
&lt;p&gt;无论是哪种解释，看起来都比早期的线性激活函数(y=x),阶跃激活函数(-1/1,0/1)高明了不少。&lt;/p&gt;
&lt;h2&gt;0.3  近似生物神经激活函数：Softplus&amp;amp;ReLu &lt;/h2&gt;
&lt;p&gt;2001年，神经科学家Dayan、Abott从生物学角度，模拟出了脑神经元接受信号更精确的激活模型，该模型如左图所示：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;file:///C:/Users/Administrator/AppData/Roaming/Tencent/Users/2876734969/QQ/WinTemp/RichOle/5%7B%60L6GE1KSSOWDQ%60GUE3183.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;file:///C:/Users/Administrator/AppData/Roaming/Tencent/Users/2876734969/QQ/WinTemp/RichOle/5%7B%60L6GE1KSSOWDQ%60GUE3183.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/678029/201504/241258145158893.png&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;308&quot;/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/678029/201504/241900156879853.png&quot; alt=&quot;&quot; width=&quot;408&quot; height=&quot;312&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个模型对比Sigmoid系主要变化有三点：&lt;span&gt;&lt;strong&gt;① 单侧抑制　　 ② 相对宽阔的兴奋边界　　 ③ 稀疏激活性 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;（重点，可以看到红框里前端状态完全没有激活）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同年，Charles Dugas等人在做&lt;strong&gt;正数&lt;/strong&gt;回归预测&lt;a href=&quot;http://95.173.210.46/url?q=http://papers.nips.cc/paper/1920-incorporating-second-order-functional-knowledge-for-better-option-pricing.pdf&amp;amp;sa=U&amp;amp;ei=4SM6VefqBIbaPL-HgPAN&amp;amp;ved=0CAUQFjAA&amp;amp;usg=AFQjCNHY_71xurXxTe9sgH1iHqjZHwg2rA&quot; target=&quot;_blank&quot;&gt;论文&lt;/a&gt;中偶然使用了Softplus函数，Softplus函数是Logistic-Sigmoid函数原函数。&lt;/p&gt;
&lt;p&gt; &lt;span id=&quot;MathJax-Element-1-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;S&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;o&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;f&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;t&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;p&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;u&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;s&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;o&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;g&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;+&amp;lt;/mo&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;e&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-2&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-3&quot; class=&quot;mi&quot;&gt;S&lt;span id=&quot;MathJax-Span-4&quot; class=&quot;mi&quot;&gt;o&lt;span id=&quot;MathJax-Span-5&quot; class=&quot;mi&quot;&gt;f&lt;span id=&quot;MathJax-Span-6&quot; class=&quot;mi&quot;&gt;t&lt;span id=&quot;MathJax-Span-7&quot; class=&quot;mi&quot;&gt;p&lt;span id=&quot;MathJax-Span-8&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-9&quot; class=&quot;mi&quot;&gt;u&lt;span id=&quot;MathJax-Span-10&quot; class=&quot;mi&quot;&gt;s&lt;span id=&quot;MathJax-Span-11&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-12&quot; class=&quot;mi&quot;&gt;x&lt;span id=&quot;MathJax-Span-13&quot; class=&quot;mo&quot;&gt;)&lt;span id=&quot;MathJax-Span-14&quot; class=&quot;mo&quot;&gt;=&lt;span id=&quot;MathJax-Span-15&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-16&quot; class=&quot;mi&quot;&gt;o&lt;span id=&quot;MathJax-Span-17&quot; class=&quot;mi&quot;&gt;g&lt;span id=&quot;MathJax-Span-18&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-19&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-20&quot; class=&quot;mo&quot;&gt;+&lt;span id=&quot;MathJax-Span-21&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-22&quot; class=&quot;mi&quot;&gt;e&lt;span id=&quot;MathJax-Span-23&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-24&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-25&quot; class=&quot;mi&quot;&gt;&lt;sup&gt;x&lt;/sup&gt;&lt;span id=&quot;MathJax-Span-26&quot; class=&quot;mo&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;按照论文的说法，一开始想要使用一个指数函数（天然正数）作为激活函数来回归，但是到后期梯度实在太大，难以训练，于是加了一个log来减缓上升趋势。&lt;/p&gt;
&lt;p&gt;加了1是为了保证非负性。同年，Charles Dugas等人在NIPS会议&lt;a href=&quot;http://papers.nips.cc/paper/2062-estimating-car-insurance-premia-a-case-study-in-high-dimensional-data-inference&quot; target=&quot;_blank&quot;&gt;论文&lt;/a&gt;中又调侃了一句，Softplus可以看作是强制非负校正函数&lt;span id=&quot;MathJax-Element-2-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo movablelimits=&amp;quot;true&amp;quot; form=&amp;quot;prefix&amp;quot;&amp;gt;max&amp;lt;/mo&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-27&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-28&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-29&quot; class=&quot;mo&quot;&gt;max&lt;span id=&quot;MathJax-Span-30&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-31&quot; class=&quot;mn&quot;&gt;0&lt;span id=&quot;MathJax-Span-32&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-33&quot; class=&quot;mi&quot;&gt;x&lt;span id=&quot;MathJax-Span-34&quot; class=&quot;mo&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;max(0,x)平滑版本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;偶然的是，同是2001年，ML领域的Softplus/Rectifier激活函数与神经科学领域的提出脑神经元激活频率函数有神似的地方，这促成了新的激活函数的研究。&lt;/p&gt;
&lt;h2&gt;0.4  生物神经的&lt;span&gt;稀疏激活性&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在神经科学方面，除了新的激活频率函数之外，神经科学家还发现了&lt;span&gt;&lt;strong&gt;神经元的稀疏激活性&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;还是2001年，Attwell等人基于大脑能量消耗的观察学习上，推测神经元编码工作方式具有稀疏性和分布性。&lt;/p&gt;
&lt;p&gt;2003年Lennie等人估测大脑同时被激活的神经元只有1~4%，进一步表明神经元工作的稀疏性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;从信号方面来看，即神经元同时只对输入信号的少部分选择性响应，大量信号被刻意的屏蔽了，这样&lt;span&gt;可以提高学习的精度，更好更快地提取稀疏特征&lt;/span&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从这个角度来看，在经验规则的初始化W之后，传统的Sigmoid系函数同时近乎有一半的神经元被激活，这不符合神经科学的研究，而且会给深度网络训练带来巨大问题。&lt;/p&gt;
&lt;p&gt;Softplus照顾到了新模型的前两点，却没有稀疏激活性。因而，校正函数&lt;span id=&quot;MathJax-Element-3-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo movablelimits=&amp;quot;true&amp;quot; form=&amp;quot;prefix&amp;quot;&amp;gt;max&amp;lt;/mo&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-35&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-36&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-37&quot; class=&quot;mo&quot;&gt;max&lt;span id=&quot;MathJax-Span-38&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-39&quot; class=&quot;mn&quot;&gt;0&lt;span id=&quot;MathJax-Span-40&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-41&quot; class=&quot;mi&quot;&gt;x&lt;span id=&quot;MathJax-Span-42&quot; class=&quot;mo&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;成了近似符合该模型的最大赢家。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Machine Learning中的颠覆性研究是稀疏特征，基于数据的稀疏特征研究上，派生了Deep Learning这一分支。&lt;/p&gt;
&lt;p&gt;稀疏性概念最早由Olshausen、Field在1997年对信号数据稀疏编码的研究中引入，并最早在卷积神经网络中得以大施拳脚。&lt;/p&gt;
&lt;p&gt;近年来，稀疏性研究不仅在计算神经科学、机器学习领域活跃，甚至信号处理、统计学也在借鉴。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结起来稀疏性大概有以下三方面的贡献：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1.1  信息解离&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;当前，深度学习一个明确的目标是从数据变量中解离出关键因子。原始数据（以自然数据为主）中通常缠绕着高度密集的特征。&lt;/p&gt;
&lt;p&gt;原因是这些特征向量是相互关联的，一个小小的关键因子可能牵扰着一堆特征，有点像蝴蝶效应，牵一发而动全身。&lt;/p&gt;
&lt;p&gt;基于数学原理的传统机器学习手段在解离这些关联特征方面具有致命弱点。&lt;/p&gt;
&lt;p&gt;然而，如果能够&lt;span&gt;&lt;strong&gt;解开特征间缠绕的复杂关系，转换为稀疏特征，那么特征就有了鲁棒性&lt;/strong&gt;&lt;/span&gt;（去掉了无关的噪声）。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1.2  线性可分性&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;稀疏特征有更大可能线性可分，或者对非线性映射机制有更小的依赖&lt;/strong&gt;&lt;/span&gt;。因为稀疏特征处于高维的特征空间上（被自动映射了）&lt;/p&gt;
&lt;p&gt;从流形学习观点来看（参见降噪自动编码器），稀疏特征被移到了一个较为纯净的低维流形面上。&lt;/p&gt;
&lt;p&gt;线性可分性亦可参照天然稀疏的文本型数据，即便没有隐层结构，仍然可以被分离的很好。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1.3  稠密分布但是稀疏&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;稠密缠绕分布着的特征是信息最富集的特征，从潜在性角度，往往比局部少数点携带的特征成倍的有效。&lt;/p&gt;
&lt;p&gt;而稀疏特征，正是从稠密缠绕区解离出来的，潜在价值巨大。&lt;/p&gt;
&lt;h2&gt;1.4  稀疏性激活函数的贡献的作用：&lt;/h2&gt;
&lt;p&gt;不同的输入可能包含着大小不同关键特征，使用大小可变的数据结构去做容器，则更加灵活。&lt;/p&gt;
&lt;p&gt;假如神经元激活具有稀疏性，那么不同激活路径上：不同数量（选择性不激活）、不同功能（分布式激活），&lt;/p&gt;
&lt;p&gt;两种可优化的结构生成的激活路径，可以更好地从有效的数据的维度上，学习到相对稀疏的特征，起到自动化解离效果。&lt;/p&gt;

&lt;h2&gt;2.1  非饱和线性端&lt;/h2&gt;
&lt;p&gt;撇开稀疏激活不谈，校正激活函数&lt;span id=&quot;MathJax-Element-4-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo movablelimits=&amp;quot;true&amp;quot; form=&amp;quot;prefix&amp;quot;&amp;gt;max&amp;lt;/mo&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-43&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-44&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-45&quot; class=&quot;mo&quot;&gt;max&lt;span id=&quot;MathJax-Span-46&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-47&quot; class=&quot;mn&quot;&gt;0&lt;span id=&quot;MathJax-Span-48&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-49&quot; class=&quot;mi&quot;&gt;x&lt;span id=&quot;MathJax-Span-50&quot; class=&quot;mo&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;，与Softplus函数在兴奋端的差异较大(线性和非线性)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;几十年的机器学习发展中，我们形成了这样一个概念：非线性激活函数要比线性激活函数更加先进。&lt;/p&gt;
&lt;p&gt;尤其是在布满Sigmoid函数的BP神经网络，布满径向基函数的SVM神经网络中，往往有这样的幻觉，非线性函数对非线性网络贡献巨大。&lt;/p&gt;
&lt;p&gt;该幻觉在SVM中更加严重。核函数的形式并非完全是SVM能够处理非线性数据的主力功臣（支持向量充当着隐层角色）。&lt;/p&gt;
&lt;p&gt;那么在深度网络中，对非线性的依赖程度就可以缩一缩。另外，在上一部分提到，&lt;span&gt;&lt;strong&gt;稀疏特征并不需要网络具有很强的处理线性不可分机制&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;综合以上两点，在深度学习模型中，使用简单、速度快的线性激活函数可能更为合适。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/678029/201504/250236342652777.png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;271&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，&lt;span&gt;&lt;strong&gt;一旦神经元与神经元之间改为线性激活，网络的&lt;span&gt;非线性部分仅仅来自于神经元部分选择性激活&lt;/span&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.2  Vanishing Gradient Problem&lt;/h2&gt;
&lt;p&gt;更倾向于使用线性神经激活函数的另外一个原因是，&lt;span&gt;&lt;strong&gt;减轻梯度法训练深度网络时的Vanishing Gradient Problem&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;看过BP推导的人都知道，误差从输出层反向传播算梯度时，在各层都要乘当前层的输入神经元值，激活函数的一阶导数。&lt;/p&gt;
&lt;p&gt;即&lt;span id=&quot;MathJax-Element-5-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;G&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;r&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;d&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;E&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;r&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;r&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;o&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;r&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x22C5;&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;S&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;i&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;g&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;m&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;o&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;i&amp;lt;/mi&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;d&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2032;&amp;lt;/mo&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x22C5;&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-51&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-52&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-53&quot; class=&quot;mi&quot;&gt;G&lt;span id=&quot;MathJax-Span-54&quot; class=&quot;mi&quot;&gt;r&lt;span id=&quot;MathJax-Span-55&quot; class=&quot;mi&quot;&gt;a&lt;span id=&quot;MathJax-Span-56&quot; class=&quot;mi&quot;&gt;d&lt;span id=&quot;MathJax-Span-57&quot; class=&quot;mo&quot;&gt;=&lt;span id=&quot;MathJax-Span-58&quot; class=&quot;mi&quot;&gt;E&lt;span id=&quot;MathJax-Span-59&quot; class=&quot;mi&quot;&gt;r&lt;span id=&quot;MathJax-Span-60&quot; class=&quot;mi&quot;&gt;r&lt;span id=&quot;MathJax-Span-61&quot; class=&quot;mi&quot;&gt;o&lt;span id=&quot;MathJax-Span-62&quot; class=&quot;mi&quot;&gt;r&lt;span id=&quot;MathJax-Span-63&quot; class=&quot;mo&quot;&gt;⋅&lt;span id=&quot;MathJax-Span-64&quot; class=&quot;mi&quot;&gt;S&lt;span id=&quot;MathJax-Span-65&quot; class=&quot;mi&quot;&gt;i&lt;span id=&quot;MathJax-Span-66&quot; class=&quot;mi&quot;&gt;g&lt;span id=&quot;MathJax-Span-67&quot; class=&quot;mi&quot;&gt;m&lt;span id=&quot;MathJax-Span-68&quot; class=&quot;mi&quot;&gt;o&lt;span id=&quot;MathJax-Span-69&quot; class=&quot;mi&quot;&gt;i&lt;span id=&quot;MathJax-Span-70&quot; class=&quot;msup&quot;&gt;&lt;span id=&quot;MathJax-Span-71&quot; class=&quot;mi&quot;&gt;d&lt;span id=&quot;MathJax-Span-72&quot; class=&quot;mo&quot;&gt;′&lt;span id=&quot;MathJax-Span-73&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-74&quot; class=&quot;mi&quot;&gt;x&lt;span id=&quot;MathJax-Span-75&quot; class=&quot;mo&quot;&gt;)&lt;span id=&quot;MathJax-Span-76&quot; class=&quot;mo&quot;&gt;⋅&lt;span id=&quot;MathJax-Span-77&quot; class=&quot;mi&quot;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;。使用双端饱和(即值域被限制)Sigmoid系函数会有两个问题：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① Sigmoid'(x)∈(0,1)  导数缩放&lt;/p&gt;
&lt;p&gt;② x∈(0,1)或x∈(-1,1)  饱和值缩放&lt;/p&gt;
&lt;p&gt;这样，&lt;strong&gt;经过每一层时，Error都是成倍的衰减，一旦进行递推式的多层的反向传播，梯度就会不停的衰减，消失，使得网络学习变慢。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而校正激活函数的梯度是1，且只有一端饱和，梯度很好的在反向传播中流动，训练速度得到了很大的提高。&lt;/p&gt;
&lt;p&gt;Softplus函数则稍微慢点，Softplus'(x)=Sigmoid(x)∈(0,1) ，但是也是单端饱和，因而速度仍然会比Sigmoid系函数快。&lt;/p&gt;

&lt;h2&gt;强制引入稀疏零的合理性？&lt;/h2&gt;
&lt;p&gt;诚然，稀疏性有很多优势。但是，过分的强制稀疏处理，会减少模型的有效容量。即特征屏蔽太多，导致模型无法学习到有效特征。&lt;/p&gt;
&lt;p&gt;论文中对稀疏性的引入度做了实验，理想稀疏性（强制置0）比率是70%~85%。超过85%，网络就容量就成了问题，导致错误率极高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/678029/201504/280013037554268.png&quot; alt=&quot;&quot; width=&quot;472&quot; height=&quot;359&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对比大脑工作的95%稀疏性来看，现有的计算神经网络和生物神经网络还是有很大差距的。&lt;/p&gt;
&lt;p&gt;庆幸的是，&lt;span&gt;&lt;strong&gt;ReLu只有负值才会被稀疏掉，即引入的稀疏性是可以训练调节的，是动态变化的&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;只要进行梯度训练，网络可以向误差减少的方向，自动调控稀疏比率，保证激活链上存在着合理数量的非零值。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;4.1  缩小做和不做非监督预训练的代沟&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;ReLu的使用，使得网络可以自行引入稀疏性。这一做法，等效于无监督学习的预训练。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/678029/201504/280055431153635.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，效果肯定没预训练好。论文中给出的数据显示，没做预训练情况下，ReLu激活网络遥遥领先其它激活函数。&lt;/p&gt;
&lt;p&gt;甚至出现了比普通激活函数预训练后更好的奇葩情况。当然，在预训练后，ReLu仍然有提升空间。&lt;/p&gt;
&lt;p&gt;从这一层面来说，ReLu缩小了非监督学习和监督学习之间的代沟。当然，还有更快的训练速度。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;4.2  更快的特征学习&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在MNIST+LeNet4中，ReLu+Tanh的组合在epoch 50左右就能把验证集错误率降到1.05%&lt;/p&gt;
&lt;p&gt;但是，全Tanh在epoch 150时，还是1.37%，这个结果ReLu+Tanh在epoch 17时就能达到了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/678029/201504/280120355838911.png&quot; alt=&quot;&quot; width=&quot;415&quot; height=&quot;336&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该图来自AlexNet的&lt;a href=&quot;http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf&quot; target=&quot;_blank&quot;&gt;论文&lt;/a&gt;对ReLu和普通Sigmoid系函数做的对比测试，可以看到，ReLu的使用，使得学习周期&lt;/p&gt;
&lt;p&gt;大大缩短。综合速率和效率，DL中大部分激活函数应该选择ReLu。&lt;/p&gt;

&lt;p&gt;ReLu可以直接用T.maximum(0,x)实现，用T.max(0,x)不能求导.&lt;/p&gt;
</description>
<pubDate>Fri, 06 Apr 2018 05:17:00 +0000</pubDate>
<dc:creator>郭耀华</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guoyaohua/p/8727509.html</dc:identifier>
</item>
<item>
<title>machine learning 之 导论 一元线性回归 - Echo_fy</title>
<link>http://www.cnblogs.com/echo-coding/p/8727475.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/echo-coding/p/8727475.html</guid>
<description>&lt;p&gt;整理自Andrew Ng 的 machine learnig 课程 week1&lt;/p&gt;

&lt;p&gt;目录：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是机器学习&lt;/li&gt;
&lt;li&gt;监督学习&lt;/li&gt;
&lt;li&gt;非监督学习&lt;/li&gt;
&lt;li&gt;一元线性回归
&lt;ul&gt;&lt;li&gt;模型表示&lt;/li&gt;
&lt;li&gt;损失函数&lt;/li&gt;
&lt;li&gt;梯度下降算法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;1、什么是机器学习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Arthur Samuel不是一个playing checker的高手，但是他编了一个程序，每天和这个程序playing checker，后来这个程序最后变得特别厉害，可以赢很多很厉害的人了。所以Arthur Samuel就给机器学习下了一个比较old，不太正式的定义：&lt;/p&gt;
&lt;p&gt;” the field of study that gives the computer the ability to learn without being explicitly programmed “ &lt;/p&gt;

&lt;p&gt;现代比较正式的一个定义是：&lt;/p&gt;
&lt;p&gt;” &lt;span&gt;A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P , if its perfermance at tasks in T as measured by P, improves with experience E&lt;/span&gt;  “ &lt;/p&gt;
&lt;p&gt;也就是说：计算机程序从 ” 做一系列任务T得来的经验E ” 和 “ 测度这个任务做的好不好的表现测度 P “ 中去学习，学习的目标就是，通过这些经验E ，这些任务T做的更好了，做的好不好的评价标准就是P；&lt;/p&gt;
&lt;p&gt;以上面Arthur Samuel playing checker的例子来说：&lt;/p&gt;
&lt;p&gt;E：Arthur Samuel和程序很多次play checker的经验；&lt;/p&gt;
&lt;p&gt;T：playing checker&lt;/p&gt;
&lt;p&gt;P：程序在下一次比赛中赢的概率&lt;/p&gt;

&lt;p&gt;机器学习问题一般可以分为 ” 监督学习 “ 和 ” 非监督学习 “两类。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、监督学习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&quot;given data set and already know what our correct output should look like&quot;&lt;/p&gt;
&lt;p&gt;对于输入和输出之间的关系我们已经差不多可以有一个思路了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; ” 回归 “ 和 ” 分类 “&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回归：结果是连续的，map input to some continuous function （如：预测房价）&lt;/p&gt;
&lt;p&gt;分类：结果是离散的，map input to some discrete function （如：预测房价是否大于某个值）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、非监督学习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;” approach problems with little or no ideal what our result should look like “&lt;/p&gt;
&lt;p&gt;对于输入和输出之间的关系，我们没有一个概念&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;” 聚类 “ 和 ” 非聚类 “&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;聚类：对1000,000中不同的基因聚类，group related to lifespan, height.......&lt;/p&gt;
&lt;p&gt;非聚类：鸡尾酒宴会算法，find structure in chaotic environment （比如，在鸡尾酒宴会中各种混杂的声音中识别出某个人的声音或者背景音乐）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4、一元线性回归&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模型表示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$x^{(i)}$：输入变量&lt;/p&gt;
&lt;p&gt;$y^{(i)}$：输出变量&lt;/p&gt;
&lt;p&gt;$(x^{(i)}, y^{(i)})$：一个训练数据&lt;/p&gt;
&lt;p&gt;$(x^{(i)}, y^{(i)}); i=1...m$：训练数据集&lt;/p&gt;
&lt;p&gt;$X=Y=R$：输入空间和输出空间，这里是一样的&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$h_\theta(x)=\theta_0+\theta_1x$&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;比如以下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226720/201804/1226720-20180406123640717-2111506537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226720/201804/1226720-20180406123609078-1910777195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对于监督学习问题：给定训练数据集(x,y)，学习一个$h(x):X \rightarrow Y$，对于h(x)是y的一个好的预测&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226720/201804/1226720-20180406130213751-1899117413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;损失函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于衡量h(x)的accuracy，是h(x)和y的average difference&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$ J(\theta_0,\theta_1)$ = $ \frac{1}{2m} $ $\sum_{i=1}^m$ $(h_\theta(x^{(i)}-y^{(i)})))^2 $&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个函数被称为平方损失函数（square error function / mean square error）, 在回归问题中常用于表示损失函数，非回归问题中也会用，比较常用&lt;/p&gt;
&lt;p&gt;这里 $ \sum_{i=1}^m$ $(h_\theta(x^{(i)})-y^{(i)})^2 $ 是损失平方和，$\frac12$是为了以后求导方便加上去的&lt;/p&gt;
&lt;p&gt;我们的目标就是找到一个使得损失函数最小的$\theta_0和\theta_1$:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;损失函数 visual 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下为了展示损失函数，为了方便，让$\theta_0=0$&lt;/p&gt;
&lt;p&gt;当$\theta_1=1$时，$J(\theta_1)=0$，在右图绿色叉叉的位置；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226720/201804/1226720-20180406124015827-1997759612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当$\theta_1=0.5$时，$J(\theta_1)=0.~$，大概在右图蓝色叉叉的位置；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226720/201804/1226720-20180406124028385-695225972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当$\theta_1=0$时，$J(\theta_1)=2.～$，大概在右图上y轴的黑色叉叉那里；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226720/201804/1226720-20180406124047010-1392750808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;基于以上三个点，我们知道$J(\theta_1)$大概就是上右图的样子，当$\theta_1=1$时$J(\theta_1)$最小，左边递减，右边递增；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;损失函数 visual 2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于以上简单的损失函数，我们还可以在二维图上画出来，也比较好理解，但是当维度（变量）大了之后，这种图就不好画了，比如二维：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226720/201804/1226720-20180406125100995-198836129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;此时常用&lt;span&gt;等高线图&lt;/span&gt;来表示损失函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226720/201804/1226720-20180406125107651-745488151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于以上的训练数据，当$\theta_0=0, \theta_1=360$时，$J(\theta_0, \theta_1)$位于等高线图中红色叉叉的位置；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226720/201804/1226720-20180406125247191-444581757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当$\theta_0, \theta_1$如下左图时，$J(\theta_0, \theta_1)$位于等高线图中绿色叉叉的位置；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226720/201804/1226720-20180406125200919-117404288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当$\theta_0, \theta_1$如下左图时，$J(\theta_0, \theta_1)$位于等高线图中蓝色叉叉的位置，也就是接近最优解的地方，等高线的近似中间位置；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226720/201804/1226720-20180406125218072-1832982569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;梯度下降算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么如何找到最优解呢？梯度下降算法就是一个方法，见以往博客：&lt;a href=&quot;http://www.cnblogs.com/echo-coding/p/8641327.html&quot; target=&quot;_blank&quot;&gt;Gradient Descent&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 06 Apr 2018 05:04:00 +0000</pubDate>
<dc:creator>Echo_fy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/echo-coding/p/8727475.html</dc:identifier>
</item>
<item>
<title>MongoDb进阶实践之三 MongoDB查询命令详述 - PatrickLiu</title>
<link>http://www.cnblogs.com/PatrickLiu/p/8727470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/8727470.html</guid>
<description>&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;           上一篇文章我们已经介绍了MongoDB数据库的最基本操作，包括数据库的创建、使用和删除数据库，文档的操作也涉及到了文档的创建、删除、更新和查询，当然也包括集合的创建、重命名和删除。有了这些基本操作，大家第一次使用MongoDb数据库的时候就不会慌张，慢慢操作就可以了。虽然上一篇文章简单介绍了一些文档的查询，那都是最基本的，由于文档的查询涉及的内容比较多，所以我们需要单独写一篇文章来专门介绍有关文档的查询的详细信息。废话不多说，马上开始我们今天的写作吧。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、MongDB查询的详解&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;          &lt;br/&gt;          我比较直接，直接上内容，有关查询的每个方法都有示例代码，应该不是很难。&lt;/p&gt;&lt;p&gt;            &lt;span&gt;&lt;strong&gt;1、find()查询方法：根据查询条件返回符合条件的所有文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                     MongoDB 查询文档使用 find() 方法，find() 方法以非结构化的方式来显示所有文档。&lt;/p&gt;&lt;p&gt;                     &lt;strong&gt;语法：db.collectionName.find(query, projection)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                    参数说明：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                         query ：可选，使用查询操作符指定查询条件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                         projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。格式类似{&amp;lt;key&amp;gt;:1,&amp;lt;key&amp;gt;:1,_id:0}，0值表示不显示，其他值均为显示，无论正负值。该参数控制不显示的字段，需要显示的不在该参数里书写就可以。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                     如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                     &amp;gt;db.collectionName.find().pretty()&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                     pretty() 方法以格式化的方式来显示所有文档。&lt;/p&gt;&lt;p&gt;                  &lt;span&gt;&lt;strong&gt;   1.1、示例代码：查询所有文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                          //find()方法内没有任何查询条件，查询所有记录，find({})方法表示空条件，也就是无条件，和find()方法查询结果一样。&lt;br/&gt;                          &amp;gt; db.students.find()&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de3c3afa6504457050e4&quot;), &quot;name&quot; : &quot;HuangFeiHong&quot;, &quot;age&quot; : 32, &quot;sex&quot; : 1, &quot;school&quot; : &quot;GuangDongDaXue&quot;, &quot;address&quot; : &quot;GuangDongFoShan&quot; }&lt;/p&gt;&lt;p&gt;                         &amp;gt; db.students.find({})&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de3c3afa6504457050e4&quot;), &quot;name&quot; : &quot;HuangFeiHong&quot;, &quot;age&quot; : 32, &quot;sex&quot; : 1, &quot;school&quot; : &quot;GuangDongDaXue&quot;, &quot;address&quot; : &quot;GuangDongFoShan&quot; }&lt;/p&gt;&lt;p&gt;                     &lt;span&gt;&lt;strong&gt;1.2、示例代码：根据指定条件查询文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                         //查询【name】字段的值是【angShiYu】 的文档&lt;br/&gt;                         &amp;gt; db.students.find({name:&quot;FangShiYu&quot;})&lt;br/&gt;                        { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;/p&gt;&lt;p&gt;                         //查询【sex】性别字段是【1】男的所有文档&lt;br/&gt;                         &amp;gt; db.students.find({sex:1})&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de3c3afa6504457050e4&quot;), &quot;name&quot; : &quot;HuangFeiHong&quot;, &quot;age&quot; : 32, &quot;sex&quot; : 1, &quot;school&quot; : &quot;GuangDongDaXue&quot;, &quot;address&quot; : &quot;GuangDongFoShan&quot; }&lt;/p&gt;&lt;p&gt;                         //查询【sex】性别字段是【1】男的，并且【age】字段的值是【22】的所有文档&lt;br/&gt;                         &amp;gt; db.students.find({sex:1,age:22})&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;br/&gt;                         &amp;gt;&lt;/p&gt;&lt;p&gt;                   &lt;span&gt;&lt;strong&gt;  1.3、示例代码：控制字段的显示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                           //find({查询条件},{控制字段显示与否})方法的第二个参数控制查询出来的字段的显示，_id:0,表示不显示，其他值均为显示，不写该字段也会显示，_id主键除外的字段，需要显示就写上，但是其值不能是0，比如：address:0，这会产生错误，address:1/-1都会显示&lt;/p&gt;&lt;p&gt;                         //查询【sex】性别字段是【1】男的所有文档，_id字段不显示，只显示【name】,【age】,【school】字段&lt;br/&gt;                         &amp;gt; db.students.find({sex:1},{_id:0,name:-1,age:1,school:1})&lt;br/&gt;                         { &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;school&quot; : &quot;ZheJiangDaXue&quot; }&lt;br/&gt;                         { &quot;name&quot; : &quot;HuangFeiHong&quot;, &quot;age&quot; : 32, &quot;school&quot; : &quot;GuangDongDaXue&quot; }&lt;br/&gt;                         &amp;gt;&lt;/p&gt;&lt;p&gt;                     &lt;span&gt;&lt;strong&gt;1.4、示例代码：格式化文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                         //使用pretty()格式化输出&lt;br/&gt;                         &amp;gt; db.students.find({sex:0}).pretty()&lt;br/&gt;                        {&lt;br/&gt;                                 &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;),&lt;br/&gt;                                 &quot;name&quot; : &quot;YanYongChun&quot;,&lt;br/&gt;                                 &quot;age&quot; : 27,&lt;br/&gt;                                 &quot;sex&quot; : 0,&lt;br/&gt;                                 &quot;school&quot; : &quot;FuJianDaXue&quot;,&lt;br/&gt;                                 &quot;address&quot; : &quot;FuJianNanTianRen&quot;&lt;br/&gt;                         }&lt;/p&gt;&lt;p&gt;            &lt;span&gt;&lt;strong&gt;2、findOne()查询方法：查询结果只会返回符合条件的第一条文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                     &lt;strong&gt;MongoDB 查询文档使用 findOne()方法查询符合条件的第一条文档，使用和find()方法类似，并以非结构化的方式来显示所有文档。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                     语法：db.collectionName.findOne(query, projection)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                     参数说明：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                             query ：可选，使用查询操作符指定查询条件&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;                             projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。格式类似{&amp;lt;key&amp;gt;:1,&amp;lt;key&amp;gt;:1,_id:0}，非0的值表示显示，0表示不显示&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                             findOne()方法不支持pretty()方法。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                     &lt;span&gt;&lt;strong&gt;2.1、示例代码：显示符合条件的第一条记录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                         //性别【sex】是【1】男性的有两条文档，但是只显示了第一条&lt;br/&gt;                         &amp;gt;  db.students.findOne({sex:1})&lt;br/&gt;                         {&lt;br/&gt;                                  &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;),&lt;br/&gt;                                  &quot;name&quot; : &quot;FangShiYu&quot;,&lt;br/&gt;                                  &quot;age&quot; : 22,&lt;br/&gt;                                  &quot;sex&quot; : 1,&lt;br/&gt;                               &quot;school&quot; : &quot;ZheJiangDaXue&quot;,&lt;br/&gt;                              &quot;address&quot; : &quot;GuangDongGuangZhou&quot;&lt;br/&gt;                         }&lt;/p&gt;&lt;p&gt;      &lt;span&gt;&lt;strong&gt;               2.2、示例代码：控制字段列的显示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                         &amp;gt;  db.students.findOne({sex:1},{_id:0,name:1,age:1,sex:1,school:1,address:1})&lt;br/&gt;                         {&lt;br/&gt;                                  &quot;name&quot; : &quot;FangShiYu&quot;,&lt;br/&gt;                                  &quot;age&quot; : 22,&lt;br/&gt;                                  &quot;sex&quot; : 1,&lt;br/&gt;                                  &quot;school&quot; : &quot;ZheJiangDaXue&quot;,&lt;br/&gt;                                  &quot;address&quot; : &quot;GuangDongGuangZhou&quot;&lt;br/&gt;                         }&lt;br/&gt;                         &amp;gt;&lt;/p&gt;&lt;p&gt;                     &lt;span&gt;&lt;strong&gt;2.3、示例代码：findOne()方法不支持pretty()方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                         &amp;gt; db.students.find({sex:1},{_id:0,name:-1,age:1,school:1}).pretty()&lt;br/&gt;                         2018-03-29T13:27:12.277+0800 E QUERY    [thread1] TypeError: db.students.findOne(...).pretty is not a function :&lt;br/&gt;                         @(shell):1:1&lt;/p&gt;&lt;p&gt;            &lt;span&gt;&lt;strong&gt;3、条件操作符&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                     如果你熟悉常规的 SQL 数据，通过下表可以更好的理解 MongoDB 的条件语句查询：&lt;/p&gt;&lt;p&gt;                     &lt;strong&gt;3.1、: 等于 ：查询指定字段的值等于某个具体的值的时候返回符合条件的文档&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                           &lt;strong&gt;语法：db.collectionName.find({&amp;lt;key&amp;gt;:&amp;lt;value&amp;gt;})&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                           &lt;strong&gt;&lt;strong&gt;参数说明：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                             key：需要执行查询判断的字段名&lt;/p&gt;&lt;p&gt;                             value：这个值是一个具体的数值，并且这个值需要和Key字段里面的值进行比较，只有当Key字段的值等于Value的时候，才返回符合条件的文档&lt;/p&gt;&lt;p&gt;                           实例代码：&lt;/p&gt;&lt;p&gt;                                &amp;gt; db.students.find({&quot;name&quot;:&quot;FangShiYu&quot;})&lt;br/&gt;                                { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;/p&gt;&lt;p&gt; &lt;br/&gt;&lt;span&gt;&lt;strong&gt;                     3.2、$lt 小于：查询指定字段的值小于某个具体的值的时候返回符合条件的文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                           语法：db.collectionName.find({&amp;lt;key&amp;gt;:{$lt:&amp;lt;value&amp;gt;}})&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                           &lt;strong&gt;&lt;strong&gt;参数说明：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                              key：需要执行查询判断的字段名&lt;/p&gt;&lt;p&gt;                              value：这个值是一个具体的数值，并且这个值需要和Key字段里面的值进行比较，只有当Key字段的值小于Value的时候，才返回符合条件的文档&lt;/p&gt;&lt;p&gt;                           实例代码：&lt;/p&gt;&lt;p&gt;                                &amp;gt;db.students.find({&quot;age&quot;:{$lt:27}})&lt;br/&gt;                                { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;/p&gt;&lt;p&gt;                     &lt;span&gt;&lt;strong&gt;3.3、$lte 小于或等于 ：查询指定字段的值在小于或者等于某个具体的数值时返回所有符合条件的文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                           语法：db.collectionName.find({&amp;lt;key&amp;gt;:{$lte:&amp;lt;value&amp;gt;}})&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                           &lt;strong&gt;&lt;strong&gt;参数说明：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                              key：需要执行查询判断的字段名&lt;/p&gt;&lt;p&gt;                             value：这个值是一个具体的数值，并且这个值需要和Key字段里面的值进行比较，只有当Key字段的值小于或者等于Value的时候，才返回符合条件的文档&lt;/p&gt;&lt;p&gt;                           实例代码：&lt;/p&gt;&lt;p&gt;                                &amp;gt; db.students.find({&quot;age&quot;:{$lte:27}})&lt;br/&gt;                                { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;br/&gt;                                { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;br/&gt;                                &amp;gt;&lt;/p&gt;&lt;p&gt;                &lt;span&gt;&lt;strong&gt;     3.4、$gt 大于：查询指定字段的值是大于某个具体的值的所有文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                           &lt;strong&gt;语法：db.collectionName.find({&amp;lt;key&amp;gt;:{$gt:&amp;lt;value&amp;gt;}})&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                           &lt;strong&gt;&lt;strong&gt;参数说明：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                              key：需要执行查询判断的字段名&lt;/p&gt;&lt;p&gt;                             value：这个值是一个具体的数值，并且这个值需要和Key字段里面的值进行比较，只有当Key字段的值大于Value的时候，才返回符合条件的文档&lt;/p&gt;&lt;p&gt;                           实例代码：&lt;/p&gt;&lt;p&gt;                                &amp;gt; db.students.find({&quot;age&quot;:{$gt:27}})&lt;br/&gt;                               { &quot;_id&quot; : ObjectId(&quot;5ab9de3c3afa6504457050e4&quot;), &quot;name&quot; : &quot;HuangFeiHong&quot;, &quot;age&quot; : 32, &quot;sex&quot; : 1, &quot;school&quot; : &quot;GuangDongDaXue&quot;, &quot;address&quot; : &quot;GuangDongFoShan&quot; }&lt;br/&gt;                                &amp;gt;&lt;/p&gt;&lt;p&gt;                     &lt;span&gt;&lt;strong&gt;3.5、$gte 大于或等于&lt;/strong&gt; &lt;strong&gt;：查询指定字段的值是大于或者等于某个值的所有文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                           语法：db.collectionName.find({&amp;lt;key&amp;gt;:{$gte:&amp;lt;value&amp;gt;}})&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                           &lt;strong&gt;参数说明：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                              key：需要执行查询判断的字段名&lt;/p&gt;&lt;p&gt;                             value：这个值是一个具体的数值，并且这个值需要和Key字段里面的值进行比较，只有当Key字段的值比Value大或者相等，并返回符合条件的文档&lt;/p&gt;&lt;p&gt;                           实例代码：&lt;/p&gt;&lt;p&gt;                                &amp;gt; db.students.find({&quot;age&quot;:{$gte:24}})&lt;br/&gt;                                { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;br/&gt;                                { &quot;_id&quot; : ObjectId(&quot;5ab9de3c3afa6504457050e4&quot;), &quot;name&quot; : &quot;HuangFeiHong&quot;, &quot;age&quot; : 32, &quot;sex&quot; : 1, &quot;school&quot; : &quot;GuangDongDaXue&quot;, &quot;address&quot; : &quot;GuangDongFoShan&quot; }&lt;br/&gt;                                 &amp;gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;                     3.6、$ne 不等于：查询指定字段的值不等于某个特定值并返回符合条件的文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                      &lt;strong&gt;     语法：db.collectionName.find({&amp;lt;key&amp;gt;:{$ne:&amp;lt;value&amp;gt;}})&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                           参数说明：&lt;/p&gt;&lt;p&gt;                                   key：需要执行查询的字段名&lt;/p&gt;&lt;p&gt;                                  value：这个值是一个具体的数值，并且这个值需要和Key字段里面的值进行比较，不相等，就执行查询，并返回符合条件的记录&lt;/p&gt;&lt;p&gt;                           实例代码：&lt;/p&gt;&lt;p&gt;                                &amp;gt; db.students.find({&quot;sex&quot;:{$ne:1}})&lt;br/&gt;                               { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;/p&gt;&lt;p&gt;                     &lt;span&gt;&lt;strong&gt;3.7、$gte 和 $lte &lt;span&gt;&lt;strong&gt;大于等于、小于等于&lt;/strong&gt;&lt;/span&gt;：查询指定字段的值属于某个指定值的范围的所有文档，满足条件返回文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                           &lt;strong&gt;语法：db.collectionName.find({&amp;lt;key&amp;gt;:{$gte:&amp;lt;value1&amp;gt;,$lte:&amp;lt;value2&amp;gt;}})&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                           参数说明：&lt;/p&gt;&lt;p&gt;                                   key：进行比较的字段名&lt;/p&gt;&lt;p&gt;                                  $gte：大于等于&lt;/p&gt;&lt;p&gt;                                  &lt;strong&gt;value1：这个值是要大于等于的那个值&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                                  $lte：小于等于&lt;/p&gt;&lt;p&gt;                                  value2：这个值是要小于等于的那个值&lt;br/&gt;                                &lt;br/&gt;                                  value1和value2形成一个比较的范围，可以针对名称为Key的字段的值进行判断&lt;/p&gt;&lt;p&gt;                           实例代码：&lt;/p&gt;&lt;p&gt;                                &amp;gt; db.students.find({&quot;age&quot;:{$gte:20,$lte:27}})&lt;br/&gt;                               { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;br/&gt;                               { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;br/&gt;                                &amp;gt;&lt;/p&gt;&lt;p&gt;             &lt;span&gt;&lt;strong&gt;4、And和Or 的使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                   &lt;span&gt;&lt;strong&gt;4.1、and 的使用：和的关系，必须满足所有的条件才能完成查询&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                         &lt;strong&gt;语法：db.collectionName.find({query1，query2，query3，...queryn})&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                        参数说明：&lt;/p&gt;
&lt;p&gt;                                &lt;strong&gt;query1-n：查询条件，这些查询条件必须在一个花括号（{}）里面，这种使用方式才是and的关系&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                         示例代码：&lt;/p&gt;&lt;p&gt;                             &amp;gt;db.students.find({age:{$gt:24},sex:0})&lt;br/&gt;                             { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;br/&gt;                             &amp;gt;&lt;/p&gt;&lt;p&gt;                         &lt;br/&gt;                   &lt;span&gt;&lt;strong&gt;4.2、or 的使用：或的关系，满足条件之一就可以完成查询&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                         &lt;strong&gt;语法：db.collectionName.find({$or:[{query1}，{query2}，{query3}，...{queryn}]}) &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                        参数说明：&lt;/p&gt;&lt;p&gt;                                query1-n：是查询条件，条件之间是或（or）的关系，并且“[]”方括号不能省略&lt;/p&gt;&lt;p&gt;                         示例代码：&lt;/p&gt;&lt;p&gt;                             &amp;gt;db.students.find({$or:[{sex:0},{age:22}]})&lt;br/&gt;                             { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;br/&gt;                             { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;br/&gt;                             &amp;gt;&lt;/p&gt;&lt;p&gt;                   &lt;strong&gt;4.3、and 和 or&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                         &lt;strong&gt;语法：db.collectionName.find({query1，query2，query3，...,$or:[{query4}，{query5}，{query6}，...]]})&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                        参数说明：&lt;/p&gt;&lt;p&gt;                               query1-n：都是查询的条件，前面的查询条件和后面的查询条件是or的关系，“$or”前面部分的查询条件是and的关系，后面的是or的关系&lt;/p&gt;&lt;p&gt;                         示例代码：&lt;/p&gt;&lt;p&gt;                             &amp;gt; db.students.find({age:{$gt:24},sex:0,$or:[{sex:1},{age:27}]})&lt;br/&gt;                             { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;br/&gt;                             &amp;gt;&lt;br/&gt;                    &lt;/p&gt;&lt;p&gt;             &lt;span&gt;&lt;strong&gt;5、以ID作为查询条件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                   &lt;strong&gt;语法：db.collectionName.find({_id：ObjectId(&quot;id的值&quot;)})&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                  参数说明：&lt;/p&gt;&lt;p&gt;                           _id：Mongodb自动生成的主键，这个是固定写法，不能改变。&lt;/p&gt;&lt;p&gt;                          ObjectId：代表是主键_id的值，整个的写法是：ObjectId(&quot;5ab9de223afa6504457050e2&quot;)，这个方法的值才是_id主键的值，其他写法是错误&lt;/p&gt;&lt;p&gt;                   代码实例：&lt;/p&gt;&lt;p&gt;                        &amp;gt; db.students.find({_id:ObjectId(&quot;5ab9de223afa6504457050e2&quot;)})&lt;br/&gt;                       { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;br/&gt;                        &amp;gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;             &lt;span&gt;6、count()方法：统计查询文档记录的条数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                   语法：db.collectionName.find({query1,query2...queryn}).count()&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;                   &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;                   参数说明：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                         query1-n:查询条件，可以有多个查询条件，多个查询条件之间是and的关系。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                   代码实例：&lt;/p&gt;&lt;p&gt;                        &amp;gt; db.students.find({&quot;sex&quot;:1}).count()&lt;br/&gt;                        2&lt;br/&gt;                        &amp;gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;             7、查询以什么值开头&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                   &lt;strong&gt;语法：db.collectionName.find({&amp;lt;key&amp;gt;:/^value/})&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                  参数说明：&lt;/p&gt;&lt;p&gt;                           key：要查询的字段的名称&lt;/p&gt;&lt;p&gt;                          value：检查key字段的值中是否以value开始，格式：/^value/，斜杠“/”和“^”不能省略&lt;/p&gt;&lt;p&gt;                   代码实例：&lt;/p&gt;&lt;p&gt;                        &amp;gt; db.students.find({name:/^F/})&lt;br/&gt;                        { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;             8、查询某个字段总是否包含另一个值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                   &lt;strong&gt;语法：db.collectionName.find({&amp;lt;key&amp;gt;:/value/})&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                  参数说明：&lt;/p&gt;&lt;p&gt;                           key：查询的字段的名称&lt;/p&gt;&lt;p&gt;                          value：查询key字段的值中是否包含着value的值，前后的两个斜杠“/”不能省略&lt;br/&gt;                   &lt;/p&gt;&lt;p&gt;                   代码实例：&lt;/p&gt;&lt;p&gt;                        &amp;gt; db.students.find({name:/ng/})&lt;br/&gt;                        { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;br/&gt;                        { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;br/&gt;                        { &quot;_id&quot; : ObjectId(&quot;5ab9de3c3afa6504457050e4&quot;), &quot;name&quot; : &quot;HuangFeiHong&quot;, &quot;age&quot; : 32, &quot;sex&quot; : 1, &quot;school&quot; : &quot;GuangDongDaXue&quot;, &quot;address&quot; : &quot;GuangDongFoShan&quot; }&lt;/p&gt;&lt;p&gt;             &lt;strong&gt;&lt;span&gt;9、limit()和skip()方法的使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                   &lt;span&gt;&lt;strong&gt;9.1、limit()方法：只显示num条&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                        &lt;strong&gt;语法：db.collectionName.find({query}).limit(num)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                        参数说明：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                               query：查询条件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                               num：条数，仅仅显示的条数&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                        示例代码：&lt;/p&gt;&lt;p&gt;                            //显示前2条&lt;br/&gt;                            &amp;gt;db.students.find().limit(2)&lt;br/&gt;                            { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;br/&gt;                            { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;/p&gt;&lt;p&gt;                   &lt;span&gt;&lt;strong&gt;9.2、skip()方法：跳过num条后继续显示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                        &lt;strong&gt;语法：db.collectionName.find({query}).skip(num)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                       &lt;strong&gt;参数说明：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                                query：查询条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                                num：跳过的条数&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                        示例代码：&lt;br/&gt;                        &lt;br/&gt;                            //跳过2条，从第3条开始显示&lt;br/&gt;                            &amp;gt;db.students.find().skip(2)&lt;br/&gt;                            { &quot;_id&quot; : ObjectId(&quot;5ab9de3c3afa6504457050e4&quot;), &quot;name&quot; : &quot;HuangFeiHong&quot;, &quot;age&quot; : 32, &quot;sex&quot; : 1, &quot;school&quot; : &quot;GuangDongDaXue&quot;, &quot;address&quot; : &quot;GuangDongFoShan&quot; }&lt;br/&gt;                            &amp;gt;&lt;/p&gt;&lt;p&gt;              &lt;span&gt;&lt;strong&gt;     9.3、skip()和 limit() 联合使用：分页显示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                        &lt;strong&gt;语法：db.collectionName.find({query}).skip(pageIndex*pageSize).limit(pageSize)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                        参数说明：&lt;/p&gt;&lt;p&gt;                                   query：查询条件&lt;/p&gt;&lt;p&gt;                                   pageIndex：页码索引，从0开始&lt;/p&gt;&lt;p&gt;                                   pageSize：每页显示的条数&lt;br/&gt;&lt;/p&gt;&lt;p&gt;                        示例代码：&lt;/p&gt;&lt;p&gt;                            //跳过1条，从第2条开始显示2条&lt;br/&gt;                            &amp;gt; db.students.find().skip(1).limit(2)&lt;br/&gt;                            { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;br/&gt;                            { &quot;_id&quot; : ObjectId(&quot;5ab9de3c3afa6504457050e4&quot;), &quot;name&quot; : &quot;HuangFeiHong&quot;, &quot;age&quot; : 32, &quot;sex&quot; : 1, &quot;school&quot; : &quot;GuangDongDaXue&quot;, &quot;address&quot; : &quot;GuangDongFoShan&quot; }&lt;br/&gt;                            &amp;gt;&lt;/p&gt;&lt;p&gt;           &lt;span&gt;&lt;strong&gt;  10、sort()方法：针对某个字段进行升序或者降序排序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                   &lt;strong&gt;语法：db.collectionName.find({query}).sort({&amp;lt;key&amp;gt;:1升序|-1 降序})&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                  参数说明：&lt;/p&gt;&lt;p&gt;                          query：查询条件&lt;/p&gt;&lt;p&gt;                          key：针对排序的字段名，1为升序，-1为降序，不能为其他值&lt;br/&gt;&lt;/p&gt;&lt;p&gt;                   示例代码：&lt;/p&gt;&lt;p&gt;                         //按年龄（age）升序排列&lt;br/&gt;                         &amp;gt; db.students.find().sort({age:1})&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de3c3afa6504457050e4&quot;), &quot;name&quot; : &quot;HuangFeiHong&quot;, &quot;age&quot; : 32, &quot;sex&quot; : 1, &quot;school&quot; : &quot;GuangDongDaXue&quot;, &quot;address&quot; : &quot;GuangDongFoShan&quot; }&lt;/p&gt;&lt;p&gt;                         //按年龄（age）降序排列&lt;br/&gt;                         &amp;gt; db.students.find().sort({age:-1})&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de3c3afa6504457050e4&quot;), &quot;name&quot; : &quot;HuangFeiHong&quot;, &quot;age&quot; : 32, &quot;sex&quot; : 1, &quot;school&quot; : &quot;GuangDongDaXue&quot;, &quot;address&quot; : &quot;GuangDongFoShan&quot; }&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;br/&gt;                         { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;/p&gt;&lt;p&gt;             &lt;span&gt;&lt;strong&gt;11、$type 操作符：可以针对某个字段查询该字段的值和具体数据类型相匹配的文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;                    &lt;strong&gt;语法：db.collectionName.find({&amp;lt;key&amp;gt;:{$type:&amp;lt;value&amp;gt;}})&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                    参数说明：&lt;/p&gt;&lt;p&gt;                           key：要操作的字段名称&lt;/p&gt;&lt;p&gt;                           value：表示类型对应的值&lt;/p&gt;&lt;p&gt;                    &lt;strong&gt;$type操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                    &lt;strong&gt;MongoDB 中可以使用的类型如下表所示：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                       &lt;strong&gt;类型                               数字       备注&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;                       Double                             1     &lt;br/&gt;                       String                               2     &lt;br/&gt;                       Object                              3     &lt;br/&gt;                       Array                                4     &lt;br/&gt;                       Binary data                       5     &lt;br/&gt;                       Undefined                         6       已废弃。&lt;br/&gt;                       Object id                           7     &lt;br/&gt;                       Boolean                            8     &lt;br/&gt;                       Date                                  9     &lt;br/&gt;                       Null                                  10     &lt;br/&gt;                       Regular Expression         11     &lt;br/&gt;                       JavaScript                        13     &lt;br/&gt;                       Symbol                             14     &lt;br/&gt;                       JavaScript (with scope)    15     &lt;br/&gt;                       32-bit integer                   16     &lt;br/&gt;                       Timestamp                       17     &lt;br/&gt;                       64-bit integer                   18     &lt;br/&gt;                       Min key                          255       Query with -1.&lt;br/&gt;                       Max key                         127&lt;/p&gt;&lt;p&gt;                        示例代码：&lt;br/&gt;                   &lt;br/&gt;                             //如果想获取 &quot;school&quot; 集合中 name 为 String 的数据，你可以使用以下命令：&lt;br/&gt;                             &amp;gt; db.students.find({&quot;name&quot;:{$type:2}})&lt;br/&gt;                             { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e2&quot;), &quot;name&quot; : &quot;FangShiYu&quot;, &quot;age&quot; : 22, &quot;sex&quot; : 1, &quot;school&quot; : &quot;ZheJiangDaXue&quot;, &quot;address&quot; : &quot;GuangDongGuangZhou&quot; }&lt;br/&gt;                             { &quot;_id&quot; : ObjectId(&quot;5ab9de223afa6504457050e3&quot;), &quot;name&quot; : &quot;YanYongChun&quot;, &quot;age&quot; : 27, &quot;sex&quot; : 0, &quot;school&quot; : &quot;FuJianDaXue&quot;, &quot;address&quot; : &quot;FuJianNanTianRen&quot; }&lt;br/&gt;                             { &quot;_id&quot; : ObjectId(&quot;5ab9de3c3afa6504457050e4&quot;), &quot;name&quot; : &quot;HuangFeiHong&quot;, &quot;age&quot; : 32, &quot;sex&quot; : 1, &quot;school&quot; : &quot;GuangDongDaXue&quot;, &quot;address&quot; : &quot;GuangDongFoShan&quot; }&lt;br/&gt;                              &amp;gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;           今天就写到这里了，有关查询和更新的内容还很多，今天只是介绍一个大概的内容，让大家对MongoDB的操作有一个初步的印象。我们以后会用更多的章节介绍查询和跟新的内容，包括条件操作符，修改操作符，还有一些特殊的操作符，正因为这部分的内容很多，所以需要我们使用单独的章节来介绍其内容。不忘初衷，继续努力吧。&lt;/p&gt;
</description>
<pubDate>Fri, 06 Apr 2018 05:02:00 +0000</pubDate>
<dc:creator>PatrickLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/8727470.html</dc:identifier>
</item>
<item>
<title>彻底搞懂shell的高级I/O重定向 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8727401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8727401.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8727401.html#blog1.1&quot;&gt;&lt;span&gt;1.1 文件描述符(file description,fd)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8727401.html#blog1.2&quot;&gt;&lt;span&gt;1.2 文件描述符的复制&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8727401.html#blog1.3&quot;&gt;&lt;span&gt;1.3 重定向顺序很重要：&quot;&amp;gt;file 2&amp;gt;&amp;amp;1&quot;和&quot;2&amp;gt;&amp;amp;1 &amp;gt;file&quot;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8727401.html#blog1.4&quot;&gt;&lt;span&gt;1.4 改变当前shell环境的重定向目标&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8727401.html#blog1.5&quot;&gt;&lt;span&gt;1.5 关闭文件描述符&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8727401.html#blog1.6&quot;&gt;&lt;span&gt;1.6 打开文件&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8727401.html#blog1.7&quot;&gt;&lt;span&gt;1.7 文件描述符的移动&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8727401.html#blog1.8&quot;&gt;&lt;span&gt;1.8 经典示例&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p class=&quot;01&quot;&gt;基本的重定向功能想必都理解。本文对shell环境下的IO重定向稍作深入，相信看完后，能够彻底理解 &lt;span class=&quot;cnblogs_code&quot;&gt;&amp;gt;file &lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt; 。&lt;/p&gt;

&lt;h2&gt;1.1 文件描述符(file description,fd)&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;文件描述符是IO重定向中的重要概念。文件描述符使用数字表示，它指明了数据的流向特征。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;软件设计认为，程序应该有一个数据来源、数据出口和报告错误的地方。在Linux系统中，它们分别使用描述符0、1、2来表示，这3个描述符默认的目标文件(设备)分别是/dev/stdin、/dev/stdout、/dev/stderr，它们分别是各个终端字符设备的软链接。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@mariadb ~]# ll /dev/std*&lt;span&gt;
lrwxrwxrwx &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;15&lt;/span&gt; Apr  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;07&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt; /dev/stderr -&amp;gt; /proc/self/fd/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
lrwxrwxrwx &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;15&lt;/span&gt; Apr  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;07&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt; /dev/stdin -&amp;gt; /proc/self/fd/&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
lrwxrwxrwx &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;15&lt;/span&gt; Apr  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;07&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt; /dev/stdout -&amp;gt; /proc/self/fd/&lt;span&gt;1&lt;/span&gt;&lt;span&gt;

[root@mariadb &lt;/span&gt;~]# ll /proc/self/fd/&lt;span&gt;
total &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
lrwx&lt;/span&gt;------ &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;64&lt;/span&gt; Apr  &lt;span&gt;6&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; -&amp;gt; /dev/pts/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
lrwx&lt;/span&gt;------ &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;64&lt;/span&gt; Apr  &lt;span&gt;6&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; -&amp;gt; /dev/pts/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
lrwx&lt;/span&gt;------ &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;64&lt;/span&gt; Apr  &lt;span&gt;6&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; -&amp;gt; /dev/pts/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
lr&lt;/span&gt;-x------ &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;64&lt;/span&gt; Apr  &lt;span&gt;6&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; -&amp;gt; /proc/&lt;span&gt;14038&lt;/span&gt;/fd
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;在Linux中，每一个进程打开时都会自动获取3个文件描述符0、1和2，分别表示标准输入、标准输出、和标准错误，如果要打开其他文件，则文件描述符必须从3开始标识。对于我们人为要打开的描述符，建议使用9以内的描述符，超过9的描述符可能已经被系统内部分配给其他进程。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;文件描述符说白了就是系统为了跟踪这个打开的文件而分配给它的一个数字，这个数字和文件绑定在一起，数据流入描述符的时候也表示流入文件。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;而Linux中万物皆文件，这些文件都可以分配描述符，包括套接字。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;程序在打开文件描述符的时候，有三种可能的行为：从描述符中读、向描述符中写、可读也可写。从lsof的FD列可以看出程序打开这个文件是为了从中读数据，还是向其中写数据，亦或是既读又写。例如，tail命令监控文件时，就是打开文件从中读数据的(3r的r是read，w是write，u是read and write)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@mariadb ~]# lsof -n | grep &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/a.sh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | column -&lt;span&gt;t                 
tail  &lt;/span&gt;&lt;span&gt;13563&lt;/span&gt;  root  3r  REG  &lt;span&gt;8&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;182&lt;/span&gt;  &lt;span&gt;69632966&lt;/span&gt;  /root/a.sh
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;1.2 文件描述符的复制(duplicate)&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;文件描述符的复制表示复制文件描述符到另一个文件描述符中以作副本文件。使用&quot;&amp;amp;&quot;进行复制。如果不好理解复制的意思，将其理解为&quot;绑定&quot;、&quot;重用&quot;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[n]&amp;lt;&amp;amp;&lt;span&gt;word ：将文件描述符n绑定到word 代表的文件或描述符。可以理解为文件描述符n重用word代表的文件或描述符。n不指定则默认为0(标准输入就是0)，表示标准输入也将输入到word所代表的文件或描述符中。

[n]&lt;/span&gt;&amp;gt;&amp;amp;word ：将文件描述符n绑定到word 代表的文件或描述符。可以理解为文件描述符n重用word代表的文件或描述符。n不指定则默认为1(标准输出就是1)，表示标准输出也将输出到word所代表的文件或描述符中。
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;注意，&lt;span&gt;&lt;strong&gt;每绑定一次，都会立刻重定向到对应的文件&lt;/strong&gt;&lt;/span&gt;。请结合下面的例子感受。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;例如， &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;3&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt; 表示fd=3绑定到fd=1上，而fd=1目前的重定向目标文件是/dev/stdout，因此fd=3也重定向到/dev/stdout，以后进程将数据写入fd=3的时候，将直接输出到屏幕。如果用&quot;复制&quot;来理解，就是fd=3是当前fd=1的一个副本，即指向/dev/stdout设备。如果后面改变了fd=1的输出目标(如file1)，由于fd=3的目标仍然是/dev/stdout，所以可以拿fd=3来还原fd=1使其目标变回/dev/stdout。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;再例如， &lt;span class=&quot;cnblogs_code&quot;&gt;cat &amp;lt;&amp;amp;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt; 表示fd=0绑定到fd=1上，而此时fd=1的重定向文件是/dev/stdout，因此此时/dev/stdout既是标准输入设备，也是标准输出设备，也就是说进程从/dev/stdout(屏幕)接受输入，输入后再直接输出到/dev/stdout。以下是结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@mariadb ~]# cat &amp;lt;&amp;amp;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
q   # 进入交互式，输入数据
q   # 直接输出&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;1.3 重定向顺序很重要：&quot;&amp;gt;file 2&amp;gt;&amp;amp;1&quot;和&quot;2&amp;gt;&amp;amp;1 &amp;gt;file&quot;&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;想必很多人都知道 &lt;span class=&quot;cnblogs_code&quot;&gt;&amp;gt;file &lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt; 的作用，它等价于 &lt;span class=&quot;cnblogs_code&quot;&gt;&amp;amp;&amp;gt;file&lt;/span&gt; ，表示标准输出和标准错误都重定向到file中。那它和 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; &amp;gt;file&lt;/span&gt; 有什么区别呢？&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;首先解释 &lt;span class=&quot;cnblogs_code&quot;&gt;&amp;gt;file &lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt; 。这里分两个过程：先打开file，再将fd=1重定向到file文件上，这样file文件就成了标准输出的输出目标；之后再将fd=2绑定(注意，是绑定不是重定向)到fd=1上，而fd=1此时已经重定向到file文件上，因此fd=2也重定向到file上。所以，最终的结果是标准输出重定向到file上，标准错误也重定向到file上。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;再解释 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; &amp;gt;file&lt;/span&gt; 。这里也分两个过程：先将fd=2绑定到fd=1上，而此时fd=1重定向的文件是默认的/dev/stdout，所以fd=2也重定向到/dev/stdout；之后再将fd=1重定向到file文件上(注意，不是绑定是重定向)。也就是说，这里的标准错误和标准输出仍然是分开输出的，只不过是使用/dev/stdout替代了/dev/stderr，使用file替代了/dev/stdout。所以，最终的结果是标准错误输出到/dev/stdout，即屏幕上，而标准输出将输出到file文件中。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;可以使用下面的命令来测试 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; &amp;gt;file&lt;/span&gt; 。第一个ls命令是正确的，结果输出到/tmp/a.log中，第二个ls命令是错误的，结果将直接输出到屏幕上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@mariadb ~]# ls /boot &lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; &amp;gt;/tmp/&lt;span&gt;a.log
[root@mariadb &lt;/span&gt;~]# ls sjdfk &lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; &amp;gt;/tmp/&lt;span&gt;a.log
ls: cannot access sjdfk: No such file or directory&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;最后，也许你已经发现了，&lt;span&gt;&lt;strong&gt;绑定和重定向是不同的，绑定不应该称为重定向&lt;/strong&gt;。&lt;/span&gt;区分这两个概念，在实际应用的过程中能解决非常多的疑惑。在本文结尾的最后一个例子中，你将能非常明确地体会到绑定和重定向的区别。&lt;/p&gt;

&lt;h2&gt;1.4 改变当前shell环境的重定向目标&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;如果在命令中直接改变重定向的位置，那么命令执行结束的时候描述符会自动还原。正如上面的 &lt;span class=&quot;cnblogs_code&quot;&gt;ls /boot &lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; &amp;gt;/tmp/a.log&lt;/span&gt; 命令，在ls执行结束后，fd=2还原回默认的/dev/stderr，fd=1还原回默认的/dev/stdout。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;但是我们可以通过exec程序直接在当前的shell环境下改变重定向目标，只有在当前shell退出的时候才会释放描述符的绑定。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;例如：下面的命令将标准错误fd=2重定向到fd=3对应的文件上。&lt;/p&gt;

&lt;p class=&quot;01&quot;&gt;因此，我们可能在一段程序执行结束后，需要将描述符还原到原来的位置，并关闭不再需要的描述符。毕竟描述符也是资源，是有限的(ulimit -n)。&lt;/p&gt;

&lt;h2&gt;1.5 关闭文件描述符&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
[n]&amp;gt;&amp;amp;-&lt;span&gt;
[n]&lt;/span&gt;&amp;lt;&amp;amp;-
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;关闭文件描述符的方式是将 &lt;span class=&quot;cnblogs_code&quot;&gt;[n]&amp;gt;&amp;amp;word&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;[n]&amp;lt;&amp;amp;word&lt;/span&gt; 中的word使用符号&quot;-&quot;，这表示释放fd=n描述符，且关闭其指向的文件。&lt;/p&gt;

&lt;h2&gt;1.6 打开文件&lt;/h2&gt;
&lt;p class=&quot;03&quot;&gt;&lt;strong&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;[n]&amp;lt;&amp;gt; filename&lt;/span&gt; ：&lt;/strong&gt;打开filename，并指定其文件描述符为n，该描述符是可读、可写的描述符。若不指定n则默认为0，若filename文件不存在，则先创建filename文件。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@mariadb ~]# exec &lt;span&gt;3&lt;/span&gt;&amp;lt;&amp;gt; /tmp/&lt;span&gt;a.log
[root@mariadb &lt;/span&gt;~]# lsof -n | grep &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/a.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | column -&lt;span&gt;t 
bash  &lt;/span&gt;&lt;span&gt;13637&lt;/span&gt;  root  &lt;span&gt;3u&lt;/span&gt;  REG  &lt;span&gt;8&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;292018&lt;/span&gt;  &lt;span&gt;69632965&lt;/span&gt;  /tmp/a.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;如果再 &lt;span class=&quot;cnblogs_code&quot;&gt;exec &lt;span&gt;1&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt; 将fd=0绑定到fd=3上，那么/tmp/a.log就成了标准输入的来源。&lt;/p&gt;

&lt;h2&gt;1.7 文件描述符的移动&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;文件描述符的移动表示将文件描述符1移动到描述符2上，同时关闭文件描述符1。&lt;/p&gt;
&lt;p class=&quot;03&quot;&gt;&lt;strong&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;[n]&amp;gt;&amp;amp;digit-&lt;/span&gt; ：&lt;/strong&gt;将文件描述符digit代表的输出文件移动到n上，并关闭digit值的描述符。&lt;/p&gt;
&lt;p class=&quot;03&quot;&gt;&lt;strong&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;[n]&amp;lt;&amp;amp;digit-&lt;/span&gt; ：&lt;/strong&gt;将文件描述符digit代表的输入文件移动到n上，并关闭digit值的描述符。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@mariadb ~]# exec &lt;span&gt;3&lt;/span&gt;&amp;lt;&amp;gt; /tmp/&lt;span&gt;a.log
[root@mariadb &lt;/span&gt;~]# lsof -n | grep &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/a.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | column -&lt;span&gt;t 
bash  &lt;/span&gt;&lt;span&gt;13637&lt;/span&gt;  root  &lt;span&gt;3u&lt;/span&gt;  REG  &lt;span&gt;8&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;292018&lt;/span&gt;  &lt;span&gt;69632965&lt;/span&gt;  /tmp/&lt;span&gt;a.log
[root@mariadb &lt;/span&gt;~]# exec &lt;span&gt;1&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;3&lt;/span&gt;-&lt;span&gt;  # 将3移动到1上，关闭3
[root@mariadb &lt;/span&gt;~]# lsof -n | grep &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/a.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | column -&lt;span&gt;t   # 在另一个bash窗口查看
bash  &lt;/span&gt;&lt;span&gt;13637&lt;/span&gt;  root  &lt;span&gt;1u&lt;/span&gt;  REG  &lt;span&gt;8&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;292018&lt;/span&gt;  &lt;span&gt;69632965&lt;/span&gt;  /tmp/a.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可见，fd=3移动到fd=1后，原本与fd=3关联的/tmp/a.log已经关联到fd=1上。&lt;/p&gt;

&lt;h2&gt;1.8 经典示例&lt;/h2&gt;
&lt;p class=&quot;10&quot;&gt;(1). 示例一：&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;以下是《Advanced Bash-Scripting Guide》中的示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
echo &lt;span&gt;1234567890&lt;/span&gt; &amp;gt; File # (&lt;span&gt;1&lt;/span&gt;).写字符串到&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.
exec &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&amp;lt;&amp;gt; File          # (&lt;span&gt;2&lt;/span&gt;).打开&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;并且给它分配fd &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.
read &lt;/span&gt;-n &lt;span&gt;4&lt;/span&gt; &amp;lt;&amp;amp;&lt;span&gt;3&lt;/span&gt;          # (&lt;span&gt;3&lt;/span&gt;&lt;span&gt;).只读4 个字符.
echo &lt;/span&gt;-n . &amp;gt;&amp;amp;&lt;span&gt;3&lt;/span&gt;          # (&lt;span&gt;4&lt;/span&gt;&lt;span&gt;).写一个小数点.
exec &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&amp;gt;&amp;amp;-              # (&lt;span&gt;5&lt;/span&gt;).关闭fd &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.
cat File               # (&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;).&lt;span&gt;1234.67890&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;(1)向文件File中写入几个字符。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(2)打开文件File以备read/write，并分配fd=3给该文件。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(3)将fd=0绑定到fd=3上，而fd=3的重定向目标为File，所以fd=0的目标也是File，即从File中读取数据。这里读取4个字符，由于read命令中没有指定变量，因此分配给默认变量REPLY。注意，这个命令执行结束后，fd=0的重定向目标会变回/dev/stdin。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(4)将fd=1绑定到fd=3上，而fd=3的重定向目标文件为File，所以fd=1的目标也是File，即数据写入到File中。这里写入一个小数点。注意，这个命令结束后，fd=1的重定向目标回变回/dev/stdout。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(5)关闭fd=3，这也会关闭其指向的文件File。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(6)File文件中已经写入了一个小数点。如果此时执行 &lt;span class=&quot;cnblogs_code&quot;&gt;echo $REPLY&lt;/span&gt; ，将输出&quot;1234&quot;。&lt;/p&gt;
&lt;p class=&quot;10&quot;&gt;&lt;strong&gt;(2). 示例二：关于描述符恢复、关闭&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
exec &lt;span&gt;6&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt;                   # (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
exec &lt;/span&gt;&amp;gt; /tmp/file.txt        # (&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;      # (&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
exec &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&amp;gt;&amp;amp;-              # (&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===============&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;      # (&lt;span&gt;5&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;(1)首先将fd=6绑定到fd=1，此时fd=1的重定向目标为/dev/stdout，因此fd=6的重定向目标为/dev/stdout。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(2)将fd=1重定向到/tmp/file.txt文件。此后所有标准输出都将写入到/tmp/file.txt中。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(3)写入数据。该数据将写入到/tmp/file.txt中。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(4)将fd=1绑定回fd=6，此时fd=6的重定向目标为/dev/stdout，因此fd=1将恢复到/dev/stdout上。最后将fd=6关闭。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(5)写入数据，这段数据将输出在屏幕上。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;可能你会疑惑，为什么要先将fd=1绑定到fd=6上，再用fd=6来恢复fd=1，恢复的时候直接将fd=1重定向回/dev/stdout不就可以了吗？&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;实际上，这里借用fd=6这个中转描述符是为了方便操作。你可以不它，但是再恢复fd=1的重定向目标的时候，应该重定向到/dev/{伪终端字符设备}上，而不是/dev/stdout，因为/dev/stdout是软链接，其目标指向/proc/self/fd/1，但该文件还是软链接，它指向/dev/{伪终端字符设备}。同理/dev/stdin和/dev/stderr都一样。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;因此，如果你当前所在的终端如果是pts/2，那么可以使用下面的命令来实现上面同样的功能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
exec &amp;gt; /tmp/&lt;span&gt;file.txt
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
exec &lt;/span&gt;&amp;gt;/dev/pts/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===============&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;如果不借用fd=6这个中转描述符，你要先去获取并记住当前shell所在的终端，很不方便。而且，如果要恢复的不是fd={0,1,2}，那就更麻烦。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;最后给张描述符复制、恢复的过程实例图：&lt;/p&gt;
&lt;p class=&quot;a0&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201804/733013-20180406121920101-752401821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8727401.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8727401.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Apr 2018 04:37:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8727401.html</dc:identifier>
</item>
<item>
<title>RocketMQ(二)：RPC通讯 - 匠心零度</title>
<link>http://www.cnblogs.com/lirenzuo/p/8727320.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lirenzuo/p/8727320.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;匠心零度 转载请注明原创出处，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;rocketmq网络部署图&quot;&gt;RocketMQ网络部署图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b17f1d670?w=1047&amp;amp;h=635&amp;amp;f=png&amp;amp;s=160332&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NameServer：在系统中是做命名服务，更新和发现 broker服务。&lt;/li&gt;
&lt;li&gt;Broker-Master：broker 消息主机服务器。&lt;/li&gt;
&lt;li&gt;Broker-Slave： broker 消息从机服务器。&lt;/li&gt;
&lt;li&gt;Producer： 消息生产者。&lt;/li&gt;
&lt;li&gt;Consumer： 消息消费者。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;rocketmq的几个核心的模块，而对于每个模块都是单独的jvm进程，我们看到上面的架构图的时候，那些箭头就是rocketmq的rpc调用，下面我们来看看rocketmq的rpc是如果进行封装实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; rocketmq系列都将会以rocketmq-4.1.0-incubating进行介绍。&lt;/p&gt;
&lt;h3 id=&quot;rocketmq通信组件&quot;&gt;RocketMQ通信组件&lt;/h3&gt;
&lt;p&gt;先排除Master、Slave直接通过原生的nio进行调用，其他通讯都是基于netty-all-4.0.36.Final以及RocketMQ自定义协议进行通讯的。&lt;/p&gt;
&lt;h4 id=&quot;网络协议定义如下&quot;&gt;网络协议定义如下&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b186b5d47?w=922&amp;amp;h=371&amp;amp;f=png&amp;amp;s=18236&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来看看header data里面的数据定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b193706c0?w=882&amp;amp;h=711&amp;amp;f=png&amp;amp;s=143462&quot;/&gt;&lt;/p&gt;
&lt;p&gt;code对于Request来说就是RequestCode类里面的常量信息：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;说明：公众号【匠心零度】回复：rocketmq，可获得基于rocketmq4.1.0加详细中文代码注释 。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RequestCode {
    &lt;span class=&quot;co&quot;&gt;// Broker 发送消息&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SEND_MESSAGE = &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 订阅消息&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; PULL_MESSAGE = &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 查询消息&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; QUERY_MESSAGE = &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 查询Broker Offset&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; QUERY_BROKER_OFFSET = &lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 查询Consumer Offset&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; QUERY_CONSUMER_OFFSET = &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 更新Consumer Offset&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; UPDATE_CONSUMER_OFFSET = &lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 更新或者增加一个Topic&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; UPDATE_AND_CREATE_TOPIC = &lt;span class=&quot;dv&quot;&gt;17&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 获取所有Topic的配置（Slave和Namesrv都会向Master请求此配置）&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_ALL_TOPIC_CONFIG = &lt;span class=&quot;dv&quot;&gt;21&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 获取所有Topic配置（Slave和Namesrv都会向Master请求此配置&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_TOPIC_CONFIG_LIST = &lt;span class=&quot;dv&quot;&gt;22&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 获取所有Topic名称列表&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_TOPIC_NAME_LIST = &lt;span class=&quot;dv&quot;&gt;23&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 更新Broker上的配置&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; UPDATE_BROKER_CONFIG = &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 获取Broker上的配置&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_BROKER_CONFIG = &lt;span class=&quot;dv&quot;&gt;26&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 触发Broker删除文件&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; TRIGGER_DELETE_FILES = &lt;span class=&quot;dv&quot;&gt;27&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 获取Broker运行时信息&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_BROKER_RUNTIME_INFO = &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 根据时间查询队列的Offset&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SEARCH_OFFSET_BY_TIMESTAMP = &lt;span class=&quot;dv&quot;&gt;29&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 查询队列最大Offset&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_MAX_OFFSET = &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 查询队列最小Offset&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_MIN_OFFSET = &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 查询队列最早消息对应时间&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_EARLIEST_MSG_STORETIME = &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 根据消息ID来查询消息&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; VIEW_MESSAGE_BY_ID = &lt;span class=&quot;dv&quot;&gt;33&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker Client向Client发送心跳，并注册自身&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; HEART_BEAT = &lt;span class=&quot;dv&quot;&gt;34&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker Client注销&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; UNREGISTER_CLIENT = &lt;span class=&quot;dv&quot;&gt;35&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker Consumer将处理不了的消息发回服务器&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CONSUMER_SEND_MSG_BACK = &lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker Commit或者Rollback事务&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; END_TRANSACTION = &lt;span class=&quot;dv&quot;&gt;37&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 获取ConsumerId列表通过GroupName&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_CONSUMER_LIST_BY_GROUP = &lt;span class=&quot;dv&quot;&gt;38&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 主动向Producer回查事务状态&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CHECK_TRANSACTION_STATE = &lt;span class=&quot;dv&quot;&gt;39&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker Broker通知Consumer列表变化&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; NOTIFY_CONSUMER_IDS_CHANGED = &lt;span class=&quot;dv&quot;&gt;40&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker Consumer向Master锁定队列&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; LOCK_BATCH_MQ = &lt;span class=&quot;dv&quot;&gt;41&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker Consumer向Master解锁队列&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; UNLOCK_BATCH_MQ = &lt;span class=&quot;dv&quot;&gt;42&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 获取所有Consumer Offset&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_ALL_CONSUMER_OFFSET = &lt;span class=&quot;dv&quot;&gt;43&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 获取所有定时进度&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_ALL_DELAY_OFFSET = &lt;span class=&quot;dv&quot;&gt;45&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CHECK_CLIENT_CONFIG = &lt;span class=&quot;dv&quot;&gt;46&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Namesrv 向Namesrv追加KV配置&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; PUT_KV_CONFIG = &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Namesrv 从Namesrv获取KV配置&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_KV_CONFIG = &lt;span class=&quot;dv&quot;&gt;101&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Namesrv 从Namesrv获取KV配置&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; DELETE_KV_CONFIG = &lt;span class=&quot;dv&quot;&gt;102&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Namesrv 注册一个Broker，数据都是持久化的，如果存在则覆盖配置&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; REGISTER_BROKER = &lt;span class=&quot;dv&quot;&gt;103&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Namesrv 卸载一个Broker，数据都是持久化的&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; UNREGISTER_BROKER = &lt;span class=&quot;dv&quot;&gt;104&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Namesrv 根据Topic获取Broker Name、队列数(包含读队列与写队列)&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_ROUTEINTO_BY_TOPIC = &lt;span class=&quot;dv&quot;&gt;105&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Namesrv 获取注册到Name Server的所有Broker集群信息&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_BROKER_CLUSTER_INFO = &lt;span class=&quot;dv&quot;&gt;106&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; UPDATE_AND_CREATE_SUBSCRIPTIONGROUP = &lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_ALL_SUBSCRIPTIONGROUP_CONFIG = &lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_TOPIC_STATS_INFO = &lt;span class=&quot;dv&quot;&gt;202&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_CONSUMER_CONNECTION_LIST = &lt;span class=&quot;dv&quot;&gt;203&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_PRODUCER_CONNECTION_LIST = &lt;span class=&quot;dv&quot;&gt;204&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; WIPE_WRITE_PERM_OF_BROKER = &lt;span class=&quot;dv&quot;&gt;205&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 从Name Server获取完整Topic列表&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_ALL_TOPIC_LIST_FROM_NAMESERVER = &lt;span class=&quot;dv&quot;&gt;206&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 从Broker删除订阅组&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; DELETE_SUBSCRIPTIONGROUP = &lt;span class=&quot;dv&quot;&gt;207&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 从Broker获取消费状态（进度）&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_CONSUME_STATS = &lt;span class=&quot;dv&quot;&gt;208&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Suspend Consumer消费过程&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SUSPEND_CONSUMER = &lt;span class=&quot;dv&quot;&gt;209&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Resume Consumer消费过程&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; RESUME_CONSUMER = &lt;span class=&quot;dv&quot;&gt;210&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 重置Consumer Offset&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; RESET_CONSUMER_OFFSET_IN_CONSUMER = &lt;span class=&quot;dv&quot;&gt;211&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 重置Consumer Offset&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; RESET_CONSUMER_OFFSET_IN_BROKER = &lt;span class=&quot;dv&quot;&gt;212&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 调整Consumer线程池数量&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ADJUST_CONSUMER_THREAD_POOL = &lt;span class=&quot;dv&quot;&gt;213&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 查询消息被哪些消费组消费&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; WHO_CONSUME_THE_MESSAGE = &lt;span class=&quot;dv&quot;&gt;214&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 从Broker删除Topic配置&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; DELETE_TOPIC_IN_BROKER = &lt;span class=&quot;dv&quot;&gt;215&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 从Namesrv删除Topic配置&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; DELETE_TOPIC_IN_NAMESRV = &lt;span class=&quot;dv&quot;&gt;216&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 通过NameSpace获取所有的KV List&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_KVLIST_BY_NAMESPACE = &lt;span class=&quot;dv&quot;&gt;219&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// offset 重置&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; RESET_CONSUMER_CLIENT_OFFSET = &lt;span class=&quot;dv&quot;&gt;220&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 客户端订阅消息&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_CONSUMER_STATUS_FROM_CLIENT = &lt;span class=&quot;dv&quot;&gt;221&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 通知 broker 调用 offset 重置处理&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; INVOKE_BROKER_TO_RESET_OFFSET = &lt;span class=&quot;dv&quot;&gt;222&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 通知 broker 调用客户端订阅消息处理&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; INVOKE_BROKER_TO_GET_CONSUMER_STATUS = &lt;span class=&quot;dv&quot;&gt;223&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 查询topic被谁消费&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; QUERY_TOPIC_CONSUME_BY_WHO = &lt;span class=&quot;dv&quot;&gt;300&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 获取指定集群下的所有 topic&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_TOPICS_BY_CLUSTER = &lt;span class=&quot;dv&quot;&gt;224&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 向Broker注册Filter Server&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; REGISTER_FILTER_SERVER = &lt;span class=&quot;dv&quot;&gt;301&lt;/span&gt;;
   &lt;span class=&quot;co&quot;&gt;// 向Filter Server注册Class&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; REGISTER_MESSAGE_FILTER_CLASS = &lt;span class=&quot;dv&quot;&gt;302&lt;/span&gt;;
   &lt;span class=&quot;co&quot;&gt;// 根据 topic 和 group 获取消息的时间跨度&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; QUERY_CONSUME_TIME_SPAN = &lt;span class=&quot;dv&quot;&gt;303&lt;/span&gt;;
   &lt;span class=&quot;co&quot;&gt;// 获取所有系统内置 Topic 列表&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_SYSTEM_TOPIC_LIST_FROM_NS = &lt;span class=&quot;dv&quot;&gt;304&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_SYSTEM_TOPIC_LIST_FROM_BROKER = &lt;span class=&quot;dv&quot;&gt;305&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 清理失效队列&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CLEAN_EXPIRED_CONSUMEQUEUE = &lt;span class=&quot;dv&quot;&gt;306&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 通过Broker查询Consumer内存数据&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_CONSUMER_RUNNING_INFO = &lt;span class=&quot;dv&quot;&gt;307&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 查找被修正 offset (转发组件）&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; QUERY_CORRECTION_OFFSET = &lt;span class=&quot;dv&quot;&gt;308&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 通过Broker直接向某个Consumer发送一条消息，并立刻消费，返回结果给broker，再返回给调用方&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CONSUME_MESSAGE_DIRECTLY = &lt;span class=&quot;dv&quot;&gt;309&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Broker 发送消息，优化网络数据包&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SEND_MESSAGE_V2 = &lt;span class=&quot;dv&quot;&gt;310&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 单元化相关 topic&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_UNIT_TOPIC_LIST = &lt;span class=&quot;dv&quot;&gt;311&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 获取含有单元化订阅组的 Topic 列表&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_HAS_UNIT_SUB_TOPIC_LIST = &lt;span class=&quot;dv&quot;&gt;312&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 获取含有单元化订阅组的非单元化 Topic 列表&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_HAS_UNIT_SUB_UNUNIT_TOPIC_LIST = &lt;span class=&quot;dv&quot;&gt;313&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 克隆某一个组的消费进度到新的组&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CLONE_GROUP_OFFSET = &lt;span class=&quot;dv&quot;&gt;314&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 查看Broker上的各种统计信息&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; VIEW_BROKER_STATS_DATA = &lt;span class=&quot;dv&quot;&gt;315&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CLEAN_UNUSED_TOPIC = &lt;span class=&quot;dv&quot;&gt;316&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_BROKER_CONSUME_STATS = &lt;span class=&quot;dv&quot;&gt;317&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * update the config of name server&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; UPDATE_NAMESRV_CONFIG = &lt;span class=&quot;dv&quot;&gt;318&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * get config from name server&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; GET_NAMESRV_CONFIG = &lt;span class=&quot;dv&quot;&gt;319&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SEND_BATCH_MESSAGE = &lt;span class=&quot;dv&quot;&gt;320&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; QUERY_CONSUME_QUEUE = &lt;span class=&quot;dv&quot;&gt;321&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;code对于Response来说就是ResponseCode类里面的常量信息：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ResponseCode &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; RemotingSysResponseCode {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; FLUSH_DISK_TIMEOUT = &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SLAVE_NOT_AVAILABLE = &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; FLUSH_SLAVE_TIMEOUT = &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; MESSAGE_ILLEGAL = &lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SERVICE_NOT_AVAILABLE = &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; VERSION_NOT_SUPPORTED = &lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; NO_PERMISSION = &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; TOPIC_NOT_EXIST = &lt;span class=&quot;dv&quot;&gt;17&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; TOPIC_EXIST_ALREADY = &lt;span class=&quot;dv&quot;&gt;18&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; PULL_NOT_FOUND = &lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; PULL_RETRY_IMMEDIATELY = &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; PULL_OFFSET_MOVED = &lt;span class=&quot;dv&quot;&gt;21&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; QUERY_NOT_FOUND = &lt;span class=&quot;dv&quot;&gt;22&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SUBSCRIPTION_PARSE_FAILED = &lt;span class=&quot;dv&quot;&gt;23&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SUBSCRIPTION_NOT_EXIST = &lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SUBSCRIPTION_NOT_LATEST = &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SUBSCRIPTION_GROUP_NOT_EXIST = &lt;span class=&quot;dv&quot;&gt;26&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; FILTER_DATA_NOT_EXIST = &lt;span class=&quot;dv&quot;&gt;27&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; FILTER_DATA_NOT_LATEST = &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; TRANSACTION_SHOULD_COMMIT = &lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; TRANSACTION_SHOULD_ROLLBACK = &lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; TRANSACTION_STATE_UNKNOW = &lt;span class=&quot;dv&quot;&gt;202&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; TRANSACTION_STATE_GROUP_WRONG = &lt;span class=&quot;dv&quot;&gt;203&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; NO_BUYER_ID = &lt;span class=&quot;dv&quot;&gt;204&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; NOT_IN_CURRENT_UNIT = &lt;span class=&quot;dv&quot;&gt;205&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CONSUMER_NOT_ONLINE = &lt;span class=&quot;dv&quot;&gt;206&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CONSUME_MSG_TIMEOUT = &lt;span class=&quot;dv&quot;&gt;207&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; NO_MESSAGE = &lt;span class=&quot;dv&quot;&gt;208&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;flag&lt;/strong&gt;字段进行说明，其他后续分析到具体的具体分析。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;flag = 0表示是request，flag = 1表示是response。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; RPC_TYPE = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// 0, REQUEST_COMMAND&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; RemotingCommandType &lt;span class=&quot;fu&quot;&gt;getType&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;isResponseType&lt;/span&gt;()) {&lt;span class=&quot;co&quot;&gt;//flag=1为true&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; RemotingCommandType.&lt;span class=&quot;fu&quot;&gt;RESPONSE_COMMAND&lt;/span&gt;;
        }

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; RemotingCommandType.&lt;span class=&quot;fu&quot;&gt;REQUEST_COMMAND&lt;/span&gt;;
    }


    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isResponseType&lt;/span&gt;() {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; bits = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; RPC_TYPE;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;flag&lt;/span&gt; &amp;amp; bits) == bits;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;flag为2、3（二进制表示10、11）为oneway请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; RPC_ONEWAY = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// Oneway bit&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;markOnewayRPC&lt;/span&gt;() {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; bits = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; RPC_ONEWAY;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;flag&lt;/span&gt; |= bits;
    }


    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isOnewayRPC&lt;/span&gt;() {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; bits = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; RPC_ONEWAY;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;flag&lt;/span&gt; &amp;amp; bits) == bits;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b194ad50a?w=1088&amp;amp;h=579&amp;amp;f=png&amp;amp;s=64119&quot;/&gt;&lt;/p&gt;
&lt;p&gt;code=310很快我们就明白什么意思了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b19812984?w=559&amp;amp;h=72&amp;amp;f=png&amp;amp;s=12757&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于下面类似a、b、c等可以简单查看下类SendMessageRequestHeaderV2（后续继续讲解）基本就是类似js压缩效果，可以借鉴学习下。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; SendMessageRequestHeaderV2 &lt;span class=&quot;fu&quot;&gt;createSendMessageRequestHeaderV2&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; SendMessageRequestHeader v1) {
        SendMessageRequestHeaderV2 v2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SendMessageRequestHeaderV2&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * 进行转换，这样网络传输数据就比较小了，学习下&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         */&lt;/span&gt;
        v2.&lt;span class=&quot;fu&quot;&gt;a&lt;/span&gt; = v1.&lt;span class=&quot;fu&quot;&gt;getProducerGroup&lt;/span&gt;();
        v2.&lt;span class=&quot;fu&quot;&gt;b&lt;/span&gt; = v1.&lt;span class=&quot;fu&quot;&gt;getTopic&lt;/span&gt;();
        v2.&lt;span class=&quot;fu&quot;&gt;c&lt;/span&gt; = v1.&lt;span class=&quot;fu&quot;&gt;getDefaultTopic&lt;/span&gt;();
        v2.&lt;span class=&quot;fu&quot;&gt;d&lt;/span&gt; = v1.&lt;span class=&quot;fu&quot;&gt;getDefaultTopicQueueNums&lt;/span&gt;();
        v2.&lt;span class=&quot;fu&quot;&gt;e&lt;/span&gt; = v1.&lt;span class=&quot;fu&quot;&gt;getQueueId&lt;/span&gt;();
        v2.&lt;span class=&quot;fu&quot;&gt;f&lt;/span&gt; = v1.&lt;span class=&quot;fu&quot;&gt;getSysFlag&lt;/span&gt;();
        v2.&lt;span class=&quot;fu&quot;&gt;g&lt;/span&gt; = v1.&lt;span class=&quot;fu&quot;&gt;getBornTimestamp&lt;/span&gt;();
        v2.&lt;span class=&quot;fu&quot;&gt;h&lt;/span&gt; = v1.&lt;span class=&quot;fu&quot;&gt;getFlag&lt;/span&gt;();
        v2.&lt;span class=&quot;fu&quot;&gt;i&lt;/span&gt; = v1.&lt;span class=&quot;fu&quot;&gt;getProperties&lt;/span&gt;();
        v2.&lt;span class=&quot;fu&quot;&gt;j&lt;/span&gt; = v1.&lt;span class=&quot;fu&quot;&gt;getReconsumeTimes&lt;/span&gt;();
        v2.&lt;span class=&quot;fu&quot;&gt;k&lt;/span&gt; = v1.&lt;span class=&quot;fu&quot;&gt;isUnitMode&lt;/span&gt;();
        v2.&lt;span class=&quot;fu&quot;&gt;l&lt;/span&gt; = v1.&lt;span class=&quot;fu&quot;&gt;getMaxReconsumeTimes&lt;/span&gt;();
        v2.&lt;span class=&quot;fu&quot;&gt;m&lt;/span&gt; = v1.&lt;span class=&quot;fu&quot;&gt;isBatch&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; v2;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt; &lt;strong&gt;RemotingCommand&lt;/strong&gt;类包含了传输过程中所有数据的封装，还包括了编解码等操作（非常棒！！！解读为什么这样，从面向对象角度，&lt;strong&gt;谁拥有数据谁就对外提供操作这些数据的方法&lt;/strong&gt;，这句话应该是大学的时候学习面向对象的时候看&lt;strong&gt;张孝祥&lt;/strong&gt;老师说的，一直记忆犹新，的确应该这么设计，rocketmq就这么做的，再次学习）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b19ad6b65?w=1014&amp;amp;h=96&amp;amp;f=png&amp;amp;s=19443&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;rocketmq网络协议实现&quot;&gt;RocketMQ网络协议实现&lt;/h3&gt;
&lt;h4 id=&quot;uml类图&quot;&gt;UML类图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b42c4ea00?w=1240&amp;amp;h=389&amp;amp;f=png&amp;amp;s=125318&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的图已经做到非常清晰了，&lt;strong&gt;RemotingClient&lt;/strong&gt;接口定义了client应该具备那些功能，&lt;strong&gt;RemotingSever&lt;/strong&gt;类似，主要有：registerProcessor、invokeSync（同步调用）、invokeAsync（异步调用）、invokeOneway（单向调用）等等，而RemotingClient与RemotingSever在三种调用的区别就是参数有所区别。&lt;/p&gt;
&lt;p&gt;NettyRemotingAbstract是Server与Client公用处理的抽象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BrokerOuterAPI、MQClientImpl&lt;/strong&gt;:都封装了NettyRemotingClient（后续介绍）。&lt;/p&gt;
&lt;p&gt;不管是client还是server通过RemotingService我们明白，启动都是在start里面，我们看看里面核心netty代码，以server里面代码为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b409a73ad?w=1240&amp;amp;h=762&amp;amp;f=png&amp;amp;s=349786&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：此处netty相关内容不进行深入展开，只会把涉及的的简单说明，后续另开系列进行说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;涉及主要channelhandler简单说明&quot;&gt;涉及主要ChannelHandler简单说明&lt;/h4&gt;
&lt;p&gt;在进行tcp传输的时候经常会面临黏包/拆包问题，netty自带了很多通用的TCP黏包/拆包解决方案，下面我们看看rocketmq如何借助netty来实现编解码：&lt;strong&gt;NettyEncoder编码、NettyDecoder解码&lt;/strong&gt;，rocketmq相关的网络协议上面内容已经说明过了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NettyEncoder编码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b4298dfa6?w=849&amp;amp;h=498&amp;amp;f=png&amp;amp;s=59167&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b45108443?w=666&amp;amp;h=803&amp;amp;f=png&amp;amp;s=57551&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b4ad69898?w=604&amp;amp;h=277&amp;amp;f=png&amp;amp;s=27107&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b4be409de?w=1146&amp;amp;h=788&amp;amp;f=png&amp;amp;s=77004&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NettyDecoder解码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;netty中针对这四种场景均有对应的解码器作为解决方案，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过FixedLengthFrameDecoder 定长解码器来解决&lt;strong&gt;定长消息&lt;/strong&gt;的黏包拆包问题。&lt;/li&gt;
&lt;li&gt;通过LineBasedFrameDecoder和StringDecoder来解决以&lt;strong&gt;回车换行符&lt;/strong&gt;作为消息结束符的TCP黏包拆包的问题。&lt;/li&gt;
&lt;li&gt;通过DelimiterBasedFrameDecoder 特殊分隔符解码器来解决以&lt;strong&gt;特殊符号作为消息结束符&lt;/strong&gt;的TCP黏包拆包问题。&lt;/li&gt;
&lt;li&gt;通过LengthFieldBasedFrameDecoder &lt;strong&gt;自定义长度&lt;/strong&gt;解码器解决TCP黏包拆包问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;rocketmq中使用的就是基于&lt;strong&gt;LengthFieldBasedFrameDecoder&lt;/strong&gt;自定义长度解码器的。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b6f6f7fb6?w=931&amp;amp;h=733&amp;amp;f=png&amp;amp;s=82045&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b71622866?w=1099&amp;amp;h=512&amp;amp;f=png&amp;amp;s=72309&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b735e558d?w=949&amp;amp;h=213&amp;amp;f=png&amp;amp;s=28861&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IdleStateHandler：Netty自带的心跳检测。&lt;/p&gt;
&lt;p&gt;NettyConnetManageHandle：主要就是链接管理，新连接、连接断开、异常、Idle等事件，每个事件过来存入NettyEventExecuter的队列里面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b8c200edd?w=805&amp;amp;h=750&amp;amp;f=png&amp;amp;s=88667&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b8cf064c9?w=1028&amp;amp;h=331&amp;amp;f=png&amp;amp;s=44584&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NettyEventExecutor的run方法会不断的从队列里面取事件进行相应的处理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b96c481bd?w=780&amp;amp;h=803&amp;amp;f=png&amp;amp;s=76490&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NettyServerHandler：具体业务处理（后续会说到）。&lt;/p&gt;
&lt;h3 id=&quot;核心nettyremotingabstract介绍&quot;&gt;核心NettyRemotingAbstract介绍&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;invokeSync（同步调用）进行说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066b9fc3cf49?w=1030&amp;amp;h=940&amp;amp;f=png&amp;amp;s=107700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066ba59f8d4c?w=1057&amp;amp;h=465&amp;amp;f=png&amp;amp;s=50219&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066baf74573f?w=875&amp;amp;h=168&amp;amp;f=png&amp;amp;s=12197&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;opaque&lt;/strong&gt;就相当与标识的这个请求，虽然rpc调用请求发送结束了，但是响应回来的时候还是会带有该信息就可以判断出是原来那个请求，比如响应回来之后执行原来给定的回调等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过countDownLatch来控制等待网络通信时间 ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066bb0a4f934?w=769&amp;amp;h=208&amp;amp;f=png&amp;amp;s=29808&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;invokeAsync（异步调用）进行说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066bb21f90d6?w=1122&amp;amp;h=891&amp;amp;f=png&amp;amp;s=125327&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066bc500ada7?w=677&amp;amp;h=528&amp;amp;f=png&amp;amp;s=46742&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与invokeSync（同步调用）基本类似，boolean acquired = this.semaphoreAsync.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS);//控制异步请求的个数以及超时和使用使用布尔原子变量，信号量保证只释放一次，对于异步invokeCallback不为空，需要进行调用。invokeOneway（单向调用）比较简单略过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面看看消息接收处理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066bc75a0641?w=835&amp;amp;h=347&amp;amp;f=png&amp;amp;s=33268&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;这里判断是request还是response都是通过header里面的flag标记来判断的，上面已经说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;processResponseCommand在介绍上面三种发送的时候说过了，下面重点看看&lt;strong&gt;processRequestCommand&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066bcd7d41f1?w=951&amp;amp;h=75&amp;amp;f=png&amp;amp;s=18113&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066bd1b96ec1?w=1056&amp;amp;h=232&amp;amp;f=png&amp;amp;s=27644&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066bd85b8e09?w=1064&amp;amp;h=750&amp;amp;f=png&amp;amp;s=92078&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066bd6b5e317?w=1030&amp;amp;h=497&amp;amp;f=png&amp;amp;s=61056&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;这里需要做流控，要求线程池对应的队列必须是有大小限制的，是通过线程池进行限流的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;友情推荐&quot;&gt;友情推荐&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066becf53156?w=1123&amp;amp;h=851&amp;amp;f=png&amp;amp;s=69608&quot; alt=&quot;iocoder.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.60606060606061&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;&lt;a href=&quot;http://www.iocoder.cn%E9%87%8C%E9%9D%A2%E6%9C%89%E5%BE%88%E5%A4%9A%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E5%88%86%E6%9E%90%EF%BC%8C%E9%9D%9E%E5%B8%B8%E4%B8%8D%E9%94%99%EF%BC%8C%E6%8E%A8%E8%8D%90%E7%BB%99%E5%A4%A7%E5%AE%B6&quot; class=&quot;uri&quot;&gt;http://www.iocoder.cn里面有很多源码系列分析，非常不错，推荐给大家&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考:&lt;/h3&gt;
&lt;p&gt;RocketMQ原理介绍V3.1.1&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/a0a51fd79f62&quot;&gt;netty源码分析之LengthFieldBasedFrameDecoder&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;如果读完觉得有收获的话，欢迎点赞、关注、加公众号【匠心零度】，查阅更多精彩历史！！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加入知识星球，一起探讨！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/4/1629066bef3a4359?w=640&amp;amp;h=290&amp;amp;f=jpeg&amp;amp;s=15090&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Apr 2018 04:00:00 +0000</pubDate>
<dc:creator>匠心零度</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lirenzuo/p/8727320.html</dc:identifier>
</item>
<item>
<title>后缀数组小结 - zjp_shadow</title>
<link>http://www.cnblogs.com/zjp-shadow/p/8727237.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjp-shadow/p/8727237.html</guid>
<description>[unable to retrieve full-text content]前言 ：Orz ShichengXiao 冬令营的时候就早解决了 字符串算法还是不能随意放弃啊 要认真学了！！ 这个算法常用于解决字符串上的 $\mathrm{LCP}$ 问题 和 一些字符串匹配的问题 这个算法思维难度不是很大 但是代码难度还是有一些的 想学好这个算法 一定要牢牢的记住各个数组的含</description>
<pubDate>Fri, 06 Apr 2018 03:33:00 +0000</pubDate>
<dc:creator>zjp_shadow</dc:creator>
<dc:identifier>http://www.cnblogs.com/zjp-shadow/p/8727237.html</dc:identifier>
</item>
</channel>
</rss>