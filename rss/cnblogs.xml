<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>012 继承和聚合的区别 - nnngu</title>
<link>http://www.cnblogs.com/nnngu/p/8344113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnngu/p/8344113.html</guid>
<description>&lt;p&gt;作者：&lt;a href=&quot;https://github.com/nnngu&quot;&gt;nnngu&lt;/a&gt;&lt;br/&gt;GitHub：&lt;a href=&quot;https://github.com/nnngu&quot; class=&quot;uri&quot;&gt;https://github.com/nnngu&lt;/a&gt;&lt;br/&gt;博客园：&lt;a href=&quot;http://www.cnblogs.com/nnngu/&quot;&gt;http://www.cnblogs.com/nnngu&lt;/a&gt;&lt;br/&gt;简书：&lt;a href=&quot;https://www.jianshu.com/users/1df20d76ea5c&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/users/1df20d76ea5c&lt;/a&gt;&lt;br/&gt;知乎：&lt;a href=&quot;https://www.zhihu.com/people/nnngu/posts&quot; class=&quot;uri&quot;&gt;https://www.zhihu.com/people/nnngu/posts&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;继承&quot;&gt;继承&lt;/h2&gt;
&lt;p&gt;指的是一个类继承另外的一个类的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/24/1516808461696.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;聚合&quot;&gt;聚合&lt;/h2&gt;
&lt;p&gt;聚合体现的是整体与部分、拥有的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期；比如计算机与CPU、公司与员工的关系等；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/24/1516808836569.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 15:51:00 +0000</pubDate>
<dc:creator>nnngu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnngu/p/8344113.html</dc:identifier>
</item>
<item>
<title>用于 C&amp;sharp; 图像识别的轮廓分析技术 - GPA</title>
<link>http://www.cnblogs.com/academy/p/contour-analysis-for-image-recognition-in-csharp.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/academy/p/contour-analysis-for-image-recognition-in-csharp.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;供稿：Conmajia&lt;/p&gt;
&lt;p&gt;标题：Contour Analysis for Image Recognition in C#&lt;/p&gt;
&lt;p&gt;作者：Pavel Torgashov&lt;/p&gt;
&lt;p&gt;&lt;em&gt;此中文版翻译已获作者本人授权.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Jan. 23rd，2018&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1108150/201801/1108150-20180124231308772-944086904.png&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图 1 本文提供的范例程序截图&lt;/center&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;本文阐述了轮廓分析 (Contour Analysis，以下简称 CA) 的理论基础以及它在图像识别方面的实际应用. 文章末尾提供了一个处理 CA 的库文件和一个范例 (参见图 1).&lt;/p&gt;
&lt;p&gt;文章第一部分给出了 CA 的定义和相关定理. 笔者尝试尽量用精简的语言对 CA 进行概要说明，以使读者能尽快理解 CA 的理论基础并加以应用. 同时，笔者提出了一些自己的思考，试图将文章核心聚焦于 CA 理论的部分方面和算法优化上. 第二部分在此基础上对算法进行了阐述.&lt;/p&gt;
&lt;p&gt;第三部分是对 C♯ 专用库 &lt;code&gt;ContourAnalysis&lt;/code&gt; 的说明.&lt;/p&gt;
&lt;h2 id=&quot;第一部分-轮廓分析基础&quot;&gt;第一部分 轮廓分析基础&lt;/h2&gt;
&lt;h3 id=&quot;为什么需要轮廓分析&quot;&gt;为什么需要轮廓分析&lt;/h3&gt;
&lt;p&gt;CA 允许对物体呈现的外部边界——即轮廓——进行描述、存储、比较和查找. 它假定此轮廓已包含有物体形状的必要信息，而不考虑物体内部的点. 对于图像，CA 将分析从 2 维空间限定到轮廓空间上可降低计算强度及算法的复杂性. 由此，CA 便可高效地解决模式识别的主要问题：图像物体的换位、旋转及重设大小. 对这些变换而言，CA 方法是不变的.&lt;/p&gt;
&lt;h3 id=&quot;主要概念&quot;&gt;主要概念&lt;/h3&gt;
&lt;p&gt;首先，定义物体的轮廓.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;轮廓&lt;/strong&gt;是物体的边界，一组可将物体从背景中分离出来的点 (像素) 的集合.&lt;/p&gt;
&lt;p&gt;在计算机视觉系统中，经常用到多种编码格式来记录轮廓，如 Freeman 编码、2 维编码、多项式编码等. 但在本文讲述的轮廓分析中，不使用上述任何一种编码.&lt;/p&gt;
&lt;p&gt;作为替代，笔者使用一组复数序列对轮廓进行编码. 对某一轮廓而言，假定其上一点为&lt;em&gt;起点&lt;/em&gt;，将该点固定. (顺时针或逆时针地) 遍历轮廓上的点，记录每个点相对于它前一个点偏移量，用复数 &lt;span class=&quot;math inline&quot;&gt;\(a+\mathbf{i}b​\)&lt;/span&gt; 表示&lt;em&gt;偏移向量&lt;/em&gt;，&lt;span class=&quot;math inline&quot;&gt;\(a​\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(x​\)&lt;/span&gt; 轴方向上的偏移量，&lt;span class=&quot;math inline&quot;&gt;\(b​\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(y​\)&lt;/span&gt; 轴方向上的偏移量. 图 2 展示了一个简单的例子.&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1108150/201801/1108150-20180124231251475-281031777.jpg&quot;/&gt;&lt;/center&gt;
&lt;center&gt;图 2 使用复数表示偏移向量&lt;/center&gt;
&lt;p&gt;考虑到 3 维物体的物理实际，它们的轮廓不会内交，并且轮廓的最后一点总是与起点重合. 这保证了上述编码方法可以唯一地表示一个轮廓.&lt;/p&gt;
&lt;p&gt;在这里，定义轮廓上的一个偏移向量为&lt;em&gt;基础向量&lt;/em&gt; (elementary vector)，简称 EV，用小写希腊字母表示；由 EV 所组成的复数序列称为&lt;em&gt;向量轮廓&lt;/em&gt; (vector contour)，简称 VC，用大写希腊字母表示.&lt;/p&gt;
&lt;p&gt;这样，长度为 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 的向量轮廓 &lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt; 可以表示为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \Gamma=(\gamma_0,\gamma_1,\cdots,\gamma_{k-1}) \]&lt;/span&gt;&lt;br/&gt;之所以采用复数编码，是因为对向量进行运算相对于其他直接计算轮廓的编码方式，在不增加额外计算负担和复杂性的基础上，可以保留可观的轮廓数学信息.&lt;/p&gt;
&lt;p&gt;基本上，复数编码非常接近 2 维编码，后者将轮廓定义为一组 2 维空间中的坐标. 然而在处理点积上二者是不同的.&lt;/p&gt;
&lt;h3 id=&quot;轮廓的性质&quot;&gt;轮廓的性质&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;闭合轮廓的所有 EV，其和为零. EV 最终指向起点，它们的和是一个零向量.&lt;/li&gt;
&lt;li&gt;轮廓向量不依赖于源图像的平行换位. 由于轮廓是相对于起点编码的，所以这种编码方式不会因初始轮廓而改变.&lt;/li&gt;
&lt;li&gt;图像旋转相当于对轮廓上所有 EV 旋转同一角度.&lt;/li&gt;
&lt;li&gt;改变起点不会改变 VC. EV 是相对于它之前的一点而编码，显然改变起点后，整个轮廓的 EV 序列除了起点位置外不会有任何改变.&lt;/li&gt;
&lt;li&gt;源图像缩放可认为是对轮廓中每个 EV 与缩放因子的乘积.&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;轮廓的点积&quot;&gt;轮廓的点积&lt;/h3&gt;
&lt;p&gt;考虑轮廓 &lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt; 和轮廓 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 的点积，有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \eta=(\Gamma,N)=\sum_{n=0}^{k-1}(\gamma_n,\upsilon_n) \tag{1} \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 是向量轮廓 VC 的维数；&lt;span class=&quot;math inline&quot;&gt;\(\gamma_n\)&lt;/span&gt; 是轮廓 &lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt; 的第 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个 EV；&lt;span class=&quot;math inline&quot;&gt;\(\upsilon_n\)&lt;/span&gt; 是轮廓 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 的第 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个 EV. 复数点积 &lt;span class=&quot;math inline&quot;&gt;\((\gamma_n,\upsilon_n)\)&lt;/span&gt; 计算方法为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ (a+\mathbf{i}b,c+\mathbf{i}d)=(a+\mathbf{i}b)\cdot(c-\mathbf{i}d)=ac+bd+\mathbf{i}(bc-ad) \tag{2} \]&lt;/span&gt;&lt;br/&gt;需要注意，在 CA 中计算轮廓的点积时，各轮廓维数必须一致，即 EV 的数量应相等.&lt;/p&gt;
&lt;p&gt;将两个 EV 作为简单向量相乘，其点积为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \left((a,b),(c,d)\right)=ac+bd \tag{3} \]&lt;/span&gt;&lt;br/&gt;比较式 &lt;span class=&quot;math inline&quot;&gt;\((2)\)&lt;/span&gt; 和式 &lt;span class=&quot;math inline&quot;&gt;\((3)\)&lt;/span&gt;，可以发现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;向量的点积结果为实数，复数的乘积为复数.&lt;/li&gt;
&lt;li&gt;复数点积的实数部分与对应向量的点积相等.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;根据线性代数知识，向量的点积等于其夹角的余弦. 这意味着两个垂直的向量其点积总是为零，同向的两个向量其点积最大.&lt;/p&gt;
&lt;p&gt;向量乘积的这些性质，使得它可以用来衡量向量之间的接近程度. 乘积值越大，说明向量间夹角越小，即它们&lt;em&gt;越接近&lt;/em&gt;. 互相垂直的向量其乘积为零，随着夹角继续增大，其乘积为负值，直到&lt;em&gt;再次平行时&lt;/em&gt;得到最大值 (绝对值). 式 &lt;span class=&quot;math inline&quot;&gt;\((1)\)&lt;/span&gt; 显然也具有与此相同的性质.&lt;/p&gt;
&lt;p&gt;接下来引入&lt;strong&gt;归一化点积&lt;/strong&gt; (Normalized Scalar Product，NSP) 的概念：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \eta=\frac{(\Gamma,N)}{|\Gamma||N|} \tag{4} \]&lt;/span&gt;&lt;br/&gt;模 &lt;span class=&quot;math inline&quot;&gt;\(|\Gamma|\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(|N|\)&lt;/span&gt; 计算方法为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ |\Gamma|=\left(\sum_{n=0}^{k-1}|\gamma_n|^2\right)^{\frac{1}{2}} \tag{5} \]&lt;/span&gt;&lt;br/&gt;复数空间中的 NSP 亦为复数.&lt;/p&gt;
&lt;p&gt;于是，NSP 归一化的最大可能值为单位向量 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{E}\)&lt;/span&gt; (|&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{E}|=1\)&lt;/span&gt;)，且仅在&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \Gamma=\mu N \tag{6} \]&lt;/span&gt;&lt;br/&gt;时成立. 式中 &lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt; 为任意复数.&lt;/p&gt;
&lt;p&gt;我们知道，两个复数相乘，相当于它们的长度相乘 (缩放)，幅角相加 (旋转). 式 &lt;span class=&quot;math inline&quot;&gt;\((6)\)&lt;/span&gt; 中轮廓 &lt;span class=&quot;math inline&quot;&gt;\(\mu N\)&lt;/span&gt; 即表示轮廓 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 被旋转和缩放 &lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt; 后的结果.&lt;/p&gt;
&lt;p&gt;所以对 NSP 而言，当且仅当轮廓 &lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt; 和轮廓 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 为相同轮廓时——可以按一定系数旋转或缩放——其模达到最大.&lt;/p&gt;
&lt;p&gt;如表 1 所示例子. 假设两个同样的轮廓进行点积运算，可得 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{NSP}=1\)&lt;/span&gt;. 将其中一个旋转 &lt;span class=&quot;math inline&quot;&gt;\(90^\circ\)&lt;/span&gt;，可得 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{NSP}=0+\mathbf{i}\)&lt;/span&gt;. 旋转 &lt;span class=&quot;math inline&quot;&gt;\(180^\circ\)&lt;/span&gt; 则得 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{NSP}=-1\)&lt;/span&gt;. 于是，NSP 的实数部分给出了轮廓夹角的余弦值，而模 &lt;span class=&quot;math inline&quot;&gt;\(|\mathrm{NSP}|\)&lt;/span&gt; 恒等于 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;.&lt;/p&gt;
&lt;center&gt;表 1 轮廓归一化点积的性质&lt;/center&gt;
&lt;center&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1108150/201801/1108150-20180124231226475-1191236655.jpg&quot;/&gt;&lt;/center&gt;
&lt;p&gt;类似的，由式 &lt;span class=&quot;math inline&quot;&gt;\((4)\)&lt;/span&gt; 可知，如果增加某个向量轮廓的缩放因数，仍有 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{NSP}=1\)&lt;/span&gt;.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;结论 1&lt;/strong&gt; NSP 的模不随换位、旋转或缩放而改变.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;故而仅当两个轮廓在旋转方向和缩放大小均相同时，其 NSP 为 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{E}\)&lt;/span&gt;，否则均小于 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{E}\)&lt;/span&gt;. 实际上，NSP 的模与其换位、旋转或缩放等变换均无关. 类似的，如果轮廓处于变化中，则它们的 NSP 必小于 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{E}\)&lt;/span&gt;.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;结论 2&lt;/strong&gt; NSP 的模体现了轮廓之间的接近程度.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;轮廓的相关函数&quot;&gt;轮廓的相关函数&lt;/h3&gt;
&lt;p&gt;上一节，我们确立了 NSP 在轮廓相似性判断中的作用. 然而要使用这一性质，取决于对起点的选取.&lt;/p&gt;
&lt;p&gt;式 &lt;span class=&quot;math inline&quot;&gt;\((6)\)&lt;/span&gt; 仅当轮廓的起点一致时成立. 如果轮廓唯一，但 EV 所参考的起点不同，则其 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{NSP}\ne\mathbf{E}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;下面引入一个新的概念，两个轮廓的&lt;strong&gt;内相关函数&lt;/strong&gt; (intercorrelation function，ICF)：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \tau(m)=(\Gamma,N^{(m)}), \qquad m=0,1,\cdots,k-1 \tag{7} \]&lt;/span&gt;&lt;br/&gt;式中 &lt;span class=&quot;math inline&quot;&gt;\(N^{(m)}\)&lt;/span&gt; 是轮廓 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 循环移位 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 次得到的 EV.&lt;/p&gt;
&lt;p&gt;例如，&lt;span class=&quot;math inline&quot;&gt;\(N=(n_1,n_2,n_3,n_4)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(N^{(1)}=(n_2,n_3,n_4,n_1)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(N^{(2)}=(n_3,n_4,n_1,n_2)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;ICF 揭示了轮廓 &lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt; 和轮廓 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 在移位 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 次时的相似程度. 它是 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 的周期函数，所以我们限制 &lt;span class=&quot;math inline&quot;&gt;\(m\in[0,k-1]\)&lt;/span&gt;. 显然有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \tau_{\mathrm{max}}=\max\left(\frac{\tau(m)}{|\Gamma||N|}\right),\qquad m=0,1,\cdots,k-1 \tag{8} \]&lt;/span&gt;&lt;br/&gt;综上，模 &lt;span class=&quot;math inline&quot;&gt;\(|\tau_{\mathrm{max}}|\)&lt;/span&gt; 表示了两个轮廓的相似度，并当轮廓相同时，&lt;span class=&quot;math inline&quot;&gt;\(|\tau_{\mathrm{max}}|=\mathbf{E}\)&lt;/span&gt;. 夹角 &lt;span class=&quot;math inline&quot;&gt;\(\arg(\tau_{\mathrm{max}})\)&lt;/span&gt; 给出了一个轮廓相对另一个的夹角.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;结论 3&lt;/strong&gt; ICF 模最大值表示了两个轮廓的相似度.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论 4&lt;/strong&gt; ICF 模的最大值不受换位、缩放、旋转或起点移位的影响.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另一个新概念是&lt;strong&gt;自相关函数&lt;/strong&gt; (autocorrelation function，ACF). ACF 实际是 ICF 在 &lt;span class=&quot;math inline&quot;&gt;\(\Gamma=N\)&lt;/span&gt; 时的特例，有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \upsilon(m)=(\Gamma,\Gamma^{(m)}),\qquad m=0,1,\cdots,k-1 \tag{9} \]&lt;/span&gt;&lt;br/&gt;下面考察 ACF 的性质.&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1108150/201801/1108150-20180124231333365-306541320.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;图 3 自相关函数的性质&lt;/center&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ACF 与轮廓起点选取无关. 由式 &lt;span class=&quot;math inline&quot;&gt;\((1)\)&lt;/span&gt; 可知，起点的变化不会导致 &lt;span class=&quot;math inline&quot;&gt;\(\eta\)&lt;/span&gt; 改变，&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ACF 由轮廓 EV 两两相乘得到，在 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 到 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 范围内对称分布，对称点为 &lt;span class=&quot;math inline&quot;&gt;\(k/2\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;令 &lt;span class=&quot;math inline&quot;&gt;\(N=(n_1,n_2,n_3,n_4)\)&lt;/span&gt;，可以写出其对不同 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 的 ACF：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{ACF}(0)=(n_1,n_1)+(n_2,n_2)+(n_3,n_3)+(n_4,n_4)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{ACF}(1)=(n_1,n_2)+(n_2,n_3)+(n_3,n_4)+(n_4,n_1)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{ACF}(2)=(n_1,n_3)+(n_2,n_4)+(n_3,n_1)+(n_4,n_2)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{ACF}(3)=(n_1,n_4)+(n_2,n_1)+(n_3,n_2)+(n_4,n_3)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{ACF}(4)=(n_1,n_1)+(n_2,n_2)+(n_3,n_3)+(n_4,n_4)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可知 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{ACF}(1)=\mathrm{ACF}(3)^*\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(\because |a^*|=|a|\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(\therefore |\mathrm{ACF}(1)|=|\mathrm{ACF}(3)|\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;类似的，&lt;span class=&quot;math inline&quot;&gt;\(|\mathrm{ACF}(0)|=|\mathrm{ACF}(4)|\)&lt;/span&gt;.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由图 4 可以看出，除最后一幅图像外，前 3 幅图像其 ACF——用蓝色表示——均关于 &lt;span class=&quot;math inline&quot;&gt;\(k/2\)&lt;/span&gt; 对称.&lt;/li&gt;
&lt;/ol&gt;&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1108150/201801/1108150-20180124231346959-840354992.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;&lt;br/&gt;图 4 轮廓 ACF 示例&lt;/center&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在某种意义上，可以认为轮廓的 ACF 代表了轮廓的形状特性.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对 ACF 取模无关于其缩放、位置、旋转或是起点的选取.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上即是 CA 的理论部分. 在这一部分，笔者为了引入下一部分模式识别，只介绍了较为重要的相关概念和理论计算.&lt;/p&gt;
&lt;h2 id=&quot;第二部分-轮廓分析的实际应用&quot;&gt;第二部分 轮廓分析的实际应用&lt;/h2&gt;
&lt;h3 id=&quot;通用识别算法&quot;&gt;通用识别算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;(未完待续)&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 15:33:00 +0000</pubDate>
<dc:creator>GPA</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/academy/p/contour-analysis-for-image-recognition-in-csharp.html</dc:identifier>
</item>
<item>
<title>LockSupport理解 - chen_yong</title>
<link>http://www.cnblogs.com/hupu-jr/p/8344009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hupu-jr/p/8344009.html</guid>
<description>&lt;p&gt;一、背景&lt;/p&gt;
&lt;p&gt;在看并发包源码的时候看见过LockSupport,今天恰巧看到LockSupport字眼,于是看下jdk1.7中的源码结构。想着它应该是运用多线程的锁工具的，到底似乎怎么实现的呢？&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二、使用&lt;/p&gt;
&lt;p&gt;于是自己写个demo对比下synchronized&lt;/p&gt;
&lt;p&gt;场景：main线程中创建一个线程A,想让threadA 循环完毕的时候先阻塞，然后再main线程中释放。&lt;/p&gt;
&lt;p&gt;1.控制多线程并发：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Object obj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        generalSync(obj);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        obj.notifyAll();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         System.out.println(&quot;主线程执行完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; generalSync(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object obj) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         Runnable runnable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10000; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;　　　　　　　　　　　　　System.out.println(i);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 System.out.println(&quot;循环完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    obj.wait();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 System.out.println(&quot;线程A执行完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         Thread threadA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(runnable);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        threadA.start();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个最终结果是什么呢情？&lt;strong&gt;会以异常结束：java.lang.IllegalMonitorStateException，&lt;/strong&gt; &lt;strong&gt;产生的原因是Object的wait,notify,notifyAll方法必须在同步块中执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.使用synchronized但主线程接触阻塞在threadA阻塞执行之前&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Object obj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        generalSync(obj);&lt;br/&gt;　　　　　　　// Thread.sleep(1000);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (obj) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            obj.notifyAll();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;主线程执行完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; generalSync(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object obj) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         Runnable runnable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10000; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    System.out.println(i);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 System.out.println(&quot;循环完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (obj) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                        obj.wait();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 System.out.println(&quot;线程A执行完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         Thread threadA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(runnable);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        threadA.start();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面会导致一直阻塞，因为主线程在第3行开启一个threadA后，就往下执行4~7代码，而threadA需要循环所用的时间更久。因此会先调用obj.notifyAll()，然后再obj.wait()导致&lt;strong&gt;调用顺序错误一直阻塞&lt;/strong&gt;。想要达到我们预期的目的，根据threadA时间，可以在第4行添加Thread.sleep(1000)使主线程中的obj.notifyAll()晚于obj.wait()执行。&lt;/p&gt;
&lt;p&gt;3.使用LockSupport来实现同步&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Thread threadA =&lt;span&gt; generalSync();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        LockSupport.unpark(threadA);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         System.out.println(&quot;主线程执行完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Thread generalSync() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Runnable runnable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10000; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    System.out.println(i);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 System.out.println(&quot;循环完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                LockSupport.park();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 System.out.println(&quot;线程A执行完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Thread threadA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(runnable);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        threadA.start();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; threadA;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过LockSupport无需关于阻塞和释放的调用先后问题，仅仅通过park/unpark即可阻塞或释放。&lt;strong&gt;park/unpark模型真正解耦了线程之间的同步，线程之间不再需要一个Object或者其它变量来存储状态，不再需要关心对方的状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;三、阅读源码&lt;/p&gt;
&lt;p&gt;通过类注释介绍，LockSupport是JDK中比较底层的类，&lt;strong&gt;用来创建锁和其他同步工具类的基本线程阻塞原语&lt;/strong&gt;。java锁和同步器框架的核心 AQS: AbstractQueuedSynchronizer，就是通过调用 LockSupport .park()和 LockSupport .unpark()实现线程的阻塞和唤醒 的，下面重点关注着2个方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LockSupport {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; LockSupport() {} &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cannot be instantiated.
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Hotspot implementation via intrinsics API&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Unsafe unsafe =&lt;span&gt; Unsafe.getUnsafe();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; parkBlockerOffset;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.根据上面的类定义，内部构造方法私有化，外部类无法实例，作为工具类使用的意图。类中实例化了一个Unsafe这个可直接操作内存的本地API&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; park(Object blocker) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Thread t =&lt;span&gt; Thread.currentThread();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        setBlocker(t, blocker);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         unsafe.park(&lt;span&gt;false&lt;/span&gt;, 0L&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         setBlocker(t, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.阻塞是通过park方法，第2行获取当前线程；第3行执行setBlocker(Thread t, Object arg)，setBlocker从名字感觉设置阻塞的地方；第4行调用Unsafe中public native void park(boolean paramBoolean, long paramLong)产生阻塞；第5行调用setBlocker(Thread t, Object arg)，但是Object参数是null，此处应该是去除阻塞点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LockSupport {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; LockSupport() {} &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cannot be instantiated.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Hotspot implementation via intrinsics API&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Unsafe unsafe =&lt;span&gt; Unsafe.getUnsafe();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; parkBlockerOffset;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             parkBlockerOffset =&lt;span&gt; unsafe.objectFieldOffset
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 (java.lang.Thread.&lt;span&gt;class&lt;/span&gt;.getDeclaredField(&quot;parkBlocker&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt; (Exception ex) { &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(ex); }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBlocker(Thread t, Object arg) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Even though volatile, hotspot doesn't need a write barrier here.&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        unsafe.putObject(t, parkBlockerOffset, arg);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.setBlocker是调用Unsafe中public native void putObject(Object paramObject1, long paramLong, Object paramObject2)方法，这个long类型paramLong传的是Thread在内存中的偏移量。通过8~13可以看出在静态代码块中通过Unsafe中public native long objectFieldOffset(Field paramField)来得到内存中位置（之前原子操作类也是通过此方法来获取偏移量）这个偏移量属性名称是&quot;&lt;strong&gt;parkBlocker&lt;/strong&gt;&quot;,类型从第11行可以知道&lt;strong&gt;parkBlocker是&lt;/strong&gt;&lt;strong&gt;java.lang.Thread&lt;/strong&gt;类中的一个属性，&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Thread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Make sure registerNatives is the first thing &amp;lt;clinit&amp;gt; does. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerNatives();
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        registerNatives();
    }

    ... ...
 &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The argument supplied to the current call to
     * java.util.concurrent.locks.LockSupport.park.
     * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker
     * Accessed using java.util.concurrent.locks.LockSupport.getBlocker
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;volatile&lt;/span&gt; Object parkBlocker;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个&lt;strong&gt;parkBlocker&lt;/strong&gt;应该是Thread&lt;strong&gt;类变量。&lt;/strong&gt;首先LockSupport 是构造方法私有化，类似一个工具类，而且parkBlockerOffset是static类型的，所以即使在多个场景下的多线程环境，不同的多个Thread调用setBlocker方法都只是针对Thread的类变量进行赋值（类变量只有一个）所以是多对一的关系。并且通过getBlocker源码注释可以看出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Returns the blocker object supplied to the most recent
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * invocation of a park method that has not yet unblocked, or null
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * if not blocked.  The value returned is just a momentary
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * snapshot -- the thread may have since unblocked or blocked on a
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * different blocker object.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; t the thread
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the blocker
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NullPointerException if argument is null
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.6
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object getBlocker(Thread t) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; unsafe.getObjectVolatile(t, parkBlockerOffset);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从注释看出“返回的是最近被阻塞的对象，类似一个瞬间的快照”，那么我理解Thread中Object parkBlocker属性可能会被多个线程赋值。这个属性跟并发阻塞并无关系，只是起到记录阻塞对象的作用。&lt;/p&gt;
&lt;p&gt; 至于Unsafe类中native方法，就没有去追究。看其他博客理解到的是：在hotspot里每个java线程都有一个Parker实例，Parker里使用了一个无锁的队列在分配释放Parker实例。Parker里面有个变量，&lt;span class=&quot;keyword&quot;&gt;volatile &lt;span class=&quot;datatypes&quot;&gt;int _counter 相当于许可，二元信号量（类似0和1）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;datatypes&quot;&gt;当调用park时，先尝试直接能否直接拿到“许可”（即_counter&amp;gt;0时）如果成功，则把_counter设置为0,并返回；如果不成功，则构造一个ThreadBlockInVM，然后检查_counter是不是&amp;gt;0，如果是，则把_counter设置为0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;datatypes&quot;&gt;当unpark时，则简单多了，直接设置_counter为1，如果_counter之前的值是0，则还要调用唤醒在park中等待的线程：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 15:09:00 +0000</pubDate>
<dc:creator>chen_yong</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hupu-jr/p/8344009.html</dc:identifier>
</item>
<item>
<title>【深度学习系列】CNN模型的可视化 - Charlotte77</title>
<link>http://www.cnblogs.com/charlotte77/p/8343700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlotte77/p/8343700.html</guid>
<description>&lt;p data-anchor-id=&quot;jnj1&quot;&gt;　　&lt;span&gt;前面几篇文章讲到了卷积神经网络CNN，但是对于它在每一层提取到的特征以及训练的过程可能还是不太明白，所以这节主要通过模型的可视化来神经网络在每一层中是如何训练的。我们知道，神经网络本身包含了一系列特征提取器，理想的feature map应该是稀疏的以及包含典型的局部信息。通过模型可视化能有一些直观的认识并帮助我们调试模型，比如：feature map与原图很接近，说明它没有学到什么特征；或者它几乎是一个纯色的图，说明它太过稀疏，可能是我们feature map数太多了（feature_map数太多也反映了卷积核太小）。可视化有很多种，比如：feature map可视化、权重可视化等等，我以feature map可视化为例。&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;jnj1&quot;&gt; &lt;/p&gt;
&lt;hr/&gt;&lt;p data-anchor-id=&quot;jnj1&quot;&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;模型可视化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;6dsy&quot;&gt;&lt;span&gt;　　因为我没有搜到用paddlepaddle在imagenet 1000分类的数据集上预训练好的googLeNet inception v3，所以用了keras做实验，以下图作为输入:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li data-anchor-id=&quot;6dsy&quot;&gt;&lt;span&gt;输入图片 &lt;/span&gt;
&lt;ul data-anchor-id=&quot;dp36&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;北汽绅宝D50:&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201801/853467-20180124223333412-1662270630.png&quot; alt=&quot;&quot; width=&quot;372&quot; height=&quot;303&quot;/&gt;&lt;a href=&quot;http://static.zybuluo.com/vivounicorn/2r11lev7bj5jcef01oa9o2s5/image_1bf6huue31l0815eh1kh18c53b213.png&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;feature map可视化 &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　取网络的前15层，每层取前3个feature map。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　北汽绅宝D50 feature map：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201801/853467-20180124223548209-786505629.png&quot; alt=&quot;&quot; width=&quot;987&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;5ks1&quot;&gt;　　&lt;span&gt;从左往右看，可以看到整个特征提取的过程，有的分离背景、有的提取轮廓，有的提取色差，但也能发现10、11层中间两个feature map是纯色的，可能这一层feature map数有点多了，另外北汽绅宝D50的光晕对feature map中光晕的影响也能比较明显看到。&lt;/span&gt;&lt;/p&gt;
&lt;ul data-anchor-id=&quot;gr6g&quot;&gt;&lt;li&gt;&lt;span&gt;Hypercolumns &lt;/span&gt;&lt;br/&gt;&lt;span&gt;通常我们把神经网络最后一个fc全连接层作为整个图片的特征表示，但是这一表示可能过于粗糙（从上面的feature map可视化也能看出来），没法精确描述局部空间上的特征，而网络的第一层空间特征又太过精确，缺乏语义信息（比如后面的色差、轮廓等），于是论文《&lt;a href=&quot;https://arxiv.org/pdf/1411.5752v2.pdf&quot; target=&quot;_blank&quot;&gt;Hypercolumns for Object Segmentation and Fine-grained Localization&lt;/a&gt;》提出一种新的特征表示方法：Hypercolumns——将一个像素的 hypercolumn 定义为所有 cnn 单元对应该像素位置的激活输出值组成的向量），比较好的tradeoff了前面两个问题，直观地看如图：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201801/853467-20180124223658287-793474527.png&quot; alt=&quot;&quot; width=&quot;389&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;把北汽绅宝D50 第1、4、7层的feature map以及第1, 4, 7, 10, 11, 14, 17层的feature map分别做平均，可视化如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201801/853467-20180124223804365-360124346.png&quot; alt=&quot;&quot; width=&quot;549&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;96&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.applications &lt;span&gt;import&lt;/span&gt;&lt;span&gt; InceptionV3
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.applications.inception_v3 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; preprocess_input
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.preprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; image
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Model
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.applications.imagenet_utils &lt;span&gt;import&lt;/span&gt;&lt;span&gt; decode_predictions
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; cv2 &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; scipy as sp
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; scipy.misc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; toimage
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_opencv():
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 加载摄像头&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;     cam = VideoCapture(0)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 0 -&amp;gt; 摄像头序号，如果有两个三个四个摄像头，要调用哪一个数字往上加嘛&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 抓拍 5 张小图片&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(0, 5&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;         s, img =&lt;span&gt; cam.read()
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; s:
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;             imwrite(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;o-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(x) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img)
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; load_original(img_path):
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把原始图片压缩为 299*299大小&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;     im_original = cv2.resize(cv2.imread(img_path), (299, 299&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     im_converted =&lt;span&gt; cv2.cvtColor(im_original, cv2.COLOR_BGR2RGB)
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;    plt.figure(0)
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     plt.subplot(211&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;    plt.imshow(im_converted)
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; im_original
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; load_fine_tune_googlenet_v3(img):
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 加载fine-tuning googlenet v3模型，并做预测&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;     model = InceptionV3(include_top=True, weights=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;imagenet&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;    model.summary()
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     x =&lt;span&gt; image.img_to_array(img)
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     x = np.expand_dims(x, axis=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     x =&lt;span&gt; preprocess_input(x)
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;     preds =&lt;span&gt; model.predict(x)
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Predicted:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, decode_predictions(preds))
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;     plt.subplot(212&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;    plt.plot(preds.ravel())
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    plt.show()
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; model, x
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; extract_features(ins, layer_id, filters, layer_num):
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;    提取指定模型指定层指定数目的feature map并输出到一幅图上.
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    :param ins: 模型实例
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;    :param layer_id: 提取指定层特征
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    :param filters: 每层提取的feature map数
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;    :param layer_num: 一共提取多少层feature map
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    :return: None
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; len(ins) != 2&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parameter error:(model, instance)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     model =&lt;span&gt; ins[0]
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     x = ins[1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; type(layer_id) == type(1&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         model_extractfeatures = Model(input=model.input, output=model.get_layer(index=&lt;span&gt;layer_id).output)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         model_extractfeatures = Model(input=model.input, output=model.get_layer(name=&lt;span&gt;layer_id).output)
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     fc2_features =&lt;span&gt; model_extractfeatures.predict(x)
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; filters &amp;gt;&lt;span&gt; len(fc2_features[0][0][0]):
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;layer number error.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, len(fc2_features[0][0][0]),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,filters)
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(filters):
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         plt.subplots_adjust(left=0, right=1, bottom=0, top=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         plt.subplot(filters, layer_num, layer_id + 1 + i *&lt;span&gt; layer_num)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;         plt.axis(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; i &amp;lt;&lt;span&gt; len(fc2_features[0][0][0]):
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;            plt.imshow(fc2_features[0, :, :, i])
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 层数、模型、卷积核数&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; extract_features_batch(layer_num, model, filters):
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;    批量提取特征
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;    :param layer_num: 层数
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;    :param model: 模型
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;    :param filters: feature map数
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;    :return: None
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;     plt.figure(figsize=&lt;span&gt;(filters, layer_num))
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     plt.subplot(filters, layer_num, 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(layer_num):
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        extract_features(model, i, filters, layer_num)
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;     plt.savefig(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sample.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;    plt.show()
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; extract_features_with_layers(layers_extract):
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;    提取hypercolumn并可视化.
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;    :param layers_extract: 指定层列表
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;    :return: None
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;     hc = extract_hypercolumn(x[0], layers_extract, x[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     ave = np.average(hc.transpose(1, 2, 0), axis=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;    plt.imshow(ave)
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;    plt.show()
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; extract_hypercolumn(model, layer_indexes, instance):
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt; &lt;span&gt;    提取指定模型指定层的hypercolumn向量
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;    :param model: 模型
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;    :param layer_indexes: 层id
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;    :param instance: 模型
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;    :return:
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;     feature_maps =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; layer_indexes:
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         feature_maps.append(Model(input=model.input, output=model.get_layer(index=&lt;span&gt;i).output).predict(instance))
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;     hypercolumns =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; convmap &lt;span&gt;in&lt;/span&gt;&lt;span&gt; feature_maps:
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; convmap[0][0][0]:
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;             upscaled = sp.misc.imresize(convmap[0, :, :, i], size=(299, 299), mode=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, interp=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bilinear&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;            hypercolumns.append(upscaled)
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; np.asarray(hypercolumns)
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; 
&lt;span&gt;120&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     img_path = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;~/auto1.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt;     img =&lt;span&gt; load_original(img_path)
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;     x =&lt;span&gt; load_fine_tune_googlenet_v3(img)
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;     extract_features_batch(15, x, 3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;     extract_features_with_layers([1, 4, 7&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;     extract_features_with_layers([1, 4, 7, 10, 11, 14, 17])
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　还有一些网站做的关于CNN的可视化做的非常不错，譬如这个网站：http://shixialiu.com/publications/cnnvis/demo/，大家可以在训练的时候采取不同的卷积核尺寸和个数对照来看训练的中间过程。最近PaddlePaddle也开源了可视化工具VisaulDL，下篇文章我们讲讲paddlepaddle的visualDL和tesorflow的tensorboard。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 24 Jan 2018 14:47:00 +0000</pubDate>
<dc:creator>Charlotte77</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charlotte77/p/8343700.html</dc:identifier>
</item>
<item>
<title>审计日志中的AOP - 见风任然是风</title>
<link>http://www.cnblogs.com/sunven/p/8343705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunven/p/8343705.html</guid>
<description>&lt;p&gt;审计跟踪（也称为审核日志）是一个安全相关的时间顺序记录，记录这些记录的目的是为已经影响在任何时候的详细操作，提供程序运行的证明文件记录、源或事件&lt;/p&gt;
&lt;h2 id=&quot;mvc&quot;&gt;MVC&lt;/h2&gt;
&lt;p&gt;自定义一个过滤器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AuditFilter : IActionFilter
{
    /// &amp;lt;summary&amp;gt;
    ///     在执行操作方法后调用。
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;filterContext&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public void OnActionExecuted(ActionExecutedContext filterContext)
    {
        var auditData = AbpAuditFilterData.GetOrNull(filterContext.HttpContext);
        if (auditData == null)
            return;
        auditData.Stopwatch.Stop();
        var path = AppDomain.CurrentDomain.BaseDirectory + &quot;log.txt&quot;;
        if (filterContext.Exception != null)
            File.AppendAllText(path,
                DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;) + &quot;异常：&quot; + filterContext.Exception + &quot;\r\n&quot;);
        else
            File.AppendAllText(path,
                DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;) + &quot;耗时：&quot; +
                Convert.ToInt32(auditData.Stopwatch.Elapsed.TotalMilliseconds) + &quot;\r\n&quot;);
    }
    /// &amp;lt;summary&amp;gt;
    ///     在执行操作方法之前调用。
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;filterContext&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public void OnActionExecuting(ActionExecutingContext filterContext)
    {
        var actionStopwatch = Stopwatch.StartNew();
        AbpAuditFilterData.Set(
            filterContext.HttpContext,
            new AbpAuditFilterData(actionStopwatch)
        );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义一个数据存储&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AbpAuditFilterData
{
    private const string AbpAuditFilterDataHttpContextKey = &quot;__AbpAuditFilterData&quot;;


    public AbpAuditFilterData(
        Stopwatch stopwatch)
    {
        Stopwatch = stopwatch;
    }

    public Stopwatch Stopwatch { get; }

    public static void Set(HttpContextBase httpContext, AbpAuditFilterData auditFilterData)
    {
        GetAuditDataStack(httpContext).Push(auditFilterData);
    }

    public static AbpAuditFilterData GetOrNull(HttpContextBase httpContext)
    {
        var stack = GetAuditDataStack(httpContext);
        return stack.Count &amp;lt;= 0
            ? null
            : stack.Pop();
    }

    /// &amp;lt;summary&amp;gt;
    ///     获取一个可变大小的后进先出 (LIFO) 集合
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;httpContext&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private static Stack&amp;lt;AbpAuditFilterData&amp;gt; GetAuditDataStack(HttpContextBase httpContext)
    {
        if (httpContext.Items[AbpAuditFilterDataHttpContextKey] is Stack&amp;lt;AbpAuditFilterData&amp;gt; stack)
            return stack;
        stack = new Stack&amp;lt;AbpAuditFilterData&amp;gt;();
        httpContext.Items[AbpAuditFilterDataHttpContextKey] = stack;
        return stack;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HomeController 如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class HomeController : Controller
{
    public ActionResult Index()
    {
        var a = 0;
        for (var i = 0; i &amp;lt; 10000; i++)
            for (var j = 0; j &amp;lt; 10000; j++)
                a = i - j;
        ViewBag.A = a;
        return View();
    }

    public ActionResult About()
    {
        var a = Convert.ToInt32(&quot;a&quot;);
        ViewBag.Message = &quot;Your application description page.&quot;;

        return View();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问home/index 日志记录如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2018-01-22 19:11:09耗时：342
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问home/about 日志记录如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xk2dp.com1.z0.glb.clouddn.com/AuditingMvcDemo01201801221918482115.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;web-api&quot;&gt;Web Api&lt;/h2&gt;
&lt;p&gt;自定义过滤器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AuditFilter : IActionFilter
{
    //
    // 摘要:
    //     获取或设置一个值，该值指示是否可以为单个程序元素指定多个已指示特性的实例。
    //
    // 返回结果:
    //     如果可以指定多个实例，则为 true；否则为 false。默认值为 false。
    public bool AllowMultiple =&amp;gt; false;

    /// &amp;lt;summary&amp;gt;
    /// 异步执行筛选器操作
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;actionContext&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;cancellationToken&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;continuation&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public async Task&amp;lt;HttpResponseMessage&amp;gt; ExecuteActionFilterAsync(HttpActionContext actionContext, CancellationToken cancellationToken, Func&amp;lt;Task&amp;lt;HttpResponseMessage&amp;gt;&amp;gt; continuation)
    {
        var method = actionContext.ActionDescriptor is ReflectedHttpActionDescriptor descriptor ? descriptor.MethodInfo : null;
        var str = $&quot;{actionContext.ActionDescriptor.ControllerDescriptor.ControllerType.Name}/{method?.Name}/{JsonConvert.SerializeObject(actionContext.ActionArguments)}&quot;;


        var stopwatch = Stopwatch.StartNew();
        var path = AppDomain.CurrentDomain.BaseDirectory + &quot;log.txt&quot;;
        try
        {
            return await continuation();
        }
        catch (Exception ex)
        {
            File.AppendAllText(path,
                DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;) + &quot; &quot; + str + &quot;异常：&quot; + ex + &quot;\r\n&quot;);
            throw;
        }
        finally
        {
            stopwatch.Stop();
            File.AppendAllText(path,
                DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;) + &quot; &quot; + str + &quot;耗时：&quot; +
                Convert.ToInt32(stopwatch.Elapsed.TotalMilliseconds) + &quot;\r\n&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ValuesController代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ValuesController : ApiController
{
    // GET api/values
    public IEnumerable&amp;lt;string&amp;gt; Get()
    {
        Thread.Sleep(new Random().Next(500, 1000));
        return new[] { &quot;Get&quot; };
    }

    // GET api/values/5
    public string Get(int id)
    {
        Thread.Sleep(new Random().Next(500, 1000));
        return id + &quot;&quot;;
    }

    [Route(&quot;api/values/GetError&quot;)]
    public void GetError()
    {
        var a = Convert.ToInt32(&quot;a&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问api/values 日志记录如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2018-01-22 19:23:27 ValuesController/Get/{}耗时：978&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问api/values/1 日志记录如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2018-01-22 19:24:21 ValuesController/Get/{&quot;id&quot;:1}耗时：727&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问api/values/GetError 日志记录如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xk2dp.com1.z0.glb.clouddn.com/AuditingWebApiDemo01201801221930484522.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;unity&quot;&gt;Unity&lt;/h2&gt;
&lt;p&gt;自定义一个拦截器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[AttributeUsage(AttributeTargets.Method | AttributeTargets.Class | AttributeTargets.Interface)]
public class UnityAopAttribute : HandlerAttribute, ICallHandler
{
    public override ICallHandler CreateHandler(IUnityContainer container)
    {
        return this;
    }

    public IMethodReturn Invoke(IMethodInvocation input, GetNextHandlerDelegate getNext)
    {
        var s = new Stopwatch();
        s.Start();
        var result = getNext()(input, getNext);
        if (result.Exception != null)
        {
            WriteLog(result.Exception.ToString());
            //表示处理异常 Unity就不会抛出
            result.Exception = null;
        }
        s.Stop();
        WriteLog(&quot;方法：{0},参数：{1},耗时：{2}&quot;,
            input.MethodBase.Name, JsonConvert.SerializeObject(input.Arguments), s.Elapsed.TotalMilliseconds);
        return result;
    }

    private void WriteLog(string format, params object[] arg)
    {
        var path = AppDomain.CurrentDomain.BaseDirectory + &quot;log.txt&quot;;
        File.AppendAllText(path, string.Format(format, arg) + &quot;\r\n&quot;);
    }

    public IEnumerable&amp;lt;Type&amp;gt; GetRequiredInterfaces()
    {
        return Type.EmptyTypes;
    }

    public bool WillExecute =&amp;gt; false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接口定义如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IOrderService
{
    string GetOrder();

    string GetOrderDetail();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现如下&lt;/p&gt;
&lt;p&gt;加上UnityAop标记&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[UnityAop]
public class OrderService : IOrderService
{
    public string GetOrder()
    {
        Thread.Sleep(new Random().Next(500, 1000));
        return &quot;GetOrder&quot;;
    }

    public string GetOrderDetail()
    {
        var i = Convert.ToInt32(&quot;a&quot;);
        return i + &quot;GetOrder&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注入及调用如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xk2dp.com1.z0.glb.clouddn.com/UnityDemo01201801231017117225.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;a href=&quot;https://github.com/sunven/Abp1&quot; class=&quot;uri&quot;&gt;https://github.com/sunven/Abp1&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/1-2-3/archive/2009/11/18/unity-aop-exception.html&quot;&gt;Unity AOP 处理异常的方法&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 13:48:00 +0000</pubDate>
<dc:creator>见风任然是风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunven/p/8343705.html</dc:identifier>
</item>
<item>
<title>spring boot容器启动详解 - 只会一点java</title>
<link>http://www.cnblogs.com/dennyzhangdd/p/8028950.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dennyzhangdd/p/8028950.html</guid>
<description>&lt;p&gt;目录&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/dennyzhangdd/p/8028950.html#first&quot;&gt; 一、前言&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/dennyzhangdd/p/8028950.html#second&quot;&gt; 二、容器启动&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/dennyzhangdd/p/8028950.html#third&quot;&gt; 三、总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;=======正文分割线======&lt;/p&gt;
&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;spring cloud大行其道的当下，如果不了解基本原理那么是很纠结的(看见的都是&lt;span&gt;约定大于配置&lt;/span&gt;，但是原理呢？为什么要这么做？)。spring cloud是基于spring boot快速搭建的，今天咱们就看看spring boot容器启动流程。(本文不讲解如何快速启动spring boot，那些直接官方看即可，&lt;a href=&quot;http://projects.spring.io/spring-boot/#quick-start&quot; target=&quot;_blank&quot;&gt;官网文档飞机票&lt;/a&gt;)&lt;/p&gt;
&lt;h2&gt;二、容器启动&lt;/h2&gt;
&lt;p&gt;spring boot一般是&lt;strong&gt;指定容器启动main方法，然后以命令行方式启动Jar包&lt;/strong&gt;，如下图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Application {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;SpringApplication&lt;/span&gt;.run(Application.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里核心关注2个东西：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.@SpringBootApplication注解&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.&lt;span&gt;SpringApplication.run()静态方法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 下面我们就分别探究这两块内容。&lt;/p&gt;
&lt;h3&gt;2.1 &lt;strong&gt;&lt;span&gt;@SpringBootApplication注解&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;源码如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Target(ElementType.TYPE)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@Inherited
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;@SpringBootConfiguration
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&lt;span&gt;@EnableAutoConfiguration&lt;/span&gt;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; @ComponentScan(excludeFilters =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) })
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; SpringBootApplication {
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;核心注解：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span readability=&quot;2&quot;&gt;@&lt;span&gt;SpringBootConfiguration&lt;/span&gt;（实际就是个@Configuration）：表示这是一个&lt;span&gt;JavaConfig配置类&lt;/span&gt;，可以在这个类中自定义bean,依赖关系等。-》这个是spring-boot特有的注解，常用到。&lt;br/&gt;@&lt;span&gt;EnableAutoConfiguration&lt;/span&gt;：借助@Import的帮助，将所有符合&lt;span&gt;自动配置条件的bean定义加载到IoC容器&lt;/span&gt;（建议放在根包路径下，这样可以扫描子包和类）。-》这个需要详细深挖！&lt;br/&gt;@&lt;span&gt;ComponentScan&lt;/span&gt;：spring的&lt;span&gt;自动扫描注解&lt;/span&gt;，可定义扫描范围，加载到IOC容器。-》这个不多说，spring的注解大家肯定眼熟&lt;p&gt;其中&lt;span&gt;&lt;span&gt;@&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;EnableAutoConfiguration这个注解的源码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @SuppressWarnings(&quot;deprecation&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@Target(ElementType.TYPE)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;@Inherited
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;@AutoConfigurationPackage
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; @&lt;span&gt;Import&lt;/span&gt;(&lt;span&gt;EnableAutoConfigurationImportSelector&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; EnableAutoConfiguration {
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;核心是一个EnableAutoConfigurationImportSelector类图如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/584866/201712/584866-20171213175835363-107347956.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;核心方法在顶级接口&lt;span&gt;ImportSelector&lt;/span&gt;的&lt;strong&gt;&lt;span&gt;selectImports（）&lt;/span&gt;&lt;/strong&gt;，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String[] &lt;span&gt;selectImports&lt;/span&gt;(AnnotationMetadata annotationMetadata) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isEnabled(annotationMetadata)) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NO_IMPORTS;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {         &lt;span&gt;//1.从META-INF/spring-autoconfigure-metadata.properties文件中载入483条配置属性（有一些有默认值），
&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             AutoConfigurationMetadata autoConfigurationMetadata =&lt;span&gt; AutoConfigurationMetadataLoader
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     .&lt;span&gt;loadMetadata&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanClassLoader);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             AnnotationAttributes attributes =&lt;span&gt; getAttributes(annotationMetadata);&lt;span&gt;//2.获取注解属性
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             List&amp;lt;String&amp;gt; configurations =&lt;span&gt;&lt;span&gt; getCandidateConfigurations&lt;/span&gt;(annotationMetadata,&lt;span&gt;//3.获取97个自动配置类
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    attributes);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             configurations =&lt;span&gt; removeDuplicates(configurations);&lt;span&gt;//4.移除重复的
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             configurations =&lt;span&gt; sort(configurations, autoConfigurationMetadata);&lt;span&gt;//5.排序
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             Set&amp;lt;String&amp;gt; exclusions =&lt;span&gt; getExclusions(annotationMetadata, attributes);&lt;span&gt;//6.获取需要排除的
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            checkExcludedClasses(configurations, exclusions);&lt;span&gt;//7.校验排除类
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            configurations.removeAll(exclusions);&lt;span&gt;//8.删除所有需要排除的
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             configurations =&lt;span&gt;&lt;span&gt; filter&lt;/span&gt;(configurations, autoConfigurationMetadata);&lt;span&gt;//9.过滤器&lt;span&gt;&lt;span&gt;OnClassCondition（注解中配置的当存在某类才生效）&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            fireAutoConfigurationImportEvents(configurations, exclusions);&lt;span&gt;//10.触发自动配置导入监听事件
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; configurations.toArray(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[configurations.size()]);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(ex);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这里注意3个核心方法：&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;loadMetadata 加载配置&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实就是用类加载器去加载：&lt;span&gt;META-INF/spring-autoconfigure-metadata.properties&lt;span&gt;（spring-boot-autoconfigure-1.5.9.RELEASE-sources.jar）&lt;/span&gt;&lt;/span&gt;文件中定义的配置，返回PropertiesAutoConfigurationMetadata（实现了AutoConfigurationMetadata接口，封装了属性的get set方法）&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;&lt;span&gt;getCandidateConfigurations&lt;span&gt;获取默认支持的自动配置类名列表&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;自动配置灵魂方法，&lt;span&gt;SpringFactoriesLoader.loadFactoryNames&lt;/span&gt; 从&lt;span&gt;META-INF/spring.factories&lt;/span&gt;（spring-boot-autoconfigure-1.5.9.RELEASE-sources.jar）文件中获取自动配置类key=EnableAutoConfiguration.class的配置。&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getCandidateConfigurations(AnnotationMetadata metadata,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            AnnotationAttributes attributes) {&lt;span&gt;//话说这里2个入参没啥用啊...谁来给我解释一下...
&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         List&amp;lt;String&amp;gt; configurations =&lt;span&gt; SpringFactoriesLoader.&lt;span&gt;loadFactoryNames&lt;/span&gt;(
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;&lt;span&gt;                getSpringFactoriesLoaderFactoryClass&lt;/span&gt;(), getBeanClassLoader());
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        Assert.notEmpty(configurations,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;
&lt;span&gt; 7&lt;/span&gt;                         + &quot;are using a custom packaging, make sure that file is correct.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; configurations;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&lt;span&gt;//返回的是EnableAutoConfiguration类&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt;&lt;span&gt; getSpringFactoriesLoaderFactoryClass&lt;/span&gt;() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; EnableAutoConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际获取了什么？&lt;span&gt;spring.factories&lt;/span&gt;文件如下，实际获取了&lt;span&gt;&lt;span&gt;# Auto Configure&lt;/span&gt;自动配置模块的所有类。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;137&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Initializers
org.springframework.context.ApplicationContextInitializer&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\
org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer

# Application Listeners
org.springframework.context.ApplicationListener&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.autoconfigure.BackgroundPreinitializer

# Auto Configuration Import Listeners
org.springframework.boot.autoconfigure.AutoConfigurationImportListener&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener

# Auto Configuration Import Filters
org.springframework.boot.autoconfigure.&lt;span&gt;AutoConfigurationImportFilter&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.autoconfigure.condition.&lt;span&gt;OnClassCondition&lt;/span&gt;

# Auto Configure &lt;span&gt;这里就是全部的自动配置类&lt;/span&gt;
org.springframework.boot.autoconfigure.&lt;span&gt;EnableAutoConfiguration&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\
org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\
org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\
org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\
org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\
org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\
org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\
org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\
org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\
org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\
org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\
org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\
org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\
org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\
org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\
org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\
org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\
org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\
org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\
org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\
org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\
org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\
org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\
org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\
org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\
org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\
org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\
org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\
org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\
org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\
org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\
org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\
org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\
org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\
org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\
org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\
org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\
org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\
org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\
org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\
org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration

# Failure analyzers
org.springframework.boot.diagnostics.FailureAnalyzer&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\
org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\
org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer

# Template availability providers
org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.web.JspTemplateAvailabilityProvider&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 3）filter过滤器&lt;/span&gt; 根据&lt;span&gt;&lt;span&gt;OnClassCondition&lt;/span&gt;&lt;/span&gt;注解把不满足条件的过滤掉&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span&gt;filter&lt;/span&gt;(List&amp;lt;String&amp;gt;&lt;span&gt; configurations,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            AutoConfigurationMetadata autoConfigurationMetadata) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.nanoTime();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         String[] candidates = configurations.toArray(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[configurations.size()]);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt;[] skip = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[candidates.length];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; skipped = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;           //获取需要过滤的自动配置导入拦截器，&lt;span&gt;spring.factories&lt;/span&gt;配置中就一个：&lt;span&gt;org.springframework.boot.autoconfigure.condition.&lt;span&gt;OnClassCondition&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (AutoConfigurationImportFilter filter : getAutoConfigurationImportFilters()) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            invokeAwareMethods(filter);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt;[] match =&lt;span&gt; filter.match(candidates, autoConfigurationMetadata);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; match.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;match[i]) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     skip[i] = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     skipped = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;skipped) {&lt;span&gt;&lt;span&gt;&lt;span&gt;//多条件只要有一个不匹配-&amp;gt;skipped = &lt;span&gt;true&lt;/span&gt;，全部匹配-》&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;skipped = &lt;span&gt;false-&amp;gt;直接返回&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; configurations;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         List&amp;lt;String&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;(candidates.length);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; candidates.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;skip[i]) {&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//匹配-》不跳过-》添加进result&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                result.add(candidates[i]);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; numberFiltered = configurations.size() -&lt;span&gt; result.size();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             logger.trace(&quot;Filtered &quot; + numberFiltered + &quot; auto configuration class in &quot;
&lt;span&gt;29&lt;/span&gt;                     + TimeUnit.NANOSECONDS.toMillis(System.nanoTime() -&lt;span&gt; startTime)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     + &quot; ms&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;(result);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.2 &lt;span&gt;SpringApplication&lt;span&gt;.run()静态方法&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;SpringApplication.run&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConfigurableApplicationContext run(String... args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         StopWatch stopWatch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StopWatch();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        stopWatch.start();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         ConfigurableApplicationContext context = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         FailureAnalyzers analyzers = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        configureHeadlessProperty();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         SpringApplicationRunListeners &lt;span&gt;listeners &lt;/span&gt;=&lt;span&gt;&lt;span&gt; getRunListeners&lt;/span&gt;(args);&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//1.获取监听器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;strong&gt;&lt;span&gt;        listeners.starting();--&amp;gt;启动！
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             ApplicationArguments applicationArguments = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultApplicationArguments(
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    args);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             ConfigurableEnvironment environment =&lt;span&gt;&lt;span&gt; prepareEnvironment&lt;/span&gt;(&lt;span&gt;listeners&lt;/span&gt;,&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//2.准备好环境，触发ApplicationEnvironmentPreparedEvent事件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    applicationArguments);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             Banner printedBanner =&lt;span&gt;&lt;span&gt; printBanner&lt;/span&gt;(environment);&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//打印启动提示字符，默认spring的字符图&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             context =&lt;span&gt;&lt;span&gt; createApplicationContext&lt;/span&gt;();&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//实例化一个可配置应用上下文&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             analyzers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; FailureAnalyzers&lt;/span&gt;(context);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;&lt;span&gt;            prepareContext&lt;/span&gt;(context, environment, &lt;span&gt;listeners&lt;/span&gt;, applicationArguments,&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//3.准备上下文&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                    printedBanner);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;&lt;span&gt;            refreshContext&lt;/span&gt;(context);&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//4.刷新上下文&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;&lt;span&gt;            afterRefresh&lt;/span&gt;(context, applicationArguments);&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//5.刷新上下文后&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;&lt;strong&gt;listeners.finished(context, null);--关闭！
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            stopWatch.stop();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.logStartupInfo) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; StartupInfoLogger(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainApplicationClass)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                        .logStarted(getApplicationLog(), stopWatch);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; context;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            handleRunFailure(context, listeners, analyzers, ex);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(ex);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 1.&lt;span&gt;&lt;span&gt;getRunListeners&lt;/span&gt;&lt;/span&gt;获取监听器（&lt;span&gt;SpringApplicationRunListeners&lt;/span&gt; ）&lt;/h3&gt;
&lt;p&gt;实际是&lt;span&gt;SpringApplicationRunListener&lt;/span&gt;类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; SpringApplicationRunListeners &lt;span&gt;getRunListeners&lt;/span&gt;(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Class&amp;lt;?&amp;gt;[] types = &lt;span&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[] { SpringApplication.&lt;span&gt;class&lt;/span&gt;, String[].&lt;span&gt;class&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; SpringApplicationRunListeners&lt;/span&gt;(logger, &lt;span&gt;getSpringFactoriesInstances&lt;/span&gt;(
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             SpringApplicationRunListener.&lt;span&gt;class&lt;/span&gt;, types, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args));
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T&amp;gt; getSpringFactoriesInstances(Class&amp;lt;T&amp;gt;&lt;span&gt; type) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;getSpringFactoriesInstances&lt;/span&gt;(type, &lt;span&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt;[] {});
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T&amp;gt; &lt;span&gt;getSpringFactoriesInstances&lt;/span&gt;(Class&amp;lt;T&amp;gt;&lt;span&gt; type,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         Class&amp;lt;?&amp;gt;&lt;span&gt;[] parameterTypes, Object... args) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     ClassLoader classLoader =&lt;span&gt; Thread.currentThread().getContextClassLoader();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用Set确保的字符串的唯一性&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     Set&amp;lt;String&amp;gt; names = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;String&amp;gt;&lt;span&gt;(
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            SpringFactoriesLoader.&lt;span&gt;loadFactoryNames&lt;/span&gt;(type, classLoader));&lt;span&gt;//&lt;span&gt; 1.载入工厂名称集合&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     List&amp;lt;T&amp;gt; instances =&lt;span&gt;&lt;span&gt; createSpringFactoriesInstances&lt;/span&gt;(type, parameterTypes,&lt;span&gt;//&lt;span&gt; 2.创建工厂实例&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            classLoader, args, names);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    AnnotationAwareOrderComparator.sort(instances);&lt;span&gt;//&lt;span&gt; 排序&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; instances;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.1 载入工厂名称（loadFactoryNames）&lt;/h3&gt;
&lt;p&gt;当前类的类加载器从&lt;span&gt;META-INF/spring.factories&lt;/span&gt;文件中获取SpringApplicationRunListener类的配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span&gt;loadFactoryNames&lt;/span&gt;(Class&amp;lt;?&amp;gt;&lt;span&gt; factoryClass, ClassLoader classLoader) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         String factoryClassName =&lt;span&gt; factoryClass.getName();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             Enumeration&amp;lt;URL&amp;gt; urls = (classLoader != &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                    ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             List&amp;lt;String&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (urls.hasMoreElements()) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 URL url =&lt;span&gt; urls.nextElement();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 Properties properties = PropertiesLoaderUtils.&lt;span&gt;loadProperties&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UrlResource(url));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 String factoryClassNames =&lt;span&gt; properties.getProperty(factoryClassName);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Unable to load [&quot; + factoryClass.getName() +
&lt;span&gt;17&lt;/span&gt;                     &quot;] factories from location [&quot; + FACTORIES_RESOURCE_LOCATION + &quot;]&quot;&lt;span&gt;, ex);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图，获取到工厂类名后，下面来看看META-INF/spring.factories中定义了啥：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# &lt;span&gt;PropertySource Loaders&lt;/span&gt;
org.springframework.boot.env.PropertySourceLoader&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.env.PropertiesPropertySourceLoader,\
org.springframework.boot.env.YamlPropertySourceLoader

# &lt;span&gt;Run Listeners  这里呢，看这里！！！！&lt;/span&gt;
&lt;span&gt;org.springframework.boot.SpringApplicationRunListener&lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt;\
org.springframework.boot.context.event.EventPublishingRunListener&lt;/span&gt;

# &lt;span&gt;Application Context Initializers&lt;/span&gt;
org.springframework.context.ApplicationContextInitializer&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\
org.springframework.boot.context.ContextIdApplicationContextInitializer,\
org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\
org.springframework.boot.context.embedded.ServerPortInfoApplicationContextInitializer

# &lt;span&gt;Application Listeners&lt;/span&gt;
org.springframework.context.ApplicationListener&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.ClearCachesApplicationListener,\
org.springframework.boot.builder.ParentContextCloserApplicationListener,\
org.springframework.boot.context.FileEncodingApplicationListener,\
org.springframework.boot.context.config.AnsiOutputApplicationListener,\
org.springframework.boot.context.config.ConfigFileApplicationListener,\
org.springframework.boot.context.config.DelegatingApplicationListener,\
org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\
org.springframework.boot.logging.ClasspathLoggingApplicationListener,\
org.springframework.boot.logging.LoggingApplicationListener

# &lt;span&gt;Environment Post Processors&lt;/span&gt;
org.springframework.boot.env.EnvironmentPostProcessor&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\
org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor

# &lt;span&gt;Failure Analyzers&lt;/span&gt;
org.springframework.boot.diagnostics.FailureAnalyzer&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.diagnostics.analyzer.BeanCurrentlyInCreationFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.BeanNotOfRequiredTypeFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.BindFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.ConnectorStartFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.NoUniqueBeanDefinitionFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.PortInUseFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.ValidationExceptionFailureAnalyzer

# &lt;span&gt;FailureAnalysisReporters&lt;/span&gt;
org.springframework.boot.diagnostics.FailureAnalysisReporter&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哇，都是些类全名称，且key都是接口，value都是实现类。我们根据key=“&lt;span&gt;&lt;span&gt;org.springframework.boot.SpringApplicationRunListener&lt;/span&gt;&lt;/span&gt;”查询得到实现类value=&quot;&lt;span&gt;&lt;span&gt;org.springframework.boot.context.event.EventPublishingRunListener&quot;&lt;span&gt;事件发布启动监听器&lt;/span&gt;，&lt;/span&gt;&lt;/span&gt;一猜也知道肯定要用”&lt;span&gt;反射&lt;/span&gt;”根据类名获取类实例，下面很快得到验证...&lt;/p&gt;
&lt;h3&gt;1.2 创建spring工厂实例（createSpringFactoriesInstances）&lt;/h3&gt;
&lt;p&gt;根据第一步得到的Set&amp;lt;String&amp;gt; names（SpringApplicationRunListener的唯一实现类&lt;span&gt;&lt;span&gt;EventPublishingRunListener&lt;/span&gt;&lt;/span&gt;）生成&quot;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;事件发布启动监听器&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;工厂实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; &lt;span&gt;createSpringFactoriesInstances&lt;/span&gt;(Class&amp;lt;T&amp;gt;&lt;span&gt; type,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             Class&amp;lt;?&amp;gt;&lt;span&gt;[] parameterTypes, ClassLoader classLoader, Object[] args,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             Set&amp;lt;String&amp;gt;&lt;span&gt; names) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         List&amp;lt;T&amp;gt; instances = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;T&amp;gt;&lt;span&gt;(names.size());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String name : names) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 Class&amp;lt;?&amp;gt; instanceClass =&lt;span&gt; ClassUtils.&lt;span&gt;forName&lt;/span&gt;(name, classLoader);&lt;span&gt;&lt;span&gt;//&lt;span&gt; 利用反射获取类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                Assert.isAssignable(type, instanceClass);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 Constructor&amp;lt;?&amp;gt; constructor =&lt;span&gt; instanceClass
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                        .&lt;span&gt;getDeclaredConstructor&lt;/span&gt;(parameterTypes);&lt;span&gt;&lt;span&gt;//&lt;span&gt; 得到构造器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 T instance =&lt;span&gt; (T) BeanUtils.&lt;span&gt;instantiateClass&lt;/span&gt;(constructor, args);&lt;span&gt;&lt;span&gt;//&lt;span&gt; 根据构造器和参数构造实例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                instances.add(instance);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                         &quot;Cannot instantiate &quot; + type + &quot; : &quot; +&lt;span&gt; name, ex);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; instances;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt; 准备上下文&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;&lt;span&gt; prepareContext&lt;/span&gt;(ConfigurableApplicationContext context,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            ApplicationArguments applicationArguments, Banner printedBanner) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        context.setEnvironment(environment);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        postProcessApplicationContext(context);&lt;span&gt;//单例一个BeanNameGenerator，把ResourceLoader设置进应用上下文&lt;/span&gt;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        applyInitializers(context);&lt;span&gt;&lt;span&gt;//执行初始化器&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        listeners.contextPrepared(context);&lt;span&gt;&lt;span&gt;//&lt;span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;监听器执行上下文&quot;已准备好&quot;方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.logStartupInfo) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             logStartupInfo(context.getParent() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            logStartupProfileInfo(context);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加spring boot特殊单例bean&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         context.getBeanFactory().registerSingleton(&quot;springApplicationArguments&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                applicationArguments);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (printedBanner != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             context.getBeanFactory().registerSingleton(&quot;springBootBanner&quot;&lt;span&gt;, printedBanner);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 载入资源&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         Set&amp;lt;Object&amp;gt; sources =&lt;span&gt; getSources();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         Assert.notEmpty(sources, &quot;Sources must not be empty&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         load(context, sources.toArray(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[sources.size()]));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        listeners.contextLoaded(context);&lt;span&gt;//&lt;span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;监听器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;执行&quot;上下文已加载&quot;方法&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;刷新上下文&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;&lt;span&gt;refreshContext&lt;/span&gt;(ConfigurableApplicationContext context) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&lt;span&gt;    refresh&lt;/span&gt;(context);&lt;span&gt;&lt;span&gt;//核心类&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registerShutdownHook) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            context.&lt;span&gt;registerShutdownHook&lt;/span&gt;();&lt;span&gt;//注册关闭钩子，容器关闭时执行&lt;/span&gt;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AccessControlException ex) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Not allowed in some environments.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;&lt;span&gt; refresh&lt;/span&gt;(ApplicationContext applicationContext) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     Assert.isInstanceOf(AbstractApplicationContext.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, applicationContext);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    ((AbstractApplicationContext) applicationContext).&lt;span&gt;refresh&lt;/span&gt;();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最终执行的是AbstractApplicationContext抽象类的&lt;span&gt;refresh&lt;span&gt;方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; refresh() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException, IllegalStateException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.startupShutdownMonitor) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证。&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            prepareRefresh();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动子类的refreshBeanFactory方法.解析xml&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             ConfigurableListableBeanFactory beanFactory =&lt;span&gt; obtainFreshBeanFactory();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为BeanFactory配置容器特性，例如类加载器、事件处理器等.&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            prepareBeanFactory(beanFactory);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置BeanFactory的后置处理. 空方法，留给子类拓展用。 &lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                postProcessBeanFactory(beanFactory);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用BeanFactory的后处理器, 这些后处理器是在Bean定义中向容器注册的.  &lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                invokeBeanFactoryPostProcessors(beanFactory);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册Bean的后处理器, 在Bean创建过程中调用.  &lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                registerBeanPostProcessors(beanFactory);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化上下文中的消息源，即不同语言的消息体进行国际化处理  &lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                initMessageSource();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化ApplicationEventMulticaster bean,应用事件广播器&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                initApplicationEventMulticaster();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化其它特殊的Bean， 空方法，留给子类拓展用。 &lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                onRefresh();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查并向容器注册监听器Bean&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                registerListeners();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化所有剩余的(non-lazy-init) 单例Bean.&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                finishBeanFactoryInitialization(beanFactory);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布容器事件, 结束refresh过程. &lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                finishRefresh();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeansException ex) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isWarnEnabled()) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                     logger.warn(&quot;Exception encountered during context initialization - &quot; +
&lt;span&gt;44&lt;/span&gt;                             &quot;cancelling refresh attempt: &quot; +&lt;span&gt; ex);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;销毁已经创建的单例Bean, 以避免资源占用.&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                destroyBeans();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消refresh操作, 重置active标志. &lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                cancelRefresh(ex);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Propagate exception to caller.&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重置Spring的核心缓存&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                resetCommonCaches();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;刷新完上下文后&lt;/h3&gt;
&lt;p&gt;spring boot提供的2个供用户自己拓展的接口：&lt;span&gt;&lt;span&gt;ApplicationRunner和&lt;span&gt;&lt;span&gt;CommandLineRunner。可以在容器启动完毕后（上下文刷新后）执行，做一些类似数据初始化的操作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; callRunners(ApplicationContext context, ApplicationArguments args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         List&amp;lt;Object&amp;gt; runners = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         runners.addAll(context.getBeansOfType(ApplicationRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).values());&lt;span&gt;//&lt;span&gt;从上下文中获取ApplicationRunner类型的bean&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         runners.addAll(context.getBeansOfType(CommandLineRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).values());&lt;span&gt;&lt;span&gt;//&lt;span&gt;从上下文中获取CommandLineRunner类型的bean&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        AnnotationAwareOrderComparator.sort(runners);&lt;span&gt;&lt;span&gt;//&lt;span&gt;排序&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Object runner : &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;Object&amp;gt;&lt;span&gt;(runners)) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (runner &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ApplicationRunner) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;&lt;span&gt;                callRunner&lt;/span&gt;((&lt;span&gt;ApplicationRunner&lt;/span&gt;) runner, args);&lt;span&gt;&lt;span&gt;//&lt;span&gt;执行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (runner &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; CommandLineRunner) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;&lt;span&gt;                callRunner&lt;/span&gt;((&lt;span&gt;CommandLineRunner&lt;/span&gt;) runner, args);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;两个区别在于入参不同，根据实际情况自己选择。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; CommandLineRunner {&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; run(&lt;span&gt;String...&lt;/span&gt; args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ApplicationRunner {&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; run(&lt;span&gt;ApplicationArguments&lt;/span&gt; args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;CommandLineRunner中执行参数是原始的&lt;span&gt;&lt;span&gt;&lt;span&gt;java启动类main方法的String[] args字符串数组参数；&lt;span&gt;ApplicationRunner中的参数经过处理提供一些方法例如:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; List&amp;lt;String&amp;gt; getOptionValues(String name);&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;根据名称获取值list,java 启动命令中 --foo=bar --foo=baz，则根据foo参数名返回list&lt;code&gt;[&quot;bar&quot;, &quot;baz&quot;]&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;三、总结&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/584866/201801/584866-20180124192749740-1647336398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照前面的分析，Spring-boot容器启动流程总体可划分为2部分：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）&lt;strong&gt;执行注解&lt;/strong&gt;&lt;/span&gt;：扫描指定范围下的bean、载入自动配置类对应的bean加载到IOC容器。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）man方法中具体SpringAppliocation.run()&lt;/span&gt;，全流程贯穿SpringApplicationEvent,有6个子类：&lt;/p&gt;
&lt;p&gt;ApplicationFailedEvent.class&lt;/p&gt;
&lt;p&gt;ApplicationPreparedEvent.class&lt;/p&gt;
&lt;p&gt;ApplicationReadyEvent.class&lt;/p&gt;
&lt;p&gt;ApplicationStartedEvent.class&lt;/p&gt;
&lt;p&gt;ApplicationStartingEvent.class&lt;/p&gt;
&lt;p&gt;SpringApplicationEvent.class&lt;/p&gt;
&lt;p&gt;这里用到了很经典的&lt;span&gt;&lt;strong&gt;spring事件驱动模型&lt;/strong&gt;&lt;/span&gt;，飞机票：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;singleposttitle&quot; href=&quot;http://www.cnblogs.com/dennyzhangdd/p/8343229.html&quot;&gt;Spring事件驱动模型和观察者模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/584866/201801/584866-20180124194042131-769199264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，就是一个经典spring 事件驱动模型，包含3种角色：事件发布者、事件、监听者。对应到spring-boot中就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;.EventPublishingRunListener&lt;/span&gt;&lt;/strong&gt;这个类封装了&lt;strong&gt;&lt;span&gt;事件发布&lt;/span&gt;&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;&lt;span&gt;SpringApplicationEvent&lt;/span&gt;&lt;/strong&gt;是spring-boot中定义的事件（上面说的6种事件），继承自&lt;span&gt;ApplicationEvent&lt;/span&gt;（spring中定义的）&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;&lt;span&gt;监听者 spring-boot并没有实现针对上述6种事件的监听者（我没找到...），&lt;/span&gt;&lt;/strong&gt;这里用户可以自己实现监听者（上述6种事件）来注入spring boot容器启动流程，触发相应的事件。&lt;/p&gt;
&lt;p&gt;例如：实现ApplicationListener&amp;lt;ApplicationReadyEvent&amp;gt;这个接口，在容器启动完毕时最后一步listener.finished时，如果启动没有异常，就会执行！可以做一些数据初始化之类的操作。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 12:32:00 +0000</pubDate>
<dc:creator>只会一点java</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dennyzhangdd/p/8028950.html</dc:identifier>
</item>
<item>
<title>基于TypeScript装饰器定义Express RESTful 服务 - 一箭中的</title>
<link>http://www.cnblogs.com/winfred/p/8260885.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/winfred/p/8260885.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;本文主要讲解如何使用TypeScript装饰器定义Express路由。文中出现的代码经过简化不能直接运行，完整代码的请戳：&lt;a href=&quot;https://github.com/WinfredWang/express-decorator&quot; class=&quot;uri&quot;&gt;https://github.com/WinfredWang/express-decorator&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么使用装饰器&quot;&gt;1 为什么使用装饰器&lt;/h3&gt;
&lt;p&gt;当我们在使用Express时，经常要暴露RESTful服务，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var express = require('express');
var app = express();
app.get('/users', function(req, res) {
  res.send([{name:'xx'}]);
});

// 路由模块化写法
var router = express.Router();
app.get('/users', function(req, res) {
  res.send([{name:'xx'}]);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;熟悉Java WEB童鞋知道&lt;a href=&quot;https://baike.baidu.com/item/JAX-RS/10914743?fr=aladdin&quot;&gt;&lt;code&gt;jax-rs&lt;/code&gt;&lt;/a&gt;可以使用标注(annotation)声明服务。例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Path(&quot;/myResource&quot;)
public class SomeResource {
    @GET
    public String doGetAsPlainText() {
        ...
    }
 
    @GET
    public String doGetAsHtml() {
        ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这种方式声明的服务非常简洁方便，免去了写一坨重复代码之苦，而且看起来更加清晰，那我们看看在Node.js中如何做。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;需求&quot;&gt;2 需求&lt;/h3&gt;
&lt;p&gt;参照&lt;a href=&quot;https://docs.oracle.com/javaee/6/tutorial/doc/gijqy.html&quot;&gt;&lt;code&gt;jax-rs&lt;/code&gt;&lt;/a&gt;规范，我们列出如下需求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;code&gt;@Path&lt;/code&gt;声明RESTful服务路由&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;@GET/@POST/@DELETE/@PUT&lt;/code&gt;声明子路由&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;@PathParam，@QueryParam，@HeaderParam，@CookieParam，@FormParam,&lt;/code&gt;来接受服务参数&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;实现思路&quot;&gt;3 实现思路&lt;/h3&gt;
&lt;p&gt;在ES6和TypeScript中有新特性:&lt;code&gt;装饰器(Decorator)&lt;/code&gt;，正好我们可以借助它实现我们的需求。至于装饰器用法，可以参考我的&lt;a href=&quot;http://www.cnblogs.com/winfred/p/8216650.html&quot;&gt;上一篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/2776992/34775124-ffb5ef42-f64c-11e7-8438-28fb4646e2f5.png&quot; alt=&quot;20180107195916&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中左边是Java中定义RESTful代码，右边是Express代码，其实他们本质上是一一对应的。我们只要在装饰器的定义中实现Express 路由即可。&lt;/p&gt;
&lt;p&gt;继续思考，我们Express 路由到底是放到那个注解中实现呢？&lt;br/&gt;我们知道不同装饰器(类/方法/参数)执行顺序不同：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参数装饰器先执行，然后方法最后类装饰器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据这个特性我们应该将核心实现放到类装饰器&lt;code&gt;Path&lt;/code&gt;中执行是不是就可以了呢？&lt;/p&gt;
&lt;p&gt;其实不是，我们看如下代码，我们在&lt;code&gt;user-service.ts&lt;/code&gt;中定义了&lt;code&gt;UserService&lt;/code&gt;服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Path(&quot;/user&quot;)
 class UserService {
    @GET(&quot;/{id}&quot;)
    public getUsers(@PathParam(&quot;id&quot;) id： string) {
       // TODO
    }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们定义好了服务，然后想让Node.js模块加载，我们必须在工程入口模块(main.ts)中导入上述文件&lt;br/&gt;main.ts代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { HelloService } from './hello-service'

// TODO&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述服务代码会执行吗？也就是说&lt;br/&gt;如果仅仅导入模块，而没有使用该模块的话，Node.js是否会加载这个模块呢，换句话说这个模块会执行吗？答案是NO。&lt;br/&gt;为啥呀？因为Node.js对其做了优化，只有一个模块被真正用到才会加载。&lt;/p&gt;
&lt;p&gt;上有政策，下有对策。我们就在模块引用一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { HelloService } from './hello-service'

HelloService; // 就是为了让Node加载它&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样好吗，当然不好。谁知道这是干嘛的。&lt;/p&gt;
&lt;p&gt;所以我们应该换了思路，将Express 注册路由代码拿到装饰器外部，额外提供注册服务的入口，通过该注册服务入口，用户可以显式看到有哪些服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { HelloService } from './hello-service';
import {RegisterService } from 'xxx';

RegisterService([HelloService]);//注册服务&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;装饰器核心代码&quot;&gt;4 装饰器核心代码&lt;/h3&gt;
&lt;p&gt;基于上面的思考，我们在装饰器的实现中只是单纯地存储RESTful url以及参数即可，剩下服务注册工作交给&lt;code&gt;RegisterService&lt;/code&gt;去做。&lt;/p&gt;
&lt;h5 id=&quot;path装饰器实现&quot;&gt;Path装饰器实现&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt; function Path(baseUrl: string) {
    return function (target) {
        target.prototype.$Meta = {
            baseUrl: baseUrl
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们将RESTful路由存储到类的原型中，以便服务实例化时能获取到。&lt;/p&gt;
&lt;h5 id=&quot;getpostdeleteput&quot;&gt;GET/POST/DELETE/PUT&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;function GET (url: string) =&amp;gt; {
    return (target, methodName: string, descriptor: PropertyDescriptor) =&amp;gt; {
        let meta = getMethod(target, methodName);
        meta.subUrl = url;
        meta.httpMethod = httpMehod;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;queryparampathparam等实现&quot;&gt;QueryParam/PathParam等实现&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;function PahtParam(paramType: string) {
    return function (target, methodName: string, paramIndex: number) {
        let meta = getMethod(target, methodName);
        meta.params.push({
            name: paramName ? paramName : paramType,
            index: paramIndex,
            type: paramType
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述就装饰自身代码，本质上就是讲路由、http请求方法和参数存储到类的原型对象中，以便后续可以去到。&lt;/p&gt;
&lt;h3 id=&quot;注册服务核心代码&quot;&gt;5 注册服务核心代码&lt;/h3&gt;
&lt;h5 id=&quot;路由实现&quot;&gt;路由实现&lt;/h5&gt;
&lt;p&gt;经过上面的分析，我们可知注册服务主要将Express中注册路由交由我们框架处理,核心代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function RegisterService(app, service) {
    let router = Router();

    // 1. 获取存储在原型对象中的http请求信息()
    let meta = getClazz(service.prototype);

    // 2. 实例化服务类
    let serviceInstance = new service();
    let routes = meta.routes;

    for (const methodName in routes) {
        let methodMeta = routes[methodName];
        let httpMethod = methodMeta.httpMethod;

        // 3. 回调函数
        let fn = (req, res, next) =&amp;gt; {
            let result = service.prototype[methodName].apply(serviceInstance, params);
            res.send(result);
        };

        // 4. 注册路由
        router[httpMethod].apply(router, methodMeta.subUrl);
    }
    // 5. 路由中间件
    app.use.apply(app, [meta.baseUrl]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/2776992/34775138-0b038fbc-f64d-11e7-95db-e72548da8064.png&quot; alt=&quot;image 6&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;http请求参数处理&quot;&gt;http请求参数处理&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt; @GET('/:id', [ testMidware1 ])
 list( @PathParam('id') id: string, @QueryParam('name') name: string) {
    return {name:&quot;tom&quot;, age: 10}
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用户编码时我们期望回调函数中的参数框架自动注入，而不是让用户自己从&lt;code&gt;request&lt;/code&gt;中取，所以在注册服务代码中第3处，框架需要出更加参数装饰器中信息，从request中取值后注入回调函数中&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;23&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 3. 回调函数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; params &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;extractParameters&lt;/span&gt;(req&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; res&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; methodMeta[&lt;span class=&quot;st&quot;&gt;'params'&lt;/span&gt;])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; fn &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (req&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; res&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; next) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;service&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;[methodName].&lt;span class=&quot;at&quot;&gt;apply&lt;/span&gt;(serviceInstance&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; params)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;send&lt;/span&gt;(result)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 根据参数类型，从request取出对应的值&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;extractParameters&lt;/span&gt;(req&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; paramMeta) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; paramHandlerTpe &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;'query'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;paramName&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; string) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;req&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;query&lt;/span&gt;[paramName]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;'path'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;paramName&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; string) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;req&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;params&lt;/span&gt;[paramName]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;'form'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;paramName&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; string) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;req&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;body&lt;/span&gt;[paramName]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;'cookie'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;paramName&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; string) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;req&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;cookies&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;req&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;cookies&lt;/span&gt;[paramName]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;'header'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (paramName) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;req&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(paramName)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;'request'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; req&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 获取request/response对象，做一些特别操作&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;'response'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; res&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; args &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;params&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;(param &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;args&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(paramHandlerTpe[&lt;span class=&quot;va&quot;&gt;param&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt;](&lt;span class=&quot;va&quot;&gt;param&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt;))
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; args&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;response处理&quot;&gt;response处理&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;javascript @GET('/:id', [ testMidware1 ]) list( @PathParam('id') id: string, @QueryParam('name') name: string) { return {name:&quot;tom&quot;, age: 10} }&lt;/code&gt;&lt;br/&gt;一个服务处理完成后，总是要向浏览器返回值的，在回调函数中直接使用&lt;code&gt;return&lt;/code&gt;语句，而不是自己调用response.send方法， 如下代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 3. 回调函数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; fn &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (req&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; res&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; next) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;service&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;[methodName].&lt;span class=&quot;at&quot;&gt;apply&lt;/span&gt;(serviceInstance&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; params)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 支持promise处理&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (result &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; Promise) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(value &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;headersSent&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;send&lt;/span&gt;(value)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;catch&lt;/span&gt;(err &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;at&quot;&gt;next&lt;/span&gt;(err)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (result &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;undefined&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;headersSent&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;send&lt;/span&gt;(result)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;总结&quot;&gt;6 总结&lt;/h3&gt;
&lt;p&gt;以上就是我们框架处理核心代码，核心实现主要有两步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;装饰器本身用来存在路由信息&lt;/li&gt;
&lt;li&gt;注册机制实现express路由注册（回调函数参数处理，返回值处理等）&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 24 Jan 2018 12:24:00 +0000</pubDate>
<dc:creator>一箭中的</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/winfred/p/8260885.html</dc:identifier>
</item>
<item>
<title>Vuex初识 - 学习会让你青春永驻</title>
<link>http://www.cnblogs.com/blackgan/p/8343253.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blackgan/p/8343253.html</guid>
<description>&lt;p&gt;vuex是vue中单向数据流的一个状态管理模式，它可以集中存储管理应用中所有组件的状态，并且有一套相应的规则可以去预测数据的变化。类似与此的还有react中的redux,dva等状态管理模式。&lt;/p&gt;
&lt;p&gt;一般我们的状态管理包含以下几个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;state 这是驱动页面变化的数据源&lt;/li&gt;
&lt;li&gt;view state数据展示的视图&lt;/li&gt;
&lt;li&gt;action 在view层用户操作数据变化的响应&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;vue中的数据流为单向数流&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vuex.vuejs.org/zh-cn/images/flow.png&quot; alt=&quot;数据流&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单向数据流在兄弟组件需要传参或者多个组件需要使用同一个状态并且多个组将都可以改变该状态时不易进行维护。&lt;/p&gt;
&lt;p&gt;因此，我们采取的是将多个共用的状态抽离到一个全局单例中（实际上就是将组件的状态抽离出来进行单独管理），其实在redux和dva中，是将每个组件的状态抽离到它自己的单例状态中，并且这些单例状态之间是互通的。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;vuex中数据流的一个大概的流程是，我们再视图层通过触发一个一个的action到mutations中，mutataions中改变对应的state,然后该state的变化会去影响所对应的视图层的html结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然正如其他状态机模式一样，如果你不打算开发大型单页应用，也是没必要去使用vuex。&lt;/p&gt;
&lt;h4 id=&quot;核心概念&quot;&gt;核心概念&lt;/h4&gt;
&lt;p&gt;vuex应用的核心就是store,store中包含着我们应用中的大部分状态，vuex的状态存储是快速响应的，当store中的state有变化时，相应的组件也会快速的更新。并且我们需要遵循vuex中的规则，无法直接去改变state,改变store中的状态的唯一途径就是通过commit.&lt;/p&gt;
&lt;p&gt;通过每次的commit中所含的信息，我们可以轻松明确的去看到我们每次改变state的意图，这样也方便我们将来对数据的追踪。&lt;/p&gt;
&lt;h5 id=&quot;state&quot;&gt;state&lt;/h5&gt;
&lt;p&gt;由于vuex使用单一状态树，也就是一个应用中的state你可以全部放到这一个store中，但是如果你放置的状态过多的时候，这也是挺鸡肋的不是？我还没有去看vuex如何将状态和状态变更的事件分布到各个子模块中去。&lt;/p&gt;
&lt;p&gt;mapState是vuex提供的简化数据访问的辅助函数，mapState函数返回的是一个对象，通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给computed属性。&lt;/p&gt;
&lt;p&gt;当然，使用vuex并不意味着我们将所有的状态放入vuex，虽然将所有的状态放到vuex会使状态变化更显示和易调试，但是如果全部放到了全局Store中我们的代码会变得冗长和不直观，所以这些个东西还需要边开发边权衡吧。&lt;/p&gt;
&lt;h5 id=&quot;getter&quot;&gt;Getter&lt;/h5&gt;
&lt;p&gt;有时候我们需要从store中的state中派生出一些状态，例如对列表进行过滤并计数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;computed&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;doneTodosCount&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;$store&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;todos&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;filter&lt;/span&gt;(todo &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;todo&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;done&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;vuex允许我们在store中定义“getter&quot;.就像计算属性一样，getter返回值会根据他的依赖被缓存起来，且只有当他的依赖值发生了改变才会被重新计算。&lt;/p&gt;
&lt;p&gt;getter接受state作为其第一个参数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; store &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Vuex&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Store&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;todos&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [
      &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'...'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'...'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    ]
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;getters&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;doneTodos&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; state &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;todos&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;filter&lt;/span&gt;(todo &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;todo&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;done&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;getter会暴露store.getters对象：&lt;br/&gt;getter类似于dva中的reducer。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;getters&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;doneTodos&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// -&amp;gt; [{ id: 1, text: '...', done: true }&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;getter也可以接受其他getter作为第二个参数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;getters&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;doneTodosCount&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (state&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; getters) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;getters&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;doneTodos&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;getters&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;doneTodosCount&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// -&amp;gt; 1&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以很容易的在任何组件中调用它：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;computed&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;doneTodosCount&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;$store&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;getters&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;doneTodosCount&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h6 id=&quot;mapgetters辅助函数&quot;&gt;mapGetters辅助函数&lt;/h6&gt;
&lt;p&gt;mapGetters辅助函数仅仅是将store中的getter映射到局部计算属性。&lt;br/&gt;例如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;computed&lt;span class=&quot;op&quot;&gt;:{&lt;/span&gt;
    ...&lt;span class=&quot;at&quot;&gt;mapGetters&lt;/span&gt;([&lt;span class=&quot;st&quot;&gt;'getter1'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'getter2'&lt;/span&gt;])
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照上述写法，全局store中的getter1和getter2函数便可以在局部组件中使用了。&lt;br/&gt;如果想将一个getter属性另取一个名字，使用对象形式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;computed&lt;span class=&quot;op&quot;&gt;:{&lt;/span&gt;
    ...&lt;span class=&quot;at&quot;&gt;mapGetters&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;newGetter&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;oldStoreGetter&quot;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;mutation&quot;&gt;Mutation&lt;/h4&gt;
&lt;p&gt;更改Vuex的store中的状态的唯一办法是提交mutation.Vuex中的mutation非常类似于事件，这有点类似于dva中的effects,每一个mutation都会有一个字符串的事件类型和一个回调函数。这个回调函数就是我们实际进行状态更改的地方。并且他会接受state作为第一个参数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; mutations&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;setAdminInfo&lt;/span&gt;(state&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;adminInfo)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;adminInfo&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; adminInfo&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;setCityList&lt;/span&gt;(state&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;cityList)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;cityList&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; cityList
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然了，我们还不能直接调用mutation handler,我们想要执行此函数时，需要以相应的type调用store.commit方法:&lt;/p&gt;
&lt;p&gt;当我们需要给mutation传参时，我们需要通过payload来进行,上述例子中的adminInfo就是我们要传的的参数，在vuex中叫payload，当然，官方的建议是payload尽量是一个对象，这样我们在使用的时候能够更好的去追踪数据流。&lt;/p&gt;
&lt;p&gt;当然，更好的调用mutation的方式是commit包含type属性的对象：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;commit&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'updateAdminInfo'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;adminInfo&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'allen'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'qwe123'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mutation需要遵守vue的响应规则&lt;/p&gt;
&lt;p&gt;既然Vuex的store中的状态是响应式的，那么当我们变更状态时，监视状态的vue组件也会自动更新。这就意味着Vuex中的mutation也需要与Vue一样遵守一些注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在store中初始化好所有的属性&lt;/li&gt;
&lt;li&gt;使用新对象替换老对象，即每次都返回一个全新的state对象，可以使用Object.Assign的方式。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用常亮替代Mutation事件类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用常量替代mutation事件类型再各种flux实现中是很常见的模式。可以使我们整个项目的数据流向一目了然。&lt;/p&gt;
&lt;p&gt;当然，另外重要的一点就是mutation必须是同步函数，当我们再debug一个app并且观察devtool的mutation日志时，每一条mutation被记录，都需要捕捉到前一状态和后一状态的快照。&lt;/p&gt;
&lt;p&gt;我们可以在组件中使用this.$store.commit(&quot;example&quot;)提交mutation,或者使用mapMutations辅助函数将组件中的methods映射为store.commit调用。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; mapMutations &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'vuex'&lt;/span&gt;

&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    ...&lt;span class=&quot;at&quot;&gt;mapMutations&lt;/span&gt;([
      &lt;span class=&quot;st&quot;&gt;'increment'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 将 `this.increment()` 映射为 `this.$store.commit('increment')`&lt;/span&gt;

      &lt;span class=&quot;co&quot;&gt;// `mapMutations` 也支持载荷：&lt;/span&gt;
      &lt;span class=&quot;st&quot;&gt;'incrementBy'&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`&lt;/span&gt;
    ])&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    ...&lt;span class=&quot;at&quot;&gt;mapMutations&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'increment'&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 将 `this.add()` 映射为 `this.$store.commit('increment')`&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;action&quot;&gt;Action&lt;/h4&gt;
&lt;p&gt;Action类似于mutation,不同在于:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Action提交的是mutation，而不是直接变更状态。&lt;/li&gt;
&lt;li&gt;Action可以包含任意异步操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下边来看一个简单的action的例子：&lt;br/&gt;&lt;code&gt;jsconst store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit('increment') } } }) const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit('increment') } } })&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Action通过store.dispatch方法触发：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;dispatch&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'increment'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用action进行触发mutation可以不用受必须同步执行的约束。我们可以在Action内部执行异步操作。&lt;/p&gt;
&lt;p&gt;同样Action中也可以使用payload来传递参数&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;dispatch&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;increment&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时，Action通常是异步的，store.dispatch可以处理被触发的action的处理函数返回的Promise,并且store.dispatch仍然返回Promise.&lt;/p&gt;
&lt;p&gt;现在，我们已经不需要去执行promise.then函数了，我们直接用async/await就可以了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;async &lt;span class=&quot;at&quot;&gt;action1&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;commit&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;commit&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'gotData'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; await &lt;span class=&quot;at&quot;&gt;getData&lt;/span&gt;())&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;module&quot;&gt;Module&lt;/h3&gt;
&lt;p&gt;使用单一状态树，应用的所有状态会集中到一个比较大的对象中。当应用变得非常复杂时，store对象就会变得十分臃肿。&lt;/p&gt;
&lt;p&gt;vuex允许我们将store分割成模块，每个模块拥有自己的state,mutation,acion,getter,甚至是嵌套子模块，从上至下进行分割。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; moduleA &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; ... &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;mutations&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; ... &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;actions&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; ... &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;getters&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; ... &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; moduleB &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; ... &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;mutations&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; ... &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;actions&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; ... &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; store &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Vuex&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Store&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;modules&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; moduleA&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; moduleB
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)

&lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// -&amp;gt; moduleA 的状态&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// -&amp;gt; moduleB 的状态&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;模块的局部状态&quot;&gt;模块的局部状态&lt;/h5&gt;
&lt;p&gt;对于模块内部的mutation和getter,接受的第一个参数是模块的局部状态对象。同样的，对于模块内部的action，局部状态通过context.state暴露出来，根节点状态则为context.rootState；&lt;/p&gt;
&lt;p&gt;对于模块内部的getter,根节点状态会作为第三个参数暴露出来；&lt;/p&gt;
&lt;h5 id=&quot;命名空间&quot;&gt;命名空间&lt;/h5&gt;
&lt;p&gt;默认情况下，模块内部的action,mutation,和getter是注册再全局命名空间的--这样可以使多个模块能够对同一个mutation或action作出响应。&lt;/p&gt;
&lt;p&gt;当然，模块化中，我们可以使用namespaced:true的方式使其成为命名空间模块。当模块被注册之后，他的所有getter、Action、以及mutation都会自动根据模块注册的路径调整命名。启用了命名空间之后，便是将一个整体的store给分割成了一个个模块。&lt;/p&gt;
&lt;h5 id=&quot;模块动态注册&quot;&gt;模块动态注册&lt;/h5&gt;
&lt;p&gt;在store创建之后，你可以使用store.registerModule方法注册模块：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 注册模块 `myModule`&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;registerModule&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'myModule'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;// 注册嵌套模块 `nested/myModule`&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;registerModule&lt;/span&gt;([&lt;span class=&quot;st&quot;&gt;'nested'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'myModule'&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，我们也可以通过store.unregisterModule（moduleName）来动态卸载模块。但是我们无法使用此方法去卸载静态模块。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Vuex并不限制你的代码结构。但是，他规定了一些需要遵守的规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用层级的状态应该集中到单个store对象中。&lt;/li&gt;
&lt;li&gt;提交mutation是更改状态的唯一办法，并且这个过程是同步的。&lt;/li&gt;
&lt;li&gt;异步逻辑都应该封装在Action里面。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 24 Jan 2018 11:46:00 +0000</pubDate>
<dc:creator>学习会让你青春永驻</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blackgan/p/8343253.html</dc:identifier>
</item>
<item>
<title>Android开发——BroadcastReceiver广播的使用 - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/8331359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/8331359.html</guid>
<description>
&lt;p class=&quot;title&quot;&gt;&lt;span&gt;想要了解广播定义及相关原理的可以看下这一篇&lt;/span&gt;&lt;a href=&quot;https://www.jianshu.com/p/ca3d87a4cdf3&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;BroadcastReceiver史上最全面解析&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;&lt;span&gt;简单地对广播进行分类吧，&lt;strong&gt;广播有两个角色，一个是广播发送者，另外一个是广播接收者&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;广播按照类型分为两种，一种是全局广播，另外一种是本地广播&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全局广播的意思就是发出的广播可以被其他任意的应用程序接收，或者可以接收来自其他任意应用程序的广播。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本地广播则是只能在应用程序的内部进行传递的广播，广播接收器也只能接收内部的广播，不能接受其他应用程序的广播&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;按照广播机制也可以分为两种，标准广播和有序广播&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无序广播：所有的接收者都会接收事件，不可以被拦截，不可以被修改。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有序广播：按照优先级，一级一级的向下传递，接收者可以修改广播数据，也可以终止广播事件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;下面所说的接收广播和发送广播均是针对全局广播来说的，之后会介绍如何使用本地广播&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 使用广播接收器接收广播&lt;/h2&gt;
&lt;h3&gt;1.定义一个广播类&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在开始使用广播之前（也就是接收广播），我们需要定义一个类，使其继承BroadcastReceiver，复写其中的onrecevie方法，onreceieve方法中就是我们想要广播接收器收到广播之后需要处理的操作&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; myreceiver &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BroadcastReceiver {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onReceive(Context context, Intent intent) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里写上相关的处理代码，一般来说，不要此添加过多的逻辑或者是进行任何的耗时操作
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为广播接收器中是不允许开启多线程的，过久的操作就会出现报错
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因此广播接收器更多的是扮演一种打开程序其他组件的角色，比如创建一条状态栏通知，或者启动某个服务&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;h3&gt;&lt;span&gt;&lt;span&gt;2.对广播进行注册&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注册的方式有两种，一种是动态注册（使用java代码），另外一种则是静态注册（在AndroidMainFest文件中定义）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;动态注册的步骤：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;在相关的activity文件中new一个刚才我们定义的广播类&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;new一个intentFilter类，调用其的setAction方法，参数中传入相关值的action&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;调用context.registerReceiver方法进行注册，方法的第一个参数为广播类，第二个则是intentFilter类&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private &lt;span&gt;myreceiver recevier;&lt;br/&gt;&lt;span&gt;private &lt;span&gt;IntentFilter intentFilter;&lt;br/&gt;&lt;span&gt;@Override&lt;br/&gt;&lt;span&gt;protected void &lt;span&gt;onCreate(&lt;span&gt;Bundle savedInstanceState) {&lt;br/&gt;&lt;span&gt;super.&lt;span&gt;onCreate(savedInstanceState);&lt;br/&gt;&lt;span&gt;setContentView(&lt;span&gt;R.layout.&lt;span&gt;activity_main);&lt;br/&gt;&lt;span&gt;recevier = &lt;span&gt;new &lt;span&gt;myreceiver();&lt;br/&gt;&lt;span&gt;intentFilter = &lt;span&gt;new &lt;span&gt;IntentFilter();&lt;br/&gt;&lt;span&gt;intentFilter.&lt;span&gt;addAction(&lt;span&gt;&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);&lt;br/&gt;&lt;span&gt;//当网络发生变化的时候，系统广播会发出值为android.net.conn.CONNECTIVITY_CHANGE这样的一条广播&lt;br/&gt;&lt;span&gt;    &lt;span&gt;registerReceiver(&lt;span&gt;recevier,&lt;span&gt;intentFilter);&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;这里我们将广播类与intentFilter类声明为全局变量，便于之后的注册与注销&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;需要注意的是，动态注册的广播接收器一定要注销，在onDestroy方法中调用&lt;span&gt;unregisterReceiver(&lt;span&gt;recevier);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;静态注册的步骤：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;在AndroidMainFest中的application标签下加上receiver的子标签&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;与&lt;span&gt;&lt;span&gt;通过name属性指定注册一个广播类，也就是我们刚才定义的那个广播类，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;还有enabled与exported属性，enabled代表是否启用这个广播接收器，exported属性表示是否允许这个广播接收器接受本程序以外的广播（这两步可以通过Android Studio自动完成）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;之后在receiver标签下加上intent-filter标签，设置其的action&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;receiver &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;.myreceiver&quot;&lt;/span&gt;&lt;span&gt;
            android:exported&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
            android:enabled&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;intent-filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.intent.action.BOOT_COMPLETED&quot;&amp;gt;&lt;br/&gt;　　　　　　　　　　&lt;/span&gt;&lt;span&gt;//开机完成后系统广播发出的一条值为&lt;span&gt;android.intent.action.BOOT_COMPLETED的广播&lt;/span&gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;intent-filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;receiver&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;PS：使用android studio可以快速实现第二步，操作如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;右键，打开new，选择other，再选择BroadcastReceiver&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201801/1210268-20180124180005084-1529258921.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;classname就是填写之前的那个广播类，默认exported和enabled两个属性都是true，不勾选的话就是false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201801/1210268-20180124180302897-734203032.png&quot; alt=&quot;&quot; width=&quot;960&quot; height=&quot;816&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这个功能就是生成一个广播类，并且为其实现静态注册，当然，就是实现了创建一个广播类与静态注册的前两步，我们还需要完成第三步，填写intent-filter标签中的action的值&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;3.在AndroidMainFest声明相关的权限&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 注册完之后，我们还需要在AndroidMAinFest中声明相关的权限，这个不用多说了，这里贴一张图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201801/1210268-20180124180919819-1096794277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在最后贴张图补充一下关于动态注册与静态注册的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201801/1210268-20180124181046272-915743709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt; 使用广播发送者发送自定义广播&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;前面介绍的是接收广播，这里介绍如何发送自定义广播&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
　　　　　　　　　　Intent intent = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Intent();
                intent.setAction(&lt;/span&gt;&quot;com.example.mymessage&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Intent intent = new Intent(&quot;com,example.mymessage&quot;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;也可以像注释这样写&lt;/span&gt;
                sendBroadcast(intent);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送标准广播&lt;/span&gt;
                sendOrderedBroadcast(intent,&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送有序广播&lt;br/&gt;　　　　　　　　　　&lt;span&gt;//&lt;span&gt;意思就是发送值为com.example.mymessage的这样一条广播&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;之后，我们把intentfilter中的action改为上面的com.example.mymessage可以了，但是，测试的时候我们会发现不能体现出有序广播的定义，我们需要给广播接收器设置一下优先度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果使用的是动态注册，直接调用&lt;span&gt;intentFilter.&lt;span&gt;setPriority();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是静态注册，则是设置intent-fliter的中Priority属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201801/1210268-20180124184205615-1984761711.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优先度的大小设置范围为-1000~1000&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;想要截断广播，只需要在onreceive()方法中调用aboryBroadcast()即可是广播不再传递下去&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;使用本地广播&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;之前所说是属于全局广播，存在有数据安全的问题，使用本地广播，只能在本地应用程序中发送与接收广播，可以起到保护数据安全的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回想一下，之前动态注册广播是通过registerReceiver(receiver，intentFilter)这个方法来注册的，其实，本地广播的使用与其十分类似，之前的步骤均是一样的，就是在后面注册调用的方法不同而已，注册时候调用的是LocalBroadcastManager的registerReceiver方法，之前调用的是context的registerReceiver方法，两者参数就是相同的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201801/1210268-20180124185932147-1951128323.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样的，我们也是需要在onDestory方法中使用localBrocastManager.unregisterReceiver()方法，&lt;span&gt;注意下，图片中我没有把localBroadcastManager定义为全局变量&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发送广播也是类似的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201801/1210268-20180124190658803-1418526134.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;这里需要说一下，使用本地广播并没有静态注册的方法，因为静态注册主要是为了让程序在未启动的情况下也能收到广播，而发动本地广播的时候，我们的程序已经是启动了，所以，自然是没有静态注册这个方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常用的action&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201801/1210268-20180124193127334-2118311592.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 24 Jan 2018 11:14:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kexing/p/8331359.html</dc:identifier>
</item>
<item>
<title>Netty5序章之BIO NIO AIO演变 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/8337234.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/8337234.html</guid>
<description>&lt;p&gt;Netty是一个提供异步事件驱动的网络应用框架，用以快速开发&lt;strong&gt;高性能&lt;/strong&gt;、&lt;strong&gt;高可靠&lt;/strong&gt;的网络服务器和客户端程序。Netty简化了网络程序的开发，是很多框架和公司都在使用的技术。更是面试的加分项。Netty并非横空出世，它是在BIO，NIO，AIO演变中的产物，是一种NIO框架。而BIO，NIO，AIO更是笔试中要考，面试中要问的技术。也是一个很好的加分项，加分就是加工资，你还在等什么？本章带你细细品味三者的不同！&lt;/p&gt;
&lt;p&gt;流程图：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/806956/201801/806956-20180124175433631-1596430754.png&quot; alt=&quot;BIO NIO AIO 流程图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;技术：BIO，NIO，AIO&lt;br/&gt;说明：github上有更全的源码。&lt;br/&gt;源码：&lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/tree/master/Netty/socket-io&quot; class=&quot;uri&quot;&gt;https://github.com/ITDragonBlog/daydayup/tree/master/Netty/socket-io&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;bio&quot;&gt;BIO&lt;/h2&gt;
&lt;p&gt;BIO 全称Block-IO 是一种&lt;strong&gt;阻塞同步&lt;/strong&gt;的通信模式。我们常说的Stock IO 一般指的是BIO。是一个比较传统的通信方式，&lt;strong&gt;模式简单&lt;/strong&gt;，&lt;strong&gt;使用方便&lt;/strong&gt;。但&lt;strong&gt;并发处理能力低&lt;/strong&gt;，&lt;strong&gt;通信耗时&lt;/strong&gt;，&lt;strong&gt;依赖网速&lt;/strong&gt;。&lt;br/&gt;BIO 设计原理：&lt;br/&gt;服务器通过一个Acceptor线程负责监听客户端请求和为每个客户端创建一个新的线程进行链路处理。典型的一请求一应答模式。若客户端数量增多，频繁地创建和销毁线程会给服务器打开很大的压力。后改良为用线程池的方式代替新增线程，被称为伪异步IO。&lt;/p&gt;
&lt;p&gt;服务器提供IP地址和监听的端口，客户端通过TCP的三次握手与服务器连接，连接成功后，双放才能通过套接字(Stock)通信。&lt;br/&gt;小结：&lt;strong&gt;BIO模型中通过Socket和ServerSocket完成套接字通道的实现。阻塞，同步，建立连接耗时&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;BIO服务器代码，负责启动服务，阻塞服务，监听客户端请求，新建线程处理任务。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.io.IOException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.net.ServerSocket;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.net.Socket;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.ArrayBlockingQueue;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.ThreadPoolExecutor;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.TimeUnit;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * IO 也称为 BIO，Block IO 阻塞同步的通讯方式&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 比较传统的技术，实际开发中基本上用Netty或者是AIO。熟悉BIO，NIO，体会其中变化的过程。作为一个web开发人员，stock通讯面试经常问题。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * BIO最大的问题是：阻塞，同步。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * BIO通讯方式很依赖于网络，若网速不好，阻塞时间会很长。每次请求都由程序执行并返回，这是同步的缺陷。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * BIO工作流程：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 第一步：server端服务器启动&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 第二步：server端服务器阻塞监听client请求&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 第三步：server端服务器接收请求，创建线程实现任务&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ITDragonBIOServer {
    
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Integer PORT = &lt;span class=&quot;dv&quot;&gt;8888&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// 服务器对外的端口号  &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {  
        ServerSocket server = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
        Socket socket = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
        ThreadPoolExecutor executor = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
            server = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ServerSocket(PORT); &lt;span class=&quot;co&quot;&gt;// ServerSocket 启动监听端口  &lt;/span&gt;
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;BIO Server 服务器启动.........&quot;&lt;/span&gt;);  
            &lt;span class=&quot;co&quot;&gt;/*--------------传统的新增线程处理----------------*/&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;/*while (true) { &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;                // 服务器监听：阻塞，等待Client请求 &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;                socket = server.accept(); &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;                System.out.println(&quot;server 服务器确认请求 : &quot; + socket); &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;                // 服务器连接确认：确认Client请求后，创建线程执行任务  。很明显的问题，若每接收一次请求就要创建一个线程，显然是不合理的。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;                new Thread(new ITDragonBIOServerHandler(socket)).start(); &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;            } */&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;/*--------------通过线程池处理缓解高并发给程序带来的压力（伪异步IO编程）----------------*/&lt;/span&gt;  
            executor = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;, TimeUnit.&lt;span class=&quot;fu&quot;&gt;SECONDS&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;));  
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;) {  
                socket = server.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;();  &lt;span class=&quot;co&quot;&gt;// 服务器监听：阻塞，等待Client请求 &lt;/span&gt;
                ITDragonBIOServerHandler serverHandler = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonBIOServerHandler&lt;/span&gt;(socket);  
                executor.&lt;span class=&quot;fu&quot;&gt;execute&lt;/span&gt;(serverHandler);  
            }  
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {  
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {  
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; != socket) {  
                  socket.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;(); 
                  socket = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                }  
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; != server) {  
                    server.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();  
                    server = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
                    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;BIO Server 服务器关闭了！！！！&quot;&lt;/span&gt;);  
                }  
                executor.&lt;span class=&quot;fu&quot;&gt;shutdown&lt;/span&gt;();  
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {  
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
            }  
        }  
    }  
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BIO服务端处理任务代码，负责处理Stock套接字，返回套接字给客户端，解耦。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.io.BufferedReader;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.IOException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.InputStreamReader;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.PrintWriter;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.net.Socket;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.util.CalculatorUtil;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ITDragonBIOServerHandler &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Runnable{  
    
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Socket socket;  
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonBIOServerHandler&lt;/span&gt;(Socket socket) {  
      &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt; = socket;  
  }  
  &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
      BufferedReader reader = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
      PrintWriter writer = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
          reader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InputStreamReader(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getInputStream&lt;/span&gt;()));  
          writer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PrintWriter(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getOutputStream&lt;/span&gt;(), &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);  
          String body = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
          &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;) {  
              body = reader.&lt;span class=&quot;fu&quot;&gt;readLine&lt;/span&gt;(); &lt;span class=&quot;co&quot;&gt;// 若客户端用的是 writer.print() 传值，那readerLine() 是不能获取值，细节  &lt;/span&gt;
              &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; == body) {  
                  &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;  
              }  
              System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;server服务端接收参数 : &quot;&lt;/span&gt; + body);  
              writer.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(body + &lt;span class=&quot;st&quot;&gt;&quot; = &quot;&lt;/span&gt; + CalculatorUtil.&lt;span class=&quot;fu&quot;&gt;cal&lt;/span&gt;(body).&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;());
          }  
      } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {  
          e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
      } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {  
          &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; != writer) {  
              writer.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();  
          }  
          &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
              &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; != reader) {  
                  reader.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();  
              }  
              &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; != &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;) {  
                  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();  
                  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
              }  
          } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {  
              e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
          }  
      }  
  }  
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BIO客户端代码，负责启动客户端，向服务器发送请求，接收服务器返回的Stock套接字。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.io.BufferedReader;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.IOException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.InputStreamReader;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.PrintWriter;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.net.Socket;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Random;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * BIO 客户端&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Socket :         向服务端发送连接&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * PrintWriter :    向服务端传递参数&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * BufferedReader : 从服务端接收参数&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ITDragonBIOClient {
    
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Integer PORT = &lt;span class=&quot;dv&quot;&gt;8888&lt;/span&gt;;  
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String IP_ADDRESS = &lt;span class=&quot;st&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;;  
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {  
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;; i++) {  
            &lt;span class=&quot;fu&quot;&gt;clientReq&lt;/span&gt;(i);  
        }  
    }  
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;clientReq&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i) {  
        Socket socket = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
        BufferedReader reader = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
        PrintWriter writer = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
            socket = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Socket(IP_ADDRESS, PORT); &lt;span class=&quot;co&quot;&gt;// Socket 发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信  &lt;/span&gt;
            reader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InputStreamReader(socket.&lt;span class=&quot;fu&quot;&gt;getInputStream&lt;/span&gt;())); &lt;span class=&quot;co&quot;&gt;// 获取返回内容  &lt;/span&gt;
            writer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PrintWriter(socket.&lt;span class=&quot;fu&quot;&gt;getOutputStream&lt;/span&gt;(), &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);  
            String []operators = {&lt;span class=&quot;st&quot;&gt;&quot;+&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;-&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;*&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;};
            Random random = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Random(System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;());  
            String expression = random.&lt;span class=&quot;fu&quot;&gt;nextInt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)+operators[random.&lt;span class=&quot;fu&quot;&gt;nextInt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)]+(random.&lt;span class=&quot;fu&quot;&gt;nextInt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)+&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
            writer.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(expression); &lt;span class=&quot;co&quot;&gt;// 向服务器端发送数据  &lt;/span&gt;
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(i + &lt;span class=&quot;st&quot;&gt;&quot; 客户端打印返回数据 : &quot;&lt;/span&gt; + reader.&lt;span class=&quot;fu&quot;&gt;readLine&lt;/span&gt;());  
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {  
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {  
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; != reader) {  
                    reader.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();  
                }  
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; != socket) {  
                    socket.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();  
                    socket = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
                }  
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {  
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
            }  
        }  
    }  
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;nio&quot;&gt;NIO&lt;/h2&gt;
&lt;p&gt;NIO 全称New IO，也叫Non-Block IO 是一种&lt;strong&gt;非阻塞同步&lt;/strong&gt;的通信模式。&lt;br/&gt;NIO 设计原理：&lt;br/&gt;NIO 相对于BIO来说一大进步。客户端和服务器之间通过Channel通信。NIO可以在Channel进行读写操作。这些Channel都会被注册在Selector多路复用器上。Selector通过一个线程不停的轮询这些Channel。找出已经准备就绪的Channel执行IO操作。&lt;br/&gt;NIO 通过一个线程轮询，实现千万个客户端的请求，这就是非阻塞NIO的特点。&lt;br/&gt;1）&lt;strong&gt;缓冲区Buffer&lt;/strong&gt;：它是NIO与BIO的一个重要区别。BIO是将数据直接写入或读取到Stream对象中。而NIO的数据操作都是在缓冲区中进行的。缓冲区实际上是一个数组。Buffer最常见的类型是ByteBuffer，另外还有CharBuffer，ShortBuffer，IntBuffer，LongBuffer，FloatBuffer，DoubleBuffer。&lt;br/&gt;2）&lt;strong&gt;通道Channel&lt;/strong&gt;：和流不同，通道是双向的。NIO可以通过Channel进行数据的读，写和同时读写操作。通道分为两大类：一类是网络读写（SelectableChannel），一类是用于文件操作（FileChannel），我们使用的SocketChannel和ServerSocketChannel都是SelectableChannel的子类。&lt;br/&gt;3）&lt;strong&gt;多路复用器Selector&lt;/strong&gt;：NIO编程的基础。多路复用器提供选择已经就绪的任务的能力。就是Selector会不断地轮询注册在其上的通道（Channel），如果某个通道处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以取得就绪的Channel集合，从而进行后续的IO操作。服务器端只要提供一个线程负责Selector的轮询，就可以接入成千上万个客户端，这就是JDK NIO库的巨大进步。&lt;/p&gt;
&lt;p&gt;说明：这里的代码只实现了客户端发送请求，服务端接收数据的功能。其目的是简化代码，方便理解。github源码中有完整代码。&lt;br/&gt;小结：&lt;strong&gt;NIO模型中通过SocketChannel和ServerSocketChannel完成套接字通道的实现。非阻塞/阻塞，同步，避免TCP建立连接使用三次握手带来的开销。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NIO服务器代码，负责开启多路复用器，打开通道，注册通道，轮询通道，处理通道。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.io.IOException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.net.InetSocketAddress;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.nio.ByteBuffer;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.nio.channels.SelectionKey;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.nio.channels.Selector;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.nio.channels.ServerSocketChannel;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.nio.channels.SocketChannel;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Iterator;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * NIO 也称 New IO， Non-Block IO，非阻塞同步通信方式&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 从BIO的阻塞到NIO的非阻塞，这是一大进步。功归于Buffer，Channel，Selector三个设计实现。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Buffer   ：  缓冲区。NIO的数据操作都是在缓冲区中进行。缓冲区实际上是一个数组。而BIO是将数据直接写入或读取到Stream对象。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Channel  ：  通道。NIO可以通过Channel进行数据的读，写和同时读写操作。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Selector ：  多路复用器。NIO编程的基础。多路复用器提供选择已经就绪状态任务的能力。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 客户端和服务器通过Channel连接，而这些Channel都要注册在Selector。Selector通过一个线程不停的轮询这些Channel。找出已经准备就绪的Channel执行IO操作。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * NIO通过一个线程轮询，实现千万个客户端的请求，这就是非阻塞NIO的特点。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ITDragonNIOServer &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Runnable{  
    
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; BUFFER_SIZE = &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// 缓冲区大小  &lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; PORT = &lt;span class=&quot;dv&quot;&gt;8888&lt;/span&gt;;        &lt;span class=&quot;co&quot;&gt;// 监听的端口  &lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Selector selector;            &lt;span class=&quot;co&quot;&gt;// 多路复用器，NIO编程的基础，负责管理通道Channel &lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ByteBuffer readBuffer = ByteBuffer.&lt;span class=&quot;fu&quot;&gt;allocate&lt;/span&gt;(BUFFER_SIZE);  &lt;span class=&quot;co&quot;&gt;// 缓冲区Buffer  &lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonNIOServer&lt;/span&gt;() {  
      &lt;span class=&quot;fu&quot;&gt;startServer&lt;/span&gt;();  
  }  
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;startServer&lt;/span&gt;() {  
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
          &lt;span class=&quot;co&quot;&gt;// 1.开启多路复用器  &lt;/span&gt;
          selector = Selector.&lt;span class=&quot;fu&quot;&gt;open&lt;/span&gt;();  
          &lt;span class=&quot;co&quot;&gt;// 2.打开服务器通道(网络读写通道)  &lt;/span&gt;
          ServerSocketChannel channel = ServerSocketChannel.&lt;span class=&quot;fu&quot;&gt;open&lt;/span&gt;();  
          &lt;span class=&quot;co&quot;&gt;// 3.设置服务器通道为非阻塞模式，true为阻塞，false为非阻塞  &lt;/span&gt;
          channel.&lt;span class=&quot;fu&quot;&gt;configureBlocking&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);  
          &lt;span class=&quot;co&quot;&gt;// 4.绑定端口  &lt;/span&gt;
          channel.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;bind&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InetSocketAddress(PORT));  
          &lt;span class=&quot;co&quot;&gt;// 5.把通道注册到多路复用器上，并监听阻塞事件  &lt;/span&gt;
          &lt;span class=&quot;co&quot;&gt;/** &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           * SelectionKey.OP_READ   : 表示关注读数据就绪事件  &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           * SelectionKey.OP_WRITE  : 表示关注写数据就绪事件  &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           * SelectionKey.OP_CONNECT: 表示关注socket channel的连接完成事件  &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           * SelectionKey.OP_ACCEPT : 表示关注server-socket channel的accept事件  &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;           */&lt;/span&gt;  
          channel.&lt;span class=&quot;fu&quot;&gt;register&lt;/span&gt;(selector, SelectionKey.&lt;span class=&quot;fu&quot;&gt;OP_ACCEPT&lt;/span&gt;);  
          System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Server start &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; port :&quot;&lt;/span&gt; + PORT);  
      } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {  
          e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
      }  
  }  
  &lt;span class=&quot;co&quot;&gt;// 需要一个线程负责Selector的轮询  &lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
      &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;) {  
          &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
              &lt;span class=&quot;co&quot;&gt;/** &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;               * a.select() 阻塞到至少有一个通道在你注册的事件上就绪  &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;               * b.select(long timeOut) 阻塞到至少有一个通道在你注册的事件上就绪或者超时timeOut &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;               * c.selectNow() 立即返回。如果没有就绪的通道则返回0  &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;               * select方法的返回值表示就绪通道的个数。 &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;               */&lt;/span&gt;  
              &lt;span class=&quot;co&quot;&gt;// 1.多路复用器监听阻塞  &lt;/span&gt;
              selector.&lt;span class=&quot;fu&quot;&gt;select&lt;/span&gt;();  
              &lt;span class=&quot;co&quot;&gt;// 2.多路复用器已经选择的结果集  &lt;/span&gt;
              Iterator&amp;lt;SelectionKey&amp;gt; selectionKeys = selector.&lt;span class=&quot;fu&quot;&gt;selectedKeys&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;iterator&lt;/span&gt;();  
              &lt;span class=&quot;co&quot;&gt;// 3.不停的轮询  &lt;/span&gt;
              &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (selectionKeys.&lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;()) {  
                  &lt;span class=&quot;co&quot;&gt;// 4.获取一个选中的key  &lt;/span&gt;
                  SelectionKey key = selectionKeys.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;();  
                  &lt;span class=&quot;co&quot;&gt;// 5.获取后便将其从容器中移除  &lt;/span&gt;
                  selectionKeys.&lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;();  
                  &lt;span class=&quot;co&quot;&gt;// 6.只获取有效的key  &lt;/span&gt;
                  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!key.&lt;span class=&quot;fu&quot;&gt;isValid&lt;/span&gt;()){  
                      &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;;  
                  }  
                  &lt;span class=&quot;co&quot;&gt;// 阻塞状态处理  &lt;/span&gt;
                  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (key.&lt;span class=&quot;fu&quot;&gt;isAcceptable&lt;/span&gt;()){  
                      &lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;(key);  
                  }  
                  &lt;span class=&quot;co&quot;&gt;// 可读状态处理  &lt;/span&gt;
                  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (key.&lt;span class=&quot;fu&quot;&gt;isReadable&lt;/span&gt;()){  
                      &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(key);  
                  }  
              }  
          } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {  
              e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
          }  
      }  
  }  
  &lt;span class=&quot;co&quot;&gt;// 设置阻塞，等待Client请求。在传统IO编程中，用的是ServerSocket和Socket。在NIO中采用的ServerSocketChannel和SocketChannel  &lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;(SelectionKey selectionKey) {  
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
          &lt;span class=&quot;co&quot;&gt;// 1.获取通道服务  &lt;/span&gt;
          ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.&lt;span class=&quot;fu&quot;&gt;channel&lt;/span&gt;();  
          &lt;span class=&quot;co&quot;&gt;// 2.执行阻塞方法  &lt;/span&gt;
          SocketChannel socketChannel = serverSocketChannel.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;();  
          &lt;span class=&quot;co&quot;&gt;// 3.设置服务器通道为非阻塞模式，true为阻塞，false为非阻塞  &lt;/span&gt;
          socketChannel.&lt;span class=&quot;fu&quot;&gt;configureBlocking&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);  
          &lt;span class=&quot;co&quot;&gt;// 4.把通道注册到多路复用器上，并设置读取标识  &lt;/span&gt;
          socketChannel.&lt;span class=&quot;fu&quot;&gt;register&lt;/span&gt;(selector, SelectionKey.&lt;span class=&quot;fu&quot;&gt;OP_READ&lt;/span&gt;);  
      } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {  
          e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
      }  
  }  
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(SelectionKey selectionKey) {  
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
          &lt;span class=&quot;co&quot;&gt;// 1.清空缓冲区数据  &lt;/span&gt;
          readBuffer.&lt;span class=&quot;fu&quot;&gt;clear&lt;/span&gt;();  
          &lt;span class=&quot;co&quot;&gt;// 2.获取在多路复用器上注册的通道  &lt;/span&gt;
          SocketChannel socketChannel = (SocketChannel) selectionKey.&lt;span class=&quot;fu&quot;&gt;channel&lt;/span&gt;();  
          &lt;span class=&quot;co&quot;&gt;// 3.读取数据，返回  &lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count = socketChannel.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(readBuffer);  
          &lt;span class=&quot;co&quot;&gt;// 4.返回内容为-1 表示没有数据  &lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; == count) {  
              selectionKey.&lt;span class=&quot;fu&quot;&gt;channel&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();  
              selectionKey.&lt;span class=&quot;fu&quot;&gt;cancel&lt;/span&gt;();  
              &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ;  
          }  
          &lt;span class=&quot;co&quot;&gt;// 5.有数据则在读取数据前进行复位操作  &lt;/span&gt;
          readBuffer.&lt;span class=&quot;fu&quot;&gt;flip&lt;/span&gt;();  
          &lt;span class=&quot;co&quot;&gt;// 6.根据缓冲区大小创建一个相应大小的bytes数组，用来获取值  &lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] bytes = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[readBuffer.&lt;span class=&quot;fu&quot;&gt;remaining&lt;/span&gt;()];  
          &lt;span class=&quot;co&quot;&gt;// 7.接收缓冲区数据  &lt;/span&gt;
          readBuffer.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(bytes);  
          &lt;span class=&quot;co&quot;&gt;// 8.打印获取到的数据  &lt;/span&gt;
          System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;NIO Server : &quot;&lt;/span&gt; + &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(bytes)); &lt;span class=&quot;co&quot;&gt;// 不能用bytes.toString()  &lt;/span&gt;
      } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {  
          e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
      }  
  }  
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {  
      &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonNIOServer&lt;/span&gt;()).&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();  
  } 
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;NIO客户端代码，负责连接服务器，声明通道，连接通道&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.io.IOException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.net.InetSocketAddress;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.nio.ByteBuffer;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.nio.channels.SocketChannel;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ITDragonNIOClient {
    
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; PORT = &lt;span class=&quot;dv&quot;&gt;8888&lt;/span&gt;;  
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; BUFFER_SIZE = &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt;;  
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String IP_ADDRESS = &lt;span class=&quot;st&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;;  
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {  
        &lt;span class=&quot;fu&quot;&gt;clientReq&lt;/span&gt;();
    }  
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;clientReq&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// 1.创建连接地址  &lt;/span&gt;
        InetSocketAddress inetSocketAddress = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InetSocketAddress(IP_ADDRESS, PORT);  
        &lt;span class=&quot;co&quot;&gt;// 2.声明一个连接通道  &lt;/span&gt;
        SocketChannel socketChannel = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
        &lt;span class=&quot;co&quot;&gt;// 3.创建一个缓冲区  &lt;/span&gt;
        ByteBuffer byteBuffer = ByteBuffer.&lt;span class=&quot;fu&quot;&gt;allocate&lt;/span&gt;(BUFFER_SIZE);  
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
            &lt;span class=&quot;co&quot;&gt;// 4.打开通道  &lt;/span&gt;
            socketChannel = SocketChannel.&lt;span class=&quot;fu&quot;&gt;open&lt;/span&gt;();  
            &lt;span class=&quot;co&quot;&gt;// 5.连接服务器  &lt;/span&gt;
            socketChannel.&lt;span class=&quot;fu&quot;&gt;connect&lt;/span&gt;(inetSocketAddress);  
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;){  
                &lt;span class=&quot;co&quot;&gt;// 6.定义一个字节数组，然后使用系统录入功能：  &lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] bytes = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[BUFFER_SIZE];  
                &lt;span class=&quot;co&quot;&gt;// 7.键盘输入数据  &lt;/span&gt;
                System.&lt;span class=&quot;fu&quot;&gt;in&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(bytes);  
                &lt;span class=&quot;co&quot;&gt;// 8.把数据放到缓冲区中  &lt;/span&gt;
                byteBuffer.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(bytes);  
                &lt;span class=&quot;co&quot;&gt;// 9.对缓冲区进行复位  &lt;/span&gt;
                byteBuffer.&lt;span class=&quot;fu&quot;&gt;flip&lt;/span&gt;();  
                &lt;span class=&quot;co&quot;&gt;// 10.写出数据  &lt;/span&gt;
                socketChannel.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(byteBuffer);  
                &lt;span class=&quot;co&quot;&gt;// 11.清空缓冲区数据  &lt;/span&gt;
                byteBuffer.&lt;span class=&quot;fu&quot;&gt;clear&lt;/span&gt;();  
            }  
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {  
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {  
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; != socketChannel) {  
                &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
                    socketChannel.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();  
                } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {  
                    e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
                }  
            }  
        } 
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;aio&quot;&gt;AIO&lt;/h2&gt;
&lt;p&gt;AIO 也叫NIO2.0 是一种&lt;strong&gt;非阻塞异步&lt;/strong&gt;的通信模式。在NIO的基础上引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。&lt;br/&gt;AIO 并没有采用NIO的多路复用器，而是使用异步通道的概念。其read，write方法的返回类型都是Future对象。而Future模型是异步的，其核心思想是：去主函数等待时间。&lt;/p&gt;
&lt;p&gt;小结：&lt;strong&gt;AIO模型中通过AsynchronousSocketChannel和AsynchronousServerSocketChannel完成套接字通道的实现。非阻塞，异步&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;AIO服务端代码，负责创建服务器通道，绑定端口，等待请求。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.net.InetSocketAddress;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.nio.channels.AsynchronousChannelGroup;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.nio.channels.AsynchronousServerSocketChannel;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.ExecutorService;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.Executors;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * AIO, 也叫 NIO2.0 是一种异步非阻塞的通信方式&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * AIO 引入了异步通道的概念 AsynchronousServerSocketChannel和AsynchronousSocketChannel 其read和write方法返回值类型是Future对象。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ITDragonAIOServer {
      
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ExecutorService executorService;        &lt;span class=&quot;co&quot;&gt;// 线程池&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; AsynchronousChannelGroup threadGroup;   &lt;span class=&quot;co&quot;&gt;// 通道组&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; AsynchronousServerSocketChannel asynServerSocketChannel;  &lt;span class=&quot;co&quot;&gt;// 服务器通道 &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;(Integer port){  
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
            &lt;span class=&quot;co&quot;&gt;// 1.创建一个缓存池  &lt;/span&gt;
            executorService = Executors.&lt;span class=&quot;fu&quot;&gt;newCachedThreadPool&lt;/span&gt;();  
            &lt;span class=&quot;co&quot;&gt;// 2.创建通道组  &lt;/span&gt;
            threadGroup = AsynchronousChannelGroup.&lt;span class=&quot;fu&quot;&gt;withCachedThreadPool&lt;/span&gt;(executorService, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);  
            &lt;span class=&quot;co&quot;&gt;// 3.创建服务器通道  &lt;/span&gt;
            asynServerSocketChannel = AsynchronousServerSocketChannel.&lt;span class=&quot;fu&quot;&gt;open&lt;/span&gt;(threadGroup);  
            &lt;span class=&quot;co&quot;&gt;// 4.进行绑定  &lt;/span&gt;
            asynServerSocketChannel.&lt;span class=&quot;fu&quot;&gt;bind&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InetSocketAddress(port));  
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;server start , port : &quot;&lt;/span&gt; + port);  
            &lt;span class=&quot;co&quot;&gt;// 5.等待客户端请求  &lt;/span&gt;
            asynServerSocketChannel.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonAIOServerHandler&lt;/span&gt;());  
            &lt;span class=&quot;co&quot;&gt;// 一直阻塞 不让服务器停止，真实环境是在tomcat下运行，所以不需要这行代码  &lt;/span&gt;
            Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(Integer.&lt;span class=&quot;fu&quot;&gt;MAX_VALUE&lt;/span&gt;);  
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {  
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
        }  
    }  
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {  
        ITDragonAIOServer server = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonAIOServer&lt;/span&gt;();  
        server.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;8888&lt;/span&gt;);  
    }  
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AIO服务器任务处理代码，负责，读取数据，写入数据&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.nio.ByteBuffer;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.nio.channels.AsynchronousSocketChannel;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.nio.channels.CompletionHandler;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.ExecutionException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.util.CalculatorUtil;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ITDragonAIOServerHandler &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; CompletionHandler&amp;lt;AsynchronousSocketChannel, ITDragonAIOServer&amp;gt; {  
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Integer BUFFER_SIZE = &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt;;  
  &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;completed&lt;/span&gt;(AsynchronousSocketChannel asynSocketChannel, ITDragonAIOServer attachment) {  
      &lt;span class=&quot;co&quot;&gt;// 保证多个客户端都可以阻塞  &lt;/span&gt;
      attachment.&lt;span class=&quot;fu&quot;&gt;asynServerSocketChannel&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;(attachment, &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);  
      &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(asynSocketChannel);  
  }  
  &lt;span class=&quot;co&quot;&gt;//读取数据  &lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; AsynchronousSocketChannel asynSocketChannel) {  
      ByteBuffer byteBuffer = ByteBuffer.&lt;span class=&quot;fu&quot;&gt;allocate&lt;/span&gt;(BUFFER_SIZE);  
      asynSocketChannel.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(byteBuffer, byteBuffer, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; CompletionHandler&amp;lt;Integer, ByteBuffer&amp;gt;() {  
          &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
          &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;completed&lt;/span&gt;(Integer resultSize, ByteBuffer attachment) {  
              &lt;span class=&quot;co&quot;&gt;//进行读取之后,重置标识位  &lt;/span&gt;
              attachment.&lt;span class=&quot;fu&quot;&gt;flip&lt;/span&gt;();  
              &lt;span class=&quot;co&quot;&gt;//获取读取的数据  &lt;/span&gt;
              String resultData = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(attachment.&lt;span class=&quot;fu&quot;&gt;array&lt;/span&gt;()).&lt;span class=&quot;fu&quot;&gt;trim&lt;/span&gt;();  
              System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Server -&amp;gt; &quot;&lt;/span&gt; + &lt;span class=&quot;st&quot;&gt;&quot;收到客户端的数据信息为:&quot;&lt;/span&gt; + resultData);  
              String response = resultData + &lt;span class=&quot;st&quot;&gt;&quot; = &quot;&lt;/span&gt; + CalculatorUtil.&lt;span class=&quot;fu&quot;&gt;cal&lt;/span&gt;(resultData);  
              &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(asynSocketChannel, response);  
          }  
          &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
          &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;failed&lt;/span&gt;(Throwable exc, ByteBuffer attachment) {  
              exc.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
          }  
      });  
  }  
  &lt;span class=&quot;co&quot;&gt;// 写入数据&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(AsynchronousSocketChannel asynSocketChannel, String response) {  
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
          &lt;span class=&quot;co&quot;&gt;// 把数据写入到缓冲区中  &lt;/span&gt;
          ByteBuffer buf = ByteBuffer.&lt;span class=&quot;fu&quot;&gt;allocate&lt;/span&gt;(BUFFER_SIZE);  
          buf.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(response.&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;());  
          buf.&lt;span class=&quot;fu&quot;&gt;flip&lt;/span&gt;();  
          &lt;span class=&quot;co&quot;&gt;// 在从缓冲区写入到通道中  &lt;/span&gt;
          asynSocketChannel.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(buf).&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();  
      } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {  
          e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
      } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ExecutionException e) {  
          e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
      }  
  }  
  &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;failed&lt;/span&gt;(Throwable exc, ITDragonAIOServer attachment) {  
      exc.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
  }  
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AIO客户端代码，负责连接服务器，声明通道，连接通道&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.net.InetSocketAddress;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.nio.ByteBuffer;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.nio.channels.AsynchronousSocketChannel;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Random;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ITDragonAIOClient &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Runnable{  
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Integer PORT = &lt;span class=&quot;dv&quot;&gt;8888&lt;/span&gt;;  
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String IP_ADDRESS = &lt;span class=&quot;st&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; AsynchronousSocketChannel asynSocketChannel ;  
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonAIOClient&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {  
        asynSocketChannel = AsynchronousSocketChannel.&lt;span class=&quot;fu&quot;&gt;open&lt;/span&gt;();  &lt;span class=&quot;co&quot;&gt;// 打开通道  &lt;/span&gt;
    }  
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;connect&lt;/span&gt;(){  
        asynSocketChannel.&lt;span class=&quot;fu&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InetSocketAddress(IP_ADDRESS, PORT));  &lt;span class=&quot;co&quot;&gt;// 创建连接 和NIO一样  &lt;/span&gt;
    }  
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(String request){  
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
            asynSocketChannel.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(ByteBuffer.&lt;span class=&quot;fu&quot;&gt;wrap&lt;/span&gt;(request.&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;())).&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();  
            ByteBuffer byteBuffer = ByteBuffer.&lt;span class=&quot;fu&quot;&gt;allocate&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt;);  
            asynSocketChannel.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(byteBuffer).&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();  
            byteBuffer.&lt;span class=&quot;fu&quot;&gt;flip&lt;/span&gt;();  
            &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] respByte = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[byteBuffer.&lt;span class=&quot;fu&quot;&gt;remaining&lt;/span&gt;()];  
            byteBuffer.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(respByte); &lt;span class=&quot;co&quot;&gt;// 将缓冲区的数据放入到 byte数组中  &lt;/span&gt;
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(respByte,&lt;span class=&quot;st&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;trim&lt;/span&gt;());  
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {  
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
        }  
    }  
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;){  
        }  
    }  
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {  
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;; i++) {
            ITDragonAIOClient myClient = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonAIOClient&lt;/span&gt;();  
            myClient.&lt;span class=&quot;fu&quot;&gt;connect&lt;/span&gt;();  
            &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(myClient, &lt;span class=&quot;st&quot;&gt;&quot;myClient&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;(); 
            String []operators = {&lt;span class=&quot;st&quot;&gt;&quot;+&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;-&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;*&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;};
            Random random = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Random(System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;());  
            String expression = random.&lt;span class=&quot;fu&quot;&gt;nextInt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)+operators[random.&lt;span class=&quot;fu&quot;&gt;nextInt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)]+(random.&lt;span class=&quot;fu&quot;&gt;nextInt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)+&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
            myClient.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(expression);  
        }
    }  
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;常见面试题&quot;&gt;常见面试题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1 IO，NIO，AIO区别&lt;/strong&gt;&lt;br/&gt;IO 阻塞同步通信模式，客户端和服务器连接需要三次握手，使用简单，但吞吐量小&lt;br/&gt;NIO 非阻塞同步通信模式，客户端与服务器通过Channel连接，采用多路复用器轮询注册的Channel。提高吞吐量和可靠性。&lt;br/&gt;AIO 非阻塞异步通信模式，NIO的升级版，采用异步通道实现异步通信，其read和write方法均是异步方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 Stock通信的伪代码实现流程&lt;/strong&gt;&lt;br/&gt;服务器绑定端口：server = new ServerSocket(PORT)&lt;br/&gt;服务器阻塞监听：socket = server.accept()&lt;br/&gt;服务器开启线程：new Thread(Handle handle)&lt;br/&gt;服务器读写数据：BufferedReader PrintWriter&lt;br/&gt;客户端绑定IP和PORT：new Socket(IP_ADDRESS, PORT)&lt;br/&gt;客户端传输接收数据：BufferedReader PrintWriter&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3 TCP协议与UDP协议有什么区别&lt;/strong&gt;&lt;br/&gt;TCP : 传输控制协议是基于连接的协议，在正式收发数据前，必须和对方建立可靠的连接。速度慢，合适传输大量数据。&lt;br/&gt;UDP : 用户数据报协议是与TCP相对应的协议。面向非连接的协议，不与对方建立连接，而是直接就把数据包发送过去，速度快，适合传输少量数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4 什么是同步阻塞BIO，同步非阻塞NIO，异步非阻塞AIO&lt;/strong&gt;&lt;br/&gt;同步阻塞IO : 用户进程发起一个IO操作以后，必须等待IO操作的真正完成后，才能继续运行。&lt;br/&gt;同步非阻塞IO: 用户进程发起一个IO操作以后，可做其它事情，但用户进程需要经常询问IO操作是否完成，这样造成不必要的CPU资源浪费。&lt;br/&gt;异步非阻塞IO: 用户进程发起一个IO操作然后，立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知。类比Future模式。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;1 BIO模型中通过&lt;strong&gt;Socket&lt;/strong&gt;和&lt;strong&gt;ServerSocket&lt;/strong&gt;完成套接字通道实现。阻塞，同步，连接耗时。&lt;br/&gt;2 NIO模型中通过&lt;strong&gt;SocketChannel&lt;/strong&gt;和&lt;strong&gt;ServerSocketChannel&lt;/strong&gt;完成套接字通道实现。非阻塞/阻塞，同步，避免TCP建立连接使用三次握手带来的开销。&lt;br/&gt;3 AIO模型中通过&lt;strong&gt;AsynchronousSocketChannel&lt;/strong&gt;和&lt;strong&gt;AsynchronousServerSocketChannel&lt;/strong&gt;完成套接字通道实现。非阻塞，异步。&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/806956/201801/806956-20180124173405319-1569806904.png&quot; alt=&quot;BIO NIO AIO 对比&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里BIO，NIO，AIO的知识点就梳理完了。下一章是Netty5的入门 编解码 数据通信知识。如果觉得不错可以点个&lt;strong&gt;&quot;推荐&quot;&lt;/strong&gt;。也可以&lt;strong&gt;&quot;关注&quot;&lt;/strong&gt;我，一起学习，一起成长。正常情况一周一更。学习方向是JAVA架构师。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 10:32:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/8337234.html</dc:identifier>
</item>
</channel>
</rss>