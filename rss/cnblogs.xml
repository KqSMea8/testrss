<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C#语言支持的特性，.NET却不支持，那么C#被.NET支持的部分又是如何在.NET上运行的呢？ - junlu</title>
<link>http://www.cnblogs.com/junlu/p/7789966.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/junlu/p/7789966.html</guid>
<description>&lt;p&gt;阅读《C#高级编程》系列丛书中，介绍C#与.NET的关系，提到C#是语言，.NET是平台（C#不是.NET的一部分），说”.NET支持的一些特性，C#并不支持“，这个可以理解，因为C#只是.NET平台支持的语言中的一种，并且.NET可以直接编写IL程序；但是又说”C#支持的一些特性，.NET并不支持“，这我就不理解，因为C#只能在.NET平台上运行，那C#支持的特性，.NET上不支持，程序是怎么运行的呢？求解！&lt;/p&gt;
</description>
<pubDate>Sun, 05 Nov 2017 15:35:00 +0000</pubDate>
<dc:creator>junlu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/junlu/p/7789966.html</dc:identifier>
</item>
<item>
<title>哈哈，原来这叫做“松鼠症”……并谈谈我建议的学习方法 - 自由飞</title>
<link>http://www.cnblogs.com/freeflying/p/7725385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeflying/p/7725385.html</guid>
<description>&lt;p&gt;&lt;span&gt;好几天前在QQ群里有同学要我给一个技术栈，我没给，告诉他那玩意儿没用。第二天他就给了我一个链接，园子里的&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/1996V/p/7700087.html&quot;&gt;.Net Web开发技术栈&lt;/a&gt;，我看到的时候已有102个赞。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“啪啪啪”打脸，&lt;span&gt;/(ㄒoㄒ)/~~&lt;/span&gt;，突然觉得心好累……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而，我始终觉得哪里不对劲？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这其实不是个例。你在知乎搜索“如何学习xxx”的问题，看看高票答案，好多好多的都是一串一串的书单，或者一版一版的网址，以前我其实有点奇怪为什么？为什么这样的回答能得到这么多的赞呢？当然，答主的劳动值得肯定，他付出了大量的时间和精力来收集整理；然而，注意这个然而，同样有很多“答主付出了大量时间和精力”的答案无人问津啊？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一定有什么原因的！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哦，对了，除了那么多的赞以外，更多的是“收藏”。收藏的含义应该就是收藏起来我以后慢慢看——好了，我突然灵光一闪：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;收藏起来的那些东西，后来你都真的看了么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/49387/201710/49387-20171026163547976-1881733008.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以啊！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我想起了我的一些事。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;那时候学英语，练听力，他们说《老友记》不错，谁谁谁哪个学渣把它怎么怎么翻来覆去看了n遍，然后就华丽丽的变身学霸，从此看原版不用字幕，一口纯正的曼哈顿口音把老外唬得一愣一愣的……&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是我就像打了鸡血一样，到网上疯了一样的找《老友记》，一定不能要带字幕的，但又一定要有字幕脚本，从第一季第一集到第七季最后一集，一集都不能落下！为此还专门买了一个刻录机……等等，关刻录机什么事？哦，我担心硬盘会坏掉呀！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上，你肯定猜到了，硬盘没坏，是我的脑子坏掉了：我连第一季都没看完。还看了多少遍！还担心什么把硬盘看坏掉？！天啊！为什么我会这么天真？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/49387/201710/49387-20171027002309383-1138600592.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;还有买书。唉哟，那些什么经典之类的大部头，当时买的时候那个激动啊！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网上买的，寄到公司，唉哟我的妈，同事眼睛都大了，“老叶！牛逼啊……”然后下班我“哈呲哈呲”的把他们扛回家，租的房子没电梯，九楼——痛并快乐着啊。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/49387/201711/49387-20171105173740513-403974564.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;快十年过去了，现在那些书还像新的一样。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;但如果不是QQ群里 &lt;span&gt;@ARピ&lt;/span&gt; 同学贴出来一段话，我也不会写这篇博客。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/49387/201711/49387-20171105220115904-1545942018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;感觉一下子就说到了心坎上一样，而且居然已经很流行了？还有一个很贴切的名字：“&lt;span&gt;松鼠症&lt;/span&gt;”，耶！感觉有底气多了。搜索了一阵，这种行为除了“浪费”——浪费时间浪费精力浪费金钱以外，最大的问题是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;让我们产生了“我已经学会了”，“我很强”“我好厉害”的错觉，而不会去真正的学习和练习。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt;&lt;span&gt;这让我想起以前我看到过的&lt;a href=&quot;http://www.bilibili.com/video/av294900/&quot; target=&quot;_blank&quot;&gt;【TED】不要公开你的个人目标&lt;/a&gt;，有时间的同学可以看一下，其实道理都是一样的。&lt;/span&gt;&lt;/p&gt;

&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt; &lt;/p&gt;
&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt;&lt;span&gt;所以，一开始我的直觉是对的，至少是有一定道理的。给你一个什么“&lt;span&gt;技术栈&lt;/span&gt;”，对你一点用都没有，甚至可能害了你！而且这个“技术栈”越宏大越壮阔，害你越深：目标太宏伟，计划太宏大。你就会把太多的热情都消耗在了计划上面，而&lt;span&gt;开始行动的时候，&lt;/span&gt;咳咳，你懂的……&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt; &lt;/p&gt;

&lt;p&gt;那这种情况肿么破？&lt;/p&gt;
&lt;p&gt;就编程而言，我觉得有两点：&lt;/p&gt;
&lt;p&gt;1、忘掉你那壮（hao）志（gao）凌（wu）云（远）的理想；&lt;/p&gt;
&lt;p&gt;2、脚踏实地的先把代码撸起来（参考：&lt;a href=&quot;https://www.zhihu.com/question/19578287/answer/243019750&quot; target=&quot;_blank&quot;&gt;如何学习编程？&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;我再补充一点，为什么“把代码撸起来”就可以破掉烦人的“松鼠症”。因为：&lt;/p&gt;
&lt;p&gt;1、这是你走出“舒适区”的第一步。我在&lt;a href=&quot;http://17bang.ren/Article/8&quot; target=&quot;_blank&quot;&gt;“零基础”全栈课程&lt;/a&gt;里一直呼吁大家把代码撸起来，然而，即使最简单的作业也没有几个同学去完成。为什么？因为完成作业需要动手，哪怕是最简单的作业，都得弄个页面，跑一跑，调试一下，哪有开着电脑左手瓜子右手可乐，看（听）飞哥吹牛逼舒服呢？我完全可以想象，并且理解这种心理。然而，这样不行啊！要是这样都能学会编程，我，我，我……我直接去买块豆腐撞死球算了！&lt;/p&gt;
&lt;p&gt;2、它会破灭你很多很多的幻想。只要你开始撸代码，你就会发现：唉呀什么高性能可扩展各种牛逼都是浮云，能把“hello，world”整出来就万事大吉了！非.NET系统的，连个开发环境都搭建不出来，搞个毛线……用你们年轻人的话说，叫“分分钟教你做人”，是不是？&lt;/p&gt;
&lt;p&gt;3、你会得到真正的、有效的、及时的反馈，激励你一步一步继续走下去。但一旦你克服眼前的这些困难，把你就能马上获得反馈&lt;/p&gt;

&lt;p&gt;&lt;span&gt;知乎上看到一个11K+赞的回答：&lt;a href=&quot;https://www.zhihu.com/question/19550362/answer/18044986&quot; target=&quot;_blank&quot;&gt;学习一个新领域的知识的最佳方法和最快时间各是什么？&lt;/a&gt;，答案超级长（知乎特色），我简单点总结就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学会了点，就马上开练，技术是练出来的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不要想着一口吃个大胖子。&lt;/span&gt;&lt;/p&gt;





&lt;p&gt;&lt;span&gt;又有一天，我看到了另一篇文章，标题大概是《如果我再从头开始学JAVA》，我没有点进去看——是的，懒得点进去看——但我想了想，假如我再从头开始学.NET，我会怎么学？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;能不学的就不学。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类似的例子还有很多，我们野心勃勃的计划，最后都落了空。为什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt;&lt;span&gt;目标定得越高，我们的挫败感就会越强烈。因为我们本质上，都不过是一个普通人，长时间的得不到正面的反馈，就凭一口气，我们是坚持不了太久的。就像行路，前路漫漫；就像登山，山峰高耸入云，不知道什么时候是个头……自己心里就开始打退堂鼓。&lt;/span&gt;&lt;/p&gt;
&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt;&lt;span&gt;.NET WEB技术开发栈，如果我一开始就知道&lt;/span&gt;&lt;/p&gt;
&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt;&lt;span&gt;此外，摊子铺得越大。&lt;/span&gt;&lt;/p&gt;
&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt;&lt;span&gt;用大力跑不远。&lt;/span&gt;&lt;/p&gt;
&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt;&lt;span&gt;对这个现象做了最合理的解释。&lt;/span&gt;&lt;/p&gt;
&lt;p title=&quot;【TED】不要公开你的个人目标&quot;&gt;&lt;span&gt;当然，凡事都有例外，我一天到晚满世界的嚷嚷着我的目标：。我仍然相信我一定能够实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;坚信我的这种学习路径，培训模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;做起来，通过实现一个一个的小目标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高山仰止&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 05 Nov 2017 15:34:00 +0000</pubDate>
<dc:creator>自由飞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeflying/p/7725385.html</dc:identifier>
</item>
<item>
<title>利用Tkinter和matplotlib两种方式画饼状图 - 欠你一颗糖</title>
<link>http://www.cnblogs.com/KBe24Love/p/7789962.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KBe24Love/p/7789962.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;当我们学习python的时候，总会用到一些常用的模块，接下来我就详细讲解下利用两种不同的方式画饼状图。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;首先利用【&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Tkinter&lt;/span&gt;&lt;span&gt;&lt;span&gt;】中的canvas画布来画饼状图：&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;29&quot;&gt;
&lt;strong&gt;&lt;span&gt;from tkinter import Tk, Canvas&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;def DrawPie():&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    #创建窗口&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    windows=Tk()&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    #添加标题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    windows.title(&quot;画饼图&quot;)&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    # 设置画布样式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    canvas=Canvas(windows,height=500,width=500)&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    # 将画布打包到窗口&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    canvas.pack()&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    #利用画布的create_arc画饼形，(400,400)和(100,100)为饼形外围的矩形,&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    # start=角度起始，extent=旋转的度数，fill=填充的颜色&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    canvas.create_arc(400,400,100,100,start=0,extent=36,fill=&quot;red&quot;)&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    canvas.create_arc(400,400,100,100,start=36,extent=72,fill=&quot;green&quot;)&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    canvas.create_arc(400,400,100,100,start=108,extent=108,fill=&quot;yellow&quot;)&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    canvas.create_arc(400,400,100,100,start=216,extent=144,fill=&quot;blue&quot;)&lt;/span&gt;&lt;/strong&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    # 为各个扇形添加内容，圆心为（250，250）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    canvas.create_text(430,200,text=&quot;36°&quot;,font=(&quot;华文新魏&quot;,20))&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    canvas.create_text(330,100,text=&quot;72°&quot;,font=(&quot;华文新魏&quot;,20))&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    canvas.create_text(90,200,text=&quot;108°&quot;,font=(&quot;华文新魏&quot;,20))&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    canvas.create_text(390,370,text=&quot;144°&quot;,font=(&quot;华文新魏&quot;,20))&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    # 开启消息循环&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    windows.mainloop()&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;if __name__ == '__main__':&lt;br/&gt;　　&lt;span&gt;#调用方法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;    DrawPie()&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;以上方法就是用的Tkinter画布来画饼状图的，接下来我们来看下第三方模块&lt;/span&gt;&lt;/span&gt;&lt;span&gt;【&lt;/span&gt;&lt;span&gt;&lt;span&gt;matplotlib&lt;/span&gt;&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;span&gt;中的pyplot：&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;strong&gt;&lt;span&gt;from matplotlib import pyplot&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;# 中文支持&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;pyplot.rcParams['font.sans-serif'] = ['SimHei']&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;#  用来正常显示中文标签&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;pyplot.rcParams['axes.unicode_minus'] = False  # 用来正常显示负号&lt;/span&gt;&lt;/strong&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;def showPieChart():&lt;br/&gt;&lt;/span&gt;     &lt;span&gt;#调用pyplot模块中的pie方法绘制饼图，pie方法的第一个参数是各个部分所占的比例，后面其他的参数是对饼形图的一些修饰的标签，&lt;br/&gt;labels为描述的内容，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;startangle为绘制的起始角度，counterclock为绘制的方向（默认为逆时针）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;strong&gt;&lt;span&gt;    pyplot.pie([36,72,108,144], labels=[&quot;36°&quot;, &quot;72°&quot;, &quot;108°&quot;, &quot;144°&quot;], startangle=90, counterclock=False)&lt;br/&gt;&lt;/span&gt;    &lt;span&gt; #显示图形&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    pyplot.show()&lt;/span&gt;&lt;/strong&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;if __name__ == '__main__':&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;　　&lt;span&gt;　&lt;strong&gt;#调用函数&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    showPieChart()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;其实两种方法都大同小异，只不过应用的模块不一样，第一种方法只能绘制图形不能添加饼图的内容，而第二种方法内部封装的饼形图的样式，可以添加的样式也丰富多彩。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 05 Nov 2017 15:33:00 +0000</pubDate>
<dc:creator>欠你一颗糖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/KBe24Love/p/7789962.html</dc:identifier>
</item>
<item>
<title>详细解读-this-关键字在全局、函数、对象、jQuery等中的基础用法！ - ../..随风</title>
<link>http://www.cnblogs.com/xyq1107/p/7789915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xyq1107/p/7789915.html</guid>
<description>
&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;1、 Javascript是一门基于对象的动态语言，也就是说，所有东西都是对象，一个很典型的例子就是函数也被视为普通的对象。Javascript可以通过一定的设计模式来实现面向对象的编程，其中this “指针”就是实现面向对象的一个很重要的特性。但是this也是Javascript中一个非常容易理解错，进而用错的特性。&lt;/p&gt;
&lt;p&gt;2、this是Javascript语言的一个关键字。 它代表函数运行时，自动生成的一个内部对象。&lt;/p&gt;
&lt;h2&gt;二、进入正题&lt;/h2&gt;
&lt;h3&gt;1、全局代码中的——this&lt;/h3&gt;
&lt;p&gt;　　1、 浏览器宿主的全局环境中，&lt;code&gt;this&lt;/code&gt;指的是&lt;code&gt;window&lt;/code&gt;对象。在全局代码中，this始终是全局对象本身，这样就有可能间接的引用到它了。&lt;/p&gt;
&lt;p&gt;　　示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        console.log(this); //window
        console.log(this == window);//true
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2、 浏览器中在全局环境下，使用&lt;code&gt;var&lt;/code&gt;声明变量将会把值赋给&lt;code&gt;this&lt;/code&gt;或&lt;code&gt;window&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        var  name = &quot;Jack&quot; ;
        console.log(this.name);//Jack
        console.log(window.name);//Jack
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、任何情况下，即使创建变量时没有使用&lt;code&gt;var&lt;/code&gt;，也是在操作全局&lt;code&gt;this&lt;/code&gt;。而在函数里面创建变量时，结果为undefined。&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    name = &quot;Jack&quot;;
    function testThis() {
         age = 20;
         console.log(this.age); // 20
    }
    console.log(this.age); // undefined 
    console.log(this.name);// Jack
    testThis();
    console.log(this.name);// Jack
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;二、函数代码中的——this&lt;/h3&gt;
&lt;p&gt;1、先来看一个最简单的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var name = &quot;Jack&quot;;
    function sayHi(){
      console.log(&quot;你好，我的名字叫&quot; + name);// &quot;你好，我的名字叫Jack&quot;
      console.log(&quot;你好，我的名字叫&quot; + this.name);// &quot;你好，我的名字叫Jack&quot;
    }
    sayHi();
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先，我们定义了一个全局字符串对象name和函数对象sayHi。运行都会打印出，“你好，我的名字叫Jack”。全局变量name将值赋给this。&lt;/p&gt;
&lt;p&gt;2、我们把上面的代码改一改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    name = &quot;Jack&quot;;
    function testThis() {
      this.name = &quot;Alice&quot;;
    }
    console.log(&quot;你好，我的名字叫&quot;+this.name); //  &quot;你好，我的名字叫Jack&quot;
    testThis();
    console.log(&quot;你好，我的名字叫&quot;+this.name); //  &quot;你好，我的名字叫Alice&quot;
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为Jack中的this为函数调用之前的全局变量name=Jack将值赋给this，此时textThis函数未将Alice赋值给this；运行结果为Alice为函数调用之后testThis函数将Alice值赋值给了全局变量name，此时name = &quot;Alice&quot;   this.name = &quot;Alice&quot;。&lt;/p&gt;
&lt;p&gt;3、函数也是普通的对象，可以将其当作一个普通变量使用。我们再把上面的代码改一改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var name = &quot;Jack&quot;;
    function sayHi(){
       console.log(&quot;你好，我的名字叫&quot; + this.name);// undefined
    }
    var person = {};
    person.sayHello = sayHi;
    person.sayHello();
&amp;lt;/script&amp;gt;

//而定义  person = {name：Alice}  ，则：
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var name = &quot;Jack&quot;;
    function sayHi(){
       console.log(&quot;你好，我的名字叫&quot; + this.name);// &quot;你好，我的名字叫Alice&quot;
    }
    var person = {name:Alice};
    person.sayHello = sayHi;
    person.sayHello();
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一，我们定义了一个全局函数对象sayHi并执行了这个函数，函数内部使用了this关键字，那么执行this这行代码的对象是sayHi（一切皆对象的体现），sayHi是被定义在全局作用域中。其实在Javascript中所谓的全局对象，无非是定义在window这个根对象下的一个属性而已。因此，sayHi的所有者是window对象。也就是说，在全局作用域下，你可以通过直接使用name去引用这个对象，你也可以通过window.name去引用同一个对象。因而&lt;strong&gt;this.name就可以翻译为window.name&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;第二，我们定义了一个person的对象，并定义了它的sayHello属性，使其指向sayHi全局对象。那么这个时候，当我们运行person.sayHello的时候，this所在的代码所属对象就是sayHello了（其实准确来说，sayHi和sayHello是只不过类似两个指针，指向的对象实际上是同一个），而sayHello对象的所有者就是person了。第一次，person里面没有name属性，因此弹出的对话框就是this.name引用的就是undefined对象（&lt;strong&gt;Javascript中所有只声明而没有定义的变量全都指向undefined对象&lt;/strong&gt;）；而第二次我们在定义person的时候加了name属性了，那么this.name指向的自然就是我们定义的字符串了。&lt;/p&gt;
&lt;p&gt;参考上面解释，我们将上面示例改造成面向对象式的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var name = &quot;Jack&quot;;
    function sayHi(){
       console.log(&quot;你好，我的名字叫&quot; + this.name);//两次函数调用均成功，打印两次：&quot;你好，我的名字叫Marry&quot;     &quot;你好，我的名字叫Alice&quot;
    }
    function Person(name){
        this.name = name;
    }
    Person.prototype.sayHello = sayHi;
    var marry = new Person(&quot;Marry&quot;);   
    marry.sayHello();
    var alice = new Person(&quot;Alice&quot;);
    alice.sayHello();
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面这段代码中，我们定义了一个Person的“类”（实际上还是一个对象），然后在这个类的原型（&lt;strong&gt;类原型相当于C++中的静态成员变量的概念&lt;/strong&gt;）中定义了sayHello属性，使其指向全局的sayHi对象。运行代码我们可以看到，marry和kevin都成功打印出来。&lt;/p&gt;
&lt;p&gt;4、当用调用函数时使用了&lt;code&gt;new&lt;/code&gt;关键字，此刻&lt;code&gt;this&lt;/code&gt;指代一个新的上下文，不再指向全局&lt;code&gt;this。通常我将这个新的上下文称作实例。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    name = &quot;Jack&quot;;
    function testThis() {
      this.name = &quot;Alice&quot;;
    }
    console.log(this.name); // &quot;Jack&quot;
    new testThis();
    console.log(this.name); // &quot;Jack&quot;
    console.log(new testThis().name); // &quot;Alice&quot;
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;三、对象代码中的——this&lt;/h3&gt;
&lt;p&gt;1、可以在对象的任何方法中使用&lt;code&gt;this&lt;/code&gt;来访问该对象的属性。这与用&lt;code&gt;new&lt;/code&gt;得到的实例是不一样的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
var obj = {
   name: &quot;Jack&quot;,
    func: function () {
        console.log(this.name); //   &quot;Jack&quot;
    }
};

obj.func();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、可以将函数绑定到对象，就好像这个对象是一个实例一样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
var obj = {
    name: &quot;Jack&quot;
};

function logName() {
    console.log(this.name); //logs &quot;Jack&quot;
}

logName.apply(obj);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、也可以不通过&lt;code&gt;this&lt;/code&gt;，直接访问对象的属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
var obj = {
   name: &quot;Jack&quot;,
    deeper: {
        logName: function () {
            console.log(obj.name);//    &quot;Jack&quot;
        }
    }
};

obj.deeper.logName(); 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;四、jQuery代码中的——this&lt;/h3&gt;
&lt;p&gt;1、jQuery库中大多地方的&lt;code&gt;this&lt;/code&gt;也是指代的DOM元素。页面上的事件回调和一些便利的静态方法比如&lt;code&gt;$.each&lt;/code&gt; 都是这样的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;div class=&quot;foo bar1&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;foo bar2&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script src=&quot;../05-JQuery/JS/jquery-1.10.2.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
$(function(){

     　　$(&quot;.foo&quot;).each(function () {
            console.log(this); //  &amp;lt;div class=&quot;foo bar1&quot;&amp;gt;&amp;lt;/div&amp;gt;   &amp;lt;div class=&quot;foo bar2&quot;&amp;gt;&amp;lt;/div&amp;gt;
        });
        $(&quot;.foo&quot;).on(&quot;click&quot;, function () {
            console.log(this); //  &amp;lt;div class=&quot;foo bar1&quot;&amp;gt;   &amp;lt;div class=&quot;foo bar2&quot;&amp;gt;&amp;lt;/div&amp;gt;
        });
          
   })

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 五、DOM事件中的——this&lt;/h3&gt;
&lt;p&gt;在DOM事件的处理函数中，&lt;code&gt;this&lt;/code&gt;指代的是被绑定该事件的DOM元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
function&lt;span&gt; Listener() {
    document.getElementById(&quot;foo&quot;).addEventListener(&quot;click&quot;&lt;span&gt;,
       this&lt;span&gt;.handleClick);
}
Listener.prototype.handleClick = function&lt;span&gt; (event) {
    console.log(this); //logs &quot;&amp;lt;div id=&quot;foo&quot;&amp;gt;&amp;lt;/div&amp;gt;&quot;
&lt;span&gt;}

var listener = new&lt;span&gt; Listener();
document.getElementById(&quot;foo&quot;).click();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;六、使用&lt;code&gt;with&lt;/code&gt;时的——&lt;code&gt;this&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;with&lt;/code&gt;可以将&lt;code&gt;this&lt;/code&gt;人为添加到当前执行环境中而不需要显示地引用&lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
function&lt;span&gt; Thing () {
}
Thing.prototype.foo = &quot;bar&quot;&lt;span&gt;;
Thing.prototype.logFoo = function&lt;span&gt; () {
    with (this&lt;span&gt;) {
        console.log(foo);
        foo = &quot;foo&quot;&lt;span&gt;;
    }
}

var thing = new&lt;span&gt; Thing();
thing.logFoo(); // logs &quot;bar&quot;
console.log(thing.foo); // logs &quot;foo&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;结束：&lt;/h2&gt;
&lt;p&gt;　　上面，就是博主自己在实践的过程中，总结的一点经验，希望对大家能否有所帮助，欢迎大家能够提出高贵意见，博主定当补充改正。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;














</description>
<pubDate>Sun, 05 Nov 2017 15:24:00 +0000</pubDate>
<dc:creator>../..随风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xyq1107/p/7789915.html</dc:identifier>
</item>
<item>
<title>CS231n 2017 学习笔记01——KNN（K-Nearest Neighbors） - Irran</title>
<link>http://www.cnblogs.com/irran/p/cs231n_learningnotes_01.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/irran/p/cs231n_learningnotes_01.html</guid>
<description>&lt;p&gt;本博客内容来自 Stanford University CS231N 2017 Lecture 2 - Image Classification&lt;/p&gt;
&lt;p&gt;课程官网：&lt;a href=&quot;http://cs231n.stanford.edu/syllabus.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://cs231n.stanford.edu/syllabus.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从课程官网可以查询到更详细的信息，查看视频需要FQ上YouTube，如果不能FQ或觉得比较麻烦，也可以从我给出的百度云链接中下载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;课程视频&amp;amp;讲义下载：&lt;a href=&quot;http://pan.baidu.com/s/1gfu51KJ&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://pan.baidu.com/s/1gfu51KJ&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在我有一张关于猫的图片，如何让计算机识别出这是只猫呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;算法思路&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们人眼虽然可以很轻松的辨认出一只猫，但却说不出是怎么辨别的，这个过程对我们来说其实是一个黑匣子。自己说都说不出来，那就更没法用编程的方式写下来了。所以显式定义规则识别的思路不可取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;换一种思考的角度，我们采用一种叫做 &lt;span&gt;“Data-Driven Approach” 的思路&lt;/span&gt; 。 这个思路顾名思义，不是显式的定义规则，而是让计算机沉浸在海量的数据中，试图让计算机自己从中学会某种规律，某种技巧。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; train(images, labels):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Machine learning!&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; model

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; predict(model, test_images):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Use model to predict labels&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; test_labels
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在这种情况下，我们的代码结构应该是上面这段代码所呈现的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先将海量的数据输送给计算机&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;images：代表图片的信息（比如说图片所有像素的rgb值）&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;labels：代表图片所属类别的信息（比如说“猫”）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后计算机通过这海量的数据，训练出一个模型——model&lt;/p&gt;
&lt;p&gt;最后给计算机一个刚刚训练好的模型和一张测试用的图片，计算机用接受的模型对图片作出预测。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;算法原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;谈起KNN之间，我们先介绍NN（Nearest Neighbor）。&lt;/p&gt;
&lt;p&gt;NN的原理及其简单，模型训练的过程就是记住所有的数据以及对应的标签。而在预测的过程，我们将测试图片与已经记住的数据逐一对比，选出相似度最高的一张图片，然后预测他们属于同一类别。&lt;/p&gt;
&lt;p&gt;那怎么定义相似度呢？简单的方式有两种——L1距离和L2距离。用两点间的距离代表相似程度，距离越小，二者越相似。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;L1 (Manhattan) distanc&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1261967/201711/1261967-20171105222334888-1154599137.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;L2 (Euclidean) distance&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1261967/201711/1261967-20171105222458123-482349439.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了更直观的表述整个算法，我们想象每一条数据都是二维平面中的一个点。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://i.imgur.com/RlmIsPh.jpg&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;307&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这张图中，不同颜色的点代表不同类别的数据，而不同颜色的区域对应了NN的分类结果，颜色相近的点和区域属于同一类别。&lt;/p&gt;
&lt;p&gt;这样我们就能看出NN算法的某些缺陷了，图片正中间有一块孤立的黄色区域，而按照常理，这块区域更可能是属于绿色类别，这个黄色的数据点很有可能是因为某些误差造成的。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，KNN出现了。&lt;/p&gt;
&lt;p&gt;现在我们不是仅考虑最相似的一个数据点，我们考虑最相似的K个数据点，在这K个数据点中，我们采取多数表决的方式决定最终的结果。举个例子，如果我们采用K=3，而与某个区域最接近的三个点中有两个属于黄色标签，一个属于绿色标签，那么这一点属于黄色范围。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://i.imgur.com/KYLDKxk.jpg&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;455&quot;/&gt;上述图片演示了不同K取值的时候形成的分类结果。可以看出当K变大的时候，不同区域之间的分界线变得更加圆滑。而白色的区域则是因为有多个相等的多数表决结果。举个例子，当K=3的时候，如果距离最近的三个点分别是蓝色、红色、绿色，这个区域就被表为白色。&lt;/p&gt;
&lt;p&gt;下面的网站是 Stanford 的大佬自己做的，可以动手尝试不同的k取值、不同距离函数的选择对KNN分类结果的影响，有兴趣可以去玩一玩。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;http://vision.stanford.edu/teaching/cs231n-demos/knn/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;超参数——Hyperparameters&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;K这样的参数被称之为超参数，超参数也包括距离公式的选择（L1或者L2），它不是可以计算机通过数据能够学习到的，而是在学习之前，由我们人为的规定的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么具体而言，如何选择超参数呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实并没有很好的办法，能普遍的方法是尝试，尝试不同的超参数，然后选取效果最好的一组超参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那如何衡量效果的好坏呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们不能在训练集上衡量，试想，在K=1的KNN算法中，每一个训练数据都被算法“正确”得划分了，准确率是100%，难道这就是最好的超参数么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然不是，模型就是在训练集上训练得来的，在训练集上的准确率不具有代表性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那我们可以将数据划分为训练集、测试集两部分么，在训练集上训练模型，在测试集上选择超参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也不行，因为如果根据测试集上的表现选择超参数，我们选择的必然是在测试机上表现最好的超参数，很可能过度拟合测试集，也不具有代表性，不能反映一般情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最常规的方式：将数据划分为训练集（training set）、验证集（validation set）、测试集（test set）三部分。在训练集上训练模型，在验证集上选择最合适的超参数，在测试集上测出最终结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里要特别注意，在得出了测试集的结果之后，我们不能根据这个结果再修改参数。尽管这样可能在测试集上得到更高的准确率，但这事实上属于一种“作弊”的行为，我们的模型就又会又过度拟合测试集的问题，丧失了代表性。况且这样做无疑让验证集与测试集的划分毫无意义，他们此时起到了相同的作用，情况又回到了上一种划分方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;KNN的缺陷&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;训练耗时短，测试耗时长&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　训练的时候仅需记忆所有数据即可，如果是传递指针的话，能够常数时间内完成 O(1)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;两点间距离公式不能提供足够的信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/zgILisj.jpg&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;450&quot;/&gt;　　上图中右侧的三张图片是在左侧图片上分别作出了某些修改后形成的，而通过精心的构建，这三张图片与左侧原本的图片有相同的距离，也就是说距离公式无法将他们区分开。&lt;/p&gt;
&lt;p&gt;　　而事实上，如果进行精心的设计，我们甚至可以让任意两张修改后的图片都与某张照片具有相同的距离。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;维度灾难&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/yLBj5bk.jpg&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;450&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　KNN算法翻译过来，是K-最临近算法，而为了能够有效的体现出“最邻近”这个概念，我们势必需要样本能够均匀的分布在整个空间中，将整个空间支撑起来。在一维或者二维的情况下还好说，如果是上图的例子中，一维需要4个样本点，二维需要16个样本点，而到了三维就需要64个样本点。所需的样本数量随着维数的增加呈现指数级增长的趋势，这无疑是灾难性的，所以被称作“维度灾难”。我们一张图片就算很小，10像素*10像素，再乘上rgb三个颜色值，一共有300个数值，这就意味着300维度，而 4&lt;sup&gt;300&lt;/sup&gt; 是一个无法想象的天文数字，我们永远不可能取得足够多的数据。&lt;/p&gt;

</description>
<pubDate>Sun, 05 Nov 2017 15:16:00 +0000</pubDate>
<dc:creator>Irran</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/irran/p/cs231n_learningnotes_01.html</dc:identifier>
</item>
<item>
<title>使用sklearn进行数据挖掘-房价预测(6)—模型调优 - Wanna_Go</title>
<link>http://www.cnblogs.com/wxshi/p/7789288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wxshi/p/7789288.html</guid>
<description>&lt;p&gt;通过上一节的探索，我们会得到几个相对比较满意的模型，本节我们就对模型进行调优&lt;/p&gt;
&lt;h3 id=&quot;网格搜索&quot;&gt;网格搜索&lt;/h3&gt;
&lt;p&gt;列举出参数组合，直到找到比较满意的参数组合，这是一种调优方法，当然如果手动选择并一一进行实验这是一个十分繁琐的工作，sklearn提供了&lt;code&gt;GridSearch-网格搜索&lt;/code&gt;方法，我们只需要将每一个参数的取值告诉它，网格搜索将使用交叉验证方法对所有情况进行验证，并返回结果最好的组合。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.model_selection import GridSearchCV

param_grid = [
    # 12 (3×4) 种超参数组合
    {'n_estimators': [3, 10, 30], 'max_features': [2, 4, 6, 8]}, #组合1
    #  6 (2×3) 种
    {'bootstrap': [False], 'n_estimators': [3, 10], 'max_features': [2, 3, 4]},#组合2
  ]

forest_reg = RandomForestRegressor(random_state=42)
# 5折交叉验证，总共需要 (12+6)*5=90 次训练
grid_search = GridSearchCV(forest_reg, param_grid, cv=5,
                           scoring='neg_mean_squared_error')
grid_search.fit(housing_prepared, housing_labels)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;上面&lt;code&gt;param_grid&lt;/code&gt;中的字典key可不是随便起的，这些都是需要网格搜索的模型中的参数。另外当你不知道如何选取参数的时候可以按照10的平方取值或者从小到大的值。&lt;/p&gt;
&lt;ul readability=&quot;67&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;1.看看上面的结果（可能是一个漫长的过程）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;grid_search.best_params_
{'max_features': 8, 'n_estimators': 30}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;2.再看一看最好的分类器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;grid_search.best_estimator_
RandomForestRegressor(bootstrap=True, criterion='mse', max_depth=None,
       max_features=8, max_leaf_nodes=None, min_impurity_split=1e-07,
       min_samples_leaf=1, min_samples_split=2,
       min_weight_fraction_leaf=0.0, n_estimators=30, n_jobs=1,
       oob_score=False, random_state=42, verbose=0, warm_start=False)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;32&quot;&gt;
&lt;p&gt;3.看一看得分&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;grid_search.best_score_
-2469578258.9821739&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们想看以下各个参数组合的情况呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cv_result = grid_search.cv_results_&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;cv_result是一个字典类型，记录了整个训练过程的数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;cv_result.keys(
['std_train_score',
 'rank_test_score',
 'split4_test_score',
 'param_bootstrap',
 'split2_train_score',
 'param_n_estimators',
 'std_score_time',
 'split4_train_score',
 'split2_test_score',
 'mean_score_time',
 'mean_fit_time',
 'split3_train_score',
 'split0_train_score',
 'std_test_score',
 'split1_train_score',
 'split0_test_score',
 'mean_test_score',
 'param_max_features',
 'params',
 'std_fit_time',
 'split3_test_score',
 'mean_train_score',
 'split1_test_score']&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;76&quot;&gt;
&lt;p&gt;4.看一下组合的分值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;for mean_score, params in zip(cv_result [&quot;mean_test_score&quot;], cv_result [&quot;params&quot;]):
    print(np.sqrt(-mean_score), params)
(63825.047930176741, {'max_features': 2, 'n_estimators': 3})
(55643.842909084706, {'max_features': 2, 'n_estimators': 10})
(53380.65668593633, {'max_features': 2, 'n_estimators': 30})
(60959.138858487866, {'max_features': 4, 'n_estimators': 3})
(52740.584166652523, {'max_features': 4, 'n_estimators': 10})
(50374.142146147307, {'max_features': 4, 'n_estimators': 30})
(58661.2866461823, {'max_features': 6, 'n_estimators': 3})
(52009.973979776936, {'max_features': 6, 'n_estimators': 10})
(50154.117773684942, {'max_features': 6, 'n_estimators': 30})
(57865.361680144459, {'max_features': 8, 'n_estimators': 3})
(51730.075508665534, {'max_features': 8, 'n_estimators': 10})
(49694.851433344418, {'max_features': 8, 'n_estimators': 30})
(62874.407393096284, {'max_features': 2, 'n_estimators': 3, 'bootstrap': False})
(54561.939815728343, {'max_features': 2, 'n_estimators': 10, 'bootstrap': False})
(59416.646314497353, {'max_features': 3, 'n_estimators': 3, 'bootstrap': False})
(52660.245911032733, {'max_features': 3, 'n_estimators': 10, 'bootstrap': False})
(57490.016827879947, {'max_features': 4, 'n_estimators': 3, 'bootstrap': False})
(51093.905942805257, {'max_features': 4, 'n_estimators': 10, 'bootstrap': False})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面正好有18种组合结果。在第四节的时候，我们自己定义了一个estimator&lt;code&gt;CombinedAttributesAdder&lt;/code&gt;其中有一个参数&lt;code&gt;add_bedrooms_per_room&lt;/code&gt;我们也可以将其加入网格搜索中。&lt;/p&gt;
&lt;h3 id=&quot;在测试集合上评估模型&quot;&gt;在测试集合上评估模型&lt;/h3&gt;
&lt;p&gt;上面我们已经得到了我们最好的模型，那么模型到底如何呢？是骡子是马拉出来溜溜，测试集该上场了，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final_model = grid_search.best_estimator_
#去掉标签
X_test = strat_test_set.drop(&quot;median_house_value&quot;, axis=1)
y_test = strat_test_set[&quot;median_house_value&quot;].copy()
#这个时候只需要transform
X_test_prepared = full_pipeline.transform(X_test)
final_predictions = final_model.predict(X_test_prepared)
#均方误差
final_mse = mean_squared_error(y_test, final_predictions)
final_rmse = np.sqrt(final_mse)
&amp;gt;&amp;gt;final_rmse
 47766.003966433083&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;持久化模型&quot;&gt;持久化模型&lt;/h3&gt;
&lt;p&gt;模型已经建立好了，当下次再使用的时候，为了避免再次繁琐的训练过程，我们考虑将模型给&lt;code&gt;存储&lt;/code&gt;起来，python提供了&lt;code&gt;pickle&lt;/code&gt;方法，当然我们也可以使用sklearn提供的&lt;code&gt;joblib&lt;/code&gt;方法，这种方法相对更加的高效。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.externals import joblib
#存储
joblib.dump(final_model,'best_model.pkl')
#加载
best_model = joblib.load('best_model.pkl')
#后续的使用....&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;至此，本系列的使用sklearn对房价进行预测的文章就此结束，本系列文章主要介绍了并实战了数据挖掘过程种的一些步骤、工具的使用方法及技巧。一路走来看似平坦实则为坑坑洼洼，还有很多需要完善的地方，如特征的组合、模型的选择等等。希望看完本系列之后能够让你对数据挖掘有更深的理解^-^(完)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 05 Nov 2017 14:59:00 +0000</pubDate>
<dc:creator>Wanna_Go</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wxshi/p/7789288.html</dc:identifier>
</item>
<item>
<title>剖析Linux系统调用的执行路径 - ☆Ronny丶</title>
<link>http://www.cnblogs.com/ronny/p/7789057.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ronny/p/7789057.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;http://www.cnblogs.com/ronny/p/7787105.html&quot;&gt;什么是操作系统&lt;/a&gt;这篇文章中，介绍过操作系统像是一个代理一样，为我们去管理计算机的众多硬件，我们需要计算机的一些计算服务、数据管理的服务，都由操作系统提供&lt;strong&gt;接口&lt;/strong&gt;来完成。这样做的好处是让一般的计算机使用者不用关心硬件的细节。&lt;/p&gt;

&lt;p&gt;既然使用者是通过操作系统接口来使用计算机的，那到底是什么是操作系统提供的接口呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口&lt;/strong&gt;（interface）这个词来源于电气工程学科，指的是插座与插头的连接口，起到将电与电器连接起为的功能。后来延伸到软件工程里指软件包向外提供的功能模块的函数接口。所以接口是用来连接两个东西、信号转换和屏蔽细节。&lt;/p&gt;
&lt;p&gt;那对于操作系统来说：操作系统通过接口的方式，建立了用户与计算机硬件的沟通方式。用户通过调用操作系统的接口来使用计算机的各种计算服务。为了用户友好性，操作系统一般会提供两个重要的接口来满足用户的一些一般性的使用需求：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;命令行：实际是一个叫&lt;code&gt;bash/sh&lt;/code&gt;的端终程序提供的功能，该程序底层的实质还是调用一些操作系统提供的函数。&lt;/li&gt;
&lt;li&gt;窗口界面：窗口界面通过编写的窗口程序接收来自操作系统消息队列的一些鼠标、键盘动作，进而做出一些响应。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于非一般性使用需求，操作系统提供了一系列的函数调用给软件开发者，由软件开发者来实现一些用户需要的功能。这些函数调用由于是操作系统内核提供的，为了有别于一般的函数调用，被称为&lt;strong&gt;系统调用&lt;/strong&gt;。比如我们使用C语言进行软件开发时，经常用的&lt;code&gt;printf&lt;/code&gt;函数，它的内部实际就是通过&lt;code&gt;write&lt;/code&gt;这个系统调用，让操作系统内核为我们把字符打印在屏幕上的。&lt;/p&gt;
&lt;p&gt;为了规范操作系统提供的系统调用，IEEE制定了一个标准接口族，被称为&lt;code&gt;POSIX&lt;/code&gt;（Portable Operating System Interface of Unix）。一些我们熟悉的接口比如：&lt;code&gt;fork&lt;/code&gt;、&lt;code&gt;pthread_create&lt;/code&gt;、&lt;code&gt;open&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;计算机硬件资源都是操作系统内核进行管理的，那我们可以直接用内核中的一些功能模块来操作硬件资源吗？可以直接访问内核中维护的一些数据结构吗？ 当然不行！有人会说，为什么不行呢？我买的电脑，内核代码在内存中，那内存不都是我自己买的吗？，我自己不能访问吗？&lt;br/&gt;现在我们运行的操作系统都是一个多任务、多用户的操作系统。如果每个用户进程都可以随便访问操作系统内核的模块，改变状态，那整个操作系统的稳定性、安全性都大大降低了。&lt;/p&gt;
&lt;p&gt;为了将内核程序与用户程序隔离开，在硬件层面上提供了一次机制，将程序执行的状态分为了不同的级别，从0到3，数字越小，访问级别越高。0代表内核态，在该特权级别下，所有内存上的数据都是可见的，可访问的。3代表用户态，在这个特权级下，程序只能访问一部分的内存区域，只能执行一些限定的指令。&lt;/p&gt;
&lt;p&gt;操作系统在建立GTD表的时候，将GTD的每个表项中的2位（4种特权级别）设置为特权位（DPL），然后操作系统将整个内存分为不同的段，不同的段，在GDT对应的表项中的DPL位是不同的。比如内核内存段的所有特权位都为&lt;code&gt;00&lt;/code&gt;。而用户程序访存时，在保护模式下都是通过段寄存器+IP寄存器来访问的，而段寄存器里则用两位表示当前进程的级别（CPL），是位于内核态还是用户态。&lt;/p&gt;
&lt;p&gt;既然如此，那我们还有什么办法可以调用操作系统的内核代码呢？操作系统为了实现系统调用，提供了一个主动进入内核的惟一方式：中断指令&lt;code&gt;int&lt;/code&gt;。&lt;code&gt;int&lt;/code&gt;指令会将GDT表中的DPL改为3，让我们可以访问内核中的函数。所以所有的系统调用都必须通过调用&lt;code&gt;int&lt;/code&gt;指令来实现，大致的过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户程序中包含一段包含int指令的代码&lt;/li&gt;
&lt;li&gt;操作系统写中断处理，获取相调程序的编号&lt;/li&gt;
&lt;li&gt;操作系统根据编号执行相应的代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们以&lt;code&gt;printf&lt;/code&gt;函数的调用为例，说明该函数是如何一步一步最终落在内核函数上去的。&lt;/p&gt;
&lt;div class=&quot;imgcap&quot; readability=&quot;7&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/378920/201711/378920-20171105215548951-327708573.png&quot;/&gt;&lt;p&gt;图1：应用程序、库函数和内核系统调用之间的关系&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;printf函数是C语言的一个库函数，它并不是真正的系统调用，在Unix下，它是通过调用&lt;code&gt;write&lt;/code&gt;函数来完成功能的。&lt;/p&gt;
&lt;p&gt;write函数内部就是调用了&lt;code&gt;int&lt;/code&gt;中断。一般的系统调用都是调用0x80号中断。而操作系统中一般不会的显式的写出write的实现代码，而是通过&lt;code&gt;_syscall3&lt;/code&gt;宏展开的实现。&lt;code&gt;_syscall3&lt;/code&gt;是专门用来处理有3个参数的系统调用的函数的实现。同理还有&lt;code&gt;_syscall0&lt;/code&gt;、&lt;code&gt;_syscall1&lt;/code&gt;和&lt;code&gt;_syscall2&lt;/code&gt;等，目前最大支持的参数个数为3个，这三个参数是通过&lt;code&gt;ebx&lt;/code&gt;, &lt;code&gt;ecx&lt;/code&gt;,&lt;code&gt;edx&lt;/code&gt;传递的。如果有系统调用的参数超过了3个，那么可以通过一个参数结构体来进行传递。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;// linux/lib/write.c&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define __LIBRARY__&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// &lt;/span&gt;
_syscall3(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;,write,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;,fd,&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *,buf,off_t,count)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;// linux/&lt;span class=&quot;kw&quot;&gt;include&lt;/span&gt;/unistd.h
#define _syscall3(type,name,atype,a,btype,b,ctype,c) \
type name(atype a,btype b,ctype c) \
{ \
long __res&lt;span class=&quot;co&quot;&gt;; \&lt;/span&gt;
__asm__ volatile (&lt;span class=&quot;st&quot;&gt;&quot;int $0x80&quot;&lt;/span&gt; \
    : &lt;span class=&quot;st&quot;&gt;&quot;=a&quot;&lt;/span&gt; (__res) \
    : &lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt; (__NR_##name),&lt;span class=&quot;st&quot;&gt;&quot;b&quot;&lt;/span&gt; ((long)(a)),&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt; ((long)(b)),&lt;span class=&quot;st&quot;&gt;&quot;d&quot;&lt;/span&gt; ((long)(c)))&lt;span class=&quot;co&quot;&gt;; \&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;if&lt;/span&gt; (__res&amp;gt;=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) \
    return (type) __res&lt;span class=&quot;co&quot;&gt;; \&lt;/span&gt;
errno=-__res&lt;span class=&quot;co&quot;&gt;; \&lt;/span&gt;
return -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;; \&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以宏展开后，write函数的实现实现为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; write(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *buf, off_t count)
{ 
    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; __res; 
    __asm__ &lt;span class=&quot;dt&quot;&gt;volatile&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;&quot;int $0x80&quot;&lt;/span&gt; 
        : &lt;span class=&quot;st&quot;&gt;&quot;=a&quot;&lt;/span&gt; (__res) 
        : &lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt; (__NR_write),&lt;span class=&quot;st&quot;&gt;&quot;b&quot;&lt;/span&gt; ((&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt;)(a)),&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt; ((&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt;)(b)),&lt;span class=&quot;st&quot;&gt;&quot;d&quot;&lt;/span&gt; ((&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt;)(c))); 
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (__res&amp;gt;=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) 
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (type) __res; 
    errno=-__res; 
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; 
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看到实际函数内部并没有做太多的事情，主要就是调用&lt;code&gt;int 0x80&lt;/code&gt;，将把相关的参数传递给一些通用寄存器，调用的结果通过&lt;code&gt;eax&lt;/code&gt;返回。其中一个很重要的调用参数是&lt;code&gt;__NR_write&lt;/code&gt;这个也是一个宏，就是wirte的系统调用号，在linux/include/unistd.h中被定义为4，同样还有很多其他系统调用号。因为所有的系统调用都是通过&lt;code&gt;int 0x80&lt;/code&gt;，那怎么知道具体需要什么功能呢，只能通过系统调用号来识别。&lt;/p&gt;
&lt;p&gt;下面我们来看看&lt;code&gt;int 0x80&lt;/code&gt;是如何执行的。这是一个系统中断，操作系统对于中断处理流程一般为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;关中断：CPU关闭中段响应，即不再接受其它外部中断请求&lt;/li&gt;
&lt;li&gt;保存断点：将发生中断处的指令地址压入堆栈，以使中断处理完后能正确地返回。&lt;/li&gt;
&lt;li&gt;识别中断源：CPU识别中断的来源，确定中断类型号，从而找到相应的中断服务程序的入口地址。&lt;/li&gt;
&lt;li&gt;保护现场所：将发生中断处理有关寄存器（中断服务程序中要使用的寄存器）以及标志寄存器的内存压入堆栈。&lt;/li&gt;
&lt;li&gt;执行中断服务程序：转到中断服务程序入口开始执行，可在适当时刻重新开放中断，以便允许响应较高优先级的外部中断。&lt;/li&gt;
&lt;li&gt;恢复现场并返回：把“保护现场”时压入堆栈的信息弹回原寄存器，然后执行中断返回指令（IRET），从而返回主程序继续运行。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;前3项通常由处理中断的硬件电路完成，后3项通常由软件（中断服务程序）完成。&lt;/p&gt;
&lt;div class=&quot;imgcap&quot; readability=&quot;7&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/378920/201711/378920-20171105215809685-2034644903.png&quot;/&gt;&lt;p&gt;图2：系统调用中断处理流程&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;那0x80号中断的处理程序是什么呢，我们可以看一下操作系统是如何设置这个中断向量表的。在操作系统初始化时&lt;code&gt;shecd_init&lt;/code&gt;函数里，调用了&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;set_system_gate(&lt;span class=&quot;bn&quot;&gt;0x80&lt;/span&gt;, &amp;amp;system_call);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们深入看一下&lt;code&gt;set_system_gate&lt;/code&gt;函数做了什么&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;#define _set_gate(gate_addr,type,dpl,addr) \
__asm__ (&lt;span class=&quot;st&quot;&gt;&quot;movw %%dx,%%ax\n\t&quot;&lt;/span&gt; \
    &lt;span class=&quot;st&quot;&gt;&quot;movw %0,%%dx\n\t&quot;&lt;/span&gt; \
    &lt;span class=&quot;st&quot;&gt;&quot;movl %%eax,%1\n\t&quot;&lt;/span&gt; \
    &lt;span class=&quot;st&quot;&gt;&quot;movl %%edx,%2&quot;&lt;/span&gt; \
    : \
    : &lt;span class=&quot;st&quot;&gt;&quot;i&quot;&lt;/span&gt; ((short) (&lt;span class=&quot;bn&quot;&gt;0x8000&lt;/span&gt;+(dpl&amp;lt;&amp;lt;&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;)+(type&amp;lt;&amp;lt;&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;))), \
    &lt;span class=&quot;st&quot;&gt;&quot;o&quot;&lt;/span&gt; (*((char *) (gate_addr))), \
    &lt;span class=&quot;st&quot;&gt;&quot;o&quot;&lt;/span&gt; (*(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;+(char *) (gate_addr))), \
    &lt;span class=&quot;st&quot;&gt;&quot;d&quot;&lt;/span&gt; ((char *) (addr)),&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt; (&lt;span class=&quot;bn&quot;&gt;0x00080000&lt;/span&gt;))

#define set_system_gate(n,addr) \
    _set_gate(&amp;amp;idt[n],&lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,addr)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面的代码，我们可以看出，&lt;code&gt;set_system_gate&lt;/code&gt;把第0x80中断表的表项中中断处理程序入口地址设置为&amp;amp;system_call。并且把那一项IDT表中的DPL设置了为3, 方便用户程序可以去访问这个地址。&lt;/p&gt;
&lt;p&gt;所以&lt;code&gt;init 0x80&lt;/code&gt;最终会被&lt;code&gt;system_call&lt;/code&gt;这个函数地址处的代码来实际处理。让我们看下&lt;code&gt;system_call&lt;/code&gt;做了什么事情。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;# linux/kernel/system_call.s
nr_system_calls=&lt;span class=&quot;dv&quot;&gt;72&lt;/span&gt; # 最大的系统调用个数
.globl _system_call

&lt;span class=&quot;fu&quot;&gt;system_call:&lt;/span&gt;
    cmpl &lt;span class=&quot;dv&quot;&gt;$&lt;/span&gt;nr_system_calls&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;,%&lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;    # eax中放的系统调用号，在write的调用过程中为__NR_write = &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;ja&lt;/span&gt; bad_sys_call
    &lt;span class=&quot;kw&quot;&gt;push&lt;/span&gt; %&lt;span class=&quot;kw&quot;&gt;ds&lt;/span&gt;        # 下面是一些寄存器保护，后面还要弹出
    &lt;span class=&quot;kw&quot;&gt;push&lt;/span&gt; %&lt;span class=&quot;kw&quot;&gt;es&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;push&lt;/span&gt; %&lt;span class=&quot;kw&quot;&gt;fs&lt;/span&gt;
    pushl %&lt;span class=&quot;kw&quot;&gt;edx&lt;/span&gt;
    pushl %&lt;span class=&quot;kw&quot;&gt;ecx&lt;/span&gt;              # &lt;span class=&quot;kw&quot;&gt;push&lt;/span&gt; %&lt;span class=&quot;kw&quot;&gt;ebx&lt;/span&gt;,%&lt;span class=&quot;kw&quot;&gt;ecx&lt;/span&gt;,%&lt;span class=&quot;kw&quot;&gt;edx&lt;/span&gt; as parameters
    pushl %&lt;span class=&quot;kw&quot;&gt;ebx&lt;/span&gt;              # to the system &lt;span class=&quot;kw&quot;&gt;call&lt;/span&gt;
    movl &lt;span class=&quot;dv&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;0x10&lt;/span&gt;,%&lt;span class=&quot;kw&quot;&gt;edx&lt;/span&gt;         # set up &lt;span class=&quot;kw&quot;&gt;ds&lt;/span&gt;,&lt;span class=&quot;kw&quot;&gt;es&lt;/span&gt; to kernel space
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; %&lt;span class=&quot;kw&quot;&gt;dx&lt;/span&gt;,%&lt;span class=&quot;kw&quot;&gt;ds&lt;/span&gt;             #　把ds的段标号设置为&lt;span class=&quot;dv&quot;&gt;0001&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0000&lt;/span&gt;(最后２位是特权级)，所以段号为&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;，内核态数据段
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; %&lt;span class=&quot;kw&quot;&gt;dx&lt;/span&gt;,%&lt;span class=&quot;kw&quot;&gt;es&lt;/span&gt;
    movl &lt;span class=&quot;dv&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;0x17&lt;/span&gt;,%&lt;span class=&quot;kw&quot;&gt;edx&lt;/span&gt;     # 把fs的段标号设置为&lt;span class=&quot;dv&quot;&gt;0001&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0111&lt;/span&gt;(最后２位是特权级)，所以段号为&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;，用户态数据段
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; %&lt;span class=&quot;kw&quot;&gt;dx&lt;/span&gt;,%&lt;span class=&quot;kw&quot;&gt;fs&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;call&lt;/span&gt; sys_call_table(,%&lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)        # 实际的系统调用
    pushl %&lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;
    movl current,%&lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;
    cmpl&lt;span class=&quot;bn&quot;&gt; $0,&lt;/span&gt;state(%&lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;)     # state 检测是否为就绪状态
    &lt;span class=&quot;kw&quot;&gt;jne&lt;/span&gt; reschedule                        # 进入调度程序
    cmpl&lt;span class=&quot;bn&quot;&gt; $0,&lt;/span&gt;counter(%&lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;)       # counter 查看信号状态
    &lt;span class=&quot;kw&quot;&gt;je&lt;/span&gt; reschedule
&lt;span class=&quot;fu&quot;&gt;ret_from_sys_call:&lt;/span&gt;
    movl current,%&lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;       # task[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] cannot have signals
    cmpl task,%&lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;je&lt;/span&gt; 3f
    cmpw &lt;span class=&quot;dv&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;0x0f&lt;/span&gt;,&lt;span class=&quot;kw&quot;&gt;CS&lt;/span&gt;(%&lt;span class=&quot;kw&quot;&gt;esp&lt;/span&gt;)     # was old code &lt;span class=&quot;kw&quot;&gt;segment&lt;/span&gt; supervisor ?
    &lt;span class=&quot;kw&quot;&gt;jne&lt;/span&gt; 3f
    cmpw &lt;span class=&quot;dv&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;0x17&lt;/span&gt;,OLDSS(%&lt;span class=&quot;kw&quot;&gt;esp&lt;/span&gt;)      # was &lt;span class=&quot;kw&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;segment&lt;/span&gt; =&lt;span class=&quot;bn&quot;&gt; 0x17 &lt;/span&gt;?
    &lt;span class=&quot;kw&quot;&gt;jne&lt;/span&gt; 3f
    movl signal(%&lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;),%&lt;span class=&quot;kw&quot;&gt;ebx&lt;/span&gt;
    movl blocked(%&lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;),%&lt;span class=&quot;kw&quot;&gt;ecx&lt;/span&gt;
    notl %&lt;span class=&quot;kw&quot;&gt;ecx&lt;/span&gt;
    andl %&lt;span class=&quot;kw&quot;&gt;ebx&lt;/span&gt;,%&lt;span class=&quot;kw&quot;&gt;ecx&lt;/span&gt;
    bsfl %&lt;span class=&quot;kw&quot;&gt;ecx&lt;/span&gt;,%&lt;span class=&quot;kw&quot;&gt;ecx&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;je&lt;/span&gt; 3f
    btrl %&lt;span class=&quot;kw&quot;&gt;ecx&lt;/span&gt;,%&lt;span class=&quot;kw&quot;&gt;ebx&lt;/span&gt;
    movl %&lt;span class=&quot;kw&quot;&gt;ebx&lt;/span&gt;,signal(%&lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;)
    incl %&lt;span class=&quot;kw&quot;&gt;ecx&lt;/span&gt;
    pushl %&lt;span class=&quot;kw&quot;&gt;ecx&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;call&lt;/span&gt; do_signal
    popl %&lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;3:&lt;/span&gt;  popl %&lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;
    popl %&lt;span class=&quot;kw&quot;&gt;ebx&lt;/span&gt;
    popl %&lt;span class=&quot;kw&quot;&gt;ecx&lt;/span&gt;
    popl %&lt;span class=&quot;kw&quot;&gt;edx&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;pop&lt;/span&gt; %&lt;span class=&quot;kw&quot;&gt;fs&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;pop&lt;/span&gt; %&lt;span class=&quot;kw&quot;&gt;es&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;pop&lt;/span&gt; %&lt;span class=&quot;kw&quot;&gt;ds&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;iret&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以发现，上面代码中大部分代码是寄存器状态保存与恢复，堆栈段的切换。核心代码为&lt;code&gt;call sys_call_table(,%eax,4)&lt;/code&gt;，它是一个函数调用，函数的地址为&lt;code&gt;sys_call_table(,%eax,4) = sys_call_table + 4*%eax&lt;/code&gt;说明&lt;code&gt;sys_call_table&lt;/code&gt;为一个数组入口，数组中的元素长度都为4个字节，我们要访问数组中的第&lt;code&gt;%eax&lt;/code&gt;个元素。而&lt;code&gt;%eax&lt;/code&gt;即为系统调用号。&lt;code&gt;sys_call_table&lt;/code&gt;就是所有系统调用的函数指针数组。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 定义在 linux/include/linux/sys.h
fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,
sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,
sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,
sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,
sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,
sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,
sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,
sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,
sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,
sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,
sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,
sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,
sys_setreuid,sys_setregid };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，我们找到了最终真正的执行核心函数地址&lt;code&gt;sys_write&lt;/code&gt;，这个是操作实现的内核代码，所有的屏幕打印就是由该函数最终实现。它里面涉及IO的一些硬件驱动函数，我们在这里就不再继续深入了。&lt;/p&gt;
&lt;p&gt;到此，我们已经通过printf这样一个上层的函数接口，清楚操作系统是如何一步步为了我们提供了一个内核调用的方法。如此的精细控制，让人感叹。&lt;/p&gt;

&lt;p&gt;下面简单说明一下，如何在操作系统源码中添加两个我们自己的系统调用&lt;code&gt;whoami&lt;/code&gt;和&lt;code&gt;iam&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;iam系统调用把我们指定的一个字符串保存在内核中。&lt;/li&gt;
&lt;li&gt;whoami把内核中的通过iam设置的那个字符串读取出来。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是具体的操作步骤。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在linux/kernel文件夹加入一个自定义的文件who.c&lt;/li&gt;
&lt;li&gt;在who.c中实现sys_iam和sys_whoami，需要注意的实现这两个函数时，需要用于用户栈数据与内核栈数据拷贝。&lt;/li&gt;
&lt;li&gt;在linux/include/linux/sys.h中的sys_call_table中添加两个数组项。&lt;/li&gt;
&lt;li&gt;修改linux/kernel/system_call.s中的系统调用个数nr_system_calls。&lt;/li&gt;
&lt;li&gt;用int 0x80实现iam和whoami函数。&lt;/li&gt;
&lt;li&gt;编写用户程序调用上面两个函数。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;要注意的是：在系统调用的过程中，段寄存器ds和es指向内核数据空间，而fs被设置指向用户数据空间。因此在实际数据块信息传递过程中Linux内核就可以利用fs寄存器来执行内核数据空间与用户数据空间之间的数据复制工作，并且在复制过程中内核程序不需要对数据边界范围作任何检查操作。边界检查操作由CPU自动完成。内核程序的实际数据传送工作可以使用&lt;code&gt;get_fs_byte()&lt;/code&gt;和&lt;code&gt;puts_fs_bypte()&lt;/code&gt;等函数进行。&lt;/p&gt;

&lt;p&gt;[1] 《Linux内核完全剖析基于0.12内核》 赵炯著。&lt;br/&gt;[2] 网易云课堂，哈尔滨工业大学《操作系统之应用》 李治军。&lt;/p&gt;
</description>
<pubDate>Sun, 05 Nov 2017 14:07:00 +0000</pubDate>
<dc:creator>☆Ronny丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ronny/p/7789057.html</dc:identifier>
</item>
<item>
<title>浅谈MES系统SMT的JIT功能（一）：JIT原理 - Wesley.Liang</title>
<link>http://www.cnblogs.com/Weiss/p/7788969.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Weiss/p/7788969.html</guid>
<description>&lt;p&gt;前段时间帮忙客户实现了MES系统的SMT线上的JIT功能（JIT功能只适合电子行业的生产线），今天就来谈谈JIT功能是什么，为什么工厂车间需要用到JIT等等一些经验&lt;/p&gt;
&lt;p&gt;首先说说JIT：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;准时制生产方式（Just In Time简称 JIT）指的是：将必要的零件以必要的数量在必要的时间送到生产线，并且只将所需要的零件、只以所需要的数量、只在正好需要的时间送到生产&lt;/li&gt;
&lt;li&gt;JIT生产方式的基本思想是“只在需要的时候，按需要的量，生产所需的产品”，也就是追求一种无库存，或库存达到最小的生产系统&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上这些是网上说的一些原理，说说我自己的看法&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;以前工厂里生产产品，仓库人员都是会把一个物料内的所有原材料一次性都发到生产线上，然后仓库人员就算上已经完成他的工作了，下面仓库人员可能就无所事事，但生产线上的原材料可能是需要生产一天或一天以上才会把物料用完，这就导致了这些物料堆在生产线上，物料使用效率并不高，这些方式是以仓库人员为核心的，通过仓库后台来拉动生产线上的方式&lt;/li&gt;
&lt;li&gt;JIT的方式（也叫拉式叫料）是指以生产线为核心的去拉动仓库人员的方式，原理是生产人员先会在工单上面进行排程，如果一片PCB板有双面，可以分为正反面二个排程工单来生产，再导入上料清单数据，然后根据导入的上料清单数据来生成备料清单，再根据系统的计算方式来计算这个排程工单要分几次来发料，最后仓库人员在仓库的JIT配送看板上根据看板上显示的排程工单来发对应数量的物料&lt;/li&gt;
&lt;li&gt;这样的好处是
&lt;ol&gt;&lt;li&gt;仓库人员发的物料是只够生产线上生产几小时的物料，不用像以前那样一次性的都发到生产线上，这样会大大提高物料的使用效率&lt;/li&gt;
&lt;li&gt;JIT配送看板是有一个提前提醒的设置，如果用户设置了提前4小时显示数据，那么生产线上的使用时间只剩下4小时的话，那么系统就会提示仓库人员发料，仓库人员只需要根据JIT配送看板上的排程工单发料即可，这样整个工厂的生产方式都是以生产线为核心来生产的，通过生产线上的生产情况来拉动整个后台仓库效率，这也大大提高了工厂的生产效率&lt;/li&gt;
&lt;li&gt;JIT还可以实时跟踪整个生产线上的生产情况，物料的上料、抛料率、达到率等一些生产数据，方便企业高层了解整个生产线上的情况，更方便作出高效的决策&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;今天就先说到这里，下次再说一些JIT是内部的仔细功能，一步一步的介绍JIT功能的实现流程&lt;/p&gt;
</description>
<pubDate>Sun, 05 Nov 2017 13:49:00 +0000</pubDate>
<dc:creator>Wesley.Liang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Weiss/p/7788969.html</dc:identifier>
</item>
<item>
<title>SpringAop源码情操陶冶-AspectJAwareAdvisorAutoProxyCreator - 南柯问天</title>
<link>http://www.cnblogs.com/question-sky/p/7788931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/question-sky/p/7788931.html</guid>
<description>&lt;blockquote readability=&quot;5.0829875518672&quot;&gt;
&lt;p&gt;本文将对SpringAop中如何为AspectJ切面类创建自动代理的过程作下简单的分析，阅读本文前需要对AOP的Spring相关解析有所了解，具体可见&lt;a href=&quot;http://www.cnblogs.com/question-sky/p/7688863.html&quot;&gt;Spring源码情操陶冶-AOP之ConfigBeanDefinitionParser解析器&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;官方注释&quot;&gt;官方注释&lt;/h3&gt;
&lt;p&gt;注释内容如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{@link org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * subclass that exposes AspectJ's invocation context and understands AspectJ's rules&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * for advice precedence when multiple pieces of advice come from the same aspect.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@author &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;Adrian Colyer&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@author &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;Juergen Hoeller&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@author &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;Ramnivas Laddad&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@since &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;2.0&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从注释上可知此类是&lt;code&gt;org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator&lt;/code&gt;抽象类的继承类，主要为&lt;code&gt;AspectJ&lt;/code&gt;切面服务。具体的针对如何创建代理，肯定是在父类中实现了，我们在此研究下父类。&lt;/p&gt;
&lt;h3 id=&quot;abstractautoproxycreator-aop代理实现的抽象父类&quot;&gt;AbstractAutoProxyCreator-AOP代理实现的抽象父类&lt;/h3&gt;
&lt;p&gt;继承结构上为&lt;code&gt;extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware&lt;/code&gt;，而其中的&lt;code&gt;SmartInstantiationAwareBeanPostProcessor&lt;/code&gt;是beanPostProcessor接口的子类，此处注意下此接口。下面分析的内容建立在spring在实例化bean对象的时候会调用beanPostProcessor的公有接口。&lt;/p&gt;
&lt;h4 id=&quot;abstractautoproxycreatorpostprocessafterinitialization-创建代理的入口函数&quot;&gt;AbstractAutoProxyCreator#postProcessAfterInitialization()-创建代理的入口函数&lt;/h4&gt;
&lt;p&gt;先奉上源码内容如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * Create a proxy with the configured interceptors if the bean is&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * identified as one to proxy by the subclass.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@see #getAdvicesAndAdvisorsForBean&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;postProcessAfterInitialization&lt;/span&gt;(Object bean, String beanName) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (bean != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            Object cacheKey = &lt;span class=&quot;fu&quot;&gt;getCacheKey&lt;/span&gt;(bean.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;(), beanName);
            &lt;span class=&quot;co&quot;&gt;// 如果缓存中不存在则调用wrapIfNecessary()方法创建代理&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;earlyProxyReferences&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;contains&lt;/span&gt;(cacheKey)) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;wrapIfNecessary&lt;/span&gt;(bean, beanName, cacheKey);
            }
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; bean;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上调用的是beanPostProcessor接口的&lt;code&gt;postProcessAfterInitialization(Object bean,String beanName)&lt;/code&gt;的方法，其一般是bean对象被实例化的最后一步操作的，此处避而不谈了，我们转而查看&lt;code&gt;wrapIfNecessary()&lt;/code&gt;的内部是如何操作的&lt;/p&gt;
&lt;h4 id=&quot;abstractautoproxycreatorwrapifnecessary-创建代理对象帮助函数&quot;&gt;AbstractAutoProxyCreator#wrapIfNecessary()-创建代理对象帮助函数&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param bean &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;the raw bean instance&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param beanName &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;the name of the bean&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param cacheKey &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;the cache key for metadata access&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;a proxy wrapping the bean, or the raw bean instance as-is&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;wrapIfNecessary&lt;/span&gt;(Object bean, String beanName, Object cacheKey) {
        &lt;span class=&quot;co&quot;&gt;// 查看缓存是否存在此bean&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (beanName != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;targetSourcedBeans&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;contains&lt;/span&gt;(beanName)) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; bean;
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (Boolean.&lt;span class=&quot;fu&quot;&gt;FALSE&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;advisedBeans&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(cacheKey))) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; bean;
        }
        &lt;span class=&quot;co&quot;&gt;// Advice/Advisor/AopInfrastructureBean接口的beanClass不进行代理以及对beanName为aop内的切面名也不进行代理，此处可查看子类复写的sholdSkip()方法&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isInfrastructureClass&lt;/span&gt;(bean.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;()) || &lt;span class=&quot;fu&quot;&gt;shouldSkip&lt;/span&gt;(bean.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;(), beanName)) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;advisedBeans&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(cacheKey, Boolean.&lt;span class=&quot;fu&quot;&gt;FALSE&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; bean;
        }

        &lt;span class=&quot;co&quot;&gt;// Create proxy if we have advice.&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 查找对代理类相关的advisor对象集合，此处就与ponit-cut表达式有关了&lt;/span&gt;
        Object[] specificInterceptors = &lt;span class=&quot;fu&quot;&gt;getAdvicesAndAdvisorsForBean&lt;/span&gt;(bean.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;(), beanName, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;// 对相应的advisor不为空才采取代理&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (specificInterceptors != DO_NOT_PROXY) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;advisedBeans&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(cacheKey, Boolean.&lt;span class=&quot;fu&quot;&gt;TRUE&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;// 调用createProxy()方法创建真正的代理对象&lt;/span&gt;
            Object proxy = &lt;span class=&quot;fu&quot;&gt;createProxy&lt;/span&gt;(
                    bean.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;(), beanName, specificInterceptors, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SingletonTargetSource&lt;/span&gt;(bean));
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;proxyTypes&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(cacheKey, proxy.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;());
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; proxy;
        }

        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;advisedBeans&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(cacheKey, Boolean.&lt;span class=&quot;fu&quot;&gt;FALSE&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; bean;
    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对上述的源码分析作下简单的总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先对&lt;code&gt;Advice/Advisor/AopInfrastructureBean&lt;/code&gt;接口的实现类不进行代理操作；对beanName为&lt;code&gt;aspectName&lt;/code&gt;的bean对象也不采取代理操作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;再而需要查找beanClass有几个advisor与之相关联，这当然与每个&lt;code&gt;Advisor&lt;/code&gt;接口内的&lt;code&gt;PointCut&lt;/code&gt;对象对应的表达式&lt;code&gt;expression&lt;/code&gt;有关。只有关联的&lt;code&gt;Advisor&lt;/code&gt;个数不为0，才可采取代理(此处查找Advisor关联个数的源码读者可自行分析&lt;strong&gt;AspectJAwareAdvisorAutoProxyCreator#shouldSkip()&lt;/strong&gt;方法)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;真正的代理操作是由&lt;code&gt;AbstractAutoProxyCreator#createProxy()&lt;/code&gt;内部方法实现&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;abstractautoproxycreatorcreateproxy-创建真正的aop代理&quot;&gt;AbstractAutoProxyCreator#createProxy()-创建真正的AOP代理&lt;/h4&gt;
&lt;p&gt;对符合条件的beanClass进行相应的代理操作，简单看下源码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * Create an AOP proxy for the given bean.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param beanClass &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;the class of the bean&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param beanName &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;the name of the bean&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param specificInterceptors &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;the set of interceptors that is&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * specific to this bean (may be empty, but not null)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param targetSource &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;the TargetSource for the proxy,&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * already pre-configured to access the bean&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;the AOP proxy for the bean&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@see #buildAdvisors&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;createProxy&lt;/span&gt;(
            Class&amp;lt;?&amp;gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;beanFactory&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; ConfigurableListableBeanFactory) {
            AutoProxyUtils.&lt;span class=&quot;fu&quot;&gt;exposeTargetClass&lt;/span&gt;((ConfigurableListableBeanFactory) &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;beanFactory&lt;/span&gt;, beanName, beanClass);
        }
        &lt;span class=&quot;co&quot;&gt;// 创建AOP代理工厂，拷贝相同的属性&lt;/span&gt;
        ProxyFactory proxyFactory = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ProxyFactory&lt;/span&gt;();
        proxyFactory.&lt;span class=&quot;fu&quot;&gt;copyFrom&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;// 是否采用动态代理&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!proxyFactory.&lt;span class=&quot;fu&quot;&gt;isProxyTargetClass&lt;/span&gt;()) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;shouldProxyTargetClass&lt;/span&gt;(beanClass, beanName)) {
                proxyFactory.&lt;span class=&quot;fu&quot;&gt;setProxyTargetClass&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
            }
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;// 查看beanClass对应的类是否含有InitializingBean.class/DisposableBean.class/Aware.class接口，无则采用静态代理，有则采用动态代理&lt;/span&gt;
                &lt;span class=&quot;fu&quot;&gt;evaluateProxyInterfaces&lt;/span&gt;(beanClass, proxyFactory);
            }
        }
        &lt;span class=&quot;co&quot;&gt;// 获得所有关联的Advisor集合&lt;/span&gt;
        Advisor[] advisors = &lt;span class=&quot;fu&quot;&gt;buildAdvisors&lt;/span&gt;(beanName, specificInterceptors);
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Advisor advisor : advisors) {
            proxyFactory.&lt;span class=&quot;fu&quot;&gt;addAdvisor&lt;/span&gt;(advisor);
        }
        &lt;span class=&quot;co&quot;&gt;// 此处的targetSource一般为SingletonTargetSource&lt;/span&gt;
        proxyFactory.&lt;span class=&quot;fu&quot;&gt;setTargetSource&lt;/span&gt;(targetSource);
        &lt;span class=&quot;fu&quot;&gt;customizeProxyFactory&lt;/span&gt;(proxyFactory);

        proxyFactory.&lt;span class=&quot;fu&quot;&gt;setFrozen&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;freezeProxy&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;// 是否设置预过滤模式，此处针对本文为true&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;advisorsPreFiltered&lt;/span&gt;()) {
            proxyFactory.&lt;span class=&quot;fu&quot;&gt;setPreFiltered&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
        }

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; proxyFactory.&lt;span class=&quot;fu&quot;&gt;getProxy&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;getProxyClassLoader&lt;/span&gt;());
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对以上的源码也作下简单的总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;采用ProxyFactory对象来创建代理对象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果AOP没有指定proxyTargetClass属性，则针对beanClass含有非&lt;code&gt;InitializingBean/DisposableBean/Aware&lt;/code&gt;接口的bean采用静态代理，反之采用动态代理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ProxyFactory创建代理对象前也需要设置与beanClass相关联的advisor集合&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;proxyfactorygetproxy-最终创建代理类&quot;&gt;ProxyFactory#getProxy()-最终创建代理类&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;getProxy&lt;/span&gt;(ClassLoader classLoader) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;createAopProxy&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getProxy&lt;/span&gt;(classLoader);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上的源码我们只需要关注&lt;code&gt;createAopProxy()&lt;/code&gt;方法即可，此处我们直接查看&lt;code&gt;DefaultAopProxyFactory#createAopProxy()&lt;/code&gt;源码，参考如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; AopProxy &lt;span class=&quot;fu&quot;&gt;createAopProxy&lt;/span&gt;(AdvisedSupport config) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; AopConfigException {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (config.&lt;span class=&quot;fu&quot;&gt;isOptimize&lt;/span&gt;() || config.&lt;span class=&quot;fu&quot;&gt;isProxyTargetClass&lt;/span&gt;() || &lt;span class=&quot;fu&quot;&gt;hasNoUserSuppliedProxyInterfaces&lt;/span&gt;(config)) {
            Class&amp;lt;?&amp;gt; targetClass = config.&lt;span class=&quot;fu&quot;&gt;getTargetClass&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (targetClass == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;AopConfigException&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;TargetSource cannot determine target class: &quot;&lt;/span&gt; +
                        &lt;span class=&quot;st&quot;&gt;&quot;Either an interface or a target is required for proxy creation.&quot;&lt;/span&gt;);
            }
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (targetClass.&lt;span class=&quot;fu&quot;&gt;isInterface&lt;/span&gt;() || Proxy.&lt;span class=&quot;fu&quot;&gt;isProxyClass&lt;/span&gt;(targetClass)) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;JdkDynamicAopProxy&lt;/span&gt;(config);
            }
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ObjenesisCglibAopProxy&lt;/span&gt;(config);
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;JdkDynamicAopProxy&lt;/span&gt;(config);
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述源码很简单，默认是采用JDK静态代理，对beanClass为非接口实现类采取CGLIB动态代理&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;循序渐进的分析的总结见以上的各部分小结，我们只需要知道AOP代理的beanClass必须有相应的&lt;code&gt;Advisor&lt;/code&gt;接口与之绑定，才会创建AOP代理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;创建的代理类无非是JDK代理抑或是CGLIB代理，但是具体关联的&lt;code&gt;Advisor&lt;/code&gt;集合的处理逻辑见下文讲解&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
<pubDate>Sun, 05 Nov 2017 13:41:00 +0000</pubDate>
<dc:creator>南柯问天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/question-sky/p/7788931.html</dc:identifier>
</item>
<item>
<title>线上服务故障处理原则 - tylercao</title>
<link>http://www.cnblogs.com/tylercao/p/7788893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylercao/p/7788893.html</guid>
<description>&lt;h2 id=&quot;墨菲定律&quot;&gt;墨菲定律&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;任何事情都没有表面看起来那么简单&lt;/li&gt;
&lt;li&gt;所有事情的发展都会比你预计的时间长&lt;/li&gt;
&lt;li&gt;会出错的事情总会出错&lt;/li&gt;
&lt;li&gt;如果担心某个事情发生，那么它更有可能发生&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;墨菲定律暗示我们，如果担心某种情况会发生，那么它更有可能发生，久而久之就一定会发生。这警示我们，在互联网公司，对生成环境发生的任何怪异现象和问题都不要轻视，对其背后的原因一定要调查清楚。同样，海恩法则也强调任何严重的事故背后都是很多次小问题的积累，当到一定量级后会导致质变，严重的问题就会浮出水面。&lt;br/&gt;那么，我们需要对线上服务产生任何现象，哪怕是小问题，都要刨根问底，对任何现象都要遵循下面问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么会发生 ？&lt;/li&gt;
&lt;li&gt;发生了该怎么应对 ？&lt;/li&gt;
&lt;li&gt;怎么恢复 ？&lt;/li&gt;
&lt;li&gt;怎么避免 ？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;应急目标&quot;&gt;应急目标&lt;/h2&gt;
&lt;p&gt;在生成环境发生故障时快速恢复服务，避免或减少故障带来的损失，避免或减少故障对客户的影响&lt;/p&gt;
&lt;h2 id=&quot;应急原则&quot;&gt;应急原则&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;应第一时间恢复系统，而不是彻底解决呢问题，快速止损&lt;/li&gt;
&lt;li&gt;明显资金损失时，要第时间升级，快速止损&lt;/li&gt;
&lt;li&gt;指标要围绕目标，快速启动应急过程与止损方案&lt;/li&gt;
&lt;li&gt;当前负责人不能短时间内解决问题，则必须进行升级处理&lt;/li&gt;
&lt;li&gt;处理过程在不影响用户体验的前提下，保留现场&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;应急方法与流程&quot;&gt;应急方法与流程&lt;/h2&gt;
&lt;p&gt;线上应急一般分为 6 个阶段&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;发现问题&lt;/li&gt;
&lt;li&gt;定位问题&lt;/li&gt;
&lt;li&gt;解决问题&lt;/li&gt;
&lt;li&gt;回顾问题&lt;/li&gt;
&lt;li&gt;改进措施&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;过程中要记住，应急只有一个总体目标：尽快恢复，消除影响。不管处于哪个阶段，首先想到的必须是恢复问题，恢复问题不一定能定位问题，也不一定有完美的解决方案，可能通过经验或者开关等。但这可以达到快速恢复的目的，然后保留现场，以及定位问题，解决问题和复盘&lt;/p&gt;
&lt;h3 id=&quot;发现问题&quot;&gt;发现问题&lt;/h3&gt;
&lt;p&gt;通常我们通过系统层面、应用层面和中间件层面监控来发现问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统层面监控包括&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;系统的 CPU 使用率&lt;/li&gt;
&lt;li&gt;Load average&lt;/li&gt;
&lt;li&gt;Memory&lt;/li&gt;
&lt;li&gt;I/O （网络与磁盘）&lt;/li&gt;
&lt;li&gt;SWAP 使用情况&lt;/li&gt;
&lt;li&gt;线程数&lt;/li&gt;
&lt;li&gt;File Description 文件描述符等&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;应用层面监控包括&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;接口的响应时间&lt;/li&gt;
&lt;li&gt;QPS&lt;/li&gt;
&lt;li&gt;调用频次&lt;/li&gt;
&lt;li&gt;接口成功率&lt;/li&gt;
&lt;li&gt;接口波动率等&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;中间件层面监控包括数据库、缓存、消息队列。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;对数据库的负载、慢查询、连接数等监控&lt;/li&gt;
&lt;li&gt;对缓存的连接数、占用内存、吞吐量、响应时间等监控&lt;/li&gt;
&lt;li&gt;消息队列的响应时间、吞吐量、负载、堆积情况等监控&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;定位问题&quot;&gt;定位问题&lt;/h3&gt;
&lt;p&gt;分析定位过程中先考虑系统最近发生的变化，需要考虑如下几方面&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;故障系统最近是否上过线？&lt;/li&gt;
&lt;li&gt;依赖的基础平台与资源是否升级过？&lt;/li&gt;
&lt;li&gt;依赖的系统是否上过线？&lt;/li&gt;
&lt;li&gt;运营是否在系统内做过运营变更？&lt;/li&gt;
&lt;li&gt;网络是否有波动？&lt;/li&gt;
&lt;li&gt;最近的业务量是否涨了？&lt;/li&gt;
&lt;li&gt;运营方是否有促销活动？&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;解决问题&quot;&gt;解决问题&lt;/h3&gt;
&lt;p&gt;解决问题要以定位问题为基础，必须清晰定位问题产生的根本原因，在提出解决问题的有效方案，没有明确原因之前，不用使用各种方法来尝试修复问题，可能还没有解决这个问题又引入了下个问题，想想刚刚提到的墨菲定律&lt;/p&gt;
&lt;h3 id=&quot;回顾问题&quot;&gt;回顾问题&lt;/h3&gt;
&lt;p&gt;解决问题后，需应急团队与相关方回顾事故产生的原因、应急过程的合理性、提出整改措施，主要聚焦在以下几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类似的问题还有哪些没有发生？&lt;/li&gt;
&lt;li&gt;做了哪些事情，事故就不会再发生？&lt;/li&gt;
&lt;li&gt;做了哪些事情，及时发生故障，也不会产生影响？&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;改进措施&quot;&gt;改进措施&lt;/h3&gt;
&lt;p&gt;根据回顾问题提出的改进措施，以正式的项目管理方式进行统一管理，采用 SMART 原则来跟进&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;分布式服务架构原理、设计与实战 &lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 05 Nov 2017 13:35:00 +0000</pubDate>
<dc:creator>tylercao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tylercao/p/7788893.html</dc:identifier>
</item>
</channel>
</rss>