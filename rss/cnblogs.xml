<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SAP中的BRF+ - 氢氦</title>
<link>http://www.cnblogs.com/hhelibeb/p/9021665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhelibeb/p/9021665.html</guid>
<description>&lt;p&gt;即便努力去尝试最小化SAP系统中的自定义内容，大量自定义业务逻辑通常还是无法避免的。在过去，这意味着需要在系统的各种地方引入自定义ABAP代码，包括user-exits，enhancement，BAdi和自定义程序等等。&lt;strong&gt;考虑到SAP系统的复杂性和相互依赖性，人们不得不小心翼翼地管理基于ABAP的自定义内容，以保证业务逻辑在不同的功能区域一致、且不重复。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在，&lt;span id=&quot;title-text&quot; class=&quot;with-breadcrumbs&quot;&gt;&lt;a href=&quot;https://wiki.scn.sap.com/wiki/pages/viewpage.action?pageId=428114190&quot;&gt;Business Rule Framework Plus&lt;/a&gt;（业务规则框架，以下简称BRFplus或BRF+）&lt;/span&gt;来了，它是SAP推出的新功能，可以在一个位置、通过可复用的方式管理你的所有自定义业务逻辑。&lt;/p&gt;

&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: SAP中的BRF+&quot; href=&quot;http://www.cnblogs.com/hhelibeb/p/9021665.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hhelibeb/p/9021665.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;英文标题：&lt;a class=&quot;u-url&quot; href=&quot;http://www.xpertminds.net/blog/2015/3/9/brfplus-a-hidden-gem-within-your-sap-system&quot; rel=&quot;bookmark&quot;&gt;BRFplus - a hidden gem within your SAP system&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;title-text&quot; class=&quot;with-breadcrumbs&quot;&gt;可用性&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;with-breadcrumbs&quot;&gt;通常来说，&lt;span class=&quot;with-breadcrumbs&quot;&gt;BRF+&lt;/span&gt;功能在任何基于合适版本的SAP NeWeaver的系统都可用。要快速地检验它是否在你的系统上可用，只需要执行事务代码&lt;strong&gt;BRFPULS&lt;/strong&gt;或者&lt;strong&gt;BRF+&lt;/strong&gt;。如果你看到了在新浏览器窗口打开的web应用，那么基本上你的环境允许使用&lt;span class=&quot;with-breadcrumbs&quot;&gt;BRF+&lt;/span&gt;。（如果不能的话打开的话，有可能是系统本身不支持，也有可能是没有配置webdynpro相关服务等）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;with-breadcrumbs&quot;&gt;值得注意的是，在2013年，SAP发布了一个名为Decision Service Management（DSM）的解决方案，它建立在BRF+的基础上，并且添加了某些新的功能。最重要的是DSM允许跨SAP系统和实例的中央业务规则管理。然而，DSM需要额外的许可证，相反&lt;span class=&quot;with-breadcrumbs&quot;&gt;一般&lt;/span&gt;BRF+通过已有的SAP许可证就可以使用。我们发现对绝大多数客户来说，DSM的功能有点过了头，BRF+则更适合使用。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;with-breadcrumbs&quot;&gt;使用场景&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;with-breadcrumbs&quot;&gt;现在你知道了一点BRF+的历史，那么在你能用它来做什么呢？这里是一些真实世界利用BRF+满足业务需求的例子：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输出表单中的Logo判断&lt;/li&gt;
&lt;li&gt;服务提醒文档的默认优先级和截止日期判断&lt;/li&gt;
&lt;li&gt;销售订单的默认工厂判断&lt;/li&gt;
&lt;li&gt;SAP Transportation Management中的默认载具判断&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从技术的观点看，BRF+最常见的用例是在user-exits和增强中的自定义业务逻辑实施中。事实上，在这些情况下，BRF+是我们实现自定义业务逻辑的首选实现手段。它在较高层面上可以被描述为2步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在BRF+中创建一个function，依据需要的业务逻辑，它接收输入、进行处理，然后给出输出结果。&lt;/li&gt;
&lt;li&gt;通过ABAP在user-exits/BAdi/enhancement/自定义程序等地方调用先前创建的BRF+应用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;很重要的一点是，在上述的（aforementioned）方式中&lt;strong&gt;你还是需要写一些ABAP代码来调用BRF+ function&lt;/strong&gt;。（和完全使用ABAP代码实现业务逻辑的）区别在于，通常来说，在这种情况下，ABAP代码只负责调用BRF+，不会直接包含业务逻辑。你可能要问这样做的好处在哪里。它的好处是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BRF+ function易于复用，通常可以大大地减少系统中重复业务逻辑实现的数量。&lt;/li&gt;
&lt;li&gt;BRF+包含一个巨大的expression库，可以加速映射业务规则的开发过程，特别是这些业务规则比较复杂的情况下。使用ABAP编码来从零开始（from scratch）实现某些东西，也许可以花上数天甚至数周的时间，但是在BRF+里只要使用expression就可以快速地建模实现。&lt;/li&gt;
&lt;li&gt;你的所有自定义业务逻辑可以在一个地方实现——BRF+事务。你不需要从庞大的自开发程序、增强中搜寻代码以调整现有的业务逻辑。&lt;/li&gt;
&lt;li&gt;对现有的业务逻辑的简单调整可以经由非编码的方式实现，不需要开发人员的参与。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后一点值得详细阐述（elaborating on）。SAP通常建议通过BRF+工具让业务用户代替ABAP开发者来作为他们自己的逻辑的维护者。坦白说，这种建议有点夸张（exaggerattion）。实际上，BRF+元素（function, expression等）的创建依然是一件相当技术性的活动。大部分没有技术背景的SAP专家可能会发现，想要掌握BRF+的全部内容是件具有挑战性的事情。了解一些基本的编程概念，如变量和循环，会对BRF+的使用起很大帮助，即便你只是通过鼠标来创建这些对象，而不是（as opposed）写ABAP代码。但是撇开陡峭的学习曲线不说，在具备足够多的学习时间和努力的情况下，SAP功能分析师当然是可以精通BRF+的，由此便可以在不依赖开发者的情况下构建复杂的自定义业务逻辑。然而，业务用户完全是另一回事。业务用户对BRF+进行某些实验性的调整是可能的，例如改变已有的decision table中的值，但是BRF+内的主要变更还是需要由IT团队进行。&lt;/p&gt;
&lt;h2&gt;特性&lt;/h2&gt;
&lt;p&gt;BRF+中包含很多了不起的特性，使得它是一个杰出的业务规则框架。&lt;/p&gt;
&lt;h3&gt;expressions&lt;/h3&gt;
&lt;p&gt;在许多方面上expressions是BRF+中第一个令人心动的东西。它们是预包装的逻辑对象，可以在BRF+环境中大大加速业务规则的建模。虽然BRF+中支持多种表达式类型，但最常用的一种是Decision Table。如果你熟悉SAP系统中的&lt;strong&gt;条件技术&lt;/strong&gt;，decision table会给你相似的感觉，并且它会提供扩展性更强的功能。除了（In addition to）可以从表的顶部检索到底部直到找到匹配的记录为止外，你也可以维护输入值为多值的range、sets、通过空白来表示任意值、以及使用其它一些逻辑操作符等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201805/994049-20180511143521607-1152221753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;customizing and master data applications&lt;/h3&gt;
&lt;p&gt;自定义和主数据应用（customizing and master data applications）是BRF+中的一个灵巧的特性。自定义应用需要使用SAP transports来在不同SAP系统之间移动修改，相反主数据应用允许直接在每个SAP系统和client直接进行修改。在你将主数据值，比如客户、供应商、物料等是业务逻辑的一部分时特别有用。记住因为在多数情况下BRF+通过ABAP调用，function本身需要存在在一个自定义应用中。但是这些自定义级别的function接下来可以利用存在于主数据级别应用下的expressions（例如decision tables）。一言蔽之（In a nutshell），你可以在一个业务规则中混合使用自定义和主数据BRF+对象。&lt;/p&gt;
&lt;h3&gt;user interface&lt;/h3&gt;
&lt;p&gt;BRF+中的建模大多通过“点击”的用户界面进行，通过事务代码BRF+访问它。你可以通过简单地右击屏幕左侧的节点来创建新的对象，并且通过上下文菜单选择合适的条目。&lt;/p&gt;
&lt;h3&gt;api&lt;/h3&gt;
&lt;p&gt;你也可以通过API和BRF+交互。这意味着你不仅可以通过事务BRF+来创建和更新BRF+对象，你也可以通过标准交付ABAP类和方法（standard delivered ABAP classes and methods）实现同样的事情。例如，在某个场景中我们需要存储美国的柴油平均价到BRF+的decision table中。我们可以创建一个自定义ABAP程序通过公网服务来查找上周的柴油价格，并且最后经由BRF+ API更新decision表。&lt;/p&gt;
&lt;h3&gt;web services&lt;/h3&gt;
&lt;p&gt;BRF+ functions可以很容易地暴露为web services。这意味着你可以同时在SAP和非SAP系统中消费BRF+业务逻辑。&lt;/p&gt;
&lt;h3&gt;HELPER TOOLS&lt;/h3&gt;
&lt;p&gt;BRF+伴随着大量的工具，可以帮助你开发、导入/导出、检查和BRF+对象和排查故障。其中某些工具可以从BRF+事务中的菜单访问，不过最简单的查找他们的方式是在SE38中运行程序FDT_HELPERS。较早地了解这些工具，你就可以在将来省下很多时间。例如，下图里选中的工具允许你快速地识别和解决大部分有关系统间传输BRF+对象的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201805/994049-20180511152935115-257105609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;总而言之，大部分SAP客户都可以在不需要额外许可证的条件下使用BRF+。我们鼓励你们仔细了解BRF+、并且开始为你们的自定义业务逻辑需求使用它。&lt;/p&gt;


</description>
<pubDate>Fri, 11 May 2018 07:50:00 +0000</pubDate>
<dc:creator>氢氦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhelibeb/p/9021665.html</dc:identifier>
</item>
<item>
<title>Nginx服务器导致CSS无法解析不起效果 - hongsusu</title>
<link>http://www.cnblogs.com/hongsusu/p/nginx.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongsusu/p/nginx.html</guid>
<description>&lt;p&gt;最近部署一个项目html,js正常加载，css也没有报404，css能够正常获取，只是浏览器无法解析，研究了一下发现,原来是配置Nginx的时候将/etc/nginx/nginx.conf的一行include /etc/nginx/mime.types;误删了，导致了Nginx无法正确识别CSS文件，因此向浏览器发送了错误的MIME类型。加上那行，然后重启Nginx守护进行就好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216926/201805/1216926-20180511155617231-430917854.png&quot; alt=&quot;&quot; width=&quot;607&quot; height=&quot;99&quot;/&gt;&lt;/p&gt;

&lt;p&gt;错误的css和js类型如下面&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1216926/201805/1216926-20180511154601810-404738887.png&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;148&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正确的css和js类型应该如下面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216926/201805/1216926-20180511154741358-826078995.png&quot; alt=&quot;&quot; width=&quot;631&quot; height=&quot;157&quot;/&gt;&lt;/p&gt;


&lt;p&gt;记录下来,希望对别人有所帮助.&lt;/p&gt;
</description>
<pubDate>Fri, 11 May 2018 07:50:00 +0000</pubDate>
<dc:creator>hongsusu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongsusu/p/nginx.html</dc:identifier>
</item>
<item>
<title>浅谈编程语言中的新宠Python，你叫它如何不火？ - Python新世界</title>
<link>http://www.cnblogs.com/xinshiye/p/9024905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinshiye/p/9024905.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/1526022518016a250b18164&quot; alt=&quot;浅谈编程语言中的新宠Python，你叫它如何不火？&quot;/&gt;&lt;/p&gt;

&lt;p&gt;凡是对编程有所关注的朋友都已经知道，Python公布于1991年，即使出现的时间不是很遥远，但是在众多爱好者的贡献下已经发展到全民Python的地步。&lt;/p&gt;
&lt;p&gt;Python最近火起来的笼统原因：面向企业客户和一流项目，Python几乎是万能的！&lt;/p&gt;
&lt;p&gt;你可以利用Python来构建：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9.pstatp.com/large/pgc-image/152602036215795fb3c3b7b&quot; alt=&quot;浅谈编程语言中的新宠Python，你叫它如何不火？&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/152602242820145106b48e3&quot; alt=&quot;浅谈编程语言中的新宠Python，你叫它如何不火？&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Python很纯粹，易于阅读与编写，为最高效的完成任务而生！Python的设计者不太强调惯用的语法，这使得Python加倍易于使用，甚至不是程序员员或开发人员都可以随意上手。&lt;/p&gt;
&lt;p&gt;别的，Python还可以满足各类开发需求。供给各类选择，它是一门真正通用的编程。若是习惯了使用python，可以很随意地从一个行业跳到别的一个行业，由于Python被遍及地用于：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/152602070307474bffbc851&quot; alt=&quot;浅谈编程语言中的新宠Python，你叫它如何不火？&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而让人觉得不可思议的是：由于Python易于使用，所以被大多数程序员当做第二或第三种学习的语言，并没有将Python作为本身最首要的技能，而是还是很幼稚的把它当做一个玩具！殊不知在你眼里它是玩具，那么你就是个小孩！互联网科技公司大佬“谷歌”他们甚至有一个门户，专门为Python开发人员供给课程练习、演讲视频等，他们大量招聘Python程序员！&lt;/p&gt;
&lt;p&gt;固然，Django框架的火起是python成功的一个关键因素。但是从真正意义上来说这是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/15260211235114114211162&quot; alt=&quot;浅谈编程语言中的新宠Python，你叫它如何不火？&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/1526022462267f94f0baa49&quot; alt=&quot;浅谈编程语言中的新宠Python，你叫它如何不火？&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Python社区的存在&lt;/p&gt;
&lt;p&gt;若是你进修过其它编程，你必定会觉得缺乏文档和开发人员支撑，很难学习。而Python并没有这些问题，Python的拥护者在开发者社区积累了难以置信的文档、指南、教程等等。&lt;/p&gt;
&lt;p&gt;Python获得良多大企业的帮助&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9.pstatp.com/large/pgc-image/1526021591849c57b994d3d&quot; alt=&quot;浅谈编程语言中的新宠Python，你叫它如何不火？&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个就非常牛逼了，大家应该知道霍金的椅子是怎么来的吧？不知道的自己去谷歌一下，在这里就不说了。当一个公司希望他们的团队和将来的开发人员使用python连续研发本身的体系和应用程序，他们就必要供给大量的资源。&lt;/p&gt;
&lt;p&gt;大数据的崛起&lt;/p&gt;
&lt;p&gt;大数据和云计较处理方案在各个公司的的应用也是Python火起来的一个重要原因。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/1526022342961924730b243&quot; alt=&quot;浅谈编程语言中的新宠Python，你叫它如何不火？&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/1526021866133982a96dc2f&quot; alt=&quot;浅谈编程语言中的新宠Python，你叫它如何不火？&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Python强大无比的“库”&lt;/p&gt;
&lt;p&gt;当你在开发大型项目的时，Python的库可以良好的帮助我们节省时间并缩短原方案的开发周期。从NumPy和SciPy，再到网页开发的Django。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/152602197594298e6891b2c&quot; alt=&quot;浅谈编程语言中的新宠Python，你叫它如何不火？&quot;/&gt;&lt;/p&gt;
&lt;p&gt;别的，像Encoding.com如许的大型云办事平台还容许它与C互相兼容。也就是说，有一些类库工具可以供给跨平台的支撑，这是一个庞大的增益！&lt;/p&gt;
&lt;p&gt;Python平稳定与高效性能&lt;/p&gt;
&lt;p&gt;在这里我就要说道说道了，我本人以前学习的是易语言，后来学习的Python。论简单高效性？易语言比Python还要简单高效！但是如果说你要比稳定性，那么不好意思，E语言开发一个软件基本过一段时间都会出现错误，极不稳定！而且E语言至今还未被在大型企业中进行开发。&lt;/p&gt;
&lt;p&gt;Python与人工智能紧密相关&lt;/p&gt;
&lt;p&gt;Python的简洁高效、人工智能的难度非常高。两者结合，利用Python开发人工智能比任何其它编程语言都简单高效，Python与人工智能不可分割！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/15260226660859454d1430c&quot; alt=&quot;浅谈编程语言中的新宠Python，你叫它如何不火？&quot;/&gt;&lt;/p&gt;
&lt;p&gt;喜欢小编的请记得点击关注小编哦。&lt;/p&gt;
</description>
<pubDate>Fri, 11 May 2018 07:27:00 +0000</pubDate>
<dc:creator>Python新世界</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xinshiye/p/9024905.html</dc:identifier>
</item>
<item>
<title>第三次创业 - 一步之遥&gt;&gt;</title>
<link>http://www.cnblogs.com/somebody2005/p/9024870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/somebody2005/p/9024870.html</guid>
<description>&lt;p&gt;从业15年，这已经是我的第三次创业了。&lt;/p&gt;

&lt;p&gt;第一次创业是在2006年，毕业刚好两年，从业算是三年(在大三就接项目做了)。那年刚在一个技术大会上显摆完，觉得自己是技术大牛，无所不能。所以一头冲进去创业。&lt;/p&gt;

&lt;p&gt;第一次创业是失败的。我们以纯粹的项目为主，在经济好的时候，顺风顺水，几个大工厂不少好项目。2008年经济危机来的时候就一地鸡毛了。和国内不同，新加坡的经济对世界经济大势依赖严重，所以经济危机对这里影响很大。那一年失去了好几个大客户。然后越做越艰难，不得已接了很多其他行业的小项目。直到自己都觉得做的没意思，就关门了。&lt;/p&gt;
&lt;p&gt;关门之后，机缘巧合，进入政企。创过业的人再去混职场，自然是游刃有余。生活休闲了很多，我的数学基础派上了用场。甚至出书、拍片，啥都玩。&lt;/p&gt;
&lt;p&gt;之后又离职进入私企，做了1年的CTO。&lt;/p&gt;

&lt;p&gt;第二次创业就发生在了2015年。老朋友们都非常帮助，辞职之后又吃了回头草，在原来的政企做个闲差，技术顾问。然后大部分时间自己创业。&lt;/p&gt;
&lt;p&gt;有上次的教训，这次创业以产品为主。作为一个全栈，很快就设计完成了产品。于此同时，也想代理表弟的产品，和另外一个朋友合作智能家居。基本上就是起了三四摊，看看哪个果子先掉下来。&lt;/p&gt;
&lt;p&gt;这次失败在于市场。做销售的朋友不够投入，而我的英文不足与做好销售。只有初期的几个种子客户，之后扩张非常困难。&lt;/p&gt;
&lt;p&gt;我记得有一次见一个投资人，他问起我的团队，我还傻了吧唧的的说自己顶一支队伍，项目计划书写的也是找不到重点。&lt;/p&gt;
&lt;p&gt;机缘巧合之下，我认识了一些朋友，找到了另外一个好项目，于是第二次创业无疾而终。&lt;/p&gt;
&lt;p&gt;终于认识到，创业还是靠团队呀。&lt;/p&gt;

&lt;p&gt;第三次创业就在2016年。和两个合伙人一拍即合。这次是产品和服务一起上。&lt;/p&gt;
&lt;p&gt;两个合伙人都是很NB的，一路来，我们亲力亲为，敢打敢拼，从产品到市场，从人力到财务，慢慢做大。&lt;/p&gt;
&lt;p&gt;2017年初的时候，我们证明了市场，然后急速扩张。拿了几个认证，做了ISO。&lt;/p&gt;
&lt;p&gt;然后就开始融资。接触了n多大佬。&lt;/p&gt;
&lt;p&gt;Pre-A是去年11月做完的。现在正在进行正式的A轮。&lt;/p&gt;

&lt;p&gt;创业过程很多故事，有空慢慢写吧。&lt;/p&gt;
&lt;p&gt;1：如何选择创业方向。&lt;/p&gt;
&lt;p&gt;2：如何管理团队。&lt;/p&gt;
&lt;p&gt;3：如何打开市场。&lt;/p&gt;
&lt;p&gt;4：如何融资。&lt;/p&gt;
&lt;p&gt;每一个话题之下，又有很多小话题。欢迎大家继续关注。&lt;/p&gt;
</description>
<pubDate>Fri, 11 May 2018 07:23:00 +0000</pubDate>
<dc:creator>一步之遥&amp;gt;&amp;gt;</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/somebody2005/p/9024870.html</dc:identifier>
</item>
<item>
<title>Android平台的Swift—Kotlin - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/9024743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/9024743.html</guid>
<description>&lt;p&gt;Kotlin 已经出来较长一段时间了，有些同学已经对Kotlin进行了深入的学习，甚至已经运用到了自己的项目当中，但是还有较多同学可能只是听过Kotlin或简单了解过，这篇文章的目的是让这些同学对Kotlin有一个系统全面的认识，让有兴趣的同学在之后学习的时候能更加的轻车熟路。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2&gt;&lt;strong&gt;一、一门静态编程语言&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;跟java，c一样的强类型语言，变量的数据类型在编译时确定。对比的JavaScript，python则是动态编程语言。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;二、JetBrians开发设计&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;一家捷克的软件公司，是著名的IDE开发商，对很多的开发语言和平台都提供了相应的集成开发环境，比如Java的，OC的，JavaScript，PHP，C/C++等。而其中最著名的是IntelliJ IDEA ，Java的集成开发环境，被称为目前最好用的java IDE。而且Android Studio就是Google基于IntelliJ IDEA 开发的，由此可见Google和JetBrains的合作也是比较密切的。而从以上说明也可以看到JetBrains不仅实力强劲，这家公司对于语言设计更是有天然优势。Kotlin是集多家语言之大成。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;三、Kotlin是开源的(基于Apache 2.0开源许可协议)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我们在GitHub上可以下载Kotlin的全部源代码。而且可以自己进行代码修改，再发布。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JetBrains/kotlin&quot;&gt;https://github.com/JetBrains/kotlin &lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 最新版本已经更新到了1.2.3 。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;四、Android官方开发语言&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;JetBrains其实在2011年就推出了Kotlin， 在之后的很长一段时间都处于设计，开发和完善当中，2016年才发布第一个正式版本，而在2017年5月份的Google I/O开发者大会上，被Google宣布称为Android的官方开发语言。&lt;/p&gt;
&lt;p&gt;被程序员们称为Android平台的Swift。&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;一、 语法简洁，且吸收了很多其他语言的优点&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;大量的语法糖（有函数声明，类的创建，集合相关，范围运算符等等大量简洁的语法）、 Lambda表达式（Java8支持），简洁的函数表示法，后面会介绍到。&lt;/p&gt;

&lt;p&gt;可参考：&lt;a href=&quot;http://qinghua.github.io/kotlin-syntax-suger/&quot;&gt;http://qinghua.github.io/kotlin-syntax-suger/ &lt;/a&gt;收集的语法糖们。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;吸收其他语言的优点有：&lt;/strong&gt;模板字符串，运算符重载，方法扩展，命名参数等。后面在语言新特性中会讲到。&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;二、安全性&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;空安全：&lt;/strong&gt;避免空指针异常。当变量可以为null时，必须使用可空安全符？进行声明，否则会出现编译错误。声明变量为可空后，在运行时便不会抛出异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类型智能转换：&lt;/strong&gt;通过is进行类型判断后，编译器自动进行类型转换。父类引用可以调用子类接口，注意转换只在is的代码块中生效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;三、完全兼容Java&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;类似于swift于OC的关系，虽然官方推荐使用新语言Kotlin进行Android开发，但是前提新语言必须兼容旧语言（否则是无法得到google的认可的）。所以Kotlin的设计初衷就是要完全兼容Java。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相互调用：&lt;/strong&gt;使用Kotlin进行Android或者Java服务端开发，可以导入任意的Java库。Kotlin和Java之间可以相互调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相互转换：&lt;/strong&gt;在Android Studio中可以一键转换Java代码为Kotlin代码（Code &amp;gt; Convert Java File to Kotlin File.）。同时Kotlin代码也可以反编译成Java代码（1.Tools&amp;gt;Kotlin&amp;gt;Show Kotlin Bytecode 2.Decompile）。&lt;/p&gt;

&lt;p&gt;Java的API = Kotlin的API。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;四、工具支持&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;JetBrains为Kotlin的开发提供了大量的工具支持。我们可以直接下载Kotlin Compiler库在命令行进行编译和运行，也可以通过安装插件在Eclipse中使用Kotlin，而现在IntelliJ IDEA和Android Studio已经可以直接使用Kotlin进行开发。就像JetBrains所说：一门语言需要工具化，而在 JetBrains，这正是我们做得最好的地方！&lt;/p&gt;

&lt;p&gt;Kotlin如何兼容Java？&lt;/p&gt;
&lt;p&gt;我们来看一张图，了解Kotlin的编译过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145341999-636207866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Kotlin为什么可以兼容Java，一个主要原因是Kotlin文件在经过Kotlin编译器编译后会生成Java字节码。这跟Java文件通过Java编译器编译后生成的字节码几乎没有区别，这样JVM就能直接识别和处理Kotlin代码的功能和逻辑。&lt;/p&gt;

&lt;p&gt;当Kotlin调用Java代码，Kotlin编译器会对调用的Java文件进行分析，以便kt文件能够生成正确的class文件。为什么这么说呢？举个列子，Java字节码有几种函数调用的方式invokespecial 、 invokeStatic 、 invokeInterface等，编译器必须知道调用的Java函数是什么类型才能生成相应的正确的字节码。而当在Java代码中调用Kotlin对象时，Kotlin生成的class文件也要输入到Java编译器，这时Java文件才能生成正确的class文件。生成的class文件打成jar包后，最终可以生成Android的APK，或供Java服务端调用。&lt;/p&gt;

&lt;p&gt;我们可以直接下载下载Kotlin编译器下来查看他的编译过程（最新&lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.2.40-eap-16&quot;&gt;https://github.com/JetBrains/kotlin/releases/tag/v1.2.40-eap-16&lt;/a&gt;）。Kotlin编译器的代码都是用java写的，所以使用Kotlin编译器必须要有java环境。&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;一、基础特性&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;1、 定义变量&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145414546-1559721672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; Var用来声明变量，Val类似Java final，用来声明常量。语句后面不需要跟分号。变量类型可以根据变量值进行自动推导。这里Kotlin的基础类型都是对象，使用的是Java的包装类（基础类型包装成对象）。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2、定义函数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145427110-408300825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;函数使用fun为关键字进行声明。变量的冒号之后是变量类型，函数的冒号之后是返回值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145444098-907126290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同时我们可以在定义函数的时候声明参数的默认值。&lt;/p&gt;
&lt;p&gt;函数调用的时候可以直接调用，也可以使用命名参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://f.wetest.qq.com/gqop/10000/20000/LabImage_6d6754fceda02eeaefe1c31044908d2a.png&quot; alt=&quot;&quot; width=&quot;655&quot; height=&quot;58&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用命名参数可以增加可读性，减少函数的重载。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145504689-1320633482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;3、类的声明&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145523026-929906196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;类名的冒号表示继承，所有类的基类称为Any（并不是Object，只包含equals、hascode、toString方法）。声明构造函数要指明constructor关键字。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145535494-806999688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;也可以直接在声明类的时候指定构造函数。&lt;/p&gt;
&lt;p&gt;对象实例化可以不写new关键字：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145548381-1450355105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145602400-968144931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;数据类，用来保存Info数据的类，其实就是JavaBeans。这里使用一句代码创建一个包含 getters、 setters、 equals()、 hashCode()、 toString() 以及 copy() 的 类。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;4.、流程控制&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;其他流程控制基本跟Java差不多，这里主要讲下when表达式，他取代了Java的switch&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145611866-352457767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;when表达式其实最终是使用if/else来实现的。&lt;/p&gt;
&lt;p&gt;保留了原来的for each循环，同时增加了区间控制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145620848-588369146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;5、集合&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Kotlin的集合与OC的集合相似，分为可变集合和不可变集合（lists、sets、maps 等）。&lt;/p&gt;

&lt;p&gt;kotlin中的可变集合对Java的集合进行了包装，同时它实现了一套不可变集合库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145632316-843411122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;访问：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145642246-479658593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;6、伴生对象&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Kotlin中没有静态属性和方法。如果我们要创建单列，可以使用Object关键字声明类&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145652815-363234627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果要在一个类里面声明静态成员，可以在类的内部使用伴生对象。使用关键字companion object&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145803554-854817371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;调用的话，直接跟Java一样，通过类名点属性名称或函数名称调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145815681-384223903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;二、新特性&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;1、空安全&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Kotlin是如何实现空安全的呢？&lt;/p&gt;
&lt;p&gt;在Kotlin中，对象声明分为可空引用和非空引用两种。&lt;/p&gt;

&lt;p&gt;非空引用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145824879-1885808325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可空引用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145833929-1186450351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;安全调用操作符，写作 ?. 可空调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145850751-1099792438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过函数调用给可空引用赋值，返回的必须也是可空引用。这就在编译期间杜绝了空指针异常。但是这里要注意一点，如果从Java返回的集合，不会强制做可空检查，这个是时候如果给不可空引用赋值Java集合中的null会出现转换错误异常。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2、扩展函数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;跟OC的Category一样，可以对API的函数进行扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145903592-438037436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们在任意Activity中都可以直接调用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145911317-1960939770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;函数扩展并不是修改了原来的类，通过反编译成Java代码可以发现，函数的扩展是通过静态导入的方式实现的。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;3、字符串模板&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;表示字符串中可以包含变量或者表达式，以$符号开头（这跟JSP的EL表达式有点像），比如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145921179-1047170814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Kotlin中是通过单引号进行转义的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145930329-2126935065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;4、操作符重载&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Kotlin为基本的运算符提供了固定名称函数表，比如&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145940219-1910443839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145949760-1827019962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511145959553-1843634031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;5、Lambda表达式&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Lambda本质上是一个未声明的函数，他会以表达式的形式传递。既然是函数，就由这三块组成：参数 、 方法体 和 返回值。&lt;/p&gt;

&lt;p&gt;我们来看一下完整的Lambda表达式是怎么写的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511150014274-671378971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;大括号内，箭头左边是参数，箭头右侧是方法体和返回值。这里传入两个Int类型的参数，返回一个Int类型的值。 &lt;/p&gt;

&lt;p&gt;声明一个接受函数为参数的函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511150022435-1069711687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 第二个参数rightV表明接受的是一个函数，函数有两个Int型的入参，返回一个Int型的输出。&lt;/p&gt;

&lt;p&gt;调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511150037987-1296103260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在Android中使用Lambda表达式，可以写成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511150046214-1475612001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;省略了函数的括号。这里原本不是传入函数类型参数，是编译器做的处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;listener有多个接口声明时，不能这么使用，比如setOnCheckedChangeListener&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;三、高级特性&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;1、高阶函数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;把函数作为参数或者是返回值的函数，Kotlin称之为高阶函数。比如函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511150056830-1074834140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;就是一个高阶函数。可以这么调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511150105064-1346781226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们声明一个局部函数，然后把他作为参数传递给另一个函数。我们还可以使用Lambda表达式来表示函数参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511150119869-1264329454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2、泛型&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;泛型的存在主要是为了消除模板代码和类型转换安全， 在Kotlin中泛型的使用基本与Java是一致的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511150130382-593469255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在Java中泛型是不变的，比如：虽然A继承B，但List&amp;lt;A&amp;gt;和List&amp;lt;B&amp;gt;之间没有任何关系，Java是通过泛型通配符来实现型变的：&lt;/p&gt;
&lt;p&gt;&amp;lt;? extends T&amp;gt; 对应Kotlin的 out T 生产者&lt;/p&gt;
&lt;p&gt;&amp;lt;? super T&amp;gt; 对应Kotlin的  in T 消费者&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PECS原则 :&lt;/strong&gt; producer-extends, consumer-super&lt;/p&gt;
&lt;p&gt;但是Kotlin中使用比Java的更加灵活，比如可以在类声明的时候添加型变 ， 或者函数声明的时候添加。&lt;/p&gt;

&lt;p&gt;更多可以了解：https://segmentfault.com/a/1190000010313252 写的非常详细。对Java泛型理解的不是很透彻可以再看看 http://www.importnew.com/24029.html&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;3、反射&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在运行时获取类的方法，属性，类结构等所有信息。&lt;/p&gt;
&lt;p&gt;1）Kotlin中使用Java的反射&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511150139747-94610774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;jc返回的是Java的class对象，可以通过这个对象去调用调用Java的反射。&lt;/p&gt;

&lt;p&gt;2）Kotlin中的反射：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511150147549-1045745035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以不通过KClass对象，直接调用方法和访问属性（注意：如果有重载的函数或同名的属性不能使用以下方式）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511150157716-1490292147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;4、协程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;什么是协程？&lt;/p&gt;
&lt;p&gt;协程是一种新的异步编程方式，它使用线程为资源，基于代码逻辑去实现任务之间的调度。它主要是由编译器去实现的。&lt;/p&gt;

&lt;p&gt;程序使用协程可以书写线性的异步代码，没有callback，大大简化了异步编程。线程有的异步操作协程都支持，协程的挂起和切换非常轻量基本没有开销。&lt;/p&gt;

&lt;p&gt;如何使用协程？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511150218705-256922575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;协程目前虽然还在试验阶段，但是功能已经非常完善了（现在Kotlin最新1.2.3版本，预计1.3会删除实验室状态）。有兴趣的同学可以参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kotlincn.net/docs/tutorials/coroutines-basic-jvm.html&quot;&gt;https://www.kotlincn.net/docs/tutorials/coroutines-basic-jvm.html&lt;/a&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;一、多平台支持&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Kotlin的不仅仅用于Java，JetBrains的野心远不止于此。使用Kotlin同时可以用于其他平台的开发。所以市面上之前说Kotlin是一款基于JVM的语言是不准确的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511150230648-2038083975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Kotlin用于服务端开发：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用Kotlin可用于Java服务端开发。Java与Kotlin的相互兼容性，我们可使用服务端的任意框架，同时我们可以保留老的Java代码，使用Kotlin编写新代码。Kotlin的协程特性更有助于构建服务端程序。IDE的支持和Sring框架的支持。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kotlin用于Android开发：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Android Studio的支持。大量的实际案列。大量可学习的APP项目。与Java兼容性允许在 Kotlin 应用程序中使用所有现有的 Android 库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kotlin用于JavaScript：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用kotlinc-js编译器将Kotlin代码转换为JavaScript（不是Kotlin或标准库的代码编译时会被忽略），Kotlin中提供了一些标准库用于JS开发，同时可以使用第三方JS库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kotlin Native：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Kotlin/Native 是一种将 Kotlin 编译为没有任何虚拟机的原生二进制文件的技术。还在开发中，现在只出了预览版本。&lt;/p&gt;

&lt;p&gt;预览版本支持： Window 、 Mac 、 IOS 、 Android等平台。Kotlin代码最终会编译成一个kexe文件，直接打开就可以运行。&lt;/p&gt;

&lt;p&gt;基于Kotlin/Native的一款游戏源码：&lt;a href=&quot;https://github.com/jetbrains/kotlinconf-spinner&quot;&gt;https://github.com/jetbrains/kotlinconf-spinner&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;二、开发多平台项目&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Kotlin 多平台项目允许你将相同的代码编译到多个目标平台。 目前支持的目标平台为 JVM 与 JS，即将增加 Native。&lt;/p&gt;

&lt;p&gt;目前还是1.2新版本的一个实验性功能。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180511150242092-1188914864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;多平台项目由三种类型的模块组成：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;● 公共模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;公用模块只包含与平台无关的Kotlin代码以及Kotlin公共标准库代码。同时还包含不含实现的平台接口声明。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 平台模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;平台模块可以依赖在指定平台上可用的任何模块与库 （包括对于 Kotlin/JVM 平台的 Java 库与 Kotlin/JS 平台的 JS 库）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 常用模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与平台模块相互依赖的模块&lt;/p&gt;


&lt;p&gt;1、确实是一门很优秀的语言。语言简洁，包含各种语言的优秀特性。但是一些亮点的特性包含协程和多平台都处于试验和开发阶段。并不能吸引除Java，Android之外的更多开发者加入（JS平台使用的人并不多）。&lt;/p&gt;

&lt;p&gt;2、与Java的交互性，让它能够依赖Java成长。但是对Java的依赖和兼容性注定无法完全替换Java。&lt;/p&gt;

&lt;p&gt;3、虽然获得Google认可，但是Kotlin语言的热度一直在逐渐下降，发文之前在TIOBE排行榜已经降至49位。我猜测虽然Kotlin获得经验丰富的程序员的青睐，但是对于初中级选手来说他们更愿选择Java这门熟悉的语言。&lt;/p&gt;

&lt;p&gt;4、潜力是巨大的，毕竟有Google的官方支持和JetBrains的强劲实力做支撑。如果之后Kotlin在多平台等实验室特性上有所突破的话，绝对会吸引更多的开发者。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;1.Kotlin官网&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kotlinlang.org/&quot;&gt;http://kotlinlang.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.kotlin中文官网&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kotlincn.net/&quot;&gt;https://www.kotlincn.net/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.Google Kotlin项目学习实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/samples/index.html?language=kotlin&quot;&gt;https://developer.android.com/samples/index.html?language=kotlin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.阿里巴巴工程师教学系列文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/u/donghaichenguangjian&quot;&gt;https://segmentfault.com/u/donghaichenguangjian&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.Kotlin协程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/9f720b9ccdea&quot;&gt;https://www.jianshu.com/p/9f720b9ccdea&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md&quot;&gt;https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md&quot;&gt;https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.其他文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u013448469/article/details/79403284&quot;&gt;https://blog.csdn.net/u013448469/article/details/79403284&lt;/a&gt; Kotlin反射&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ztguang/article/details/72511994&quot;&gt;https://blog.csdn.net/ztguang/article/details/72511994 &lt;/a&gt;Kotlin Native&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;腾讯WeTest自动化兼容测试提供云端自动化兼容服务，提交云端百台真机，并行测试。快速发现游戏/应用兼容性和性能问题，覆盖安卓主流机型。目前已经支持所有腾讯在研和运营的手游项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎点击链接：&lt;a href=&quot;http://wetest.qq.com/product/auto-compatibility-testing?from=content_cnblogs&quot;&gt;http://wetest.qq.com/product/auto-compatibility-testing &lt;/a&gt;&lt;/strong&gt;&lt;strong&gt;使用专家兼容测试服务&lt;/strong&gt;。WeTest兼容性测试团队期待与您交流！You Create，We Test！&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;juejin-editor-bold&quot;&gt;腾讯WeTest有奖征文活动进行中，欢迎投稿！了解详情：&lt;img alt=&quot;&quot;/&gt;&lt;span class=&quot;juejin-editor-bold&quot;&gt;&lt;a href=&quot;http://wetest.qq.com/lab/view/379.html?from=content_cnblogs&quot;&gt;http://wetest.qq.com/lab/view/379.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 11 May 2018 07:05:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/9024743.html</dc:identifier>
</item>
<item>
<title>ScalaPB（3）： gRPC streaming - 雪川大虫</title>
<link>http://www.cnblogs.com/tiger-xc/p/9023937.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-xc/p/9023937.html</guid>
<description>&lt;p&gt;&lt;span&gt;  接着上期讨论的gRPC unary服务我们跟着介绍gRPC streaming，包括: Server-Streaming, Client-Streaming及Bidirectional-Streaming。我们首先在.proto文件里用IDL描述Server-Streaming服务：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *  responding stream of increment results
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
service SumOneToMany {
  rpc AddOneToMany(SumRequest) returns (stream SumResponse) {}
}

message SumRequest {
  int32 toAdd &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

message SumResponse {
  int32 currentResult &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;SumOneToMany服务中AddOneToMany函数接受一个SumRequest然后返回stream SumResponse，就这么简单。经过编译后产生了SumOneToManyGrpc.scala文件，在这个文件里提供了有关RPC操作的api。我们看看protoc把IDL描述的服务函数变成了什么样的scala函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def addOneToMany(request: SumRequest, responseObserver: StreamObserver[SumResponse]): Unit&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;调用scala函数addOneToMany需要传入参数SumRequest和StreamObserver[SumResponse]，也就是说用户需要准备这两个入参数。在调用addOneToMany函数时用户事先构建这个StreamObserver传给server，由server把结果通过这个结构传回用户。gRPC是通过StreamObserver类型实例来实现数据streaming的。这个类型的构建例子如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    val responseObserver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamObserver[SumResponse] {
      def onError(t: Throwable): Unit &lt;/span&gt;= println(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ON_ERROR: $t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      def onCompleted(): Unit         &lt;/span&gt;= println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ON_COMPLETED&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      def onNext(value: SumResponse): Unit &lt;/span&gt;=&lt;span&gt;
        println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ON_NEXT: Current sum: ${value.currentResult}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;server端通过onNext把结果不断传回给client端，因为这个responseObserver是在client端构建的。下面是SumManyToMany的实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SumOne2ManyService extends SumOneToManyGrpc.SumOneToMany {
    &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def addOneToMany(request: SumRequest, responseObserver: StreamObserver[SumResponse]): Unit =&lt;span&gt; {
      val currentSum: AtomicInt &lt;/span&gt;= Atomic(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
      (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; to request.toAdd).map { _ =&amp;gt;&lt;span&gt;
          responseObserver.onNext(SumResponse().withCurrentResult(currentSum.incrementAndGet()))
      }
      Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;delay and then finish&lt;/span&gt;
&lt;span&gt;      responseObserver.onCompleted()
    }
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个addOneToMany服务函数把 1-request.toAdd之间的数字逐个通过responseObserver返还调用方。 在客户端如下调用服务：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; get asyn stub&lt;/span&gt;
    val client: SumOneToManyGrpc.SumOneToManyStub =&lt;span&gt; SumOneToManyGrpc.stub(channel)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; prepare stream observer&lt;/span&gt;
    val streamObserver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamObserver[SumResponse] {
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onError(t: Throwable): Unit = println(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error: ${t.getMessage}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onCompleted(): Unit = println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Done incrementing !!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onNext(value: SumResponse): Unit = println(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;current value: ${value.currentResult}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; call service with stream observer&lt;/span&gt;
    client.addOneToMany(SumRequest().withToAdd(&lt;span&gt;6&lt;/span&gt;),streamObserver)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Client-Streaming服务的IDL如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *  responding a result from a request of stream of numbers
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
service SumManyToOne {
  rpc AddManyToOne(stream SumRequest ) returns (SumResponse) {}
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;传入stream SumRequest, 返回SumResponse。scalaPB自动产生scala代码中的addManyToOne函数款式如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def addManyToOne(responseObserver: StreamObserver[SumResponse]): StreamObserver[SumRequest]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;调用方提供StreamObserver[SumResponse]用作返回结果，函数返回客方需要的StreamObserver[SumRequest]用以传递request流。注意：虽然在.proto文件中AddManyToOne的返回结果是单个SumResponse，但产生的scala函数则提供了一个StreamObserver[SumResponse]类型，所以需要谨记只能调用一次onNext。下面是这个服务的实现代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Many2OneService extends SumManyToOneGrpc.SumManyToOne {
     val currentSum: AtomicInt &lt;/span&gt;= Atomic(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
     &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def addManyToOne(responseObserver: StreamObserver[SumResponse]): StreamObserver[SumRequest] =
       &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamObserver[SumRequest] {
         val currentSum: AtomicInt &lt;/span&gt;= Atomic(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
         &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onError(t: Throwable): Unit = println(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error: ${t.getMessage}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
         &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onCompleted(): Unit = println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Done summing!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
         &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onNext(value: SumRequest): Unit =&lt;span&gt; {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;only allow one response&lt;/span&gt;
           &lt;span&gt;if&lt;/span&gt; (value.toAdd &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
              currentSum.add(value.toAdd)
           &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
              responseObserver.onNext(SumResponse(currentSum.addAndGet(value.toAdd)))
         }
       }
   }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;客户方调用示范如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;pass to server for result&lt;/span&gt;
    val respStreamObserver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamObserver[SumResponse] {
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onError(t: Throwable): Unit = println(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error: ${t.getMessage}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onCompleted(): Unit = println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Done responding!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onNext(value: SumResponse): Unit =&lt;span&gt;
        println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Result: ${value.currentResult}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get async stub&lt;/span&gt;
    val client =&lt;span&gt; SumManyToOneGrpc.stub(channel)

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get request stream observer from server&lt;/span&gt;
    val reqStreamObserver =&lt;span&gt; client.addManyToOne(respStreamObserver)

    List(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;).map { n =&amp;gt;&lt;span&gt;
      reqStreamObserver.onNext(SumRequest(n))
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Bidirectional-Streaming的IDL描述如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Sums up numbers received from the client and returns the current result after each received request.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
service SumInter {
  rpc AddInter(stream SumRequest) returns (stream SumResponse) {}
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个service SumInter 描述了stream SumRequest 及 stream SumResponse运算模式。产生的对应scala函数如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;def addInter(responseObserver: StreamObserver[SumResponse]): StreamObserver[SumRequest]
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个函数的款式与Client-Streaming服务函数是一样的。但是，我们可以通过responseObserver传递多个SumResponse。这个服务的实现代码是这样的： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Many2ManyService extends SumInterGrpc.SumInter {
    &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def addInter(responseObserver: StreamObserver[SumResponse]): StreamObserver[SumRequest] =
      &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamObserver[SumRequest] {
        val currentSum: AtomicInt &lt;/span&gt;= Atomic(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onError(t: Throwable): Unit = println(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error: ${t.getMessage}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onCompleted(): Unit = println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Done requesting!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onNext(value: SumRequest): Unit =&lt;span&gt; {
          responseObserver.onNext(SumResponse(currentSum.addAndGet(value.toAdd)))
        }
      }
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们可以多次调用responseObserver.onNext。客户端源代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;create stream observer for result stream&lt;/span&gt;
    val responseObserver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamObserver[SumResponse] {
      def onError(t: Throwable): Unit &lt;/span&gt;= println(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ON_ERROR: $t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      def onCompleted(): Unit         &lt;/span&gt;= println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ON_COMPLETED&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      def onNext(value: SumResponse): Unit &lt;/span&gt;=&lt;span&gt;
        println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ON_NEXT: Current sum: ${value.currentResult}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get request container&lt;/span&gt;
    val requestObserver =&lt;span&gt; client.addInter(responseObserver)

    scheduler.scheduleWithFixedDelay(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;.seconds, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.seconds) {
      val toBeAdded &lt;/span&gt;= Random.nextInt(&lt;span&gt;11&lt;/span&gt;&lt;span&gt;)
      println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Adding number: $toBeAdded&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      requestObserver.onNext(SumRequest(toBeAdded))
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面是本次示范的源代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;project/scalapb.sbt&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;addSbtPlugin(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.thesamet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sbt-protoc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.99.18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
libraryDependencies &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.thesamet.scalapb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;compil&lt;/span&gt;erplugin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.7.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;build.sbt&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import scalapb.compiler.Version.scalapbVersion
import scalapb.compiler.Version.grpcJavaVersion

name :&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;learn-gRPC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

version :&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

scalaVersion :&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.12.6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

libraryDependencies &lt;/span&gt;++=&lt;span&gt; Seq(
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.thesamet.scalapb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scalapb-runtime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % scalapbVersion % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;protobuf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;io.grpc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grpc-netty&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; grpcJavaVersion,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.thesamet.scalapb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scalapb-runtime-grpc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; scalapbVersion,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;io.monix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;monix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.3.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

PB.targets &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; Compile :=&lt;span&gt; Seq(
  scalapb.gen() &lt;/span&gt;-&amp;gt; (sourceManaged &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Compile).value
)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;src/main/protobuf/sum.proto&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;syntax = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;proto3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

package learn.grpc.services;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *  responding stream of increment results
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
service SumOneToMany {
  rpc AddOneToMany(SumRequest) returns (stream SumResponse) {}
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *  responding a result from a request of stream of numbers
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
service SumManyToOne {
  rpc AddManyToOne(stream SumRequest ) returns (SumResponse) {}
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Sums up numbers received from the client and returns the current result after each received request.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
service SumInter {
  rpc AddInter(stream SumRequest) returns (stream SumResponse) {}
}

message SumRequest {
  int32 toAdd &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

message SumResponse {
  int32 currentResult &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;gRPCServer.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package learn.grpc.server
import io.grpc.{ServerBuilder,ServerServiceDefinition}

trait gRPCServer {
  def runServer(service: ServerServiceDefinition): Unit &lt;/span&gt;=&lt;span&gt; {
    val server &lt;/span&gt;=&lt;span&gt; ServerBuilder
      .forPort(&lt;/span&gt;&lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)
      .addService(service)
      .build
      .start

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; make sure our server is stopped when jvm is shut down&lt;/span&gt;
    Runtime.getRuntime.addShutdownHook(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread() {
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def run(): Unit =&lt;span&gt; server.shutdown()
    })

    server.awaitTermination()
  }

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OneToManyServer.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package learn.grpc.sum.one2many.server
import io.grpc.stub.StreamObserver
import learn.grpc.services.sum._
import monix.execution.atomic.{Atomic,AtomicInt}
import learn.grpc.server.gRPCServer

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; One2ManyServer extends gRPCServer {

  &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SumOne2ManyService extends SumOneToManyGrpc.SumOneToMany {
    &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def addOneToMany(request: SumRequest, responseObserver: StreamObserver[SumResponse]): Unit =&lt;span&gt; {
      val currentSum: AtomicInt &lt;/span&gt;= Atomic(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
      (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; to request.toAdd).map { _ =&amp;gt;&lt;span&gt;
          responseObserver.onNext(SumResponse().withCurrentResult(currentSum.incrementAndGet()))
      }
      Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;delay and then finish&lt;/span&gt;
&lt;span&gt;      responseObserver.onCompleted()
    }
  }

  def main(args: Array[String]) &lt;/span&gt;=&lt;span&gt; {
    val svc &lt;/span&gt;= SumOneToManyGrpc.bindService(&lt;span&gt;new&lt;/span&gt; SumOne2ManyService, scala.concurrent.ExecutionContext.&lt;span&gt;global&lt;/span&gt;&lt;span&gt;)
    runServer(svc)
  }

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OneToManyClient.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package learn.grpc.sum.one2many.client
import io.grpc.stub.StreamObserver
import learn.grpc.services.sum._

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; One2ManyClient {
  def main(args: Array[String]): Unit &lt;/span&gt;=&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;build connection channel&lt;/span&gt;
    val channel =&lt;span&gt; io.grpc.ManagedChannelBuilder
      .forAddress(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LocalHost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)
      .usePlaintext(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
      .build()

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; get asyn stub&lt;/span&gt;
    val client: SumOneToManyGrpc.SumOneToManyStub =&lt;span&gt; SumOneToManyGrpc.stub(channel)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; prepare stream observer&lt;/span&gt;
    val streamObserver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamObserver[SumResponse] {
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onError(t: Throwable): Unit = println(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error: ${t.getMessage}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onCompleted(): Unit = println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Done incrementing !!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onNext(value: SumResponse): Unit = println(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;current value: ${value.currentResult}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; call service with stream observer&lt;/span&gt;
    client.addOneToMany(SumRequest().withToAdd(&lt;span&gt;6&lt;/span&gt;&lt;span&gt;),streamObserver)

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait for async execution&lt;/span&gt;
&lt;span&gt;    scala.io.StdIn.readLine()
  }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ManyToOneServer.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package learn.grpc.sum.many2one.server
import io.grpc.stub.StreamObserver
import learn.grpc.services.sum._
import learn.grpc.server.gRPCServer
import monix.execution.atomic.{Atomic,AtomicInt}

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Many2OneServer extends gRPCServer {
   &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Many2OneService extends SumManyToOneGrpc.SumManyToOne {
     val currentSum: AtomicInt &lt;/span&gt;= Atomic(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
     &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def addManyToOne(responseObserver: StreamObserver[SumResponse]): StreamObserver[SumRequest] =
       &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamObserver[SumRequest] {
         val currentSum: AtomicInt &lt;/span&gt;= Atomic(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
         &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onError(t: Throwable): Unit = println(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error: ${t.getMessage}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
         &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onCompleted(): Unit = println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Done summing!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
         &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onNext(value: SumRequest): Unit =&lt;span&gt; {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;only allow one response&lt;/span&gt;
           &lt;span&gt;if&lt;/span&gt; (value.toAdd &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
              currentSum.add(value.toAdd)
           &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
              responseObserver.onNext(SumResponse(currentSum.addAndGet(value.toAdd)))
         }
       }
   }

   def main(args: Array[String]): Unit &lt;/span&gt;=&lt;span&gt; {
     val svc &lt;/span&gt;= SumManyToOneGrpc.bindService(&lt;span&gt;new&lt;/span&gt; Many2OneService,scala.concurrent.ExecutionContext.&lt;span&gt;global&lt;/span&gt;&lt;span&gt;)
     runServer(svc)
   }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ManyToOneClient.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package learn.grpc.sum.many2one.client
import io.grpc.stub.StreamObserver
import learn.grpc.services.sum._

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Many2OneClient {
  def main(args: Array[String]): Unit &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;build channel&lt;/span&gt;
    val channel =&lt;span&gt; io.grpc.ManagedChannelBuilder
      .forAddress(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LocalHost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)
      .usePlaintext(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
      .build()
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pass to server for result&lt;/span&gt;
    val respStreamObserver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamObserver[SumResponse] {
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onError(t: Throwable): Unit = println(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error: ${t.getMessage}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onCompleted(): Unit = println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Done responding!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onNext(value: SumResponse): Unit =&lt;span&gt;
        println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Result: ${value.currentResult}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get async stub&lt;/span&gt;
    val client =&lt;span&gt; SumManyToOneGrpc.stub(channel)

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get request stream observer from server&lt;/span&gt;
    val reqStreamObserver =&lt;span&gt; client.addManyToOne(respStreamObserver)

    List(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;).map { n =&amp;gt;&lt;span&gt;
      reqStreamObserver.onNext(SumRequest(n))
    }
    scala.io.StdIn.readLine()
  }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ManyToManyServer.scala &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package learn.grpc.sum.many2many.server
import io.grpc.stub.StreamObserver
import learn.grpc.services.sum._
import learn.grpc.server.gRPCServer
import monix.execution.atomic.{Atomic,AtomicInt}
&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Many2ManyServer extends gRPCServer {
  &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Many2ManyService extends SumInterGrpc.SumInter {
    &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def addInter(responseObserver: StreamObserver[SumResponse]): StreamObserver[SumRequest] =
      &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamObserver[SumRequest] {
        val currentSum: AtomicInt &lt;/span&gt;= Atomic(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onError(t: Throwable): Unit = println(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error: ${t.getMessage}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onCompleted(): Unit = println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Done requesting!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def onNext(value: SumRequest): Unit =&lt;span&gt; {
          responseObserver.onNext(SumResponse(currentSum.addAndGet(value.toAdd)))
        }
      }
  }
  def main(args: Array[String]): Unit &lt;/span&gt;=&lt;span&gt; {
    val svc &lt;/span&gt;= SumInterGrpc.bindService(&lt;span&gt;new&lt;/span&gt; Many2ManyService, scala.concurrent.ExecutionContext.&lt;span&gt;global&lt;/span&gt;&lt;span&gt;)
    runServer(svc)
  }

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ManyToManyClient.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package learn.grpc.sum.many2many.client
import monix.execution.Scheduler.{&lt;/span&gt;&lt;span&gt;global&lt;/span&gt; =&amp;gt;&lt;span&gt; scheduler}
import learn.grpc.services.sum._

import scala.concurrent.duration._
import scala.util.Random
import io.grpc._
import io.grpc.stub.StreamObserver

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Many2ManyClient {
  def main(args: Array[String]): Unit &lt;/span&gt;=&lt;span&gt; {
    val channel &lt;/span&gt;= ManagedChannelBuilder.forAddress(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;50051&lt;/span&gt;).usePlaintext(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).build
    val client  &lt;/span&gt;=&lt;span&gt; SumInterGrpc.stub(channel)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;create stream observer for result stream&lt;/span&gt;
    val responseObserver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamObserver[SumResponse] {
      def onError(t: Throwable): Unit &lt;/span&gt;= println(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ON_ERROR: $t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      def onCompleted(): Unit         &lt;/span&gt;= println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ON_COMPLETED&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      def onNext(value: SumResponse): Unit &lt;/span&gt;=&lt;span&gt;
        println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ON_NEXT: Current sum: ${value.currentResult}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get request container&lt;/span&gt;
    val requestObserver =&lt;span&gt; client.addInter(responseObserver)

    scheduler.scheduleWithFixedDelay(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;.seconds, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.seconds) {
      val toBeAdded &lt;/span&gt;= Random.nextInt(&lt;span&gt;11&lt;/span&gt;&lt;span&gt;)
      println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Adding number: $toBeAdded&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      requestObserver.onNext(SumRequest(toBeAdded))
    }

    scala.io.StdIn.readLine()
  }

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 11 May 2018 06:13:00 +0000</pubDate>
<dc:creator>雪川大虫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiger-xc/p/9023937.html</dc:identifier>
</item>
<item>
<title>前端工程化（一）---工程目录搭建 - lichking2017</title>
<link>http://www.cnblogs.com/lichking2017/p/9023821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lichking2017/p/9023821.html</guid>
<description>&lt;p&gt;导航&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/lichking2017/p/9023821.html&quot; target=&quot;_blank&quot;&gt;前端工程化（一）---工程基础目录搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前端工程化（二）---webpack配置&lt;/p&gt;
&lt;p&gt;前端工程化（三）---Vue的开发模式&lt;/p&gt;
&lt;p&gt;前端工程化（四）---helloWord&lt;/p&gt;


&lt;p&gt;由于一直在搞后端开发，对于前端内容的掌握一直停留在css、jquery、js、html这类的基础应用上。&lt;/p&gt;
&lt;p&gt;一下子接触到前端工程化、spa这类的东西，曲线有些陡峭，整个过程经历了诸多曲折。将收集到的知识总结一下，掺杂着一些个人的理解，不一定准确。&lt;/p&gt;
&lt;p&gt;开始搭建之前，先要搞清楚一些概念。&lt;/p&gt;

&lt;p&gt;1、前端工程化&lt;/p&gt;
&lt;p&gt;　　记得在刚刚进入软件行业的时候，项目组中一般都会有美工这个角色，负责设计系统需要的各种图片、切图，设计系统整体的样式。上面的工作完成后就可以交给后台开发人员了，后者负责后台逻辑，从数据库中读取数据并渲染到页面上。前端的所有工作围绕着切图、调样式开展&lt;/p&gt;
&lt;p&gt;　　现在的前端趋势是什么？就是工程化，工作的模式和后端开发一样，也是多模块多人协作开发（这也就诞生了CommonJS、AMD/CMD、require这些模块化标准），那么就需要进行工程化，否则代码很难管理与维护。前端承担的任务也比原来繁重了很多，后端只需要提供接口API，剩下的视图层的渲染工作全部由前端完成。前后端分工越来越清晰，前后端在项目开发过程中不再相互制约，前端与后端已经分离&lt;/p&gt;
&lt;p&gt;　　同时，前端开发已经不是所见即所得了，比如es6、less是不能够得到所有浏览器的完美支持的，但是这些东西还能加快我们的开发效率，那怎么权衡呢？那么就需要解释为浏览器能够完美支持的css、js语法&lt;/p&gt;
&lt;p&gt;2、webpack&lt;/p&gt;
&lt;p&gt;　 一些基本概念请参照：&lt;a href=&quot;https://doc.webpack-china.org/&quot; target=&quot;_blank&quot;&gt;官方教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    官方的解释：&lt;em&gt;webpack&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 是一个现代 JavaScript 应用程序的&lt;em&gt;静态模块打包器(module bundler)&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;em&gt;   &lt;/em&gt; 在我自己的项目场景中，webpack就是将es6、less、vue、图片、字体这些资源通通都打包为浏览器能够解析的js、css代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;3、Node.js 的 包管理器npm&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;    全球最大的开源生态系统，在前端项目构建过程中，会不断的使用该命令去添加项目对各种第三方模块的依赖，例如：添加html-webpack-plugin的引用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cnpm install html-webpack-plugin --save-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;    给我的感觉它就向后台构建工具Maven，Maven是通过在pom文件中添加模块的坐标来添加依赖，例如：添加对Mybatis的依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis-spring&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${version.mybatis-spring}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;以下过程都是基于webpack4的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;1、安装node.js&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;进入 &lt;a href=&quot;https://nodejs.org/en/download/&quot; target=&quot;_blank&quot;&gt;https://nodejs.org/en/download/&lt;/a&gt; 根据自己电脑的系统不同，下载对应的安装文件，进行安装&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;2、由于npm下载资源很慢，因此推荐使用阿里的 cnpm来取代npm&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;3、安装webpack，我装的是4.5.0版本&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo cnpm install webpack@4.5.0 -g
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、安装后，发现webpack -h不好使，提示要安装webpack-cli&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo cnpm install webpack-cli -g
sudo cnpm install webpack-cli -D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这两步都要执行&lt;/p&gt;
&lt;p&gt;5、初始化工程&lt;/p&gt;
&lt;p&gt;新建工程目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mkdir syInfoApp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化&lt;/p&gt;

&lt;p&gt;安装后，目录下会产生一个package.json文件，它类似于Maven中的pom。里面记录了依赖的模块信息、版本信息还有项目的一些基本信息。网上的一些教程，使用已经搭建好的环境进行讲解，当看到package.json文件的时候，里面一大堆的东西让人头晕，还是从头一点儿点儿来比较清晰&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1394048/201805/1394048-20180511124434503-513231191.png&quot; alt=&quot;&quot; width=&quot;735&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、安装全局webpack&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo cnpm install webpack@4.5.0 -g
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装后，发现webpack -h不好使，提示要安装webpack-cli&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo cnpm install webpack-cli -g
sudo cnpm install webpack-cli -D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上这两步都要执行&lt;/p&gt;
&lt;p&gt;7、在项目中安装webpack，以便在项目中可以使用&lt;/p&gt;
&lt;p&gt;进入项目所在目，执行如下命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cnpm install webpack@4.5.0 --save-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时可以看到在package.json中看到对webpack的依赖信息了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1394048/201805/1394048-20180511125647655-2126704228.png&quot; alt=&quot;&quot; width=&quot;445&quot; height=&quot;205&quot;/&gt;&lt;/p&gt;

&lt;p&gt;8、创建项目基本目录&lt;/p&gt;
&lt;p&gt;参照约定，创建以下目录&lt;/p&gt;
&lt;p&gt;/src：存放源码目录&lt;/p&gt;
&lt;p&gt;/src/assets：存放项目公用的图片、js、样式、模板、数据的资源&lt;/p&gt;
&lt;p&gt;/src/components：存放封装好的前端组件，比如图片上传组件、树组件、列表组件等等&lt;/p&gt;
&lt;p&gt;/src/routes：存放vue-router的路由配置&lt;/p&gt;
&lt;p&gt;/src/views：存放应用的视图，比如用户管理页面（叫页面不确切，因为我们是单页面应用，整个系统只有一个页面。所以叫html片段更贴切）&lt;/p&gt;
&lt;p&gt;/dist：存放构建后的文件&lt;/p&gt;
&lt;p&gt;9、创建表要的文件&lt;/p&gt;
&lt;p&gt;app.vue：这是基于Vue开发的根实例。&lt;/p&gt;
&lt;p&gt;index.js：负责将app.vue挂载到项目的主页，也就是index.html上（index.html在哪？后续会介绍）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1394048/201805/1394048-20180511140356870-909376894.png&quot; alt=&quot;&quot; width=&quot;206&quot; height=&quot;428&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 11 May 2018 06:07:00 +0000</pubDate>
<dc:creator>lichking2017</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lichking2017/p/9023821.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Config - RSA简介以及使用RSA加密配置文件 - 乾儿_Polaris</title>
<link>http://www.cnblogs.com/zxuqian/p/9024149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zxuqian/p/9024149.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;RSA非对称加密有着非常强大的安全性，HTTPS的SSL加密就是使用这种方法进行HTTPS请求加密传输的。因为RSA算法会涉及Private Key和Public Key分别用来加密和解密，所以称为非对称加密。Private Key和Public Key有互操作性，即用private key加密的可以用public key解密，用public key加密的可以用private key解密。传统的单向认证则只用public key进行加密，有private key的一方才可进行解密。例如，一个web服务器会有一对private key和public key。浏览器客户端保存着服务器的public key。当客户端需要向服务器发送数据时，就用服务器的public key进行加密，然后服务器收到数据时，再用private key进行解密。客户端验证服务器是否为真实的服务器时，会根据服务器提供的public key和自己本地保存的public key作比较，一致的话才能验证服务器的真实性。&lt;/p&gt;
&lt;p&gt;在我们的config server中，一些对加密要求比较高的可以采用RSA算法进行数据的加密和解密。&lt;/p&gt;
&lt;h2 id=&quot;项目源码&quot;&gt;项目源码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/zxuqian/spring-cloud/tree/spring-cloud-config-rsa&quot;&gt;Gitee码云&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;生成测试keystore&quot;&gt;生成测试Keystore&lt;/h2&gt;
&lt;p&gt;我们需要使用jdk自带的&lt;code&gt;keytool&lt;/code&gt;工具生成一个keystore，里边保存了private key的信息，使用如下命令行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;keytool -genkeypair -alias config-server-key -keyalg RSA -dname &quot;CN=Config Server,OU=Xuqian,O=My Own Company,L=Beijing,S=Beijing,C=CN&quot; -keypass changeit -keystore server.jks -storepass changeit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;-genkeypair 参数即产生一对public key和private key。&lt;br/&gt;-alias 指定key的别名，用于区分同一keystore中不同的key。&lt;br/&gt;-keyalg 指定生成key的算法，这里使用默认的RSA&lt;br/&gt;-dname 指定common name，即CN，用以验证key的身份。其中各项皆为自定义参数，OU为单位名称，O为组织名称，L为城市，S为省份/州，C为国家&lt;br/&gt;-keypass 为key的密码&lt;br/&gt;-keystore 为keystore的文件名&lt;br/&gt;-storepass 访问keystore的密码&lt;/p&gt;
&lt;p&gt;上述工具将产生的 privte key 保存在了名为server.jks的 key store 中。到目前为止，我们只产生了 private key，Spring Cloud Config Server 会根据我们提供的 key 的信息，每次会用程序生成一个 public key，参考如下源代码&lt;code&gt;org.springframework.security.rsa.crypto.KeyStoreKeyFactory&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; KeyPair &lt;span class=&quot;fu&quot;&gt;getKeyPair&lt;/span&gt;(String alias, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;[] password) {
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (lock) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (store == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (lock) {
                    &lt;span class=&quot;co&quot;&gt;// 根据配置提供的 keystore 文件地址和密码获取 keystore 的实例对象&lt;/span&gt;
                    store = KeyStore.&lt;span class=&quot;fu&quot;&gt;getInstance&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;jks&quot;&lt;/span&gt;);
                    store.&lt;span class=&quot;fu&quot;&gt;load&lt;/span&gt;(resource.&lt;span class=&quot;fu&quot;&gt;getInputStream&lt;/span&gt;(), &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;password&lt;/span&gt;);
                }
            }
        }
        &lt;span class=&quot;co&quot;&gt;// 根据配置提供的 alias 和 password 从 keystore 中取得 private key&lt;/span&gt;
        RSAPrivateCrtKey key = (RSAPrivateCrtKey) store.&lt;span class=&quot;fu&quot;&gt;getKey&lt;/span&gt;(alias, password);
        &lt;span class=&quot;co&quot;&gt;// 定义 Public Key 生成规则&lt;/span&gt;
        RSAPublicKeySpec spec = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; RSAPublicKeySpec(key.&lt;span class=&quot;fu&quot;&gt;getModulus&lt;/span&gt;(),
                key.&lt;span class=&quot;fu&quot;&gt;getPublicExponent&lt;/span&gt;());
        &lt;span class=&quot;co&quot;&gt;// 生成 Public Key&lt;/span&gt;
        PublicKey publicKey = KeyFactory.&lt;span class=&quot;fu&quot;&gt;getInstance&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;RSA&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;generatePublic&lt;/span&gt;(spec);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; KeyPair(publicKey, key);
    }
    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;st&quot;&gt;&quot;Cannot load keys from store: &quot;&lt;/span&gt; + resource, e);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用了 Java Security API 来对key进行操作。参见注释。然后上边的信息通过 &lt;code&gt;configserver&lt;/code&gt; 中的 &lt;code&gt;bootstrap.xml&lt;/code&gt; 配置文件提供：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode yml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;encrypt:&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;#key: Thisismysecretkey&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;key-store:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;location:&lt;/span&gt; file://${user.home}/development/keys/server.jks
    &lt;span class=&quot;fu&quot;&gt;password:&lt;/span&gt; changeit
    &lt;span class=&quot;fu&quot;&gt;alias:&lt;/span&gt; config-server-key
    &lt;span class=&quot;fu&quot;&gt;secret:&lt;/span&gt; changeit&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为我们不能同时使用对称加密和非对称加密，所以我们把 &lt;code&gt;encrypt.key&lt;/code&gt; 配置注释掉，然后指定非对称加密的参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;location： Keystore 的文件路径&lt;/li&gt;
&lt;li&gt;password： keystore 的密码&lt;/li&gt;
&lt;li&gt;alias： key 的别名&lt;/li&gt;
&lt;li&gt;secret： key的密码&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;我们继续使用 &lt;code&gt;encrypt&lt;/code&gt; API加密一项测试数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl http://localhost:8888/encrypt -d 23456789&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回加密后的字符：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AQAPWOUOh4WVexGgVv+bgtKc5E0d5Aba8VUKnzEXh27HyKSAbW+wyzDwZTbk5QYfXpoCAs413rdeNIdR2ez44nkjT5V+438/VQExySzjZPhP0xYXi9YIaJqA3+Ji+IWK8hrGtJ4dzxIkmItiimCOirLdZzZGDm/yklMUVh7lARSNuMxXGKlpdBPKYWdqHm57ob6Sb0ivm4H4mL1n4d3QUCuE7hh2F4Aw4oln7XueyMkRPTtPy8OpnBEEZhRfmaL/auVZquLU5jjMNJk9JiWOy+DSTscViY/MZ+dypv6F4AfDdVvog89sNmPzcUT+zmB8jXHdjLoKy+63RG326WffY9OPuImW6/kCWZHV6Vws55hHqRy713W6yDBlrQ/gYC3Wils=&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后测试解密&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl http://localhost:8888/decrypt -d AQAPWOUOh4+bgtKc5E0d5Aba8VUKnzEXh27HyKSAbW+wyzDwZTbk5QYfXpoCAs413rdeNIdR2ez44nkjT5V+438/VQExySzjZPhP0xYXi9YIaJqA3+Ji+IWK8hrGtJ4dzxIkmItiimCOirLdZzZGDm/yklMUVh7lARSNuMxXGKlpdBPKYWdqHm57ob6Sb0ivm4H4mL1n4d3QUCuE7hh2F4Aw4oln7XueyMkRPTtPy8OpnBEEZhRfmaL/auVZquLU5jjMNJk9JiWOy+DSTscViY/MZ+dypv6F4AfDdVvog89sNmPzcUT+zmB8jXHdjLoKy+63RG326WffY9OPuImW6/kCWZHV6Vws55hHqRy713W6yDBlrQ/gYC3Wils=&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会返回&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;23456789&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以修改&lt;code&gt;web-client.yml&lt;/code&gt;来验证：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode yml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;co&quot;&gt;#test:&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;#password: '{cipher}94c1027141add9844ec47f0be13caebb6b38ed1dcf99811b1a5cd2b874c64407'&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;user:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;password:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'{cipher}AQAPWOUOh4WVexGgVv+bgtKc5E0d5Aba8VUKnzEXh27HyKSAbW+wyzDwZTbk5QYfXpoCAs413rdeNIdR2ez44nkjT5V+438/VQExySzjZPhP0xYXi9YIaJqA3+Ji+IWK8hrGtJ4dzxIkmItiimCOirLdZzZGDm/yklMUVh7lARSNuMxXGKlpdBPKYWdqHm57ob6Sb0ivm4H4mL1n4d3QUCuE7hh2F4Aw4oln7XueyMkRPTtPy8OpnBEEZhRfmaL/auVZquLU5jjMNJk9JiWOy+DSTscViY/MZ+dypv6F4AfDdVvog89sNmPzcUT+zmB8jXHdjLoKy+63RG326WffY9OPuImW6/kCWZHV6Vws55hHqRy713W6yDBlrQ/gYC3Wils='&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注释掉 &lt;code&gt;test.password&lt;/code&gt;，新增一个 &lt;code&gt;user.password&lt;/code&gt; 使用加密后的配置值。然后提交的gitee仓库，通过 url 访问此配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:8888/web-client/default&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到如下结果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;web-client&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;profiles&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&quot;default&quot;&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;label&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;3044a5345fb86d09a043ca7404b9e57c8c13c512&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;state&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;propertySources&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;https://gitee.com/zxuqian/spring-cloud-config-remote/web-client.yml&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;source&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;&quot;message&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;此条消息来自于远程配置仓库&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;&quot;management.endpoints.web.exposure.include&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;&quot;user.password&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;23456789&quot;&lt;/span&gt;
            &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 11 May 2018 05:32:00 +0000</pubDate>
<dc:creator>乾儿_Polaris</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zxuqian/p/9024149.html</dc:identifier>
</item>
<item>
<title>设计模式（四）—— 建造者模式 - Answer.Geng</title>
<link>http://www.cnblogs.com/Answer-Geng/p/9016274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Answer-Geng/p/9016274.html</guid>
<description>&lt;h2 id=&quot;建造者模式&quot;&gt;建造者模式&lt;/h2&gt;
&lt;h3 id=&quot;模式简介&quot;&gt;模式简介&lt;/h3&gt;
&lt;p&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于创建型模式。&lt;/p&gt;
&lt;h3 id=&quot;结构说明&quot;&gt;结构说明&lt;/h3&gt;
&lt;h4 id=&quot;uml类图&quot;&gt;UML类图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201805/971601-20180511130512215-1377995917.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;角色及职责&quot;&gt;角色及职责&lt;/h4&gt;
&lt;p&gt;为创建一个Product对象的各个部件指定抽象接口&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ConcreteBuilder&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体的生成器，实现Builder的接口以构造和装配该产品的各个部件&lt;/p&gt;
&lt;p&gt;导向器，构造一个使用Builder接口的对象&lt;/p&gt;
&lt;p&gt;被构建的复杂对象，ConcreteBuilder创建该产品的内部表示并定义它的装配过程&lt;/p&gt;
&lt;h4 id=&quot;uml时序图&quot;&gt;UML时序图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201805/971601-20180511095631651-460854707.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;示例分析&quot;&gt;示例分析&lt;/h3&gt;
&lt;h4 id=&quot;文档转换器&quot;&gt;文档转换器&lt;/h4&gt;
&lt;h4 id=&quot;功能简介文档转换器读取一份text文档并根据文档中的内容为不同部门生成指定格式报告&quot;&gt;功能简介：文档转换器读取一份Text文档，并根据文档中的内容为不同部门生成指定格式报告。&lt;/h4&gt;
&lt;h4 id=&quot;分析虽然各部门指定的报告格式及文件类型不同但是文档创建的顺序均可以理解为设置文档名-设置文档类型-填写标题-填写报告内容&quot;&gt;分析：虽然各部门指定的报告格式及文件类型不同，但是文档创建的顺序均可以理解为：设置文档名-&amp;gt;设置文档类型-&amp;gt;填写标题-&amp;gt;填写报告内容&lt;/h4&gt;
&lt;h4 id=&quot;设计思路&quot;&gt;设计思路&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201805/971601-20180511101511187-482899872.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;创建抽象建造者reportbuilder&quot;&gt;创建抽象建造者ReportBuilder&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;abstract class ReportBuilder
{
    public abstract void SetReportName();
    public abstract void SetReportType();
    public abstract void FillTitle();
    public abstract void FillContent();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建产品类textreport和excelreport&quot;&gt;创建产品类TextReport和ExcelReport&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;class TextReport
{
    public string ReportName { get; set; }
    public string ReportType { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public void Show()
    {
        Console.WriteLine($&quot;ReportName:{ReportName}&quot;);
        Console.WriteLine($&quot;ReportType:{ReportType}&quot;);
        Console.WriteLine($&quot;Title:[{Title}]&quot;);
        Console.WriteLine($&quot;Content:{Content}&quot;);
    }
}

class ExcelReport
{
    public string ReportName { get; set; }
    public string ReportType { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public void Show()
    {
        Console.WriteLine($&quot;--ReportName:{ReportName}--&quot;);
        Console.WriteLine(&quot;----------------------------&quot;);
        Console.WriteLine($&quot;--ReportType:{ReportType}--&quot;);
        Console.WriteLine(&quot;----------------------------&quot;);
        Console.WriteLine($&quot;--Title:[{Title}]--&quot;);
        Console.WriteLine(&quot;----------------------------&quot;);
        Console.WriteLine($&quot;--Content:{Content}--&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;分别实现具体建造者textreportbuilder和excelreportbuilder&quot;&gt;分别实现具体建造者TextReportBuilder和ExcelReportBuilder&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;class TextReportBuilder : ReportBuilder
{
    TextReport report = new TextReport();
    public override void FillContent()
    {
        report.Content = &quot;TEXT REPORT CONTENT&quot;;
    }

    public override void FillTitle()
    {
        report.Title = &quot;This is a TEXT REPORT&quot;;
    }

    public override void SetReportName()
    {
        report.ReportName = &quot;TextReport&quot;;
    }

    public override void SetReportType()
    {
        report.ReportType = &quot;txt&quot;;
    }

    public TextReport GetResult()
    {
        return report;
    }
}

class ExcelReportBuilder : ReportBuilder
{
    ExcelReport report = new ExcelReport();
    public override void FillContent()
    {
        report.Content = &quot;EXCEL REPORT CONTENT&quot;;
    }

    public override void FillTitle()
    {
        report.Title = &quot;This is a EXCEL REPORT&quot;;
    }

    public override void SetReportName()
    {
        report.ReportName = &quot;TextReport&quot;;
    }

    public override void SetReportType()
    {
        report.ReportType = &quot;txt&quot;;
    }

    public ExcelReport GetResult()
    {
        return report;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;声明指挥着textreader&quot;&gt;声明指挥着TextReader&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;class TextReader
{
    private string text;
    public TextReader(string text)
    {
        this.text = text;
    }

    public void Construct(ReportBuilder reportBuilder)
    {
        reportBuilder.SetReportName();
        reportBuilder.SetReportType();
        reportBuilder.FillTitle();
        reportBuilder.FillContent();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;客户端调用&quot;&gt;客户端调用&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;TextReader reader = new TextReader(&quot;Text Content&quot;);
ExcelReportBuilder builder = new ExcelReportBuilder();
reader.Construct(builder);
builder.GetResult().Show();
Console.ReadLine();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;建造者模式扩展&quot;&gt;建造者模式扩展&lt;/h3&gt;
&lt;h4 id=&quot;本节讲述如何使用建造者模式封装一个邮件构造器&quot;&gt;本节讲述如何使用建造者模式封装一个邮件构造器&lt;/h4&gt;
&lt;p&gt;想想我们怎样通过SMTP发送邮件，大致代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SmtpClient mailClient = newSmtpClient(host);
mailClient.Credentials = CredentialCache.DefaultNetworkCredentials;
MailMessage msg = new MailMessage();
msg.From = new MailAddress(address);
msg.To.Add(to);
msg.CC.Add(cc);
msg.Attachments.Add(attachment);
msg.Subject = subject;
msg.SubjectEncoding = Encoding.UTF8;
msg.Body = body;
msg.BodyEncoding = Encoding.UTF8;
msg.IsBodyHtml = false;
msg.Priority = priority;
mailClient.Send(msg);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于各个公司来说，邮件服务器信息一般是固定的，所以发送邮件程序里变化部分仅仅是邮件内容。&lt;/p&gt;
&lt;h4 id=&quot;使用建造者模式封装一个邮件构造器&quot;&gt;使用建造者模式封装一个邮件构造器&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public class MailBuilder
{
    private string host = &quot;xxxx.xxx.com&quot;;
    private string subject;
    private string body;
    private bool isBodyHtml;
    private string from;
    private List&amp;lt;string&amp;gt; to;
    private List&amp;lt;string&amp;gt; cc;
    private List&amp;lt;Attachment&amp;gt; attachment;
    private MailPriority priority;

    public MailBuilder Subject(string subject)
    {
        this.subject = subject;
        return this;
    }

    public MailBuilder Body(string body)
    {
        this.body = body;
        return this;
    }

    public MailBuilder IsBodyHtml(bool isBodyHtml)
    {
        this.isBodyHtml = isBodyHtml;
        return this;
    }

    public MailBuilder MailFrom(string mailFrom)
    {
        this.from = mailFrom;
        return this;
    }

    public MailBuilder MailTo(List&amp;lt;string&amp;gt; mailTo)
    {
        this.to = mailTo;
        return this;
    }

    public MailBuilder MailCc(List&amp;lt;string&amp;gt; mailCc)
    {
        this.cc = mailCc;
        return this;
    }

    public MailBuilder Attachment(List&amp;lt;Attachment&amp;gt; attachment)
    {
        this.attachment = attachment;
        return this;
    }

    public MailBuilder MailPriority(MailPriority mailpriority)
    {
        this.priority = mailpriority;
        return this;
    }

    public void Send()
    {
        SmtpClient client = new SmtpClient(host);
        client.Credentials = CredentialCache.DefaultNetworkCredentials;
        MailMessage msg = new MailMessage();
        msg.Subject = this.subject;
        msg.Body = this.body;
        msg.IsBodyHtml = this.isBodyHtml;
        msg.From = new MailAddress(this.from);
        if (this.to != null)
        {
            this.to.ForEach(p =&amp;gt; msg.To.Add(p));
        }

        if (this.cc != null)
        {
            this.cc.ForEach(p =&amp;gt; msg.CC.Add(p));
        }

        if (this.attachment != null)
        {
            this.attachment.ForEach(p =&amp;gt; msg.Attachments.Add(p));
        }
        msg.Priority = this.priority;
        client.Send(msg);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MailBuilder mail = new MailBuilder();
mail.Subject($&quot;{DateTime.Now}&quot;)
    .Body(&quot;Test&quot;)
    .MailFrom(&quot;xxxx@xxx.com&quot;)
    .MailTo(to)
    .Send();
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如此调用，是不是优雅了很多呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：这里省略了抽象建造者以及指挥者，Builder角色扮演了指挥者与建造者双重角色&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;建造者模式与抽象工厂模式比较&quot;&gt;建造者模式与抽象工厂模式比较&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;建造者模式侧重&lt;strong&gt;产品构造的过程及顺序&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;建造者模式强调返回一个&lt;strong&gt;组装&lt;/strong&gt;好的完整的产品，抽象工厂模式&lt;strong&gt;生产&lt;/strong&gt;一系列产品。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;优缺点&quot;&gt;优缺点&lt;/h3&gt;
&lt;h4 id=&quot;优点&quot;&gt;优点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;将产品的构建与表示解耦，使得相同的创建过程可以复用在不同产品上&lt;/li&gt;
&lt;li&gt;具体建造者相互独立，替换起来比较方便，用户使用不同建造者即可得到不同的产品对象&lt;/li&gt;
&lt;li&gt;对产品的创建过程加以控制，使得创建过程更加清晰&lt;/li&gt;
&lt;li&gt;增加具体建造者无需修改现有代码，便于扩展&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;缺点&quot;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;仅适用于产品组成与创建过程相似的情况&lt;/li&gt;
&lt;li&gt;随着建造者数量的增加，导致系统变得很庞大&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用场景&quot;&gt;使用场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时&lt;/li&gt;
&lt;li&gt;但个构造过程必须允许被构造的对象有不同的表示时&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;示例代码下载&quot;&gt;示例代码下载&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Answer-Geng/dotnet-design-pattern/tree/master/builder/src&quot;&gt;dotnet-design-pattern_builder&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 11 May 2018 05:18:00 +0000</pubDate>
<dc:creator>Answer.Geng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Answer-Geng/p/9016274.html</dc:identifier>
</item>
<item>
<title>bootstrap-table+x-editable入门 - seltonzyf</title>
<link>http://www.cnblogs.com/selton/p/9024060.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selton/p/9024060.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;https://getbootstrap.com/&quot;&gt;&lt;img src=&quot;https://files.cnblogs.com/files/selton/show.ico&quot; alt=&quot;&quot; width=&quot;72&quot; height=&quot;72&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 align=&quot;center&quot;&gt;Bootstrap-table&lt;/h3&gt;
&lt;p align=&quot;center&quot;&gt;快速入门bootstrap-table----我的表单不可能这么帅.&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&quot;table-of-contents&quot;&gt;Table of contents&lt;/h2&gt;
&lt;h2 id=&quot;quick-start&quot;&gt;quick-start&lt;/h2&gt;
&lt;p&gt;快速使用:&lt;/p&gt;
&lt;p&gt;没有配置java环境,移步&lt;a href=&quot;https://jingyan.baidu.com/article/6dad5075d1dc40a123e36ea3.html&quot;&gt;JDK安装与环境变量配置&lt;/a&gt;;&lt;br/&gt;没有配置tomcat环境,移步&lt;a href=&quot;https://jingyan.baidu.com/article/2c8c281daa77aa0008252aff.html&quot;&gt;tomcat的下载和安装配置&lt;/a&gt;;&lt;br/&gt;没有下载配置idea环境,移步&lt;a href=&quot;https://jingyan.baidu.com/article/afd8f4debd60f434e286e91f.html&quot;&gt;IntelliJ IDEA安装以及配置&lt;/a&gt;;&lt;/p&gt;
&lt;h2 id=&quot;why-use&quot;&gt;why-use&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;学习成本低,配置简单,文档齐全&lt;/li&gt;
&lt;li&gt;与Bootstrap无缝衔接,整体风格一致,也便于二次开发&lt;/li&gt;
&lt;li&gt;开发者活跃,Github定期维护&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;whats-included&quot;&gt;whats-included&lt;/h2&gt;
&lt;p&gt;file list:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bootstrapDemo/
├── web/
│   ├── js
│   ├── WEB-INF
│   └── bootindex.html
└── src/
│   └── DataSendServlet.java

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表单展示页面 (&lt;code&gt;bootindex.html&lt;/code&gt;)&lt;br/&gt;javascript文件 (&lt;code&gt;showOrder.js&lt;/code&gt;)从服务器取得数据,然后渲染表格&lt;/p&gt;
&lt;h2 id=&quot;details&quot;&gt;details&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#table&quot;).bootstrapTable({
  method: &quot;post&quot;,
  url: &quot;获取后台数据的url&quot;,
  ... ...

});   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的js语句的所有渲染操作是针对html页面中的id为table的一个table,所以不要忘了在导入了该js的html中构建出id为table的table&lt;/p&gt;
&lt;p&gt;bootstrap-table中的重要键值的简单解释:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;showorder.js&lt;/code&gt;会向服务器发起ajax访问&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bootstrapTable&lt;/code&gt;构建元素解析:&lt;/p&gt;
&lt;h4 id=&quot;url&quot;&gt;url&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#table&quot;).bootstrapTable({
  method: &quot;post&quot;,
  url: &quot;获取后台数据的url&quot;,
  ... ...

}); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ajax访问到的后台路径(必须),该后台需要按照指定的&lt;a href=&quot;http://www.cnblogs.com/selton/p/9024060.html#jsonstyle&quot;&gt;json&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;queryparams&quot;&gt;queryParams&lt;/h4&gt;
&lt;p&gt;不需要任何修改,相当于ajax中的data键,发送给后台的数据,给出实现表单分页的两个参数,&lt;a href=&quot;http://www.cnblogs.com/selton/p/9024060.html#offset&quot;&gt;offset&lt;/a&gt;和&lt;a href=&quot;http://www.cnblogs.com/selton/p/9024060.html#limit&quot;&gt;limit&lt;/a&gt;,在&lt;code&gt;oTableInit.queryParams&lt;/code&gt;中给出,后台用&lt;code&gt;request.getParameter()&lt;/code&gt;的方式拿到queryParams中传递过来的值,然后制定dao&lt;/p&gt;
&lt;h4 id=&quot;pagesize&quot;&gt;pageSize&lt;/h4&gt;
&lt;p&gt;当前table一次最多显示多少行,也就是你的table的一页应该展现多少行,必须&lt;/p&gt;
&lt;h4 id=&quot;pagenumber&quot;&gt;pageNumber&lt;/h4&gt;
&lt;p&gt;起始页,一般是1不用改,这个和pageSize决定了queryParams中的offset的值,&lt;code&gt;offset=(pageSize - 1) * pageSize,limit=pageSize&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;contenttype&quot;&gt;contentType&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;contentType: &quot;application/x-www-form-urlencoded&quot;&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;columns&quot;&gt;columns&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#table&quot;).bootstrapTable({
  method: &quot;post&quot;,
  url: &quot;获取后台数据的url&quot;,
    [
    {field: 'testId', title: 'ID'},
    {field: 'testName', title: '姓名'},
    {field: 'testPassword', title: '密码'}
    ]  
      ... ...
  ]
});  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你的table的表结构,以上例子表示表有三列,列的实际显示名字分别是ID,姓名,密码,但是field代表实际数据的名字,表中的数据是由于ajax向服务器发起访问,服务器返回给的数据中的rows的每一个json对象的键都会对应到field的列中-----&lt;a href=&quot;http://www.cnblogs.com/selton/p/9024060.html#jsonstyle&quot;&gt;服务器返还的值&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;jsonstyle&quot;&gt;jsonstyle&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;{  
&quot;total&quot;:25,  
    &quot;rows&quot;:[
        {
        &quot;testID&quot;:1,
        &quot;testName&quot;:&quot;xiaoming1&quot;,
        &quot;testPassword&quot;:&quot;xiaomingpwd1&quot;
        },
        {
        &quot;testID&quot;:2,
        &quot;testName&quot;:&quot;xiaoming2&quot;,
        &quot;testPassword&quot;:&quot;xiaomingpwd2&quot;
        }
    ]
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据库返还给发起访问的ajax的数据,必须满足,包含两个json形式的键值对,&lt;br/&gt;一个是total键,值为表单拥有者在数据库中的全部数据的数量(行数),这个数据和pageSize决定table展示的页面有多少页,另一个是rows键,值为多个json对象,rows的每一个json对象就是当前table页的一行实体展示,这里的rows相当于会给前端table两行数据,testID,testName,testPassword分别会被填入到table中的field对应的列中-----&lt;a href=&quot;http://www.cnblogs.com/selton/p/9024060.html#columns&quot;&gt;前端接收到值表现&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;offset&quot;&gt;offset&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;oTableInit.queryParams = function (params) {

    var temp = {   //这里的键的名字和控制器的变量名必须一直，这边改动，控制器也需要改成一样的
        limit: params.limit,    //params.limit,   页面大小
        offset: params.offset,
        testNum: 445,
        testNum1: 343
    };  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;offset=(&lt;a href=&quot;http://www.cnblogs.com/selton/p/9024060.html#pageNumber&quot;&gt;pageNumber&lt;/a&gt; - 1) * &lt;a href=&quot;http://www.cnblogs.com/selton/p/9024060.html#pageSize&quot;&gt;pageSize&lt;/a&gt;,是会被发送到后台使用的数据,&lt;a href=&quot;http://www.cnblogs.com/selton/p/9024060.html#sql示例&quot;&gt;后台数据提取sql语句示例&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;limit&quot;&gt;limit&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;oTableInit.queryParams = function (params) {

    var temp = {   //这里的键的名字和控制器的变量名必须一直，这边改动，控制器也需要改成一样的
        limit: params.limit,    //params.limit,   页面大小
        offset: params.offset,
        testNum: 445,
        testNum1: 343
    };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;limit=&lt;a href=&quot;http://www.cnblogs.com/selton/p/9024060.html#pageSize&quot;&gt;pageSize&lt;/a&gt;,是会被发送到后台使用的数据,&lt;a href=&quot;http://www.cnblogs.com/selton/p/9024060.html#sql示例&quot;&gt;后台数据提取sql语句示例&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;sql示例&quot;&gt;sql示例&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;SELECT * FROM test WHERE id = ? LIMIT offset,limit&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;表格绑定事件&quot;&gt;表格绑定事件&lt;/h4&gt;
&lt;p&gt;用于测试ajax返回的数据是最好的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#table&quot;).bootstrapTable({
      method: &quot;post&quot;,
      url: &quot;获取后台数据的url&quot;,
      onLoadSuccess: function(){  //加载成功时执行
            console.info(&quot;加载成功&quot;);
      },
      onLoadError: function(){  //加载失败时执行
            console.info(&quot;加载数据失败&quot;);
      }
});    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于事件,更为详细的介绍请访问&lt;a href=&quot;http://bootstrap-table.wenzhixin.net.cn/zh-cn/documentation/#%E4%BA%8B%E4%BB%B6&quot;&gt;boottableDoc&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;editable&quot;&gt;editable&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;这是在操作的是table吗,感觉就像是数据库展现在了页面上&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果你已经阅读完或者已经在自己代码中实现了上述功能,但是table存在的目的本来就不应该只是展现,应该还有寻常的CRUD,精力有限,只是实践了update,笔者使用的是行内编辑的方式实现的update,需要用到另一个工具X-editable,不过还好boottable有这样的插件,将x-editable封装整合到了当中,只需要引入&lt;code&gt;https://cdn.bootcss.com/bootstrap-table/1.12.1/extensions/editable/bootstrap-table-editable.min.js&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;start-editable&quot;&gt;start editable&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#table&quot;).bootstrapTable({
  method: &quot;post&quot;,
  url: &quot;获取后台数据的url&quot;,
    [
    {field: 'testId',
    title: 'ID',
    editable: {mode: 'inline'}
    },
    {field: 'testName', 
    title: '姓名'},
    {field: 'testPassword', 
    title: '密码'}
    ]  
      ... ...
  ]
});  

onEditableSave: function (field, row, oldValue, $el) {

    $.ajax({
        type: &quot;post&quot;,
        url: &quot;/ordercenter/updateOrder.json&quot;,
        data: {
            orderid: row.orderid,
            updateCol: field,
            updateVal: eval('row.'+field)
        },
        dataType: 'JSON',
        success: function (data, status) {
            console.log(data);
            if (status == &quot;success&quot;) {
                alert('旧数据: 订单号: ' + row.orderid + ' ' + field + ': ' + oldValue + '\r\n'
                + '更新后的数据: 订单号: ' + data.updateId + ' ' + data.updateCol + ': ' + data.updateVal)
            }
        },
        error: function () {
            alert('编辑失败');
        },
        complete: function () {

        }

    });
},&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;details-editable&quot;&gt;details editable&lt;/h4&gt;
&lt;p&gt;编辑后的提交方法统一放到&lt;code&gt;onEditableSave&lt;/code&gt;事件里面统一处理&lt;/p&gt;
&lt;p&gt;例子: 页面table中的列姓名,field为testName,实际的值为xiaoming1,通过修改将其改为xiaoming2,这时候field为testName,row为一个json,键值对分别为该行的所有键值组合,oldValue为xiaoming1&lt;br/&gt;更为详细的描述请到&lt;a href=&quot;http://vitalets.github.io/x-editable/&quot;&gt;x-editable&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;建议读者直接使用我的&lt;code&gt;onEditableSave&lt;/code&gt;,它向后台发送了三个数据精确完成update,行特定标识和列特定标识定位到修改了哪一个具体的数据,再给出updateVal指出原本的数据被修改成了updateVal&lt;/p&gt;
</description>
<pubDate>Fri, 11 May 2018 05:09:00 +0000</pubDate>
<dc:creator>seltonzyf</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selton/p/9024060.html</dc:identifier>
</item>
</channel>
</rss>