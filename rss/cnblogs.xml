<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Jmeter脚本调试——关联（正则表达式） - 温一壶清酒</title>
<link>http://www.cnblogs.com/hong-fithing/p/7650762.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hong-fithing/p/7650762.html</guid>
<description>&lt;p&gt; 关联，在脚本中，是必应用到的一个设置方法，将脚本中，每次都会动态变化的特殊值进行关联。一个能正确执行的脚本，都需要进行关联（LR、jmeter）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Jmeter关联：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         在脚本回放过程中，客户端发出请求，通过Jmeter中的正则表达式提取器所定义的左右边界值（也就是关联规则），在服务器所响应的内容中查找，得到相应的值，以变量的形式替换录制时的静态值，从而向服务器发出正确的请求，这种动态获得服务器响应内容的方法称作关联。通俗点说，就是把脚本中某些写死的（hard-coded）数据，转变成撷取自服务器所送的、动态的、每次都不一样的数据。&lt;/p&gt;
&lt;p&gt;关联分两种，提取单个字符串和多个字符串。&lt;/p&gt;
&lt;p&gt;先添加正则表达式提取器，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011143038387-781306599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正则表达式提取器：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;允许用户从服务器的响应中通过使用perl的正则表达式提取值。该元素会作用在指定范围取样器，用正则表达式提取所需值，生成模板字符串，并将结果存储到给定的变量名中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;提取单个字符串&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;假如想匹配Web页面的如下部分：name=&quot;csrf_token&quot; value=&quot;d574d4d2c0b9f499&quot;/&amp;gt;并提取d574d4d2c0b9f499。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011143230324-1695996776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提取该值，正则表达式写为：name=&quot;csrf_token&quot; value=&quot;(.+?)&quot;/&amp;gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011143352621-684618633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将脚本中的相应值改为如下所示即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011144640887-1390309574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可在正则下添加一个取样器，如下所示，可以清楚看到正则提取出来的值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011144744277-1115474987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行脚本，可以查看到如下结果：&lt;/p&gt;
&lt;p&gt;token=59783be4af34337b&lt;br/&gt;token_g=1&lt;br/&gt;token_g0=name=&quot;csrf_token&quot; value=&quot;59783be4af34337b&quot;/&amp;gt;&lt;br/&gt;token_g1=59783be4af34337b&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011145529887-517616559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;提取多个字符串&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;假如想匹配Web页面的如下部分：&lt;/p&gt;
&lt;p&gt;name=&quot;csrf_token&quot; value=&quot;d574d4d2c0b9f499&quot;/&amp;gt;并提取csrf_token和d574d4d2c0b9f499。&lt;/p&gt;
&lt;p&gt;添加正则提取器，写入正则表达式，如下所示，正则表达式为：name=&quot;(.+?)&quot; value=&quot;(.+?)&quot;/&amp;gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011145628934-818122609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就会创建2个组，分别用于$1$和$2$&lt;/p&gt;
&lt;p&gt; 在参数值地方设置为如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011145750605-1764254832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行脚本，查看到的结果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011145836840-1402105147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引用名称：token&lt;/p&gt;
&lt;p&gt;模板：$1$$2$&lt;/p&gt;
&lt;p&gt;如下变量的值将会被设定：&lt;/p&gt;
&lt;p&gt;token=csrf_tokenc8cd334fb5197a2a&lt;/p&gt;
&lt;p&gt;token_g=2&lt;/p&gt;
&lt;p&gt;token_g0=name=&quot;csrf_token&quot; value=&quot;c8cd334fb5197a2a&quot;/&amp;gt;&lt;/p&gt;
&lt;p&gt;token_g1=csrf_token&lt;/p&gt;
&lt;p&gt;token_g2=c8cd334fb5197a2a&lt;/p&gt;
&lt;p&gt;在需要引用地方可以通过：${ token_g1}, ${ token_g2}进行使用。&lt;/p&gt;
&lt;p&gt;说了这么多操作，可能看起来有些地方不明白，也不知道意思，那现在就来点理论补充。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;正则表达式提取器详解：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先看一张图，就是正则提取器的面板，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011150100465-237831212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;名称： 随意设置， 最好具有业务上的意义， 方便区分&lt;/p&gt;
&lt;p&gt;注释： 随意设置， 一般不填写&lt;/p&gt;
&lt;p&gt;Apply to： 应用范围， 包含4个选项。&lt;/p&gt;
&lt;p&gt;　　Main sample and sub-samples： 匹配范围包括当前父取样器并覆盖子取样器。&lt;/p&gt;
&lt;p&gt;　　Main sample only： 匹配范围是当前父取样器（一般默认选择这个） 。&lt;/p&gt;
&lt;p&gt;　　Sub-samples only： 仅匹配子取样器。&lt;/p&gt;
&lt;p&gt;　　Jmeter Variable： 支持对Jmeter变量值进行匹配。&lt;/p&gt;
&lt;p&gt;要检查的响应字段： 针对响应数据的不同部分进行匹配， 共七个选项。&lt;/p&gt;
&lt;p&gt;　　主体： 响应数据的主体部分， 排除Header部分； Http协议返回请求的主体部分就是&lt;/p&gt;
&lt;p&gt;　　Body：（一般默认选择这个）&lt;/p&gt;
&lt;p&gt;　　Body（unescaped） ： 针对替换了转义码的Body部分。&lt;/p&gt;
&lt;p&gt;　　Body as a Document： 返回内容作为一个文档进行匹配。&lt;/p&gt;
&lt;p&gt;　　信息头： 只匹配信息头部分的内容。&lt;/p&gt;
&lt;p&gt;　　URL： 只匹配URL链接。&lt;/p&gt;
&lt;p&gt;　　响应代码： 匹配响应代码， 比如状态码200代表成功等。&lt;/p&gt;
&lt;p&gt;　　响应信息： 匹配响应信息， 比如”成功” “OK”等。&lt;/p&gt;
&lt;p&gt;　　引用名称： 即下一个请求要引用的参数名称， 如填写token， 则可用${token}引用它。&lt;/p&gt;
&lt;p&gt;正则表达式： 正则表达式提取器根据该处的设置进行信息匹配&lt;/p&gt;
&lt;p&gt;模板： 用$$引用起来， 如果在正则表达式中有多个正则表达式， 则可以是$1$， $2$等等， 表示解析到的第几个值给token， $1$表示第一个模板， $0$表示全文匹配。&lt;/p&gt;
&lt;p&gt;匹配数字： 用正则表达式匹配的时候， 可能出现多个值的情况， 为正数用来确定取一组值中的第几个， 为0表示随机取匹配值， 负数取所有值。&lt;/p&gt;
&lt;p&gt;默认值： 如果没有匹配到可以指定一个默认值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二次提取：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大家可能对二次提取不理解，看个例子就明白，以百度一下，你就知道举例：&lt;/p&gt;
&lt;p&gt;先获取到百度首页的标题，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011151132996-502205357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再添加一个提取器，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011151252199-2139074967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行脚本，查看结果，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011151430902-1660589314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就取出百度一下，你就知道，以及一下，你就。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;正则表达式匹配注意事项：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果不能匹配，那么显示变量名称，如  ${token}&lt;/p&gt;
&lt;p&gt;正则的操作符与含义如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011150335074-1761622595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;在提取字符中的正则表达式详解：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171011150604715-947390320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1、引用名称：下一个请求要引用的参数名称，如填写token，则可用${token}引用它。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2、正则表达式：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　()：括起来的部分就是要提取的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　.：匹配任何字符串。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　+：一次或多次。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　?：不要太贪婪，在找到第一个匹配项后停止。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3、模板：用$$引用起来，如果在正则表达式中有多个正则表达式，则可以是$2$$3$等等，表示解析到的第几个值给token。如：$1$表示解析到的第1个值&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4、匹配数字：0代表随机取值，1代表全部取值，通常情况下填0&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;5、缺省值：如果参数没有取得到值，那默认给一个值让它取。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在正则表达式中加问号？与不加的区别：&lt;/p&gt;
&lt;p&gt;&amp;lt;img src=&quot;test.jpg&quot; width=&quot;60px&quot; height=&quot;80px&quot;/&amp;gt;&lt;/p&gt;
&lt;p&gt;正则表达式：&amp;lt;img src=&quot;(.+?)&quot;   &lt;/p&gt;
&lt;p&gt;提取到的值为：test.jpg&lt;/p&gt;
&lt;p&gt;正则表达式：&amp;lt;img src=&quot;(.+)&quot;  &lt;/p&gt;
&lt;p&gt;提取到的值为：&quot; width=&quot;60px&quot; height=&quot;80px&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这样一说应该就全明白，希望对大家有所帮助。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;29.483394833948&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;本文仅代表作者观点，系作者@温一壶清酒发表。&lt;br/&gt;欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;br/&gt;文章出处：&lt;a href=&quot;http://www.cnblogs.com/hong-fithing/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hong-fithing/&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 11 Oct 2017 07:20:00 +0000</pubDate>
<dc:creator>温一壶清酒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hong-fithing/p/7650762.html</dc:identifier>
</item>
<item>
<title>SQLServer中重建聚集索引之后会影响到非聚集索引的索引碎片吗 - MSSQL123</title>
<link>http://www.cnblogs.com/wy123/p/7650215.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wy123/p/7650215.html</guid>
<description>
&lt;p&gt;本文出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: SQLServer中重建聚集索引之后会影响到非聚集索引的索引碎片吗&quot; href=&quot;http://www.cnblogs.com/wy123/p/7650215.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/wy123/p/7650215.html&lt;/a&gt; &lt;br/&gt;（保留出处并非什么原创作品权利，本人拙作还远远达不到，仅仅是为了链接到原文，因为后续对可能存在的一些错误进行修正或补充，无他）&lt;/p&gt;


&lt;p&gt;上午（20171011）看到qq群里发了一个云栖大会的链接，点进去看了一下sqlserver的专场，刚好是提问环节&lt;br/&gt;有人问了一个问题，原话记不清楚了，&lt;br/&gt;大概的意思（他自己认为）就是说：“SQLServer中重建聚集索引之后会影响非聚集索引的碎片情况，也要顺带重建非聚集索引”&lt;br/&gt;我想大概是他自己认为“重建聚集索引之后会影响到非聚集索引的索引碎片”&lt;br/&gt;提问者跟专家交流这个观点，提问之后还撤了几句堆表RID，聚集表key值啥的。&lt;br/&gt;专家一开始说这两者没有关系，后面被提问之后可能是有点紧张，说没注意过这个问题。&lt;/p&gt;

&lt;p&gt;首先抛出结论，对于聚集索引表，重建聚集索引之后不会影响到非聚集索引的索引碎片，重建聚集索引跟非聚集索引碎片之间的关系，完全不搭嘎的。&lt;br/&gt;这些问题，其实尝试自己测试一下不就清楚了么？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;聚集索引重建之后，对非聚集索引是否有影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，暂且先不扯聚集表堆表啥的了，直接说聚集表，&lt;br/&gt;非聚集索引在叶级直接存储的是聚集索引的key值，在重建聚集索引（或者重组）前后，非聚集索引存储的对应的key值是不变的&lt;br/&gt;重建聚集索引之后，数据的屋里存储位置可能会发生变化，这是会影响到聚集索引的物理存储和碎片情况&lt;br/&gt;但是对于非聚集索引来说，非聚集索引存储的对应的聚集索引的key值是不变的，&lt;br/&gt;那非聚集索引的碎片跟聚集索引的重建与否有个毛的关系。&lt;br/&gt;正如我手机里记录了某个人的电话号码，我只要拨通这个电话就能找到他，我管他是去北京上班还是去南京出差了，跟他在人具体哪里（重建聚集索引，物理位置变化）有毛关系。&lt;/p&gt;
&lt;p&gt;这些问题如果不确定的话，测试一下就出来结果了啊，我觉得没有任何疑问的。&lt;/p&gt;

&lt;p&gt;测试，测试表TestFragment中，Id1字段类型为uniqueidentifier，建立聚集索引，&lt;br/&gt;利用uniqueidentifier的随机性，大批量写入数据之后其碎片变得很大&lt;br/&gt;相反，Id2字段类型INT，以递增的值写入数据，大批量写入数据之后其索引碎片会很小&lt;br/&gt;然后重现Id1上的索引，观察Id2上的索引碎片会不会因为Id1上的索引重建而发生变化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; TestFragment
(
    Id1 &lt;/span&gt;&lt;span&gt;uniqueidentifier&lt;/span&gt;&lt;span&gt;,
    Id2 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,
    OtherCol2 &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;)
)
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;


&lt;span&gt;create&lt;/span&gt; &lt;span&gt;unique&lt;/span&gt; &lt;span&gt;clustered&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; IDX_Id1 &lt;span&gt;on&lt;/span&gt;&lt;span&gt; TestFragment(Id1);
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;

&lt;span&gt;create&lt;/span&gt; &lt;span&gt;unique&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; IDX_Id2 &lt;span&gt;on&lt;/span&gt;&lt;span&gt; TestFragment(Id2);
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;

&lt;span&gt;begin&lt;/span&gt; &lt;span&gt;tran&lt;/span&gt;
    &lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@i&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;@i&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;1000000&lt;/span&gt;
    &lt;span&gt;begin&lt;/span&gt;
        &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; TestFragment &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;NEWID&lt;/span&gt;(),&lt;span&gt;@i&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;NEWID&lt;/span&gt;&lt;span&gt;());
        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@i&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@i&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;commit&lt;/span&gt;
&lt;span&gt;go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写入100W数据之后观察两个索引上的碎片，&lt;/p&gt;
&lt;p&gt;对于聚集索引（Id1上的索引IDX_Id1）：&lt;br/&gt;很明显，聚集索引（因为是uniqueidentifier类型的字段），&lt;br/&gt;其avg_fragmentation_in_percent很高（99.2557236469541），同时avg_page_space_used_in_percent较低（68.9408574252533）&lt;br/&gt;对于非聚集索引（Id1上的索引IDX_Id2）：&lt;br/&gt;Id2索引因为是递增的，其avg_fragmentation_in_percent很低（0.528606965174129），也就是说碎片程度很低&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/380271/201710/380271-20171011134653730-1712078092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里姑且不管聚集索引与非聚集索引的碎片程度，这里重点关注“重建聚集索引之后是否会对非聚集索引碎片情况产生影响”&lt;/p&gt;
&lt;p&gt;这里重建聚集索引之后，重新观察索引碎片情况，看截图sys.dm_db_index_physical_stats的查询结果&lt;br/&gt;可以很清楚地发现，重建聚集索引之后，聚集索引本身的碎片发生了很大的变化，碎片基本完全消除（avg_fragmentation_in_percent0.0116986429574169），&lt;br/&gt;但是非聚集索引的碎片情况并没有发生任何一点变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/380271/201710/380271-20171011135228574-2078153432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;从理论上也不难理解：&lt;br/&gt;聚集索引和非聚集索引是两个完全独立的物理存储结构（当然也可以说是逻辑存储结构）&lt;br/&gt;其唯一的联系就是非聚集索引B树叶子节点会存储聚集索引的Key值&lt;br/&gt;其存储的聚集索引的key值不是其物理位置，聚集索引或者说数据本身的位置变化并不会因为key值的变化&lt;br/&gt;因此说重建还是重组聚集索引不会影响到非聚集索引的碎片情况&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;堆表的碎片消除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于堆表的索引碎片消除，也是可以通过alter table xxx rebuild重建的，&lt;br/&gt;当然也有一种很挫的做法就不想提了（fix heap fragmentation by creating and dropping a clustered index.）&lt;br/&gt;记住这是一种很挫的做法，可能是SQL Server 2008之前的版本中，alter table xxx rebuild语法被支持之前的无奈之举，&lt;br/&gt;这里暂不表述这种做法。&lt;br/&gt;对于堆表，alter table xxx rebuild可以通过重建表来消除碎片，但其功能不限于次，还会重建堆表上的非聚集索引&lt;/p&gt;
&lt;p&gt;测试示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; TestHeapFragment
(
    Id1 &lt;/span&gt;&lt;span&gt;uniqueidentifier&lt;/span&gt;&lt;span&gt;,
    Id2 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,
    OtherCol2 &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;)
)
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;

&lt;span&gt;create&lt;/span&gt; &lt;span&gt;unique&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; IDX_Id1 &lt;span&gt;on&lt;/span&gt;&lt;span&gt; TestHeapFragment(Id1);
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;

&lt;span&gt;create&lt;/span&gt; &lt;span&gt;unique&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; IDX_Id3 &lt;span&gt;on&lt;/span&gt;&lt;span&gt; TestHeapFragment(OtherCol2);
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;

&lt;span&gt;begin&lt;/span&gt; &lt;span&gt;tran&lt;/span&gt;
    &lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@i&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;@i&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;1000000&lt;/span&gt;
    &lt;span&gt;begin&lt;/span&gt;
        &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; TestHeapFragment &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;NEWID&lt;/span&gt;(),&lt;span&gt;@i&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;NEWID&lt;/span&gt;&lt;span&gt;());
        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@i&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@i&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;commit&lt;/span&gt;
&lt;span&gt;go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过alter table xxx rebuild对堆表重建，发现非聚集索引也会因为堆表的重建而发生索引重建。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/380271/201710/380271-20171011150558793-335383606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;If you think you can use &lt;em&gt;ALTER TABLE … REBUILD&lt;/em&gt; to fix heap fragmentation, you can, but it causes all the nonclustered indexes to be rebuilt as the heap record locations obviously change.&lt;/p&gt;
&lt;p&gt;暂时不清楚alter table xxx rebuild的具体实现过程，但是从各种表现来看，他在重建表的过程中确实也重建了非聚集索引。&lt;br/&gt;但是“重建表的过程中确实也重建了非聚集索引”可以认为是“使得非聚集索引变得更加好，而不是变坏”，&lt;br/&gt;这里要说明的是alter table xxx rebuild重建堆表不会对对表上的非聚集索引产生副作用&lt;/p&gt;
&lt;p&gt;强调一点，&lt;br/&gt;对于非聚集表，alter table xxx rebuild会重建所有的非聚集索引&lt;br/&gt;对于聚集表，alter table xxx rebuild只会重建聚集索引，但是不会重建非聚集索引&lt;/p&gt;


&lt;p&gt;说实话，提问者所说的“重建聚集索引之后会影响到非聚集索引碎片”这个观点我也是第一次听说，&lt;br/&gt;如果真的了解索引的话，应该知道这两者（重建聚集索引与非聚集索引碎片）之间没有必然的关系，&lt;br/&gt;对于莫名其妙的结论，到底是道听途说还是真有其事，为什么不自己动手试一试？&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.red-gate.com/simple-talk/sql/database-administration/sql-server-heaps-and-their-fragmentation/&quot; target=&quot;_blank&quot;&gt;https://www.red-gate.com/simple-talk/sql/database-administration/sql-server-heaps-and-their-fragmentation/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.sqlskills.com/blogs/paul/a-sql-server-dba-myth-a-day-2930-fixing-heap-fragmentation/&quot; target=&quot;_blank&quot;&gt;https://www.sqlskills.com/blogs/paul/a-sql-server-dba-myth-a-day-2930-fixing-heap-fragmentation/&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 11 Oct 2017 07:15:00 +0000</pubDate>
<dc:creator>MSSQL123</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wy123/p/7650215.html</dc:identifier>
</item>
<item>
<title>一个高性能、轻量级的分布式内存队列系统--beanstalk - 静儿1986</title>
<link>http://www.cnblogs.com/xiexj/p/7644999.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/7644999.html</guid>
<description>&lt;p&gt;　　Beanstalk是一个高性能、轻量级的、分布式的、内存型的消息队列系统。最初设计的目的是想通过后台异步执行耗时的任务来降低高容量Web应用系统的页面访问延迟。其实Beanstalkd是典型的类Memcached设计，协议和使用方式都是同样的风格。其基本设计思想很简单：高性能离不开异步，异步离不开队列，而内部都是生产者-消费者模式的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;背景介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　现在市面上有很多消息队列系统了。常用的有ActiveMQ, RabbitMQ,ZeroMA,Kafka,RocketMQ。Redis之父最近又开源了一个Disque。我之前在乐视用的是apache的qpid。但是之所以各个系统都在流行，还要看其侧重点。&lt;/p&gt;
&lt;p&gt;　　其中ActiveMQ可以称之为传统型，它们完全支持JMS和AMQP规范。&lt;/p&gt;

&lt;p&gt;　　JMS即Java消息服务(Java Message Service)应用程序接口。它是Java平台上有关面向消息中间件（Message Oriented Middleware,缩写为MOM）的技术规范，它便于消息系统中的Java应用程序进行消息交换，并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。&lt;span&gt;(*我这里说了，JMS是应用程序接口，就是API，API就意味着是和编程语言绑定的)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　JMS的体系架构由JMS提供者、JMS客户、JMS生产者、JMS消费者、JMS消息、JMS队列、JMS主题组成。&lt;/p&gt;
&lt;p&gt;　　JMS对象模型包含：连接工厂、JMS连接、JMS会话、JMS目的、JMS生产者和消费者和JMS消息。其中大家最关心的是JMS消息的两种模型：点对点(point to point, queue)和发布/订阅(publish/subscribe, topic)。这两者之间的区别就是点对点模式是生产者发送一条消息到queue，一个queue可以有很多消费者，但是一个消息只能被一个消费者接收，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者，所以queue实现了一个可靠的负载均衡。而发布订阅模式是发布者发送到topic的消息，只有订阅了topic的订阅者才会收到消息。topic实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到这个消息的拷贝。&lt;/p&gt;

&lt;p&gt;　　AMQP(高级消息队列协议)，和JMS的区别在于：JMS只是java平台的方案，AMQP是一个跨语言的协议。由于跨语言的特点，降低了企业和系统集成的开销。所以现在的消息队列系统支持AMQP的多，支持JMS的少。&lt;/p&gt;
&lt;p&gt;　　AMQP的特征是面向消息，队列化，消息模型（和JMS一样：点对点和发布订阅），可靠性和安全性。它提供了三种消息传递保证方式：最多一次，至少一次和精确一次。　　&lt;/p&gt;
&lt;p&gt;　　我们经常在使用消息队列的时候提到的broker是对实现了AMQP协议的服务端的称呼。其基本结构如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1112728/201710/1112728-20171010222041684-1344555528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Beanstalk介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　那下面开始说beanstalk了。首先说beanstalk其实并不是JMS规范的，也并不严格遵守AMQP协议。有人说Beanstalk之于RabbitMQ，就好比Nginx之于Apache。它更简单，轻量级，高性能，易使用。但是相比kafka，数据处理能力还是有差距，所以我们现在其实在逐渐替代它。但它有些很易用的特殊功能，后面会讲到。&lt;/p&gt;
&lt;p&gt;　　Beanstalk主要包括4个部分。&lt;/p&gt;
&lt;p&gt;　　1&amp;gt; job:一个需要异步处理的任务，需要放在一个tube中。&lt;/p&gt;
&lt;p&gt;　　2&amp;gt; tube:一个有名的任务队列，用来存储统一类型的job，是producer和consumer操作的对象。&lt;/p&gt;
&lt;p&gt;　　3&amp;gt; producer:job的生产者，通过put命令来将一个job放到一个tube中。&lt;/p&gt;
&lt;p&gt;　　4&amp;gt; consumer:job的消费者，通过reserve、release、bury、delete命令来获取job或改变job的状态。&lt;/p&gt;

&lt;p&gt;　　刚才说Beanstalk有一些特殊的好用功能。那就是它支持任务优先级(priority)、延时(delay)、超时重发(time-to-run)和预留(buried)，能够很好的支持分布式的后台任务和定时任务处理。这些特性是和beanstalk工作过程密切相关。&lt;/p&gt;
&lt;p&gt;　　Beanstalk的一个job的生命周期有READY、RESERVED、DELAYED、BURIED四种。&lt;/p&gt;
&lt;p&gt;　　当producer直接put一个job时，job就是READY状态，等待consumer来处理。如果选择延迟put，job就先到DELAYED状态，到指定时间再READY。consumer获取了READY的job，此状态就为RESERVED。这样其他consumer不能再操作此job。当consumer完成该job后，可以选择delete、release或者bury。&lt;/p&gt;
&lt;p&gt;　　delete之后，job不能再获取。release的job可以重新迁移或延迟迁移回READY。bury的job可以被休眠，需要的时候再READY或者delete掉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Beanstalk使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　用作延时队列：比如可以用于如果用户30分钟内不操作，任务关闭。&lt;/p&gt;
&lt;p&gt;　　用作循环队列：用release命令可以循环执行任务，比如可以做负载均衡任务分发。&lt;/p&gt;
&lt;p&gt;　　用作兜底机制：比如一个请求有失败的概率，可以用Beanstalk不断重试，设定超时时间，时间内尝试到成功为止。&lt;/p&gt;
&lt;p&gt;　　用作定时任务：比如可以用于专门的后台任务。&lt;/p&gt;
&lt;p&gt;　　用作异步操作：这是所有消息队列都最常用的，先将任务仍进去，顺序执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;跑题时间：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　平时其实不爱聊闲天。但是和我家男神一起，就会有如下场景：我们去青岛旅游，火车站上上电梯，我们各走一边，然后相遇了。“咱俩太有缘分了，又遇到你了。”“你去哪里啊，这么巧，我也去。”“你家住哪里啊，这么巧，我也是。”……额，顿时觉得我们是最有缘分和最无聊的人，却乐此不疲。&lt;/p&gt;
&lt;p&gt;　　还有更二的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1112728/201710/1112728-20171011133024277-1154778693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　除了胖到170斤那几年，新到一个公司，总会有很多搭讪的，大家都特别热情。直到我骄傲的介绍我家男神和小鲜肉。额~~，整个世界都清净了~~&lt;/p&gt;
</description>
<pubDate>Wed, 11 Oct 2017 05:30:00 +0000</pubDate>
<dc:creator>静儿1986</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/7644999.html</dc:identifier>
</item>
<item>
<title>ASP.NET没有魔法——ASP.NET MVC &amp; 分层 - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/7646445.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/7646445.html</guid>
<description>&lt;p&gt;　　上一篇文章简要说明了MVC所代表的含义并提供了详细的项目及其控制器、视图等内容的创建步骤,最终完成了一个简单ASP.NET MVC程序。&lt;br/&gt;　　注：MVC与ASP.NET MVC不相等，MVC是一种开发模式，而ASP.NET MVC是MVC这种模式的其中一种实现方式，本文中提到的MVC如果没有特指，那么均表示ASP.NET MVC。&lt;br/&gt;　　本文将从ASP.NET的M-V-C到底代表什么？如何编写对应的代码？来讨论如何使用ASP.NET MVC开发应用程序。&lt;br/&gt;　　○ ASP.NET MVC与分层&lt;br/&gt;　　○ ASP.NET MVC中的M代表什么&lt;br/&gt;　　○ ASP.NET MVC的V和C是如何交互的&lt;br/&gt;　　○ ASP.NET MVC中的C应该如何处理业务逻辑&lt;br/&gt;　　○ 如何使用ASP.NET MVC&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; ASP.NET MVC与分层&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　什么是分层？&lt;/p&gt;
&lt;p&gt;　　在了解分层之前，先了解一下层次的概念，层次是指系统在结构或功能方面的等级秩序。具有多样性，可按物质的质量、能量、运动状态、空间尺度、时间顺序、组织化程度等多种标准划分。不同层次具有不同的性质和特征，既有共同的规律，又各有特殊规律。（来自百度百科）&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;所以分层实际上是根据一定的标准和规律，将一个整体划分为多个层次，保证每一个层次中的内容都有共同的性质和特征，便于针对每一个层次进行维护管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　代码分层：&lt;/p&gt;
&lt;p&gt;　　代码分层就是将代码根据其功能特性将代码分而治之，代码分层一般分为三层（所以也被称为&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/11031448?fr=aladdin&quot; target=&quot;_blank&quot;&gt;三层架构&lt;/a&gt;），分别是UI层、业务逻辑层和数据层，分层架构主要是把整个系统的数据存储、业务逻辑、UI实现进行关注点分离：&lt;br/&gt;　　○数据层：关注数据是如何存储的不需要业务逻辑来处理，只需要调用相应接口就可以完成数据的获取、存储等功能。&lt;br/&gt;　　○业务层：把业务区分出来可以更好的专注于业务逻辑的实现，对于一些业务逻辑较为复杂的系统可以使用领域驱动(DDD)的方法去实现。另外业务逻辑可以被重用，一个常见的例子就是MVC以及Web API，MVC用于Web端应用开发，Web API还可以用于为其它客户端或者是提供第三方应用使用，所以业务逻辑的实现不能在UI层，否则就回出现MVC的Controller中存在一份代码，而Web API的Controller中也存在相同的一份代码，以致于代码难以维护。&lt;br/&gt;　　○UI层：需要做的就只有用户界面的设计，设计师只需要去关心如何将需要表达的内容完美的表达给用户并提高用户体验即可。　&lt;/p&gt;
&lt;p&gt;　　另外分层架构的“层”其实应该是根据业务特性、系统复杂度等因素来拆分的，分层可以让适合的人做适合的事情，并且设计模式中的“依赖倒置”原则定义模块直接要依赖抽象而不是实现，只要定义出抽象(接口)那么多个团队即可同时对不同的“层”进行开发。&lt;/p&gt;
&lt;p&gt;　　注：以上的分层架构特指服务端分层架构，像移动应用甚至一些单页应用也会特意的进行分层以享受分层带来的代码管理的便利。&lt;/p&gt;
&lt;p&gt;　　ASP.NET MVC是什么？&lt;/p&gt;
&lt;p&gt;　　在上一篇文章中介绍了ASP.NET MVC以及MVC分别代表的意义。从意义上看起来MVC的概念和三层架构的概念很相似，它们分别都对应了UI、业务逻辑和数据。但是它们有着很大的区别，&lt;span&gt;MVC的View、Controller、Model的作用是处理UI显示、操作和数据交换。换句话说ASP.NET MVC在三层架构中仅仅是UI层的一种实现。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;ASP.NET MVC中的M代表什么&lt;/span&gt;　　&lt;/h2&gt;
&lt;p&gt;　　M代表数据模型，但是应用程序中是存在多种数据模型的，比如与数据库一一对应的数据模型、用于显示的数据模型，ASP.NET MVC中很容易混用这两种模型，举个例子，用户信息除了用户特征还会包含用于登陆系统的密码等信息。对用户信息修改时除了修改特征还会修改密码等，但是在显示时就肯定不会把密码显示出来。还有一种情况就是一个列表页面，它不仅仅显示记录条目，还会显示分页信息，但是分页信息是不会存储到数据库中的，所以这两种模型是有明显区别的。　　&lt;/p&gt;
&lt;p&gt;　　ASP.NET MVC在分层架构中被定位为UI的实现，那么这里的M应该被看作用于显示的数据模型。一些人也把它称为View Model，但是这个View Model与MVVM模式下的View Model有本质的区别，这里的View Model是用于显示的数据模型。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;ASP.NET MVC的V和C是如何交互的&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　根据之前的分析MVC的Model是用来展示的数据，所以理所应当的Controller应该生成一个Model交付给View来渲染。相反的，在通过Web页面提交一些数据时，这些数据来自View，那么View也应该提供一个Model交给Controller来执行相应的业务，它们的关系如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171011125012855-868611931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;ASP.NET MVC中的C应该如何处理业务逻辑&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　Controller用于处理来自客户端的请求，然后给出响应。而这个处理的过程就对应了实际的业务逻辑，而MVC又处于业务逻辑层之上，所以Controller唯一能做的就是直接调用业务逻辑，这里的调用应该是顺序的，没有任何逻辑判断的，所有的处理均交付给逻辑层。&lt;br/&gt;　　如何处理Controller和业务层的数据交换？视图模型还是实体模型(数据库模型)?&lt;br/&gt;　　首先视图模型不可用，因为MVC在业务层之上，如果使用视图模型，那么下层依赖上层是违反依赖原则的。而且视图模型可能包含分页等信息，也不是业务层需要的。&lt;br/&gt;　　其次可以用实体模型来交换，这个方案看上去可以，MVC以及业务都依赖一份实体模型。但是如果使用领域驱动来设计模型的时候怎么办？这时的“实体”包含了部分业务逻辑，而这部分的逻辑一般是不可以被UI层直接调用的。&lt;br/&gt;　　根据以上的分析发现两种都存在不符合的应用场景，所以引入了DTO（Data Transfer Object）数据传输对象这个概念，关于这个概念后续在分析，现在的博客系统先使用实体模型来处理数据交换。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;如何使用ASP.NET MVC&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　任何一个工具，不同的人可能会有不同的效果，对于软件开发来说除了完成功能性需求的开发，更重要的还有保证开发效率、软件质量、代码质量等非功能需求，以保证软件能够在适合的时间开发完成，代码可测试、可维护。但是不同的开发者使用工具习惯不一致，对于ASP.NET MVC来说，有的人可能习惯把Model当数据库模型和页面模型使用、把所有业务逻辑编写到Controller中、过多使用ViewBag等对象传输数据到View等。对于这些方法来说它仍然能够实现功能性需求，而且对于个人来说使用习惯的方法效率最高，但是对于一个团队来说这往往会造成很大的麻烦，每个人保持自己的风格，最后整个项目代码被改的面目全非，代码没有可读性、无法维护、无法测试等等。&lt;br/&gt;　　所以在使用工具前必须统一规范。没有规矩不成方圆。ASP.NET MVC 在某些角度上对于MVC来说也是一种规范。&lt;br/&gt;　　规范有好有坏，但无论好坏，只要存在规范，那么在修改规范时也会更容易，本系列文章会根据“博客系统”的进度来设定不同的规范，对于ASP.NET MVC的使用来说，应该有以下几点：&lt;br/&gt;　　○ Controller只能顺序调用业务逻辑，不存在任何判断语句。&lt;br/&gt;　　○ View在一般情况下只是用Controller传过来的Model对象，避免ViewBag等对象的使用。&lt;br/&gt;　　○ Model只作为View和Controller之前的传输对象使用，与数据实体无关。&lt;/p&gt;
&lt;p&gt;　　小结：&lt;br/&gt;　　本章进一步的分析了MVC的概念，并在最后提出了规范，对于规范来说更多的指编码规范，比如命名规范、注释规范等等，这里的规范仅仅是对统一对ASP.NET MVC的使用方法，使得代码便于维护、测试，甚至后续使用代码生成器来生成代码也更加容易(关于代码规范等内容会在后续引入更多介绍)。&lt;/p&gt;

&lt;p&gt;本文连接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: ASP.NET没有魔法——ASP.NET MVC &amp;amp;amp; 分层&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7646445.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/selimsong/p/7646445.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_7641799&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7641799.html&quot;&gt;ASP.NET没有魔法——目录&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Oct 2017 05:05:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/7646445.html</dc:identifier>
</item>
<item>
<title>前端性能优化：客户端从输入到展示讲解 - 仲强</title>
<link>http://www.cnblogs.com/GerryOfZhong/p/7649653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GerryOfZhong/p/7649653.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;性能优化的根本目的：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　要思考的是用户使用网站的体验如何，而不是我们可以节省多少字节，只有准确感知用户的感受，我们才有必要谈毫秒、字节和请求数量等问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;针对优化注意事项：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;防止过早优化：没必要在刚开始阶段就对一个细节进行放大型的优化，因为这样的成本很高，除了代码可读性方面的东西，甚至还可能会引入更多的bug，所以，针对这个问题，我们可以在上线和运营的时候进行监控，当快暴露到问题的时候，进行整体优化。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;本末倒置的关注：网站内容是最重要的，应该查看页面的每个部分，看是否满足网站页面的主要目的，暂时不需要将额外的注意力全部放到一些不关乎本质的东西上。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;对于性能的分析：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用浏览器的性能分析工具，得到性能分析图表，最著名的就是反向火焰图表，针对浏览器的加载和渲染一目了然。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;投入使用之前缺乏压力测试和性能测试&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;性能优化（从用户输入网址到客户端展现，一步一步优化）&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;　　1.  &lt;/span&gt; &lt;span&gt;输入网址 　　　　　　 　　 ==&amp;gt; 告诉浏览器你要去哪里&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　2.&lt;/span&gt;   &lt;span&gt;浏览器查找DNS 　　　 　　 ==&amp;gt; 网络世界是IP地址的世界，DNS就是ip地址的别名。从本地DNS到最顶级DNS一步一步的网上爬，直到命中需要访问的IP地址&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　a.   DNS预解析 使用CDN缓存，加快解析CDN寻找到目标地址（dns-prefetch）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　3. 客户端和服务器建立连接　　 ==&amp;gt;建立TCP的安全通道，3次握手&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　a.  CDN加速 使用内容分发网络，让用户更快的获取到所要内容&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　b.  启用压缩 在http协议中，使用类似Gzip压缩的方案（对服务器资源不足的时候进行权衡）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　c.  使用HTTP/2协议 http2.0针对1.0优化了很多东西，包括异步连接复用，头压缩等等，使传输更快&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　4.  浏览器发送http请求　　　　  ==&amp;gt; 默认长连接（复用一个tcp通道，短连接：每次连接完就销毁）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　a.  减少http请求 每个请求从创建到销毁都会消耗很多资源和时间，减少请求就可以相对来说更快展示内容&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　1).  压缩合并js文件以及css文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　2).  针对图片，可将图片进行合并然后下载，通过css Sprites切割展示（控制大小，太大的话反而适得其反）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　b.  使用http缓存 缓存原则：越多越好，越久越好。让客户端发送更少请求，直接从本地获取，加快性能。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　c.  减少cookie请求 针对非必要数据（静态资源）请求，进行跨域隔离，减少传输内容大小。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　d.  预加载请求 针对一些业务中场景可预加载的内容，提前加载，在之后的用户操作中更少的请求，更快的响应&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　e.  选择get和post 在http定义的时候，get本质上就是获取数据，post是发送数据的。get可以在一个TCP报文完成请求，但是post先发header，再发送数据。so，考虑好请求选型。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　f.   缓存方案选型 递进式缓存更新（防止一次性丢失大量缓存，导致负载骤多）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　5.&lt;/span&gt;  &lt;span&gt;服务器响应请求 　　　　　　 ==&amp;gt; tomcat、IIS等服务器通过本地映射文件关系找到地址或者通过数据库查找到数据，处理完成返回给浏览器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　a.  后端框架选型 　　 \&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　　　 ==&amp;gt; 更快的响应，前端更快的操作。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　b.  数据库选型和优化 /&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　6.&lt;/span&gt;  &lt;span&gt;浏览器接受响应 ==&amp;gt; 浏览器根据报文头里面的数据进行不同的响应处理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　a.  解耦第三方依赖 越多的第三方的不确定因素，会导致web的不稳定性和不确定性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　b.  避免404资源 请求资源不到浪费了从请求到接受的所有资源&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　7.&lt;/span&gt;  &lt;span&gt;浏览器渲染顺序 ==&amp;gt; a.HTML解析开始构建dom树&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　b. 外部脚本和样式表加载完毕&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　a).  尽快加载css，首先将CSSOM对象渲染出来，然后进行页面渲染，否则导致页面闪屏，用户体验差&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　b).  css选择器是从右往左解析的，so类似#test a {color: #444},css解析器会查找所有a标签的祖先节点，所以效率不是那么高&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　c).  在css的媒介查询中，最好不要直接和任何css规则直接相关。最好写到link标签中，告诉浏览器，只有在这个媒介下，加载指定这个css&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　c. 脚本在文档内解析并执行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　a）.  按需加载脚本，例如现在的webpack就可以打包和按需加载js脚本&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　b）.  将脚本标记为异步，不阻塞页面渲染，获得最佳启动，保证无关主要的脚本不会阻塞页&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　c). 慎重选型框架和类库，避免只是用类库和框架的一个功能或者函数，而引用整个文件。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　d. HTML DOM完全构造起来&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　a).  DOM 的多个读操作（或多个写操作），应该放在一起。原则：统一读、统一写。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　e. 图片和外部内容加载&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　a).  对多媒体内容进行适当优化，包括恰当使用文件格式，文件处理、渐进式渲染等&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　b).  避免空的src，空的src仍然会发送请求到服务器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　c).  避免在html内容中缩放图片，如果你需要使用小图，则直接使用小图&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　f. 网页完成加载&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　a).  服务端渲染，特别针对首屏加载很重要的网站，可以考虑这个方案。后端渲染结束，前端接管展示。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　　a） 针对首屏展示优化&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　1).  图片懒加载 针对展示只加载第一屏，等用户进行滚动的时候再进行加载。如果用户对下面内容不感兴趣，那么节省的请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　b） javascript优化&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　1).  减少对dom节点的查询，因为每次都会重新去索引这个集合或者元素。或者查询一次缓存起来，以待接下来使用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　2).  进行js操作DOM的时候，考虑清楚页面的重绘和重排，因为这些操作相对来说十分损耗性能的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　3).  避免使用eval和Function构造，因为解析器会将这些内容先转换成可执行代码，然后再进行接下去的操作。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　4).  减少作用域链的查找，如果一个闭包函数使用到全局作用域的数据，那么每次局部作用域都会一层一层爬到最高作用域取得数据。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　5).  数据访问，对非引用类型数据访问和局部变量的访问是最快的。所以如果对引用类型的成员（对象的属性或者数组的成员）访问超过一次，则缓存&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　6).  将前端可能会使用的一些算法函数写的更优化，在时间和空间复杂度上寻找到一个最优方案。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　7).  去除重复加载同一模块脚本&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　8).  智能事件处理，比如在一个div下有10个按钮，可以在冒泡过程中捕获这个事件源，然后注册&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　c）  css优化&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　1).  删除无用规则&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　2).  内联关键CSS&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　3).  避免@imports和Base64&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　4).  启用高性价比属性(如opacity over rgba())&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　5).  避免重复性工作&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　6).  不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　7).  可将元素设为display: none（需要1次重排和重绘），然后N次操作，最后恢复显示&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　8).  position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　d）  图片优化（网络请求中80%都是静态资源的请求）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　1).  图片正确格式的选择&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　2).  图片尺寸的选择，在低分辨率等状况下考虑降级处理（考虑响应式图片）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　3).  使用正确的工具进行优化（有损压缩、无损压缩）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　4).  能用css处理和代理的，优先考虑css实现（阴影，滤镜等）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　5).  正确使用data url，比如说多地使用的地方，不建议data url，可考虑缓存&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　6).  考虑图片的懒加载和元素可见加载方案&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　7).  图片的预加载，在正确的合理的设计节点进行图片的预加载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;所有性能优化总结为三个层面优化：&lt;strong&gt;&lt;span&gt;物理层面的优化，设计层面的优化，代码层面的优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：设计层优化最主要的核心：衡量如何花费最少代价实现页面功能&lt;/span&gt;&lt;br/&gt;&lt;span&gt;注：HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），是HTTP协议的的第二个主要版本，HTTP/2的目标包括异步连接复用，头压缩和请求反馈管线化并保留与HTTP 1.1的完全语义兼容。Google Chrome、Mozilla Firefox、Microsoft Edge和Opera已支持HTTP/2，并默认启用。Internet Explorer自IE 11开始支持HTTP/2，但仅限于Windows 10 Beta，并默认情况激活。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;github地址：&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/GerryIsWarrior/optimization&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;github.com/GerryIsWarri&lt;span class=&quot;invisible&quot;&gt;or/optimization&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;　　　&lt;/span&gt;&lt;span&gt;鄙人厚颜无耻要颗星，这样才有动力持续更新&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em&gt;&lt;span&gt;问题补充路径：&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　1. 博客留言&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　2. gerry.zhong@outlook.com&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　3.github留言&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Oct 2017 04:52:00 +0000</pubDate>
<dc:creator>仲强</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GerryOfZhong/p/7649653.html</dc:identifier>
</item>
<item>
<title>“一切都是消息”--MSF（消息服务框架）之【发布-订阅】模式 - 深蓝医生</title>
<link>http://www.cnblogs.com/bluedoctor/p/7649169.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bluedoctor/p/7649169.html</guid>
<description>&lt;p&gt;在上一篇，&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/bluedoctor/p/7632887.html&quot;&gt;“一切都是消息”--MSF（消息服务框架）之【请求-响应】模式&lt;/a&gt; ，我们演示了MSF实现简单的请求-响应模式的示例，今天来看看如何实现【发布-订阅】模式。简单来说，该模式的工作过程是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端发起订阅“服务器时间”服务--》服务器接受订阅--》服务器处理被订阅的服务方法--》 服务器将处理结果推送给客户端--》客户端收到消息--》客户端关闭订阅连接&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;MSF的【发布-订阅】通信模式，支持2种模式，分别是：&lt;/p&gt;

&lt;p&gt;这是最普通最常见的推送模式，只要客户端订阅了MSF的服务，服务器会每隔一秒向客户端推送一次服务处理结果。在下面的示例中，我们先来演示一个简单的“服务器时间服务”的功能。&lt;/p&gt;
&lt;h2&gt;1.1，在TestService项目添加一个类文件 TimeService.cs ，其代码如下：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TestService
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TimeService:ServiceBase
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DateTime ServerTime()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DateTime.Now;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：今天我们这个MSF服务类TimeService 集成的不是前一篇说的IService接口，而是 ServiceBase 抽象类，实际上它也是实现了IService接口的类，这样可以让我们的服务类代码更简单。&lt;/p&gt;
&lt;p&gt;别忘了，在IOC配置文件 IOCConfig.xml 注册我们新添加的服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IOC &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;TestService&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Add &lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;=&quot;TestTimeService&quot;&lt;/span&gt;&lt;span&gt; InterfaceName&lt;/span&gt;&lt;span&gt;=&quot;IService&quot;&lt;/span&gt;&lt;span&gt; FullClassName&lt;/span&gt;&lt;span&gt;=&quot;TestService.TimeService&quot;&lt;/span&gt;&lt;span&gt; Assembly&lt;/span&gt;&lt;span&gt;=&quot;TestService&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 其它略 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;IOC&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该配置需要注意3点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;虽然TimeService 继承的是ServiceBase 对象，但在这里配置 InterfaceName的时候，仍然使用 IService&lt;/li&gt;
&lt;li&gt;Key=&quot;TestTimeService&quot; 而不是 Key=&quot;TimeService&quot; ，实际上这里配置的Key 可以是任意名字，只要跟配置文件中其它Key的值不重复即可&lt;/li&gt;
&lt;li&gt;调用服务的时候，ServiceRequest 对象的 ServiceName 属性指定的服务名称，是这里配置的Key的值，而不是MSF服务类的类名&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;1.2，在TestClient 项目添加订阅服务的代码：&lt;/h2&gt;
&lt;p&gt;在订阅前，我们可以直接请求下上面的【服务器时间】服务，测试下服务是否可行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
DateTime serverTime = client.RequestServiceAsync&amp;lt;DateTime&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service://TestTimeService/ServerTime/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
                PWMIS.EnterpriseFramework.Common.DataType.DateTime).Result;
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MSF Get Server Time:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, serverTime);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 测试成功，下面继续编写订阅模式的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
            ServiceRequest request3 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceRequest();
            request3.ServiceName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestTimeService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            request3.MethodName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ServerTime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            client.Subscribe&lt;/span&gt;&amp;lt;DateTime&amp;gt;&lt;span&gt;(request3, 
                PWMIS.EnterpriseFramework.Common.DataType.DateTime, 
                s &lt;/span&gt;=&amp;gt;&lt;span&gt; 
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (s.Succeed)
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MSF Server Time:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, s.Result);
                      
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MSF Server Error:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, s.ErrorMessage);
                    }
                    count&lt;/span&gt;++&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
                    {
                        client.Close();
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;订阅【服务器时钟服务】结束。按回车键继续。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与请求模式不同，客户端要使用订阅模式，只需要将服务代理类的 RequestService 方法替换成 Subscribe 方法，该方法的第一个泛型参数类型表示订阅的结果的类型。&lt;/p&gt;
&lt;p&gt;由于是订阅模式， Subscribe 不提供Async的同名方法，因为服务器会多次向客户端推送订阅的结果，何时订阅结束，可以由客户端来决定，在客户端提供的服务端回调方法内来关闭订阅的连接即可。所以Subscribe 方法的下一行代码会立即执行，无法实现RequestServiceAsync 这种“同步”效果。&lt;/p&gt;
&lt;p&gt;在当前示例中，服务端会向客户端推送10次服务器时间，然后客户端会关闭订阅连接。假如客户端不关闭订阅连接，服务器会一直向客户端推送订阅结果，每秒推送一次。&lt;/p&gt;
&lt;p&gt;下面是这个示例的运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
MSF Server Time:2017-10-11 10:33:48
MSF Server Time:2017-10-11 10:33:49
MSF Server Time:2017-10-11 10:33:50
MSF Server Time:2017-10-11 10:33:51
MSF Server Time:2017-10-11 10:33:52
MSF Server Time:2017-10-11 10:33:53
MSF Server Time:2017-10-11 10:33:54
MSF Server Time:2017-10-11 10:33:55
MSF Server Time:2017-10-11 10:33:56
MSF Server Time:2017-10-11 10:33:58
MSF Server Time:2017-10-11 10:33:59
订阅【服务器时钟服务】结束。按回车键继续。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有时候我们并不需要固定间隔时间（例如每秒）调用服务方法然后将处理结果推送给客户端，而是在某个特定的时间才向客户端推送订阅的服务结果，这个需求可以在服务端实现一个定时器，在时间到了后才推送，或者，进行某项业务处理过程，满足某项业务条件后，触发一个业务事件，在这个业务事件中，将订阅的结果推送给客户端。&lt;/p&gt;
&lt;p&gt;定时器处理的是它触发的事件，业务处理过程也可以触发某种业务操作事件，所以这种推送模式，就是“&lt;strong&gt;事件推送模式&lt;/strong&gt;”，跟前面的“&lt;strong&gt;定时推送模式&lt;/strong&gt;”是完全不同的模式，在事件推送模式中，看起来是将服务端的事件，推送到客户端订阅的方法里面去了，事件的实际处理，到了客户端，因此，事件推送模式，也是一种“&lt;strong&gt;分布式事件&lt;/strong&gt;”处理模式。&lt;/p&gt;
&lt;p&gt;下面我们来实现一个“闹铃服务”，客户端订阅此闹铃服务，指定响铃的时间和响铃的次数，服务端的闹铃到了指定时间，就会向客户端推送“闹铃服务”：“闹铃响了”，一直推送到客户端指定的次数为止。&lt;/p&gt;
&lt;h2&gt;2.1,在TestService项目添加闹钟服务类文件 AlarmClockService.cs，其代码如下：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AlarmClockService:ServiceBase
    {
        System.Timers.Timer timer;
        DateTime AlarmTime;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; AlarmCount;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; MaxAlarmCount;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; EventHandler Alarming;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AlarmClockService()
        {
            timer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Timers.Timer();
            timer.Interval &lt;/span&gt;= &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;;
            timer.Elapsed &lt;/span&gt;+=&lt;span&gt; timer_Elapsed;
        }

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; timer_Elapsed(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, System.Timers.ElapsedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.SignalTime &amp;gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.AlarmTime)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Alarming != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    Alarming(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventArgs());

                &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;.CurrentContext.PublishData(DateTime.Now); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;e.SignalTime&lt;/span&gt;
                AlarmCount++&lt;span&gt;;
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AlarmClockService Publish Count:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, AlarmCount);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alarm Time:{0},AlarmClock waiting...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.AlarmTime);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (AlarmCount &amp;gt;&lt;span&gt; MaxAlarmCount)
            {
                timer.Stop();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;推送一个结束标记值：1900-1-1&lt;/span&gt;
                &lt;span&gt;base&lt;/span&gt;.CurrentContext.PublishData(&lt;span&gt;new&lt;/span&gt; DateTime(&lt;span&gt;1900&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[{0}] AlarmClockService Timer Stoped. &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; DateTime(&lt;span&gt;1900&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.CurrentContext.PublishEventSource.DeActive();
            }
        }


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServiceEventSource SetAlarmTime(AlarmClockParameter para)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.MaxAlarmCount =&lt;span&gt; para.AlarmCount;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.AlarmTime =&lt;span&gt; para.AlarmTime;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServiceEventSource(timer, &lt;span&gt;2&lt;/span&gt;, () =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要初始化执行的代码或者方法&lt;/span&gt;
                AlarmCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                timer.Start();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果上面的代码是一个执行时间比较长的方法，但又不知道何时执行完成，
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;并且不想等待超时回收服务对象，而是在执行完成后立即回收服务对象，可以调用下面的代码：
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CurrentContext.PublishEventSource.DeActive();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意：调用DeActive 方法后将会停止事件推送，所以请注意此方法调用的时机。

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面代码仅做测试，查看服务事件源对象的活动生命周期
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在 ActiveLife 时间之后，一直没有事件推送，则事件源对象被视为非活动状态，发布工作线程会被回收。
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在本例中，ActiveLife 为ServiceEventSource 构造函数的第二个参数，值为 2分钟，可以通过下面一行代码证实：&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; life = &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.CurrentContext.PublishEventSource.ActiveLife;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果上面执行的是一个执行时间比较长的方法，并且有返回值，想将返回值也推送给订阅端，可以再次执行CurrentContext.PublishData
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CurrentContext.PublishData(DateTime.Now);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果事件推送结束，需要设置事件源为非活动状态，否则，需要等待 ActiveLife 时间之后自然过期成为非活动状态。
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果你无法确定事件推送何时结束，请不要调用下面的方法
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CurrentContext.PublishEventSource.DeActive();&lt;/span&gt;
&lt;span&gt;            });
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;跟上面一样，不要忘记了在IOCConfig.xml文件注册此闹钟服务。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;闹钟服务的类中有一个定时器对象，当订阅闹钟服务的 SetAlarmTime 方法的时候，会给闹钟服务传入必要的参数以便闹钟工作，参数类AlarmClockParameter 定义在 TestDto项目中，其代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TestDto
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AlarmClockParameter
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 响铃时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DateTime AlarmTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 响铃次数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AlarmCount { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.2，编写闹铃服务订阅客户端&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
            AlarmClockParameter acp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AlarmClockParameter();
            acp.AlarmCount &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
            acp.AlarmTime &lt;/span&gt;=&lt;span&gt; alarmTime;

            ServiceRequest request4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceRequest();
            request4.ServiceName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AlarmClockService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            request4.MethodName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SetAlarmTime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            request4.Parameters &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] { acp };

            client.Subscribe&lt;/span&gt;&amp;lt;DateTime&amp;gt;&lt;span&gt;(request4,
                  PWMIS.EnterpriseFramework.Common.DataType.DateTime, 
                  s &lt;/span&gt;=&amp;gt;&lt;span&gt;
                  {
                      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (s.Succeed)
                      {
                          Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;闹钟响了，现在时间:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, s.Result);
                          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s.Result == &lt;span&gt;new&lt;/span&gt; DateTime(&lt;span&gt;1900&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
                          {
                              client.Close();
                              Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;闹铃服务结束，按回车键继续。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                          }
                      }
                      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                      {
                          Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MSF Server Error:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, s.ErrorMessage);
                          client.Close();
                      }
              });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个订阅客户端，像前面订阅服务器时间一样，没有区别，这里不多解释。&lt;/p&gt;
&lt;h2&gt;2.3，注册MSF服务方法的参数类&lt;/h2&gt;
&lt;p&gt;运行此服务端和客户端，发现客户端输出了下面的异常信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
---处理服务时错误：系统不能处理当前类型的参数：TestDto.AlarmClockParameter
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个消息是前面服务代理类的错误处理事件输出的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  Proxy client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Proxy();
   client.ErrorMessage &lt;/span&gt;+=&lt;span&gt; client_ErrorMessage;

   &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; client_ErrorMessage(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, MessageSubscriber.MessageEventArgs e)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---处理服务时错误：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,e.MessageText);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们去看MSF Host控制台输出的相信错误信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[2017-10-11 09:12:23.736]订阅消息-- From: 127.0.0.1:57822
[2017-10-11 09:12:23.752]正在处理服务请求--From: 127.0.0.1:57822,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]Publish://AlarmClockService/SetAlarmTime/TestDto.AlarmClockParameter=TestDto.AlarmClockParameter
[2017-10-11 09:12:23]处理服务的时候发生异常：执行服务方法错误：
源错误信息：系统不能处理当前类型的参数：TestDto.AlarmClockParameter，
请求的Uri:
Publish://AlarmClockService/SetAlarmTime/TestDto.AlarmClockParameter=TestDto.AlarmClockParameter，
127.0.0.1:57822,WMI2114256838

错误发生时的异常对象调用堆栈：
System.ArgumentException: 系统不能处理当前类型的参数：TestDto.AlarmClockParameter
[2017-10-11 09:12:23.767]请求处理完毕(15.6339ms)--To: 127.0.0.1:57822,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]消息长度：63字节 -------
result:Service_Execute_Error:系统不能处理当前类型的参数：TestDto.AlarmClockParameter
Publish Message OK.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这说明MSF服务端不识别当前调用的服务方法上的参数类型 TestDto.AlarmClockParameter ，这里需要将这个自定义的参数类型注册到MSF的IOC配置文件上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IOC &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;ServiceModel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Add &lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;=&quot;AlarmClockParameter&quot;&lt;/span&gt;&lt;span&gt;  InterfaceName&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;  FullClassName&lt;/span&gt;&lt;span&gt;=&quot;TestDto.AlarmClockParameter&quot;&lt;/span&gt;&lt;span&gt; Assembly&lt;/span&gt;&lt;span&gt;=&quot;TestDto&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 其它略&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;IOC&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注意：服务访问需要的自定义参数类型，必须注册在 ServiceModel 节点下。&lt;/p&gt;
&lt;h2&gt;2.4，运行订阅服务&lt;/h2&gt;
&lt;p&gt;如果前面的配置都正确了，我们重新生成项目，启动MS Host 和TestClient，就可以看到客户端输出的结果了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
请输入闹铃响铃时间(示例输入格式 11:54) &amp;gt;&amp;gt;11:55
订阅闹钟服务，闹钟将在 11:55 响铃...
闹钟响了，现在时间:2017-10-11 11:55:09
闹钟响了，现在时间:2017-10-11 11:55:19
闹钟响了，现在时间:2017-10-11 11:55:29
闹钟响了，现在时间:2017-10-11 11:55:39
闹钟响了，现在时间:2017-10-11 11:55:49
闹钟响了，现在时间:2017-10-11 11:55:59
闹钟响了，现在时间:2017-10-11 11:56:09
闹钟响了，现在时间:2017-10-11 11:56:19
闹钟响了，现在时间:2017-10-11 11:56:29
闹钟响了，现在时间:2017-10-11 11:56:39
闹钟响了，现在时间:2017-10-11 11:56:49
闹钟响了，现在时间:1900-1-1 0:00:00
闹铃服务结束，按回车键继续。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在客户端控制台输入闹铃时间，我们看到在时间到了后，服务器才向客户端推送了“响铃通知”消息，客户端处理这个事件将结果打印在屏幕上。&lt;/p&gt;

&lt;p&gt;在MSF的入门篇介绍中，我们说MSF具有实现Actor编程模型的能力，在MSF中，每一个被订阅的服务，它本质上都是一个&lt;strong&gt;分布式的Actor对象&lt;/strong&gt;，这&lt;span&gt;些Actor对象在第一次被订阅的时候激活，一直到没有任何客户端订阅它们为止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于同一个MSF服务类下的服务方法，当我们以订阅的方式激活此Actor的时候，是以被订阅的服务方法的参数来区分的，简单说，就是订阅的服务方法参数一样，那么多个客户端订阅的都是同一个MSF的服务对象实例。&lt;/p&gt;
&lt;p&gt;这个现象，可以通过本篇的“闹钟服务”订阅过程来验证，在第一个客户端订阅闹钟服务后，启动第二个TestClient程序，也来订阅闹钟服务，注意，2个进程订阅的闹钟服务，它的闹铃时间设置为一样。订阅后，我们发现，即使第一个订阅客户端已经开始收到服务器的“闹铃消息”推送，第二个订阅客户端加入进来后，可以马上收到同样的消息推送，这说明，两个客户端订阅的是同一个MSF的服务对象，也就是同一个Actor对象。我们注意观察 MSF Host的屏幕输出，也能验证这个结果，它会提示消息发送给了2个客户端，具体过程，大家可以去仔细看看，本篇不再说明。下面是效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/114517/201710/114517-20171011125041918-880680698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;---------------------------分界线------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;欢迎加入我们的QQ群讨论MSF框架的使用，群号：敏思（PWMIS） .NET 18215717，加群请注明：PDF.NET技术交流，否则可能被拒。&lt;/p&gt;

</description>
<pubDate>Wed, 11 Oct 2017 04:19:00 +0000</pubDate>
<dc:creator>深蓝医生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bluedoctor/p/7649169.html</dc:identifier>
</item>
<item>
<title>自适应 Tab 宽度可以滑动文字逐渐变色的 TabLayout(仿今日头条顶部导航) - 丁先森</title>
<link>http://www.cnblogs.com/dingxiansen/p/7649930.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dingxiansen/p/7649930.html</guid>
<description>
&lt;p&gt;&lt;code&gt;TabLayout&lt;/code&gt;相信大家都用过，2015年Google大会上发布了新的Android Support Design库里面包含了很多新的控件，其中就包含&lt;code&gt;TabLayout&lt;/code&gt;，它可以配合&lt;code&gt;ViewPager&lt;/code&gt;完成很好的效果。&lt;/p&gt;
&lt;p&gt;一种类似于今日头条指示器，根据ViewPager的页面滑动，文字逐渐变色。&lt;/p&gt;
&lt;p&gt;今日头条的顶部tab导航效果的实现，我们一般会用RadioGroup+Fragment+ViewPager来实现，适配器繁多，代码量大，今天我们来介绍TabLayout的使用。TabLayout为Android的Design库中的一个控件。首先我们来看一下运行的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1058389/201710/1058389-20171011120159246-846518696.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;ColorTrackTabLayout&lt;/h2&gt;
&lt;p&gt;先看下效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/4/18/c856e0907f007d5f47a552ffda78b960.gif?imageView2/0/w/1280/h/960&quot; alt=&quot;&quot; data-original-src=&quot;https://github.com/yewei02538/ColorTrackTabLayout/raw/master/screenshot/screenshot.gif&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;使用&lt;/h2&gt;
&lt;p&gt;因为是继承TabLayout，所以用法跟TabLayout一模一样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;隐藏Indicator&lt;/span&gt;
        mTab.setSelectedTabIndicatorHeight(0&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置左右内边距&lt;/span&gt;
        mTab.setTabPaddingLeftAndRight(10,10&lt;span&gt;);
        mTab.setupWithViewPager(mViewPager);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;原理&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ColorTrackLayout&lt;/code&gt;主要是继承了TabLayout，对它做了一些扩展。&lt;/p&gt;
&lt;p&gt;既然是随着页面的滑动文字颜色渐变那么肯定少不了ViewPager的页面监听，这个在我们调用&lt;code&gt;setupWithViewPager&lt;/code&gt;的时候TabLayout就已经添加监听。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setupWithViewPager(@Nullable &lt;span&gt;final&lt;/span&gt; ViewPager viewPager, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; autoRefresh,
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; implicitSetup) {
        ....

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (viewPager != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            mViewPager &lt;/span&gt;=&lt;span&gt; viewPager;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add our custom OnPageChangeListener to the ViewPager&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (mPageChangeListener == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加了滑动监听&lt;/span&gt;
                mPageChangeListener = &lt;span&gt;new&lt;/span&gt; TabLayoutOnPageChangeListener(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            }
            mPageChangeListener.reset();
            viewPager.addOnPageChangeListener(mPageChangeListener);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Now we'll add a tab selected listener to set ViewPager's current item&lt;/span&gt;
            mCurrentVpSelectedListener = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ViewPagerOnTabSelectedListener(viewPager);
            addOnTabSelectedListener(mCurrentVpSelectedListener);

            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; PagerAdapter adapter =&lt;span&gt; viewPager.getAdapter();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (adapter != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Now we'll populate ourselves from the pager adapter, adding an observer if
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; autoRefresh is enabled&lt;/span&gt;
&lt;span&gt;                setPagerAdapter(adapter, autoRefresh);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add a listener so that we're notified of any adapter changes&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (mAdapterChangeListener == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                mAdapterChangeListener &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdapterChangeListener();
            }
            mAdapterChangeListener.setAutoRefresh(autoRefresh);
            viewPager.addOnAdapterChangeListener(mAdapterChangeListener);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Now update the scroll position to match the ViewPager's current item&lt;/span&gt;
            setScrollPosition(viewPager.getCurrentItem(), 0f, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We've been given a null ViewPager so we need to clear out the internal state,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; listeners and observers&lt;/span&gt;
            mViewPager = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            setPagerAdapter(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }
        ....

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建了mPageChangeListener并添加了监听&lt;/p&gt;
&lt;p&gt;所以我们必须要重写&lt;code&gt;setupWithViewPager&lt;/code&gt;删除掉原来的监听，换成我们自己的监听&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
mPageChangeListener = &lt;span&gt;new&lt;/span&gt; TabLayoutOnPageChangeListener(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setupWithViewPager(@Nullable ViewPager viewPager, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; autoRefresh) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.setupWithViewPager(viewPager, autoRefresh);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过反射找到mPageChangeListener&lt;/span&gt;
            Field field = TabLayout.&lt;span&gt;class&lt;/span&gt;.getDeclaredField(&quot;mPageChangeListener&quot;&lt;span&gt;);
            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            TabLayoutOnPageChangeListener listener &lt;/span&gt;= (TabLayoutOnPageChangeListener) field.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (listener != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除自带监听&lt;/span&gt;
&lt;span&gt;                viewPager.removeOnPageChangeListener(listener);
                mPageChangeListenter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ColorTrackTabLayoutOnPageChangeListener(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
                mPageChangeListenter.reset();
                viewPager.addOnPageChangeListener(mPageChangeListenter);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }


    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还需要做的一点就是把TabLayout每一个的Tab布局替换成我们的。怎么替换呢？重写&lt;code&gt;addTab&lt;/code&gt;，在添加的时候改成我们的布局&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addTab(@NonNull Tab tab, &lt;span&gt;int&lt;/span&gt; position, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; setSelected) {
        ColorTrackView colorTrackView &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ColorTrackView(getContext());
        colorTrackView.setProgress(setSelected &lt;/span&gt;? 1 : 0&lt;span&gt;);
        colorTrackView.setText(tab.getText() &lt;/span&gt;+ &quot;&quot;&lt;span&gt;);
        colorTrackView.setTextSize(mTabTextSize);
        colorTrackView.setTag(position);
        colorTrackView.setTextChangeColor(mTabSelectedTextColor);
        colorTrackView.setTextOriginColor(mTabTextColor);
        LinearLayout.LayoutParams layoutParams &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT);
        colorTrackView.setLayoutParams(layoutParams);
        tab.setCustomView(colorTrackView);

        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.addTab(tab, position, setSelected);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (position == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认选中第一个&lt;/span&gt;
&lt;span&gt;            setSelectedView(position);
        }

        setTabWidth(position, colorTrackView);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 借鉴： &lt;a href=&quot;https://link.juejin.im?target=http%3A%2F%2Fwww.weyye.me%2Fdetail%2Fcolor-track-tablayout%2F&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;www.weyye.me/detail/colo…&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其关键就是将我们的布局利用setCustomView方法来设置上去。&lt;/p&gt;
&lt;p&gt;源码链接 &lt;a href=&quot;https://github.com/DingXianSen/DcColorTabLayout&quot; target=&quot;_blank&quot;&gt;https://github.com/DingXianSen/DcColorTabLayout&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Oct 2017 04:05:00 +0000</pubDate>
<dc:creator>丁先森</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dingxiansen/p/7649930.html</dc:identifier>
</item>
<item>
<title>多线程编程：多线程并发制单的开发记录【一】 - 禁心尽力</title>
<link>http://www.cnblogs.com/1315925303zxz/p/7649823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1315925303zxz/p/7649823.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近天气很冷，记得保暖，我在帝都向各位问好。一次舒服的小长假回来，是不是都忘了增删改查怎么敲了，那就赶紧粘贴一会儿吧，别等着公司把你优化掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，老习惯，首先给各位脑补一下多线程必备的知识。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;进程和线程：&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;下图是在来自知乎用户的解释，个人感觉狠到位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/855612/201710/855612-20171011110022059-1366106001.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;155&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;进程和线程的关系：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/855612/201710/855612-20171011113624668-1875634235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;线程安全：&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;       何为线程安全？就是应用中多个线程访问某一个类（对象或方法）时，这个类始终能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       线程安全就是多线程访问时，采用了加锁机制(在多线程安全上加锁也是一门技术活，不是说对于共享资源你简单加个同步关键字或定义成同步方法就OK了的，锁的不合理则会大大影响程序的性能，甚至影响到业务，这里本人亲身经历过一个问题，锁粒度大小对程序的影响，参考：&lt;a href=&quot;http://www.cnblogs.com/1315925303zxz/p/7561236.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/1315925303zxz/p/7561236.html&lt;/a&gt;)，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        线程不安全呢，就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。这里的加锁机制常见的如：synchronized。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;由spring管理的线程池进行并发制单的业务设计：&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;业务需求：多个通道进行数据采集，数据采集就是拿着VIN码去抓取数据，但是当VIN码很多时，采集的速度就很慢，所以实施多线程多并发进行采集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、spring管理线程池的配置，这里需要说明的一点就是核心线程数和最大线程数的配置一定要按照自己业务的并发量来设定，否则不仅不会提升并发效率，反而会出现各种数据污染的情况。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 异步线程池 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;threadPoolTaskExecutor&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 核心线程数，最小线程数 默认为1 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;corePoolSize&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 最大线程数，默认为Integer.MAX_VALUE &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;maxPoolSize&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 队列最大长度，一般需要设置值&amp;gt;=notifyScheduledMainExecutor.maxNum；默认为Integer.MAX_VALUE &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;queueCapacity&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;2000&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 线程池维护线程所允许的空闲时间，默认为60s &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;keepAliveSeconds&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 线程池对拒绝任务（无线程可用）的处理策略，目前只支持AbortPolicy、CallerRunsPolicy；默认为后者 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;rejectedExecutionHandler&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; AbortPolicy:直接抛出java.util.concurrent.RejectedExecutionException异常 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; CallerRunsPolicy:主线程直接执行该任务，执行完之后尝试添加下一个任务到线程池中，可以有效降低向线程池内添加任务的速度 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; DiscardOldestPolicy:抛弃旧的任务、暂不支持；会导致被丢弃的任务无法再次被执行 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; DiscardPolicy:抛弃当前任务、暂不支持；会导致被丢弃的任务无法再次被执行 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　&amp;lt;!-- 一汽大众和奥迪多并发制单 --&amp;gt;&lt;br/&gt;　　　　  &amp;lt;bean id=&quot;multiThreadTask_VW_AD&quot; class=&quot;cn.base.thread.MultiThreadTask_VW_AD&quot;/&amp;gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2、线程制单业务(这里是伪代码)，将符合条件的VIN码进行数据采集，否则记录到指定容器中统一处理(退单)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初始化任务(VIN码)队列：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3f1c7d95-8af8-486c-ba47-eb7f1eeab4b5')&quot; readability=&quot;39.5&quot;&gt;&lt;img id=&quot;code_img_closed_3f1c7d95-8af8-486c-ba47-eb7f1eeab4b5&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3f1c7d95-8af8-486c-ba47-eb7f1eeab4b5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3f1c7d95-8af8-486c-ba47-eb7f1eeab4b5',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3f1c7d95-8af8-486c-ba47-eb7f1eeab4b5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InitQueue {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(MultiThreadTask_VW_AD.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     *    并发队列
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Queue&amp;lt;String&amp;gt; queue = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化并发队列&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initQueue(){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         logger.info(&quot;初始化并发队列：{}&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(queue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             queue = &lt;span&gt;new&lt;/span&gt; ConcurrentLinkedQueue&amp;lt;String&amp;gt;();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;并发队列    &lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         String tasklist = &quot;JF1GH78F18G03614,JF1SH95F6AG110830,JF1SJ94D7DG010387333,JF1SH92F9CG26924,JF1SH92F5BG215090,JF1SH92F5BG222556,JF1SH92F4CG279994,JF1BR96D7CG114298,JF1BR96D0BG078632,JF1SH95F9AG094011,JF1SH98FXAG186997,JF1BM92D8BG022510,JF1BM92DXAG013855,JF1BM94D8EG0366&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         String[] split = tasklist.split(&quot;,&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         List&amp;lt;String&amp;gt; task = Arrays.asList(split);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组转集合&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         queue.addAll(task);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按照集合中元素的顺序将集合中全部元素放进队列&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对外提供一个任务队列&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Queue&amp;lt;String&amp;gt;&lt;span&gt; getQueue(){
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        initQueue();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; queue;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;制单：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;br/&gt;&lt;span&gt;   class&lt;/span&gt; MultiThreadTask_VW_AD &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable,Serializable{&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(MultiThreadTask_VW_AD.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object lock = &lt;span&gt;new&lt;/span&gt; Object();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态锁，任务队列在某一时刻只能由一个线程操作&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt; errorVinList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放不合理VIN码的集合&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Queue&amp;lt;String&amp;gt; taskQueue = InitQueue.getQueue();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务队列
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据采集&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; queueSize =&lt;span&gt; taskQueue.size();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(queueSize &amp;gt; 0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 logger.info(&quot;任务队列目前有{}个任务&quot;&lt;span&gt;,queueSize);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 String thisVin =&lt;span&gt; taskQueue.poll();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 logger.info(&quot;当前任务VIN码：{}&quot;&lt;span&gt;,thisVin);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(thisVin.length() == 17&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                     System.out.println(&quot;采集任务已完成【&quot;+Thread.currentThread().getName()+&quot;】&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     System.out.println(&quot;不进行采集【&quot;+Thread.currentThread().getName()+&quot;】&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                    errorVinList.add(thisVin);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     System.err.println(&quot;未采集的VIN码有：&quot;+&lt;span&gt;errorVinList);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 logger.info(&quot;任务队列目前无任务&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     
&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       再次强调：加锁的时候一定要掌握好锁的粒度，不然会影响并发效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、模拟多通道进行数据采集。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPoolController {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(ThreadPoolController.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * 一汽大众、奥迪多并发进行数据采集：
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; vwadTest(){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载线程池配置文件&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         ApplicationContext ctx = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;classpath:springs/applicationContext-threadpool.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过applicationContext获取异步线程池对象threadPoolTaskExecutor&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         ThreadPoolTaskExecutor threadPool = (ThreadPoolTaskExecutor) ctx.getBean(&quot;threadPoolTaskExecutor&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取品牌制单业务对象(由spring管理的)&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         MultiThreadTask_VW_AD multiThreadTask_VW_AD = (MultiThreadTask_VW_AD) ctx.getBean(&quot;multiThreadTask_VW_AD&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=1; i&amp;lt;=15; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            threadPool.execute(multiThreadTask_VW_AD);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;后期继续更新多线程并发的文章，因为被这家伙给看上了，不得不深入剖析了，一直在学习的路上。&lt;/p&gt;

</description>
<pubDate>Wed, 11 Oct 2017 03:48:00 +0000</pubDate>
<dc:creator>禁心尽力</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1315925303zxz/p/7649823.html</dc:identifier>
</item>
<item>
<title>当我们准备做前后端分离项目时，我们在考虑什么？ - 春哥大魔王</title>
<link>http://www.cnblogs.com/xiguain/p/7649689.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiguain/p/7649689.html</guid>
<description>&lt;p&gt;几年前做前后端分离项目的原因，是node刚刚横空出世，业界开始考虑如何真正的&lt;code&gt;用js去写后端服务&lt;/code&gt;，于是就借鉴阿里&lt;code&gt;中途岛&lt;/code&gt;项目去尝试，主要还是用到了node的密集io场景下的转发。&lt;/p&gt;
&lt;p&gt;我们的新项目是采用前后端分离的方式进行开发，这一点主要是基于产品特点考虑而来，产品本身会有很强的&lt;code&gt;富客户端&lt;/code&gt;的特点。&lt;/p&gt;
&lt;p&gt;我们后端服务面向的客户端包含：&lt;code&gt;iOS&lt;/code&gt;，&lt;code&gt;Android&lt;/code&gt;，&lt;code&gt;iPad&lt;/code&gt;，&lt;code&gt;H5&lt;/code&gt;，还有一些&lt;code&gt;游戏场景&lt;/code&gt;。所以最好的方式就是后端提供通用的&lt;code&gt;restapi&lt;/code&gt;进行数据传输，而前端展示逻辑则交由不同客户端自己实现。&lt;/p&gt;
&lt;p&gt;前后端分离项目主要基于&lt;code&gt;微服务架构&lt;/code&gt;开发，既然是&lt;code&gt;微服务&lt;/code&gt;，所以&lt;code&gt;分布式系统&lt;/code&gt;所应该面对的问题一个也漏不掉。&lt;/p&gt;
&lt;p&gt;JAVA微服务开发场景下，&lt;code&gt;SpringBoot&lt;/code&gt;可谓神器，我们基于&lt;code&gt;SpringBoot&lt;/code&gt;开发了一个可以快速开发的脚手架，脚手架本身包含了常用及通用的基本功能，如&lt;code&gt;auth验证&lt;/code&gt;，&lt;code&gt;功能鉴权&lt;/code&gt;，&lt;code&gt;Mysql&lt;/code&gt;，&lt;code&gt;Mq&lt;/code&gt;，&lt;code&gt;Redis&lt;/code&gt;及&lt;code&gt;通用配置&lt;/code&gt;的依赖，这样开发工程师在需要开发新功能时，直接从对应的代码库拉下来，编译之后便可跑起来一个&lt;code&gt;hello world&lt;/code&gt;的&lt;code&gt;restapi&lt;/code&gt;项目。剩下的工作就是围绕业务逻辑去写&lt;code&gt;repository，service，controller&lt;/code&gt;代码了。&lt;/p&gt;
&lt;h4 id=&quot;通信&quot;&gt;通信&lt;/h4&gt;
&lt;p&gt;服务之间的通信主要可以通过&lt;code&gt;HTTP，RPC&lt;/code&gt;方式，众所周知&lt;code&gt;RPC&lt;/code&gt;调用的效率要高&lt;code&gt;HTTP&lt;/code&gt;好几个等级，所以推荐使用&lt;code&gt;RPC&lt;/code&gt;，但是综合考虑系统性能及可用性，快速开发等因素，我们也大量使用&lt;code&gt;HTTP&lt;/code&gt;进行服务调用，同时我们也通过&lt;code&gt;Golang&lt;/code&gt;对一些核心&lt;code&gt;api&lt;/code&gt;，比如&lt;code&gt;支付，交易类&lt;/code&gt;接口进行了重写，所以需要在系统效率及开发效率之间做好平衡。&lt;/p&gt;
&lt;h4 id=&quot;接口规范&quot;&gt;接口规范&lt;/h4&gt;
&lt;p&gt;虽然是前后端分离项目，大部分是通过&lt;code&gt;restapi&lt;/code&gt;方式给客户端暴露数据，但是也不可避免在系统中会存在自己的&lt;code&gt;view&lt;/code&gt;页面，所以在&lt;code&gt;api及controller&lt;/code&gt;命名上会建立：&lt;code&gt;AuthApi，AuthController&lt;/code&gt;，约定大于配置，可以帮助我们后端对不同的请求做隔离和控制。&lt;/p&gt;
&lt;h4 id=&quot;任务类系统&quot;&gt;任务类系统&lt;/h4&gt;
&lt;p&gt;项目中不可避免存在大量的任务程序，主要需要做好数据备份，考虑分布式场景下的任务调度，资源分配问题，主要根据场景不同进行开发。&lt;br/&gt;我们采用&lt;code&gt;Zk+定时任务&lt;/code&gt;自研的调度系统，也可以采用开源的&lt;code&gt;Elastic-Job&lt;/code&gt;方案。&lt;/p&gt;
&lt;h4 id=&quot;依赖梳理&quot;&gt;依赖梳理&lt;/h4&gt;
&lt;p&gt;这个是一个项目开发过程中最重要的一点，梳理好系统上下游所依赖的服务，同时梳理好服务之间的等级关系。&lt;/p&gt;
&lt;p&gt;依赖关系主要分为两部分：&lt;code&gt;依赖别人，被别人依赖&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;依赖别人的服务，包含其他系统API及底层的数据库，Redis，MQ等服务，需要做好对方服务不可用的准备，随时做好&lt;code&gt;降级，限流及开关&lt;/code&gt;功能，最好做成可配置，自动化。&lt;br/&gt;被别人依赖的服务做成&lt;code&gt;高可用，幂等性，响应数据的可读性好&lt;/code&gt;等特点。&lt;/p&gt;
&lt;p&gt;同时对服务依赖性梳理，哪些系统属于强依赖，哪些属于若依赖。&lt;/p&gt;
&lt;p&gt;不同依赖的标准做好开关，降级，重试等功能，强依赖比如DB挂了，可以写日志，写到MQ。弱依赖可以做成柔性降级，比如写日志到ES中，ES不可用，可以直接降级即可。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;黄金等级服务&lt;/code&gt;，则一定&lt;code&gt;保证服务高可用，可以做灾备，比如依赖集群，多个机房&lt;/code&gt;，也就是这个服务是不可降级的，必须准备多套方案保证服务可用。&lt;/p&gt;
&lt;p&gt;关于依赖降级可以使用&lt;code&gt;Hystrix&lt;/code&gt;做。&lt;/p&gt;
&lt;h4 id=&quot;用户友好性&quot;&gt;用户友好性&lt;/h4&gt;
&lt;p&gt;做好最坏的打算，如果后端服务全部不可用，前端转发问题等，一定不要给用户一个错误页面，一定建立多级缓存，&lt;code&gt;有数据托底&lt;/code&gt;，无论如何保证页面上有内容的。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;综上所述，做好工具，梳理好服务依赖，对服务做等级划分，弱依赖可以通过降级，限流方式处理。强依赖则必须通过多种灾备手段保证高可用，不要给用户感到&lt;code&gt;恐慌&lt;/code&gt;的页面，要有数据托底。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/376571/201710/376571-20171011112305637-1862996704.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Oct 2017 03:23:00 +0000</pubDate>
<dc:creator>春哥大魔王</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiguain/p/7649689.html</dc:identifier>
</item>
<item>
<title>翻译 | 关键CSS和Webpack: 减少阻塞渲染的CSS的自动化解决方案 - iKcamp</title>
<link>http://www.cnblogs.com/ikcamp/p/7649623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ikcamp/p/7649623.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/11/d123c4d3fb42413f4ccf1ca5026158c7&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&quot;消除阻塞渲染的CSS和JavaScript&quot;。 这一条Google Page Speed Insights的建议总让我困惑。&lt;/p&gt;
&lt;p&gt;当一个网页被访问时，Google希望它仅加载对初始视图有用的内容，并使用空闲时间来加载其他内容。这种方式可以使用户尽可能早地看到页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/11/410eb86cffa42c913096fdb95e73e797&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以做很多事情来减少阻塞渲染的JavaScript，例如code splitting、tree shaking，缓存等。&lt;/p&gt;
&lt;p&gt;但是如何减少阻塞渲染的CSS？为此，可以拆分并优先加载首次渲染所需要的CSS（关键CSS)，然后再加载其它CSS。&lt;/p&gt;
&lt;p&gt;可以通过编程的方式筛选出关键CSS，在本文中，我将向你展示如何通过Webpack的自动化流程来实现该方案。&lt;/p&gt;
&lt;h2 id=&quot;什么是阻塞渲染&quot;&gt;什么是阻塞渲染&lt;/h2&gt;
&lt;p&gt;如果资源是“阻塞渲染”的，则表示浏览器在资源下载或处理完成之前不会显示该页面。&lt;/p&gt;
&lt;p&gt;通常，我们在html的&lt;code&gt;head&lt;/code&gt;标签中添加CSS样式表，这种方式会阻塞渲染，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;head&amp;gt;
  &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot;&amp;gt;
  ...
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;p&amp;gt;在style.css下载完之前，你看不到我！！！&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当这个html页面被网络浏览器加载时，它将从上到下被逐行解析。当浏览器解析到&lt;code&gt;link&lt;/code&gt;标签时，它将立即开始下载CSS样式表，在完成之前不会渲染页面。&lt;/p&gt;
&lt;p&gt;对于一个大型网站，尤其是像使用了Bootstrap这种庞大框架的网站，样式表有几百KB，用户必须耐心等待其完全下载完才能看到页面。&lt;/p&gt;
&lt;p&gt;那么，我们是否应该把link标签放到&lt;code&gt;body&lt;/code&gt;中，以防止阻塞渲染？你可以这么做，但是阻塞渲染也不是全无优点，我们实际上可以利用它。如果页面渲染时没有加载任何CSS，我们会遇到丑陋的&quot;内容闪现&quot;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/11/36c4d6a05d89cc0df4d23dc2f2ee53e0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们想要的完美解决方案就应该是：首屏相关的关键CSS使用阻塞渲染的方式加载，所有的非关键CSS在首屏渲染完成后加载。&lt;/p&gt;
&lt;h2 id=&quot;关键css&quot;&gt;关键CSS&lt;/h2&gt;
&lt;p&gt;这里是我用Webpack和Bootstrap编写的一个简单的网页, 下面的截图是首次渲染后的样式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/11/deec0cd6678eb9a847f1c2a72f0f69a0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Sign Up today按钮会弹出一个模态框, 模态框弹出时的样式如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/11/59fd687e2aaed761d36ed9ec98fc6c22&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首次渲染需要的样式包括导航条的样式、超大屏幕样式、按钮样式、其它布局和字体的公用样式。但是我们并不需要模态框的样式，因为它不会立即在页面中显示。考虑到这些，下面是我们拆分关键CSS和非关键CSS的可能的方式：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;critical.css&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.nav {
  ...
}

.jumbtron {
  ...
}

.btn {
  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;non_critical.css&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.modal {
  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你已经有这个概念，那么你可能会提出两个疑问：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们如何用程序区分关键CSS和非关键CSS?&lt;/li&gt;
&lt;li&gt;如何让页面在首次渲染之前加载关键CSS，之后加载非关键CSS？&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;示例项目&quot;&gt;示例项目&lt;/h2&gt;
&lt;p&gt;我将简要介绍一下这个项目的基本配置，这样我们在遇到解决方案时，方便快速消化。&lt;br/&gt;首先, 在入口文件中引入Bootsrap SASS。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;main.js&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;require(&quot;bootstrap-sass/assets/stylesheets/_bootstrap.scss&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我使用&lt;em&gt;sass-loader&lt;/em&gt;来处理sass，与&lt;em&gt;Extract Text Plugin&lt;/em&gt;一起使用，将编译出来的css放到单独的文件中。&lt;/p&gt;
&lt;p&gt;使用&lt;em&gt;HTML Webpack Plugin&lt;/em&gt;来创建一个HTML文件，它引入编译后的CSS。这在我们的解决方案中是必需的，你马上就会看到。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;webpack.config.js&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
  module: {
    rules: [
      {
        test: /\.scss$/,
        use: ExtractTextPlugin.extract({
          fallback: 'style-loader',
          use: ['css-loader', 'sass-loader']
        })
      },
      ...
    ]
  },
  ...
  plugins: [
    new ExtractTextPlugin({ filename: 'style.css' }),
    new HtmlWebpackPlugin({
      filename: 'index.html',
      template: 'index.html',
      inject: true
    })
  ] 
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行构建之后，这里是HTML文件的样子。请注意，CSS文件在&lt;code&gt;head&lt;/code&gt;标签里引入，因此将会阻塞渲染。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;index.html&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&amp;gt;
    &amp;lt;title&amp;gt;vuestrap-code-split&amp;lt;/title&amp;gt;
    &amp;lt;link href=&quot;/style.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;!--App content goes here, omitted for brevity.--&amp;gt;
  &amp;lt;script type=&quot;text/javascript&quot; src=&quot;/build_main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编程识别关键css&quot;&gt;编程识别关键CSS&lt;/h2&gt;
&lt;p&gt;手动区分关键CSS维护起来会非常痛苦。以编程方式来实现的话，我们可以使用Addy Osmani的&lt;a href=&quot;https://github.com/addyosmani/critical&quot;&gt;Critical&lt;/a&gt;。这是一个Node.js模块，它将读入HTML文档，并识别关键CSS。Critical能做的还不止这些，你很快就能体会到。&lt;/p&gt;
&lt;p&gt;Critical识别关键CSS的方式如下：指定屏幕尺寸并使用PhantomJS加载页面，提取在渲染页面中用到的所有CSS规则。&lt;/p&gt;
&lt;p&gt;以下为对项目的设置:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const critical = require(&quot;critical&quot;);

critical.generate({
  
  /* Webpack打包输出的路径 */
  base: path.join(path.resolve(__dirname), 'dist/'),
  src: 'index.html',
  dest: 'index.html',
  inline: true,
  extract: true,

  /* iPhone6的尺寸，你可以按需要修改 */
  width: 375,
  height: 565,
  
  /* 确保调用打包后的JS文件 */
  penthouse: {
    blockJSRequests: false,
  }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行时，会将Webpack打包输出文件中HTML更新为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&amp;gt;
  &amp;lt;title&amp;gt;Bootstrap Critical&amp;lt;/title&amp;gt;
  &amp;lt;style type=&quot;text/css&quot;&amp;gt;
    /* 关键CSS通过内部样式表方式引入 */
    body {
      font-family: Helvetica Neue,Helvetica,Arial,sans-serif;
      font-size: 14px;
      line-height: 1.42857;
      color: #333;
      background-color: #fff;
    }
    ...
  &amp;lt;/style&amp;gt;
  &amp;lt;link href=&quot;/style.96106fab.css&quot; rel=&quot;preload&quot; as=&quot;style&quot; onload=&quot;this.rel='stylesheet'&quot;&amp;gt;
  &amp;lt;noscript&amp;gt;
      &amp;lt;link href=&quot;/style.96106fab.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
  &amp;lt;/noscript&amp;gt;
  &amp;lt;script&amp;gt;
    /*用来加载非关键CSS的脚本*/
  &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;!-- 这里是App的内容 --&amp;gt;
  &amp;lt;script type=&quot;text/javascript&quot; src=&quot;/build_main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它还将输出一个新的CSS文件，例如&lt;em&gt;style.96106fab.css&lt;/em&gt;（文件自动Hash命名）。这个CSS文件与原始样式表相同，只是不包含关键CSS。&lt;/p&gt;
&lt;h2 id=&quot;内联嵌入关键css样式&quot;&gt;内联嵌入关键CSS样式&lt;/h2&gt;
&lt;p&gt;你会注意到，关键CSS已经嵌入到文档的头部。这是最佳的，因为页面不必从服务器加载它。&lt;/p&gt;
&lt;h2 id=&quot;预加载非关键css&quot;&gt;预加载非关键CSS&lt;/h2&gt;
&lt;p&gt;你还会注意到，非关键CSS使用了一个看起来更复杂的&lt;code&gt;link&lt;/code&gt;标签来加载。&lt;code&gt;rel=&quot;preload&quot;&lt;/code&gt;通知浏览器开始获取非关键CSS以供之后用。其关键在于，&lt;code&gt;preload&lt;/code&gt;不阻塞渲染，无论资源是否加载完成，浏览器都会接着绘制页面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;link&lt;/code&gt;标签中的&lt;code&gt;onload&lt;/code&gt;属性允许我们在非关键CSS加载完成时运行脚本。&lt;em&gt;Critical&lt;/em&gt;模块可以自动将此脚本嵌入到文档中，这种方式提供了将非关键CSS加载到页面中的跨浏览器兼容方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;link href=&quot;/style.96106fab.css&quot; rel=&quot;preload&quot; as=&quot;style&quot; onload=&quot;this.rel='stylesheet'&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;把critical组件添加到webpack打包流程中&quot;&gt;把Critical组件添加到webpack打包流程中&lt;/h2&gt;
&lt;p&gt;我创建了一个名为&lt;a href=&quot;https://github.com/anthonygore/html-critical-webpack-plugin&quot;&gt;HTML Critical Webpack Plugin&lt;/a&gt;的插件，该插件仅仅是&lt;em&gt;Critical&lt;/em&gt;模块的封装。它将在&lt;em&gt;HTML Webpack Plugin&lt;/em&gt;输出文件后运行。&lt;/p&gt;
&lt;p&gt;你可以在Webpack的项目中这样引入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const HtmlCriticalPlugin = require(&quot;html-critical-webpack-plugin&quot;);

module.export = {
  ...
  plugins: [
    new HtmlWebpackPlugin({ ... }),
    new ExtractTextPlugin({ ... }),
    new HtmlCriticalPlugin({
      base: path.join(path.resolve(__dirname), 'dist/'),
      src: 'index.html',
      dest: 'index.html',
      inline: true,
      minify: true,
      extract: true,
      width: 375,
      height: 565,
      penthouse: {
        blockJSRequests: false,
      }
    })
  ] 
};&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：你应该只在生产版本中使用，因为它将使你的开发环境的构建很慢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;表现结果&quot;&gt;表现结果&lt;/h2&gt;
&lt;p&gt;现在已经抽离了关键CSS，并且把非关键CSS的加载放到空闲时间，这在性能方面会有怎样的提升呢?&lt;/p&gt;
&lt;p&gt;我使用Chrome的Lighthouse扩展插件进行测试。请记住，我们尝试优化的指标是&lt;a href=&quot;https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint&quot;&gt;“首次有效绘制”&lt;/a&gt;，也就是用户需要多久才能看到真正可浏览的页面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不使用区分关键CSS技术的表现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/11/2d6acb4c652608c289ba3c6f0f595fdc&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用区分关键CSS技术的表现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/11/403fb424ed898cc70b1190267e99a6db&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正如你所看到的，我的应用程序First Meaningful paint时间缩短了将近1秒，到达可交互状态的时间节省了0.5秒。实际中，你的应用程序可能无法获得如此惊人的改善，因为我的CSS很笨重（我包含了整个Bootstrap库），而且在这样一个简单的应用程序中，我没有很多关键CSS规则。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dn-mhke0kuv.qbox.me/3326ff01e1f06fd6dc3c.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/8/31/076d086e1d56bd0fb1f51c2abd0b8c08&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;iKcamp原创新书《移动Web前端高效开发实战》已在亚马逊、京东、当当开售。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;2.0833333333333&quot;&gt;
&lt;p&gt;iKcamp官网：&lt;a href=&quot;http://www.ikcamp.com/&quot; class=&quot;uri&quot;&gt;http://www.ikcamp.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 11 Oct 2017 03:15:00 +0000</pubDate>
<dc:creator>iKcamp</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ikcamp/p/7649623.html</dc:identifier>
</item>
</channel>
</rss>