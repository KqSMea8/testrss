<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Kubernetes 架构（上）- 每天5分钟玩转 Docker 容器技术（120） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8294766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8294766.html</guid>
<description>&lt;p&gt;&lt;span&gt;Kubernetes Cluster 由 Master 和 Node 组成，节点上运行着若干 Kubernetes 服务。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Master 节点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Master 是 Kubernetes Cluster 的大脑，运行着如下 Daemon 服务：kube-apiserver、kube-scheduler、kube-controller-manager、etcd 和 Pod 网络（例如 flannel）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;601.png&quot; src=&quot;https://i.imgsafe.org/d3/d3d435682c.png&quot; alt=&quot;601.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;API Server（kube-apiserver）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;API Server 提供 HTTP/HTTPS RESTful API，即 Kubernetes API。API Server 是 Kubernetes Cluster 的前端接口，各种客户端工具（CLI 或 UI）以及 Kubernetes 其他组件可以通过它管理 Cluster 的各种资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Scheduler（kube-scheduler）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Scheduler 负责决定将 Pod 放在哪个 Node 上运行。Scheduler 在调度时会充分考虑 Cluster 的拓扑结构，当前各个节点的负载，以及应用对高可用、性能、数据亲和性的需求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Controller Manager（kube-controller-manager）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Controller Manager 负责管理 Cluster 各种资源，保证资源处于预期的状态。Controller Manager 由多种 controller 组成，包括 replication controller、endpoints controller、namespace controller、serviceaccounts controller 等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不同的 controller 管理不同的资源。例如 replication controller 管理 Deployment、StatefulSet、DaemonSet 的生命周期，namespace controller 管理 Namespace 资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;etcd&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;etcd 负责保存 Kubernetes Cluster 的配置信息和各种资源的状态信息。当数据发生变化时，etcd 会快速地通知 Kubernetes 相关组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Pod 网络&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Pod 要能够相互通信，Kubernetes Cluster 必须部署 Pod 网络，flannel 是其中一个可选方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上是 Master 上运行的组件，下一节我们讨论 Node。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://www.cnblogs.com/Users/wanglei/百度云同步盘/容器/images/480.png?v=1510821977521&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 22:44:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8294766.html</dc:identifier>
</item>
<item>
<title>Java的参数传递是值传递还是引用传递 - nnngu</title>
<link>http://www.cnblogs.com/nnngu/p/8299724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnngu/p/8299724.html</guid>
<description>&lt;p&gt;&lt;strong&gt;当一个对象被当作参数传递到一个方法后，在此方法内可以改变这个对象的属性，那么这里到底是值传递还是引用传递? &lt;br/&gt;&lt;/strong&gt;　　答：是值传递。&lt;span&gt;&lt;strong&gt;Java 语言的参数传递只有值传递。&lt;/strong&gt;&lt;/span&gt;当一个实例对象作为参数被传递到方法中时，参数的值就是该对象的引用的一个副本。指向同一个对象，对象的内容可以在被调用的方法内改变，但对象的引用(不是引用的副本) 是永远不会改变的。&lt;/p&gt;

&lt;p&gt;Java的参数传递，不管是基本数据类型还是引用类型的参数，&lt;strong&gt;都是按值传递，没有按引用传递！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 我们可以看一下microsoft的文档中对按引用传递参数的定义（如下截图）：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref#passing-an-argument-by-reference&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref#passing-an-argument-by-reference&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180117012532662-1383872913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;1、基本数据类型的参数&lt;/h3&gt;
&lt;p&gt;先来看一下基本数据类型的参数按值传递的例子：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TransferTest.java&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TransferTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = 1&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;changeNum()方法调用之前：num = &quot; +&lt;span&gt; num);
        changeNum(num);
        System.out.println(&lt;/span&gt;&quot;changeNum()方法调用之后：num = &quot; +&lt;span&gt; num);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; changeNum(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x) {
        x &lt;/span&gt;= 2&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180116231340787-453502639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个传递过程的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180116232730537-1218992078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;num作为参数传递给changeNum()方法时，是将内存空间中num所指向的那个存储单元中存放的值1传递给了changeNum()方法中的x变量，而这个x变量也在内存空间中分配了一个存储单元，这个时候，就把num的值1传递给了x的这个存储单元中。此后，在changeNum()方法中对x的一切操作都是针对x所指向的这个存储单元，与num所指向的那个存储单元没有关系了！&lt;/p&gt;
&lt;p&gt;所以，在changeNum()方法调用之后，num所指向的存储单元的值还是没有发生变化，&lt;strong&gt;这就是所谓的“值传递”！&lt;/strong&gt;&lt;span&gt;值传递的精髓是：传递的是存储单元中的内容，而不是存储单元的引用！&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;2、引用类型的参数&lt;/h3&gt;
&lt;p&gt;同样，先看一个例子：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TransferTest2.java &lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TransferTest2 {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Person person = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        System.out.println(person);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        change(person);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        System.out.println(person);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; change(Person p) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * Person类
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180117062547818-886816427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看出两次打印person的地址值是一样的，即调用完change() 方法之后，person变量并没有发生改变。&lt;/p&gt;

&lt;p&gt;这个传递过程的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180117001417209-2073627440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当执行到第3行代码时，程序在堆内存中开辟了一块内存空间用来存储Person类的实例对象，同时在栈内存中开辟了一个存储单元用来存储该实例对象的引用，即上图中person指向的存储单元。&lt;/p&gt;
&lt;p&gt;当执行到第5行代码时，person作为参数传递给change()方法，&lt;strong&gt;需要注意的是：person将自己存储单元的&lt;span&gt;内容&lt;/span&gt;传递给了change()方法的p变量！&lt;/strong&gt;此后，在change()方法中对p的一切操作都是针对p所指向的存储单元，与person所指向的那个存储单元没有关系了！&lt;/p&gt;
&lt;p&gt;下一篇文章会分析&lt;a href=&quot;http://www.cnblogs.com/nnngu/p/8300164.html&quot; target=&quot;_blank&quot;&gt;如何用java语言实现按引用传递参数的效果&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;欢迎转载，但请保留文章原始出处&lt;/p&gt;
&lt;p&gt;本文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Java的参数传递是值传递还是引用传递&quot; href=&quot;http://www.cnblogs.com/nnngu/p/8299724.html&quot;&gt;http://www.cnblogs.com/nnngu/p/8299724.html&lt;/a&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 16:39:00 +0000</pubDate>
<dc:creator>nnngu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnngu/p/8299724.html</dc:identifier>
</item>
<item>
<title>微信跳一跳辅助Demo - Rain911</title>
<link>http://www.cnblogs.com/Mr-stockings/p/8299474.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mr-stockings/p/8299474.html</guid>
<description>&lt;p&gt;　　[原创] 前几天没事干看别人一直在玩微信上线的那一个跳一跳小游戏,玩着玩着老是掉下去,闲着没事呗&lt;/p&gt;
&lt;p&gt;就想了想做一个辅助程序的呗.不过先做的手动版的.自动版的有点麻烦.就不发了.用的Java写的,也就一个蒙版.&lt;/p&gt;
&lt;p&gt;下面就开始介绍我的小程序,没好多东西,真正的代码应该就是100行左右,没啥难的.&lt;/p&gt;
&lt;p&gt;　　下面这是我的微信朋友们的跳一跳&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1134372/201801/1134372-20180116235040381-325038837.jpg&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;761&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就这样吧,因为wechat还是有那个仿作弊系统的,所以还是低调的吧...&lt;/p&gt;
&lt;p&gt;话不多说,还是下面奉上我的code吧,说多了墨迹呢....&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.rain.jump.util;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.awt.event.MouseAdapter;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.awt.event.MouseEvent;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.swing.JFrame;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.swing.JLabel;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt; * @classname JumpOneJump.java
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt; * @package com.rain.jump.util
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt; * @project Jump
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Rain 
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt; * @describe 微信跳一跳项目
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt; * @date 2018年1月13日 下午12:06:07
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JumpOneJump &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; JFrame{
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两点坐标&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x0,y0,x1,y1;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置鼠标点击是第一次还是...&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; flag=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; JumpOneJump()
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;(&quot;微信跳一跳&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调父类的方法&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.setSize(316,565&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.setUndecorated(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置窗口居中&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.setLocationRelativeTo(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.setOpacity(0.3f&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.setAlwaysOnTop(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.setVisible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         
&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt;         JLabel jLabel=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; JLabel();
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.add(jLabel);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给jLabel添加一个监听&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.addMouseListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MouseAdapter() {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当你鼠标点击的时候&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; mouseClicked(MouseEvent e){
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数 鼠标的事件源
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(e);&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(e.getButton()==&lt;span&gt;MouseEvent.BUTTON3)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;哈哈哈&quot;);&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;                     
&lt;span&gt; 53&lt;/span&gt;                     
&lt;span&gt; 54&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(flag)
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                         x0=&lt;span&gt;e.getX(); 
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                         y0=&lt;span&gt;e.getY();
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                         flag=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                         System.out.println(&quot;第一次点击的坐标是:(&quot;+x0+&quot;,&quot;+y0+&quot;)&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                         x1=&lt;span&gt;e.getX();
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                         y1=&lt;span&gt;e.getY();
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                         flag=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                         System.out.println(&quot;第二次点击的坐标是:(&quot;+x1+&quot;,&quot;+y1+&quot;)&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取绝对值&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;                         &lt;span&gt;double&lt;/span&gt; _x=Math.abs(x0-&lt;span&gt;x1);
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                         &lt;span&gt;double&lt;/span&gt; _y=Math.abs(y0-&lt;span&gt;y1);
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开平方(两点的距离)&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;                         &lt;span&gt;double&lt;/span&gt; dis = Math.sqrt(_x*_x+_y*&lt;span&gt;_y);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;                        System.out.println(dis);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义adb命令
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;                        String cmd=&quot;adb shell input touchscreen &quot;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;                                +&quot;swipe 200 187 200 187 &quot;+Math.round(dis*3);&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;                         String cmd=&quot;adb shell input swipe 320 410 320 410 &quot;+Math.round(dis*5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                         Runtime run =&lt;span&gt; Runtime.getRuntime();
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                         
&lt;span&gt; 78&lt;/span&gt;                         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行命令&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;                             Process p=&lt;span&gt;run.exec(cmd);
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;                            System.out.println(cmd);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;                            p.waitFor();
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e1) {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;                            e1.printStackTrace();
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e1) {
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;                            e1.printStackTrace();
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                         
&lt;span&gt; 91&lt;/span&gt;                     }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;end else&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;                     
&lt;span&gt; 93&lt;/span&gt;                 }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;end if&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;             }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;end mouseClick()&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     
&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序的入口&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;         
&lt;span&gt;102&lt;/span&gt;         
&lt;span&gt;103&lt;/span&gt;         
&lt;span&gt;104&lt;/span&gt;          &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JumpOneJump();
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过这个辅助用法还是有讲究的呢...要配套ADB工具, &lt;/p&gt;
&lt;p&gt;还要那个就是配套的那个能在电脑上面操作手机的辅助工具,类似TC的套件呀,&lt;/p&gt;
&lt;p&gt;还有就是手机得开USB调试(这个在开发者模式中有的),然后看下连接上了电脑没,win+R键然后在输入cmd进入命令行模式,然后adb devices看有没有连接上手机.&lt;/p&gt;
&lt;p&gt;还是不懂的下面评论,然后告知你的...谢谢大家 了&lt;/p&gt;
&lt;p&gt;再附上下图片,刚刚跳的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1134372/201801/1134372-20180117001059740-1858538350.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 16 Jan 2018 16:04:00 +0000</pubDate>
<dc:creator>Rain911</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mr-stockings/p/8299474.html</dc:identifier>
</item>
<item>
<title>微信【跳一跳】 opencv视觉识别 + 物理外挂 - HongYi_Liang</title>
<link>http://www.cnblogs.com/HongYi-Liang/p/8299460.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HongYi-Liang/p/8299460.html</guid>
<description>&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ScreenExtraction.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;


ScreenExtract::ScreenExtract()
{

}

ScreenExtract::ScreenExtract(Mat srcMat)
{
    setSrc(srcMat);
}

ScreenExtract::&lt;/span&gt;~&lt;span&gt;ScreenExtract()
{
}
Mat ScreenExtract::getDst()
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_MatDstImageStand;
}

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; ScreenExtract::setSrc(Mat srcMat)
{
    m_MatSrcImage &lt;/span&gt;=&lt;span&gt; srcMat.clone();
    m_MatEdgeImage &lt;/span&gt;=&lt;span&gt; srcMat.clone();
    m_MatHoughImage &lt;/span&gt;=&lt;span&gt; srcMat.clone();
    m_MatCornerImage &lt;/span&gt;=&lt;span&gt; srcMat.clone();
    Mat temp(&lt;/span&gt;&lt;span&gt;1280&lt;/span&gt;,&lt;span&gt;720&lt;/span&gt;&lt;span&gt;,srcMat.type()); 
    m_MatDstImageLie &lt;/span&gt;=&lt;span&gt; temp.clone();
    Mat temp2(&lt;/span&gt;&lt;span&gt;720&lt;/span&gt;,&lt;span&gt;1280&lt;/span&gt;&lt;span&gt;,srcMat.type()); 
    m_MatDstImageStand &lt;/span&gt;=&lt;span&gt; temp2.clone();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}

Mat ScreenExtract::runExtract()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cannyThrel=&lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; failCNT=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        m_MatEdgeImage &lt;/span&gt;=&lt;span&gt; EdgeDection(m_MatEdgeImage,cannyThrel);
        m_MatHoughImage &lt;/span&gt;=&lt;span&gt; HoughLine(m_MatEdgeImage);
        m_MatCornerImage &lt;/span&gt;=&lt;span&gt; CornerHarris(m_MatHoughImage,m_PointPerspectiveSrcBuff);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(failCNT&amp;gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Extract fail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_MatSrcImage;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(m_PointPerspectiveSrcBuff.size() == &lt;span&gt;8&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(m_PointPerspectiveSrcBuff.size()&amp;gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cannyThrel&amp;lt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;)
            {
                cannyThrel&lt;/span&gt;+=&lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
            }
            failCNT&lt;/span&gt;++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(m_PointPerspectiveSrcBuff.size()&amp;lt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cannyThrel&amp;gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
            {
                cannyThrel&lt;/span&gt;-=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
            }
            failCNT&lt;/span&gt;++&lt;span&gt;;
        }
        waitKey(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
    }

    m_MatDstImageLie &lt;/span&gt;=&lt;span&gt; perspectiveChange(m_MatSrcImage,m_PointPerspectiveSrcBuff);
    m_MatDstImageStand &lt;/span&gt;= rotation(m_MatDstImageLie,&lt;span&gt;90&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_MatDstImageStand;
} 
Mat ScreenExtract::runFastExtract(Mat srcMat)
{
    m_MatSrcImage &lt;/span&gt;=&lt;span&gt; srcMat.clone();
    m_MatDstImageLie &lt;/span&gt;=&lt;span&gt; perspectiveChange(m_MatSrcImage,m_PointPerspectiveSrcBuff);
    m_MatDstImageStand &lt;/span&gt;= rotation(m_MatDstImageLie,&lt;span&gt;90&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_MatDstImageStand;

}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;
Mat ScreenExtract::EdgeDection(Mat srcImage,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cannyThrel)
{
    Mat cannyEdge;
    Mat dstImage &lt;/span&gt;=&lt;span&gt; m_MatSrcImage.clone(); 

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;降噪&lt;/span&gt;
    blur(m_MatSrcImage,cannyEdge,Size(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;));
#ifdef DEBUG_SHOW_ScreenExtract
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;namedWindow(&quot;blur()&quot;,CV_WINDOW_AUTOSIZE);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;imshow(Windows_Edge,g_dstImage);&lt;/span&gt;
    imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blur()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,cannyEdge);    
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;运行Canny算子&lt;/span&gt;
    Canny(cannyEdge,cannyEdge,cannyThrel,cannyThrel*&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先将g_dstImage内的所有元素设置为0&lt;/span&gt;
    dstImage = Scalar::all(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Canny算子输出的边缘图g_cannyDetectedEdges作为掩码，来将原图g_srcImage拷贝到目标图g_dstImage中&lt;/span&gt;
&lt;span&gt;    srcImage.copyTo(dstImage,cannyEdge);

#ifdef DEBUG_SHOW_ScreenExtract
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;namedWindow(&quot;EdgeDection()&quot;,CV_WINDOW_AUTOSIZE);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;imshow(Windows_Edge,g_dstImage);&lt;/span&gt;
    imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EdgeDection()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,cannyEdge);    
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cannyEdge;
}

Mat ScreenExtract::HoughLine(Mat srcImage)
{
    Mat dstImage &lt;/span&gt;=&lt;span&gt; srcImage.clone();  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;g_houghWithSrc = g_srcImage.clone(); &lt;/span&gt;
    dstImage = Scalar::all(&lt;span&gt;255&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;houghlinesP
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;vector&amp;lt;Vec4i&amp;gt; mylines;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HoughLinesP(g_cannyDetectedEdges,mylines,1,CV_PI/180,valueA+1,valueB,valueC);&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/循环遍历绘制每一条线段  &lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  for( size_t i = 0; i &amp;lt; mylines.size(); i++ )  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  {  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      Vec4i lines = mylines[i];  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;line（）划线 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      line( dstImage, Point(lines[0], lines[1]), Point(lines[2], lines[3]), Scalar(55,100,195), 1,CV_AA);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CV_AA);  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  }  

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;houghlines&lt;/span&gt;
    vector&amp;lt;Vec2f&amp;gt;&lt;span&gt; mylines;

    HoughLines(srcImage, mylines, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, (CV_PI-&lt;span&gt;0.2&lt;/span&gt;)/&lt;span&gt;180&lt;/span&gt;,srcImage.cols/&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt; );  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HoughLines(g_cannyDetectedEdges, mylines, 1, CV_PI/180, valueA+1, valueB, valueC );  

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;依次在图中绘制出每条线段  &lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;( size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; mylines.size(); i++&lt;span&gt; )  
    {  
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; rho = mylines[i][&lt;span&gt;0&lt;/span&gt;], theta = mylines[i][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];  
        Point pt1, pt2;  
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a = cos(theta), b =&lt;span&gt; sin(theta);  
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; x0 = a*rho, y0 = b*&lt;span&gt;rho;  
        pt1.x &lt;/span&gt;= cvRound(x0 + &lt;span&gt;3000&lt;/span&gt;*(-&lt;span&gt;b));  
        pt1.y &lt;/span&gt;= cvRound(y0 + &lt;span&gt;3000&lt;/span&gt;*&lt;span&gt;(a));  
        pt2.x &lt;/span&gt;= cvRound(x0 - &lt;span&gt;3000&lt;/span&gt;*(-&lt;span&gt;b));  
        pt2.y &lt;/span&gt;= cvRound(y0 - &lt;span&gt;3000&lt;/span&gt;*&lt;span&gt;(a));  
        line( dstImage, pt1, pt2, Scalar(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;), &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, CV_AA);  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;line( g_houghWithSrc, pt1, pt2, Scalar(0,255,0), 1, CV_AA);  &lt;/span&gt;
&lt;span&gt;    }

#ifdef DEBUG_SHOW_ScreenExtract
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示图片
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;imshow(Windows_Hough,dstImage); 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;imshow(Windows_Hough,g_houghLine);&lt;/span&gt;
    imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HoughLine()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,dstImage);
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dstImage;
}


Mat ScreenExtract::CornerHarris( Mat srcImage ,vector&lt;/span&gt;&amp;lt;Point2f&amp;gt;  &amp;amp;&lt;span&gt;vecPoint)  
{  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------【1】定义一些局部变量-----------------------------  &lt;/span&gt;
    Mat g_srcImageClone =&lt;span&gt; m_MatSrcImage.clone() ;
    Mat writeImage(m_MatSrcImage.rows,m_MatSrcImage.cols,m_MatSrcImage.type());
    Mat dstImage;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标图  &lt;/span&gt;
    Mat normImage;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;归一化后的图  &lt;/span&gt;
    Mat scaledImage;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线性变换后的八位无符号整型的图  &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; iCornerThresh = &lt;span&gt;110&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;g_CornerWithHoughWithSrc = g_houghWithSrc;&lt;/span&gt;
    writeImage = Scalar::all(&lt;span&gt;255&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------【2】初始化---------------------------------------  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;置零当前需要显示的两幅图，即清除上一次调用此函数时他们的值  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dstImage = Mat::zeros( srcImage.size(), CV_32FC1 );  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;g_srcImageClone=g_srcImage.clone( );  
  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------【3】正式检测-------------------------------------  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行角点检测  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cornerHarris( g_srcGrayImage, dstImage, 2, 3, 0.04, BORDER_DEFAULT );  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原图角点检测&lt;/span&gt;
    cornerHarris( srcImage, dstImage, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;0.04&lt;/span&gt;, BORDER_DEFAULT );    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;霍夫变换后的角点检测

  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 归一化与转换  &lt;/span&gt;
    normalize( dstImage, normImage, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;&lt;span&gt;, NORM_MINMAX, CV_32FC1, Mat() );  
    convertScaleAbs( normImage, scaledImage );&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将归一化后的图线性变换成8位无符号整型   
  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------【4】进行绘制-------------------------------------  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将检测到的，且符合阈值条件的角点绘制出来  &lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; j = normImage.rows/&lt;span&gt;100&lt;/span&gt;; j &amp;lt; normImage.rows-normImage.rows/&lt;span&gt;100&lt;/span&gt; ; j++&lt;span&gt; )  
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = normImage.cols/&lt;span&gt;100&lt;/span&gt;; i &amp;lt; normImage.cols-normImage.cols/&lt;span&gt;100&lt;/span&gt;; i++&lt;span&gt; )  
        {  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( (&lt;span&gt;int&lt;/span&gt;) normImage.at&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;(j,i) &amp;gt;&lt;span&gt; iCornerThresh  )  
            {  
                circle( g_srcImageClone, Point( i, j ), &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;,  Scalar(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;255&lt;/span&gt;), &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt; );  
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;circle( g_CornerWithHoughWithSrc, Point( i, j ), 5,  Scalar(10,10,255), 2, 8, 0 );  &lt;/span&gt;
                circle( scaledImage, Point( i, j ), &lt;span&gt;10&lt;/span&gt;,  Scalar(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;255&lt;/span&gt;), -&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt; );  
                circle( writeImage, Point( i, j ), &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;,  Scalar(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;255&lt;/span&gt;), -&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ); 
            }  
        }  
    }  
    
    vecPoint &lt;/span&gt;=&lt;span&gt; GatherPoint( writeImage,iCornerThresh);
#ifdef DEBUG_SHOW_ScreenExtract
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------【4】显示最终效果---------------------------------  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;imshow( &quot;CornerHarris&quot;, g_CornerWithHoughWithSrc );  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在原图叠加霍夫图上显示
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;imshow( &quot;CornerHarris&quot;, g_srcImageClone );  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在原图上显示
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;imshow( &quot;CornerHarris&quot;, scaledImage );  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用灰度图显示&lt;/span&gt;
    imshow( &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CornerHarris&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, writeImage );
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; scaledImage;
}  

vector&lt;/span&gt;&amp;lt;Point2f&amp;gt; ScreenExtract::GatherPoint( Mat srcImage, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; CornerThresh ) 
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;imshow( &quot;GatherPoint&quot;, srcImage );
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Mat grayImage=srcImage.clone() ;&lt;/span&gt;
&lt;span&gt;    Mat canny_output;
    Mat grayImage;
    vector&lt;/span&gt;&amp;lt;vector&amp;lt;Point&amp;gt;&amp;gt;&lt;span&gt;contours;
    vector&lt;/span&gt;&amp;lt;Vec4i&amp;gt;&lt;span&gt;hierarchy;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;RNG rng(12345);


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转成灰度图&lt;/span&gt;
&lt;span&gt;    cvtColor(srcImage, grayImage, COLOR_BGR2GRAY);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;canny边缘检测&lt;/span&gt;
    Canny(grayImage, canny_output, &lt;span&gt;50&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;轮廓提取&lt;/span&gt;
    findContours(canny_output, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算图像矩&lt;/span&gt;
    vector&amp;lt;Moments&amp;gt;&lt;span&gt;mu(contours.size());
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (unsigned &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; contours.size(); i++&lt;span&gt;)
    {
        mu[i] &lt;/span&gt;= moments(contours[i], &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算图像的质心&lt;/span&gt;
    vector&amp;lt;Point2f&amp;gt;&lt;span&gt;mc(contours.size());
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (unsigned &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; contours.size(); i++&lt;span&gt;)
    {
        mc[i] &lt;/span&gt;= Point2f(mu[i].m10 / mu[i].m00, mu[i].m01 /&lt;span&gt; mu[i].m00);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制轮廓&lt;/span&gt;
    Mat drawing =&lt;span&gt; Mat::zeros(srcImage.size(), CV_8UC3);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (unsigned &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; contours.size(); i++&lt;span&gt;)
    {
        Scalar color &lt;/span&gt;= Scalar(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        drawContours(drawing, contours, i, color, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, hierarchy, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, Point());
        circle(drawing, mc[i], &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;, color, -&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    }
#ifdef DEBUG_SHOW_ScreenExtract
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;namedWindow(&quot;GatherPoint&quot;, WINDOW_AUTOSIZE);&lt;/span&gt;
    imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GatherPoint&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, drawing);
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
    
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mc;
}


Mat ScreenExtract::perspectiveChange(Mat srcMat,vector&lt;/span&gt;&amp;lt;Point2f&amp;gt;&lt;span&gt; srcBuff)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Mat变量&lt;/span&gt;
&lt;span&gt;    Mat dstMat(srcMat.rows,srcMat.cols,srcMat.type());
    Mat perspectiveMat( &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,CV_32FC1);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;透视变换参数&lt;/span&gt;
    Point2f perspectiveSrcBuff[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
    Point2f perspectiveDesBuff[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;透视变换坐标设置&lt;/span&gt;
    perspectiveSrcBuff[&lt;span&gt;0&lt;/span&gt;] = Point2f((srcBuff[&lt;span&gt;0&lt;/span&gt;].x+srcBuff[&lt;span&gt;1&lt;/span&gt;].x)/&lt;span&gt;2&lt;/span&gt;,(srcBuff[&lt;span&gt;0&lt;/span&gt;].y+srcBuff[&lt;span&gt;1&lt;/span&gt;].y)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) ;  
    perspectiveSrcBuff[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = Point2f((srcBuff[&lt;span&gt;2&lt;/span&gt;].x+srcBuff[&lt;span&gt;3&lt;/span&gt;].x)/&lt;span&gt;2&lt;/span&gt;,(srcBuff[&lt;span&gt;2&lt;/span&gt;].y+srcBuff[&lt;span&gt;3&lt;/span&gt;].y)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) ;   
    perspectiveSrcBuff[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = Point2f((srcBuff[&lt;span&gt;4&lt;/span&gt;].x+srcBuff[&lt;span&gt;5&lt;/span&gt;].x)/&lt;span&gt;2&lt;/span&gt;,(srcBuff[&lt;span&gt;4&lt;/span&gt;].y+srcBuff[&lt;span&gt;5&lt;/span&gt;].y)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) ;
    perspectiveSrcBuff[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = Point2f((srcBuff[&lt;span&gt;6&lt;/span&gt;].x+srcBuff[&lt;span&gt;7&lt;/span&gt;].x)/&lt;span&gt;2&lt;/span&gt;,(srcBuff[&lt;span&gt;6&lt;/span&gt;].y+srcBuff[&lt;span&gt;7&lt;/span&gt;].y)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) ;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求变换后坐标&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;3&lt;/span&gt;;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;==&lt;span&gt; getPointPlace(srcMat,perspectiveSrcBuff[i]) )
        {
            perspectiveDesBuff[i] &lt;/span&gt;= Point2f( &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);  
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt; ==&lt;span&gt; getPointPlace(srcMat,perspectiveSrcBuff[i]) )
        {
            perspectiveDesBuff[i] &lt;/span&gt;= Point2f( &lt;span&gt;0&lt;/span&gt;, static_cast&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;(dstMat.rows-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));         
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt; ==&lt;span&gt; getPointPlace(srcMat,perspectiveSrcBuff[i]) )
        {
            perspectiveDesBuff[i] &lt;/span&gt;= Point2f( static_cast&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;(dstMat.cols-&lt;span&gt;1&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;); 
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt; ==&lt;span&gt; getPointPlace(srcMat,perspectiveSrcBuff[i]) )
        {
            perspectiveDesBuff[i] &lt;/span&gt;= Point2f( static_cast&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;(dstMat.cols-&lt;span&gt;1&lt;/span&gt;), static_cast&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;(dstMat.rows-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
        }
    }
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求透视变换&lt;/span&gt;
    perspectiveMat =&lt;span&gt; getPerspectiveTransform( perspectiveSrcBuff, perspectiveDesBuff );  

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对源图像应用刚刚的透视变换&lt;/span&gt;
&lt;span&gt;    warpPerspective(srcMat, dstMat, perspectiveMat, dstMat.size());

#ifdef DEBUG_SHOW_ScreenExtract
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示&lt;/span&gt;
    imshow( &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;perspectiveChange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, dstMat );
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dstMat;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ScreenExtract::getPointPlace(Mat srcImage,Point2f point)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(point.x &amp;lt; srcImage.cols/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(point.y &amp;lt; srcImage.rows/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(point.y &amp;lt; srcImage.rows/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;; 
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
        }    
    }
}


Mat ScreenExtract::rotation(Mat srcMat,&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; degree)
{
    Mat dstImage(srcMat.rows,srcMat.cols,srcMat.type());
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; max(srcMat.cols, srcMat.rows);
    Point2f pt(len&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;.f,len/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.f);
    Mat r &lt;/span&gt;= getRotationMatrix2D(pt,degree,&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);
    warpAffine(srcMat,dstImage,r,Size(srcMat.rows,srcMat.cols));

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dstImage;
}&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 16 Jan 2018 15:58:00 +0000</pubDate>
<dc:creator>HongYi_Liang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HongYi-Liang/p/8299460.html</dc:identifier>
</item>
<item>
<title>nodejs+express+mysql实现restful风格的增删改查示例 - thinkam</title>
<link>http://www.cnblogs.com/thinkam/p/8299452.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thinkam/p/8299452.html</guid>
<description>&lt;p&gt;首先，放上项目github地址：&lt;a href=&quot;https://github.com/codethereforam/express-mysql-demo&quot; class=&quot;uri&quot;&gt;https://github.com/codethereforam/express-mysql-demo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;之前学的java，一直用的ssm框架写后台。前段时间接触到node.js，于是花了两天时间学了一下node.js并写了一个CRUD简单示例。由于前几天一直学用github pages搭建&lt;a href=&quot;https://codethereforam.github.io&quot;&gt;博客&lt;/a&gt;，一直没时间写README，今天有空补了上来。&lt;/p&gt;
&lt;p&gt;下面来内容自于项目的&lt;a href=&quot;https://github.com/codethereforam/express-mysql-demo/blob/master/README.md&quot;&gt;README&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;二项目介绍&quot;&gt;二、项目介绍&lt;/h2&gt;
&lt;p&gt;基于node.js + express + mysql实现的restful风格的CRUD简单示例&lt;/p&gt;
&lt;h3 id=&quot;组织结构&quot;&gt;2.1 组织结构&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;├── app.js -- 应用配置
├── bin
│   └── www -- 项目运行脚本
├── conf 
│   └── mysqlConf.js -- mysql配置文件
├── dao
│   ├── userDAO.js -- 封装和数据库的交互
│   └── userSqlMap.js -- SQL语句封装
├── model
│   └── result.js -- 返回结果对象封装
├── package.json -- 依赖模块
├── project-datamodel
│   └── user.sql -- 数据库脚本
├── public -- 前端静态页面
│   ├── add.html
│   ├── css
│   │   └── style.css
│   ├── detail.html
│   ├── index.html
│   └── modify.html
└── routes
    └── users.js -- 用户操作路由及业务逻辑&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;模块依赖&quot;&gt;2.2 模块依赖&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;www -&amp;gt; app.js -&amp;gt; users.js -&amp;gt;  userDAO.js -&amp;gt; mysqlConf.js &amp;amp; userSqlMap.js&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;技术选型&quot;&gt;2.3 技术选型&lt;/h3&gt;
&lt;p&gt;后端技术&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;node.js&lt;/li&gt;
&lt;li&gt;express&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前端技术&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;angular.js&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三环境搭建&quot;&gt;三、环境搭建&lt;/h2&gt;
&lt;h2 id=&quot;四项目运行&quot;&gt;四、项目运行&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;下载代码并部署&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;git clone https://github.com/codethereforam/express-mysql-demo.git
cd express-mysql-demo &amp;amp;&amp;amp; npm install   #安装部署依赖的包&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;新建express-mysql-demo数据库，导入project-datamodel文件夹下的user.sql&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修改conf/mysqlConf.js中数据库配置信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;# 切换到项目根路径
npm start&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;打开首页: &lt;a href=&quot;http://localhost:8888&quot; class=&quot;uri&quot;&gt;http://localhost:8888&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;五开发过程及代码分析&quot;&gt;五、开发过程及代码分析&lt;/h2&gt;
&lt;p&gt;关于restful，可参考阮一峰的两篇文章：&lt;/p&gt;
&lt;p&gt;我使用的IDE是IDEA，安装&quot;NodeJS&quot;插件后依次点击&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;File -&amp;gt; New Project -&amp;gt; Node.js and NPM -&amp;gt; Node.js Express App&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IDEA默认使用express-generator生成项目结构。&lt;/p&gt;
&lt;p&gt;新建数据库&quot;express-mysql-demo&quot;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;database&lt;/span&gt; `express-mysql-demo`;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新建user表:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;TABLE&lt;/span&gt; `express-mysql-demo`.`user` (
  `id` &lt;span class=&quot;dt&quot;&gt;INT&lt;/span&gt; UNSIGNED &lt;span class=&quot;kw&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; AUTO_INCREMENT,
  `username` &lt;span class=&quot;dt&quot;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;45&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;,
  `password` &lt;span class=&quot;dt&quot;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;45&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;,
  &lt;span class=&quot;kw&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;KEY&lt;/span&gt; (`id`))
&lt;span class=&quot;kw&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;SET&lt;/span&gt; = utf8mb4;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表结构：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;+&lt;span class=&quot;co&quot;&gt;----------+------------------+------+-----+---------+----------------+&lt;/span&gt;
| Field    | &lt;span class=&quot;kw&quot;&gt;Type&lt;/span&gt;             | &lt;span class=&quot;kw&quot;&gt;Null&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;Key&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;Default&lt;/span&gt; | Extra          |
+&lt;span class=&quot;co&quot;&gt;----------+------------------+------+-----+---------+----------------+&lt;/span&gt;
| &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt;       | &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;) unsigned | &lt;span class=&quot;kw&quot;&gt;NO&lt;/span&gt;   | PRI | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;    | auto_increment |
| username | &lt;span class=&quot;dt&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;45&lt;/span&gt;)      | &lt;span class=&quot;kw&quot;&gt;NO&lt;/span&gt;   |     | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;    |                |
| &lt;span class=&quot;kw&quot;&gt;password&lt;/span&gt; | &lt;span class=&quot;dt&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;45&lt;/span&gt;)      | &lt;span class=&quot;kw&quot;&gt;NO&lt;/span&gt;   |     | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;    |                |
+&lt;span class=&quot;co&quot;&gt;----------+------------------+------+-----+---------+----------------+&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mysql配置文件conf/mysqlConf.js:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;module&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'localhost'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'root'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'express-mysql-demo'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 最大连接数，默认为10&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;connectionLimit&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SQL语句封装模块dao/userSqlMap.js:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; userSqlMap &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'insert into user(username, password) values(?, ?)'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;deleteById&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'delete from user where id = ?'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'update user set username=?, password=? where id=?'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'select * from user'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;getById&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'select * from user where id = ?'&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;封装返回结果对象model/result.js:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;exports&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createResult&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(success&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; data) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{};&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;success&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; success&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; result&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我这里使用了工厂方法创建结果对象，对象有两个属性，success代表用户操作成功或失败，data存放后台要返回的数据。&lt;/p&gt;
&lt;p&gt;下面分析修改用户部分信息的相关代码，全部的增删改查代码请将项目clone下来查看。&lt;/p&gt;
&lt;p&gt;封装和数据库的交互模块dao/userDAO.js:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; pool &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;mysql&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createPool&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;mysqlConf&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;mysql&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;module&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;dt&quot;&gt;getById&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (id&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; callback) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;pool&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;userSqlMap&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getById&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; id&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (error&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; result) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (error) &lt;span class=&quot;cf&quot;&gt;throw&lt;/span&gt; error&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(result[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;at&quot;&gt;callback&lt;/span&gt;(result[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (user&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; callback) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;pool&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;userSqlMap&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; [&lt;span class=&quot;va&quot;&gt;user&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;user&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;user&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;id&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (error&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; result) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (error) &lt;span class=&quot;cf&quot;&gt;throw&lt;/span&gt; error&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;at&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;affectedRows&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用了连接池，重复使用数据库连接，而不必每执行一次CRUD操作就获取、释放一次数据库连接，从而提高了对数据库操作的性能。&lt;/p&gt;
&lt;p&gt;用户操作路由及实现业务逻辑routes/users.js:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;/* patch users */&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;router&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;patch&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/:id'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (req&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; res) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'patch users called'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;userDAO&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getById&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;req&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;params&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (user) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; username &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;req&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;body&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(username) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;user&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;username&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; username&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; password &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;req&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;body&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(password) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;user&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;password&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; password&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(user)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;userDAO&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;update&lt;/span&gt;(user&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (success) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; r &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createResult&lt;/span&gt;(success&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;json&lt;/span&gt;(r)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;router根据不同的HTTP请求方法和访问路径执行相应的回调函数，回调函数中先记录日志，然后检查用户传过来的数据，接着调用userDAO的相应CRUD方法，最后返回一个JSON对象给前端。这里修改用户部分信息对应HTTP方法是PATCH，而修改全部信息对应的是PUT。&lt;/p&gt;
&lt;p&gt;应用配置app.js中配置用户操作相关的路由:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;use&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/users'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; users)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端public/index.html中与后台交互的JS代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (window) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;angular&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;module&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'list'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; [])
                .&lt;span class=&quot;at&quot;&gt;controller&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'listCtrl'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; ($scope&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; $http) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;                
                    &lt;span class=&quot;va&quot;&gt;$scope&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;doPatch&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (id) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;JSON&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;stringify&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;dt&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;pwd&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; id).&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt;
                        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;va&quot;&gt;$http&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;patch&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/users/&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; id&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; data)
                            .&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (response) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                                &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;debug&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;data&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;success&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                            &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (err) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                                &lt;span class=&quot;at&quot;&gt;alert&lt;/span&gt;(err)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
                &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)(window)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端使用angualr.js，ajax异步调用后端restful API，然后解析后台返回的JSON对象在界面上展示。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 15:55:00 +0000</pubDate>
<dc:creator>thinkam</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/thinkam/p/8299452.html</dc:identifier>
</item>
<item>
<title>垃圾回收（GC） 的基本算法 - 行者酱油君</title>
<link>http://www.cnblogs.com/makor/p/base-algorithm-for-gc.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/makor/p/base-algorithm-for-gc.html</guid>
<description>&lt;p&gt;GC 作为一个长久的话题，从诞生[1]至今也算是经历了六七十年了，对于很多习惯于使用 Java/Python 的同学来说，对于内存的管理可能会稍微更陌生一些，因为这些语言在语言层面就屏蔽了内存的分配和管理，帮助我们减少了超多的麻烦。但是，在帮助我们减少麻烦的同时，也带来了很多问题，其中一个就是内存爆掉，这个问题有可能是代码写得不好，有可能是设计不好，反正就是存在这个问题。&lt;/p&gt;
&lt;p&gt;本文不准备细究这些问题，本文旨在介绍一些内存回收的基本算法，通过这些基本算法，从而介绍一下这些自动内存管理语言底层管理内存的一些套路，从而在平时使用它们的时候可以依照它们的尿性来编写代码，减少一些内存管理方面的 Bug。&lt;/p&gt;
&lt;p&gt;反观这么多年来，GC 虽然发展了这么久，从古老的 Lisp 到新一些的 Go 语言，垃圾回收的基本算法都没有太大的创新，一方面说明了这些算法的强大，另外一方面也说明了这里还有很大的挖掘空间给爱好者们/专家们去思考，挖掘出新的基本算法。本文就对这些年一直被各种编程语言直接使用/配合使用的几种垃圾回收算法进行一个总结介绍，顺便介绍一下他们的优缺点。&lt;/p&gt;
&lt;h3 id=&quot;toc_0&quot;&gt;垃圾回收算法的性能点&lt;/h3&gt;
&lt;p&gt;为什么会存在那么多的垃圾回收算法呢？我想这个问题的答案可能是没有任何一种内存回收算法是完美的，所以在针对不同的情景需求下，不同的内存回收算法有其独特的优势，所以最后就延续了多种回收算法。那么，在平时的大多数情况下，有哪些性能考虑点是我们关注的呢，下面就列举一下常见的性能指标&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;吞吐量：回收固定内存需要的时间&lt;/li&gt;
&lt;li&gt;最大暂停时间：回收过程中需要暂停代码执行的时间&lt;/li&gt;
&lt;li&gt;内存使用效率：真正用于逻辑的内存占总内存的比例&lt;/li&gt;
&lt;li&gt;访问的局部性：与计算机各项缓存的友好程度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然这不是所有的关注指标，但是这些却是大部分情况下被关注的指标。而且，需要注意的是，这里面有一些指标是互斥的，例如我们会发现，最大吞吐量和最大暂停时间往往无法得到双赢，也就是说无法同时满足这两项的最优。所以，在选择具体的回收算法的时候，其实就是在这些指标之间进行权衡，然后根据自己的需求进行选择。下面就对常见的三种基本回收算法进行介绍。&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;基本 GC 算法&lt;/h3&gt;
&lt;h4 id=&quot;toc_2&quot;&gt;1. 标记-清除&lt;/h4&gt;
&lt;p&gt;标记-清除算法是一个比较经典的算法了，在标记-清除算法中，一般都是有所谓的根对象，而且一般来说根对象都不止一个，有很多，以 C 语言来理解的话，我们可以理解成分配在栈中的对象和全局对象都是所谓的根对象。标记-清除算法从这些所谓的 &lt;strong&gt;根对象&lt;/strong&gt; 出发，进行第一个阶段——标记阶段，也就是将这些 &lt;strong&gt;根对象&lt;/strong&gt; 能够引用到的那些对象都作上标记，一般的做法是每个对象都有一个字段用于标识是否被标记，当然还有很多其他的做法，例如专门弄一张表来表示对象的标记等，这些都是后话啦，反正这个阶段就只做一件事情，那就是找出被使用的对象，作上标记，这样没有被标记的对象也就是不用的对象了。&lt;/p&gt;
&lt;p&gt;在第一阶段标记完之后，那么进入&lt;strong&gt;标记-清除&lt;/strong&gt;的第二个阶段——清除阶段，清除阶段其实也就是所谓的释放阶段，无非就是把不使用的对象所占用的内存释放掉，然后回收起来这么简单。&lt;/p&gt;
&lt;p&gt;看上去标记-清除算法还是比较简单的，但是，这个简单背后也是有很多需要思考的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对象的内存分配和对象的内存回收策略&lt;/li&gt;
&lt;li&gt;从根对象开始标记对象的方式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是两个比较常见的问题。第一个问题，对象的内存分配问题，假设现在我们的语言需要创建一个对象，那么自然需要分配一块内存给它，怎么分配这个内存呢？一个可能的做法就是从上次分配的位置往后直接分配一块，这样保证每次分配的内存都是往高位走，内存地址逐渐叠加。但是，这种方法带来了一个问题，那就是释放的时候就很尴尬了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/469840/201801/469840-20180116233402115-1424911312.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;假设这里有一段内存，按照刚才的策略分配了 A、B 和 C 三个对象，当程序运行一段时间之后，我们想回收掉对象 B，然后回收之后发现现在的内存是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/469840/201801/469840-20180116233402131-1984764229.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这个时候，我们想再分配一个对象 D，那么不巧，D 的大小就比 B 大那么一点，所以原来 B 的位置不足以容纳 D，所以也就不能使用 B 原来的位置，那么这样的话，内存结构可能就成了这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/469840/201801/469840-20180116233402162-1286448507.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;长此以往，我们会发现内存就会有一个一个的洞，碎片化会很严重，导致内存的利用率逐渐下降。同时，因为这里的内存是一块一块的，所以我们用链表来保存它的时候，分配内存查找又是一个问题，所以就很麻烦。&lt;/p&gt;
&lt;p&gt;此外，周期性得标记对象，从而会周期性得改变对象的微小数据，所以导致操作系统 COW 体系不能得到较好的运用，从而导致性能的缺失。这是一方面，前面还有一个问题，那就是我们标记对象的时候以怎么样的顺序来查找活动对象，常见的查找方式有&lt;strong&gt;深度优先查找&lt;/strong&gt; 和 &lt;strong&gt;广度优先查找&lt;/strong&gt;，这两种查找在性能上可能没有太大区别，但是，对于临时空间的占用却是有较大的影响，所以一般来说，&lt;strong&gt;深度优先&lt;/strong&gt;比&lt;strong&gt;广度优先&lt;/strong&gt;更能压低内存使用量，所以经常使用的是&lt;strong&gt;深度优先搜索&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;虽然有缺点，但是&lt;strong&gt;标记-清除&lt;/strong&gt;的优点也是比较明显的，例如实现起来还是比较简单的，与保守式 GC 是兼容的，使得 &lt;strong&gt;标记-清除&lt;/strong&gt; 算法在实际应用中还是得到大家的青睐的。&lt;/p&gt;
&lt;h4 id=&quot;toc_3&quot;&gt;2. 引用计数&lt;/h4&gt;
&lt;p&gt;除了&lt;strong&gt;标记-清除&lt;/strong&gt;算法外，&lt;strong&gt;引用计数&lt;/strong&gt; 也是一种不错的方法，&lt;strong&gt;引用计数算法&lt;/strong&gt; 顾名思义就是在对象中额外记录自身被引用的次数，当次数减小到 0 的时候那么就知道自己已经没有用处了，可以被回收了。也是一种很简单很直观的方式，可以在对象不被使用的时候立刻回收掉内存，从而将垃圾回收的时间分散化，也不需要像 &lt;strong&gt;标记-清除&lt;/strong&gt; 一样需要进行遍历查找。&lt;/p&gt;
&lt;p&gt;但是这也带来了一定程度的麻烦，例如，我们需要使用内存屏障管理引用计数，对象的生成、赋值和引用都涉及引用计数的变化，从而导致引用计数的增减处理频繁；同时，因为引用计数的存在，我们还需要在对象的自身数据之外，为引用计数分配固定的空间来存放计数，这是固有损耗。还有一个致命的缺点就是，使用&lt;strong&gt;引用计数算法&lt;/strong&gt;，无法清除 &lt;strong&gt;循环引用&lt;/strong&gt; 的问题，从而导致内存一直占用，无法释放。&lt;/p&gt;
&lt;h4 id=&quot;toc_4&quot;&gt;3. GC 复制&lt;/h4&gt;
&lt;p&gt;前面介绍的两种方法都是在对象本身上操作的，也就是说清除和释放都是操作对象本身所在的位置，但是，&lt;strong&gt;GC 复制算法&lt;/strong&gt; 就稍微复杂一些了，&lt;strong&gt;GC 复制算法&lt;/strong&gt; 最原始的做法就是将内存一分为二，每次只使用其他一半，当要 GC 的时候就将使用着的一半中的活动对象复制到另外一半中，然后清理掉这一半中的所有对象，直接使用另外一半即可，重复这个操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/469840/201801/469840-20180116233402224-1972642811.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这个我们一眼就可以看出问题，那就是空间的利用率不高，但是，好处也是非常明显的，首先是速度快，没有额外的标记-清理操作，就是直接的复制，高吞吐；分配对象直接分配，不需要考虑碎片化问题；还可以保持与 OS 的缓存兼容，优势还是比较明显的。然而，硬币总有正反面，除了空间利用率不高之外，这种方法不兼容保守式的 GC 算法，此外，对于递归调用还会有栈溢出的风险。&lt;/p&gt;
&lt;p&gt;所以为了更好得完善了这个算法，还有有很多改进思路被提出的，例如不是将空间划分为两部分，而是划分为多个部分，从而提升空间的利用率就是其中的一个思路。&lt;/p&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文就常见的三种垃圾回收基本算法以及经常需要考虑的几个性能指标进行介绍，从而为了解垃圾回收开一个头。其实看各种编程语言的 GC 实现都会发现本文中基本算法的身影，无非就是它们直接如何组合，所以，理解本文中的基本算法对于理解其他编程语言的 GC 实现还是很有帮助的。&lt;/p&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;Garbage Collection&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 16 Jan 2018 15:34:00 +0000</pubDate>
<dc:creator>行者酱油君</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/makor/p/base-algorithm-for-gc.html</dc:identifier>
</item>
<item>
<title>移动web开发之touch事件 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8293225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8293225.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　iOS版Safari为了向开发人员传达一些特殊信息，新增了一些专有事件。因为iOS设备既没有鼠标也没有键盘，所以在为移动Safari开发交互性网页时，常规的鼠标和键盘事件根本不够用。随着Android 中的WebKit的加入，很多这样的专有事件变成了事实标准，导致W3C开始制定Touch Events规范。本文将详细介绍移动端touch事件&lt;/p&gt;

&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;　　包含iOS 2.0软件的iPhone 3G发布时，也包含了一个新版本的Safari浏览器。这款新的移动Safari提供了一些与触摸(touch)操作相关的新事件。后来，Android上的浏览器也实现了相同的事件。触摸事件会在用户手指放在屏幕上面时、在屏幕上滑动时或从屏幕上移开时触发。具体来说，有以下几个触摸事件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;touchstart:当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发
touchmove:当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用preventDefault()可以阻止滚动
touchend:当手指从屏幕上移开时触发
touchcancel:当系统停止跟踪触摸时触发(不常用)。关于此事件的确切触发时间，文档中没有明确说明&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【touchenter 和 touchleave】&lt;/p&gt;
&lt;p&gt;　　触摸事件规范中曾经包含touchenter和touchleave事件，这两个事件在用户手指移入或移出某个元素时触发。但是这两个事件从来没有被实现。微软有这两个事件的替代事件，但是只有IE浏览器支持。某些情况下可以知道用户手指滑入滑出某个元素是素是非常有用的，所以希望这两个事件可以重返规范&lt;/p&gt;
&lt;p&gt;　　在触摸事件中，常用的是touchstart、touchumove和touchend这三个事件，与鼠标事件的对应如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;鼠标         触摸          
mousedown   touchstart 
mousemove   touchmove   
mouseup     touchend     &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　[注意]touch事件在chrome模拟器下部分版本使用DOM0级事件处理程序的方式来添加事件无效&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;meta http-equiv=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X-UA-Compatible&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ie=edge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;&lt;span&gt;
    #test{height:200px;width:200px;background:lightblue;}
  &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
  (function(){ 
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; 
      stateMap &lt;/span&gt;=&lt;span&gt; {
        touchstart_index : &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        touchmove_index  : &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        touchend_index   : &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
      },
      elesMap &lt;/span&gt;=&lt;span&gt; {
        touch_obj: document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
      },
      showIndex, handleTouch;

    showIndex &lt;/span&gt;=&lt;span&gt; function ( type ) {
      elesMap.touch_obj.innerHTML &lt;/span&gt;= type + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + (++stateMap[type + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);
    };

    handleTouch &lt;/span&gt;= function ( &lt;span&gt;event&lt;/span&gt;&lt;span&gt; ) {
      showIndex( &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;&lt;span&gt;.type );
    };

    elesMap.touch_obj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function(&lt;span&gt;event&lt;/span&gt;){handleTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);}); 
    elesMap.touch_obj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchmove&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function(&lt;span&gt;event&lt;/span&gt;){handleTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);});
    elesMap.touch_obj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchend&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function(&lt;span&gt;event&lt;/span&gt;){handleTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);});
  })(); 

&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;300ms&lt;/h3&gt;
&lt;p&gt;　　300ms问题是指在某个元素执行它的功能和执行touch事件之间有一个300毫秒的间隔。鼠标事件、焦点事件、浏览器默认行为等相较于touch事件，都存在着300ms的延迟&lt;/p&gt;
&lt;p&gt;【点透】&lt;/p&gt;
&lt;p&gt;　　因为300ms的存在，会造成常见的点透问题。先来看例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;meta http-equiv=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X-UA-Compatible&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ie=edge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;&lt;span&gt;
    #test {position: absolute;top: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;;left: &lt;span&gt;0&lt;/span&gt;;opacity: &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;height: 200px;width: 200px;background: lightblue;}
  &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;百度&amp;lt;/a&amp;gt;
  &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;script&amp;gt;&lt;span&gt;
    (function () {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;
        elesMap &lt;/span&gt;=&lt;span&gt; {
          touchObj: document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        fnHide, onTouch;
      fnHide &lt;/span&gt;=&lt;span&gt; function (type) {
        elesMap.touchObj.style.display &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
      };
      onTouch &lt;/span&gt;= function (&lt;span&gt;event&lt;/span&gt;&lt;span&gt;) {
        fnHide();
      };
      elesMap.touchObj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function(&lt;span&gt;event&lt;/span&gt;){onTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);});
    })(); 
  &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　浅蓝色的半透明div被点击(触发touch事件)后，如果点击位置正好位于链接的上方，则会触发链接跳转的默认行为。详细解释是，点击页面后，浏览器会记录所点击的页面坐标，300ms后，在该坐标找到元素。在该元素上触发点击行为。因此，如果300ms内同一页面坐标的上层元素消失后，300ms后在下层元素上触发点击行为。这就造成了点透问题&lt;/p&gt;

&lt;p&gt;　　造成这个问题，是因为触摸屏幕的行为被重载(overload)了。在手指触摸屏幕的瞬间，浏览器无法预知用户是在轻触(Tap)、双触(Double-Tap)、滑动(Swipe)、按住不放(Hold)还是其他什么操作。唯一保险的做法就是等上一会儿看接下来会发生什么&lt;/p&gt;
&lt;p&gt;　　问题是在于双触(Double-Tap)。即便是浏览器检测出手指离开了屏幕，它仍然无法判断接下来做什么。因为浏览器无法知道手指是会再次回到屏幕，还是就此结束触发轻触事件以及事件级联。为了确定这一点，浏览器不得不等待一小段时间。浏览器开发者找到一个最佳时间间隔，就是300毫秒&lt;/p&gt;
&lt;p&gt;【解决办法】&lt;/p&gt;
&lt;p&gt;　　1、在touch事件的事件处理程序中增加300ms的延迟&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    (function () {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;
        elesMap &lt;/span&gt;=&lt;span&gt; {
          touchObj: document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        fnHide, onTouch;
      fnHide &lt;/span&gt;=&lt;span&gt; function (type) {
        elesMap.touchObj.style.display &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
      };
      onTouch &lt;/span&gt;= function (&lt;span&gt;event&lt;/span&gt;&lt;span&gt;) {
        setTimeout(function(){
          fnHide();
        },30&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
      };
      elesMap.touchObj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function (&lt;span&gt;event&lt;/span&gt;) { onTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;); });
    })(); &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、使用缓动动画，增加300ms的过渡效果，注意display属性无法使用transition&lt;/p&gt;
&lt;p&gt;　　3、加入中间层的dom元素，让中间层接受这个穿透事件，稍后隐藏&lt;/p&gt;
&lt;p&gt;　　4、上下两级都使用tap事件，但默认行为不可避免&lt;/p&gt;
&lt;p&gt;　　5、在document上的touchstart事件，阻止默认行为。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
document.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(e){
    e.preventDefault();
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着，添加a标签的跳转行为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
a.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(){
  window.location.href &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://cnblogs.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;  
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但是，这种方法有副作用，会造成页面无法滚动、文本无法选中等。如果在某个元素上，需要恢复文本选中的行为，则可以使用阻止冒泡来恢复&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
el.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(e){
    e.stopPropagation();
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;事件对象&lt;/h3&gt;
&lt;p&gt;【基础信息】&lt;/p&gt;
&lt;p&gt;　　每个触摸事件的event对象都提供了在鼠标事件中常见的属性，包括事件类型、事件目标对象、事件冒泡、事件流、默认行为等&lt;/p&gt;
&lt;p&gt; 　　以touchstart为例，示例代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &amp;lt;script&amp;gt;&lt;span&gt;
    (function () {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;
        elesMap &lt;/span&gt;=&lt;span&gt; {
          touchObj: document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        onTouch;
      onTouch &lt;/span&gt;=&lt;span&gt; function (e) {
          console.log(e)
    };
      elesMap.touchObj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function (&lt;span&gt;event&lt;/span&gt;) { onTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;); });
    })(); 
  &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1、currentTarget属性返回事件正在执行的监听函数所绑定的节点&lt;/p&gt;
&lt;p&gt;　　2、target属性返回事件的实际目标节点&lt;/p&gt;
&lt;p&gt;　　3、srcElement属性与target属性功能一致&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前目标&lt;/span&gt;
currentTarget:[&lt;span&gt;object&lt;/span&gt;&lt;span&gt; HTMLDivElement]
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实际目标&lt;/span&gt;
target:[&lt;span&gt;object&lt;/span&gt;&lt;span&gt; HTMLDivElement]
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实际目标&lt;/span&gt;
srcElement:[&lt;span&gt;object&lt;/span&gt; HTMLDivElement]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、eventPhase属性返回一个整数值，表示事件目前所处的事件流阶段。0表示事件没有发生，1表示捕获阶段，2表示目标阶段，3表示冒泡阶段&lt;/p&gt;
&lt;p&gt;　　5、bubbles属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性&lt;/p&gt;
&lt;p&gt;　　6、cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;事件流&lt;/span&gt;
eventPhase: &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可冒泡&lt;/span&gt;
bubbles: &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认事件可取消&lt;/span&gt;
cancelable: &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【touchList】&lt;/p&gt;
&lt;p&gt;　　除了常见的DOM属性外，触摸事件对象有一个touchList数组属性，其中包含了每个触摸点的信息。如果用户使用四个手指触摸屏幕，这个数组就会有四个元素。一共有三个这样的数组&lt;/p&gt;
&lt;p&gt;　　1、touches：当前触摸屏幕的触摸点数组（至少有一个触摸在事件目标元素上）&lt;/p&gt;
&lt;p&gt;　　2、changedTouches ：导致触摸事件被触发的触摸点数组&lt;/p&gt;
&lt;p&gt;　　3、targetTouches：事件目标元素上的触摸点数组&lt;/p&gt;
&lt;p&gt;　　如果用户最后一个手指离开屏幕触发touchend事件，这最后一个触摸点信息不会出现在targetTouches和touches数组中，但是会出现在changedTouched数组中。因为是它的离开触发了touchend事件，所以changedTouches数组中仍然包含它。上面三个数组中，最常用的是changedTouches数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    (function () {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;
        elesMap &lt;/span&gt;=&lt;span&gt; {
          touchObj: document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        onTouch;
      onTouch &lt;/span&gt;=&lt;span&gt; function (e) {
          elesMap.touchObj.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;touches:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; e.touches.length
                                    &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;changedTouches:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; e.changedTouches.length
                                    &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;targetTouches:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; e.targetTouches.length;
      };
      elesMap.touchObj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function (&lt;span&gt;event&lt;/span&gt;) { onTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;); });
    })(); &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【事件坐标】&lt;/p&gt;
&lt;p&gt;　　上面这些触摸点数组中的元素可以像普通数组那样用数字索引。数组中的元素包含了触摸点的有用信息，尤其是坐标信息。每个Touch对象包含下列属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;clientx:触摸目标在视口中的x坐标
clientY:触摸目标在视口中的y坐标
identifier:标识触摸的唯一ID
pageX:触摸目标在页面中的x坐标（包含滚动）
pageY:触摸目标在页面中的y坐标（包含滚动）
screenX:触摸目标在屏幕中的x坐标
screenY:触摸目标在屏幕中的y坐标
target:触摸的DOM节点目标&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　changedTouches数组中的第一个元素就是导致事件触发的那个触摸点对象(通常这个触摸点数组不包含其他对象)。这个触摸点对象含有clientX/Y和pageX/Y坐标信息。除此之外还有screenX/Y和x/y，这些坐标在浏览器间不太一致，不建议使用&lt;/p&gt;
&lt;p&gt;　　clientX/Y和pageX/Y的区别在于前者相对于视觉视口的左上角，后者相对于布局视口的左上角。布局视口是可以滚动的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    (function () {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;
        elesMap &lt;/span&gt;=&lt;span&gt; {
          touchObj: document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        onTouch;
      onTouch &lt;/span&gt;=&lt;span&gt; function (e) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; touch = e.changedTouches[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
        elesMap.touchObj.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;clientX:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + touch.clientX + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;clientY:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; touch.clientY
          &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;pageX:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + touch.pageX + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;pageY:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; touch.pageY
          &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;screenX:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + touch.screenX + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;screenY:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; touch.screenY
      };
      elesMap.touchObj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function (&lt;span&gt;event&lt;/span&gt;) { onTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;); });
    })(); &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Tue, 16 Jan 2018 14:38:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8293225.html</dc:identifier>
</item>
<item>
<title>设计模式---代理模式 - Dan_Go</title>
<link>http://www.cnblogs.com/daniels/p/8242592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daniels/p/8242592.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;       &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;代理模式的定义：&lt;/strong&gt;代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。&lt;/p&gt;
&lt;p&gt;举个例子来说明：假如说我现在想买一辆二手车，虽然我可以自己去找车源，做质量检测等一系列的车辆过户流程，但是这确实太浪费我得时间和精力了。我只是想买一辆车而已为什么我还要额外做这么多事呢？于是我就通过中介公司来买车，他们来给我找车源，帮我办理车辆过户流程，我只是负责选择自己喜欢的车，然后付钱就可以了。用图表示如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1071931/201801/1071931-20180108134122472-1822105846.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;中介隔离作用：&lt;/strong&gt;&lt;/span&gt;在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;开闭原则，增加功能：&lt;/strong&gt;&lt;/span&gt;代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;       我们有多种不同的方式来实现代理。如果按照代理创建的时期来进行分类的话， 可以分为两种：静态代理、动态代理。静态代理是由程序员创建或特定工具自动生成源代码，在对其编译。在程序员运行之前，代理类.class文件就已经被创建了。动态代理是在程序运行时通过反射机制动态创建的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.静态代理&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;第&lt;/strong&gt;&lt;strong&gt;一步：创建服务类接口&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; main.java.proxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * @Date: 22:40 2018/1/9 0009
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BuyHouse {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; buyHosue();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;第二步：实现服务接口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.java.proxy.BuyHouse;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * @Date: 22:42 2018/1/9 0009
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BuyHouseImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BuyHouse {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; buyHosue() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;我要买房&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第三步：创建代理类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; main.java.proxy.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.java.proxy.BuyHouse;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * @Date: 22:43 2018/1/9 0009
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BuyHouseProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BuyHouse {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; BuyHouse buyHouse;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; BuyHouseProxy(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; BuyHouse buyHouse) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.buyHouse =&lt;span&gt; buyHouse;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; buyHosue() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         System.out.println(&quot;买房前准备&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        buyHouse.buyHosue();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         System.out.println(&quot;买房后装修&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第四步：编写测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.java.proxy.impl.BuyHouseImpl;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.java.proxy.impl.BuyHouseProxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Auther: dan gao
 * @Description:
 * @Date: 22:43 2018/1/9 0009
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProxyTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        BuyHouse buyHouse &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BuyHouseImpl();
        buyHouse.buyHosue();
        BuyHouseProxy buyHouseProxy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BuyHouseProxy(buyHouse);
        buyHouseProxy.buyHosue();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;静态代理总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。&lt;/p&gt;
&lt;p&gt;缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。&lt;span&gt;&lt;strong&gt;                                             &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;_mce_tagged_br&quot;&gt;&lt;span&gt;&lt;strong&gt;2.动态代理&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一步：编写动态处理器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; main.java.proxy.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * @Date: 20:34 2018/1/12 0012
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DynamicProxyHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object object;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; DynamicProxyHandler(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object object) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.object =&lt;span&gt; object;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         System.out.println(&quot;买房前准备&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         Object result =&lt;span&gt; method.invoke(object, args);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         System.out.println(&quot;买房后装修&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二步：编写测试类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; main.java.proxy.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.java.proxy.BuyHouse;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.java.proxy.impl.BuyHouseImpl;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.java.proxy.impl.DynamicProxyHandler;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * @Date: 20:38 2018/1/12 0012
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DynamicProxyTest {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         BuyHouse buyHouse = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BuyHouseImpl();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(BuyHouse.&lt;span&gt;class&lt;/span&gt;.getClassLoader(), &lt;span&gt;new&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 Class[]{BuyHouse.&lt;span&gt;class&lt;/span&gt;}, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DynamicProxyHandler(buyHouse));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        proxyBuyHouse.buyHosue();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注意&lt;span&gt;&lt;em&gt;&lt;span&gt;Proxy.newProxyInstance()&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;方&lt;span&gt;法接受三个参&lt;/span&gt;数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;code&gt;ClassLoader loader&lt;/code&gt;:&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;指定当前目标对象使用的类加载器,获取加载器的方法是固定的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;code&gt;Class&amp;lt;?&amp;gt;[] interfaces&lt;/code&gt;:&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;指定目标对&lt;span&gt;象实现的接口的类型,使用泛型方式确认类型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;em&gt;&lt;code&gt;&lt;span&gt;InvocationHandler:&lt;/span&gt;&lt;/code&gt;&lt;/em&gt;&lt;/span&gt;&lt;code&gt;指定&lt;/code&gt;&lt;code&gt;动态处理器，&lt;/code&gt;执行&lt;span&gt;目标对象的方法时,会触发事件处理器的方法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;动态代理总结：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;3.CGLIB代理&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;       JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一步：创建CGLIB代理类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; dan.proxy.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.Enhancer;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.MethodInterceptor;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.MethodProxy;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * @Date: 20:38 2018/1/16 0016
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CglibProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MethodInterceptor {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object getInstance(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object target) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         Enhancer enhancer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         enhancer.setSuperclass(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.target.getClass());
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         enhancer.setCallback(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; enhancer.create();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         System.out.println(&quot;买房前准备&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         Object result =&lt;span&gt; methodProxy.invoke(object, args);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         System.out.println(&quot;买房后装修&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二步：创建测试类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; dan.proxy.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.proxy.BuyHouse;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.proxy.impl.BuyHouseImpl;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.proxy.impl.CglibProxy;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * @Date: 20:52 2018/1/16 0016
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CglibProxyTest {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         BuyHouse buyHouse = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BuyHouseImpl();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         CglibProxy cglibProxy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CglibProxy();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         BuyHouseImpl buyHouseCglibProxy =&lt;span&gt; (BuyHouseImpl) cglibProxy.getInstance(buyHouse);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        buyHouseCglibProxy.buyHosue();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;CGLIB代理总结： &lt;/span&gt;&lt;/strong&gt;CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 13:34:00 +0000</pubDate>
<dc:creator>Dan_Go</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daniels/p/8242592.html</dc:identifier>
</item>
<item>
<title>【干货】分享几个写 demo 的思路 - 韩子迟</title>
<link>http://www.cnblogs.com/zichi/p/8298888.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zichi/p/8298888.html</guid>
<description>&lt;p&gt;好久没有动笔，最近发现了一个新的写 demo 的思路，非常有意思。仔细一想，自己仿佛积累了不少写 demo 的思路和想法，总结一下，抛砖引玉。&lt;/p&gt;
&lt;p&gt;本文所说 demo 主要分以下三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本地 demo&lt;/li&gt;
&lt;li&gt;外链 demo&lt;/li&gt;
&lt;li&gt;文章中带 demo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;楼主在工作和学习中是比较喜欢写 demo 的，抛出问题非常直观。&lt;/p&gt;
&lt;p&gt;本地写 demo，爱咋整就可以咋整，简单到可以只有一个 HTML 文件，复杂到引入 React / Vue 等框架类库，视情况而定。对于楼主来说，多数情况下是一个 HTML 文件就可以搞定的。最方便的情况下，直接新建个 HTML 文件，然后起一个本地 server 即可，本地 server 可以用 Python、PHP 等起，对于前端来说，&lt;a href=&quot;https://www.npmjs.com/package/http-server&quot;&gt;http-server&lt;/a&gt; 是个不错的选择，然后再配置个 alias，比如我在 &lt;code&gt;.zshrc&lt;/code&gt; 中配置 &lt;code&gt;alias s=&quot;http-server&quot;&lt;/code&gt;，可以秒启。如果是稍微复杂的情况，需要些许调试，那么修改后自动刷新是必须的，我写了一个简单的脚手架 &lt;a href=&quot;https://github.com/hanzichi/jsj/tree/master/gulp-simple&quot;&gt;gulp-simple&lt;/a&gt; 可以满足这个需求。但是我比较懒，觉得这样还不太方便，毕竟需要编辑器和浏览器两边切换查看效果（单屏的情况下），有时只是查看一个简单的 css 特性，这样搞就显得麻烦了，我又给自己开发了两个简单的在线编辑器，分别是 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/codeMirror/&quot;&gt;html editor1&lt;/a&gt; 以及 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/ace/&quot;&gt;html editor2&lt;/a&gt;，方便调试简单的 html 页面。&lt;/p&gt;
&lt;p&gt;本地 demo 大概三个方式，总结下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本地新建 HTML 文件，双击启动或者本地启 server&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&quot;https://github.com/hanzichi/jsj/tree/master/gulp-simple&quot;&gt;gulp-simple&lt;/a&gt;（需要简单调试的页面）&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/codeMirror/&quot;&gt;html editor1&lt;/a&gt; 或者 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/ace/&quot;&gt;html editor2&lt;/a&gt; 在线编辑以及调试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你写了个炫酷的页面，希望分享给别人，如果把 HTML 文件发给别人，显然不是一个好的想法，最简单的方式就是将文件上传到服务器，发送链接给别人，也正是接下去要说的外链 demo。&lt;/p&gt;
&lt;p&gt;最方便的选择是选择第三方服务，类似 &lt;a href=&quot;https://codepen.io/&quot;&gt;codepen&lt;/a&gt; 或者 &lt;a href=&quot;https://jsfiddle.net/&quot;&gt;jsfiddle&lt;/a&gt;，国内的 &lt;a href=&quot;http://runjs.cn/&quot;&gt;runjs&lt;/a&gt; 也做的不错可以试试。（这些网站均有很多不错的 demo，可以看看实现）&lt;/p&gt;
&lt;p&gt;因为个人是重度 GitHub 用户，自从知道 GitHub Pages 这玩意后，一般的外链 demo 都放在那了，所以 GitHub Pages 也不失为一个好的选择。（&lt;a href=&quot;https://github.com/hanzichi/hanzichi.github.io&quot;&gt;点这里&lt;/a&gt; 看我的全部 demo）&lt;/p&gt;
&lt;p&gt;说到 GitHub Pages，其实 GitHub 中的 repo 中的静态 HTML 页面也是可以查看效果的（归根结底还是 GitHub Pages），通常用来生成项目主页等。具体设置在具体 repo 的 Settings -&amp;gt; Options -&amp;gt; GitHub Pages 中，选择分支（一般是 master branch 即可），点击 save 即可，比如我在 codedog 项目中生成的 &lt;a href=&quot;https://hanzichi.github.io/codedog/demo/demo.html&quot;&gt;demo&lt;/a&gt;。还有另一个方法，进入 &lt;a href=&quot;https://htmlpreview.github.io/&quot;&gt;GitHub &amp;amp; BitBucket HTML Preview&lt;/a&gt; 这个网站，生成静态页面链接，但是只适用于只有一个 HTML 页面的场景，如果有引用 css 的话路径会错误。&lt;/p&gt;
&lt;p&gt;另外，如果有自己的服务器，那么很显然部署到自己的服务器就可以了。&lt;/p&gt;
&lt;p&gt;外链 demo 同样大概三个方式，总结下：&lt;/p&gt;

&lt;p&gt;重点重点，这才是本文的重点！&lt;/p&gt;
&lt;p&gt;有的时候写文章，需要配个简单的 demo，怎么破？外链当然可以，但是没有直接显示在文章中显得直观。&lt;/p&gt;
&lt;p&gt;首先， &lt;a href=&quot;https://codepen.io/&quot;&gt;codepen&lt;/a&gt; / &lt;a href=&quot;https://jsfiddle.net/&quot;&gt;jsfiddle&lt;/a&gt; / &lt;a href=&quot;http://runjs.cn/&quot;&gt;runjs&lt;/a&gt; 应该都是支持 iframe 插入页面的，但是我一般不这么做，首先 iframe 加载可能会太慢影响体验，其次依赖于第三方总觉得不安全，而且很多的第三方服务并不一定支持 iframe 的插入。&lt;/p&gt;
&lt;p&gt;然后以前用新页面打开来查看页面效果，可以看下很久前写的 &lt;a href=&quot;http://www.cnblogs.com/zichi/p/4214557.html&quot;&gt;这篇文章&lt;/a&gt;，核心和 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/codeMirror/&quot;&gt;html editor1&lt;/a&gt; 以及 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/ace/&quot;&gt;html editor2&lt;/a&gt; 两个在线编辑器的新页面预览的实现一致，即新建个窗口：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;runCode&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; code &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;editor&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getValue&lt;/span&gt;()
  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; handler &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;)
  &lt;span class=&quot;va&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;opener&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;write&lt;/span&gt;(code)
  &lt;span class=&quot;va&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;()
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是惊讶地发现在博客园该方式已经失效！我猜测 &lt;code&gt;window.open('')&lt;/code&gt; 被博客园给过滤掉了，所以这个方案基本已经完蛋。以前在博客园看到过页面中直接显示 css 效果的，我猜测实现应该是一样，直接混入了 html 代码，自从接触 markdown 后，我便完全抛弃了富文本编辑器，所以总觉得这样的实现有点 &quot;脏&quot;，但是一直苦于没有一个好的实现。&lt;/p&gt;
&lt;p&gt;我理想中的状态是，可以用 markdown 写文章，但是文章中有些代码可以查看 HTML 效果。最后，我开发了 &lt;a href=&quot;https://github.com/hanzichi/codedog&quot;&gt;codedog&lt;/a&gt; 这个工具，用 markdown 写文章，自动生成 html 文件，比如我前段时间在看 《CSS 揭秘》这本书，我用 markdown 做笔记，用 codedog 生成的 HTML 可以方便查看 CSS 效果，而且支持在线编辑，简直是爽，具体实现效果可以 &lt;a href=&quot;https://github.com/hanzichi/hanzichi.github.io/blob/master/css-secret/README.md&quot;&gt;点击这里&lt;/a&gt; 查看。&lt;/p&gt;
&lt;p&gt;但是 codedog 这个工具是为了这个需求量身定做的，有一定的局限性，有时候要实现文章中带 demo 的效果，不得不在 markdown 和 HTML 中取舍，比如我之前为了学习 flex 写的 &lt;a href=&quot;https://hanzichi.github.io/2017/flex/index.html&quot;&gt;这个 demo&lt;/a&gt;，是纯 HTML 写的，且存在一定的特殊性（不可复用）&lt;/p&gt;
&lt;p&gt;最后就要说到文章开头说的 “发现了一个新的写 demo 的思路”，做到首尾呼应，是什么呢？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;通过设置 style 标签的 display:block 样式可以让页面的 style 标签显示出来，并且加上 contentEditable 属性后可以让样式成为可编辑状态，更改后的样式效果也是实时更新呈现，这就给交互创造了新的可能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前的实现如果页面有样式，并且修改样式直接预览（类似 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/codeMirror/&quot;&gt;html editor1&lt;/a&gt; 或者 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/ace/&quot;&gt;html editor2&lt;/a&gt; ），其实实现是获取 value 然后再插入 HTML 文档流中，而通过设置 style 标签的 display:block 样式，操作的就是实际的样式，不需要拐弯抹角。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/675542/201801/675542-20180116213105928-77063177.gif&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;style&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; style=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;display:block&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; contentEditable&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
      body &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;blue&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写了个简单的 &lt;a href=&quot;https://hanzichi.github.io/test-case/style-display-block/&quot;&gt;demo&lt;/a&gt; 可以看下，确实是另一种思路。&lt;/p&gt;
&lt;p&gt;所以说，&quot;文章中带 demo&quot; 所说的 &quot;文章&quot; 实现，可能是 HTML 的，也可能是 markdown 的，具体如何，需要视情况而定了。&lt;/p&gt;
&lt;p&gt;总结下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果是 markdown 写的文章（如果需要涉及 inline 的 demo），最后肯定是要编译成 HTML 预览，思路类似 codedog&lt;/li&gt;
&lt;li&gt;如果直接用 HTML 写文章，类似 &lt;a href=&quot;https://hanzichi.github.io/2017/flex/index.html&quot;&gt;这个&lt;/a&gt;，那么我觉得复用性其实不是很高，毕竟交互方式是不一样的（也可以没有交互），这个时候（如果有交互），可以试试 &lt;code&gt;&amp;lt;style style=&quot;display:block&quot; contentEditable&amp;gt;&lt;/code&gt; 这种方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结就不总结了，都在上面了，如果有补充，热烈欢迎 👏&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 13:25:00 +0000</pubDate>
<dc:creator>韩子迟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zichi/p/8298888.html</dc:identifier>
</item>
<item>
<title>大话python面向对象 - 古墓派掌门</title>
<link>http://www.cnblogs.com/qflyue/p/8298555.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qflyue/p/8298555.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　师门中每逢成人礼就要下山历练一番，小掌门今年成人礼，下山也有一段时日。可恰逢年底，今年百姓收成都不是很好，各大店铺也很少招人，再加上学艺不精，小掌门无事可做就只能饿肚子了。后来小掌门饿的实在不行，只好沿街乞讨。其时惨状如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180116155952881-430066042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;初识面向对象&lt;/h2&gt;
&lt;p&gt;　　就这样每天风吹日晒地乞讨,后来小掌门发现自己每天所获得的馒头都比其他同行的小乞丐少好多，他发现其他小乞丐都有自己的广告语，然后小掌门稍一改进，便成了如下模样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180116160944912-972626044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每次要饭前小掌门都在地上写上几个字&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def beg():#定义一个要饭函数
    print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    beg()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就这样，小掌门的馒头比以往多了起来，时不时也分点馒头给其他乞丐。&lt;/p&gt;
&lt;p&gt;　　一天，过来一个老叫花对小掌门说：“孩子啊，你这样每天要饭前还得找个树枝在地上写一遍字，其实你可以自己做个招牌啊，就跟那人一样”，老叫花指了指对面走过来的另一个乞讨的年轻人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180116162018006-1028504962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小掌门一拍脑门，是啊，我做一个招牌就不用每次都写一遍了，小掌门找了一块破木板，在上面好好提了几笔&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger:
    def __init__(self,name,age,money):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
        self.money&lt;/span&gt;=&lt;span&gt;money
    def beg(self):  # 定义一个要饭函数
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)



&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    zm&lt;/span&gt;=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
    zm.beg()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180116163501037-1063714383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;老叫花见小掌门挺聪明，笑着说：“看来你已经理解面向对象了”。&lt;/p&gt;
&lt;p&gt;“前辈，什么叫面向对象啊”，小掌门瞪着水汪汪的大眼睛问道。&lt;/p&gt;
&lt;p&gt;“说起面向对象，还得从面向过程说起”&lt;/p&gt;

&lt;h2&gt;面向对象vs面向过程&lt;/h2&gt;
&lt;p&gt;面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的设计就好比精心设计好一条流水线，考虑周全什么时候处理什么东西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点是：极大的降低了写程序的复杂度，只需要顺着要执行的步骤，堆叠代码即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点是：一套流水线或者流程就是用来解决一个问题，代码牵一发而动全身。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用场景：一旦完成基本很少改变的场景，著名的例子有Linux內核，git，以及Apache HTTP Server等。&lt;/p&gt;

&lt;p&gt;面向对象的程序设计的核心是对象（上帝式思维），要理解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，不存在的也可以创造出来。面向对象的程序设计好比如来设计西游记，如来要解决的问题是把经书传给东土大唐，如来想了想解决这个问题需要四个人：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象的属性和方法），然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与妖魔鬼怪神仙互相缠斗着直到最后取得真经。如来根本不会管师徒四人按照什么流程去取。&lt;/p&gt;
&lt;p&gt;面向对象的程序设计的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点是：解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：可控性差，无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题&lt;/strong&gt;，&lt;strong&gt;即便是上帝也无法预测最终结果。于是我们经常看到一个游戏人某一参数的修改极有可能导致阴霸的技能出现，一刀砍死3个人，这个游戏就失去平衡。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。&lt;/p&gt;
&lt;p&gt;在python 中面向对象的程序设计并不是全部。&lt;/p&gt;
&lt;p&gt;面向对象编程可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使它人更加容易理解你的代码逻辑，从而使团队开发变得更从容。&lt;/p&gt;
&lt;p&gt;了解一些名词：类、对象、实例、实例化&lt;/p&gt;
&lt;p&gt;类：具有相同特征的一类事物(人、狗、老虎)&lt;/p&gt;
&lt;p&gt;对象／实例：具体的某一个事物（隔壁阿花、楼下旺财）&lt;/p&gt;
&lt;p&gt;实例化：类——&amp;gt;对象的过程（这在生活中表现的不明显，我们在后面再慢慢解释）&lt;/p&gt;

&lt;h3&gt;类的声明&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #&lt;span&gt;class&lt;/span&gt;&lt;span&gt; 类名:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; #    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;类的文档字符串&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#    类体
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#如：
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    def __init__(self,name,age,money):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self.name=&lt;span&gt;name
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.age=&lt;span&gt;age
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         self.money=&lt;span&gt;money
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    def beg(self):  # 定义一个要饭函数
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         print(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在对象实例化时，会自动调用__init__函数，完成对象初识化，相当于c++，java中的构造函数&lt;/p&gt;
&lt;p&gt;上述代码定义了一个Begger类，在&lt;strong&gt;实例化对象&lt;/strong&gt;时，会自动初始化name，age，money&lt;strong&gt;实例属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面提到两个名词‘&lt;strong&gt;实例化对象&lt;/strong&gt;’，‘&lt;strong&gt;实例属性&lt;/strong&gt;’，下面我一一道来&lt;/p&gt;
&lt;h4&gt;实例化对象&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
类名加括号就是实例化，会自动触发__init__函数的运行，可以用它来为每个实例定制自己的特征
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
zm=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;实例属性与类属性及私有属性&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
　　&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：实例属性：

　　　　最好在__init__(self,...)中初始化

　　　　内部调用时都需要加上self.

　　　　外部调用时用instancename.propertyname

　　&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:类属性：

　　　　在__init__()外初始化

　　　　在内部用classname.类属性名调用

　　　　外部既可以用classname.类属性名又可以用instancename.类属性名来调用

　　&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;：私有属性：

　　　　&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）：单下划线_开头：只是告诉别人这是私有属性，外部依然可以访问更改

　　　　&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）：双下划线__开头：外部不可通过instancename.propertyname来访问或者更改

　　　　　　实际将其转化为了_classname__propertyname&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如我们在乞丐类（Begger）中加一个count类属性，用来计算小乞丐的个数，每个小乞丐加一个婚姻状况（marriage）私有属性：&lt;/p&gt;
&lt;p&gt;(内心戏：没钱还想结婚，做梦吧)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     count=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  #这是一个类属性
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     def __init__(self,name,age,money,single=&lt;span&gt;True):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.name=&lt;span&gt;name #实例属性
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         self.age=&lt;span&gt;age
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self.money=&lt;span&gt;money
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self._single=&lt;span&gt;True #私有属性
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Begger.count+=&lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    def beg(self):  # 定义一个要饭函数
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         print(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     zm=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    zm.beg()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小乞丐个数：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%Begger.count)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;类方法与静态方法&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
　　&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：普通类方法：

　　　　def fun_name(self,...):

　　　　　　pass

　　　　外部用实例调用

　　&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：静态方法：@staticmethod            

　　　　　　不能访问实例属性！！！   参数不能传入self！！！

　　　　　　与类相关但是不依赖类与实例的方法！！

　　&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;:类方法：@classmethod

　　　　　　不能访问实例属性！！！   参数必须传入cls！！！

　　　　　　必须传入cls参数（即代表了此类对象&lt;/span&gt;-----区别------&lt;span&gt;self代表实例对象），并且用此来调用类属性：cls.类属性名

　　&lt;/span&gt;*静态方法与类方法都可以通过类或者实例来调用。其两个的特点都是不能够调用实例属性
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     count=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  #这是一个类属性
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     def __init__(self,name,age,money,single=&lt;span&gt;True):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.name=&lt;span&gt;name #实例属性
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         self.age=&lt;span&gt;age
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self.money=&lt;span&gt;money
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self._single=&lt;span&gt;True #私有属性
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Begger.count+=&lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    def beg(self):  # 定义一个要饭函数，普通类方法
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         print(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    def beg_skill():#定义一个乞讨技巧函数，静态方法
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乞讨技巧&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    @classmethod
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    def beg_counter(cls):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小乞丐个数：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; Begger.count)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     zm=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    zm.beg()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    zm.beg_skill()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     Begger.beg_counter()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;tip：类属性与类方法是类固有的方法与属性，不会因为实例不同而改变，写他们的目的是减少多实例时所创造出来的内存空间，加快运行速度&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;封装、继承、多态&lt;/h2&gt;
&lt;p&gt;&quot;封装、继承、多态并称为类的三大特性，也是面向对象的一个主要特点&quot;老叫花说道“下面我就一一跟你讲”&lt;/p&gt;

&lt;h4&gt;封装&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“&lt;em&gt;封装在于明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者的代码；而外部使用用者只知道一个接口(函数)，只要接口（函数）名、参数不变，使用者的代码永远无需改变。这就提供一个良好的合作基础——或者说，只要接口这个基础约定不变，则代码改变不足为虑。你用的那个乞讨类中的乞讨技巧就是很好的体现，别人只看到你表现出的乞讨的形式，并不知道你在背后所做的何种工作&lt;/em&gt;” 老叫花意味深长地说。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;property特性&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
property是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;将一个类的函数定义成特性以后，对象再去使用的时候obj.name,根本无法察觉自己的name是执行了一个函数然后计算出来的，这种特性的使用方式遵循了统一访问的原则


ps：面向对象的封装有三种方式:
【&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;】
这种其实就是不封装,是对外公开的
【&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;】
这种封装方式对外不公开,但对朋友(friend)或者子类公开
【&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;】
这种封装对谁都不公开&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;python并没有在语法上把它们三个内建到自己的class机制中，在C++或java里一般会将所有的所有的数据都设置为私有的，然后提供set和get方法（接口）去设置和获取，在python中通过property方法可以实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用法如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger:
    count&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  #这是一个类属性
    def __init__(self,name,age,money,single&lt;/span&gt;=&lt;span&gt;True):
        self._name&lt;/span&gt;=&lt;span&gt;name
        self._age&lt;/span&gt;=&lt;span&gt;age
        self._money&lt;/span&gt;=&lt;span&gt;money
        self._single&lt;/span&gt;=&lt;span&gt;True #私有属性
        Begger.count&lt;/span&gt;+=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    def beg(self):  # 定义一个要饭函数，普通类方法
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    @property
    def age(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._age

    @age.setter
    def age(self,value):
        self._age&lt;/span&gt;=&lt;span&gt;value

    @age.deleter
    def age(self):
        del self._age
    @staticmethod
    def beg_skill():#定义一个乞讨技巧函数，静态方法
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乞讨技巧&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    @classmethod
    def beg_counter(cls):
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小乞丐个数：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; Begger.count)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    zm&lt;/span&gt;=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
    print(zm.age)#获取年龄属性
    zm.age&lt;/span&gt;=&lt;span&gt;20&lt;/span&gt;&lt;span&gt;#设置年龄属性
    print(zm.age)
    del zm.age#删除年龄属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;继承&lt;/h4&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;
&lt;pre readability=&quot;6&quot;&gt;
继承，以通用的类为基础建立专门的类对象&lt;p&gt;继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类，父类又可称为基类或超类，新建的类称为派生类或子类&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“说起继承，老叫花子我可就有话说了，什么叫继承，就是儿子继承老子的东西。‘龙生龙，凤生凤，老鼠的儿子会打洞’。虽然说古人有云，‘王侯将相宁有种乎’ ，但有钱真的可以为所欲为，地主的儿子生下来就会继承老子的东西成为富二代，跟咱们这些臭要饭的就不一样了。我来给你举几个例子 ”&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person: #定义一个人类
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     def __init__(self,name,age,money,single=&lt;span&gt;True):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         self.name=&lt;span&gt;name #实例属性
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.age=&lt;span&gt;age
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         self.money=&lt;span&gt;money
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self._single=&lt;span&gt;True #私有属性
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger(Person):#定义一个乞丐类，继承Person
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     # count=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  #这是一个类属性
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    def beg(self):  # 定义一个要饭函数，普通类方法
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         print(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    def beg_skill():#定义一个乞讨技巧函数，静态方法
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乞讨技巧&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    # @classmethod
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    # def beg_counter(cls):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     #     print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小乞丐个数：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; Begger.count)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     zm=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    zm.beg()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    zm.beg_skill()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     # Begger.beg_counter()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;tip：用已经有的类建立一个新的类，这样就重用了已经有的软件中的一部分设置大部分，大大生了编程工作量，这就是常说的软件重用，不仅可以重用自己的类，也可以继承别人的，比如标准库，来定制新的数据类型，这样就是大大缩短了软件开发周期，对大型软件开发来说，意义重大.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在python3中，子类新建与父类重名的方法叫重写，子类执行父类的方法也可以直接用super方法（这些与c++，java类似），如我们重写一下子类init方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     def __init__(self,name,age,money,single=&lt;span&gt;True):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         self.name=&lt;span&gt;name #实例属性
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.age=&lt;span&gt;age
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         self.money=&lt;span&gt;money
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self._single=&lt;span&gt;True #私有属性
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger(Person):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     count=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  #这是一个类属性
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    #重写父类__init__
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     def __init__(self,name,age,money,single=&lt;span&gt;True):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        super(Begger,self).__init__(name,age,money,single)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        #或者
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        # Person.__init__(self,name,age,money,single)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Begger.count+=&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;         
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    def beg(self):  # 定义一个要饭函数，普通类方法
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         print(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @property
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    def age(self):
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._age
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    @age.setter
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    def age(self,value):
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         self._age=&lt;span&gt;value
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    @age.deleter
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    def age(self):
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        del self._age
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    def beg_skill():#定义一个乞讨技巧函数，静态方法
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乞讨技巧&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    @classmethod
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    def beg_counter(cls):
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小乞丐个数：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; Begger.count)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     zm=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    zm.beg_counter()
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     zm.beg_skill()
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;抽象类与接口类&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;继承有两种用途：

一：继承基类的方法，并且做出自己的改变或者扩展（代码重用）  

二：声明某个子类兼容于某基类，定义一个接口类Interface，接口类中定义了一些接口名（就是函数名）且并未实现接口的功能，子类继承接口类，并且实现接口中的功能&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Alipay:
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    支付宝支付
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    def pay(self,money):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;支付宝支付了%s元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;money)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Applepay:
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    apple pay支付
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    def pay(self,money):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;apple pay支付了%s元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;money)


def pay(payment,money):
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    支付函数，总体负责支付
    对应支付的对象和要支付的金额
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    payment.pay(money)


p &lt;/span&gt;=&lt;span&gt; Alipay()
pay(p,&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开发中容易出现的问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Alipay:
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    支付宝支付
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    def pay(self,money):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;支付宝支付了%s元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;money)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Applepay:
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    apple pay支付
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    def pay(self,money):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;apple pay支付了%s元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;money)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Wechatpay:
    def fuqian(self,money):
        &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;        实现了pay的功能，但是名字不一样
        &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;        print(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;微信支付了%s元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;money)

def pay(payment,money):
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    支付函数，总体负责支付
    对应支付的对象和要支付的金额
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    payment.pay(money)


p &lt;/span&gt;=&lt;span&gt; Wechatpay()
pay(p,&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;)   #执行会报错
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接口初成：手动报异常：NotImplementedError来解决开发中遇到的问题&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Payment:
    def pay(self):
        raise NotImplementedError

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Wechatpay(Payment):
    def fuqian(self,money):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;微信支付了%s元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;money)


p &lt;/span&gt;=&lt;span&gt; Wechatpay()  #这里不报错
pay(p,&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;)      #这里报错了
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;借用abc模块来实现接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; abc import ABCMeta,abstractmethod

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Payment(metaclass=&lt;span&gt;ABCMeta):
    @abstractmethod
    def pay(self,money):
        pass


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Wechatpay(Payment):
    def fuqian(self,money):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;微信支付了%s元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;money)

p &lt;/span&gt;= Wechatpay() #不调就报错了
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实践中，继承的第一种含义意义并不很大，甚至常常是有害的。因为它使得子类与基类出现强耦合。&lt;/p&gt;
&lt;p&gt;继承的第二种含义非常重要。它又叫“接口继承”。&lt;br/&gt;接口继承实质上是要求“做出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理实现了特定接口的所有对象”——这在程序设计上，叫做归一化。&lt;/p&gt;
&lt;p&gt;归一化使得高层的外部使用者可以不加区分的处理所有接口兼容的对象集合——就好象linux的泛文件概念一样，所有东西都可以当文件处理，不必关心它是内存、磁盘、网络还是屏幕（当然，对底层设计者，当然也可以区分出“字符设备”和“块设备”，然后做出针对性的设计：细致到什么程度，视需求而定）。&lt;/p&gt;
&lt;p&gt;在python中根本就没有一个叫做interface的关键字，上面的代码只是看起来像接口，其实并没有起到接口的作用，子类完全可以不用去实现接口 ，如果非要去模仿接口的概念，可以借助第三方模块&lt;/p&gt;
&lt;h4&gt;抽象类&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;与java一样，python也有抽象类的概念但是同样需要借助模块实现，&lt;strong&gt;抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0f219eca-8258-4a89-b2e1-b8991a8fc292')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_0f219eca-8258-4a89-b2e1-b8991a8fc292&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0f219eca-8258-4a89-b2e1-b8991a8fc292&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0f219eca-8258-4a89-b2e1-b8991a8fc292',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0f219eca-8258-4a89-b2e1-b8991a8fc292&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#一切皆文件
import abc #利用abc模块实现抽象类

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; All_file(metaclass=&lt;span&gt;abc.ABCMeta):
    all_type&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    @abc.abstractmethod #定义抽象方法，无需实现功能
    def read(self):
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;子类必须定义读功能&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        pass

    @abc.abstractmethod #定义抽象方法，无需实现功能
    def write(self):
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;子类必须定义写功能&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        pass

# &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Txt(All_file):
#     pass
#
# t1&lt;/span&gt;=&lt;span&gt;Txt() #报错,子类没有定义抽象方法

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Txt(All_file): #子类继承抽象类，但是必须定义read和write方法
    def read(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;文本数据的读取方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    def write(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;文本数据的读取方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sata(All_file): #子类继承抽象类，但是必须定义read和write方法
    def read(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;硬盘数据的读取方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    def write(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;硬盘数据的读取方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Process(All_file): #子类继承抽象类，但是必须定义read和write方法
    def read(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;进程数据的读取方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    def write(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;进程数据的读取方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

wenbenwenjian&lt;/span&gt;=&lt;span&gt;Txt()

yingpanwenjian&lt;/span&gt;=&lt;span&gt;Sata()

jinchengwenjian&lt;/span&gt;=&lt;span&gt;Process()

#这样大家都是被归一化了,也就是一切皆文件的思想
wenbenwenjian.read()
yingpanwenjian.write()
jinchengwenjian.read()

print(wenbenwenjian.all_type)
print(yingpanwenjian.all_type)
print(jinchengwenjian.all_type)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;python中实现抽象类&lt;/span&gt;&lt;/div&gt;



&lt;h3&gt;多态&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
多态指的是一类事物有多种形态
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
    def __init__(self,name,age,money,single&lt;/span&gt;=&lt;span&gt;True):
        self.name&lt;/span&gt;=&lt;span&gt;name #实例属性
        self.age&lt;/span&gt;=&lt;span&gt;age
        self.money&lt;/span&gt;=&lt;span&gt;money
        self._single&lt;/span&gt;=&lt;span&gt;True #私有属性
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; landlord(Person):
    def __init__(self):
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是一个地主&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; prince(Person):
    def __init__(self):
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是一个王子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger(Person):#乞丐类
    count&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  #这是一个类属性

    #重写父类__init__
    def __init__(self,name,age,money,single&lt;/span&gt;=&lt;span&gt;True):
        super(Begger,self).__init__(name,age,money,single)
        #或者
        # Person.__init__(self,name,age,money,single)
        Begger.count&lt;/span&gt;+=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    def beg(self):  # 定义一个要饭函数，普通类方法
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    @property
    def age(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._age

    @age.setter
    def age(self,value):
        self._age&lt;/span&gt;=&lt;span&gt;value

    @age.deleter
    def age(self):
        del self._age
    @staticmethod
    def beg_skill():#定义一个乞讨技巧函数，静态方法
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乞讨技巧&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    @classmethod
    def beg_counter(cls):
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小乞丐个数：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; Begger.count)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    zm&lt;/span&gt;=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
    zm.beg_counter()
    zm.beg_skill()
    wz&lt;/span&gt;=&lt;span&gt;prince()
    dz&lt;/span&gt;=landlord()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;鸭子类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Python崇尚鸭子类型，即‘如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子’&lt;/p&gt;
&lt;p&gt;python程序员通常根据这种行为来编写程序。例如，如果想编写现有对象的自定义版本，可以继承该对象&lt;/p&gt;
&lt;p&gt;也可以创建一个外观和行为像，但与它无任何关系的全新对象，后者通常用于保存程序组件的松耦合度。&lt;/p&gt;







&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;“以上就是面向对象的解释了，小家伙可还满意”老叫花拍了拍酒葫芦道&lt;/p&gt;
&lt;p&gt;“前辈你懂这么多为什么还是一个要饭的啊”&lt;/p&gt;
&lt;p&gt;“其实我以前跟他一样”说着，老叫花指了指对面的那个年轻人&lt;/p&gt;
&lt;p&gt;“前辈，你再给我讲点其他的呗”&lt;/p&gt;
&lt;p&gt;“好好，回头老叫花我慢慢给你讲点其他的，不过你得给我弄点酒。。。。。。。。。。。。”&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 12:08:00 +0000</pubDate>
<dc:creator>古墓派掌门</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qflyue/p/8298555.html</dc:identifier>
</item>
</channel>
</rss>