<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>通过案例了解Hystrix的各种基本使用方式 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/9399209.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/9399209.html</guid>
<description>&lt;h4&gt; 1 通过一些算术题了解系统发生错误的概率&lt;/h4&gt;
&lt;p&gt;    我们一般用每秒查询率（Query Per Second，简称QPS）来衡量一个网站的流量，QPS是指一台服务器在一秒里能处理的查询次数，它可以被用来衡量服务器的性能。&lt;/p&gt;
&lt;p&gt;    假设一个Web应用有20个基于微服务的子模块，比如某电商系统里有订单、合同管理和会员管理等子模块，该系统的平均QPS是1000，也就是说平均每秒有1000个访问量，这个数值属于中等水平，并不高。&lt;/p&gt;
&lt;p&gt;    算术题一，请计算每天的访问总量？注：一般网站在凌晨1点到上午9点的访问量比较少，所以计算时按每天16个小时算。&lt;/p&gt;
&lt;p&gt;    答：1000*60*60*16=57600000=5.76乘以10的8次方。&lt;/p&gt;
&lt;p&gt;    算术题二：由于该系统中有20个子模块，在处理每次请求时，该模块有99.9999%的概率不出错（百万分之一的出错概率，这个概率很低了），而任何一个模块出错，整个系统就出错，那么问题是，每小时该系统出错的概率是多少？每天（按16小时算）是多少？每月（按30天算）又是多少？&lt;/p&gt;
&lt;p&gt;    答：针对每次访问，一个模块正常工作的概率是99.9999%，那么每小时20个模块都不出错的概率是99.9999%的（20*3600）次方，大约是93%，换句话说，在一个小时内，该系统出错的概率是7%。&lt;/p&gt;
&lt;p&gt;    我们再来算每天的正常工作概率，是93%的16次方，大约是31%，换句话说，每天出错的概率高达69%。同理我们能算出，每月出错的概率高达95%。&lt;/p&gt;
&lt;p&gt;    通过这组数据，我们能看到，规模尚属中等的网站（相当于尚能正常盈利不亏本的网站）平均每月就会出现一次故障，对于哪些模块故障率高于百万分之一或平均QPS更高的网站，这个出故障周期会更频繁，所以说，对于互联网公司而言，服务容错组件是必配，而不是优化项。&lt;/p&gt;

&lt;h4&gt;2 准备服务提供者&lt;/h4&gt;
&lt;p&gt;    这里我们将在HystrixServerDemo项目里，提供两个供Hystrix调用的服务，其中一个是可用的，而在另外一个服务里，是通过sleep机制，故意让服务延迟返回，从而造成不可用的后果。&lt;/p&gt;
&lt;p&gt;    这是一个基本的Spring Boot的服务，之前类似的博文里我们已经反复讲述过，所以这里仅给出实现要点，具体信息请大家自己参照代码。&lt;/p&gt;
&lt;p&gt;    要点1，在pom.xml里引入spring boot的依赖项，关键代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1    &amp;lt;dependency&amp;gt;
2        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 
3        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; 
4        &amp;lt;version&amp;gt;1.5.4.RELEASE&amp;lt;/version&amp;gt; 
5    &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    要点2，在ServerStarter.java里，开启服务，代码如下。      &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import代码&lt;/span&gt;
2&lt;span&gt;    @SpringBootApplication
&lt;/span&gt;3    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServerStarter{
&lt;/span&gt;4        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main( String[] args )
&lt;/span&gt;5        {      SpringApplication.run(ServerStarter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args); }
&lt;/span&gt;6    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    要点3，在控制器Controller.java里，编写两个提供服务的方法，代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;    @RestController
&lt;/span&gt;2    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Controller {        
&lt;/span&gt;3        @RequestMapping(value = &quot;/available&quot;, method =&lt;span&gt; RequestMethod.GET    )
&lt;/span&gt;4        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String availabieService() 
&lt;/span&gt;5        { &lt;span&gt;return&lt;/span&gt; &quot;This Server works well.&quot;&lt;span&gt;; }
&lt;/span&gt;6        
7        @RequestMapping(value = &quot;/unavailable&quot;, method =&lt;span&gt; RequestMethod.GET    )
&lt;/span&gt;8        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String unavailableServicve () {
&lt;/span&gt;9            &lt;span&gt;try&lt;/span&gt; { Thread.sleep(5000&lt;span&gt;); } 
&lt;/span&gt;10            &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) 
&lt;/span&gt;11&lt;span&gt;            { e.printStackTrace(); }
&lt;/span&gt;12            &lt;span&gt;return&lt;/span&gt; &quot;This service is unavailable.&quot;&lt;span&gt;;
&lt;/span&gt;13&lt;span&gt;        }
&lt;/span&gt;14    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    其中在第3行提供了一个可用的服务，在第8行的unavailableServicve的服务里，是通过第9行的sleep方法，造成“服务延迟返回”的效果。&lt;/p&gt;
&lt;h4&gt;3 以同步方式调用正常工作的服务&lt;/h4&gt;
&lt;p&gt;    这里我们新建一个HystrixClientDemo项目，在其中开发各种Hystrix调用服务的代码。&lt;/p&gt;
&lt;p&gt;在这个项目里，我们将通过Ribbon和Hystrix结合的方式，调用在上部分里提供的服务，所以在pom.xml文件里，我们将引入这两部分的依赖包，关键代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1    &amp;lt;dependencies&amp;gt;    
2        &amp;lt;dependency&amp;gt;
3                &amp;lt;groupId&amp;gt;com.netflix.ribbon&amp;lt;/groupId&amp;gt;
4                &amp;lt;artifactId&amp;gt;ribbon-httpclient&amp;lt;/artifactId&amp;gt;
5                &amp;lt;version&amp;gt;2.2.0&amp;lt;/version&amp;gt;
6        &amp;lt;/dependency&amp;gt;
7         &amp;lt;dependency&amp;gt;
8                &amp;lt;groupId&amp;gt;com.netflix.hystrix&amp;lt;/groupId&amp;gt;
9                &amp;lt;artifactId&amp;gt;hystrix-core&amp;lt;/artifactId&amp;gt;
10                &amp;lt;version&amp;gt;1.5.12&amp;lt;/version&amp;gt;
11        &amp;lt;/dependency&amp;gt;
12      &amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在上述代码的第2到第6行里，我们引入了Ribbon的依赖项，从第7到第11里，我们引入了Hystrix的依赖项。&lt;/p&gt;
&lt;p&gt;    在NormalHystrixDemo.java里，我们将演示通过Hystrix调用正常服务的开发方式，代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import代码&lt;/span&gt;
2    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承HystrixCommand&amp;lt;String&amp;gt;，所以run方法返回String类型对象&lt;/span&gt;
3    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NormalHystrixDemo &lt;span&gt;extends&lt;/span&gt; HystrixCommand&amp;lt;String&amp;gt;&lt;span&gt; {
&lt;/span&gt;4        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义访问服务的两个对象&lt;/span&gt;
5        RestClient client = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;6        HttpRequest request = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;7        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在构造函数里指定命令组的名字 &lt;/span&gt;
8        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; NormalHystrixDemo() {
&lt;/span&gt;9       &lt;span&gt;super&lt;/span&gt;(HystrixCommandGroupKey.Factory.asKey(&quot;demo&quot;&lt;span&gt;));
&lt;/span&gt;10&lt;span&gt;        }
&lt;/span&gt;11        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在initRestClient方法里设置访问服务的client对象&lt;/span&gt;
12        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initRestClient() {
&lt;/span&gt;13            client = (RestClient) ClientFactory.getNamedClient(&quot;HelloCommand&quot;&lt;span&gt;);
&lt;/span&gt;14            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;15                request = HttpRequest.newBuilder().uri(&lt;span&gt;new&lt;/span&gt; URI(&quot;/available&quot;&lt;span&gt;)).build();
&lt;/span&gt;16            } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (URISyntaxException e) 
&lt;/span&gt;17&lt;span&gt;             { e.printStackTrace(); }
&lt;/span&gt;18        ConfigurationManager.getConfigInstance().setProperty(    &quot;HelloCommand.ribbon.listOfServers&quot;, &quot;localhost:8080&quot;&lt;span&gt;);
&lt;/span&gt;19        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在第12行的initRestClient方法里，我们做好了以基于Ribbon的RestClient对象访问服务的准备工作，具体而言，在第13行里通过工厂初始化了client对象，在第18行，设置了待访问的url，在第15行，设置了待访问的服务名。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
20        &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String run() {
&lt;/span&gt;21            System.out.println(&quot;In run&quot;&lt;span&gt;);
&lt;/span&gt;22&lt;span&gt;            HttpResponse response;
&lt;/span&gt;23            String result = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;24            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;25                response =&lt;span&gt; client.executeWithLoadBalancer(request);
&lt;/span&gt;26                System.out.println(&quot;Status for URI:&quot; + response.getRequestedURI()+ &quot; is :&quot; +&lt;span&gt; response.getStatus());
&lt;/span&gt;27                result = response.getEntity(String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;28            } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClientException e) 
&lt;/span&gt;29&lt;span&gt;            { e.printStackTrace();} 
&lt;/span&gt;30           &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {    e.printStackTrace();    }
&lt;/span&gt;31            &lt;span&gt;return&lt;/span&gt; &quot;Hystrix Demo,result is: &quot; +&lt;span&gt; result;
&lt;/span&gt;32        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    我们在第20行定义了返回String类型的run方法， 这里的返回类型需要和第3行里本类继承的HystrixCommand对象的泛型一致。在其中，我们是通过第25行的代码调用服务，并在第31行，返回一个包括调用结果的String字符串。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;34            NormalHystrixDemo normalDemo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NormalHystrixDemo();
&lt;/span&gt;35            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化调用服务的环境&lt;/span&gt;
36&lt;span&gt;            normalDemo.initRestClient();
&lt;/span&gt;37            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 睡眠1秒&lt;/span&gt;
38            &lt;span&gt;try&lt;/span&gt; {Thread.sleep(1000&lt;span&gt;);} 
&lt;/span&gt;39            &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) 
&lt;/span&gt;40&lt;span&gt;            {e.printStackTrace();    }
&lt;/span&gt;41            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用execute方法后，会自动地执行定义在第20行的run方法&lt;/span&gt;
42            String result =&lt;span&gt; normalDemo.execute();
&lt;/span&gt;43            System.out.println(&quot;Call available function, result is:&quot; +&lt;span&gt; result);
&lt;/span&gt;44&lt;span&gt;        }
&lt;/span&gt;45    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在main方法里，我们指定了如下的工作流程。&lt;/p&gt;
&lt;p&gt;    第一步，在第36行里，通过调用initRestClient方法完成了初始化的工作。&lt;/p&gt;
&lt;p&gt;    第二步，在第42行里执行了execute方法，这个方法是封装在HystrixCommand方法里的，一旦调用，则会触发第20行的run方法。&lt;/p&gt;
&lt;p&gt;    请注意，这里一旦执行execute方法，则会立即（即以同步的方式）执行run方法，在run方法返回结果之前，代码是会阻塞在第42行的，即不会继续往后执行。&lt;/p&gt;
&lt;p&gt;    第三步，在第20行的run方法里，我们以localhost:8080/available的方式调用了服务端的服务。&lt;/p&gt;
&lt;p&gt;    执行本段代码，会看到如下的打印语句，这些打印语句很好地验证了上述讲述的过程流程。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;    In run
&lt;/span&gt;2    Status &lt;span&gt;for&lt;/span&gt; URI:http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8080/available is :200&lt;/span&gt;
3    Call available function, result is:Hystrix Demo,result is: This Server works well.
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;span lang=&quot;EN-US&quot;&gt;4 以异步的方式调用服务&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;    &lt;/span&gt;在上部分的Hystrix案例中，请求是被依次执行，在处理完上个请求之前，后一个请求处于阻塞等待状态，这种Hystrix同步的处理方式适用于并发量一般的场景。&lt;/p&gt;
&lt;p&gt;    但单台服务器的负载处理能力毕竟是有限的，如果并发量高于（或远远高于）这个极限时，那么我们就得考虑采用Hystrix基于异步的保护机制，从下图里，我们能看到基于异步处理的效果图。 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201808/1226172-20180801070224925-1456694327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    从上图里我们能看到，请求不是被同步地立即执行，而是被放入到一个队列（queue）中，封装在HystrixCommand的处理代码是从queue里拿出请求，并以基于hystrix保护措施的方式处理该请求。在下面的AsyncHystrixDemo.java里，我们将演示hystrix异步执行的方式。   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import代码&lt;/span&gt;
2    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里同样是继承HystrixCommand&amp;lt;String&amp;gt;类&lt;/span&gt;
3    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AsyncHystrixDemo &lt;span&gt;extends&lt;/span&gt; HystrixCommand&amp;lt;String&amp;gt;&lt;span&gt; {
&lt;/span&gt;4        RestClient client = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;5        HttpRequest request = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;6        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AsyncHystrixDemo() {
&lt;/span&gt;7            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定命令组的名字&lt;/span&gt;
8    &lt;span&gt;super&lt;/span&gt;(HystrixCommandGroupKey.Factory.asKey(&quot;ExampleGroup&quot;&lt;span&gt;));
&lt;/span&gt;9&lt;span&gt;        }
&lt;/span&gt;10        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initRestClient() {
&lt;/span&gt;11            client = (RestClient) ClientFactory.getNamedClient(&quot;AsyncHystrix&quot;&lt;span&gt;);
&lt;/span&gt;12            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;13                request = HttpRequest.newBuilder().uri(&lt;span&gt;new&lt;/span&gt; URI(&quot;/available&quot;&lt;span&gt;)).build();
&lt;/span&gt;14&lt;span&gt;            } 
&lt;/span&gt;15            &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (URISyntaxException e) 
&lt;/span&gt;16&lt;span&gt;            {    e.printStackTrace();    }
&lt;/span&gt;17&lt;span&gt;        ConfigurationManager.getConfigInstance().setProperty(
&lt;/span&gt;18                    &quot;AsyncHystrix.ribbon.listOfServers&quot;, &quot;localhost:8080&quot;&lt;span&gt;);
&lt;/span&gt;19&lt;span&gt;        }
&lt;/span&gt;20        &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String run() {
&lt;/span&gt;21            System.out.println(&quot;In run&quot;&lt;span&gt;);
&lt;/span&gt;22&lt;span&gt;            HttpResponse response;
&lt;/span&gt;23            String result = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;24            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;25                response =&lt;span&gt; client.executeWithLoadBalancer(request);
&lt;/span&gt;26                System.out.println(&quot;Status for URI:&quot; + response.getRequestedURI() + &quot; is :&quot; +&lt;span&gt; response.getStatus());
&lt;/span&gt;27                result = response.getEntity(String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;28&lt;span&gt;            } 
&lt;/span&gt;29            &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClientException e) {e.printStackTrace(); } 
&lt;/span&gt;30            &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) { e.printStackTrace();    }
&lt;/span&gt;31            &lt;span&gt;return&lt;/span&gt; &quot;Hystrix Demo,result is: &quot; +&lt;span&gt; result;
&lt;/span&gt;32        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在上述代码的第6行里，我们定义了构造函数，在第10行里，定义了初始化Ribbon环境的initRestClient方法，在第20行里，定义了执行hytrix业务的run方法。这三个方法和刚才讲到的NormalHystrixDemo类里很相似，所以就不再详细讲述。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;33        public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;34            AsyncHystrixDemo asyncDemo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AsyncHystrixDemo();
&lt;/span&gt;35&lt;span&gt;            asyncDemo.initRestClient();
&lt;/span&gt;36            &lt;span&gt;try&lt;/span&gt; {    Thread.sleep(1000&lt;span&gt;);} 
&lt;/span&gt;37            &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) 
&lt;/span&gt;38&lt;span&gt;            {    e.printStackTrace();    }
&lt;/span&gt;39             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上述代码是初始化环境并sleep 1秒&lt;/span&gt;
40            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到Future对象  &lt;/span&gt;
41            Future&amp;lt;String&amp;gt; future =&lt;span&gt; asyncDemo.queue();
&lt;/span&gt;42            String result = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;43            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;44                System.out.println(&quot;Start Async Call&quot;&lt;span&gt;);
&lt;/span&gt;45                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过get方法以异步的方式调用请求&lt;/span&gt;
46                result =&lt;span&gt; future.get();
&lt;/span&gt;47            } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) 
&lt;/span&gt;48&lt;span&gt;              { e.printStackTrace();} 
&lt;/span&gt;49             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExecutionException e) 
&lt;/span&gt;50&lt;span&gt;           {     e.printStackTrace();    }
&lt;/span&gt;51            System.out.println(&quot;Call available function, result is:&quot; +&lt;span&gt; result);
&lt;/span&gt;52&lt;span&gt;        }
&lt;/span&gt;53    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在main函数的34到38行，我们同样是初始化了Ribbon环境，这和之前的NormalHystrixDemo类的做法是一样的。&lt;/p&gt;
&lt;p&gt;    在第41行里，我们通过queue方法，得到了一个包含调用请求的Future&amp;lt;String&amp;gt;类型的对象，而在第46行里，我们是通过future对象的get方法执行请求。&lt;/p&gt;
&lt;p&gt;    这里有两个看点，第一，在执行第46行的get方法后，HystrixComman会自动调用定义在第20行的run方法，第二，这里得到请求对象是在第41行，而调用请求则在46行，也就是说，并不是在请求到达时就立即执行，而是通过异步的方式执行。&lt;/p&gt;
&lt;p&gt;    本部分代码的执行结果和NormalHystrixDemo.java是一样的，所以就不再给出了。   &lt;/p&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;&lt;span lang=&quot;EN-US&quot;&gt;本文中的文字和代码谢绝转载。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;    &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 31 Jul 2018 23:05:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/9399209.html</dc:identifier>
</item>
<item>
<title>依赖注入[6]: .NET Core DI框架[编程体验] - Artech</title>
<link>http://www.cnblogs.com/artech/p/net-core-di-06.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/net-core-di-06.html</guid>
<description>&lt;p&gt;毫不夸张地说，整个ASP.NET Core框架是建立在一个依赖注入框架之上的，它在应用启动时构建请求处理管道过程中，以及利用该管道处理每个请求过程中使用到的服务对象均来源于DI容器。该DI容器不仅为ASP.NET Core框架提供必要的服务，同时作为了应用的服务提供者，依赖注入已经成为了ASP.NET Core应用基本的编程模式。在前面一系列的文章中，我们主要从理论层面讲述了依赖注入这种设计模式，补充必要的理论基础是为了能够理解与ASP.NET Core框架无缝集成的依赖注入框架的设计原理。我们总是采用“先简单体验，后者深入剖析”来讲述每一个知识点，所以我们利用一些简单的实例从编程层面来体验一下服务注册的添加和服务实例的提取。&lt;/p&gt;

&lt;p&gt;为了让读者朋友们能够更加容易地认识依赖注入框架的实现原理和编程模式，我在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-04.html&quot;&gt;依赖注入[4]: 创建一个简易版的DI框架[上篇]&lt;/a&gt;》和《&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-05.html&quot;&gt;依赖注入[5]: 创建一个简易版的DI框架[下篇]&lt;/a&gt;》自行创建了一个名为&lt;strong&gt;Cat&lt;/strong&gt;的依赖注入框架。不论是编程模式和实现原理，Cat与我们现在即将介绍的依赖注入框架都非常相似，对于后者提供的每一个特性，我们几乎都能在Cat中找到对应物。&lt;/p&gt;
&lt;p&gt;我在设计Cat的时候即将它作为提供服务实例的DI容器，也作为了存放服务注册的容器，但是与ASP.NET Core框架集成的这个依赖注入框架则将这两者分离开来。我们添加的服务注册被保存到通过&lt;strong&gt;IServiceCollection&lt;/strong&gt;接口表示的集合之中，基于这个集合创建的DI容器体现为一个&lt;strong&gt;IServiceProvider&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于作为DI框架的IServiceProvider具有类似于Cat的层次结构，所以两者对提供的服务实例采用一致的生命周期管理方式。DI框架利用如下这个枚举ServiceLifetime提供了&lt;strong&gt;Singleton&lt;/strong&gt;、&lt;strong&gt;Scoped&lt;/strong&gt;和&lt;strong&gt;Transient&lt;/strong&gt;三种生命周期模式是，我在Cat中则将其命名为&lt;strong&gt;Root&lt;/strong&gt;、&lt;strong&gt;Self&lt;/strong&gt;和&lt;strong&gt;Transient&lt;/strong&gt;，前者命名关注于现象，而我则关注于内部实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; ServiceLifetime
{
    Singleton,
    Scoped,
    Transient
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
应用初始化过程中添加的服务注册是DI容器用于提供所需服务实例的依据。由于IServiceProvider总是利用指定的&lt;strong&gt;服务类型&lt;/strong&gt;来提供对应服务实例，所以服务是基于类型进行注册的，我们倾向于利用接口来对服务进行抽象，所以这里的服务类型一般为接口。除了以指定服务实例的形式外（默认采用Singleton模式），我们在注册服务的时候必须指定一个具体的生命周期模式。
&lt;ul&gt;&lt;li&gt;指定注册非服务类型和实现类型；&lt;/li&gt;
&lt;li&gt;指定一个现有的服务实例；&lt;/li&gt;
&lt;li&gt;指定一个创建服务实例的委托对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们定义了如下的接口和对应的实现类型来演示针对DI框架的服务注册和提取。其中Foo、Bar和Baz分别实现了对应的接口IFoo、IBar和IBaz，为了反映Cat对服务实例生命周期的控制，我们让它们派生于同一个基类Base。Base实现了IDisposable接口，我们在其构造函数和实现的Dispose方法中打印出相应的文字以确定对应的实例何时被创建和释放。我们还定义了一个泛型的接口IFoobar&amp;lt;T1, T2&amp;gt;和对应的实现类Foobar&amp;lt;T1, T2&amp;gt;来演示针对泛型服务实例的提供。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFoo {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBar {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBaz {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IFoobar&amp;lt;T1, T2&amp;gt;&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Base : IDisposable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Base() =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An instance of {GetType().Name} is created.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose() =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The instance of {GetType().Name} is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo : Base, IFoo, IDisposable { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar : Base, IBar, IDisposable { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Baz : Base, IBaz, IDisposable { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Foobar&amp;lt;T1, T2&amp;gt;: IFoobar&amp;lt;T1,T2&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IFoo Foo { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Foobar(IFoo foo, IBar bar)
    {
        Foo &lt;/span&gt;=&lt;span&gt; foo;
        Bar &lt;/span&gt;=&lt;span&gt; bar;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在如下所示的代码片段中我们创建了一个ServiceCollection（它是对IServiceCollection接口的默认实现）对象并调用相应的方法（AddTransient、AddScoped和AddSingleton）针对接口IFoo、IBar和IBaz注册了对应的服务，从方法命名可以看出注册的服务采用的生命周期模式分别为Transient、Scoped和Singleton。在完成服务注册之后，我们调用IServiceCollection接口的扩展方法BuildServiceProvider创建出代表DI容器的IServiceProvider对象，并利用它调用后者的GetService&amp;lt;T&amp;gt;方法来提供相应的服务实例。调试断言表明IServiceProvider提供的服务实例与预先添加的服务注册是一致的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provider = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddTransient&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
            .AddScoped&lt;/span&gt;&amp;lt;IBar&amp;gt;(_ =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bar())
            .AddSingleton&lt;/span&gt;&amp;lt;IBaz, Baz&amp;gt;&lt;span&gt;()
            .BuildServiceProvider();
        Debug.Assert(provider.GetService&lt;/span&gt;&amp;lt;IFoo&amp;gt;() &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Foo);
        Debug.Assert(provider.GetService&lt;/span&gt;&amp;lt;IBar&amp;gt;() &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Bar);
        Debug.Assert(provider.GetService&lt;/span&gt;&amp;lt;IBaz&amp;gt;() &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Baz); 
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了提供类似于IFoo、IBar和IBaz这样非泛型服务实例之外，如果具有对应的泛型定义（Generic Definition）的服务注册，IServiceProvider同样也能提供泛型服务实例。如下面的代码片段所示，在为创建的ServiceCollection对象添加了针对IFoo和IBar接口的服务注册之后，我们调用AddTransient方法注册了针对泛型定义IFoobar&amp;lt;，&amp;gt;的服务注册，实现的类型为Foobar&amp;lt;,&amp;gt;。当我们利用ServiceCollection创建出代表DI容器的IServiceProvider对象并利用后者提供一个类型为IFoobar&amp;lt;IFoo, IBar&amp;gt;的服务实例的时候，它会创建并返回一个Foobar&amp;lt;Foo, Bar&amp;gt;对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; provider = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
    .AddTransient&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
    .AddTransient&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;()
    .AddTransient(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IFoobar&amp;lt;,&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(Foobar&amp;lt;,&amp;gt;&lt;span&gt;))
    .BuildServiceProvider();

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foobar = (Foobar&amp;lt;IFoo, IBar&amp;gt;)provider.GetService&amp;lt;IFoobar&amp;lt;IFoo, IBar&amp;gt;&amp;gt;&lt;span&gt;();
Debug.Assert(foobar.Foo &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; Foo);
Debug.Assert(foobar.Bar &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; Bar);
&lt;/pre&gt;&lt;/div&gt;
当我们在进行服务注册的时候，可以为同一个类型添加多个服务注册，实际上添加的所有服务注册均是有效的。不过由于扩展方法GetService总是返回一个唯一的服务实例，我们对该方法采用了“后来居上”的策略，即总是采用最近添加的服务注册来创建服务实例。如果我们调用另一个扩展方法GetServices，它将利用返回所有服务注册提供的服务实例。
&lt;p&gt;如下面的代码片段所示，我们为创建的Cat对象添加了三个针对Base类型的服务注册，对应的实现类型分别为Foo、Bar和Baz。我们最后将Base作为泛型参数调用了GetServices&amp;lt;Base&amp;gt;方法，该方法会返回包含三个Base对象的集合，集合元素的类型分别为Foo、Bar和Baz。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; services = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
    .AddTransient&lt;/span&gt;&amp;lt;Base, Foo&amp;gt;&lt;span&gt;()
    .AddTransient&lt;/span&gt;&amp;lt;Base, Bar&amp;gt;&lt;span&gt;()
    .AddTransient&lt;/span&gt;&amp;lt;Base, Baz&amp;gt;&lt;span&gt;()
    .BuildServiceProvider()
    .GetServices&lt;/span&gt;&amp;lt;Base&amp;gt;&lt;span&gt;();
Debug.Assert(services.OfType&lt;/span&gt;&amp;lt;Foo&amp;gt;&lt;span&gt;().Any());
Debug.Assert(services.OfType&lt;/span&gt;&amp;lt;Bar&amp;gt;&lt;span&gt;().Any());
Debug.Assert(services.OfType&lt;/span&gt;&amp;lt;Baz&amp;gt;().Any());
&lt;/pre&gt;&lt;/div&gt;
对于IServiceProvider针对服务实例的提供还具有这么一个细节：如果我们在调用GetService或者GetService方法是将服务类型设置为IServiceProvider接口类型，提供的服务实例实际上就是当前的IServiceProvider对象。这一特性意味着我们可以将代表DI容器的IServiceProvider作为服务进行注入，但是在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-03.html&quot;&gt;依赖注入[3]: 依赖注入模式&lt;/a&gt;》已经提到过，一旦我们在应用中利用注入的IServiceProvider来获取其他依赖的服务实例，意味着我们在使用“&lt;strong&gt;Service Locator&lt;/strong&gt;”模式。这是一种“反模式（Anti-Pattern）”，如果迫不得已最好不要这么做。IServiceProvider的这一特性体现在如下所示的调试断言中。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; provider = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection().BuildServiceProvider();
Debug.Assert(provider.GetService&lt;/span&gt;&amp;lt;IServiceProvider&amp;gt;() == provider);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;IServiceProvider之间的层次结构造就了三种不同的生命周期模式：由于&lt;strong&gt;Singleton&lt;/strong&gt;服务实例保存在作为&lt;strong&gt;根容器&lt;/strong&gt;的IServiceProvider对象上，所以它能够在多个同根IServiceProvider对象之间提供真正的单例保证。&lt;strong&gt;Scoped&lt;/strong&gt;服务实例被保存在&lt;strong&gt;当前&lt;/strong&gt;IServiceProvider上，所以它只能在当前IServiceProvider对象的“服务范围”保证的单例的。没有实现IDisposable接口的Transient服务则采用“&lt;strong&gt;即用即取，用后即弃&lt;/strong&gt;”的策略。&lt;/p&gt;
&lt;p&gt;接下来我们通过简单的实例来演示三种不同生命周期模式的差异。在如下所示的代码片段中我们创建了一个ServiceCollection对象并针对接口IFoo、IBar和IBaz注册了对应的服务，它们采用的生命周期模式分别为Transient、Scoped和Singleton。在利用ServiceCollection创建出代表DI容器的IServiceProvider对象之后，我们调用其&lt;strong&gt;CreateScope&lt;/strong&gt;方法创建了两个所谓的“服务范围”，后者的ServiceProvider属性返回一个新的IServiceProvider对象，它实际上是当前IServiceProvider对象的子容器。我们最后利用作为子容器的IServiceProvider对象来提供相应的服务实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddTransient&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
            .AddScoped&lt;/span&gt;&amp;lt;IBar&amp;gt;(_ =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bar())
            .AddSingleton&lt;/span&gt;&amp;lt;IBaz, Baz&amp;gt;&lt;span&gt;()
            .BuildServiceProvider();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provider1 =&lt;span&gt; root.CreateScope().ServiceProvider;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provider2 =&lt;span&gt; root.CreateScope().ServiceProvider;

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; GetServices&amp;lt;TService&amp;gt;&lt;span&gt;(IServiceProvider provider)
        {
            provider.GetService&lt;/span&gt;&amp;lt;TService&amp;gt;&lt;span&gt;();
            provider.GetService&lt;/span&gt;&amp;lt;TService&amp;gt;&lt;span&gt;();
        }

        GetServices&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;(provider1);
        GetServices&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;(provider1);
        GetServices&lt;/span&gt;&amp;lt;IBaz&amp;gt;&lt;span&gt;(provider1);
        Console.WriteLine();
        GetServices&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;(provider2);
        GetServices&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;(provider2);
        GetServices&lt;/span&gt;&amp;lt;IBaz&amp;gt;&lt;span&gt;(provider2);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
上面的程序运行之后会在控制台上输出如图1所示的结果。由于服务IFoo被注册为Transient服务，所以IServiceProvider针对该接口类型的四次请求都会创建一个全新的Foo对象。IBar服务的生命周期模式为Scoped，如果我们利用同一个IServiceProvider对象来提供对应的服务实例，它只会创建一个Bar对象，所以整个程序执行过程中会创建两个Bar对象。IBaz服务采用Singleton生命周期，所以具有同根的两个IServiceProvider对象提供的总是同一个Baz对象，后者只会被创建一次。
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot;/&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/19327/201808/19327-20180801061815458-282238898.png&quot;&gt;&lt;img width=&quot;325&quot; height=&quot;232&quot; title=&quot;4-1&quot; alt=&quot;4-1&quot; src=&quot;https://images2018.cnblogs.com/blog/19327/201808/19327-20180801061815709-980218625.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt;图1 IServiceProvider按照服务注册对应的生命周期模式提供服务实例&lt;/p&gt;
&lt;p&gt;作为DI容器的IServiceProvider不仅仅为我们提供所需的服务实例，它还帮我们管理者这些服务实例的生命周期。如果某个服务实例实现了IDisposable接口，意味着当生命周期完结的时候需要通过调用Dispose方法执行一些资源释放操作，这些操作同样由提供服务实例的IServiceProvider对象来驱动执行。DI框架针对提供服务实例的释放策略取决于对应的服务注册采用的生命周期模式，具体的策略如下：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Transient和Scoped：所有实现了IDisposable接口的服务实例会被作为服务提供者的当前IServiceProvider对象保存起来，当IServiceProvider对象自身被释放的时候，这些服务实例的Dispose方法会随之被调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Singleton：由于服务实例保存在作为根容器的IServiceProvider对象上，所以后者被释放的时候调用会触发针对服务实例的释放。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于一个ASP.NET Core应用来说，它具有一个与当前应用绑定，代表全局根容器的IServiceProvider对象。对于处理的每一次请求，ASP.NET Core框架都会利用这个根容器来创建基于当前请求的服务范围，并利用后者提供的IServiceProvider来提供请求处理所需的服务实例。请求处理完成之后，创建的服务范围被终结，对应的IServiceProvider对象也随之被释放，此时由它提供的Scoped服务实例以及实现了IDisposable接口的Transient服务实例最终得以释放。&lt;/p&gt;
&lt;p&gt;上述的释放策略可以通过如下的演示实例来印证。我们在如下的代码片段中创建了一个ServiceCollection对象，并针对不同的生命周期模式添加了针对IFoo、IBar和IBaz的服务注册。在利用ServiceCollection创建出作为根容器的IServiceProvider之后，我们调用它的CreateScope方法创建出对应的服务范围。接下来我们利用创建对的服务范围得到代表子容器的IServiceProvider对象，并用后者提供了三个注册服务对应的实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddTransient&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
            .AddScoped&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;()
            .AddSingleton&lt;/span&gt;&amp;lt;IBaz, Baz&amp;gt;&lt;span&gt;()
            .BuildServiceProvider())
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; scope =&lt;span&gt; root.CreateScope())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provider =&lt;span&gt; scope.ServiceProvider;
                provider.GetService&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;();
                provider.GetService&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;();
                provider.GetService&lt;/span&gt;&amp;lt;IBaz&amp;gt;&lt;span&gt;();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Child container is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Root container is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于代表根容器的IServiceProvider对象和服务范围的创建都是在using块中进行的，所有针对它们的Dispose方法都会在using块结束的地方被调用，为了确定方法被调用的时机，我们特意在控制台上打印了相应的文字。该程序运行之后会在控制台上输出如图2所示的结果，我们可以看到当作为子容器的IServiceProvider对象被释放的时候，由它提供的两个生命周期模式分别为Transient和Scoped的两个服务实例（Foo和Bar）被正常释放了。至于生命周期模式为Singleton的服务实例Baz，它的Dispose方法会延迟到作为根容器IServiceProvider对象被释放的时候。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/19327/201808/19327-20180801061815894-1346401595.png&quot;&gt;&lt;img width=&quot;325&quot; height=&quot;198&quot; title=&quot;4-2&quot; alt=&quot;4-2&quot; src=&quot;https://images2018.cnblogs.com/blog/19327/201808/19327-20180801061816139-1684393474.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt;图2 服务实例的释放&lt;/p&gt;

&lt;p&gt;Singleton和Scoped这两种不同生命周期是通过将提供的服务实例分别存放到作为根容器的IServiceProvider对象和当前IServiceProvider对象来实现，这意味着&lt;strong&gt;作为根容器的IServiceProvider对象提供的Scoped服务实例也是不能被释放的&lt;/strong&gt;。如果某个Singleton服务以来另一个Scoped服务，那么Scoped服务实例将被一个Singleton服务实例所引用，意味着Scoped服务实例也成了一个不会被释放的服务实例。&lt;/p&gt;
&lt;p&gt;在ASP.NET Core应用中，当我们将某个服务注册的生命周期设置为Scoped的真正意图是希望DI容器根据请求上下文来创建和释放服务实例，但是一旦出现上述的情况下，意味着Scoped服务实例将变成一个Singleton服务实例，这样的Scoped服务实例直到应用关闭的哪一个才会得到释放。如果某个Scoped服务实例引用的资源（比如数据库连接）需要被及时释放，这可能会对应用造成灭顶之灾。为了避免这种情况下，我们在利用IServiceProvider提供服务过程开启针对服务范围的验证。&lt;/p&gt;
&lt;p&gt;如果希望IServiceProvider在提供服务的过程中对服务范围作有效性检验，我们只需要在调用ServiceCollection的BuildServiceProvider方法的时候将一个布尔类型的True值作为参数即可。在如下所示的演示程序中，我们定义了两个服务接口（IFoo和IBar）和对应的实现类型（Foo和Bar），其中Foo依赖IBar。我们将IFoo和IBar分别注册为Singleton和Scoped服务，当我们在调用BuildServiceProvider方法创建代表DI容器的IServiceProvider对象的时候将参数设置为True以开启针对服务范围的检验。我们最后分别利用代表根容器和子容器的IServiceProvider来分别提供这两种类型的服务实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddSingleton&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
            .AddScoped&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;()
            .BuildServiceProvider(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);    
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; child =&lt;span&gt; root.CreateScope().ServiceProvider;

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; ResolveService&amp;lt;T&amp;gt;&lt;span&gt;(IServiceProvider provider)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isRootContainer = root == provider ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                provider.GetService&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt;();
                Console.WriteLine( $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Status: Success; &lt;/span&gt;Service Type: {&lt;span&gt;typeof&lt;/span&gt;(T).Name}; Root: {isRootContainer}&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Status: Fail; &lt;/span&gt;Service Type: {&lt;span&gt;typeof&lt;/span&gt;(T).Name}; Root: {isRootContainer}&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
                  Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error: {ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }

        ResolveService&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;(root);
        ResolveService&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;(root);
        ResolveService&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;(child);
        ResolveService&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;(child);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFoo {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBar {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo : IFoo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Foo(IBar bar) =&amp;gt; Bar =&lt;span&gt; bar;
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Bar : IBar {}
&lt;/pre&gt;&lt;/div&gt;
上面这个演示实例启动之后将在控制台上输出如图3所示的输出结果。从输出结果可以看出针对四个服务解析，只有一次（使用代表子容器的IServiceProvider提供IBar服务实例）是成功的。这个实例充分说明了一旦开启了针对服务范围的验证，IServiceProvider对象不可能提供以单例形式存在的Scoped服务。
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/19327/201808/19327-20180801061816369-44778700.png&quot;&gt;&lt;img width=&quot;710&quot; height=&quot;219&quot; title=&quot;4-3&quot; alt=&quot;4-3&quot; src=&quot;https://images2018.cnblogs.com/blog/19327/201808/19327-20180801061816601-71314277.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt;图3 IServiceProvider针对服务范围的检验&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-01.html&quot;&gt;依赖注入[1]: 控制反转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-02.html&quot;&gt;依赖注入[2]: 基于IoC的设计模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-03.html&quot;&gt;依赖注入[3]: 依赖注入模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-04.html&quot;&gt;依赖注入[4]: 创建一个简易版的DI框架[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-05.html&quot;&gt;依赖注入[5]: 创建一个简易版的DI框架[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-06.html&quot;&gt;依赖注入[6]: .NET Core DI框架[编程体验]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-07.html&quot;&gt;依赖注入[7]: .NET Core DI框架[服务注册]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-08html&quot;&gt;依赖注入[8]: .NET Core DI框架[服务消费]&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 22:18:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/artech/p/net-core-di-06.html</dc:identifier>
</item>
<item>
<title>JAVAEE——宜立方商城10：使用freemarker实现网页静态化、ActiveMq同步生成静态网页、Sso单点登录系统分析 - kent鹏</title>
<link>http://www.cnblogs.com/xieyupeng/p/9399066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieyupeng/p/9399066.html</guid>
<description>&lt;p&gt;1、&lt;span&gt;使用&lt;/span&gt;freemarker&lt;span&gt;实现网页静态化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、ActiveMq&lt;span&gt;同步生成静态网页&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;可以使用&lt;/span&gt;Freemarker&lt;span&gt;实现网页静态化。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2.1. &lt;span&gt;什么是&lt;/span&gt;freemarker&lt;/h2&gt;
&lt;p&gt;FreeMarker&lt;span&gt;是一个用&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;语言编写的模板引擎，它基于模板来生成文本输出。&lt;/span&gt;&lt;span&gt;FreeMarker&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;Web&lt;/span&gt;&lt;span&gt;容器无关，即在&lt;/span&gt;&lt;span&gt;Web&lt;/span&gt;&lt;span&gt;运行时，它并不知道&lt;/span&gt;&lt;span&gt;Servlet&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;span&gt;。它不仅可以用作表现层的实现技术，而且还可以用于生成&lt;/span&gt;&lt;span&gt;XML&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;JSP&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt; &lt;span&gt;等。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;目前企业中&lt;/span&gt;:&lt;span&gt;主要用&lt;/span&gt;&lt;span&gt;Freemarker&lt;/span&gt;&lt;span&gt;做静态页面或是页面展示&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2.2. Freemarker&lt;span&gt;的使用方法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;把&lt;/span&gt;freemarker&lt;span&gt;的&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包添加到工程中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Maven&lt;span&gt;工程添加依赖&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;710&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt; 　　 &amp;lt;groupId&amp;gt;org.freemarker&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;  　　&amp;lt;artifactId&amp;gt;freemarker&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;  　　&amp;lt;version&amp;gt;2.3.23&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;原理：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180801003457291-1743612457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：创建一个&lt;/span&gt;Configuration&lt;span&gt;对象，直接&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;一个对象。构造方法的参数就是&lt;/span&gt;&lt;span&gt;freemarker&lt;/span&gt;&lt;span&gt;对于的版本号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第二步：设置模板文件所在的路径。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：设置模板文件使用的字符集。一般就是&lt;/span&gt;utf-8.&lt;/p&gt;
&lt;p&gt;第四步：加载一个模板，创建一个模板对象。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第五步：创建一个模板使用的数据集，可以是&lt;/span&gt;pojo&lt;span&gt;也可以是&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;。一般是&lt;/span&gt;&lt;span&gt;Map&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第六步：创建一个&lt;/span&gt;Writer&lt;span&gt;对象，一般创建一&lt;/span&gt;&lt;span&gt;FileWriter&lt;/span&gt;&lt;span&gt;对象，指定生成的文件名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第七步：调用模板对象的&lt;/span&gt;process&lt;span&gt;方法输出文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第八步：关闭流。&lt;/p&gt;

&lt;p&gt;模板：&lt;/p&gt;
&lt;p&gt;${hello}&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; genFile() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一步：创建一个Configuration对象，直接new一个对象。构造方法的参数就是freemarker对于的版本号。&lt;/span&gt;
        Configuration configuration = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Configuration(Configuration.getVersion());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步：设置模板文件所在的路径。&lt;/span&gt;
        configuration.setDirectoryForTemplateLoading(&lt;span&gt;new&lt;/span&gt; File(&quot;D:/workspaces-itcast/term197/e3-item-web/src/main/webapp/WEB-INF/ftl&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步：设置模板文件使用的字符集。一般就是utf-8.&lt;/span&gt;
        configuration.setDefaultEncoding(&quot;utf-8&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第四步：加载一个模板，创建一个模板对象。&lt;/span&gt;
        Template template = configuration.getTemplate(&quot;hello.ftl&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第五步：创建一个模板使用的数据集，可以是pojo也可以是map。一般是Map。&lt;/span&gt;
        Map dataModel = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向数据集中添加数据&lt;/span&gt;
        dataModel.put(&quot;hello&quot;, &quot;this is my first freemarker test.&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第六步：创建一个Writer对象，一般创建一FileWriter对象，指定生成的文件名。&lt;/span&gt;
        Writer out = &lt;span&gt;new&lt;/span&gt; FileWriter(&lt;span&gt;new&lt;/span&gt; File(&quot;D:/temp/term197/out/hello.html&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第七步：调用模板对象的process方法输出文件。&lt;/span&gt;
&lt;span&gt;        template.process(dataModel, out);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第八步：关闭流。&lt;/span&gt;
&lt;span&gt;        out.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;2.3. 模板的语法&lt;/span&gt; &lt;/p&gt;
&lt;h3&gt;2.3.1. &lt;span&gt;访问&lt;/span&gt;map&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;${key}&lt;/p&gt;

&lt;h3&gt;2.3.2. &lt;span&gt;访问&lt;/span&gt;pojo&lt;span&gt;中的属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Student&lt;span&gt;对象。学号、姓名、年龄&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;${key.property}&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180801003530299-1020268886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;2.3.3. 取集合中的数据&lt;/h3&gt;
&lt;p&gt;&amp;lt;#list studentList as student&amp;gt;&lt;/p&gt;
&lt;p&gt;${student.id}/${studnet.name}&lt;/p&gt;
&lt;p&gt;&amp;lt;/#list&amp;gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180801003534511-213110859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180801003538066-655279989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;2.3.4. 取循环中的下标&lt;/h3&gt;
&lt;p&gt;&amp;lt;#list studentList as student&amp;gt;&lt;/p&gt;
&lt;p&gt;${student_index}&lt;/p&gt;
&lt;p&gt;&amp;lt;/#list&amp;gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180801003542190-1793797744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.3.5. 判断&lt;/h3&gt;
&lt;p&gt;&amp;lt;#if student_index % 2 == 0&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;#else&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/#if&amp;gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180801003546293-324046339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;2.3.6. 日期类型格式化&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180801003549960-1987379207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.3.7. Null&lt;span&gt;值的处理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180801003553487-1801948271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.3.8. Include&lt;span&gt;标签&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&amp;lt;#include “模板名称”&amp;gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180801003558402-234365345.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;2.4. Freemarker&lt;span&gt;整合&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;引入&lt;/span&gt;jar&lt;span&gt;包：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Freemarker&lt;span&gt;的&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180801003605017-1155459042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;2.4.1. &lt;span&gt;创建整合&lt;/span&gt;spring&lt;span&gt;的配置文件&lt;/span&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xmlns:p&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:dubbo&lt;/span&gt;&lt;span&gt;=&quot;http://code.alibabatech.com/schema/dubbo&quot;&lt;/span&gt;&lt;span&gt; xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd
        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;freemarkerConfig&quot;&lt;/span&gt;&lt;span&gt;
        class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;templateLoaderPath&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;/WEB-INF/ftl/&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultEncoding&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;br/&gt;需要编写一&lt;/span&gt;Controller&lt;span&gt;进行测试&lt;/span&gt; &lt;/p&gt;

&lt;h3&gt;2.4.2. Controller&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;请求的&lt;/span&gt;url&lt;span&gt;：&lt;/span&gt;&lt;span&gt;/genhtml&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;参数：无&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回值：&lt;/span&gt;ok &lt;span&gt;（&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;， 需要使用&lt;/span&gt;&lt;span&gt;@ResponseBody&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;业务逻辑：&lt;/p&gt;
&lt;p&gt;1、&lt;span&gt;从&lt;/span&gt;spring&lt;span&gt;容器中获得&lt;/span&gt;&lt;span&gt;FreeMarkerConfigurer&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;span&gt;从&lt;/span&gt;FreeMarkerConfigurer&lt;span&gt;对象中获得&lt;/span&gt;&lt;span&gt;Configuration&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;span&gt;使用&lt;/span&gt;Configuration&lt;span&gt;对象获得&lt;/span&gt;&lt;span&gt;Template&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4、创建数据集&lt;/p&gt;
&lt;p&gt;5、&lt;span&gt;创建输出文件的&lt;/span&gt;Writer&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;span&gt;调用模板对象的&lt;/span&gt;process&lt;span&gt;方法，生成文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;7、关闭流。&lt;/p&gt;

&lt;p&gt;加载配置文件：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180801003621792-1901389782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HtmlGenController {
    
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; FreeMarkerConfigurer freeMarkerConfigurer;

    @RequestMapping(&lt;/span&gt;&quot;/genhtml&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String genHtml()&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、从spring容器中获得FreeMarkerConfigurer对象。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、从FreeMarkerConfigurer对象中获得Configuration对象。&lt;/span&gt;
        Configuration configuration =&lt;span&gt; freeMarkerConfigurer.getConfiguration();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、使用Configuration对象获得Template对象。&lt;/span&gt;
        Template template = configuration.getTemplate(&quot;hello.ftl&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4、创建数据集&lt;/span&gt;
        Map dataModel = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        dataModel.put(&lt;/span&gt;&quot;hello&quot;, &quot;1000&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5、创建输出文件的Writer对象。&lt;/span&gt;
        Writer out = &lt;span&gt;new&lt;/span&gt; FileWriter(&lt;span&gt;new&lt;/span&gt; File(&quot;D:/temp/term197/out/spring-freemarker.html&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6、调用模板对象的process方法，生成文件。&lt;/span&gt;
&lt;span&gt;        template.process(dataModel, out);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 7、关闭流。&lt;/span&gt;
&lt;span&gt;        out.close();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;OK&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2.5. 商品详情页面静态化&lt;/span&gt; &lt;/p&gt;
&lt;h3&gt;2.5.1. 网页的静态化方案&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;输出文件的名称：商品&lt;/span&gt;id+&lt;span&gt;“&lt;/span&gt;&lt;span&gt;.html&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出文件的路径：工程外部的任意目录。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网页访问：使用&lt;/span&gt;nginx&lt;span&gt;访问网页。在此方案下&lt;/span&gt;&lt;span&gt;tomcat&lt;/span&gt;&lt;span&gt;只有一个作用就是生成静态页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;工程部署：可以把e3-item-web&lt;span&gt;部署到多个服务器上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生成静态页面的时机：商品添加后，生成静态页面。可以使用&lt;/span&gt;Activemq&lt;span&gt;，订阅&lt;/span&gt;&lt;span&gt;topic&lt;/span&gt;&lt;span&gt;（商品添加）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180801003731015-1915540348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;3.1. &lt;span&gt;什么是&lt;/span&gt;sso&lt;span&gt;系统&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;SSO&lt;span&gt;英文全称&lt;/span&gt;&lt;span&gt;Single Sign On&lt;/span&gt;&lt;span&gt;，单点登录。&lt;/span&gt;&lt;span&gt;SSO&lt;/span&gt;&lt;span&gt;是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3.2. 为什么要有单点登录系统&lt;/h2&gt;
&lt;h3&gt;3.2.1. 传统的登录实现方式&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180801003800242-1966623486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;此方式在只有一个&lt;/span&gt;web&lt;span&gt;工程时是没有问题。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.2.2. 集群环境下&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180801003837031-1007850550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;集群环境下会出现要求用户多次登录的情况。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;1、&lt;span&gt;配置&lt;/span&gt;tomcat&lt;span&gt;集群。配置&lt;/span&gt;&lt;span&gt;tomcatSession&lt;/span&gt;&lt;span&gt;复制。节点数不要超过&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;span&gt;可以使用&lt;/span&gt;Session&lt;span&gt;服务器，保存&lt;/span&gt;&lt;span&gt;Session&lt;/span&gt;&lt;span&gt;信息，使每个节点是无状态。需要模拟&lt;/span&gt;&lt;span&gt;Session&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;单点登录系统是使用&lt;/span&gt;redis&lt;span&gt;模拟&lt;/span&gt;&lt;span&gt;Session&lt;/span&gt;&lt;span&gt;，实现&lt;/span&gt;&lt;span&gt;Session&lt;/span&gt;&lt;span&gt;的统一管理。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 31 Jul 2018 16:39:00 +0000</pubDate>
<dc:creator>kent鹏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieyupeng/p/9399066.html</dc:identifier>
</item>
<item>
<title>反射和代理 - 嗜血蚂蚁</title>
<link>http://www.cnblogs.com/shixiemayi/p/9398867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shixiemayi/p/9398867.html</guid>
<description>&lt;p&gt;1、类的编译和运行简易过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;java的源码文件（也称为编译单元，以.java为后缀的文件）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　↓　文件内最多只能有一个public修饰的类，否则编译器报错；某个类被public修饰，该类名必需与文件名称一致；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;java的字节码文件（以.class为后缀的文件）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　↓　源码文件经过编译器编译后产生的字节码文件，源码文件中的每个类都会产生一个与类名相同的字节码文件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;java虚拟机解析字节码文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　　　加载.class文件，在内存里保持Class对象，它被用来创建这个类的所有对象。&lt;/p&gt;
&lt;p&gt; 2、获取Class对象的途径&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Class.forName()&lt;/li&gt;
&lt;li&gt;已知某个对象w，通过w.getClass()方法获取，该方法在Object中&lt;/li&gt;
&lt;li&gt;普通的类、接口、数组、基本数据类型，可以通过 .class的形式获取，如char.class、Petty.class&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、反射--运行时的类型信息&lt;/p&gt;
&lt;p&gt;什么是反射：程序在运行时候，可以通过类型信息获取类的域、方法、构造器等细节，通过java的反射API可以调用这些域、方法、构造器等&lt;/p&gt;
&lt;p&gt;反射的API在java.lang.reflect类库，Class类的实例表示正在运行的 Java 应用程序中的类和接口，因此可以获取Field、Method、Constructor类的对象等信息&lt;/p&gt;
&lt;p&gt;4、反射应用--动态代理（jdk版）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先看看静态代理：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.leixingxinxi;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TestFace testFace&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person1();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Persion2(testFace).testDo();
    }
}

&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestFace{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; testDo();
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Person1 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; TestFace{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testDo() {
        System.out.println(&lt;/span&gt;&quot;去买一杯咖啡...&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Persion2 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; TestFace{
    TestFace testFace;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Persion2(TestFace testFace){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.testFace=&lt;span&gt;testFace;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testDo() { &lt;br/&gt;　　　　  //方法前的操作
        testFace.testDo();&lt;br/&gt;　　　　  //方法后的操作
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接调用方法：可以新建对象Persion1并执行testDo()方法，能够得到一致的结果；------&amp;gt;&amp;gt;&amp;gt;main 让 persion1去买一杯咖啡；&lt;/p&gt;
&lt;p&gt;使用静态代理：被代理类和代理类都实现了同一个接口，将被代理类的对象注入代理类的对象域中，在代理类中重写的方法里通过被代理类对象调用对应的方法，实际使用不直接使用被代理类的方法，而是通过代理类的对象调用覆盖的方法；那么在代理类中调用的方法里，真正去调用被代理类的方法前后可以做一些操作------&amp;gt;&amp;gt;&amp;gt;main 告诉persion2 去买咖啡，persion2通知persion1去买一杯咖啡&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;动态代理（jdk版）：动态的创建了代理对象，并动态的处理对所代理的方法的调用。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.leixingxinxi;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;span&gt;TestFace&lt;/span&gt; proxy&lt;/span&gt;= (&lt;span&gt;TestFace&lt;/span&gt;) Proxy.newProxyInstance(Persion1.&lt;span&gt;class&lt;/span&gt;.getClassLoader(),Persion1.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getInterfaces(),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MyInvocationHandler(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Persion1()));
        proxy.testDo();
    }
}

&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestFace{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; testDo();
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Persion1 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; TestFace{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testDo() {
        System.out.println(&lt;/span&gt;&quot;去买一杯咖啡...&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MyInvocationHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TestFace testFace;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyInvocationHandler(TestFace testFace){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.testFace=&lt;span&gt;testFace;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用被代理对象的方法前的业务&lt;/span&gt;
        System.out.println(&quot;当前调用的方法为：&quot;+&lt;span&gt;method.getName());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用被代理对象方法&lt;/span&gt;
&lt;span&gt;        method.invoke(testFace);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用被代理对象的方法后的业务&lt;/span&gt;
        System.out.println(&quot;被代理的方法调用结束&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用过程：通过代理对象proxy调用代理方法时候，实际会去调用MyInvocationHandler 对象的invoke方法，该方法内部会调用Method的invoke方法真正去执行被代理对象的方法体&lt;/p&gt;

</description>
<pubDate>Tue, 31 Jul 2018 16:32:00 +0000</pubDate>
<dc:creator>嗜血蚂蚁</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shixiemayi/p/9398867.html</dc:identifier>
</item>
<item>
<title>【java代码之美】---Java8 Stream - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9399015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9399015.html</guid>
<description>&lt;p&gt;第一次看到Stream表达式就深深把我吸引，用它可以使你的代码更加整洁而且对集合的操作效率也会大大提高，如果你还没有用到java8的Stream特性，那就说明你确实out啦。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;1、什么是Stream&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;Stream是一种&lt;span&gt;可供流式操作的数据视图&lt;/span&gt;有些类似数据库中视图的概念&lt;span&gt;它不改变源数据集合&lt;/span&gt;如果&lt;span&gt;对其进行改变的操作它会返回一个新的数据集合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;总的来讲它有三大特性：在之后我们会对照着详细说明&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       1、stream不存储数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       2、stream不改变源数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       3、stream的延迟执行特性&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;2、Stream优点&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;代码简洁，函数式编程写出的代码简洁且意图明确，使用&lt;em&gt;stream&lt;/em&gt;接口让你从此告别&lt;em&gt;for&lt;/em&gt;循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;多核友好，Java函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下&lt;code&gt;parallel()&lt;/code&gt;方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;3、Stream API常用方法&lt;/span&gt;&lt;/h4&gt;
&lt;table align=&quot;left&quot;&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr&gt;&lt;td colspan=&quot;3&quot; align=&quot;center&quot;&gt;Stream操作分类&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;中间操作(Intermediate operations)&lt;/td&gt;
&lt;td&gt;无状态(Stateless)&lt;/td&gt;
&lt;td&gt;unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;有状态(Stateful)&lt;/td&gt;
&lt;td&gt;distinct() sorted() sorted() limit() skip()&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;结束操作(Terminal operations)&lt;/td&gt;
&lt;td&gt;非短路操作&lt;/td&gt;
&lt;td&gt;forEach() forEachOrdered() toArray() reduce() collect() max() min() count()&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;短路操作(short-circuiting)&lt;/td&gt;
&lt;td&gt;anyMatch() allMatch() noneMatch() findFirst() findAny()&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;








&lt;p&gt;Stream上的所有操作分为两类：&lt;span&gt;中间操作&lt;/span&gt;和&lt;span&gt;结束操作&lt;/span&gt;，中间操作只是一种标记，只有结束操作才会触发实际计算。&lt;/p&gt;
&lt;p&gt;中间操作又可以分为无状态的和有状态的：&lt;/p&gt;
&lt;p&gt;      无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；&lt;/p&gt;
&lt;p&gt;结束操作又可以分为短路操作和非短路操作&lt;/p&gt;
&lt;p&gt;      短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;常用中间件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;filter&lt;/span&gt;：过滤流，过滤流中的元素，返回一个符合条件的Stream&lt;/p&gt;
&lt;div readability=&quot;53.129819277108&quot;&gt;
&lt;p&gt;      &lt;span&gt;map&lt;/span&gt;：转换流，将一种类型的流转换为另外一种流。（mapToInt、mapToLong、mapToDouble 返回int、long、double基本类型对应的Stream）&lt;/p&gt;
&lt;p&gt;&lt;span&gt; flatMap&lt;/span&gt;：简单的说，就是一个或多个流合并成一个新流。（flatMapToInt、flatMapToLong、flatMapToDouble 返回对应的IntStream、LongStream、DoubleStream流。）&lt;/p&gt;
&lt;p&gt;&lt;span&gt; distinct&lt;/span&gt;：返回去重的Stream。&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;sorted&lt;/span&gt;：返回一个排序的Stream。&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;peek&lt;/span&gt;：主要用来查看流中元素的数据状态。&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;limit&lt;/span&gt;：返回前n个元素数据组成的Stream。属于短路操作&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;skip&lt;/span&gt;：返回第n个元素后面数据组成的Stream。 &lt;/p&gt;
&lt;p id=&quot;articleHeader3&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结束操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;forEach&lt;/span&gt;: 循环操作Stream中数据。&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;toArray&lt;/span&gt;: 返回流中元素对应的数组对象。&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;reduce&lt;/span&gt;: 聚合操作，用来做统计。&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;collect&lt;/span&gt;: 聚合操作，封装目标数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;min、max、count&lt;/span&gt;: 聚合操作，最小值，最大值，总数量。&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;anyMatch&lt;/span&gt;: 短路操作，有一个符合条件返回true。&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;allMatch&lt;/span&gt;: 所有数据都符合条件返回true。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;noneMatch&lt;/span&gt;: 所有数据都不符合条件返回true。&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;findFirst&lt;/span&gt;: 短路操作，获取第一个元素。&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;findAny&lt;/span&gt;: 短路操作，获取任一元素。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;forEachOrdered&lt;/span&gt;: 暗元素顺序执行循环操作。&lt;/p&gt;

&lt;div class=&quot;article fmt article__content&quot; data-id=&quot;1190000012404465&quot; data-license=&quot;&quot; readability=&quot;35.5&quot;&gt;
&lt;h2&gt;&lt;span&gt;二、各种案例说明&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;多举点例子，以后忘记了还可以来找自己的博客，哈哈。&lt;/p&gt;
&lt;p&gt;首先写一个领域对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer  id;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供get，set，和满参构造函数&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;1、map中间件相关例子&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class=&quot;clearfix mt10&quot; readability=&quot;56.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestMap {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;Person&amp;gt; persionList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Person&amp;gt;&lt;span&gt;();
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(1,&quot;张三&quot;,&quot;男&quot;,8&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(2,&quot;小小&quot;,&quot;女&quot;,2&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(3,&quot;李四&quot;,&quot;男&quot;,25&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(4,&quot;王五&quot;,&quot;女&quot;,20&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(5,&quot;赵六&quot;,&quot;男&quot;,38&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(6,&quot;大大&quot;,&quot;男&quot;,65&lt;span&gt;));
        
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、只取出该集合中所有姓名组成一个新集合&lt;/span&gt;
        List&amp;lt;String&amp;gt; nameList=&lt;span&gt;persionList.stream().map(Person::getName).collect(Collectors.toList());
        System.out.println(nameList.toString());
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、只取出该集合中所有id组成一个新集合&lt;/span&gt;
          List&amp;lt;Integer&amp;gt; idList=&lt;span&gt;persionList.stream().mapToInt(Person::getId).boxed().collect(Collectors.toList());
         System.out.println(idList.toString());
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、list转map，key值为id，value为Person对象&lt;/span&gt;
         Map&amp;lt;Integer, Person&amp;gt; personmap = persionList.stream().collect(Collectors.toMap(Person::getId, person -&amp;gt;&lt;span&gt; person));
         System.out.println(personmap.toString());
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、list转map，key值为id，value为name&lt;/span&gt;
         Map&amp;lt;Integer, String&amp;gt; namemap =&lt;span&gt; persionList.stream().collect(Collectors.toMap(Person::getId, Person::getName));
         System.out.println(namemap.toString());         
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201807/1090617-20180731230549914-1688110300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是之前要好几层的for循环解决的问题，通过Stream只要一行代码就可以解决了。&lt;/p&gt;
&lt;p&gt;这里要注意，如果你list转map的key如果不唯一，会报错，所以如果你不确定你的key是否唯一，可以改成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 Map&amp;lt;Integer, String&amp;gt; map =&lt;span&gt; persionList.stream().collect(
                Collectors.toMap(Person::getAge, Person::getName, (key1, key2) &lt;/span&gt;-&amp;gt;&lt;span&gt; key1)
        );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt; 2、filter相关例子&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestFilter {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;Person&amp;gt; persionList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Person&amp;gt;&lt;span&gt;();
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(1, &quot;张三&quot;, &quot;男&quot;, 8&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(2, &quot;小小&quot;, &quot;女&quot;, 2&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(3, &quot;李四&quot;, &quot;男&quot;, 25&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(4, &quot;王五&quot;, &quot;女&quot;, 8&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(5, &quot;赵六&quot;, &quot;女&quot;, 25&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(6, &quot;大大&quot;, &quot;男&quot;, 65&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、查找年龄大于20岁的人数&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt;  age=persionList.stream().filter(p-&amp;gt;p.getAge()&amp;gt;20&lt;span&gt;).count();
        System.out.println(age);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、查找年龄大于20岁，性别为男的人数&lt;/span&gt;
       List&amp;lt;Person&amp;gt;  ageList=persionList.stream().filter(p-&amp;gt;p.getAge()&amp;gt;20).filter(p-&amp;gt;&quot;男&quot;&lt;span&gt;.equals(p.getSex())).collect(Collectors.toList());
        System.out.println(ageList.size());

    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     *运行结果：
     *  3
     *  2
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt; 3、sorted相关例子&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;   对于数组举例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSort {

    String[] arr1 &lt;/span&gt;= {&quot;abc&quot;,&quot;a&quot;,&quot;bc&quot;,&quot;abcd&quot;&lt;span&gt;};

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 按照字符长度排序
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSorted1_(){
        Arrays.stream(arr1).sorted(Comparator.comparing(String::length)).forEach(System.out::println);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：a、bc、abc、abcd&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 倒序
     * reversed(),java8泛型推导的问题，所以如果comparing里面是非方法引用的lambda表达式就没办法直接使用reversed()
     * Comparator.reverseOrder():也是用于翻转顺序，用于比较对象（Stream里面的类型必须是可比较的）
     * Comparator. naturalOrder()：返回一个自然排序比较器，用于比较对象（Stream里面的类型必须是可比较的）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSorted2_(){
        Arrays.stream(arr1).sorted(Comparator.comparing(String::length).reversed()).forEach(System.out::println);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：abcd、abc、bc、a&lt;/span&gt;
&lt;span&gt;        Arrays.stream(arr1).sorted(Comparator.reverseOrder()).forEach(System.out::println);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：bc、abcd、abc、a&lt;/span&gt;
&lt;span&gt;        Arrays.stream(arr1).sorted(Comparator.naturalOrder()).forEach(System.out::println);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：a、abc、abcd、bc&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 先按照首字母排序
     * 之后按照String的长度排序
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSorted3_(){
        Arrays.stream(arr1).sorted(Comparator.comparing(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;::com1).thenComparing(String::length)).forEach(System.out::println);
    }&lt;br/&gt;&lt;span&gt; //输出：a、abc、abcd、bc
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt; com1(String x){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x.charAt(0&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 对于集合举例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSort {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;Person&amp;gt; persionList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Person&amp;gt;&lt;span&gt;();
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(1, &quot;张三&quot;, &quot;男&quot;, 8&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(2, &quot;小小&quot;, &quot;女&quot;, 2&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(3, &quot;李四&quot;, &quot;男&quot;, 25&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(4, &quot;王五&quot;, &quot;女&quot;, 8&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(5, &quot;赵六&quot;, &quot;女&quot;, 25&lt;span&gt;));
        persionList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(6, &quot;大大&quot;, &quot;男&quot;, 65&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、找到年龄最小的岁数&lt;/span&gt;
        Collections.sort(persionList, (x, y) -&amp;gt;&lt;span&gt; x.getAge().compareTo(y.getAge()));
        Integer age &lt;/span&gt;= persionList.get(0&lt;span&gt;).getAge();
        System.out.println(&lt;/span&gt;&quot;年龄最小的有:&quot; +&lt;span&gt; age);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：年龄最小的有:2

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、找到年龄最小的姓名&lt;/span&gt;
        String name =&lt;span&gt; persionList.stream()
                .sorted(Comparator.comparingInt(x &lt;/span&gt;-&amp;gt;&lt;span&gt; x.getAge()))
                .findFirst()
                .get().getName();
        System.out.println(&lt;/span&gt;&quot;年龄最小的姓名:&quot; +&lt;span&gt; name);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：年龄最小的姓名:小小&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; 其它的就不具体写了。以后遇到特殊的再往里面补充。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;    1、&lt;/span&gt;&lt;a href=&quot;http://www.importnew.com/26090.html&quot; target=&quot;_blank&quot;&gt;跟上 Java 8 – Stream API 快速入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;   2、&lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/andywithu/p/7404101.html&quot;&gt;java8之stream&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;   3、&lt;a href=&quot;https://blog.csdn.net/u011863951/article/details/81108312&quot; target=&quot;_blank&quot;&gt;[Java进阶篇][函数式编程][Java 8+ Stream API]&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;   4、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/CarpenterLee/p/6637118.html&quot;&gt;深入理解Java Stream流水线&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;想太多，做太少，中间的落差就是烦恼。想没有烦恼，要么别想，要么多做。中校【10】&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 16:11:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9399015.html</dc:identifier>
</item>
<item>
<title>Lucene-Query的使用及其索引库的维护 - 马瘦风</title>
<link>http://www.cnblogs.com/shoufeng/p/9398964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufeng/p/9398964.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Lucene是使用Query对象执行查询的, 由Query对象生成查询的语法. 如bookName:java, 表示搜索bookName域中包含java的文档数据.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;query对象的两种创建方法&quot;&gt;1.1 Query对象的两种创建方法&lt;/h2&gt;
&lt;h3 id=&quot;使用query子类对象&quot;&gt;1.1.1 使用Query子类对象&lt;/h3&gt;
&lt;h4 id=&quot;常用的query子类对象&quot;&gt;1.1.1.1 常用的Query子类对象&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;TermQuery&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;不使用分析器, 对关键词做精确匹配搜索. 如:订单编号、身份证号&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;NumericRangeQuery&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;数字范围查询, 比如: 图书价格大于80, 小于100&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;10&quot;&gt;&lt;td&gt;&lt;strong&gt;BooleanQuery&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;布尔查询, 实现组合条件查询. 组合关系有: 1. MUST与MUST: 表示“与”, 即“交集” 2. MUST与MUST NOT: 包含前者, 排除后者 3. MUST NOT与MUST NOT: 没有意义 4. SHOULD与MUST: 表示MUST, SHOULD失去意义 5. SHOULD与MUST NOT: 等于MUST与MUST NOT 6. SHOULD与SHOULD表示“或”, 即“并集”&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;常用的query子类对象使用&quot;&gt;1.1.1.2 常用的Query子类对象使用&lt;/h4&gt;
&lt;h5 id=&quot;使用termquery&quot;&gt;1.1.1.2.1 使用TermQuery&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;需求: 查询图书名称中包含java的图书.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 搜索索引(封装搜索方法)
 */
private void seracher(Query query) throws Exception {
    // 打印查询语法
    System.out.println(&quot;查询语法: &quot; + query);
    
    // 1.创建索引库目录位置对象(Directory), 指定索引库的位置
    Directory directory = FSDirectory.open(new File(&quot;/Users/healchow/Documents/index&quot;));
    
    // 2.创建索引读取对象(IndexReader), 用于读取索引
    IndexReader reader = DirectoryReader.open(directory);
    
    // 3.创建索引搜索对象(IndexSearcher), 用于执行搜索
    IndexSearcher searcher = new IndexSearcher(reader);  

    // 4. 使用IndexSearcher对象执行搜索, 返回搜索结果集TopDocs
    // 参数一:使用的查询对象, 参数二:指定要返回的搜索结果排序后的前n个
    TopDocs topDocs = searcher.search(query, 10);

    // 5. 处理结果集
    // 5.1 打印实际查询到的结果数量
    System.out.println(&quot;实际查询到的结果数量: &quot; + topDocs.totalHits);
    // 5.2 获取搜索的结果数组
    // ScoreDoc中有文档的id及其评分
    ScoreDoc[] scoreDocs = topDocs.scoreDocs;
    
    for (ScoreDoc scoreDoc : scoreDocs) {
        System.out.println(&quot;= = = = = = = = = = = = = = = = = = =&quot;);
        // 获取文档的id和评分
        int docId = scoreDoc.doc;
        float score = scoreDoc.score;
        System.out.println(&quot;文档id= &quot; + docId + &quot; , 评分= &quot; + score);
        
        // 根据文档Id, 查询文档数据 -- 相当于关系数据库中根据主键Id查询数据
        Document doc = searcher.doc(docId);
        System.out.println(&quot;图书Id: &quot; + doc.get(&quot;bookId&quot;));
        System.out.println(&quot;图书名称: &quot; + doc.get(&quot;bookName&quot;));
        System.out.println(&quot;图书价格: &quot; + doc.get(&quot;bookPrice&quot;));
        System.out.println(&quot;图书图片: &quot; + doc.get(&quot;bookPic&quot;));
        System.out.println(&quot;图书描述: &quot; + doc.get(&quot;bookDesc&quot;));
    }
    
    // 6. 关闭资源
    reader.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试使用TermQuery:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 测试使用TermQuery: 需求: 查询图书名称中包含java的图书
 */
@Test
public void testTermQuery() throws Exception {
    //1. 创建TermQuery对象
    TermQuery termQuery = new TermQuery(new Term(&quot;bookName&quot;, &quot;java&quot;));
    // 2.执行搜索
    this.seracher(termQuery);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233454131-917596653.jpg&quot; width=&quot;60%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;使用numericrangequery&quot;&gt;1.1.1.2.2 使用NumericRangeQuery&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;需求: 查询图书价格在80-100之间的图书(不包含80和100):&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 测试使用NumericRangeQuery: 需求: 查询图书价格在80-100之间的图书
 */
@Test
public void testNumericRangeQuery() throws Exception{
    // 1.创建NumericRangeQuery对象, 参数说明: 
    // field: 搜索的域; min: 范围最小值; max: 范围最大值
    // minInclusive: 是否包含最小值(左边界); maxInclusive: 是否包含最大值(右边界)
    NumericRangeQuery numQuery = NumericRangeQuery.newFloatRange(&quot;bookPrice&quot;, 80f, 100f, false, false);

    // 2.执行搜索
    this.seracher(numQuery); 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233520895-829754029.jpg&quot; width=&quot;60%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试包含80和100:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 测试包含80和100

NumericRangeQuery numQuery = NumericRangeQuery.newFloatRange(&quot;bookPrice&quot;, 80f, 100f, true, true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233535883-1029468024.jpg&quot; width=&quot;60%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;使用booleanquery&quot;&gt;1.1.1.2.3 使用BooleanQuery&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;需求: 查询图书名称中包含Lucene, 并且价格在80-100之间的图书.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 测试使用BooleanQuery: 需求: 查询图书名称中包含Lucene, 且价格在80-100之间的图书
 */
@Test
public void testBooleanQuery() throws Exception {
    // 1.创建查询条件
    // 1.1.创建查询条件一
    TermQuery query1 = new TermQuery(new Term(&quot;bookName&quot;, &quot;lucene&quot;));
    
    // 1.2.创建查询条件二
    NumericRangeQuery query2 = NumericRangeQuery.newFloatRange(&quot;bookPrice&quot;, 80f, 100f, true, true);
    // 2.创建组合查询条件
    BooleanQuery bq = new BooleanQuery();
    // add方法: 添加组合的查询条件
    // query参数: 查询条件对象
    // occur参数: 组合条件
    bq.add(query1, Occur.MUST);
    bq.add(query2, Occur.MUST);
    
    // 3.执行搜索
   this.seracher(bq);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询语法中, &quot;+&quot;表示并且条件, &quot;-&quot;表示不包含后面的条件:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233551268-970801123.jpg&quot; width=&quot;60%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用queryparser&quot;&gt;1.1.2 使用QueryParser&lt;/h3&gt;
&lt;p&gt;说明: 使用QueryParser对象解析查询表达式, 实例化Query对象.&lt;/p&gt;
&lt;h4 id=&quot;queryparse表达式语法&quot;&gt;1.1.2.1 QueryParse表达式语法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;关键词基本查询: 域名+&quot;:&quot;+关键词, 比如: bookname:lucene&lt;/li&gt;
&lt;li&gt;范围查询: 域名+&quot;:&quot;+[最小值 TO 最大值], 比如: price:[80 TO 100]. &lt;strong&gt;需要注意QueryParser不支持数字范围查询, 仅适用于字符串范围查询. 如果有数字范围查询需求, 请使用NumericRangeQuery.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;组合查询:&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;Occur.MUST&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;搜索条件必须满足, 相当于AND&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;Occur.SHOULD&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;搜索条件可选, 相当于OR&lt;/td&gt;
&lt;td&gt;空格&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;Occur.MUST_NOT&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;搜索条件不能满足, 相当于NOT非&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;使用queryparser-1&quot;&gt;1.1.3 使用QueryParser&lt;/h3&gt;
&lt;p&gt;需求: 查询图书名称中包含java, 并且图书名称中包含&quot;Lucene&quot;的图书.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 测试使用QueryParser: 需求: 查询图书名称中包含Lucene, 且包含java的图书
 */
@Test
public void testQueryParser() throws Exception {
    // 1.创建查询对象
    // 1.1.创建分析器对象
    Analyzer analyzer = new IKAnalyzer();
    // 1.2.创建查询解析器对象
    QueryParser qp = new QueryParser(&quot;bookName&quot;, analyzer);
    // 1.3.使用QueryParser解析查询表达式
    Query query = qp.parse(&quot;bookName:java AND bookName:lucene&quot;);
    
    // 2.执行搜索
    this.seracher(query);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233712304-564682659.jpg&quot; width=&quot;60%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注意: 使用QueryParser, 表达式中的组合关键字AND/OR/NOT必须要大写. 设置了默认搜索域后, 若查询的域没有改变, 则可不写.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;数据保存在关系型数据库中, 需要实现增、删、改、查操作; 索引保存在索引库中, 也需要实现增、删、改、查操作.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;增加索引&quot;&gt;2.1 增加索引&lt;/h2&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://www.cnblogs.com/shoufeng/p/9367789.html&quot;&gt;Lucene-入门程序及Java API的简单使用&lt;/a&gt; 中的内容:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233725702-1570320147.jpg&quot; width=&quot;45%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;删除索引&quot;&gt;2.2 删除索引&lt;/h2&gt;
&lt;h3 id=&quot;根据term删除索引&quot;&gt;2.2.1 根据Term删除索引&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;创建分析器对象(Analyzer), 用于分词;&lt;/li&gt;
&lt;li&gt;创建索引配置对象(IndexWriterConfig), 用于配置Lucene;&lt;/li&gt;
&lt;li&gt;创建索引库目录对象(Directory), 用于指定索引库的位置;&lt;/li&gt;
&lt;li&gt;创建索引写入对象(IndexWriter), 用于操作索引;&lt;/li&gt;
&lt;li&gt;创建删除条件对象(Term);&lt;/li&gt;
&lt;li&gt;使用IndexWriter对象, 执行删除;&lt;/li&gt;
&lt;li&gt;释放资源.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 根据Term删除索引
 */
@Test
public void deleteIndexByTerm() throws IOException {
    // 1.创建分析器对象(Analyzer), 用于分词
    Analyzer analyzer = new IKAnalyzer(); 

    // 2.创建索引配置对象(IndexWriterConfig), 用于配置Lucene
    IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_4_10_4, analyzer);

    // 3.创建索引库目录对象(Directory), 用于指定索引库的位置
    Directory directory = FSDirectory.open(new File(&quot;/Users/healchow/Documents/index&quot;));
    
    // 4.创建索引写入对象(IndexWriter), 用于操作索引
    IndexWriter writer = new IndexWriter(directory, iwc);
    
    // 5.创建删除条件对象(Term)
    // 删除图书名称域中, 包含&quot;java&quot;的索引
    // delete from table where name=&quot;java&quot;
    // 参数一: 删除的域的名称, 参数二: 删除的条件值
    Term term = new Term(&quot;bookName&quot;, &quot;java&quot;); 

    // 6.使用IndexWriter对象, 执行删除
    // 可变参数, 能传多个term
    writer.deleteDocuments(term);
  
   // 7.释放资源
    writer.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据Term执行删除操作(&lt;strong&gt;indexWriter.deleteDocuments(term)&lt;/strong&gt;)时, &lt;strong&gt;要求对应的Field不能分词且只能是一个词, 且这个Field必须索引过&lt;/strong&gt;, Lucene将先去搜索, 然后将所有满足条件的记录删除(伪删除, 做了&quot;.del&quot;标记) -- 最好定义一个唯一标识来做删除操作.&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233905132-480067076.jpg&quot; width=&quot;25%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是否删除索引, 需要分情况讨论: 我们知道, Lucene是以段(segment)来组织索引内容的, 通过Term执行删除操作(indexWriter.deleteDocuments(term))时, 若索引段中仍包含符合条件的文档对象的其他分词的索引, 就会保留整个索引数据(若采取更新操作, 则会降低性能), 如果没有, 则也将删除索引数据:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233857746-963949999.jpg&quot; width=&quot;70%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看删除了的文档的编号:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731234057152-902287296.jpg&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;删除全部索引慎用&quot;&gt;2.2.2 删除全部索引(慎用)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;创建分析器对象(Analyzer), 用于分词;&lt;/li&gt;
&lt;li&gt;创建索引配置对象(IndexWriterConfig), 用于配置Lucene;&lt;/li&gt;
&lt;li&gt;创建索引库目录对象(Directory), 指定索引库位置;&lt;/li&gt;
&lt;li&gt;创建索引写入对象(IndexWriter), 用于操作索引库;&lt;/li&gt;
&lt;li&gt;使用IndexWriter对象, 执行删除;&lt;/li&gt;
&lt;li&gt;释放资源.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
* 删除全部索引
*/
@Test
public void deleteAllIndex() throws IOException {
   // 1.创建分析器对象(Analyzer), 用于分词
   Analyzer analyzer = new IKAnalyzer();

   // 2.创建索引配置对象(IndexWriterConfig), 用于配置Lucene
   IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_4_10_4, analyzer);
   
   // 3.创建索引库目录对象(Directory), 用于指定索引库的位置
   Directory directory = FSDirectory.open(new File(&quot;/Users/healchow/Documents/index&quot;));
   
   // 4.创建索引写入对象(IndexWriter), 用于操作索引
   IndexWriter writer = new IndexWriter(directory, iwc);
   
   // 5.使用IndexWriter对象, 执行删除
   writer.deleteAll();
   
   // 6.释放资源
  writer.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除后的索引结果:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731234113496-232488901.jpg&quot; width=&quot;70%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;删除全部索引, 将文档域的数据, 索引域的数据都删除.&lt;/p&gt;
&lt;p&gt;类似于关系型数据库的Truncate删除: 完全删除数据, 包括存储结构, 因而更快速.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;更新索引&quot;&gt;2.3 更新索引&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Lucene是根据Term对象更新索引: 先根据Term执行查询, 查询到则执行更新, 查询不到则执行添加索引.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;创建分析器对象(Analyzer), 用于分词;&lt;/li&gt;
&lt;li&gt;创建索引配置对象(IndexWriterConfig), 用于配置Lucene;&lt;/li&gt;
&lt;li&gt;创建索引库目录对象(Directory), 用于指定索引库的位置;&lt;/li&gt;
&lt;li&gt;创建索引写入对象(IndexWriter), 用于操作索引库;&lt;/li&gt;
&lt;li&gt;创建文档对象(Document);&lt;/li&gt;
&lt;li&gt;创建Term对象;&lt;/li&gt;
&lt;li&gt;使用IndexWriter对象, 执行更新;&lt;/li&gt;
&lt;li&gt;释放资源.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 更新索引
 */
@Test
public void updateIndexByTerm() throws IOException{
    // 1.创建分析器对象(Analyzer), 用于分词
    Analyzer analyzer = new IKAnalyzer();
   
    // 2.创建索引配置对象(IndexWriterConfig), 用于配置Lucene
    IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_4_10_4, analyzer);   

    // 3.创建索引库目录对象(Directory), 用于指定索引库的位置
    Directory directory = FSDirectory.open(new File(&quot;/Users/healchow/Documents/index&quot;));   

    // 4.创建索引写入对象(IndexWriter), 用于操作索引
    IndexWriter writer = new IndexWriter(directory, iwc);
 
    // 5.创建文档对象(Document)
    Document doc = new Document();
    doc.add(new TextField(&quot;id&quot;, &quot;1234&quot;, Store.YES));
    // doc.add(new TextField(&quot;name&quot;, &quot;MyBatis and SpringMVC&quot;, Store.YES));
    doc.add(new TextField(&quot;name&quot;, &quot;MyBatis and Struts2&quot;, Store.YES)); 

    // 6.创建Term对象
    Term term = new Term(&quot;name&quot;, &quot;SpringMVC&quot;); 

    // 7.使用IndexWriter对象, 执行更新
    writer.updateDocument(term, doc);
   
    // 8.释放资源
    writer.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次执行, 由于没有查找到对应的索引, 故执行添加功能, 结果如图(不区分大小写):&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731234129306-1488602472.jpg&quot; width=&quot;70%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二次执行时, 由于索引库中已有&lt;strong&gt;&quot;name&quot;=&quot;SpringMVC&quot;&lt;/strong&gt;的内容, 故执行更新操作: 将整个TextField的内容:&lt;strong&gt;&quot;MyBatis and Struts2&quot;&lt;/strong&gt;添加到索引库中, 并与上次的结果合并, 结果如下图示:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731234143699-1293111662.jpg&quot; width=&quot;70%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若第二次执行时更改了Term中name域的条件值(索引中没有对应的), 将继续执行添加功能: 将整个TextField中的内容添加到索引中.&lt;/p&gt;
&lt;blockquote readability=&quot;16.067073170732&quot;&gt;
&lt;h3 id=&quot;版权声明&quot;&gt;版权声明&lt;/h3&gt;
&lt;p&gt;作者: ma_shoufeng(马瘦风)&lt;/p&gt;
&lt;p&gt;出处: 博客园 &lt;a href=&quot;http://www.cnblogs.com/shoufeng/&quot;&gt;马瘦风的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;您的支持是对博主的极大鼓励, 感谢您的阅读.&lt;/p&gt;
&lt;p&gt;本文版权归博主所有, 欢迎转载, 但未经博主同意必须保留此段声明, 且在文章页面明显位置给出原文链接, 否则博主保留追究法律责任的权利.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 31 Jul 2018 15:45:00 +0000</pubDate>
<dc:creator>马瘦风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shoufeng/p/9398964.html</dc:identifier>
</item>
<item>
<title>做程序员的这五年 - 海角在眼前</title>
<link>http://www.cnblogs.com/lovesong/p/9398952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovesong/p/9398952.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/555379/201807/555379-20180731233155553-1773790022.png&quot; alt=&quot;&quot; width=&quot;100%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    到昨天为止，做程序员，已经整整五年。最近半年来，我时常思考我走过这五年，反思我的职业工作，反思我的生活，我选择错了很多，也做错了很多。有些道理，到最近才幡然醒悟，遂决定谈谈我个人对软件工作的看法，以及一些生活的感悟。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;苦苦攒钱的年轻人&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    我还在苦苦地攒钱，也许有人不信，我当初一万二的收入，每个月能存一万。我花钱不多，也有些克制自己的欲望，但这就导致我很多想做的事情不敢去做。&lt;/p&gt;
&lt;p&gt;    想学吉他，想报健身班，想去进修课程，想有段长时间的旅游等等。都没有去做，并不是没有钱去做，而是怕尝试太费钱，万一我只是三分钟热度呢？&lt;/p&gt;
&lt;p&gt;    可是就是这种心理，丢失了太多的可能性，看到的风光太过狭隘，一直过着一种平庸的生活。我总觉得，以后要买房买车娶媳妇，这钱还远远不够呢。&lt;/p&gt;
&lt;p&gt;    到这几个月，我才醒悟，我根本没有为自己而活，我把自己困在牢笼中，望着我想尝试的东西，即便是那些可能不需费多少钱。我这种行为，限制自己的心，也限制自己成长。明明心心念念且合理的需求，却不去做，苦苦攒钱至今，实在是太愚蠢了，以至于到如今，我没有一件值得纪念的事情。&lt;/p&gt;
&lt;p&gt;    年轻时，对自己投资太重要了，磨刀都还不误砍柴工。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;工作的格局&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    工作上更是不堪回首，倒不是做得多差，而是只会埋头工作，却忽略了长远的规划发展。一个人在一个位置做得太久，导致格局太小，眼界太窄。做的东西太熟悉了，用的东西也长久不变。不过问题不在于技术上，技术只是实现需求的方式，这并不重要。眼界格局才是年轻人最需拓宽的。&lt;/p&gt;
&lt;p&gt;    我相信面过试的人，都会被问到一个问题，那就是，“你想做什么东西？”以前的我，是不知道怎么回答的，也不在意，你叫我做什么我就做什么。而现在，我会认真了解自己能做什么，想做什么，想往哪个方向走，薪酬不再是最需要考虑的事情。&lt;/p&gt;
&lt;p&gt;    懂得自己要做什么，老板想让自己做什么。人如果只是被动接受任务，是没有多大进步的。从分配的任务，分析到老大为什么这么分，考虑点在哪，该做到什么效果，继而推导出更好的方案。从任务的执行者，变成指派者的角度去看问题，这才算成长。&lt;/p&gt;
&lt;p&gt;    在职业规划方面，我觉得，年轻人，就该多出去见见世面，多看看别人做的东西。可能你在这家工作所做的好，到了另一家公司，就变成下等了。我是在这几个月才明白这个道路，但也有些晚了。&lt;/p&gt;
&lt;p&gt;    水往低处流，人往高处走，遇见强者，自己才能更强。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;平台的重要性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    两个相差无几的产品，在不同平台上的效果可能差距非常大。有些时候，我们的技术能力不错，做的产品也不错，但就是卖得不好，原因就在于平台。&lt;/p&gt;
&lt;p&gt;    换句话说，就是小公司没办法跟大公司拼，特别做大众产品。我如今做的产品，虽然是行业里最早投入研发的，但公司没有能够像阿里、腾讯这种大公司做推广，一直都默默无闻。虽然后来有点起色，但等到大公司也开始着手做这一类产品，就被远远的抛下。&lt;/p&gt;
&lt;p&gt;    另外，也是公司能支援的有限，投入的人力也不能与大公司比拟。大公司发展的速度非常快，以至于到后来，我们需要反过来学习这些大公司的产品。这是个硬伤，成员的素质也因成本问题，无法雇佣更有能力的人，也就没法做出优秀的产品，这也使得领导“无人可用”。&lt;/p&gt;
&lt;p&gt;    到最后，我们还在只能卖项目，被项目推着走，做成一个伪产品。&lt;/p&gt;
&lt;p&gt;    我倒不是在抱怨公司的无能为力，只是有些感叹，软件产品，也是越来越不好做了，BAT这三座大山，已经将很多路子生生切断。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;人到三十&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    再过两年，我就要三十了。虽然现在还是孑然一身，有些许积蓄，但也不免有些担忧未来。&lt;/p&gt;
&lt;p&gt;    如果是刚入职场，倒也还有几年可以拼搏莽撞；如果已有老婆孩子，其实路已经是确定了。对于后一种，我没能有什么建议，对于前一种，我的建议是，去冲去闯，无论是工作还是生活。我这一类人，倒也是另一种典型的分类，似乎有很多选择，也似乎没有选择。&lt;/p&gt;
&lt;p&gt;    一个人，在一座大都市，走到了十字路口，前方有几条路，犹豫不决，怕走下去，就再回不了头了。 &lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 15:39:00 +0000</pubDate>
<dc:creator>海角在眼前</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovesong/p/9398952.html</dc:identifier>
</item>
<item>
<title>Cocos文档案例游戏设计的梳理与分析 - Magic激流</title>
<link>http://www.cnblogs.com/magicxyx/p/9397622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/magicxyx/p/9397622.html</guid>
<description>&lt;p&gt;    &lt;span&gt;&lt;em&gt;导语：这是一篇新手教程，适用于已看完&lt;/em&gt;Cocos官方文档&lt;em&gt;，但还对游戏设计、运行流程不熟悉的新人。这篇教程是对文档【快速上手】里那款名叫&quot;&lt;/em&gt;摘星星&lt;em&gt;&quot;的坑爹小游戏(文档原话)流程的梳理，以期望见微知著，得到游戏设计的一些普适性的方法，为看完文档仍然迷迷糊糊的新人提供一个游戏制作、运行的大体方向。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;一、游戏元素&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1219242/201807/1219242-20180731233743168-284103117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;1、图片资源&lt;/h3&gt;
&lt;p&gt;    ·背景图 background&lt;/p&gt;
&lt;p&gt;    ·开始按钮 btn_play&lt;/p&gt;
&lt;p&gt;    ·主角 PurpleMonster&lt;/p&gt;
&lt;p&gt;    ·地面 ground&lt;/p&gt;
&lt;p&gt;    ·星星 star&lt;/p&gt;
&lt;h3&gt;2、场景&lt;/h3&gt;
&lt;p&gt;        ·Game&lt;/p&gt;
&lt;h3&gt;    3、脚本&lt;/h3&gt;
&lt;p&gt;        ·Game.js&lt;/p&gt;
&lt;p&gt;        ·Player.js&lt;/p&gt;
&lt;p&gt;        ·Star.js&lt;/p&gt;
&lt;h3&gt;    4、字体及声音&lt;/h3&gt;
&lt;p&gt;        ·jump&lt;/p&gt;
&lt;p&gt;        ·score&lt;/p&gt;
&lt;p&gt;        ·mikado_outline_shadow&lt;/p&gt;
&lt;h3&gt;    5、预制资源&lt;/h3&gt;
&lt;p&gt;        ·Star&lt;/p&gt;

&lt;h2&gt;二、游戏场景&lt;/h2&gt;
&lt;p&gt;    场景Game:&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1219242/201807/1219242-20180731233743422-813678844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;    官方：在 Cocos Creator 中，游戏场景（Scene）是开发时组织游戏内容的中心，也是呈现给玩家所有游戏内容的载体。游戏场景中一般会包括以下内容：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        ·场景图像和文字（Sprite，Label）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;·角色&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;·以组件形式附加在场景节点上的游戏逻辑脚本&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当玩家运行游戏时，就会载入游戏场景，游戏场景加载后就会自动运行所包含组件的游戏脚本，实现各种各样开发者设置的逻辑功能。所以除了资源以外，游戏场景是一切内容创作的基础。&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;&lt;em&gt;    &lt;/em&gt;1、渲染根节点——Canvas&lt;/h3&gt;
&lt;p&gt;        可以理解为一块要展示的黑板，后续需要添加的各种资源都会在这块&quot;黑板&quot;上。&lt;/p&gt;
&lt;h3&gt;    2、背景图——background&lt;/h3&gt;
&lt;p&gt;        在这款游戏中，可以理解为整个游戏的背景。&lt;/p&gt;
&lt;h3&gt;    3、地面——ground&lt;/h3&gt;
&lt;p&gt;        地面覆盖了一部分背景图，也算是整个游戏静态背景的一部分。&lt;/p&gt;
&lt;h3&gt;    4、角色——Player&lt;/h3&gt;
&lt;h3&gt;    5、分数——Score&lt;/h3&gt;
&lt;h3&gt;    6、层级渲染关系&lt;/h3&gt;
&lt;p&gt;        &lt;span&gt;&lt;span&gt;显示在下方的节点的渲染顺序是在上方节点的后面，也就是说下方的节点是在上方节点之后绘制的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;三、脚本&lt;/h2&gt;
&lt;h3&gt;    1、游戏逻辑脚本——Game.js&lt;/h3&gt;
&lt;p&gt;        Game.js的内容可分为四部分，分别是属性、onload函数、update函数与其他函数。&lt;/p&gt;
&lt;h4&gt;        &lt;strong&gt;·属性&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;            a. star预制资源&lt;/p&gt;
&lt;p&gt;            b. star消失时间范围&lt;/p&gt;
&lt;p&gt;            c. 地面节点&lt;/p&gt;
&lt;p&gt;d. Play节点&lt;/p&gt;
&lt;p&gt;e. Label分数节点&lt;/p&gt;
&lt;p&gt;f.得分音效&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·onLoad函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;&lt;span&gt;&lt;span&gt;onLoad&lt;/span&gt;&lt;span&gt;方法会在场景加载后立刻执行，初始化相关的操作和逻辑都放在这里面。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 得到地面坐标&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. 初始化计时器&lt;/p&gt;
&lt;p&gt;            c. 生成新的星星&lt;/p&gt;
&lt;p&gt;            d. 初始化计分&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·update函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;&lt;span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;在场景加载后就会每帧调用一次，一般把需要经常计算或及时更新的逻辑内容放在这里。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;            a. 计时器更新&lt;/p&gt;
&lt;p&gt;            b. 超时判断&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·其他函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 生成星星&lt;/p&gt;
&lt;p&gt;            b. 生成星星的随机位置&lt;/p&gt;
&lt;p&gt;            c. 得分&lt;/p&gt;
&lt;p&gt;            d. 游戏结束&lt;/p&gt;
&lt;h3&gt;    2、Player节点脚本——Player.js&lt;/h3&gt;
&lt;p&gt;        这个脚本绑定的是场景元素Player，也包含属性、onload函数、update函数与其他函数。&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 跳跃高度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. 跳跃持续时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;c. 移速&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;d. 加速度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;e. 音效资源&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·onload函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 执行跳跃&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. 监听初始化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;c. 加速度&lt;/p&gt;
&lt;p&gt;            d. 水平速度&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·update函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 速度更新&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. 速度限制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;c. 位置更新&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·其他函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 跳跃&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. 输入控制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;c. 播放声音&lt;/p&gt;
&lt;h3&gt;    3、Star节点脚本——Star.js&lt;/h3&gt;
&lt;p&gt;        star.js为Star预制资源的脚本。Star预制资源为脚本Game.js属性Star的引用。&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 星星与player的距离&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. Game对象引用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        ·onLoad&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 根据属性a判断位置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. 星星的生成与销毁&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;c. 调用得分方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        ·update&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 判断距离&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. 星星透明度的变化&lt;/p&gt;
&lt;h2&gt;四、小游戏分析&lt;/h2&gt;
&lt;h3&gt;    1、白话文版本&lt;/h3&gt;
&lt;p&gt;        在一个背景图中有一个会不断跳跃的小妖怪，并且场景里会随机生成一个星星。当小妖怪把星星吃掉时，星星消失，得分加一，并生成新的星星，星星消失时仍然没有被吃掉，小妖怪GG，游戏结束。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;2、正式版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        绑定到根节点的Game.js脚本负责游戏主逻辑，它负责生成背景图（background&amp;amp;ground）等各种资源（见Game.js属性），以及不同资源的调配（见Game.js函数）。场景中有一只会不断跳跃（Player.js）的小妖怪（Player）供玩家操作。场景随机产生（脚本中动态生成）一个星星（见star.js函数b）。当玩家按下键盘上的键时，触发Player节点的输入控制函数（Player.js.其他函数.b），对输入进行筛选，并更改加速度及方向的属性。当星星与Player的距离小于属性规定的距离时，星星消失，加一分，再生成新的星星。当星星超时消失，游戏结束。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;3、图示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1219242/201807/1219242-20180731233743785-40602678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、游戏设计流程的梳理&lt;/h2&gt;
&lt;p&gt;    在这个游戏中，我们可以看到这款游戏得以运行的三要素（资源、脚本、场景）。其中资源和场景负责游戏的视觉、图像效果，而脚本则是串联各资源，既可以是单个元素的脚本（Player.js），也可以是整个游戏流程、规则的脚本（Game.js）。&lt;/p&gt;
&lt;p&gt;    除了上述提到 的游戏运行需要的条件，一个游戏的推出还需要其他要素的支持，如激励、剧情、交互等。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1219242/201807/1219242-20180731233744346-1672020250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;六、改进与进阶&lt;/h2&gt;
&lt;h3&gt;    1、在原游戏模式上的改进&lt;/h3&gt;
&lt;p&gt;        ·对触屏事件的处理。（&lt;span&gt;&lt;span&gt;cc.Node.EventType.TOUCH_START&lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;·加入菜单模块，添加重新开始、暂停、退出等功能。&lt;/p&gt;
&lt;p&gt;·加入手游摇杆（见附录）。&lt;/p&gt;
&lt;p&gt;        ·加入边界，限制Player移到屏幕外。&lt;/p&gt;
&lt;h3&gt;    2、略微改变游戏模式的案例——贪吃蛇&lt;/h3&gt;
&lt;p&gt;        ·星星改为食物，该模块可直接复制。&lt;/p&gt;
&lt;p&gt;        ·加入手游摇杆，控制蛇身移动。&lt;/p&gt;
&lt;p&gt;        ·重新定义蛇身类。&lt;/p&gt;
&lt;p&gt;        ·基于案例小游戏的贪吃蛇正在酝酿之中，挖坑后填。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;附录：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    手游摇杆系列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            ·&lt;a href=&quot;https://blog.csdn.net/xufeng0991/article/details/75141161&quot;&gt;四方向摇杆&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            ·&lt;a href=&quot;https://blog.csdn.net/xufeng0991/article/details/75268705&quot;&gt;八方向摇杆&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            ·&lt;a href=&quot;https://blog.csdn.net/xufeng0991/article/details/75332160&quot;&gt;跟随式摇杆&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 15:38:00 +0000</pubDate>
<dc:creator>Magic激流</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/magicxyx/p/9397622.html</dc:identifier>
</item>
<item>
<title>好代码是管出来的——使用GitHub实现简单的CI/CD - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/9398738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/9398738.html</guid>
<description>&lt;p&gt;　　软件开发一般来说是一项团队作业，在本系列文章开始就提到过软件的编码是由一个团队“并行”完成的，为了保证编码任务正常完成，首先引入版本控制工具来完成代码管理，为了保证代码质量引入了代码分析器以及代码测试。&lt;/p&gt;
&lt;p&gt;　　版本控制工具可以保证代码有一个主版本，但代码分析和测试均是开发人员手动在本地完成的(通过编译、执行测试等方式)，在进行代码分析和测试时可能并没有将本地代码更新到最新版本，这样就会出现一个问题，当多个开发人员向版本库提交代码时，无法保证最新代码库的代码是正确的，为了解决这个问题，提出了持续集成，持续集成的集成指的是&lt;span&gt;持续的对多个开发人员编写的代码进行集成&lt;/span&gt;，本文从下面几个方面介绍持续集成以及基于Github进行持续集成实践：&lt;/p&gt;
&lt;h2&gt;CI&amp;amp;CD&lt;/h2&gt;
&lt;p&gt;　　持续集成(Continuous integration，CI)指的是在开发过程中持续地将所有开发人员的代码合并到代码库的主线上，然后对该主线代码进行编译、测试运行等操作对代码进行检验，其目的是&lt;span&gt;尽可能早的发现代码集成后导致的问题&lt;/span&gt;。&lt;br/&gt;　　实现持续集成的要点主要有：共享的代码库、自动化编译、自动化测试等，同时要保证合理的集成频率，一般持续集成的时机在于开发人员将代码提交到代码库时自动进行，但是如果提交过于频繁，那么应该使用时间间隔的形式进行持续集成。&lt;br/&gt;　　持续发布(Continuous delivery,CD)实际上是持续集成上的一个拓展，在持续集成的基础上将发布工作自动化，&lt;span&gt;避免人为操作从而减少发布时间和发布时人为造成的错误&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;常用的持续集成工具&lt;/h2&gt;
&lt;p&gt;　　持续集成经过多年的发展，在不同的应用场景、平台/语言、商业化等因素下产生了许多持续集成工具，可参考(但不限于这些)：　　&lt;a href=&quot;https://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software&lt;/a&gt;&lt;br/&gt;　　比较常用的持续集成工具有：&lt;br/&gt;　　Jenkins&lt;br/&gt;　　Jenkins是一个开源的跨平台持续集成工具，它提供了GUI界面以及大量的拓展插件，通过GUI界面可以简单、快速的完成项目持续集成配置，更重要的是Jenkins支持所有的版本控制工具。&lt;br/&gt;　　项目地址：&lt;a href=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot;&gt;https://jenkins.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　TeamCity&lt;br/&gt;　　TeamCity是JetBrains公司开发的持续集成工具，它有免费和收费两种授权，免费版本的TeamCity拥有所有功能，其限制仅仅是只能创建100个编译配置和只能并行运行3个代理。&lt;br/&gt;　　项目地址：&lt;a href=&quot;http://www.jetbrains.com/teamcity/&quot; target=&quot;_blank&quot;&gt;http://www.jetbrains.com/teamcity/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　GitLab&lt;br/&gt;　　GitLab是一个Git的代码管理工具，使用GitLab可以轻松的在Linux环境搭建一个Git的远程代码托管平台，同时GitLab中也内置的CI/CD功能。&lt;br/&gt;　　项目地址：&lt;a href=&quot;https://about.gitlab.com/&quot; target=&quot;_blank&quot;&gt;https://about.gitlab.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　Travis CI&lt;br/&gt;　　Travis CI是一个持续集成托管平台，它为开源项目提供免费支持，但Travis CI不支持Windows下编译。&lt;br/&gt;　　项目地址：&lt;a href=&quot;https://www.travis-ci.org/&quot; target=&quot;_blank&quot;&gt;https://www.travis-ci.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　AppVeyor&lt;br/&gt;　　AppVeyor也是一个持续集成的托管平台，它支持Windows和Linux，并且AppVeyor可以对环境进行定制：&lt;a href=&quot;https://www.appveyor.com/docs/build-environment/&quot; target=&quot;_blank&quot;&gt;https://www.appveyor.com/docs/build-environment/&lt;/a&gt;，是一个非常强大的CI工具，AppVeyor对开源项目提供免费支持。&lt;br/&gt;　　项目地址：&lt;a href=&quot;https://www.appveyor.com/&quot; target=&quot;_blank&quot;&gt;https://www.appveyor.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　VSTS&lt;br/&gt;　　VSTS(Visual Studio Team Services)是微软的软件开发管理解决方案，它包含了代码版本管理、持续集成/发布、敏捷等特性，并且VSTS为5人以下团队提供了免费使用。&lt;br/&gt;　　项目地址：&lt;a href=&quot;https://visualstudio.microsoft.com/zh-hans/team-services/&quot; target=&quot;_blank&quot;&gt;https://visualstudio.microsoft.com/zh-hans/team-services/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　总的来说持续集成工具分为可本地安装和平台托管两类，本地安装类型的工具适合有专用构建服务器资源的闭源项目(当然开源项目也可以使用)，而托管平台则比较适合开源或者没有专用构建服务器资源的项目，使用上托管平台更加省心，这些工具需要根据实际情况来进行选用。&lt;/p&gt;
&lt;h2&gt;GitHub市场简介&lt;/h2&gt;
&lt;p&gt;　　GitHub作为一个分布式的软件管理解决方案，它除了提供代码托管外，还通过应用市场的方式提供了拓展应用，这些应用主要用于持续继承、部署、测试、代码审查、项目管理等等，详情查看：&lt;a href=&quot;https://github.com/marketplace/&quot; target=&quot;_blank&quot;&gt;https://github.com/marketplace/&lt;/a&gt;&lt;br/&gt;　　下图为Github市场中的CI工具：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224241490-203279483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一般来说市场中提供的应用对于开源项目都是可以免费使用的，下面就介绍如何将Github上的开源项目使用其市场应用完成持续集成。&lt;/p&gt;
&lt;h2&gt;使用AppVeyor实现持续集成&lt;/h2&gt;
&lt;p&gt;　　AppVeyor是一个支持自定义持续集成环境的CI工具，它对.Net程序的支持非常强大，同时对开源项目免费，所以AppVeyor是.Net Core项目持续集成的首选，下面就介绍如何使用AppVeyor完成持续基础：&lt;br/&gt;　　1. 在GitHub市场中找到AppVeyor，并完成安装：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224434634-1397204928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 添加项目：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224454829-790756155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　选择GitHub仓库，并完成授权：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224556974-2123963496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　添加需要的仓库：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224613353-624953312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击“NEW BUILD”进行一次编译：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224631579-297863656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从编译的信息可以看到，此次编译失败了，并且给出了相应的错误信息，这是由于编译环境导致的。&lt;/p&gt;
&lt;p&gt;　　3. 环境配置：&lt;br/&gt;　　将编译镜像选择为VS2017：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224657740-64294683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在编译前先执行dotnet restore命令还原项目依赖：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224715527-959964128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4. 开始一个新的编译：&lt;br/&gt;　　编译结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224738984-420054646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从编译结果可以看出Appveyor不仅仅是完成了编译工作，而且还搜索了测试信息，并完成了测试。另外有一个要点是本项目中的测试是依赖数据库的，这就意味着Appveyor的编译环境提供了SQL Server数据的支持。&lt;/p&gt;
&lt;p&gt;　　5. 将编译后的内容发布到GitHub release：&lt;br/&gt;　　为xUnitTestDemo代码库添加一个Tag：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224804801-623813258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后Appveyor将会检测到代码库的变化，自动编译Tag，并将结果部署到Github的Release中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224855084-754570041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　自动部署的Release内容：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224910330-847102152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　关于appveryor部署的更多信息参考：&lt;a href=&quot;https://www.appveyor.com/docs/deployment/&quot; target=&quot;_blank&quot;&gt;https://www.appveyor.com/docs/deployment/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　6. 将编译状态显示到GitHub上：&lt;br/&gt;　　Appveyor的Badges(标记)配置界面中可以获取到状态标记地址：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224934211-1651502373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将MarkDown的代码复制到项目的README.md文件中：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224949442-308545953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　效果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225008993-978936522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　7. 导出appveyor.yml文件以及通过appveyor.yml来完成配置：&lt;br/&gt;　　上面的方法是通过Appveyor的Web界面上完成配置的，除此之外还可以通过appveyor.yml文件来完成配置，appveyor.yml文件可以自己创建或导出已有配置：&lt;br/&gt;　　导出已有配置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225032904-289342027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将appveyor.yml文件放置到代码根目录，并通过修改该文件来变更配置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225054968-1673214677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图在原有配置基础上修改为release的方式编译代码，并且指定生成结果目录，将结果进行压缩。&lt;br/&gt;　　更多appveyor.yml配置可参考：&lt;a href=&quot;https://www.appveyor.com/docs/appveyor-yml/&quot; target=&quot;_blank&quot;&gt;https://www.appveyor.com/docs/appveyor-yml/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;使用Codecov显示代码覆盖率&lt;/h2&gt;
&lt;p&gt;　　Codecov也是Github市场的一个应用，它用于生成代码覆盖率报告，codecov对C#的支持是基于OpenCover的(使用OpenCover检测代码覆盖率参考：&lt;a href=&quot;https://www.cnblogs.com/selimsong/p/9263957.html&quot; target=&quot;_blank&quot;&gt;好代码是管出来的——.Net Core中的单元测试与代码覆盖率&lt;/a&gt;)，Codecov对Github的公开项目是免费的，下面就开始介绍如何使用codecov来实现测试代码覆盖率的统计：&lt;br/&gt;　　1. 安装Codecov：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225150706-886391554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：安装完成Codecov后，会有一个Upload Token用来将代码覆盖报告上传到Codecov，但Appveyor的公共仓库可以不需要：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225241143-2002965002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 修改appveyor.yml文件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225349063-598536888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　添加使用choco管理器安装OpenCover及codecov，然后在test_script中添加代码覆盖率分析报告以及上传脚本。&lt;br/&gt;　　&lt;span&gt;注：当上述变更push到Github后，Appveyor将开始自动编译并完成包括代码覆盖率报告生成、上传等所有工作，此时打开codecov页面将会看到报告信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225557132-1620931801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 在README.md文件中添加Codecov的标签：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225649783-322910257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225712173-812784126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225731519-240305522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　本文介绍了CI和CD的基本概念，前者目的在于尽可能早的发现多人开发时代码集成的错误，而后者目的是避免人为造成的错误，将一些重复的事情交由程序自动完成，既可以减少成本又可以提高正确率，现在流行的DevOps的基础之一就是自动化也就是CI和CD。&lt;br/&gt;　　另外本文还介绍了在Github上使用Appvoyer和Codecov工具实现了简单的持续集成，当把新代码推到GitHub仓库时，Appvoyer会自动的完成一系列构建操作。Appvoyer是一个非常强大的CI工具，对C#的支持也非常好可以选择VS版本(包括预览版)，多种数据库(包括Linux下的SQL Server)，所以在执行测试时依赖数据库的测试也能通过。&lt;br/&gt;　　下篇文章将介绍如何使用Jenkins完成本地CI服务器的搭建。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;　　&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_integration&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Continuous_integration&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_delivery&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Continuous_delivery&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://cakebuild.net/&quot; target=&quot;_blank&quot;&gt;https://cakebuild.net/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://docs.codecov.io/docs&quot; target=&quot;_blank&quot;&gt;https://docs.codecov.io/docs&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.appveyor.com/docs/&quot; target=&quot;_blank&quot;&gt;https://www.appveyor.com/docs/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 好代码是管出来的——使用GitHub实现简单的CI/CD&quot; href=&quot;https://www.cnblogs.com/selimsong/p/9398738.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/selimsong/p/9398738.html&lt;/a&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 15:23:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/9398738.html</dc:identifier>
</item>
<item>
<title>将项目发布到Maven中央仓库的不完整纪要 - 网无忌</title>
<link>http://www.cnblogs.com/netWild/p/maven.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/netWild/p/maven.html</guid>
<description>&lt;p&gt;有几个Utils性质的Jar需要跨项目引用，原本想部署私有Maven仓库，后来感觉太麻烦，索性直接发布到中央库，引用时也方便。&lt;/p&gt;
&lt;p&gt;发布成功之后，觉得某些细节还是有必要记录一下。&lt;/p&gt;


&lt;p&gt;此处将整个发布流程进行梳理，目的是从宏观上对这项工作有个感性认识，这是我之前最想找，却无论如何也没找到的。&lt;/p&gt;
&lt;p&gt;图中的“&lt;strong&gt;重点&lt;/strong&gt;”都是需要注意的，也是最终能否成功发布的关键，基本上这几个“&lt;strong&gt;重点&lt;/strong&gt;”都做到，就没什么问题了&lt;/p&gt;
&lt;p&gt;至于每个步骤的实现细节就不再重复了，可以很方便的搜索到相关文章。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/8859/201807/8859-20180731230940680-284646696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 31 Jul 2018 15:23:00 +0000</pubDate>
<dc:creator>网无忌</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/netWild/p/maven.html</dc:identifier>
</item>
</channel>
</rss>