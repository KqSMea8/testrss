<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Zeppelin源码 - 哥不是小萝莉</title>
<link>http://www.cnblogs.com/smartloli/p/7669742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smartloli/p/7669742.html</guid>
<description>&lt;p&gt;　　在大数据应用场景中，处理数据分析方面，由于开发者的水平不一样，使用的编程语言也不尽相同，可能会涉及到R、Python、Java、Scala等，数据计算模型也估计不一样，可能涉及的有Spark、Hive、Flink、Kylin等等。本篇博客笔者给大家介绍的内容并不是告诉大家如何去使用。在《&lt;a href=&quot;http://www.cnblogs.com/smartloli/p/5148941.html&quot; target=&quot;_blank&quot;&gt;Zeppelin使用心得&lt;/a&gt;》中有介绍如何使用，这里就不多做赘述了，今天主要是给大家剖析Zeppelin的源码模块。&lt;/p&gt;

&lt;p&gt;　　目前Zeppelin官方已经发布版本为0.7.3，源码带托管在Github上，大家可以先将Zeppelin的源码在Github上下载下来。Zeppelin的项目结构是以Maven的形式存在的，由多个Module构成，分为框架核心Module和其他Interpreter Module，源码结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/666745/201710/666745-20171015023048715-1983623034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从截图中可以看出，其实Zeppelin到目前为止，集成了很多插件，比如Beam、HBase、ES、Flink、Kylin、Pig等，这些都是平时大数据场景下常用的。&lt;/p&gt;
&lt;h2&gt;2.1 模块分析&lt;/h2&gt;
&lt;p&gt;　　Zeppelin的入口是ZeppelinServer（在zeppelin-server模块下）这个类下的Main函数，通过Jetty内嵌服务器提供WebSocket服务和Restful服务，还基于Shiro提供了权限认证和用户校验功能，都是使用Java编程语言实现的。在zeppelin-zengine模块下，实现Notebook的持久化和检索功能，同样使用Java语言实现。在zeppelin-interpreter模块下，通过调用zeppelin-zengine中的Thrift服务，来实现解释器的交互功能。在zeppelin-web模块下，用于脚本语言编写以及数据的可视化，使用AngularJS前端框架实现。其他模块详见下表。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;td&gt;实现语言&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;zeppelin-server&lt;/td&gt;
&lt;td&gt;整个系统入口，提供服务器功能、权限认证以及用户校验等功能&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;zeppelin-zengine&lt;/td&gt;
&lt;td&gt;实现Zeppelin中Notebook的持久化和检索功能&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;zeppelin-interpreter&lt;/td&gt;
&lt;td&gt;执行解释器&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;zeppelin-web&lt;/td&gt;
&lt;td&gt;业务脚本语言编写、数据分析界面、数据可视化与结果导出&lt;/td&gt;
&lt;td&gt;AngularJS&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;zeppelin-display&lt;/td&gt;
&lt;td&gt;让前端的AngularJS元素与后台数据进行绑定，进行数据交互&lt;/td&gt;
&lt;td&gt;Scala&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;zeppelin-distribution&lt;/td&gt;
&lt;td&gt;用于存放编译后的二进制安装包　　&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;zeppelin-examples&lt;/td&gt;
&lt;td&gt;示例代码，用于测试&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;helium-dev&lt;/td&gt;
&lt;td&gt;新特性，让解释器，存储插件加入到Zeppelin中时，不需要重启Zeppelin服务&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　Zeppelin项目运用了许多编程语言和框架，属于一个混合项目。&lt;/p&gt;

&lt;p&gt;　　明白Zeppelin各个模块的功能和作用后，我们可以尝试去调试一下Zeppelin的源码，这里我们将Zeppelin的源码导入到 IDEA 编辑器，然后找到ZeppelinServer启动，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/666745/201710/666745-20171015030017402-247194269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后选择“Run 'ZeppelinServer.main()'”命令即可，等待服务启动完成，启动成功后，会在编辑器控制台打印日志，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/666745/201710/666745-20171015030241621-520151061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里，在启动端口默认是8080，在ZeppelinConfiguration类下可以进行编辑，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/666745/201710/666745-20171015030448902-1819978356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后，我们可以到浏览器预览调试结果，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/666745/201710/666745-20171015030718090-1514543796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一般在二次开发完成Zeppelin的功能后，我们会将源代码重新编译打包，可以使用Maven打包命令，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mvn clean package -Pbuild-distr -Dcheckstyle.skip=&lt;span&gt;true&lt;/span&gt; -DskipTests
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打包完成后，会在zeppelin-distribution的target目录下生成一个二进制的软件安装包。&lt;/p&gt;

&lt;p&gt;　　这里笔者给大家整理了Zeppelin-0.7.3的各个Module之间的关系图，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/666745/201710/666745-20171015032336309-1666044198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 19:26:00 +0000</pubDate>
<dc:creator>哥不是小萝莉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smartloli/p/7669742.html</dc:identifier>
</item>
<item>
<title>【Vue】浅谈Vue(一)：从模板语法数据绑定、指令到计算属性 - OkayChen</title>
<link>http://www.cnblogs.com/okaychen/p/7669487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okaychen/p/7669487.html</guid>
<description>&lt;p&gt;今年前端届比较有意思，从大漠穷秋发表文章比较angular和vue，继而致歉vue作者、社区，从谷歌辞去Angular Developer PM in China一职并且呼吁大家停止各种无谓的争论；到尤小右(尤雨溪)知乎回应大漠穷秋，表态遗憾大漠穷秋离职，希望世界和平。&lt;/p&gt;
&lt;p&gt;其实我觉得更多的是两者社区、用户、粉丝态度过激导致争端，所以我们要怀着一颗理性的心态去看待，切不要党同伐异。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 说了点题外话，进入今天的正题 - -&lt;/p&gt;
&lt;p&gt;今天的主题是vue，也是我之前在初步学习vue和angular之后，选择vue的第二天，因为已经凌晨了，但是我不想去排斥其他，应该多多学习不同前辈们的智慧结晶 ；&lt;/p&gt;
&lt;p&gt;之前在图灵社区读过一篇文章&lt;span&gt;&lt;a title=&quot;okaychen&quot; href=&quot;http://www.ituring.com.cn/article/273032&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;《Vue作者尤雨溪：以匠人的态度不断打磨完善vue》&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;先来一发福利照 - - &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201710/1140602-20171015003545777-1083013832.jpg&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;275&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面也有尤小右一些对于开发vue的想法，总结下来就是：轻量化，快速上手，灵活运用；&lt;/p&gt;
&lt;p&gt;也有给我们的一些建议，简单总结就是：保持好奇心，在业余时间多做尝试，以兴趣为动力，把兴趣推进一步，保持一种持续学习，持续研究的状态，多探索，多尝试；&lt;/p&gt;
&lt;p&gt;前缀有点长，请放下手里的西瓜刀，接下来进入今天的正正题吧~~&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;关键词&lt;/strong&gt;：&lt;span&gt;[数据绑定]&lt;/span&gt;，&lt;span&gt;[指令]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;谈到到模板语法，我们就会想起&lt;span&gt;数据绑定&lt;/span&gt;和&lt;span&gt;指令&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;我们可以通过声明式的方式将DOM绑定至vue实例的数据：&lt;/p&gt;
&lt;p&gt;先来聊一聊数据绑定：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）数据绑定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关键词&lt;/strong&gt;：&lt;span&gt;[ 插值表达式 ]&lt;/span&gt;，&lt;span&gt;[ v-once一次性插值 ]&lt;/span&gt;，&lt;span&gt;[ v-html ]&lt;/span&gt;，&lt;span&gt;[ 作用于特性v-bind ]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;丶数据绑定最常用的形式应该就是“Mustache”语法 (双大括号) 的&lt;span&gt;文本插值&lt;/span&gt;，无论是vue，还是angular，小程序都采用了这种方式的文本插值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;丶而&lt;span&gt;v-once&lt;/span&gt;指令也好理解，&lt;span&gt;一次性插值&lt;/span&gt;，当我们在改变数据的时候，插值的内容不会随之改变，写一个例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app9&quot;&lt;/span&gt;&lt;span&gt; v-once&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这个将不会随之改变：{{msg}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app9 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data: {
            msg: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是一次性插入的内容&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        }
    })
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 数据改变，插值内容不会随之改变&lt;/span&gt;
&lt;span&gt;    app9.msg &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;　　　　 
    console.log(app9.msg);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; '1'&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;丶插值表达式双大括号就将数据解释为普通文本，而非HTML。使用&lt;span&gt;v-html&lt;/span&gt;指令，可以输出html，但是我们一般不这么做，对于复杂需复用的用&lt;span&gt;组件&lt;/span&gt;代替效果更佳&lt;/p&gt;
&lt;p&gt;丶Mustache 语法不能作用在 HTML 特性上，我们使用&lt;span&gt;v-bind&lt;/span&gt;作用于特性，写一个例子：&lt;/p&gt;
&lt;p&gt;　通过v-bind绑定disabled属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app10&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;='message' &lt;/span&gt;&lt;span&gt;v-bind:disabled&lt;/span&gt;&lt;span&gt;=&quot;isButtonDisabled&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app10 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            data: {
                message: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v-bind绑定标签特性&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                isButtonDisabled: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
            }
      })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）指令&lt;/p&gt;
&lt;p&gt;关于指令，上面我们已经用到几个了，指令是带有 &lt;span&gt;v- &lt;span&gt;前缀的特殊属性，angular中的指令是 &lt;span&gt;ng- &lt;span&gt;开头&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;关键词分类&lt;/strong&gt;：&lt;span&gt;[ v-bind绑定标签属性 ]&lt;/span&gt;，&lt;span&gt;[ v-if条件 ]&lt;/span&gt;，&lt;span&gt;[ v-for循环 ]&lt;/span&gt;，&lt;span&gt;[ v-on绑定事件 ]&lt;/span&gt; ，&lt;span&gt;[ v-model双向绑定 ]，[ v-show显示隐藏 ]，[ v-text/v-html读取 ]，[ v-once一次性插值 ]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面列出了指令关键词的一些分类，对于条件指令：存在v-if，那么一定会有&lt;span&gt;v-else&lt;/span&gt;，&lt;span&gt;v-else-if。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;丶&lt;span&gt;v-bind&lt;/span&gt; 绑定标签属性，&lt;span&gt;说起标签属性，我们都知道，&lt;span&gt;class、id、href、disabled...等等这些都是属于标签的属性，上面写了一个绑定disabled属性的例子，那么v-bind对于绑定class是不是那么得心应手呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    .red &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .blue &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; blue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px;height: 100px;&quot;&lt;/span&gt;&lt;span&gt; v-bind:class&lt;/span&gt;&lt;span&gt;='isred?&quot;red&quot;:&quot;blue&quot;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px;height: 100px;&quot;&lt;/span&gt;&lt;span&gt; v-bind:class&lt;/span&gt;&lt;span&gt;='[{red:&quot;isred&quot;}]'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#box&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            data() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                    isred: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                }
            }
         })
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201710/1140602-20171015015217652-1233229256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看了一下效果，看来v-bind可以很好的操作标签属性，包括class、id等这些&lt;/p&gt;
&lt;p&gt;丶&lt;span&gt;v-if &lt;span&gt;主要做添加判断，操作删除Dom元素，&lt;span&gt;来写一个简单的例子：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px;height: 100px;background: black;&quot;&lt;/span&gt;&lt;span&gt; v-if&lt;/span&gt;&lt;span&gt;=&quot;show&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 300px;height: 300px;background: blue&quot;&lt;/span&gt;&lt;span&gt; v-else&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#box&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        data(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                show: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            }
        }
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;丶&lt;span&gt;v-for&lt;/span&gt; &lt;span&gt;做循环遍历数据等&lt;/span&gt;，并通过插值表达式将它们输出到页面&lt;/p&gt;
&lt;p&gt;丶&lt;span&gt;v-on&lt;/span&gt; &lt;span&gt;绑定事件&lt;/span&gt;，能绑定的事件有很多：参考 &lt;a title=&quot;okaychen&quot; href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Events&quot; target=&quot;_blank&quot;&gt;MDN 事件类型一览表&lt;/a&gt;，写一个click的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201710/1140602-20171015020953512-89160387.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{message}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:click&lt;/span&gt;&lt;span&gt;=&quot;reverseMessage&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;逆转消息&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app5 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
     el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
     data: {
         message: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello v-on!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
     },
     methods: {
         reverseMessage: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
             &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.message &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.message.split(&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;).reverse().join(&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
         }
     }
 })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;丶&lt;span&gt;v-model&lt;/span&gt; &lt;span&gt;双向绑定&lt;/span&gt; ，使用v-model实现双向数据绑定，&lt;/p&gt;
&lt;p&gt;在看vue双向数据绑定之前，我们先看一下一个简单的angular的双向数据绑定：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ng-app&lt;/span&gt;&lt;span&gt;=&quot;myApp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ng-controller&lt;/span&gt;&lt;span&gt;=&quot;myCtrl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ note }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; ng-model&lt;/span&gt;&lt;span&gt;=&quot;note&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; myModule &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; angular.module(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myApp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, []);
myModule.controller(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myCtrl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$scopp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;($scope) {
    $scope.note &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
]);
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来写一个vue的双向绑定例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 双向绑定：v-model &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app6&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{message}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt;&lt;span&gt; v-on:change&lt;/span&gt;&lt;span&gt;='textChange'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app6 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
     el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
     data: {
         message: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello v-modle!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
     },
     methods: {
         textChange: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
             console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.message);
         }
     }
 })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从我个人而言，在这里相比之下，vue的代码编写风格更加简洁，通俗易懂；&lt;/p&gt;

&lt;p&gt;vue支持内联表达式，可以完成简单的布尔操作，字符串拼接；但是如果涉及更复杂的逻辑，就需要用到计算属性了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关键词&lt;/strong&gt;：&lt;span&gt;[ 计算属性computed ]&lt;/span&gt;，&lt;span&gt;[  计算属性computed  VS 方法methods ]&lt;/span&gt;，&lt;span&gt;[ 计算属性computed VS 监听属性watch ]&lt;/span&gt;，&lt;span&gt;[ 计算属性的setter ]&lt;/span&gt;，&lt;span&gt;[ 侦听器watch ]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;丶计算属性computed VS 方法methods，特点：&lt;strong&gt;计算属性&lt;/strong&gt; &lt;span&gt;依赖缓存，不必每次执行函数，直到相关值发生变化时才重新计算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;丶计算属性computed VS 侦听watch，特点：&lt;span&gt;&lt;span&gt;&lt;strong&gt;watc&lt;/strong&gt;h&lt;/span&gt; 过程式，$watch回调&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app11&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Original message:&quot;{{ message }}&quot;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Computed reversed message:&quot;{{ reversedMessage1 }}&quot;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app12&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{fullName}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算属性&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app11 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
     el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
     data: {
         message: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
     },
     computed: {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算属性的getter&lt;/span&gt;
&lt;span&gt;         reversedMessage1: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.message.split(&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;).reverse().join(&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;);
         }
     }
 })
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; watch侦听属性&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app12 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
     el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app12&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
     data: {
         firstName: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
         lastName: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
         fullName: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
     },
     watch: {
         firstName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val) {
             &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fullName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; val &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lastName;
         },
         lastName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val) {
             &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fullName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.firstName &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; val;
         }
     }
 })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种情况下，我们往往选择计算属性。&lt;/p&gt;
&lt;p&gt;丶计算属性的&lt;span&gt;setter&lt;/span&gt;，像上面那样，一般computed计算属性默认只有一个getter，但是如果有需要可以提供一个setter给计算属性；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app13&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{fullName}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算属性的setter&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app13 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
     el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app13&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
     data: {
         firstName: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;okay&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
         lastName: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chen&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
         fullName: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;okay chen&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
     },
     computed: {
         fullName: {
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; getter&lt;/span&gt;
&lt;span&gt;             get: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.firstName &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lastName
             },
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; setter&lt;/span&gt;
&lt;span&gt;             set: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(newValue) {
                 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; names &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; newValue.split(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                 &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.firstName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; names[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
                 &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lastName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; names[names.length &lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
             }
         }
     }
 })
 app13.fullName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;john Doe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
 console.log(app13.fullName);
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前端的一些技术都是融会贯通的，学习一门语言或者框架本身并不是为了学习它的技术，最重要的是学习它的思维，只有思维层面得到了延伸，学习其他技术的时候会发现得心应手。&lt;/p&gt;
&lt;p&gt;学习vue我往往联想到小程序，虽然我没有做过vue的项目，但是做过几个小程序的项目，发现他们之间或多或少有些相识之处，&lt;/p&gt;
&lt;p&gt;比如vue利用data设置暴露数据，小程序利用&lt;span&gt;data&lt;/span&gt;和&lt;span&gt;setData()&lt;/span&gt;暴露数据；&lt;/p&gt;
&lt;p&gt;两者的列表渲染：vue是v-for循环同时利用&lt;span&gt;for-in&lt;/span&gt;迭代器 (item in items) ，小程序wx-for循环同时利用 wx:for-item=&quot;item&quot;，angular则是ng-repeat渲染列表&lt;/p&gt;
&lt;p&gt;Vue带给我们的是前端一种解决问题的新的思维，我们应该欣然接受他，也应该欣然接受那些你暂时没有选择或者考虑在内的框架；&lt;/p&gt;

</description>
<pubDate>Sat, 14 Oct 2017 19:20:00 +0000</pubDate>
<dc:creator>OkayChen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okaychen/p/7669487.html</dc:identifier>
</item>
<item>
<title>高效实用的.NET开源项目 - 彭泽0902</title>
<link>http://www.cnblogs.com/pengze0902/p/7669631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pengze0902/p/7669631.html</guid>
<description>&lt;p&gt;      似乎...很久很久没有写博客了，一直都想写两篇，但是却没有时间写。感觉最近有很多事情需要处理，一直都是疲于奔命，一直到最近才变得有些时间学习和充电。最近没有事情都会看一些博客和开源项目，发现介绍开源项目的文章似乎有些旧，而且很多介绍开源项目的文章都有比较相似的地方，毕竟.NET很好很实用的项目的确有限。&lt;/p&gt;
&lt;p&gt;    很多人也想了解一下最新和感觉有用的.NET开源项目，但是又没有时间去GitHub去逐一的看。感觉自己没事就花了几个小时，去GitHub看了搜索到的100个项目，个人觉得比较实用的项目就自己做了一个整理。（备注：很多比较新的和比较厉害的组件和项目没有写入，因为很多文章都已经介绍过了，而且很多人也使用了，所以就没有怎么介绍）&lt;/p&gt;
&lt;p&gt;    最近忙着在做“在线协议”的方案，整个方案都实现，但是却陷入一个坑爹的场景，那就是在线协议需要借用UE对粘贴的文档进行转换为HTML，但是原始文档的格式很容易出现问题，导致生成的HTML标记也会产生问题，已至后面的正式的协议PDF文件和World文件都会失真，想看看大家有没有好的意见。（后面我会将目前的实现方案写出来分享）&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;1.Akka.NET&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：更轻松地构建强大的并发和分布式应用。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：Akka.NET是一个用于在.NET和Mono上构建高度并发，分布式和容错的事件驱动应用程序的工具包和运行时。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/akkadotnet/akka.net&quot;&gt;https://github.com/akkadotnet/akka.net&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  &lt;strong&gt;2.Topshelf&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：使用.NET构建Windows服务的简单服务托管框架。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：Topshelf是托管使用.NET框架编写的服务的框架。服务的创建被简化，允许开发人员创建一个简单的控制台应用程序，可以使用Topshelf作为服务安装。原因很简单：调试控制台应用程序比服务容易得多。一旦应用程序经过测试并可以进行生产，Topshelf可以轻松安装应用程序作为服务。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/Topshelf/Topshelf&quot;&gt;https://github.com/Topshelf/Topshelf&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  3.IdentityServer3&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：OpenID Connect Provider和用于ASP.NET 4.x / Katana的OAuth 2.0授权服务器框架。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：IdentityServer是一个基于.NET / Katana的框架和可托管组件，允许使用OpenID Connect和OAuth2等协议实现对现代Web应用程序和API的单一登录和访问控制。它支持广泛的客户端，如移动，Web，SPA和桌面应用程序，并且是可扩展的，可以集成到新的和现有的架构中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer3&quot;&gt;https://github.com/IdentityServer/IdentityServer3&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  4.MediatR&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：在.NET中简单的中介器实现。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：进程内消息传递，无依赖关系。支持请求/响应，命令，查询，通知和事件，通过C＃通用方差进行智能调度的同步和异步。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/jbogard/MediatR&quot;&gt;https://github.com/jbogard/MediatR&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  5.MassTransit：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：.NET的分布式应用程序框架。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：MassTransit可以轻松创建应用和服务，利用基于消息的松散耦合的异步通信，实现更高的可用性，可靠性和可扩展性。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/MassTransit/MassTransit&quot;&gt;https://github.com/MassTransit/MassTransit&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  6.microdot：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：一个开源的.NET微服务框架。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：Microdot框架可帮助您创建可扩展和可靠的微服务（&lt;a href=&quot;http://microservices.io/patterns/microservice-chassis.html&quot;&gt;“微服务机架”&lt;/a&gt;），让您专注于编写定义服务逻辑的代码，而无需解决开发分布式系统的无数挑战。Microdot还可以很好地与 &lt;a href=&quot;https://dotnet.github.io/orleans/&quot;&gt;Orleans&lt;/a&gt;虚拟演员框架相结合，让您轻松地编写基于 &lt;a href=&quot;https://dotnet.github.io/orleans/&quot;&gt;Orleans&lt;/a&gt;微型服务。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/gigya/microdot&quot;&gt;https://github.com/gigya/microdot&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  7.Docker.DotNet：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：用于Docker API的.NET（C＃）客户端库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：与 .NET应用程序中的Docker Remote API端点进行交互。它是完全异步的，旨在以非阻塞和面向对象的方式通过编程方式与Docker守护程序进行交互。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/Microsoft/Docker.DotNet&quot;&gt;https://github.com/Microsoft/Docker.DotNet&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  8.Z.ExtensionMethods&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：C＃扩展方法| .NET开源和免费库&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：通过超过1000种扩展方法增强.NET Framework。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/zzzprojects/Z.ExtensionMethods&quot;&gt;https://github.com/zzzprojects/Z.ExtensionMethods&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  9.SuperWebSocket：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：SuperWebSocket是WebSocket服务器的.NET实现。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：WebSocket是通过单个传输控制协议（TCP）插座提供双向，全双工通信信道的技术。它被设计为在Web浏览器和Web服务器中实现，但它可以被任何客户端或服务器应用程序使用。SuperWebSocket被合并到&lt;a href=&quot;https://github.com/kerryjiang/SuperSocket&quot;&gt;SuperSocket&lt;/a&gt;作为附加模块SuperSocket.WebSocket。您可以使用SuperSocket.WebSocket用相同的方式SuperWebSocket但有不同的命名空间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/kerryjiang/SuperWebSocket&quot;&gt;https://github.com/kerryjiang/SuperWebSocket&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  10.Seal-Report：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：开放数据库报表工具（.Net）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：Seal-Report提供了一个完整的框架，用于从任何数据库生成日常报告和仪表板。Seal-Report是Microsoft .NET Framework完全用C＃编写的开源工具。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/ariacom/Seal-Report&quot;&gt;https://github.com/ariacom/Seal-Report&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  11.accord-net-extensions：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：先进的图像处理和计算机视觉算法作为流畅的扩展而构建为可移植性。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：Accord.NET Extensions是Accord.NET和AForge.NET的扩展框架。框架集中将.NET本地数组作为主要成像对象，并提供大多数构建为扩展的计算机视觉算法。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/dajuric/accord-net-extensions&quot;&gt;https://github.com/dajuric/accord-net-extensions&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  12.MediaToolkit&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：用于转换和处理所有视频和音频文件的.NET库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：MediaToolkit为处理媒体数据提供了一个简单的界面，完成了轻松转换，切片和编辑音频和视频等任务。在引擎盖下，MediaToolkit是一个用于FFmpeg的.NET包装器; 一个包含多个音频和视频编解码器的免费（LGPLv2.1）多媒体框架，支持多种媒体格式的多路复用，解复用和转码任务。（从视频抓住缩略图，检索元数据，基本转换，将Flash视频转换为DVD，转码选项FLV到MP4，将视频缩小到较小的长度）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/AydinAdn/MediaToolkit&quot;&gt;https://github.com/AydinAdn/MediaToolkit&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt; 13.htmldiff.net：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：.NET的Html Diff算法。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：用于比较两个HTML文件/片段的库，并使用简单的HTML突出显示差异。这个HTML Diff实现是在这里找到的ruby实现的C＃端口。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/Rohland/htmldiff.net&quot;&gt;https://github.com/Rohland/htmldiff.net&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  14.CalbucciLib.ExtensionsGalore：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：.NET中内置类型和类的扩展的100个扩展。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：ExtensionsGalore是一个库，可以扩展.NET的许多常见类型和类别，以便快速方便地访问Web和移动开发的常见场景。换句话说，它可以帮助您编写更少的代码行，并将更多的焦点集中在应用程序中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/calbucci/CalbucciLib.ExtensionsGalore&quot;&gt;https://github.com/calbucci/CalbucciLib.ExtensionsGalore&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  15.Dapper：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　概述：Dapper - 一个简单的对象映射器.Net&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　简介：Dapper的一个关键特性是性能。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开源地址：&lt;a href=&quot;https://github.com/StackExchange/Dapper&quot;&gt;https://github.com/StackExchange/Dapper&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    以上只是简单的介绍了一些开源项目，后面如果有时间和精力，会写一些组件和开源项目的介绍，如果大家也有觉得比较好的项目，也可以在博客下面留言分享，让大家一起学习。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 17:49:00 +0000</pubDate>
<dc:creator>彭泽0902</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pengze0902/p/7669631.html</dc:identifier>
</item>
<item>
<title>Unity编辑器下重启 - wuzhang</title>
<link>http://www.cnblogs.com/wuzhang/p/wuzhang20171014.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuzhang/p/wuzhang20171014.html</guid>
<description>&lt;pre&gt;
　&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetUnityPath()
    {
        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 通过注册便获取Unity安装路径
        &lt;span&gt;var&lt;/span&gt; regKey = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Unity package file\DefaultIcon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        RegistryKey registryKey &lt;/span&gt;=&lt;span&gt; Registry.ClassesRoot.OpenSubKey(regKey);
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; pathName = (&lt;span&gt;string&lt;/span&gt;)registryKey.GetValue(&lt;span&gt;null&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;(Default)&quot;  &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(pathName))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = pathName.LastIndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index != -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; exepath = pathName.Substring(&lt;span&gt;0&lt;/span&gt;, index).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; binpath =&lt;span&gt; Path.GetDirectoryName(exepath); 
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; di = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DirectoryInfo(binpath);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (di.Parent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; di.Parent.FullName;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;   
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 14 Oct 2017 17:28:00 +0000</pubDate>
<dc:creator>wuzhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuzhang/p/wuzhang20171014.html</dc:identifier>
</item>
<item>
<title>PHP多进程编程之僵尸进程问题 - Summer7C</title>
<link>http://www.cnblogs.com/Summer7C/p/7669321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Summer7C/p/7669321.html</guid>
<description>&lt;p&gt;上一篇说到了使用pcntl_fork函数可以让PHP实现多进程并发或者异步处理的效果。那么问题是我们产生的进程需要去控制，而不能置之不理。最基本的方式就是fork进程和杀死进程。&lt;/p&gt;
&lt;p&gt;通过利用pcntl_fork函数，我们已经有了新的子进程，而子进程接下来完成我们需要处理的内容，那么我们就暂且叫做service()吧，而且我们需要很多个service()进行处理，再次参照我们之前的需求，父进程需要一直循环读取配置文件，等待文件发生改变。通过对pcntl_fork的方式，很容易我们就可以写出如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$res&lt;/span&gt; =&lt;span&gt; config();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;kill进程&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;$i&lt;/span&gt; = 0; &lt;span&gt;$i&lt;/span&gt; &amp;lt; &lt;span&gt;$res&lt;/span&gt;[sum]; &lt;span&gt;$i&lt;/span&gt;++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;$pid&lt;/span&gt; =&lt;span&gt; pcntl_fork();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$pid&lt;/span&gt; == 0&lt;span&gt;) {
        service();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中注释的地方我们需要在配置文件中发生改变的时候杀死进程，杀死进程的的方式很简单，可以使用kill命令直接杀死，比如（假设pid为123）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;kill&lt;/span&gt; &lt;span&gt;123&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是我们发现，使用这个杀死进程的方式并没有真正的把进程杀死，这个子进程被杀死后还占用这个进程的资源，我们成为僵尸进程，僵尸进程是使用kill命令无法杀死的。想要解决这个问题，我们能做的只有两种方式。&lt;/p&gt;
&lt;p&gt;1. shutdown&lt;/p&gt;
&lt;p&gt;2. 杀死该进程的父进程。&lt;/p&gt;
&lt;p&gt;但是这两种方法都不行，因为这个程序的目的是监控常驻在服务器内，服务器不能关闭，并且父进程也不能被干掉。这时候我们看到了官方文档对于fork方法的解释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; pcntl_wait(&lt;span&gt;$status&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待子进程中断，防止子进程成为僵尸进程。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原来有种方式可以防止进程成为僵尸进程，但是，官网给出的代码是这样子的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;$pid&lt;/span&gt; =&lt;span&gt; pcntl_fork();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父进程和子进程都会执行下面代码&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$pid&lt;/span&gt; == -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误处理：创建子进程失败时返回-1.&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;die&lt;/span&gt;('could not fork'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$pid&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父进程会得到子进程号，所以这里是父进程执行的逻辑&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;      pcntl_wait(&lt;span&gt;$status&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待子进程中断，防止子进程成为僵尸进程。&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子进程得到的$pid为0, 所以这里是子进程执行的逻辑。&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;什么意思呢？就是父进程会等待子进程运行，等子进程运行结束之后，才会进行下一步，并且也会消除僵尸进程。但是这里又和我们的需求不符合了，我们的子进程为一个死循环的程序，不断的查找输出，更本没有结束的时候，并且我们需要的是异步处理而不是同步。但是这个方法可以用吗？其实当然可以。&lt;/p&gt;
&lt;p&gt;在pcntl_wait的文档中是这么解释这个函数的：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;wait函数刮起当前进程的执行直到一个子进程退出或接收到一个信号要求中断当前进程或调用一个信号处理函数。 如果一个子进程在调用此函数时已经退出（俗称僵尸进程），此函数立刻返回。子进程使用的所有系统资源将 被释放。关于wait在您系统上工作的详细规范请查看您系统的wait（2）手册。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们发现，当这个函数发现子进程成为了僵尸进程就会释放僵尸进程的资源——前提是这个僵尸进程为这个父进程的子进程。那么我们就可以巧妙的利用这个方式让这些僵尸进程释放资源了，所以就有了如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; posix_kill(123, 9&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; pcntl_wait(&lt;span&gt;$status&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们先使用kill干掉这个进程，这个进程就不会再运行了，但是这个进程成为了僵尸进程，占用着资源，我们下一句就执行一次pcntl_wait()让这些僵尸进程释放资源，这样，子进程才真正的被终止了，僵尸进程被消除了。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 16:53:00 +0000</pubDate>
<dc:creator>Summer7C</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Summer7C/p/7669321.html</dc:identifier>
</item>
<item>
<title>【网络爬虫入门02】HTTP客户端库Requests的基本原理与基础应用 - 小蜜蜂老师</title>
<link>http://www.cnblogs.com/ALittleBee/p/7669180.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ALittleBee/p/7669180.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;【网络爬虫入门02】HTTP客户端库Requests的基本原理与基础应用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;广东职业技术学院  欧浩源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、引言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    实现网络爬虫的第一步就是要建立网络连接并向服务器或网页等网络资源发起请求。&lt;span&gt;&lt;strong&gt;urllib&lt;/strong&gt;&lt;/span&gt;是目前最常用的做法，然而&lt;span&gt;&lt;strong&gt;Requests&lt;/strong&gt;&lt;/span&gt;会比urlib更加方便，能够让人以更加简单的方式获取网络资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、什么是Requests？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;&lt;span&gt;Requests&lt;/span&gt;&lt;/strong&gt;是用&lt;span&gt;&lt;strong&gt;Python&lt;/strong&gt;&lt;/span&gt;语言编写，基于&lt;span&gt;&lt;strong&gt;urllib&lt;/strong&gt;&lt;/span&gt;，采用&lt;span&gt;&lt;strong&gt;Apache2 Licensed&lt;/strong&gt;&lt;/span&gt;开源协议的&lt;span&gt;&lt;strong&gt;HTTP库&lt;/strong&gt;&lt;/span&gt;。它比urllib更加方便，可以节约我们大量的工作，完全满足HTTP测试需求。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;Requests对象&lt;/strong&gt;&lt;/span&gt;有Get、Post、Put、Delete、Head、Options等HTTP方法，使用起来非常简单。对于WEB系统，一般只支持Get和Post方法。在网络爬虫中，&lt;span&gt;&lt;strong&gt;Get方法&lt;/strong&gt;&lt;/span&gt;最常用。在本文中也重点讨论该方法相关的应用，其他方法即更加详细的使用，见用户手册：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;http://docs.python-requests.org/zh_CN/latest/user/quickstart.html&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、发起网络请求&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    使用&lt;span&gt;&lt;strong&gt;Requests&lt;/strong&gt;&lt;/span&gt;的&lt;span&gt;&lt;strong&gt;Get方法&lt;/strong&gt;&lt;/span&gt;发送网络请求&lt;span&gt;&lt;strong&gt;非常简单&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    首先，导入Requests模块：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;strong&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;requests&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    然后，通过URL向网页发起请求：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;strong&gt;res = &lt;span&gt;requests&lt;/span&gt;.&lt;span&gt;get&lt;/span&gt;('http://www.gdptc.cn/')&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    这时，我们有一个名为res的Requests对象，从这个对象中我们可以获取所有我们想要的信息，例如将网页的URL打印出来。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt; &lt;/span&gt; &lt;strong&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;res.url&lt;/span&gt;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1172284/201710/1172284-20171015001451137-1470132977.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、获取响应内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    我们能读取服务器响应的内容。Requests会&lt;span&gt;&lt;strong&gt;自动解码&lt;/strong&gt;&lt;/span&gt;来自服务器的内容，大多数&lt;span&gt;&lt;strong&gt;unicode字符集&lt;/strong&gt;&lt;/span&gt;都能被&lt;span&gt;&lt;strong&gt;无缝地解码&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1172284/201710/1172284-20171015001649965-1737898022.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    请求发出后，&lt;span&gt;&lt;strong&gt;Requests会&lt;span&gt;基于HTTP头部&lt;/span&gt;对响应的&lt;span&gt;编码&lt;/span&gt;作出有根据的推测&lt;/strong&gt;&lt;/span&gt;。当你访问res.text 之时，Requests会使用其推测的文本编码。你可以找出 Requests使用了什么编码，并且&lt;span&gt;&lt;strong&gt;能够使用res.encoding属性来&lt;span&gt;改变它&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1172284/201710/1172284-20171015001821559-1410607405.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    如果你&lt;span&gt;&lt;strong&gt;改变了编码&lt;/strong&gt;&lt;/span&gt;，每当你访问 res.text ，Request 都将会使用res.encoding的&lt;span&gt;&lt;strong&gt;新值&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1172284/201710/1172284-20171015001851137-350698867.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、响应头的内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;&lt;span&gt;服务器响应头&lt;/span&gt;&lt;/strong&gt;以一个Python&lt;span&gt;&lt;strong&gt;字典&lt;/strong&gt;&lt;/span&gt;的形式来表示。这个字典比较特殊，它是仅为HTTP头部而生的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;res.headers&lt;/strong&gt;&lt;/span&gt;的结果是：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  '&lt;span&gt;&lt;strong&gt;Content-Length&lt;/strong&gt;&lt;/span&gt;' : '&lt;span&gt;&lt;strong&gt;39037&lt;/strong&gt;&lt;/span&gt;'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  '&lt;span&gt;&lt;strong&gt;X-Powered-By&lt;/strong&gt;&lt;/span&gt;' : '&lt;span&gt;&lt;strong&gt;ASP.NET&lt;/strong&gt;&lt;/span&gt;'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  '&lt;span&gt;&lt;strong&gt;Date&lt;/strong&gt;&lt;/span&gt;' : '&lt;span&gt;&lt;strong&gt;Sat, 14 Oct 2017 13:58:41 GMT&lt;/strong&gt;&lt;/span&gt;'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  '&lt;span&gt;&lt;strong&gt;X-AspNet-Version&lt;/strong&gt;&lt;/span&gt;' : '&lt;span&gt;&lt;strong&gt;2.0.50727&lt;/strong&gt;&lt;/span&gt;'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  '&lt;span&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt;&lt;/span&gt;' : '&lt;span&gt;&lt;strong&gt;private&lt;/strong&gt;&lt;/span&gt;'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  '&lt;span&gt;&lt;strong&gt;Content-Type&lt;/strong&gt;&lt;/span&gt;' : '&lt;span&gt;&lt;strong&gt;text/html; &lt;span&gt;charset&lt;/span&gt;=utf-8&lt;/strong&gt;&lt;/span&gt;'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  '&lt;span&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/span&gt;' : '&lt;span&gt;&lt;strong&gt;Microsoft-IIS/7.5&lt;/strong&gt;&lt;/span&gt;'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    通过这个服务器的响应头，我们可以知道服务器的一些基本数据信息。根据 RFC2616， &lt;span&gt;&lt;strong&gt;HTTP头部是大小写不敏感的&lt;/strong&gt;&lt;/span&gt;。因此，我们可以使用任意大写形式来访问这些响应头字段。例如我们想查看服务器的编码和服务器型号：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1172284/201710/1172284-20171015001957230-1665678403.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6、定制请求头&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    如果你想为请求添加&lt;span&gt;&lt;strong&gt;HTTP头部&lt;/strong&gt;&lt;/span&gt;，只要简单地传递一个&lt;span&gt;&lt;strong&gt;dict&lt;/strong&gt;&lt;/span&gt;给&lt;span&gt;&lt;strong&gt;headers&lt;/strong&gt;&lt;/span&gt;参数就可以了。很多服务器对于非正常的请求往往会拒绝，这时候就需要给网络请求穿上合法的外衣，而伪装请求头部则是最常用的手段。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    用户代&lt;span&gt;&lt;strong&gt;理User Agent&lt;/strong&gt;&lt;/span&gt;，是HTTP协议中的一部分，属于请求头的组成部分。它是一个&lt;span&gt;&lt;strong&gt;特殊字符串头&lt;/strong&gt;&lt;/span&gt;，是一种向访问网站提供你所使用的&lt;span&gt;&lt;strong&gt;&lt;span&gt;浏览器&lt;/span&gt;类型及版本、&lt;span&gt;操作系统&lt;/span&gt;及版本、&lt;span&gt;浏览器内核&lt;/span&gt;等信息的标识&lt;/strong&gt;&lt;/span&gt;。通过添加合法浏览器的UA信息，可以将爬虫的请求伪装成浏览器的请求。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    例如，IE9浏览器的User Agent为：&lt;span&gt;&lt;strong&gt;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    这些常用的浏览器UA在网上都可以查到。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    如果要模拟IE9浏览器访问百度网站，可以这样实现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1172284/201710/1172284-20171015002042152-146445081.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    Requests不会基于定制 header 的具体情况改变自己的行为。只不过在最后的请求中，&lt;span&gt;&lt;strong&gt;所有的header信息都会被传递进去&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;7、小结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    Requests的用法远不止此，但作为网络爬虫的入门应用，上述知识基本足够。向服务器发送请求的方法也不止一种，怎么熟悉怎么用，怎么方便怎么用，作为入门，多了解，多学习，多练习，多应用才是正道。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 16:37:00 +0000</pubDate>
<dc:creator>小蜜蜂老师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ALittleBee/p/7669180.html</dc:identifier>
</item>
<item>
<title>Socket简单实现数据交互及上传 - 孤独是1态度</title>
<link>http://www.cnblogs.com/gudu1/p/7669175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gudu1/p/7669175.html</guid>
<description>
&lt;p&gt;声明：本文为原创，如需转载请说明出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Socket简单实现数据交互及上传&quot; href=&quot;http://www.cnblogs.com/gudu1/p/7669175.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/gudu1/p/7669175.html&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;首先为什么要写这个呢？因为在几个月之前我还使用Socket做一个小项目，而在今天我回想起Socket的操作细节，在我脑海里使劲挖掘Socket的痕迹，竟然丝毫没有找到，我很苦恼，所以立即写了一个小Demo来记录一下，有些东西长时间不用肯定要忘的，要知道人的脑容量是有限的，跟电脑缓存一样，不够用的时候会把那些不用的占内存的给释放掉， 就到这吧，说正题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 　  Socket 和 ServerSocket 的官方API解释：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;Socket&lt;/span&gt; ： 此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;ServerSocket&lt;/span&gt;：此类实现服务器套接字。服务器套接字等待请求通过网络传入。它基于该请求执行某些操作，然后可能向请求者返回结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　套接字的实际工作由 &lt;code&gt;SocketImpl&lt;/code&gt; 类的实例执行。应用程序通过更改创建套接字实现的套接字工厂可以配置它自身，以创建适合本地防火墙的套接字。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　在这个Demo中我使用了java.net包下的两个类：Socket 和 ServerSocket ，使用到的自定义类有3个：Service 、 Client 、ServiceThread，下面配合代码来解释一下&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　ServiceThread.java ，&lt;span&gt;就把它当做一个服务器处理程序就好了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.ServerSocket;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Socket;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;public class&lt;/span&gt; ServiceThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    Socket s &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServiceThread(Socket socket) { &lt;span&gt;// ①
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.s =&lt;span&gt; socket;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        String ip &lt;/span&gt;=&lt;span&gt; s.getInetAddress().getHostName();&lt;span&gt; // ②&lt;/span&gt;
        System.out.println(&lt;/span&gt;&quot;ip:&quot;+&lt;span&gt;ip); 
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            InputStream is &lt;/span&gt;=&lt;span&gt; s.getInputStream(); &lt;span&gt;// ③
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len = 0&lt;span&gt;;    
            File file &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(&quot;D:/heheCopy.java&quot;&lt;span&gt;);&lt;span&gt; // ④&lt;/span&gt;
            OutputStream os &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(file);
            System.out.println(&lt;/span&gt;&quot;开始上传&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((len = is.read(buf)) != -1&lt;span&gt;){ &lt;span&gt;// ⑤&lt;/span&gt;
                os.write(buf,&lt;/span&gt;0&lt;span&gt;,len);  &lt;span&gt;// ⑥&lt;/span&gt;
            }    
            System.out.println(&lt;/span&gt;&quot;上传完毕&quot;&lt;span&gt;);
            is.close();
            os.close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
        }
        
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　 &lt;span&gt;① ：类只有一个构造函数，参数是Socket对象（即一个用户），因为在服务器和客户端是通过 I/O 流来交互，所以服务器端要获取客户端的IO对象（即输入输出流）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　②： 获取客户端的IP地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③： 获取客户端的输入流，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　④： 创建一个File对象，并指定客户端传输过来的数据存放的位置，如果不存在该文件就自动创建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　⑤： 开始从流中读取数据，并存放在byte数组缓冲区中，在客户端的输出流未写入之前此方法一直处于阻塞状态（即等待状态）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　⑥： 开始写入服务器本地文件&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　Client.java ，&lt;span&gt;当做一个客户端&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Socket s &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Socket(&quot;127.0.0.1&quot;, 10001&lt;span&gt;);  &lt;span&gt;// ①&lt;/span&gt;
        InputStream is &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;D:/hehe.java&quot;&lt;span&gt;);&lt;span&gt; // ②
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((len = is.read(buf))!=-1&lt;span&gt;){
            s.getOutputStream().write(buf,&lt;/span&gt;0&lt;span&gt;,len); &lt;span&gt;// ③&lt;/span&gt;
        }
        s.shutdownOutput();&lt;span&gt; // ④&lt;/span&gt;
        System.out.println(&lt;/span&gt;&quot;读取完毕&quot;&lt;span&gt;);
        is.close();
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　 &lt;span&gt;①： 创建 Socket 对象，传入要连接服务器的 IP 和 端口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　②： 创建一个输入流对象读取要上传的文件路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③： 获取 Socket 输出流对象并将读取到的数据写入输出流中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　④： 任何以前写入的数据都将被发送，如果不调用这个方法，那么在服务器端就不会知道数据已经传输完毕，将继续调用此 Socket 输入流的 read 方法，那么此时客户端只是一个Java程序，已经执行完毕，虚拟机将释放资源，这时，此Socket已经被 close掉，程序将抛出 SocketException 异常。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　Serivce.java ，&lt;span&gt;服务器&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Service{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        ServerSocket ss &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ServerSocket(10001&lt;span&gt;); &lt;span&gt;// ①
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            Socket s &lt;/span&gt;=&lt;span&gt; ss.accept(); &lt;span&gt;// ②
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceThread(s)).start();  &lt;span&gt;// ③&lt;/span&gt;
        }
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;　　①： 创建服务器对象，指定该服务器的端口号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　②： 获得请求连接到该服务器的客户端对象Socket&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③： 启动服务器处理程序线程，因为程序是无限循环，所以每当一个客户端连接进来都会创建一个新的线程&lt;/span&gt;&lt;/p&gt;



&lt;p&gt; 　　　　　　　　　&lt;span&gt;　&lt;span&gt;The End。。。。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 14 Oct 2017 16:35:00 +0000</pubDate>
<dc:creator>孤独是1态度</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gudu1/p/7669175.html</dc:identifier>
</item>
<item>
<title>机器翻译评测——一种检测批量译文是否参考机器翻译的方法 - 胖喵~</title>
<link>http://www.cnblogs.com/by-dream/p/7669139.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/by-dream/p/7669139.html</guid>
<description>&lt;p&gt;　　◆&lt;strong&gt;版权声明：本文出自胖喵~的博客，转载必须注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　转载请注明出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 机器翻译评测——一种检测批量译文是否参考机器翻译的方法&quot; href=&quot;http://www.cnblogs.com/by-dream/p/7669139.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/by-dream/p/7669139.html&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;　　首先解释一下几个名词，由于我的另外两篇文章还没有写出来，因此这里需要先介绍一下：&lt;/p&gt;
&lt;p&gt;　　翻译评测集：以下简称评测集，一组由原文和译文组成的文件，译文一般由专业的译员根据原文翻译获得，在计算BLEU的时候只需要把译文作为参考答案使用即可。&lt;/p&gt;
&lt;p&gt;　　BLEU：一种机器翻译评价指标，用于分析候选译文和参考译文中n元组共同出现的程度，由IBM于2002年提出。通常需要用译文和翻译翻译评测集共同计算获得分值，从而判定译文与评测集之间的相似程度。&lt;/p&gt;

&lt;p&gt; 　　为什么要写这么一篇文章呢？&lt;/p&gt;
&lt;p&gt;　　翻译团队在制作翻译评测集时经常需要雇佣一些译员和翻译公司进行翻译工作，由于制作的评测集需要用来评价各个机器翻译引擎，所以该译文绝对不能参考机器翻译，那么如何得知译员是否有参考机器翻译引擎就成了一个比较重要的问题。目前市面上翻译的成本大概在千字120-150元人名币，我们通过这种方法可以有效的避免无效翻译，节省成本。当有翻译公司或个人完成翻译工作后，我们用这种方法来衡量翻译的内容是否为我们可用的内容。事实证明，我这种方法确实很有效。&lt;/p&gt;

&lt;p&gt;　　此方法最便捷的方式就是通过脚本，可以快速定位出现有译文参考了哪些翻译引擎，并且可以快速定位到句子，然后人工分析句子后，就可以知道是否参考了机器翻译。&lt;/p&gt;

&lt;p&gt;　　我们来看看具体的过程：&lt;/p&gt;
&lt;p&gt;　　首先我们准备一份500句的英文语句,递交给翻译公司，需求是规定的时间内完成英文翻译中文的任务。&lt;/p&gt;
&lt;p&gt;　　在递交之后，我们使用市面上现有的机器翻译引擎（百度翻译、Google翻译、有道翻译、Bing翻译、小牛翻译、搜狗翻译、腾讯翻译君翻译）对这份译文进行翻译，得到各个引擎的中文结果文件，我们把这些文件做为将来要评测翻译公司翻译结果的一个评测集。&lt;/p&gt;
&lt;p&gt;　　待翻译公司呈交翻译结果后，我们用之前制作好的各个机器翻译引擎翻译结果的评测集针对译员的翻译结果进行BLEU的计算。我们得到如下数值：&lt;/p&gt;
&lt;p&gt;　　百度：68.4, 89.4/73.5/63.2/56.1(BP=0.985,ratio=0.985,hyp_len=60808,ref_len=61743)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　腾讯：45.96, 82.3/56.8/38.9/26.5(BP=0.981,ratio=0.981,hyp_len=60244,ref_len=61398)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　搜狗：44.92, 81.1/55.8/37.8/25.7(BP=0.980,ratio=0.981,hyp_len=59788,ref_len=60967)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　小牛：42.48, 80.5/53.9/35.7/23.3(BP=0.975,ratio=0.976,hyp_len=59451,ref_len=60940)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　Bing：42.14, 81.5/54.0/36.0/23.9(BP=0.956,ratio=0.956,hyp_len=57653,ref_len=60276)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　google：41.03, 80.8/52.5/34.3/22.5(BP=0.964,ratio=0.965,hyp_len=58155,ref_len=60260)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　有道：40.01, 80.5/52.2/34.1/22.2(BP=0.947,ratio=0.949,hyp_len=56675,ref_len=59735)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　一般我们只看第一个数值：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626346/201710/626346-20171015000336027-1801963858.jpg&quot; alt=&quot;&quot; width=&quot;446&quot; height=&quot;268&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　根据经验来看，一般BLEU的值的差距之间会比较小，例如上图中除百度之外的其他所有引擎，因此我们可以判断出百度的分值的异常，很有可能就是因为译文有大量参考百度机器翻译的原因，为了证实这个结论，我们需要用百度的机器翻译译文和人工翻译的译文进行比较，可以使用“比较软件Beyond Compare”，也可以使用我自己实现的same.py脚本，可以直接看出百度的机器翻译译文和人工翻译的译文中完全相同的句子。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626346/201710/626346-20171015000322215-1165022352.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　如上图所示，红色部分是两篇译文直接有差距的地方，白色底色的部分就是完全相同的句子。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　这时候我们再次提取出这些完全相同的句子，BLEU如果特别高，基本就说明了参考的可能性越大，这时候我们对这些句子进行流畅度和翻译忠实度两个标准进行评判，如果句子本身质量特别高，都没有问题，那么说明百度的翻译质量非常高，已经接近了人翻，但是一般情况下人工评测完的结果都是这些句子的质量不是特别好，那么就说明这些句子并不是来自人翻，而是直接采用了机器翻译的结果。&lt;/p&gt;
&lt;p&gt;　　之前合作的几家翻译公司提供过来的译文经过这种方法的计算后，均发现了译文有参考翻译引擎的嫌疑，事后经过人工二次确认，发现翻译公司确实没有按照规定完成任务，译员在翻译的过程中参考了机器翻译，甚至有些直接采用了一些有问题的机器翻译的结果。&lt;/p&gt;
&lt;p&gt;　　说实话人都有惰性，一般让一个译员翻译过多的译文，难免会出现这样的情况，只要我们掌握了这个方法，就可以有效的避免这样事情的发生了。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 16:13:00 +0000</pubDate>
<dc:creator>胖喵~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/by-dream/p/7669139.html</dc:identifier>
</item>
<item>
<title>RN 常见问题 - shidaying</title>
<link>http://www.cnblogs.com/shidaying/p/7669046.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shidaying/p/7669046.html</guid>
<description>&lt;h2 id=&quot;reactrctbridgemodule.h-not-found&quot;&gt;React/RCTBridgeModule.h not found&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#import &amp;lt;React/RCTBridgeModule.h&amp;gt; 全部替换为
#import &quot;RCTBridgeModule.h&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样也有可能遇到 #import &quot;RCTBridgeModule.h&quot; 找不到，可以尝试替换为 #import &amp;lt;React/RCTBridgeModule.h&amp;gt;&lt;/p&gt;
&lt;h2 id=&quot;ignoring-return-value-of-function-declared-with-warn_unused_result-attribute&quot;&gt;Ignoring return value of function declared with 'warn_unused_result' attribute&lt;/h2&gt;
&lt;p&gt;上述错误出现在 RCTWebSockect文件中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes);  全部替换为
(void)SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外一种解决方案(没试过)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int result = SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes);
  assert(result == 0);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;react-native-scrollable-tab-view-组件的scrollabletabbar-默认选中效果出不来也就是-initialpage-无效&quot;&gt;&quot;react-native-scrollable-tab-view&quot; 组件的ScrollableTabBar 默认选中效果出不来，也就是 initialPage 无效&lt;/h2&gt;
&lt;p&gt;react-native-scrollable-tab-view 使用的是 0.6.7 版本，到 ScrollableTabBar.js 中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;this.props.scrollValue._value 全部替换为
this.props.scrollValue.__getValue()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者到官网中 ()[&lt;a href=&quot;https://github.com/skv-headless/react-native-scrollable-tab-view&quot; class=&quot;uri&quot;&gt;https://github.com/skv-headless/react-native-scrollable-tab-view&lt;/a&gt;] 查看最新版本, 使用最新版本,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd 工程目录
npm install react-native-scrollable-tab-view@0.7.4 --save
或者
yarn add react-native-scrollable-tab-view@0.7.4&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;flatlist-中-itemseparate-部分分割线不显示&quot;&gt;FlatList 中 itemSeparate 部分分割线不显示&lt;/h2&gt;
&lt;p&gt;单元格item 使用的 TouchableOpacity 作为容器，当选中单元格，再上下滚动 list, 会发现itemSeparate 不显示&lt;br/&gt;解决办法： TouchableOpacity 组件替换为 TouchableHighlight&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 15:37:00 +0000</pubDate>
<dc:creator>shidaying</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shidaying/p/7669046.html</dc:identifier>
</item>
<item>
<title>标准输入输出 stdio 流缓冲 - 李秋豪</title>
<link>http://www.cnblogs.com/liqiuhao/p/7669007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiuhao/p/7669007.html</guid>
<description>&lt;p&gt;**From : &lt;a href=&quot;http://www.pixelbeat.org/programming/stdio_buffering/**&quot; class=&quot;uri&quot;&gt;http://www.pixelbeat.org/programming/stdio_buffering/**&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我发现找出标准流用的是什么缓冲是一件困难的事。&lt;/p&gt;
&lt;p&gt;例如下面这个使用unix shell 管道的例子：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ command1 | command2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下图显示了shell fork了两个进程并通过一个管道将他们联系起来。在这个连接中移动使用了&lt;strong&gt;三个缓冲&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201710/1072319-20171014233157652-1418464708.png&quot; alt=&quot;buffers used in simple unix shell pipeline&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内核中的缓冲区室友pipe系统函数生成的，它的大小取决于操作系统的页大小。我们无法也没必要控制这个缓冲区的大小，因为它会立即转送数据（至少在linux上是这样）。[更新：这个pipe buffer 已经变化为 &lt;a href=&quot;http://lwn.net/Articles/118750/&quot;&gt;circular buffers&lt;/a&gt; (16 x 4KiB)并且有一个新的 &lt;a href=&quot;http://lkml.org/lkml/2008/5/30/180&quot;&gt;proposed patch&lt;/a&gt; 使得它的大小是动态的]&lt;/p&gt;
&lt;p&gt;另外两个缓冲是关于流的，为了提高效率，仅仅在第一次使用流的时候申请缓冲区空间。三个标准流(stdin, stdout, stderr)会在几乎所有的unix GNU C程序开始执行自动被创建，新的流也可以被创建用来连接文件、套接字、管道等等。你可以通过控制缓冲策略（无缓冲，行缓冲，满缓冲）来控制数据的读写方法。我使用&lt;a href=&quot;http://www.pixelbeat.org/programming/stdio_buffering/default_buffers.c&quot;&gt;这个程序&lt;/a&gt;来确定标准流的默认缓冲区的特性：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;28&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/* Output info about the default buffering parameters&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * applied by libc to stdin, stdout and stderr.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Note the info is sent to stderr, as redirecting it&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * makes no difference to its buffering parameters.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Note gnulib has fbufmode() to make this portable.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio_ext.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;

FILE* fileno2FILE(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fileno){
    &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt;(fileno) {
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; stdin;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; stdout;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;:  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; stderr;
        &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;: &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; NULL;
    }
}

&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;* fileno2name(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fileno){
    &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt;(fileno) {
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;stdin&quot;&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;stdout&quot;&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;:  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;stderr&quot;&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;: &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; NULL;
    }
}

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (isatty(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)) {
        fprintf(stderr,&lt;span class=&quot;st&quot;&gt;&quot;Hit Ctrl-d to initialise stdin&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        fprintf(stderr,&lt;span class=&quot;st&quot;&gt;&quot;Initialising stdin&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    }
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; data[&lt;span class=&quot;dv&quot;&gt;4096&lt;/span&gt;];
    fread(data,&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(data),&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,stdin);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (isatty(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)) {
        fprintf(stdout,&lt;span class=&quot;st&quot;&gt;&quot;Initialising stdout&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        fprintf(stdout,&lt;span class=&quot;st&quot;&gt;&quot;Initialising stdout&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
        fprintf(stderr,&lt;span class=&quot;st&quot;&gt;&quot;Initialising stdout&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    }
    fprintf(stderr,&lt;span class=&quot;st&quot;&gt;&quot;Initialising stderr&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//redundant&lt;/span&gt;

    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (i=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;; i++) {
        fprintf(stderr,&lt;span class=&quot;st&quot;&gt;&quot;%6s: tty=%d, lb=%d, size=%d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,
                fileno2name(i),
                isatty(i),
                __flbf(fileno2FILE(i))?&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,
                __fbufsize(fileno2FILE(i)));
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; EXIT_SUCCESS;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;默认缓冲策略：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;stdin总是缓冲的&lt;/li&gt;
&lt;li&gt;stderr总是无缓冲的&lt;/li&gt;
&lt;li&gt;如果stdout是终端的话缓冲是行缓冲的，否则是满缓冲的。（补充一下，GNU里面定义的可交互设备，显然终端是可交互设备）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;默认缓冲大小：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓冲大小只会直接影响缓冲策略&lt;/li&gt;
&lt;li&gt;内核的pipe buffer 已经变化为 &lt;a href=&quot;http://lwn.net/Articles/118750/&quot;&gt;circular buffers&lt;/a&gt; (16 x 4KiB)并且有一个新的 &lt;a href=&quot;http://lkml.org/lkml/2008/5/30/180&quot;&gt;proposed patch&lt;/a&gt; 使得它的大小是动态的&lt;/li&gt;
&lt;li&gt;如果stdin/stdout 连接的是交互设备那么默认大小是1024，否则是4096&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;stdio-输出缓冲的问题&quot;&gt;stdio 输出缓冲的问题&lt;/h2&gt;
&lt;p&gt;现在来考虑一个问题：数据源的信息是间隔发送的，并且接受者希望立即收到新产生的数据。&lt;/p&gt;
&lt;p&gt;例如，一个人想要过滤 &lt;code&gt;tcpdump -l&lt;/code&gt; 或者 &lt;code&gt;tail -f&lt;/code&gt; 的输出等等（注意有一些过滤器比如sort要求一次缓存所有数据到内部，所以这里不能使用）。&lt;/p&gt;
&lt;p&gt;考虑下面这个操作，从动态网络日志终端数据中过滤出不一样的IP地址：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ tail -f access.log | cut -d' ' -f1 | uniq&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题在于，如果按照上面这个命令，我们将不能实时的看到增加的主机IP，示例图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201710/1072319-20171014233217277-79733456.png&quot; alt=&quot;buffering problem in unix shell pipeline&quot;/&gt;&lt;/p&gt;
&lt;p&gt;高亮的缓冲区导致了问题的发生。由于该缓存区连接了一个管道缓冲区，他会等到数据达到4096字节后再作为一个块传送给uniq。注意到tail的标准输出也有这个问题，但是&lt;code&gt;tail -f&lt;/code&gt;调用会自动清除缓冲区当有新的数据输入时，所以这里不会产生影响( &lt;code&gt;tcpdump -l&lt;/code&gt;, &lt;code&gt;grep --line-buffered&lt;/code&gt; &lt;code&gt;sed --unbuffered&lt;/code&gt; 也是这样)。另外，由于uniq标准输出连接的是一个可交互设备，所以当有新的一行数据到达时也会自动清除缓冲区，不会产生影响。&lt;/p&gt;
&lt;h2 id=&quot;stdio-输入缓冲问题&quot;&gt;stdio 输入缓冲问题&lt;/h2&gt;
&lt;p&gt;Buffering on stdin like stdout is used (to coalesce reads) for efficiency.正如向stdout一样，stdin也使用缓冲区以增加效率。&lt;/p&gt;
&lt;p&gt;One would have more control with byte by byte reads, but that would not be practical.如果一个一个字节的读入显然会有更多控制的空间，但是这样是不实际的。&lt;/p&gt;
&lt;p&gt;Consider the following issue:考虑以下命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ printf &quot;one\ntwo\nthree\n&quot; | ( sed 1q ; sed 1q ; sed 1q )
one&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（译者注：这里的q是sed流编辑器的退出命令，1q表示当输出到达第一行结束时退出。参考&lt;a href=&quot;http://www.grymoire.com/Unix/Sed.html#uh-34&quot;&gt;The q or quit command&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;正如你所见到的，第一个sed进程读取了所有数据，导致后面的sed没办法读入数据。注意仅仅将stdin缓冲区设置为行缓冲是没有用的，因为只有当输出缓冲区被清除的时候才会产生控制效果（译者注，如果没有输出的话，第一个sed还是会”一行一行的把输入数据读完）。以上的sed标准输入都是行缓冲&lt;a href=&quot;http://www.pixelbeat.org/programming/readline/&quot;&gt;Reading lines from stdin&lt;/a&gt;.通常你只能控制一个进程能否从stdin读入数据，或者读入特定规模的数据然后禁止读入。以下是这样的一个例子：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ printf &quot;one\ntwo\nthree\n&quot; | ( ssh localhost printf 'zero\\n' ; cat )
zero&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（译者注：后面的cat命令用于从stdin中读取数据输出到屏幕，防止printf的输出存储在缓冲区中。）&lt;/p&gt;
&lt;p&gt;这个远程printf命令并不会从stdin读取数据（译者注：'zero\n'是参数），但是ssh client并不知道这个，所以他会读取前面printf传入的数据即stdin中读取数据。为了告诉ssh远程命令不需要读入数据，可以加上&lt;code&gt;-n&lt;/code&gt;这个参数：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ printf &quot;one\ntwo\nthree\n&quot; | ( ssh -n localhost printf 'zero\n' ; cat )
zero
one
two
three&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常见的经历是你想要吧ssh放在后台当你知道远程命令不会读取数据的时候（利于常见的图像化程序），设置ssh client阻止读入数据可以防止远程应用程序停滞。你可以通过&lt;code&gt;-f&lt;/code&gt;参数告诉ssh忽略stdin并且fork到后台。例如：&lt;code&gt;ssh -fY localhost xterm&lt;/code&gt;(译者注：&lt;code&gt;-Y Enables trusted X11 forwarding&lt;/code&gt;)。&lt;/p&gt;
&lt;h2 id=&quot;stdio-缓冲控制&quot;&gt;stdio 缓冲控制&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;省略...&lt;/em&gt;（关键词：stdbuf, BUF_X_=Y where X = 0 (stdin), 1 (stdout), 2 (stderr) ）&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 15:31:00 +0000</pubDate>
<dc:creator>李秋豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiuhao/p/7669007.html</dc:identifier>
</item>
</channel>
</rss>